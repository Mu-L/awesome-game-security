Project Path: arc_bromoket_x64dbg_mcp_ybciksq6

Source Tree:

```txt
arc_bromoket_x64dbg_mcp_ybciksq6
├── LICENSE
├── PROMOTION.md
├── README.md
├── build
│   ├── CMakeCache.txt
│   └── CMakeFiles
│       ├── 4.2.3
│       │   ├── CMakeCXXCompiler.cmake
│       │   ├── CMakeDetermineCompilerABI_CXX.bin
│       │   ├── CMakeRCCompiler.cmake
│       │   ├── CMakeSystem.cmake
│       │   └── CompilerIdCXX
│       │       ├── CMakeCXXCompilerId.cpp
│       │       └── CMakeCXXCompilerId.exe
│       ├── CMakeConfigureLog.yaml
│       ├── ShowIncludes
│       │   ├── foo.h
│       │   └── main.c
│       ├── cmake.check_cache
│       └── feature_tests.bin
├── install.ps1
├── plugin
│   ├── CMakeLists.txt
│   ├── CMakePresets.json
│   ├── plugin.def
│   ├── sdk
│   │   ├── XEDParse
│   │   │   └── XEDParse.h
│   │   ├── _dbgfunctions.h
│   │   ├── _plugin_types.h
│   │   ├── _plugins.h
│   │   ├── _scriptapi.h
│   │   ├── _scriptapi_argument.h
│   │   ├── _scriptapi_assembler.h
│   │   ├── _scriptapi_bookmark.h
│   │   ├── _scriptapi_comment.h
│   │   ├── _scriptapi_debug.h
│   │   ├── _scriptapi_flag.h
│   │   ├── _scriptapi_function.h
│   │   ├── _scriptapi_gui.h
│   │   ├── _scriptapi_label.h
│   │   ├── _scriptapi_memory.h
│   │   ├── _scriptapi_misc.h
│   │   ├── _scriptapi_module.h
│   │   ├── _scriptapi_pattern.h
│   │   ├── _scriptapi_register.h
│   │   ├── _scriptapi_stack.h
│   │   ├── _scriptapi_symbol.h
│   │   ├── bridgegraph.h
│   │   ├── bridgelist.h
│   │   ├── bridgemain.h
│   │   ├── jansson
│   │   │   ├── jansson.h
│   │   │   ├── jansson_config.h
│   │   │   └── jansson_x64dbg.h
│   │   └── lz4
│   │       ├── lz4.h
│   │       ├── lz4file.h
│   │       └── lz4hc.h
│   ├── src
│   │   ├── bridge
│   │   │   ├── c_bridge_executor.cpp
│   │   │   └── c_bridge_executor.h
│   │   ├── handlers
│   │   │   ├── analysis_handler.cpp
│   │   │   ├── annotation_handler.cpp
│   │   │   ├── antidebug_handler.cpp
│   │   │   ├── breakpoint_handler.cpp
│   │   │   ├── command_handler.cpp
│   │   │   ├── controlflow_handler.cpp
│   │   │   ├── debug_handler.cpp
│   │   │   ├── disasm_handler.cpp
│   │   │   ├── dumping_handler.cpp
│   │   │   ├── exceptions_handler.cpp
│   │   │   ├── handles_handler.cpp
│   │   │   ├── memmap_handler.cpp
│   │   │   ├── memory_handler.cpp
│   │   │   ├── module_handler.cpp
│   │   │   ├── patch_handler.cpp
│   │   │   ├── process_handler.cpp
│   │   │   ├── register_handler.cpp
│   │   │   ├── search_handler.cpp
│   │   │   ├── stack_handler.cpp
│   │   │   ├── symbol_handler.cpp
│   │   │   ├── thread_handler.cpp
│   │   │   └── tracing_handler.cpp
│   │   ├── http
│   │   │   ├── c_http_router.cpp
│   │   │   ├── c_http_router.h
│   │   │   ├── c_http_server.cpp
│   │   │   ├── c_http_server.h
│   │   │   ├── s_http_request.h
│   │   │   └── s_http_response.h
│   │   ├── plugin_main.cpp
│   │   ├── plugin_main.h
│   │   ├── resources
│   │   │   └── plugin_icon.h
│   │   ├── ui
│   │   │   ├── about_dialog.cpp
│   │   │   ├── about_dialog.h
│   │   │   ├── settings_dialog.cpp
│   │   │   └── settings_dialog.h
│   │   └── util
│   │       ├── format_utils.cpp
│   │       └── format_utils.h
│   └── vcpkg.json
└── server
    ├── README.md
    ├── package-lock.json
    ├── package.json
    ├── server.json
    ├── src
    │   ├── config.ts
    │   ├── http_client.ts
    │   ├── index.ts
    │   └── tools
    │       ├── analysis.ts
    │       ├── antidebug.ts
    │       ├── breakpoints.ts
    │       ├── command.ts
    │       ├── controlflow.ts
    │       ├── debug.ts
    │       ├── disassembly.ts
    │       ├── dumping.ts
    │       ├── exceptions.ts
    │       ├── handles.ts
    │       ├── index.ts
    │       ├── memory.ts
    │       ├── modules.ts
    │       ├── patches.ts
    │       ├── process.ts
    │       ├── registers.ts
    │       ├── search.ts
    │       ├── stack.ts
    │       ├── symbols.ts
    │       ├── threads.ts
    │       └── tracing.ts
    └── tsconfig.json

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 bromo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PROMOTION.md`:

```md
# Promotion Checklist - x64dbg MCP Server

Everything below is ready to copy-paste. Work through the list.

---

## 1. MCP Official Registry (HIGH PRIORITY)

**URL**: https://registry.modelcontextprotocol.io

They have a CLI publisher tool. Follow the guide at the registry site under "Adding Servers to the MCP Registry" for server maintainers. Your package name is `x64dbg-mcp-server` on npm.

---

## 2. awesome-mcp-servers (HIGH PRIORITY)

### Option A: mcpservers.org (punkpeye's list)
**Submit at**: https://mcpservers.org/submit

### Option B: wong2/awesome-mcp-servers
**URL**: https://github.com/wong2/awesome-mcp-servers
Open a PR adding this line under a "Debugging / Reverse Engineering" category (or wherever it fits):

```markdown
- **[x64dbg MCP Server](https://github.com/bromoket/x64dbg_mcp)** - 152-tool MCP server for the x64dbg debugger. Full control over debugging, disassembly, breakpoints, tracing, memory analysis, and anti-debug bypass. C++ plugin + TypeScript server. `npx x64dbg-mcp-server`
```

### Option C: appcypher/awesome-mcp-servers
**URL**: https://github.com/appcypher/awesome-mcp-servers
Same - open a PR with the line above.

---

## 3. x64dbg Wiki Plugin List

**URL**: https://github.com/x64dbg/x64dbg/wiki/Plugins

The wiki is editable. Add an entry:

```markdown
### [x64dbg MCP Server](https://github.com/bromoket/x64dbg_mcp)
AI-powered debugging through the Model Context Protocol. 152 tools give LLMs (Claude, Cursor, etc.) full control over x64dbg - breakpoints, memory, disassembly, tracing, anti-debug, and more. C++ plugin + TypeScript MCP server on npm.
```

---

## 4. awesome-ida-x64-olly-plugin

**URL**: https://github.com/fr0gger/awesome-ida-x64-olly-plugin
Open a PR. Add under x64dbg section:

```markdown
- [x64dbg MCP Server](https://github.com/bromoket/x64dbg_mcp) - MCP server giving AI assistants (Claude, Cursor, Windsurf) full control over x64dbg. 152 tools for debugging, disassembly, tracing, memory analysis, anti-debug bypass.
```

---

## 5. Reddit Posts

### r/ReverseEngineering

**Title**: I built an MCP server that lets AI control x64dbg - 152 tools for AI-powered reverse engineering

**Body**:
```
I've been working on an MCP (Model Context Protocol) server for x64dbg that gives AI assistants like Claude, Cursor, and Windsurf full control over the debugger.

**What it does**: 152 tools across 21 categories - breakpoints, memory read/write, disassembly, tracing, anti-debug bypass, control flow graphs, IAT dumping, pattern scanning, and more. You talk to the AI in natural language and it operates x64dbg for you.

**How it works**: A C++ plugin runs inside x64dbg as a REST API on localhost. A TypeScript MCP server bridges that to any MCP-compatible AI client over stdio. All local, nothing leaves your machine.

**Example prompts**:
- "Set a breakpoint on CreateFileW, run, then show me the call stack"
- "Search for the byte pattern 48 8B ?? 48 85 C0 and disassemble whatever you find"
- "Hide the debugger from anti-debug checks and trace through the VM dispatcher"
- "Configure 8 logging breakpoints in one call that log function arguments"

**Install**: Copy the plugin DLL to x64dbg, add one JSON block to your AI client config pointing at `npx x64dbg-mcp-server`.

GitHub: https://github.com/bromoket/x64dbg_mcp
npm: https://www.npmjs.com/package/x64dbg-mcp-server

Open source, MIT licensed. Feedback welcome.
```

### r/ClaudeAI

**Title**: Built a 152-tool MCP server for x64dbg - AI-powered binary debugging and reverse engineering

**Body**:
```
Made an MCP server that connects Claude (Code or Desktop) to the x64dbg debugger. 152 fully-typed tools let Claude set breakpoints, read memory, disassemble functions, trace execution, bypass anti-debug, dump modules, and more.

Setup is just:
1. Copy plugin DLL to x64dbg
2. Add to your Claude config:
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}

Then you can say things like "disassemble the current function and explain what it does" or "set a conditional breakpoint that only triggers when EAX == 0" and Claude does it.

Works with Claude Code, Claude Desktop, Cursor, Windsurf, Cline.

GitHub: https://github.com/bromoket/x64dbg_mcp
npm: https://www.npmjs.com/package/x64dbg-mcp-server
```

### r/Malware

**Title**: MCP server for x64dbg - let AI assist your malware analysis (152 debugging tools)

**Body**:
```
Built an MCP server that bridges AI assistants to x64dbg. Useful for malware analysis workflows where you want AI to help navigate through packed/obfuscated code.

152 tools including:
- Anti-debug: hide debugger, read/modify PEB, DEP status
- Tracing: conditional trace with logging, hit counting
- Memory: AOB pattern scan (returns all matches), read/write with verify
- Breakpoints: batch configure (set 8 logging BPs in one call), fast resume
- Analysis: xrefs, CFG, basic blocks, imports/exports, PE header parsing
- Dumping: module dump, IAT fix via Scylla, export patched files

Everything runs locally on 127.0.0.1. The C++ plugin sits inside x64dbg, the MCP server bridges it to Claude/Cursor/etc over stdio.

GitHub: https://github.com/bromoket/x64dbg_mcp
npm: https://www.npmjs.com/package/x64dbg-mcp-server

MIT licensed.
```

### r/cursor

**Title**: x64dbg MCP server - 152 debugging/RE tools for Cursor

**Body**:
```
If anyone here does reverse engineering or binary debugging, I built an MCP server that connects Cursor to the x64dbg debugger.

152 tools: breakpoints, memory, disassembly, tracing, anti-debug, pattern scanning, control flow graphs, etc.

Add to .cursor/mcp.json:
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}

You also need the x64dbg plugin DLL from the releases page.

GitHub: https://github.com/bromoket/x64dbg_mcp
```

---

## 6. Hacker News - Show HN

**Title**: Show HN: 152-tool MCP server that lets AI control the x64dbg debugger

**URL**: https://github.com/bromoket/x64dbg_mcp

**Comment** (post as first comment on your own submission):
```
I built this because I wanted Claude to help me reverse engineer binaries without constantly copy-pasting between the AI and x64dbg.

It's two components:
- A C++ plugin that runs inside x64dbg as a REST API on localhost
- A TypeScript MCP server on npm that bridges to any MCP client (Claude, Cursor, Windsurf, etc.)

152 tools covering: debug control, registers, memory, disassembly, breakpoints (including batch configure), symbols, stack, threads, modules, search (AOB pattern scan), command execution, analysis (xrefs, CFG), tracing, dumping (with Scylla IAT fix), anti-debug bypass, exceptions, process inspection, handles, control flow, and patching.

Everything is local - the plugin binds to 127.0.0.1 only, the MCP server uses stdio. No data leaves your machine.

Real use case: I used it to analyze a game's anti-cheat system. Claude traced through VMProtect'd code, identified FindWindowA-based scanner threads, decoded XOR-encrypted class names, and mapped out the detection logic - all through natural language commands.

Install: copy plugin DLL + add one JSON config block pointing at `npx x64dbg-mcp-server`.
```

---

## 7. Twitter/X

**Post 1 - Launch announcement**:
```
I built an MCP server that gives AI full control over the x64dbg debugger.

152 tools: breakpoints, memory, disassembly, tracing, anti-debug bypass, CFG, pattern scanning, IAT dumping...

Works with Claude, Cursor, Windsurf, Cline.

One config line: npx x64dbg-mcp-server

github.com/bromoket/x64dbg_mcp

#ReverseEngineering #MCP #AI #x64dbg
```

**Post 2 - Use case thread**:
```
How I reversed an anti-cheat using AI + x64dbg:

1/ Claude set logging breakpoints on FindWindowA with fast resume
2/ Traced through VMProtect'd code at 46 hits/sec
3/ Identified XOR-encrypted window class names (0xF4AACCBC key)
4/ Mapped 5 scanner call sites + 2 scan threads (4s and 300ms intervals)

All through natural language. No manual scripting.

This is what 152 MCP tools looks like in practice.
github.com/bromoket/x64dbg_mcp
```

**Tag**: @anthropic @x64dbg

---

## 8. YouTube / Video Content

Record a 2-3 minute demo showing:
1. Open a packed binary in x64dbg
2. Claude: "Hide the debugger and set a breakpoint on VirtualAlloc"
3. Claude: "Run and show me the call stack when it hits"
4. Claude: "Search for the string 'license' in the main module"
5. Claude: "Disassemble that function and explain it"

Title: "AI-Powered Reverse Engineering with Claude + x64dbg (152 MCP Tools)"

Upload to YouTube, embed in README.

---

## Done Already (automated)

- [x] GitHub topics: mcp, mcp-server, x64dbg, debugger, reverse-engineering, model-context-protocol, claude, ai-debugging, malware-analysis, binary-analysis, plugin, typescript, cpp, x64dbg-plugin
- [x] GitHub repo description updated
- [x] npm published with keywords
- [x] READMEs restructured with multi-client setup guides

## Priority Order

1. MCP Official Registry (registry.modelcontextprotocol.io)
2. awesome-mcp-servers (mcpservers.org/submit)
3. Hacker News Show HN
4. Reddit r/ReverseEngineering
5. Reddit r/ClaudeAI
6. Twitter/X launch post
7. x64dbg wiki
8. awesome-ida-x64-olly-plugin PR
9. Reddit r/Malware, r/cursor
10. YouTube demo video

```

`README.md`:

```md
# x64dbg MCP Server

[![npm version](https://img.shields.io/npm/v/x64dbg-mcp-server)](https://www.npmjs.com/package/x64dbg-mcp-server)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

An [MCP server](https://modelcontextprotocol.io/) that gives AI assistants full control over the [x64dbg](https://x64dbg.com/) debugger. **23 mega-tools** covering 151 REST endpoints via Zod discriminated unions - stepping, breakpoints, memory, disassembly, tracing, anti-debug bypasses, control flow analysis, PE dumping, and more.

Works with Claude Code, Claude Desktop, Cursor, Windsurf, Cline, and any MCP-compatible client.

## Table of Contents

- [Quick Start](#quick-start)
- [How It Works](#how-it-works)
- [Tool Reference](#tool-reference-23-mega-tools)
- [Usage Examples](#usage-examples)
- [Configuration](#configuration)
- [Architecture](#architecture)
- [Building from Source](#building-from-source)
- [Troubleshooting](#troubleshooting)
- [Security](#security)

## Quick Start

### Prerequisites

1. **x64dbg** - [Download latest snapshot](https://github.com/x64dbg/x64dbg/releases)
2. **Node.js** >= 18 - [Download](https://nodejs.org/)
3. **MCP plugin** - [Download from releases](https://github.com/bromoket/x64dbg_mcp/releases) (`x64dbg_mcp.dp64` and/or `x64dbg_mcp.dp32`)

### Step 1: Install the Plugin

Copy the plugin DLLs into your x64dbg plugins directories:

```
x64dbg/
  x64/plugins/x64dbg_mcp.dp64    <-- for 64-bit debugging
  x32/plugins/x64dbg_mcp.dp32    <-- for 32-bit debugging
```

Start x64dbg. You should see in the log:

```
[MCP] x64dbg MCP Server started on 127.0.0.1:27042
```

### Step 2: Add to Your AI Client

Pick your client and copy the config:

<details open>
<summary><b>Claude Code</b></summary>

Add to `.claude/settings.json` (project-level) or `~/.claude/settings.json` (global):

```json
{
  "mcpServers": {
    "x64dbg": {
      "type": "stdio",
      "command": "cmd",
      "args": ["/c", "npx", "-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Claude Desktop</b></summary>

Add to `claude_desktop_config.json`:

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Cursor</b></summary>

Add to `.cursor/mcp.json` (project-level) or `~/.cursor/mcp.json` (global):

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Windsurf</b></summary>

Add to `~/.codeium/windsurf/mcp_config.json`:

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Cline (VSCode extension)</b></summary>

Open Cline settings > MCP Servers > Configure, then add to `cline_mcp_settings.json`:

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Any other MCP client</b></summary>

The server uses **stdio transport**. Spawn it as a child process:

```bash
npx -y x64dbg-mcp-server
```

Communicate over stdin/stdout using the [MCP protocol](https://modelcontextprotocol.io/).

</details>

### Step 3: Start Debugging

Open any executable in x64dbg, then talk to your AI assistant:

```
"Set a breakpoint on CreateFileW and run the program"
"Disassemble the current function and explain what it does"
"Search for the byte pattern 48 8B ?? 48 85 C0 in the main module"
"Hide the debugger and bypass the anti-debug checks"
"List all threads and show me which one is the anti-cheat scanner"
"Trace into the VM dispatcher and log all instructions to a file"
```

## How It Works

The system has two components:

```
                         stdio                        HTTP (localhost)
 MCP Client  <───────────────────>  TypeScript MCP  <──────────────────>  C++ Plugin
 (Claude,                           Server            127.0.0.1:27042     (inside x64dbg)
  Cursor,                           23 mega-tools                         151 REST endpoints
  etc.)                             Zod validation                        Bridge/Plugin SDK
```

- **C++ Plugin** (`x64dbg_mcp.dp64` / `.dp32`) runs inside x64dbg as a lightweight REST API server on `127.0.0.1:27042`. It wraps the x64dbg Bridge/Plugin SDK with 151 JSON endpoints across 22 handler files.

- **TypeScript MCP Server** (`x64dbg-mcp-server` on npm) implements the MCP protocol over stdio. The 23 mega-tools use Zod discriminated unions to validate parameters, then route requests to the correct REST endpoint on the plugin via localhost HTTP.

The MCP server waits up to 2 minutes for the plugin to become available, performs health checks every 15 seconds, and automatically reconnects if x64dbg restarts. Requests retry up to 3 times with exponential backoff.

**Why stdio?** No SSE reconnection issues, no port conflicts, no dropped connections. The MCP client spawns the server as a child process - it just works.

## Tool Reference (23 Mega-Tools)

Each tool accepts an `action` parameter that selects the specific operation. Parameters are validated with Zod schemas at runtime.

### Debugger Control

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_debug` | `run`, `pause`, `force_pause`, `step_into`, `step_over`, `step_out`, `stop_debug`, `restart_debug`, `run_to_address`, `state` | Control execution flow and query debugger state |
| `x64dbg_command` | `execute`, `script`, `evaluate`, `format`, `set_init_script`, `get_init_script`, `get_hash`, `get_events` | Execute raw x64dbg commands, batch scripts, and expression evaluation |

### CPU & Memory

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_registers` | `get_all`, `get_specific`, `get_flags`, `get_avx512`, `set` | Read/write CPU registers including GPR, flags, and AVX-512 |
| `x64dbg_memory` | `read`, `write`, `info`, `is_valid`, `is_code`, `allocate`, `free`, `protect`, `map`, `update_map` | Full memory operations: read, write, allocate, protect, and memory map |
| `x64dbg_stack` | `get_call_stack`, `read`, `pointers`, `seh_chain`, `return_address`, `comment` | Call stack unwinding, raw stack reads, SEH chain, return address |

### Code Analysis

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_disassembly` | `at_address`, `function`, `info`, `assemble` | Disassemble instructions, whole functions, or assemble new code |
| `x64dbg_analysis` | `function`, `xrefs_to`, `xrefs_from`, `basic_blocks`, `source`, `mnemonic_brief` | Cross-references, function boundaries, basic blocks, source mapping |
| `x64dbg_control_flow` | `cfg`, `branch_dest`, `is_jump_taken`, `loops`, `func_type`, `add_function`, `delete_function` | Control flow graph, branch analysis, loop detection, function management |
| `x64dbg_database` | `constants`, `error_codes`, `structs`, `strings` | Query x64dbg's analysis database for constants, errors, structs, strings |
| `x64dbg_address_convert` | `va_to_file`, `file_to_va` | Convert between virtual addresses and file offsets |
| `x64dbg_watchdog` | *(id parameter)* | Check if a watch expression watchdog has been triggered |

### Breakpoints & Tracing

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_breakpoints` | `set_software`, `set_hardware`, `set_memory`, `delete`, `enable`, `disable`, `toggle`, `set_condition`, `set_log`, `reset_hit_count`, `get`, `list`, `configure`, `configure_batch` | Full breakpoint management: software, hardware, memory, conditional, logging, batch |
| `x64dbg_tracing` | `into`, `over`, `run`, `stop`, `animate`, `conditional_run`, `log_setup`, `hitcount`, `type`, `set_type` | Execution tracing, trace logging, hit counters, conditional tracing |
| `x64dbg_exceptions` | `set`, `delete`, `list`, `list_codes`, `skip` | Exception breakpoints, known exception codes, skip/pass exceptions |

### Symbols & Annotations

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_symbols` | `resolve`, `address`, `search`, `list_module`, `get_label`, `set_label`, `get_comment`, `set_comment`, `bookmark` | Symbol resolution, labels, comments, bookmarks |
| `x64dbg_search` | `pattern`, `string`, `string_at`, `symbol_auto_complete`, `encode_type` | AOB/byte pattern scan, string search, symbol autocomplete |
| `x64dbg_modules` | `list`, `get_info`, `get_base`, `get_section`, `get_party` | Loaded modules, base addresses, sections, user/system classification |

### Process & System

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_process` | `basic`, `detailed`, `cmdline`, `elevated`, `dbversion`, `set_cmdline` | Process info, PID, PEB, elevation status, debugger version |
| `x64dbg_threads` | `list`, `current`, `count`, `info`, `teb`, `name`, `switch`, `suspend`, `resume` | Thread enumeration, TEB access, thread control |
| `x64dbg_handles` | `list_handles`, `list_tcp`, `list_windows`, `list_heaps`, `get_name`, `close` | Handles, TCP connections, windows, heaps |
| `x64dbg_antidebug` | `peb`, `teb`, `dep`, `hide_debugger` | PEB/TEB inspection, DEP status, hide debugger from anti-debug |

### Patching & Dumping

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_patches` | `list`, `apply`, `restore`, `export` | Apply byte patches, restore originals, export patched module |
| `x64dbg_dumping` | `pe_header`, `sections`, `imports`, `exports`, `entry_point`, `relocations`, `dump_module`, `fix_iat`, `export_patch_file` | PE analysis, module dumping, IAT reconstruction, patch file export |

## Usage Examples

**Basic debugging:**
```
"Set a breakpoint on kernel32.CreateFileW and run"
"Step over 10 instructions and show me the registers"
"What's the current call stack?"
```

**Memory analysis:**
```
"Read 128 bytes at the address pointed to by RDI"
"Search for the byte pattern FF 15 ?? ?? ?? ?? in the .text section"
"Write 90 90 90 (NOPs) at 0x401000 and verify the write"
"Allocate a page of memory and write my shellcode there"
```

**Reverse engineering:**
```
"Disassemble the current function and explain the algorithm"
"Get the control flow graph and identify the switch cases"
"Show me cross-references to this function - who calls it?"
"List all imports from kernel32 and advapi32"
"What loops are in this function? Show me the loop boundaries"
```

**Anti-debug bypass:**
```
"Hide the debugger from anti-debug checks"
"Show me the PEB fields - is BeingDebugged set?"
"Set an exception breakpoint on STATUS_ACCESS_VIOLATION"
"Check DEP status for this process"
```

**Tracing and logging:**
```
"Configure a logging breakpoint on GetProcAddress that logs the function name"
"Set up 8 breakpoints in one call using configure_batch"
"Trace into this function and log every instruction to trace.log"
"Run to user code (skip system DLLs)"
```

**Process inspection:**
```
"List all threads and tell me which one is the main thread"
"Show me all open file handles in this process"
"List TCP connections - is it phoning home?"
"Dump the main module to disk and fix the import table"
```

## Configuration

Environment variables for the MCP server:

| Variable | Default | Description |
|----------|---------|-------------|
| `X64DBG_MCP_HOST` | `127.0.0.1` | Plugin REST API host |
| `X64DBG_MCP_PORT` | `27042` | Plugin REST API port |
| `X64DBG_MCP_TIMEOUT` | `30000` | Request timeout in milliseconds |
| `X64DBG_MCP_RETRIES` | `3` | Retry count on transient failures |

Set these in your MCP client config if needed:

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"],
      "env": {
        "X64DBG_MCP_PORT": "27043"
      }
    }
  }
}
```

### Plugin Commands

Control the REST API from the x64dbg command bar:

```
mcpserver start     Start the HTTP server
mcpserver stop      Stop the HTTP server
mcpserver status    Show server status and port
```

The plugin also provides GUI dialogs accessible from `Plugins > x64dbg MCP Server`:

- **Settings...** — configure host, port, and auto-start (persisted via BridgeSetting)
- **About...** — version, live server status (green/red), GitHub link, Discord contact

## Architecture

### System Overview

```
┌─────────────────────────────────────────────────────────────────┐
│  MCP Client (Claude Code, Cursor, etc.)                         │
│  Spawns server as child process, communicates via stdin/stdout   │
└──────────────────────────┬──────────────────────────────────────┘
                           │ stdio (MCP JSON-RPC)
┌──────────────────────────▼──────────────────────────────────────┐
│  TypeScript MCP Server (x64dbg-mcp-server)                      │
│                                                                 │
│  23 tools registered via @modelcontextprotocol/sdk              │
│  Zod discriminated unions validate action + parameters          │
│  HttpClient: auto-reconnect, health checks, retry logic         │
└──────────────────────────┬──────────────────────────────────────┘
                           │ HTTP GET/POST (127.0.0.1:27042)
┌──────────────────────────▼──────────────────────────────────────┐
│  C++ Plugin DLL (x64dbg_mcp.dp64 / .dp32)                      │
│                                                                 │
│  Winsock2 HTTP server, JSON via nlohmann/json                   │
│  22 handler files, 151 REST endpoints                           │
│  c_bridge_executor: thread-safe calls to x64dbg SDK             │
└──────────────────────────┬──────────────────────────────────────┘
                           │ x64dbg Bridge/Plugin SDK
┌──────────────────────────▼──────────────────────────────────────┐
│  x64dbg Debugger Engine                                         │
│  DbgFunctions(), Script API, Bridge API                         │
└─────────────────────────────────────────────────────────────────┘
```

### Project Structure

```
x64dbg_mcp/
├── plugin/                         # C++ x64dbg plugin (REST API server)
│   ├── CMakeLists.txt              # Build config (C++23, clang-cl)
│   ├── CMakePresets.json           # x64-release, x32-release, x64-debug presets
│   ├── plugin.def                  # DLL export definitions
│   ├── sdk/                        # x64dbg Plugin SDK headers + libs
│   │   ├── _plugins.h              # Plugin API
│   │   ├── _dbgfunctions.h         # DbgFunctions() interface
│   │   ├── bridgemain.h            # Bridge API
│   │   ├── jansson/                # JSON library (SDK dependency)
│   │   └── *.lib                   # x64bridge, x32bridge, x64dbg, x32dbg
│   └── src/
│       ├── plugin_main.cpp/.h      # Plugin entry, /api/health, /api/process/info
│       ├── bridge/
│       │   └── c_bridge_executor.* # Thread-safe wrapper for x64dbg API calls
│       ├── handlers/               # 22 REST endpoint handler files
│       │   ├── debug_handler.cpp       # /api/debug/* (11 endpoints)
│       │   ├── register_handler.cpp    # /api/registers/* (5 endpoints)
│       │   ├── memory_handler.cpp      # /api/memory/* (9 endpoints)
│       │   ├── breakpoint_handler.cpp  # /api/breakpoints/* (15 endpoints)
│       │   ├── disasm_handler.cpp      # /api/disasm/* (4 endpoints)
│       │   ├── module_handler.cpp      # /api/modules/* (5 endpoints)
│       │   ├── thread_handler.cpp      # /api/threads/* (9 endpoints)
│       │   ├── stack_handler.cpp       # /api/stack/* (7 endpoints)
│       │   ├── symbol_handler.cpp      # /api/symbols/* (4 endpoints)
│       │   ├── annotation_handler.cpp  # /api/labels/*, /api/comments/*, /api/bookmarks/* (5 endpoints)
│       │   ├── search_handler.cpp      # /api/search/* (5 endpoints)
│       │   ├── command_handler.cpp     # /api/command/* (8 endpoints)
│       │   ├── analysis_handler.cpp    # /api/analysis/* (13 endpoints)
│       │   ├── tracing_handler.cpp     # /api/trace/* (10 endpoints)
│       │   ├── dumping_handler.cpp     # /api/dump/*, /api/patches/export_file (10 endpoints)
│       │   ├── patch_handler.cpp       # /api/patches/* (4 endpoints)
│       │   ├── memmap_handler.cpp      # /api/memmap/* (2 endpoints)
│       │   ├── antidebug_handler.cpp   # /api/antidebug/* (4 endpoints)
│       │   ├── exceptions_handler.cpp  # /api/exceptions/* (5 endpoints)
│       │   ├── process_handler.cpp     # /api/process/* (5 endpoints)
│       │   ├── handles_handler.cpp     # /api/handles/* (6 endpoints)
│       │   └── controlflow_handler.cpp # /api/cfg/* (7 endpoints)
│       ├── http/
│       │   ├── c_http_server.*     # Winsock2 HTTP server (localhost only)
│       │   ├── c_http_router.*     # Method + path routing
│       │   ├── s_http_request.h    # Request struct (method, path, body, query)
│       │   └── s_http_response.h   # Response helpers (ok, bad_request, conflict, etc.)
│       ├── ui/
│       │   ├── settings_dialog.*   # Settings dialog (host, port, auto-start)
│       │   └── about_dialog.*      # About dialog (version, status, links)
│       └── util/
│           └── format_utils.*      # Address formatting, hex parsing
│
├── server/                         # TypeScript MCP server (npm package)
│   ├── package.json                # x64dbg-mcp-server v2.2.1
│   ├── tsconfig.json               # ES2022, Node16, strict mode
│   ├── server.json                 # MCP registry manifest
│   └── src/
│       ├── index.ts                # McpServer entry, stdio transport, graceful shutdown
│       ├── config.ts               # Environment variable config
│       ├── http_client.ts          # HTTP client with auto-reconnect and health monitoring
│       └── tools/                  # 19 tool files, 23 MCP tools
│           ├── index.ts            # Registers all tools on the McpServer
│           ├── debug.ts            # x64dbg_debug
│           ├── registers.ts        # x64dbg_registers
│           ├── memory.ts           # x64dbg_memory (includes memmap)
│           ├── disassembly.ts      # x64dbg_disassembly
│           ├── breakpoints.ts      # x64dbg_breakpoints
│           ├── symbols.ts          # x64dbg_symbols (includes labels, comments, bookmarks)
│           ├── stack.ts            # x64dbg_stack
│           ├── threads.ts          # x64dbg_threads
│           ├── modules.ts          # x64dbg_modules
│           ├── search.ts           # x64dbg_search
│           ├── command.ts          # x64dbg_command
│           ├── analysis.ts         # x64dbg_analysis, x64dbg_database, x64dbg_address_convert, x64dbg_watchdog
│           ├── tracing.ts          # x64dbg_tracing
│           ├── dumping.ts          # x64dbg_dumping
│           ├── antidebug.ts        # x64dbg_antidebug
│           ├── exceptions.ts       # x64dbg_exceptions
│           ├── process.ts          # x64dbg_process
│           ├── handles.ts          # x64dbg_handles
│           ├── controlflow.ts      # x64dbg_control_flow
│           └── patches.ts          # x64dbg_patches
│
├── install.ps1                     # PowerShell deploy script (local use, gitignored paths)
├── LICENSE                         # MIT
└── README.md
```

### Tech Stack

**MCP Server (TypeScript)**
- **Runtime**: Node.js >= 18
- **Language**: TypeScript (ES2022, strict mode)
- **MCP SDK**: `@modelcontextprotocol/sdk` ^1.12.1
- **Validation**: `zod` ^3.25.1
- **Transport**: stdio (stdin/stdout JSON-RPC)

**Plugin (C++)**
- **Standard**: C++23 (`/std:c++latest`)
- **Compiler**: Clang-cl (ships with Visual Studio 2022)
- **Build System**: CMake 3.20+ with Ninja
- **Dependencies**: nlohmann/json (via vcpkg), x64dbg Plugin SDK, Winsock2
- **Package Manager**: vcpkg

## Building from Source

### C++ Plugin

Requires CMake >= 3.20, Ninja, vcpkg, and Clang-cl (ships with Visual Studio 2022 C++ workload).

```powershell
cd plugin

# Set VCPKG_ROOT to your vcpkg installation
$env:VCPKG_ROOT = "C:\path\to\vcpkg"

# Configure
cmake --preset x64-release    # For 64-bit plugin
cmake --preset x32-release    # For 32-bit plugin

# Build
cmake --build build/x64-release
cmake --build build/x32-release

# Output:
#   build/x64-release/bin/x64dbg_mcp.dp64
#   build/x32-release/bin/x64dbg_mcp.dp32
```

Copy the `.dp64` / `.dp32` files to your x64dbg `plugins/` directory and restart x64dbg.

### TypeScript Server

```bash
cd server
npm install
npm run build
```

To run the server from source instead of npm:

```bash
node server/dist/index.js
```

Or point your MCP client config to the local build:

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "node",
      "args": ["C:/path/to/x64dbg_mcp/server/dist/index.js"]
    }
  }
}
```

## Troubleshooting

### "Connection refused" or server can't reach plugin

1. Make sure x64dbg is running with a target loaded
2. Verify the plugin is in the correct `plugins/` directory
3. Check the x64dbg log for `[MCP] x64dbg MCP Server started on 127.0.0.1:27042`
4. Test manually: `curl http://127.0.0.1:27042/api/health`

### "Waiting for x64dbg plugin..." hangs

The MCP server waits up to 2 minutes for the plugin to come online. Either:
- Start x64dbg **before** launching your MCP client
- Or restart the MCP client after x64dbg is running

### Tools return errors about debugger state

| Error | Meaning | Solution |
|-------|---------|----------|
| "Debugger must be paused" | Inspection tools need paused state | Pause the target or hit a breakpoint first |
| "No active debug session" | No executable loaded | Load a target in x64dbg (`File > Open`) |
| "Debugger must be running" | `pause`/`force_pause` need running target | Run the target first |

### 32-bit vs 64-bit

Use the correct plugin for your target architecture:

| Target | Debugger | Plugin File |
|--------|----------|-------------|
| 64-bit | x64dbg | `x64dbg_mcp.dp64` |
| 32-bit | x32dbg | `x64dbg_mcp.dp32` |

Both use the same MCP server - just `npx -y x64dbg-mcp-server`.

### Plugin not loading

If the plugin doesn't appear in the x64dbg log on startup:

1. Check that the DLL is in the right directory (e.g., `x64/plugins/` for 64-bit)
2. Make sure you're using a recent x64dbg snapshot (2024+)
3. Check if another plugin is conflicting on port 27042
4. Try manually: type `mcpserver start` in the x64dbg command bar

### Request timeouts

For operations on large binaries (full memory scan, module dump), increase the timeout:

```bash
X64DBG_MCP_TIMEOUT=120000 npx -y x64dbg-mcp-server
```

## Security

- The C++ plugin binds to `127.0.0.1` only - no remote access, no network exposure
- The MCP server communicates exclusively via stdio (stdin/stdout)
- All HTTP traffic stays on localhost - no data leaves your machine
- No authentication is needed because the REST API is localhost-only

## Author

**bromo** - [GitHub](https://github.com/bromoket)

Built with [Claude Code](https://claude.ai/claude-code) by Anthropic.

## License

[MIT](LICENSE)

```

`build/CMakeCache.txt`:

```txt
# This is the CMakeCache file.
# For build in directory: e:/GitHub/x64dbg_mcp/build
# It was generated by CMake: C:/Program Files/CMake/bin/cmake.exe
# You can edit this file to change values found and used by cmake.
# If you do not want to change any of the values, simply exit the editor.
# If you do want to change a value, simply edit, save, and exit the editor.
# The syntax for the file is as follows:
# KEY:TYPE=VALUE
# KEY is the name of a variable in the cache.
# TYPE is a hint to GUIs for the type of VALUE, DO NOT EDIT TYPE!.
# VALUE is the current value for the KEY.

########################
# EXTERNAL cache entries
########################

//Path to a program.
CMAKE_AR:FILEPATH=C:/Program Files/LLVM/bin/llvm-lib.exe

//No help, variable specified on the command line.
CMAKE_BUILD_TYPE:STRING=Debug

//No help, variable specified on the command line.
CMAKE_CXX_COMPILER:FILEPATH=C:/Program Files/LLVM/bin/clang-cl.exe

//LLVM archiver
CMAKE_CXX_COMPILER_AR:FILEPATH=C:/Program Files/LLVM/bin/llvm-ar.exe

//`clang-scan-deps` dependency scanner
CMAKE_CXX_COMPILER_CLANG_SCAN_DEPS:FILEPATH=C:/Program Files/LLVM/bin/clang-scan-deps.exe

//Generate index for LLVM archive
CMAKE_CXX_COMPILER_RANLIB:FILEPATH=C:/Program Files/LLVM/bin/llvm-ranlib.exe

//Flags used by the CXX compiler during all build types.
CMAKE_CXX_FLAGS:STRING=/DWIN32 /D_WINDOWS /EHsc

//Flags used by the CXX compiler during DEBUG builds.
CMAKE_CXX_FLAGS_DEBUG:STRING=/Zi /Ob0 /Od /RTC1

//Flags used by the CXX compiler during MINSIZEREL builds.
CMAKE_CXX_FLAGS_MINSIZEREL:STRING=/O1 /Ob1 /DNDEBUG

//Flags used by the CXX compiler during RELEASE builds.
CMAKE_CXX_FLAGS_RELEASE:STRING=/O2 /Ob2 /DNDEBUG

//Flags used by the CXX compiler during RELWITHDEBINFO builds.
CMAKE_CXX_FLAGS_RELWITHDEBINFO:STRING=/Zi /O2 /Ob1 /DNDEBUG

//Libraries linked by default with all C++ applications.
CMAKE_CXX_STANDARD_LIBRARIES:STRING=kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib

//No help, variable specified on the command line.
CMAKE_C_COMPILER:FILEPATH=C:/Program Files/LLVM/bin/clang-cl.exe

//Flags used by the linker during all build types.
CMAKE_EXE_LINKER_FLAGS:STRING=/machine:x64

//Flags used by the linker during DEBUG builds.
CMAKE_EXE_LINKER_FLAGS_DEBUG:STRING=/debug /INCREMENTAL

//Flags used by the linker during MINSIZEREL builds.
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL:STRING=/INCREMENTAL:NO

//Flags used by the linker during RELEASE builds.
CMAKE_EXE_LINKER_FLAGS_RELEASE:STRING=/INCREMENTAL:NO

//Flags used by the linker during RELWITHDEBINFO builds.
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO:STRING=/debug /INCREMENTAL

//Enable/Disable output of build database during the build.
CMAKE_EXPORT_BUILD_DATABASE:BOOL=

//No help, variable specified on the command line.
CMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE

//Value Computed by CMake.
CMAKE_FIND_PACKAGE_REDIRECTS_DIR:STATIC=E:/GitHub/x64dbg_mcp/build/CMakeFiles/pkgRedirects

//Install path prefix, prepended onto install directories.
CMAKE_INSTALL_PREFIX:PATH=C:/Program Files (x86)/x64dbg_mcp

//Path to a program.
CMAKE_LINKER:FILEPATH=C:/Program Files/LLVM/bin/lld-link.exe

//Program used to build from build.ninja files.
CMAKE_MAKE_PROGRAM:FILEPATH=C:/ProgramData/chocolatey/bin/ninja.exe

//Flags used by the linker during the creation of modules during
// all build types.
CMAKE_MODULE_LINKER_FLAGS:STRING=/machine:x64

//Flags used by the linker during the creation of modules during
// DEBUG builds.
CMAKE_MODULE_LINKER_FLAGS_DEBUG:STRING=/debug /INCREMENTAL

//Flags used by the linker during the creation of modules during
// MINSIZEREL builds.
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL:STRING=/INCREMENTAL:NO

//Flags used by the linker during the creation of modules during
// RELEASE builds.
CMAKE_MODULE_LINKER_FLAGS_RELEASE:STRING=/INCREMENTAL:NO

//Flags used by the linker during the creation of modules during
// RELWITHDEBINFO builds.
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO:STRING=/debug /INCREMENTAL

//Path to a program.
CMAKE_MT:FILEPATH=C:/Program Files/LLVM/bin/llvm-mt.exe

//Path to a program.
CMAKE_NM:FILEPATH=C:/Program Files/LLVM/bin/llvm-nm.exe

//Value Computed by CMake
CMAKE_PROJECT_COMPAT_VERSION:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_DESCRIPTION:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_HOMEPAGE_URL:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_NAME:STATIC=x64dbg_mcp

//Value Computed by CMake
CMAKE_PROJECT_SPDX_LICENSE:STATIC=

//RC compiler
CMAKE_RC_COMPILER:FILEPATH=C:/Program Files/LLVM/bin/llvm-rc.exe

//Flags for Windows Resource Compiler during all build types.
CMAKE_RC_FLAGS:STRING=-DWIN32

//Flags for Windows Resource Compiler during DEBUG builds.
CMAKE_RC_FLAGS_DEBUG:STRING=-D_DEBUG

//Flags for Windows Resource Compiler during MINSIZEREL builds.
CMAKE_RC_FLAGS_MINSIZEREL:STRING=

//Flags for Windows Resource Compiler during RELEASE builds.
CMAKE_RC_FLAGS_RELEASE:STRING=

//Flags for Windows Resource Compiler during RELWITHDEBINFO builds.
CMAKE_RC_FLAGS_RELWITHDEBINFO:STRING=

//Flags used by the linker during the creation of shared libraries
// during all build types.
CMAKE_SHARED_LINKER_FLAGS:STRING=/machine:x64

//Flags used by the linker during the creation of shared libraries
// during DEBUG builds.
CMAKE_SHARED_LINKER_FLAGS_DEBUG:STRING=/debug /INCREMENTAL

//Flags used by the linker during the creation of shared libraries
// during MINSIZEREL builds.
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL:STRING=/INCREMENTAL:NO

//Flags used by the linker during the creation of shared libraries
// during RELEASE builds.
CMAKE_SHARED_LINKER_FLAGS_RELEASE:STRING=/INCREMENTAL:NO

//Flags used by the linker during the creation of shared libraries
// during RELWITHDEBINFO builds.
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO:STRING=/debug /INCREMENTAL

//If set, runtime paths are not added when installing shared libraries,
// but are added when building.
CMAKE_SKIP_INSTALL_RPATH:BOOL=NO

//If set, runtime paths are not added when using shared libraries.
CMAKE_SKIP_RPATH:BOOL=NO

//Flags used by the archiver during the creation of static libraries
// during all build types.
CMAKE_STATIC_LINKER_FLAGS:STRING=/machine:x64

//Flags used by the archiver during the creation of static libraries
// during DEBUG builds.
CMAKE_STATIC_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the archiver during the creation of static libraries
// during MINSIZEREL builds.
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the archiver during the creation of static libraries
// during RELEASE builds.
CMAKE_STATIC_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the archiver during the creation of static libraries
// during RELWITHDEBINFO builds.
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//If this value is on, makefiles will be generated without the
// .SILENT directive, and all commands will be echoed to the console
// during the make.  This is useful for debugging only. With Visual
// Studio IDE projects all commands are done without /nologo.
CMAKE_VERBOSE_MAKEFILE:BOOL=FALSE

//The directory containing a CMake configuration file for nlohmann_json.
nlohmann_json_DIR:PATH=nlohmann_json_DIR-NOTFOUND

//Value Computed by CMake
x64dbg_mcp_BINARY_DIR:STATIC=E:/GitHub/x64dbg_mcp/build

//Value Computed by CMake
x64dbg_mcp_IS_TOP_LEVEL:STATIC=ON

//Value Computed by CMake
x64dbg_mcp_SOURCE_DIR:STATIC=E:/GitHub/x64dbg_mcp/plugin


########################
# INTERNAL cache entries
########################

//ADVANCED property for variable: CMAKE_AR
CMAKE_AR-ADVANCED:INTERNAL=1
//This is the directory where this CMakeCache.txt was created
CMAKE_CACHEFILE_DIR:INTERNAL=e:/GitHub/x64dbg_mcp/build
//Major version of cmake used to create the current loaded cache
CMAKE_CACHE_MAJOR_VERSION:INTERNAL=4
//Minor version of cmake used to create the current loaded cache
CMAKE_CACHE_MINOR_VERSION:INTERNAL=2
//Patch version of cmake used to create the current loaded cache
CMAKE_CACHE_PATCH_VERSION:INTERNAL=3
//Path to CMake executable.
CMAKE_COMMAND:INTERNAL=C:/Program Files/CMake/bin/cmake.exe
//Path to cpack program executable.
CMAKE_CPACK_COMMAND:INTERNAL=C:/Program Files/CMake/bin/cpack.exe
//Path to ctest program executable.
CMAKE_CTEST_COMMAND:INTERNAL=C:/Program Files/CMake/bin/ctest.exe
//ADVANCED property for variable: CMAKE_CXX_COMPILER
CMAKE_CXX_COMPILER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_COMPILER_AR
CMAKE_CXX_COMPILER_AR-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_COMPILER_CLANG_SCAN_DEPS
CMAKE_CXX_COMPILER_CLANG_SCAN_DEPS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_COMPILER_RANLIB
CMAKE_CXX_COMPILER_RANLIB-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS
CMAKE_CXX_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_DEBUG
CMAKE_CXX_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_MINSIZEREL
CMAKE_CXX_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_RELEASE
CMAKE_CXX_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_RELWITHDEBINFO
CMAKE_CXX_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_STANDARD_LIBRARIES
CMAKE_CXX_STANDARD_LIBRARIES-ADVANCED:INTERNAL=1
//Path to cache edit program executable.
CMAKE_EDIT_COMMAND:INTERNAL=C:/Program Files/CMake/bin/cmake-gui.exe
//Executable file format
CMAKE_EXECUTABLE_FORMAT:INTERNAL=Unknown
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS
CMAKE_EXE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_DEBUG
CMAKE_EXE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_MINSIZEREL
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELEASE
CMAKE_EXE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXPORT_BUILD_DATABASE
CMAKE_EXPORT_BUILD_DATABASE-ADVANCED:INTERNAL=1
//Name of external makefile project generator.
CMAKE_EXTRA_GENERATOR:INTERNAL=
//Name of generator.
CMAKE_GENERATOR:INTERNAL=Ninja
//Generator instance identifier.
CMAKE_GENERATOR_INSTANCE:INTERNAL=
//Name of generator platform.
CMAKE_GENERATOR_PLATFORM:INTERNAL=
//Name of generator toolset.
CMAKE_GENERATOR_TOOLSET:INTERNAL=
//Source directory with the top level CMakeLists.txt file for this
// project
CMAKE_HOME_DIRECTORY:INTERNAL=E:/GitHub/x64dbg_mcp/plugin
//ADVANCED property for variable: CMAKE_LINKER
CMAKE_LINKER-ADVANCED:INTERNAL=1
//Name of CMakeLists files to read
CMAKE_LIST_FILE_NAME:INTERNAL=CMakeLists.txt
//ADVANCED property for variable: CMAKE_MAKE_PROGRAM
CMAKE_MAKE_PROGRAM-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS
CMAKE_MODULE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_DEBUG
CMAKE_MODULE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELEASE
CMAKE_MODULE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MT
CMAKE_MT-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_NM
CMAKE_NM-ADVANCED:INTERNAL=1
//number of local generators
CMAKE_NUMBER_OF_MAKEFILES:INTERNAL=1
//Platform information initialized
CMAKE_PLATFORM_INFO_INITIALIZED:INTERNAL=1
//noop for ranlib
CMAKE_RANLIB:INTERNAL=:
//ADVANCED property for variable: CMAKE_RC_COMPILER
CMAKE_RC_COMPILER-ADVANCED:INTERNAL=1
CMAKE_RC_COMPILER_WORKS:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS
CMAKE_RC_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS_DEBUG
CMAKE_RC_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS_MINSIZEREL
CMAKE_RC_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS_RELEASE
CMAKE_RC_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RC_FLAGS_RELWITHDEBINFO
CMAKE_RC_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//Path to CMake installation.
CMAKE_ROOT:INTERNAL=C:/Program Files/CMake/share/cmake-4.2
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS
CMAKE_SHARED_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_DEBUG
CMAKE_SHARED_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELEASE
CMAKE_SHARED_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_INSTALL_RPATH
CMAKE_SKIP_INSTALL_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_RPATH
CMAKE_SKIP_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS
CMAKE_STATIC_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_DEBUG
CMAKE_STATIC_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELEASE
CMAKE_STATIC_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_VERBOSE_MAKEFILE
CMAKE_VERBOSE_MAKEFILE-ADVANCED:INTERNAL=1


```

`build/CMakeFiles/4.2.3/CMakeCXXCompiler.cmake`:

```cmake
set(CMAKE_CXX_COMPILER "C:/Program Files/LLVM/bin/clang-cl.exe")
set(CMAKE_CXX_COMPILER_ARG1 "")
set(CMAKE_CXX_COMPILER_ID "Clang")
set(CMAKE_CXX_COMPILER_VERSION "21.1.8")
set(CMAKE_CXX_COMPILER_VERSION_INTERNAL "")
set(CMAKE_CXX_COMPILER_WRAPPER "")
set(CMAKE_CXX_STANDARD_COMPUTED_DEFAULT "14")
set(CMAKE_CXX_EXTENSIONS_COMPUTED_DEFAULT "ON")
set(CMAKE_CXX_STANDARD_LATEST "26")
set(CMAKE_CXX_COMPILE_FEATURES "cxx_std_98;cxx_template_template_parameters;cxx_std_11;cxx_alias_templates;cxx_alignas;cxx_alignof;cxx_attributes;cxx_auto_type;cxx_constexpr;cxx_decltype;cxx_default_function_template_args;cxx_defaulted_functions;cxx_defaulted_move_initializers;cxx_delegating_constructors;cxx_deleted_functions;cxx_enum_forward_declarations;cxx_explicit_conversions;cxx_extended_friend_declarations;cxx_extern_templates;cxx_final;cxx_func_identifier;cxx_generalized_initializers;cxx_inheriting_constructors;cxx_inline_namespaces;cxx_lambdas;cxx_local_type_template_args;cxx_long_long_type;cxx_noexcept;cxx_nonstatic_member_init;cxx_nullptr;cxx_override;cxx_range_for;cxx_raw_string_literals;cxx_reference_qualified_functions;cxx_right_angle_brackets;cxx_rvalue_references;cxx_sizeof_member;cxx_static_assert;cxx_strong_enums;cxx_thread_local;cxx_trailing_return_types;cxx_unicode_literals;cxx_uniform_initialization;cxx_unrestricted_unions;cxx_user_literals;cxx_variadic_macros;cxx_variadic_templates;cxx_aggregate_default_initializers;cxx_attribute_deprecated;cxx_binary_literals;cxx_contextual_conversions;cxx_decltype_auto;cxx_digit_separators;cxx_generic_lambdas;cxx_lambda_init_captures;cxx_relaxed_constexpr;cxx_return_type_deduction;cxx_variable_templates;cxx_std_14;cxx_std_17;cxx_std_20;cxx_std_23;cxx_std_26")
set(CMAKE_CXX98_COMPILE_FEATURES "cxx_std_98;cxx_template_template_parameters")
set(CMAKE_CXX11_COMPILE_FEATURES "cxx_std_11;cxx_alias_templates;cxx_alignas;cxx_alignof;cxx_attributes;cxx_auto_type;cxx_constexpr;cxx_decltype;cxx_default_function_template_args;cxx_defaulted_functions;cxx_defaulted_move_initializers;cxx_delegating_constructors;cxx_deleted_functions;cxx_enum_forward_declarations;cxx_explicit_conversions;cxx_extended_friend_declarations;cxx_extern_templates;cxx_final;cxx_func_identifier;cxx_generalized_initializers;cxx_inheriting_constructors;cxx_inline_namespaces;cxx_lambdas;cxx_local_type_template_args;cxx_long_long_type;cxx_noexcept;cxx_nonstatic_member_init;cxx_nullptr;cxx_override;cxx_range_for;cxx_raw_string_literals;cxx_reference_qualified_functions;cxx_right_angle_brackets;cxx_rvalue_references;cxx_sizeof_member;cxx_static_assert;cxx_strong_enums;cxx_thread_local;cxx_trailing_return_types;cxx_unicode_literals;cxx_uniform_initialization;cxx_unrestricted_unions;cxx_user_literals;cxx_variadic_macros;cxx_variadic_templates;cxx_aggregate_default_initializers;cxx_attribute_deprecated;cxx_binary_literals;cxx_contextual_conversions;cxx_decltype_auto;cxx_digit_separators;cxx_generic_lambdas;cxx_lambda_init_captures;cxx_relaxed_constexpr;cxx_return_type_deduction;cxx_variable_templates")
set(CMAKE_CXX14_COMPILE_FEATURES "cxx_std_14")
set(CMAKE_CXX17_COMPILE_FEATURES "cxx_std_17")
set(CMAKE_CXX20_COMPILE_FEATURES "cxx_std_20")
set(CMAKE_CXX23_COMPILE_FEATURES "cxx_std_23")
set(CMAKE_CXX26_COMPILE_FEATURES "cxx_std_26")

set(CMAKE_CXX_PLATFORM_ID "Windows")
set(CMAKE_CXX_SIMULATE_ID "MSVC")
set(CMAKE_CXX_COMPILER_FRONTEND_VARIANT "MSVC")
set(CMAKE_CXX_COMPILER_APPLE_SYSROOT "")
set(CMAKE_CXX_SIMULATE_VERSION "19.50")
set(CMAKE_CXX_COMPILER_ARCHITECTURE_ID "x64")

set(MSVC_CXX_ARCHITECTURE_ID x64)

set(CMAKE_AR "C:/Program Files/LLVM/bin/llvm-lib.exe")
set(CMAKE_CXX_COMPILER_AR "C:/Program Files/LLVM/bin/llvm-ar.exe")
set(CMAKE_RANLIB ":")
set(CMAKE_CXX_COMPILER_RANLIB "C:/Program Files/LLVM/bin/llvm-ranlib.exe")
set(CMAKE_LINKER "C:/Program Files/LLVM/bin/lld-link.exe")
set(CMAKE_LINKER_LINK "link")
set(CMAKE_LINKER_LLD "C:/Program Files/LLVM/bin/lld-link.exe")
set(CMAKE_CXX_COMPILER_LINKER "C:/PROGRA~1/LLVM/bin/lld-link.exe")
set(CMAKE_CXX_COMPILER_LINKER_ID "LLD")
set(CMAKE_CXX_COMPILER_LINKER_VERSION 21.1.8)
set(CMAKE_CXX_COMPILER_LINKER_FRONTEND_VARIANT MSVC)
set(CMAKE_MT "C:/Program Files/LLVM/bin/llvm-mt.exe")
set(CMAKE_TAPI "")
set(CMAKE_COMPILER_IS_GNUCXX )
set(CMAKE_CXX_COMPILER_LOADED 1)
set(CMAKE_CXX_COMPILER_WORKS TRUE)
set(CMAKE_CXX_ABI_COMPILED TRUE)

set(CMAKE_CXX_COMPILER_ENV_VAR "CXX")

set(CMAKE_CXX_COMPILER_ID_RUN 1)
set(CMAKE_CXX_SOURCE_FILE_EXTENSIONS C;M;c++;cc;cpp;cxx;m;mm;mpp;CPP;ixx;cppm;ccm;cxxm;c++m)
set(CMAKE_CXX_IGNORE_EXTENSIONS inl;h;hpp;HPP;H;o;O;obj;OBJ;def;DEF;rc;RC)

foreach (lang IN ITEMS C OBJC OBJCXX)
  if (CMAKE_${lang}_COMPILER_ID_RUN)
    foreach(extension IN LISTS CMAKE_${lang}_SOURCE_FILE_EXTENSIONS)
      list(REMOVE_ITEM CMAKE_CXX_SOURCE_FILE_EXTENSIONS ${extension})
    endforeach()
  endif()
endforeach()

set(CMAKE_CXX_LINKER_PREFERENCE 30)
set(CMAKE_CXX_LINKER_PREFERENCE_PROPAGATES 1)
set(CMAKE_CXX_LINKER_DEPFILE_SUPPORTED )
set(CMAKE_LINKER_PUSHPOP_STATE_SUPPORTED )
set(CMAKE_CXX_LINKER_PUSHPOP_STATE_SUPPORTED )

# Save compiler ABI information.
set(CMAKE_CXX_SIZEOF_DATA_PTR "8")
set(CMAKE_CXX_COMPILER_ABI "")
set(CMAKE_CXX_BYTE_ORDER "LITTLE_ENDIAN")
set(CMAKE_CXX_LIBRARY_ARCHITECTURE "")

if(CMAKE_CXX_SIZEOF_DATA_PTR)
  set(CMAKE_SIZEOF_VOID_P "${CMAKE_CXX_SIZEOF_DATA_PTR}")
endif()

if(CMAKE_CXX_COMPILER_ABI)
  set(CMAKE_INTERNAL_PLATFORM_ABI "${CMAKE_CXX_COMPILER_ABI}")
endif()

if(CMAKE_CXX_LIBRARY_ARCHITECTURE)
  set(CMAKE_LIBRARY_ARCHITECTURE "")
endif()

set(CMAKE_CXX_CL_SHOWINCLUDES_PREFIX "Note: including file: ")
if(CMAKE_CXX_CL_SHOWINCLUDES_PREFIX)
  set(CMAKE_CL_SHOWINCLUDES_PREFIX "${CMAKE_CXX_CL_SHOWINCLUDES_PREFIX}")
endif()





set(CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES "")
set(CMAKE_CXX_IMPLICIT_LINK_LIBRARIES "")
set(CMAKE_CXX_IMPLICIT_LINK_DIRECTORIES "")
set(CMAKE_CXX_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES "")
set(CMAKE_CXX_COMPILER_CLANG_RESOURCE_DIR "")

set(CMAKE_CXX_COMPILER_IMPORT_STD "")
### Imported target for C++23 standard library
set(CMAKE_CXX23_COMPILER_IMPORT_STD_NOT_FOUND_MESSAGE "Experimental `import std` support not enabled when detecting toolchain; it must be set before `CXX` is enabled (usually a `project()` call)")


### Imported target for C++26 standard library
set(CMAKE_CXX26_COMPILER_IMPORT_STD_NOT_FOUND_MESSAGE "Experimental `import std` support not enabled when detecting toolchain; it must be set before `CXX` is enabled (usually a `project()` call)")




```

`build/CMakeFiles/4.2.3/CMakeRCCompiler.cmake`:

```cmake
set(CMAKE_RC_COMPILER "C:/Program Files/LLVM/bin/llvm-rc.exe")
set(CMAKE_RC_COMPILER_ARG1 "")
set(CMAKE_RC_COMPILER_LOADED 1)
set(CMAKE_RC_SOURCE_FILE_EXTENSIONS rc;RC)
set(CMAKE_RC_OUTPUT_EXTENSION .res)
set(CMAKE_RC_COMPILER_ENV_VAR "RC")

```

`build/CMakeFiles/4.2.3/CMakeSystem.cmake`:

```cmake
set(CMAKE_HOST_SYSTEM "Windows-10.0.26200")
set(CMAKE_HOST_SYSTEM_NAME "Windows")
set(CMAKE_HOST_SYSTEM_VERSION "10.0.26200")
set(CMAKE_HOST_SYSTEM_PROCESSOR "AMD64")



set(CMAKE_SYSTEM "Windows-10.0.26200")
set(CMAKE_SYSTEM_NAME "Windows")
set(CMAKE_SYSTEM_VERSION "10.0.26200")
set(CMAKE_SYSTEM_PROCESSOR "AMD64")

set(CMAKE_CROSSCOMPILING "FALSE")

set(CMAKE_SYSTEM_LOADED 1)

```

`build/CMakeFiles/4.2.3/CompilerIdCXX/CMakeCXXCompilerId.cpp`:

```cpp
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"
# if __SUNPRO_CC >= 0x5100
   /* __SUNPRO_CC = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# endif

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"
  /* __HP_aCC = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"
  /* __DECCXX_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)

#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)
# define COMPILER_VERSION_INTERNAL_STR  __clang_version__


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
# define COMPILER_ID "XL"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(__clang__) && defined(__cray__)
# define COMPILER_ID "CrayClang"
# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TASKING__)
# define COMPILER_ID "Tasking"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)

#elif defined(__ORANGEC__)
# define COMPILER_ID "OrangeC"
# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)

#elif defined(__RENESAS__)
# define COMPILER_ID "Renesas"
/* __RENESAS_VERSION__ = 0xVVRRPP00 */
# define COMPILER_VERSION_MAJOR HEX(__RENESAS_VERSION__ >> 24 & 0xFF)
# define COMPILER_VERSION_MINOR HEX(__RENESAS_VERSION__ >> 16 & 0xFF)
# define COMPILER_VERSION_PATCH HEX(__RENESAS_VERSION__ >> 8  & 0xFF)

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__) && defined(__ti__)
# define COMPILER_ID "TIClang"
  # define COMPILER_VERSION_MAJOR DEC(__ti_major__)
  # define COMPILER_VERSION_MINOR DEC(__ti_minor__)
  # define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
# define COMPILER_VERSION_INTERNAL DEC(__ti_version__)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__) || defined(__GNUG__)
# define COMPILER_ID "GNU"
# if defined(__GNUC__)
#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# else
#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif

#elif defined(__DCC__) && defined(_DIAB_TOOL)
# define COMPILER_ID "Diab"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION_MAJOR_NUMBER__)
  # define COMPILER_VERSION_MINOR DEC(__VERSION_MINOR_NUMBER__)
  # define COMPILER_VERSION_PATCH DEC(__VERSION_ARCH_FEATURE_NUMBER__)
  # define COMPILER_VERSION_TWEAK DEC(__VERSION_BUG_FIX_NUMBER__)



/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__clang__) && defined(__ti__)
# if defined(__ARM_ARCH)
#  define ARCHITECTURE_ID "ARM"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#elif defined(__TASKING__)

# if defined(__CTC__) || defined(__CPTC__)
#  define ARCHITECTURE_ID "TriCore"

# elif defined(__CMCS__)
#  define ARCHITECTURE_ID "MCS"

# elif defined(__CARM__) || defined(__CPARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__CARC__)
#  define ARCHITECTURE_ID "ARC"

# elif defined(__C51__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__CPCP__)
#  define ARCHITECTURE_ID "PCP"

# else
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__RENESAS__)
# if defined(__CCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__CCRL__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__CCRH__)
#  define ARCHITECTURE_ID "RH850"

# else
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#define CXX_STD_98 199711L
#define CXX_STD_11 201103L
#define CXX_STD_14 201402L
#define CXX_STD_17 201703L
#define CXX_STD_20 202002L
#define CXX_STD_23 202302L

#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > CXX_STD_17
#    define CXX_STD _MSVC_LANG
#  elif _MSVC_LANG == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14 && __cplusplus > CXX_STD_17
#    define CXX_STD CXX_STD_20
#  elif _MSVC_LANG > CXX_STD_14
#    define CXX_STD CXX_STD_17
#  elif defined(__INTEL_CXX11_MODE__) && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  elif defined(__INTEL_CXX11_MODE__)
#    define CXX_STD CXX_STD_11
#  else
#    define CXX_STD CXX_STD_98
#  endif
#elif defined(_MSC_VER) && defined(_MSVC_LANG)
#  if _MSVC_LANG > __cplusplus
#    define CXX_STD _MSVC_LANG
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__NVCOMPILER)
#  if __cplusplus == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
#    define CXX_STD CXX_STD_20
#  else
#    define CXX_STD __cplusplus
#  endif
#elif defined(__INTEL_COMPILER) || defined(__PGI)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_namespace_attributes)
#    define CXX_STD CXX_STD_17
#  elif __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif (defined(__IBMCPP__) || defined(__ibmxl__)) && defined(__linux__)
#  if __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
#    define CXX_STD CXX_STD_14
#  else
#    define CXX_STD __cplusplus
#  endif
#elif __cplusplus == 1 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#  define CXX_STD CXX_STD_11
#else
#  define CXX_STD __cplusplus
#endif

const char* info_language_standard_default = "INFO" ":" "standard_default["
#if CXX_STD > CXX_STD_23
  "26"
#elif CXX_STD > CXX_STD_20
  "23"
#elif CXX_STD > CXX_STD_17
  "20"
#elif CXX_STD > CXX_STD_14
  "17"
#elif CXX_STD > CXX_STD_11
  "14"
#elif CXX_STD >= CXX_STD_11
  "11"
#else
  "98"
#endif
"]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__) || defined(__RENESAS__)) &&             \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#if defined(COMPILER_VERSION_INTERNAL) || defined(COMPILER_VERSION_INTERNAL_STR)
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}

```

`build/CMakeFiles/CMakeConfigureLog.yaml`:

```yaml

---
events:
  -
    kind: "message-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineSystem.cmake:212 (message)"
      - "CMakeLists.txt:2 (project)"
    message: |
      The system is: Windows - 10.0.26200 - AMD64
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeNinjaFindMake.cmake:5 (find_program)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "CMAKE_MAKE_PROGRAM"
    description: "Program used to build from build.ninja files."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: true
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "ninja-build"
      - "ninja"
      - "samu"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/ninja-build.com"
      - "C:/Program Files/LLVM/bin/ninja-build.exe"
      - "C:/Program Files/LLVM/bin/ninja-build"
      - "C:/Program Files/LLVM/bin/ninja.com"
      - "C:/Program Files/LLVM/bin/ninja.exe"
      - "C:/Program Files/LLVM/bin/ninja"
      - "C:/Program Files/LLVM/bin/samu.com"
      - "C:/Program Files/LLVM/bin/samu.exe"
      - "C:/Program Files/LLVM/bin/samu"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/ninja-build.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/ninja-build.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/ninja-build"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/ninja.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/ninja.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/ninja"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/samu.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/samu.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/samu"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/ninja-build.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/ninja-build.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/ninja-build"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/ninja.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/ninja.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/ninja"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/samu.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/samu.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/samu"
      - "C:/Program Files (x86)/oh-my-posh/bin/ninja-build.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/ninja-build.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/ninja-build"
      - "C:/Program Files (x86)/oh-my-posh/bin/ninja.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/ninja.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/ninja"
      - "C:/Program Files (x86)/oh-my-posh/bin/samu.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/samu.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/samu"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/ninja-build.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/ninja-build.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/ninja-build"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/ninja.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/ninja.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/ninja"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/samu.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/samu.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/samu"
      - "C:/Python311/Scripts/ninja-build.com"
      - "C:/Python311/Scripts/ninja-build.exe"
      - "C:/Python311/Scripts/ninja-build"
      - "C:/Python311/Scripts/ninja.com"
      - "C:/Python311/Scripts/ninja.exe"
      - "C:/Python311/Scripts/ninja"
      - "C:/Python311/Scripts/samu.com"
      - "C:/Python311/Scripts/samu.exe"
      - "C:/Python311/Scripts/samu"
      - "C:/Python311/ninja-build.com"
      - "C:/Python311/ninja-build.exe"
      - "C:/Python311/ninja-build"
      - "C:/Python311/ninja.com"
      - "C:/Python311/ninja.exe"
      - "C:/Python311/ninja"
      - "C:/Python311/samu.com"
      - "C:/Python311/samu.exe"
      - "C:/Python311/samu"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/ninja-build.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/ninja-build.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/ninja-build"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/ninja.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/ninja.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/ninja"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/samu.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/samu.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/samu"
      - "C:/Windows/System32/ninja-build.com"
      - "C:/Windows/System32/ninja-build.exe"
      - "C:/Windows/System32/ninja-build"
      - "C:/Windows/System32/ninja.com"
      - "C:/Windows/System32/ninja.exe"
      - "C:/Windows/System32/ninja"
      - "C:/Windows/System32/samu.com"
      - "C:/Windows/System32/samu.exe"
      - "C:/Windows/System32/samu"
      - "C:/Windows/ninja-build.com"
      - "C:/Windows/ninja-build.exe"
      - "C:/Windows/ninja-build"
      - "C:/Windows/ninja.com"
      - "C:/Windows/ninja.exe"
      - "C:/Windows/ninja"
      - "C:/Windows/samu.com"
      - "C:/Windows/samu.exe"
      - "C:/Windows/samu"
      - "C:/Windows/System32/wbem/ninja-build.com"
      - "C:/Windows/System32/wbem/ninja-build.exe"
      - "C:/Windows/System32/wbem/ninja-build"
      - "C:/Windows/System32/wbem/ninja.com"
      - "C:/Windows/System32/wbem/ninja.exe"
      - "C:/Windows/System32/wbem/ninja"
      - "C:/Windows/System32/wbem/samu.com"
      - "C:/Windows/System32/wbem/samu.exe"
      - "C:/Windows/System32/wbem/samu"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/ninja-build.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/ninja-build.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/ninja-build"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/ninja.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/ninja.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/ninja"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/samu.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/samu.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/samu"
      - "C:/Windows/System32/OpenSSH/ninja-build.com"
      - "C:/Windows/System32/OpenSSH/ninja-build.exe"
      - "C:/Windows/System32/OpenSSH/ninja-build"
      - "C:/Windows/System32/OpenSSH/ninja.com"
      - "C:/Windows/System32/OpenSSH/ninja.exe"
      - "C:/Windows/System32/OpenSSH/ninja"
      - "C:/Windows/System32/OpenSSH/samu.com"
      - "C:/Windows/System32/OpenSSH/samu.exe"
      - "C:/Windows/System32/OpenSSH/samu"
      - "C:/ProgramData/chocolatey/bin/ninja-build.com"
      - "C:/ProgramData/chocolatey/bin/ninja-build.exe"
      - "C:/ProgramData/chocolatey/bin/ninja-build"
      - "C:/ProgramData/chocolatey/bin/ninja.com"
    found: "C:/ProgramData/chocolatey/bin/ninja.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerId.cmake:462 (find_file)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerId.cmake:500 (CMAKE_DETERMINE_COMPILER_ID_WRITE)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerId.cmake:8 (CMAKE_DETERMINE_COMPILER_ID_BUILD)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerId.cmake:64 (__determine_compiler_id_test)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:125 (CMAKE_DETERMINE_COMPILER_ID)"
      - "CMakeLists.txt:2 (project)"
    mode: "file"
    variable: "src_in"
    description: "Path to a file."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: true
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "CMakeCXXCompilerId.cpp.in"
    candidate_directories:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/"
    found: "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeCXXCompilerId.cpp.in"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "message-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerId.cmake:17 (message)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerId.cmake:64 (__determine_compiler_id_test)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:125 (CMAKE_DETERMINE_COMPILER_ID)"
      - "CMakeLists.txt:2 (project)"
    message: |
      Compiling the CXX compiler identification source file "CMakeCXXCompilerId.cpp" succeeded.
      Compiler: C:/Program Files/LLVM/bin/clang-cl.exe 
      Build flags: 
      Id flags:  
      
      The output was:
      0
      
      
      Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" produced "CMakeCXXCompilerId.exe"
      
      The CXX compiler identification is Clang, found in:
        E:/GitHub/x64dbg_mcp/build/CMakeFiles/4.2.3/CompilerIdCXX/CMakeCXXCompilerId.exe
      
  -
    kind: "message-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerId.cmake:1341 (message)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerId.cmake:250 (CMAKE_DETERMINE_MSVC_SHOWINCLUDES_PREFIX)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:125 (CMAKE_DETERMINE_COMPILER_ID)"
      - "CMakeLists.txt:2 (project)"
    message: |
      Detecting CXX compiler /showIncludes prefix:
        Note: including file: .\\foo.h
        
      Found prefix "Note: including file: "
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:37 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:65 (__resolve_tool_path)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:103 (__resolve_linker_path)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:206 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "_CMAKE_TOOL_WITH_PATH"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: false
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: false
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "link"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/link.com"
      - "C:/Program Files/LLVM/bin/link.exe"
      - "C:/Program Files/LLVM/bin/link"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/link.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/link.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/link"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/link.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/link.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/link"
      - "C:/Program Files (x86)/oh-my-posh/bin/link.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/link.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/link"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/link.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/link.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/link"
      - "C:/Python311/Scripts/link.com"
      - "C:/Python311/Scripts/link.exe"
      - "C:/Python311/Scripts/link"
      - "C:/Python311/link.com"
      - "C:/Python311/link.exe"
      - "C:/Python311/link"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/link.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/link.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/link"
      - "C:/Windows/System32/link.com"
      - "C:/Windows/System32/link.exe"
      - "C:/Windows/System32/link"
      - "C:/Windows/link.com"
      - "C:/Windows/link.exe"
      - "C:/Windows/link"
      - "C:/Windows/System32/wbem/link.com"
      - "C:/Windows/System32/wbem/link.exe"
      - "C:/Windows/System32/wbem/link"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/link.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/link.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/link"
      - "C:/Windows/System32/OpenSSH/link.com"
      - "C:/Windows/System32/OpenSSH/link.exe"
      - "C:/Windows/System32/OpenSSH/link"
      - "C:/ProgramData/chocolatey/bin/link.com"
      - "C:/ProgramData/chocolatey/bin/link.exe"
      - "C:/ProgramData/chocolatey/bin/link"
      - "C:/Program Files/PowerShell/7/link.com"
      - "C:/Program Files/PowerShell/7/link.exe"
      - "C:/Program Files/PowerShell/7/link"
      - "C:/Program Files (x86)/LLVM/bin/link.com"
      - "C:/Program Files (x86)/LLVM/bin/link.exe"
      - "C:/Program Files (x86)/LLVM/bin/link"
      - "C:/Program Files/dotnet/link.com"
      - "C:/Program Files/dotnet/link.exe"
      - "C:/Program Files/dotnet/link"
      - "C:/Program Files (x86)/Yarn/bin/link.com"
      - "C:/Program Files (x86)/Yarn/bin/link.exe"
      - "C:/Program Files (x86)/Yarn/bin/link"
      - "C:/ProgramData/nvm/link.com"
      - "C:/ProgramData/nvm/link.exe"
      - "C:/ProgramData/nvm/link"
      - "C:/nvm4w/nodejs/link.com"
      - "C:/nvm4w/nodejs/link.exe"
      - "C:/nvm4w/nodejs/link"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/link.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/link.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/link"
      - "C:/tools/php85/link.com"
      - "C:/tools/php85/link.exe"
      - "C:/tools/php85/link"
      - "C:/Program Files/Microsoft VS Code/bin/link.com"
      - "C:/Program Files/Microsoft VS Code/bin/link.exe"
      - "C:/Program Files/Microsoft VS Code/bin/link"
      - "C:/Program Files/Tailscale/link.com"
      - "C:/Program Files/Tailscale/link.exe"
      - "C:/Program Files/Tailscale/link"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/link.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/link.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/link"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/link.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/link.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/link"
      - "C:/Program Files/Mullvad VPN/resources/link.com"
      - "C:/Program Files/Mullvad VPN/resources/link.exe"
      - "C:/Program Files/Mullvad VPN/resources/link"
      - "C:/Program Files/OpenSSL-Win64/bin/link.com"
      - "C:/Program Files/OpenSSL-Win64/bin/link.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/link"
      - "C:/Program Files/GitHub CLI/link.com"
      - "C:/Program Files/GitHub CLI/link.exe"
      - "C:/Program Files/GitHub CLI/link"
      - "C:/Program Files/CMake/bin/link.com"
      - "C:/Program Files/CMake/bin/link.exe"
      - "C:/Program Files/CMake/bin/link"
      - "C:/Program Files/doxygen/bin/link.com"
      - "C:/Program Files/doxygen/bin/link.exe"
      - "C:/Program Files/doxygen/bin/link"
      - "C:/Users/Able/.local/bin/link.com"
      - "C:/Users/Able/.local/bin/link.exe"
      - "C:/Users/Able/.local/bin/link"
      - "C:/Program Files/Docker/Docker/resources/bin/link.com"
      - "C:/Program Files/Docker/Docker/resources/bin/link.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/link"
      - "C:/Program Files/Git/cmd/link.com"
      - "C:/Program Files/Git/cmd/link.exe"
      - "C:/Program Files/Git/cmd/link"
      - "C:/Program Files/nodejs/link.com"
      - "C:/Program Files/nodejs/link.exe"
      - "C:/Program Files/nodejs/link"
      - "C:/Program Files/PowerToys/DSCModules/link.com"
      - "C:/Program Files/PowerToys/DSCModules/link.exe"
      - "C:/Program Files/PowerToys/DSCModules/link"
      - "E:/platform-tools/link.com"
      - "E:/platform-tools/link.exe"
      - "E:/platform-tools/link"
      - "C:/Users/Able/.cargo/bin/link.com"
      - "C:/Users/Able/.cargo/bin/link.exe"
      - "C:/Users/Able/.cargo/bin/link"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/link.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/link.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/link"
      - "C:/Users/Able/AppData/Local/Yarn/bin/link.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/link.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/link"
      - "E:/GitHub/vcpkg/link.com"
      - "E:/GitHub/vcpkg/link.exe"
      - "E:/GitHub/vcpkg/link"
      - "C:/Users/Able/.dotnet/tools/link.com"
      - "C:/Users/Able/.dotnet/tools/link.exe"
      - "C:/Users/Able/.dotnet/tools/link"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/link.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/link.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/link"
      - "C:/Users/Able/AppData/Roaming/npm/link.com"
      - "C:/Users/Able/AppData/Roaming/npm/link.exe"
      - "C:/Users/Able/AppData/Roaming/npm/link"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/link.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/link.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/link"
    found: false
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:37 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:65 (__resolve_tool_path)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:104 (__resolve_linker_path)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:206 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "_CMAKE_TOOL_WITH_PATH"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: false
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: false
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "lld-link"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/lld-link.com"
    found: "C:/Program Files/LLVM/bin/lld-link.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:243 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:206 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "CMAKE_NM"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: false
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: false
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "llvm-nm"
      - "nm"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/llvm-nm.com"
    found: "C:/Program Files/LLVM/bin/llvm-nm.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:243 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:206 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "CMAKE_LINKER"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: false
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: false
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "lld-link"
      - "link"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/lld-link.com"
    found: "C:/Program Files/LLVM/bin/lld-link.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:243 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:206 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "CMAKE_MT"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: false
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: false
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "llvm-mt"
      - "mt"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/llvm-mt.com"
    found: "C:/Program Files/LLVM/bin/llvm-mt.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeFindBinUtils.cmake:243 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:206 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "CMAKE_AR"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: false
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: false
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "llvm-lib"
      - "lib"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/llvm-lib.com"
    found: "C:/Program Files/LLVM/bin/llvm-lib.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Compiler/Clang-FindBinUtils.cmake:26 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:207 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "CMAKE_CXX_COMPILER_AR"
    description: "LLVM archiver"
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: false
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: false
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "llvm-ar-21.1"
      - "llvm-ar-21"
      - "llvm-ar21"
      - "llvm-ar"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/llvm-ar-21.1.com"
      - "C:/Program Files/LLVM/bin/llvm-ar-21.1.exe"
      - "C:/Program Files/LLVM/bin/llvm-ar-21.1"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ar-21.1.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ar-21.1.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ar-21.1"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ar-21.1.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ar-21.1.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ar-21.1"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ar-21.1.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ar-21.1.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ar-21.1"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ar-21.1.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ar-21.1.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ar-21.1"
      - "C:/Python311/Scripts/llvm-ar-21.1.com"
      - "C:/Python311/Scripts/llvm-ar-21.1.exe"
      - "C:/Python311/Scripts/llvm-ar-21.1"
      - "C:/Python311/llvm-ar-21.1.com"
      - "C:/Python311/llvm-ar-21.1.exe"
      - "C:/Python311/llvm-ar-21.1"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ar-21.1.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ar-21.1.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ar-21.1"
      - "C:/Windows/System32/llvm-ar-21.1.com"
      - "C:/Windows/System32/llvm-ar-21.1.exe"
      - "C:/Windows/System32/llvm-ar-21.1"
      - "C:/Windows/llvm-ar-21.1.com"
      - "C:/Windows/llvm-ar-21.1.exe"
      - "C:/Windows/llvm-ar-21.1"
      - "C:/Windows/System32/wbem/llvm-ar-21.1.com"
      - "C:/Windows/System32/wbem/llvm-ar-21.1.exe"
      - "C:/Windows/System32/wbem/llvm-ar-21.1"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ar-21.1.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ar-21.1.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ar-21.1"
      - "C:/Windows/System32/OpenSSH/llvm-ar-21.1.com"
      - "C:/Windows/System32/OpenSSH/llvm-ar-21.1.exe"
      - "C:/Windows/System32/OpenSSH/llvm-ar-21.1"
      - "C:/ProgramData/chocolatey/bin/llvm-ar-21.1.com"
      - "C:/ProgramData/chocolatey/bin/llvm-ar-21.1.exe"
      - "C:/ProgramData/chocolatey/bin/llvm-ar-21.1"
      - "C:/Program Files/PowerShell/7/llvm-ar-21.1.com"
      - "C:/Program Files/PowerShell/7/llvm-ar-21.1.exe"
      - "C:/Program Files/PowerShell/7/llvm-ar-21.1"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ar-21.1.com"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ar-21.1.exe"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ar-21.1"
      - "C:/Program Files/dotnet/llvm-ar-21.1.com"
      - "C:/Program Files/dotnet/llvm-ar-21.1.exe"
      - "C:/Program Files/dotnet/llvm-ar-21.1"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ar-21.1.com"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ar-21.1.exe"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ar-21.1"
      - "C:/ProgramData/nvm/llvm-ar-21.1.com"
      - "C:/ProgramData/nvm/llvm-ar-21.1.exe"
      - "C:/ProgramData/nvm/llvm-ar-21.1"
      - "C:/nvm4w/nodejs/llvm-ar-21.1.com"
      - "C:/nvm4w/nodejs/llvm-ar-21.1.exe"
      - "C:/nvm4w/nodejs/llvm-ar-21.1"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ar-21.1.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ar-21.1.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ar-21.1"
      - "C:/tools/php85/llvm-ar-21.1.com"
      - "C:/tools/php85/llvm-ar-21.1.exe"
      - "C:/tools/php85/llvm-ar-21.1"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ar-21.1.com"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ar-21.1.exe"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ar-21.1"
      - "C:/Program Files/Tailscale/llvm-ar-21.1.com"
      - "C:/Program Files/Tailscale/llvm-ar-21.1.exe"
      - "C:/Program Files/Tailscale/llvm-ar-21.1"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ar-21.1.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ar-21.1.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ar-21.1"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ar-21.1.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ar-21.1.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ar-21.1"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ar-21.1.com"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ar-21.1.exe"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ar-21.1"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ar-21.1.com"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ar-21.1.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ar-21.1"
      - "C:/Program Files/GitHub CLI/llvm-ar-21.1.com"
      - "C:/Program Files/GitHub CLI/llvm-ar-21.1.exe"
      - "C:/Program Files/GitHub CLI/llvm-ar-21.1"
      - "C:/Program Files/CMake/bin/llvm-ar-21.1.com"
      - "C:/Program Files/CMake/bin/llvm-ar-21.1.exe"
      - "C:/Program Files/CMake/bin/llvm-ar-21.1"
      - "C:/Program Files/doxygen/bin/llvm-ar-21.1.com"
      - "C:/Program Files/doxygen/bin/llvm-ar-21.1.exe"
      - "C:/Program Files/doxygen/bin/llvm-ar-21.1"
      - "C:/Users/Able/.local/bin/llvm-ar-21.1.com"
      - "C:/Users/Able/.local/bin/llvm-ar-21.1.exe"
      - "C:/Users/Able/.local/bin/llvm-ar-21.1"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ar-21.1.com"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ar-21.1.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ar-21.1"
      - "C:/Program Files/Git/cmd/llvm-ar-21.1.com"
      - "C:/Program Files/Git/cmd/llvm-ar-21.1.exe"
      - "C:/Program Files/Git/cmd/llvm-ar-21.1"
      - "C:/Program Files/nodejs/llvm-ar-21.1.com"
      - "C:/Program Files/nodejs/llvm-ar-21.1.exe"
      - "C:/Program Files/nodejs/llvm-ar-21.1"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ar-21.1.com"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ar-21.1.exe"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ar-21.1"
      - "E:/platform-tools/llvm-ar-21.1.com"
      - "E:/platform-tools/llvm-ar-21.1.exe"
      - "E:/platform-tools/llvm-ar-21.1"
      - "C:/Users/Able/.cargo/bin/llvm-ar-21.1.com"
      - "C:/Users/Able/.cargo/bin/llvm-ar-21.1.exe"
      - "C:/Users/Able/.cargo/bin/llvm-ar-21.1"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ar-21.1.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ar-21.1.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ar-21.1"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ar-21.1.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ar-21.1.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ar-21.1"
      - "E:/GitHub/vcpkg/llvm-ar-21.1.com"
      - "E:/GitHub/vcpkg/llvm-ar-21.1.exe"
      - "E:/GitHub/vcpkg/llvm-ar-21.1"
      - "C:/Users/Able/.dotnet/tools/llvm-ar-21.1.com"
      - "C:/Users/Able/.dotnet/tools/llvm-ar-21.1.exe"
      - "C:/Users/Able/.dotnet/tools/llvm-ar-21.1"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ar-21.1.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ar-21.1.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ar-21.1"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ar-21.1.com"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ar-21.1.exe"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ar-21.1"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ar-21.1.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ar-21.1.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ar-21.1"
      - "C:/Program Files/LLVM/bin/llvm-ar-21.com"
      - "C:/Program Files/LLVM/bin/llvm-ar-21.exe"
      - "C:/Program Files/LLVM/bin/llvm-ar-21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ar-21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ar-21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ar-21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ar-21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ar-21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ar-21"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ar-21.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ar-21.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ar-21"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ar-21.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ar-21.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ar-21"
      - "C:/Python311/Scripts/llvm-ar-21.com"
      - "C:/Python311/Scripts/llvm-ar-21.exe"
      - "C:/Python311/Scripts/llvm-ar-21"
      - "C:/Python311/llvm-ar-21.com"
      - "C:/Python311/llvm-ar-21.exe"
      - "C:/Python311/llvm-ar-21"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ar-21.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ar-21.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ar-21"
      - "C:/Windows/System32/llvm-ar-21.com"
      - "C:/Windows/System32/llvm-ar-21.exe"
      - "C:/Windows/System32/llvm-ar-21"
      - "C:/Windows/llvm-ar-21.com"
      - "C:/Windows/llvm-ar-21.exe"
      - "C:/Windows/llvm-ar-21"
      - "C:/Windows/System32/wbem/llvm-ar-21.com"
      - "C:/Windows/System32/wbem/llvm-ar-21.exe"
      - "C:/Windows/System32/wbem/llvm-ar-21"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ar-21.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ar-21.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ar-21"
      - "C:/Windows/System32/OpenSSH/llvm-ar-21.com"
      - "C:/Windows/System32/OpenSSH/llvm-ar-21.exe"
      - "C:/Windows/System32/OpenSSH/llvm-ar-21"
      - "C:/ProgramData/chocolatey/bin/llvm-ar-21.com"
      - "C:/ProgramData/chocolatey/bin/llvm-ar-21.exe"
      - "C:/ProgramData/chocolatey/bin/llvm-ar-21"
      - "C:/Program Files/PowerShell/7/llvm-ar-21.com"
      - "C:/Program Files/PowerShell/7/llvm-ar-21.exe"
      - "C:/Program Files/PowerShell/7/llvm-ar-21"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ar-21.com"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ar-21.exe"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ar-21"
      - "C:/Program Files/dotnet/llvm-ar-21.com"
      - "C:/Program Files/dotnet/llvm-ar-21.exe"
      - "C:/Program Files/dotnet/llvm-ar-21"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ar-21.com"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ar-21.exe"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ar-21"
      - "C:/ProgramData/nvm/llvm-ar-21.com"
      - "C:/ProgramData/nvm/llvm-ar-21.exe"
      - "C:/ProgramData/nvm/llvm-ar-21"
      - "C:/nvm4w/nodejs/llvm-ar-21.com"
      - "C:/nvm4w/nodejs/llvm-ar-21.exe"
      - "C:/nvm4w/nodejs/llvm-ar-21"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ar-21.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ar-21.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ar-21"
      - "C:/tools/php85/llvm-ar-21.com"
      - "C:/tools/php85/llvm-ar-21.exe"
      - "C:/tools/php85/llvm-ar-21"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ar-21.com"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ar-21.exe"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ar-21"
      - "C:/Program Files/Tailscale/llvm-ar-21.com"
      - "C:/Program Files/Tailscale/llvm-ar-21.exe"
      - "C:/Program Files/Tailscale/llvm-ar-21"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ar-21.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ar-21.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ar-21"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ar-21.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ar-21.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ar-21"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ar-21.com"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ar-21.exe"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ar-21"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ar-21.com"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ar-21.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ar-21"
      - "C:/Program Files/GitHub CLI/llvm-ar-21.com"
      - "C:/Program Files/GitHub CLI/llvm-ar-21.exe"
      - "C:/Program Files/GitHub CLI/llvm-ar-21"
      - "C:/Program Files/CMake/bin/llvm-ar-21.com"
      - "C:/Program Files/CMake/bin/llvm-ar-21.exe"
      - "C:/Program Files/CMake/bin/llvm-ar-21"
      - "C:/Program Files/doxygen/bin/llvm-ar-21.com"
      - "C:/Program Files/doxygen/bin/llvm-ar-21.exe"
      - "C:/Program Files/doxygen/bin/llvm-ar-21"
      - "C:/Users/Able/.local/bin/llvm-ar-21.com"
      - "C:/Users/Able/.local/bin/llvm-ar-21.exe"
      - "C:/Users/Able/.local/bin/llvm-ar-21"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ar-21.com"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ar-21.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ar-21"
      - "C:/Program Files/Git/cmd/llvm-ar-21.com"
      - "C:/Program Files/Git/cmd/llvm-ar-21.exe"
      - "C:/Program Files/Git/cmd/llvm-ar-21"
      - "C:/Program Files/nodejs/llvm-ar-21.com"
      - "C:/Program Files/nodejs/llvm-ar-21.exe"
      - "C:/Program Files/nodejs/llvm-ar-21"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ar-21.com"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ar-21.exe"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ar-21"
      - "E:/platform-tools/llvm-ar-21.com"
      - "E:/platform-tools/llvm-ar-21.exe"
      - "E:/platform-tools/llvm-ar-21"
      - "C:/Users/Able/.cargo/bin/llvm-ar-21.com"
      - "C:/Users/Able/.cargo/bin/llvm-ar-21.exe"
      - "C:/Users/Able/.cargo/bin/llvm-ar-21"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ar-21.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ar-21.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ar-21"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ar-21.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ar-21.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ar-21"
      - "E:/GitHub/vcpkg/llvm-ar-21.com"
      - "E:/GitHub/vcpkg/llvm-ar-21.exe"
      - "E:/GitHub/vcpkg/llvm-ar-21"
      - "C:/Users/Able/.dotnet/tools/llvm-ar-21.com"
      - "C:/Users/Able/.dotnet/tools/llvm-ar-21.exe"
      - "C:/Users/Able/.dotnet/tools/llvm-ar-21"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ar-21.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ar-21.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ar-21"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ar-21.com"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ar-21.exe"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ar-21"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ar-21.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ar-21.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ar-21"
      - "C:/Program Files/LLVM/bin/llvm-ar21.com"
      - "C:/Program Files/LLVM/bin/llvm-ar21.exe"
      - "C:/Program Files/LLVM/bin/llvm-ar21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ar21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ar21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ar21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ar21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ar21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ar21"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ar21.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ar21.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ar21"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ar21.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ar21.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ar21"
      - "C:/Python311/Scripts/llvm-ar21.com"
      - "C:/Python311/Scripts/llvm-ar21.exe"
      - "C:/Python311/Scripts/llvm-ar21"
      - "C:/Python311/llvm-ar21.com"
      - "C:/Python311/llvm-ar21.exe"
      - "C:/Python311/llvm-ar21"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ar21.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ar21.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ar21"
      - "C:/Windows/System32/llvm-ar21.com"
      - "C:/Windows/System32/llvm-ar21.exe"
      - "C:/Windows/System32/llvm-ar21"
      - "C:/Windows/llvm-ar21.com"
      - "C:/Windows/llvm-ar21.exe"
      - "C:/Windows/llvm-ar21"
      - "C:/Windows/System32/wbem/llvm-ar21.com"
      - "C:/Windows/System32/wbem/llvm-ar21.exe"
      - "C:/Windows/System32/wbem/llvm-ar21"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ar21.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ar21.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ar21"
      - "C:/Windows/System32/OpenSSH/llvm-ar21.com"
      - "C:/Windows/System32/OpenSSH/llvm-ar21.exe"
      - "C:/Windows/System32/OpenSSH/llvm-ar21"
      - "C:/ProgramData/chocolatey/bin/llvm-ar21.com"
      - "C:/ProgramData/chocolatey/bin/llvm-ar21.exe"
      - "C:/ProgramData/chocolatey/bin/llvm-ar21"
      - "C:/Program Files/PowerShell/7/llvm-ar21.com"
      - "C:/Program Files/PowerShell/7/llvm-ar21.exe"
      - "C:/Program Files/PowerShell/7/llvm-ar21"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ar21.com"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ar21.exe"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ar21"
      - "C:/Program Files/dotnet/llvm-ar21.com"
      - "C:/Program Files/dotnet/llvm-ar21.exe"
      - "C:/Program Files/dotnet/llvm-ar21"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ar21.com"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ar21.exe"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ar21"
      - "C:/ProgramData/nvm/llvm-ar21.com"
      - "C:/ProgramData/nvm/llvm-ar21.exe"
      - "C:/ProgramData/nvm/llvm-ar21"
      - "C:/nvm4w/nodejs/llvm-ar21.com"
      - "C:/nvm4w/nodejs/llvm-ar21.exe"
      - "C:/nvm4w/nodejs/llvm-ar21"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ar21.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ar21.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ar21"
      - "C:/tools/php85/llvm-ar21.com"
      - "C:/tools/php85/llvm-ar21.exe"
      - "C:/tools/php85/llvm-ar21"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ar21.com"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ar21.exe"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ar21"
      - "C:/Program Files/Tailscale/llvm-ar21.com"
      - "C:/Program Files/Tailscale/llvm-ar21.exe"
      - "C:/Program Files/Tailscale/llvm-ar21"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ar21.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ar21.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ar21"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ar21.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ar21.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ar21"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ar21.com"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ar21.exe"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ar21"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ar21.com"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ar21.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ar21"
      - "C:/Program Files/GitHub CLI/llvm-ar21.com"
      - "C:/Program Files/GitHub CLI/llvm-ar21.exe"
      - "C:/Program Files/GitHub CLI/llvm-ar21"
      - "C:/Program Files/CMake/bin/llvm-ar21.com"
      - "C:/Program Files/CMake/bin/llvm-ar21.exe"
      - "C:/Program Files/CMake/bin/llvm-ar21"
      - "C:/Program Files/doxygen/bin/llvm-ar21.com"
      - "C:/Program Files/doxygen/bin/llvm-ar21.exe"
      - "C:/Program Files/doxygen/bin/llvm-ar21"
      - "C:/Users/Able/.local/bin/llvm-ar21.com"
      - "C:/Users/Able/.local/bin/llvm-ar21.exe"
      - "C:/Users/Able/.local/bin/llvm-ar21"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ar21.com"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ar21.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ar21"
      - "C:/Program Files/Git/cmd/llvm-ar21.com"
      - "C:/Program Files/Git/cmd/llvm-ar21.exe"
      - "C:/Program Files/Git/cmd/llvm-ar21"
      - "C:/Program Files/nodejs/llvm-ar21.com"
      - "C:/Program Files/nodejs/llvm-ar21.exe"
      - "C:/Program Files/nodejs/llvm-ar21"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ar21.com"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ar21.exe"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ar21"
      - "E:/platform-tools/llvm-ar21.com"
      - "E:/platform-tools/llvm-ar21.exe"
      - "E:/platform-tools/llvm-ar21"
      - "C:/Users/Able/.cargo/bin/llvm-ar21.com"
      - "C:/Users/Able/.cargo/bin/llvm-ar21.exe"
      - "C:/Users/Able/.cargo/bin/llvm-ar21"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ar21.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ar21.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ar21"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ar21.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ar21.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ar21"
      - "E:/GitHub/vcpkg/llvm-ar21.com"
      - "E:/GitHub/vcpkg/llvm-ar21.exe"
      - "E:/GitHub/vcpkg/llvm-ar21"
      - "C:/Users/Able/.dotnet/tools/llvm-ar21.com"
      - "C:/Users/Able/.dotnet/tools/llvm-ar21.exe"
      - "C:/Users/Able/.dotnet/tools/llvm-ar21"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ar21.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ar21.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ar21"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ar21.com"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ar21.exe"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ar21"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ar21.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ar21.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ar21"
      - "C:/Program Files/LLVM/bin/llvm-ar.com"
    found: "C:/Program Files/LLVM/bin/llvm-ar.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Compiler/Clang-FindBinUtils.cmake:38 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:207 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "CMAKE_CXX_COMPILER_RANLIB"
    description: "Generate index for LLVM archive"
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: false
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: false
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "llvm-ranlib-21.1"
      - "llvm-ranlib-21"
      - "llvm-ranlib21"
      - "llvm-ranlib"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files/LLVM/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files/LLVM/bin/llvm-ranlib-21.1"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ranlib-21.1.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ranlib-21.1.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ranlib-21.1"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ranlib-21.1.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ranlib-21.1.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ranlib-21.1"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ranlib-21.1"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ranlib-21.1"
      - "C:/Python311/Scripts/llvm-ranlib-21.1.com"
      - "C:/Python311/Scripts/llvm-ranlib-21.1.exe"
      - "C:/Python311/Scripts/llvm-ranlib-21.1"
      - "C:/Python311/llvm-ranlib-21.1.com"
      - "C:/Python311/llvm-ranlib-21.1.exe"
      - "C:/Python311/llvm-ranlib-21.1"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ranlib-21.1"
      - "C:/Windows/System32/llvm-ranlib-21.1.com"
      - "C:/Windows/System32/llvm-ranlib-21.1.exe"
      - "C:/Windows/System32/llvm-ranlib-21.1"
      - "C:/Windows/llvm-ranlib-21.1.com"
      - "C:/Windows/llvm-ranlib-21.1.exe"
      - "C:/Windows/llvm-ranlib-21.1"
      - "C:/Windows/System32/wbem/llvm-ranlib-21.1.com"
      - "C:/Windows/System32/wbem/llvm-ranlib-21.1.exe"
      - "C:/Windows/System32/wbem/llvm-ranlib-21.1"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ranlib-21.1.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ranlib-21.1.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ranlib-21.1"
      - "C:/Windows/System32/OpenSSH/llvm-ranlib-21.1.com"
      - "C:/Windows/System32/OpenSSH/llvm-ranlib-21.1.exe"
      - "C:/Windows/System32/OpenSSH/llvm-ranlib-21.1"
      - "C:/ProgramData/chocolatey/bin/llvm-ranlib-21.1.com"
      - "C:/ProgramData/chocolatey/bin/llvm-ranlib-21.1.exe"
      - "C:/ProgramData/chocolatey/bin/llvm-ranlib-21.1"
      - "C:/Program Files/PowerShell/7/llvm-ranlib-21.1.com"
      - "C:/Program Files/PowerShell/7/llvm-ranlib-21.1.exe"
      - "C:/Program Files/PowerShell/7/llvm-ranlib-21.1"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ranlib-21.1"
      - "C:/Program Files/dotnet/llvm-ranlib-21.1.com"
      - "C:/Program Files/dotnet/llvm-ranlib-21.1.exe"
      - "C:/Program Files/dotnet/llvm-ranlib-21.1"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ranlib-21.1"
      - "C:/ProgramData/nvm/llvm-ranlib-21.1.com"
      - "C:/ProgramData/nvm/llvm-ranlib-21.1.exe"
      - "C:/ProgramData/nvm/llvm-ranlib-21.1"
      - "C:/nvm4w/nodejs/llvm-ranlib-21.1.com"
      - "C:/nvm4w/nodejs/llvm-ranlib-21.1.exe"
      - "C:/nvm4w/nodejs/llvm-ranlib-21.1"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ranlib-21.1.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ranlib-21.1.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ranlib-21.1"
      - "C:/tools/php85/llvm-ranlib-21.1.com"
      - "C:/tools/php85/llvm-ranlib-21.1.exe"
      - "C:/tools/php85/llvm-ranlib-21.1"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ranlib-21.1"
      - "C:/Program Files/Tailscale/llvm-ranlib-21.1.com"
      - "C:/Program Files/Tailscale/llvm-ranlib-21.1.exe"
      - "C:/Program Files/Tailscale/llvm-ranlib-21.1"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ranlib-21.1.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ranlib-21.1.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ranlib-21.1"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ranlib-21.1.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ranlib-21.1.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ranlib-21.1"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ranlib-21.1.com"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ranlib-21.1.exe"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ranlib-21.1"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ranlib-21.1"
      - "C:/Program Files/GitHub CLI/llvm-ranlib-21.1.com"
      - "C:/Program Files/GitHub CLI/llvm-ranlib-21.1.exe"
      - "C:/Program Files/GitHub CLI/llvm-ranlib-21.1"
      - "C:/Program Files/CMake/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files/CMake/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files/CMake/bin/llvm-ranlib-21.1"
      - "C:/Program Files/doxygen/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files/doxygen/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files/doxygen/bin/llvm-ranlib-21.1"
      - "C:/Users/Able/.local/bin/llvm-ranlib-21.1.com"
      - "C:/Users/Able/.local/bin/llvm-ranlib-21.1.exe"
      - "C:/Users/Able/.local/bin/llvm-ranlib-21.1"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ranlib-21.1.com"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ranlib-21.1.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ranlib-21.1"
      - "C:/Program Files/Git/cmd/llvm-ranlib-21.1.com"
      - "C:/Program Files/Git/cmd/llvm-ranlib-21.1.exe"
      - "C:/Program Files/Git/cmd/llvm-ranlib-21.1"
      - "C:/Program Files/nodejs/llvm-ranlib-21.1.com"
      - "C:/Program Files/nodejs/llvm-ranlib-21.1.exe"
      - "C:/Program Files/nodejs/llvm-ranlib-21.1"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ranlib-21.1.com"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ranlib-21.1.exe"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ranlib-21.1"
      - "E:/platform-tools/llvm-ranlib-21.1.com"
      - "E:/platform-tools/llvm-ranlib-21.1.exe"
      - "E:/platform-tools/llvm-ranlib-21.1"
      - "C:/Users/Able/.cargo/bin/llvm-ranlib-21.1.com"
      - "C:/Users/Able/.cargo/bin/llvm-ranlib-21.1.exe"
      - "C:/Users/Able/.cargo/bin/llvm-ranlib-21.1"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ranlib-21.1.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ranlib-21.1.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ranlib-21.1"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ranlib-21.1.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ranlib-21.1.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ranlib-21.1"
      - "E:/GitHub/vcpkg/llvm-ranlib-21.1.com"
      - "E:/GitHub/vcpkg/llvm-ranlib-21.1.exe"
      - "E:/GitHub/vcpkg/llvm-ranlib-21.1"
      - "C:/Users/Able/.dotnet/tools/llvm-ranlib-21.1.com"
      - "C:/Users/Able/.dotnet/tools/llvm-ranlib-21.1.exe"
      - "C:/Users/Able/.dotnet/tools/llvm-ranlib-21.1"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ranlib-21.1.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ranlib-21.1.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ranlib-21.1"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ranlib-21.1.com"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ranlib-21.1.exe"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ranlib-21.1"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ranlib-21.1.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ranlib-21.1.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ranlib-21.1"
      - "C:/Program Files/LLVM/bin/llvm-ranlib-21.com"
      - "C:/Program Files/LLVM/bin/llvm-ranlib-21.exe"
      - "C:/Program Files/LLVM/bin/llvm-ranlib-21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ranlib-21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ranlib-21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ranlib-21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ranlib-21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ranlib-21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ranlib-21"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ranlib-21.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ranlib-21.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ranlib-21"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ranlib-21.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ranlib-21.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ranlib-21"
      - "C:/Python311/Scripts/llvm-ranlib-21.com"
      - "C:/Python311/Scripts/llvm-ranlib-21.exe"
      - "C:/Python311/Scripts/llvm-ranlib-21"
      - "C:/Python311/llvm-ranlib-21.com"
      - "C:/Python311/llvm-ranlib-21.exe"
      - "C:/Python311/llvm-ranlib-21"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ranlib-21.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ranlib-21.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ranlib-21"
      - "C:/Windows/System32/llvm-ranlib-21.com"
      - "C:/Windows/System32/llvm-ranlib-21.exe"
      - "C:/Windows/System32/llvm-ranlib-21"
      - "C:/Windows/llvm-ranlib-21.com"
      - "C:/Windows/llvm-ranlib-21.exe"
      - "C:/Windows/llvm-ranlib-21"
      - "C:/Windows/System32/wbem/llvm-ranlib-21.com"
      - "C:/Windows/System32/wbem/llvm-ranlib-21.exe"
      - "C:/Windows/System32/wbem/llvm-ranlib-21"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ranlib-21.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ranlib-21.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ranlib-21"
      - "C:/Windows/System32/OpenSSH/llvm-ranlib-21.com"
      - "C:/Windows/System32/OpenSSH/llvm-ranlib-21.exe"
      - "C:/Windows/System32/OpenSSH/llvm-ranlib-21"
      - "C:/ProgramData/chocolatey/bin/llvm-ranlib-21.com"
      - "C:/ProgramData/chocolatey/bin/llvm-ranlib-21.exe"
      - "C:/ProgramData/chocolatey/bin/llvm-ranlib-21"
      - "C:/Program Files/PowerShell/7/llvm-ranlib-21.com"
      - "C:/Program Files/PowerShell/7/llvm-ranlib-21.exe"
      - "C:/Program Files/PowerShell/7/llvm-ranlib-21"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ranlib-21.com"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ranlib-21.exe"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ranlib-21"
      - "C:/Program Files/dotnet/llvm-ranlib-21.com"
      - "C:/Program Files/dotnet/llvm-ranlib-21.exe"
      - "C:/Program Files/dotnet/llvm-ranlib-21"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ranlib-21.com"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ranlib-21.exe"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ranlib-21"
      - "C:/ProgramData/nvm/llvm-ranlib-21.com"
      - "C:/ProgramData/nvm/llvm-ranlib-21.exe"
      - "C:/ProgramData/nvm/llvm-ranlib-21"
      - "C:/nvm4w/nodejs/llvm-ranlib-21.com"
      - "C:/nvm4w/nodejs/llvm-ranlib-21.exe"
      - "C:/nvm4w/nodejs/llvm-ranlib-21"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ranlib-21.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ranlib-21.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ranlib-21"
      - "C:/tools/php85/llvm-ranlib-21.com"
      - "C:/tools/php85/llvm-ranlib-21.exe"
      - "C:/tools/php85/llvm-ranlib-21"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ranlib-21.com"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ranlib-21.exe"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ranlib-21"
      - "C:/Program Files/Tailscale/llvm-ranlib-21.com"
      - "C:/Program Files/Tailscale/llvm-ranlib-21.exe"
      - "C:/Program Files/Tailscale/llvm-ranlib-21"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ranlib-21.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ranlib-21.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ranlib-21"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ranlib-21.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ranlib-21.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ranlib-21"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ranlib-21.com"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ranlib-21.exe"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ranlib-21"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ranlib-21.com"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ranlib-21.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ranlib-21"
      - "C:/Program Files/GitHub CLI/llvm-ranlib-21.com"
      - "C:/Program Files/GitHub CLI/llvm-ranlib-21.exe"
      - "C:/Program Files/GitHub CLI/llvm-ranlib-21"
      - "C:/Program Files/CMake/bin/llvm-ranlib-21.com"
      - "C:/Program Files/CMake/bin/llvm-ranlib-21.exe"
      - "C:/Program Files/CMake/bin/llvm-ranlib-21"
      - "C:/Program Files/doxygen/bin/llvm-ranlib-21.com"
      - "C:/Program Files/doxygen/bin/llvm-ranlib-21.exe"
      - "C:/Program Files/doxygen/bin/llvm-ranlib-21"
      - "C:/Users/Able/.local/bin/llvm-ranlib-21.com"
      - "C:/Users/Able/.local/bin/llvm-ranlib-21.exe"
      - "C:/Users/Able/.local/bin/llvm-ranlib-21"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ranlib-21.com"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ranlib-21.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ranlib-21"
      - "C:/Program Files/Git/cmd/llvm-ranlib-21.com"
      - "C:/Program Files/Git/cmd/llvm-ranlib-21.exe"
      - "C:/Program Files/Git/cmd/llvm-ranlib-21"
      - "C:/Program Files/nodejs/llvm-ranlib-21.com"
      - "C:/Program Files/nodejs/llvm-ranlib-21.exe"
      - "C:/Program Files/nodejs/llvm-ranlib-21"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ranlib-21.com"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ranlib-21.exe"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ranlib-21"
      - "E:/platform-tools/llvm-ranlib-21.com"
      - "E:/platform-tools/llvm-ranlib-21.exe"
      - "E:/platform-tools/llvm-ranlib-21"
      - "C:/Users/Able/.cargo/bin/llvm-ranlib-21.com"
      - "C:/Users/Able/.cargo/bin/llvm-ranlib-21.exe"
      - "C:/Users/Able/.cargo/bin/llvm-ranlib-21"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ranlib-21.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ranlib-21.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ranlib-21"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ranlib-21.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ranlib-21.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ranlib-21"
      - "E:/GitHub/vcpkg/llvm-ranlib-21.com"
      - "E:/GitHub/vcpkg/llvm-ranlib-21.exe"
      - "E:/GitHub/vcpkg/llvm-ranlib-21"
      - "C:/Users/Able/.dotnet/tools/llvm-ranlib-21.com"
      - "C:/Users/Able/.dotnet/tools/llvm-ranlib-21.exe"
      - "C:/Users/Able/.dotnet/tools/llvm-ranlib-21"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ranlib-21.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ranlib-21.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ranlib-21"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ranlib-21.com"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ranlib-21.exe"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ranlib-21"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ranlib-21.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ranlib-21.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ranlib-21"
      - "C:/Program Files/LLVM/bin/llvm-ranlib21.com"
      - "C:/Program Files/LLVM/bin/llvm-ranlib21.exe"
      - "C:/Program Files/LLVM/bin/llvm-ranlib21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ranlib21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ranlib21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/llvm-ranlib21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ranlib21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ranlib21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/llvm-ranlib21"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ranlib21.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ranlib21.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/llvm-ranlib21"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ranlib21.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ranlib21.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/llvm-ranlib21"
      - "C:/Python311/Scripts/llvm-ranlib21.com"
      - "C:/Python311/Scripts/llvm-ranlib21.exe"
      - "C:/Python311/Scripts/llvm-ranlib21"
      - "C:/Python311/llvm-ranlib21.com"
      - "C:/Python311/llvm-ranlib21.exe"
      - "C:/Python311/llvm-ranlib21"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ranlib21.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ranlib21.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/llvm-ranlib21"
      - "C:/Windows/System32/llvm-ranlib21.com"
      - "C:/Windows/System32/llvm-ranlib21.exe"
      - "C:/Windows/System32/llvm-ranlib21"
      - "C:/Windows/llvm-ranlib21.com"
      - "C:/Windows/llvm-ranlib21.exe"
      - "C:/Windows/llvm-ranlib21"
      - "C:/Windows/System32/wbem/llvm-ranlib21.com"
      - "C:/Windows/System32/wbem/llvm-ranlib21.exe"
      - "C:/Windows/System32/wbem/llvm-ranlib21"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ranlib21.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ranlib21.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/llvm-ranlib21"
      - "C:/Windows/System32/OpenSSH/llvm-ranlib21.com"
      - "C:/Windows/System32/OpenSSH/llvm-ranlib21.exe"
      - "C:/Windows/System32/OpenSSH/llvm-ranlib21"
      - "C:/ProgramData/chocolatey/bin/llvm-ranlib21.com"
      - "C:/ProgramData/chocolatey/bin/llvm-ranlib21.exe"
      - "C:/ProgramData/chocolatey/bin/llvm-ranlib21"
      - "C:/Program Files/PowerShell/7/llvm-ranlib21.com"
      - "C:/Program Files/PowerShell/7/llvm-ranlib21.exe"
      - "C:/Program Files/PowerShell/7/llvm-ranlib21"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ranlib21.com"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ranlib21.exe"
      - "C:/Program Files (x86)/LLVM/bin/llvm-ranlib21"
      - "C:/Program Files/dotnet/llvm-ranlib21.com"
      - "C:/Program Files/dotnet/llvm-ranlib21.exe"
      - "C:/Program Files/dotnet/llvm-ranlib21"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ranlib21.com"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ranlib21.exe"
      - "C:/Program Files (x86)/Yarn/bin/llvm-ranlib21"
      - "C:/ProgramData/nvm/llvm-ranlib21.com"
      - "C:/ProgramData/nvm/llvm-ranlib21.exe"
      - "C:/ProgramData/nvm/llvm-ranlib21"
      - "C:/nvm4w/nodejs/llvm-ranlib21.com"
      - "C:/nvm4w/nodejs/llvm-ranlib21.exe"
      - "C:/nvm4w/nodejs/llvm-ranlib21"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ranlib21.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ranlib21.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/llvm-ranlib21"
      - "C:/tools/php85/llvm-ranlib21.com"
      - "C:/tools/php85/llvm-ranlib21.exe"
      - "C:/tools/php85/llvm-ranlib21"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ranlib21.com"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ranlib21.exe"
      - "C:/Program Files/Microsoft VS Code/bin/llvm-ranlib21"
      - "C:/Program Files/Tailscale/llvm-ranlib21.com"
      - "C:/Program Files/Tailscale/llvm-ranlib21.exe"
      - "C:/Program Files/Tailscale/llvm-ranlib21"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ranlib21.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ranlib21.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/llvm-ranlib21"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ranlib21.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ranlib21.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/llvm-ranlib21"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ranlib21.com"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ranlib21.exe"
      - "C:/Program Files/Mullvad VPN/resources/llvm-ranlib21"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ranlib21.com"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ranlib21.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/llvm-ranlib21"
      - "C:/Program Files/GitHub CLI/llvm-ranlib21.com"
      - "C:/Program Files/GitHub CLI/llvm-ranlib21.exe"
      - "C:/Program Files/GitHub CLI/llvm-ranlib21"
      - "C:/Program Files/CMake/bin/llvm-ranlib21.com"
      - "C:/Program Files/CMake/bin/llvm-ranlib21.exe"
      - "C:/Program Files/CMake/bin/llvm-ranlib21"
      - "C:/Program Files/doxygen/bin/llvm-ranlib21.com"
      - "C:/Program Files/doxygen/bin/llvm-ranlib21.exe"
      - "C:/Program Files/doxygen/bin/llvm-ranlib21"
      - "C:/Users/Able/.local/bin/llvm-ranlib21.com"
      - "C:/Users/Able/.local/bin/llvm-ranlib21.exe"
      - "C:/Users/Able/.local/bin/llvm-ranlib21"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ranlib21.com"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ranlib21.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/llvm-ranlib21"
      - "C:/Program Files/Git/cmd/llvm-ranlib21.com"
      - "C:/Program Files/Git/cmd/llvm-ranlib21.exe"
      - "C:/Program Files/Git/cmd/llvm-ranlib21"
      - "C:/Program Files/nodejs/llvm-ranlib21.com"
      - "C:/Program Files/nodejs/llvm-ranlib21.exe"
      - "C:/Program Files/nodejs/llvm-ranlib21"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ranlib21.com"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ranlib21.exe"
      - "C:/Program Files/PowerToys/DSCModules/llvm-ranlib21"
      - "E:/platform-tools/llvm-ranlib21.com"
      - "E:/platform-tools/llvm-ranlib21.exe"
      - "E:/platform-tools/llvm-ranlib21"
      - "C:/Users/Able/.cargo/bin/llvm-ranlib21.com"
      - "C:/Users/Able/.cargo/bin/llvm-ranlib21.exe"
      - "C:/Users/Able/.cargo/bin/llvm-ranlib21"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ranlib21.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ranlib21.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/llvm-ranlib21"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ranlib21.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ranlib21.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/llvm-ranlib21"
      - "E:/GitHub/vcpkg/llvm-ranlib21.com"
      - "E:/GitHub/vcpkg/llvm-ranlib21.exe"
      - "E:/GitHub/vcpkg/llvm-ranlib21"
      - "C:/Users/Able/.dotnet/tools/llvm-ranlib21.com"
      - "C:/Users/Able/.dotnet/tools/llvm-ranlib21.exe"
      - "C:/Users/Able/.dotnet/tools/llvm-ranlib21"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ranlib21.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ranlib21.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/llvm-ranlib21"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ranlib21.com"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ranlib21.exe"
      - "C:/Users/Able/AppData/Roaming/npm/llvm-ranlib21"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ranlib21.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ranlib21.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/llvm-ranlib21"
      - "C:/Program Files/LLVM/bin/llvm-ranlib.com"
    found: "C:/Program Files/LLVM/bin/llvm-ranlib.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Compiler/Clang-FindBinUtils.cmake:50 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCXXCompiler.cmake:207 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "CMAKE_CXX_COMPILER_CLANG_SCAN_DEPS"
    description: "`clang-scan-deps` dependency scanner"
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: false
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: false
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "clang-scan-deps-21.1"
      - "clang-scan-deps-21"
      - "clang-scan-deps21"
      - "clang-scan-deps"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files/LLVM/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files/LLVM/bin/clang-scan-deps-21.1"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/clang-scan-deps-21.1.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/clang-scan-deps-21.1.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/clang-scan-deps-21.1"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/clang-scan-deps-21.1.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/clang-scan-deps-21.1.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/clang-scan-deps-21.1"
      - "C:/Program Files (x86)/oh-my-posh/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/clang-scan-deps-21.1"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/clang-scan-deps-21.1"
      - "C:/Python311/Scripts/clang-scan-deps-21.1.com"
      - "C:/Python311/Scripts/clang-scan-deps-21.1.exe"
      - "C:/Python311/Scripts/clang-scan-deps-21.1"
      - "C:/Python311/clang-scan-deps-21.1.com"
      - "C:/Python311/clang-scan-deps-21.1.exe"
      - "C:/Python311/clang-scan-deps-21.1"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/clang-scan-deps-21.1"
      - "C:/Windows/System32/clang-scan-deps-21.1.com"
      - "C:/Windows/System32/clang-scan-deps-21.1.exe"
      - "C:/Windows/System32/clang-scan-deps-21.1"
      - "C:/Windows/clang-scan-deps-21.1.com"
      - "C:/Windows/clang-scan-deps-21.1.exe"
      - "C:/Windows/clang-scan-deps-21.1"
      - "C:/Windows/System32/wbem/clang-scan-deps-21.1.com"
      - "C:/Windows/System32/wbem/clang-scan-deps-21.1.exe"
      - "C:/Windows/System32/wbem/clang-scan-deps-21.1"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/clang-scan-deps-21.1.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/clang-scan-deps-21.1.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/clang-scan-deps-21.1"
      - "C:/Windows/System32/OpenSSH/clang-scan-deps-21.1.com"
      - "C:/Windows/System32/OpenSSH/clang-scan-deps-21.1.exe"
      - "C:/Windows/System32/OpenSSH/clang-scan-deps-21.1"
      - "C:/ProgramData/chocolatey/bin/clang-scan-deps-21.1.com"
      - "C:/ProgramData/chocolatey/bin/clang-scan-deps-21.1.exe"
      - "C:/ProgramData/chocolatey/bin/clang-scan-deps-21.1"
      - "C:/Program Files/PowerShell/7/clang-scan-deps-21.1.com"
      - "C:/Program Files/PowerShell/7/clang-scan-deps-21.1.exe"
      - "C:/Program Files/PowerShell/7/clang-scan-deps-21.1"
      - "C:/Program Files (x86)/LLVM/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files (x86)/LLVM/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files (x86)/LLVM/bin/clang-scan-deps-21.1"
      - "C:/Program Files/dotnet/clang-scan-deps-21.1.com"
      - "C:/Program Files/dotnet/clang-scan-deps-21.1.exe"
      - "C:/Program Files/dotnet/clang-scan-deps-21.1"
      - "C:/Program Files (x86)/Yarn/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files (x86)/Yarn/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files (x86)/Yarn/bin/clang-scan-deps-21.1"
      - "C:/ProgramData/nvm/clang-scan-deps-21.1.com"
      - "C:/ProgramData/nvm/clang-scan-deps-21.1.exe"
      - "C:/ProgramData/nvm/clang-scan-deps-21.1"
      - "C:/nvm4w/nodejs/clang-scan-deps-21.1.com"
      - "C:/nvm4w/nodejs/clang-scan-deps-21.1.exe"
      - "C:/nvm4w/nodejs/clang-scan-deps-21.1"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/clang-scan-deps-21.1.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/clang-scan-deps-21.1.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/clang-scan-deps-21.1"
      - "C:/tools/php85/clang-scan-deps-21.1.com"
      - "C:/tools/php85/clang-scan-deps-21.1.exe"
      - "C:/tools/php85/clang-scan-deps-21.1"
      - "C:/Program Files/Microsoft VS Code/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files/Microsoft VS Code/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files/Microsoft VS Code/bin/clang-scan-deps-21.1"
      - "C:/Program Files/Tailscale/clang-scan-deps-21.1.com"
      - "C:/Program Files/Tailscale/clang-scan-deps-21.1.exe"
      - "C:/Program Files/Tailscale/clang-scan-deps-21.1"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/clang-scan-deps-21.1.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/clang-scan-deps-21.1.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/clang-scan-deps-21.1"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/clang-scan-deps-21.1.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/clang-scan-deps-21.1.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/clang-scan-deps-21.1"
      - "C:/Program Files/Mullvad VPN/resources/clang-scan-deps-21.1.com"
      - "C:/Program Files/Mullvad VPN/resources/clang-scan-deps-21.1.exe"
      - "C:/Program Files/Mullvad VPN/resources/clang-scan-deps-21.1"
      - "C:/Program Files/OpenSSL-Win64/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files/OpenSSL-Win64/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/clang-scan-deps-21.1"
      - "C:/Program Files/GitHub CLI/clang-scan-deps-21.1.com"
      - "C:/Program Files/GitHub CLI/clang-scan-deps-21.1.exe"
      - "C:/Program Files/GitHub CLI/clang-scan-deps-21.1"
      - "C:/Program Files/CMake/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files/CMake/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files/CMake/bin/clang-scan-deps-21.1"
      - "C:/Program Files/doxygen/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files/doxygen/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files/doxygen/bin/clang-scan-deps-21.1"
      - "C:/Users/Able/.local/bin/clang-scan-deps-21.1.com"
      - "C:/Users/Able/.local/bin/clang-scan-deps-21.1.exe"
      - "C:/Users/Able/.local/bin/clang-scan-deps-21.1"
      - "C:/Program Files/Docker/Docker/resources/bin/clang-scan-deps-21.1.com"
      - "C:/Program Files/Docker/Docker/resources/bin/clang-scan-deps-21.1.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/clang-scan-deps-21.1"
      - "C:/Program Files/Git/cmd/clang-scan-deps-21.1.com"
      - "C:/Program Files/Git/cmd/clang-scan-deps-21.1.exe"
      - "C:/Program Files/Git/cmd/clang-scan-deps-21.1"
      - "C:/Program Files/nodejs/clang-scan-deps-21.1.com"
      - "C:/Program Files/nodejs/clang-scan-deps-21.1.exe"
      - "C:/Program Files/nodejs/clang-scan-deps-21.1"
      - "C:/Program Files/PowerToys/DSCModules/clang-scan-deps-21.1.com"
      - "C:/Program Files/PowerToys/DSCModules/clang-scan-deps-21.1.exe"
      - "C:/Program Files/PowerToys/DSCModules/clang-scan-deps-21.1"
      - "E:/platform-tools/clang-scan-deps-21.1.com"
      - "E:/platform-tools/clang-scan-deps-21.1.exe"
      - "E:/platform-tools/clang-scan-deps-21.1"
      - "C:/Users/Able/.cargo/bin/clang-scan-deps-21.1.com"
      - "C:/Users/Able/.cargo/bin/clang-scan-deps-21.1.exe"
      - "C:/Users/Able/.cargo/bin/clang-scan-deps-21.1"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/clang-scan-deps-21.1.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/clang-scan-deps-21.1.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/clang-scan-deps-21.1"
      - "C:/Users/Able/AppData/Local/Yarn/bin/clang-scan-deps-21.1.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/clang-scan-deps-21.1.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/clang-scan-deps-21.1"
      - "E:/GitHub/vcpkg/clang-scan-deps-21.1.com"
      - "E:/GitHub/vcpkg/clang-scan-deps-21.1.exe"
      - "E:/GitHub/vcpkg/clang-scan-deps-21.1"
      - "C:/Users/Able/.dotnet/tools/clang-scan-deps-21.1.com"
      - "C:/Users/Able/.dotnet/tools/clang-scan-deps-21.1.exe"
      - "C:/Users/Able/.dotnet/tools/clang-scan-deps-21.1"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/clang-scan-deps-21.1.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/clang-scan-deps-21.1.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/clang-scan-deps-21.1"
      - "C:/Users/Able/AppData/Roaming/npm/clang-scan-deps-21.1.com"
      - "C:/Users/Able/AppData/Roaming/npm/clang-scan-deps-21.1.exe"
      - "C:/Users/Able/AppData/Roaming/npm/clang-scan-deps-21.1"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/clang-scan-deps-21.1.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/clang-scan-deps-21.1.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/clang-scan-deps-21.1"
      - "C:/Program Files/LLVM/bin/clang-scan-deps-21.com"
      - "C:/Program Files/LLVM/bin/clang-scan-deps-21.exe"
      - "C:/Program Files/LLVM/bin/clang-scan-deps-21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/clang-scan-deps-21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/clang-scan-deps-21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/clang-scan-deps-21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/clang-scan-deps-21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/clang-scan-deps-21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/clang-scan-deps-21"
      - "C:/Program Files (x86)/oh-my-posh/bin/clang-scan-deps-21.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/clang-scan-deps-21.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/clang-scan-deps-21"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/clang-scan-deps-21.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/clang-scan-deps-21.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/clang-scan-deps-21"
      - "C:/Python311/Scripts/clang-scan-deps-21.com"
      - "C:/Python311/Scripts/clang-scan-deps-21.exe"
      - "C:/Python311/Scripts/clang-scan-deps-21"
      - "C:/Python311/clang-scan-deps-21.com"
      - "C:/Python311/clang-scan-deps-21.exe"
      - "C:/Python311/clang-scan-deps-21"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/clang-scan-deps-21.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/clang-scan-deps-21.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/clang-scan-deps-21"
      - "C:/Windows/System32/clang-scan-deps-21.com"
      - "C:/Windows/System32/clang-scan-deps-21.exe"
      - "C:/Windows/System32/clang-scan-deps-21"
      - "C:/Windows/clang-scan-deps-21.com"
      - "C:/Windows/clang-scan-deps-21.exe"
      - "C:/Windows/clang-scan-deps-21"
      - "C:/Windows/System32/wbem/clang-scan-deps-21.com"
      - "C:/Windows/System32/wbem/clang-scan-deps-21.exe"
      - "C:/Windows/System32/wbem/clang-scan-deps-21"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/clang-scan-deps-21.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/clang-scan-deps-21.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/clang-scan-deps-21"
      - "C:/Windows/System32/OpenSSH/clang-scan-deps-21.com"
      - "C:/Windows/System32/OpenSSH/clang-scan-deps-21.exe"
      - "C:/Windows/System32/OpenSSH/clang-scan-deps-21"
      - "C:/ProgramData/chocolatey/bin/clang-scan-deps-21.com"
      - "C:/ProgramData/chocolatey/bin/clang-scan-deps-21.exe"
      - "C:/ProgramData/chocolatey/bin/clang-scan-deps-21"
      - "C:/Program Files/PowerShell/7/clang-scan-deps-21.com"
      - "C:/Program Files/PowerShell/7/clang-scan-deps-21.exe"
      - "C:/Program Files/PowerShell/7/clang-scan-deps-21"
      - "C:/Program Files (x86)/LLVM/bin/clang-scan-deps-21.com"
      - "C:/Program Files (x86)/LLVM/bin/clang-scan-deps-21.exe"
      - "C:/Program Files (x86)/LLVM/bin/clang-scan-deps-21"
      - "C:/Program Files/dotnet/clang-scan-deps-21.com"
      - "C:/Program Files/dotnet/clang-scan-deps-21.exe"
      - "C:/Program Files/dotnet/clang-scan-deps-21"
      - "C:/Program Files (x86)/Yarn/bin/clang-scan-deps-21.com"
      - "C:/Program Files (x86)/Yarn/bin/clang-scan-deps-21.exe"
      - "C:/Program Files (x86)/Yarn/bin/clang-scan-deps-21"
      - "C:/ProgramData/nvm/clang-scan-deps-21.com"
      - "C:/ProgramData/nvm/clang-scan-deps-21.exe"
      - "C:/ProgramData/nvm/clang-scan-deps-21"
      - "C:/nvm4w/nodejs/clang-scan-deps-21.com"
      - "C:/nvm4w/nodejs/clang-scan-deps-21.exe"
      - "C:/nvm4w/nodejs/clang-scan-deps-21"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/clang-scan-deps-21.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/clang-scan-deps-21.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/clang-scan-deps-21"
      - "C:/tools/php85/clang-scan-deps-21.com"
      - "C:/tools/php85/clang-scan-deps-21.exe"
      - "C:/tools/php85/clang-scan-deps-21"
      - "C:/Program Files/Microsoft VS Code/bin/clang-scan-deps-21.com"
      - "C:/Program Files/Microsoft VS Code/bin/clang-scan-deps-21.exe"
      - "C:/Program Files/Microsoft VS Code/bin/clang-scan-deps-21"
      - "C:/Program Files/Tailscale/clang-scan-deps-21.com"
      - "C:/Program Files/Tailscale/clang-scan-deps-21.exe"
      - "C:/Program Files/Tailscale/clang-scan-deps-21"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/clang-scan-deps-21.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/clang-scan-deps-21.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/clang-scan-deps-21"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/clang-scan-deps-21.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/clang-scan-deps-21.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/clang-scan-deps-21"
      - "C:/Program Files/Mullvad VPN/resources/clang-scan-deps-21.com"
      - "C:/Program Files/Mullvad VPN/resources/clang-scan-deps-21.exe"
      - "C:/Program Files/Mullvad VPN/resources/clang-scan-deps-21"
      - "C:/Program Files/OpenSSL-Win64/bin/clang-scan-deps-21.com"
      - "C:/Program Files/OpenSSL-Win64/bin/clang-scan-deps-21.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/clang-scan-deps-21"
      - "C:/Program Files/GitHub CLI/clang-scan-deps-21.com"
      - "C:/Program Files/GitHub CLI/clang-scan-deps-21.exe"
      - "C:/Program Files/GitHub CLI/clang-scan-deps-21"
      - "C:/Program Files/CMake/bin/clang-scan-deps-21.com"
      - "C:/Program Files/CMake/bin/clang-scan-deps-21.exe"
      - "C:/Program Files/CMake/bin/clang-scan-deps-21"
      - "C:/Program Files/doxygen/bin/clang-scan-deps-21.com"
      - "C:/Program Files/doxygen/bin/clang-scan-deps-21.exe"
      - "C:/Program Files/doxygen/bin/clang-scan-deps-21"
      - "C:/Users/Able/.local/bin/clang-scan-deps-21.com"
      - "C:/Users/Able/.local/bin/clang-scan-deps-21.exe"
      - "C:/Users/Able/.local/bin/clang-scan-deps-21"
      - "C:/Program Files/Docker/Docker/resources/bin/clang-scan-deps-21.com"
      - "C:/Program Files/Docker/Docker/resources/bin/clang-scan-deps-21.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/clang-scan-deps-21"
      - "C:/Program Files/Git/cmd/clang-scan-deps-21.com"
      - "C:/Program Files/Git/cmd/clang-scan-deps-21.exe"
      - "C:/Program Files/Git/cmd/clang-scan-deps-21"
      - "C:/Program Files/nodejs/clang-scan-deps-21.com"
      - "C:/Program Files/nodejs/clang-scan-deps-21.exe"
      - "C:/Program Files/nodejs/clang-scan-deps-21"
      - "C:/Program Files/PowerToys/DSCModules/clang-scan-deps-21.com"
      - "C:/Program Files/PowerToys/DSCModules/clang-scan-deps-21.exe"
      - "C:/Program Files/PowerToys/DSCModules/clang-scan-deps-21"
      - "E:/platform-tools/clang-scan-deps-21.com"
      - "E:/platform-tools/clang-scan-deps-21.exe"
      - "E:/platform-tools/clang-scan-deps-21"
      - "C:/Users/Able/.cargo/bin/clang-scan-deps-21.com"
      - "C:/Users/Able/.cargo/bin/clang-scan-deps-21.exe"
      - "C:/Users/Able/.cargo/bin/clang-scan-deps-21"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/clang-scan-deps-21.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/clang-scan-deps-21.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/clang-scan-deps-21"
      - "C:/Users/Able/AppData/Local/Yarn/bin/clang-scan-deps-21.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/clang-scan-deps-21.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/clang-scan-deps-21"
      - "E:/GitHub/vcpkg/clang-scan-deps-21.com"
      - "E:/GitHub/vcpkg/clang-scan-deps-21.exe"
      - "E:/GitHub/vcpkg/clang-scan-deps-21"
      - "C:/Users/Able/.dotnet/tools/clang-scan-deps-21.com"
      - "C:/Users/Able/.dotnet/tools/clang-scan-deps-21.exe"
      - "C:/Users/Able/.dotnet/tools/clang-scan-deps-21"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/clang-scan-deps-21.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/clang-scan-deps-21.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/clang-scan-deps-21"
      - "C:/Users/Able/AppData/Roaming/npm/clang-scan-deps-21.com"
      - "C:/Users/Able/AppData/Roaming/npm/clang-scan-deps-21.exe"
      - "C:/Users/Able/AppData/Roaming/npm/clang-scan-deps-21"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/clang-scan-deps-21.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/clang-scan-deps-21.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/clang-scan-deps-21"
      - "C:/Program Files/LLVM/bin/clang-scan-deps21.com"
      - "C:/Program Files/LLVM/bin/clang-scan-deps21.exe"
      - "C:/Program Files/LLVM/bin/clang-scan-deps21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/clang-scan-deps21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/clang-scan-deps21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/clang-scan-deps21"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/clang-scan-deps21.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/clang-scan-deps21.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/clang-scan-deps21"
      - "C:/Program Files (x86)/oh-my-posh/bin/clang-scan-deps21.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/clang-scan-deps21.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/clang-scan-deps21"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/clang-scan-deps21.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/clang-scan-deps21.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/clang-scan-deps21"
      - "C:/Python311/Scripts/clang-scan-deps21.com"
      - "C:/Python311/Scripts/clang-scan-deps21.exe"
      - "C:/Python311/Scripts/clang-scan-deps21"
      - "C:/Python311/clang-scan-deps21.com"
      - "C:/Python311/clang-scan-deps21.exe"
      - "C:/Python311/clang-scan-deps21"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/clang-scan-deps21.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/clang-scan-deps21.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/clang-scan-deps21"
      - "C:/Windows/System32/clang-scan-deps21.com"
      - "C:/Windows/System32/clang-scan-deps21.exe"
      - "C:/Windows/System32/clang-scan-deps21"
      - "C:/Windows/clang-scan-deps21.com"
      - "C:/Windows/clang-scan-deps21.exe"
      - "C:/Windows/clang-scan-deps21"
      - "C:/Windows/System32/wbem/clang-scan-deps21.com"
      - "C:/Windows/System32/wbem/clang-scan-deps21.exe"
      - "C:/Windows/System32/wbem/clang-scan-deps21"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/clang-scan-deps21.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/clang-scan-deps21.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/clang-scan-deps21"
      - "C:/Windows/System32/OpenSSH/clang-scan-deps21.com"
      - "C:/Windows/System32/OpenSSH/clang-scan-deps21.exe"
      - "C:/Windows/System32/OpenSSH/clang-scan-deps21"
      - "C:/ProgramData/chocolatey/bin/clang-scan-deps21.com"
      - "C:/ProgramData/chocolatey/bin/clang-scan-deps21.exe"
      - "C:/ProgramData/chocolatey/bin/clang-scan-deps21"
      - "C:/Program Files/PowerShell/7/clang-scan-deps21.com"
      - "C:/Program Files/PowerShell/7/clang-scan-deps21.exe"
      - "C:/Program Files/PowerShell/7/clang-scan-deps21"
      - "C:/Program Files (x86)/LLVM/bin/clang-scan-deps21.com"
      - "C:/Program Files (x86)/LLVM/bin/clang-scan-deps21.exe"
      - "C:/Program Files (x86)/LLVM/bin/clang-scan-deps21"
      - "C:/Program Files/dotnet/clang-scan-deps21.com"
      - "C:/Program Files/dotnet/clang-scan-deps21.exe"
      - "C:/Program Files/dotnet/clang-scan-deps21"
      - "C:/Program Files (x86)/Yarn/bin/clang-scan-deps21.com"
      - "C:/Program Files (x86)/Yarn/bin/clang-scan-deps21.exe"
      - "C:/Program Files (x86)/Yarn/bin/clang-scan-deps21"
      - "C:/ProgramData/nvm/clang-scan-deps21.com"
      - "C:/ProgramData/nvm/clang-scan-deps21.exe"
      - "C:/ProgramData/nvm/clang-scan-deps21"
      - "C:/nvm4w/nodejs/clang-scan-deps21.com"
      - "C:/nvm4w/nodejs/clang-scan-deps21.exe"
      - "C:/nvm4w/nodejs/clang-scan-deps21"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/clang-scan-deps21.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/clang-scan-deps21.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/clang-scan-deps21"
      - "C:/tools/php85/clang-scan-deps21.com"
      - "C:/tools/php85/clang-scan-deps21.exe"
      - "C:/tools/php85/clang-scan-deps21"
      - "C:/Program Files/Microsoft VS Code/bin/clang-scan-deps21.com"
      - "C:/Program Files/Microsoft VS Code/bin/clang-scan-deps21.exe"
      - "C:/Program Files/Microsoft VS Code/bin/clang-scan-deps21"
      - "C:/Program Files/Tailscale/clang-scan-deps21.com"
      - "C:/Program Files/Tailscale/clang-scan-deps21.exe"
      - "C:/Program Files/Tailscale/clang-scan-deps21"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/clang-scan-deps21.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/clang-scan-deps21.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/clang-scan-deps21"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/clang-scan-deps21.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/clang-scan-deps21.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/clang-scan-deps21"
      - "C:/Program Files/Mullvad VPN/resources/clang-scan-deps21.com"
      - "C:/Program Files/Mullvad VPN/resources/clang-scan-deps21.exe"
      - "C:/Program Files/Mullvad VPN/resources/clang-scan-deps21"
      - "C:/Program Files/OpenSSL-Win64/bin/clang-scan-deps21.com"
      - "C:/Program Files/OpenSSL-Win64/bin/clang-scan-deps21.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/clang-scan-deps21"
      - "C:/Program Files/GitHub CLI/clang-scan-deps21.com"
      - "C:/Program Files/GitHub CLI/clang-scan-deps21.exe"
      - "C:/Program Files/GitHub CLI/clang-scan-deps21"
      - "C:/Program Files/CMake/bin/clang-scan-deps21.com"
      - "C:/Program Files/CMake/bin/clang-scan-deps21.exe"
      - "C:/Program Files/CMake/bin/clang-scan-deps21"
      - "C:/Program Files/doxygen/bin/clang-scan-deps21.com"
      - "C:/Program Files/doxygen/bin/clang-scan-deps21.exe"
      - "C:/Program Files/doxygen/bin/clang-scan-deps21"
      - "C:/Users/Able/.local/bin/clang-scan-deps21.com"
      - "C:/Users/Able/.local/bin/clang-scan-deps21.exe"
      - "C:/Users/Able/.local/bin/clang-scan-deps21"
      - "C:/Program Files/Docker/Docker/resources/bin/clang-scan-deps21.com"
      - "C:/Program Files/Docker/Docker/resources/bin/clang-scan-deps21.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/clang-scan-deps21"
      - "C:/Program Files/Git/cmd/clang-scan-deps21.com"
      - "C:/Program Files/Git/cmd/clang-scan-deps21.exe"
      - "C:/Program Files/Git/cmd/clang-scan-deps21"
      - "C:/Program Files/nodejs/clang-scan-deps21.com"
      - "C:/Program Files/nodejs/clang-scan-deps21.exe"
      - "C:/Program Files/nodejs/clang-scan-deps21"
      - "C:/Program Files/PowerToys/DSCModules/clang-scan-deps21.com"
      - "C:/Program Files/PowerToys/DSCModules/clang-scan-deps21.exe"
      - "C:/Program Files/PowerToys/DSCModules/clang-scan-deps21"
      - "E:/platform-tools/clang-scan-deps21.com"
      - "E:/platform-tools/clang-scan-deps21.exe"
      - "E:/platform-tools/clang-scan-deps21"
      - "C:/Users/Able/.cargo/bin/clang-scan-deps21.com"
      - "C:/Users/Able/.cargo/bin/clang-scan-deps21.exe"
      - "C:/Users/Able/.cargo/bin/clang-scan-deps21"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/clang-scan-deps21.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/clang-scan-deps21.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/clang-scan-deps21"
      - "C:/Users/Able/AppData/Local/Yarn/bin/clang-scan-deps21.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/clang-scan-deps21.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/clang-scan-deps21"
      - "E:/GitHub/vcpkg/clang-scan-deps21.com"
      - "E:/GitHub/vcpkg/clang-scan-deps21.exe"
      - "E:/GitHub/vcpkg/clang-scan-deps21"
      - "C:/Users/Able/.dotnet/tools/clang-scan-deps21.com"
      - "C:/Users/Able/.dotnet/tools/clang-scan-deps21.exe"
      - "C:/Users/Able/.dotnet/tools/clang-scan-deps21"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/clang-scan-deps21.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/clang-scan-deps21.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/clang-scan-deps21"
      - "C:/Users/Able/AppData/Roaming/npm/clang-scan-deps21.com"
      - "C:/Users/Able/AppData/Roaming/npm/clang-scan-deps21.exe"
      - "C:/Users/Able/AppData/Roaming/npm/clang-scan-deps21"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/clang-scan-deps21.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/clang-scan-deps21.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/clang-scan-deps21"
      - "C:/Program Files/LLVM/bin/clang-scan-deps.com"
    found: "C:/Program Files/LLVM/bin/clang-scan-deps.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang.cmake:210 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang-CXX.cmake:1 (include)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeCXXInformation.cmake:48 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "__RC_COMPILER_PATH"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: true
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "rc"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
      - "C:/Program Files/bin/"
      - "C:/Program Files/sbin/"
      - "C:/Program Files/"
      - "C:/Program Files (x86)/bin/"
      - "C:/Program Files (x86)/sbin/"
      - "C:/Program Files (x86)/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/CMake/sbin/"
      - "C:/Program Files/CMake/"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/"
      - "C:/Program Files (x86)/x64dbg_mcp/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/rc.com"
      - "C:/Program Files/LLVM/bin/rc.exe"
      - "C:/Program Files/LLVM/bin/rc"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/rc.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/rc.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/rc"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/rc.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/rc.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/rc"
      - "C:/Program Files (x86)/oh-my-posh/bin/rc.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/rc.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/rc"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/rc.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/rc.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/rc"
      - "C:/Python311/Scripts/rc.com"
      - "C:/Python311/Scripts/rc.exe"
      - "C:/Python311/Scripts/rc"
      - "C:/Python311/rc.com"
      - "C:/Python311/rc.exe"
      - "C:/Python311/rc"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/rc.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/rc.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/rc"
      - "C:/Windows/System32/rc.com"
      - "C:/Windows/System32/rc.exe"
      - "C:/Windows/System32/rc"
      - "C:/Windows/rc.com"
      - "C:/Windows/rc.exe"
      - "C:/Windows/rc"
      - "C:/Windows/System32/wbem/rc.com"
      - "C:/Windows/System32/wbem/rc.exe"
      - "C:/Windows/System32/wbem/rc"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/rc.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/rc.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/rc"
      - "C:/Windows/System32/OpenSSH/rc.com"
      - "C:/Windows/System32/OpenSSH/rc.exe"
      - "C:/Windows/System32/OpenSSH/rc"
      - "C:/ProgramData/chocolatey/bin/rc.com"
      - "C:/ProgramData/chocolatey/bin/rc.exe"
      - "C:/ProgramData/chocolatey/bin/rc"
      - "C:/Program Files/PowerShell/7/rc.com"
      - "C:/Program Files/PowerShell/7/rc.exe"
      - "C:/Program Files/PowerShell/7/rc"
      - "C:/Program Files (x86)/LLVM/bin/rc.com"
      - "C:/Program Files (x86)/LLVM/bin/rc.exe"
      - "C:/Program Files (x86)/LLVM/bin/rc"
      - "C:/Program Files/dotnet/rc.com"
      - "C:/Program Files/dotnet/rc.exe"
      - "C:/Program Files/dotnet/rc"
      - "C:/Program Files (x86)/Yarn/bin/rc.com"
      - "C:/Program Files (x86)/Yarn/bin/rc.exe"
      - "C:/Program Files (x86)/Yarn/bin/rc"
      - "C:/ProgramData/nvm/rc.com"
      - "C:/ProgramData/nvm/rc.exe"
      - "C:/ProgramData/nvm/rc"
      - "C:/nvm4w/nodejs/rc.com"
      - "C:/nvm4w/nodejs/rc.exe"
      - "C:/nvm4w/nodejs/rc"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/rc.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/rc.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/rc"
      - "C:/tools/php85/rc.com"
      - "C:/tools/php85/rc.exe"
      - "C:/tools/php85/rc"
      - "C:/Program Files/Microsoft VS Code/bin/rc.com"
      - "C:/Program Files/Microsoft VS Code/bin/rc.exe"
      - "C:/Program Files/Microsoft VS Code/bin/rc"
      - "C:/Program Files/Tailscale/rc.com"
      - "C:/Program Files/Tailscale/rc.exe"
      - "C:/Program Files/Tailscale/rc"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/rc.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/rc.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/rc"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/rc.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/rc.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/rc"
      - "C:/Program Files/Mullvad VPN/resources/rc.com"
      - "C:/Program Files/Mullvad VPN/resources/rc.exe"
      - "C:/Program Files/Mullvad VPN/resources/rc"
      - "C:/Program Files/OpenSSL-Win64/bin/rc.com"
      - "C:/Program Files/OpenSSL-Win64/bin/rc.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/rc"
      - "C:/Program Files/GitHub CLI/rc.com"
      - "C:/Program Files/GitHub CLI/rc.exe"
      - "C:/Program Files/GitHub CLI/rc"
      - "C:/Program Files/CMake/bin/rc.com"
      - "C:/Program Files/CMake/bin/rc.exe"
      - "C:/Program Files/CMake/bin/rc"
      - "C:/Program Files/doxygen/bin/rc.com"
      - "C:/Program Files/doxygen/bin/rc.exe"
      - "C:/Program Files/doxygen/bin/rc"
      - "C:/Users/Able/.local/bin/rc.com"
      - "C:/Users/Able/.local/bin/rc.exe"
      - "C:/Users/Able/.local/bin/rc"
      - "C:/Program Files/Docker/Docker/resources/bin/rc.com"
      - "C:/Program Files/Docker/Docker/resources/bin/rc.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/rc"
      - "C:/Program Files/Git/cmd/rc.com"
      - "C:/Program Files/Git/cmd/rc.exe"
      - "C:/Program Files/Git/cmd/rc"
      - "C:/Program Files/nodejs/rc.com"
      - "C:/Program Files/nodejs/rc.exe"
      - "C:/Program Files/nodejs/rc"
      - "C:/Program Files/PowerToys/DSCModules/rc.com"
      - "C:/Program Files/PowerToys/DSCModules/rc.exe"
      - "C:/Program Files/PowerToys/DSCModules/rc"
      - "E:/platform-tools/rc.com"
      - "E:/platform-tools/rc.exe"
      - "E:/platform-tools/rc"
      - "C:/Users/Able/.cargo/bin/rc.com"
      - "C:/Users/Able/.cargo/bin/rc.exe"
      - "C:/Users/Able/.cargo/bin/rc"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/rc.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/rc.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/rc"
      - "C:/Users/Able/AppData/Local/Yarn/bin/rc.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/rc.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/rc"
      - "E:/GitHub/vcpkg/rc.com"
      - "E:/GitHub/vcpkg/rc.exe"
      - "E:/GitHub/vcpkg/rc"
      - "C:/Users/Able/.dotnet/tools/rc.com"
      - "C:/Users/Able/.dotnet/tools/rc.exe"
      - "C:/Users/Able/.dotnet/tools/rc"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/rc.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/rc.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/rc"
      - "C:/Users/Able/AppData/Roaming/npm/rc.com"
      - "C:/Users/Able/AppData/Roaming/npm/rc.exe"
      - "C:/Users/Able/AppData/Roaming/npm/rc"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/rc.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/rc.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/rc"
      - "C:/Program Files/bin/rc.com"
      - "C:/Program Files/bin/rc.exe"
      - "C:/Program Files/bin/rc"
      - "C:/Program Files/sbin/rc.com"
      - "C:/Program Files/sbin/rc.exe"
      - "C:/Program Files/sbin/rc"
      - "C:/Program Files/rc.com"
      - "C:/Program Files/rc.exe"
      - "C:/Program Files/rc"
      - "C:/Program Files (x86)/bin/rc.com"
      - "C:/Program Files (x86)/bin/rc.exe"
      - "C:/Program Files (x86)/bin/rc"
      - "C:/Program Files (x86)/sbin/rc.com"
      - "C:/Program Files (x86)/sbin/rc.exe"
      - "C:/Program Files (x86)/sbin/rc"
      - "C:/Program Files (x86)/rc.com"
      - "C:/Program Files (x86)/rc.exe"
      - "C:/Program Files (x86)/rc"
      - "C:/Program Files/CMake/bin/rc.com"
      - "C:/Program Files/CMake/bin/rc.exe"
      - "C:/Program Files/CMake/bin/rc"
      - "C:/Program Files/CMake/sbin/rc.com"
      - "C:/Program Files/CMake/sbin/rc.exe"
      - "C:/Program Files/CMake/sbin/rc"
      - "C:/Program Files/CMake/rc.com"
      - "C:/Program Files/CMake/rc.exe"
      - "C:/Program Files/CMake/rc"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/rc.com"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/rc.exe"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/rc"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/rc.com"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/rc.exe"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/rc"
      - "C:/Program Files (x86)/x64dbg_mcp/rc.com"
      - "C:/Program Files (x86)/x64dbg_mcp/rc.exe"
      - "C:/Program Files (x86)/x64dbg_mcp/rc"
    found: false
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
      CMAKE_INSTALL_PREFIX: "C:/Program Files (x86)/x64dbg_mcp"
      CMAKE_SYSTEM_PREFIX_PATH:
        - "C:/Program Files"
        - "C:/Program Files (x86)"
        - "C:/Program Files/CMake"
        - "C:/Program Files (x86)/x64dbg_mcp"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang.cmake:216 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang-CXX.cmake:1 (include)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeCXXInformation.cmake:48 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "__RC_COMPILER_PATH"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: true
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "llvm-rc"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
      - "C:/Program Files/bin/"
      - "C:/Program Files/sbin/"
      - "C:/Program Files/"
      - "C:/Program Files (x86)/bin/"
      - "C:/Program Files (x86)/sbin/"
      - "C:/Program Files (x86)/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/CMake/sbin/"
      - "C:/Program Files/CMake/"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/"
      - "C:/Program Files (x86)/x64dbg_mcp/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/llvm-rc.com"
    found: "C:/Program Files/LLVM/bin/llvm-rc.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
      CMAKE_INSTALL_PREFIX: "C:/Program Files (x86)/x64dbg_mcp"
      CMAKE_SYSTEM_PREFIX_PATH:
        - "C:/Program Files"
        - "C:/Program Files (x86)"
        - "C:/Program Files/CMake"
        - "C:/Program Files (x86)/x64dbg_mcp"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineRCCompiler.cmake:40 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-MSVC.cmake:580 (enable_language)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-MSVC.cmake:553 (__windows_compiler_msvc_enable_rc)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang.cmake:235 (__windows_compiler_msvc)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang.cmake:291 (__windows_compiler_clang_base)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang-CXX.cmake:3 (__windows_compiler_clang)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeCXXInformation.cmake:48 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "CMAKE_RC_COMPILER"
    description: "RC compiler"
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: true
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "llvm-rc"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
      - "C:/Program Files/bin/"
      - "C:/Program Files/sbin/"
      - "C:/Program Files/"
      - "C:/Program Files (x86)/bin/"
      - "C:/Program Files (x86)/sbin/"
      - "C:/Program Files (x86)/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/CMake/sbin/"
      - "C:/Program Files/CMake/"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/"
      - "C:/Program Files (x86)/x64dbg_mcp/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/llvm-rc.com"
    found: "C:/Program Files/LLVM/bin/llvm-rc.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
      CMAKE_INSTALL_PREFIX: "C:/Program Files (x86)/x64dbg_mcp"
      CMAKE_SYSTEM_PREFIX_PATH:
        - "C:/Program Files"
        - "C:/Program Files (x86)"
        - "C:/Program Files/CMake"
        - "C:/Program Files (x86)/x64dbg_mcp"
  -
    kind: "try_compile-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerABI.cmake:83 (try_compile)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeTestCXXCompiler.cmake:26 (CMAKE_DETERMINE_COMPILER_ABI)"
      - "CMakeLists.txt:2 (project)"
    checks:
      - "Detecting CXX compiler ABI info"
    directories:
      source: "E:/GitHub/x64dbg_mcp/build/CMakeFiles/CMakeScratch/TryCompile-w2hyfw"
      binary: "E:/GitHub/x64dbg_mcp/build/CMakeFiles/CMakeScratch/TryCompile-w2hyfw"
    cmakeVariables:
      CMAKE_CXX_COMPILER_CLANG_SCAN_DEPS: "C:/Program Files/LLVM/bin/clang-scan-deps.exe"
      CMAKE_CXX_FLAGS: "/DWIN32 /D_WINDOWS /EHsc"
      CMAKE_CXX_FLAGS_DEBUG: "/Zi /Ob0 /Od /RTC1"
      CMAKE_CXX_SCAN_FOR_MODULES: "OFF"
      CMAKE_EXE_LINKER_FLAGS: "/machine:x64"
    buildResult:
      variable: "CMAKE_CXX_ABI_COMPILED"
      cached: true
      stdout: |
        Change Dir: 'E:/GitHub/x64dbg_mcp/build/CMakeFiles/CMakeScratch/TryCompile-w2hyfw'
        
        Run Build Command(s): C:/ProgramData/chocolatey/bin/ninja.exe -v cmTC_f06ef
        [1/2] C:\\PROGRA~1\\LLVM\\bin\\clang-cl.exe  /nologo -TP -D_MBCS  /DWIN32 /D_WINDOWS /EHsc  /Zi /Ob0 /Od /RTC1 -MDd /showIncludes /FoCMakeFiles\\cmTC_f06ef.dir\\CMakeCXXCompilerABI.cpp.obj /FdCMakeFiles\\cmTC_f06ef.dir\\ -c -- "C:\\Program Files\\CMake\\share\\cmake-4.2\\Modules\\CMakeCXXCompilerABI.cpp"
        [2/2] C:\\WINDOWS\\system32\\cmd.exe /C "cd . && "C:\\Program Files\\CMake\\bin\\cmake.exe" -E vs_link_exe --msvc-ver=1950 --intdir=CMakeFiles\\cmTC_f06ef.dir --rc=C:\\PROGRA~1\\LLVM\\bin\\llvm-rc.exe --mt=C:\\PROGRA~1\\LLVM\\bin\\llvm-mt.exe --manifests  -- C:\\PROGRA~1\\LLVM\\bin\\lld-link.exe /nologo CMakeFiles\\cmTC_f06ef.dir\\CMakeCXXCompilerABI.cpp.obj  /out:cmTC_f06ef.exe /implib:cmTC_f06ef.lib /pdb:cmTC_f06ef.pdb /version:0.0 /machine:x64  /debug /INCREMENTAL /subsystem:console   && cd ."
        
      exitCode: 0
  -
    kind: "message-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerABI.cmake:253 (message)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeTestCXXCompiler.cmake:26 (CMAKE_DETERMINE_COMPILER_ABI)"
      - "CMakeLists.txt:2 (project)"
    message: |
      Parsed CXX implicit link information:
        link line regex: [^( *|.*[/\\])(ld[0-9]*(|\\.[a-rt-z][a-z]*|\\.s[a-np-z][a-z]*|\\.so[a-z]+)|link\\.exe|lld-link(\\.exe)?|CMAKE_LINK_STARTFILE-NOTFOUND|([^/\\]+-)?ld|collect2)[^/\\]*( |$)]
        linker tool regex: [^[ 	]*(->|"|[0-9]+>[ 	-]*Build:[ 	0-9]+ ms[ 	]*)?[ 	]*(([^"]*[/\\])?(ld[0-9]*(|\\.[a-rt-z][a-z]*|\\.s[a-np-z][a-z]*|\\.so[a-z]+)|link\\.exe|lld-link(\\.exe)?))("|,| |$)]
        linker tool for 'CXX': C:/PROGRA~1/LLVM/bin/lld-link.exe
        implicit libs: []
        implicit objs: []
        implicit dirs: []
        implicit fwks: []
      
      
  -
    kind: "message-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Internal/CMakeDetermineLinkerId.cmake:38 (message)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerABI.cmake:299 (cmake_determine_linker_id)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeTestCXXCompiler.cmake:26 (CMAKE_DETERMINE_COMPILER_ABI)"
      - "CMakeLists.txt:2 (project)"
    message: |
      Running the CXX compiler's linker: "C:/PROGRA~1/LLVM/bin/lld-link.exe" "-v"
      lld-link: warning: ignoring unknown argument '-v'
      lld-link: error: no input files
  -
    kind: "message-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Internal/CMakeDetermineLinkerId.cmake:38 (message)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerABI.cmake:299 (cmake_determine_linker_id)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeTestCXXCompiler.cmake:26 (CMAKE_DETERMINE_COMPILER_ABI)"
      - "CMakeLists.txt:2 (project)"
    message: |
      Running the CXX compiler's linker: "C:/PROGRA~1/LLVM/bin/lld-link.exe" "-V"
      lld-link: warning: ignoring unknown argument '-V'
      lld-link: error: no input files
  -
    kind: "message-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Internal/CMakeDetermineLinkerId.cmake:38 (message)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerABI.cmake:299 (cmake_determine_linker_id)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeTestCXXCompiler.cmake:26 (CMAKE_DETERMINE_COMPILER_ABI)"
      - "CMakeLists.txt:2 (project)"
    message: |
      Running the CXX compiler's linker: "C:/PROGRA~1/LLVM/bin/lld-link.exe" "--version"
      LLD 21.1.8
  -
    kind: "try_compile-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Internal/FeatureTesting.cmake:34 (try_compile)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Internal/FeatureTesting.cmake:87 (_record_compiler_features)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Compiler/CMakeCommonCompilerMacros.cmake:124 (_record_compiler_features_cxx)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerSupport.cmake:70 (cmake_record_cxx_compile_features)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeTestCXXCompiler.cmake:83 (CMAKE_DETERMINE_COMPILER_SUPPORT)"
      - "CMakeLists.txt:2 (project)"
    checks:
      - "Detecting CXX compile features"
    directories:
      source: "E:/GitHub/x64dbg_mcp/build/CMakeFiles/CMakeScratch/TryCompile-y5j6m4"
      binary: "E:/GitHub/x64dbg_mcp/build/CMakeFiles/CMakeScratch/TryCompile-y5j6m4"
    cmakeVariables:
      CMAKE_CXX_COMPILER_CLANG_SCAN_DEPS: "C:/Program Files/LLVM/bin/clang-scan-deps.exe"
      CMAKE_CXX_FLAGS: "/DWIN32 /D_WINDOWS /EHsc"
      CMAKE_CXX_FLAGS_DEBUG: "/Zi /Ob0 /Od /RTC1"
      CMAKE_EXE_LINKER_FLAGS: "/machine:x64"
    buildResult:
      variable: "CMAKE_CXX_FEATURE_TEST"
      cached: true
      stdout: |
        Change Dir: 'E:/GitHub/x64dbg_mcp/build/CMakeFiles/CMakeScratch/TryCompile-y5j6m4'
        
        Run Build Command(s): C:/ProgramData/chocolatey/bin/ninja.exe -v cmTC_d9368
        [1/2] C:\\PROGRA~1\\LLVM\\bin\\clang-cl.exe  /nologo -TP -D_MBCS  /DWIN32 /D_WINDOWS /EHsc  /Zi /Ob0 /Od /RTC1 -MDd   -std:c++14 /showIncludes /FoCMakeFiles\\cmTC_d9368.dir\\feature_tests.cxx.obj /FdCMakeFiles\\cmTC_d9368.dir\\ -c -- E:\\GitHub\\x64dbg_mcp\\build\\CMakeFiles\\CMakeScratch\\TryCompile-y5j6m4\\feature_tests.cxx
        [2/2] C:\\WINDOWS\\system32\\cmd.exe /C "cd . && "C:\\Program Files\\CMake\\bin\\cmake.exe" -E vs_link_exe --msvc-ver=1950 --intdir=CMakeFiles\\cmTC_d9368.dir --rc=C:\\PROGRA~1\\LLVM\\bin\\llvm-rc.exe --mt=C:\\PROGRA~1\\LLVM\\bin\\llvm-mt.exe --manifests  -- C:\\PROGRA~1\\LLVM\\bin\\lld-link.exe /nologo CMakeFiles\\cmTC_d9368.dir\\feature_tests.cxx.obj  /out:cmTC_d9368.exe /implib:cmTC_d9368.lib /pdb:cmTC_d9368.pdb /version:0.0 /machine:x64  /debug /INCREMENTAL /subsystem:console  kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib && cd ."
        
      exitCode: 0
  -
    kind: "try_compile-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Internal/FeatureTesting.cmake:34 (try_compile)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Internal/FeatureTesting.cmake:87 (_record_compiler_features)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Compiler/CMakeCommonCompilerMacros.cmake:132 (_record_compiler_features_cxx)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeDetermineCompilerSupport.cmake:70 (cmake_record_cxx_compile_features)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeTestCXXCompiler.cmake:83 (CMAKE_DETERMINE_COMPILER_SUPPORT)"
      - "CMakeLists.txt:2 (project)"
    checks:
      - "Detecting CXX compile features"
    directories:
      source: "E:/GitHub/x64dbg_mcp/build/CMakeFiles/CMakeScratch/TryCompile-blugf8"
      binary: "E:/GitHub/x64dbg_mcp/build/CMakeFiles/CMakeScratch/TryCompile-blugf8"
    cmakeVariables:
      CMAKE_CXX_COMPILER_CLANG_SCAN_DEPS: "C:/Program Files/LLVM/bin/clang-scan-deps.exe"
      CMAKE_CXX_FLAGS: "/DWIN32 /D_WINDOWS /EHsc"
      CMAKE_CXX_FLAGS_DEBUG: "/Zi /Ob0 /Od /RTC1"
      CMAKE_EXE_LINKER_FLAGS: "/machine:x64"
    buildResult:
      variable: "CMAKE_CXX_FEATURE_TEST"
      cached: true
      stdout: |
        Change Dir: 'E:/GitHub/x64dbg_mcp/build/CMakeFiles/CMakeScratch/TryCompile-blugf8'
        
        Run Build Command(s): C:/ProgramData/chocolatey/bin/ninja.exe -v cmTC_235b8
        [1/2] C:\\PROGRA~1\\LLVM\\bin\\clang-cl.exe  /nologo -TP -D_MBCS  /DWIN32 /D_WINDOWS /EHsc  /Zi /Ob0 /Od /RTC1 -MDd /showIncludes /FoCMakeFiles\\cmTC_235b8.dir\\feature_tests.cxx.obj /FdCMakeFiles\\cmTC_235b8.dir\\ -c -- E:\\GitHub\\x64dbg_mcp\\build\\CMakeFiles\\CMakeScratch\\TryCompile-blugf8\\feature_tests.cxx
        [2/2] C:\\WINDOWS\\system32\\cmd.exe /C "cd . && "C:\\Program Files\\CMake\\bin\\cmake.exe" -E vs_link_exe --msvc-ver=1950 --intdir=CMakeFiles\\cmTC_235b8.dir --rc=C:\\PROGRA~1\\LLVM\\bin\\llvm-rc.exe --mt=C:\\PROGRA~1\\LLVM\\bin\\llvm-mt.exe --manifests  -- C:\\PROGRA~1\\LLVM\\bin\\lld-link.exe /nologo CMakeFiles\\cmTC_235b8.dir\\feature_tests.cxx.obj  /out:cmTC_235b8.exe /implib:cmTC_235b8.lib /pdb:cmTC_235b8.pdb /version:0.0 /machine:x64  /debug /INCREMENTAL /subsystem:console  kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib && cd ."
        
      exitCode: 0
  -
    kind: "find_package-v1"
    backtrace:
      - "CMakeLists.txt:21 (find_package)"
    name: "nlohmann_json"
    configs:
      -
        filename: "nlohmann_jsonConfig.cmake"
        kind: "cmake"
      -
        filename: "nlohmann_json-config.cmake"
        kind: "cmake"
    version_request:
      exact: false
    settings:
      required: "required_explicit"
      quiet: false
      global: false
      policy_scope: true
      bypass_provider: false
      names:
        - "nlohmann_json"
      path_suffixes:
        - ""
      paths:
        CMAKE_FIND_USE_CMAKE_PATH: true
        CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: true
        CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
        CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
        CMAKE_FIND_USE_INSTALL_PREFIX: true
        CMAKE_FIND_USE_PACKAGE_ROOT_PATH: true
        CMAKE_FIND_USE_CMAKE_PACKAGE_REGISTRY: true
        CMAKE_FIND_USE_SYSTEM_PACKAGE_REGISTRY: true
        CMAKE_FIND_ROOT_PATH_MODE: "BOTH"
    candidates:
      -
        path: "E:/GitHub/x64dbg_mcp/build/CMakeFiles/pkgRedirects/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "E:/GitHub/x64dbg_mcp/build/CMakeFiles/pkgRedirects/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/LLVM/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/LLVM/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/oh-my-posh/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/oh-my-posh/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/VMware/VMware Workstation/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/VMware/VMware Workstation/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Python311/Scripts/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Python311/Scripts/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Python311/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Python311/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/System32/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/System32/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/System32/wbem/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/System32/wbem/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/System32/WindowsPowerShell/v1.0/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/System32/WindowsPowerShell/v1.0/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/System32/OpenSSH/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Windows/System32/OpenSSH/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/ProgramData/chocolatey/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/ProgramData/chocolatey/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/PowerShell/7/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/PowerShell/7/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/dotnet/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/dotnet/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/Yarn/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/Yarn/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/ProgramData/nvm/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/ProgramData/nvm/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/nvm4w/nodejs/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/nvm4w/nodejs/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/tools/php85/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/tools/php85/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Microsoft VS Code/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Microsoft VS Code/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Tailscale/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Tailscale/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Mullvad VPN/resources/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Mullvad VPN/resources/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/OpenSSL-Win64/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/OpenSSL-Win64/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/GitHub CLI/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/GitHub CLI/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/CMake/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/CMake/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/doxygen/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/doxygen/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/.local/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/.local/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Docker/Docker/resources/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Docker/Docker/resources/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Git/cmd/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/Git/cmd/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/nodejs/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/nodejs/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/PowerToys/DSCModules/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/PowerToys/DSCModules/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "E:/platform-tools/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "E:/platform-tools/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/.cargo/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/.cargo/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Local/Yarn/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Local/Yarn/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "E:/GitHub/vcpkg/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "E:/GitHub/vcpkg/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Roaming/npm/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Roaming/npm/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Local/Programs/Antigravity/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Users/Able/AppData/Local/Programs/Antigravity/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/CMake/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files/CMake/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/nlohmann_jsonConfig.cmake"
        mode: "config"
        reason: "no_exist"
      -
        path: "C:/Program Files (x86)/nlohmann_json-config.cmake"
        mode: "config"
        reason: "no_exist"
    found: null
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
      CMAKE_INSTALL_PREFIX: "C:/Program Files (x86)/x64dbg_mcp"
      CMAKE_SYSTEM_PREFIX_PATH:
        - "C:/Program Files"
        - "C:/Program Files (x86)"
        - "C:/Program Files/CMake"
        - "C:/Program Files (x86)/x64dbg_mcp"
...

---
events:
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang.cmake:210 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang-CXX.cmake:1 (include)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeCXXInformation.cmake:48 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "__RC_COMPILER_PATH"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: true
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "rc"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
      - "C:/Program Files/bin/"
      - "C:/Program Files/sbin/"
      - "C:/Program Files/"
      - "C:/Program Files (x86)/bin/"
      - "C:/Program Files (x86)/sbin/"
      - "C:/Program Files (x86)/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/CMake/sbin/"
      - "C:/Program Files/CMake/"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/"
      - "C:/Program Files (x86)/x64dbg_mcp/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/rc.com"
      - "C:/Program Files/LLVM/bin/rc.exe"
      - "C:/Program Files/LLVM/bin/rc"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/rc.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/rc.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/rc"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/rc.com"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/rc.exe"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/rc"
      - "C:/Program Files (x86)/oh-my-posh/bin/rc.com"
      - "C:/Program Files (x86)/oh-my-posh/bin/rc.exe"
      - "C:/Program Files (x86)/oh-my-posh/bin/rc"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/rc.com"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/rc.exe"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/rc"
      - "C:/Python311/Scripts/rc.com"
      - "C:/Python311/Scripts/rc.exe"
      - "C:/Python311/Scripts/rc"
      - "C:/Python311/rc.com"
      - "C:/Python311/rc.exe"
      - "C:/Python311/rc"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/rc.com"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/rc.exe"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/rc"
      - "C:/Windows/System32/rc.com"
      - "C:/Windows/System32/rc.exe"
      - "C:/Windows/System32/rc"
      - "C:/Windows/rc.com"
      - "C:/Windows/rc.exe"
      - "C:/Windows/rc"
      - "C:/Windows/System32/wbem/rc.com"
      - "C:/Windows/System32/wbem/rc.exe"
      - "C:/Windows/System32/wbem/rc"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/rc.com"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/rc.exe"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/rc"
      - "C:/Windows/System32/OpenSSH/rc.com"
      - "C:/Windows/System32/OpenSSH/rc.exe"
      - "C:/Windows/System32/OpenSSH/rc"
      - "C:/ProgramData/chocolatey/bin/rc.com"
      - "C:/ProgramData/chocolatey/bin/rc.exe"
      - "C:/ProgramData/chocolatey/bin/rc"
      - "C:/Program Files/PowerShell/7/rc.com"
      - "C:/Program Files/PowerShell/7/rc.exe"
      - "C:/Program Files/PowerShell/7/rc"
      - "C:/Program Files (x86)/LLVM/bin/rc.com"
      - "C:/Program Files (x86)/LLVM/bin/rc.exe"
      - "C:/Program Files (x86)/LLVM/bin/rc"
      - "C:/Program Files/dotnet/rc.com"
      - "C:/Program Files/dotnet/rc.exe"
      - "C:/Program Files/dotnet/rc"
      - "C:/Program Files (x86)/Yarn/bin/rc.com"
      - "C:/Program Files (x86)/Yarn/bin/rc.exe"
      - "C:/Program Files (x86)/Yarn/bin/rc"
      - "C:/ProgramData/nvm/rc.com"
      - "C:/ProgramData/nvm/rc.exe"
      - "C:/ProgramData/nvm/rc"
      - "C:/nvm4w/nodejs/rc.com"
      - "C:/nvm4w/nodejs/rc.exe"
      - "C:/nvm4w/nodejs/rc"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/rc.com"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/rc.exe"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/rc"
      - "C:/tools/php85/rc.com"
      - "C:/tools/php85/rc.exe"
      - "C:/tools/php85/rc"
      - "C:/Program Files/Microsoft VS Code/bin/rc.com"
      - "C:/Program Files/Microsoft VS Code/bin/rc.exe"
      - "C:/Program Files/Microsoft VS Code/bin/rc"
      - "C:/Program Files/Tailscale/rc.com"
      - "C:/Program Files/Tailscale/rc.exe"
      - "C:/Program Files/Tailscale/rc"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/rc.com"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/rc.exe"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/rc"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/rc.com"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/rc.exe"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/rc"
      - "C:/Program Files/Mullvad VPN/resources/rc.com"
      - "C:/Program Files/Mullvad VPN/resources/rc.exe"
      - "C:/Program Files/Mullvad VPN/resources/rc"
      - "C:/Program Files/OpenSSL-Win64/bin/rc.com"
      - "C:/Program Files/OpenSSL-Win64/bin/rc.exe"
      - "C:/Program Files/OpenSSL-Win64/bin/rc"
      - "C:/Program Files/GitHub CLI/rc.com"
      - "C:/Program Files/GitHub CLI/rc.exe"
      - "C:/Program Files/GitHub CLI/rc"
      - "C:/Program Files/CMake/bin/rc.com"
      - "C:/Program Files/CMake/bin/rc.exe"
      - "C:/Program Files/CMake/bin/rc"
      - "C:/Program Files/doxygen/bin/rc.com"
      - "C:/Program Files/doxygen/bin/rc.exe"
      - "C:/Program Files/doxygen/bin/rc"
      - "C:/Users/Able/.local/bin/rc.com"
      - "C:/Users/Able/.local/bin/rc.exe"
      - "C:/Users/Able/.local/bin/rc"
      - "C:/Program Files/Docker/Docker/resources/bin/rc.com"
      - "C:/Program Files/Docker/Docker/resources/bin/rc.exe"
      - "C:/Program Files/Docker/Docker/resources/bin/rc"
      - "C:/Program Files/Git/cmd/rc.com"
      - "C:/Program Files/Git/cmd/rc.exe"
      - "C:/Program Files/Git/cmd/rc"
      - "C:/Program Files/nodejs/rc.com"
      - "C:/Program Files/nodejs/rc.exe"
      - "C:/Program Files/nodejs/rc"
      - "C:/Program Files/PowerToys/DSCModules/rc.com"
      - "C:/Program Files/PowerToys/DSCModules/rc.exe"
      - "C:/Program Files/PowerToys/DSCModules/rc"
      - "E:/platform-tools/rc.com"
      - "E:/platform-tools/rc.exe"
      - "E:/platform-tools/rc"
      - "C:/Users/Able/.cargo/bin/rc.com"
      - "C:/Users/Able/.cargo/bin/rc.exe"
      - "C:/Users/Able/.cargo/bin/rc"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/rc.com"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/rc.exe"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/rc"
      - "C:/Users/Able/AppData/Local/Yarn/bin/rc.com"
      - "C:/Users/Able/AppData/Local/Yarn/bin/rc.exe"
      - "C:/Users/Able/AppData/Local/Yarn/bin/rc"
      - "E:/GitHub/vcpkg/rc.com"
      - "E:/GitHub/vcpkg/rc.exe"
      - "E:/GitHub/vcpkg/rc"
      - "C:/Users/Able/.dotnet/tools/rc.com"
      - "C:/Users/Able/.dotnet/tools/rc.exe"
      - "C:/Users/Able/.dotnet/tools/rc"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/rc.com"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/rc.exe"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/rc"
      - "C:/Users/Able/AppData/Roaming/npm/rc.com"
      - "C:/Users/Able/AppData/Roaming/npm/rc.exe"
      - "C:/Users/Able/AppData/Roaming/npm/rc"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/rc.com"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/rc.exe"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/rc"
      - "C:/Program Files/bin/rc.com"
      - "C:/Program Files/bin/rc.exe"
      - "C:/Program Files/bin/rc"
      - "C:/Program Files/sbin/rc.com"
      - "C:/Program Files/sbin/rc.exe"
      - "C:/Program Files/sbin/rc"
      - "C:/Program Files/rc.com"
      - "C:/Program Files/rc.exe"
      - "C:/Program Files/rc"
      - "C:/Program Files (x86)/bin/rc.com"
      - "C:/Program Files (x86)/bin/rc.exe"
      - "C:/Program Files (x86)/bin/rc"
      - "C:/Program Files (x86)/sbin/rc.com"
      - "C:/Program Files (x86)/sbin/rc.exe"
      - "C:/Program Files (x86)/sbin/rc"
      - "C:/Program Files (x86)/rc.com"
      - "C:/Program Files (x86)/rc.exe"
      - "C:/Program Files (x86)/rc"
      - "C:/Program Files/CMake/bin/rc.com"
      - "C:/Program Files/CMake/bin/rc.exe"
      - "C:/Program Files/CMake/bin/rc"
      - "C:/Program Files/CMake/sbin/rc.com"
      - "C:/Program Files/CMake/sbin/rc.exe"
      - "C:/Program Files/CMake/sbin/rc"
      - "C:/Program Files/CMake/rc.com"
      - "C:/Program Files/CMake/rc.exe"
      - "C:/Program Files/CMake/rc"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/rc.com"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/rc.exe"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/rc"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/rc.com"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/rc.exe"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/rc"
      - "C:/Program Files (x86)/x64dbg_mcp/rc.com"
      - "C:/Program Files (x86)/x64dbg_mcp/rc.exe"
      - "C:/Program Files (x86)/x64dbg_mcp/rc"
    found: false
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
      CMAKE_INSTALL_PREFIX: "C:/Program Files (x86)/x64dbg_mcp"
      CMAKE_SYSTEM_PREFIX_PATH:
        - "C:/Program Files"
        - "C:/Program Files (x86)"
        - "C:/Program Files/CMake"
        - "C:/Program Files (x86)/x64dbg_mcp"
  -
    kind: "find-v1"
    backtrace:
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang.cmake:216 (find_program)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/Platform/Windows-Clang-CXX.cmake:1 (include)"
      - "C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeCXXInformation.cmake:48 (include)"
      - "CMakeLists.txt:2 (project)"
    mode: "program"
    variable: "__RC_COMPILER_PATH"
    description: "Path to a program."
    settings:
      SearchFramework: "NEVER"
      SearchAppBundle: "NEVER"
      CMAKE_FIND_USE_CMAKE_PATH: true
      CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH: true
      CMAKE_FIND_USE_CMAKE_SYSTEM_PATH: true
      CMAKE_FIND_USE_INSTALL_PREFIX: true
    names:
      - "llvm-rc"
    candidate_directories:
      - "C:/Program Files/LLVM/bin/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/java8path/"
      - "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/"
      - "C:/Program Files (x86)/oh-my-posh/bin/"
      - "C:/Program Files (x86)/VMware/VMware Workstation/bin/"
      - "C:/Python311/Scripts/"
      - "C:/Python311/"
      - "C:/Program Files/Eclipse Adoptium/jdk-17.0.17.10-hotspot/bin/"
      - "C:/Windows/System32/"
      - "C:/Windows/"
      - "C:/Windows/System32/wbem/"
      - "C:/Windows/System32/WindowsPowerShell/v1.0/"
      - "C:/Windows/System32/OpenSSH/"
      - "C:/ProgramData/chocolatey/bin/"
      - "C:/Program Files/PowerShell/7/"
      - "C:/Program Files (x86)/LLVM/bin/"
      - "C:/Program Files/dotnet/"
      - "C:/Program Files (x86)/Yarn/bin/"
      - "C:/ProgramData/nvm/"
      - "C:/nvm4w/nodejs/"
      - "C:/Program Files/Microsoft SQL Server/170/Tools/Binn/"
      - "C:/tools/php85/"
      - "C:/Program Files/Microsoft VS Code/bin/"
      - "C:/Program Files/Tailscale/"
      - "C:/Program Files/Microsoft SQL Server/150/Tools/Binn/"
      - "C:/Program Files (x86)/Windows Kits/10/Windows Performance Toolkit/"
      - "C:/Program Files/Mullvad VPN/resources/"
      - "C:/Program Files/OpenSSL-Win64/bin/"
      - "C:/Program Files/GitHub CLI/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/doxygen/bin/"
      - "C:/Users/Able/.local/bin/"
      - "C:/Program Files/Docker/Docker/resources/bin/"
      - "C:/Program Files/Git/cmd/"
      - "C:/Program Files/nodejs/"
      - "C:/Program Files/PowerToys/DSCModules/"
      - "E:/platform-tools/"
      - "C:/Users/Able/.cargo/bin/"
      - "C:/Users/Able/AppData/Local/Microsoft/WindowsApps/"
      - "C:/Users/Able/AppData/Local/Yarn/bin/"
      - "E:/GitHub/vcpkg/"
      - "C:/Users/Able/.dotnet/tools/"
      - "C:/Users/Able/AppData/Local/JetBrains/Toolbox/scripts/"
      - "C:/Users/Able/AppData/Roaming/npm/"
      - "C:/Users/Able/AppData/Local/Programs/Antigravity/bin/"
      - "C:/Program Files/bin/"
      - "C:/Program Files/sbin/"
      - "C:/Program Files/"
      - "C:/Program Files (x86)/bin/"
      - "C:/Program Files (x86)/sbin/"
      - "C:/Program Files (x86)/"
      - "C:/Program Files/CMake/bin/"
      - "C:/Program Files/CMake/sbin/"
      - "C:/Program Files/CMake/"
      - "C:/Program Files (x86)/x64dbg_mcp/bin/"
      - "C:/Program Files (x86)/x64dbg_mcp/sbin/"
      - "C:/Program Files (x86)/x64dbg_mcp/"
    searched_directories:
      - "C:/Program Files/LLVM/bin/llvm-rc.com"
    found: "C:/Program Files/LLVM/bin/llvm-rc.exe"
    search_context:
      ENV{PATH}:
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path"
        - "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath"
        - "C:\\Program Files (x86)\\oh-my-posh\\bin\\"
        - "C:\\Program Files (x86)\\VMware\\VMware Workstation\\bin\\"
        - "C:\\Python311\\Scripts\\"
        - "C:\\Python311\\"
        - "C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.17.10-hotspot\\bin"
        - "C:\\WINDOWS\\system32"
        - "C:\\WINDOWS"
        - "C:\\WINDOWS\\System32\\Wbem"
        - "C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\"
        - "C:\\WINDOWS\\System32\\OpenSSH\\"
        - "C:\\ProgramData\\chocolatey\\bin"
        - "C:\\Program Files\\PowerShell\\7\\"
        - "C:\\Program Files\\LLVM\\bin"
        - "C:\\Program Files (x86)\\LLVM\\bin"
        - "C:\\Program Files\\dotnet\\"
        - "C:\\Program Files (x86)\\Yarn\\bin\\"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "C:\\Program Files\\Microsoft SQL Server\\170\\Tools\\Binn\\"
        - "C:\\tools\\php85"
        - "C:\\Program Files\\Microsoft VS Code\\bin"
        - "C:\\Program Files\\Tailscale\\"
        - "C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\"
        - "C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\"
        - "C:\\Program Files\\Mullvad VPN\\resources"
        - "C:\\Program Files\\OpenSSL-Win64\\bin"
        - "C:\\Program Files\\GitHub CLI\\"
        - "C:\\Program Files\\CMake\\bin"
        - "C:\\Program Files\\doxygen\\bin"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Program Files\\Docker\\Docker\\resources\\bin"
        - "C:\\Program Files\\Git\\cmd"
        - "C:\\Program Files\\nodejs\\"
        - "C:\\Program Files\\PowerToys\\DSCModules\\"
        - "E:\\platform-tools\\"
        - "C:\\Users\\Able\\.local\\bin"
        - "C:\\Users\\Able\\.cargo\\bin"
        - "C:\\Users\\Able\\AppData\\Local\\Microsoft\\WindowsApps"
        - "C:\\Users\\Able\\AppData\\Local\\Yarn\\bin"
        - "C:\\ProgramData\\nvm"
        - "C:\\nvm4w\\nodejs"
        - "E:\\GitHub\\vcpkg"
        - "C:\\Users\\Able\\.dotnet\\tools"
        - "C:\\Users\\Able\\AppData\\Local\\JetBrains\\Toolbox\\scripts"
        - "C:\\Users\\Able\\AppData\\Roaming\\npm"
        - "C:\\Users\\Able\\AppData\\Local\\Programs\\Antigravity\\bin"
      CMAKE_INSTALL_PREFIX: "C:/Program Files (x86)/x64dbg_mcp"
      CMAKE_SYSTEM_PREFIX_PATH:
        - "C:/Program Files"
        - "C:/Program Files (x86)"
        - "C:/Program Files/CMake"
        - "C:/Program Files (x86)/x64dbg_mcp"
...

```

`build/CMakeFiles/ShowIncludes/main.c`:

```c
#include "foo.h" 
int main(){}

```

`build/CMakeFiles/cmake.check_cache`:

```check_cache
# This file is generated by cmake for dependency checking of the CMakeCache.txt file

```

`install.ps1`:

```ps1
# install.ps1 - Install x64dbg MCP plugin DLLs to your x64dbg installation
# This script is local-only (.gitignore'd) - edit X64DBG_PATH to match your setup.
#
# Usage:
#   .\install.ps1            - Install both x64 and x32 plugins
#   .\install.ps1 -Arch x64  - Install x64 only
#   .\install.ps1 -Arch x32  - Install x32 only

param(
    [ValidateSet('x64', 'x32', 'both')]
    [string]$Arch = 'both'
)

# ── CONFIGURE THIS ────────────────────────────────────────────────────────────
$X64DBG_PATH = "E:\reverse_tools\x64dbg_2025-08-19_19-40\release"
# ─────────────────────────────────────────────────────────────────────────────

$ScriptDir   = Split-Path -Parent $MyInvocation.MyCommand.Path
$Dp64        = Join-Path $ScriptDir "plugin\build\x64-release\bin\x64dbg_mcp.dp64"
$Dp32        = Join-Path $ScriptDir "plugin\build\x32-release\bin\x64dbg_mcp.dp32"
$PluginsX64  = Join-Path $X64DBG_PATH "x64\plugins"
$PluginsX32  = Join-Path $X64DBG_PATH "x32\plugins"

function Install-Plugin {
    param([string]$Src, [string]$DestDir, [string]$Label)

    if (-not (Test-Path $Src)) {
        Write-Host "[$Label] SKIP - not built yet: $Src" -ForegroundColor Yellow
        Write-Host "         Run: cmake --build plugin/build/$($Label.ToLower())-release" -ForegroundColor Yellow
        return
    }
    if (-not (Test-Path $DestDir)) {
        Write-Host "[$Label] ERROR - plugins directory not found: $DestDir" -ForegroundColor Red
        Write-Host "         Edit X64DBG_PATH in install.ps1" -ForegroundColor Red
        return
    }

    $Dest = Join-Path $DestDir (Split-Path -Leaf $Src)
    try {
        Copy-Item -Path $Src -Destination $Dest -Force
        $size = [math]::Round((Get-Item $Dest).Length / 1KB)
        Write-Host "[$Label] Installed ${size}KB -> $Dest" -ForegroundColor Green
    } catch {
        Write-Host "[$Label] FAILED: $_" -ForegroundColor Red
        Write-Host "         Is x64dbg currently running with the DLL locked?" -ForegroundColor Yellow
    }
}

Write-Host ""
Write-Host "x64dbg MCP Plugin Installer" -ForegroundColor Cyan
Write-Host "x64dbg path: $X64DBG_PATH" -ForegroundColor DarkGray
Write-Host ""

if ($Arch -eq 'x64' -or $Arch -eq 'both') {
    Install-Plugin -Src $Dp64 -DestDir $PluginsX64 -Label "x64"
}
if ($Arch -eq 'x32' -or $Arch -eq 'both') {
    Install-Plugin -Src $Dp32 -DestDir $PluginsX32 -Label "x32"
}

Write-Host ""
Write-Host "Done. Reload x64dbg plugins or restart x64dbg." -ForegroundColor Cyan

```

`plugin/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
project(x64dbg_mcp LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Determine architecture
if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(X64DBG_ARCH "x64")
    set(PLUGIN_EXT ".dp64")
    set(BRIDGE_LIB "x64bridge")
    set(DBG_LIB "x64dbg")
else()
    set(X64DBG_ARCH "x32")
    set(PLUGIN_EXT ".dp32")
    set(BRIDGE_LIB "x32bridge")
    set(DBG_LIB "x32dbg")
endif()

# vcpkg dependencies
find_package(nlohmann_json CONFIG REQUIRED)

# Source files
set(SOURCES
    src/plugin_main.cpp
    src/http/c_http_server.cpp
    src/http/c_http_router.cpp
    src/bridge/c_bridge_executor.cpp
    src/util/format_utils.cpp
    src/handlers/debug_handler.cpp
    src/handlers/register_handler.cpp
    src/handlers/memory_handler.cpp
    src/handlers/breakpoint_handler.cpp
    src/handlers/disasm_handler.cpp
    src/handlers/module_handler.cpp
    src/handlers/thread_handler.cpp
    src/handlers/stack_handler.cpp
    src/handlers/symbol_handler.cpp
    src/handlers/annotation_handler.cpp
    src/handlers/search_handler.cpp
    src/handlers/patch_handler.cpp
    src/handlers/memmap_handler.cpp
    src/handlers/command_handler.cpp
    src/handlers/analysis_handler.cpp
    src/handlers/tracing_handler.cpp
    src/handlers/dumping_handler.cpp
    src/handlers/antidebug_handler.cpp
    src/handlers/exceptions_handler.cpp
    src/handlers/process_handler.cpp
    src/handlers/handles_handler.cpp
    src/handlers/controlflow_handler.cpp
    src/ui/settings_dialog.cpp
    src/ui/about_dialog.cpp
)

# Create shared library (plugin DLL)
add_library(${PROJECT_NAME} SHARED ${SOURCES} plugin.def)

# Include directories (SDK as SYSTEM to suppress its warnings)
target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)
target_include_directories(${PROJECT_NAME} SYSTEM PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/sdk
)

# Determine jansson lib based on architecture
if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(JANSSON_LIB "${CMAKE_CURRENT_SOURCE_DIR}/sdk/jansson/jansson_x64.lib")
else()
    set(JANSSON_LIB "${CMAKE_CURRENT_SOURCE_DIR}/sdk/jansson/jansson_x86.lib")
endif()

# Link dependencies
target_link_libraries(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/sdk/${BRIDGE_LIB}.lib
    ${CMAKE_CURRENT_SOURCE_DIR}/sdk/${DBG_LIB}.lib
    ${JANSSON_LIB}
    nlohmann_json::nlohmann_json
    ws2_32
    dbghelp
)

# Set output name to match x64dbg plugin convention
set_target_properties(${PROJECT_NAME} PROPERTIES
    OUTPUT_NAME "x64dbg_mcp"
    SUFFIX ${PLUGIN_EXT}
    PREFIX ""
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
)

# Compiler flags for clang-cl / MSVC
target_compile_options(${PROJECT_NAME} PRIVATE
    /W4
    /utf-8
    /EHsc
)

target_compile_definitions(${PROJECT_NAME} PRIVATE
    _CRT_SECURE_NO_WARNINGS
    NOMINMAX
    WIN32_LEAN_AND_MEAN
    BUILD_PLUGIN
)

```

`plugin/CMakePresets.json`:

```json
{
  "version": 6,
  "configurePresets": [
    {
      "name": "x64-release",
      "displayName": "x64 Release (Clang-cl + Ninja)",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/x64-release",
      "architecture": {
        "value": "x64",
        "strategy": "external"
      },
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_C_COMPILER": "clang-cl",
        "CMAKE_CXX_COMPILER": "clang-cl",
        "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
        "VCPKG_TARGET_TRIPLET": "x64-windows"
      },
      "condition": {
        "type": "equals",
        "lhs": "${hostSystemName}",
        "rhs": "Windows"
      }
    },
    {
      "name": "x64-debug",
      "displayName": "x64 Debug (Clang-cl + Ninja)",
      "inherits": "x64-release",
      "binaryDir": "${sourceDir}/build/x64-debug",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug"
      }
    },
    {
      "name": "x32-release",
      "displayName": "x32 Release (Clang-cl + Ninja)",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/x32-release",
      "architecture": {
        "value": "x86",
        "strategy": "external"
      },
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_C_COMPILER": "clang-cl",
        "CMAKE_CXX_COMPILER": "clang-cl",
        "CMAKE_CXX_FLAGS": "-m32",
        "CMAKE_C_FLAGS": "-m32",
        "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
        "VCPKG_TARGET_TRIPLET": "x86-windows"
      },
      "condition": {
        "type": "equals",
        "lhs": "${hostSystemName}",
        "rhs": "Windows"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "x64-release",
      "configurePreset": "x64-release"
    },
    {
      "name": "x64-debug",
      "configurePreset": "x64-debug"
    },
    {
      "name": "x32-release",
      "configurePreset": "x32-release"
    }
  ]
}

```

`plugin/plugin.def`:

```def
EXPORTS
    pluginit
    plugsetup
    plugstop
    CBMENUENTRY

```

`plugin/sdk/XEDParse/XEDParse.h`:

```h
#ifndef _XEDPARSE_H
#define _XEDPARSE_H

#include <windows.h>

//XEDParse defines
#ifdef XEDPARSE_BUILD
#define XEDPARSE_EXPORT __declspec(dllexport)
#else
#define XEDPARSE_EXPORT __declspec(dllimport)
#endif //XEDPARSE_BUILD

#define XEDPARSE_CALL //calling convention

#define XEDPARSE_MAXBUFSIZE 256
#define XEDPARSE_MAXASMSIZE 16

//typedefs
typedef bool (XEDPARSE_CALL* CBXEDPARSE_UNKNOWN)(const char* text, ULONGLONG* value);

//XEDParse enums
enum XEDPARSE_STATUS
{
    XEDPARSE_ERROR = 0,
    XEDPARSE_OK = 1
};

//XEDParse structs
#pragma pack(push,8)
struct XEDPARSE
{
    bool x64; // use 64-bit instructions
    ULONGLONG cip; //instruction pointer (for relative addressing)
    unsigned int dest_size; //destination size (returned by XEDParse)
    CBXEDPARSE_UNKNOWN cbUnknown; //unknown operand callback
    unsigned char dest[XEDPARSE_MAXASMSIZE]; //destination buffer
    char instr[XEDPARSE_MAXBUFSIZE]; //instruction text
    char error[XEDPARSE_MAXBUFSIZE]; //error text (in case of an error)
};
#pragma pack(pop)

#ifdef __cplusplus
extern "C"
{
#endif

XEDPARSE_EXPORT XEDPARSE_STATUS XEDPARSE_CALL XEDParseAssemble(XEDPARSE* XEDParse);

#ifdef __cplusplus
}
#endif

#endif // _XEDPARSE_H

```

`plugin/sdk/_dbgfunctions.h`:

```h
#ifndef _DBGFUNCTIONS_H
#define _DBGFUNCTIONS_H

#ifndef __cplusplus
#include <stdbool.h>
#else
#include <string>
#endif

typedef struct
{
    char mod[MAX_MODULE_SIZE];
    duint addr;
    unsigned char oldbyte;
    unsigned char newbyte;
} DBGPATCHINFO;

typedef struct
{
    duint addr;
    duint from;
    duint to;
    char comment[MAX_COMMENT_SIZE];
} DBGCALLSTACKENTRY;

typedef struct
{
    int total;
    DBGCALLSTACKENTRY* entries;
} DBGCALLSTACK;

typedef struct
{
    duint addr;
    duint handler;
} DBGSEHRECORD;

typedef struct
{
    duint total;
    DBGSEHRECORD* records;
} DBGSEHCHAIN;

typedef struct
{
    DWORD dwProcessId;
    char szExeFile[MAX_PATH];
    char szExeMainWindowTitle[MAX_PATH];
    char szExeArgs[MAX_COMMAND_LINE_SIZE];
} DBGPROCESSINFO;

typedef struct
{
    DWORD rva;
    BYTE type;
    WORD size;
} DBGRELOCATIONINFO;

typedef enum
{
    InstructionBody = 0,
    InstructionHeading = 1,
    InstructionTailing = 2,
    InstructionOverlapped = 3, // The byte was executed with differing instruction base addresses
    DataByte,  // This and the following is not implemented yet.
    DataWord,
    DataDWord,
    DataQWord,
    DataFloat,
    DataDouble,
    DataLongDouble,
    DataXMM,
    DataYMM,
    DataMMX,
    DataMixed, //the byte is accessed in multiple ways
    InstructionDataMixed //the byte is both executed and written
} TRACERECORDBYTETYPE;

typedef enum
{
    TraceRecordNone,
    TraceRecordBitExec,
    TraceRecordByteWithExecTypeAndCounter,
    TraceRecordWordWithExecTypeAndCounter
} TRACERECORDTYPE;

typedef struct
{
    duint Handle;
    unsigned char TypeNumber;
    unsigned int GrantedAccess;
} HANDLEINFO;

// The longest ip address is 1234:6789:1234:6789:1234:6789:123.567.901.345 (46 bytes)
#define TCP_ADDR_SIZE 50

typedef struct
{
    char RemoteAddress[TCP_ADDR_SIZE];
    unsigned short RemotePort;
    char LocalAddress[TCP_ADDR_SIZE];
    unsigned short LocalPort;
    char StateText[TCP_ADDR_SIZE];
    unsigned int State;
} TCPCONNECTIONINFO;

typedef struct
{
    duint handle;
    duint parent;
    DWORD threadId;
    DWORD style;
    DWORD styleEx;
    duint wndProc;
    bool enabled;
    RECT position;
    char windowTitle[MAX_COMMENT_SIZE];
    char windowClass[MAX_COMMENT_SIZE];
} WINDOW_INFO;

typedef struct
{
    duint addr;
    duint size;
    duint flags;
} HEAPINFO;

typedef struct
{
    const char* name;
    duint value;
} CONSTANTINFO;

typedef enum
{
    MODSYMUNLOADED = 0,
    MODSYMLOADING,
    MODSYMLOADED
} MODULESYMBOLSTATUS;

typedef enum
{
    bpf_type, // number (read-only, BPXTYPE)
    bpf_offset, // number (read-only)
    bpf_address, // number (read-only)
    bpf_enabled, // number (bool)
    bpf_singleshoot, // number (bool)
    bpf_active, // number (read-only)
    bpf_silent, // number (bool)
    bpf_typeex, // number (read-only, BPHWTYPE/BPMEMTYPE/BPDLLTYPE/BPEXTYPE)
    bpf_hwsize, // number (read-only, BPHWSIZE)
    bpf_hwslot, // number (read-only)
    bpf_oldbytes, // number (read-only, uint16_t)
    bpf_fastresume, // number (bool)
    bpf_hitcount, // number
    bpf_module, // text (read-only)
    bpf_name, // text
    bpf_breakcondition, // text
    bpf_logtext, // text
    bpf_logcondition, // text
    bpf_commandtext, // text
    bpf_commandcondition, // text
    bpf_logfile, // text
} BP_FIELD;

// An instance of this structure represents a reference to a breakpoint.
// Use DbgFunctions()->BpRefXxx() list/create references.
// Use DbgFunctions()->BpXxx() to manipulate breakpoints with the references.
struct BP_REF
{
    BPXTYPE type;
    duint module;
    duint offset;

    // C++ helper functions
#ifdef __cplusplus
    bool GetField(BP_FIELD field, duint & value);
    bool GetField(BP_FIELD field, bool & value);
    bool SetField(BP_FIELD field, duint value);
    bool GetField(BP_FIELD field, std::string & value);
    bool SetField(BP_FIELD field, const std::string & value);

    template<class T, typename = typename std::enable_if< std::is_enum<T>::value, T >::type>
    void GetField(BP_FIELD field, T & value)
    {
        duint n = 0;
        GetField(field, n);
        value = (T)n;
    }
#endif // __cplusplus
};

typedef struct BP_REF BP_REF;

typedef void(*CBSTRING)(const char* str, void* userdata);

//The list of all the DbgFunctions() return value.
//WARNING: This list is append only. Do not insert things in the middle or plugins would break.
typedef struct DBGFUNCTIONS_
{
    bool (*AssembleAtEx)(duint addr, const char* instruction, char* error, bool fillnop);
    bool (*SectionFromAddr)(duint addr, char* section);
    bool (*ModNameFromAddr)(duint addr, char* modname, bool extension);
    duint(*ModBaseFromAddr)(duint addr);
    duint(*ModBaseFromName)(const char* modname);
    duint(*ModSizeFromAddr)(duint addr);
    bool (*Assemble)(duint addr, unsigned char* dest, int* size, const char* instruction, char* error);
    bool (*PatchGet)(duint addr);
    bool (*PatchInRange)(duint start, duint end);
    bool (*MemPatch)(duint va, const unsigned char* src, duint size);
    void (*PatchRestoreRange)(duint start, duint end);
    bool (*PatchEnum)(DBGPATCHINFO* patchlist, size_t* cbsize);
    bool (*PatchRestore)(duint addr);
    int (*PatchFile)(DBGPATCHINFO* patchlist, int count, const char* szFileName, char* error);
    int (*ModPathFromAddr)(duint addr, char* path, int size);
    int (*ModPathFromName)(const char* modname, char* path, int size);
    bool (*DisasmFast)(const unsigned char* data, duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
    void (*MemUpdateMap)();
    void (*GetCallStack)(DBGCALLSTACK* callstack);
    void (*GetSEHChain)(DBGSEHCHAIN* sehchain);
    void (*SymbolDownloadAllSymbols)(const char* szSymbolStore);
    bool (*GetJitAuto)(bool* jitauto);
    bool (*GetJit)(char* jit, bool x64);
    bool (*GetDefJit)(char* defjit);
    bool (*GetProcessList)(DBGPROCESSINFO** entries, int* count);
    bool (*GetPageRights)(duint addr, char* rights);
    bool (*SetPageRights)(duint addr, const char* rights);
    bool (*PageRightsToString)(DWORD protect, char* rights);
    bool (*IsProcessElevated)();
    bool (*GetCmdline)(char* cmdline, size_t* cbsize);
    bool (*SetCmdline)(const char* cmdline);
    duint(*FileOffsetToVa)(const char* modname, duint offset);
    duint(*VaToFileOffset)(duint va);
    duint(*GetAddrFromLine)(const char* szSourceFile, int line, duint* displacement);
    bool (*GetSourceFromAddr)(duint addr, char* szSourceFile, int* line);
    bool (*ValFromString)(const char* string, duint* value);
    bool (*PatchGetEx)(duint addr, DBGPATCHINFO* info);
    bool (*GetBridgeBp)(BPXTYPE type, duint addr, BRIDGEBP* bp);
    bool (*StringFormatInline)(const char* format, size_t resultSize, char* result);
    void (*GetMnemonicBrief)(const char* mnem, size_t resultSize, char* result);
    unsigned int (*GetTraceRecordHitCount)(duint address);
    TRACERECORDBYTETYPE(*GetTraceRecordByteType)(duint address);
    bool (*SetTraceRecordType)(duint pageAddress, TRACERECORDTYPE type);
    TRACERECORDTYPE(*GetTraceRecordType)(duint pageAddress);
    bool (*EnumHandles)(ListOf(HANDLEINFO) handles);
    bool (*GetHandleName)(duint handle, char* name, size_t nameSize, char* typeName, size_t typeNameSize);
    bool (*EnumTcpConnections)(ListOf(TCPCONNECTIONINFO) connections);
    duint(*GetDbgEvents)();
    MODULEPARTY(*ModGetParty)(duint base);
    void (*ModSetParty)(duint base, MODULEPARTY party);
    bool (*WatchIsWatchdogTriggered)(unsigned int id);
    bool (*MemIsCodePage)(duint addr, bool refresh);
    bool (*AnimateCommand)(const char* command);
    void (*DbgSetDebuggeeInitScript)(const char* fileName);
    const char* (*DbgGetDebuggeeInitScript)();
    bool (*EnumWindows)(ListOf(WINDOW_INFO) windows);
    bool (*EnumHeaps)(ListOf(HEAPINFO) heaps);
    bool (*ThreadGetName)(DWORD tid, char* name);
    bool (*IsDepEnabled)();
    void (*GetCallStackEx)(DBGCALLSTACK* callstack, bool cache);
    bool (*GetUserComment)(duint addr, char* comment);
    void (*EnumConstants)(ListOf(CONSTANTINFO) constants);
    void (*EnumErrorCodes)(ListOf(CONSTANTINFO) constants);
    void (*EnumExceptions)(ListOf(CONSTANTINFO) constants);
    duint(*MemBpSize)(duint addr);
    bool (*ModRelocationsFromAddr)(duint addr, ListOf(DBGRELOCATIONINFO) relocations);
    bool (*ModRelocationAtAddr)(duint addr, DBGRELOCATIONINFO* relocation);
    bool (*ModRelocationsInRange)(duint addr, duint size, ListOf(DBGRELOCATIONINFO) relocations);
    duint(*DbGetHash)();
    int (*SymAutoComplete)(const char* Search, char** Buffer, int MaxSymbols);
    void (*RefreshModuleList)();
    duint(*GetAddrFromLineEx)(duint mod, const char* szSourceFile, int line);
    MODULESYMBOLSTATUS(*ModSymbolStatus)(duint mod);
    void (*GetCallStackByThread)(HANDLE thread, DBGCALLSTACK* callstack);
    void (*EnumStructs)(CBSTRING callback, void* userdata);
    BP_REF* (*BpRefList)(duint* count);
    bool (*BpRefVa)(BP_REF* ref, BPXTYPE type, duint va);
    bool (*BpRefRva)(BP_REF* ref, BPXTYPE type, const char* module, duint rva);
    void (*BpRefDll)(BP_REF* ref, const char* module);
    void (*BpRefException)(BP_REF* ref, unsigned int code);
    bool (*BpRefExists)(const BP_REF* ref);
    bool (*BpGetFieldNumber)(const BP_REF* ref, BP_FIELD field, duint* value);
    bool (*BpSetFieldNumber)(const BP_REF* ref, BP_FIELD field, duint value);
    bool (*BpGetFieldText)(const BP_REF* ref, BP_FIELD field, CBSTRING callback, void* userdata);
    bool (*BpSetFieldText)(const BP_REF* ref, BP_FIELD field, const char* value);
} DBGFUNCTIONS;

#ifdef __cplusplus
inline bool BP_REF::GetField(BP_FIELD field, duint & value)
{
    return DbgFunctions()->BpGetFieldNumber(this, field, &value);
}

inline bool BP_REF::GetField(BP_FIELD field, bool & value)
{
    duint n = 0;
    if(!DbgFunctions()->BpGetFieldNumber(this, field, &n))
        return false;
    value = !!n;
    return true;
}

inline bool BP_REF::SetField(BP_FIELD field, duint value)
{
    return DbgFunctions()->BpSetFieldNumber(this, field, value);
}

inline bool BP_REF::GetField(BP_FIELD field, std::string & value)
{
    return DbgFunctions()->BpGetFieldText(this, field, [](const char* str, void* userdata)
    {
        *(std::string*)userdata = str;
    }, &value);
}

inline bool BP_REF::SetField(BP_FIELD field, const std::string & value)
{
    return DbgFunctions()->BpSetFieldText(this, field, value.c_str());
}
#endif // __cplusplus

#ifdef BUILD_DBG

const DBGFUNCTIONS* dbgfunctionsget();
void dbgfunctionsinit();

#endif //BUILD_DBG

#endif //_DBGFUNCTIONS_H

```

`plugin/sdk/_plugin_types.h`:

```h
#ifndef _PLUGIN_DATA_H
#define _PLUGIN_DATA_H

#ifdef BUILD_DBG

#include "_global.h"
#include "jansson/jansson.h"
#pragma warning(push)
#pragma warning(disable:4091)
#include <dbghelp.h>
#pragma warning(pop)

#else

#include <Windows.h>

#ifdef __GNUC__
#include "dbghelp/dbghelp.h"
#else
#pragma warning(push)
#pragma warning(disable:4091)
#include <DbgHelp.h>
#pragma warning(pop)
#endif // __GNUC__

#ifndef deflen
#define deflen 1024
#endif // deflen

#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "jansson/jansson.h"

#endif // BUILD_DBG

#endif // _PLUGIN_DATA_H

```

`plugin/sdk/_plugins.h`:

```h
#ifndef _PLUGINS_H
#define _PLUGINS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifndef PLUG_IMPEXP
#ifdef BUILD_DBG
#define PLUG_IMPEXP __declspec(dllexport)
#else
#define PLUG_IMPEXP __declspec(dllimport)
#endif //BUILD_DBG
#endif //PLUG_IMPEXP

#include "_plugin_types.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

//defines
#define PLUG_SDKVERSION 1

#define PLUG_DB_LOADSAVE_DATA 1
#define PLUG_DB_LOADSAVE_ALL 2

//structures
typedef struct
{
    //provided by the debugger
    int pluginHandle;
    //provided by the pluginit function
    int sdkVersion;
    int pluginVersion;
    char pluginName[256];
} PLUG_INITSTRUCT;

typedef struct
{
    //provided by the debugger
    HWND hwndDlg; //gui window handle
    int hMenu; //plugin menu handle
    int hMenuDisasm; //plugin disasm menu handle
    int hMenuDump; //plugin dump menu handle
    int hMenuStack; //plugin stack menu handle
    int hMenuGraph; //plugin graph menu handle
    int hMenuMemmap; //plugin memory map menu handle
    int hMenuSymmod; //plugin symbol module menu handle
} PLUG_SETUPSTRUCT;

typedef struct
{
    void* data; //user data
} PLUG_SCRIPTSTRUCT;

//callback structures
typedef struct
{
    const char* szFileName;
} PLUG_CB_INITDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPPINGDEBUG;

typedef struct
{
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
    IMAGEHLP_MODULE64* modInfo;
    const char* DebugFileName;
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_CREATEPROCESS;

typedef struct
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess;
} PLUG_CB_EXITPROCESS;

typedef struct
{
    CREATE_THREAD_DEBUG_INFO* CreateThread;
    DWORD dwThreadId;
} PLUG_CB_CREATETHREAD;

typedef struct
{
    EXIT_THREAD_DEBUG_INFO* ExitThread;
    DWORD dwThreadId;
} PLUG_CB_EXITTHREAD;

typedef struct
{
    void* reserved;
} PLUG_CB_SYSTEMBREAKPOINT;

typedef struct
{
    LOAD_DLL_DEBUG_INFO* LoadDll;
    IMAGEHLP_MODULE64* modInfo;
    const char* modname;
} PLUG_CB_LOADDLL;

typedef struct
{
    UNLOAD_DLL_DEBUG_INFO* UnloadDll;
} PLUG_CB_UNLOADDLL;

typedef struct
{
    OUTPUT_DEBUG_STRING_INFO* DebugString;
} PLUG_CB_OUTPUTDEBUGSTRING;

typedef struct
{
    EXCEPTION_DEBUG_INFO* Exception;
} PLUG_CB_EXCEPTION;

typedef struct
{
    BRIDGEBP* breakpoint;
} PLUG_CB_BREAKPOINT;

typedef struct
{
    void* reserved;
} PLUG_CB_PAUSEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_RESUMEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STEPPED;

typedef struct
{
    DWORD dwProcessId;
} PLUG_CB_ATTACH;

typedef struct
{
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_DETACH;

typedef struct
{
    DEBUG_EVENT* DebugEvent;
} PLUG_CB_DEBUGEVENT;

typedef struct
{
    int hEntry;
} PLUG_CB_MENUENTRY;

typedef struct
{
    MSG* message;
    long* result;
    bool retval;
} PLUG_CB_WINEVENT;

typedef struct
{
    MSG* message;
    bool retval;
} PLUG_CB_WINEVENTGLOBAL;

typedef struct
{
    json_t* root;
    int loadSaveType;
} PLUG_CB_LOADSAVEDB;

typedef struct
{
    const char* symbol;
    bool retval;
} PLUG_CB_FILTERSYMBOL;

typedef struct
{
    duint cip;
    bool stop;
} PLUG_CB_TRACEEXECUTE;

typedef struct
{
    int hWindow;
    duint VA;
} PLUG_CB_SELCHANGED;

typedef struct
{
    BridgeCFGraphList graph;
} PLUG_CB_ANALYZE;

typedef struct
{
    duint addr;
    BRIDGE_ADDRINFO* addrinfo;
    bool retval;
} PLUG_CB_ADDRINFO;

typedef struct
{
    const char* string;
    duint value;
    int* value_size;
    bool* isvar;
    bool* hexonly;
    bool retval;
} PLUG_CB_VALFROMSTRING;

typedef struct
{
    const char* string;
    duint value;
    bool retval;
} PLUG_CB_VALTOSTRING;

typedef struct
{
    GUIMENUTYPE hMenu;
} PLUG_CB_MENUPREPARE;

typedef enum
{
    ValueTypeNumber,
    ValueTypeString,
    // Types below cannot be used for values, only for registration
    ValueTypeAny,
    ValueTypeOptionalNumber,
    ValueTypeOptionalString,
    ValueTypeOptionalAny,
} ValueType;

typedef struct
{
    const char* ptr; // Should be allocated with BridgeAlloc
    bool isOwner; // When set to true BridgeFree will be called on ptr
} StringValue;

typedef struct
{
    ValueType type;
    duint number;
    StringValue string;
} ExpressionValue;

//enums
typedef enum
{
    CB_INITDEBUG, //PLUG_CB_INITDEBUG
    CB_STOPDEBUG, //PLUG_CB_STOPDEBUG
    CB_CREATEPROCESS, //PLUG_CB_CREATEPROCESS
    CB_EXITPROCESS, //PLUG_CB_EXITPROCESS
    CB_CREATETHREAD, //PLUG_CB_CREATETHREAD
    CB_EXITTHREAD, //PLUG_CB_EXITTHREAD
    CB_SYSTEMBREAKPOINT, //PLUG_CB_SYSTEMBREAKPOINT
    CB_LOADDLL, //PLUG_CB_LOADDLL
    CB_UNLOADDLL, //PLUG_CB_UNLOADDLL
    CB_OUTPUTDEBUGSTRING, //PLUG_CB_OUTPUTDEBUGSTRING
    CB_EXCEPTION, //PLUG_CB_EXCEPTION
    CB_BREAKPOINT, //PLUG_CB_BREAKPOINT
    CB_PAUSEDEBUG, //PLUG_CB_PAUSEDEBUG
    CB_RESUMEDEBUG, //PLUG_CB_RESUMEDEBUG
    CB_STEPPED, //PLUG_CB_STEPPED
    CB_ATTACH, //PLUG_CB_ATTACHED (before attaching, after CB_INITDEBUG)
    CB_DETACH, //PLUG_CB_DETACH (before detaching, before CB_STOPDEBUG)
    CB_DEBUGEVENT, //PLUG_CB_DEBUGEVENT (called on any debug event)
    CB_MENUENTRY, //PLUG_CB_MENUENTRY
    CB_WINEVENT, //PLUG_CB_WINEVENT
    CB_WINEVENTGLOBAL, //PLUG_CB_WINEVENTGLOBAL
    CB_LOADDB, //PLUG_CB_LOADSAVEDB
    CB_SAVEDB, //PLUG_CB_LOADSAVEDB
    CB_FILTERSYMBOL, //PLUG_CB_FILTERSYMBOL
    CB_TRACEEXECUTE, //PLUG_CB_TRACEEXECUTE
    CB_SELCHANGED, //PLUG_CB_SELCHANGED
    CB_ANALYZE, //PLUG_CB_ANALYZE
    CB_ADDRINFO, //PLUG_CB_ADDRINFO
    CB_VALFROMSTRING, //PLUG_CB_VALFROMSTRING
    CB_VALTOSTRING, //PLUG_CB_VALTOSTRING
    CB_MENUPREPARE, //PLUG_CB_MENUPREPARE
    CB_STOPPINGDEBUG, //PLUG_CB_STOPDEBUG
    CB_LAST
} CBTYPE;

typedef enum
{
    FORMAT_ERROR, //generic failure (no message)
    FORMAT_SUCCESS, //success
    FORMAT_ERROR_MESSAGE, //formatting failed but an error was put in the buffer (there are always at least 511 characters available).
    FORMAT_BUFFER_TOO_SMALL //buffer too small (x64dbg will retry until the buffer is big enough)
} FORMATRESULT;

//typedefs
typedef void (*CBPLUGIN)(CBTYPE cbType, void* callbackInfo);
typedef bool (*CBPLUGINCOMMAND)(int argc, char** argv);
typedef void (*CBPLUGINSCRIPT)();
typedef duint(*CBPLUGINEXPRFUNCTION)(int argc, const duint* argv, void* userdata);
typedef bool(*CBPLUGINEXPRFUNCTIONEX)(ExpressionValue* result, int argc, const ExpressionValue* argv, void* userdata);
typedef FORMATRESULT(*CBPLUGINFORMATFUNCTION)(char* dest, size_t destCount, int argc, char* argv[], duint value, void* userdata);
typedef bool (*CBPLUGINPREDICATE)(void* userdata);

//exports
#ifdef __cplusplus
extern "C"
{
#endif

PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
PLUG_IMPEXP bool _plugin_unregistercallback(int pluginHandle, CBTYPE cbType);
PLUG_IMPEXP bool _plugin_registercommand(int pluginHandle, const char* command, CBPLUGINCOMMAND cbCommand, bool debugonly);
PLUG_IMPEXP bool _plugin_unregistercommand(int pluginHandle, const char* command);
PLUG_IMPEXP void _plugin_logprintf(const char* format, ...);
PLUG_IMPEXP void _plugin_lograw_html(const char* text);
PLUG_IMPEXP void _plugin_logputs(const char* text);
PLUG_IMPEXP void _plugin_logprint(const char* text);
PLUG_IMPEXP void _plugin_debugpause();
PLUG_IMPEXP void _plugin_debugskipexceptions(bool skip);
PLUG_IMPEXP int _plugin_menuadd(int hMenu, const char* title);
PLUG_IMPEXP bool _plugin_menuaddentry(int hMenu, int hEntry, const char* title);
PLUG_IMPEXP bool _plugin_menuaddseparator(int hMenu);
PLUG_IMPEXP bool _plugin_menuclear(int hMenu);
PLUG_IMPEXP void _plugin_menuseticon(int hMenu, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentryseticon(int pluginHandle, int hEntry, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentrysetchecked(int pluginHandle, int hEntry, bool checked);
PLUG_IMPEXP void _plugin_menusetvisible(int pluginHandle, int hMenu, bool visible);
PLUG_IMPEXP void _plugin_menuentrysetvisible(int pluginHandle, int hEntry, bool visible);
PLUG_IMPEXP void _plugin_menusetname(int pluginHandle, int hMenu, const char* name);
PLUG_IMPEXP void _plugin_menuentrysetname(int pluginHandle, int hEntry, const char* name);
PLUG_IMPEXP void _plugin_menuentrysethotkey(int pluginHandle, int hEntry, const char* hotkey);
PLUG_IMPEXP bool _plugin_menuremove(int hMenu);
PLUG_IMPEXP bool _plugin_menuentryremove(int pluginHandle, int hEntry);
PLUG_IMPEXP void _plugin_startscript(CBPLUGINSCRIPT cbScript);
PLUG_IMPEXP bool _plugin_waituntilpaused();
PLUG_IMPEXP bool _plugin_registerexprfunction(int pluginHandle, const char* name, int argc, CBPLUGINEXPRFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_registerexprfunctionex(int pluginHandle, const char* name, ValueType returnType, const ValueType* argTypes, size_t argCount, CBPLUGINEXPRFUNCTIONEX cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterexprfunction(int pluginHandle, const char* name);
PLUG_IMPEXP bool _plugin_unload(const char* pluginName);
PLUG_IMPEXP bool _plugin_load(const char* pluginName);
PLUG_IMPEXP duint _plugin_hash(const void* data, duint size);
PLUG_IMPEXP bool _plugin_registerformatfunction(int pluginHandle, const char* type, CBPLUGINFORMATFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterformatfunction(int pluginHandle, const char* type);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _PLUGINS_H

```

`plugin/sdk/_scriptapi.h`:

```h
#ifndef _SCRIPT_API_H
#define _SCRIPT_API_H

#include "_plugins.h"

#define SCRIPT_EXPORT PLUG_IMPEXP

#endif //_SCRIPT_API_H
```

`plugin/sdk/_scriptapi_argument.h`:

```h
#ifndef _SCRIPTAPI_ARGUMENT_H
#define _SCRIPTAPI_ARGUMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Argument
    {
        struct ArgumentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const ArgumentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, ArgumentInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual = false);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(ArgumentInfo) list); //caller has the responsibility to free the list
    }; //Argument
}; //Script

#endif //_SCRIPTAPI_ARGUMENT_H
```

`plugin/sdk/_scriptapi_assembler.h`:

```h
#ifndef _SCRIPTAPI_ASSEMBLER_H
#define _SCRIPTAPI_ASSEMBLER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Assembler
    {
        SCRIPT_EXPORT bool Assemble(duint addr, unsigned char* dest, int* size, const char* instruction); //dest[16]
        SCRIPT_EXPORT bool AssembleEx(duint addr, unsigned char* dest, int* size, const char* instruction, char* error); //dest[16], error[MAX_ERROR_SIZE]
        SCRIPT_EXPORT bool AssembleMem(duint addr, const char* instruction);
        SCRIPT_EXPORT bool AssembleMemEx(duint addr, const char* instruction, int* size, char* error, bool fillnop); //error[MAX_ERROR_SIZE]
    }; //Assembler
}; //Script

#endif //_SCRIPTAPI_ASSEMBLER_H
```

`plugin/sdk/_scriptapi_bookmark.h`:

```h
#ifndef _SCRIPTAPI_BOOKMARK_H
#define _SCRIPTAPI_BOOKMARK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Bookmark
    {
        struct BookmarkInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, bool manual = false);
        SCRIPT_EXPORT bool Set(const BookmarkInfo* info);
        SCRIPT_EXPORT bool Get(duint addr);
        SCRIPT_EXPORT bool GetInfo(duint addr, BookmarkInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(BookmarkInfo) list); //caller has the responsibility to free the list
    }; //Bookmark
}; //Script

#endif //_SCRIPTAPI_BOOKMARK_H
```

`plugin/sdk/_scriptapi_comment.h`:

```h
#ifndef _SCRIPTAPI_COMMENT_H
#define _SCRIPTAPI_COMMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Comment
    {
        struct CommentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const CommentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_COMMENT_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, CommentInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(CommentInfo) list); //caller has the responsibility to free the list
    }; //Comment
}; //Script

#endif //_SCRIPTAPI_COMMENT_H
```

`plugin/sdk/_scriptapi_debug.h`:

```h
#ifndef _SCRIPTAPI_DEBUG_H
#define _SCRIPTAPI_DEBUG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Debug
    {
        enum HardwareType
        {
            HardwareAccess,
            HardwareWrite,
            HardwareExecute
        };

        SCRIPT_EXPORT void Wait();
        SCRIPT_EXPORT void Run();
        SCRIPT_EXPORT void Pause();
        SCRIPT_EXPORT void Stop();
        SCRIPT_EXPORT void StepIn();
        SCRIPT_EXPORT void StepOver();
        SCRIPT_EXPORT void StepOut();
        SCRIPT_EXPORT bool SetBreakpoint(duint address);
        SCRIPT_EXPORT bool DeleteBreakpoint(duint address);
        SCRIPT_EXPORT bool DisableBreakpoint(duint address);
        SCRIPT_EXPORT bool SetHardwareBreakpoint(duint address, HardwareType type = HardwareExecute);
        SCRIPT_EXPORT bool DeleteHardwareBreakpoint(duint address);
    }; //Debug
}; //Script

#endif //_SCRIPTAPI_DEBUG_H
```

`plugin/sdk/_scriptapi_flag.h`:

```h
#ifndef _SCRIPTAPI_FLAG_H
#define _SCRIPTAPI_FLAG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Flag
    {
        enum FlagEnum
        {
            ZF,
            OF,
            CF,
            PF,
            SF,
            TF,
            AF,
            DF,
            IF
        };

        SCRIPT_EXPORT bool Get(FlagEnum flag);
        SCRIPT_EXPORT bool Set(FlagEnum flag, bool value);

        SCRIPT_EXPORT bool GetZF();
        SCRIPT_EXPORT bool SetZF(bool value);
        SCRIPT_EXPORT bool GetOF();
        SCRIPT_EXPORT bool SetOF(bool value);
        SCRIPT_EXPORT bool GetCF();
        SCRIPT_EXPORT bool SetCF(bool value);
        SCRIPT_EXPORT bool GetPF();
        SCRIPT_EXPORT bool SetPF(bool value);
        SCRIPT_EXPORT bool GetSF();
        SCRIPT_EXPORT bool SetSF(bool value);
        SCRIPT_EXPORT bool GetTF();
        SCRIPT_EXPORT bool SetTF(bool value);
        SCRIPT_EXPORT bool GetAF();
        SCRIPT_EXPORT bool SetAF(bool value);
        SCRIPT_EXPORT bool GetDF();
        SCRIPT_EXPORT bool SetDF(bool value);
        SCRIPT_EXPORT bool GetIF();
        SCRIPT_EXPORT bool SetIF(bool value);
    };
};

#endif //_SCRIPTAPI_FLAG_H
```

`plugin/sdk/_scriptapi_function.h`:

```h
#ifndef _SCRIPTAPI_FUNCTION_H
#define _SCRIPTAPI_FUNCTION_H

#include "_scriptapi.h"

namespace Script
{
    namespace Function
    {
        struct FunctionInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const FunctionInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, FunctionInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(FunctionInfo) list); //caller has the responsibility to free the list
    }; //Function
}; //Script

#endif //_SCRIPTAPI_FUNCTION_H

```

`plugin/sdk/_scriptapi_gui.h`:

```h
#ifndef _SCRIPTAPI_GUI_H
#define _SCRIPTAPI_GUI_H

#include "_scriptapi.h"

namespace Script
{
    namespace Gui
    {
        namespace Disassembly
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Disassembly

        namespace Dump
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Dump

        namespace Stack
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Stack

        namespace Graph
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //Graph

        namespace MemMap
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //MemoryMap

        namespace SymMod
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //SymMod
    }; //Gui

    namespace Gui
    {
        enum Window
        {
            DisassemblyWindow,
            DumpWindow,
            StackWindow,
            GraphWindow,
            MemMapWindow,
            SymModWindow
        };

        SCRIPT_EXPORT bool SelectionGet(Window window, duint* start, duint* end);
        SCRIPT_EXPORT bool SelectionSet(Window window, duint start, duint end);
        SCRIPT_EXPORT duint SelectionGetStart(Window window);
        SCRIPT_EXPORT duint SelectionGetEnd(Window window);
        SCRIPT_EXPORT void Message(const char* message);
        SCRIPT_EXPORT bool MessageYesNo(const char* message);
        SCRIPT_EXPORT bool InputLine(const char* title, char* text); //text[GUI_MAX_LINE_SIZE]
        SCRIPT_EXPORT bool InputValue(const char* title, duint* value);
        SCRIPT_EXPORT void Refresh();
        SCRIPT_EXPORT void AddQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void ShowQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void CloseQWidgetTab(void* qWidget);

    }; //Gui
}; //Script

#endif //_SCRIPTAPI_GUI_H
```

`plugin/sdk/_scriptapi_label.h`:

```h
#ifndef _SCRIPTAPI_LABEL_H
#define _SCRIPTAPI_LABEL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Label
    {
        struct LabelInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false, bool temporary = false);
        SCRIPT_EXPORT bool Set(const LabelInfo* info);
        SCRIPT_EXPORT bool FromString(const char* label, duint* addr);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_LABEL_SIZE]
        SCRIPT_EXPORT bool IsTemporary(duint addr);
        SCRIPT_EXPORT bool GetInfo(duint addr, LabelInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(LabelInfo) list); //caller has the responsibility to free the list
    }; //Label
}; //Script

#endif //_SCRIPTAPI_LABEL_H
```

`plugin/sdk/_scriptapi_memory.h`:

```h
#ifndef _SCRIPTAPI_MEMORY_H
#define _SCRIPTAPI_MEMORY_H

#include "_scriptapi.h"

namespace Script
{
    namespace Memory
    {
        SCRIPT_EXPORT bool Read(duint addr, void* data, duint size, duint* sizeRead);
        SCRIPT_EXPORT bool Write(duint addr, const void* data, duint size, duint* sizeWritten);
        SCRIPT_EXPORT bool IsValidPtr(duint addr);
        SCRIPT_EXPORT duint RemoteAlloc(duint addr, duint size);
        SCRIPT_EXPORT bool RemoteFree(duint addr);
        SCRIPT_EXPORT unsigned int GetProtect(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT bool SetProtect(duint addr, unsigned int protect, duint size);
        SCRIPT_EXPORT duint GetBase(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetSize(duint addr, bool reserved = false, bool cache = true);

        SCRIPT_EXPORT unsigned char ReadByte(duint addr);
        SCRIPT_EXPORT bool WriteByte(duint addr, unsigned char data);
        SCRIPT_EXPORT unsigned short ReadWord(duint addr);
        SCRIPT_EXPORT bool WriteWord(duint addr, unsigned short data);
        SCRIPT_EXPORT unsigned int ReadDword(duint addr);
        SCRIPT_EXPORT bool WriteDword(duint addr, unsigned int data);
        SCRIPT_EXPORT unsigned long long ReadQword(duint addr);
        SCRIPT_EXPORT bool WriteQword(duint addr, unsigned long long data);
        SCRIPT_EXPORT duint ReadPtr(duint addr);
        SCRIPT_EXPORT bool WritePtr(duint addr, duint data);
    }; //Memory
}; //Script

#endif //_SCRIPTAPI_MEMORY_H
```

`plugin/sdk/_scriptapi_misc.h`:

```h
#ifndef _SCRIPTAPI_MISC_H
#define _SCRIPTAPI_MISC_H

#include "_scriptapi.h"

namespace Script
{
    namespace Misc
    {
        /// <summary>
        /// Evaluates an expression and returns the result. Analagous to using the Command field in x64dbg.
        ///
        /// Expressions can consist of memory locations, registers, flags, API names, labels, symbols, variables etc.
        /// <example>
        /// Shows how to read from stack at esp+8
        /// <code>
        ///     bool success = ParseExpression("[esp+8]", &amp;val)
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="expression">The expression to evaluate.</param>
        /// <param name="value">The result of the expression.</param>
        /// <returns>True on success, False on failure.</returns>
        SCRIPT_EXPORT bool ParseExpression(const char* expression, duint* value);

        /// <summary>
        /// Returns the address of a function in the debuggee's memory space.
        /// </summary>
        /// <example>
        /// <code>
        ///     duint addr = RemoteGetProcAddress("kernel32.dll", "GetProcAddress")
        /// </code>
        /// </example>
        /// <param name="module">The name of the module.</param>
        /// <param name="api">The name of the function.</param>
        /// <returns>The address of the function in the debuggee.</returns>
        SCRIPT_EXPORT duint RemoteGetProcAddress(const char* module, const char* api);

        /// <summary>
        /// Returns the address for a label created in the disassembly window.
        /// </summary>
        /// <example>
        /// <code>
        ///     duint addr = ResolveLabel("sneaky_crypto")
        /// </code>
        /// </example>
        /// <param name="label">The name of the label to resolve.</param>
        /// <returns>The memory address for the label.</returns>
        SCRIPT_EXPORT duint ResolveLabel(const char* label);

        /// <summary>
        /// Allocates the requested number of bytes from x64dbg's default process heap.
        ///
        /// Note: this allocation is in the debugger, not the debuggee.
        ///
        /// Memory allocated using this function should be Free'd after use.
        /// </summary>
        /// <example>
        /// <code>
        ///     void* addr = Alloc(0x100000)
        /// </code>
        /// </example>
        /// <param name="size">Number of bytes to allocate.</param>
        /// <returns>A pointer to the newly allocated memory.</returns>
        SCRIPT_EXPORT void* Alloc(duint size);

        /// <summary>
        /// Frees memory previously allocated by Alloc.
        /// </summary>
        /// <example>
        /// <code>
        ///     Free(addr)
        /// </code>
        /// </example>
        /// <param name="ptr">Pointer returned by Alloc.</param>
        /// <returns>Nothing.</returns>
        SCRIPT_EXPORT void Free(void* ptr);
    }; //Misc
}; //Script

#endif //_SCRIPTAPI_MISC_H
```

`plugin/sdk/_scriptapi_module.h`:

```h
#ifndef _SCRIPTAPI_MODULE_H
#define _SCRIPTAPI_MODULE_H

#include "_scriptapi.h"

namespace Script
{
    namespace Module
    {
        struct ModuleInfo
        {
            duint base;
            duint size;
            duint entry;
            int sectionCount;
            char name[MAX_MODULE_SIZE];
            char path[MAX_PATH];
        };

        struct ModuleSectionInfo
        {
            duint addr;
            duint size;
            char name[MAX_SECTION_SIZE * 5];
        };

        struct ModuleExport
        {
            duint ordinal;
            duint rva;
            duint va;
            bool forwarded;
            char forwardName[MAX_STRING_SIZE];
            char name[MAX_STRING_SIZE];
            char undecoratedName[MAX_STRING_SIZE];
        };

        struct ModuleImport
        {
            duint iatRva;
            duint iatVa;
            duint ordinal; //equal to -1 if imported by name
            char name[MAX_STRING_SIZE];
            char undecoratedName[MAX_STRING_SIZE];
        };

        SCRIPT_EXPORT bool InfoFromAddr(duint addr, ModuleInfo* info);
        SCRIPT_EXPORT bool InfoFromName(const char* name, ModuleInfo* info);
        SCRIPT_EXPORT duint BaseFromAddr(duint addr);
        SCRIPT_EXPORT duint BaseFromName(const char* name);
        SCRIPT_EXPORT duint SizeFromAddr(duint addr);
        SCRIPT_EXPORT duint SizeFromName(const char* name);
        SCRIPT_EXPORT bool NameFromAddr(duint addr, char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool PathFromAddr(duint addr, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool PathFromName(const char* name, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT duint EntryFromAddr(duint addr);
        SCRIPT_EXPORT duint EntryFromName(const char* name);
        SCRIPT_EXPORT int SectionCountFromAddr(duint addr);
        SCRIPT_EXPORT int SectionCountFromName(const char* name);
        SCRIPT_EXPORT bool SectionFromAddr(duint addr, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionFromName(const char* name, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionListFromAddr(duint addr, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool SectionListFromName(const char* name, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool GetMainModuleInfo(ModuleInfo* info);
        SCRIPT_EXPORT duint GetMainModuleBase();
        SCRIPT_EXPORT duint GetMainModuleSize();
        SCRIPT_EXPORT duint GetMainModuleEntry();
        SCRIPT_EXPORT int GetMainModuleSectionCount();
        SCRIPT_EXPORT bool GetMainModuleName(char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool GetMainModulePath(char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool GetMainModuleSectionList(ListOf(ModuleSectionInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetList(ListOf(ModuleInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetExports(const ModuleInfo* mod, ListOf(ModuleExport) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetImports(const ModuleInfo* mod, ListOf(ModuleImport) list); //caller has the responsibility to free the list
    }; //Module
}; //Script

#endif //_SCRIPTAPI_MODULE_H

```

`plugin/sdk/_scriptapi_pattern.h`:

```h
#ifndef _SCRIPTAPI_PATTERN_H
#define _SCRIPTAPI_PATTERN_H

#include "_scriptapi.h"

namespace Script
{
    namespace Pattern
    {
        SCRIPT_EXPORT duint Find(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT duint FindMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT void Write(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT void WriteMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT bool SearchAndReplace(unsigned char* data, duint datasize, const char* searchpattern, const char* replacepattern);
        SCRIPT_EXPORT bool SearchAndReplaceMem(duint start, duint size, const char* searchpattern, const char* replacepattern);
    };
};

#endif //_SCRIPTAPI_FIND_H
```

`plugin/sdk/_scriptapi_register.h`:

```h
#ifndef _SCRIPTAPI_REGISTER_H
#define _SCRIPTAPI_REGISTER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Register
    {
        enum RegisterEnum
        {
            DR0,
            DR1,
            DR2,
            DR3,
            DR6,
            DR7,

            EAX,
            AX,
            AH,
            AL,
            EBX,
            BX,
            BH,
            BL,
            ECX,
            CX,
            CH,
            CL,
            EDX,
            DX,
            DH,
            DL,
            EDI,
            DI,
            ESI,
            SI,
            EBP,
            BP,
            ESP,
            SP,
            EIP,

#ifdef _WIN64
            RAX,
            RBX,
            RCX,
            RDX,
            RSI,
            SIL,
            RDI,
            DIL,
            RBP,
            BPL,
            RSP,
            SPL,
            RIP,
            R8,
            R8D,
            R8W,
            R8B,
            R9,
            R9D,
            R9W,
            R9B,
            R10,
            R10D,
            R10W,
            R10B,
            R11,
            R11D,
            R11W,
            R11B,
            R12,
            R12D,
            R12W,
            R12B,
            R13,
            R13D,
            R13W,
            R13B,
            R14,
            R14D,
            R14W,
            R14B,
            R15,
            R15D,
            R15W,
            R15B,
#endif //_WIN64

            CIP,
            CSP,
            CAX,
            CBX,
            CCX,
            CDX,
            CDI,
            CSI,
            CBP,
            CFLAGS
        }; //RegisterEnum

        SCRIPT_EXPORT duint Get(RegisterEnum reg);
        SCRIPT_EXPORT bool Set(RegisterEnum reg, duint value);
        SCRIPT_EXPORT int Size(); //gets architecture register size in bytes

        SCRIPT_EXPORT duint GetDR0();
        SCRIPT_EXPORT bool SetDR0(duint value);
        SCRIPT_EXPORT duint GetDR1();
        SCRIPT_EXPORT bool SetDR1(duint value);
        SCRIPT_EXPORT duint GetDR2();
        SCRIPT_EXPORT bool SetDR2(duint value);
        SCRIPT_EXPORT duint GetDR3();
        SCRIPT_EXPORT bool SetDR3(duint value);
        SCRIPT_EXPORT duint GetDR6();
        SCRIPT_EXPORT bool SetDR6(duint value);
        SCRIPT_EXPORT duint GetDR7();
        SCRIPT_EXPORT bool SetDR7(duint value);

        SCRIPT_EXPORT unsigned int GetEAX();
        SCRIPT_EXPORT bool SetEAX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetAX();
        SCRIPT_EXPORT bool SetAX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetAH();
        SCRIPT_EXPORT bool SetAH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetAL();
        SCRIPT_EXPORT bool SetAL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEBX();
        SCRIPT_EXPORT bool SetEBX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBX();
        SCRIPT_EXPORT bool SetBX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetBH();
        SCRIPT_EXPORT bool SetBH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetBL();
        SCRIPT_EXPORT bool SetBL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetECX();
        SCRIPT_EXPORT bool SetECX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetCX();
        SCRIPT_EXPORT bool SetCX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetCH();
        SCRIPT_EXPORT bool SetCH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetCL();
        SCRIPT_EXPORT bool SetCL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDX();
        SCRIPT_EXPORT bool SetEDX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDX();
        SCRIPT_EXPORT bool SetDX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetDH();
        SCRIPT_EXPORT bool SetDH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetDL();
        SCRIPT_EXPORT bool SetDL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDI();
        SCRIPT_EXPORT bool SetEDI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDI();
        SCRIPT_EXPORT bool SetDI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESI();
        SCRIPT_EXPORT bool SetESI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSI();
        SCRIPT_EXPORT bool SetSI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEBP();
        SCRIPT_EXPORT bool SetEBP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBP();
        SCRIPT_EXPORT bool SetBP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESP();
        SCRIPT_EXPORT bool SetESP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSP();
        SCRIPT_EXPORT bool SetSP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEIP();
        SCRIPT_EXPORT bool SetEIP(unsigned int value);

#ifdef _WIN64
        SCRIPT_EXPORT unsigned long long GetRAX();
        SCRIPT_EXPORT bool SetRAX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRBX();
        SCRIPT_EXPORT bool SetRBX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRCX();
        SCRIPT_EXPORT bool SetRCX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRDX();
        SCRIPT_EXPORT bool SetRDX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRSI();
        SCRIPT_EXPORT bool SetRSI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSIL();
        SCRIPT_EXPORT bool SetSIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRDI();
        SCRIPT_EXPORT bool SetRDI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetDIL();
        SCRIPT_EXPORT bool SetDIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRBP();
        SCRIPT_EXPORT bool SetRBP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetBPL();
        SCRIPT_EXPORT bool SetBPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRSP();
        SCRIPT_EXPORT bool SetRSP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSPL();
        SCRIPT_EXPORT bool SetSPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRIP();
        SCRIPT_EXPORT bool SetRIP(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetR8();
        SCRIPT_EXPORT bool SetR8(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR8D();
        SCRIPT_EXPORT bool SetR8D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR8W();
        SCRIPT_EXPORT bool SetR8W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR8B();
        SCRIPT_EXPORT bool SetR8B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR9();
        SCRIPT_EXPORT bool SetR9(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR9D();
        SCRIPT_EXPORT bool SetR9D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR9W();
        SCRIPT_EXPORT bool SetR9W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR9B();
        SCRIPT_EXPORT bool SetR9B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR10();
        SCRIPT_EXPORT bool SetR10(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR10D();
        SCRIPT_EXPORT bool SetR10D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR10W();
        SCRIPT_EXPORT bool SetR10W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR10B();
        SCRIPT_EXPORT bool SetR10B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR11();
        SCRIPT_EXPORT bool SetR11(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR11D();
        SCRIPT_EXPORT bool SetR11D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR11W();
        SCRIPT_EXPORT bool SetR11W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR11B();
        SCRIPT_EXPORT bool SetR11B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR12();
        SCRIPT_EXPORT bool SetR12(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR12D();
        SCRIPT_EXPORT bool SetR12D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR12W();
        SCRIPT_EXPORT bool SetR12W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR12B();
        SCRIPT_EXPORT bool SetR12B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR13();
        SCRIPT_EXPORT bool SetR13(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR13D();
        SCRIPT_EXPORT bool SetR13D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR13W();
        SCRIPT_EXPORT bool SetR13W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR13B();
        SCRIPT_EXPORT bool SetR13B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR14();
        SCRIPT_EXPORT bool SetR14(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR14D();
        SCRIPT_EXPORT bool SetR14D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR14W();
        SCRIPT_EXPORT bool SetR14W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR14B();
        SCRIPT_EXPORT bool SetR14B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR15();
        SCRIPT_EXPORT bool SetR15(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR15D();
        SCRIPT_EXPORT bool SetR15D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR15W();
        SCRIPT_EXPORT bool SetR15W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR15B();
        SCRIPT_EXPORT bool SetR15B(unsigned char value);
#endif //_WIN64

        SCRIPT_EXPORT duint GetCAX();
        SCRIPT_EXPORT bool SetCAX(duint value);
        SCRIPT_EXPORT duint GetCBX();
        SCRIPT_EXPORT bool SetCBX(duint value);
        SCRIPT_EXPORT duint GetCCX();
        SCRIPT_EXPORT bool SetCCX(duint value);
        SCRIPT_EXPORT duint GetCDX();
        SCRIPT_EXPORT bool SetCDX(duint value);
        SCRIPT_EXPORT duint GetCDI();
        SCRIPT_EXPORT bool SetCDI(duint value);
        SCRIPT_EXPORT duint GetCSI();
        SCRIPT_EXPORT bool SetCSI(duint value);
        SCRIPT_EXPORT duint GetCBP();
        SCRIPT_EXPORT bool SetCBP(duint value);
        SCRIPT_EXPORT duint GetCSP();
        SCRIPT_EXPORT bool SetCSP(duint value);
        SCRIPT_EXPORT duint GetCIP();
        SCRIPT_EXPORT bool SetCIP(duint value);
        SCRIPT_EXPORT duint GetCFLAGS();
        SCRIPT_EXPORT bool SetCFLAGS(duint value);
    }; //Register
}; //Script

#endif //_SCRIPTAPI_REGISTER_H
```

`plugin/sdk/_scriptapi_stack.h`:

```h
#ifndef _SCRIPTAPI_STACK_H
#define _SCRIPTAPI_STACK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Stack
    {
        SCRIPT_EXPORT duint Pop();
        SCRIPT_EXPORT duint Push(duint value); //returns the previous top, equal to Peek(1)
        SCRIPT_EXPORT duint Peek(int offset = 0); //offset is in multiples of Register::Size(), for easy x32/x64 portability
    }; //Stack
}; //Script

#endif //_SCRIPTAPI_STACK_H
```

`plugin/sdk/_scriptapi_symbol.h`:

```h
#ifndef _SCRIPTAPI_SYMBOL_H
#define _SCRIPTAPI_SYMBOL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Symbol
    {
        enum SymbolType
        {
            Function, //user-defined function
            Import, //IAT entry
            Export //export
        };

        struct SymbolInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char name[MAX_LABEL_SIZE];
            bool manual;
            SymbolType type;
        };

        SCRIPT_EXPORT bool GetList(ListOf(SymbolInfo) list); //caller has the responsibility to free the list
    }; //Symbol
}; //Script

#endif //_SCRIPTAPI_SYMBOL_H
```

`plugin/sdk/bridgegraph.h`:

```h
#ifndef _GRAPH_H
#define _GRAPH_H

typedef struct
{
    duint addr; //virtual address of the instruction
    unsigned char data[15]; //instruction bytes
} BridgeCFInstruction;

typedef struct
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    ListInfo exits; //exits (including brtrue and brfalse, duint)
    ListInfo instrs; //block instructions
} BridgeCFNodeList;

typedef struct
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    ListInfo nodes; //graph nodes (BridgeCFNodeList)
} BridgeCFGraphList;

#ifdef __cplusplus
#if __cplusplus >= 201103 || (defined(_MSC_VER) && _MSC_VER >= 1700)

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <utility>

struct BridgeCFNode
{
    duint parentGraph = 0; //function of which this node is a part
    duint start = 0; //va of the first instruction in the block
    duint end = 0; //va of the last instruction in the block (inclusive)
    duint brtrue = 0; //destination if condition is true
    duint brfalse = 0; //destination if condition is false
    duint icount = 0; //number of instructions in node
    bool terminal = false; //node is a RET
    bool split = false; //node is a split (brtrue points to the next node)
    bool indirectcall = false; //node contains indirect calls (call reg, call [reg+X])
    void* userdata = nullptr; //user data
    std::vector<duint> exits; //exits (including brtrue and brfalse)
    std::vector<BridgeCFInstruction> instrs; //block instructions

    static void Free(const BridgeCFNodeList* nodeList)
    {
        if(!BridgeList<duint>::Free(&nodeList->exits))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::Free(&nodeList->instrs))
            __debugbreak();
    }

    BridgeCFNode() = default;

    BridgeCFNode(const BridgeCFNodeList* nodeList, bool freedata)
    {
        if(!nodeList)
            __debugbreak();
        parentGraph = nodeList->parentGraph;
        start = nodeList->start;
        end = nodeList->end;
        brtrue = nodeList->brtrue;
        brfalse = nodeList->brfalse;
        icount = nodeList->icount;
        terminal = nodeList->terminal;
        indirectcall = nodeList->indirectcall;
        split = nodeList->split;
        userdata = nodeList->userdata;
        if(!BridgeList<duint>::ToVector(&nodeList->exits, exits, freedata))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::ToVector(&nodeList->instrs, instrs, freedata))
            __debugbreak();
    }

    BridgeCFNode(duint parentGraph, duint start, duint end)
        : parentGraph(parentGraph),
          start(start),
          end(end)
    {
    }

    BridgeCFNodeList ToNodeList() const
    {
        BridgeCFNodeList out;
        out.parentGraph = parentGraph;
        out.start = start;
        out.end = end;
        out.brtrue = brtrue;
        out.brfalse = brfalse;
        out.icount = icount;
        out.terminal = terminal;
        out.indirectcall = indirectcall;
        out.split = split;
        out.userdata = userdata;
        BridgeList<duint>::CopyData(&out.exits, exits);
        BridgeList<BridgeCFInstruction>::CopyData(&out.instrs, instrs);
        return std::move(out);
    }
};

struct BridgeCFGraph
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    std::unordered_map<duint, BridgeCFNode> nodes; //CFNode.start -> CFNode
    std::unordered_map<duint, std::unordered_set<duint>> parents; //CFNode.start -> parents

    static void Free(const BridgeCFGraphList* graphList)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            BridgeCFNode::Free(&data[i]);
        BridgeFree(data);
    }

    explicit BridgeCFGraph(const BridgeCFGraphList* graphList, bool freedata)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        entryPoint = graphList->entryPoint;
        userdata = graphList->userdata;
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            AddNode(BridgeCFNode(&data[i], freedata));
        if(freedata && data)
            BridgeFree(data);
    }

    explicit BridgeCFGraph(duint entryPoint)
        : entryPoint(entryPoint),
          userdata(nullptr)
    {
    }

    void AddNode(const BridgeCFNode & node)
    {
        nodes[node.start] = node;
        AddParent(node.start, node.brtrue);
        AddParent(node.start, node.brfalse);
    }

    void AddParent(duint child, duint parent)
    {
        if(!child || !parent)
            return;
        auto found = parents.find(child);
        if(found == parents.end())
        {
            parents[child] = std::unordered_set<duint>();
            parents[child].insert(parent);
        }
        else
            found->second.insert(parent);
    }

    BridgeCFGraphList ToGraphList() const
    {
        BridgeCFGraphList out;
        out.entryPoint = entryPoint;
        out.userdata = userdata;
        std::vector<BridgeCFNodeList> nodeList;
        nodeList.reserve(nodes.size());
        for(const auto & nodeIt : nodes)
            nodeList.push_back(nodeIt.second.ToNodeList());
        BridgeList<BridgeCFNodeList>::CopyData(&out.nodes, nodeList);
        return std::move(out);
    }
};

#endif //_MSC_VER
#endif //__cplusplus

#endif //_GRAPH_H
```

`plugin/sdk/bridgelist.h`:

```h
#ifndef _LIST_H
#define _LIST_H

typedef struct
{
    int count; //Number of element in the list.
    size_t size; //Size of list in bytes (used for type checking).
    void* data; //Pointer to the list contents. Must be deleted by the caller using BridgeFree (or BridgeList::Free).
} ListInfo;

#define ListOf(Type) ListInfo*

#ifdef __cplusplus

#include <vector>

/**
\brief A list object. This object is NOT thread safe.
\tparam Type BridgeList contents type.
*/
template<typename Type>
class BridgeList
{
public:
    /**
    \brief BridgeList constructor.
    \param _freeData (Optional) the free function.
    */
    explicit BridgeList()
    {
        memset(&_listInfo, 0, sizeof(_listInfo));
    }

    /**
    \brief BridgeList destructor.
    */
    ~BridgeList()
    {
        Cleanup();
    }

    /**
    \brief Gets the list data.
    \return Returns ListInfo->data. Can be null if the list was never initialized. Will be destroyed once this object goes out of scope!
    */
    Type* Data() const
    {
        return reinterpret_cast<Type*>(_listInfo.data);
    }

    /**
    \brief Gets the number of elements in the list. This will crash the program if the data is not consistent with the specified template argument.
    \return The number of elements in the list.
    */
    int Count() const
    {
        if(_listInfo.size != _listInfo.count * sizeof(Type)) //make sure the user is using the correct type.
            __debugbreak();
        return _listInfo.count;
    }

    /**
    \brief Cleans up the list, freeing the list data when it is not null.
    */
    void Cleanup()
    {
        if(_listInfo.data)
        {
            BridgeFree(_listInfo.data);
            _listInfo.data = nullptr;
        }
    }

    /**
    \brief Reference operator (cleans up the previous list)
    \return Pointer to the ListInfo.
    */
    ListInfo* operator&()
    {
        Cleanup();
        return &_listInfo;
    }

    /**
    \brief Array indexer operator. This will crash if you try to access out-of-bounds.
    \param index Zero-based index of the item you want to get.
    \return Reference to a value at that index.
    */
    Type & operator[](size_t index) const
    {
        if(index >= size_t(Count())) //make sure the out-of-bounds access is caught as soon as possible.
            __debugbreak();
        return Data()[index];
    }

    /**
    \brief Copies data to a ListInfo structure..
    \param [out] listInfo If non-null, information describing the list.
    \param listData Data to copy in the ListInfo structure.
    \return true if it succeeds, false if it fails.
    */
    static bool CopyData(ListInfo* listInfo, const std::vector<Type> & listData)
    {
        if(!listInfo)
            return false;
        listInfo->count = int(listData.size());
        listInfo->size = listInfo->count * sizeof(Type);
        if(listInfo->count)
        {
            listInfo->data = BridgeAlloc(listInfo->size);
            Type* curItem = reinterpret_cast<Type*>(listInfo->data);
            for(const auto & item : listData)
            {
                *curItem = item;
                ++curItem;
            }
        }
        else
            listInfo->data = nullptr;
        return true;
    }

    static bool Free(const ListInfo* listInfo)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        BridgeFree(listInfo->data);
        return true;
    }

    static bool ToVector(const ListInfo* listInfo, std::vector<Type> & listData, bool freedata = true)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        listData.resize(listInfo->count);
        for(int i = 0; i < listInfo->count; i++)
            listData[i] = ((Type*)listInfo->data)[i];
        if(freedata && listInfo->data)
            BridgeFree(listInfo->data);
        return true;
    }

private:
    ListInfo _listInfo;
};

#endif //__cplusplus

#endif //_LIST_H
```

`plugin/sdk/bridgemain.h`:

```h
#ifndef _BRIDGEMAIN_H_
#define _BRIDGEMAIN_H_

#include <Windows.h>
#include <stdint.h>

#ifndef __cplusplus
#include <stdbool.h>
#define DEFAULT_PARAM(name, value) name
#else
#define DEFAULT_PARAM(name, value) name = value
#endif // __cplusplus

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

#ifdef _WIN64
typedef unsigned long long duint;
typedef signed long long dsint;
#else
typedef unsigned long duint;
typedef signed long dsint;
#endif //_WIN64

#ifndef BRIDGE_IMPEXP
#ifdef BUILD_BRIDGE
#define BRIDGE_IMPEXP __declspec(dllexport)
#else
#define BRIDGE_IMPEXP __declspec(dllimport)
#endif //BUILD_BRIDGE
#endif //BRIDGE_IMPEXP

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

//Bridge defines
#define MAX_SETTING_SIZE 65536
#define DBG_VERSION 25

//Bridge functions
typedef struct _BRIDGE_CONFIG
{
    HINSTANCE hGuiModule;
    const wchar_t* szUserDirectory;
} BRIDGE_CONFIG;

/// <summary>
/// Initialize the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeInit(BRIDGE_CONFIG* config);

BRIDGE_IMPEXP HMODULE WINAPI BridgeLoadLibraryCheckedW(const wchar_t* szDll, bool allowFailure);

BRIDGE_IMPEXP HMODULE WINAPI BridgeLoadLibraryCheckedA(const char* szDll, bool allowFailure);

/// <summary>
/// Start the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeStart();

/// <summary>
/// Allocate buffer. Use BridgeFree to free the buffer.
/// </summary>
/// <param name="size">Size in bytes of the buffer to allocate.</param>
/// <returns>A pointer to the allocated buffer. This function will trigger a crash dump if unsuccessful.</returns>
BRIDGE_IMPEXP void* BridgeAlloc(size_t size);

/// <summary>
/// Free buffer allocated by BridgeAlloc.
/// </summary>
/// <param name="ptr">Buffer to free.</param>
BRIDGE_IMPEXP void BridgeFree(void* ptr);

/// <summary>
/// Get a string setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output buffer for the value. Should be of MAX_SETTING_SIZE. Cannot be null.</param>
/// <returns>True if the setting was found and copied in the value parameter.</returns>
BRIDGE_IMPEXP bool BridgeSettingGet(const char* section, const char* key, char* value);

/// <summary>
/// Get an integer setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output value.</param>
/// <returns>True if the setting was found and successfully converted to an integer.</returns>
BRIDGE_IMPEXP bool BridgeSettingGetUint(const char* section, const char* key, duint* value);

/// <summary>
/// Set a string setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value. Set to null to remove the key from the section.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSet(const char* section, const char* key, const char* value);

/// <summary>
/// Set an integer setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSetUint(const char* section, const char* key, duint value);

/// <summary>
/// Flush the in-memory setting store to disk.
/// </summary>
/// <returns></returns>
BRIDGE_IMPEXP bool BridgeSettingFlush();

/// <summary>
/// Read the in-memory setting store from disk.
/// </summary>
/// <param name="errorLine">Line where the error occurred. Set to null to ignore this.</param>
/// <returns>True if the setting were read and parsed correctly.</returns>
BRIDGE_IMPEXP bool BridgeSettingRead(int* errorLine);

/// <summary>
/// Get the debugger version.
/// </summary>
/// <returns>25</returns>
BRIDGE_IMPEXP int BridgeGetDbgVersion();

/// <summary>
/// Checks if the current process is elevated.
/// </summary>
/// <returns>true if the process is elevated, false otherwise.</returns>
BRIDGE_IMPEXP bool BridgeIsProcessElevated();

/// <summary>
/// Gets the NT build number from the operating system.
/// </summary>
/// <returns>NtBuildNumber</returns>
BRIDGE_IMPEXP unsigned int BridgeGetNtBuildNumber();

/// <summary>
/// Returns the original working directory when starting the debugger.
/// The working directory is changed to the x64dbg directory after initialization.
/// </summary>
BRIDGE_IMPEXP const wchar_t* BridgeWorkingDirectory();

/// <summary>
/// Returns the user directory (without trailing backslash).
/// </summary>
BRIDGE_IMPEXP const wchar_t* BridgeUserDirectory();

/// <summary>
/// Returns true if x64dbg is running under ARM64 emulation.
/// </summary>
BRIDGE_IMPEXP bool BridgeIsARM64Emulated();

#ifdef __cplusplus
}
#endif // __cplusplus

//list structure (and C++ wrapper)
#include "bridgelist.h"

#include "bridgegraph.h"

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

//Debugger defines
#define MAX_LABEL_SIZE 256
#define MAX_COMMENT_SIZE 512
#define MAX_MODULE_SIZE 256
#define MAX_IMPORT_SIZE 65536
#define MAX_BREAKPOINT_SIZE 256
#define MAX_CONDITIONAL_EXPR_SIZE 256
#define MAX_CONDITIONAL_TEXT_SIZE 256
#define MAX_SCRIPT_LINE_SIZE 2048
#define MAX_THREAD_NAME_SIZE 256
#define MAX_WATCH_NAME_SIZE 256
#define MAX_STRING_SIZE 512
#define MAX_ERROR_SIZE 512
#define RIGHTS_STRING_SIZE (sizeof("ERWCG"))
#define MAX_SECTION_SIZE 10
#define MAX_COMMAND_LINE_SIZE 256
#define MAX_MNEMONIC_SIZE 64

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif // PAGE_SIZE

//Debugger enums
typedef enum
{
    initialized,
    paused,
    running,
    stopped
} DBGSTATE;

typedef enum
{
    SEG_DEFAULT,
    SEG_ES,
    SEG_DS,
    SEG_FS,
    SEG_GS,
    SEG_CS,
    SEG_SS
} SEGMENTREG;

typedef enum
{
    flagmodule = 0x1,
    flaglabel = 0x2,
    flagcomment = 0x4,
    flagbookmark = 0x8,
    flagfunction = 0x10,
    flagloop = 0x20,
    flagargs = 0x40,
    flagNoFuncOffset = 0x80
} ADDRINFOFLAGS;

typedef enum
{
    bp_none = 0,
    bp_normal = 1,
    bp_hardware = 2,
    bp_memory = 4,
    bp_dll = 8,
    bp_exception = 16
} BPXTYPE;

typedef enum
{
    FUNC_NONE,
    FUNC_BEGIN,
    FUNC_MIDDLE,
    FUNC_END,
    FUNC_SINGLE
} FUNCTYPE;

typedef enum
{
    LOOP_NONE,
    LOOP_BEGIN,
    LOOP_MIDDLE,
    LOOP_ENTRY,
    LOOP_END,
    LOOP_SINGLE
} LOOPTYPE;

//order by most important type last
typedef enum
{
    XREF_NONE,
    XREF_DATA,
    XREF_JMP,
    XREF_CALL
} XREFTYPE;

typedef enum
{
    ARG_NONE,
    ARG_BEGIN,
    ARG_MIDDLE,
    ARG_END,
    ARG_SINGLE
} ARGTYPE;

typedef enum
{
    DBG_SCRIPT_LOAD,                // param1=const char* filename,      param2=unused
    DBG_SCRIPT_UNLOAD,              // param1=unused,                    param2=unused
    DBG_SCRIPT_RUN,                 // param1=int destline,              param2=unused
    DBG_SCRIPT_STEP,                // param1=unused,                    param2=unused
    DBG_SCRIPT_BPTOGGLE,            // param1=int line,                  param2=unused
    DBG_SCRIPT_BPGET,               // param1=int line,                  param2=unused
    DBG_SCRIPT_CMDEXEC,             // param1=const char* command,       param2=unused
    DBG_SCRIPT_ABORT,               // param1=unused,                    param2=unused
    DBG_SCRIPT_GETLINETYPE,         // param1=int line,                  param2=unused
    DBG_SCRIPT_SETIP,               // param1=int line,                  param2=unused
    DBG_SCRIPT_GETBRANCHINFO,       // param1=int line,                  param2=SCRIPTBRANCH* info
    DBG_SYMBOL_ENUM,                // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_ASSEMBLE_AT,                // param1=duint addr,                param2=const char* instruction
    DBG_MODBASE_FROM_NAME,          // param1=const char* modname,       param2=unused
    DBG_DISASM_AT,                  // param1=duint addr,                 param2=DISASM_INSTR* instr
    DBG_STACK_COMMENT_GET,          // param1=duint addr,                param2=STACK_COMMENT* comment
    DBG_GET_THREAD_LIST,            // param1=THREADALLINFO* list,       param2=unused
    DBG_SETTINGS_UPDATED,           // param1=unused,                    param2=unused
    DBG_DISASM_FAST_AT,             // param1=duint addr,                param2=BASIC_INSTRUCTION_INFO* basicinfo
    DBG_MENU_ENTRY_CLICKED,         // param1=int hEntry,                param2=unused
    DBG_FUNCTION_GET,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_OVERLAPS,          // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_ADD,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_DEL,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_GET,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_OVERLAPS,              // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_ADD,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_DEL,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_IS_RUN_LOCKED,              // param1=unused,                    param2=unused
    DBG_IS_BP_DISABLED,             // param1=duint addr,                param2=unused
    DBG_SET_AUTO_COMMENT_AT,        // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_COMMENT_RANGE,  // param1=duint start,               param2=duint end
    DBG_SET_AUTO_LABEL_AT,          // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_LABEL_RANGE,    // param1=duint start,               param2=duint end
    DBG_SET_AUTO_BOOKMARK_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_BOOKMARK_RANGE, // param1=duint start,               param2=duint end
    DBG_SET_AUTO_FUNCTION_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_FUNCTION_RANGE, // param1=duint start,               param2=duint end
    DBG_GET_STRING_AT,              // param1=duint addr,                param2=unused
    DBG_GET_FUNCTIONS,              // param1=unused,                    param2=unused
    DBG_WIN_EVENT,                  // param1=MSG* message,              param2=long* result
    DBG_WIN_EVENT_GLOBAL,           // param1=MSG* message,              param2=unused
    DBG_INITIALIZE_LOCKS,           // param1=unused,                    param2=unused
    DBG_DEINITIALIZE_LOCKS,         // param1=unused,                    param2=unused
    DBG_GET_TIME_WASTED_COUNTER,    // param1=unused,                    param2=unused
    DBG_SYMBOL_ENUM_FROMCACHE,      // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_DELETE_COMMENT_RANGE,       // param1=duint start,               param2=duint end
    DBG_DELETE_LABEL_RANGE,         // param1=duint start,               param2=duint end
    DBG_DELETE_BOOKMARK_RANGE,      // param1=duint start,               param2=duint end
    DBG_GET_XREF_COUNT_AT,          // param1=duint addr,                param2=unused
    DBG_GET_XREF_TYPE_AT,           // param1=duint addr,                param2=unused
    DBG_XREF_ADD,                   // param1=duint addr,                param2=duint from
    DBG_XREF_DEL_ALL,               // param1=duint addr,                param2=unused
    DBG_XREF_GET,                   // param1=duint addr,                param2=XREF_INFO* info
    DBG_GET_ENCODE_TYPE_BUFFER,     // param1=duint addr,                param2=unused
    DBG_ENCODE_TYPE_GET,            // param1=duint addr,                param2=duint size
    DBG_DELETE_ENCODE_TYPE_RANGE,   // param1=duint start,               param2=duint end
    DBG_ENCODE_SIZE_GET,            // param1=duint addr,                param2=duint codesize
    DBG_DELETE_ENCODE_TYPE_SEG,     // param1=duint addr,                param2=unused
    DBG_RELEASE_ENCODE_TYPE_BUFFER, // param1=void* buffer,              param2=unused
    DBG_ARGUMENT_GET,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_OVERLAPS,          // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_ADD,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_DEL,               // param1=FUNCTION* info,            param2=unused
    DBG_GET_WATCH_LIST,             // param1=ListOf(WATCHINFO),         param2=unused
    DBG_SELCHANGED,                 // param1=hWindow,                   param2=VA
    DBG_GET_PROCESS_HANDLE,         // param1=unused,                    param2=unused
    DBG_GET_THREAD_HANDLE,          // param1=unused,                    param2=unused
    DBG_GET_PROCESS_ID,             // param1=unused,                    param2=unused
    DBG_GET_THREAD_ID,              // param1=unused,                    param2=unused
    DBG_GET_PEB_ADDRESS,            // param1=DWORD ProcessId,           param2=unused
    DBG_GET_TEB_ADDRESS,            // param1=DWORD ThreadId,            param2=unused
    DBG_ANALYZE_FUNCTION,           // param1=BridgeCFGraphList* graph,  param2=duint entry
    DBG_MENU_PREPARE,               // param1=int hMenu,                 param2=unused
    DBG_GET_SYMBOL_INFO,            // param1=void* symbol,              param2=SYMBOLINFO* info
    DBG_GET_DEBUG_ENGINE,           // param1=unused,                    param2-unused
    DBG_GET_SYMBOL_INFO_AT,         // param1=duint addr,                param2=SYMBOLINFO* info
    DBG_XREF_ADD_MULTI,             // param1=const XREF_EDGE* edges,    param2=duint count
    DBG_TYPE_VISIT,                 // param1=TYPEVISITDATA* data,       param2=unused
    DBG_UPDATE_GUI,                 // param1=disasm_addr,               param2=bool stack
} DBGMSG;

typedef enum
{
    linecommand,
    linebranch,
    linelabel,
    linecomment,
    lineempty,
} SCRIPTLINETYPE;

typedef enum
{
    scriptnobranch,
    scriptjmp,
    scriptjnejnz,
    scriptjejz,
    scriptjbjl,
    scriptjajg,
    scriptjbejle,
    scriptjaejge,
    scriptcall
} SCRIPTBRANCHTYPE;

typedef enum
{
    instr_normal,
    instr_branch,
    instr_stack
} DISASM_INSTRTYPE;

typedef enum
{
    arg_normal,
    arg_memory
} DISASM_ARGTYPE;

typedef enum
{
    str_none,
    str_ascii,
    str_unicode
} STRING_TYPE;

typedef enum
{
    _PriorityIdle = -15,
    _PriorityAboveNormal = 1,
    _PriorityBelowNormal = -1,
    _PriorityHighest = 2,
    _PriorityLowest = -2,
    _PriorityNormal = 0,
    _PriorityTimeCritical = 15,
    _PriorityUnknown = 0x7FFFFFFF
} THREADPRIORITY;

typedef enum
{
    _Executive = 0,
    _FreePage = 1,
    _PageIn = 2,
    _PoolAllocation = 3,
    _DelayExecution = 4,
    _Suspended = 5,
    _UserRequest = 6,
    _WrExecutive = 7,
    _WrFreePage = 8,
    _WrPageIn = 9,
    _WrPoolAllocation = 10,
    _WrDelayExecution = 11,
    _WrSuspended = 12,
    _WrUserRequest = 13,
    _WrEventPair = 14,
    _WrQueue = 15,
    _WrLpcReceive = 16,
    _WrLpcReply = 17,
    _WrVirtualMemory = 18,
    _WrPageOut = 19,
    _WrRendezvous = 20,
    _Spare2 = 21,
    _Spare3 = 22,
    _Spare4 = 23,
    _Spare5 = 24,
    _WrCalloutStack = 25,
    _WrKernel = 26,
    _WrResource = 27,
    _WrPushLock = 28,
    _WrMutex = 29,
    _WrQuantumEnd = 30,
    _WrDispatchInt = 31,
    _WrPreempted = 32,
    _WrYieldExecution = 33,
    _WrFastMutex = 34,
    _WrGuardedMutex = 35,
    _WrRundown = 36,
} THREADWAITREASON;

typedef enum
{
    size_byte = 1,
    size_word = 2,
    size_dword = 4,
    size_qword = 8,
    size_xmmword = 16,
    size_ymmword = 32,
    size_zmmword = 64
} MEMORY_SIZE;

typedef enum
{
    enc_unknown,  //must be 0
    enc_byte,     //1 byte
    enc_word,     //2 bytes
    enc_dword,    //4 bytes
    enc_fword,    //6 bytes
    enc_qword,    //8 bytes
    enc_tbyte,    //10 bytes
    enc_oword,    //16 bytes
    enc_mmword,   //8 bytes
    enc_xmmword,  //16 bytes
    enc_ymmword,  //32 bytes
    enc_zmmword,  //64 bytes
    enc_real4,    //4 byte float
    enc_real8,    //8 byte double
    enc_real10,   //10 byte decimal
    enc_ascii,    //ascii sequence
    enc_unicode,  //unicode sequence
    enc_code,     //start of code
    enc_junk,     //junk code
    enc_middle    //middle of data
} ENCODETYPE;

typedef enum
{
    TYPE_UINT, // unsigned integer
    TYPE_INT,  // signed integer
    TYPE_FLOAT,// single precision floating point value
    TYPE_ASCII, // ascii string
    TYPE_UNICODE, // unicode string
    TYPE_INVALID // invalid watch expression or data type
} WATCHVARTYPE;

typedef enum
{
    MODE_DISABLED, // watchdog is disabled
    MODE_ISTRUE,   // alert if expression is not 0
    MODE_ISFALSE,  // alert if expression is 0
    MODE_CHANGED,  // alert if expression is changed
    MODE_UNCHANGED // alert if expression is not changed
} WATCHDOGMODE;

typedef enum
{
    hw_access,
    hw_write,
    hw_execute
} BPHWTYPE;

typedef enum
{
    mem_access,
    mem_read,
    mem_write,
    mem_execute
} BPMEMTYPE;

typedef enum
{
    dll_load = 1,
    dll_unload,
    dll_all
} BPDLLTYPE;

typedef enum
{
    ex_firstchance = 1,
    ex_secondchance,
    ex_all
} BPEXTYPE;

typedef enum
{
    hw_byte,
    hw_word,
    hw_dword,
    hw_qword
} BPHWSIZE;

typedef enum
{
    sym_import,
    sym_export,
    sym_symbol
} SYMBOLTYPE;

#define SYMBOL_MASK_IMPORT (1u << sym_import)
#define SYMBOL_MASK_EXPORT (1u << sym_export)
#define SYMBOL_MASK_SYMBOL (1u << sym_symbol)
#define SYMBOL_MASK_ALL (SYMBOL_MASK_IMPORT | SYMBOL_MASK_EXPORT | SYMBOL_MASK_SYMBOL)

typedef enum
{
    mod_user,
    mod_system
} MODULEPARTY;

typedef enum
{
    DebugEngineTitanEngine,
    DebugEngineGleeBug,
    DebugEngineStaticEngine,
} DEBUG_ENGINE;

//Debugger typedefs
struct _TYPEDESCRIPTOR;
typedef MEMORY_SIZE VALUE_SIZE;

typedef struct DBGFUNCTIONS_ DBGFUNCTIONS;

// Callback declaration:
// bool cbSymbolEnum(const SYMBOLPTR* symbol, void* user);
// To get the data from the opaque pointer:
// SYMBOLINFO info;
// DbgGetSymbolInfo(symbol, &info);
// The SYMBOLPTR* becomes invalid when the module is unloaded
// DO NOT STORE unless you are absolutely certain you handle it correctly
typedef bool (*CBSYMBOLENUM)(const struct SYMBOLPTR_* symbol, void* user);

typedef bool (*TYPETOSTRING)(const struct _TYPEDESCRIPTOR* type, char* dest, size_t* destCount); //don't change destCount for final failure

//Debugger structs
typedef struct
{
    MEMORY_BASIC_INFORMATION mbi;
    char info[MAX_MODULE_SIZE];
} MEMPAGE;

typedef struct
{
    int count;
    MEMPAGE* page;
} MEMMAP;

typedef struct
{
    BPXTYPE type;
    duint addr;
    bool enabled;
    bool singleshoot;
    bool active;
    char name[MAX_BREAKPOINT_SIZE];
    char mod[MAX_MODULE_SIZE];
    unsigned short slot;
    // extended part
    unsigned char typeEx; //BPHWTYPE/BPMEMTYPE/BPDLLTYPE/BPEXTYPE
    unsigned char hwSize; //BPHWSIZE
    unsigned int hitCount;
    bool fastResume;
    bool silent;
    char breakCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char logText[MAX_CONDITIONAL_TEXT_SIZE];
    char logCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char commandText[MAX_CONDITIONAL_TEXT_SIZE];
    char commandCondition[MAX_CONDITIONAL_EXPR_SIZE];
} BRIDGEBP;

typedef struct
{
    int count;
    BRIDGEBP* bp;
} BPMAP;

typedef struct
{
    char WatchName[MAX_WATCH_NAME_SIZE];
    char Expression[MAX_CONDITIONAL_EXPR_SIZE];
    unsigned int window;
    unsigned int id;
    WATCHVARTYPE varType;
    WATCHDOGMODE watchdogMode;
    duint value;
    bool watchdogTriggered;
} WATCHINFO;

typedef struct
{
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} FUNCTION;

typedef struct
{
    int depth; //IN
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} LOOP;

typedef struct
{
    int flags; //ADDRINFOFLAGS (IN)
    char module[MAX_MODULE_SIZE]; //module the address is in
    char label[MAX_LABEL_SIZE];
    char comment[MAX_COMMENT_SIZE];
    bool isbookmark;
    FUNCTION function;
    LOOP loop;
    FUNCTION args;
} BRIDGE_ADDRINFO;

typedef struct SYMBOLINFO_
{
    duint addr;
    char* decoratedSymbol;
    char* undecoratedSymbol;
    SYMBOLTYPE type;

    // If true: Use BridgeFree(decoratedSymbol) to deallocate
    // Else: The decoratedSymbol pointer is valid until the module unloads
    bool freeDecorated;

    // If true: Use BridgeFree(undecoratedSymbol) to deallcoate
    // Else: The undecoratedSymbol pointer is valid until the module unloads
    bool freeUndecorated;

    // The entry point pseudo-export has ordinal == 0 (invalid ordinal value)
    DWORD ordinal;
} SYMBOLINFO;

#ifdef __cplusplus
struct SYMBOLINFOCPP : SYMBOLINFO
{
    SYMBOLINFOCPP(const SYMBOLINFOCPP &) = delete;
    SYMBOLINFOCPP(SYMBOLINFOCPP &&) = delete;

    SYMBOLINFOCPP()
    {
        memset(this, 0, sizeof(SYMBOLINFO));
    }

    ~SYMBOLINFOCPP()
    {
        if(freeDecorated)
            BridgeFree(decoratedSymbol);
        if(freeUndecorated)
            BridgeFree(undecoratedSymbol);
    }
};
static_assert(sizeof(SYMBOLINFOCPP) == sizeof(SYMBOLINFO), "");
#endif // __cplusplus

typedef struct
{
    duint base;
    char name[MAX_MODULE_SIZE];
} SYMBOLMODULEINFO;

typedef struct
{
    duint base;
    CBSYMBOLENUM cbSymbolEnum;
    void* user;
    duint start;
    duint end;
    unsigned int symbolMask;
} SYMBOLCBINFO;

typedef struct
{
    bool c;
    bool p;
    bool a;
    bool z;
    bool s;
    bool t;
    bool i;
    bool d;
    bool o;
} FLAGS;

typedef struct
{
    bool FZ;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool IM;
    bool DM;
    bool DAZ;
    bool PE;
    bool UE;
    bool OE;
    bool ZE;
    bool DE;
    bool IE;

    unsigned short RC;
} MXCSRFIELDS;

typedef struct
{
    bool B;
    bool C3;
    bool C2;
    bool C1;
    bool C0;
    bool ES;
    bool SF;
    bool P;
    bool U;
    bool O;
    bool Z;
    bool D;
    bool I;

    unsigned short TOP;

} X87STATUSWORDFIELDS;

typedef struct
{
    bool IC;
    bool IEM;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool DM;
    bool IM;

    unsigned short RC;
    unsigned short PC;

} X87CONTROLWORDFIELDS;

typedef struct DECLSPEC_ALIGN(16) _XMMREGISTER
{
    ULONGLONG Low;
    LONGLONG High;
} XMMREGISTER;

typedef struct
{
    XMMREGISTER Low; //XMM/SSE part
    XMMREGISTER High; //AVX part
} YMMREGISTER;

typedef struct
{
    YMMREGISTER Low; //AVX part
    YMMREGISTER High; //AVX-512 part
} ZMMREGISTER;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} X87FPUREGISTER;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} X87FPU;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    X87FPU x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XMMREGISTER XmmRegisters[16];
    YMMREGISTER YmmRegisters[16];
#else // x86
    XMMREGISTER XmmRegisters[8];
    YMMREGISTER YmmRegisters[8];
#endif
} REGISTERCONTEXT;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    // To save space, aliased SSE and AVX states are shared with AVX-512 states instead. If the CPU does not support AVX-512, the unused part will be ignored.
#ifdef _WIN64
    ZMMREGISTER ZmmRegisters[32];
#else // x86
    ZMMREGISTER ZmmRegisters[8];
#endif
    ULONGLONG Opmask[8];
    BYTE RegisterArea[80];
    DWORD MxCsr;
    X87FPU x87fpu;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
} REGISTERCONTEXT_AVX512;

typedef struct
{
    DWORD code;
    char name[128];
} LASTERROR;

typedef struct
{
    DWORD code;
    char name[128];
} LASTSTATUS;

typedef struct
{
    REGISTERCONTEXT regcontext;
    FLAGS flags;
    X87FPUREGISTER x87FPURegisters[8];
    unsigned long long mmx[8];
    MXCSRFIELDS MxCsrFields;
    X87STATUSWORDFIELDS x87StatusWordFields;
    X87CONTROLWORDFIELDS x87ControlWordFields;
    LASTERROR lastError;
    LASTSTATUS lastStatus;
} REGDUMP;

typedef struct
{
    REGISTERCONTEXT_AVX512 regcontext;
    // To save space, original aliased fields (flags, x87FPURegisters, mmx, MxCsrFields, x87StatusWordFields, x87ControlWordFields) are removed, and can be found in regcontext.
    DWORD lastError;
    DWORD lastStatus;
} REGDUMP_AVX512;

typedef struct
{
    DISASM_ARGTYPE type; //normal/memory
    SEGMENTREG segment;
    char mnemonic[64];
    duint constant; //constant in the instruction (imm/disp)
    duint value; //equal to constant or equal to the register value
    duint memvalue; //memsize:[value]
} DISASM_ARG;

typedef struct
{
    char instruction[64];
    DISASM_INSTRTYPE type;
    int argcount;
    int instr_size;
    DISASM_ARG arg[3];
} DISASM_INSTR;

typedef struct
{
    char color[8]; //hex color-code
    char comment[MAX_COMMENT_SIZE];
} STACK_COMMENT;

typedef struct
{
    int ThreadNumber;
    HANDLE Handle;
    DWORD ThreadId;
    duint ThreadStartAddress;
    duint ThreadLocalBase;
    char threadName[MAX_THREAD_NAME_SIZE];
} THREADINFO;

typedef struct
{
    THREADINFO BasicInfo;
    duint ThreadCip;
    DWORD SuspendCount;
    THREADPRIORITY Priority;
    THREADWAITREASON WaitReason;
    DWORD LastError;
    FILETIME UserTime;
    FILETIME KernelTime;
    FILETIME CreationTime;
    ULONG64 Cycles; // Windows Vista or greater
} THREADALLINFO;

typedef struct
{
    int count;
    THREADALLINFO* list;
    int CurrentThread;
} THREADLIST;

typedef struct
{
    duint value; //displacement / addrvalue (rip-relative)
    MEMORY_SIZE size; //byte/word/dword/qword
    char mnemonic[MAX_MNEMONIC_SIZE];
} MEMORY_INFO;

typedef struct
{
    duint value;
    VALUE_SIZE size;
} VALUE_INFO;

//definitions for BASIC_INSTRUCTION_INFO.type
#define TYPE_VALUE 1
#define TYPE_MEMORY 2
#define TYPE_ADDR 4

typedef struct
{
    DWORD type; //value|memory|addr
    VALUE_INFO value; //immediat
    MEMORY_INFO memory;
    duint addr; //addrvalue (jumps + calls)
    bool branch; //jumps/calls
    bool call; //instruction is a call
    int size;
    char instruction[MAX_MNEMONIC_SIZE * 4];
} BASIC_INSTRUCTION_INFO;

typedef struct
{
    SCRIPTBRANCHTYPE type;
    int dest;
    char branchlabel[256];
} SCRIPTBRANCH;

typedef struct
{
    duint addr;
    duint start;
    duint end;
    bool manual;
    int depth;
} FUNCTION_LOOP_INFO;

typedef struct
{
    duint addr;
    XREFTYPE type;
} XREF_RECORD;

typedef struct
{
    duint refcount;
    XREF_RECORD* references;
} XREF_INFO;

typedef struct
{
    duint address;
    duint from;
} XREF_EDGE;

typedef struct SYMBOLPTR_
{
    duint modbase;
    const void* symbol;
} SYMBOLPTR;

#define TYPEDESCRIPTOR_MAGIC 0x1337

typedef struct _TYPEDESCRIPTOR
{
    bool expanded; //is the type node expanded?
    bool reverse; //big endian?
    uint16_t magic; // compatiblity (set to TYPEDESCRIPTOR_MAGIC for the new version)
    const char* name; //type name (int b)
    duint addr; //virtual address
    duint offset; //offset to addr for the actual location in bytes
    int id; //type id
    int sizeBits; //sizeof(type) in bits
    TYPETOSTRING callback; //convert to string
    void* userdata; //user data
    duint bitOffset; // bit offset from first bitfield
    const char* typeName; // undecorated typename
} TYPEDESCRIPTOR;

//Debugger functions
BRIDGE_IMPEXP const char* DbgInit();
BRIDGE_IMPEXP const char* DbgInitBlocking();
BRIDGE_IMPEXP void DbgExit();
BRIDGE_IMPEXP bool DbgMemRead(duint va, void* dest, duint size);
BRIDGE_IMPEXP bool DbgMemWrite(duint va, const void* src, duint size);
BRIDGE_IMPEXP duint DbgMemGetPageSize(duint base);
BRIDGE_IMPEXP duint DbgMemFindBaseAddr(duint addr, duint* size);

/// <summary>
/// Asynchronously execute a debugger command by adding it to the command queue.
/// Note: the command may not have completed before this call returns. Use this
/// function if you don't care when the command gets executed.
///
/// Example: DbgCmdExec("ClearLog")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command was successfully submitted to the command queue. False if the submission failed.</returns>
BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd);

/// <summary>
/// Performs synchronous execution of a debugger command. This function call only
/// returns after the command has completed.
///
/// Example: DbgCmdExecDirect("loadlib advapi32.dll")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command executed successfully, False if there was a problem.</returns>
BRIDGE_IMPEXP bool DbgCmdExecDirect(const char* cmd);
BRIDGE_IMPEXP bool DbgMemMap(MEMMAP* memmap);
BRIDGE_IMPEXP bool DbgIsValidExpression(const char* expression);
BRIDGE_IMPEXP bool DbgIsDebugging();
BRIDGE_IMPEXP bool DbgIsJumpGoingToExecute(duint addr);
BRIDGE_IMPEXP bool DbgGetLabelAt(duint addr, SEGMENTREG segment, char* text);
BRIDGE_IMPEXP bool DbgSetLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetCommentAt(duint addr, char* text);
BRIDGE_IMPEXP bool DbgSetCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetBookmarkAt(duint addr);
BRIDGE_IMPEXP bool DbgSetBookmarkAt(duint addr, bool isbookmark);
BRIDGE_IMPEXP void DbgClearBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetModuleAt(duint addr, char* text);
BRIDGE_IMPEXP BPXTYPE DbgGetBpxTypeAt(duint addr);
BRIDGE_IMPEXP duint DbgValFromString(const char* string);
BRIDGE_IMPEXP bool DbgGetRegDumpEx(REGDUMP_AVX512* regdump, size_t size);
BRIDGE_IMPEXP bool DbgValToString(const char* string, duint value);
BRIDGE_IMPEXP bool DbgMemIsValidReadPtr(duint addr);
BRIDGE_IMPEXP int DbgGetBpList(BPXTYPE type, BPMAP* list);
BRIDGE_IMPEXP FUNCTYPE DbgGetFunctionTypeAt(duint addr);
BRIDGE_IMPEXP LOOPTYPE DbgGetLoopTypeAt(duint addr, int depth);
BRIDGE_IMPEXP duint DbgGetBranchDestination(duint addr);
BRIDGE_IMPEXP void DbgScriptLoad(const char* filename);
BRIDGE_IMPEXP void DbgScriptUnload();
BRIDGE_IMPEXP void DbgScriptRun(int destline);
BRIDGE_IMPEXP void DbgScriptStep();
BRIDGE_IMPEXP bool DbgScriptBpToggle(int line);
BRIDGE_IMPEXP bool DbgScriptBpGet(int line);
BRIDGE_IMPEXP bool DbgScriptCmdExec(const char* command);
BRIDGE_IMPEXP void DbgScriptAbort();
BRIDGE_IMPEXP SCRIPTLINETYPE DbgScriptGetLineType(int line);
BRIDGE_IMPEXP void DbgScriptSetIp(int line);
BRIDGE_IMPEXP bool DbgScriptGetBranchInfo(int line, SCRIPTBRANCH* info);
BRIDGE_IMPEXP bool DbgSymbolEnum(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgSymbolEnumFromCache(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgSymbolEnumRange(duint start, duint end, unsigned int symbolMask, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgAssembleAt(duint addr, const char* instruction);
BRIDGE_IMPEXP duint DbgModBaseFromName(const char* name);
BRIDGE_IMPEXP void DbgDisasmAt(duint addr, DISASM_INSTR* instr);
BRIDGE_IMPEXP bool DbgStackCommentGet(duint addr, STACK_COMMENT* comment);
BRIDGE_IMPEXP void DbgGetThreadList(THREADLIST* list);
BRIDGE_IMPEXP void DbgSettingsUpdated();
BRIDGE_IMPEXP void DbgDisasmFastAt(duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
BRIDGE_IMPEXP void DbgMenuEntryClicked(int hEntry);
BRIDGE_IMPEXP bool DbgFunctionGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgFunctionOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionDel(duint addr);
BRIDGE_IMPEXP bool DbgArgumentGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgArgumentOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentDel(duint addr);
BRIDGE_IMPEXP bool DbgLoopGet(int depth, duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgLoopOverlaps(int depth, duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopDel(int depth, duint addr);
BRIDGE_IMPEXP bool DbgXrefAdd(duint addr, duint from);
BRIDGE_IMPEXP bool DbgXrefDelAll(duint addr);
BRIDGE_IMPEXP bool DbgXrefGet(duint addr, XREF_INFO* info);
BRIDGE_IMPEXP size_t DbgGetXrefCountAt(duint addr);
BRIDGE_IMPEXP XREFTYPE DbgGetXrefTypeAt(duint addr);
BRIDGE_IMPEXP bool DbgIsRunLocked();
BRIDGE_IMPEXP bool DbgIsBpDisabled(duint addr);
BRIDGE_IMPEXP bool DbgSetAutoCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoBookmarkAt(duint addr);
BRIDGE_IMPEXP void DbgClearAutoBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoFunctionAt(duint start, duint end);
BRIDGE_IMPEXP void DbgClearAutoFunctionRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetStringAt(duint addr, char* text);
BRIDGE_IMPEXP const DBGFUNCTIONS* DbgFunctions();
BRIDGE_IMPEXP bool DbgWinEvent(MSG* message, long* result);
BRIDGE_IMPEXP bool DbgWinEventGlobal(MSG* message);
BRIDGE_IMPEXP bool DbgIsRunning();
BRIDGE_IMPEXP duint DbgGetTimeWastedCounter();
BRIDGE_IMPEXP ARGTYPE DbgGetArgTypeAt(duint addr);
BRIDGE_IMPEXP void* DbgGetEncodeTypeBuffer(duint addr, duint* size);
BRIDGE_IMPEXP void DbgReleaseEncodeTypeBuffer(void* buffer);
BRIDGE_IMPEXP ENCODETYPE DbgGetEncodeTypeAt(duint addr, duint size);
BRIDGE_IMPEXP duint DbgGetEncodeSizeAt(duint addr, duint codesize);
BRIDGE_IMPEXP bool DbgSetEncodeType(duint addr, duint size, ENCODETYPE type);
BRIDGE_IMPEXP void DbgDelEncodeTypeRange(duint start, duint end);
BRIDGE_IMPEXP void DbgDelEncodeTypeSegment(duint start);
BRIDGE_IMPEXP bool DbgGetWatchList(ListOf(WATCHINFO) list);
BRIDGE_IMPEXP void DbgSelChanged(int hWindow, duint VA);
BRIDGE_IMPEXP HANDLE DbgGetProcessHandle();
BRIDGE_IMPEXP HANDLE DbgGetThreadHandle();
BRIDGE_IMPEXP DWORD DbgGetProcessId();
BRIDGE_IMPEXP DWORD DbgGetThreadId();
BRIDGE_IMPEXP duint DbgGetPebAddress(DWORD ProcessId);
BRIDGE_IMPEXP duint DbgGetTebAddress(DWORD ThreadId);
BRIDGE_IMPEXP bool DbgAnalyzeFunction(duint entry, BridgeCFGraphList* graph);
BRIDGE_IMPEXP duint DbgEval(const char* expression, bool* DEFAULT_PARAM(success, nullptr));
BRIDGE_IMPEXP void DbgGetSymbolInfo(const SYMBOLPTR* symbolptr, SYMBOLINFO* info);
BRIDGE_IMPEXP DEBUG_ENGINE DbgGetDebugEngine();
BRIDGE_IMPEXP bool DbgGetSymbolInfoAt(duint addr, SYMBOLINFO* info);
BRIDGE_IMPEXP duint DbgXrefAddMulti(const XREF_EDGE* edges, duint count);
BRIDGE_IMPEXP void DbgUpdateGui(duint disasm_addr, bool stack);

typedef enum
{
    GUI_PLUGIN_MENU,
    GUI_DISASM_MENU,
    GUI_DUMP_MENU,
    GUI_STACK_MENU,
    GUI_GRAPH_MENU,
    GUI_MEMMAP_MENU,
    GUI_SYMMOD_MENU,
} GUIMENUTYPE;

BRIDGE_IMPEXP void DbgMenuPrepare(GUIMENUTYPE hMenu);

typedef enum
{
    GUI_DISASSEMBLY,
    GUI_DUMP,
    GUI_STACK,
    GUI_GRAPH,
    GUI_MEMMAP,
    GUI_SYMMOD,
    GUI_THREADS,
} GUISELECTIONTYPE;

typedef void* (*TYPEVISITFUNC)(void* parent, const TYPEDESCRIPTOR* type, void* userdata);

typedef struct _TYPEVISITDATA
{
    const char* typeName;
    const char* declName; // optional
    void* root;
    duint addr;
    int maxPtrDepth; // negative for default
    int maxExpandDepth; // negative for default
    int maxExpandArray; // negative for default
    bool createLabels; // create (temporary) labels for every member
    TYPEVISITFUNC callback;
    void* userdata;
} TYPEVISITDATA;

BRIDGE_IMPEXP bool DbgTypeVisit(const TYPEVISITDATA* data);

//Gui defines
#define GUI_MAX_LINE_SIZE 65536
#define GUI_MAX_DISASSEMBLY_SIZE 2048

//Gui enums (NOTE: only add new messages to the end of the list)
// clang-format off
#define GUIMSG_LIST(msg) \
    msg(GUI_DISASSEMBLE_AT, (duint)va, (duint)cip) \
    msg(GUI_SET_DEBUG_STATE, (DBGSTATE)state, unused) \
    msg(GUI_ADD_MSG_TO_LOG, (const char*)msg, unused) \
    msg(GUI_CLEAR_LOG, unused, unused) \
    msg(GUI_UPDATE_REGISTER_VIEW, unused, unused) \
    msg(GUI_UPDATE_DISASSEMBLY_VIEW, unused, unused) \
    msg(GUI_UPDATE_BREAKPOINTS_VIEW, unused, unused) \
    msg(GUI_UPDATE_WINDOW_TITLE, (const char*)file, unused) \
    msg(GUI_GET_WINDOW_HANDLE, unused, unused) \
    msg(GUI_DUMP_AT, (duint)va, unused) \
    msg(GUI_SCRIPT_ADD, int count, const char** lines) \
    msg(GUI_SCRIPT_CLEAR, unused, unused) \
    msg(GUI_SCRIPT_SETIP, int line, unused) \
    msg(GUI_SCRIPT_ERROR, int line, const char* message) \
    msg(GUI_SCRIPT_SETTITLE, const char* title, unused) \
    msg(GUI_SCRIPT_SETINFOLINE, int line, const char* info) \
    msg(GUI_SCRIPT_MESSAGE, const char* message, unused) \
    msg(GUI_SCRIPT_MSGYN, const char* message, unused) \
    msg(GUI_SYMBOL_LOG_ADD, (const char*)msg, unused) \
    msg(GUI_SYMBOL_LOG_CLEAR, unused, unused) \
    msg(GUI_SYMBOL_SET_PROGRESS, int percent, unused) \
    msg(GUI_SYMBOL_UPDATE_MODULE_LIST, int count, SYMBOLMODULEINFO* modules) \
    msg(GUI_REF_ADDCOLUMN, int width, (const char*)title) \
    msg(GUI_REF_SETROWCOUNT, int rows, unused) \
    msg(GUI_REF_GETROWCOUNT, unused, unused) \
    msg(GUI_REF_DELETEALLCOLUMNS, unused, unused) \
    msg(GUI_REF_SETCELLCONTENT, (CELLINFO*)info, unused) \
    msg(GUI_REF_GETCELLCONTENT, int row, int col) \
    msg(GUI_REF_RELOADDATA, unused, unused) \
    msg(GUI_REF_SETSINGLESELECTION, int index, bool scroll) \
    msg(GUI_REF_SETPROGRESS, int progress, unused) \
    msg(GUI_REF_SETCURRENTTASKPROGRESS, int progress, const char* taskTitle) \
    msg(GUI_REF_SETSEARCHSTARTCOL, int col, unused) \
    msg(GUI_STACK_DUMP_AT, duint addr, duint csp) \
    msg(GUI_UPDATE_DUMP_VIEW, unused, unused) \
    msg(GUI_UPDATE_THREAD_VIEW, unused, unused) \
    msg(GUI_ADD_RECENT_FILE, (const char*)file, unused) \
    msg(GUI_SET_LAST_EXCEPTION, unsigned int code, unused) \
    msg(GUI_GET_DISASSEMBLY, duint addr, char* text) \
    msg(GUI_MENU_ADD, int hMenu, const char* title) \
    msg(GUI_MENU_ADD_ENTRY, int hMenu, const char* title) \
    msg(GUI_MENU_ADD_SEPARATOR, int hMenu, unused) \
    msg(GUI_MENU_CLEAR, int hMenu, unused) \
    msg(GUI_SELECTION_GET, GUISELECTIONTYPE, SELECTIONDATA* selection) \
    msg(GUI_SELECTION_SET, GUISELECTIONTYPE, const SELECTIONDATA* selection) \
    msg(GUI_GETLINE_WINDOW, const char* title, char* text) \
    msg(GUI_AUTOCOMPLETE_ADDCMD, const char* cmd, ununsed) \
    msg(GUI_AUTOCOMPLETE_DELCMD, const char* cmd, ununsed) \
    msg(GUI_AUTOCOMPLETE_CLEARALL, unused, unused) \
    msg(GUI_SCRIPT_ENABLEHIGHLIGHTING, bool enable, unused) \
    msg(GUI_ADD_MSG_TO_STATUSBAR, const char* msg, unused) \
    msg(GUI_UPDATE_SIDEBAR, unused, unused) \
    msg(GUI_REPAINT_TABLE_VIEW, unused, unused) \
    msg(GUI_UPDATE_PATCHES, unused, unused) \
    msg(GUI_UPDATE_CALLSTACK, unused, unused) \
    msg(GUI_UPDATE_SEHCHAIN, unused, unused) \
    msg(GUI_SYMBOL_REFRESH_CURRENT, unused, unused) \
    msg(GUI_UPDATE_MEMORY_VIEW, unused, unused) \
    msg(GUI_REF_INITIALIZE, const char* name, unused) \
    msg(GUI_LOAD_SOURCE_FILE, const char* path, duint addr) \
    msg(GUI_MENU_SET_ICON, int hMenu, ICONINFO*) \
    msg(GUI_MENU_SET_ENTRY_ICON, int hEntry, ICONINFO*) \
    msg(GUI_SHOW_CPU, unused, unused) \
    msg(GUI_ADD_QWIDGET_TAB, QWidget*, unused) \
    msg(GUI_SHOW_QWIDGET_TAB, QWidget*, unused) \
    msg(GUI_CLOSE_QWIDGET_TAB, QWidget*, unused) \
    msg(GUI_EXECUTE_ON_GUI_THREAD, GUICALLBACKEX cb, void* userdata) \
    msg(GUI_UPDATE_TIME_WASTED_COUNTER, unused, unused) \
    msg(GUI_SET_GLOBAL_NOTES, const char* text, unused) \
    msg(GUI_GET_GLOBAL_NOTES, char** text, unused) \
    msg(GUI_SET_DEBUGGEE_NOTES, const char* text, unused) \
    msg(GUI_GET_DEBUGGEE_NOTES, char** text, unused) \
    msg(GUI_DUMP_AT_N, int index, duint va) \
    msg(GUI_DISPLAY_WARNING, const char *text, unused) \
    msg(GUI_REGISTER_SCRIPT_LANG, SCRIPTTYPEINFO* info, unused) \
    msg(GUI_UNREGISTER_SCRIPT_LANG, int id, unused) \
    msg(GUI_UPDATE_ARGUMENT_VIEW, unused, unused) \
    msg(GUI_FOCUS_VIEW, int hWindow, unused) \
    msg(GUI_UPDATE_WATCH_VIEW, unused, unused) \
    msg(GUI_LOAD_GRAPH, BridgeCFGraphList*, unused) \
    msg(GUI_GRAPH_AT, duint addr, unused) \
    msg(GUI_UPDATE_GRAPH_VIEW, unused, unused) \
    msg(GUI_SET_LOG_ENABLED, bool isEnabled, unused) \
    msg(GUI_ADD_FAVOURITE_TOOL, const char* name, const char* description) \
    msg(GUI_ADD_FAVOURITE_COMMAND, const char* command, const char* shortcut) \
    msg(GUI_SET_FAVOURITE_TOOL_SHORTCUT, const char* name, const char* shortcut) \
    msg(GUI_FOLD_DISASSEMBLY, duint startAddress, duint length) \
    msg(GUI_SELECT_IN_MEMORY_MAP, duint addr, unused) \
    msg(GUI_GET_ACTIVE_VIEW, ACTIVEVIEW*, unused) \
    msg(GUI_MENU_SET_ENTRY_CHECKED, int hEntry, bool checked) \
    msg(GUI_ADD_INFO_LINE, const char* infoline, unused) \
    msg(GUI_PROCESS_EVENTS, unused, unused) \
    msg(GUI_TYPE_ADDNODE, void* parent, TYPEDESCRIPTOR* type) \
    msg(GUI_TYPE_CLEAR, unused, unused) \
    msg(GUI_UPDATE_TYPE_WIDGET, unused, unused) \
    msg(GUI_CLOSE_APPLICATION, unused, unused) \
    msg(GUI_MENU_SET_VISIBLE, int hMenu, bool visible) \
    msg(GUI_MENU_SET_ENTRY_VISIBLE, int hEntry, bool visible) \
    msg(GUI_MENU_SET_NAME, int hMenu, const char* name) \
    msg(GUI_MENU_SET_ENTRY_NAME, int hEntry, const char* name) \
    msg(GUI_FLUSH_LOG, unused, unused) \
    msg(GUI_MENU_SET_ENTRY_HOTKEY, int hEntry, const char* hack) \
    msg(GUI_REF_SEARCH_GETROWCOUNT, unused, unused) \
    msg(GUI_REF_SEARCH_GETCELLCONTENT, int row, int col) \
    msg(GUI_MENU_REMOVE, int hEntryMenu, unused) \
    msg(GUI_REF_ADDCOMMAND, const char* title, const char* command) \
    msg(GUI_OPEN_TRACE_FILE, const char* file name, unused) \
    msg(GUI_UPDATE_TRACE_BROWSER, unused, unused) \
    msg(GUI_INVALIDATE_SYMBOL_SOURCE, duint base, unused) \
    msg(GUI_GET_CURRENT_GRAPH, BridgeCFGraphList*, unused) \
    msg(GUI_SHOW_REF, unused, unused) \
    msg(GUI_SELECT_IN_SYMBOLS_TAB, duint addr, unused) \
    msg(GUI_GOTO_TRACE, duint index, unused) \
    msg(GUI_SHOW_TRACE, unused, unused) \
    msg(GUI_GET_MAIN_THREAD_ID, unused, unused) \
    msg(GUI_ADD_MSG_TO_LOG_HTML, (const char*)msg, unused) \
    msg(GUI_IS_LOG_ENABLED, unused, unused) \
    msg(GUI_IS_DEBUGGER_FOCUSED_UNUSED, unused, unused) \
    msg(GUI_SAVE_LOG, const char* file name, unused) \
    msg(GUI_REDIRECT_LOG, const char* file name, unused) \
    msg(GUI_STOP_REDIRECT_LOG, unused, unused) \
    msg(GUI_SHOW_THREADS, unused, unused) \
    msg(GUI_SHOW_STRUCT, unused, unused) \
    msg(GUI_TYPE_VISIT, const char* typeName, duint addr) \
    msg(GUI_TYPE_LIST_UPDATED, unused, unused) \

// clang-format on

#define GUIMSG_ENUM(msg, param1, param2) msg,

typedef enum
{
    GUIMSG_LIST(GUIMSG_ENUM)
} GUIMSG;

#undef GUIMSG_ENUM

//GUI Typedefs
typedef void (*GUICALLBACK)();
typedef void (*GUICALLBACKEX)(void*);
typedef bool (*GUISCRIPTEXECUTE)(const char* text);
typedef void (*GUISCRIPTCOMPLETER)(const char* text, char** entries, int* entryCount);

//GUI structures
typedef struct
{
    int row;
    int col;
    const char* str;
} CELLINFO;

typedef struct
{
    duint start;
    duint end;
} SELECTIONDATA;

typedef struct
{
    const void* data;
    duint size;
} ICONDATA;

typedef struct
{
    char name[64];
    int id;
    GUISCRIPTEXECUTE execute;
    GUISCRIPTCOMPLETER completeCommand;
} SCRIPTTYPEINFO;

typedef struct
{
    void* titleHwnd;
    void* classHwnd;
    char title[MAX_STRING_SIZE];
    char className[MAX_STRING_SIZE];
} ACTIVEVIEW;

//GUI functions
//code page is utf8
BRIDGE_IMPEXP const char* GuiTranslateText(const char* Source);
BRIDGE_IMPEXP void GuiDisasmAt(duint addr, duint cip);
BRIDGE_IMPEXP void GuiSetDebugState(DBGSTATE state);
BRIDGE_IMPEXP void GuiSetDebugStateFast(DBGSTATE state);
BRIDGE_IMPEXP void GuiAddLogMessage(const char* msg);
BRIDGE_IMPEXP void GuiAddLogMessageHtml(const char* msg);
BRIDGE_IMPEXP void GuiLogClear();
BRIDGE_IMPEXP void GuiLogSave(const char* filename);
BRIDGE_IMPEXP void GuiLogRedirect(const char* filename);
BRIDGE_IMPEXP void GuiLogRedirectStop();
BRIDGE_IMPEXP void GuiUpdateAllViews();
BRIDGE_IMPEXP void GuiUpdateRegisterView();
BRIDGE_IMPEXP void GuiUpdateDisassemblyView();
BRIDGE_IMPEXP void GuiUpdateBreakpointsView();
BRIDGE_IMPEXP void GuiUpdateWindowTitle(const char* filename);
BRIDGE_IMPEXP HWND GuiGetWindowHandle();
BRIDGE_IMPEXP void GuiDumpAt(duint va);
BRIDGE_IMPEXP void GuiScriptAdd(int count, const char** lines);
BRIDGE_IMPEXP void GuiScriptClear();
BRIDGE_IMPEXP void GuiScriptSetIp(int line);
BRIDGE_IMPEXP void GuiScriptError(int line, const char* message);
BRIDGE_IMPEXP void GuiScriptSetTitle(const char* title);
BRIDGE_IMPEXP void GuiScriptSetInfoLine(int line, const char* info);
BRIDGE_IMPEXP void GuiScriptMessage(const char* message);
BRIDGE_IMPEXP int GuiScriptMsgyn(const char* message);
BRIDGE_IMPEXP void GuiScriptEnableHighlighting(bool enable);
BRIDGE_IMPEXP void GuiSymbolLogAdd(const char* message);
BRIDGE_IMPEXP void GuiSymbolLogClear();
BRIDGE_IMPEXP void GuiSymbolSetProgress(int percent);
BRIDGE_IMPEXP void GuiSymbolUpdateModuleList(int count, SYMBOLMODULEINFO* modules);
BRIDGE_IMPEXP void GuiSymbolRefreshCurrent();
BRIDGE_IMPEXP void GuiReferenceAddColumn(int width, const char* title);
BRIDGE_IMPEXP void GuiReferenceSetRowCount(int count);
BRIDGE_IMPEXP int GuiReferenceGetRowCount();
BRIDGE_IMPEXP int GuiReferenceSearchGetRowCount();
BRIDGE_IMPEXP void GuiReferenceDeleteAllColumns();
BRIDGE_IMPEXP void GuiReferenceInitialize(const char* name);
BRIDGE_IMPEXP void GuiReferenceSetCellContent(int row, int col, const char* str);
BRIDGE_IMPEXP char* GuiReferenceGetCellContent(int row, int col);
BRIDGE_IMPEXP char* GuiReferenceSearchGetCellContent(int row, int col);
BRIDGE_IMPEXP void GuiReferenceReloadData();
BRIDGE_IMPEXP void GuiReferenceSetSingleSelection(int index, bool scroll);
BRIDGE_IMPEXP void GuiReferenceSetProgress(int progress);
BRIDGE_IMPEXP void GuiReferenceSetCurrentTaskProgress(int progress, const char* taskTitle);
BRIDGE_IMPEXP void GuiReferenceSetSearchStartCol(int col);
BRIDGE_IMPEXP void GuiStackDumpAt(duint addr, duint csp);
BRIDGE_IMPEXP void GuiUpdateDumpView();
BRIDGE_IMPEXP void GuiUpdateWatchView();
BRIDGE_IMPEXP void GuiUpdateThreadView();
BRIDGE_IMPEXP void GuiUpdateMemoryView();
BRIDGE_IMPEXP void GuiAddRecentFile(const char* file);
BRIDGE_IMPEXP void GuiSetLastException(unsigned int exception);
BRIDGE_IMPEXP bool GuiGetDisassembly(duint addr, char* text);
BRIDGE_IMPEXP int GuiMenuAdd(int hMenu, const char* title);
BRIDGE_IMPEXP int GuiMenuAddEntry(int hMenu, const char* title);
BRIDGE_IMPEXP void GuiMenuAddSeparator(int hMenu);
BRIDGE_IMPEXP void GuiMenuClear(int hMenu);
BRIDGE_IMPEXP void GuiMenuRemove(int hEntryMenu);
BRIDGE_IMPEXP bool GuiSelectionGet(GUISELECTIONTYPE hWindow, SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiSelectionSet(GUISELECTIONTYPE hWindow, const SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiGetLineWindow(const char* title, char* text);
BRIDGE_IMPEXP void GuiAutoCompleteAddCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteDelCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteClearAll();
BRIDGE_IMPEXP void GuiAddStatusBarMessage(const char* msg);
BRIDGE_IMPEXP void GuiUpdateSideBar();
BRIDGE_IMPEXP void GuiRepaintTableView();
BRIDGE_IMPEXP void GuiUpdatePatches();
BRIDGE_IMPEXP void GuiUpdateCallStack();
BRIDGE_IMPEXP void GuiUpdateSEHChain();
BRIDGE_IMPEXP void GuiLoadSourceFileEx(const char* path, duint addr);
BRIDGE_IMPEXP void GuiMenuSetIcon(int hMenu, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryIcon(int hEntry, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryChecked(int hEntry, bool checked);
BRIDGE_IMPEXP void GuiMenuSetVisible(int hMenu, bool visible);
BRIDGE_IMPEXP void GuiMenuSetEntryVisible(int hEntry, bool visible);
BRIDGE_IMPEXP void GuiMenuSetName(int hMenu, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryName(int hEntry, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryHotkey(int hEntry, const char* hack);
BRIDGE_IMPEXP void GuiShowCpu();
BRIDGE_IMPEXP void GuiShowThreads();
BRIDGE_IMPEXP void GuiAddQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiShowQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiCloseQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiExecuteOnGuiThread(GUICALLBACK cbGuiThread);
BRIDGE_IMPEXP void GuiUpdateTimeWastedCounter();
BRIDGE_IMPEXP void GuiSetGlobalNotes(const char* text);
BRIDGE_IMPEXP void GuiGetGlobalNotes(char** text);
BRIDGE_IMPEXP void GuiSetDebuggeeNotes(const char* text);
BRIDGE_IMPEXP void GuiGetDebuggeeNotes(char** text);
BRIDGE_IMPEXP void GuiDumpAtN(duint va, int index);
BRIDGE_IMPEXP void GuiDisplayWarning(const char* title, const char* text);
BRIDGE_IMPEXP void GuiRegisterScriptLanguage(SCRIPTTYPEINFO* info);
BRIDGE_IMPEXP void GuiUnregisterScriptLanguage(int id);
BRIDGE_IMPEXP void GuiUpdateArgumentWidget();
BRIDGE_IMPEXP void GuiFocusView(int hWindow);
BRIDGE_IMPEXP bool GuiIsUpdateDisabled();
BRIDGE_IMPEXP void GuiUpdateEnable(bool updateNow);
BRIDGE_IMPEXP void GuiUpdateDisable();
BRIDGE_IMPEXP bool GuiLoadGraph(BridgeCFGraphList* graph, duint addr);
BRIDGE_IMPEXP duint GuiGraphAt(duint addr);
BRIDGE_IMPEXP void GuiUpdateGraphView();
BRIDGE_IMPEXP void GuiDisableLog();
BRIDGE_IMPEXP void GuiEnableLog();
BRIDGE_IMPEXP bool GuiIsLogEnabled();
BRIDGE_IMPEXP void GuiAddFavouriteTool(const char* name, const char* description);
BRIDGE_IMPEXP void GuiAddFavouriteCommand(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiFoldDisassembly(duint startAddress, duint length);
BRIDGE_IMPEXP void GuiSelectInMemoryMap(duint addr);
BRIDGE_IMPEXP void GuiGetActiveView(ACTIVEVIEW* activeView);
BRIDGE_IMPEXP void GuiAddInfoLine(const char* infoLine);
BRIDGE_IMPEXP void GuiProcessEvents();
BRIDGE_IMPEXP void* GuiTypeAddNode(void* parent, const TYPEDESCRIPTOR* type);
BRIDGE_IMPEXP bool GuiTypeClear();
BRIDGE_IMPEXP void GuiTypeVisit(const char* typeName, duint addr);
BRIDGE_IMPEXP void GuiTypeListUpdated();
BRIDGE_IMPEXP void GuiUpdateTypeWidget();
BRIDGE_IMPEXP void GuiCloseApplication();
BRIDGE_IMPEXP void GuiFlushLog();
BRIDGE_IMPEXP void GuiReferenceAddCommand(const char* title, const char* command);
BRIDGE_IMPEXP void GuiUpdateTraceBrowser();
BRIDGE_IMPEXP void GuiOpenTraceFile(const char* fileName);
BRIDGE_IMPEXP void GuiInvalidateSymbolSource(duint base);
BRIDGE_IMPEXP void GuiExecuteOnGuiThreadEx(GUICALLBACKEX cbGuiThread, void* userdata);
BRIDGE_IMPEXP void GuiGetCurrentGraph(BridgeCFGraphList* graphList);
BRIDGE_IMPEXP void GuiShowReferences();
BRIDGE_IMPEXP void GuiSelectInSymbolsTab(duint addr);
BRIDGE_IMPEXP void GuiGotoTrace(duint index);
BRIDGE_IMPEXP void GuiShowTrace();
BRIDGE_IMPEXP DWORD GuiGetMainThreadId();
BRIDGE_IMPEXP void GuiShowStructView();

#ifdef __cplusplus
}
#endif // __cplusplus

// Some useful C++ wrapper classes
#ifdef __cplusplus

class GuiDisableLogScope
{
    bool wasEnabled;

public:
    GuiDisableLogScope(const GuiDisableLogScope &) = delete;

    GuiDisableLogScope()
    {
        wasEnabled = GuiIsLogEnabled();
        if(wasEnabled)
            GuiDisableLog();
    }

    ~GuiDisableLogScope()
    {
        if(wasEnabled)
            GuiEnableLog();
    }
};

class GuiDisableUpdateScope
{
    bool updateAfter;
    bool wasEnabled;

public:
    GuiDisableUpdateScope(const GuiDisableUpdateScope &) = delete;

    explicit GuiDisableUpdateScope(bool updateAfter = true)
        : updateAfter(updateAfter)
    {
        wasEnabled = !GuiIsUpdateDisabled();
        if(wasEnabled)
            GuiUpdateDisable();
    }

    ~GuiDisableUpdateScope()
    {
        if(wasEnabled)
            GuiUpdateEnable(updateAfter);
    }
};

class GuiDisableScope : GuiDisableUpdateScope, GuiDisableLogScope { };

#endif // __cplusplus

#pragma pack(pop)

#endif // _BRIDGEMAIN_H_

```

`plugin/sdk/jansson/jansson.h`:

```h
/*
 * Copyright (c) 2009-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 */

#ifndef JANSSON_H
#define JANSSON_H

#include <stdio.h>
#include <stdlib.h>  /* for size_t */
#include <stdarg.h>

#include "jansson_config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* version */

#define JANSSON_MAJOR_VERSION  2
#define JANSSON_MINOR_VERSION  9
#define JANSSON_MICRO_VERSION  0

/* Micro version is omitted if it's 0 */
#define JANSSON_VERSION  "2.9"

/* Version as a 3-byte hex number, e.g. 0x010201 == 1.2.1. Use this
   for numeric comparisons, e.g. #if JANSSON_VERSION_HEX >= ... */
#define JANSSON_VERSION_HEX  ((JANSSON_MAJOR_VERSION << 16) |   \
                              (JANSSON_MINOR_VERSION << 8)  |   \
                              (JANSSON_MICRO_VERSION << 0))


/* types */

typedef enum
{
    JSON_OBJECT,
    JSON_ARRAY,
    JSON_STRING,
    JSON_INTEGER,
    JSON_REAL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NULL
} json_type;

typedef struct json_t
{
    json_type type;
    size_t refcount;
} json_t;

#ifndef JANSSON_USING_CMAKE /* disabled if using cmake */
#if JSON_INTEGER_IS_LONG_LONG
#ifdef _WIN32
#define JSON_INTEGER_FORMAT "I64d"
#else
#define JSON_INTEGER_FORMAT "lld"
#endif
typedef long long json_int_t;
#else
#define JSON_INTEGER_FORMAT "ld"
typedef long json_int_t;
#endif /* JSON_INTEGER_IS_LONG_LONG */
#endif

#define json_typeof(json)      ((json)->type)
#define json_is_object(json)   ((json) && json_typeof(json) == JSON_OBJECT)
#define json_is_array(json)    ((json) && json_typeof(json) == JSON_ARRAY)
#define json_is_string(json)   ((json) && json_typeof(json) == JSON_STRING)
#define json_is_integer(json)  ((json) && json_typeof(json) == JSON_INTEGER)
#define json_is_real(json)     ((json) && json_typeof(json) == JSON_REAL)
#define json_is_number(json)   (json_is_integer(json) || json_is_real(json))
#define json_is_true(json)     ((json) && json_typeof(json) == JSON_TRUE)
#define json_is_false(json)    ((json) && json_typeof(json) == JSON_FALSE)
#define json_boolean_value     json_is_true
#define json_is_boolean(json)  (json_is_true(json) || json_is_false(json))
#define json_is_null(json)     ((json) && json_typeof(json) == JSON_NULL)

/* construction, destruction, reference counting */

__declspec(dllimport) json_t* json_object(void);
__declspec(dllimport) json_t* json_array(void);
__declspec(dllimport) json_t* json_string(const char* value);
__declspec(dllimport) json_t* json_stringn(const char* value, size_t len);
__declspec(dllimport) json_t* json_string_nocheck(const char* value);
__declspec(dllimport) json_t* json_stringn_nocheck(const char* value, size_t len);
__declspec(dllimport) json_t* json_integer(json_int_t value);
__declspec(dllimport) json_t* json_real(double value);
__declspec(dllimport) json_t* json_true(void);
__declspec(dllimport) json_t* json_false(void);
#define json_boolean(val)      ((val) ? json_true() : json_false())
__declspec(dllimport) json_t* json_null(void);

static JSON_INLINE
json_t* json_incref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1)
        ++json->refcount;
    return json;
}

/* do not call json_delete directly */
__declspec(dllimport) void json_delete(json_t* json);

static JSON_INLINE
void json_decref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1 && --json->refcount == 0)
        json_delete(json);
}

#if defined(__GNUC__) || defined(__clang__)
static JSON_INLINE
void json_decrefp(json_t** json)
{
    if(json)
    {
        json_decref(*json);
        *json = NULL;
    }
}

#define json_auto_t json_t __attribute__((cleanup(json_decrefp)))
#endif


/* error reporting */

#define JSON_ERROR_TEXT_LENGTH    160
#define JSON_ERROR_SOURCE_LENGTH   80

typedef struct
{
    int line;
    int column;
    int position;
    char source[JSON_ERROR_SOURCE_LENGTH];
    char text[JSON_ERROR_TEXT_LENGTH];
} json_error_t;


/* getters, setters, manipulation */

__declspec(dllimport) void json_object_seed(size_t seed);
__declspec(dllimport) size_t json_object_size(const json_t* object);
__declspec(dllimport) json_t* json_object_get(const json_t* object, const char* key);
__declspec(dllimport) int json_object_set_new(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_set_new_nocheck(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_del(json_t* object, const char* key);
__declspec(dllimport) int json_object_clear(json_t* object);
__declspec(dllimport) int json_object_update(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_existing(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_missing(json_t* object, json_t* other);
__declspec(dllimport) void* json_object_iter(json_t* object);
__declspec(dllimport) void* json_object_iter_at(json_t* object, const char* key);
__declspec(dllimport) void* json_object_key_to_iter(const char* key);
__declspec(dllimport) void* json_object_iter_next(json_t* object, void* iter);
__declspec(dllimport) const char* json_object_iter_key(void* iter);
__declspec(dllimport) json_t* json_object_iter_value(void* iter);
__declspec(dllimport) int json_object_iter_set_new(json_t* object, void* iter, json_t* value);

#define json_object_foreach(object, key, value) \
    for(key = json_object_iter_key(json_object_iter(object)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(json_object_iter_next(object, json_object_key_to_iter(key))))

#define json_object_foreach_safe(object, n, key, value)     \
    for(key = json_object_iter_key(json_object_iter(object)), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(n), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)))

#define json_array_foreach(array, index, value) \
    for(index = 0; \
        index < json_array_size(array) && (value = json_array_get(array, index)); \
        index++)

static JSON_INLINE
int json_object_set(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_set_nocheck(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new_nocheck(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_iter_set(json_t* object, void* iter, json_t* value)
{
    return json_object_iter_set_new(object, iter, json_incref(value));
}

__declspec(dllimport) size_t json_array_size(const json_t* array);
__declspec(dllimport) json_t* json_array_get(const json_t* array, size_t index);
__declspec(dllimport) int json_array_set_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_append_new(json_t* array, json_t* value);
__declspec(dllimport) int json_array_insert_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_remove(json_t* array, size_t index);
__declspec(dllimport) int json_array_clear(json_t* array);
__declspec(dllimport) int json_array_extend(json_t* array, json_t* other);

static JSON_INLINE
int json_array_set(json_t* array, size_t ind, json_t* value)
{
    return json_array_set_new(array, ind, json_incref(value));
}

static JSON_INLINE
int json_array_append(json_t* array, json_t* value)
{
    return json_array_append_new(array, json_incref(value));
}

static JSON_INLINE
int json_array_insert(json_t* array, size_t ind, json_t* value)
{
    return json_array_insert_new(array, ind, json_incref(value));
}

__declspec(dllimport) const char* json_string_value(const json_t* string);
__declspec(dllimport) size_t json_string_length(const json_t* string);
__declspec(dllimport) json_int_t json_integer_value(const json_t* integer);
__declspec(dllimport) double json_real_value(const json_t* real);
__declspec(dllimport) double json_number_value(const json_t* json);

__declspec(dllimport) int json_string_set(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_string_set_nocheck(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn_nocheck(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_integer_set(json_t* integer, json_int_t value);
__declspec(dllimport) int json_real_set(json_t* real, double value);

/* pack, unpack */

__declspec(dllimport) json_t* json_pack(const char* fmt, ...);
__declspec(dllimport) json_t* json_pack_ex(json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) json_t* json_vpack_ex(json_error_t* error, size_t flags, const char* fmt, va_list ap);

#define JSON_VALIDATE_ONLY  0x1
#define JSON_STRICT         0x2

__declspec(dllimport) int json_unpack(json_t* root, const char* fmt, ...);
__declspec(dllimport) int json_unpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) int json_vunpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, va_list ap);


/* equality */

__declspec(dllimport) int json_equal(json_t* value1, json_t* value2);


/* copying */

__declspec(dllimport) json_t* json_copy(json_t* value);
__declspec(dllimport) json_t* json_deep_copy(const json_t* value);


/* decoding */

#define JSON_REJECT_DUPLICATES  0x1
#define JSON_DISABLE_EOF_CHECK  0x2
#define JSON_DECODE_ANY         0x4
#define JSON_DECODE_INT_AS_REAL 0x8
#define JSON_ALLOW_NUL          0x10

typedef size_t (*json_load_callback_t)(void* buffer, size_t buflen, void* data);

__declspec(dllimport) json_t* json_loads(const char* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadb(const char* buffer, size_t buflen, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadf(FILE* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_file(const char* path, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_callback(json_load_callback_t callback, void* data, size_t flags, json_error_t* error);


/* encoding */

#define JSON_MAX_INDENT         0x1F
#define JSON_INDENT(n)          ((n) & JSON_MAX_INDENT)
#define JSON_COMPACT            0x20
#define JSON_ENSURE_ASCII       0x40
#define JSON_SORT_KEYS          0x80
#define JSON_PRESERVE_ORDER     0x100
#define JSON_ENCODE_ANY         0x200
#define JSON_ESCAPE_SLASH       0x400
#define JSON_REAL_PRECISION(n)  (((n) & 0x1F) << 11)

typedef int (*json_dump_callback_t)(const char* buffer, size_t size, void* data);

__declspec(dllimport) char* json_dumps(const json_t* json, size_t flags);
__declspec(dllimport) int json_dumpf(const json_t* json, FILE* output, size_t flags);
__declspec(dllimport) int json_dump_file(const json_t* json, const char* path, size_t flags);
__declspec(dllimport) int json_dump_callback(const json_t* json, json_dump_callback_t callback, void* data, size_t flags);

/* custom memory allocation */

typedef void* (*json_malloc_t)(size_t);
typedef void (*json_free_t)(void*);

__declspec(dllimport) void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
__declspec(dllimport) void json_get_alloc_funcs(json_malloc_t* malloc_fn, json_free_t* free_fn);

#ifdef __cplusplus
}
#endif

#endif

```

`plugin/sdk/jansson/jansson_config.h`:

```h
/*
 * Copyright (c) 2010-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 *
 *
 * This file specifies a part of the site-specific configuration for
 * Jansson, namely those things that affect the public API in
 * jansson.h.
 *
 * The CMake system will generate the jansson_config.h file and
 * copy it to the build and install directories.
 */

#ifndef JANSSON_CONFIG_H
#define JANSSON_CONFIG_H

/* Define this so that we can disable scattered automake configuration in source files */
#ifndef JANSSON_USING_CMAKE
#define JANSSON_USING_CMAKE
#endif

/* Note: when using cmake, JSON_INTEGER_IS_LONG_LONG is not defined nor used,
 * as we will also check for __int64 etc types.
 * (the definition was used in the automake system) */

/* Bring in the cmake-detected defines */
#define HAVE_STDINT_H 1
/* #undef HAVE_INTTYPES_H */
/* #undef HAVE_SYS_TYPES_H */

/* Include our standard type header for the integer typedef */

#if defined(HAVE_STDINT_H)
#  include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#  include <inttypes.h>
#elif defined(HAVE_SYS_TYPES_H)
#  include <sys/types.h>
#endif


/* If your compiler supports the inline keyword in C, JSON_INLINE is
   defined to `inline', otherwise empty. In C++, the inline is always
   supported. */
#ifdef __cplusplus
#define JSON_INLINE inline
#else
#define JSON_INLINE __inline
#endif


#define json_int_t long long
#define json_strtoint strtoll
#define JSON_INTEGER_FORMAT "I64d"


/* If locale.h and localeconv() are available, define to 1, otherwise to 0. */
#define JSON_HAVE_LOCALECONV 1


/* Maximum recursion depth for parsing JSON input.
   This limits the depth of e.g. array-within-array constructions. */
#define JSON_PARSER_MAX_DEPTH 2048


#endif

```

`plugin/sdk/jansson/jansson_x64dbg.h`:

```h
#pragma once

#include "jansson.h"

typedef json_t* JSON;

static JSON_INLINE
json_t* json_hex(unsigned json_int_t value)
{
    char hexvalue[20];
    sprintf_s(hexvalue, "0x%llX", value);
    return json_string(hexvalue);
}

static JSON_INLINE
unsigned json_int_t json_hex_value(const json_t* hex)
{
    unsigned json_int_t ret = 0;
    const char* hexvalue;
    hexvalue = json_string_value(hex);
    if(!hexvalue)
        return 0;
    sscanf_s(hexvalue, "0x%llX", &ret);
    return ret;
}

static JSON_INLINE
json_t* json_string(const std::string & str)
{
    return json_stringn(str.c_str(), str.length());
}

```

`plugin/sdk/lz4/lz4.h`:

```h
/*
   LZ4 - Fast LZ compression algorithm
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4_H
#define _LZ4_H

#if defined (__cplusplus)
extern "C"
{
#endif


/**************************************
   Version
**************************************/
#define LZ4_VERSION_MAJOR    1    /* for major interface/format changes  */
#define LZ4_VERSION_MINOR    1    /* for minor interface/format changes  */
#define LZ4_VERSION_RELEASE  3    /* for tweaks, bug-fixes, or development */


/**************************************
   Compiler Options
**************************************/
#if (defined(__GNUC__) && defined(__STRICT_ANSI__)) || (defined(_MSC_VER) && !defined(__cplusplus))   /* Visual Studio */
#  define inline __inline           /* Visual C is not C99, but supports some kind of inline */
#endif


/**************************************
   Simple Functions
**************************************/

__declspec(dllimport) int LZ4_compress(const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_decompress_safe(const char* source, char* dest, int inputSize, int maxOutputSize);

/*
LZ4_compress() :
    Compresses 'inputSize' bytes from 'source' into 'dest'.
    Destination buffer must be already allocated,
    and must be sized to handle worst cases situations (input data not compressible)
    Worst case size evaluation is provided by function LZ4_compressBound()
    inputSize : Max supported value is LZ4_MAX_INPUT_VALUE
    return : the number of bytes written in buffer dest
             or 0 if the compression fails

LZ4_decompress_safe() :
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function is protected against buffer overflow exploits (never writes outside of output buffer, and never reads outside of input buffer). Therefore, it is protected against malicious data packets
*/


/**************************************
   Advanced Functions
**************************************/
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)

/*
LZ4_compressBound() :
    Provides the maximum size that LZ4 may output in a "worst case" scenario (input data not compressible)
    primarily useful for memory allocation of output buffer.
    inline function is recommended for the general case,
    macro is also provided when result needs to be evaluated at compilation (such as stack memory allocation).

    isize  : is the input size. Max supported value is LZ4_MAX_INPUT_SIZE
    return : maximum output size in a "worst case" scenario
             or 0, if input size is too large ( > LZ4_MAX_INPUT_SIZE)
*/
__declspec(dllimport) int LZ4_compressBound(int isize);


/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is LZ4_MAX_INPUT_VALUE
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes written in buffer 'dest'
             or 0 if the compression fails
*/
__declspec(dllimport) int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);


/*
LZ4_decompress_fast() :
    originalSize : is the original and therefore uncompressed size
    return : the number of bytes read from the source buffer (in other words, the compressed size)
             If the source stream is malformed, the function will stop decoding and return a negative result.
    note : This function is a bit faster than LZ4_decompress_safe()
           This function never writes outside of output buffers, but may read beyond input buffer in case of malicious data packet.
           Use this function preferably into a trusted environment (data to decode comes from a trusted source).
           Destination buffer must be already allocated. Its size must be a minimum of 'outputSize' bytes.
*/
__declspec(dllimport) int LZ4_decompress_fast(const char* source, char* dest, int originalSize);


/*
LZ4_decompress_safe_partial() :
    This function decompress a compressed block of size 'inputSize' at position 'source'
    into output buffer 'dest' of size 'maxOutputSize'.
    The function tries to stop decompressing operation as soon as 'targetOutputSize' has been reached,
    reducing decompression time.
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
       Note : this number can be < 'targetOutputSize' should the compressed block to decode be smaller.
             Always control how many bytes were decoded.
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets
*/
__declspec(dllimport) int LZ4_decompress_safe_partial(const char* source, char* dest, int inputSize, int targetOutputSize, int maxOutputSize);


/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofState();

Note that tables must be aligned on 4-bytes boundaries, otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withState() and LZ4_compress_limitedOutput_withState() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/
__declspec(dllimport) int LZ4_sizeofState(void);
__declspec(dllimport) int LZ4_compress_withState(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compress_limitedOutput_withState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_create(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compress_continue(void* LZ4_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compress_limitedOutput_continue(void* LZ4_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBuffer(void* LZ4_Data);
__declspec(dllimport) int   LZ4_free(void* LZ4_Data);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4 Data Structure, thanks to the function :

void* LZ4_create (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4 Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compress_continue() or LZ4_compress_limitedOutput_continue().
Their behavior are identical to LZ4_compress() or LZ4_compress_limitedOutput(),
but require the LZ4 Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBuffer(void* LZ4_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compress_continue() or LZ4_compress_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_free() will release the memory used by the LZ4 Data Structure.
*/


__declspec(dllimport) int LZ4_sizeofStreamState(void);
__declspec(dllimport) int LZ4_resetStreamState(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_create (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamState();
Note also that space must be 4-bytes aligned.

Once space is allocated, you must initialize it using : LZ4_resetStreamState(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned on 4-bytes boundaries, and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamState() must be 0 is OK.
Any other value means there was an error (typically, pointer is not aligned on 4-bytes boundaries).
*/


__declspec(dllimport) int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int outputSize);

/*
*_withPrefix64k() :
    These decoding functions work the same as their "normal name" versions,
    but can use up to 64KB of data in front of 'char* dest'.
    These functions are necessary to decode inter-dependant blocks.
*/


/**************************************
   Obsolete Functions
**************************************/
/*
These functions are deprecated and should no longer be used.
They are provided here for compatibility with existing user programs.
*/
__declspec(dllimport) int LZ4_uncompress(const char* source, char* dest, int outputSize);
__declspec(dllimport) int LZ4_uncompress_unknownOutputSize(const char* source, char* dest, int isize, int maxOutputSize);


#if defined (__cplusplus)
}
#endif

#endif //_LZ4_H
```

`plugin/sdk/lz4/lz4file.h`:

```h
#ifndef _LZ4FILE_H
#define _LZ4FILE_H

typedef enum _LZ4_STATUS
{
    LZ4_SUCCESS,
    LZ4_FAILED_OPEN_INPUT,
    LZ4_FAILED_OPEN_OUTPUT,
    LZ4_NOT_ENOUGH_MEMORY,
    LZ4_INVALID_ARCHIVE,
    LZ4_CORRUPTED_ARCHIVE
} LZ4_STATUS;

#if defined (__cplusplus)
extern "C"
{
#endif

__declspec(dllimport) LZ4_STATUS LZ4_compress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_compress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);

#if defined (__cplusplus)
}
#endif

#endif //_LZ4FILE_H
```

`plugin/sdk/lz4/lz4hc.h`:

```h
/*
   LZ4 HC - High Compression Mode of LZ4
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4HC_H
#define _LZ4HC_H

#if defined (__cplusplus)
extern "C"
{
#endif


__declspec(dllimport) int LZ4_compressHC(const char* source, char* dest, int inputSize);
/*
LZ4_compressHC :
    return : the number of bytes in compressed buffer dest
             or 0 if compression fails.
    note : destination buffer must be already allocated.
        To avoid any problem, size it to handle worst cases situations (input data not compressible)
        Worst case size evaluation is provided by function LZ4_compressBound() (see "lz4.h")
*/

__declspec(dllimport) int LZ4_compressHC_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);
/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is 1 GB
    maxOutputSize : is maximum allowed size into the destination buffer (which must be already allocated)
    return : the number of output bytes written in buffer 'dest'
             or 0 if compression fails.
*/


__declspec(dllimport) int LZ4_compressHC2(const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);
/*
    Same functions as above, but with programmable 'compressionLevel'.
    Recommended values are between 4 and 9, although any value between 0 and 16 will work.
    'compressionLevel'==0 means use default 'compressionLevel' value.
    Values above 16 behave the same as 16.
    Equivalent variants exist for all other compression functions below.
*/

/* Note :
Decompression functions are provided within LZ4 source code (see "lz4.h") (BSD license)
*/


/**************************************
   Using an external allocation
**************************************/
__declspec(dllimport) int LZ4_sizeofStateHC(void);
__declspec(dllimport) int LZ4_compressHC_withStateHC(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compressHC_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);

__declspec(dllimport) int LZ4_compressHC2_withStateHC(void* state, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofStateHC();

Note that tables must be aligned for pointer (32 or 64 bits), otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withStateHC() and LZ4_compress_limitedOutput_withStateHC() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_createHC(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compressHC_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compressHC_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
__declspec(dllimport) int   LZ4_freeHC(void* LZ4HC_Data);

__declspec(dllimport) int   LZ4_compressHC2_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int   LZ4_compressHC2_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4HC Data Structure, thanks to the function :

void* LZ4_createHC (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4HC Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue().
Their behavior are identical to LZ4_compressHC() or LZ4_compressHC_limitedOutput(),
but require the LZ4HC Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_freeHC() will release the memory used by the LZ4HC Data Structure.
*/

__declspec(dllimport) int LZ4_sizeofStreamStateHC(void);
__declspec(dllimport) int LZ4_resetStreamStateHC(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_createHC (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamStateHC();
Note also that space must be aligned for pointers (32 or 64 bits).

Once space is allocated, you must initialize it using : LZ4_resetStreamStateHC(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned for pointers (32 or 64 bits), and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamStateHC() must be 0 is OK.
Any other value means there was an error (typically, state is not aligned for pointers (32 or 64 bits)).
*/


#if defined (__cplusplus)
}
#endif

#endif //_LZ4HC_H

```

`plugin/src/bridge/c_bridge_executor.cpp`:

```cpp
#include "bridge/c_bridge_executor.h"

#include <thread>
#include <chrono>

#include "bridgemain.h"
#include "_plugins.h"
#include "_dbgfunctions.h"
#include "util/format_utils.h"

// Global singleton instance
static c_bridge_executor g_bridge;

c_bridge_executor& get_bridge() {
    return g_bridge;
}

bool c_bridge_executor::is_debugging() const {
    return DbgIsDebugging();
}

bool c_bridge_executor::is_running() const {
    return DbgIsRunning();
}

std::string c_bridge_executor::get_state_string() const {
    if (!DbgIsDebugging()) return "stopped";
    if (DbgIsRunning())    return "running";
    return "paused";
}

bool c_bridge_executor::exec_command(const std::string& cmd) {
    return DbgCmdExecDirect(cmd.c_str());
}

bool c_bridge_executor::exec_command_async(const std::string& cmd) {
    return DbgCmdExec(cmd.c_str());
}

bool c_bridge_executor::exec_command_and_wait(const std::string& cmd, int timeout_ms) {
    std::lock_guard lock(m_mutex);

    if (!DbgCmdExecDirect(cmd.c_str())) {
        return false;
    }

    return wait_for_pause(timeout_ms);
}

bool c_bridge_executor::wait_for_pause(int timeout_ms) {
    auto start = std::chrono::steady_clock::now();
    auto timeout = std::chrono::milliseconds(timeout_ms);

    // First, wait a tiny bit for the command to take effect
    std::this_thread::sleep_for(std::chrono::milliseconds(10));

    while (DbgIsRunning()) {
        auto elapsed = std::chrono::steady_clock::now() - start;
        if (elapsed >= timeout) {
            return false; // Timed out waiting for pause
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }

    return true;
}

duint c_bridge_executor::eval_expression(const std::string& expression) {
    return DbgValFromString(expression.c_str());
}

bool c_bridge_executor::is_valid_expression(const std::string& expression) {
    return DbgIsValidExpression(expression.c_str());
}

std::expected<std::vector<uint8_t>, std::string> c_bridge_executor::read_memory(duint address, size_t size) {
    if (size == 0 || size > 10 * 1024 * 1024) { // 10MB max
        return std::unexpected("Invalid read size (must be 1 to 10MB)");
    }

    std::vector<uint8_t> buffer(size);
    if (!DbgMemRead(address, buffer.data(), static_cast<duint>(size))) {
        return std::unexpected("Failed to read memory at " + format_utils::format_address(address));
    }

    return buffer;
}

std::expected<void, std::string> c_bridge_executor::write_memory(duint address, const std::vector<uint8_t>& data) {
    if (data.empty()) {
        return std::unexpected("No data to write");
    }

    if (!DbgMemWrite(address, data.data(), static_cast<duint>(data.size()))) {
        return std::unexpected("Failed to write memory at " + format_utils::format_address(address));
    }

    return {};
}

bool c_bridge_executor::is_valid_read_ptr(duint address) {
    return DbgMemIsValidReadPtr(address);
}

std::expected<REGDUMP, std::string> c_bridge_executor::get_register_dump() {
    REGDUMP dump{};
    // DbgGetRegDumpEx uses size parameter to distinguish REGDUMP vs REGDUMP_AVX512
    if (!DbgGetRegDumpEx(reinterpret_cast<REGDUMP_AVX512*>(&dump), sizeof(REGDUMP))) {
        return std::unexpected("Failed to get register dump");
    }
    return dump;
}

std::expected<nlohmann::json, std::string> c_bridge_executor::get_memory_map() {
    MEMMAP memmap{};
    if (!DbgMemMap(&memmap)) {
        return std::unexpected("Failed to get memory map");
    }

    auto result = nlohmann::json::array();
    for (int i = 0; i < memmap.count; ++i) {
        const auto& page = memmap.page[i];
        result.push_back({
            {"base",             format_utils::format_address(reinterpret_cast<duint>(page.mbi.BaseAddress))},
            {"allocation_base",  format_utils::format_address(reinterpret_cast<duint>(page.mbi.AllocationBase))},
            {"size",             static_cast<duint>(page.mbi.RegionSize)},
            {"size_hex",         format_utils::format_hex(static_cast<duint>(page.mbi.RegionSize))},
            {"state",            format_utils::format_mem_state(page.mbi.State)},
            {"protect",          format_utils::format_protection(page.mbi.Protect)},
            {"type",             format_utils::format_mem_type(page.mbi.Type)},
            {"info",             page.info}
        });
    }

    if (memmap.page) {
        BridgeFree(memmap.page);
    }

    return result;
}

std::expected<nlohmann::json, std::string> c_bridge_executor::get_breakpoint_list(BPXTYPE type) {
    BPMAP bpmap{};
    DbgGetBpList(type, &bpmap); // Returns count (int), 0 is valid (no breakpoints)

    auto result = nlohmann::json::array();
    for (int i = 0; i < bpmap.count; ++i) {
        const auto& bp = bpmap.bp[i];
        result.push_back({
            {"address",          format_utils::format_address(bp.addr)},
            {"enabled",          bp.enabled},
            {"active",           bp.active},
            {"singleshoot",      bp.singleshoot},
            {"name",             bp.name},
            {"module",           bp.mod},
            {"hit_count",        bp.hitCount},
            {"fast_resume",      bp.fastResume},
            {"silent",           bp.silent},
            {"break_condition",  bp.breakCondition},
            {"log_text",         bp.logText},
            {"log_condition",    bp.logCondition},
            {"command_text",     bp.commandText},
            {"command_condition", bp.commandCondition},
            {"type",             static_cast<int>(bp.type)}
        });
    }

    if (bpmap.bp) {
        BridgeFree(bpmap.bp);
    }

    return result;
}

std::expected<nlohmann::json, std::string> c_bridge_executor::get_thread_list() {
    THREADLIST thread_list{};
    DbgGetThreadList(&thread_list);

    auto result = nlohmann::json::object();
    auto threads = nlohmann::json::array();

    for (int i = 0; i < thread_list.count; ++i) {
        const auto& t = thread_list.list[i];
        threads.push_back({
            {"number",        t.BasicInfo.ThreadNumber},
            {"id",            t.BasicInfo.ThreadId},
            {"handle",        format_utils::format_address(reinterpret_cast<duint>(t.BasicInfo.Handle))},
            {"start_address", format_utils::format_address(t.BasicInfo.ThreadStartAddress)},
            {"local_base",    format_utils::format_address(t.BasicInfo.ThreadLocalBase)},
            {"name",          t.BasicInfo.threadName},
            {"cip",           format_utils::format_address(t.ThreadCip)},
            {"suspend_count", t.SuspendCount},
            {"priority",      static_cast<int>(t.Priority)},
            {"last_error",    t.LastError}
        });
    }

    result["threads"] = threads;
    result["count"] = thread_list.count;
    result["current_thread"] = thread_list.CurrentThread;

    if (thread_list.list) {
        BridgeFree(thread_list.list);
    }

    return result;
}

std::string c_bridge_executor::get_label_at(duint address) {
    char label[MAX_LABEL_SIZE] = {};
    if (DbgGetLabelAt(address, SEG_DEFAULT, label)) {
        return label;
    }
    return "";
}

bool c_bridge_executor::set_label_at(duint address, const std::string& text) {
    return DbgSetLabelAt(address, text.c_str());
}

std::string c_bridge_executor::get_comment_at(duint address) {
    char comment[MAX_COMMENT_SIZE] = {};
    if (DbgGetCommentAt(address, comment)) {
        return comment;
    }
    return "";
}

bool c_bridge_executor::set_comment_at(duint address, const std::string& text) {
    return DbgSetCommentAt(address, text.c_str());
}

bool c_bridge_executor::set_bookmark_at(duint address, bool set) {
    return DbgSetBookmarkAt(address, set);
}

std::expected<nlohmann::json, std::string> c_bridge_executor::disassemble_at(duint address, int count) {
    auto instructions = nlohmann::json::array();
    auto current_addr = address;

    for (int i = 0; i < count; ++i) {
        DISASM_INSTR instr{};
        DbgDisasmAt(current_addr, &instr); // Returns void
        if (instr.instr_size == 0) break;

        // Get basic info for branch/call flags
        BASIC_INSTRUCTION_INFO basic{};
        DbgDisasmFastAt(current_addr, &basic);

        // Get label if any
        char label[MAX_LABEL_SIZE] = {};
        DbgGetLabelAt(current_addr, SEG_DEFAULT, label);

        // Get comment if any
        char comment[MAX_COMMENT_SIZE] = {};
        DbgGetCommentAt(current_addr, comment);

        instructions.push_back({
            {"address",     format_utils::format_address(current_addr)},
            {"instruction", instr.instruction},
            {"size",        instr.instr_size},
            {"type",        static_cast<int>(instr.type)},
            {"is_branch",   basic.branch},
            {"is_call",     basic.call},
            {"label",       label},
            {"comment",     comment}
        });

        current_addr += instr.instr_size;
    }

    return instructions;
}

std::expected<nlohmann::json, std::string> c_bridge_executor::get_basic_info(duint address) {
    BASIC_INSTRUCTION_INFO info{};
    DbgDisasmFastAt(address, &info); // Returns void

    if (info.size == 0) {
        return std::unexpected("Failed to get instruction info at " + format_utils::format_address(address));
    }

    return nlohmann::json{
        {"address",     format_utils::format_address(address)},
        {"size",        info.size},
        {"is_branch",   info.branch},
        {"is_call",     info.call},
        {"instruction", info.instruction}
    };
}

std::expected<nlohmann::json, std::string> c_bridge_executor::get_function_bounds(duint address) {
    duint start = 0, end = 0;
    if (!DbgFunctionGet(address, &start, &end)) {
        return std::unexpected("No function found at " + format_utils::format_address(address));
    }

    return nlohmann::json{
        {"start", format_utils::format_address(start)},
        {"end",   format_utils::format_address(end)},
        {"size",  end - start}
    };
}

duint c_bridge_executor::get_module_base(const std::string& name) {
    return DbgModBaseFromName(name.c_str());
}

std::string c_bridge_executor::get_module_at(duint address) {
    char mod_name[MAX_MODULE_SIZE] = {};
    if (DbgGetModuleAt(address, mod_name)) {
        return mod_name;
    }
    return "";
}

bool c_bridge_executor::require_paused() const {
    return is_debugging() && !is_running();
}

bool c_bridge_executor::require_debugging() const {
    return is_debugging();
}

```

`plugin/src/bridge/c_bridge_executor.h`:

```h
#pragma once

#include <string>
#include <expected>
#include <cstdint>
#include <mutex>
#include <vector>

#include <nlohmann/json.hpp>
#include "_plugin_types.h"

// Thread-safe wrapper around x64dbg Bridge API calls.
// Most Bridge functions are already internally synchronized,
// but we add a mutex for compound operations (e.g., step + wait).
class c_bridge_executor {
public:
    // Debugger state check
    [[nodiscard]] bool is_debugging() const;
    [[nodiscard]] bool is_running() const;

    // Get the current debugger state as a string
    [[nodiscard]] std::string get_state_string() const;

    // Execute a command synchronously (return value often intentionally ignored)
    bool exec_command(const std::string& cmd);

    // Execute a command asynchronously (non-blocking, for traces/animations)
    bool exec_command_async(const std::string& cmd);

    // Execute a command and wait for the debugger to pause (with timeout)
    [[nodiscard]] bool exec_command_and_wait(const std::string& cmd, int timeout_ms = 5000);

    // Evaluate an expression (e.g., "rax", "module.entry", "0x401000+10")
    [[nodiscard]] duint eval_expression(const std::string& expression);

    // Check if an expression is valid
    [[nodiscard]] bool is_valid_expression(const std::string& expression);

    // Memory operations
    [[nodiscard]] std::expected<std::vector<uint8_t>, std::string> read_memory(duint address, size_t size);
    [[nodiscard]] std::expected<void, std::string> write_memory(duint address, const std::vector<uint8_t>& data);
    [[nodiscard]] bool is_valid_read_ptr(duint address);

    // Register dump
    [[nodiscard]] std::expected<REGDUMP, std::string> get_register_dump();

    // Memory map
    [[nodiscard]] std::expected<nlohmann::json, std::string> get_memory_map();

    // Breakpoint list
    [[nodiscard]] std::expected<nlohmann::json, std::string> get_breakpoint_list(BPXTYPE type);

    // Thread list
    [[nodiscard]] std::expected<nlohmann::json, std::string> get_thread_list();

    // Labels and comments
    [[nodiscard]] std::string get_label_at(duint address);
    [[nodiscard]] bool set_label_at(duint address, const std::string& text);
    [[nodiscard]] std::string get_comment_at(duint address);
    [[nodiscard]] bool set_comment_at(duint address, const std::string& text);
    [[nodiscard]] bool set_bookmark_at(duint address, bool set);

    // Disassembly
    [[nodiscard]] std::expected<nlohmann::json, std::string> disassemble_at(duint address, int count);
    [[nodiscard]] std::expected<nlohmann::json, std::string> get_basic_info(duint address);

    // Function analysis
    [[nodiscard]] std::expected<nlohmann::json, std::string> get_function_bounds(duint address);

    // Module info
    [[nodiscard]] duint get_module_base(const std::string& name);
    [[nodiscard]] std::string get_module_at(duint address);

    // Require paused state, return error response if not paused
    [[nodiscard]] bool require_paused() const;

    // Require debugging state, return error response if not debugging
    [[nodiscard]] bool require_debugging() const;

private:
    mutable std::mutex m_mutex;  // For compound operations only

    // Wait for debugger to reach paused state
    [[nodiscard]] bool wait_for_pause(int timeout_ms);
};

// Global singleton
c_bridge_executor& get_bridge();

```

`plugin/src/handlers/analysis_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "bridgelist.h"

namespace handlers {

void register_analysis_routes(c_http_router& router) {
    // GET /api/analysis/function?address=0x... - Function boundaries
    router.get("/api/analysis/function", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);

        auto bounds = bridge.get_function_bounds(address);
        if (!bounds.has_value()) {
            return s_http_response::not_found("No function at " + address_str);
        }

        auto start_addr = format_utils::parse_address(bounds.value()["start"].get<std::string>());
        auto label = bridge.get_label_at(start_addr);
        auto module_name = bridge.get_module_at(start_addr);

        auto data = bounds.value();
        data["label"] = label;
        data["module"] = module_name;

        return s_http_response::ok(data);
    });

    // GET /api/analysis/xrefs_to?address=0x... - Cross-references to address
    router.get("/api/analysis/xrefs_to", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto xref_count = DbgGetXrefCountAt(address);

        auto xrefs = nlohmann::json::array();

        if (xref_count > 0) {
            XREF_INFO xref_info{};
            if (DbgXrefGet(address, &xref_info)) {
                for (duint i = 0; i < xref_info.refcount; ++i) {
                    const auto& ref = xref_info.references[i];
                    auto label = bridge.get_label_at(ref.addr);
                    auto module_name = bridge.get_module_at(ref.addr);

                    std::string type_str;
                    switch (ref.type) {
                        case XREF_CALL: type_str = "call"; break;
                        case XREF_JMP:  type_str = "jmp"; break;
                        case XREF_DATA: type_str = "data"; break;
                        default:        type_str = "unknown"; break;
                    }

                    xrefs.push_back({
                        {"address", format_utils::format_address(ref.addr)},
                        {"type",    type_str},
                        {"label",   label},
                        {"module",  module_name}
                    });
                }

                if (xref_info.references) {
                    BridgeFree(xref_info.references);
                }
            }
        }

        return s_http_response::ok({
            {"target", format_utils::format_address(address)},
            {"xrefs",  xrefs},
            {"count",  xrefs.size()}
        });
    });

    // GET /api/analysis/xrefs_from?address=0x... - Cross-references from address
    router.get("/api/analysis/xrefs_from", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);

        // Disassemble the instruction to find references
        auto basic = bridge.get_basic_info(address);
        if (!basic.has_value()) {
            return s_http_response::internal_error(basic.error());
        }

        auto refs = nlohmann::json::array();
        if (basic.value()["is_call"].get<bool>() || basic.value()["is_branch"].get<bool>()) {
            // Try to evaluate the target
            // x64dbg uses dis.branchexec(addr) and dis.branchtarget(addr) expressions
            auto target = bridge.eval_expression("dis.branchtarget(" + address_str + ")");
            if (target != 0) {
                auto label = bridge.get_label_at(target);
                auto module_name = bridge.get_module_at(target);

                refs.push_back({
                    {"address", format_utils::format_address(target)},
                    {"type",    basic.value()["is_call"].get<bool>() ? "call" : "branch"},
                    {"label",   label},
                    {"module",  module_name}
                });
            }
        }

        return s_http_response::ok({
            {"source", format_utils::format_address(address)},
            {"refs",   refs},
            {"count",  refs.size()}
        });
    });

    // GET /api/analysis/basic_blocks?address=0x... - CFG basic blocks
    router.get("/api/analysis/basic_blocks", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);

        // Get function boundaries first
        auto bounds = bridge.get_function_bounds(address);
        if (!bounds.has_value()) {
            return s_http_response::not_found("No function at " + address_str);
        }

        auto func_start = format_utils::parse_address(bounds.value()["start"].get<std::string>());
        auto func_end = format_utils::parse_address(bounds.value()["end"].get<std::string>());

        // Walk the function to identify basic blocks
        auto blocks = nlohmann::json::array();
        auto current_block_start = func_start;
        auto current_addr = func_start;

        while (current_addr <= func_end) {
            BASIC_INSTRUCTION_INFO info{};
            DbgDisasmFastAt(current_addr, &info); // Returns void
            if (info.size == 0) break;

            bool is_block_end = info.branch || info.call;

            // Check if next instruction starts a new block (e.g., is a branch target)
            if (is_block_end || current_addr + info.size > func_end) {
                blocks.push_back({
                    {"start", format_utils::format_address(current_block_start)},
                    {"end",   format_utils::format_address(current_addr)},
                    {"size",  current_addr + info.size - current_block_start}
                });
                current_block_start = current_addr + info.size;
            }

            current_addr += info.size;
        }

        return s_http_response::ok({
            {"function_start", bounds.value()["start"]},
            {"function_end",   bounds.value()["end"]},
            {"blocks",         blocks},
            {"count",          blocks.size()}
        });
    });

    // GET /api/analysis/constants - List known constants
    router.get("/api/analysis/constants", [](const s_http_request&) -> s_http_response {
        BridgeList<CONSTANTINFO> constants;
        DbgFunctions()->EnumConstants(&constants);

        auto result = nlohmann::json::array();
        for (int i = 0; i < constants.Count(); ++i) {
            result.push_back({
                {"name",  constants[i].name},
                {"value", format_utils::format_address(constants[i].value)}
            });
        }

        return s_http_response::ok({
            {"constants", result},
            {"count",     result.size()}
        });
    });

    // GET /api/analysis/error_codes - List known error codes
    router.get("/api/analysis/error_codes", [](const s_http_request&) -> s_http_response {
        BridgeList<CONSTANTINFO> codes;
        DbgFunctions()->EnumErrorCodes(&codes);

        auto result = nlohmann::json::array();
        for (int i = 0; i < codes.Count(); ++i) {
            result.push_back({
                {"name",  codes[i].name},
                {"value", format_utils::format_address(codes[i].value)}
            });
        }

        return s_http_response::ok({
            {"error_codes", result},
            {"count",       result.size()}
        });
    });

    // GET /api/analysis/watch?id= - Check if watchdog triggered
    router.get("/api/analysis/watch", [](const s_http_request& req) -> s_http_response {
        auto id_str = req.get_query("id", "0");
        auto id = static_cast<unsigned int>(std::stoul(id_str));

        auto triggered = DbgFunctions()->WatchIsWatchdogTriggered(id);

        return s_http_response::ok({
            {"id",        id},
            {"triggered", triggered}
        });
    });

    // GET /api/analysis/structs - List defined structs
    router.get("/api/analysis/structs", [](const s_http_request&) -> s_http_response {
        auto structs = nlohmann::json::array();

        DbgFunctions()->EnumStructs([](const char* str, void* userdata) {
            auto* arr = static_cast<nlohmann::json*>(userdata);
            arr->push_back(str);
        }, &structs);

        return s_http_response::ok({
            {"structs", structs},
            {"count",   structs.size()}
        });
    });

    // GET /api/analysis/source?address= - Get source file location
    router.get("/api/analysis/source", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);

        char source_file[MAX_PATH] = {};
        int line = 0;
        auto found = DbgFunctions()->GetSourceFromAddr(address, source_file, &line);

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"found",   found},
            {"file",    std::string(source_file)},
            {"line",    line}
        });
    });

    // GET /api/analysis/va_to_file?address= - Convert VA to file offset
    router.get("/api/analysis/va_to_file", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto va = bridge.eval_expression(address_str);
        auto file_offset = DbgFunctions()->VaToFileOffset(va);

        return s_http_response::ok({
            {"va",          format_utils::format_address(va)},
            {"file_offset", format_utils::format_address(file_offset)},
            {"found",       file_offset != 0}
        });
    });

    // GET /api/analysis/file_to_va?module=&offset= - Convert file offset to VA
    router.get("/api/analysis/file_to_va", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto module_name = req.get_query("module");
        auto offset_str = req.get_query("offset");
        if (module_name.empty() || offset_str.empty()) {
            return s_http_response::bad_request("Missing 'module' and/or 'offset' query parameters");
        }

        auto offset = bridge.eval_expression(offset_str);
        auto va = DbgFunctions()->FileOffsetToVa(module_name.c_str(), offset);

        return s_http_response::ok({
            {"module",      module_name},
            {"file_offset", format_utils::format_address(offset)},
            {"va",          format_utils::format_address(va)},
            {"found",       va != 0}
        });
    });

    // GET /api/analysis/mnemonic_brief?mnemonic= - Get mnemonic brief description
    router.get("/api/analysis/mnemonic_brief", [](const s_http_request& req) -> s_http_response {
        auto mnemonic = req.get_query("mnemonic");
        if (mnemonic.empty()) {
            return s_http_response::bad_request("Missing 'mnemonic' query parameter");
        }

        char result[256] = {};
        DbgFunctions()->GetMnemonicBrief(mnemonic.c_str(), sizeof(result), result);

        return s_http_response::ok({
            {"mnemonic",    mnemonic},
            {"description", std::string(result)}
        });
    });

    // GET /api/analysis/strings?module=... - Find strings in module
    router.get("/api/analysis/strings", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto module_name = req.get_query("module");
        if (module_name.empty()) {
            return s_http_response::bad_request("Missing 'module' query parameter");
        }

        auto base = bridge.get_module_base(module_name);
        if (base == 0) {
            return s_http_response::not_found("Module not found: " + module_name);
        }

        // Use x64dbg's strref command
        auto cmd = "strref " + format_utils::format_address(base);
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"module",  module_name},
            {"base",    format_utils::format_address(base)},
            {"message", "String references displayed in x64dbg references view"}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/annotation_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>

namespace handlers {

void register_annotation_routes(c_http_router& router) {
    // GET /api/labels/get?address=0x... - Get label
    router.get("/api/labels/get", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto label = bridge.get_label_at(address);

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"label",   label}
        });
    });

    // POST /api/labels/set - Set label
    router.post("/api/labels/set", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address") || !body.contains("text")) {
            return s_http_response::bad_request("Missing 'address' and/or 'text' fields");
        }

        auto address = bridge.eval_expression(body["address"].get<std::string>());
        auto text = body["text"].get<std::string>();

        if (!bridge.set_label_at(address, text)) {
            return s_http_response::internal_error("Failed to set label");
        }

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"label",   text}
        });
    });

    // GET /api/comments/get?address=0x... - Get comment
    router.get("/api/comments/get", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto comment = bridge.get_comment_at(address);

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"comment", comment}
        });
    });

    // POST /api/comments/set - Set comment
    router.post("/api/comments/set", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address") || !body.contains("text")) {
            return s_http_response::bad_request("Missing 'address' and/or 'text' fields");
        }

        auto address = bridge.eval_expression(body["address"].get<std::string>());
        auto text = body["text"].get<std::string>();

        if (!bridge.set_comment_at(address, text)) {
            return s_http_response::internal_error("Failed to set comment");
        }

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"comment", text}
        });
    });

    // POST /api/bookmarks/set - Set/clear bookmark
    router.post("/api/bookmarks/set", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address = bridge.eval_expression(body["address"].get<std::string>());
        auto set = body.value("set", true);

        if (!bridge.set_bookmark_at(address, set)) {
            return s_http_response::internal_error("Failed to set bookmark");
        }

        return s_http_response::ok({
            {"address",    format_utils::format_address(address)},
            {"bookmarked", set}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/antidebug_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"

namespace handlers {

void register_antidebug_routes(c_http_router& router) {
    // GET /api/antidebug/peb?pid= - Read PEB info
    router.get("/api/antidebug/peb", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto pid_str = req.get_query("pid", "");
        DWORD pid = 0;
        if (pid_str.empty()) {
            pid = static_cast<DWORD>(bridge.eval_expression("$pid"));
        } else {
            pid = static_cast<DWORD>(std::stoul(pid_str));
        }

        auto peb_addr = DbgGetPebAddress(pid);
        if (peb_addr == 0) {
            return s_http_response::not_found("Failed to get PEB address");
        }

        nlohmann::json data = {
            {"peb_address", format_utils::format_address(peb_addr)},
            {"pid", pid}
        };

        // Read BeingDebugged (offset 0x2 in PEB, 1 byte)
        auto being_debugged = bridge.read_memory(peb_addr + 0x2, 1);
        if (being_debugged.has_value()) {
            data["being_debugged"] = being_debugged.value()[0];
        }

        // Read NtGlobalFlag (offset 0x68 on x86, 0xBC on x64)
#ifdef _WIN64
        constexpr duint ntglobalflag_offset = 0xBC;
#else
        constexpr duint ntglobalflag_offset = 0x68;
#endif
        auto ntglobal = bridge.read_memory(peb_addr + ntglobalflag_offset, 4);
        if (ntglobal.has_value()) {
            DWORD flags = 0;
            memcpy(&flags, ntglobal.value().data(), 4);
            data["nt_global_flag"] = format_utils::format_address(flags);
            data["nt_global_flag_decimal"] = flags;
        }

        // Read ProcessHeap (offset 0x18 on x86, 0x30 on x64)
#ifdef _WIN64
        constexpr duint heap_offset = 0x30;
#else
        constexpr duint heap_offset = 0x18;
#endif
        auto heap_data = bridge.read_memory(peb_addr + heap_offset, sizeof(duint));
        if (heap_data.has_value()) {
            duint heap_addr = 0;
            memcpy(&heap_addr, heap_data.value().data(), sizeof(duint));
            data["process_heap"] = format_utils::format_address(heap_addr);
        }

        return s_http_response::ok(data);
    });

    // GET /api/antidebug/teb?tid= - Read TEB info
    router.get("/api/antidebug/teb", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto tid_str = req.get_query("tid", "");
        DWORD tid = 0;
        if (tid_str.empty()) {
            tid = static_cast<DWORD>(bridge.eval_expression("$tid"));
        } else {
            tid = static_cast<DWORD>(std::stoul(tid_str));
        }

        auto teb_addr = DbgGetTebAddress(tid);
        if (teb_addr == 0) {
            return s_http_response::not_found("Failed to get TEB address");
        }

        nlohmann::json data = {
            {"teb_address", format_utils::format_address(teb_addr)},
            {"tid", tid}
        };

        // Read SEH chain pointer (offset 0x0 in TEB)
        auto seh = bridge.read_memory(teb_addr, sizeof(duint));
        if (seh.has_value()) {
            duint seh_addr = 0;
            memcpy(&seh_addr, seh.value().data(), sizeof(duint));
            data["seh_frame"] = format_utils::format_address(seh_addr);
        }

        // Read stack base (offset 0x4/0x8) and limit (offset 0x8/0x10)
#ifdef _WIN64
        constexpr duint stack_base_offset = 0x8;
        constexpr duint stack_limit_offset = 0x10;
        constexpr duint peb_offset = 0x60;
#else
        constexpr duint stack_base_offset = 0x4;
        constexpr duint stack_limit_offset = 0x8;
        constexpr duint peb_offset = 0x30;
#endif

        auto stack_base = bridge.read_memory(teb_addr + stack_base_offset, sizeof(duint));
        if (stack_base.has_value()) {
            duint val = 0;
            memcpy(&val, stack_base.value().data(), sizeof(duint));
            data["stack_base"] = format_utils::format_address(val);
        }

        auto stack_limit = bridge.read_memory(teb_addr + stack_limit_offset, sizeof(duint));
        if (stack_limit.has_value()) {
            duint val = 0;
            memcpy(&val, stack_limit.value().data(), sizeof(duint));
            data["stack_limit"] = format_utils::format_address(val);
        }

        auto peb = bridge.read_memory(teb_addr + peb_offset, sizeof(duint));
        if (peb.has_value()) {
            duint val = 0;
            memcpy(&val, peb.value().data(), sizeof(duint));
            data["peb_address"] = format_utils::format_address(val);
        }

        return s_http_response::ok(data);
    });

    // POST /api/antidebug/hide_debugger - Hide debugger from PEB
    router.post("/api/antidebug/hide_debugger", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto pid = static_cast<DWORD>(bridge.eval_expression("$pid"));
        auto peb_addr = DbgGetPebAddress(pid);
        if (peb_addr == 0) {
            return s_http_response::internal_error("Failed to get PEB address");
        }

        nlohmann::json changes = nlohmann::json::array();

        // Zero out BeingDebugged (PEB + 0x2)
        std::vector<uint8_t> zero_byte = {0x00};
        auto result = bridge.write_memory(peb_addr + 0x2, zero_byte);
        if (result.has_value()) {
            changes.push_back({{"field", "BeingDebugged"}, {"offset", "0x2"}, {"value", 0}});
        }

        // Zero out NtGlobalFlag
#ifdef _WIN64
        constexpr duint ntglobalflag_offset = 0xBC;
#else
        constexpr duint ntglobalflag_offset = 0x68;
#endif
        std::vector<uint8_t> zero_dword = {0x00, 0x00, 0x00, 0x00};
        result = bridge.write_memory(peb_addr + ntglobalflag_offset, zero_dword);
        if (result.has_value()) {
            changes.push_back({{"field", "NtGlobalFlag"}, {"offset", format_utils::format_hex(ntglobalflag_offset)}, {"value", 0}});
        }

        return s_http_response::ok({
            {"peb_address", format_utils::format_address(peb_addr)},
            {"changes", changes},
            {"message", "Debugger hidden from PEB checks"}
        });
    });

    // GET /api/antidebug/dep_status - DEP enabled status
    router.get("/api/antidebug/dep_status", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto dep_enabled = DbgFunctions()->IsDepEnabled();

        return s_http_response::ok({
            {"dep_enabled", dep_enabled}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/breakpoint_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>

namespace handlers {

// Apply all configurable breakpoint fields present in the JSON body.
// Uses SetBreakpointXxx commands. Only sets fields that are explicitly provided.
// x64dbg expression syntax: use [addr] for dereference, NOT poi(addr).
static void apply_bp_config(c_bridge_executor& bridge, const std::string& addr_str,
                             const nlohmann::json& body) {
    if (body.contains("break_condition")) {
        auto cond = body["break_condition"].get<std::string>();
        bridge.exec_command("SetBreakpointCondition " + addr_str + ", \"" + cond + "\"");
    }
    if (body.contains("command_condition")) {
        auto cond = body["command_condition"].get<std::string>();
        bridge.exec_command("SetBreakpointCommandCondition " + addr_str + ", \"" + cond + "\"");
    }
    if (body.contains("command_text")) {
        auto cmd = body["command_text"].get<std::string>();
        bridge.exec_command("SetBreakpointCommand " + addr_str + ", \"" + cmd + "\"");
    }
    if (body.contains("log_text")) {
        auto log = body["log_text"].get<std::string>();
        bridge.exec_command("SetBreakpointLog " + addr_str + ", \"" + log + "\"");
    }
    if (body.contains("log_condition")) {
        auto cond = body["log_condition"].get<std::string>();
        bridge.exec_command("SetBreakpointLogCondition " + addr_str + ", \"" + cond + "\"");
    }
    if (body.contains("silent")) {
        auto silent = body["silent"].get<bool>();
        bridge.exec_command("SetBreakpointSilent " + addr_str + ", " + (silent ? "1" : "0"));
    }
    if (body.contains("fast_resume")) {
        auto fr = body["fast_resume"].get<bool>();
        bridge.exec_command("SetBreakpointFastResume " + addr_str + ", " + (fr ? "1" : "0"));
    }
    if (body.contains("name")) {
        auto name = body["name"].get<std::string>();
        bridge.exec_command("SetBreakpointName " + addr_str + ", \"" + name + "\"");
    }
}

void register_breakpoint_routes(c_http_router& router) {
    // GET /api/breakpoints/list - List all breakpoints (with symbol labels resolved)
    router.get("/api/breakpoints/list", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();

        nlohmann::json all_bps = nlohmann::json::array();

        auto add_bps_with_type = [&](BPXTYPE type, const char* type_name) {
            auto bps = bridge.get_breakpoint_list(type);
            if (!bps.has_value()) return;
            for (auto& bp : bps.value()) {
                // Resolve symbol label if name is empty
                if (bp["name"].get<std::string>().empty()) {
                    auto addr = bridge.eval_expression(bp["address"].get<std::string>());
                    auto label = bridge.get_label_at(addr);
                    bp["label"] = label;  // Symbol name (e.g. "FindWindowA")
                } else {
                    bp["label"] = bp["name"].get<std::string>();
                }
                bp["type_name"] = type_name;
                all_bps.push_back(bp);
            }
        };

        add_bps_with_type(bp_normal,   "software");
        add_bps_with_type(bp_hardware, "hardware");
        add_bps_with_type(bp_memory,   "memory");

        return s_http_response::ok({
            {"breakpoints", all_bps},
            {"count",       all_bps.size()}
        });
    });

    // GET /api/breakpoints/get?address=0x... - Get breakpoint at address
    router.get("/api/breakpoints/get", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto addr_hex = format_utils::format_address(address);

        for (auto type : {bp_normal, bp_hardware, bp_memory}) {
            auto bps = bridge.get_breakpoint_list(type);
            if (!bps.has_value()) continue;
            for (auto& bp : bps.value()) {
                if (bp["address"] == addr_hex) {
                    // Resolve label
                    if (bp["name"].get<std::string>().empty()) {
                        bp["label"] = bridge.get_label_at(address);
                    } else {
                        bp["label"] = bp["name"].get<std::string>();
                    }
                    return s_http_response::ok(bp);
                }
            }
        }

        return s_http_response::not_found("No breakpoint at " + address_str);
    });

    // POST /api/breakpoints/set - Set software breakpoint
    router.post("/api/breakpoints/set", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        auto singleshot = body.value("singleshot", false);

        auto cmd = singleshot
            ? "bp " + address_str + ", ss"
            : "bp " + address_str;

        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"address",    address_str},
            {"type",       "software"},
            {"singleshot", singleshot}
        });
    });

    // POST /api/breakpoints/set_hardware - Set hardware breakpoint
    router.post("/api/breakpoints/set_hardware", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        auto type = body.value("type", "x"); // r/w/x
        auto size = body.value("size", "1"); // 1/2/4/8

        auto cmd = "bphws " + address_str + ", " + type + ", " + size;
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"address", address_str},
            {"type",    "hardware"},
            {"hw_type", type},
            {"hw_size", size}
        });
    });

    // POST /api/breakpoints/set_memory - Set memory breakpoint
    router.post("/api/breakpoints/set_memory", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        auto type = body.value("type", "a"); // a=access, r=read, w=write, x=execute

        auto cmd = "bpm " + address_str + ", " + type;
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"address",  address_str},
            {"type",     "memory"},
            {"mem_type", type}
        });
    });

    // POST /api/breakpoints/delete - Delete breakpoint
    router.post("/api/breakpoints/delete", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        auto type = body.value("type", "software");

        std::string cmd;
        if (type == "hardware") {
            cmd = "bphwc " + address_str;
        } else if (type == "memory") {
            cmd = "bpmc " + address_str;
        } else {
            cmd = "bc " + address_str;
        }

        bridge.exec_command(cmd);
        return s_http_response::ok({
            {"address", address_str},
            {"deleted", true}
        });
    });

    // POST /api/breakpoints/enable - Enable breakpoint
    router.post("/api/breakpoints/enable", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        bridge.exec_command("bpe " + address_str);

        return s_http_response::ok({{"address", address_str}, {"enabled", true}});
    });

    // POST /api/breakpoints/disable - Disable breakpoint
    router.post("/api/breakpoints/disable", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        bridge.exec_command("bpd " + address_str);

        return s_http_response::ok({{"address", address_str}, {"enabled", false}});
    });

    // POST /api/breakpoints/toggle - Toggle breakpoint
    router.post("/api/breakpoints/toggle", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        bridge.exec_command("bptoggle " + address_str);

        return s_http_response::ok({{"address", address_str}, {"toggled", true}});
    });

    // POST /api/breakpoints/set_condition - Set breakpoint break_condition
    // Note: this sets break_condition (controls whether to PAUSE), not command_condition.
    // Use /api/breakpoints/configure for all conditions in one call.
    router.post("/api/breakpoints/set_condition", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address") || !body.contains("condition")) {
            return s_http_response::bad_request("Missing 'address' and/or 'condition' fields");
        }

        auto address_str = body["address"].get<std::string>();
        auto condition = body["condition"].get<std::string>();

        // Note: x64dbg uses [addr] bracket syntax for memory dereference, NOT poi(addr)
        auto cmd = "SetBreakpointCondition " + address_str + ", \"" + condition + "\"";
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"address",   address_str},
            {"condition", condition}
        });
    });

    // POST /api/breakpoints/set_log - Set breakpoint log message
    router.post("/api/breakpoints/set_log", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address") || !body.contains("text")) {
            return s_http_response::bad_request("Missing 'address' and/or 'text' fields");
        }

        auto address_str = body["address"].get<std::string>();
        auto text = body["text"].get<std::string>();

        auto cmd = "SetBreakpointLog " + address_str + ", \"" + text + "\"";
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"address", address_str},
            {"log",     text}
        });
    });

    // POST /api/breakpoints/configure - Unified breakpoint configuration
    // Creates the BP if it does not exist, then applies all provided fields.
    // This replaces 6 separate calls (set + condition + command_condition + command_text + silent + fast_resume).
    //
    // Expression syntax note: x64dbg uses [addr] for memory dereference, NOT poi(addr).
    // Examples:
    //   break_condition: "0"                      (never pause - fast-resume style)
    //   command_condition: "[esp+8]==11"           (condition to run command)
    //   command_text: "eax=0;eip=[esp];esp=esp+C;run"  (command on BP hit)
    router.post("/api/breakpoints/configure", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        auto bp_type = body.value("bp_type", "software");  // software, hardware, memory

        // Set the breakpoint if it doesn't exist yet
        if (bp_type == "hardware") {
            auto hw_type = body.value("hw_type", "x");
            auto hw_size = body.value("hw_size", "1");
            bridge.exec_command("bphws " + address_str + ", " + hw_type + ", " + hw_size);
        } else if (bp_type == "memory") {
            auto mem_type = body.value("mem_type", "a");
            bridge.exec_command("bpm " + address_str + ", " + mem_type);
        } else {
            // Software BP
            auto singleshot = body.value("singleshot", false);
            if (singleshot) {
                bridge.exec_command("bp " + address_str + ", ss");
            } else {
                bridge.exec_command("bp " + address_str);
            }
        }

        // Apply all config fields
        apply_bp_config(bridge, address_str, body);

        return s_http_response::ok({
            {"address", address_str},
            {"bp_type", bp_type},
            {"configured", true}
        });
    });

    // POST /api/breakpoints/configure_batch - Batch configure multiple breakpoints
    // Accepts an array of configure objects. Reduces N*6 calls to 1 call.
    // Each entry has the same fields as /api/breakpoints/configure.
    router.post("/api/breakpoints/configure_batch", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("breakpoints")) {
            return s_http_response::bad_request("Missing 'breakpoints' array field");
        }

        auto& bps_json = body["breakpoints"];
        if (!bps_json.is_array()) {
            return s_http_response::bad_request("'breakpoints' must be an array");
        }

        auto results = nlohmann::json::array();
        int succeeded = 0;
        int failed = 0;

        for (const auto& entry : bps_json) {
            if (!entry.contains("address")) {
                results.push_back({{"error", "missing address"}, {"success", false}});
                ++failed;
                continue;
            }

            auto address_str = entry["address"].get<std::string>();
            auto bp_type = entry.value("bp_type", "software");

            // Set the BP
            if (bp_type == "hardware") {
                auto hw_type = entry.value("hw_type", "x");
                auto hw_size = entry.value("hw_size", "1");
                bridge.exec_command("bphws " + address_str + ", " + hw_type + ", " + hw_size);
            } else if (bp_type == "memory") {
                auto mem_type = entry.value("mem_type", "a");
                bridge.exec_command("bpm " + address_str + ", " + mem_type);
            } else {
                auto singleshot = entry.value("singleshot", false);
                if (singleshot) {
                    bridge.exec_command("bp " + address_str + ", ss");
                } else {
                    bridge.exec_command("bp " + address_str);
                }
            }

            // Apply config
            apply_bp_config(bridge, address_str, entry);

            results.push_back({{"address", address_str}, {"success", true}});
            ++succeeded;
        }

        return s_http_response::ok({
            {"results",   results},
            {"total",     bps_json.size()},
            {"succeeded", succeeded},
            {"failed",    failed}
        });
    });

    // POST /api/breakpoints/reset_hit_count - Reset hit counter for a breakpoint
    router.post("/api/breakpoints/reset_hit_count", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        bridge.exec_command("ResetBreakpointHitCount " + address_str);

        return s_http_response::ok({
            {"address",   address_str},
            {"hit_count", 0}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/command_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "_dbgfunctions.h"

namespace handlers {

void register_command_routes(c_http_router& router) {
    // POST /api/command/exec - Execute x64dbg command
    router.post("/api/command/exec", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("command")) {
            return s_http_response::bad_request("Missing 'command' field");
        }

        auto command = body["command"].get<std::string>();
        auto success = bridge.exec_command(command);

        return s_http_response::ok({
            {"command", command},
            {"success", success}
        });
    });

    // POST /api/command/eval - Evaluate expression
    router.post("/api/command/eval", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("expression")) {
            return s_http_response::bad_request("Missing 'expression' field");
        }

        auto expression = body["expression"].get<std::string>();

        if (!bridge.is_valid_expression(expression)) {
            return s_http_response::bad_request("Invalid expression: " + expression);
        }

        auto result = bridge.eval_expression(expression);

        return s_http_response::ok({
            {"expression", expression},
            {"value",      format_utils::format_address(result)},
            {"decimal",    result}
        });
    });

    // POST /api/command/format - Format string using x64dbg expression engine
    router.post("/api/command/format", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("format")) {
            return s_http_response::bad_request("Missing 'format' field");
        }

        auto fmt = body["format"].get<std::string>();
        char result[1024] = {};
        auto success = DbgFunctions()->StringFormatInline(fmt.c_str(), sizeof(result), result);

        return s_http_response::ok({
            {"success", success},
            {"format",  fmt},
            {"result",  std::string(result)}
        });
    });

    // GET /api/command/events - Get debug event count
    router.get("/api/command/events", [](const s_http_request&) -> s_http_response {
        auto events = DbgFunctions()->GetDbgEvents();

        return s_http_response::ok({
            {"event_count", events}
        });
    });

    // POST /api/command/init_script - Set debuggee init script
    router.post("/api/command/init_script", [](const s_http_request& req) -> s_http_response {
        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("file")) {
            return s_http_response::bad_request("Missing 'file' field");
        }

        auto file = body["file"].get<std::string>();
        DbgFunctions()->DbgSetDebuggeeInitScript(file.c_str());

        return s_http_response::ok({
            {"file", file},
            {"message", "Init script set"}
        });
    });

    // GET /api/command/init_script - Get debuggee init script
    router.get("/api/command/init_script", [](const s_http_request&) -> s_http_response {
        auto* script = DbgFunctions()->DbgGetDebuggeeInitScript();

        return s_http_response::ok({
            {"file", script ? std::string(script) : ""}
        });
    });

    // GET /api/command/hash - Get database hash
    router.get("/api/command/hash", [](const s_http_request&) -> s_http_response {
        auto hash = DbgFunctions()->DbGetHash();

        return s_http_response::ok({
            {"hash", format_utils::format_address(hash)}
        });
    });

    // POST /api/command/script - Execute batch of commands
    router.post("/api/command/script", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("commands")) {
            return s_http_response::bad_request("Missing 'commands' field (array of strings)");
        }

        auto commands = body["commands"];
        if (!commands.is_array()) {
            return s_http_response::bad_request("'commands' must be an array of strings");
        }

        auto results = nlohmann::json::array();
        int succeeded = 0;
        int failed = 0;

        for (const auto& cmd : commands) {
            auto cmd_str = cmd.get<std::string>();
            auto success = bridge.exec_command(cmd_str);

            results.push_back({
                {"command", cmd_str},
                {"success", success}
            });

            if (success) ++succeeded;
            else ++failed;
        }

        return s_http_response::ok({
            {"results",   results},
            {"total",     commands.size()},
            {"succeeded", succeeded},
            {"failed",    failed}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/controlflow_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "bridgegraph.h"

namespace handlers {

void register_controlflow_routes(c_http_router& router) {
    // GET /api/cfg/function?address= - Get control flow graph
    router.get("/api/cfg/function", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);

        BridgeCFGraphList graph_list{};
        if (!DbgAnalyzeFunction(address, &graph_list)) {
            return s_http_response::not_found("Failed to analyze function at " + address_str);
        }

        BridgeCFGraph graph(&graph_list, true);

        auto nodes = nlohmann::json::array();
        for (const auto& [start, node] : graph.nodes) {
            auto exits = nlohmann::json::array();
            for (auto exit_addr : node.exits) {
                exits.push_back(format_utils::format_address(exit_addr));
            }

            auto instrs = nlohmann::json::array();
            for (const auto& instr : node.instrs) {
                instrs.push_back({
                    {"address", format_utils::format_address(instr.addr)},
                    {"data",    format_utils::format_bytes_hex(instr.data, sizeof(instr.data))}
                });
            }

            nodes.push_back({
                {"start",          format_utils::format_address(node.start)},
                {"end",            format_utils::format_address(node.end)},
                {"brtrue",         format_utils::format_address(node.brtrue)},
                {"brfalse",        format_utils::format_address(node.brfalse)},
                {"terminal",       node.terminal},
                {"split",          node.split},
                {"indirectcall",   node.indirectcall},
                {"exits",          exits},
                {"instructions",   instrs}
            });
        }

        return s_http_response::ok({
            {"entry_point", format_utils::format_address(graph.entryPoint)},
            {"nodes",       nodes},
            {"node_count",  nodes.size()}
        });
    });

    // GET /api/cfg/branch_dest?address= - Get branch destination
    router.get("/api/cfg/branch_dest", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);
        auto dest = DbgGetBranchDestination(address);

        auto label = bridge.get_label_at(dest);
        auto module_name = bridge.get_module_at(dest);

        return s_http_response::ok({
            {"address",     format_utils::format_address(address)},
            {"destination", format_utils::format_address(dest)},
            {"label",       label},
            {"module",      module_name},
            {"has_dest",    dest != 0}
        });
    });

    // GET /api/cfg/is_jump_taken?address= - Will jump execute?
    router.get("/api/cfg/is_jump_taken", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);
        auto will_execute = DbgIsJumpGoingToExecute(address);

        return s_http_response::ok({
            {"address",      format_utils::format_address(address)},
            {"will_execute", will_execute}
        });
    });

    // GET /api/cfg/loops?address= - Get loop info
    router.get("/api/cfg/loops", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);

        auto loops = nlohmann::json::array();
        for (int depth = 0; depth < 10; ++depth) {
            duint loop_start = 0, loop_end = 0;
            if (!DbgLoopGet(depth, address, &loop_start, &loop_end)) {
                break;
            }
            loops.push_back({
                {"depth", depth},
                {"start", format_utils::format_address(loop_start)},
                {"end",   format_utils::format_address(loop_end)},
                {"size",  loop_end - loop_start}
            });
        }

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"loops",   loops},
            {"count",   loops.size()}
        });
    });

    // POST /api/cfg/add_function - Define a function
    router.post("/api/cfg/add_function", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("start") || !body.contains("end")) {
            return s_http_response::bad_request("Missing 'start' and/or 'end' fields");
        }

        auto start = bridge.eval_expression(body["start"].get<std::string>());
        auto end = bridge.eval_expression(body["end"].get<std::string>());

        auto success = DbgFunctionAdd(start, end);

        return s_http_response::ok({
            {"success", success},
            {"start",   format_utils::format_address(start)},
            {"end",     format_utils::format_address(end)}
        });
    });

    // POST /api/cfg/delete_function - Delete a function definition
    router.post("/api/cfg/delete_function", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address = bridge.eval_expression(body["address"].get<std::string>());
        auto success = DbgFunctionDel(address);

        return s_http_response::ok({
            {"success", success},
            {"address", format_utils::format_address(address)}
        });
    });

    // GET /api/cfg/func_type?address= - Get function type at address
    router.get("/api/cfg/func_type", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);
        auto func_type = DbgGetFunctionTypeAt(address);

        std::string type_str;
        switch (func_type) {
            case FUNC_NONE:   type_str = "none"; break;
            case FUNC_BEGIN:  type_str = "begin"; break;
            case FUNC_MIDDLE: type_str = "middle"; break;
            case FUNC_END:    type_str = "end"; break;
            case FUNC_SINGLE: type_str = "single"; break;
            default:          type_str = "unknown"; break;
        }

        return s_http_response::ok({
            {"address",   format_utils::format_address(address)},
            {"func_type", type_str},
            {"type_id",   static_cast<int>(func_type)}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/debug_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include <thread>
#include <chrono>

namespace handlers {

void register_debug_routes(c_http_router& router) {
    // GET /api/debug/state - Current debugger state + CIP
    router.get("/api/debug/state", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        auto state = bridge.get_state_string();

        nlohmann::json data = {{"state", state}};

        if (bridge.is_debugging() && !bridge.is_running()) {
            auto cip = bridge.eval_expression("cip");
            data["cip"] = format_utils::format_address(cip);

            auto module_name = bridge.get_module_at(cip);
            if (!module_name.empty()) {
                data["module"] = module_name;
            }

            auto label = bridge.get_label_at(cip);
            if (!label.empty()) {
                data["label"] = label;
            }
        }

        return s_http_response::ok(data);
    });

    // POST /api/debug/run - Resume execution
    router.post("/api/debug/run", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        bridge.exec_command("run");
        return s_http_response::ok({{"message", "Execution resumed"}});
    });

    // POST /api/debug/pause - Pause execution
    router.post("/api/debug/pause", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.is_debugging()) {
            return s_http_response::conflict("No active debug session");
        }
        if (!bridge.is_running()) {
            return s_http_response::ok({{"message", "Already paused"}});
        }

        bridge.exec_command("pause");
        return s_http_response::ok({{"message", "Pause requested"}});
    });

    // POST /api/debug/step_into - Step into
    router.post("/api/debug/step_into", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        if (!bridge.exec_command_and_wait("StepInto")) {
            return s_http_response::internal_error("Step into timed out");
        }

        auto cip = bridge.eval_expression("cip");
        return s_http_response::ok({
            {"cip", format_utils::format_address(cip)},
            {"message", "Stepped into"}
        });
    });

    // POST /api/debug/step_over - Step over
    router.post("/api/debug/step_over", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        if (!bridge.exec_command_and_wait("StepOver")) {
            return s_http_response::internal_error("Step over timed out");
        }

        auto cip = bridge.eval_expression("cip");
        return s_http_response::ok({
            {"cip", format_utils::format_address(cip)},
            {"message", "Stepped over"}
        });
    });

    // POST /api/debug/step_out - Run to return
    router.post("/api/debug/step_out", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        if (!bridge.exec_command_and_wait("StepOut", 30000)) {
            return s_http_response::internal_error("Step out timed out");
        }

        auto cip = bridge.eval_expression("cip");
        return s_http_response::ok({
            {"cip", format_utils::format_address(cip)},
            {"message", "Stepped out"}
        });
    });

    // POST /api/debug/stop - Stop debugging
    router.post("/api/debug/stop", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.is_debugging()) {
            return s_http_response::ok({{"message", "Not debugging"}});
        }

        bridge.exec_command("stop");
        return s_http_response::ok({{"message", "Debug session stopped"}});
    });

    // POST /api/debug/restart - Restart debuggee
    router.post("/api/debug/restart", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.is_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        bridge.exec_command("restart");
        return s_http_response::ok({{"message", "Restart initiated"}});
    });

    // POST /api/debug/force_pause - Force pause even against high-frequency fast-resume breakpoints
    // Strategy: temporarily disables all fast-resume breakpoints, issues pause, waits for
    // paused state, then restores fast-resume. This reliably wins the race that normal
    // pause loses when 46+ fast-resume hits/sec are occurring.
    router.post("/api/debug/force_pause", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.is_debugging()) {
            return s_http_response::conflict("No active debug session");
        }
        if (!bridge.is_running()) {
            return s_http_response::ok({{"message", "Already paused"}});
        }

        // Collect all normal BPs with fast_resume=true and temporarily disable it
        std::vector<std::string> fast_resume_addrs;
        for (auto type : {bp_normal, bp_hardware, bp_memory}) {
            auto bps = bridge.get_breakpoint_list(type);
            if (!bps.has_value()) continue;
            for (const auto& bp : bps.value()) {
                if (bp.value("fast_resume", false)) {
                    auto addr_str = bp["address"].get<std::string>();
                    fast_resume_addrs.push_back(addr_str);
                    bridge.exec_command("SetBreakpointFastResume " + addr_str + ", 0");
                }
            }
        }

        // Now issue pause - without fast-resume racing, it will succeed
        bridge.exec_command("pause");

        // Wait up to 3s for paused state
        bool paused = false;
        for (int i = 0; i < 300 && !paused; ++i) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            paused = !bridge.is_running();
        }

        // Restore fast-resume on all BPs that had it
        for (const auto& addr_str : fast_resume_addrs) {
            bridge.exec_command("SetBreakpointFastResume " + addr_str + ", 1");
        }

        if (!paused) {
            return s_http_response::internal_error("Force pause timed out after 3s");
        }

        return s_http_response::ok({
            {"message",           "Debuggee forcefully paused"},
            {"fast_resume_count", fast_resume_addrs.size()}
        });
    });

    // POST /api/debug/run_to - Run to specific address
    router.post("/api/debug/run_to", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        auto cmd = "bp " + address_str + ", ss";  // Single-shot breakpoint
        bridge.exec_command(cmd.c_str());
        bridge.exec_command("run");

        return s_http_response::ok({
            {"message", "Running to " + address_str},
            {"target", address_str}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/disasm_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>

namespace handlers {

void register_disasm_routes(c_http_router& router) {
    // GET /api/disasm/at?address=0x...&count=10 - Disassemble N instructions
    router.get("/api/disasm/at", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto count_str = req.get_query("count", "10");

        auto address = bridge.eval_expression(address_str);
        auto count = std::stoi(count_str);

        if (count < 1) count = 1;
        if (count > 1000) count = 1000;

        auto result = bridge.disassemble_at(address, count);
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        return s_http_response::ok({
            {"address",      format_utils::format_address(address)},
            {"count",        result->size()},
            {"instructions", result.value()}
        });
    });

    // GET /api/disasm/function?address=0x...&max_instructions=N - Disassemble entire function
    // max_instructions: used as the fallback count when no function boundary is found
    // (common with VMP/Themida protected modules). Default: 50. Max: 5000.
    router.get("/api/disasm/function", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);

        auto max_instr_str = req.get_query("max_instructions", "50");
        auto fallback_count = std::stoi(max_instr_str);
        if (fallback_count < 1)    fallback_count = 1;
        if (fallback_count > 5000) fallback_count = 5000;

        // Get function boundaries
        auto bounds = bridge.get_function_bounds(address);
        if (!bounds.has_value()) {
            // No function boundary found - common with VMP/packed modules
            // Use max_instructions parameter so caller can control how much to see
            auto result = bridge.disassemble_at(address, fallback_count);
            if (!result.has_value()) {
                return s_http_response::internal_error(result.error());
            }
            return s_http_response::ok({
                {"address",          format_utils::format_address(address)},
                {"note",             "No function boundary found (try running 'analyze' first). Showing " +
                                     std::to_string(fallback_count) + " instructions from address."},
                {"fallback_count",   fallback_count},
                {"instructions",     result.value()}
            });
        }

        auto start = format_utils::parse_address(bounds.value()["start"].get<std::string>());
        auto end_addr = format_utils::parse_address(bounds.value()["end"].get<std::string>());

        // Estimate instruction count (average ~4 bytes per instruction)
        auto estimated_count = static_cast<int>((end_addr - start) / 2) + 1;
        if (estimated_count > 5000) estimated_count = 5000;

        auto result = bridge.disassemble_at(start, estimated_count);
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        // Filter to only instructions within the function
        auto filtered = nlohmann::json::array();
        for (const auto& instr : result.value()) {
            auto instr_addr = format_utils::parse_address(instr["address"].get<std::string>());
            if (instr_addr > end_addr) break;
            filtered.push_back(instr);
        }

        return s_http_response::ok({
            {"function_start", bounds.value()["start"]},
            {"function_end",   bounds.value()["end"]},
            {"function_size",  bounds.value()["size"]},
            {"count",          filtered.size()},
            {"instructions",   filtered}
        });
    });

    // GET /api/disasm/basic?address=0x... - Fast instruction info
    router.get("/api/disasm/basic", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "cip");
        auto address = bridge.eval_expression(address_str);

        auto result = bridge.get_basic_info(address);
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        return s_http_response::ok(result.value());
    });

    // POST /api/disasm/assemble - Assemble instruction at address
    router.post("/api/disasm/assemble", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address") || !body.contains("instruction")) {
            return s_http_response::bad_request("Missing 'address' and/or 'instruction' fields");
        }

        auto address_str = body["address"].get<std::string>();
        auto instruction = body["instruction"].get<std::string>();

        auto cmd = "asm " + address_str + ", \"" + instruction + "\"";
        if (!bridge.exec_command(cmd)) {
            return s_http_response::internal_error("Failed to assemble instruction");
        }

        return s_http_response::ok({
            {"address",     address_str},
            {"instruction", instruction}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/dumping_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "bridgelist.h"

namespace handlers {

void register_dumping_routes(c_http_router& router) {
    // POST /api/dump/module - Dump module to file
    router.post("/api/dump/module", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("module")) {
            return s_http_response::bad_request("Missing 'module' field");
        }

        auto module_name = body["module"].get<std::string>();
        auto file_path = body.value("file", "");

        auto base = bridge.get_module_base(module_name);
        if (base == 0) {
            return s_http_response::not_found("Module not found: " + module_name);
        }

        // Use x64dbg's savedata command
        auto size = bridge.eval_expression("mod.size(" + module_name + ")");
        std::string cmd;
        if (!file_path.empty()) {
            cmd = "savedata " + file_path + ", " + format_utils::format_address(base) + ", " + format_utils::format_hex(size);
        } else {
            cmd = "savedata :memdump:, " + format_utils::format_address(base) + ", " + format_utils::format_hex(size);
        }

        auto success = bridge.exec_command(cmd);

        return s_http_response::ok({
            {"success", success},
            {"module", module_name},
            {"base", format_utils::format_address(base)},
            {"size", size},
            {"file", file_path.empty() ? "(prompted)" : file_path}
        });
    });

    // GET /api/dump/pe_header?address= - Parse PE header from memory
    router.get("/api/dump/pe_header", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address", "");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto base = bridge.eval_expression(address_str);

        // Read DOS header (first 64 bytes)
        auto dos_header = bridge.read_memory(base, 64);
        if (!dos_header.has_value()) {
            return s_http_response::internal_error("Failed to read DOS header");
        }

        const auto& dos = dos_header.value();
        if (dos.size() < 64 || dos[0] != 'M' || dos[1] != 'Z') {
            return s_http_response::bad_request("Not a valid PE file (no MZ signature)");
        }

        // e_lfanew at offset 0x3C
        DWORD e_lfanew = 0;
        memcpy(&e_lfanew, dos.data() + 0x3C, 4);

        // Read PE signature + headers (enough for COFF + optional header)
        auto pe_header = bridge.read_memory(base + e_lfanew, 264);
        if (!pe_header.has_value()) {
            return s_http_response::internal_error("Failed to read PE header");
        }

        const auto& pe = pe_header.value();
        if (pe.size() < 4 || pe[0] != 'P' || pe[1] != 'E') {
            return s_http_response::bad_request("Invalid PE signature");
        }

        // COFF header starts at offset 4 in PE signature block
        WORD machine = 0;
        memcpy(&machine, pe.data() + 4, 2);

        WORD num_sections = 0;
        memcpy(&num_sections, pe.data() + 6, 2);

        DWORD timestamp = 0;
        memcpy(&timestamp, pe.data() + 8, 4);

        WORD size_of_optional = 0;
        memcpy(&size_of_optional, pe.data() + 20, 2);

        WORD characteristics = 0;
        memcpy(&characteristics, pe.data() + 22, 2);

        nlohmann::json data = {
            {"base",              format_utils::format_address(base)},
            {"e_lfanew",          format_utils::format_address(e_lfanew)},
            {"machine",           format_utils::format_address(machine)},
            {"number_of_sections", num_sections},
            {"timestamp",         timestamp},
            {"characteristics",   format_utils::format_address(characteristics)},
            {"size_of_optional_header", size_of_optional}
        };

        // Optional header starts at offset 24
        if (pe.size() >= 28) {
            WORD magic = 0;
            memcpy(&magic, pe.data() + 24, 2);
            data["magic"] = format_utils::format_address(magic);
            data["is_pe32plus"] = (magic == 0x20B);

            if (magic == 0x10B && pe.size() >= 64) {
                // PE32
                DWORD entry_point = 0;
                memcpy(&entry_point, pe.data() + 40, 4);
                data["address_of_entry_point"] = format_utils::format_address(entry_point);

                DWORD image_base_32 = 0;
                memcpy(&image_base_32, pe.data() + 52, 4);
                data["image_base"] = format_utils::format_address(image_base_32);

                DWORD size_of_image = 0;
                memcpy(&size_of_image, pe.data() + 80, 4);
                data["size_of_image"] = size_of_image;
            } else if (magic == 0x20B && pe.size() >= 88) {
                // PE32+
                DWORD entry_point = 0;
                memcpy(&entry_point, pe.data() + 40, 4);
                data["address_of_entry_point"] = format_utils::format_address(entry_point);

                uint64_t image_base_64 = 0;
                memcpy(&image_base_64, pe.data() + 48, 8);
                data["image_base"] = format_utils::format_address(static_cast<duint>(image_base_64));

                DWORD size_of_image = 0;
                memcpy(&size_of_image, pe.data() + 80, 4);
                data["size_of_image"] = size_of_image;
            }
        }

        return s_http_response::ok(data);
    });

    // GET /api/dump/sections?module= - Get PE sections
    router.get("/api/dump/sections", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto module_name = req.get_query("module", "");
        if (module_name.empty()) {
            return s_http_response::bad_request("Missing 'module' query parameter");
        }

        auto base = bridge.get_module_base(module_name);
        if (base == 0) {
            return s_http_response::not_found("Module not found: " + module_name);
        }

        // Read DOS header to get e_lfanew
        auto dos = bridge.read_memory(base, 64);
        if (!dos.has_value() || dos.value().size() < 64) {
            return s_http_response::internal_error("Failed to read DOS header");
        }

        DWORD e_lfanew = 0;
        memcpy(&e_lfanew, dos.value().data() + 0x3C, 4);

        // Read PE header to get number of sections and optional header size
        auto pe = bridge.read_memory(base + e_lfanew, 24);
        if (!pe.has_value() || pe.value().size() < 24) {
            return s_http_response::internal_error("Failed to read PE header");
        }

        WORD num_sections = 0;
        memcpy(&num_sections, pe.value().data() + 6, 2);

        WORD optional_size = 0;
        memcpy(&optional_size, pe.value().data() + 20, 2);

        // Section headers start after optional header
        auto section_offset = e_lfanew + 24 + optional_size;
        auto section_data = bridge.read_memory(base + section_offset, num_sections * 40); // IMAGE_SECTION_HEADER is 40 bytes
        if (!section_data.has_value()) {
            return s_http_response::internal_error("Failed to read section headers");
        }

        auto sections = nlohmann::json::array();
        for (WORD i = 0; i < num_sections; ++i) {
            auto* sec = section_data.value().data() + (i * 40);

            char name[9] = {};
            memcpy(name, sec, 8);

            DWORD virtual_size = 0, virtual_addr = 0, raw_size = 0, raw_ptr = 0, chars = 0;
            memcpy(&virtual_size, sec + 8, 4);
            memcpy(&virtual_addr, sec + 12, 4);
            memcpy(&raw_size, sec + 16, 4);
            memcpy(&raw_ptr, sec + 20, 4);
            memcpy(&chars, sec + 36, 4);

            sections.push_back({
                {"name",           std::string(name)},
                {"virtual_address", format_utils::format_address(virtual_addr)},
                {"virtual_size",   virtual_size},
                {"raw_size",       raw_size},
                {"raw_offset",     format_utils::format_address(raw_ptr)},
                {"characteristics", format_utils::format_address(chars)}
            });
        }

        return s_http_response::ok({
            {"module", module_name},
            {"base", format_utils::format_address(base)},
            {"sections", sections},
            {"count", sections.size()}
        });
    });

    // GET /api/dump/imports?module= - Get import table
    router.get("/api/dump/imports", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto module_name = req.get_query("module", "");
        if (module_name.empty()) {
            return s_http_response::bad_request("Missing 'module' query parameter");
        }

        // Use x64dbg's modimports command to display in reference view
        auto base = bridge.get_module_base(module_name);
        if (base == 0) {
            return s_http_response::not_found("Module not found: " + module_name);
        }

        auto cmd = "modimports " + format_utils::format_address(base);
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"module", module_name},
            {"base", format_utils::format_address(base)},
            {"message", "Import table displayed in x64dbg references view"}
        });
    });

    // GET /api/dump/exports?module= - Get export table
    router.get("/api/dump/exports", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto module_name = req.get_query("module", "");
        if (module_name.empty()) {
            return s_http_response::bad_request("Missing 'module' query parameter");
        }

        auto base = bridge.get_module_base(module_name);
        if (base == 0) {
            return s_http_response::not_found("Module not found: " + module_name);
        }

        auto cmd = "modexports " + format_utils::format_address(base);
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"module", module_name},
            {"base", format_utils::format_address(base)},
            {"message", "Export table displayed in x64dbg references view"}
        });
    });

    // POST /api/dump/fix_iat - IAT reconstruction (uses x64dbg Scylla)
    router.post("/api/dump/fix_iat", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        auto oep = body.value("oep", "");

        if (oep.empty()) {
            return s_http_response::bad_request("Missing 'oep' (original entry point) field");
        }

        // Use Scylla plugin commands
        auto cmd = "scylla iatAutoFix " + oep;
        auto success = bridge.exec_command(cmd);

        return s_http_response::ok({
            {"success", success},
            {"oep", oep},
            {"message", "IAT fix attempted via Scylla"}
        });
    });

    // GET /api/dump/relocations?address= - Get relocations for module
    router.get("/api/dump/relocations", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address", "");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);

        BridgeList<DBGRELOCATIONINFO> relocs;
        auto success = DbgFunctions()->ModRelocationsFromAddr(address, &relocs);

        if (!success) {
            return s_http_response::ok({
                {"address", format_utils::format_address(address)},
                {"relocations", nlohmann::json::array()},
                {"count", 0},
                {"message", "No relocations found or relocation data unavailable"}
            });
        }

        auto result = nlohmann::json::array();
        for (int i = 0; i < relocs.Count(); ++i) {
            result.push_back({
                {"rva",  format_utils::format_address(relocs[i].rva)},
                {"type", relocs[i].type},
                {"size", relocs[i].size}
            });
        }

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"relocations", result},
            {"count", result.size()}
        });
    });

    // POST /api/patches/export_file - Export patches to file
    router.post("/api/patches/export_file", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("filename")) {
            return s_http_response::bad_request("Missing 'filename' field");
        }

        auto filename = body["filename"].get<std::string>();

        // Get all patches
        size_t patch_count = 0;
        DbgFunctions()->PatchEnum(nullptr, &patch_count);

        if (patch_count == 0) {
            return s_http_response::ok({
                {"success", false},
                {"message", "No patches to export"}
            });
        }

        std::vector<DBGPATCHINFO> patches(patch_count);
        DbgFunctions()->PatchEnum(patches.data(), &patch_count);

        char error[MAX_ERROR_SIZE] = {};
        auto result = DbgFunctions()->PatchFile(patches.data(), static_cast<int>(patch_count), filename.c_str(), error);

        return s_http_response::ok({
            {"success",     result > 0},
            {"patch_count", patch_count},
            {"filename",    filename},
            {"error",       std::string(error)}
        });
    });

    // GET /api/dump/entry_point?module= - Get entry point of module
    router.get("/api/dump/entry_point", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto module_name = req.get_query("module", "");
        if (module_name.empty()) {
            return s_http_response::bad_request("Missing 'module' query parameter");
        }

        auto base = bridge.get_module_base(module_name);
        if (base == 0) {
            return s_http_response::not_found("Module not found: " + module_name);
        }

        auto entry = bridge.eval_expression("mod.entry(" + module_name + ")");

        return s_http_response::ok({
            {"module", module_name},
            {"base", format_utils::format_address(base)},
            {"entry_point", format_utils::format_address(entry)},
            {"rva", format_utils::format_address(entry - base)}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/exceptions_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "bridgelist.h"

namespace handlers {

void register_exception_routes(c_http_router& router) {
    // POST /api/exceptions/set_bp - Set exception breakpoint
    router.post("/api/exceptions/set_bp", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("code")) {
            return s_http_response::bad_request("Missing 'code' field");
        }

        auto code = body["code"].get<std::string>();
        auto chance = body.value("chance", "first"); // first, second, all
        auto action = body.value("action", "break"); // break, log, command

        auto cmd = "SetExceptionBPX " + code;
        if (chance == "second") {
            cmd += ", 1"; // second chance
        }

        auto success = bridge.exec_command(cmd);

        return s_http_response::ok({
            {"success", success},
            {"code", code},
            {"chance", chance}
        });
    });

    // POST /api/exceptions/delete_bp - Delete exception breakpoint
    router.post("/api/exceptions/delete_bp", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("code")) {
            return s_http_response::bad_request("Missing 'code' field");
        }

        auto code = body["code"].get<std::string>();
        auto cmd = "DeleteExceptionBPX " + code;
        auto success = bridge.exec_command(cmd);

        return s_http_response::ok({
            {"success", success},
            {"code", code}
        });
    });

    // GET /api/exceptions/list_bps - List exception breakpoints
    router.get("/api/exceptions/list_bps", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto result = bridge.get_breakpoint_list(bp_exception);
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        return s_http_response::ok({
            {"breakpoints", result.value()},
            {"count", result.value().size()}
        });
    });

    // GET /api/exceptions/list_codes - List known exception codes
    router.get("/api/exceptions/list_codes", [](const s_http_request&) -> s_http_response {
        BridgeList<CONSTANTINFO> constants;
        DbgFunctions()->EnumExceptions(&constants);

        auto result = nlohmann::json::array();
        for (int i = 0; i < constants.Count(); ++i) {
            result.push_back({
                {"name",  constants[i].name},
                {"value", format_utils::format_address(constants[i].value)}
            });
        }

        return s_http_response::ok({
            {"exceptions", result},
            {"count", result.size()}
        });
    });

    // POST /api/exceptions/skip - Skip/pass current exception
    router.post("/api/exceptions/skip", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto success = bridge.exec_command("skip");

        return s_http_response::ok({
            {"success", success},
            {"message", "Exception skipped"}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/handles_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "bridgelist.h"

namespace handlers {

void register_handles_routes(c_http_router& router) {
    // GET /api/handles/list - List handles in debugged process
    router.get("/api/handles/list", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        BridgeList<HANDLEINFO> handles;
        auto success = DbgFunctions()->EnumHandles(&handles);

        if (!success) {
            return s_http_response::ok({
                {"handles", nlohmann::json::array()},
                {"count", 0}
            });
        }

        auto result = nlohmann::json::array();
        for (int i = 0; i < handles.Count(); ++i) {
            char name[256] = {};
            char type_name[256] = {};
            DbgFunctions()->GetHandleName(handles[i].Handle, name, sizeof(name), type_name, sizeof(type_name));

            result.push_back({
                {"handle",         format_utils::format_address(handles[i].Handle)},
                {"type_number",    handles[i].TypeNumber},
                {"granted_access", format_utils::format_address(handles[i].GrantedAccess)},
                {"name",           std::string(name)},
                {"type_name",      std::string(type_name)}
            });
        }

        return s_http_response::ok({
            {"handles", result},
            {"count", result.size()}
        });
    });

    // GET /api/handles/get?handle= - Get handle name and type
    router.get("/api/handles/get", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto handle_str = req.get_query("handle");
        if (handle_str.empty()) {
            return s_http_response::bad_request("Missing 'handle' query parameter");
        }

        auto handle = bridge.eval_expression(handle_str);

        char name[256] = {};
        char type_name[256] = {};
        auto success = DbgFunctions()->GetHandleName(handle, name, sizeof(name), type_name, sizeof(type_name));

        return s_http_response::ok({
            {"handle",    format_utils::format_address(handle)},
            {"name",      std::string(name)},
            {"type_name", std::string(type_name)},
            {"found",     success}
        });
    });

    // GET /api/handles/tcp - List TCP connections
    router.get("/api/handles/tcp", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        BridgeList<TCPCONNECTIONINFO> connections;
        auto success = DbgFunctions()->EnumTcpConnections(&connections);

        if (!success) {
            return s_http_response::ok({
                {"connections", nlohmann::json::array()},
                {"count", 0}
            });
        }

        auto result = nlohmann::json::array();
        for (int i = 0; i < connections.Count(); ++i) {
            result.push_back({
                {"remote_address", std::string(connections[i].RemoteAddress)},
                {"remote_port",    connections[i].RemotePort},
                {"local_address",  std::string(connections[i].LocalAddress)},
                {"local_port",     connections[i].LocalPort},
                {"state_text",     std::string(connections[i].StateText)},
                {"state",          connections[i].State}
            });
        }

        return s_http_response::ok({
            {"connections", result},
            {"count", result.size()}
        });
    });

    // GET /api/handles/windows - List windows
    router.get("/api/handles/windows", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        BridgeList<WINDOW_INFO> windows;
        auto success = DbgFunctions()->EnumWindows(&windows);

        if (!success) {
            return s_http_response::ok({
                {"windows", nlohmann::json::array()},
                {"count", 0}
            });
        }

        auto result = nlohmann::json::array();
        for (int i = 0; i < windows.Count(); ++i) {
            result.push_back({
                {"handle",       format_utils::format_address(windows[i].handle)},
                {"parent",       format_utils::format_address(windows[i].parent)},
                {"thread_id",    windows[i].threadId},
                {"style",        format_utils::format_address(windows[i].style)},
                {"style_ex",     format_utils::format_address(windows[i].styleEx)},
                {"wnd_proc",     format_utils::format_address(windows[i].wndProc)},
                {"enabled",      windows[i].enabled},
                {"title",        std::string(windows[i].windowTitle)},
                {"class_name",   std::string(windows[i].windowClass)}
            });
        }

        return s_http_response::ok({
            {"windows", result},
            {"count", result.size()}
        });
    });

    // GET /api/handles/heaps - List heaps
    router.get("/api/handles/heaps", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        BridgeList<HEAPINFO> heaps;
        auto success = DbgFunctions()->EnumHeaps(&heaps);

        if (!success) {
            return s_http_response::ok({
                {"heaps", nlohmann::json::array()},
                {"count", 0}
            });
        }

        auto result = nlohmann::json::array();
        for (int i = 0; i < heaps.Count(); ++i) {
            result.push_back({
                {"address", format_utils::format_address(heaps[i].addr)},
                {"size",    heaps[i].size},
                {"flags",   format_utils::format_address(heaps[i].flags)}
            });
        }

        return s_http_response::ok({
            {"heaps", result},
            {"count", result.size()}
        });
    });

    // POST /api/handles/close - Close a handle
    router.post("/api/handles/close", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("handle")) {
            return s_http_response::bad_request("Missing 'handle' field");
        }

        auto handle = body["handle"].get<std::string>();
        auto cmd = "HandleClose " + handle;
        auto success = bridge.exec_command(cmd);

        return s_http_response::ok({
            {"success", success},
            {"handle", handle}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/memmap_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"

namespace handlers {

void register_memmap_routes(c_http_router& router) {
    // GET /api/memmap/list - Full memory map
    router.get("/api/memmap/list", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto result = bridge.get_memory_map();
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        return s_http_response::ok({
            {"regions", result.value()},
            {"count",   result->size()}
        });
    });

    // GET /api/memmap/at?address=0x... - Region containing address
    router.get("/api/memmap/at", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);

        // Find the region via DbgMemFindBaseAddr
        duint region_size = 0;
        auto base = DbgMemFindBaseAddr(address, &region_size);

        if (base == 0) {
            return s_http_response::not_found("No memory region at " + address_str);
        }

        auto module_name = bridge.get_module_at(base);

        return s_http_response::ok({
            {"address",     format_utils::format_address(address)},
            {"base",        format_utils::format_address(base)},
            {"region_size", region_size},
            {"module",      module_name}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/memory_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "_dbgfunctions.h"

namespace handlers {

void register_memory_routes(c_http_router& router) {
    // GET /api/memory/read?address=0x...&size=N - Read memory bytes
    router.get("/api/memory/read", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        auto size_str = req.get_query("size", "256");

        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto size = static_cast<size_t>(std::stoull(size_str));

        auto result = bridge.read_memory(address, size);
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        const auto& bytes = result.value();

        // Build ASCII representation
        std::string ascii;
        ascii.reserve(bytes.size());
        for (auto b : bytes) {
            ascii += (b >= 0x20 && b < 0x7F) ? static_cast<char>(b) : '.';
        }

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"size",    bytes.size()},
            {"hex",     format_utils::format_bytes_hex(bytes.data(), bytes.size())},
            {"ascii",   ascii}
        });
    });

    // POST /api/memory/write - Write bytes to memory
    // Optional: set "verify": true to read back and confirm the write succeeded.
    // This detects silent failures on copy-on-write or write-protected pages.
    router.post("/api/memory/write", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address") || !body.contains("bytes")) {
            return s_http_response::bad_request("Missing 'address' and/or 'bytes' fields");
        }

        auto address = bridge.eval_expression(body["address"].get<std::string>());
        auto hex_str = body["bytes"].get<std::string>();
        auto bytes = format_utils::parse_hex_bytes(hex_str);

        if (bytes.empty()) {
            return s_http_response::bad_request("No valid bytes to write");
        }

        auto result = bridge.write_memory(address, bytes);
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        nlohmann::json data = {
            {"address",       format_utils::format_address(address)},
            {"bytes_written", bytes.size()}
        };

        // Optional verify: read back and compare
        auto verify = body.value("verify", false);
        if (verify) {
            auto readback = bridge.read_memory(address, bytes.size());
            if (!readback.has_value()) {
                data["verified"] = false;
                data["verify_error"] = "Could not read back memory after write";
            } else if (readback.value() != bytes) {
                data["verified"] = false;
                data["verify_error"] = "Read-back mismatch - write may have failed (page may be write-protected or copy-on-write)";
                data["written_hex"]  = hex_str;
                data["actual_hex"]   = format_utils::format_bytes_hex(readback.value().data(), readback.value().size());
            } else {
                data["verified"] = true;
            }
        }

        return s_http_response::ok(data);
    });

    // GET /api/memory/is_valid?address=0x... - Check pointer validity
    router.get("/api/memory/is_valid", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto valid = bridge.is_valid_read_ptr(address);

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"valid",   valid}
        });
    });

    // GET /api/memory/page_info?address=0x... - Memory page info
    router.get("/api/memory/page_info", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        duint region_size = 0;
        auto base = DbgMemFindBaseAddr(address, &region_size);

        if (base == 0) {
            return s_http_response::not_found("No memory region at " + address_str);
        }

        auto module_name = bridge.get_module_at(address);

        return s_http_response::ok({
            {"address",     format_utils::format_address(address)},
            {"base",        format_utils::format_address(base)},
            {"region_size", region_size},
            {"module",      module_name}
        });
    });

    // POST /api/memory/allocate - Allocate memory in target process
    router.post("/api/memory/allocate", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        auto size_str = body.value("size", "0x1000");

        auto cmd = "alloc " + size_str;
        bridge.exec_command(cmd);

        auto result = bridge.eval_expression("$result");
        if (result == 0) {
            return s_http_response::internal_error("Memory allocation failed");
        }

        return s_http_response::ok({
            {"address", format_utils::format_address(result)},
            {"size",    size_str}
        });
    });

    // POST /api/memory/free - Free memory in target process
    router.post("/api/memory/free", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();
        auto cmd = "free " + address_str;
        bridge.exec_command(cmd);

        return s_http_response::ok({{"message", "Memory freed at " + address_str}});
    });

    // POST /api/memory/protect - Change page protection
    router.post("/api/memory/protect", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address") || !body.contains("protection")) {
            return s_http_response::bad_request("Missing 'address' and/or 'protection' fields");
        }

        auto address_str = body["address"].get<std::string>();
        auto size_str = body.value("size", "0x1000");
        auto protection = body["protection"].get<std::string>();

        auto cmd = "VirtualProtect " + address_str + ", " + size_str + ", " + protection;
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"address",    address_str},
            {"size",       size_str},
            {"protection", protection}
        });
    });

    // GET /api/memory/is_code?address= - Check if address is in a code page
    router.get("/api/memory/is_code", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto is_code = DbgFunctions()->MemIsCodePage(address, true);

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"is_code", is_code}
        });
    });

    // POST /api/memory/update_map - Refresh memory map
    router.post("/api/memory/update_map", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        DbgFunctions()->MemUpdateMap();

        return s_http_response::ok({
            {"message", "Memory map updated"}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/module_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "_dbgfunctions.h"

namespace handlers {

void register_module_routes(c_http_router& router) {
    // GET /api/modules/list - List loaded modules
    router.get("/api/modules/list", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        // Get memory map and extract unique modules
        auto memmap = bridge.get_memory_map();
        if (!memmap.has_value()) {
            return s_http_response::internal_error(memmap.error());
        }

        std::unordered_map<std::string, nlohmann::json> modules;
        for (const auto& page : memmap.value()) {
            auto info = page.value("info", "");
            if (info.empty()) continue;

            // Check if this looks like a module section
            auto base_str = page["base"].get<std::string>();
            auto base = format_utils::parse_address(base_str);
            auto mod_name = bridge.get_module_at(base);

            if (mod_name.empty()) continue;

            if (modules.find(mod_name) == modules.end()) {
                auto mod_base = bridge.get_module_base(mod_name);
                auto mod_size = bridge.eval_expression("mod.size(" + mod_name + ")");
                auto mod_entry = bridge.eval_expression("mod.entry(" + mod_name + ")");

                modules[mod_name] = {
                    {"name",  mod_name},
                    {"base",  format_utils::format_address(mod_base)},
                    {"size",  mod_size},
                    {"entry", format_utils::format_address(mod_entry)}
                };
            }
        }

        auto result = nlohmann::json::array();
        for (const auto& [name, info] : modules) {
            result.push_back(info);
        }

        return s_http_response::ok({
            {"modules", result},
            {"count",   result.size()}
        });
    });

    // GET /api/modules/get?name=... - Module info
    router.get("/api/modules/get", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto name = req.get_query("name");
        if (name.empty()) {
            return s_http_response::bad_request("Missing 'name' query parameter");
        }

        auto base = bridge.get_module_base(name);
        if (base == 0) {
            return s_http_response::not_found("Module not found: " + name);
        }

        auto size = bridge.eval_expression("mod.size(" + name + ")");
        auto entry = bridge.eval_expression("mod.entry(" + name + ")");
        auto party = bridge.eval_expression("mod.party(" + name + ")");

        return s_http_response::ok({
            {"name",  name},
            {"base",  format_utils::format_address(base)},
            {"size",  size},
            {"entry", format_utils::format_address(entry)},
            {"party", static_cast<int>(party)} // 0=user, 1=system
        });
    });

    // GET /api/modules/base?name=... - Module base address
    router.get("/api/modules/base", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto name = req.get_query("name");
        if (name.empty()) {
            return s_http_response::bad_request("Missing 'name' query parameter");
        }

        auto base = bridge.get_module_base(name);
        if (base == 0) {
            return s_http_response::not_found("Module not found: " + name);
        }

        return s_http_response::ok({
            {"name", name},
            {"base", format_utils::format_address(base)}
        });
    });

    // GET /api/modules/section?address= - Get section name at address
    router.get("/api/modules/section", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        char section[MAX_SECTION_SIZE * 5] = {};
        auto found = DbgFunctions()->SectionFromAddr(address, section);

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"found",   found},
            {"section", std::string(section)}
        });
    });

    // GET /api/modules/party?base= - Get module party (user/system)
    router.get("/api/modules/party", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto base_str = req.get_query("base");
        if (base_str.empty()) {
            return s_http_response::bad_request("Missing 'base' query parameter");
        }

        auto base = bridge.eval_expression(base_str);
        auto party = DbgFunctions()->ModGetParty(base);

        std::string party_str;
        switch (party) {
            case mod_user:   party_str = "user"; break;
            case mod_system: party_str = "system"; break;
            default:         party_str = "unknown"; break;
        }

        return s_http_response::ok({
            {"base",  format_utils::format_address(base)},
            {"party", party_str},
            {"party_id", static_cast<int>(party)}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/patch_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>

namespace handlers {

void register_patch_routes(c_http_router& router) {
    // GET /api/patches/list - List current patches
    router.get("/api/patches/list", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        // Use patchlist command to show patches
        bridge.exec_command("patchlist");

        return s_http_response::ok({
            {"message", "Patch list displayed in x64dbg log. Use the patches dialog for full patch management."}
        });
    });

    // POST /api/patches/apply - Apply byte patch
    router.post("/api/patches/apply", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address") || !body.contains("bytes")) {
            return s_http_response::bad_request("Missing 'address' and/or 'bytes' fields");
        }

        auto address = bridge.eval_expression(body["address"].get<std::string>());
        auto hex_str = body["bytes"].get<std::string>();
        auto bytes = format_utils::parse_hex_bytes(hex_str);

        if (bytes.empty()) {
            return s_http_response::bad_request("No valid bytes to patch");
        }

        // Read original bytes first
        auto original = bridge.read_memory(address, bytes.size());

        // Write the patch
        auto result = bridge.write_memory(address, bytes);
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        nlohmann::json data = {
            {"address",       format_utils::format_address(address)},
            {"bytes_patched", bytes.size()},
            {"new_bytes",     format_utils::format_bytes_hex(bytes.data(), bytes.size())}
        };

        if (original.has_value()) {
            data["original_bytes"] = format_utils::format_bytes_hex(original->data(), original->size());
        }

        return s_http_response::ok(data);
    });

    // POST /api/patches/restore - Restore original bytes
    router.post("/api/patches/restore", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address_str = body["address"].get<std::string>();

        // Use x64dbg's patch restore command
        auto cmd = "patchrestore " + address_str;
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"address", address_str},
            {"message", "Patch restore requested"}
        });
    });

    // POST /api/patches/export - Export patched module
    router.post("/api/patches/export", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        auto module_name = body.value("module", "");
        auto output_path = body.value("path", "");

        if (output_path.empty()) {
            return s_http_response::bad_request("Missing 'path' field for output file");
        }

        auto cmd = "savedata \"" + output_path + "\"";
        if (!module_name.empty()) {
            auto base = bridge.get_module_base(module_name);
            auto size = bridge.eval_expression("mod.size(" + module_name + ")");
            cmd = "savedata \"" + output_path + "\", " + format_utils::format_address(base)
                + ", " + format_utils::format_hex(size);
        }

        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"module", module_name},
            {"path",   output_path},
            {"message", "Module export initiated"}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/process_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"

namespace handlers {

void register_process_routes(c_http_router& router) {
    // GET /api/process/info - Extended process info
    // Note: basic /api/process/info exists in plugin_main.cpp,
    // this route is registered with a different path
    router.get("/api/process/details", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto pid = bridge.eval_expression("$pid");
        auto peb = DbgGetPebAddress(static_cast<DWORD>(pid));
        auto process_handle = DbgGetProcessHandle();
        auto entry = bridge.eval_expression("mod.entry(0)");

        return s_http_response::ok({
            {"pid",              pid},
            {"peb_address",      format_utils::format_address(peb)},
            {"process_handle",   format_utils::format_address(reinterpret_cast<duint>(process_handle))},
            {"entry_point",      format_utils::format_address(entry)},
            {"debugger_state",   bridge.get_state_string()},
            {"is_elevated",      DbgFunctions()->IsProcessElevated()},
            {"dep_enabled",      DbgFunctions()->IsDepEnabled()}
        });
    });

    // GET /api/process/cmdline - Get command line
    router.get("/api/process/cmdline", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        // First call to get required size
        size_t size = 0;
        DbgFunctions()->GetCmdline(nullptr, &size);

        if (size == 0) {
            return s_http_response::ok({{"cmdline", ""}});
        }

        std::vector<char> buffer(size + 1, 0);
        DbgFunctions()->GetCmdline(buffer.data(), &size);

        return s_http_response::ok({
            {"cmdline", std::string(buffer.data())}
        });
    });

    // POST /api/process/set_cmdline - Set command line
    router.post("/api/process/set_cmdline", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("cmdline")) {
            return s_http_response::bad_request("Missing 'cmdline' field");
        }

        auto cmdline = body["cmdline"].get<std::string>();
        auto success = DbgFunctions()->SetCmdline(cmdline.c_str());

        return s_http_response::ok({
            {"success", success},
            {"cmdline", cmdline}
        });
    });

    // GET /api/process/elevated - Is process elevated
    router.get("/api/process/elevated", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        return s_http_response::ok({
            {"elevated", DbgFunctions()->IsProcessElevated()}
        });
    });

    // GET /api/process/dbversion - Debugger version
    router.get("/api/process/dbversion", [](const s_http_request&) -> s_http_response {
        auto version = BridgeGetDbgVersion();

        return s_http_response::ok({
            {"version", version}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/register_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"

namespace handlers {

void register_register_routes(c_http_router& router) {
    // GET /api/registers/all - All register values
    router.get("/api/registers/all", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto dump_result = bridge.get_register_dump();
        if (!dump_result.has_value()) {
            return s_http_response::internal_error(dump_result.error());
        }

        const auto& ctx = dump_result->regcontext;
        nlohmann::json regs;

#ifdef _WIN64
        regs["rax"] = format_utils::format_address(ctx.cax);
        regs["rcx"] = format_utils::format_address(ctx.ccx);
        regs["rdx"] = format_utils::format_address(ctx.cdx);
        regs["rbx"] = format_utils::format_address(ctx.cbx);
        regs["rsp"] = format_utils::format_address(ctx.csp);
        regs["rbp"] = format_utils::format_address(ctx.cbp);
        regs["rsi"] = format_utils::format_address(ctx.csi);
        regs["rdi"] = format_utils::format_address(ctx.cdi);
        regs["r8"]  = format_utils::format_address(ctx.r8);
        regs["r9"]  = format_utils::format_address(ctx.r9);
        regs["r10"] = format_utils::format_address(ctx.r10);
        regs["r11"] = format_utils::format_address(ctx.r11);
        regs["r12"] = format_utils::format_address(ctx.r12);
        regs["r13"] = format_utils::format_address(ctx.r13);
        regs["r14"] = format_utils::format_address(ctx.r14);
        regs["r15"] = format_utils::format_address(ctx.r15);
        regs["rip"] = format_utils::format_address(ctx.cip);
#else
        regs["eax"] = format_utils::format_address(ctx.cax);
        regs["ecx"] = format_utils::format_address(ctx.ccx);
        regs["edx"] = format_utils::format_address(ctx.cdx);
        regs["ebx"] = format_utils::format_address(ctx.cbx);
        regs["esp"] = format_utils::format_address(ctx.csp);
        regs["ebp"] = format_utils::format_address(ctx.cbp);
        regs["esi"] = format_utils::format_address(ctx.csi);
        regs["edi"] = format_utils::format_address(ctx.cdi);
        regs["eip"] = format_utils::format_address(ctx.cip);
#endif

        regs["eflags"] = format_utils::format_address(ctx.eflags);

        // Segment registers
        regs["cs"] = ctx.cs;
        regs["ds"] = ctx.ds;
        regs["es"] = ctx.es;
        regs["fs"] = ctx.fs;
        regs["gs"] = ctx.gs;
        regs["ss"] = ctx.ss;

        // Debug registers
        regs["dr0"] = format_utils::format_address(ctx.dr0);
        regs["dr1"] = format_utils::format_address(ctx.dr1);
        regs["dr2"] = format_utils::format_address(ctx.dr2);
        regs["dr3"] = format_utils::format_address(ctx.dr3);
        regs["dr6"] = format_utils::format_address(ctx.dr6);
        regs["dr7"] = format_utils::format_address(ctx.dr7);

        return s_http_response::ok(regs);
    });

    // GET /api/registers/get?name=rax - Single register
    router.get("/api/registers/get", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto name = req.get_query("name");
        if (name.empty()) {
            return s_http_response::bad_request("Missing 'name' query parameter");
        }

        if (!bridge.is_valid_expression(name)) {
            return s_http_response::bad_request("Invalid register name: " + name);
        }

        auto value = bridge.eval_expression(name);
        return s_http_response::ok({
            {"name",  name},
            {"value", format_utils::format_address(value)}
        });
    });

    // POST /api/registers/set - Set register value
    router.post("/api/registers/set", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("name") || !body.contains("value")) {
            return s_http_response::bad_request("Missing 'name' and/or 'value' fields");
        }

        auto name = body["name"].get<std::string>();
        auto value = body["value"].get<std::string>();

        auto cmd = "mov " + name + ", " + value;
        if (!bridge.exec_command(cmd)) {
            return s_http_response::internal_error("Failed to set register " + name);
        }

        auto new_value = bridge.eval_expression(name);
        return s_http_response::ok({
            {"name",  name},
            {"value", format_utils::format_address(new_value)}
        });
    });

    // GET /api/registers/flags - EFLAGS decoded
    router.get("/api/registers/flags", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto dump_result = bridge.get_register_dump();
        if (!dump_result.has_value()) {
            return s_http_response::internal_error(dump_result.error());
        }

        const auto& flags = dump_result->flags;
        return s_http_response::ok({
            {"CF", flags.c},
            {"PF", flags.p},
            {"AF", flags.a},
            {"ZF", flags.z},
            {"SF", flags.s},
            {"TF", flags.t},
            {"IF", flags.i},
            {"DF", flags.d},
            {"OF", flags.o},
            {"eflags", format_utils::format_address(dump_result->regcontext.eflags)}
        });
    });

    // GET /api/registers/avx512 - Get AVX-512 register dump
    router.get("/api/registers/avx512", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        REGDUMP_AVX512 avx512{};
        if (!DbgGetRegDumpEx(&avx512, sizeof(REGDUMP_AVX512))) {
            return s_http_response::internal_error("Failed to get AVX-512 register dump (may not be supported)");
        }

        // Return the standard REGDUMP portion plus AVX-512 indicator
        const auto& ctx = avx512.regcontext;
        nlohmann::json data;

#ifdef _WIN64
        data["rax"] = format_utils::format_address(ctx.cax);
        data["rcx"] = format_utils::format_address(ctx.ccx);
        data["rdx"] = format_utils::format_address(ctx.cdx);
        data["rbx"] = format_utils::format_address(ctx.cbx);
        data["rsp"] = format_utils::format_address(ctx.csp);
        data["rbp"] = format_utils::format_address(ctx.cbp);
        data["rsi"] = format_utils::format_address(ctx.csi);
        data["rdi"] = format_utils::format_address(ctx.cdi);
        data["rip"] = format_utils::format_address(ctx.cip);
#else
        data["eax"] = format_utils::format_address(ctx.cax);
        data["ecx"] = format_utils::format_address(ctx.ccx);
        data["edx"] = format_utils::format_address(ctx.cdx);
        data["ebx"] = format_utils::format_address(ctx.cbx);
        data["esp"] = format_utils::format_address(ctx.csp);
        data["ebp"] = format_utils::format_address(ctx.cbp);
        data["esi"] = format_utils::format_address(ctx.csi);
        data["edi"] = format_utils::format_address(ctx.cdi);
        data["eip"] = format_utils::format_address(ctx.cip);
#endif

        data["avx512_supported"] = true;
        data["eflags"] = format_utils::format_address(ctx.eflags);

        return s_http_response::ok(data);
    });
}

} // namespace handlers

```

`plugin/src/handlers/search_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"

namespace handlers {

// Parse a hex byte pattern string (e.g., "C4 CB 75 5B" or "C4CB755B" or "C4 ?? 75 5B")
// Returns pairs of (byte_value, is_wildcard).
// Returns empty vector if the pattern is malformed.
struct pattern_byte {
    uint8_t value = 0;
    bool    is_wildcard = false;
};

static std::vector<pattern_byte> parse_byte_pattern(const std::string& pattern_str) {
    // Strip all spaces to normalize
    std::string cleaned;
    cleaned.reserve(pattern_str.size());
    for (char c : pattern_str) {
        if (c != ' ') cleaned += c;
    }

    if (cleaned.empty() || (cleaned.size() % 2) != 0) {
        return {};
    }

    std::vector<pattern_byte> result;
    result.reserve(cleaned.size() / 2);

    for (size_t i = 0; i + 1 < cleaned.size(); i += 2) {
        char hi = cleaned[i];
        char lo = cleaned[i + 1];

        bool hi_wild = (hi == '?' || hi == '*');
        bool lo_wild = (lo == '?' || lo == '*');

        if (hi_wild || lo_wild) {
            result.push_back({0, true});
        } else {
            // Validate hex chars
            auto is_hex = [](char c) {
                return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
            };
            if (!is_hex(hi) || !is_hex(lo)) {
                return {};  // Invalid pattern
            }
            char hex[3] = {hi, lo, '\0'};
            result.push_back({static_cast<uint8_t>(std::stoul(hex, nullptr, 16)), false});
        }
    }

    return result;
}

// Scan a memory buffer for a byte pattern starting at any offset.
// Returns all offsets (relative to buffer start) where the pattern matches.
static std::vector<size_t> scan_buffer(
    const uint8_t* buf, size_t buf_size,
    const std::vector<pattern_byte>& pattern
) {
    std::vector<size_t> hits;
    if (pattern.empty() || buf_size < pattern.size()) return hits;

    const size_t pat_len = pattern.size();
    const size_t search_end = buf_size - pat_len + 1;

    for (size_t i = 0; i < search_end; ++i) {
        bool match = true;
        for (size_t j = 0; j < pat_len; ++j) {
            if (!pattern[j].is_wildcard && buf[i + j] != pattern[j].value) {
                match = false;
                break;
            }
        }
        if (match) {
            hits.push_back(i);
        }
    }

    return hits;
}

void register_search_routes(c_http_router& router) {
    // POST /api/search/pattern - AOB/byte pattern scan
    // Returns ALL matches (up to max_results). Supports wildcard bytes (??)
    router.post("/api/search/pattern", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("pattern")) {
            return s_http_response::bad_request("Missing 'pattern' field");
        }

        auto pattern_str = body["pattern"].get<std::string>();
        auto pattern = parse_byte_pattern(pattern_str);

        if (pattern.empty()) {
            return s_http_response::bad_request(
                "Invalid pattern '" + pattern_str + "'. Use hex bytes (e.g. 'C4 CB 75 5B' or 'C4CB755B'), wildcards as '?" "?'");
        }

        auto max_results = body.value("max_results", 1000);
        if (max_results < 1) max_results = 1;
        if (max_results > 10000) max_results = 10000;

        // Optional: restrict to a specific memory range
        std::string address_str = body.value("address", "");
        std::string size_str    = body.value("size", "");

        auto matches = nlohmann::json::array();

        if (!address_str.empty() && !size_str.empty()) {
            // Scan a specific range
            auto base = bridge.eval_expression(address_str);
            auto range_size = static_cast<size_t>(bridge.eval_expression(size_str));

            if (range_size == 0 || range_size > 256 * 1024 * 1024) {
                return s_http_response::bad_request("Invalid size (must be 1 byte - 256MB)");
            }

            auto mem = bridge.read_memory(base, range_size);
            if (mem.has_value()) {
                auto hits = scan_buffer(mem.value().data(), mem.value().size(), pattern);
                for (auto offset : hits) {
                    if (static_cast<int>(matches.size()) >= max_results) break;
                    auto match_addr = base + static_cast<duint>(offset);
                    matches.push_back(format_utils::format_address(match_addr));
                }
            }
        } else {
            // Scan all mapped memory pages (read + execute pages)
            MEMMAP memmap{};
            if (!DbgMemMap(&memmap)) {
                return s_http_response::internal_error("Failed to get memory map");
            }

            // Read each page and scan it (with overlap to catch cross-page matches)
            const size_t overlap = pattern.size() - 1;
            std::vector<uint8_t> prev_tail;

            for (int i = 0; i < memmap.count && static_cast<int>(matches.size()) < max_results; ++i) {
                const auto& page = memmap.page[i];
                auto page_base = reinterpret_cast<duint>(page.mbi.BaseAddress);
                auto page_size = static_cast<size_t>(page.mbi.RegionSize);

                // Skip non-committed or non-readable pages
                if (page.mbi.State != MEM_COMMIT) {
                    prev_tail.clear();
                    continue;
                }
                if (page.mbi.Protect == PAGE_NOACCESS || page.mbi.Protect == 0) {
                    prev_tail.clear();
                    continue;
                }

                // Read the page (limit single reads to 64MB)
                const size_t read_size = (page_size > 64 * 1024 * 1024) ? 64 * 1024 * 1024 : page_size;
                auto mem = bridge.read_memory(page_base, read_size);
                if (!mem.has_value()) {
                    prev_tail.clear();
                    continue;
                }

                const auto& buf = mem.value();

                // Build combined buffer: overlap from previous page + current page
                // This catches patterns that straddle page boundaries
                std::vector<uint8_t> combined;
                if (!prev_tail.empty()) {
                    combined.reserve(prev_tail.size() + buf.size());
                    combined.insert(combined.end(), prev_tail.begin(), prev_tail.end());
                    combined.insert(combined.end(), buf.begin(), buf.end());
                    auto base_addr = page_base - static_cast<duint>(prev_tail.size());

                    auto hits = scan_buffer(combined.data(), combined.size(), pattern);
                    for (auto offset : hits) {
                        if (static_cast<int>(matches.size()) >= max_results) break;
                        matches.push_back(format_utils::format_address(base_addr + static_cast<duint>(offset)));
                    }
                } else {
                    auto hits = scan_buffer(buf.data(), buf.size(), pattern);
                    for (auto offset : hits) {
                        if (static_cast<int>(matches.size()) >= max_results) break;
                        matches.push_back(format_utils::format_address(page_base + static_cast<duint>(offset)));
                    }
                }

                // Save tail for next iteration (cross-page match detection)
                if (buf.size() >= overlap && overlap > 0) {
                    prev_tail.assign(buf.end() - static_cast<ptrdiff_t>(overlap), buf.end());
                } else {
                    prev_tail = buf;
                }
            }

            if (memmap.page) {
                BridgeFree(memmap.page);
            }
        }

        bool found = !matches.empty();
        nlohmann::json data = {
            {"pattern",      pattern_str},
            {"found",        found},
            {"count",        matches.size()},
            {"matches",      matches},
        };

        // Backwards-compat: first_match field
        if (found) {
            data["first_match"] = matches[0];
        } else {
            data["first_match"] = "";
        }

        return s_http_response::ok(data);
    });

    // POST /api/search/string - String search
    router.post("/api/search/string", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("text")) {
            return s_http_response::bad_request("Missing 'text' field");
        }

        auto text = body["text"].get<std::string>();
        auto module_name = body.value("module", "");
        auto encoding = body.value("encoding", "utf8"); // utf8, ascii, unicode

        // Convert string to byte pattern
        std::string byte_pattern;
        if (encoding == "unicode" || encoding == "utf16") {
            // UTF-16LE encoding
            for (char c : text) {
                char buf[8];
                snprintf(buf, sizeof(buf), "%02X 00 ", static_cast<unsigned char>(c));
                byte_pattern += buf;
            }
        } else {
            // ASCII / UTF-8
            for (char c : text) {
                char buf[4];
                snprintf(buf, sizeof(buf), "%02X ", static_cast<unsigned char>(c));
                byte_pattern += buf;
            }
        }

        // Trim trailing space
        if (!byte_pattern.empty() && byte_pattern.back() == ' ') {
            byte_pattern.pop_back();
        }

        auto pattern = parse_byte_pattern(byte_pattern);

        // Determine search range
        duint base = 0;
        size_t range = 0;

        if (!module_name.empty()) {
            base = bridge.get_module_base(module_name);
            if (base == 0) {
                return s_http_response::not_found("Module not found: " + module_name);
            }
            range = static_cast<size_t>(bridge.eval_expression("mod.size(" + module_name + ")"));
        }

        auto matches = nlohmann::json::array();

        if (base != 0 && range != 0) {
            auto mem = bridge.read_memory(base, range);
            if (mem.has_value()) {
                auto hits = scan_buffer(mem.value().data(), mem.value().size(), pattern);
                for (auto offset : hits) {
                    if (static_cast<int>(matches.size()) >= 1000) break;
                    matches.push_back(format_utils::format_address(base + static_cast<duint>(offset)));
                }
            }
        } else {
            // Full memory scan via pattern endpoint logic (simplified: use findall command)
            std::string cmd = "findall 0, " + byte_pattern;
            bridge.exec_command(cmd);
            auto result_addr = bridge.eval_expression("$result");
            if (result_addr != 0) {
                matches.push_back(format_utils::format_address(result_addr));
            }
        }

        return s_http_response::ok({
            {"text",        text},
            {"encoding",    encoding},
            {"pattern",     byte_pattern},
            {"found",       !matches.empty()},
            {"count",       matches.size()},
            {"matches",     matches},
            {"first_match", !matches.empty() ? matches[0] : ""}
        });
    });

    // GET /api/search/string_at?address=&encoding=auto&max_length=256 - Get string at address
    // encoding: auto (default), ascii, unicode
    router.get("/api/search/string_at", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto encoding = req.get_query("encoding", "auto");
        auto max_length_str = req.get_query("max_length", "256");
        auto max_length = static_cast<size_t>(std::stoull(max_length_str));
        if (max_length < 1) max_length = 1;
        if (max_length > 4096) max_length = 4096;

        auto address = bridge.eval_expression(address_str);

        nlohmann::json data = {
            {"address",  format_utils::format_address(address)},
            {"encoding", encoding}
        };

        // Always read raw bytes for transparency
        auto raw_mem = bridge.read_memory(address, max_length);
        if (raw_mem.has_value()) {
            const auto& raw = raw_mem.value();
            data["raw_hex"] = format_utils::format_bytes_hex(raw.data(), raw.size());

            if (encoding == "unicode" || encoding == "utf16") {
                // Read as UTF-16LE
                std::string utf16_str;
                for (size_t i = 0; i + 1 < raw.size(); i += 2) {
                    uint16_t wc = raw[i] | (static_cast<uint16_t>(raw[i + 1]) << 8);
                    if (wc == 0) break;
                    // Simple ASCII-range conversion
                    if (wc < 0x80) {
                        utf16_str += static_cast<char>(wc);
                    } else {
                        utf16_str += '?';  // Non-ASCII wide char
                    }
                }
                data["text"] = utf16_str;
                data["found"] = !utf16_str.empty();
            } else if (encoding == "ascii") {
                // Read as null-terminated ASCII
                std::string ascii_str;
                for (size_t i = 0; i < raw.size(); ++i) {
                    if (raw[i] == 0) break;
                    ascii_str += static_cast<char>(raw[i]);
                }
                data["text"] = ascii_str;
                data["found"] = !ascii_str.empty();
            } else {
                // Auto-detect: use DbgGetStringAt first, then cross-check
                char dbg_text[MAX_STRING_SIZE] = {};
                auto found = DbgGetStringAt(address, dbg_text);
                data["text"] = std::string(dbg_text);
                data["found"] = found;

                // Also attempt raw ASCII read for comparison
                std::string raw_ascii;
                for (size_t i = 0; i < raw.size(); ++i) {
                    if (raw[i] == 0) break;
                    uint8_t b = raw[i];
                    if (b >= 0x20 && b < 0x7F) {
                        raw_ascii += static_cast<char>(b);
                    } else {
                        break;  // Stop at non-printable
                    }
                }
                if (!raw_ascii.empty()) {
                    data["raw_ascii"] = raw_ascii;
                }
            }
        } else {
            // Fallback to DbgGetStringAt only
            char text[MAX_STRING_SIZE] = {};
            auto found = DbgGetStringAt(address, text);
            data["found"] = found;
            data["text"]  = std::string(text);
        }

        return s_http_response::ok(data);
    });

    // POST /api/search/auto_complete - Symbol auto-complete
    router.post("/api/search/auto_complete", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("search")) {
            return s_http_response::bad_request("Missing 'search' field");
        }

        auto search = body["search"].get<std::string>();
        auto max_results = body.value("max_results", 20);

        // Allocate buffer for results
        std::vector<char*> buffer(max_results, nullptr);
        auto count = DbgFunctions()->SymAutoComplete(search.c_str(), buffer.data(), max_results);

        auto results = nlohmann::json::array();
        for (int i = 0; i < count && i < max_results; ++i) {
            if (buffer[i]) {
                results.push_back(std::string(buffer[i]));
                BridgeFree(buffer[i]);
            }
        }

        return s_http_response::ok({
            {"search",  search},
            {"results", results},
            {"count",   results.size()}
        });
    });

    // GET /api/search/encode_type?address= - Get encode type at address
    router.get("/api/search/encode_type", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto size_str = req.get_query("size", "1");
        auto address = bridge.eval_expression(address_str);
        auto size = bridge.eval_expression(size_str);

        auto encode_type = DbgGetEncodeTypeAt(address, size);

        std::string type_str;
        switch (encode_type) {
            case enc_unknown: type_str = "unknown"; break;
            case enc_byte:    type_str = "byte"; break;
            case enc_word:    type_str = "word"; break;
            case enc_dword:   type_str = "dword"; break;
            case enc_fword:   type_str = "fword"; break;
            case enc_qword:   type_str = "qword"; break;
            case enc_tbyte:   type_str = "tbyte"; break;
            case enc_oword:   type_str = "oword"; break;
            case enc_mmword:  type_str = "mmword"; break;
            case enc_xmmword: type_str = "xmmword"; break;
            case enc_ymmword: type_str = "ymmword"; break;
            case enc_real4:   type_str = "real4"; break;
            case enc_real8:   type_str = "real8"; break;
            case enc_real10:  type_str = "real10"; break;
            case enc_ascii:   type_str = "ascii"; break;
            case enc_unicode: type_str = "unicode"; break;
            case enc_code:    type_str = "code"; break;
            case enc_junk:    type_str = "junk"; break;
            case enc_middle:  type_str = "middle"; break;
            default:          type_str = "unknown"; break;
        }

        return s_http_response::ok({
            {"address",     format_utils::format_address(address)},
            {"encode_type", type_str},
            {"type_id",     static_cast<int>(encode_type)}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/stack_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"

namespace handlers {

void register_stack_routes(c_http_router& router) {
    // GET /api/stack/trace?max_depth=50 - Call stack
    router.get("/api/stack/trace", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        DBGCALLSTACK callstack{};
        DbgFunctions()->GetCallStackEx(&callstack, false);

        auto frames = nlohmann::json::array();
        for (int i = 0; i < callstack.total; ++i) {
            const auto& entry = callstack.entries[i];
            auto label = bridge.get_label_at(entry.to);
            auto module_name = bridge.get_module_at(entry.to);

            frames.push_back({
                {"index",   i},
                {"address", format_utils::format_address(entry.addr)},
                {"from",    format_utils::format_address(entry.from)},
                {"to",      format_utils::format_address(entry.to)},
                {"label",   label},
                {"module",  module_name},
                {"comment", entry.comment}
            });
        }

        if (callstack.entries) {
            BridgeFree(callstack.entries);
        }

        return s_http_response::ok({
            {"frames", frames},
            {"count",  frames.size()}
        });
    });

    // GET /api/stack/read?address=0x...&size=N - Read stack memory
    router.get("/api/stack/read", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address", "csp");
        auto size_str = req.get_query("size", "256");

        auto address = bridge.eval_expression(address_str);
        auto size = static_cast<size_t>(std::stoull(size_str));

        auto result = bridge.read_memory(address, size);
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        const auto& bytes = result.value();

        // Build pointer-sized entries
        auto entries = nlohmann::json::array();
        auto ptr_size = sizeof(duint);
        for (size_t offset = 0; offset + ptr_size <= bytes.size(); offset += ptr_size) {
            duint value = 0;
            memcpy(&value, bytes.data() + offset, ptr_size);

            auto entry_addr = address + offset;
            auto label = bridge.get_label_at(value);
            auto module_name = bridge.get_module_at(value);

            entries.push_back({
                {"address", format_utils::format_address(entry_addr)},
                {"value",   format_utils::format_address(value)},
                {"label",   label},
                {"module",  module_name}
            });
        }

        return s_http_response::ok({
            {"base",    format_utils::format_address(address)},
            {"size",    bytes.size()},
            {"entries", entries}
        });
    });

    // GET /api/stack/pointers - RSP/RBP values
    router.get("/api/stack/pointers", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto csp = bridge.eval_expression("csp");
        auto cbp = bridge.eval_expression("cbp");

        return s_http_response::ok({
#ifdef _WIN64
            {"rsp", format_utils::format_address(csp)},
            {"rbp", format_utils::format_address(cbp)},
#else
            {"esp", format_utils::format_address(csp)},
            {"ebp", format_utils::format_address(cbp)},
#endif
        });
    });

    // GET /api/stack/comment?address= - Get stack comment
    router.get("/api/stack/comment", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        STACK_COMMENT comment{};
        auto found = DbgStackCommentGet(address, &comment);

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"found",   found},
            {"comment", std::string(comment.comment)},
            {"color",   std::string(comment.color)}
        });
    });

    // GET /api/stack/callstack_thread?handle= - Get call stack for specific thread
    router.get("/api/stack/callstack_thread", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto handle_str = req.get_query("handle");
        if (handle_str.empty()) {
            return s_http_response::bad_request("Missing 'handle' query parameter");
        }

        auto handle = bridge.eval_expression(handle_str);

        DBGCALLSTACK callstack{};
        DbgFunctions()->GetCallStackByThread(reinterpret_cast<HANDLE>(handle), &callstack);

        auto frames = nlohmann::json::array();
        for (int i = 0; i < callstack.total; ++i) {
            const auto& entry = callstack.entries[i];
            auto label = bridge.get_label_at(entry.to);
            auto module_name = bridge.get_module_at(entry.to);

            frames.push_back({
                {"index",   i},
                {"address", format_utils::format_address(entry.addr)},
                {"from",    format_utils::format_address(entry.from)},
                {"to",      format_utils::format_address(entry.to)},
                {"label",   label},
                {"module",  module_name},
                {"comment", entry.comment}
            });
        }

        if (callstack.entries) {
            BridgeFree(callstack.entries);
        }

        return s_http_response::ok({
            {"frames", frames},
            {"count",  frames.size()}
        });
    });

    // GET /api/stack/return_address - Get return address from stack
    router.get("/api/stack/return_address", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        // Read the value at [RSP/ESP] which is typically the return address
        auto sp = bridge.eval_expression("csp");
        auto mem = bridge.read_memory(sp, sizeof(duint));
        if (!mem.has_value()) {
            return s_http_response::internal_error("Failed to read stack pointer");
        }

        duint return_addr = 0;
        memcpy(&return_addr, mem.value().data(), sizeof(duint));

        auto label = bridge.get_label_at(return_addr);
        auto module_name = bridge.get_module_at(return_addr);

        return s_http_response::ok({
            {"stack_pointer",  format_utils::format_address(sp)},
            {"return_address", format_utils::format_address(return_addr)},
            {"label",          label},
            {"module",         module_name}
        });
    });

    // GET /api/stack/seh_chain - SEH handler chain
    router.get("/api/stack/seh_chain", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        DBGSEHCHAIN seh_chain{};
        DbgFunctions()->GetSEHChain(&seh_chain);

        auto chain = nlohmann::json::array();
        for (duint i = 0; i < seh_chain.total; ++i) {
            const auto& record = seh_chain.records[i];
            auto label = bridge.get_label_at(record.handler);
            auto module_name = bridge.get_module_at(record.handler);

            chain.push_back({
                {"address", format_utils::format_address(record.addr)},
                {"handler", format_utils::format_address(record.handler)},
                {"label",   label},
                {"module",  module_name}
            });
        }

        if (seh_chain.records) {
            BridgeFree(seh_chain.records);
        }

        return s_http_response::ok({
            {"chain", chain},
            {"count", chain.size()}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/symbol_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>

namespace handlers {

void register_symbol_routes(c_http_router& router) {
    // GET /api/symbols/resolve?name=... - Name to address
    router.get("/api/symbols/resolve", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto name = req.get_query("name");
        if (name.empty()) {
            return s_http_response::bad_request("Missing 'name' query parameter");
        }

        if (!bridge.is_valid_expression(name)) {
            return s_http_response::not_found("Cannot resolve: " + name);
        }

        auto address = bridge.eval_expression(name);
        if (address == 0) {
            return s_http_response::not_found("Symbol not found: " + name);
        }

        return s_http_response::ok({
            {"name",    name},
            {"address", format_utils::format_address(address)}
        });
    });

    // GET /api/symbols/at?address=0x... - Address to name
    router.get("/api/symbols/at", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto label = bridge.get_label_at(address);
        auto module_name = bridge.get_module_at(address);

        return s_http_response::ok({
            {"address", format_utils::format_address(address)},
            {"label",   label},
            {"module",  module_name}
        });
    });

    // GET /api/symbols/search?pattern=... - Search symbols by pattern
    router.get("/api/symbols/search", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto pattern = req.get_query("pattern");
        auto module = req.get_query("module");
        if (pattern.empty()) {
            return s_http_response::bad_request("Missing 'pattern' query parameter");
        }

        // Use x64dbg's symfind command via expression evaluation
        // Build a filter expression
        auto search_expr = module.empty() ? pattern : module + "." + pattern;

        // Use the command to search and retrieve through eval
        auto cmd = "symfind " + search_expr;
        bridge.exec_command(cmd);

        // Since symfind outputs to log, we return what we can resolve
        return s_http_response::ok({
            {"pattern",  pattern},
            {"module",   module},
            {"message",  "Symbol search initiated. Check x64dbg symbol view for results."}
        });
    });

    // GET /api/symbols/list?module=... - List module symbols
    router.get("/api/symbols/list", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto module = req.get_query("module");
        if (module.empty()) {
            return s_http_response::bad_request("Missing 'module' query parameter");
        }

        auto base = bridge.get_module_base(module);
        if (base == 0) {
            return s_http_response::not_found("Module not found: " + module);
        }

        // Trigger symbol loading for the module
        bridge.exec_command("symload " + module);

        return s_http_response::ok({
            {"module",  module},
            {"base",    format_utils::format_address(base)},
            {"message", "Symbols loaded. Use symbol search to find specific symbols."}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/thread_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"

namespace handlers {

void register_thread_routes(c_http_router& router) {
    // GET /api/threads/list - List all threads
    router.get("/api/threads/list", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto result = bridge.get_thread_list();
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        return s_http_response::ok(result.value());
    });

    // GET /api/threads/current - Current thread info
    router.get("/api/threads/current", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto result = bridge.get_thread_list();
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        auto current_idx = result.value()["current_thread"].get<int>();
        const auto& threads = result.value()["threads"];

        for (const auto& t : threads) {
            if (t["number"].get<int>() == current_idx) {
                return s_http_response::ok(t);
            }
        }

        // Fallback: return first thread
        if (!threads.empty()) {
            return s_http_response::ok(threads[0]);
        }

        return s_http_response::not_found("No current thread");
    });

    // GET /api/threads/get?id=N - Specific thread by ID
    router.get("/api/threads/get", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto id_str = req.get_query("id");
        if (id_str.empty()) {
            return s_http_response::bad_request("Missing 'id' query parameter");
        }

        auto tid = std::stoul(id_str);
        auto result = bridge.get_thread_list();
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        for (const auto& t : result.value()["threads"]) {
            if (t["id"].get<DWORD>() == tid) {
                return s_http_response::ok(t);
            }
        }

        return s_http_response::not_found("Thread not found: " + id_str);
    });

    // POST /api/threads/switch - Switch active thread
    router.post("/api/threads/switch", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("id")) {
            return s_http_response::bad_request("Missing 'id' field");
        }

        auto tid = body["id"].get<DWORD>();
        auto cmd = "switchthread " + std::to_string(tid);
        bridge.exec_command(cmd);

        return s_http_response::ok({
            {"switched_to", tid},
            {"message",     "Switched to thread " + std::to_string(tid)}
        });
    });

    // POST /api/threads/suspend - Suspend thread
    router.post("/api/threads/suspend", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("id")) {
            return s_http_response::bad_request("Missing 'id' field");
        }

        auto tid = body["id"].get<DWORD>();
        auto cmd = "suspendthread " + std::to_string(tid);
        bridge.exec_command(cmd);

        return s_http_response::ok({{"id", tid}, {"suspended", true}});
    });

    // POST /api/threads/resume - Resume thread
    router.post("/api/threads/resume", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("id")) {
            return s_http_response::bad_request("Missing 'id' field");
        }

        auto tid = body["id"].get<DWORD>();
        auto cmd = "resumethread " + std::to_string(tid);
        bridge.exec_command(cmd);

        return s_http_response::ok({{"id", tid}, {"resumed", true}});
    });

    // GET /api/threads/count - Thread count
    router.get("/api/threads/count", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto result = bridge.get_thread_list();
        if (!result.has_value()) {
            return s_http_response::internal_error(result.error());
        }

        return s_http_response::ok({{"count", result.value()["count"]}});
    });

    // GET /api/threads/teb?tid= - Get TEB address for thread
    router.get("/api/threads/teb", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto tid_str = req.get_query("tid");
        if (tid_str.empty()) {
            return s_http_response::bad_request("Missing 'tid' query parameter");
        }

        auto tid = static_cast<DWORD>(std::stoul(tid_str));
        auto teb = DbgGetTebAddress(tid);

        return s_http_response::ok({
            {"tid", tid},
            {"teb", format_utils::format_address(teb)},
            {"found", teb != 0}
        });
    });

    // GET /api/threads/name?tid= - Get thread name
    router.get("/api/threads/name", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto tid_str = req.get_query("tid");
        if (tid_str.empty()) {
            return s_http_response::bad_request("Missing 'tid' query parameter");
        }

        auto tid = static_cast<DWORD>(std::stoul(tid_str));
        char name[MAX_THREAD_NAME_SIZE] = {};
        auto found = DbgFunctions()->ThreadGetName(tid, name);

        return s_http_response::ok({
            {"tid", tid},
            {"name", std::string(name)},
            {"found", found}
        });
    });
}

} // namespace handlers

```

`plugin/src/handlers/tracing_handler.cpp`:

```cpp
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"

#include <nlohmann/json.hpp>
#include "bridgemain.h"
#include "_dbgfunctions.h"

namespace handlers {

void register_tracing_routes(c_http_router& router) {
    // POST /api/trace/into - Trace into (conditional)
    router.post("/api/trace/into", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        auto condition = body.value("condition", "");
        auto max_steps = body.value("max_steps", "");
        auto log_text = body.value("log_text", "");

        std::string cmd = "TraceIntoConditional";
        if (!condition.empty()) {
            cmd += " " + condition;
        }
        if (!max_steps.empty()) {
            cmd += ", " + max_steps;
        }
        if (!log_text.empty()) {
            cmd += ", " + log_text;
        }

        auto success = bridge.exec_command_async(cmd);

        return s_http_response::ok({
            {"success", success},
            {"command", cmd},
            {"message", "Trace into started (async)"}
        });
    });

    // POST /api/trace/over - Trace over (conditional)
    router.post("/api/trace/over", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        auto condition = body.value("condition", "");
        auto max_steps = body.value("max_steps", "");
        auto log_text = body.value("log_text", "");

        std::string cmd = "TraceOverConditional";
        if (!condition.empty()) {
            cmd += " " + condition;
        }
        if (!max_steps.empty()) {
            cmd += ", " + max_steps;
        }
        if (!log_text.empty()) {
            cmd += ", " + log_text;
        }

        auto success = bridge.exec_command_async(cmd);

        return s_http_response::ok({
            {"success", success},
            {"command", cmd},
            {"message", "Trace over started (async)"}
        });
    });

    // POST /api/trace/run - Run to user code (RunToParty 0)
    router.post("/api/trace/run", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        auto party = body.value("party", "0"); // 0=user, 1=system

        auto cmd = "RunToParty " + party;
        auto success = bridge.exec_command_async(cmd);

        return s_http_response::ok({
            {"success", success},
            {"command", cmd},
            {"message", "Run to party started (async)"}
        });
    });

    // POST /api/trace/stop - Stop trace recording
    router.post("/api/trace/stop", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto success = bridge.exec_command("StopRunTrace");

        return s_http_response::ok({
            {"success", success},
            {"message", "Trace stopped"}
        });
    });

    // GET /api/trace/record/hitcount?address= - Get trace record hit count
    router.get("/api/trace/record/hitcount", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto hit_count = DbgFunctions()->GetTraceRecordHitCount(address);

        return s_http_response::ok({
            {"address",   format_utils::format_address(address)},
            {"hit_count", hit_count}
        });
    });

    // GET /api/trace/record/type?address= - Get trace record byte type
    router.get("/api/trace/record/type", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto address_str = req.get_query("address");
        if (address_str.empty()) {
            return s_http_response::bad_request("Missing 'address' query parameter");
        }

        auto address = bridge.eval_expression(address_str);
        auto byte_type = DbgFunctions()->GetTraceRecordByteType(address);

        std::string type_str;
        switch (byte_type) {
            case InstructionBody:      type_str = "InstructionBody"; break;
            case InstructionHeading:   type_str = "InstructionHeading"; break;
            case InstructionTailing:   type_str = "InstructionTailing"; break;
            case InstructionOverlapped: type_str = "InstructionOverlapped"; break;
            case DataByte:             type_str = "DataByte"; break;
            case DataWord:             type_str = "DataWord"; break;
            case DataDWord:            type_str = "DataDWord"; break;
            case DataQWord:            type_str = "DataQWord"; break;
            case DataFloat:            type_str = "DataFloat"; break;
            case DataDouble:           type_str = "DataDouble"; break;
            case DataLongDouble:       type_str = "DataLongDouble"; break;
            case DataXMM:              type_str = "DataXMM"; break;
            case DataYMM:              type_str = "DataYMM"; break;
            case DataMMX:              type_str = "DataMMX"; break;
            case DataMixed:            type_str = "DataMixed"; break;
            case InstructionDataMixed: type_str = "InstructionDataMixed"; break;
            default:                   type_str = "Unknown"; break;
        }

        return s_http_response::ok({
            {"address",   format_utils::format_address(address)},
            {"type",      type_str},
            {"type_id",   static_cast<int>(byte_type)}
        });
    });

    // POST /api/trace/record/set_type - Set trace record type for a page
    router.post("/api/trace/record/set_type", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("address")) {
            return s_http_response::bad_request("Missing 'address' field");
        }

        auto address = bridge.eval_expression(body["address"].get<std::string>());
        auto type_id = body.value("type", 0);

        auto success = DbgFunctions()->SetTraceRecordType(address, static_cast<TRACERECORDTYPE>(type_id));

        return s_http_response::ok({
            {"success", success},
            {"address", format_utils::format_address(address)},
            {"type",    type_id}
        });
    });

    // POST /api/trace/animate - Animate command
    router.post("/api/trace/animate", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        if (body.is_discarded() || !body.contains("command")) {
            return s_http_response::bad_request("Missing 'command' field");
        }

        auto command = body["command"].get<std::string>();
        auto success = DbgFunctions()->AnimateCommand(command.c_str());

        return s_http_response::ok({
            {"success", success},
            {"command", command}
        });
    });

    // POST /api/trace/conditional_run - Start a conditional trace run
    router.post("/api/trace/conditional_run", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_paused()) {
            return s_http_response::conflict("Debugger must be paused");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        auto break_condition = body.value("break_condition", "");
        auto log_text = body.value("log_text", "");
        auto log_condition = body.value("log_condition", "");
        auto cmd_text = body.value("command_text", "");
        auto cmd_condition = body.value("command_condition", "");
        auto trace_type = body.value("type", "into"); // into or over

        std::string cmd;
        if (trace_type == "over") {
            cmd = "TraceOverConditional";
        } else {
            cmd = "TraceIntoConditional";
        }

        if (!break_condition.empty()) {
            cmd += " " + break_condition;
        }

        auto success = bridge.exec_command_async(cmd);

        return s_http_response::ok({
            {"success", success},
            {"command", cmd},
            {"type", trace_type},
            {"message", "Conditional trace started (async)"}
        });
    });

    // POST /api/trace/log - Setup trace logging
    router.post("/api/trace/log", [](const s_http_request& req) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto body = nlohmann::json::parse(req.body, nullptr, false);
        auto file = body.value("file", "");
        auto text = body.value("text", "");
        auto condition = body.value("condition", "");

        std::string cmd;
        if (!file.empty()) {
            cmd = "StartRunTrace " + file;
            if (!text.empty()) {
                cmd += ", " + text;
            }
        } else {
            return s_http_response::bad_request("Missing 'file' field for trace log output");
        }

        auto success = bridge.exec_command(cmd);

        return s_http_response::ok({
            {"success", success},
            {"command", cmd},
            {"file", file}
        });
    });
}

} // namespace handlers

```

`plugin/src/http/c_http_router.cpp`:

```cpp
#include "http/c_http_router.h"

void c_http_router::add_route(const std::string& method, const std::string& path, route_handler_t handler) {
    m_routes.push_back({method, path, std::move(handler)});
}

void c_http_router::get(const std::string& path, route_handler_t handler) {
    add_route("GET", path, std::move(handler));
}

void c_http_router::post(const std::string& path, route_handler_t handler) {
    add_route("POST", path, std::move(handler));
}

s_http_response c_http_router::dispatch(const s_http_request& request) const {
    // Handle CORS preflight
    if (request.method == "OPTIONS") {
        s_http_response resp;
        resp.status_code = 200;
        resp.body = "";
        return resp;
    }

    // Linear scan through routes (78 routes, negligible cost)
    for (const auto& route : m_routes) {
        if (route.method == request.method && route.path == request.path) {
            try {
                return route.handler(request);
            } catch (const std::exception& e) {
                return s_http_response::internal_error(
                    std::string("Handler exception: ") + e.what()
                );
            } catch (...) {
                return s_http_response::internal_error("Unknown handler exception");
            }
        }
    }

    return s_http_response::not_found(
        "No route for " + request.method + " " + request.path
    );
}

```

`plugin/src/http/c_http_router.h`:

```h
#pragma once

#include <string>
#include <vector>
#include <functional>

#include "http/s_http_request.h"
#include "http/s_http_response.h"

// Route handler function signature
using route_handler_t = std::function<s_http_response(const s_http_request&)>;

class c_http_router {
public:
    // Register a route
    void add_route(const std::string& method, const std::string& path, route_handler_t handler);

    // Convenience helpers
    void get(const std::string& path, route_handler_t handler);
    void post(const std::string& path, route_handler_t handler);

    // Dispatch a request to the appropriate handler
    [[nodiscard]] s_http_response dispatch(const s_http_request& request) const;

private:
    struct s_route {
        std::string method;
        std::string path;
        route_handler_t handler;
    };

    std::vector<s_route> m_routes;
};

```

`plugin/src/http/c_http_server.cpp`:

```cpp
#include "http/c_http_server.h"

#include <algorithm>
#include <cctype>
#include <sstream>
#include <mstcpip.h>

#pragma comment(lib, "ws2_32.lib")

c_http_server::~c_http_server() {
    stop();
}

std::expected<void, std::string> c_http_server::start(
    const std::string& host, uint16_t port, c_http_router* router
) {
    if (m_running.load()) {
        return std::unexpected("Server is already running");
    }

    m_router = router;
    m_port = port;

    // Initialize Winsock
    WSADATA wsa_data{};
    auto wsa_result = WSAStartup(MAKEWORD(2, 2), &wsa_data);
    if (wsa_result != 0) {
        return std::unexpected("WSAStartup failed with error: " + std::to_string(wsa_result));
    }

    // Create listening socket
    m_listen_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (m_listen_socket == INVALID_SOCKET) {
        auto err = WSAGetLastError();
        WSACleanup();
        return std::unexpected("socket() failed with error: " + std::to_string(err));
    }

    // Allow address reuse
    int opt_val = 1;
    setsockopt(m_listen_socket, SOL_SOCKET, SO_REUSEADDR,
               reinterpret_cast<const char*>(&opt_val), sizeof(opt_val));

    // Bind to localhost only
    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    inet_pton(AF_INET, host.c_str(), &addr.sin_addr);

    if (bind(m_listen_socket, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) == SOCKET_ERROR) {
        auto err = WSAGetLastError();
        closesocket(m_listen_socket);
        m_listen_socket = INVALID_SOCKET;
        WSACleanup();
        return std::unexpected("bind() failed with error: " + std::to_string(err));
    }

    if (listen(m_listen_socket, SOMAXCONN) == SOCKET_ERROR) {
        auto err = WSAGetLastError();
        closesocket(m_listen_socket);
        m_listen_socket = INVALID_SOCKET;
        WSACleanup();
        return std::unexpected("listen() failed with error: " + std::to_string(err));
    }

    m_running.store(true);
    m_listener_thread = std::thread(&c_http_server::listener_loop, this);

    return {};
}

void c_http_server::stop() {
    if (!m_running.load()) {
        return;
    }

    m_running.store(false);

    // Close the listening socket to unblock accept()
    if (m_listen_socket != INVALID_SOCKET) {
        closesocket(m_listen_socket);
        m_listen_socket = INVALID_SOCKET;
    }

    // Wait for the listener thread to finish
    if (m_listener_thread.joinable()) {
        m_listener_thread.join();
    }

    WSACleanup();
}

void c_http_server::listener_loop() {
    // Use select() with timeout so we can check m_running periodically
    // instead of blocking forever in accept()
    while (m_running.load()) {
        fd_set read_set;
        FD_ZERO(&read_set);
        FD_SET(m_listen_socket, &read_set);

        timeval tv{};
        tv.tv_sec = 1;  // 1 second poll interval
        tv.tv_usec = 0;

        auto sel_result = select(0, &read_set, nullptr, nullptr, &tv);
        if (sel_result == SOCKET_ERROR) {
            if (!m_running.load()) break;
            continue;
        }
        if (sel_result == 0) {
            // Timeout - just loop and check m_running
            continue;
        }

        sockaddr_in client_addr{};
        int client_addr_len = sizeof(client_addr);

        SOCKET client_socket = accept(
            m_listen_socket,
            reinterpret_cast<sockaddr*>(&client_addr),
            &client_addr_len
        );

        if (client_socket == INVALID_SOCKET) {
            if (!m_running.load()) break;
            continue;
        }

        // Handle each connection on a detached thread
        std::thread(&c_http_server::handle_connection, this, client_socket).detach();
    }
}

void c_http_server::handle_connection(SOCKET client_socket) {
    // Set receive timeout
    DWORD timeout = RECV_TIMEOUT_MS;
    setsockopt(client_socket, SOL_SOCKET, SO_RCVTIMEO,
               reinterpret_cast<const char*>(&timeout), sizeof(timeout));

    // Set send timeout
    setsockopt(client_socket, SOL_SOCKET, SO_SNDTIMEO,
               reinterpret_cast<const char*>(&timeout), sizeof(timeout));

    // Disable Nagle's algorithm for low latency
    int nodelay = 1;
    setsockopt(client_socket, IPPROTO_TCP, TCP_NODELAY,
               reinterpret_cast<const char*>(&nodelay), sizeof(nodelay));

    // Enable TCP keepalive to detect dead connections
    int keepalive = 1;
    setsockopt(client_socket, SOL_SOCKET, SO_KEEPALIVE,
               reinterpret_cast<const char*>(&keepalive), sizeof(keepalive));

    // Read the full request
    std::string raw_data;
    raw_data.reserve(4096);

    char buffer[4096];
    size_t content_length = 0;
    bool headers_complete = false;
    size_t header_end_pos = std::string::npos;

    while (true) {
        auto bytes_read = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_read <= 0) break;

        raw_data.append(buffer, static_cast<size_t>(bytes_read));

        // Check if we've received all headers
        if (!headers_complete) {
            header_end_pos = raw_data.find("\r\n\r\n");
            if (header_end_pos != std::string::npos) {
                headers_complete = true;

                // Extract Content-Length
                auto cl_pos = raw_data.find("Content-Length:");
                if (cl_pos == std::string::npos) {
                    cl_pos = raw_data.find("content-length:");
                }
                if (cl_pos != std::string::npos) {
                    auto val_start = cl_pos + 15; // length of "Content-Length:"
                    auto val_end = raw_data.find("\r\n", val_start);
                    auto val_str = raw_data.substr(val_start, val_end - val_start);
                    content_length = std::stoull(val_str);
                }
            }
        }

        // Check if we have the complete body
        if (headers_complete) {
            auto body_start = header_end_pos + 4;
            auto body_received = raw_data.size() - body_start;
            if (body_received >= content_length) break;
        }

        // Safety check: don't read more than MAX_REQUEST_SIZE
        if (raw_data.size() > MAX_REQUEST_SIZE) break;
    }

    // Parse and dispatch
    auto parse_result = parse_request(raw_data);
    s_http_response response;

    if (parse_result.has_value()) {
        response = m_router->dispatch(parse_result.value());
    } else {
        response = s_http_response::bad_request(parse_result.error());
    }

    // Send response (handle partial sends)
    auto response_str = response.serialize();
    auto total = static_cast<int>(response_str.size());
    int sent = 0;

    while (sent < total) {
        auto result = send(client_socket, response_str.c_str() + sent, total - sent, 0);
        if (result == SOCKET_ERROR) break;
        sent += result;
    }

    // Graceful shutdown
    shutdown(client_socket, SD_SEND);
    closesocket(client_socket);
}

std::expected<s_http_request, std::string> c_http_server::parse_request(
    const std::string& raw_data
) {
    if (raw_data.empty()) {
        return std::unexpected("Empty request");
    }

    s_http_request req;

    // Find end of request line
    auto line_end = raw_data.find("\r\n");
    if (line_end == std::string::npos) {
        return std::unexpected("Malformed request line");
    }

    auto request_line = raw_data.substr(0, line_end);

    // Parse: METHOD PATH HTTP/1.x
    auto first_space = request_line.find(' ');
    if (first_space == std::string::npos) {
        return std::unexpected("Malformed request line: no method");
    }
    req.method = request_line.substr(0, first_space);

    auto second_space = request_line.find(' ', first_space + 1);
    if (second_space == std::string::npos) {
        return std::unexpected("Malformed request line: no path");
    }
    auto full_path = request_line.substr(first_space + 1, second_space - first_space - 1);

    // Split path and query string
    auto query_pos = full_path.find('?');
    if (query_pos != std::string::npos) {
        req.path = full_path.substr(0, query_pos);
        req.query_string = full_path.substr(query_pos + 1);
        parse_query_string(req.query_string, req.query);
    } else {
        req.path = full_path;
    }

    // Parse headers
    auto header_end = raw_data.find("\r\n\r\n");
    if (header_end == std::string::npos) {
        return std::unexpected("Malformed headers");
    }

    auto headers_section = raw_data.substr(line_end + 2, header_end - line_end - 2);
    std::istringstream header_stream(headers_section);
    std::string header_line;

    while (std::getline(header_stream, header_line)) {
        // Remove trailing \r
        if (!header_line.empty() && header_line.back() == '\r') {
            header_line.pop_back();
        }
        if (header_line.empty()) continue;

        auto colon = header_line.find(':');
        if (colon == std::string::npos) continue;

        auto key = header_line.substr(0, colon);
        auto value = header_line.substr(colon + 1);

        // Lowercase the key
        std::transform(key.begin(), key.end(), key.begin(),
                       [](unsigned char c) { return static_cast<char>(std::tolower(c)); });

        // Trim leading whitespace from value
        auto val_start = value.find_first_not_of(" \t");
        if (val_start != std::string::npos) {
            value = value.substr(val_start);
        }

        req.headers[key] = value;
    }

    // Extract body
    auto body_start = header_end + 4;
    if (body_start < raw_data.size()) {
        req.body = raw_data.substr(body_start);
    }

    return req;
}

void c_http_server::parse_query_string(
    const std::string& query_string,
    std::unordered_map<std::string, std::string>& out
) {
    std::istringstream stream(query_string);
    std::string pair;

    while (std::getline(stream, pair, '&')) {
        auto eq = pair.find('=');
        if (eq != std::string::npos) {
            auto key = url_decode(pair.substr(0, eq));
            auto value = url_decode(pair.substr(eq + 1));
            out[key] = value;
        } else {
            out[url_decode(pair)] = "";
        }
    }
}

std::string c_http_server::url_decode(const std::string& encoded) {
    std::string result;
    result.reserve(encoded.size());

    for (size_t i = 0; i < encoded.size(); ++i) {
        if (encoded[i] == '%' && i + 2 < encoded.size()) {
            auto hex_str = encoded.substr(i + 1, 2);
            auto ch = static_cast<char>(std::stoi(hex_str, nullptr, 16));
            result += ch;
            i += 2;
        } else if (encoded[i] == '+') {
            result += ' ';
        } else {
            result += encoded[i];
        }
    }

    return result;
}

```

`plugin/src/http/c_http_server.h`:

```h
#pragma once

#include <string>
#include <thread>
#include <atomic>
#include <expected>
#include <cstdint>

#include <winsock2.h>
#include <ws2tcpip.h>

#include "http/c_http_router.h"

class c_http_server {
public:
    c_http_server() = default;
    ~c_http_server();

    // Non-copyable, non-movable
    c_http_server(const c_http_server&) = delete;
    c_http_server& operator=(const c_http_server&) = delete;
    c_http_server(c_http_server&&) = delete;
    c_http_server& operator=(c_http_server&&) = delete;

    // Start the HTTP server on the given host:port
    [[nodiscard]] std::expected<void, std::string> start(
        const std::string& host, uint16_t port, c_http_router* router
    );

    // Stop the server and join the listener thread
    void stop();

    // Check if the server is currently running
    [[nodiscard]] bool is_running() const { return m_running.load(); }

    // Get the bound port
    [[nodiscard]] uint16_t get_port() const { return m_port; }

private:
    static constexpr size_t MAX_REQUEST_SIZE = 1024 * 1024; // 1MB max request body
    static constexpr int RECV_TIMEOUT_MS = 5000;

    SOCKET m_listen_socket = INVALID_SOCKET;
    std::atomic<bool> m_running{false};
    std::thread m_listener_thread;
    c_http_router* m_router = nullptr;
    uint16_t m_port = 0;

    // Main listener loop (runs on m_listener_thread)
    void listener_loop();

    // Handle a single client connection
    void handle_connection(SOCKET client_socket);

    // Parse raw HTTP request data into s_http_request
    [[nodiscard]] static std::expected<s_http_request, std::string> parse_request(
        const std::string& raw_data
    );

    // Parse query string into key-value pairs
    static void parse_query_string(
        const std::string& query_string,
        std::unordered_map<std::string, std::string>& out
    );

    // URL-decode a string
    [[nodiscard]] static std::string url_decode(const std::string& encoded);
};

```

`plugin/src/http/s_http_request.h`:

```h
#pragma once

#include <string>
#include <unordered_map>

struct s_http_request {
    std::string method;                                     // "GET", "POST", etc.
    std::string path;                                       // "/api/debug/state"
    std::string query_string;                               // "address=0x401000&size=64"
    std::unordered_map<std::string, std::string> query;     // Parsed query parameters
    std::unordered_map<std::string, std::string> headers;   // Request headers (lowercased keys)
    std::string body;                                       // Raw request body

    // Get a query parameter with a default value
    [[nodiscard]] std::string get_query(const std::string& key, const std::string& default_value = "") const {
        auto it = query.find(key);
        return (it != query.end()) ? it->second : default_value;
    }

    // Get a header value (key must be lowercase)
    [[nodiscard]] std::string get_header(const std::string& key, const std::string& default_value = "") const {
        auto it = headers.find(key);
        return (it != headers.end()) ? it->second : default_value;
    }
};

```

`plugin/src/http/s_http_response.h`:

```h
#pragma once

#include <string>
#include <sstream>
#include <nlohmann/json.hpp>

struct s_http_response {
    int status_code = 200;
    std::string content_type = "application/json";
    std::string body;

    // Build a success response with data payload
    static s_http_response ok(const nlohmann::json& data) {
        nlohmann::json envelope = {
            {"success", true},
            {"data", data}
        };
        return {200, "application/json", envelope.dump()};
    }

    // Build an error response
    static s_http_response error(int code, const std::string& message) {
        nlohmann::json envelope = {
            {"success", false},
            {"error", {
                {"code", code},
                {"message", message}
            }}
        };
        return {code, "application/json", envelope.dump()};
    }

    // 400 Bad Request
    static s_http_response bad_request(const std::string& message) {
        return error(400, message);
    }

    // 404 Not Found
    static s_http_response not_found(const std::string& message = "Not found") {
        return error(404, message);
    }

    // 409 Conflict (wrong debugger state)
    static s_http_response conflict(const std::string& message) {
        return error(409, message);
    }

    // 500 Internal Server Error
    static s_http_response internal_error(const std::string& message) {
        return error(500, message);
    }

    // Serialize to HTTP response string
    [[nodiscard]] std::string serialize() const {
        std::ostringstream oss;
        oss << "HTTP/1.1 " << status_code << " " << status_text() << "\r\n";
        oss << "Content-Type: " << content_type << "\r\n";
        oss << "Content-Length: " << body.size() << "\r\n";
        oss << "Connection: close\r\n";
        oss << "Access-Control-Allow-Origin: *\r\n";
        oss << "Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n";
        oss << "Access-Control-Allow-Headers: Content-Type\r\n";
        oss << "\r\n";
        oss << body;
        return oss.str();
    }

private:
    [[nodiscard]] std::string status_text() const {
        switch (status_code) {
            case 200: return "OK";
            case 400: return "Bad Request";
            case 404: return "Not Found";
            case 405: return "Method Not Allowed";
            case 409: return "Conflict";
            case 500: return "Internal Server Error";
            default:  return "Unknown";
        }
    }
};

```

`plugin/src/plugin_main.cpp`:

```cpp
#include "plugin_main.h"

#include <string>
#include <cstdio>
#include <cstring>

#include "_plugins.h"
#include "http/c_http_server.h"
#include "http/c_http_router.h"
#include "bridge/c_bridge_executor.h"
#include "util/format_utils.h"
#include "resources/plugin_icon.h"
#include "ui/settings_dialog.h"
#include "ui/about_dialog.h"

// Forward declarations for handler registration functions
namespace handlers {
    void register_debug_routes(c_http_router& router);
    void register_register_routes(c_http_router& router);
    void register_memory_routes(c_http_router& router);
    void register_breakpoint_routes(c_http_router& router);
    void register_disasm_routes(c_http_router& router);
    void register_module_routes(c_http_router& router);
    void register_thread_routes(c_http_router& router);
    void register_stack_routes(c_http_router& router);
    void register_symbol_routes(c_http_router& router);
    void register_annotation_routes(c_http_router& router);
    void register_search_routes(c_http_router& router);
    void register_patch_routes(c_http_router& router);
    void register_memmap_routes(c_http_router& router);
    void register_command_routes(c_http_router& router);
    void register_analysis_routes(c_http_router& router);
    void register_tracing_routes(c_http_router& router);
    void register_dumping_routes(c_http_router& router);
    void register_antidebug_routes(c_http_router& router);
    void register_exception_routes(c_http_router& router);
    void register_process_routes(c_http_router& router);
    void register_handles_routes(c_http_router& router);
    void register_controlflow_routes(c_http_router& router);
} // namespace handlers

// Globals
static int g_plugin_handle = -1;
static int g_menu_handle = -1;
static HWND g_hwnd_dlg = nullptr;
static c_http_server g_server;
static c_http_router g_router;
static s_plugin_settings g_settings;

// ============================================================================
// Menu helpers
// ============================================================================

static void update_menu_state() {
    const bool running = g_server.is_running();
    _plugin_menuentrysetchecked(g_plugin_handle, menu_start_server, running);
    _plugin_menuentrysetchecked(g_plugin_handle, menu_stop_server, !running);
}

// ============================================================================
// Settings persistence
// ============================================================================

static void load_settings() {
    char buf[256];

    if (BridgeSettingGet(SETTINGS_SECTION, SETTINGS_KEY_HOST, buf)) {
        strncpy_s(g_settings.host, buf, _TRUNCATE);
    }

    duint port_val = 0;
    if (BridgeSettingGetUint(SETTINGS_SECTION, SETTINGS_KEY_PORT, &port_val)) {
        if (port_val >= 1 && port_val <= 65535) {
            g_settings.port = static_cast<uint16_t>(port_val);
        }
    }

    duint autostart_val = 0;
    if (BridgeSettingGetUint(SETTINGS_SECTION, SETTINGS_KEY_AUTOSTART, &autostart_val)) {
        g_settings.auto_start = (autostart_val != 0);
    }
}

static void save_settings() {
    BridgeSettingSet(SETTINGS_SECTION, SETTINGS_KEY_HOST, g_settings.host);
    BridgeSettingSetUint(SETTINGS_SECTION, SETTINGS_KEY_PORT, g_settings.port);
    BridgeSettingSetUint(SETTINGS_SECTION, SETTINGS_KEY_AUTOSTART, g_settings.auto_start ? 1 : 0);
    BridgeSettingFlush();
}

// ============================================================================
// Route registration
// ============================================================================

void register_all_routes(c_http_router& router) {
    // Health check endpoint
    router.get("/api/health", [](const s_http_request&) -> s_http_response {
        return s_http_response::ok({
            {"version", "1.0.0"},
            {"plugin",  PLUGIN_NAME},
            {"status",  "ok"}
        });
    });

    // Process info endpoint
    router.get("/api/process/info", [](const s_http_request&) -> s_http_response {
        auto& bridge = get_bridge();
        if (!bridge.require_debugging()) {
            return s_http_response::conflict("No active debug session");
        }

        auto pid = bridge.eval_expression("$pid");
        auto peb = bridge.eval_expression("peb()");
        auto entry = bridge.eval_expression("mod.entry(0)");

        return s_http_response::ok({
            {"pid",           pid},
            {"peb",           format_utils::format_address(peb)},
            {"entry_point",   format_utils::format_address(entry)},
            {"debugger_state", bridge.get_state_string()}
        });
    });

    // Register all handler categories
    handlers::register_debug_routes(router);
    handlers::register_register_routes(router);
    handlers::register_memory_routes(router);
    handlers::register_breakpoint_routes(router);
    handlers::register_disasm_routes(router);
    handlers::register_module_routes(router);
    handlers::register_thread_routes(router);
    handlers::register_stack_routes(router);
    handlers::register_symbol_routes(router);
    handlers::register_annotation_routes(router);
    handlers::register_search_routes(router);
    handlers::register_patch_routes(router);
    handlers::register_memmap_routes(router);
    handlers::register_command_routes(router);
    handlers::register_analysis_routes(router);
    handlers::register_tracing_routes(router);
    handlers::register_dumping_routes(router);
    handlers::register_antidebug_routes(router);
    handlers::register_exception_routes(router);
    handlers::register_process_routes(router);
    handlers::register_handles_routes(router);
    handlers::register_controlflow_routes(router);
}

// ============================================================================
// MCP Server command handler
// ============================================================================

static bool mcp_server_command(int argc, char* argv[]) {
    if (argc < 2) {
        _plugin_logputs("[MCP] Usage: mcpserver <start|stop|status>");
        return false;
    }

    std::string subcommand = argv[1];

    if (subcommand == "start") {
        if (g_server.is_running()) {
            _plugin_logputs("[MCP] Server is already running");
            return true;
        }

        auto result = g_server.start(g_settings.host, g_settings.port, &g_router);
        if (result.has_value()) {
            _plugin_logprintf("[MCP] Server started on %s:%u\n", g_settings.host, g_settings.port);
        } else {
            _plugin_logprintf("[MCP] Failed to start server: %s\n", result.error().c_str());
        }
        update_menu_state();
        return result.has_value();
    }

    if (subcommand == "stop") {
        if (!g_server.is_running()) {
            _plugin_logputs("[MCP] Server is not running");
            return true;
        }

        g_server.stop();
        _plugin_logputs("[MCP] Server stopped");
        update_menu_state();
        return true;
    }

    if (subcommand == "status") {
        if (g_server.is_running()) {
            _plugin_logprintf("[MCP] Server is running on %s:%u\n", g_settings.host, g_server.get_port());
        } else {
            _plugin_logputs("[MCP] Server is not running");
        }
        return true;
    }

    _plugin_logputs("[MCP] Unknown subcommand. Usage: mcpserver <start|stop|status>");
    return false;
}

// ============================================================================
// Plugin exports
// ============================================================================

PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* init_struct) {
    init_struct->sdkVersion = PLUG_SDKVERSION;
    init_struct->pluginVersion = PLUGIN_VERSION;
    strncpy_s(init_struct->pluginName, PLUGIN_NAME, _TRUNCATE);

    g_plugin_handle = init_struct->pluginHandle;

    // Register the mcpserver command
    _plugin_registercommand(g_plugin_handle, "mcpserver", mcp_server_command, false);

    return true;
}

PLUG_EXPORT bool plugstop() {
    // Unregister command
    _plugin_unregistercommand(g_plugin_handle, "mcpserver");

    // Stop the HTTP server
    g_server.stop();

    _plugin_logputs("[MCP] Plugin stopped");
    return true;
}

PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setup_struct) {
    // Store GUI handles
    g_hwnd_dlg = setup_struct->hwndDlg;
    g_menu_handle = setup_struct->hMenu;

    // Load persisted settings
    load_settings();

    // Set plugin menu icon
    ICONDATA icon_data;
    icon_data.data = plugin_icon::png_data;
    icon_data.size = plugin_icon::png_size;
    _plugin_menuseticon(g_menu_handle, &icon_data);

    // Build menu entries
    _plugin_menuaddentry(g_menu_handle, menu_start_server, "Start Server");
    _plugin_menuaddentry(g_menu_handle, menu_stop_server, "Stop Server");
    _plugin_menuaddseparator(g_menu_handle);
    _plugin_menuaddentry(g_menu_handle, menu_settings, "Settings...");
    _plugin_menuaddentry(g_menu_handle, menu_about, "About...");

    // Register all API routes
    register_all_routes(g_router);

    // Auto-start the server (if enabled in settings)
    if (g_settings.auto_start) {
        auto result = g_server.start(g_settings.host, g_settings.port, &g_router);
        if (result.has_value()) {
            _plugin_logprintf("[MCP] x64dbg MCP Server started on %s:%u\n",
                g_settings.host, g_settings.port);
        } else {
            _plugin_logprintf("[MCP] Failed to auto-start server: %s\n", result.error().c_str());
            _plugin_logputs("[MCP] Use 'mcpserver start' to retry");
        }
    } else {
        _plugin_logputs("[MCP] Auto-start disabled. Use 'mcpserver start' or menu to start.");
    }

    // Sync checkmarks with actual server state
    update_menu_state();
}

PLUG_EXPORT void CBMENUENTRY(CBTYPE, void* call_info) {
    auto* info = static_cast<PLUG_CB_MENUENTRY*>(call_info);

    switch (info->hEntry) {
    case menu_start_server:
        if (g_server.is_running()) {
            _plugin_logputs("[MCP] Server is already running");
        } else {
            auto result = g_server.start(g_settings.host, g_settings.port, &g_router);
            if (result.has_value()) {
                _plugin_logprintf("[MCP] Server started on %s:%u\n",
                    g_settings.host, g_settings.port);
            } else {
                _plugin_logprintf("[MCP] Failed to start server: %s\n", result.error().c_str());
            }
        }
        update_menu_state();
        break;

    case menu_stop_server:
        if (!g_server.is_running()) {
            _plugin_logputs("[MCP] Server is not running");
        } else {
            g_server.stop();
            _plugin_logputs("[MCP] Server stopped");
        }
        update_menu_state();
        break;

    case menu_settings: {
        // Snapshot current settings in case we need to detect host/port changes
        const auto old_host = std::string(g_settings.host);
        const auto old_port = g_settings.port;

        if (show_settings_dialog(g_hwnd_dlg, g_settings) == IDOK) {
            save_settings();
            _plugin_logputs("[MCP] Settings saved");

            // Restart server if host/port changed and server is running
            const bool host_changed = (old_host != g_settings.host);
            const bool port_changed = (old_port != g_settings.port);

            if (g_server.is_running() && (host_changed || port_changed)) {
                g_server.stop();
                auto result = g_server.start(g_settings.host, g_settings.port, &g_router);
                if (result.has_value()) {
                    _plugin_logprintf("[MCP] Server restarted on %s:%u\n",
                        g_settings.host, g_settings.port);
                } else {
                    _plugin_logprintf("[MCP] Failed to restart server: %s\n",
                        result.error().c_str());
                }
                update_menu_state();
            }
        }
        break;
    }

    case menu_about:
        show_about_dialog(g_hwnd_dlg, g_server.is_running(),
            g_settings.host, g_server.get_port());
        break;

    default:
        break;
    }
}

```

`plugin/src/plugin_main.h`:

```h
#pragma once

#include "_plugins.h"
#include "http/c_http_server.h"
#include "http/c_http_router.h"

// Plugin info
constexpr auto PLUGIN_NAME = "x64dbg MCP Server";
constexpr auto PLUGIN_AUTHOR = "bromo";
constexpr auto PLUGIN_VERSION = 1;
constexpr auto PLUGIN_VERSION_STR = "2.2.1";
constexpr auto PLUGIN_REPO_URL = "https://github.com/bromoket/x64dbg_mcp";
constexpr uint16_t DEFAULT_PORT = 27042;
constexpr auto DEFAULT_HOST = "127.0.0.1";

// Persistent settings keys (BridgeSettingGet/Set)
constexpr auto SETTINGS_SECTION = "MCP";
constexpr auto SETTINGS_KEY_HOST = "Host";
constexpr auto SETTINGS_KEY_PORT = "Port";
constexpr auto SETTINGS_KEY_AUTOSTART = "AutoStart";

/// @brief Plugin settings persisted via BridgeSetting
struct s_plugin_settings {
    char host[64] = "127.0.0.1";
    uint16_t port = 27042;
    bool auto_start = true;
};

// Menu entry IDs
enum e_menu_entry : int {
    menu_start_server = 0,
    menu_stop_server  = 1,
    menu_settings     = 2,
    menu_about        = 3
};

// Plugin export macro (functions are also listed in plugin.def)
#ifndef PLUG_EXPORT
#define PLUG_EXPORT extern "C" __declspec(dllexport)
#endif

// Register all API routes on the router
void register_all_routes(c_http_router& router);

```

`plugin/src/resources/plugin_icon.h`:

```h
#pragma once

#include <cstddef>

namespace plugin_icon {

/// @brief Embedded 16x16 PNG icon (blue connected-nodes / MCP-themed design)
constexpr unsigned char png_data[] = {
    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0xf3, 0xff,
    0x61, 0x00, 0x00, 0x00, 0x6b, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x60, 0xa0, 0x26, 0xf0,
    0x9a, 0x70, 0xf3, 0x3f, 0xd9, 0x6a, 0x40, 0x12, 0x30, 0x8c, 0x4f, 0x33, 0x56, 0x35, 0xc8, 0x12,
    0xc8, 0x0a, 0xaa, 0x36, 0xbc, 0xfc, 0x0f, 0xc2, 0xf8, 0xd4, 0xe0, 0x35, 0x1d, 0xd9, 0x00, 0xa2,
    0x5c, 0x89, 0x6c, 0xb3, 0x56, 0xc1, 0x49, 0x38, 0x86, 0x89, 0xe1, 0x0d, 0x03, 0x64, 0x80, 0xac,
    0x19, 0xd9, 0x10, 0xa2, 0x00, 0xba, 0xed, 0x30, 0x8c, 0xee, 0x1d, 0xda, 0x19, 0x80, 0xcd, 0x1b,
    0x44, 0x6b, 0x44, 0x0e, 0x44, 0x18, 0x8d, 0xcc, 0x46, 0x56, 0x83, 0x55, 0x33, 0xd9, 0xd1, 0x48,
    0xb3, 0x84, 0x44, 0x8c, 0x2b, 0xb1, 0x86, 0x01, 0x3e, 0x40, 0x54, 0x42, 0x22, 0x05, 0x00, 0x00,
    0x5d, 0xfa, 0xfe, 0xad, 0x9a, 0x58, 0x30, 0xa3, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44,
    0xae, 0x42, 0x60, 0x82
};

constexpr auto png_size = sizeof(png_data);

} // namespace plugin_icon

```

`plugin/src/ui/about_dialog.cpp`:

```cpp
#include "ui/about_dialog.h"
#include "plugin_main.h"

#include <cstdio>
#include <cstring>
#include <shellapi.h>

// Control IDs
static constexpr WORD IDC_TITLE_LABEL   = 200;
static constexpr WORD IDC_VER_LABEL     = 201;
static constexpr WORD IDC_STATUS_LABEL  = 202;
static constexpr WORD IDC_SEPARATOR     = 203;
static constexpr WORD IDC_URL_LABEL     = 204;
static constexpr WORD IDC_DISCORD_LABEL = 205;
static constexpr WORD IDC_OK_BTN        = IDOK;

// ============================================================================
// In-memory dialog template builder
// ============================================================================

static LPWORD align_dword(LPWORD ptr) {
    auto addr = reinterpret_cast<uintptr_t>(ptr);
    addr = (addr + 3) & ~static_cast<uintptr_t>(3);
    return reinterpret_cast<LPWORD>(addr);
}

static LPWORD write_wide_string(LPWORD ptr, const char* str) {
    int len = MultiByteToWideChar(CP_ACP, 0, str, -1, reinterpret_cast<LPWSTR>(ptr), 256);
    return ptr + len;
}

static LPWORD add_dialog_item(
    LPWORD ptr,
    DWORD style,
    short x, short y, short cx, short cy,
    WORD id,
    WORD class_atom,
    const char* text
) {
    ptr = align_dword(ptr);

    auto* item = reinterpret_cast<DLGITEMTEMPLATE*>(ptr);
    item->style = style | WS_CHILD | WS_VISIBLE;
    item->dwExtendedStyle = 0;
    item->x = x;
    item->y = y;
    item->cx = cx;
    item->cy = cy;
    item->id = id;

    ptr = reinterpret_cast<LPWORD>(item + 1);

    *ptr++ = 0xFFFF;
    *ptr++ = class_atom;

    ptr = write_wide_string(ptr, text);

    // Creation data (none)
    *ptr++ = 0;

    return ptr;
}

// ============================================================================
// About dialog state (passed via lParam)
// ============================================================================

struct s_about_state {
    bool is_running;
    char status_text[128];
};

/// @brief Build the about dialog template with Segoe UI 9pt font
static LPDLGTEMPLATE build_about_template() {
    static BYTE buffer[2048];
    std::memset(buffer, 0, sizeof(buffer));

    auto* dlg = reinterpret_cast<LPDLGTEMPLATE>(buffer);
    dlg->style = DS_MODALFRAME | DS_CENTER | DS_SETFONT
               | WS_POPUP | WS_CAPTION | WS_SYSMENU;
    dlg->dwExtendedStyle = 0;
    dlg->cdit = 7;  // title + version + status + separator + url + discord + OK
    dlg->x = 0;
    dlg->y = 0;
    dlg->cx = 160;
    dlg->cy = 100;

    auto* ptr = reinterpret_cast<LPWORD>(dlg + 1);

    // Menu (none)
    *ptr++ = 0;
    // Class (default)
    *ptr++ = 0;
    // Title
    ptr = write_wide_string(ptr, "About");

    // Font (DS_SETFONT): point size + face name
    *ptr++ = 9;
    ptr = write_wide_string(ptr, "Segoe UI");

    // --- Controls ---

    // Title (centered, bolded in WM_INITDIALOG)
    ptr = add_dialog_item(ptr,
        SS_CENTER, 7, 8, 146, 10,
        IDC_TITLE_LABEL, 0x0082, PLUGIN_NAME);

    // Version (centered)
    ptr = add_dialog_item(ptr,
        SS_CENTER, 7, 21, 146, 8,
        IDC_VER_LABEL, 0x0082, "");

    // Status (centered)
    ptr = add_dialog_item(ptr,
        SS_CENTER, 7, 33, 146, 8,
        IDC_STATUS_LABEL, 0x0082, "");

    // Etched separator
    ptr = add_dialog_item(ptr,
        SS_ETCHEDHORZ, 7, 47, 146, 1,
        IDC_SEPARATOR, 0x0082, "");

    // GitHub URL (centered, clickable — SS_NOTIFY enables STN_CLICKED)
    ptr = add_dialog_item(ptr,
        SS_CENTER | SS_NOTIFY, 7, 53, 146, 8,
        IDC_URL_LABEL, 0x0082, "github.com/bromoket/x64dbg_mcp");

    // Discord (centered, grey)
    ptr = add_dialog_item(ptr,
        SS_CENTER, 7, 65, 146, 8,
        IDC_DISCORD_LABEL, 0x0082, "");

    // OK button (centered)
    ptr = add_dialog_item(ptr,
        BS_DEFPUSHBUTTON | WS_TABSTOP, 55, 80, 50, 14,
        IDC_OK_BTN, 0x0080, "OK");

    return dlg;
}

// ============================================================================
// Dialog procedure
// ============================================================================

static HFONT s_bold_font = nullptr;
static HFONT s_link_font = nullptr;
static HCURSOR s_hand_cursor = nullptr;

static INT_PTR CALLBACK about_dlg_proc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam) {
    switch (msg) {
    case WM_INITDIALOG: {
        auto* state = reinterpret_cast<s_about_state*>(lparam);

        // Store state pointer for WM_CTLCOLORSTATIC
        SetWindowLongPtrA(hdlg, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(state));

        // Version
        char ver_buf[64];
        std::snprintf(ver_buf, sizeof(ver_buf), "Version %s", PLUGIN_VERSION_STR);
        SetDlgItemTextA(hdlg, IDC_VER_LABEL, ver_buf);

        // Status
        SetDlgItemTextA(hdlg, IDC_STATUS_LABEL, state->status_text);

        // Discord
        char discord_buf[64];
        std::snprintf(discord_buf, sizeof(discord_buf), "Discord:  %s", PLUGIN_AUTHOR);
        SetDlgItemTextA(hdlg, IDC_DISCORD_LABEL, discord_buf);

        // Derive bold font for title
        HFONT dlg_font = reinterpret_cast<HFONT>(SendMessageA(hdlg, WM_GETFONT, 0, 0));
        if (dlg_font) {
            LOGFONTA lf;
            GetObjectA(dlg_font, sizeof(lf), &lf);

            // Bold for title
            lf.lfWeight = FW_BOLD;
            s_bold_font = CreateFontIndirectA(&lf);
            if (s_bold_font) {
                SendDlgItemMessageA(hdlg, IDC_TITLE_LABEL, WM_SETFONT,
                    reinterpret_cast<WPARAM>(s_bold_font), TRUE);
            }

            // Underline for link
            lf.lfWeight = FW_NORMAL;
            lf.lfUnderline = TRUE;
            s_link_font = CreateFontIndirectA(&lf);
            if (s_link_font) {
                SendDlgItemMessageA(hdlg, IDC_URL_LABEL, WM_SETFONT,
                    reinterpret_cast<WPARAM>(s_link_font), TRUE);
            }
        }

        // Cache hand cursor for the link
        s_hand_cursor = LoadCursorA(nullptr, IDC_HAND);

        return TRUE;
    }

    case WM_CTLCOLORSTATIC: {
        auto ctrl_id = GetDlgCtrlID(reinterpret_cast<HWND>(lparam));
        auto hdc = reinterpret_cast<HDC>(wparam);

        if (ctrl_id == IDC_STATUS_LABEL) {
            // Green if running, red if stopped
            auto* state = reinterpret_cast<s_about_state*>(
                GetWindowLongPtrA(hdlg, GWLP_USERDATA));
            if (state && state->is_running) {
                SetTextColor(hdc, RGB(34, 139, 34));
            } else {
                SetTextColor(hdc, RGB(200, 50, 50));
            }
            SetBkMode(hdc, TRANSPARENT);
            return reinterpret_cast<INT_PTR>(GetSysColorBrush(COLOR_BTNFACE));
        }
        if (ctrl_id == IDC_URL_LABEL) {
            // Blue underlined link
            SetTextColor(hdc, RGB(0, 102, 204));
            SetBkMode(hdc, TRANSPARENT);
            return reinterpret_cast<INT_PTR>(GetSysColorBrush(COLOR_BTNFACE));
        }
        if (ctrl_id == IDC_DISCORD_LABEL) {
            // Grey text
            SetTextColor(hdc, RGB(100, 100, 100));
            SetBkMode(hdc, TRANSPARENT);
            return reinterpret_cast<INT_PTR>(GetSysColorBrush(COLOR_BTNFACE));
        }
        break;
    }

    case WM_SETCURSOR: {
        // Show hand cursor when hovering the link
        auto ctrl_id = GetDlgCtrlID(reinterpret_cast<HWND>(wparam));
        if (ctrl_id == IDC_URL_LABEL && s_hand_cursor) {
            SetCursor(s_hand_cursor);
            SetWindowLongPtrA(hdlg, DWLP_MSGRESULT, TRUE);
            return TRUE;
        }
        break;
    }

    case WM_COMMAND:
        if (LOWORD(wparam) == IDC_URL_LABEL && HIWORD(wparam) == STN_CLICKED) {
            ShellExecuteA(hdlg, "open", PLUGIN_REPO_URL, nullptr, nullptr, SW_SHOWNORMAL);
            return TRUE;
        }
        if (LOWORD(wparam) == IDC_OK_BTN) {
            EndDialog(hdlg, IDOK);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, IDOK);
        return TRUE;

    case WM_DESTROY:
        if (s_bold_font) {
            DeleteObject(s_bold_font);
            s_bold_font = nullptr;
        }
        if (s_link_font) {
            DeleteObject(s_link_font);
            s_link_font = nullptr;
        }
        return TRUE;
    }

    return FALSE;
}

// ============================================================================
// Public API
// ============================================================================

void show_about_dialog(HWND parent, bool is_server_running, const char* host, uint16_t port) {
    s_about_state state{};
    state.is_running = is_server_running;

    if (is_server_running) {
        std::snprintf(state.status_text, sizeof(state.status_text),
            "Status:  Running on %s:%u", host, port);
    } else {
        std::snprintf(state.status_text, sizeof(state.status_text),
            "Status:  Stopped");
    }

    auto* dlg_template = build_about_template();
    DialogBoxIndirectParamA(
        GetModuleHandleA(nullptr),
        dlg_template,
        parent,
        about_dlg_proc,
        reinterpret_cast<LPARAM>(&state)
    );
}

```

`plugin/src/ui/about_dialog.h`:

```h
#pragma once

#include <cstdint>
#include <windows.h>

/// @brief Show the about dialog (modal).
/// @param parent Parent window handle
/// @param is_server_running Whether the MCP server is currently running
/// @param host Current server host
/// @param port Current server port
void show_about_dialog(HWND parent, bool is_server_running, const char* host, uint16_t port);

```

`plugin/src/ui/settings_dialog.cpp`:

```cpp
#include "ui/settings_dialog.h"

#include <cstdio>
#include <cstring>
#include <cstdlib>

// Control IDs
static constexpr WORD IDC_HOST_LABEL   = 100;
static constexpr WORD IDC_HOST_EDIT    = 101;
static constexpr WORD IDC_PORT_LABEL   = 102;
static constexpr WORD IDC_PORT_EDIT    = 103;
static constexpr WORD IDC_AUTOSTART    = 104;
static constexpr WORD IDC_SEPARATOR    = 105;
static constexpr WORD IDC_SAVE_BTN     = IDOK;
static constexpr WORD IDC_CANCEL_BTN   = IDCANCEL;

// ============================================================================
// In-memory dialog template builder
// ============================================================================

static LPWORD align_dword(LPWORD ptr) {
    auto addr = reinterpret_cast<uintptr_t>(ptr);
    addr = (addr + 3) & ~static_cast<uintptr_t>(3);
    return reinterpret_cast<LPWORD>(addr);
}

static LPWORD write_wide_string(LPWORD ptr, const char* str) {
    int len = MultiByteToWideChar(CP_ACP, 0, str, -1, reinterpret_cast<LPWSTR>(ptr), 128);
    return ptr + len;
}

static LPWORD add_dialog_item(
    LPWORD ptr,
    DWORD style,
    short x, short y, short cx, short cy,
    WORD id,
    WORD class_atom,
    const char* text
) {
    ptr = align_dword(ptr);

    auto* item = reinterpret_cast<DLGITEMTEMPLATE*>(ptr);
    item->style = style | WS_CHILD | WS_VISIBLE;
    item->dwExtendedStyle = 0;
    item->x = x;
    item->y = y;
    item->cx = cx;
    item->cy = cy;
    item->id = id;

    ptr = reinterpret_cast<LPWORD>(item + 1);

    *ptr++ = 0xFFFF;
    *ptr++ = class_atom;

    ptr = write_wide_string(ptr, text);

    // Creation data (none)
    *ptr++ = 0;

    return ptr;
}

/// @brief Build the settings dialog template with Segoe UI 9pt font
static LPDLGTEMPLATE build_settings_template() {
    static BYTE buffer[2048];
    std::memset(buffer, 0, sizeof(buffer));

    auto* dlg = reinterpret_cast<LPDLGTEMPLATE>(buffer);
    dlg->style = DS_MODALFRAME | DS_CENTER | DS_SETFONT
               | WS_POPUP | WS_CAPTION | WS_SYSMENU;
    dlg->dwExtendedStyle = 0;
    dlg->cdit = 8;  // 2 labels + 2 edits + checkbox + separator + 2 buttons
    dlg->x = 0;
    dlg->y = 0;
    dlg->cx = 160;
    dlg->cy = 82;

    auto* ptr = reinterpret_cast<LPWORD>(dlg + 1);

    // Menu (none)
    *ptr++ = 0;
    // Class (default)
    *ptr++ = 0;
    // Title
    ptr = write_wide_string(ptr, "MCP Server Settings");

    // Font (DS_SETFONT): point size + face name
    *ptr++ = 9;  // 9pt
    ptr = write_wide_string(ptr, "Segoe UI");

    // --- Controls ---
    // Row 1: Host
    ptr = add_dialog_item(ptr,
        SS_RIGHT, 7, 9, 22, 8,
        IDC_HOST_LABEL, 0x0082, "Host:");

    ptr = add_dialog_item(ptr,
        ES_AUTOHSCROLL | WS_BORDER | WS_TABSTOP, 33, 7, 120, 12,
        IDC_HOST_EDIT, 0x0081, "");

    // Row 2: Port
    ptr = add_dialog_item(ptr,
        SS_RIGHT, 7, 25, 22, 8,
        IDC_PORT_LABEL, 0x0082, "Port:");

    ptr = add_dialog_item(ptr,
        ES_AUTOHSCROLL | ES_NUMBER | WS_BORDER | WS_TABSTOP, 33, 23, 40, 12,
        IDC_PORT_EDIT, 0x0081, "");

    // Row 3: Auto-start checkbox
    ptr = add_dialog_item(ptr,
        BS_AUTOCHECKBOX | WS_TABSTOP, 7, 41, 146, 10,
        IDC_AUTOSTART, 0x0080, "Auto-start server on plugin load");

    // Etched separator line
    ptr = add_dialog_item(ptr,
        SS_ETCHEDHORZ, 7, 56, 146, 1,
        IDC_SEPARATOR, 0x0082, "");

    // Buttons row (right-aligned)
    ptr = add_dialog_item(ptr,
        BS_DEFPUSHBUTTON | WS_TABSTOP, 56, 63, 45, 14,
        IDC_SAVE_BTN, 0x0080, "Save");

    ptr = add_dialog_item(ptr,
        BS_PUSHBUTTON | WS_TABSTOP, 106, 63, 45, 14,
        IDC_CANCEL_BTN, 0x0080, "Cancel");

    return dlg;
}

// ============================================================================
// Dialog procedure
// ============================================================================

static INT_PTR CALLBACK settings_dlg_proc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam) {
    switch (msg) {
    case WM_INITDIALOG: {
        auto* settings = reinterpret_cast<s_plugin_settings*>(lparam);
        SetWindowLongPtrA(hdlg, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(settings));

        SetDlgItemTextA(hdlg, IDC_HOST_EDIT, settings->host);

        char port_buf[16];
        std::snprintf(port_buf, sizeof(port_buf), "%u", settings->port);
        SetDlgItemTextA(hdlg, IDC_PORT_EDIT, port_buf);

        CheckDlgButton(hdlg, IDC_AUTOSTART,
            settings->auto_start ? BST_CHECKED : BST_UNCHECKED);

        return TRUE;
    }

    case WM_COMMAND:
        switch (LOWORD(wparam)) {
        case IDC_SAVE_BTN: {
            auto* settings = reinterpret_cast<s_plugin_settings*>(
                GetWindowLongPtrA(hdlg, GWLP_USERDATA));

            GetDlgItemTextA(hdlg, IDC_HOST_EDIT, settings->host, sizeof(settings->host));

            char port_buf[16];
            GetDlgItemTextA(hdlg, IDC_PORT_EDIT, port_buf, sizeof(port_buf));
            int port_val = std::atoi(port_buf);
            if (port_val < 1 || port_val > 65535) {
                MessageBoxA(hdlg, "Port must be between 1 and 65535.",
                    "Invalid Port", MB_OK | MB_ICONWARNING);
                return TRUE;
            }
            settings->port = static_cast<uint16_t>(port_val);

            settings->auto_start =
                (IsDlgButtonChecked(hdlg, IDC_AUTOSTART) == BST_CHECKED);

            EndDialog(hdlg, IDOK);
            return TRUE;
        }

        case IDC_CANCEL_BTN:
            EndDialog(hdlg, IDCANCEL);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        EndDialog(hdlg, IDCANCEL);
        return TRUE;
    }

    return FALSE;
}

// ============================================================================
// Public API
// ============================================================================

int show_settings_dialog(HWND parent, s_plugin_settings& settings) {
    s_plugin_settings working_copy = settings;

    auto* dlg_template = build_settings_template();
    auto result = DialogBoxIndirectParamA(
        GetModuleHandleA(nullptr),
        dlg_template,
        parent,
        settings_dlg_proc,
        reinterpret_cast<LPARAM>(&working_copy)
    );

    if (result == IDOK) {
        settings = working_copy;
    }

    return static_cast<int>(result);
}

```

`plugin/src/ui/settings_dialog.h`:

```h
#pragma once

#include <windows.h>
#include "plugin_main.h"

/// @brief Show the settings dialog (modal). Returns IDOK if user saved, IDCANCEL otherwise.
/// @param parent Parent window handle
/// @param settings Settings struct to read from / write into on save
int show_settings_dialog(HWND parent, s_plugin_settings& settings);

```

`plugin/src/util/format_utils.cpp`:

```cpp
#include "util/format_utils.h"

// All format_utils functions are inline in the header.
// This TU exists to ensure the header compiles cleanly and
// to serve as an anchor for any future non-inline helpers.

```

`plugin/src/util/format_utils.h`:

```h
#pragma once

#include <string>
#include <cstdint>
#include <vector>
#include <sstream>
#include <iomanip>

#include "_plugin_types.h"

namespace format_utils {

    // Format a duint address as hex string with 0x prefix
    [[nodiscard]] inline std::string format_address(duint addr) {
#ifdef _WIN64
        char buf[32];
        snprintf(buf, sizeof(buf), "0x%016llX", static_cast<unsigned long long>(addr));
#else
        char buf[16];
        snprintf(buf, sizeof(buf), "0x%08X", static_cast<unsigned int>(addr));
#endif
        return buf;
    }

    // Format a duint value as hex string without prefix
    [[nodiscard]] inline std::string format_hex(duint value) {
#ifdef _WIN64
        char buf[32];
        snprintf(buf, sizeof(buf), "%llX", static_cast<unsigned long long>(value));
#else
        char buf[16];
        snprintf(buf, sizeof(buf), "%X", static_cast<unsigned int>(value));
#endif
        return buf;
    }

    // Format bytes as hex string (space-separated)
    [[nodiscard]] inline std::string format_bytes_hex(const uint8_t* data, size_t size) {
        std::ostringstream oss;
        for (size_t i = 0; i < size; ++i) {
            if (i > 0) oss << ' ';
            oss << std::hex << std::uppercase << std::setw(2) << std::setfill('0')
                << static_cast<int>(data[i]);
        }
        return oss.str();
    }

    // Format bytes as contiguous hex string (no spaces)
    [[nodiscard]] inline std::string format_bytes_compact(const uint8_t* data, size_t size) {
        std::ostringstream oss;
        for (size_t i = 0; i < size; ++i) {
            oss << std::hex << std::uppercase << std::setw(2) << std::setfill('0')
                << static_cast<int>(data[i]);
        }
        return oss.str();
    }

    // Parse hex string to bytes
    [[nodiscard]] inline std::vector<uint8_t> parse_hex_bytes(const std::string& hex) {
        std::vector<uint8_t> bytes;
        std::string clean;

        // Strip spaces, 0x prefix, commas
        for (size_t i = 0; i < hex.size(); ++i) {
            char c = hex[i];
            if (c == ' ' || c == ',' || c == '\t' || c == '\n') continue;
            if (c == '0' && i + 1 < hex.size() && (hex[i + 1] == 'x' || hex[i + 1] == 'X')) {
                ++i;
                continue;
            }
            clean += c;
        }

        for (size_t i = 0; i + 1 < clean.size(); i += 2) {
            auto byte_str = clean.substr(i, 2);
            bytes.push_back(static_cast<uint8_t>(std::stoul(byte_str, nullptr, 16)));
        }

        return bytes;
    }

    // Parse address string (supports 0x prefix and plain hex)
    [[nodiscard]] inline duint parse_address(const std::string& addr_str) {
        if (addr_str.empty()) return 0;

        std::string clean = addr_str;
        if (clean.size() > 2 && clean[0] == '0' && (clean[1] == 'x' || clean[1] == 'X')) {
            clean = clean.substr(2);
        }

#ifdef _WIN64
        return static_cast<duint>(std::stoull(clean, nullptr, 16));
#else
        return static_cast<duint>(std::stoul(clean, nullptr, 16));
#endif
    }

    // Format DWORD protection flags as readable string
    [[nodiscard]] inline std::string format_protection(DWORD protect) {
        std::string result;
        switch (protect & 0xFF) {
            case PAGE_NOACCESS:          result = "PAGE_NOACCESS"; break;
            case PAGE_READONLY:          result = "PAGE_READONLY"; break;
            case PAGE_READWRITE:         result = "PAGE_READWRITE"; break;
            case PAGE_WRITECOPY:         result = "PAGE_WRITECOPY"; break;
            case PAGE_EXECUTE:           result = "PAGE_EXECUTE"; break;
            case PAGE_EXECUTE_READ:      result = "PAGE_EXECUTE_READ"; break;
            case PAGE_EXECUTE_READWRITE: result = "PAGE_EXECUTE_READWRITE"; break;
            case PAGE_EXECUTE_WRITECOPY: result = "PAGE_EXECUTE_WRITECOPY"; break;
            default:                     result = "UNKNOWN"; break;
        }
        if (protect & PAGE_GUARD)   result += " | PAGE_GUARD";
        if (protect & PAGE_NOCACHE) result += " | PAGE_NOCACHE";
        return result;
    }

    // Format memory state
    [[nodiscard]] inline std::string format_mem_state(DWORD state) {
        switch (state) {
            case MEM_COMMIT:  return "MEM_COMMIT";
            case MEM_RESERVE: return "MEM_RESERVE";
            case MEM_FREE:    return "MEM_FREE";
            default:          return "UNKNOWN";
        }
    }

    // Format memory type
    [[nodiscard]] inline std::string format_mem_type(DWORD type) {
        switch (type) {
            case MEM_IMAGE:   return "MEM_IMAGE";
            case MEM_MAPPED:  return "MEM_MAPPED";
            case MEM_PRIVATE: return "MEM_PRIVATE";
            default:          return "UNKNOWN";
        }
    }

} // namespace format_utils

```

`plugin/vcpkg.json`:

```json
{
  "name": "x64dbg-mcp",
  "version": "1.0.0",
  "description": "x64dbg MCP Server Plugin",
  "dependencies": [
    "nlohmann-json"
  ]
}

```

`server/README.md`:

```md
# x64dbg MCP Server

[![npm version](https://img.shields.io/npm/v/x64dbg-mcp-server)](https://www.npmjs.com/package/x64dbg-mcp-server)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Node.js](https://img.shields.io/badge/node-%3E%3D18-brightgreen)](https://nodejs.org/)

An [MCP server](https://modelcontextprotocol.io/) that gives AI assistants full control over the [x64dbg](https://x64dbg.com/) debugger. **23 mega-tools** covering 151 REST endpoints via Zod discriminated unions - stepping, breakpoints, memory, disassembly, tracing, anti-debug bypasses, control flow analysis, PE dumping, and more.

## Quick Start

### Prerequisites

1. **x64dbg** - [Download latest snapshot](https://github.com/x64dbg/x64dbg/releases)
2. **Node.js** >= 18 - [Download](https://nodejs.org/)
3. **MCP plugin** - [Download from releases](https://github.com/bromoket/x64dbg_mcp/releases) (`x64dbg_mcp.dp64` and/or `x64dbg_mcp.dp32`)

### Step 1: Install the Plugin

Download the plugin DLLs from [GitHub Releases](https://github.com/bromoket/x64dbg_mcp/releases) and copy them to your x64dbg plugins directories:

- `x64dbg_mcp.dp64` goes in `x64/plugins/`
- `x64dbg_mcp.dp32` goes in `x32/plugins/`

Start x64dbg. You should see: `[MCP] x64dbg MCP Server started on 127.0.0.1:27042`

### Step 2: Add to Your AI Client

<details open>
<summary><b>Claude Code</b></summary>

Add to `.claude/settings.json` (project-level) or `~/.claude/settings.json` (global):

```json
{
  "mcpServers": {
    "x64dbg": {
      "type": "stdio",
      "command": "cmd",
      "args": ["/c", "npx", "-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Claude Desktop</b></summary>

Add to `claude_desktop_config.json`:

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Cursor</b></summary>

Add to `.cursor/mcp.json` (project-level) or `~/.cursor/mcp.json` (global):

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Windsurf</b></summary>

Add to `~/.codeium/windsurf/mcp_config.json`:

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Cline (VSCode extension)</b></summary>

Open Cline settings > MCP Servers > Configure, then add to `cline_mcp_settings.json`:

```json
{
  "mcpServers": {
    "x64dbg": {
      "command": "npx",
      "args": ["-y", "x64dbg-mcp-server"]
    }
  }
}
```

</details>

<details>
<summary><b>Any other MCP client</b></summary>

The server uses **stdio transport**. Spawn it as a child process:

```bash
npx -y x64dbg-mcp-server
```

Communicate over stdin/stdout using the [MCP protocol](https://modelcontextprotocol.io/).

</details>

Or install globally instead of using npx:

```bash
npm install -g x64dbg-mcp-server
```

### Step 3: Start Debugging

Open any executable in x64dbg, then talk to your AI assistant:

```
"Set a breakpoint on CreateFileW and run the program"
"Disassemble the current function and explain what it does"
"Search for the byte pattern 48 8B ?? 48 85 C0 in the main module"
"Read 64 bytes at the address pointed to by RDI"
"Hide the debugger and bypass the anti-debug checks"
"Trace into the VM dispatcher and log all instructions to a file"
```

## How It Works

```
 MCP Client  ──stdio──>  TypeScript MCP Server  ──HTTP──>  C++ Plugin (inside x64dbg)
 (Claude,                 23 mega-tools                     151 REST endpoints
  Cursor)                 Zod validation                    127.0.0.1:27042
```

- **C++ Plugin** runs inside x64dbg as a REST API on `127.0.0.1:27042`, wrapping the x64dbg Bridge/Plugin SDK with 151 JSON endpoints.
- **TypeScript MCP Server** (this package) implements the MCP protocol over stdio. 23 mega-tools use Zod discriminated unions to validate parameters and route to the correct endpoint.

The server waits up to 2 minutes for the plugin, health-checks every 15 seconds, and auto-reconnects if x64dbg restarts. Requests retry up to 3 times.

## Tool Reference (23 Mega-Tools)

Each tool accepts an `action` parameter that selects the specific operation.

### Debugger Control

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_debug` | `run`, `pause`, `force_pause`, `step_into`, `step_over`, `step_out`, `stop_debug`, `restart_debug`, `run_to_address`, `state` | Control execution flow and query debugger state |
| `x64dbg_command` | `execute`, `script`, `evaluate`, `format`, `set_init_script`, `get_init_script`, `get_hash`, `get_events` | Execute raw x64dbg commands, batch scripts, and expression evaluation |

### CPU & Memory

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_registers` | `get_all`, `get_specific`, `get_flags`, `get_avx512`, `set` | Read/write CPU registers including GPR, flags, and AVX-512 |
| `x64dbg_memory` | `read`, `write`, `info`, `is_valid`, `is_code`, `allocate`, `free`, `protect`, `map`, `update_map` | Full memory operations: read, write, allocate, protect, and memory map |
| `x64dbg_stack` | `get_call_stack`, `read`, `pointers`, `seh_chain`, `return_address`, `comment` | Call stack unwinding, raw stack reads, SEH chain, return address |

### Code Analysis

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_disassembly` | `at_address`, `function`, `info`, `assemble` | Disassemble instructions, whole functions, or assemble new code |
| `x64dbg_analysis` | `function`, `xrefs_to`, `xrefs_from`, `basic_blocks`, `source`, `mnemonic_brief` | Cross-references, function boundaries, basic blocks, source mapping |
| `x64dbg_control_flow` | `cfg`, `branch_dest`, `is_jump_taken`, `loops`, `func_type`, `add_function`, `delete_function` | Control flow graph, branch analysis, loop detection |
| `x64dbg_database` | `constants`, `error_codes`, `structs`, `strings` | Query x64dbg's analysis database |
| `x64dbg_address_convert` | `va_to_file`, `file_to_va` | Convert between virtual addresses and file offsets |
| `x64dbg_watchdog` | *(id parameter)* | Check if a watch expression watchdog triggered |

### Breakpoints & Tracing

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_breakpoints` | `set_software`, `set_hardware`, `set_memory`, `delete`, `enable`, `disable`, `toggle`, `set_condition`, `set_log`, `reset_hit_count`, `get`, `list`, `configure`, `configure_batch` | Full breakpoint management: software, hardware, memory, conditional, logging, batch |
| `x64dbg_tracing` | `into`, `over`, `run`, `stop`, `animate`, `conditional_run`, `log_setup`, `hitcount`, `type`, `set_type` | Execution tracing, trace logging, hit counters |
| `x64dbg_exceptions` | `set`, `delete`, `list`, `list_codes`, `skip` | Exception breakpoints and exception handling |

### Symbols & Annotations

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_symbols` | `resolve`, `address`, `search`, `list_module`, `get_label`, `set_label`, `get_comment`, `set_comment`, `bookmark` | Symbol resolution, labels, comments, bookmarks |
| `x64dbg_search` | `pattern`, `string`, `string_at`, `symbol_auto_complete`, `encode_type` | AOB/byte pattern scan, string search, symbol autocomplete |
| `x64dbg_modules` | `list`, `get_info`, `get_base`, `get_section`, `get_party` | Loaded modules, base addresses, sections |

### Process & System

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_process` | `basic`, `detailed`, `cmdline`, `elevated`, `dbversion`, `set_cmdline` | Process info, PID, PEB, elevation status |
| `x64dbg_threads` | `list`, `current`, `count`, `info`, `teb`, `name`, `switch`, `suspend`, `resume` | Thread enumeration, TEB, thread control |
| `x64dbg_handles` | `list_handles`, `list_tcp`, `list_windows`, `list_heaps`, `get_name`, `close` | Handles, TCP connections, windows, heaps |
| `x64dbg_antidebug` | `peb`, `teb`, `dep`, `hide_debugger` | PEB/TEB inspection, DEP, hide debugger |

### Patching & Dumping

| Tool | Actions | Description |
|------|---------|-------------|
| `x64dbg_patches` | `list`, `apply`, `restore`, `export` | Apply byte patches, restore originals, export patched module |
| `x64dbg_dumping` | `pe_header`, `sections`, `imports`, `exports`, `entry_point`, `relocations`, `dump_module`, `fix_iat`, `export_patch_file` | PE analysis, module dumping, IAT reconstruction, patch file export |

## Configuration

| Variable | Default | Description |
|----------|---------|-------------|
| `X64DBG_MCP_HOST` | `127.0.0.1` | Plugin REST API host |
| `X64DBG_MCP_PORT` | `27042` | Plugin REST API port |
| `X64DBG_MCP_TIMEOUT` | `30000` | Request timeout (ms) |
| `X64DBG_MCP_RETRIES` | `3` | Retry count on transient failures |

### Plugin Commands

Control the REST API from the x64dbg command bar:

```
mcpserver start     Start the HTTP server
mcpserver stop      Stop the HTTP server
mcpserver status    Show server status and port
```

The plugin also provides GUI dialogs accessible from `Plugins > x64dbg MCP Server`:

- **Settings...** — configure host, port, and auto-start (persisted via BridgeSetting)
- **About...** — version, live server status (green/red), GitHub link, Discord contact

## Troubleshooting

### "Connection refused" or server can't reach plugin

1. Make sure x64dbg is running with a target loaded
2. Verify the plugin is in the correct `plugins/` directory
3. Check the x64dbg log for `[MCP] x64dbg MCP Server started on 127.0.0.1:27042`
4. Test manually: `curl http://127.0.0.1:27042/api/health`

### "Waiting for x64dbg plugin..." hangs

The server waits up to 2 minutes for the plugin. Start x64dbg **before** your MCP client, or restart the client after x64dbg is running.

### Tools return errors about debugger state

- **"Debugger must be paused"**: Inspection tools need paused state - hit a breakpoint or use pause first
- **"No active debug session"**: Load a target in x64dbg (`File > Open`)
- **"Debugger must be running"**: `pause`/`force_pause` need the target running

### 32-bit vs 64-bit

| Target | Debugger | Plugin |
|--------|----------|--------|
| 64-bit | x64dbg | `x64dbg_mcp.dp64` |
| 32-bit | x32dbg | `x64dbg_mcp.dp32` |

Both use the same MCP server.

## Security

- The C++ plugin binds to `127.0.0.1` only - no remote access
- The MCP server communicates exclusively via stdio
- All HTTP traffic stays on localhost - no data leaves your machine

## Links

- [GitHub Repository](https://github.com/bromoket/x64dbg_mcp) - source code, C++ plugin build instructions
- [Plugin Releases](https://github.com/bromoket/x64dbg_mcp/releases) - prebuilt plugin DLLs
- [x64dbg](https://x64dbg.com/) - the debugger

## Author

**bromo** - [GitHub](https://github.com/bromoket)

Built with [Claude Code](https://claude.ai/claude-code) by Anthropic.

## License

MIT

```

`server/package-lock.json`:

```json
{
  "name": "x64dbg-mcp-server",
  "version": "1.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "x64dbg-mcp-server",
      "version": "1.1.0",
      "license": "MIT",
      "dependencies": {
        "@modelcontextprotocol/sdk": "^1.12.1",
        "zod": "^3.25.1"
      },
      "bin": {
        "x64dbg-mcp-server": "dist/index.js"
      },
      "devDependencies": {
        "@types/node": "^22.15.0",
        "typescript": "^5.8.0"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@hono/node-server": {
      "version": "1.19.9",
      "resolved": "https://registry.npmjs.org/@hono/node-server/-/node-server-1.19.9.tgz",
      "integrity": "sha512-vHL6w3ecZsky+8P5MD+eFfaGTyCeOHUIFYMGpQGbrBTSmNNoxv0if69rEZ5giu36weC5saFuznL411gRX7bJDw==",
      "license": "MIT",
      "engines": {
        "node": ">=18.14.1"
      },
      "peerDependencies": {
        "hono": "^4"
      }
    },
    "node_modules/@modelcontextprotocol/sdk": {
      "version": "1.26.0",
      "resolved": "https://registry.npmjs.org/@modelcontextprotocol/sdk/-/sdk-1.26.0.tgz",
      "integrity": "sha512-Y5RmPncpiDtTXDbLKswIJzTqu2hyBKxTNsgKqKclDbhIgg1wgtf1fRuvxgTnRfcnxtvvgbIEcqUOzZrJ6iSReg==",
      "license": "MIT",
      "dependencies": {
        "@hono/node-server": "^1.19.9",
        "ajv": "^8.17.1",
        "ajv-formats": "^3.0.1",
        "content-type": "^1.0.5",
        "cors": "^2.8.5",
        "cross-spawn": "^7.0.5",
        "eventsource": "^3.0.2",
        "eventsource-parser": "^3.0.0",
        "express": "^5.2.1",
        "express-rate-limit": "^8.2.1",
        "hono": "^4.11.4",
        "jose": "^6.1.3",
        "json-schema-typed": "^8.0.2",
        "pkce-challenge": "^5.0.0",
        "raw-body": "^3.0.0",
        "zod": "^3.25 || ^4.0",
        "zod-to-json-schema": "^3.25.1"
      },
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "@cfworker/json-schema": "^4.1.1",
        "zod": "^3.25 || ^4.0"
      },
      "peerDependenciesMeta": {
        "@cfworker/json-schema": {
          "optional": true
        },
        "zod": {
          "optional": false
        }
      }
    },
    "node_modules/@types/node": {
      "version": "22.19.11",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.19.11.tgz",
      "integrity": "sha512-BH7YwL6rA93ReqeQS1c4bsPpcfOmJasG+Fkr6Y59q83f9M1WcBRHR2vM+P9eOisYRcN3ujQoiZY8uk5W+1WL8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/accepts": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz",
      "integrity": "sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "^3.0.0",
        "negotiator": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/ajv": {
      "version": "8.18.0",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-8.18.0.tgz",
      "integrity": "sha512-PlXPeEWMXMZ7sPYOHqmDyCJzcfNrUr3fGNKtezX14ykXOEIvyK81d+qydx89KY5O71FKMPaQ2vBfBFI5NHR63A==",
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.3",
        "fast-uri": "^3.0.1",
        "json-schema-traverse": "^1.0.0",
        "require-from-string": "^2.0.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ajv-formats": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/ajv-formats/-/ajv-formats-3.0.1.tgz",
      "integrity": "sha512-8iUql50EUR+uUcdRQ3HDqa6EVyo3docL8g5WJ3FNcWmu62IbkGUue/pEyLBW8VGKKucTPgqeks4fIU1DA4yowQ==",
      "license": "MIT",
      "dependencies": {
        "ajv": "^8.0.0"
      },
      "peerDependencies": {
        "ajv": "^8.0.0"
      },
      "peerDependenciesMeta": {
        "ajv": {
          "optional": true
        }
      }
    },
    "node_modules/body-parser": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-2.2.2.tgz",
      "integrity": "sha512-oP5VkATKlNwcgvxi0vM0p/D3n2C3EReYVX+DNYs5TjZFn/oQt2j+4sVJtSMr18pdRr8wjTcBl6LoV+FUwzPmNA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "^3.1.2",
        "content-type": "^1.0.5",
        "debug": "^4.4.3",
        "http-errors": "^2.0.0",
        "iconv-lite": "^0.7.0",
        "on-finished": "^2.4.1",
        "qs": "^6.14.1",
        "raw-body": "^3.0.1",
        "type-is": "^2.0.1"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/content-disposition": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.1.tgz",
      "integrity": "sha512-oIXISMynqSqm241k6kcQ5UwttDILMK4BiurCfGEREw6+X9jkkpEe5T9FZaApyLGGOnFuyMWZpdolTXMtvEJ08Q==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz",
      "integrity": "sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.6.0"
      }
    },
    "node_modules/cors": {
      "version": "2.8.6",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.6.tgz",
      "integrity": "sha512-tJtZBBHA6vjIAaF6EnIaq6laBBP9aq/Y3ouVJjEfoHbRBcHBAHYcMh/w8LDrk2PvIMMq8gmopa5D4V8RmbrxGw==",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "license": "MIT"
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "license": "MIT"
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/eventsource": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/eventsource/-/eventsource-3.0.7.tgz",
      "integrity": "sha512-CRT1WTyuQoD771GW56XEZFQ/ZoSfWid1alKGDYMmkt2yl8UXrVR4pspqWNEcqKvVIzg6PAltWjxcSSPrboA4iA==",
      "license": "MIT",
      "dependencies": {
        "eventsource-parser": "^3.0.1"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/eventsource-parser": {
      "version": "3.0.6",
      "resolved": "https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-3.0.6.tgz",
      "integrity": "sha512-Vo1ab+QXPzZ4tCa8SwIHJFaSzy4R6SHf7BY79rFBDf0idraZWAkYrDjDj8uWaSm3S2TK+hJ7/t1CEmZ7jXw+pg==",
      "license": "MIT",
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/express": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/express/-/express-5.2.1.tgz",
      "integrity": "sha512-hIS4idWWai69NezIdRt2xFVofaF4j+6INOpJlVOLDO8zXGpUVEVzIYk12UUi2JzjEzWL3IOAxcTubgz9Po0yXw==",
      "license": "MIT",
      "dependencies": {
        "accepts": "^2.0.0",
        "body-parser": "^2.2.1",
        "content-disposition": "^1.0.0",
        "content-type": "^1.0.5",
        "cookie": "^0.7.1",
        "cookie-signature": "^1.2.1",
        "debug": "^4.4.0",
        "depd": "^2.0.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "finalhandler": "^2.1.0",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "merge-descriptors": "^2.0.0",
        "mime-types": "^3.0.0",
        "on-finished": "^2.4.1",
        "once": "^1.4.0",
        "parseurl": "^1.3.3",
        "proxy-addr": "^2.0.7",
        "qs": "^6.14.0",
        "range-parser": "^1.2.1",
        "router": "^2.2.0",
        "send": "^1.1.0",
        "serve-static": "^2.2.0",
        "statuses": "^2.0.1",
        "type-is": "^2.0.1",
        "vary": "^1.1.2"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/express-rate-limit": {
      "version": "8.2.1",
      "resolved": "https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-8.2.1.tgz",
      "integrity": "sha512-PCZEIEIxqwhzw4KF0n7QF4QqruVTcF73O5kFKUnGOyjbCCgizBBiFaYpd/fnBLUMPw/BWw9OsiN7GgrNYr7j6g==",
      "license": "MIT",
      "dependencies": {
        "ip-address": "10.0.1"
      },
      "engines": {
        "node": ">= 16"
      },
      "funding": {
        "url": "https://github.com/sponsors/express-rate-limit"
      },
      "peerDependencies": {
        "express": ">= 4.11"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "license": "MIT"
    },
    "node_modules/fast-uri": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/fast-uri/-/fast-uri-3.1.0.tgz",
      "integrity": "sha512-iPeeDKJSWf4IEOasVVrknXpaBV0IApz/gp7S2bb7Z4Lljbl2MGJRqInZiUrQwV16cpzw/D3S5j5Julj/gT52AA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/fastify"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fastify"
        }
      ],
      "license": "BSD-3-Clause"
    },
    "node_modules/finalhandler": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-2.1.1.tgz",
      "integrity": "sha512-S8KoZgRZN+a5rNwqTxlZZePjT/4cnm0ROV70LedRHZ0p8u9fRID0hJUZQpkKLzro8LfmC8sx23bY6tVNxv8pQA==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "on-finished": "^2.4.1",
        "parseurl": "^1.3.3",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz",
      "integrity": "sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/hono": {
      "version": "4.11.10",
      "resolved": "https://registry.npmjs.org/hono/-/hono-4.11.10.tgz",
      "integrity": "sha512-kyWP5PAiMooEvGrA9jcD3IXF7ATu8+o7B3KCbPXid5se52NPqnOpM/r9qeW2heMnOekF4kqR1fXJqCYeCLKrZg==",
      "license": "MIT",
      "engines": {
        "node": ">=16.9.0"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
      "integrity": "sha512-4FbRdAX+bSdmo4AUFuS0WNiPz8NgFt+r8ThgNWmlrjQjt1Q7ZR9+zTlce2859x4KSXrwIsaeTqDoKQmtP8pLmQ==",
      "license": "MIT",
      "dependencies": {
        "depd": "~2.0.0",
        "inherits": "~2.0.4",
        "setprototypeof": "~1.2.0",
        "statuses": "~2.0.2",
        "toidentifier": "~1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.7.2.tgz",
      "integrity": "sha512-im9DjEDQ55s9fL4EYzOAv0yMqmMBSZp6G0VvFyTMPKWxiSBHUj9NW/qqLmXUwXrrM7AvqSlTCfvqRb0cM8yYqw==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ip-address": {
      "version": "10.0.1",
      "resolved": "https://registry.npmjs.org/ip-address/-/ip-address-10.0.1.tgz",
      "integrity": "sha512-NWv9YLW4PoW2B7xtzaS3NCot75m6nK7Icdv0o3lfMceJVRfSoQwqD4wEH5rLwoKJwUiZ/rfpiVBhnaF0FK4HoA==",
      "license": "MIT",
      "engines": {
        "node": ">= 12"
      }
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-promise": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz",
      "integrity": "sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==",
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "license": "ISC"
    },
    "node_modules/jose": {
      "version": "6.1.3",
      "resolved": "https://registry.npmjs.org/jose/-/jose-6.1.3.tgz",
      "integrity": "sha512-0TpaTfihd4QMNwrz/ob2Bp7X04yuxJkjRGi4aKmOqwhov54i6u79oCv7T+C7lo70MKH6BesI3vscD1yb/yzKXQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/panva"
      }
    },
    "node_modules/json-schema-traverse": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
      "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
      "license": "MIT"
    },
    "node_modules/json-schema-typed": {
      "version": "8.0.2",
      "resolved": "https://registry.npmjs.org/json-schema-typed/-/json-schema-typed-8.0.2.tgz",
      "integrity": "sha512-fQhoXdcvc3V28x7C7BMs4P5+kNlgUURe2jmUT1T//oBRMDrqy1QPelJimwZGo7Hg9VPV3EQV5Bnq4hbFy2vetA==",
      "license": "BSD-2-Clause"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz",
      "integrity": "sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz",
      "integrity": "sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/mime-db": {
      "version": "1.54.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.54.0.tgz",
      "integrity": "sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-3.0.2.tgz",
      "integrity": "sha512-Lbgzdk0h4juoQ9fCKXW4by0UJqj+nOOrI9MJ1sSj4nI8aI2eo1qmvQEie4VD1glsS250n15LsWsYtCugiStS5A==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "^1.54.0"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/negotiator": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz",
      "integrity": "sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "8.3.0",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.3.0.tgz",
      "integrity": "sha512-7jdwVIRtsP8MYpdXSwOS0YdD0Du+qOoF/AEPIt88PcCFrZCzx41oxku1jD88hZBwbNUIEfpqvuhjFaMAqMTWnA==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/pkce-challenge": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/pkce-challenge/-/pkce-challenge-5.0.1.tgz",
      "integrity": "sha512-wQ0b/W4Fr01qtpHlqSqspcj3EhBvimsdh0KlHhH8HRZnMsEa0ea2fTULOXOS9ccQr3om+GcGRk4e+isrZWV8qQ==",
      "license": "MIT",
      "engines": {
        "node": ">=16.20.0"
      }
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/qs": {
      "version": "6.15.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.15.0.tgz",
      "integrity": "sha512-mAZTtNCeetKMH+pSjrb76NAM8V9a05I9aBZOHztWy/UqcJdQYNsf59vrRKWnojAT9Y+GbIvoTBC++CPHqpDBhQ==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.2.tgz",
      "integrity": "sha512-K5zQjDllxWkf7Z5xJdV0/B0WTNqx6vxG70zJE4N0kBs4LovmEYWJzQGxC9bS9RAKu3bgM40lrd5zoLJ12MQ5BA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "~3.1.2",
        "http-errors": "~2.0.1",
        "iconv-lite": "~0.7.0",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/require-from-string": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/router": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/router/-/router-2.2.0.tgz",
      "integrity": "sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "depd": "^2.0.0",
        "is-promise": "^4.0.0",
        "parseurl": "^1.3.3",
        "path-to-regexp": "^8.0.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "license": "MIT"
    },
    "node_modules/send": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/send/-/send-1.2.1.tgz",
      "integrity": "sha512-1gnZf7DFcoIcajTjTwjwuDjzuz4PPcY2StKPlsGAQ1+YH20IRVrBaXSWmdjowTJ6u8Rc01PoYOGHXfP1mYcZNQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.3",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.1",
        "mime-types": "^3.0.2",
        "ms": "^2.1.3",
        "on-finished": "^2.4.1",
        "range-parser": "^1.2.1",
        "statuses": "^2.0.2"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/serve-static": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-2.2.1.tgz",
      "integrity": "sha512-xRXBn0pPqQTVQiC8wyQrKs2MOlX24zQ0POGaj0kultvoOCstBQM5yvOhAVSUwOMjQtTvsPWoNCHfPGwaaQJhTw==",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "parseurl": "^1.3.3",
        "send": "^1.2.0"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "license": "ISC"
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz",
      "integrity": "sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/type-is": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-2.0.1.tgz",
      "integrity": "sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==",
      "license": "MIT",
      "dependencies": {
        "content-type": "^1.0.5",
        "media-typer": "^1.1.0",
        "mime-types": "^3.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    },
    "node_modules/zod": {
      "version": "3.25.76",
      "resolved": "https://registry.npmjs.org/zod/-/zod-3.25.76.tgz",
      "integrity": "sha512-gzUt/qt81nXsFGKIFcC3YnfEAx5NkunCfnDlvuBSSFS02bcXu4Lmea0AFIUwbLWxWPx3d9p8S5QoaujKcNQxcQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    },
    "node_modules/zod-to-json-schema": {
      "version": "3.25.1",
      "resolved": "https://registry.npmjs.org/zod-to-json-schema/-/zod-to-json-schema-3.25.1.tgz",
      "integrity": "sha512-pM/SU9d3YAggzi6MtR4h7ruuQlqKtad8e9S0fmxcMi+ueAK5Korys/aWcV9LIIHTVbj01NdzxcnXSN+O74ZIVA==",
      "license": "ISC",
      "peerDependencies": {
        "zod": "^3.25 || ^4"
      }
    }
  }
}

```

`server/package.json`:

```json
{
  "name": "x64dbg-mcp-server",
  "version": "2.2.1",
  "description": "MCP server for x64dbg debugger - 23 mega-tools for AI-powered reverse engineering and debugging",
  "type": "module",
  "main": "dist/index.js",
  "bin": {
    "x64dbg-mcp-server": "dist/index.js"
  },
  "files": [
    "dist/**/*.js",
    "dist/**/*.d.ts",
    "dist/**/*.js.map"
  ],
  "scripts": {
    "build": "tsc",
    "prepublishOnly": "npm run build",
    "start": "node dist/index.js",
    "dev": "tsc --watch"
  },
  "keywords": [
    "mcp",
    "x64dbg",
    "debugger",
    "reverse-engineering",
    "model-context-protocol",
    "claude",
    "ai-debugging"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/bromoket/x64dbg_mcp.git",
    "directory": "server"
  },
  "homepage": "https://github.com/bromoket/x64dbg_mcp#readme",
  "bugs": {
    "url": "https://github.com/bromoket/x64dbg_mcp/issues"
  },
  "mcpName": "io.github.bromoket/x64dbg",
  "author": "bromo",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.12.1",
    "zod": "^3.25.1"
  },
  "devDependencies": {
    "@types/node": "^22.15.0",
    "typescript": "^5.8.0"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "license": "MIT"
}

```

`server/server.json`:

```json
{
  "$schema": "https://static.modelcontextprotocol.io/schemas/2025-12-11/server.schema.json",
  "name": "io.github.bromoket/x64dbg",
  "description": "MCP server for x64dbg debugger - 23 mega-tools for AI-powered reverse engineering and debugging",
  "repository": {
    "url": "https://github.com/bromoket/x64dbg_mcp",
    "source": "github"
  },
  "version": "2.2.1",
  "packages": [
    {
      "registryType": "npm",
      "identifier": "x64dbg-mcp-server",
      "version": "2.2.1",
      "transport": {
        "type": "stdio"
      },
      "environmentVariables": [
        {
          "description": "Host where the x64dbg plugin REST API listens",
          "isRequired": false,
          "format": "string",
          "isSecret": false,
          "name": "X64DBG_MCP_HOST"
        },
        {
          "description": "Port where the x64dbg plugin REST API listens",
          "isRequired": false,
          "format": "string",
          "isSecret": false,
          "name": "X64DBG_MCP_PORT"
        }
      ]
    }
  ]
}

```

`server/src/config.ts`:

```ts
export const config = {
  host: process.env.X64DBG_MCP_HOST ?? '127.0.0.1',
  port: parseInt(process.env.X64DBG_MCP_PORT ?? '27042', 10),
  timeout: parseInt(process.env.X64DBG_MCP_TIMEOUT ?? '30000', 10),
  retries: parseInt(process.env.X64DBG_MCP_RETRIES ?? '3', 10),
};

export function getBaseUrl(): string {
  return `http://${config.host}:${config.port}`;
}

```

`server/src/http_client.ts`:

```ts
import { config, getBaseUrl } from './config.js';

interface PluginResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: {
    code: number;
    message: string;
  };
}

type ConnectionState = 'connected' | 'disconnected' | 'reconnecting';

// How long to wait for the plugin to come online before failing a request
const WAIT_FOR_PLUGIN_TIMEOUT_MS = 120_000; // 2 minutes
const WAIT_POLL_INTERVAL_MS = 2_000;        // poll every 2s

export class HttpClient {
  private base_url: string;
  private state: ConnectionState = 'disconnected';
  private last_successful_request = 0;
  private consecutive_failures = 0;
  private health_check_interval: ReturnType<typeof setInterval> | null = null;

  constructor() {
    this.base_url = getBaseUrl();
    this.start_health_monitor();
  }

  get connection_state(): ConnectionState {
    return this.state;
  }

  async get<T = unknown>(path: string, params?: Record<string, string>): Promise<T> {
    const url = new URL(path, this.base_url);
    if (params) {
      for (const [key, value] of Object.entries(params)) {
        if (value !== undefined && value !== '') {
          url.searchParams.set(key, value);
        }
      }
    }

    return this.request<T>(url.toString(), { method: 'GET' });
  }

  async post<T = unknown>(path: string, body?: unknown): Promise<T> {
    const url = new URL(path, this.base_url);
    const options: RequestInit = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
    };

    if (body !== undefined) {
      options.body = JSON.stringify(body);
    }

    return this.request<T>(url.toString(), options);
  }

  destroy() {
    if (this.health_check_interval) {
      clearInterval(this.health_check_interval);
      this.health_check_interval = null;
    }
  }

  private start_health_monitor() {
    // Periodic health check every 15s to maintain connection awareness
    this.health_check_interval = setInterval(async () => {
      await this.check_health();
    }, 15_000);

    // Initial health check (non-blocking)
    this.check_health().catch(() => {});
  }

  private async check_health(): Promise<boolean> {
    try {
      const controller = new AbortController();
      const timeout_id = setTimeout(() => controller.abort(), 3000);

      const response = await fetch(`${this.base_url}/api/health`, {
        method: 'GET',
        signal: controller.signal,
      });

      clearTimeout(timeout_id);

      if (response.ok) {
        const was_disconnected = this.state !== 'connected';
        this.state = 'connected';
        this.consecutive_failures = 0;
        if (was_disconnected) {
          console.error(`[x64dbg-mcp] Plugin connection established at ${this.base_url}`);
        }
        return true;
      }
      return false;
    } catch {
      if (this.state === 'connected') {
        console.error('[x64dbg-mcp] Plugin connection lost, will reconnect automatically');
        this.state = 'disconnected';
      }
      return false;
    }
  }

  /**
   * Block until the plugin is reachable. Polls /api/health every 2s
   * for up to 2 minutes. This is the key fix: instead of failing
   * immediately when the plugin isn't running, we wait for it.
   */
  private async wait_for_connection(): Promise<void> {
    // Already connected - skip
    if (this.state === 'connected') return;

    // Quick check first
    if (await this.check_health()) return;

    // Plugin not available - enter wait loop
    this.state = 'reconnecting';
    console.error(
      `[x64dbg-mcp] Plugin not reachable at ${this.base_url}, waiting up to ${WAIT_FOR_PLUGIN_TIMEOUT_MS / 1000}s for it to come online...`
    );

    const deadline = Date.now() + WAIT_FOR_PLUGIN_TIMEOUT_MS;
    let poll_count = 0;

    while (Date.now() < deadline) {
      await new Promise(resolve => setTimeout(resolve, WAIT_POLL_INTERVAL_MS));
      poll_count++;

      if (await this.check_health()) {
        console.error(`[x64dbg-mcp] Plugin came online after ~${poll_count * 2}s`);
        return;
      }

      // Log progress every 10s
      if (poll_count % 5 === 0) {
        const elapsed = Math.round((Date.now() - (deadline - WAIT_FOR_PLUGIN_TIMEOUT_MS)) / 1000);
        const remaining = Math.round((deadline - Date.now()) / 1000);
        console.error(`[x64dbg-mcp] Still waiting for plugin... (${elapsed}s elapsed, ${remaining}s remaining)`);
      }
    }

    this.state = 'disconnected';
    throw new Error(
      `x64dbg plugin did not come online at ${this.base_url} within ${WAIT_FOR_PLUGIN_TIMEOUT_MS / 1000}s. ` +
      `Make sure x64dbg is running with the MCP plugin loaded. ` +
      `Check with 'mcpserver status' in x64dbg command bar.`
    );
  }

  private is_connection_error(err: Error): boolean {
    const msg = err.message.toLowerCase();
    return (
      msg.includes('econnrefused') ||
      msg.includes('econnreset') ||
      msg.includes('epipe') ||
      msg.includes('enotfound') ||
      msg.includes('enetunreach') ||
      msg.includes('ehostunreach') ||
      msg.includes('socket hang up') ||
      msg.includes('fetch failed') ||
      msg.includes('network') ||
      msg.includes('econnaborted') ||
      msg.includes('etimedout')
    );
  }

  private async request<T>(url: string, options: RequestInit): Promise<T> {
    // CRITICAL: If not connected, wait for the plugin to come online
    // This prevents Claude from seeing connection errors and giving up
    await this.wait_for_connection();

    let last_error: Error | null = null;

    for (let attempt = 0; attempt <= config.retries; attempt++) {
      try {
        const controller = new AbortController();
        const timeout_id = setTimeout(() => controller.abort(), config.timeout);

        const response = await fetch(url, {
          ...options,
          signal: controller.signal,
        });

        clearTimeout(timeout_id);

        const text = await response.text();
        let parsed: PluginResponse<T>;

        try {
          parsed = JSON.parse(text) as PluginResponse<T>;
        } catch {
          throw new Error(`Invalid JSON response from plugin: ${text.substring(0, 200)}`);
        }

        if (!parsed.success) {
          const err_msg = parsed.error?.message ?? 'Unknown plugin error';
          const err_code = parsed.error?.code ?? 500;
          throw new Error(`Plugin error (${err_code}): ${err_msg}`);
        }

        // Success
        this.state = 'connected';
        this.consecutive_failures = 0;
        this.last_successful_request = Date.now();

        return parsed.data as T;
      } catch (err) {
        last_error = err instanceof Error ? err : new Error(String(err));

        // Don't retry on 4xx plugin errors - these are valid responses
        if (last_error.message.includes('Plugin error (4')) {
          this.state = 'connected';
          throw last_error;
        }

        // Handle timeout
        if (last_error.name === 'AbortError') {
          this.consecutive_failures++;
          if (attempt >= config.retries) {
            throw new Error(
              `Request timed out after ${config.timeout}ms (${attempt + 1} attempts). ` +
              `The plugin may be busy with a long operation.`
            );
          }
          // Brief pause before retry on timeout
          await new Promise(resolve => setTimeout(resolve, 500));
          continue;
        }

        // Connection errors mid-request: the plugin may have restarted
        if (this.is_connection_error(last_error)) {
          this.consecutive_failures++;
          this.state = 'reconnecting';
          console.error(`[x64dbg-mcp] Connection error on attempt ${attempt + 1}: ${last_error.message}`);

          if (attempt < config.retries) {
            // Wait for reconnection before retrying
            console.error('[x64dbg-mcp] Waiting for plugin to come back...');
            try {
              await this.wait_for_connection();
              continue; // Plugin is back, retry the request
            } catch {
              throw last_error; // Timed out waiting
            }
          }

          this.state = 'disconnected';
          throw new Error(
            `Lost connection to x64dbg plugin at ${this.base_url}. ` +
            `The plugin may have been stopped or x64dbg was closed.`
          );
        }

        // Other errors - brief retry
        if (attempt < config.retries) {
          await new Promise(resolve => setTimeout(resolve, 300 * (attempt + 1)));
        }
      }
    }

    throw last_error ?? new Error('Request failed');
  }
}

export const httpClient = new HttpClient();

```

`server/src/index.ts`:

```ts
#!/usr/bin/env node
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { config } from './config.js';
import { httpClient } from './http_client.js';
import { registerAllTools } from './tools/index.js';

async function main() {
  const server = new McpServer({
    name: 'x64dbg',
    version: '2.1.0',
  });

  // Register all tools (23 mega-tools consolidated from 152)
  registerAllTools(server);

  // Connect via stdio (rock-solid transport, no connection drops)
  const transport = new StdioServerTransport();
  await server.connect(transport);

  // Log to stderr (stdout is used by MCP protocol)
  console.error(`[x64dbg-mcp] Server started (23 tools), plugin expected at ${config.host}:${config.port}`);
  console.error(`[x64dbg-mcp] Timeout: ${config.timeout}ms, Retries: ${config.retries}`);

  // Graceful shutdown
  const cleanup = () => {
    httpClient.destroy();
    process.exit(0);
  };
  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
}

main().catch((err) => {
  console.error('[x64dbg-mcp] Fatal error:', err);
  process.exit(1);
});

```

`server/src/tools/analysis.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerAnalysisTools(server: McpServer) {
  server.tool(
    'x64dbg_analysis',
    'Get function info, xrefs, basic blocks or source location for an address',
    {
      action: z.enum(['function', 'xrefs_to', 'xrefs_from', 'basic_blocks', 'source', 'mnemonic_brief']).describe('Information to get'),
      query: z.string().optional().default('cip').describe('Address to look up (or mnemonic for mnemonic_brief)')
    },
    async ({ action, query }) => {
      let data: any;
      switch (action) {
        case 'function': data = await httpClient.get('/api/analysis/function', { address: query }); break;
        case 'xrefs_to': data = await httpClient.get('/api/analysis/xrefs_to', { address: query }); break;
        case 'xrefs_from': data = await httpClient.get('/api/analysis/xrefs_from', { address: query }); break;
        case 'basic_blocks': data = await httpClient.get('/api/analysis/basic_blocks', { address: query }); break;
        case 'source': data = await httpClient.get('/api/analysis/source', { address: query }); break;
        case 'mnemonic_brief': data = await httpClient.get('/api/analysis/mnemonic_brief', { mnemonic: query }); break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );

  server.tool(
    'x64dbg_database',
    'List known constants, error codes, defined structs, or search strings in a module',
    {
      action: z.enum(['constants', 'error_codes', 'structs', 'strings']).describe('Type of list to retrieve'),
      module: z.string().optional().describe('Module name (required for strings action)')
    },
    async ({ action, module }) => {
      let data: any;
      switch (action) {
        case 'constants': data = await httpClient.get('/api/analysis/constants'); break;
        case 'error_codes': data = await httpClient.get('/api/analysis/error_codes'); break;
        case 'structs': data = await httpClient.get('/api/analysis/structs'); break;
        case 'strings':
          if (!module) throw new Error("module is required for strings action");
          data = await httpClient.get('/api/analysis/strings', { module });
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );

  server.tool(
    'x64dbg_address_convert',
    'Convert Virtual Address (VA) to File Offset, or File Offset to VA',
    {
      action: z.enum(['va_to_file', 'file_to_va']).describe('Conversion direction'),
      address: z.string().optional().describe('Virtual address (required for va_to_file)'),
      module: z.string().optional().describe('Module name (required for file_to_va)'),
      offset: z.string().optional().describe('File offset hex (required for file_to_va)')
    },
    async ({ action, address, module, offset }) => {
      let data: any;
      if (action === 'va_to_file') {
        if (!address) throw new Error("address is required for va_to_file");
        data = await httpClient.get('/api/analysis/va_to_file', { address });
      } else {
        if (!module || !offset) throw new Error("module and offset required for file_to_va");
        data = await httpClient.get('/api/analysis/file_to_va', { module, offset });
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );

  server.tool(
    'x64dbg_watchdog',
    'Check if a watch expression watchdog has been triggered',
    {
      id: z.string().optional().default('0').describe('Watch ID (decimal)'),
    },
    async ({ id }) => {
      const data = await httpClient.get('/api/analysis/watch', { id });
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/antidebug.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerAntiDebugTools(server: McpServer) {
  server.tool(
    'x64dbg_antidebug',
    'Anti-debugging analysis: Read PEB/TEB/DEP, or hide debugger',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("peb"), pid: z.string().optional() }),
        z.object({ action: z.literal("teb"), tid: z.string().optional() }),
        z.object({ action: z.literal("dep") }),
        z.object({ action: z.literal("hide_debugger") })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'peb': data = await httpClient.get('/api/antidebug/peb', { pid: action.pid || '' }); break;
        case 'teb': data = await httpClient.get('/api/antidebug/teb', { tid: action.tid || '' }); break;
        case 'dep': data = await httpClient.get('/api/antidebug/dep_status'); break;
        case 'hide_debugger': data = await httpClient.post('/api/antidebug/hide_debugger'); break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/breakpoints.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerBreakpointTools(server: McpServer) {
  server.tool(
    'x64dbg_breakpoints',
    'Unified tool for all breakpoint operations (set, get, list, configure, toggle, remove)',
    {
      action: z.discriminatedUnion("action", [
        z.object({
          action: z.literal("set_software"),
          address: z.string().describe("Address of the breakpoint"),
          singleshot: z.boolean().optional()
        }),
        z.object({
          action: z.literal("set_hardware"),
          address: z.string(),
          type: z.enum(['r', 'w', 'x']).optional().describe("Hardware BP type (read/write/execute)"),
          size: z.enum(['1', '2', '4', '8']).optional().describe("Hardware size")
        }),
        z.object({
          action: z.literal("set_memory"),
          address: z.string(),
          type: z.enum(['a', 'r', 'w', 'x']).optional().describe("Memory BP type")
        }),
        z.object({
          action: z.literal("delete"),
          address: z.string(),
          type: z.enum(['software', 'hardware', 'memory']).optional()
        }),
        z.object({ action: z.literal("enable"), address: z.string() }),
        z.object({ action: z.literal("disable"), address: z.string() }),
        z.object({ action: z.literal("toggle"), address: z.string() }),
        z.object({
          action: z.literal("set_condition"),
          address: z.string(),
          condition: z.string().describe("Expression, e.g. eax==0")
        }),
        z.object({
          action: z.literal("set_log"),
          address: z.string(),
          text: z.string().describe("Format string for logging")
        }),
        z.object({ action: z.literal("reset_hit_count"), address: z.string() }),
        z.object({ action: z.literal("get"), address: z.string() }),
        z.object({ action: z.literal("list") }),
        z.object({
          action: z.literal("configure"),
          address: z.string(),
          bp_type: z.enum(['software', 'hardware', 'memory']).optional().default('software'),
          singleshot: z.boolean().optional(),
          hw_type: z.enum(['r', 'w', 'x']).optional(),
          hw_size: z.enum(['1', '2', '4', '8']).optional(),
          mem_type: z.enum(['a', 'r', 'w', 'x']).optional(),
          break_condition: z.string().optional(),
          command_condition: z.string().optional(),
          command_text: z.string().optional(),
          log_text: z.string().optional(),
          log_condition: z.string().optional(),
          silent: z.boolean().optional(),
          fast_resume: z.boolean().optional(),
          name: z.string().optional()
        }),
        z.object({
          action: z.literal("configure_batch"),
          breakpoints: z.array(z.object({
            address: z.string(),
            bp_type: z.enum(['software', 'hardware', 'memory']).optional(),
            singleshot: z.boolean().optional(),
            hw_type: z.string().optional(),
            hw_size: z.string().optional(),
            mem_type: z.string().optional(),
            break_condition: z.string().optional(),
            command_condition: z.string().optional(),
            command_text: z.string().optional(),
            log_text: z.string().optional(),
            log_condition: z.string().optional(),
            silent: z.boolean().optional(),
            fast_resume: z.boolean().optional(),
            name: z.string().optional()
          }))
        })
      ])
    },
    async ({ action }) => {
      let endpoint = '';
      let payload: any = action.action !== 'list' && action.action !== 'configure_batch'
        ? { address: (action as any).address }
        : {};

      switch(action.action) {
        case 'set_software':
          endpoint = '/api/breakpoints/set';
          payload.singleshot = action.singleshot || false;
          break;
        case 'set_hardware':
          endpoint = '/api/breakpoints/set_hardware';
          payload.type = action.type || 'x';
          payload.size = action.size || '1';
          break;
        case 'set_memory':
          endpoint = '/api/breakpoints/set_memory';
          payload.type = action.type || 'a';
          break;
        case 'delete':
          endpoint = '/api/breakpoints/delete';
          payload.type = action.type;
          break;
        case 'enable': endpoint = '/api/breakpoints/enable'; break;
        case 'disable': endpoint = '/api/breakpoints/disable'; break;
        case 'toggle': endpoint = '/api/breakpoints/toggle'; break;
        case 'set_condition':
          endpoint = '/api/breakpoints/set_condition';
          payload.condition = action.condition;
          break;
        case 'set_log':
          endpoint = '/api/breakpoints/set_log';
          payload.text = action.text;
          break;
        case 'reset_hit_count': endpoint = '/api/breakpoints/reset_hit_count'; break;
        case 'get':
          const getData = await httpClient.get('/api/breakpoints/get', { address: action.address });
          return { content: [{ type: 'text', text: JSON.stringify(getData, null, 2) }] };
        case 'list':
          const listData = await httpClient.get('/api/breakpoints/list');
          return { content: [{ type: 'text', text: JSON.stringify(listData, null, 2) }] };
        case 'configure':
          endpoint = '/api/breakpoints/configure';
          payload = { ...action };
          break;
        case 'configure_batch':
          endpoint = '/api/breakpoints/configure_batch';
          payload = { breakpoints: action.breakpoints };
          break;
      }

      const data = await httpClient.post(endpoint, payload);
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/command.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerCommandTools(server: McpServer) {
  server.tool(
    'x64dbg_command',
    'Execute x64dbg commands, scripts, eval expressions, or manage debug session',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("execute"), command: z.string().describe("x64dbg command string") }),
        z.object({ action: z.literal("script"), commands: z.array(z.string()).describe("Array of commands") }),
        z.object({ action: z.literal("evaluate"), expression: z.string() }),
        z.object({ action: z.literal("format"), format: z.string() }),
        z.object({ action: z.literal("set_init_script"), file: z.string().describe("Path to script file") }),
        z.object({ action: z.literal("get_init_script") }),
        z.object({ action: z.literal("get_hash") }),
        z.object({ action: z.literal("get_events") })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'execute':
          data = await httpClient.post('/api/command/exec', { command: action.command });
          break;
        case 'script':
          data = await httpClient.post('/api/command/script', { commands: action.commands });
          break;
        case 'evaluate':
          data = await httpClient.post('/api/command/eval', { expression: action.expression });
          break;
        case 'format':
          data = await httpClient.post('/api/command/format', { format: action.format });
          break;
        case 'set_init_script':
          data = await httpClient.post('/api/command/init_script', { file: action.file });
          break;
        case 'get_init_script':
          data = await httpClient.get('/api/command/init_script');
          break;
        case 'get_hash':
          data = await httpClient.get('/api/command/hash');
          break;
        case 'get_events':
          data = await httpClient.get('/api/command/events');
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/controlflow.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerControlFlowTools(server: McpServer) {
  server.tool(
    'x64dbg_control_flow',
    'Get CFG/branch/loop info or manage function definitions',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("cfg"), address: z.string().optional().default("cip") }),
        z.object({ action: z.literal("branch_dest"), address: z.string().optional().default("cip") }),
        z.object({ action: z.literal("is_jump_taken"), address: z.string().optional().default("cip") }),
        z.object({ action: z.literal("loops"), address: z.string().optional().default("cip") }),
        z.object({ action: z.literal("func_type"), address: z.string().optional().default("cip") }),
        z.object({ action: z.literal("add_function"), start: z.string(), end: z.string() }),
        z.object({ action: z.literal("delete_function"), address: z.string() })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'cfg': data = await httpClient.get('/api/cfg/function', { address: action.address }); break;
        case 'branch_dest': data = await httpClient.get('/api/cfg/branch_dest', { address: action.address }); break;
        case 'is_jump_taken': data = await httpClient.get('/api/cfg/is_jump_taken', { address: action.address }); break;
        case 'loops': data = await httpClient.get('/api/cfg/loops', { address: action.address }); break;
        case 'func_type': data = await httpClient.get('/api/cfg/func_type', { address: action.address }); break;
        case 'add_function': data = await httpClient.post('/api/cfg/add_function', { start: action.start, end: action.end }); break;
        case 'delete_function': data = await httpClient.post('/api/cfg/delete_function', { address: action.address }); break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/debug.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';


export function registerDebugTools(server: McpServer) {
  server.tool(
    'x64dbg_debug',
    'Execute core debugger actions (run, pause, step, state, etc.)',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("run") }),
        z.object({ action: z.literal("pause") }),
        z.object({ action: z.literal("force_pause") }),
        z.object({ action: z.literal("step_into") }),
        z.object({ action: z.literal("step_over") }),
        z.object({ action: z.literal("step_out") }),
        z.object({ action: z.literal("stop_debug") }),
        z.object({ action: z.literal("restart_debug") }),
        z.object({
          action: z.literal("run_to_address"),
          address: z.string().describe("Target address to run to")
        }),
        z.object({
          action: z.literal("state"),
          include_health: z.boolean().optional().describe("Also check plugin health/version")
        })
      ])
    },
    async ({ action }) => {
      let endpoint = '';
      let payload: any = undefined;

      switch(action.action) {
        case 'run': endpoint = '/api/debug/run'; break;
        case 'pause': endpoint = '/api/debug/pause'; break;
        case 'force_pause': endpoint = '/api/debug/force_pause'; break;
        case 'step_into': endpoint = '/api/debug/step_into'; break;
        case 'step_over': endpoint = '/api/debug/step_over'; break;
        case 'step_out': endpoint = '/api/debug/step_out'; break;
        case 'stop_debug': endpoint = '/api/debug/stop'; break;
        case 'restart_debug': endpoint = '/api/debug/restart'; break;
        case 'run_to_address':
          endpoint = '/api/debug/run_to';
          payload = { address: action.address };
          break;
        case 'state':
          const stateData = await httpClient.get('/api/debug/state');
          let result: any = { state: stateData };
          if (action.include_health) {
            try {
              result.health = await httpClient.get('/api/health');
            } catch (e) {
              result.health = { error: "Health check failed" };
            }
          }
          return { content: [{ type: 'text', text: JSON.stringify(result, null, 2) }] };
      }

      const data = await httpClient.post(endpoint, payload);
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/disassembly.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerDisassemblyTools(server: McpServer) {
  server.tool(
    'x64dbg_disassembly',
    'Disassemble or assemble instructions (at address, function, info, assemble)',
    {
      action: z.discriminatedUnion("action", [
        z.object({
          action: z.literal("at_address"),
          address: z.string().optional().default("cip"),
          count: z.string().optional().default("10")
        }),
        z.object({
          action: z.literal("function"),
          address: z.string().optional().default("cip"),
          max_instructions: z.number().optional().default(50)
        }),
        z.object({
          action: z.literal("info"),
          address: z.string().optional().default("cip")
        }),
        z.object({
          action: z.literal("assemble"),
          address: z.string().describe("Address to assemble at"),
          instruction: z.string().describe("Assembly instruction (e.g. 'nop')")
        })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'at_address':
          data = await httpClient.get('/api/disasm/at', { address: action.address, count: action.count });
          break;
        case 'function':
          data = await httpClient.get('/api/disasm/function', {
            address: action.address,
            max_instructions: String(action.max_instructions),
          });
          break;
        case 'info':
          data = await httpClient.get('/api/disasm/basic', { address: action.address });
          break;
        case 'assemble':
          data = await httpClient.post('/api/disasm/assemble', { address: action.address, instruction: action.instruction });
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/dumping.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerDumpingTools(server: McpServer) {
  server.tool(
    'x64dbg_dumping',
    'Dump modules, fix IAT, or get PE header/sections/imports/exports',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("pe_header"), address: z.string() }),
        z.object({ action: z.literal("sections"), module: z.string() }),
        z.object({ action: z.literal("imports"), module: z.string() }),
        z.object({ action: z.literal("exports"), module: z.string() }),
        z.object({ action: z.literal("entry_point"), module: z.string() }),
        z.object({ action: z.literal("relocations"), address: z.string() }),
        z.object({ action: z.literal("dump_module"), module: z.string(), file: z.string().optional().default("") }),
        z.object({ action: z.literal("fix_iat"), oep: z.string() }),
        z.object({ action: z.literal("export_patch_file"), filename: z.string().describe("Output path for .1337 patch file") })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'pe_header': data = await httpClient.get('/api/dump/pe_header', { address: action.address }); break;
        case 'sections': data = await httpClient.get('/api/dump/sections', { module: action.module }); break;
        case 'imports': data = await httpClient.get('/api/dump/imports', { module: action.module }); break;
        case 'exports': data = await httpClient.get('/api/dump/exports', { module: action.module }); break;
        case 'entry_point': data = await httpClient.get('/api/dump/entry_point', { module: action.module }); break;
        case 'relocations': data = await httpClient.get('/api/dump/relocations', { address: action.address }); break;
        case 'dump_module': data = await httpClient.post('/api/dump/module', { module: action.module, file: action.file }); break;
        case 'fix_iat': data = await httpClient.post('/api/dump/fix_iat', { oep: action.oep }); break;
        case 'export_patch_file': data = await httpClient.post('/api/patches/export_file', { filename: action.filename }); break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/exceptions.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerExceptionTools(server: McpServer) {
  server.tool(
    'x64dbg_exceptions',
    'Manage exception breakpoints, list Windows exception codes, or skip exceptions',
    {
      action: z.discriminatedUnion("action", [
        z.object({
          action: z.literal("set"),
          code: z.string().describe("Exception code (hex, e.g. C0000005)"),
          chance: z.enum(['first', 'second', 'all']).optional().default("first"),
          bp_action: z.enum(['break', 'log', 'command']).optional().default("break")
        }),
        z.object({ action: z.literal("delete"), code: z.string() }),
        z.object({ action: z.literal("list") }),
        z.object({ action: z.literal("list_codes") }),
        z.object({ action: z.literal("skip") })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'set': data = await httpClient.post('/api/exceptions/set_bp', { code: action.code, chance: action.chance, action: action.bp_action }); break;
        case 'delete': data = await httpClient.post('/api/exceptions/delete_bp', { code: action.code }); break;
        case 'list': data = await httpClient.get('/api/exceptions/list_bps'); break;
        case 'list_codes': data = await httpClient.get('/api/exceptions/list_codes'); break;
        case 'skip': data = await httpClient.post('/api/exceptions/skip'); break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/handles.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerHandleTools(server: McpServer) {
  server.tool(
    'x64dbg_handles',
    'List handles/tcp/windows/heaps, get handle name, or close a handle',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("list_handles") }),
        z.object({ action: z.literal("list_tcp") }),
        z.object({ action: z.literal("list_windows") }),
        z.object({ action: z.literal("list_heaps") }),
        z.object({ action: z.literal("get_name"), handle: z.string() }),
        z.object({ action: z.literal("close"), handle: z.string() })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'list_handles': data = await httpClient.get('/api/handles/list'); break;
        case 'list_tcp': data = await httpClient.get('/api/handles/tcp'); break;
        case 'list_windows': data = await httpClient.get('/api/handles/windows'); break;
        case 'list_heaps': data = await httpClient.get('/api/handles/heaps'); break;
        case 'get_name': data = await httpClient.get('/api/handles/get', { handle: action.handle }); break;
        case 'close': data = await httpClient.post('/api/handles/close', { handle: action.handle }); break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/index.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';

import { registerAnalysisTools } from './analysis.js';
import { registerAntiDebugTools } from './antidebug.js';
import { registerBreakpointTools } from './breakpoints.js';
import { registerCommandTools } from './command.js';
import { registerControlFlowTools } from './controlflow.js';
import { registerDebugTools } from './debug.js';
import { registerDisassemblyTools } from './disassembly.js';
import { registerDumpingTools } from './dumping.js';
import { registerExceptionTools } from './exceptions.js';
import { registerHandleTools } from './handles.js';
import { registerMemoryTools } from './memory.js';
import { registerModuleTools } from './modules.js';
import { registerPatchTools } from './patches.js';
import { registerProcessTools } from './process.js';
import { registerRegisterTools } from './registers.js';
import { registerSearchTools } from './search.js';
import { registerStackTools } from './stack.js';
import { registerSymbolTools } from './symbols.js';
import { registerThreadTools } from './threads.js';
import { registerTracingTools } from './tracing.js';

export function registerAllTools(server: McpServer) {
  registerDebugTools(server);
  registerRegisterTools(server);
  registerMemoryTools(server);
  registerDisassemblyTools(server);
  registerBreakpointTools(server);
  registerSymbolTools(server);
  registerStackTools(server);
  registerThreadTools(server);
  registerModuleTools(server);
  registerSearchTools(server);
  registerCommandTools(server);
  registerAnalysisTools(server);
  registerTracingTools(server);
  registerDumpingTools(server);
  registerAntiDebugTools(server);
  registerExceptionTools(server);
  registerProcessTools(server);
  registerHandleTools(server);
  registerControlFlowTools(server);
  registerPatchTools(server);
}

```

`server/src/tools/memory.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerMemoryTools(server: McpServer) {
  server.tool(
    'x64dbg_memory',
    'Core memory operations: read, write, info, allocate, free, protect, map',
    {
      action: z.discriminatedUnion("action", [
        z.object({
          action: z.literal("read"),
          address: z.string().describe("Hex string or expression"),
          size: z.string().optional().default("256").describe("Size in bytes (decimal)")
        }),
        z.object({
          action: z.literal("write"),
          address: z.string().describe("Hex string or expression"),
          bytes: z.string().describe("Hex bytes (e.g. '90 90' or 'CC')"),
          verify: z.boolean().optional().default(false).describe("Verify write success")
        }),
        z.object({ action: z.literal("info"), address: z.string().describe("Address to query page info") }),
        z.object({ action: z.literal("is_valid"), address: z.string() }),
        z.object({ action: z.literal("is_code"), address: z.string() }),
        z.object({
          action: z.literal("allocate"),
          size: z.string().optional().default("0x1000").describe("Size in hex")
        }),
        z.object({
          action: z.literal("free"),
          address: z.string()
        }),
        z.object({
          action: z.literal("protect"),
          address: z.string(),
          size: z.string().optional().default("0x1000"),
          protection: z.string().describe("E.g. 'PAGE_EXECUTE_READWRITE'")
        }),
        z.object({
          action: z.literal("map"),
          address: z.string().optional().describe("Return region info for address, or full map if omitted")
        }),
        z.object({ action: z.literal("update_map") })
      ])
    },
    async ({ action }) => {
      let endpoint = '';
      let payload: any = undefined;

      switch (action.action) {
        case 'read':
          return { content: [{ type: 'text', text: JSON.stringify(await httpClient.get('/api/memory/read', { address: action.address, size: action.size }), null, 2) }] };
        case 'write':
          return { content: [{ type: 'text', text: JSON.stringify(await httpClient.post('/api/memory/write', { address: action.address, bytes: action.bytes, verify: action.verify }), null, 2) }] };
        case 'info':
          return { content: [{ type: 'text', text: JSON.stringify(await httpClient.get('/api/memory/page_info', { address: action.address }), null, 2) }] };
        case 'is_valid':
          return { content: [{ type: 'text', text: JSON.stringify(await httpClient.get('/api/memory/is_valid', { address: action.address }), null, 2) }] };
        case 'is_code':
          return { content: [{ type: 'text', text: JSON.stringify(await httpClient.get('/api/memory/is_code', { address: action.address }), null, 2) }] };
        case 'allocate':
          endpoint = '/api/memory/allocate';
          payload = { size: action.size };
          break;
        case 'free':
          endpoint = '/api/memory/free';
          payload = { address: action.address };
          break;
        case 'protect':
          endpoint = '/api/memory/protect';
          payload = { address: action.address, size: action.size, protection: action.protection };
          break;
        case 'map':
          if (action.address) {
            return { content: [{ type: 'text', text: JSON.stringify(await httpClient.get('/api/memmap/at', { address: action.address }), null, 2) }] };
          } else {
            return { content: [{ type: 'text', text: JSON.stringify(await httpClient.get('/api/memmap/list'), null, 2) }] };
          }
        case 'update_map':
          return { content: [{ type: 'text', text: JSON.stringify(await httpClient.post('/api/memory/update_map'), null, 2) }] };
      }

      if (endpoint) {
        const data = await httpClient.post(endpoint, payload);
        return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
      }
      return { content: [{ type: 'text', text: "{}" }] };
    }
  );
}

```

`server/src/tools/modules.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerModuleTools(server: McpServer) {
  server.tool(
    'x64dbg_modules',
    'List modules or get info (base, section, party) for a specific module',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("list") }),
        z.object({ action: z.literal("get_info"), module: z.string() }),
        z.object({ action: z.literal("get_base"), module: z.string() }),
        z.object({ action: z.literal("get_section"), address: z.string() }),
        z.object({ action: z.literal("get_party"), base: z.string() })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'list':
          data = await httpClient.get('/api/modules/list');
          break;
        case 'get_info':
          data = await httpClient.get('/api/modules/get', { name: action.module });
          break;
        case 'get_base':
          data = await httpClient.get('/api/modules/base', { name: action.module });
          break;
        case 'get_section':
          data = await httpClient.get('/api/modules/section', { address: action.address });
          break;
        case 'get_party':
          data = await httpClient.get('/api/modules/party', { base: action.base });
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/patches.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerPatchTools(server: McpServer) {
  server.tool(
    'x64dbg_patches',
    'List, apply, restore patches or export patched module',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("list") }),
        z.object({ action: z.literal("apply"), address: z.string(), bytes: z.string() }),
        z.object({ action: z.literal("restore"), address: z.string() }),
        z.object({ action: z.literal("export"), module: z.string().optional(), path: z.string() })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'list': data = await httpClient.get('/api/patches/list'); break;
        case 'apply': data = await httpClient.post('/api/patches/apply', { address: action.address, bytes: action.bytes }); break;
        case 'restore': data = await httpClient.post('/api/patches/restore', { address: action.address }); break;
        case 'export':
          const body: Record<string, string> = { path: action.path };
          if (action.module) body.module = action.module;
          data = await httpClient.post('/api/patches/export', body);
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/process.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerProcessTools(server: McpServer) {
  server.tool(
    'x64dbg_process',
    'Get process info (basic, detailed, cmdline, elevated, dbversion) or set cmdline',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("basic") }),
        z.object({ action: z.literal("detailed") }),
        z.object({ action: z.literal("cmdline") }),
        z.object({ action: z.literal("elevated") }),
        z.object({ action: z.literal("dbversion") }),
        z.object({ action: z.literal("set_cmdline"), cmdline: z.string() })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'basic': data = await httpClient.get('/api/process/info'); break;
        case 'detailed': data = await httpClient.get('/api/process/details'); break;
        case 'cmdline': data = await httpClient.get('/api/process/cmdline'); break;
        case 'elevated': data = await httpClient.get('/api/process/elevated'); break;
        case 'dbversion': data = await httpClient.get('/api/process/dbversion'); break;
        case 'set_cmdline': data = await httpClient.post('/api/process/set_cmdline', { cmdline: action.cmdline }); break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/registers.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerRegisterTools(server: McpServer) {
  server.tool(
    'x64dbg_registers',
    'Get or set CPU register values (all, specific, flags, avx512, set)',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("get_all") }),
        z.object({ action: z.literal("get_flags") }),
        z.object({ action: z.literal("get_avx512") }),
        z.object({
          action: z.literal("get_specific"),
          name: z.string().describe("Register name (e.g. 'rax', 'eip', 'dr0')")
        }),
        z.object({
          action: z.literal("set"),
          name: z.string().describe("Register name (e.g. 'rax', 'rcx')"),
          value: z.string().describe("New value (hex string, e.g. '0x1234' or expression)")
        })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'get_all': data = await httpClient.get('/api/registers/all'); break;
        case 'get_flags': data = await httpClient.get('/api/registers/flags'); break;
        case 'get_avx512': data = await httpClient.get('/api/registers/avx512'); break;
        case 'get_specific':
          data = await httpClient.get('/api/registers/get', { name: action.name });
          break;
        case 'set':
          data = await httpClient.post('/api/registers/set', { name: action.name, value: action.value });
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/search.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerSearchTools(server: McpServer) {
  server.tool(
    'x64dbg_search',
    'Pattern/string search, symbol autocomplete, or get string at address',
    {
      action: z.discriminatedUnion("action", [
        z.object({
          action: z.literal("pattern"),
          query: z.string().describe("Byte pattern (e.g. '48 89 5C ??')"),
          address: z.string().optional().describe("Start address"),
          size: z.string().optional().describe("Size of range"),
          max_results: z.number().optional().default(1000)
        }),
        z.object({
          action: z.literal("string"),
          query: z.string().describe("Text string to search for"),
          module: z.string().optional().default(""),
          encoding: z.enum(['utf8', 'ascii', 'unicode']).optional().default("utf8")
        }),
        z.object({
          action: z.literal("string_at"),
          query: z.string().describe("Address"),
          encoding: z.enum(['auto', 'ascii', 'unicode']).optional().default("auto"),
          max_length: z.number().optional().default(256)
        }),
        z.object({
          action: z.literal("symbol_auto_complete"),
          query: z.string().describe("Partial symbol name"),
          max_results: z.number().optional().default(256)
        }),
        z.object({
          action: z.literal("encode_type"),
          query: z.string().describe("Address"),
          size: z.string().optional().default("1")
        })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'pattern':
          const body: Record<string, unknown> = { pattern: action.query, max_results: action.max_results };
          if (action.address) body.address = action.address;
          if (action.size) body.size = action.size;
          data = await httpClient.post('/api/search/pattern', body);
          break;
        case 'string':
          data = await httpClient.post('/api/search/string', { text: action.query, module: action.module, encoding: action.encoding });
          break;
        case 'string_at':
          data = await httpClient.get('/api/search/string_at', { address: action.query, encoding: action.encoding, max_length: String(action.max_length) });
          break;
        case 'symbol_auto_complete':
          data = await httpClient.post('/api/search/auto_complete', { search: action.query, max_results: action.max_results });
          break;
        case 'encode_type':
          data = await httpClient.get('/api/search/encode_type', { address: action.query, size: action.size });
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/stack.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerStackTools(server: McpServer) {
  server.tool(
    'x64dbg_stack',
    'Stack operations: call stack, read raw, get pointers/SEH/comments',
    {
      action: z.discriminatedUnion("action", [
        z.object({
          action: z.literal("get_call_stack"),
          handle: z.string().optional().describe("Thread handle (hex)"),
          max_depth: z.string().optional().default("50")
        }),
        z.object({
          action: z.literal("read"),
          address: z.string().optional().default("csp"),
          size: z.string().optional().default("256")
        }),
        z.object({ action: z.literal("pointers") }),
        z.object({ action: z.literal("seh_chain") }),
        z.object({ action: z.literal("return_address") }),
        z.object({ action: z.literal("comment"), address: z.string() })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'get_call_stack':
          if (action.handle) {
            data = await httpClient.get('/api/stack/callstack_thread', { handle: action.handle });
          } else {
            data = await httpClient.get('/api/stack/trace', { max_depth: action.max_depth });
          }
          break;
        case 'read':
          data = await httpClient.get('/api/stack/read', { address: action.address, size: action.size });
          break;
        case 'pointers':
          data = await httpClient.get('/api/stack/pointers');
          break;
        case 'seh_chain':
          data = await httpClient.get('/api/stack/seh_chain');
          break;
        case 'return_address':
          data = await httpClient.get('/api/stack/return_address');
          break;
        case 'comment':
          data = await httpClient.get('/api/stack/comment', { address: action.address });
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/symbols.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerSymbolTools(server: McpServer) {
  server.tool(
    'x64dbg_symbols',
    'Symbol, label, comment, and bookmark operations',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("resolve"), name: z.string() }),
        z.object({ action: z.literal("address"), address: z.string() }),
        z.object({ action: z.literal("search"), pattern: z.string(), module: z.string().optional() }),
        z.object({ action: z.literal("list_module"), module: z.string() }),
        z.object({ action: z.literal("get_label"), address: z.string() }),
        z.object({ action: z.literal("set_label"), address: z.string(), text: z.string() }),
        z.object({ action: z.literal("get_comment"), address: z.string() }),
        z.object({ action: z.literal("set_comment"), address: z.string(), text: z.string() }),
        z.object({ action: z.literal("bookmark"), address: z.string(), set: z.boolean().optional().default(true) })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'resolve':
          data = await httpClient.get('/api/symbols/resolve', { name: action.name });
          break;
        case 'address':
          data = await httpClient.get('/api/symbols/at', { address: action.address });
          break;
        case 'search':
          let searchParams: any = { pattern: action.pattern };
          if (action.module) searchParams.module = action.module;
          data = await httpClient.get('/api/symbols/search', searchParams);
          break;
        case 'list_module':
          data = await httpClient.get('/api/symbols/list', { module: action.module });
          break;
        case 'get_label':
          data = await httpClient.get('/api/labels/get', { address: action.address });
          break;
        case 'set_label':
          data = await httpClient.post('/api/labels/set', { address: action.address, text: action.text });
          break;
        case 'get_comment':
          data = await httpClient.get('/api/comments/get', { address: action.address });
          break;
        case 'set_comment':
          data = await httpClient.post('/api/comments/set', { address: action.address, text: action.text });
          break;
        case 'bookmark':
          data = await httpClient.post('/api/bookmarks/set', { address: action.address, set: action.set });
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/threads.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerThreadTools(server: McpServer) {
  server.tool(
    'x64dbg_threads',
    'Thread operations: list, get current/specific/teb/name, or switch/suspend/resume',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("list") }),
        z.object({ action: z.literal("current") }),
        z.object({ action: z.literal("count") }),
        z.object({ action: z.literal("info"), tid: z.string().describe("Thread ID (decimal)") }),
        z.object({ action: z.literal("teb"), tid: z.string() }),
        z.object({ action: z.literal("name"), tid: z.string() }),
        z.object({ action: z.literal("switch"), id: z.number().describe("Thread ID (decimal)") }),
        z.object({ action: z.literal("suspend"), id: z.number() }),
        z.object({ action: z.literal("resume"), id: z.number() })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'list':
          data = await httpClient.get('/api/threads/list');
          break;
        case 'current':
          data = await httpClient.get('/api/threads/current');
          break;
        case 'count':
          data = await httpClient.get('/api/threads/count');
          break;
        case 'info':
          data = await httpClient.get('/api/threads/get', { id: action.tid });
          break;
        case 'teb':
        case 'name':
          data = await httpClient.get(`/api/threads/${action.action}`, { tid: action.tid });
          break;
        case 'switch':
        case 'suspend':
        case 'resume':
          data = await httpClient.post(`/api/threads/${action.action}`, { id: action.id });
          break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/src/tools/tracing.ts`:

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { httpClient } from '../http_client.js';

export function registerTracingTools(server: McpServer) {
  server.tool(
    'x64dbg_tracing',
    'Execution tracing operations: step into/over, run, animate, get trace info',
    {
      action: z.discriminatedUnion("action", [
        z.object({ action: z.literal("into"), condition: z.string().optional(), max_steps: z.string().optional(), log_text: z.string().optional() }),
        z.object({ action: z.literal("over"), condition: z.string().optional(), max_steps: z.string().optional(), log_text: z.string().optional() }),
        z.object({ action: z.literal("run"), party: z.string().optional() }),
        z.object({ action: z.literal("stop") }),
        z.object({ action: z.literal("animate"), command: z.string() }),
        z.object({ action: z.literal("conditional_run"), condition: z.string().optional(), log_text: z.string().optional(), command_text: z.string().optional() }),
        z.object({ action: z.literal("log_setup"), file: z.string(), log_text: z.string().optional(), condition: z.string().optional() }),
        z.object({ action: z.literal("hitcount"), address: z.string() }),
        z.object({ action: z.literal("type"), address: z.string() }),
        z.object({ action: z.literal("set_type"), address: z.string(), type: z.number().optional().default(0) })
      ])
    },
    async ({ action }) => {
      let data: any;
      switch (action.action) {
        case 'into': data = await httpClient.post('/api/trace/into', { condition: action.condition || '', max_steps: action.max_steps || '', log_text: action.log_text || '' }); break;
        case 'over': data = await httpClient.post('/api/trace/over', { condition: action.condition || '', max_steps: action.max_steps || '', log_text: action.log_text || '' }); break;
        case 'run': data = await httpClient.post('/api/trace/run', { party: action.party || '0' }); break;
        case 'stop': data = await httpClient.post('/api/trace/stop'); break;
        case 'animate': data = await httpClient.post('/api/trace/animate', { command: action.command }); break;
        case 'conditional_run': data = await httpClient.post('/api/trace/conditional_run', { break_condition: action.condition || '', log_text: action.log_text || '', log_condition: '', command_text: action.command_text || '', command_condition: '', type: 'into' }); break;
        case 'log_setup': data = await httpClient.post('/api/trace/log', { file: action.file, text: action.log_text || '', condition: action.condition || '' }); break;
        case 'hitcount': data = await httpClient.get('/api/trace/record/hitcount', { address: action.address }); break;
        case 'type': data = await httpClient.get('/api/trace/record/type', { address: action.address }); break;
        case 'set_type': data = await httpClient.post('/api/trace/record/set_type', { address: action.address, type: action.type }); break;
      }
      return { content: [{ type: 'text', text: JSON.stringify(data, null, 2) }] };
    }
  );
}

```

`server/tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

```