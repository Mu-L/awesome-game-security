Project Path: arc_abcz316_rwProcMem33_x83tbdza

Source Tree:

```txt
arc_abcz316_rwProcMem33_x83tbdza
├── README.md
├── hwBreakpointProcModule
│   ├── 5.x内核需去除cfi验证，否则会死机
│   │   └── patch_cfi工具包.7z
│   ├── hwBreakpointProc_module
│   │   ├── Makefile
│   │   ├── anti_ptrace_detection.h
│   │   ├── api_proxy.h
│   │   ├── arm64_register_helper.h
│   │   ├── cvector.h
│   │   ├── hide_procfs_dir.h
│   │   ├── hwBreakpointProc_module.c
│   │   ├── hwBreakpointProc_module.h
│   │   ├── hwbp_proc.c
│   │   ├── hwbp_proc.h
│   │   ├── kallsyms_lookup_api.h
│   │   ├── proc_pid.h
│   │   └── ver_control.h
│   ├── testHwBp
│   │   └── jni
│   │       ├── Android.mk
│   │       ├── Application.mk
│   │       ├── HwBreakpointMgr4.h
│   │       ├── IoctlBufferPool.h
│   │       └── testHwBp.cpp
│   ├── testHwBpClient
│   │   ├── Global.cpp
│   │   ├── Global.h
│   │   ├── NetworkDlg.cpp
│   │   ├── NetworkDlg.h
│   │   ├── NetworkMgr.cpp
│   │   ├── NetworkMgr.h
│   │   ├── ScaleHelper.h
│   │   ├── TextViewDlg.cpp
│   │   ├── TextViewDlg.h
│   │   ├── framework.h
│   │   ├── pch.cpp
│   │   ├── pch.h
│   │   ├── res
│   │   │   ├── testHwBpClient.ico
│   │   │   └── testHwBpClient.rc2
│   │   ├── resource.h
│   │   ├── targetver.h
│   │   ├── testHwBpClient.aps
│   │   ├── testHwBpClient.cpp
│   │   ├── testHwBpClient.h
│   │   ├── testHwBpClient.rc
│   │   ├── testHwBpClient.vcxproj
│   │   ├── testHwBpClient.vcxproj.filters
│   │   ├── testHwBpClient.vcxproj.user
│   │   ├── testHwBpClientDlg.cpp
│   │   └── testHwBpClientDlg.h
│   ├── testHwBpServer
│   │   └── jni
│   │       ├── Android.mk
│   │       ├── Application.mk
│   │       ├── Global.cpp
│   │       ├── Global.h
│   │       ├── api.cpp
│   │       ├── api.h
│   │       ├── hwbpserver.h
│   │       ├── porthelp.cpp
│   │       ├── porthelp.h
│   │       └── testHwBpServer.cpp
│   ├── testHwBpTarget
│   │   └── jni
│   │       ├── Android.mk
│   │       ├── Application.mk
│   │       └── testHwBpTarget.cpp
│   └── 演示图片.png
└── rwProcMem33Module
    ├── rwProcMem_module
    │   ├── 5.x内核需去除cfi验证，否则会死机
    │   │   └── patch_cfi工具包(2025.7).7z
    │   ├── Makefile
    │   ├── api_proxy.h
    │   ├── hide_procfs_dir.h
    │   ├── linux_kernel_api.h
    │   ├── phy_mem.h
    │   ├── phy_mem_auto_offset.h
    │   ├── proc_cmdline.h
    │   ├── proc_cmdline_auto_offset.h
    │   ├── proc_list.h
    │   ├── proc_list_auto_offset.h
    │   ├── proc_maps.h
    │   ├── proc_maps_auto_offset.h
    │   ├── proc_root.h
    │   ├── proc_root_auto_offset.h
    │   ├── proc_rss.h
    │   ├── rwProcMem_module.c
    │   ├── rwProcMem_module.h
    │   ├── test.h
    │   └── ver_control.h
    ├── testCEServer
    │   └── jni
    │       ├── Android.mk
    │       ├── Application.mk
    │       ├── api.cpp
    │       ├── api.h
    │       ├── ceserver.h
    │       ├── context.h
    │       ├── native-api.cpp
    │       ├── native-api.h
    │       ├── porthelp.cpp
    │       ├── porthelp.h
    │       ├── symbols.cpp
    │       ├── symbols.h
    │       └── testCEServer.cpp
    ├── testDumpMem
    │   └── jni
    │       ├── Android.mk
    │       ├── Application.mk
    │       ├── libzip
    │       │   ├── config.h
    │       │   ├── mkstemp.c
    │       │   ├── zip.h
    │       │   ├── zip_add.c
    │       │   ├── zip_add_dir.c
    │       │   ├── zip_add_entry.c
    │       │   ├── zip_buffer.c
    │       │   ├── zip_close.c
    │       │   ├── zip_delete.c
    │       │   ├── zip_dir_add.c
    │       │   ├── zip_dirent.c
    │       │   ├── zip_discard.c
    │       │   ├── zip_entry.c
    │       │   ├── zip_err_str.c
    │       │   ├── zip_error.c
    │       │   ├── zip_error_clear.c
    │       │   ├── zip_error_get.c
    │       │   ├── zip_error_get_sys_type.c
    │       │   ├── zip_error_strerror.c
    │       │   ├── zip_error_to_str.c
    │       │   ├── zip_extra_field.c
    │       │   ├── zip_extra_field_api.c
    │       │   ├── zip_fclose.c
    │       │   ├── zip_fdopen.c
    │       │   ├── zip_file_add.c
    │       │   ├── zip_file_error_clear.c
    │       │   ├── zip_file_error_get.c
    │       │   ├── zip_file_get_comment.c
    │       │   ├── zip_file_get_external_attributes.c
    │       │   ├── zip_file_get_offset.c
    │       │   ├── zip_file_rename.c
    │       │   ├── zip_file_replace.c
    │       │   ├── zip_file_set_comment.c
    │       │   ├── zip_file_set_external_attributes.c
    │       │   ├── zip_file_set_mtime.c
    │       │   ├── zip_file_strerror.c
    │       │   ├── zip_filerange_crc.c
    │       │   ├── zip_fopen.c
    │       │   ├── zip_fopen_encrypted.c
    │       │   ├── zip_fopen_index.c
    │       │   ├── zip_fopen_index_encrypted.c
    │       │   ├── zip_fread.c
    │       │   ├── zip_get_archive_comment.c
    │       │   ├── zip_get_archive_flag.c
    │       │   ├── zip_get_compression_implementation.c
    │       │   ├── zip_get_encryption_implementation.c
    │       │   ├── zip_get_file_comment.c
    │       │   ├── zip_get_name.c
    │       │   ├── zip_get_num_entries.c
    │       │   ├── zip_get_num_files.c
    │       │   ├── zip_io_util.c
    │       │   ├── zip_memdup.c
    │       │   ├── zip_name_locate.c
    │       │   ├── zip_new.c
    │       │   ├── zip_open.c
    │       │   ├── zip_rename.c
    │       │   ├── zip_replace.c
    │       │   ├── zip_set_archive_comment.c
    │       │   ├── zip_set_archive_flag.c
    │       │   ├── zip_set_default_password.c
    │       │   ├── zip_set_file_comment.c
    │       │   ├── zip_set_file_compression.c
    │       │   ├── zip_set_name.c
    │       │   ├── zip_source_begin_write.c
    │       │   ├── zip_source_buffer.c
    │       │   ├── zip_source_call.c
    │       │   ├── zip_source_close.c
    │       │   ├── zip_source_commit_write.c
    │       │   ├── zip_source_crc.c
    │       │   ├── zip_source_deflate.c
    │       │   ├── zip_source_error.c
    │       │   ├── zip_source_file.c
    │       │   ├── zip_source_filep.c
    │       │   ├── zip_source_free.c
    │       │   ├── zip_source_function.c
    │       │   ├── zip_source_is_deleted.c
    │       │   ├── zip_source_layered.c
    │       │   ├── zip_source_open.c
    │       │   ├── zip_source_pkware.c
    │       │   ├── zip_source_read.c
    │       │   ├── zip_source_remove.c
    │       │   ├── zip_source_rollback_write.c
    │       │   ├── zip_source_seek.c
    │       │   ├── zip_source_seek_write.c
    │       │   ├── zip_source_stat.c
    │       │   ├── zip_source_supports.c
    │       │   ├── zip_source_tell.c
    │       │   ├── zip_source_tell_write.c
    │       │   ├── zip_source_window.c
    │       │   ├── zip_source_write.c
    │       │   ├── zip_source_zip.c
    │       │   ├── zip_source_zip_new.c
    │       │   ├── zip_stat.c
    │       │   ├── zip_stat_index.c
    │       │   ├── zip_stat_init.c
    │       │   ├── zip_strerror.c
    │       │   ├── zip_string.c
    │       │   ├── zip_unchange.c
    │       │   ├── zip_unchange_all.c
    │       │   ├── zip_unchange_archive.c
    │       │   ├── zip_unchange_data.c
    │       │   ├── zip_utf-8.c
    │       │   ├── zipconf.h
    │       │   └── zipint.h
    │       └── testDumpMem.cpp
    ├── testKo
    │   └── jni
    │       ├── Android.mk
    │       ├── Application.mk
    │       ├── IMemReaderWriterProxy.h
    │       ├── IoctlBufferPool.h
    │       ├── MemoryReaderWriter39.h
    │       └── testKo.cpp
    ├── testMemSearch
    │   └── jni
    │       ├── Android.mk
    │       ├── Application.mk
    │       ├── MapRegionHelper.h
    │       ├── MapRegionType.h
    │       ├── MemSearchKit
    │       │   ├── MemSearchKitCompVal.h
    │       │   ├── MemSearchKitCore.h
    │       │   ├── MemSearchKitReverseAddrOffsetLink.h
    │       │   ├── MemSearchKitSafeMap.h
    │       │   ├── MemSearchKitSafeVector.h
    │       │   ├── MemSearchKitSafeWorkBlockWrapper.h
    │       │   ├── MemSearchKitSafeWorkSecWrapper.h
    │       │   ├── MemSearchKitString.h
    │       │   └── MemSearchKitUmbrella.h
    │       ├── ProcMapsFileReader.h
    │       └── testMemSearch.cpp
    └── testTarget
        └── jni
            ├── Android.mk
            ├── Application.mk
            └── testTarget.cpp

```

`README.md`:

```md
# 驱动1名称：Linux ARM64内核硬件进程内存读写驱动39
本驱动支持所有能解锁BL的手机，无论小米、黑鲨、红魔、ROG、一加、三星、摩托罗拉等等，并且不需要手机厂商开放内核源码。只需要手动修改五六处地方，就可以跑在任意机型的内核上！具体修改过程不再本文章的论述中。本文章仅提供驱动源代码。

### 本驱动接口列表：
1.  驱动_打开进程: OpenProcess
2.  驱动_读取进程内存: ReadProcessMemory
3.  驱动_写入进程内存: WriteProcessMemory
4.  驱动_关闭进程: CloseHandle
5.  驱动_获取进程内存块列表: VirtualQueryExFull（可选：显示全部内存、仅显示物理内存）
6.  驱动_获取进程PID列表: GetPidList
7.  驱动_提升进程权限到Root: SetProcessRoot
8.  驱动_获取进程占用物理内存大小: GetProcessPhyMemSize
9.  驱动_获取进程命令行: GetProcessCmdline
10.  驱动_隐藏驱动: HideKernelModule

# 驱动2名称: Linux ARM64内核硬件断点进程调试驱动3
### 本驱动接口列表：
1.  驱动_打开进程: OpenProcess
2.  驱动_关闭进程: CloseHandle
3.  驱动_获取CPU支持硬件执行断点的数量: GetNumBRPS
4.  驱动_获取CPU支持硬件访问断点的数量: GetNumWRPS
5.  驱动_设置进程硬件断点: AddProcessHwBp
6.  驱动_删除进程硬件断点: DelProcessHwBp
7.  驱动_暂停硬件断点: SuspendProcessHwBp
8.  驱动_恢复硬件断点: ResumeProcessHwBp
9.  驱动_读取硬件断点命中信息: ReadHwBpInfo
10. 驱动_设置无条件Hook跳转: SetHookPC

## 目录说明：
> **rwProcMem33Module**：进程内存读写驱动
>>* **rwProcMem_module**：（*内核层*）驱动源码
>>* **testKo**：（*应用层*）调用驱动demo
>>* **testTarget**：（*应用层*）读取第三方进程demo
>>* **testMemSearch**：（*应用层*）搜索第三方进程内存demo
>>* **testDumpMem**：（*应用层*）保存第三方进程内存demo
>>* **testCEServer**：（*应用层*）CheatEngine远程服务器，可配合CheatEngine7.1远程连接使用

> **hwBreakpointProcModule**：硬件断点进程调试驱动
>>* **hwBreakpointProc_module**：（*内核层*）驱动源码
>>* **testHwBp**：（*应用层*）调用驱动demo
>>* **testHwBpTarget**：（*应用层*）硬件断点第三方进程demo
>>* **testHwBpClient**：（*应用层*）硬件断点工具之远程客户端
>>* **testHwBpServer**：（*应用层*）硬件断点工具之远程服务端

## 更新日志：
2025-7（读写驱动）：
  * **1.去除无用接口**
  * **2.修复驱动进程列表获取缺陷**
  * **3.修复驱动maps列表获取的一些bug**
  * **4.修复android15兼容性问题**
  * **5.新增一种驱动隐蔽通信手段**
  
2025-5（读写驱动）：
  * **1.支持Linux6.6**

2024-10（硬件断点驱动）：
  * **1.支持Linux5.10、6.1**
  * **2.修复硬件断点会卡死的bug**
  * **3.修复搜索Kit的一些bug**

```

`hwBreakpointProcModule/hwBreakpointProc_module/Makefile`:

```
obj-m += hwBreakpointProc_module.o

```

`hwBreakpointProcModule/hwBreakpointProc_module/anti_ptrace_detection.h`:

```h
#ifndef _ANTI_PTRACE_DETECTION_H_
#define _ANTI_PTRACE_DETECTION_H_
#include <linux/types.h>
#include <linux/errno.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <linux/hw_breakpoint.h>
#include <linux/kprobes.h>

#define PTRACE_GETREGSET   0x4204
#define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
#define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */

struct hook_ptrace_data {
    struct iovec iov;
};

static struct mutex *g_p_hwbp_handle_info_mutex = NULL;
static cvector *g_p_hwbp_handle_info_arr = NULL;

static bool is_my_hwbp_handle_addr(size_t addr) {
	citerator iter;
	bool found = false;
	if(addr == 0) {
		return found;
	}
	mutex_lock(g_p_hwbp_handle_info_mutex);
	for (iter = cvector_begin(*g_p_hwbp_handle_info_arr); iter != cvector_end(*g_p_hwbp_handle_info_arr); iter = cvector_next(*g_p_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if(hwbp_handle_info->original_attr.bp_addr == addr) {
			found = true;
			break;
		}
	}
	mutex_unlock(g_p_hwbp_handle_info_mutex);
	return found;
}

static int entry_ptrace_handler(struct kretprobe_instance *ri, struct pt_regs *regs) {
    long request = regs->regs[1];
    unsigned long addr = (unsigned long)regs->regs[2];
    struct hook_ptrace_data *data = (struct hook_ptrace_data *)ri->data;
    data->iov.iov_base = 0;
    data->iov.iov_len = 0;
    printk_debug(KERN_INFO "entry_ptrace_handler called with request: %lx, addr: %lx\n", request, addr);
    if (request == PTRACE_GETREGSET && (addr == NT_ARM_HW_WATCH || addr == NT_ARM_HW_BREAK)) {
        unsigned long iov_user_ptr = regs->regs[3];
        printk_debug(KERN_INFO "entry_ptrace_handler called with request: %lx, addr: %lx, iov_user_ptr: %lx\n", request, addr, iov_user_ptr);
        if(!iov_user_ptr) {
            return 0;
        }
        if (x_copy_from_user(&data->iov, (struct iovec __user *)iov_user_ptr, sizeof(struct iovec)) != 0) {
            printk_debug(KERN_INFO "Failed to copy iovec from user space\n");
            return 0;
        }
        printk_debug(KERN_INFO "entry_ptrace_handler iov_base: %lx, iov_len %ld\n", data->iov.iov_base, data->iov.iov_len);
    }
    return 0;
}
static int ret_ptrace_handler(struct kretprobe_instance *ri, struct pt_regs *regs) {
    unsigned long retval = regs_return_value(regs);
    struct hook_ptrace_data *data = (struct hook_ptrace_data *)ri->data;
    struct user_hwdebug_state old_hw_state;
    struct user_hwdebug_state new_hw_state;
    size_t copy_size;
    int i = 0, y = 0;
    printk_debug(KERN_INFO "ret_ptrace_handler called with retval: %lx, iov_base: %lx, iov_len %ld\n", retval, data->iov.iov_base, data->iov.iov_len);
    if (!data->iov.iov_base || !data->iov.iov_len) {
        return 0;
    }
    
    // Check if the buffer of the IoV is readable and writable
    if (!access_ok((void __user *)data->iov.iov_base, data->iov.iov_len)) {
        printk_debug(KERN_INFO "User buffer is not accessible\n");
        return 0;
    }
    copy_size = min(data->iov.iov_len, sizeof(struct user_hwdebug_state));
    if (x_copy_from_user(&old_hw_state, (void __user *)data->iov.iov_base, copy_size) != 0) {
        printk_debug(KERN_INFO "Failed to copy old_hw_state from user buffer\n");
        return 0;
    }
    // After x_copy_from_user
    printk_debug(KERN_INFO "Original old_hw_state.dbg_info: %u, size %ld\n", old_hw_state.dbg_info, copy_size);
    for (i = 0; i < 16; i++) {
        printk_debug(KERN_INFO "Reg %d: addr=%llu, ctrl=%u\n", i, old_hw_state.dbg_regs[i].addr, old_hw_state.dbg_regs[i].ctrl);
    }
    // Clear the dbd_regs array
    memcpy(&new_hw_state, &old_hw_state, sizeof(new_hw_state));
    memset(new_hw_state.dbg_regs, 0x00, sizeof(new_hw_state.dbg_regs));

    printk_debug(KERN_INFO "After memset:\n");
    for (i = 0; i < sizeof(old_hw_state.dbg_regs) / sizeof(old_hw_state.dbg_regs[0]); i++) {
        if(!is_my_hwbp_handle_addr(old_hw_state.dbg_regs[i].addr)) {
            memcpy(&new_hw_state.dbg_regs[y++], &old_hw_state.dbg_regs[i], sizeof(old_hw_state.dbg_regs[i]));
        }
    }

    printk_debug(KERN_INFO "After memset:\n");
    for (i = 0; i < 16; i++) {
        printk_debug(KERN_INFO "Reg %d: addr=%llu, ctrl=%u\n", i, new_hw_state.dbg_regs[i].addr, new_hw_state.dbg_regs[i].ctrl);
    }

    // Copy the modified hw_ste back to the buffer in user space
    if (x_copy_to_user((void __user *)data->iov.iov_base, &new_hw_state, copy_size) != 0) {
        printk_debug(KERN_INFO "Failed to copy modified new_hw_state back to user buffer\n");
    } else {
        printk_debug(KERN_INFO "Successfully cleared dbg_regs in user_hwdebug_state\n");
    }
    return 0;
}


static struct kretprobe kretp_ptrace = {
    .kp.symbol_name    = "arch_ptrace",
    .data_size  = sizeof(struct hook_ptrace_data),
    .entry_handler    = entry_ptrace_handler,
    .handler    = ret_ptrace_handler,
    .maxactive  = 20,
};

static bool start_anti_ptrace_detection(struct mutex *p_hwbp_handle_info_mutex, cvector *p_hwbp_handle_info_arr) {
    int ret = 0;
    g_p_hwbp_handle_info_mutex = p_hwbp_handle_info_mutex;
    g_p_hwbp_handle_info_arr = p_hwbp_handle_info_arr;
    if(!g_p_hwbp_handle_info_mutex || !g_p_hwbp_handle_info_arr) {
        printk_debug(KERN_INFO "start_anti_ptrace_detection param error\n");
        return false;
    }
    ret = register_kretprobe(&kretp_ptrace);
    if (ret < 0) {
        printk_debug(KERN_INFO "register_kretprobe failed, returned %d\n", ret);
        return false;
    }
    printk_debug(KERN_INFO "kretprobe at %s registered, addr: %lx\n", kretp_ptrace.kp.symbol_name, kretp_ptrace.kp.addr);
	return true;
}


static void stop_anti_ptrace_detection(void) {
    if(kretp_ptrace.kp.addr) {
        unregister_kretprobe(&kretp_ptrace);
        printk_debug(KERN_INFO "kretprobe unregistered\n");
    }
}

#endif

```

`hwBreakpointProcModule/hwBreakpointProc_module/api_proxy.h`:

```h
#ifndef _API_PROXY_H_
#define _API_PROXY_H_
#include "ver_control.h"

#ifdef CONFIG_KALLSYMS_LOOKUP_NAME
#include "kallsyms_lookup_api.h"
static struct perf_event* x_register_user_hw_breakpoint(struct perf_event_attr *attr, perf_overflow_handler_t triggered, void *context, struct task_struct *tsk) {
	return register_user_hw_breakpoint_sym(attr, triggered, context, tsk);
}

static void x_unregister_hw_breakpoint(struct perf_event *bp) {
	unregister_hw_breakpoint_sym(bp);
}

static int x_modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr) {
	return modify_user_hw_breakpoint_sym(bp, attr);
}
#else
static struct perf_event* x_register_user_hw_breakpoint(struct perf_event_attr *attr, perf_overflow_handler_t triggered, void *context, struct task_struct *tsk) {
	return register_user_hw_breakpoint(attr, triggered, context, tsk);
}

static void x_unregister_hw_breakpoint(struct perf_event *bp) {
	unregister_hw_breakpoint(bp);
}

static int x_modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr) {
	return modify_user_hw_breakpoint(bp, attr);
}
#endif

static void * x_kmalloc(size_t size, gfp_t flags) {
	return __kmalloc(size, flags);
}

static unsigned long x_copy_from_user(void *to, const void __user *from, unsigned long n) {
	return __arch_copy_from_user(to, from, n);
}

static unsigned long x_copy_to_user(void __user *to, const void *from, unsigned long n) {
	return __arch_copy_to_user(to, from, n);
}
#endif

```

`hwBreakpointProcModule/hwBreakpointProc_module/arm64_register_helper.h`:

```h
# ifndef __ARM64_REGISTER_HELPER_H__
# define __ARM64_REGISTER_HELPER_H__
#include <linux/module.h>
#include <linux/types.h>
#include <linux/uaccess.h>
#include <linux/kernel.h>
#include <linux/hw_breakpoint.h>

#define READ_WB_REG_CASE(OFF, N, REG, VAL)	\
	case (OFF + N):				\
		AARCH64_DBG_READ(N, REG, VAL);	\
		break

#define WRITE_WB_REG_CASE(OFF, N, REG, VAL)	\
	case (OFF + N):				\
		AARCH64_DBG_WRITE(N, REG, VAL);	\
		break

#define GEN_READ_WB_REG_CASES(OFF, REG, VAL)	\
	READ_WB_REG_CASE(OFF,  0, REG, VAL);	\
	READ_WB_REG_CASE(OFF,  1, REG, VAL);	\
	READ_WB_REG_CASE(OFF,  2, REG, VAL);	\
	READ_WB_REG_CASE(OFF,  3, REG, VAL);	\
	READ_WB_REG_CASE(OFF,  4, REG, VAL);	\
	READ_WB_REG_CASE(OFF,  5, REG, VAL);	\
	READ_WB_REG_CASE(OFF,  6, REG, VAL);	\
	READ_WB_REG_CASE(OFF,  7, REG, VAL);	\
	READ_WB_REG_CASE(OFF,  8, REG, VAL);	\
	READ_WB_REG_CASE(OFF,  9, REG, VAL);	\
	READ_WB_REG_CASE(OFF, 10, REG, VAL);	\
	READ_WB_REG_CASE(OFF, 11, REG, VAL);	\
	READ_WB_REG_CASE(OFF, 12, REG, VAL);	\
	READ_WB_REG_CASE(OFF, 13, REG, VAL);	\
	READ_WB_REG_CASE(OFF, 14, REG, VAL);	\
	READ_WB_REG_CASE(OFF, 15, REG, VAL)

#define GEN_WRITE_WB_REG_CASES(OFF, REG, VAL)	\
	WRITE_WB_REG_CASE(OFF,  0, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF,  1, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF,  2, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF,  3, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF,  4, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF,  5, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF,  6, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF,  7, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF,  8, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF,  9, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF, 10, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF, 11, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF, 12, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF, 13, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF, 14, REG, VAL);	\
	WRITE_WB_REG_CASE(OFF, 15, REG, VAL)

static int getCpuNumBrps(void) {
	return ((read_cpuid(ID_AA64DFR0_EL1) >> 12) & 0xf) + 1;
}

static int getCpuNumWrps(void) {
	return ((read_cpuid(ID_AA64DFR0_EL1) >> 20) & 0xf) + 1;
}

static uint64_t read_wb_reg(int reg, int n)
{
	uint64_t val = 0;

	switch (reg + n) {
	GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_BVR, AARCH64_DBG_REG_NAME_BVR, val);
	GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_BCR, AARCH64_DBG_REG_NAME_BCR, val);
	GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_WVR, AARCH64_DBG_REG_NAME_WVR, val);
	GEN_READ_WB_REG_CASES(AARCH64_DBG_REG_WCR, AARCH64_DBG_REG_NAME_WCR, val);
	default:
		pr_warn("attempt to read from unknown breakpoint register %d\n", n);
	}

	return val;
}

static void write_wb_reg(int reg, int n, uint64_t val)
{
	switch (reg + n) {
	GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_BVR, AARCH64_DBG_REG_NAME_BVR, val);
	GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_BCR, AARCH64_DBG_REG_NAME_BCR, val);
	GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_WVR, AARCH64_DBG_REG_NAME_WVR, val);
	GEN_WRITE_WB_REG_CASES(AARCH64_DBG_REG_WCR, AARCH64_DBG_REG_NAME_WCR, val);
	default:
		pr_warn("attempt to write to unknown breakpoint register %d\n", n);
	}
	isb();
}

static uint64_t calc_hw_addr(const struct perf_event_attr* attr, bool is_32bit_task) {
	uint64_t alignment_mask, hw_addr;
	if(!attr) {
		return 0;
	}
	if (is_32bit_task) {
		if (attr->bp_len == HW_BREAKPOINT_LEN_8)
			alignment_mask = 0x7;
		else
			alignment_mask = 0x3;
	} else {
		if (attr->type == HW_BREAKPOINT_X)
			alignment_mask = 0x3;
		else
			alignment_mask = 0x7;
	}
	hw_addr = attr->bp_addr;
	hw_addr &= ~alignment_mask;
	return hw_addr;
}

static bool toggle_bp_registers_directly(const struct perf_event_attr * attr, bool is_32bit_task, int enable) {
	int i, max_slots, val_reg, ctrl_reg, cur_slot;
    u32 ctrl;
	uint64_t hw_addr = calc_hw_addr(attr, is_32bit_task);
	if(!attr) {
		return false;
	}

	switch (attr->bp_type)
	{
	case HW_BREAKPOINT_R:
	case HW_BREAKPOINT_W:
	case HW_BREAKPOINT_RW:
		ctrl_reg = AARCH64_DBG_REG_WCR;
		val_reg = AARCH64_DBG_REG_WVR;
		max_slots = getCpuNumWrps();
		break;
	case HW_BREAKPOINT_X:
		ctrl_reg = AARCH64_DBG_REG_BCR;
		val_reg = AARCH64_DBG_REG_BVR;
		max_slots = getCpuNumBrps();
		break;
	default:
		return false;
	}
	cur_slot = -1;

    for (i = 0; i < max_slots; ++i) {
		uint64_t addr = read_wb_reg(val_reg, i);
        if(addr == hw_addr) {
			cur_slot = i;
			break;
		}
    }
	if(cur_slot == -1) {
		return false;
	} 

    ctrl = read_wb_reg(ctrl_reg, cur_slot);
	if (enable)
		ctrl |= 0x1;
	else
		ctrl &= ~0x1;
	write_wb_reg(ctrl_reg, cur_slot, ctrl);
	return true;
}
#endif


```

`hwBreakpointProcModule/hwBreakpointProc_module/cvector.h`:

```h
# ifndef __CVECTOR_H__
# define __CVECTOR_H__

#include <linux/types.h>
# define MIN_LEN 1024
# define CVEFAILED  -1
# define CVESUCCESS  0
# define CVEPUSHBACK 1
# define CVEPOPBACK  2
# define CVEINSERT   3
# define CVERM       4
# define EXPANED_VAL 1
# define REDUSED_VAL 2

typedef void *citerator;
typedef struct _cvector *cvector;

# ifdef __cplusplus
extern "C" {
# endif
	
	cvector   cvector_create(const size_t size                           );
	void      cvector_destroy  (const cvector cv                            );
	size_t    cvector_length   (const cvector cv                            );
	int       cvector_pushback (const cvector cv, void *memb                );
	int       cvector_popback  (const cvector cv, void *memb                );
	size_t    cvector_iter_at  (const cvector cv, citerator iter            );
	int       cvector_iter_val (const cvector cv, citerator iter, void *memb);
	citerator cvector_begin    (const cvector cv                            );
	citerator cvector_end      (const cvector cv                            );
	citerator cvector_next     (const cvector cv, citerator iter            );
	int       cvector_val_at   (const cvector cv, size_t index, void *memb  );
	int       cvector_insert   (const cvector cv, citerator iter, void *memb);
	int       cvector_insert_at(const cvector cv, size_t index, void *memb  );
	int       cvector_rm       (const cvector cv, citerator iter            );
	int       cvector_rm_at    (const cvector cv, size_t index              );
	
	/* for test  */
	void      cv_info          (const cvector cv                            );
	void      cv_print         (const cvector cv                            );

# ifdef __cplusplus
}
# endif

#endif /* EOF file cvector.h */


 
// #include "cvector.h"
// 
// int main()
// {
// 	int i = 1;
// 	cvector cv = cvector_create(sizeof(int));
// 	cvector_pushback(cv, &i);
// 	cvector_pushback(cv, &i);
// 	cvector_pushback(cv, &i);
// 	cvector_pushback(cv, &i);
// 	cv_print(cv);
// 	cvector_destroy(cv);
// 	return 0;
// }




#include "api_proxy.h"
#include <linux/module.h>
#include <linux/vmalloc.h>
#include <linux/slab.h>

#ifndef __gnu_linux__
//#define __func__ "unknown"
//#define inline __forceinline
#endif

# define CWARNING_ITER(cv, iter, file, func, line) \
	do {\
	if ((cvector_begin(cv) > iter) || (cvector_end(cv) <= iter)) {\
	printk(KERN_INFO "var(" #iter ") warng out of range, "\
	"at file:%s func:%s line:%d!!\n", file, func, line);\
	return CVEFAILED;\
	}\
	} while (0)

void *vmalloc_realloc(void *old_ptr, size_t old_size, size_t new_size) {
    void *new_ptr;
    if (!old_ptr) {
        return vmalloc(new_size);
    }
    if (new_size == 0) {
        vfree(old_ptr);
        return NULL;
    }
    new_ptr = vmalloc(new_size);
    if (!new_ptr) {
        pr_err("vmalloc realloc failed for size: %zu\n", new_size);
        return NULL;
    }
    memcpy(new_ptr, old_ptr, min(old_size, new_size));
    vfree(old_ptr);
    return new_ptr;
}

struct _cvector
{
	void *cv_pdata;
	size_t cv_len, cv_tot_len, cv_size;
};


cvector cvector_create(const size_t size)
{
	cvector cv = (cvector)x_kmalloc(sizeof (struct _cvector), GFP_KERNEL);

	if (!cv) return NULL;

	cv->cv_pdata = vmalloc(MIN_LEN * size);

	if (!cv->cv_pdata)
	{
		kfree(cv);
		return NULL;
	}

	cv->cv_size = size;
	cv->cv_tot_len = MIN_LEN;
	cv->cv_len = 0;

	return cv;
}  

void cvector_destroy(const cvector cv)  
{  
	vfree(cv->cv_pdata);  
	kfree(cv);
	return;  
}  

size_t cvector_length(const cvector cv)  
{  
	return cv->cv_len;  
}  

int cvector_pushback(const cvector cv, void *memb)  
{  
	if (cv->cv_len >= cv->cv_tot_len)   
	{  
		void *pd_sav = cv->cv_pdata;
		size_t old_size = cv->cv_tot_len * cv->cv_size;
		cv->cv_tot_len <<= EXPANED_VAL;
		cv->cv_pdata = vmalloc_realloc(cv->cv_pdata, old_size, cv->cv_tot_len * cv->cv_size);

		if (!cv->cv_pdata)   
		{  
			cv->cv_pdata = pd_sav;  
			cv->cv_tot_len >>= EXPANED_VAL;  
			return CVEPUSHBACK;  
		}  
	}  

	memcpy((char *)cv->cv_pdata + cv->cv_len * cv->cv_size, memb, cv->cv_size);  
	cv->cv_len++;  

	return CVESUCCESS;  
}  

int cvector_popback(const cvector cv, void *memb)  
{  
	if (cv->cv_len <= 0) return CVEPOPBACK;  

	cv->cv_len--;  
	memcpy(memb, (char *)cv->cv_pdata + cv->cv_len * cv->cv_size, cv->cv_size);  

	if ((cv->cv_tot_len >= (MIN_LEN << REDUSED_VAL))   
		&& (cv->cv_len <= (cv->cv_tot_len >> REDUSED_VAL)))   
	{  
		void *pd_sav = cv->cv_pdata;
		size_t old_size = cv->cv_tot_len * cv->cv_size;
		cv->cv_tot_len >>= EXPANED_VAL;
		cv->cv_pdata = vmalloc_realloc(cv->cv_pdata, old_size, cv->cv_tot_len * cv->cv_size);

		if (!cv->cv_pdata)   
		{  
			cv->cv_tot_len <<= EXPANED_VAL;  
			cv->cv_pdata = pd_sav;  
			return CVEPOPBACK;  
		}  
	}  

	return CVESUCCESS;  
}  

size_t cvector_iter_at(const cvector cv, citerator iter)  
{  
	CWARNING_ITER(cv, iter, __FILE__, __func__, __LINE__);  
	return ((char *)iter - (char *)cv->cv_pdata) / cv->cv_size;  
}  

int cvector_iter_val(const cvector cv, citerator iter, void *memb)  
{  
	CWARNING_ITER(cv, iter, __FILE__, __func__, __LINE__);  
	memcpy(memb, iter, cv->cv_size);  
	return 0;  
}  

citerator cvector_begin(const cvector cv)  
{  
	return cv->cv_pdata;  
}  

citerator cvector_end(const cvector cv)  
{  
	return (char *)cv->cv_pdata + (cv->cv_size * cv->cv_len);  
}  

static inline void cvmemove_foreward(const cvector cv, void *from, void *to)  
{  
	size_t size = cv->cv_size;  
	char *p;  
	for (p = (char *)to; p >= (char *)from; p -= size) memcpy(p + size, p, size);  
	return;  
}  

static inline void cvmemove_backward(const cvector cv, void *from, void *to)  
{  
	memcpy(from, (char *)from + cv->cv_size, (char *)to - (char *)from);  
	return;  
}  

int cvector_insert(const cvector cv, citerator iter, void *memb)  
{  
	CWARNING_ITER(cv, iter, __FILE__, __func__, __LINE__);  

	if (cv->cv_len >= cv->cv_tot_len)   
	{  
		void *pd_sav = cv->cv_pdata;
		size_t old_size = cv->cv_tot_len * cv->cv_size;
		cv->cv_tot_len <<= EXPANED_VAL;  
		cv->cv_pdata = vmalloc_realloc(cv->cv_pdata, old_size, cv->cv_tot_len * cv->cv_size);

		if (!cv->cv_pdata)   
		{  
			cv->cv_pdata = pd_sav;  
			cv->cv_tot_len >>= EXPANED_VAL;  
			return CVEINSERT;  
		}  
	}  

	cvmemove_foreward(cv, iter, (char *)cv->cv_pdata + cv->cv_len * cv->cv_size);  
	memcpy(iter, memb, cv->cv_size);  
	cv->cv_len++;  

	return CVESUCCESS;  
}  

int cvector_insert_at(const cvector cv, size_t index, void *memb)  
{  
	citerator iter;  

	if (index >= cv->cv_tot_len)   
	{  
		// 保存旧大小
		size_t old_size = cv->cv_tot_len * cv->cv_size;
		cv->cv_len = index + 1;  
		while (cv->cv_len >= cv->cv_tot_len) cv->cv_tot_len <<= EXPANED_VAL;  
		cv->cv_pdata = vmalloc_realloc(cv->cv_pdata, old_size, cv->cv_tot_len * cv->cv_size);
		iter = (char *)cv->cv_pdata + cv->cv_size * index;  
		memcpy(iter, memb, cv->cv_size);  
	}  
	else   
	{  
		iter = (char *)cv->cv_pdata + cv->cv_size * index;  
		cvector_insert(cv, iter, memb);  
	}  

	return 0;  
}  

citerator cvector_next(const cvector cv, citerator iter)  
{  
	return (char *)iter + cv->cv_size;  
}  

int cvector_val(const cvector cv, citerator iter, void *memb)  
{  
	memcpy(memb, iter, cv->cv_size);  
	return 0;  
}  

int cvector_val_at(const cvector cv, size_t index, void *memb)  
{  
	memcpy(memb, (char *)cv->cv_pdata + index * cv->cv_size, cv->cv_size);  
	return 0;  
}  

int cvector_rm(const cvector cv, citerator iter)  
{  
	citerator from;  
	citerator end;  
	CWARNING_ITER(cv, iter, __FILE__, __func__, __LINE__);  
	from = iter;  
	end = cvector_end(cv);  
	memcpy(from, (char *)from + cv->cv_size, (char *)end - (char *)from);  
	cv->cv_len--;  

	if ((cv->cv_tot_len >= (MIN_LEN << REDUSED_VAL))  
		&& (cv->cv_len <= (cv->cv_tot_len >> REDUSED_VAL)))   
	{  
		void *pd_sav = cv->cv_pdata;
		size_t old_size = cv->cv_tot_len * cv->cv_size;
		cv->cv_tot_len >>= EXPANED_VAL;  
		cv->cv_pdata = vmalloc_realloc(cv->cv_pdata, old_size, cv->cv_tot_len * cv->cv_size);

		if (!cv->cv_pdata)   
		{  
			cv->cv_tot_len <<= EXPANED_VAL;  
			cv->cv_pdata = pd_sav;  
			return CVERM;  
		}  
	}  

	return CVESUCCESS;  
}  

int cvector_rm_at(const cvector cv, size_t index)  
{  
	citerator iter;  
	iter = (char *)cv->cv_pdata + cv->cv_size * index;  
	CWARNING_ITER(cv, iter, __FILE__, __func__, __LINE__);  
	return cvector_rm(cv, iter);  
}  

void cv_info(const cvector cv)  
{  
	printk("\n\ntot :%s : %zu\n", __func__, cv->cv_tot_len);  
	printk("len :%s : %zu\n",     __func__, cv->cv_len);  
	printk("size:%s : %zu\n\n",   __func__, cv->cv_size);  
	return;  
}  

void cv_print(const cvector cv)  
{  
	int num;  
	citerator iter;  

	if (cvector_length(cv) == 0)  
		printk(KERN_INFO "file:%s func:%s line:%d error, null length cvector!!\n", __FILE__, __func__, __LINE__);  

	for (iter = cvector_begin(cv);   
		iter != cvector_end(cv);  
		iter = cvector_next(cv, iter))   
	{  
		cvector_iter_val(cv, iter, &num);  
		printk("var:%d at:%zu\n", num, cvector_iter_at(cv, iter));  
	}


	return;  
}

```

`hwBreakpointProcModule/hwBreakpointProc_module/hide_procfs_dir.h`:

```h
#ifndef _HIDE_PROCFS_DIR_H_
#define _HIDE_PROCFS_DIR_H_

#include "ver_control.h"

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kprobes.h>
#include <linux/moduleparam.h>
#include <linux/fs.h>
#include <linux/string.h>

static char g_hide_dir_name[256] = {0};

static filldir_t old_filldir;

#if MY_LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
static int my_filldir(struct dir_context *buf,
                      const char *name,
                      int namelen,
                      loff_t offset,
                      u64 ino,
                      unsigned int d_type)
{
    if (namelen == strlen(g_hide_dir_name) &&
        !strncmp(name, g_hide_dir_name, namelen))
    {
        return 0;
    }
    return old_filldir(buf, name, namelen, offset, ino, d_type);
}
#else
static bool my_filldir(struct dir_context *ctx,
                       const char *name,
                       int namelen,
                       loff_t offset,
                       u64 ino,
                       unsigned int d_type)
{
    if (namelen == strlen(g_hide_dir_name) &&
        !strncmp(name, g_hide_dir_name, namelen))
    {
        return true;
    }
    return old_filldir(ctx, name, namelen, offset, ino, d_type);
}
#endif

static int handler_pre(struct kprobe *kp, struct pt_regs *regs)
{
    struct dir_context *ctx = (struct dir_context *)regs->regs[1];
    old_filldir = ctx->actor;
    ctx->actor = my_filldir;
    return 0;
}

static struct kprobe kp_hide_procfs_dir = {
    .symbol_name = "proc_root_readdir",
    .pre_handler = handler_pre,
};

static bool start_hide_procfs_dir(const char* hide_dir_name)
{
	//这里原理上可以换成SKRoot的汇编写法。避免kprobe。
    int ret;
    strlcpy(g_hide_dir_name, hide_dir_name, sizeof(g_hide_dir_name));
    ret = register_kprobe(&kp_hide_procfs_dir);
    if (ret) {
        printk_debug("[hide_procfs_dir] register_kprobe failed: %d\n", ret);
        return false;
    }
    printk_debug("[hide_procfs_dir] kprobe installed, hiding \"%s\"\n", g_hide_dir_name);
    return true;
}

static void stop_hide_procfs_dir(void)
{
    unregister_kprobe(&kp_hide_procfs_dir);
    printk_debug("[hide_procfs_dir] kprobe removed\n");
}

#endif  // _HIDE_PROCFS_DIR_H_

```

`hwBreakpointProcModule/hwBreakpointProc_module/hwBreakpointProc_module.c`:

```c
#include "hwBreakpointProc_module.h"
#include "proc_pid.h"
#include "api_proxy.h"
#include "anti_ptrace_detection.h"


#pragma pack(push,1)
struct ioctl_request {
    char     cmd;        /* 1 字节命令 */
    uint64_t param1;     /* 参数1 */
    uint64_t param2;     /* 参数2 */
    uint64_t param3;     /* 参数3 */
    uint64_t buf_size;    /* 紧随其后的动态数据长度 */
};
#pragma pack(pop)
//////////////////////////////////////////////////////////////////

static atomic64_t g_hook_pc;


static struct mutex g_hwbp_handle_info_mutex;
static cvector g_hwbp_handle_info_arr = NULL;

static void record_hit_details(struct HWBP_HANDLE_INFO *info, struct pt_regs *regs) {
    struct HWBP_HIT_ITEM hit_item = {0};
	if (!info || !regs) {
        return;
    }
	hit_item.task_id = info->task_id;
    hit_item.hit_addr = regs->pc;
	hit_item.hit_time = ktime_get_real_seconds();
    memcpy(&hit_item.regs_info.regs, regs->regs, sizeof(hit_item.regs_info.regs));
    hit_item.regs_info.sp = regs->sp;
    hit_item.regs_info.pc = regs->pc;
    hit_item.regs_info.pstate = regs->pstate;
    hit_item.regs_info.orig_x0 = regs->orig_x0;
    hit_item.regs_info.syscallno = regs->syscallno;
    if (info->hit_item_arr) {
		if(cvector_length(info->hit_item_arr) < MIN_LEN) { // 最多存放MIN_LEN个
			cvector_pushback(info->hit_item_arr, &hit_item);
		}
    }
}

#ifdef CONFIG_MODIFY_HIT_NEXT_MODE
static bool arm64_move_bp_to_next_instruction(struct perf_event *bp, uint64_t next_instruction_addr, struct perf_event_attr *original_attr, struct perf_event_attr * next_instruction_attr) {
    int result;
	if (!bp || !original_attr || !next_instruction_attr || !next_instruction_addr) {
        return false;
    }
	memcpy(next_instruction_attr, original_attr, sizeof(struct perf_event_attr));
	next_instruction_attr->bp_addr = next_instruction_addr;
	next_instruction_attr->bp_len = HW_BREAKPOINT_LEN_4;
	next_instruction_attr->bp_type = HW_BREAKPOINT_X;
	next_instruction_attr->disabled = 0;
	result = x_modify_user_hw_breakpoint(bp, next_instruction_attr);
	if(result) {
		next_instruction_attr->bp_addr = 0;
		return false;
	}
	return true;
}

static bool arm64_recovery_bp_to_original(struct perf_event *bp, struct perf_event_attr *original_attr, struct perf_event_attr * next_instruction_attr) {
    int result;
	if (!bp || !original_attr || !next_instruction_attr) {
        return false;
    }
	result = x_modify_user_hw_breakpoint(bp, original_attr);
	if(result) {
		return false;
	}
	next_instruction_attr->bp_addr = 0;
	return true;
}
#endif

static void hwbp_hit_user_info_callback(struct perf_event *bp,
	struct perf_sample_data *data,
	struct pt_regs *regs, struct HWBP_HANDLE_INFO * hwbp_handle_info) {
	hwbp_handle_info->hit_total_count++;
	record_hit_details(hwbp_handle_info, regs);
}

/*
 * Handle hitting a HW-breakpoint.
 */
static void hwbp_handler(struct perf_event *bp,
	struct perf_sample_data *data,
	struct pt_regs *regs) {
	citerator iter;
	uint64_t hook_pc;
	printk_debug(KERN_INFO "hw_breakpoint HIT!!!!! bp:%px, pc:%px, id:%d\n", bp, regs->pc, bp->id);

	hook_pc = atomic64_read(&g_hook_pc);
	if(hook_pc) {
		regs->pc = hook_pc;
		return;
	}

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if (hwbp_handle_info->sample_hbp != bp) {
			continue;
		}
#ifdef CONFIG_MODIFY_HIT_NEXT_MODE
		if(hwbp_handle_info->next_instruction_attr.bp_addr != regs->pc) {
			// first hit
			bool should_toggle = true;
			hwbp_hit_user_info_callback(bp, data, regs, hwbp_handle_info);
			if(!hwbp_handle_info->is_32bit_task) {
				if(arm64_move_bp_to_next_instruction(bp, regs->pc + 4, &hwbp_handle_info->original_attr, &hwbp_handle_info->next_instruction_attr)) {
					should_toggle = false;
				}
			}
			if(should_toggle) {
				toggle_bp_registers_directly(&hwbp_handle_info->original_attr, hwbp_handle_info->is_32bit_task, 0);
			}
		} else {
			// second hit
			if(!arm64_recovery_bp_to_original(bp, &hwbp_handle_info->original_attr, &hwbp_handle_info->next_instruction_attr)) {
				toggle_bp_registers_directly(&hwbp_handle_info->next_instruction_attr, hwbp_handle_info->is_32bit_task, 0);
			}
		}
#else
		hwbp_hit_user_info_callback(bp, data, regs, hwbp_handle_info);
		toggle_bp_registers_directly(&hwbp_handle_info->original_attr, hwbp_handle_info->is_32bit_task, 0);
#endif
	}
	
	mutex_unlock(&g_hwbp_handle_info_mutex);
}



static ssize_t OnCmdOpenProcess(struct ioctl_request *hdr, char __user* buf) {
	uint64_t pid = hdr->param1, handle = 0;
	struct pid * proc_pid_struct = NULL;
	printk_debug(KERN_INFO "CMD_OPEN_PROCESS\n");

	printk_debug(KERN_INFO "pid:%llu,size:%ld\n", pid, sizeof(pid));

	proc_pid_struct = get_proc_pid_struct(pid);
	printk_debug(KERN_INFO "proc_pid_struct *:0x%p\n", (void*)proc_pid_struct);
	if (!proc_pid_struct) {
		return -EINVAL;
	}
	handle = (uint64_t)proc_pid_struct;

	printk_debug(KERN_INFO "handle:%llu,size:%ld\n", handle, sizeof(handle));
	if (!!x_copy_to_user((void*)buf, (void*)&handle, sizeof(handle))) {
		return -EINVAL;
	}
	return 0;
}

static ssize_t OnCmdCloseProcess(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	printk_debug(KERN_INFO "CMD_CLOSE_PROCESS\n");
	printk_debug(KERN_INFO "proc_pid_struct*:0x%p,size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));
	release_proc_pid_struct(proc_pid_struct);
	return 0;
}

static ssize_t OnCmdGetCpuNumBrps(struct ioctl_request *hdr, char __user* buf) {
	printk_debug(KERN_INFO "CMD_GET_NUM_BRPS\n");
	return getCpuNumBrps();
}

static ssize_t OnCmdGetCpuNumWrps(struct ioctl_request *hdr, char __user* buf) {
	printk_debug(KERN_INFO "CMD_GET_NUM_WRPS\n");
	return getCpuNumWrps();
}

static ssize_t OnCmdInstProcessHwbp(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	uint64_t proc_virt_addr = hdr->param2;
	char hwbp_len  =  hdr->param3 & 0xFF;
	char hwbp_type = (hdr->param3 >> 8) & 0xFF;

	pid_t pid_val;
	struct task_struct *task;
	struct HWBP_HANDLE_INFO hwbp_handle_info = { 0 };
	printk_debug(KERN_INFO "CMD_INST_PROCESS_HWBP\n");
	printk_debug(KERN_INFO "proc_pid_struct *:%px\n", proc_pid_struct);
	printk_debug(KERN_INFO "proc_virt_addr :%px\n", proc_virt_addr);
	printk_debug(KERN_INFO "hwbp_len:%zu\n", hwbp_len);
	printk_debug(KERN_INFO "hwbp_type:%d\n", hwbp_type);

	pid_val = pid_nr(proc_pid_struct);
	printk_debug(KERN_INFO "pid_val:%d\n", pid_val);

	if (!pid_val) {
		printk_debug(KERN_INFO "pid_nr failed.\n");
		return -EINVAL;
	}

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		printk_debug(KERN_INFO "get_pid_task failed.\n");
		return -EINVAL;
	}
	
	hwbp_handle_info.task_id = pid_val;
	hwbp_handle_info.is_32bit_task = is_compat_thread(task_thread_info(task));
	ptrace_breakpoint_init(&hwbp_handle_info.original_attr);
	hwbp_handle_info.original_attr.bp_addr = proc_virt_addr;
	hwbp_handle_info.original_attr.bp_len = hwbp_len;
	hwbp_handle_info.original_attr.bp_type = hwbp_type;
	hwbp_handle_info.original_attr.disabled = 0;

	hwbp_handle_info.sample_hbp = x_register_user_hw_breakpoint(&hwbp_handle_info.original_attr, hwbp_handler, NULL, task);
	printk_debug(KERN_INFO "register_user_hw_breakpoint return: %px\n", hwbp_handle_info.sample_hbp);
	if (IS_ERR((void __force *)hwbp_handle_info.sample_hbp)) {
		int ret = PTR_ERR((void __force *)hwbp_handle_info.sample_hbp);
		printk_debug(KERN_INFO "register_user_hw_breakpoint failed: %d\n", ret);
		return ret;
	}
	hwbp_handle_info.hit_item_arr = cvector_create(sizeof(struct HWBP_HIT_ITEM));
	mutex_lock(&g_hwbp_handle_info_mutex);
	cvector_pushback(g_hwbp_handle_info_arr, &hwbp_handle_info);
	mutex_unlock(&g_hwbp_handle_info_mutex);

	if (x_copy_to_user((void*)buf, &hwbp_handle_info.sample_hbp, sizeof(uint64_t))) {
		return -EINVAL;
	}
	return 0;
}

static ssize_t OnCmdUninstProcessHwbp(struct ioctl_request *hdr, char __user* buf) {
	struct perf_event * sample_hbp = (struct perf_event *)hdr->param1;
	citerator iter;
	bool found = false;
	printk_debug(KERN_INFO "CMD_UNINST_PROCESS_HWBP\n");
	printk_debug(KERN_INFO "sample_hbp *:%px\n", sample_hbp);
	if(!sample_hbp) {
		return -EFAULT;
	}

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if(hwbp_handle_info->sample_hbp == sample_hbp) {
			if(hwbp_handle_info->hit_item_arr) {
				cvector_destroy(hwbp_handle_info->hit_item_arr);
				hwbp_handle_info->hit_item_arr = NULL;
			}
			cvector_rm(g_hwbp_handle_info_arr, iter);
			found = true;
			break;
		}
	}
	mutex_unlock(&g_hwbp_handle_info_mutex);
	if(found) {
		x_unregister_hw_breakpoint(sample_hbp);
	}
	
	return 0;
}

static ssize_t OnCmdSuspendProcessHwbp(struct ioctl_request *hdr, char __user* buf) {
	struct perf_event * sample_hbp = (struct perf_event *)hdr->param1;
	struct perf_event_attr new_instruction_attr;
	citerator iter;
	bool found = false;
	printk_debug(KERN_INFO "CMD_SUSPEND_PROCESS_HWBP\n");
	printk_debug(KERN_INFO "sample_hbp *:%px\n", sample_hbp);
	if(!sample_hbp) {
		return -EFAULT;
	}

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if(hwbp_handle_info->sample_hbp == sample_hbp) {
			hwbp_handle_info->original_attr.disabled = 1;
			memcpy(&new_instruction_attr, &hwbp_handle_info->original_attr, sizeof(struct perf_event_attr));
			found = true;
			break;
		}
	}
	mutex_unlock(&g_hwbp_handle_info_mutex);
	if(found) {
		if(!x_modify_user_hw_breakpoint(sample_hbp, &new_instruction_attr)) {
			return 0;
		}
	}
	return -EFAULT;
}

static ssize_t OnCmdResumeProcessHwbp(struct ioctl_request *hdr, char __user* buf) {
	struct perf_event * sample_hbp = (struct perf_event *)hdr->param1;
	struct perf_event_attr new_instruction_attr;
	citerator iter;
	bool found = false;
	printk_debug(KERN_INFO "CMD_RESUME_PROCESS_HWBP\n");
	printk_debug(KERN_INFO "sample_hbp *:%px\n", sample_hbp);
	if(!sample_hbp) {
		return -EFAULT;
	}

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if(hwbp_handle_info->sample_hbp == sample_hbp) {
			hwbp_handle_info->original_attr.disabled = 0;
			memcpy(&new_instruction_attr, &hwbp_handle_info->original_attr, sizeof(struct perf_event_attr));
			found = true;
			break;
		}
	}
	mutex_unlock(&g_hwbp_handle_info_mutex);
	if(found) {
		if(!x_modify_user_hw_breakpoint(sample_hbp, &new_instruction_attr)) {
			return 0;
		}
	}
	return -EFAULT;
}

static ssize_t OnCmdGetHwbpHitCount(struct ioctl_request *hdr, char __user* buf) {
	#pragma pack(1)
	struct buf_layout {
		uint64_t hit_total_count;
		uint64_t hit_item_arr_count;
	};
	#pragma pack()
	struct perf_event *sample_hbp = (struct perf_event *)hdr->param1;
	struct buf_layout user_data = {0};
	citerator iter;
	printk_debug(KERN_INFO "CMD_GET_HWBP_HIT_COUNT\n");
	printk_debug(KERN_INFO "sample_hbp *:%px\n", sample_hbp);

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if (hwbp_handle_info->sample_hbp == sample_hbp && hwbp_handle_info->hit_item_arr) {
			user_data.hit_total_count = hwbp_handle_info->hit_total_count;
			user_data.hit_item_arr_count = cvector_length(hwbp_handle_info->hit_item_arr);
			break;
		}
	}

	mutex_unlock(&g_hwbp_handle_info_mutex);
	
	printk_debug(KERN_INFO "user_data.hit_total_count:%zu\n", user_data.hit_total_count);
	if (x_copy_to_user((void*)buf, &user_data, sizeof(user_data))) {
		return -EINVAL;
	}
	return 0;
}

static ssize_t OnCmdGetHwbpHitDetail(struct ioctl_request *hdr, char __user* buf) {
	struct perf_event *sample_hbp = (struct perf_event *)hdr->param1;
	size_t size = hdr->buf_size;
	ssize_t count = 0;
	size_t copy_pos;
	size_t end_pos;

	citerator iter;
	printk_debug(KERN_INFO "sample_hbp *:%ld\n", sample_hbp);

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + size);

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if (hwbp_handle_info->sample_hbp == sample_hbp && hwbp_handle_info->hit_item_arr) {
			citerator child;
			for (child = cvector_begin(hwbp_handle_info->hit_item_arr); child != cvector_end(hwbp_handle_info->hit_item_arr); child = cvector_next(hwbp_handle_info->hit_item_arr, child)) {
				struct HWBP_HIT_ITEM * hit_item = (struct HWBP_HIT_ITEM *)child;
				if (copy_pos >= end_pos) {
					break;
				}
				if (x_copy_to_user((void*)copy_pos, hit_item, sizeof(struct HWBP_HIT_ITEM))) {
					break;
				}
				copy_pos += sizeof(struct HWBP_HIT_ITEM);
				count++;
			}
			break;
		}
	}
	mutex_unlock(&g_hwbp_handle_info_mutex);
	return count;
}

static ssize_t OnCmdSetHookPc(struct ioctl_request *hdr, char __user* buf) {
	uint64_t pc = hdr->param1;
	printk_debug(KERN_INFO "CMD_SET_HOOK_PC\n");
	printk_debug(KERN_INFO "pc:%px\n", pc);
	atomic64_set(&g_hook_pc, pc);
	return 0;
}

static ssize_t OnCmdHideKernelModule(struct ioctl_request *hdr, char __user* buf) {
	printk_debug(KERN_INFO "CMD_HIDE_KERNEL_MODULE\n");
	if (g_hwBreakpointProc_devp->is_hidden_module == false) {
		g_hwBreakpointProc_devp->is_hidden_module = true; 
		list_del_init(&__this_module.list);
		kobject_del(&THIS_MODULE->mkobj.kobj);
	}
	return 0;
}

static inline ssize_t DispatchCommand(struct ioctl_request *hdr, char __user* buf) {
	switch (hdr->cmd) {
	case CMD_OPEN_PROCESS:
		return OnCmdOpenProcess(hdr, buf);
	case CMD_CLOSE_PROCESS:
		return OnCmdCloseProcess(hdr, buf);
	case CMD_GET_NUM_BRPS:
		return OnCmdGetCpuNumBrps(hdr, buf);
	case CMD_GET_NUM_WRPS:
		return OnCmdGetCpuNumWrps(hdr, buf);
	case CMD_INST_PROCESS_HWBP:
		return OnCmdInstProcessHwbp(hdr, buf);
	case CMD_UNINST_PROCESS_HWBP:
		return OnCmdUninstProcessHwbp(hdr, buf);
	case CMD_SUSPEND_PROCESS_HWBP:
		return OnCmdSuspendProcessHwbp(hdr, buf);
	case CMD_RESUME_PROCESS_HWBP:
		return OnCmdResumeProcessHwbp(hdr, buf);
	case CMD_GET_HWBP_HIT_COUNT:
		return OnCmdGetHwbpHitCount(hdr, buf);
	case CMD_GET_HWBP_HIT_DETAIL:
		return OnCmdGetHwbpHitDetail(hdr, buf);
	case CMD_SET_HOOK_PC:
		return OnCmdSetHookPc(hdr, buf);
	case CMD_HIDE_KERNEL_MODULE:
		return OnCmdHideKernelModule(hdr, buf);
	default:
		return -EINVAL;
	}
	return -EINVAL;
}

static ssize_t hwBreakpointProc_read(struct file* filp,
                              char __user* buf,
                              size_t size,
                              loff_t* ppos) {
    struct ioctl_request hdr = {0};
    size_t header_size = sizeof(hdr);

    if (size < header_size) {
        return -EINVAL;
    }

    if (x_copy_from_user(&hdr, buf, header_size)) {
        return -EFAULT;
    }

    if (size < header_size + hdr.buf_size) {
        return -EINVAL;
    }

    return DispatchCommand(&hdr, buf + header_size);
}

static void clean_hwbp(void) {
	citerator iter;
	cvector wait_unregister_bp_arr = cvector_create(sizeof(struct perf_event *));
	if(!wait_unregister_bp_arr || !g_hwbp_handle_info_arr) {
		return;
	}
	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if(hwbp_handle_info->sample_hbp) {
			cvector_pushback(wait_unregister_bp_arr, &hwbp_handle_info->sample_hbp);
			hwbp_handle_info->sample_hbp = NULL;
		}
		if(hwbp_handle_info->hit_item_arr) {
			cvector_destroy(hwbp_handle_info->hit_item_arr);
			hwbp_handle_info->hit_item_arr = NULL;
		}
	}
	cvector_destroy(g_hwbp_handle_info_arr);
	g_hwbp_handle_info_arr = NULL;
	mutex_unlock(&g_hwbp_handle_info_mutex);
	
	for (iter = cvector_begin(wait_unregister_bp_arr); iter != cvector_end(wait_unregister_bp_arr); iter = cvector_next(wait_unregister_bp_arr, iter)) {
	  struct perf_event * bp = *(struct perf_event **)iter;
	  x_unregister_hw_breakpoint(bp);
	}
	cvector_destroy(wait_unregister_bp_arr);
}

static int hwBreakpointProc_release(struct inode *inode, struct file *filp) {
	clean_hwbp();
	mutex_lock(&g_hwbp_handle_info_mutex);
	g_hwbp_handle_info_arr = cvector_create(sizeof(struct HWBP_HANDLE_INFO));
	mutex_unlock(&g_hwbp_handle_info_mutex);
	return 0;
}

static int hwBreakpointProc_dev_init(void) {
#ifdef CONFIG_KALLSYMS_LOOKUP_NAME
	if(!init_kallsyms_lookup()) {
		printk(KERN_EMERG "init_kallsyms_lookup failed\n");
		return -EBADF;
	}
#endif
	g_hwbp_handle_info_arr = cvector_create(sizeof(struct HWBP_HANDLE_INFO));
	mutex_init(&g_hwbp_handle_info_mutex);

#ifdef CONFIG_ANTI_PTRACE_DETECTION_MODE
	start_anti_ptrace_detection(&g_hwbp_handle_info_mutex, &g_hwbp_handle_info_arr);
#endif

	g_hwBreakpointProc_devp = x_kmalloc(sizeof(struct hwBreakpointProcDev), GFP_KERNEL);
	memset(g_hwBreakpointProc_devp, 0, sizeof(struct hwBreakpointProcDev));

#ifdef CONFIG_USE_PROC_FILE_NODE
	g_hwBreakpointProc_devp->proc_parent = proc_mkdir(CONFIG_PROC_NODE_AUTH_KEY, NULL);
	if(g_hwBreakpointProc_devp->proc_parent) {
		g_hwBreakpointProc_devp->proc_entry = proc_create(CONFIG_PROC_NODE_AUTH_KEY, S_IRUGO | S_IWUGO, g_hwBreakpointProc_devp->proc_parent, &hwBreakpointProc_proc_ops);
		start_hide_procfs_dir(CONFIG_PROC_NODE_AUTH_KEY);
	}
#endif

#ifdef DEBUG_PRINTK
	printk(KERN_EMERG "Hello, %s debug\n", CONFIG_PROC_NODE_AUTH_KEY);
	//test1();
	//test2();
	//test3();
	//test4();
#else
	printk(KERN_EMERG "Hello\n");
#endif
	return 0;
}

static void hwBreakpointProc_dev_exit(void) {
	
#ifdef CONFIG_ANTI_PTRACE_DETECTION_MODE
	stop_anti_ptrace_detection();
#endif

	clean_hwbp();
	
	mutex_destroy(&g_hwbp_handle_info_mutex);
	
#ifdef CONFIG_USE_PROC_FILE_NODE
	if(g_hwBreakpointProc_devp->proc_entry) {
		proc_remove(g_hwBreakpointProc_devp->proc_entry);
		g_hwBreakpointProc_devp->proc_entry = NULL;
	}
	
	if(g_hwBreakpointProc_devp->proc_parent) {
		proc_remove(g_hwBreakpointProc_devp->proc_parent);
		g_hwBreakpointProc_devp->proc_parent = NULL;
	}
	stop_hide_procfs_dir();
#endif
	kfree(g_hwBreakpointProc_devp);
	printk(KERN_EMERG "Goodbye\n");
}

int __init init_module(void) {
    return hwBreakpointProc_dev_init();
}

void __exit cleanup_module(void) {
    hwBreakpointProc_dev_exit();
}

#ifndef CONFIG_MODULE_GUIDE_ENTRY
//Hook:__cfi_check_fn
unsigned char* __check_(unsigned char* result, void *ptr, void *diag)
{
	printk_debug(KERN_EMERG "my__cfi_check_fn!!!\n");
	return result;
}

//Hook:__cfi_check_fail
unsigned char * __check_fail_(unsigned char *result)
{
	printk_debug(KERN_EMERG "my__cfi_check_fail!!!\n");
	return result;
}
#endif

unsigned long __stack_chk_guard;

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Linux");
MODULE_DESCRIPTION("Linux default module");


```

`hwBreakpointProcModule/hwBreakpointProc_module/hwBreakpointProc_module.h`:

```h
#ifndef _HWBP_PROC_H_
#define _HWBP_PROC_H_
#include <linux/module.h>
#include <linux/types.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/mm.h>
#include <linux/sched.h>
#include <linux/init.h>
#include <asm/io.h>
#include <asm/uaccess.h>
#include <asm/compat.h>
#include <linux/uaccess.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <linux/kallsyms.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <linux/ksm.h>
#include <linux/mutex.h>
#include <linux/ktime.h>
#include <linux/pid.h>
#include <linux/slab.h> //kmalloc与kfree
#include "ver_control.h"
#include "arm64_register_helper.h"
#include "cvector.h"
#ifdef CONFIG_USE_PROC_FILE_NODE
#include <linux/proc_fs.h>
#include "hide_procfs_dir.h"
#endif
//////////////////////////////////////////////////////////////////

enum {
	CMD_OPEN_PROCESS, 				// 打开进程
	CMD_CLOSE_PROCESS, 				// 关闭进程
	CMD_GET_NUM_BRPS, 				// 获取CPU硬件执行断点支持数量
	CMD_GET_NUM_WRPS, 				// 获取CPU硬件访问断点支持数量
	CMD_INST_PROCESS_HWBP,			// 安装进程硬件断点
	CMD_UNINST_PROCESS_HWBP,		// 卸载进程硬件断点
	CMD_SUSPEND_PROCESS_HWBP,		// 暂停进程硬件断点
	CMD_RESUME_PROCESS_HWBP,		// 恢复进程硬件断点
	CMD_GET_HWBP_HIT_COUNT,			// 获取硬件断点命中地址数量
	CMD_GET_HWBP_HIT_DETAIL,		// 获取硬件断点命中详细信息
	CMD_SET_HOOK_PC,				// 设置无条件Hook跳转
	CMD_HIDE_KERNEL_MODULE,			// 隐藏驱动
};

struct hwBreakpointProcDev {
#ifdef CONFIG_USE_PROC_FILE_NODE
	struct proc_dir_entry *proc_parent;
	struct proc_dir_entry *proc_entry;
#endif
	bool is_hidden_module; //是否已经隐藏过驱动列表了
};
static struct hwBreakpointProcDev *g_hwBreakpointProc_devp;

static ssize_t hwBreakpointProc_read(struct file* filp, char __user* buf, size_t size, loff_t* ppos);
static int hwBreakpointProc_release(struct inode *inode, struct file *filp);
static const struct proc_ops hwBreakpointProc_proc_ops = {
    .proc_read    = hwBreakpointProc_read,
	.proc_release = hwBreakpointProc_release,
};

#pragma pack(1)
struct my_user_pt_regs {
	uint64_t regs[31];
	uint64_t sp;
	uint64_t pc;
	uint64_t pstate;
	uint64_t orig_x0;
	uint64_t syscallno;
};
struct HWBP_HIT_ITEM {
	uint64_t task_id;
	uint64_t hit_addr;
	uint64_t hit_time;
	struct my_user_pt_regs regs_info;
};
#pragma pack()

struct HWBP_HANDLE_INFO {
	uint64_t task_id;
	struct perf_event * sample_hbp;
	struct perf_event_attr original_attr;
	bool is_32bit_task;
#ifdef CONFIG_MODIFY_HIT_NEXT_MODE
	struct perf_event_attr next_instruction_attr;
#endif
	size_t hit_total_count;
	cvector hit_item_arr;
};

#endif /* _HWBP_PROC_H_ */
```

`hwBreakpointProcModule/hwBreakpointProc_module/hwbp_proc.c`:

```c

#include <linux/module.h>
#include <linux/types.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/mm.h>
#include <linux/sched.h>
#include <linux/init.h>
#include <linux/cdev.h>
#include <asm/io.h>
#include <asm/uaccess.h>
#include <asm/compat.h>
#include <linux/uaccess.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <linux/kallsyms.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <linux/ksm.h>
#include <linux/mutex.h>
#include <linux/ktime.h>
#include <linux/pid.h>

#include <linux/slab.h>
#include <linux/device.h>
#include "arm64_register_helper.h"
#include "cvector.h"
#include "proc_pid.h"
#include "api_proxy.h"


#define MAJOR_NUM 100
#define IOCTL_HWBP_OPEN_PROCESS 				_IOR(MAJOR_NUM, 1, char*) //打开进程
#define IOCTL_HWBP_CLOSE_HANDLE 				_IOR(MAJOR_NUM, 2, char*) //关闭进程
#define IOCTL_HWBP_GET_NUM_BRPS 				_IOR(MAJOR_NUM, 3, char*) //获取CPU支持硬件执行断点的数量
#define IOCTL_HWBP_GET_NUM_WRPS 				_IOR(MAJOR_NUM, 4, char*) //获取CPU支持硬件访问断点的数量
#define IOCTL_HWBP_INST_PROCESS_HWBP			_IOR(MAJOR_NUM, 5, char*) //设置进程硬件断点
#define IOCTL_HWBP_UNINST_PROCESS_HWBP		_IOR(MAJOR_NUM, 6, char*) //删除进程硬件断点
#define IOCTL_HWBP_SUSPEND_PROCESS_HWBP	_IOR(MAJOR_NUM, 7, char*) //暂停进程硬件断点
#define IOCTL_HWBP_RESUME_PROCESS_HWBP		_IOR(MAJOR_NUM, 8, char*) //恢复进程硬件断点
#define IOCTL_HWBP_GET_HWBP_HIT_COUNT		_IOR(MAJOR_NUM, 9, char*) //获取硬件断点命中地址数量
#define IOCTL_HWBP_SET_HOOK_PC						_IOR(MAJOR_NUM, 20, char*)

static atomic64_t g_hook_pc;


//////////////////////////////////////////////////////////////////
static int g_hwBreakpointProc_major = 0;
static dev_t g_hwBreakpointProc_devno;

struct hwBreakpointProcDev {
	struct cdev *pcdev;
	size_t cur_dev_open_count;
	bool is_already_hide_dev_file;
};
static struct hwBreakpointProcDev *g_hwBreakpointProc_devp;
static struct class *g_Class_devp;

static struct mutex g_hwbp_handle_info_mutex;
static cvector g_hwbp_handle_info_arr = NULL;

static void record_hit_details(struct HWBP_HANDLE_INFO *info, struct pt_regs *regs) {
    struct HWBP_HIT_ITEM hit_item = {0};
	if (!info || !regs) {
        return;
    }
	hit_item.task_id = info->task_id;
    hit_item.hit_addr = regs->pc;
	hit_item.hit_time = ktime_get_real_seconds();
    memcpy(&hit_item.regs_info.regs, regs->regs, sizeof(hit_item.regs_info.regs));
    hit_item.regs_info.sp = regs->sp;
    hit_item.regs_info.pc = regs->pc;
    hit_item.regs_info.pstate = regs->pstate;
    hit_item.regs_info.orig_x0 = regs->orig_x0;
    hit_item.regs_info.syscallno = regs->syscallno;
    if (info->hit_item_arr) {
		if(cvector_length(info->hit_item_arr) < MIN_LEN) { // 最多存放MIN_LEN个
			cvector_pushback(info->hit_item_arr, &hit_item);
		}
    }
}

#ifdef CONFIG_MODIFY_HIT_NEXT_MODE
static bool arm64_move_bp_to_next_instruction(struct perf_event *bp, uint64_t next_instruction_addr, struct perf_event_attr *original_attr, struct perf_event_attr * next_instruction_attr) {
    int result;
	if (!bp || !original_attr || !next_instruction_attr || !next_instruction_addr) {
        return false;
    }
	memcpy(next_instruction_attr, original_attr, sizeof(struct perf_event_attr));
	next_instruction_attr->bp_addr = next_instruction_addr;
	next_instruction_attr->bp_len = HW_BREAKPOINT_LEN_4;
	next_instruction_attr->bp_type = HW_BREAKPOINT_X;
	next_instruction_attr->disabled = 0;
	result = x_modify_user_hw_breakpoint(bp, next_instruction_attr);
	if(result) {
		next_instruction_attr->bp_addr = 0;
		return false;
	}
	return true;
}

static bool arm64_recovery_bp_to_original(struct perf_event *bp, struct perf_event_attr *original_attr, struct perf_event_attr * next_instruction_attr) {
    int result;
	if (!bp || !original_attr || !next_instruction_attr) {
        return false;
    }
	result = x_modify_user_hw_breakpoint(bp, original_attr);
	if(result) {
		return false;
	}
	next_instruction_attr->bp_addr = 0;
	return true;
}
#endif

static void hwbp_hit_user_info_callback(struct perf_event *bp,
	struct perf_sample_data *data,
	struct pt_regs *regs, struct HWBP_HANDLE_INFO * hwbp_handle_info) {
	hwbp_handle_info->hit_total_count++;
	record_hit_details(hwbp_handle_info, regs);
}

/*
 * Handle hitting a HW-breakpoint.
 */
static void hwbp_handler(struct perf_event *bp,
	struct perf_sample_data *data,
	struct pt_regs *regs) {
	citerator iter;
	uint64_t hook_pc;
	printk_debug(KERN_INFO "hw_breakpoint HIT!!!!! bp:%px, pc:%px, id:%d\n", bp, regs->pc, bp->id);

	hook_pc = atomic64_read(&g_hook_pc);
	if(hook_pc) {
		regs->pc = hook_pc;
		return;
	}

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if (hwbp_handle_info->sample_hbp != bp) {
			continue;
		}
#ifdef CONFIG_MODIFY_HIT_NEXT_MODE
		if(hwbp_handle_info->next_instruction_attr.bp_addr != regs->pc) {
			// first hit
			bool should_toggle = true;
			hwbp_hit_user_info_callback(bp, data, regs, hwbp_handle_info);
			if(!hwbp_handle_info->is_32bit_task) {
				if(arm64_move_bp_to_next_instruction(bp, regs->pc + 4, &hwbp_handle_info->original_attr, &hwbp_handle_info->next_instruction_attr)) {
					should_toggle = false;
				}
			}
			if(should_toggle) {
				toggle_bp_registers_directly(&hwbp_handle_info->original_attr, hwbp_handle_info->is_32bit_task, 0);
			}
		} else {
			// second hit
			if(!arm64_recovery_bp_to_original(bp, &hwbp_handle_info->original_attr, &hwbp_handle_info->next_instruction_attr)) {
				toggle_bp_registers_directly(&hwbp_handle_info->next_instruction_attr, hwbp_handle_info->is_32bit_task, 0);
			}
		}
#else
		hwbp_hit_user_info_callback(bp, data, regs, hwbp_handle_info);
		toggle_bp_registers_directly(&hwbp_handle_info->original_attr, hwbp_handle_info->is_32bit_task, 0);
#endif
	}
	
	mutex_unlock(&g_hwbp_handle_info_mutex);
}



static long OnIoctlOpenProcess(unsigned long arg) {
	int64_t pid = 0;
	struct pid * proc_pid_struct = NULL;
	if (copy_from_user(&pid, (void __user *)arg, 8)) {
		return -EINVAL;
	}
	printk_debug(KERN_INFO "pid:%ld\n", pid);
	proc_pid_struct = get_proc_pid_struct(pid);
	printk_debug(KERN_INFO "proc_pid_struct *:%px\n", proc_pid_struct);
	if (!proc_pid_struct) {
		return -EINVAL;
	}
	if (copy_to_user((void*)arg, &proc_pid_struct, 8)) {
		return -EINVAL;
	}
	return 0;
}

static long OnIoctlCloseProcess(unsigned long arg) {
	//获取进程句柄
	struct pid * proc_pid_struct = NULL;
	if (copy_from_user((void*)&proc_pid_struct, (void*)arg, 8)) {
		return -EFAULT;
	}
	//关闭进程句柄
	printk_debug(KERN_INFO "proc_pid_struct *:%px\n", proc_pid_struct);
	release_proc_pid_struct(proc_pid_struct);
	return 0;
}

static long OnIoctlGetCpuNumBrps(void) {
	return getCpuNumBrps();
}

static long OnIoctlGetCpuNumWrps(void) {
	return getCpuNumWrps();
}

static long OnIoctlInstProcessHwbp(unsigned long arg) {
	#pragma pack(1)
	struct buf_layout {
		struct pid * proc_pid_struct;
		size_t proc_virt_addr;
		unsigned int hwbp_len;
		unsigned int hwbp_type;
	};
	#pragma pack()
	pid_t pid_val;
	struct task_struct *task;
	struct buf_layout user_data = {0};
	struct HWBP_HANDLE_INFO hwbp_handle_info = { 0 };
	if (copy_from_user((void*)&user_data, (void*)arg, 24)) {
		return -EFAULT;
	}
	printk_debug(KERN_INFO "proc_pid_struct *:%px\n", user_data.proc_pid_struct);
	printk_debug(KERN_INFO "proc_virt_addr :%px\n", user_data.proc_virt_addr);
	printk_debug(KERN_INFO "hwbp_len:%zu\n", user_data.hwbp_len);
	printk_debug(KERN_INFO "hwbp_type:%d\n", user_data.hwbp_type);
	pid_val = pid_nr(user_data.proc_pid_struct);
	printk_debug(KERN_INFO "pid_val:%d\n", pid_val);

	if (!pid_val) {
		printk_debug(KERN_INFO "pid_nr failed.\n");
		return -EINVAL;
	}

	task = pid_task(user_data.proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		printk_debug(KERN_INFO "get_pid_task failed.\n");
		return -EINVAL;
	}
	
	hwbp_handle_info.task_id = pid_val;
	hwbp_handle_info.is_32bit_task = is_compat_thread(task_thread_info(task));
	ptrace_breakpoint_init(&hwbp_handle_info.original_attr);
	hwbp_handle_info.original_attr.bp_addr = user_data.proc_virt_addr;
	hwbp_handle_info.original_attr.bp_len = user_data.hwbp_len;
	hwbp_handle_info.original_attr.bp_type = user_data.hwbp_type;
	hwbp_handle_info.original_attr.disabled = 0;

	hwbp_handle_info.sample_hbp = x_register_user_hw_breakpoint(&hwbp_handle_info.original_attr, hwbp_handler, NULL, task);
	printk_debug(KERN_INFO "register_user_hw_breakpoint return: %px\n", hwbp_handle_info.sample_hbp);
	if (IS_ERR((void __force *)hwbp_handle_info.sample_hbp)) {
		int ret = PTR_ERR((void __force *)hwbp_handle_info.sample_hbp);
		printk_debug(KERN_INFO "register_user_hw_breakpoint failed: %d\n", ret);
		return ret;
	}
	hwbp_handle_info.hit_item_arr = cvector_create(sizeof(struct HWBP_HIT_ITEM));
	mutex_lock(&g_hwbp_handle_info_mutex);
	cvector_pushback(g_hwbp_handle_info_arr, &hwbp_handle_info);
	mutex_unlock(&g_hwbp_handle_info_mutex);
	if (copy_to_user((void*)arg, &hwbp_handle_info.sample_hbp, 8)) {
		return -EINVAL;
	}
	return 0;
}

static long OnIoctlUninstProcessHwbp(unsigned long arg) {
	struct perf_event * sample_hbp = NULL;
	citerator iter;
	bool found = false;
	if (copy_from_user(&sample_hbp, (void __user *)arg, 8)) {
		return -EFAULT;
	}

	printk_debug(KERN_INFO "sample_hbp *:%px\n", sample_hbp);
	if(!sample_hbp) {
		return -EFAULT;
	}

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if(hwbp_handle_info->sample_hbp == sample_hbp) {
			if(hwbp_handle_info->hit_item_arr) {
				cvector_destroy(hwbp_handle_info->hit_item_arr);
				hwbp_handle_info->hit_item_arr = NULL;
			}
			cvector_rm(g_hwbp_handle_info_arr, iter);
			found = true;
			break;
		}
	}
	mutex_unlock(&g_hwbp_handle_info_mutex);
	if(found) {
		x_unregister_hw_breakpoint(sample_hbp);
	}
	
	return 0;
}

static long OnIoctlSuspendProcessHwbp(unsigned long arg) {
	struct perf_event * sample_hbp = NULL;
	struct perf_event_attr new_instruction_attr;
	citerator iter;
	bool found = false;
	if (copy_from_user(&sample_hbp, (void __user *)arg, 8)) {
		return -EFAULT;
	}

	printk_debug(KERN_INFO "sample_hbp *:%px\n", sample_hbp);
	if(!sample_hbp) {
		return -EFAULT;
	}

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if(hwbp_handle_info->sample_hbp == sample_hbp) {
			hwbp_handle_info->original_attr.disabled = 1;
			memcpy(&new_instruction_attr, &hwbp_handle_info->original_attr, sizeof(struct perf_event_attr));
			found = true;
			break;
		}
	}
	mutex_unlock(&g_hwbp_handle_info_mutex);
	if(found) {
		if(!x_modify_user_hw_breakpoint(sample_hbp, &new_instruction_attr)) {
			return 0;
		}
	}
	return -EFAULT;
}

static long OnIoctlResumeProcessHwbp(unsigned long arg) {
	struct perf_event * sample_hbp = NULL;
	struct perf_event_attr new_instruction_attr;
	citerator iter;
	bool found = false;
	if (copy_from_user(&sample_hbp, (void __user *)arg, 8)) {
		return -EFAULT;
	}

	printk_debug(KERN_INFO "sample_hbp *:%px\n", sample_hbp);
	if(!sample_hbp) {
		return -EFAULT;
	}

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if(hwbp_handle_info->sample_hbp == sample_hbp) {
			hwbp_handle_info->original_attr.disabled = 0;
			memcpy(&new_instruction_attr, &hwbp_handle_info->original_attr, sizeof(struct perf_event_attr));
			found = true;
			break;
		}
	}
	mutex_unlock(&g_hwbp_handle_info_mutex);
	if(found) {
		if(!x_modify_user_hw_breakpoint(sample_hbp, &new_instruction_attr)) {
			return 0;
		}
	}
	return -EFAULT;
}

static long OnIoctlGetHwbpHitCount(unsigned long arg) {
	#pragma pack(1)
	struct buf_layout {
		struct perf_event *sample_hbp;
		uint64_t hit_total_count;
		uint64_t hit_item_arr_count;
	};
	#pragma pack()
	struct buf_layout user_data = {0};
	citerator iter;
	if (copy_from_user(&user_data.sample_hbp, (void __user *)arg, 8)) {
		return -EFAULT;
	}
	printk_debug(KERN_INFO "sample_hbp *:%px\n", user_data.sample_hbp);

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if (hwbp_handle_info->sample_hbp == user_data.sample_hbp && hwbp_handle_info->hit_item_arr) {
			user_data.hit_total_count = hwbp_handle_info->hit_total_count;
			user_data.hit_item_arr_count = cvector_length(hwbp_handle_info->hit_item_arr);
			break;
		}
	}

	mutex_unlock(&g_hwbp_handle_info_mutex);
	
	printk_debug(KERN_INFO "user_data.hit_total_count:%zu\n", user_data.hit_total_count);
	if (copy_to_user((void*)arg, &user_data, 24)) {
		return -EINVAL;
	}
	return 0;
}

static long OnIoctlSetHookPc(unsigned long arg) {
	uint64_t pc = 0;
	if (copy_from_user(&pc, (void __user *)arg, 8)) {
		return -EFAULT;
	}
	printk_debug(KERN_INFO "pc:%px\n", pc);
	atomic64_set(&g_hook_pc, pc);
	return 0;
}

static ssize_t hwBreakpointProc_read(struct file* filp, char __user* buf, size_t size, loff_t* ppos) {
	struct perf_event * sample_hbp = NULL;
	ssize_t count = 0;
	size_t copy_pos;
	size_t end_pos;

	citerator iter;
	if (copy_from_user((void*)&sample_hbp, buf, 8)) {
		return -EFAULT;
	}
	printk_debug(KERN_INFO "sample_hbp *:%ld\n", sample_hbp);

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + size);

	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if (hwbp_handle_info->sample_hbp == sample_hbp && hwbp_handle_info->hit_item_arr) {
			citerator child;
			for (child = cvector_begin(hwbp_handle_info->hit_item_arr); child != cvector_end(hwbp_handle_info->hit_item_arr); child = cvector_next(hwbp_handle_info->hit_item_arr, child)) {
				struct HWBP_HIT_ITEM * hit_item = (struct HWBP_HIT_ITEM *)child;
				if (copy_pos >= end_pos) {
					break;
				}
				if (copy_to_user((void*)copy_pos, hit_item, sizeof(struct HWBP_HIT_ITEM))) {
					break;
				}
				copy_pos += sizeof(struct HWBP_HIT_ITEM);
				count++;
			}
			break;
		}
	}
	mutex_unlock(&g_hwbp_handle_info_mutex);
	return count;
}

static inline long DispatchCommand(unsigned int cmd, unsigned long arg) {
	switch (cmd) {
	case IOCTL_HWBP_OPEN_PROCESS: //打开进程
		printk_debug(KERN_INFO "IOCTL_HWBP_OPEN_PROCESS\n");
		return OnIoctlOpenProcess(arg);
	case IOCTL_HWBP_CLOSE_HANDLE: //关闭进程
		printk_debug(KERN_INFO "IOCTL_HWBP_CLOSE_HANDLE\n");
		return OnIoctlCloseProcess(arg);
	case IOCTL_HWBP_GET_NUM_BRPS: //获取CPU支持硬件执行断点的数量
		printk_debug(KERN_INFO "IOCTL_HWBP_GET_NUM_BRPS\n");
		return OnIoctlGetCpuNumBrps();
	case IOCTL_HWBP_GET_NUM_WRPS: //获取CPU支持硬件访问断点的数量
		printk_debug(KERN_INFO "IOCTL_HWBP_GET_NUM_WRPS\n");
		return OnIoctlGetCpuNumWrps();
	case IOCTL_HWBP_INST_PROCESS_HWBP: //设置进程硬件断点
		printk_debug(KERN_INFO "IOCTL_HWBP_INST_PROCESS_HWBP\n");
		return OnIoctlInstProcessHwbp(arg);
	case IOCTL_HWBP_UNINST_PROCESS_HWBP: //删除进程硬件断点
		printk_debug(KERN_INFO "IOCTL_HWBP_UNINST_PROCESS_HWBP\n");
		return OnIoctlUninstProcessHwbp(arg);
	case IOCTL_HWBP_SUSPEND_PROCESS_HWBP: //暂停进程硬件断点
		printk_debug(KERN_INFO "IOCTL_HWBP_SUSPEND_PROCESS_HWBP\n");
		return OnIoctlSuspendProcessHwbp(arg);
	case IOCTL_HWBP_RESUME_PROCESS_HWBP: //恢复进程硬件断点
		printk_debug(KERN_INFO "IOCTL_HWBP_RESUME_PROCESS_HWBP\n");
		return OnIoctlResumeProcessHwbp(arg);
	case IOCTL_HWBP_GET_HWBP_HIT_COUNT: //获取硬件断点命中地址数量
		printk_debug(KERN_INFO "IOCTL_HWBP_GET_HWBP_HIT_COUNT\n");
		return OnIoctlGetHwbpHitCount(arg);
	case IOCTL_HWBP_SET_HOOK_PC:
		printk_debug(KERN_INFO "IOCTL_HWBP_SET_HOOK_PC\n");
		return OnIoctlSetHookPc(arg);
	default:
		return -EINVAL;
	}
	return -EINVAL;
}


//long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
//long (*compat_ioctl) (struct file *, unsigned int cmd, unsigned long arg)
static long hwBreakpointProc_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
	return DispatchCommand(cmd, arg);
}

static int hwBreakpointProc_open(struct inode *inode, struct file *filp) {
	g_hwBreakpointProc_devp->cur_dev_open_count++;
	if (g_hwBreakpointProc_devp->cur_dev_open_count >= 2) {
		if (!g_hwBreakpointProc_devp->is_already_hide_dev_file) {
			g_hwBreakpointProc_devp->is_already_hide_dev_file = true;
			device_destroy(g_Class_devp, g_hwBreakpointProc_devno);
			class_destroy(g_Class_devp);
		}
	}
	return 0;
}

static loff_t hwBreakpointProc_llseek(struct file* filp, loff_t offset, int orig) {
	unsigned int cmd = 0;
	printk_debug("hwBreakpointProc llseek offset:%zd\n", (ssize_t)offset);
	if (!!copy_from_user((void*)&cmd, (void*)offset, sizeof(unsigned int))) {
		return -EINVAL;
	}
	printk_debug("hwBreakpointProc llseek cmd:%u\n", cmd);
	return DispatchCommand(cmd, offset + sizeof(unsigned int));
}

static ssize_t hwBreakpointProc_write(struct file* filp, const char __user* buf, size_t size, loff_t *ppos) {
	return 0;
}

static void clean_hwbp(void) {
	citerator iter;
	cvector wait_unregister_bp_arr = cvector_create(sizeof(struct perf_event *));
	if(!wait_unregister_bp_arr || !g_hwbp_handle_info_arr) {
		return;
	}
	mutex_lock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(g_hwbp_handle_info_arr); iter != cvector_end(g_hwbp_handle_info_arr); iter = cvector_next(g_hwbp_handle_info_arr, iter)) {
		struct HWBP_HANDLE_INFO * hwbp_handle_info = (struct HWBP_HANDLE_INFO *)iter;
		if(hwbp_handle_info->sample_hbp) {
			cvector_pushback(wait_unregister_bp_arr, &hwbp_handle_info->sample_hbp);
			hwbp_handle_info->sample_hbp = NULL;
		}
		if(hwbp_handle_info->hit_item_arr) {
			cvector_destroy(hwbp_handle_info->hit_item_arr);
			hwbp_handle_info->hit_item_arr = NULL;
		}
	}
	cvector_destroy(g_hwbp_handle_info_arr);
	g_hwbp_handle_info_arr = NULL;
	mutex_unlock(&g_hwbp_handle_info_mutex);
	for (iter = cvector_begin(wait_unregister_bp_arr); iter != cvector_end(wait_unregister_bp_arr); iter = cvector_next(wait_unregister_bp_arr, iter)) {
	  struct perf_event * bp = *(struct perf_event **)iter;
	  x_unregister_hw_breakpoint(bp);
	}
	cvector_destroy(wait_unregister_bp_arr);
}

static int hwBreakpointProc_release(struct inode *inode, struct file *filp) {
	if (g_hwBreakpointProc_devp->cur_dev_open_count > 0) {
		g_hwBreakpointProc_devp->cur_dev_open_count--;
	}
	if (g_hwBreakpointProc_devp->cur_dev_open_count < 1) {
		if (g_hwBreakpointProc_devp->is_already_hide_dev_file) {
			g_hwBreakpointProc_devp->is_already_hide_dev_file = false;

			g_Class_devp = class_create(THIS_MODULE, DEV_FILENAME);
			device_create(g_Class_devp, NULL, g_hwBreakpointProc_devno, NULL, "%s", DEV_FILENAME);
		}
	}

	clean_hwbp();
	mutex_lock(&g_hwbp_handle_info_mutex);
	g_hwbp_handle_info_arr = cvector_create(sizeof(struct HWBP_HANDLE_INFO));
	mutex_unlock(&g_hwbp_handle_info_mutex);
	return 0;
}

static const struct file_operations hwBreakpointProc_fops =
{
  .owner = THIS_MODULE,
  .open = hwBreakpointProc_open,
  .release = hwBreakpointProc_release,
  .read = hwBreakpointProc_read,
  .write = hwBreakpointProc_write,
  .llseek = hwBreakpointProc_llseek,

#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
	.ioctl = hwBreakpointProc_ioctl,
#else
	.compat_ioctl = hwBreakpointProc_ioctl,
	.unlocked_ioctl = hwBreakpointProc_ioctl,
#endif
};

#ifdef CONFIG_MODULE_GUIDE_ENTRY
static
#endif
int __init hwBreakpointProc_dev_init(void) {
	int result;
	int err;

#ifdef CONFIG_KALLSYMS_LOOKUP_NAME
	if(!init_kallsyms_lookup()) {
		printk(KERN_EMERG "init_kallsyms_lookup failed\n");
		return -EBADF;
	}
#endif

	g_hwbp_handle_info_arr = cvector_create(sizeof(struct HWBP_HANDLE_INFO));
	if(!g_hwbp_handle_info_arr) {
		printk(KERN_EMERG "cvector_create failed\n");
		return -ENOMEM;
	}

	mutex_init(&g_hwbp_handle_info_mutex);

#ifdef CONFIG_ANTI_PTRACE_DETECTION_MODE
	start_anti_ptrace_detection(&g_hwbp_handle_info_mutex, &g_hwbp_handle_info_arr);
#endif

	result = alloc_chrdev_region(&g_hwBreakpointProc_devno, 0, 1, DEV_FILENAME);
	g_hwBreakpointProc_major = MAJOR(g_hwBreakpointProc_devno);

	if (result < 0) {
		printk(KERN_EMERG "hwBreakpointProc alloc_chrdev_region failed %d\n", result);
		return result;
	}

	g_hwBreakpointProc_devp = __kmalloc(sizeof(struct hwBreakpointProcDev), GFP_KERNEL);
	if (!g_hwBreakpointProc_devp) {
		result = -ENOMEM;
		goto _fail;
	}
	memset(g_hwBreakpointProc_devp, 0, sizeof(struct hwBreakpointProcDev));

	g_hwBreakpointProc_devp->pcdev = __kmalloc(sizeof(struct cdev) * 3/*大些兼容性强*/, GFP_KERNEL);
	cdev_init(g_hwBreakpointProc_devp->pcdev, &hwBreakpointProc_fops);
	g_hwBreakpointProc_devp->pcdev->owner = THIS_MODULE;
	g_hwBreakpointProc_devp->pcdev->ops = &hwBreakpointProc_fops;
	err = cdev_add(g_hwBreakpointProc_devp->pcdev, g_hwBreakpointProc_devno, 1);
	if (err) {
		printk(KERN_EMERG "Error in cdev_add()\n");
		result = -EFAULT;
		goto _fail;
	}

	g_Class_devp = class_create(THIS_MODULE, DEV_FILENAME);
	device_create(g_Class_devp, NULL, g_hwBreakpointProc_devno, NULL, "%s", DEV_FILENAME);

#ifdef DEBUG_PRINTK
	printk(KERN_EMERG "Hello, %s debug\n", DEV_FILENAME);
#else
	printk(KERN_EMERG "Hello, %s\n", DEV_FILENAME);
#endif
	return 0;

_fail:
	unregister_chrdev_region(g_hwBreakpointProc_devno, 1);
	return result;
}

#ifdef CONFIG_MODULE_GUIDE_ENTRY
static
#endif
void __exit hwBreakpointProc_dev_exit(void) {
	
#ifdef CONFIG_ANTI_PTRACE_DETECTION_MODE
	stop_anti_ptrace_detection();
#endif

	clean_hwbp();
	
	mutex_destroy(&g_hwbp_handle_info_mutex);
	
	device_destroy(g_Class_devp, g_hwBreakpointProc_devno);
	class_destroy(g_Class_devp);

	cdev_del(g_hwBreakpointProc_devp->pcdev);
	kfree(g_hwBreakpointProc_devp->pcdev);
	kfree(g_hwBreakpointProc_devp);
	unregister_chrdev_region(g_hwBreakpointProc_devno, 1);
	printk(KERN_EMERG "Goodbye, %s\n", DEV_FILENAME);
}

#ifndef CONFIG_MODULE_GUIDE_ENTRY
//Hook:__cfi_check_fn
unsigned char* __check_(unsigned char* result, void *ptr, void *diag)
{
	printk_debug(KERN_EMERG "my__cfi_check_fn!!!\n");
	return result;
}

//Hook:__cfi_check_fail
unsigned char * __check_fail_(unsigned char *result)
{
	printk_debug(KERN_EMERG "my__cfi_check_fail!!!\n");
	return result;
}
#endif

unsigned long __stack_chk_guard;

#ifdef CONFIG_MODULE_GUIDE_ENTRY
module_init(hwBreakpointProc_dev_init);
module_exit(hwBreakpointProc_dev_exit);
#endif

MODULE_AUTHOR("Linux");
MODULE_DESCRIPTION("Linux default module");
MODULE_LICENSE("GPL");

```

`hwBreakpointProcModule/hwBreakpointProc_module/hwbp_proc.h`:

```h
#ifndef _HWBP_PROC_H_
#define _HWBP_PROC_H_
#include "ver_control.h"

#pragma pack(1)
struct my_user_pt_regs {
	uint64_t regs[31];
	uint64_t sp;
	uint64_t pc;
	uint64_t pstate;
	uint64_t orig_x0;
	uint64_t syscallno;
};
struct HWBP_HIT_ITEM {
	uint64_t task_id;
	uint64_t hit_addr;
	uint64_t hit_time;
	struct my_user_pt_regs regs_info;
};
#pragma pack()

struct HWBP_HANDLE_INFO {
	uint64_t task_id;
	struct perf_event * sample_hbp;
	struct perf_event_attr original_attr;
	bool is_32bit_task;
#ifdef CONFIG_MODIFY_HIT_NEXT_MODE
	struct perf_event_attr next_instruction_attr;
#endif
	size_t hit_total_count;
	cvector hit_item_arr;
};

#endif
```

`hwBreakpointProcModule/hwBreakpointProc_module/kallsyms_lookup_api.h`:

```h
#ifndef _KALLSYMS_LOOKUP_API_H_
#define _KALLSYMS_LOOKUP_API_H_
#include "ver_control.h"
#include <linux/types.h>
#include <linux/errno.h>
#include <linux/uaccess.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <linux/kallsyms.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <linux/kprobes.h>

static unsigned long (*kallsyms_lookup_name_sym)(const char *name);
static struct perf_event* (*register_user_hw_breakpoint_sym)(struct perf_event_attr *attr, perf_overflow_handler_t triggered, void *context, struct task_struct *tsk);
static void (*unregister_hw_breakpoint_sym)(struct perf_event *bp);
#ifdef CONFIG_MODIFY_HIT_NEXT_MODE
static int (*modify_user_hw_breakpoint_sym)(struct perf_event *bp, struct perf_event_attr *attr);
#endif

static int _kallsyms_lookup_kprobe(struct kprobe *p, struct pt_regs *regs) { return 0; }
static unsigned long get_kallsyms_func(void) {
	int ret;
	unsigned long addr = 0;
	struct kprobe probe = {0};
	probe.pre_handler = _kallsyms_lookup_kprobe;
	probe.symbol_name = "kallsyms_lookup_name";
	ret = register_kprobe(&probe);
	if (ret == 0) {
		addr = (unsigned long)probe.addr;
		printk_debug(KERN_EMERG "get_kallsyms_func(kallsyms_lookup_name):%px\n", addr);
		unregister_kprobe(&probe);
	}
	return addr;
}

static unsigned long generic_kallsyms_lookup_name(const char *name) {
	if (!kallsyms_lookup_name_sym) {
			kallsyms_lookup_name_sym = (void *)get_kallsyms_func();
			printk_debug(KERN_EMERG "get_kallsyms_func:%px\n", kallsyms_lookup_name_sym);
			if(!kallsyms_lookup_name_sym)
					return 0;
	}
	return kallsyms_lookup_name_sym(name);
}

static bool init_kallsyms_lookup(void) {
	register_user_hw_breakpoint_sym = (void *)generic_kallsyms_lookup_name("register_user_hw_breakpoint");
	printk_debug(KERN_EMERG "register_user_hw_breakpoint_sym:%px\n", register_user_hw_breakpoint_sym);
	if(!register_user_hw_breakpoint_sym) { return false; }

	unregister_hw_breakpoint_sym = (void *)generic_kallsyms_lookup_name("unregister_hw_breakpoint");
	printk_debug(KERN_EMERG "unregister_hw_breakpoint_sym:%px\n", unregister_hw_breakpoint_sym);
	if(!unregister_hw_breakpoint_sym) { return false; }

#ifdef CONFIG_MODIFY_HIT_NEXT_MODE
	modify_user_hw_breakpoint_sym = (void *)generic_kallsyms_lookup_name("modify_user_hw_breakpoint");
	printk_debug(KERN_EMERG "modify_user_hw_breakpoint_sym:%px\n", modify_user_hw_breakpoint_sym);
	if(!modify_user_hw_breakpoint_sym) { return false; }
#endif

	return true;
}
#endif

```

`hwBreakpointProcModule/hwBreakpointProc_module/proc_pid.h`:

```h
#ifndef _PROC_PID_H_
#define _PROC_PID_H_
#include <linux/ksm.h>
#include <linux/pid.h>
#include "ver_control.h"
static inline struct pid * get_proc_pid_struct(int nPid) {
	return find_get_pid(nPid);
}
static inline int get_proc_pid(struct pid* proc_pid_struct) {
	return proc_pid_struct->numbers[0].nr;
}
static inline void release_proc_pid_struct(struct pid* proc_pid_struct) {
	put_pid(proc_pid_struct);
}

#endif /* _PROC_PID_H_ */

```

`hwBreakpointProcModule/hwBreakpointProc_module/ver_control.h`:

```h
#ifndef VER_CONTROL_H_
#define VER_CONTROL_H_
#include <linux/version.h>

// 独立内核模块入口模式
#define CONFIG_MODULE_GUIDE_ENTRY

// 生成proc用户层交互节点文件
#define CONFIG_USE_PROC_FILE_NODE
// 隐蔽通信密钥
#define CONFIG_PROC_NODE_AUTH_KEY "dce3771681d4c7a143d5d06b7d32548e"

// 调试打印模式
//#define CONFIG_DEBUG_PRINTK

// 动态寻址模式
#define CONFIG_KALLSYMS_LOOKUP_NAME

// 精准命中记录模式
#define CONFIG_MODIFY_HIT_NEXT_MODE

// 反PTRACE侦测模式
#define CONFIG_ANTI_PTRACE_DETECTION_MODE

#ifndef KERNEL_VERSION
#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
#endif
#ifndef MY_LINUX_VERSION_CODE 
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(3,10,0)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(3,10,84)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(3,18,71)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(3,18,140)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,4,21)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,4,78)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,4,153)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,4,192)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,9,112)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,9,186)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,14,83)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,14,117)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,14,141)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,19,81)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,19,113)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(5,4,61)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(5,10,43)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(5,15,41)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(6,1,75)
#define MY_LINUX_VERSION_CODE KERNEL_VERSION(6,6,30)
#endif

#ifdef CONFIG_DEBUG_PRINTK
#define printk_debug printk
#else
static inline void printk_debug(char *fmt, ...) {}
#endif

#endif /* VER_CONTROL_H_ */

```

`hwBreakpointProcModule/testHwBp/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_CPPFLAGS += -std=c++20
LOCAL_CFLAGS += -fPIE
LOCAL_CFLAGS += -fvisibility=hidden
LOCAL_LDFLAGS += -fPIE -pie
LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true
LOCAL_MODULE    := testHwBp
LOCAL_SRC_FILES :=  testHwBp.cpp

include $(BUILD_EXECUTABLE)

```

`hwBreakpointProcModule/testHwBp/jni/Application.mk`:

```mk
APP_ABI := arm64-v8a
APP_STL := c++_static
```

`hwBreakpointProcModule/testHwBp/jni/HwBreakpointMgr4.h`:

```h
#ifndef HW_BREAKPOINT_MANAGER_H_
#define HW_BREAKPOINT_MANAGER_H_

#include <stdio.h>
#include <stdint.h>
#include <vector>
#ifdef __linux__
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <errno.h>
#include <malloc.h>
#include <random>
#include <algorithm>
#include <filesystem>
#include "IoctlBufferPool.h"
#include <linux\perf_event.h>

typedef int BOOL;
#define TRUE 1
#define FALSE 0

#endif

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = HW_BREAKPOINT_R | HW_BREAKPOINT_W,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = HW_BREAKPOINT_RW | HW_BREAKPOINT_X,
};
#pragma pack(1)
struct my_user_pt_regs {
	uint64_t regs[31];
	uint64_t sp;
	uint64_t pc;
	uint64_t pstate;
	uint64_t orig_x0;
	uint64_t syscallno;
};

struct HW_HIT_ITEM {
	uint64_t task_id;
	uint64_t hit_addr;
	uint64_t hit_time;
	struct my_user_pt_regs regs_info;
};
#pragma pack()

#ifdef __linux__
class CHwBreakpointMgr {
public:

	CHwBreakpointMgr() {}
	~CHwBreakpointMgr() { DisconnectDriver(); }


	// 连接驱动
	// 参数 procNodeAuthKey：隐蔽节点连接密钥
	// 返回值：>=0成功，<0错误码
	int ConnectDriver(const std::string& procNodeAuthKey) {
		return _InternalConnectDriver(procNodeAuthKey);
	}

	// 断开驱动
	// 返回值：TRUE成功，FALSE失败
	BOOL DisconnectDriver() {
		return _InternalDisconnectDriver();
	}

	// 检查驱动连接状态
	// 返回值：TRUE已连接，FALSE未连接
	BOOL IsDriverConnected() {
		return _InternalIsDriverConnected();
	}

	// 驱动_打开进程
	// 参数 pid：目标进程PID
	// 返回值：成功返回进程句柄，失败返回0
	uint64_t OpenProcess(uint64_t pid) {
		return _InternalOpenProcess(pid);
	}

	// 驱动_关闭进程句柄
	// 参数 hProcess：进程句柄
	// 返回值：TRUE成功，FALSE失败
	BOOL CloseHandle(uint64_t hProcess) {
		return _InternalCloseHandle(hProcess);
	}

	// 驱动_获取CPU硬件执行断点支持数量
	// 返回值：数量
	int GetNumBRPS() {
		return _InternalGetNumBRPS();
	}

	// 驱动_获取CPU硬件访问断点支持数量
	// 返回值：数量
	int GetNumWRPS() {
		return _InternalGetNumWRPS();
	}

	
	// 驱动_安装进程硬件断点
	// 参数 hProcess：进程句柄
	// 参数 lpBaseAddress：进程内存地址
	// 参数 hwbpLen：硬件断点长度
	// 参数 hwbpType：硬件断点类型
	// 返回值：成功返回硬件断点句柄，失败返回0
	uint64_t InstProcessHwBp(
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		unsigned int hwbpLen,
		unsigned int hwbpType
	) {
		return _InternalInstProcessHwBp(hProcess, lpBaseAddress, hwbpLen, hwbpType);
	}


	// 驱动_卸载进程硬件断点
	// 参数 hHwbp：硬件断点句柄
	// 返回值：TRUE成功，FALSE失败
	BOOL UninstProcessHwBp(uint64_t hHwbp) {
		return _InternalUninstProcessHwBp(hHwbp);
	}

	// 驱动_暂停进程硬件断点
	// 参数 hHwbp：硬件断点句柄
	// 返回值：TRUE成功，FALSE失败
	BOOL SuspendProcessHwBp(uint64_t hHwbp) {
		return _InternalSuspendProcessHwBp(hHwbp);
	}
	
	// 驱动_恢复进程硬件断点
	// 参数 hHwbp：硬件断点句柄
	// 返回值：TRUE成功，FALSE失败
	BOOL ResumeProcessHwBp(uint64_t hHwbp) {
		return _InternalResumeProcessHwBp(hHwbp);
	}

	// 驱动_读取硬件断点命中记录信息
	// 参数 hHwbp：硬件断点句柄
	// 参数 nHitTotalCount：输出命中总数
	// 参数 vOutput：输出命中信息
	// 返回值：TRUE成功，FALSE失败
	BOOL ReadHwBpInfo(uint64_t hHwbp, uint64_t & nHitTotalCount, std::vector<HW_HIT_ITEM> & vOutput) {
		return _InternalReadHwBpInfo(hHwbp, nHitTotalCount, vOutput);
	}

	// 驱动_设置无条件Hook跳转
	// 参数 pc：硬件执行断点触发后，要跳转到的进程内存地址
	// 返回值：TRUE成功，FALSE失败
	BOOL SetHookPC(uint64_t pc) {
		return _hwbpProcDriver_SetHookPC(m_nFd, pc);
	}
	
	// 驱动_隐藏内核模块
	// 返回值：TRUE成功，FALSE失败
	BOOL HideKernelModule() {
		return _InternalHideKernelModule();
	}

private:
	int _InternalConnectDriver(const std::string& procNodeAuthKey) {
		if (m_nFd >= 0) { return TRUE; }
		m_nFd = _hwbpProcDriver_Connect(procNodeAuthKey);
		if (m_nFd < 0) {
			return m_nFd;
		}
		return 0;
	}

	BOOL _InternalDisconnectDriver() {
		if (m_nFd >= 0) {
			_hwbpProcDriver_Disconnect(m_nFd);
			m_nFd = -1;
			return TRUE;
		}
		return FALSE;
	}

	BOOL _InternalIsDriverConnected() {
		return m_nFd >= 0 ? TRUE : FALSE;
	}

	BOOL _InternalHideKernelModule() {
		return _hwbpProcDriver_HideKernelModule(m_nFd);
	}

	uint64_t _InternalOpenProcess(uint64_t pid) {
		return _hwbpProcDriver_OpenProcess(m_nFd, pid);
	}

	BOOL _InternalCloseHandle(uint64_t hProcess) {
		return _hwbpProcDriver_CloseHandle(m_nFd, hProcess);
	}

	int _InternalGetNumBRPS() {
		return _hwbpProcDriver_GetNumBRPS(m_nFd);
	}

	int _InternalGetNumWRPS() {
		return _hwbpProcDriver_GetNumWRPS(m_nFd);
	}

	uint64_t _InternalInstProcessHwBp(uint64_t hProcess, uint64_t lpBaseAddress, unsigned int hwbpLen, unsigned int hwbpType) {
		return _hwbpProcDriver_InstProcessHwBp(m_nFd, hProcess, lpBaseAddress, hwbpLen, hwbpType);
	}

	BOOL _InternalUninstProcessHwBp(uint64_t hHwbp) {
		return _hwbpProcDriver_UninstProcessHwBp(m_nFd, hHwbp);
	}

	BOOL _InternalSuspendProcessHwBp(uint64_t hHwbp) {
		return _hwbpProcDriver_SuspendProcessHwBp(m_nFd, hHwbp);
	}

	BOOL _InternalResumeProcessHwBp(uint64_t hHwbp) {
		return _hwbpProcDriver_ResumeProcessHwBp(m_nFd, hHwbp);
	}

	BOOL _InternalReadHwBpInfo(uint64_t hHwbp, uint64_t & nHitTotalCount, std::vector<HW_HIT_ITEM> & vOutput) {
		return _hwbpProcDriver_ReadHwBpInfo(m_nFd, hHwbp, nHitTotalCount, vOutput);
	}

	enum {
		CMD_OPEN_PROCESS, 				// 打开进程
		CMD_CLOSE_PROCESS, 				// 关闭进程
		CMD_GET_NUM_BRPS, 				// 获取CPU硬件执行断点支持数量
		CMD_GET_NUM_WRPS, 				// 获取CPU硬件访问断点支持数量
		CMD_INST_PROCESS_HWBP,			// 安装进程硬件断点
		CMD_UNINST_PROCESS_HWBP,		// 卸载进程硬件断点
		CMD_SUSPEND_PROCESS_HWBP,		// 暂停进程硬件断点
		CMD_RESUME_PROCESS_HWBP,		// 恢复进程硬件断点
		CMD_GET_HWBP_HIT_COUNT,			// 获取硬件断点命中地址数量
		CMD_GET_HWBP_HIT_DETAIL,		// 获取硬件断点命中详细信息
		CMD_SET_HOOK_PC,				// 设置无条件Hook跳转
		CMD_HIDE_KERNEL_MODULE,			// 隐藏驱动
	};

	#pragma pack(push,1)
	struct IoctlRequest {
		char     cmd = 0;        // 操作命令
		uint64_t param1 = 0;     // 参数1
		uint64_t param2 = 0;     // 参数2
		uint64_t param3 = 0;     // 参数3
		uint64_t bufSize = 0;    // 紧随其后的动态数据长度
	};
	#pragma pack(pop)
	inline ssize_t _hwbpProcDriver_MyIoctl(
		int      fd,
		char     cmd,
		uint64_t param1,
		uint64_t param2,
		uint64_t param3,
		char* buf,
		uint64_t   bufSize)
	{
		constexpr size_t headerSize = sizeof(IoctlRequest);
		size_t totalSize = headerSize + bufSize;

		static thread_local IoctlBufferPool pool;
		char* pBuf = pool.getBuffer(totalSize);
		if (!pBuf) return -ENOMEM;  

		IoctlRequest* req = reinterpret_cast<IoctlRequest*>(pBuf);
		req->cmd     = cmd;
		req->param1  = param1;
		req->param2  = param2;
		req->param3  = param3;
		req->bufSize = bufSize;
		if (bufSize > 0) {
			std::memcpy(pBuf + headerSize, buf, bufSize);
		}
		auto outRead = ::read(fd, pBuf, totalSize);
		std::memcpy(buf, pBuf + headerSize, bufSize);
		return outRead;
	}

	int _hwbpProcDriver_Connect(const std::string& procNodeAuthKey) {
	    namespace fs = std::filesystem;
		fs::path nodePath = fs::path("/proc") / procNodeAuthKey / procNodeAuthKey;
		const char* pathCStr = nodePath.c_str();
		if (chmod(pathCStr, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) != 0) {
			int err = errno;
			return -err;
		}
		int fd = open(pathCStr, O_RDWR);
		if (fd < 0) {
			int err = errno;
			return -err;
		}
		return fd;
	}

	BOOL _hwbpProcDriver_Disconnect(int nFd) {
		if (nFd < 0) { return FALSE; }
		close(nFd);
		return TRUE;
	}

	BOOL _hwbpProcDriver_HideKernelModule(int nFd) {
		if (nFd < 0) { return FALSE; }
		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_HIDE_KERNEL_MODULE, 0, 0, 0, NULL, 0);
		if (res != 0) {
			return FALSE;
		}
		return TRUE;
	}

	uint64_t _hwbpProcDriver_OpenProcess(int nFd, uint64_t pid) {
		if (nFd < 0 || pid == 0) { return 0; }
		uint64_t handle = 0;
		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_OPEN_PROCESS, pid, 0, 0, (char*)&handle, sizeof(handle));
		if (res != 0) {
			return 0;
		}
		return handle;
	}

	BOOL _hwbpProcDriver_CloseHandle(int nFd, uint64_t hProcess) {
		if (nFd < 0 || !hProcess) { return FALSE; }
		if (_hwbpProcDriver_MyIoctl(nFd, CMD_CLOSE_PROCESS, hProcess, 0, 0, NULL, 0) != 0) {
			return FALSE;
		}
		return TRUE;
	}

	int _hwbpProcDriver_GetNumBRPS(int nFd) {
		if (nFd < 0) { return 0; }
		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_GET_NUM_BRPS, 0, 0, 0, NULL, 0);
		return res;
	}

	int _hwbpProcDriver_GetNumWRPS(int nFd) {
		if (nFd < 0) { return 0; }
		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_GET_NUM_WRPS, 0, 0, 0, NULL, 0);
		return res;
	}

	uint64_t _hwbpProcDriver_InstProcessHwBp(
		int nFd,
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		unsigned int hwbpLen,
		unsigned int hwbpType
	) {
		if (nFd < 0 || !hProcess || !lpBaseAddress) { return 0; }
		uint64_t param3 = 0;
		char *p = (char*)&param3;
		p[0] = hwbpLen;
		p[1] = hwbpType;
		
		uint64_t hHwbp;
		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_INST_PROCESS_HWBP, hProcess, lpBaseAddress, param3, (char*)&hHwbp, sizeof(hHwbp));
		if (res != 0) {
			//printf("InstProcessHwBp _hwbpProcDriver_MyIoctl():%s\n", strerror(errno));
			return 0;
		}
		return hHwbp;
	}


	BOOL _hwbpProcDriver_UninstProcessHwBp(
		int nFd,
		uint64_t hHwbp) {
		if (nFd < 0 || !hHwbp) { return FALSE; }
		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_UNINST_PROCESS_HWBP, hHwbp, 0, 0, NULL, 0);
		if (res != 0) {
			//printf("UninstProcessHwBp _hwbpProcDriver_MyIoctl():%s\n", strerror(errno));
			return FALSE;
		}
		return TRUE;
	}

	BOOL _hwbpProcDriver_SuspendProcessHwBp(
		int nFd,
		uint64_t hHwbp) {
		if (nFd < 0 || !hHwbp) { return FALSE; }

		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_SUSPEND_PROCESS_HWBP, hHwbp, 0, 0, NULL, 0);
		if (res != 0) {
			//printf("SuspendProcessHwBp _hwbpProcDriver_MyIoctl():%s\n", strerror(errno));
			return FALSE;
		}
		return TRUE;
	}

	BOOL _hwbpProcDriver_ResumeProcessHwBp(
		int nFd,
		uint64_t hHwbp) {
		if (nFd < 0 || !hHwbp) { return FALSE; }

		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_RESUME_PROCESS_HWBP, hHwbp, 0, 0, NULL, 0);
		if (res != 0) {
			//printf("ResumeProcessHwBp _hwbpProcDriver_MyIoctl():%s\n", strerror(errno));
			return FALSE;
		}
		return TRUE;
	}

	BOOL _hwbpProcDriver_ReadHwBpInfo(
		int nFd,
		uint64_t hHwbp,
		uint64_t & nHitTotalCount,
		std::vector<HW_HIT_ITEM> &vOutput
	) {
		if (nFd < 0 || !hHwbp) { return FALSE; }
		#pragma pack(1)
		struct {
			uint64_t nHitTotalCount;
			uint64_t nHitItemArrCount;
		} userData = {0};
		#pragma pack()
		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_GET_HWBP_HIT_COUNT, hHwbp, 0, 0, (char*)&userData, sizeof(userData));
		//printf("ioctl res %d\n", res);
		if (res != 0) {
			//printf("ioctl():%s\n", strerror(errno));
			return FALSE;
		}
		nHitTotalCount = userData.nHitTotalCount;
		//printf("nHitTotalCount:%lu, nHitItemArrCount:%lu\n", userData.nHitTotalCount, userData.nHitItemArrCount);
		if(userData.nHitItemArrCount > 0) {
			std::vector<char> big_buf;
			big_buf.resize(sizeof(struct HW_HIT_ITEM) * userData.nHitItemArrCount);
			
			res = _hwbpProcDriver_MyIoctl(nFd, CMD_GET_HWBP_HIT_DETAIL, hHwbp, 0, 0, (char*)big_buf.data(), big_buf.size());
			//printf("ioctl res %d\n", res);
			if (res == 0) {
				//printf("ioctl():%s\n", strerror(errno));
				return FALSE;
			}
			auto* items = reinterpret_cast<const HW_HIT_ITEM*>(big_buf.data());
			size_t count = userData.nHitItemArrCount;
			vOutput.insert(vOutput.end(), items, items + count);
		}
		return TRUE;
	}

	
	BOOL _hwbpProcDriver_SetHookPC(
		int nFd,
		uint64_t pc
	) {
		if (nFd < 0) { return 0; }
		ssize_t res = _hwbpProcDriver_MyIoctl(nFd, CMD_SET_HOOK_PC, pc, 0, 0, NULL, 0);
		if (res != 0) {
			//printf("ioctl():%s\n", strerror(errno));
			return FALSE;
		}
		return TRUE;
	}
	
private:
	int m_nFd = -1;
};
#endif
#endif /* HW_BREAKPOINT_MANAGER_H_ */

```

`hwBreakpointProcModule/testHwBp/jni/IoctlBufferPool.h`:

```h
#ifndef IOCTL_BUFFER_POOL_H_
#define IOCTL_BUFFER_POOL_H_
#ifdef __linux__
#include <cstddef>  // for size_t
#include <new>      // for std::nothrow

// 创建一个静态内存缓冲区，避免重复分配内存
class IoctlBufferPool {
    static constexpr size_t kDefaultBuffer = 4096;   // 默认小缓冲区
    char    _smallBuf[kDefaultBuffer];               // 小缓冲区（无需动态分配）
    char*   _largeBuf     = nullptr;                 // 大缓冲区指针
    size_t  _largeBufSize = 0;                       // 已分配大缓冲区容量

public:
    ~IoctlBufferPool() {
        // 在线程退出时自动释放大缓冲区
		if(_largeBuf) {
        	delete[] _largeBuf;
		}
    }

    // 获取至少 capacity 字节的缓冲区
    char* getBuffer(size_t capacity) {
        if (capacity <= kDefaultBuffer) {
            return _smallBuf;
        }
        if (_largeBufSize < capacity) {
            // 需要更大的缓冲区，先释放旧的再分配
			if(_largeBuf) {
				delete[] _largeBuf;
			}
            _largeBuf = new (std::nothrow) char[capacity];
            _largeBufSize = _largeBuf ? capacity : 0;
        }
        return _largeBuf;
    }
};
#endif /*__linux__*/

#endif /* IOCTL_BUFFER_POOL_H_ */

```

`hwBreakpointProcModule/testHwBp/jni/testHwBp.cpp`:

```cpp
#include <cstdio>
#include <string.h> 
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <memory>
#include <dirent.h>
#include <thread>
#include <sstream>
#include <cinttypes>
#include "HwBreakpointMgr4.h"

int g_value = 0;

BOOL GetProcessTask(int pid, std::vector<int> & vOutput) {
	DIR *dir = NULL;
	struct dirent *ptr = NULL;
	char szTaskPath[256] = { 0 };
	sprintf(szTaskPath, "/proc/%d/task", pid);

	dir = opendir(szTaskPath);
	if (NULL != dir) {
		while ((ptr = readdir(dir)) != NULL) {
			if ((strcmp(ptr->d_name, ".") == 0) || (strcmp(ptr->d_name, "..") == 0)) {
				continue;
			} else if (ptr->d_type != DT_DIR) {
				continue;
			} else if (strspn(ptr->d_name, "1234567890") != strlen(ptr->d_name)) {
				continue;
			}

			int task = atoi(ptr->d_name);
			vOutput.push_back(task);
		}
		closedir(dir);
		return TRUE;
	}
	return FALSE;
}

void AddValueThread() {
	while(1) {
		g_value++;
		printf("pid:%d, g_value addr:%p, g_value: %d\n", getpid(), (void*)&g_value, g_value);
		fflush(stdout);
		sleep(1);
	}
}

std::string TimestampToDatetime(uint64_t timestamp) {
    time_t t = (time_t)timestamp;
    struct tm *tm_info = localtime(&t);
    char buffer[256] = {0};
    strftime(buffer, 26, "%Y-%m-%d %H:%M:%S", tm_info);
    return buffer;
}

void PrintHwHitItem(const std::vector<HW_HIT_ITEM> &vHit) {
	for (const HW_HIT_ITEM &hitItem : vHit) {
		printf("==========================================================================\n");
		printf("时间:%s, 线程ID:%zu, 硬断命中地址:%p\n", TimestampToDatetime(hitItem.hit_time).c_str(), hitItem.task_id, (void*)hitItem.hit_addr);
		for (int r = 0; r < 30; r += 5) {
			printf("\tX%-2d=%-20p, X%-2d=%-20p, X%-2d=%-20p, X%-2d=%-20p, X%-2d=%-20p\n",
				r, (void*)hitItem.regs_info.regs[r],
				r + 1, (void*)hitItem.regs_info.regs[r + 1],
				r + 2, (void*)hitItem.regs_info.regs[r + 2],
				r + 3, (void*)hitItem.regs_info.regs[r + 3],
				r + 4, (void*)hitItem.regs_info.regs[r + 4]);
		}
		printf("\tLR=%-20p, SP=%-20p, PC=%-20p\n",
			(void*)hitItem.regs_info.regs[30],
			(void*)hitItem.regs_info.sp,
			(void*)hitItem.regs_info.pc);

		printf("\tprocess status:%p, orig_x0:%p, syscallno:%p\n",
			(void*)hitItem.regs_info.pstate,
			(void*)hitItem.regs_info.orig_x0,
			(void*)hitItem.regs_info.syscallno);
	}
}

int main(int argc, char *argv[]) {
	printf(
		"======================================================\n"
		"本驱动名称: Linux ARM64 硬件断点进程调试驱动4\n"
		"本驱动接口列表：\n"
		"\t1.  驱动_打开进程: OpenProcess\n"
		"\t2.  驱动_关闭进程: CloseHandle\n"
		"\t3.  驱动_获取CPU硬件执行断点支持数量: GetNumBRPS\n"
		"\t4.  驱动_获取CPU硬件访问断点支持数量: GetNumWRPS\n"
		"\t5.  驱动_安装进程硬件断点: InstProcessHwBp\n"
		"\t6.  驱动_鞋子啊进程硬件断点: UninstProcessHwBp\n"
		"\t7.  驱动_暂停硬件断点: SuspendProcessHwBp\n"
		"\t8.  驱动_恢复硬件断点: ResumeProcessHwBp\n"
		"\t9.  驱动_读取硬件断点命中信息: ReadHwBpInfo\n"
		"\t10. 驱动_设置无条件Hook跳转: SetHookPC\n"
		"\t11. 驱动_隐藏驱动: HideKernelModule\n"
		"\t以上所有功能不注入、不附加进程, 不打开进程任何文件, 所有操作均为内核操作\n"
		"======================================================\n"
	);

	int pid = getpid();

	//启动数值增加线程
	std::thread tdValue(AddValueThread);
	tdValue.detach();
	usleep(1000*250);

	CHwBreakpointMgr driver;
	//驱动默认隐蔽通信密匙
	std::string procNodeAuthKey = "dce3771681d4c7a143d5d06b7d32548e";
	if (argc > 1) {
		//用户自定义输入驱动隐蔽通信密匙
		procNodeAuthKey = argv[1];
	}
	printf("Connecting HWBP auth key:%s\n", procNodeAuthKey.c_str());

	//连接驱动
	int err = driver.ConnectDriver(procNodeAuthKey.c_str());
	if (err < 0) {
		printf("Connect HWBP driver failed. error:%d\n", err);
		fflush(stdout);
		return 0;
	}

	//获取CPU支持硬件执行和访问断点的数量
	printf("Call GetNumBRPS() return:%d\n", driver.GetNumBRPS());
	printf("Call GetNumWRPS() return:%d\n", driver.GetNumWRPS());

	//获取当前进程所有的task
	std::vector<int> vTask;
	GetProcessTask(pid, vTask);
	if (vTask.size() == 0) {
		printf("GetProcessTask failed\n");
		return 0;
	}
	printf("GetProcessTask successfully, task count:%lu\n", vTask.size());

	//设置进程硬件断点
	std::vector<uint64_t> vHwBpHandle;
	for (int taskId : vTask) {
		if(taskId == getpid()) {
			continue; //不能打开自身
		}
		//打开task
		uint64_t hProcess = driver.OpenProcess(taskId);
		printf("Call OpenProcess(%d) return:%p\n", taskId, (void*)hProcess);
		if (!hProcess) {
			printf("Call OpenProcess failed\n");
			fflush(stdout);
			continue;
		}

		//设置读写硬件断点
		uint64_t hwBpHandle = driver.InstProcessHwBp(hProcess, (uint64_t)&g_value, HW_BREAKPOINT_LEN_4, HW_BREAKPOINT_W);
		printf("Call InstProcessHwBp(%d, %p) return:%p\n", taskId, &g_value, (void*)hwBpHandle);

		if (hwBpHandle) {
			vHwBpHandle.push_back(hwBpHandle);
		}
		//关闭task
		driver.CloseHandle(hProcess);
		printf("Call CloseHandle:%p\n", (void*)hProcess);
	}
	printf("==========================================================================\n");
	for(int i = 0; i < 5; i++) {
		sleep(1);
	}
	//暂停硬件断点
	for (uint64_t hwbpHandle : vHwBpHandle) {
		BOOL b = driver.SuspendProcessHwBp(hwbpHandle);
		printf("Call SuspendProcessHwBp(%p) return:%d\n", (void*)hwbpHandle, b);
	}
	//读取硬件断点命中信息
	for (uint64_t hwbpHandle : vHwBpHandle) {
		uint64_t nHitTotalCount = 0;
		std::vector<HW_HIT_ITEM> vHit;
		BOOL b = driver.ReadHwBpInfo(hwbpHandle, nHitTotalCount, vHit);
		printf("==========================================================================\n");
		printf("Call ReadProcessHwBp(%p) return:%d, hit_total_count:%lu, save_hit_item_count:%lu\n", (void*)hwbpHandle, b, nHitTotalCount, vHit.size());
		PrintHwHitItem(vHit);
	}
	//删除进程硬件断点
	for (uint64_t hwbpHandle : vHwBpHandle) {
		driver.UninstProcessHwBp(hwbpHandle);
		printf("Call UninstProcessHwBp(%p)\n", (void*)hwbpHandle);
	}
	return 0;
}
```

`hwBreakpointProcModule/testHwBpClient/Global.cpp`:

```cpp
#include "pch.h"
#include "Global.h"

CNetworkMgr g_NetworkMgr;
```

`hwBreakpointProcModule/testHwBpClient/Global.h`:

```h
#ifndef GLOBAL_H_
#define GLOBAL_H_
#include <map>
#include <vector>
#include <memory>
#include <atomic>
#include <cstdint>
#include <cinttypes>
#include <WinSock2.h>
#pragma comment(lib, "comsuppw.lib")
#include "NetworkMgr.h"

extern CNetworkMgr g_NetworkMgr;

static std::string ws2s(const std::wstring& ws) {
	_bstr_t t = ws.c_str();
	char* pchar = (char*)t;
	std::string result = pchar;
	return result;
}

static std::wstring s2ws(const std::string& s) {
	_bstr_t t = s.c_str();
	wchar_t* pwchar = (wchar_t*)t;
	std::wstring result = pwchar;
	return result;
}
#if defined(_MSC_VER)
#include <BaseTsd.h>
typedef SSIZE_T ssize_t;
#endif
static ssize_t recvall(SOCKET s, void *buf, size_t size, int flags) {
	ssize_t totalreceived = 0;
	ssize_t sizeleft = size;
	unsigned char *buffer = (unsigned char*)buf;

	// enter recvall
	flags = flags | MSG_WAITALL;

	while (sizeleft > 0) {
		auto i = recv(s, (char*)&buffer[totalreceived], sizeleft, flags);
		if (i == 0) {
			printf("recv returned 0\n");
			return i;
		}
		if (i == -1) {
			printf("recv returned -1\n");
			if (errno == EINTR) {
				printf("errno = EINTR\n");
				i = 0;
			} else {
				printf("Error during recvall: %d. errno=%d\n", (int)i, errno);
				return i; //read error, or disconnected
			}
		}
		totalreceived += i;
		sizeleft -= i;
	}
	// leave recvall
	return totalreceived;
}

static ssize_t sendall(SOCKET s, void *buf, size_t size, int flags) {
	ssize_t totalsent = 0;
	ssize_t sizeleft = size;
	unsigned char *buffer = (unsigned char*)buf;

	while (sizeleft > 0) {
		auto i = send(s, (const char*)&buffer[totalsent], sizeleft, flags);

		if (i == 0) {
			return i;
		}

		if (i == -1) {
			if (errno == EINTR) {
				i = 0;
			} else {
				printf("Error during sendall: %d. errno=%d\n", (int)i, errno);
				return i;
			}
		}
		totalsent += i;
		sizeleft -= i;
	}

	return totalsent;
}

#endif /* GLOBAL_H_ */
```

`hwBreakpointProcModule/testHwBpClient/NetworkDlg.cpp`:

```cpp
// NetworkDlg.cpp: 实现文件
//

#include "pch.h"
#include "testHwBpClient.h"
#include "NetworkDlg.h"
#include "afxdialogex.h"
#include <string>
#include <vector>
#include <sstream>
#include <thread>
#include <IPHlpApi.h>
#pragma comment(lib,"IPHlpApi.lib")
#include<WINSOCK2.H>
#pragma comment(lib,"ws2_32.lib")
#include "Global.h"

#define WM_ADD_FIND_SERVER WM_USER + 1

// CNetworkDlg 对话框

IMPLEMENT_DYNAMIC(CNetworkDlg, CDialogEx)

CNetworkDlg::CNetworkDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_NETWORK_DIALOG, pParent)
	, m_edit_ip(_T(""))
	, m_edit_port(_T("")) {

}

CNetworkDlg::~CNetworkDlg() {
}

void CNetworkDlg::DoDataExchange(CDataExchange* pDX) {
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_FIND_SERVER, m_list_find_server);
	DDX_Text(pDX, IDC_EDIT_IP, m_edit_ip);
	DDX_Text(pDX, IDC_EDIT_PORT, m_edit_port);
}


BEGIN_MESSAGE_MAP(CNetworkDlg, CDialogEx)
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_TIMER()
	ON_BN_CLICKED(IDC_CONNECT, &CNetworkDlg::OnBnClickedConnect)
	ON_BN_CLICKED(IDC_CANCEL, &CNetworkDlg::OnBnClickedCancel)
	ON_MESSAGE(WM_ADD_FIND_SERVER, OnAddFindServer)
	ON_NOTIFY(HDN_ITEMCLICK, 0, &CNetworkDlg::OnItemclickListFindServer)
	ON_NOTIFY(NM_CLICK, IDC_LIST_FIND_SERVER, &CNetworkDlg::OnClickListFindServer)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_FIND_SERVER, &CNetworkDlg::OnDblclkListFindServer)
END_MESSAGE_MAP()

// CNetworkDlg 消息处理程序

//测试服务器端口是否开放
void TestIdentifierThread(std::unique_ptr<char[]> ip, HWND resultHwnd) {
	SOCKET skServer = socket(PF_INET, SOCK_DGRAM, 0);
	sockaddr_in addr;
	addr.sin_family = PF_INET;
	addr.sin_port = htons(3290);
	addr.sin_addr.S_un.S_addr = inet_addr(ip.get());
	BOOL bSuccess = (connect(skServer, (sockaddr*)&addr, sizeof(sockaddr_in)) == 0) ? TRUE : FALSE;

	if (bSuccess && IsWindow(resultHwnd)) {
#pragma pack(1)
		struct {
			uint32_t checksum;
			uint16_t port;
		} packet;
#pragma pack()

		struct sockaddr_in addr_client = { 0 };
		addr_client.sin_family = PF_INET;
		addr_client.sin_addr.s_addr = inet_addr(ip.get());
		addr_client.sin_port = htons(3290);

		socklen_t clisize = sizeof(addr_client);

		packet.checksum = 1;
		packet.port = 3290;
		if (sendto(skServer, (const char*)&packet, sizeof(packet), 0, (struct sockaddr *)&addr_client, (int)&clisize) > 0) {
			if (recvfrom(skServer, (char*)&packet, sizeof(packet), 0, (struct sockaddr *)&addr_client, &clisize) > 0) {
				if (packet.checksum == 0xce) {
					//找到testHwBpServer了，通知主界面显示
					::PostMessage(resultHwnd, WM_ADD_FIND_SERVER, (WPARAM)ip.release(), packet.port);
				}
			}
		}
	}
	closesocket(skServer);

	return;
}
//探测可连接的服务器地址
BOOL GetHwServerIP(HWND resultHwnd) {
	//IP_ADAPTER_INFO结构体
	PIP_ADAPTER_INFO pIpAdapterInfo = NULL;
	pIpAdapterInfo = new IP_ADAPTER_INFO;

	//结构体大小
	unsigned long ulSize = sizeof(IP_ADAPTER_INFO);

	//获取适配器信息
	int nRet = GetAdaptersInfo(pIpAdapterInfo, &ulSize);

	if (ERROR_BUFFER_OVERFLOW == nRet) {
		//空间不足，删除之前分配的空间
		delete[]pIpAdapterInfo;

		//重新分配大小
		pIpAdapterInfo = (PIP_ADAPTER_INFO) new BYTE[ulSize];

		//获取适配器信息
		nRet = GetAdaptersInfo(pIpAdapterInfo, &ulSize);

		//获取失败
		if (ERROR_SUCCESS != nRet) {
			if (pIpAdapterInfo != NULL) {
				delete[]pIpAdapterInfo;
			}
			return FALSE;
		}
	}

	//MAC 地址信息
	//char szMacAddr[20];
	//赋值指针
	PIP_ADAPTER_INFO pIterater = pIpAdapterInfo;
	while (pIterater) {
		//cout << "网卡名称：" << pIterater->AdapterName << endl;

		//cout << "网卡描述：" << pIterater->Description << endl;

		/*sprintf_s(szMacAddr, 20, "%02X-%02X-%02X-%02X-%02X-%02X",
			pIterater->Address[0],
			pIterater->Address[1],
			pIterater->Address[2],
			pIterater->Address[3],
			pIterater->Address[4],
			pIterater->Address[5]);*/

			//cout << "MAC 地址：" << szMacAddr << endl;

			//cout << "IP地址列表：" << endl << endl;

			//指向IP地址列表
		PIP_ADDR_STRING pIpAddr = &pIterater->IpAddressList;
		while (pIpAddr) {
			//cout << "IP地址：  " << pIpAddr->IpAddress.String << endl;
			//cout << "子网掩码：" << pIpAddr->IpMask.String << endl;

			//指向网关列表
			PIP_ADDR_STRING pGateAwayList = &pIterater->GatewayList;
			while (pGateAwayList) {
				//cout << "网关：    " << pGateAwayList->IpAddress.String << endl;

				if (strcmp(pGateAwayList->IpAddress.String, "0.0.0.0") != 0) {
					//测试是否可连接
					std::unique_ptr<char[]> temIP = std::make_unique<char[]>(256);
					memset(temIP.get(), 0, 256);
					strcpy(temIP.get(), pGateAwayList->IpAddress.String);

					std::thread td(TestIdentifierThread, std::move(temIP), resultHwnd);
					td.detach();
				}

				pGateAwayList = pGateAwayList->Next;
			}

			pIpAddr = pIpAddr->Next;
		}
		//cout << endl << "--------------------------------------------------" << endl;

		pIterater = pIterater->Next;
	}

	//清理
	if (pIpAdapterInfo) {
		delete[]pIpAdapterInfo;
	}



	return TRUE;
}

BOOL CNetworkDlg::OnInitDialog() {
	CDialogEx::OnInitDialog();

	//初始化列表框
	LONG lStyle;
	lStyle = GetWindowLong(m_list_find_server.m_hWnd, GWL_STYLE);
	lStyle &= ~LVS_TYPEMASK; //清除显示方式位
	lStyle |= LVS_REPORT;
	SetWindowLong(m_list_find_server.m_hWnd, GWL_STYLE, lStyle);
	DWORD dwStyle = m_list_find_server.GetExtendedStyle();
	dwStyle |= LVS_EX_FULLROWSELECT;//选中某行使整行高亮（只适用与report风格的listctrl）
	dwStyle |= LVS_EX_GRIDLINES;//网格线（只适用与report风格的listctrl）
	//dwStyle |= LVS_EX_CHECKBOXES;//item前生成checkbox控件
	m_list_find_server.SetExtendedStyle(dwStyle);

	m_list_find_server.InsertColumn(0, L"IP", LVCFMT_LEFT, 200);//插入列
	m_list_find_server.InsertColumn(1, L"端口", LVCFMT_LEFT, 200);

	//探测可连接的服务器地址
	GetHwServerIP(m_hWnd);
	return TRUE;  // return TRUE unless you set the focus to a control
				  // 异常: OCX 属性页应返回 FALSE
}


BOOL CNetworkDlg::PreTranslateMessage(MSG* pMsg) {
	// TODO: 在此添加专用代码和/或调用基类

	return CDialogEx::PreTranslateMessage(pMsg);
}


void CNetworkDlg::OnClose() {
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	CDialogEx::OnClose();
}


void CNetworkDlg::OnDestroy() {
	CDialogEx::OnDestroy();

	// TODO: 在此处添加消息处理程序代码
}


void CNetworkDlg::OnSize(UINT nType, int cx, int cy) {
	CDialogEx::OnSize(nType, cx, cy);

	// TODO: 在此处添加消息处理程序代码
}


void CNetworkDlg::OnTimer(UINT_PTR nIDEvent) {
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	CDialogEx::OnTimer(nIDEvent);
}


void CNetworkDlg::OnBnClickedConnect() {
	// TODO: 在此添加控件通知处理程序代码
	UpdateData(TRUE);
	if (m_edit_ip.IsEmpty() || m_edit_port.IsEmpty()) {
		MessageBox(L"IP或端口不能为空");
		return;
	}
	if (!g_NetworkMgr.ConnectHwBpServer(ws2s(m_edit_ip.GetBuffer(0)), _wtoi(m_edit_port.GetBuffer(0)))) {
		MessageBox(L"连接失败");
		return;
	}
	OnOK();
}


void CNetworkDlg::OnBnClickedCancel() {
	OnOK();
}

LRESULT CNetworkDlg::OnAddFindServer(WPARAM wParam, LPARAM lParam) {
	std::unique_ptr<char[]> myMsgParam((char*)wParam);

	//显示IP地址
	int nCount = m_list_find_server.GetItemCount();
	m_list_find_server.InsertItem(nCount, s2ws(myMsgParam.get()).c_str());

	//显示端口号
	std::wstringstream ssConvert;
	ssConvert << (size_t)lParam;
	m_list_find_server.SetItemText(nCount, 1, ssConvert.str().c_str());

	return 0;
}


void CNetworkDlg::OnItemclickListFindServer(NMHDR *pNMHDR, LRESULT *pResult) {
	LPNMHEADER phdr = reinterpret_cast<LPNMHEADER>(pNMHDR);
	// TODO: 在此添加控件通知处理程序代码
	*pResult = 0;
}


void CNetworkDlg::OnClickListFindServer(NMHDR *pNMHDR, LRESULT *pResult) {
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	if (pNMItemActivate->iItem != -1) {
		//按下了列表
		m_edit_ip = m_list_find_server.GetItemText(pNMItemActivate->iItem, 0);
		m_edit_port = m_list_find_server.GetItemText(pNMItemActivate->iItem, 1);
		UpdateData(FALSE);
	}
	*pResult = 0;
}


void CNetworkDlg::OnDblclkListFindServer(NMHDR *pNMHDR, LRESULT *pResult) {
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	if (pNMItemActivate->iItem != -1) {
		//按下了列表
		m_edit_ip = m_list_find_server.GetItemText(pNMItemActivate->iItem, 0);
		m_edit_port = m_list_find_server.GetItemText(pNMItemActivate->iItem, 1);
		UpdateData(FALSE);
		//开始连接
		OnBnClickedConnect();
	}
	*pResult = 0;
}

```

`hwBreakpointProcModule/testHwBpClient/NetworkDlg.h`:

```h
#pragma once


// CNetworkDlg 对话框

class CNetworkDlg : public CDialogEx {
	DECLARE_DYNAMIC(CNetworkDlg)

public:
	CNetworkDlg(CWnd* pParent = nullptr);   // 标准构造函数
	virtual ~CNetworkDlg();

	// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_NETWORK_DIALOG };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()

public:
	virtual BOOL OnInitDialog();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnBnClickedConnect();
	afx_msg void OnBnClickedCancel();
	afx_msg LRESULT OnAddFindServer(WPARAM wParam, LPARAM lParam);
	afx_msg void OnItemclickListFindServer(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnClickListFindServer(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnDblclkListFindServer(NMHDR *pNMHDR, LRESULT *pResult);
private:
	CListCtrl m_list_find_server;
	CString m_edit_ip;
	CString m_edit_port;
};

```

`hwBreakpointProcModule/testHwBpClient/NetworkMgr.cpp`:

```cpp
#include "pch.h"
#include "NetworkMgr.h"
#include "Global.h"
#include "../testHwBp/jni/HwBreakpointMgr4.h"

CNetworkMgr::CNetworkMgr() {
	WSADATA wsadata;
	WSAStartup(MAKEWORD(2, 2), &wsadata);
	m_skServer = NULL;
}
CNetworkMgr::~CNetworkMgr() {
	if (m_skServer) {
		closesocket(m_skServer);
	}
	WSACleanup();
}
bool CNetworkMgr::ConnectHwBpServer(std::string ip, int port) {
	m_ip = ip;
	m_port = port;

	if (m_skServer) {
		closesocket(m_skServer);
		m_skServer = NULL;
	}

	if (m_ip.empty() || port == 0) {
		return false;
	}
	m_skServer = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.S_un.S_addr = inet_addr(ip.c_str());
	if (connect(m_skServer, (sockaddr*)&addr, sizeof(sockaddr_in)) != 0) {
		closesocket(m_skServer);
		m_skServer = NULL;
		return false;
	}
	return true;
}
bool CNetworkMgr::IsConnected() {
	return m_skServer ? true : false;
}
void CNetworkMgr::Disconnect() {
	if (m_skServer) {
		closesocket(m_skServer);
		m_skServer = NULL;
	}
}
bool CNetworkMgr::Reconnect() {
	return ConnectHwBpServer(m_ip, m_port);
}

bool CNetworkMgr::InstProcessHwBp(const InstProcessHwBpInfo & input, InstProcessHwBpResult & output) {
	output.allTaskCount = 0;
	output.hwbpInstalledCount = 0;
	output.vThreadHit.clear();
	if (!m_skServer) {
		return false;
	}

	unsigned char command = CMD_ADDPROCESSHWBP;
	if (sendall(m_skServer, (char*)&command, 1, 0) <= 0) {
		closesocket(m_skServer);
		m_skServer = NULL;
		return false;
	}

	if (sendall(m_skServer, (void*)&input, sizeof(input), 0) > 0) {
#pragma pack(1)
		struct {
			uint32_t allTaskCount;
			uint32_t hwbpInstalledCount;
			uint32_t hitThreadCount;
		} result;
#pragma pack()
		if (recvall(m_skServer, &result, sizeof(result), MSG_WAITALL) > 0) {
			for (; result.hitThreadCount > 0; result.hitThreadCount--) {

#pragma pack(1)
				struct {
					uint64_t taskId = 0;
					uint64_t address = 0;
					uint64_t hitTotalCount = 0;
					uint64_t saveHitItemCount = 0;
				} threadInfoBuf = { 0 };
#pragma pack()
				if (recvall(m_skServer, &threadInfoBuf, sizeof(threadInfoBuf), MSG_WAITALL) > 0) {
					InstProcessHwBpResultChild child;
					child.taskId = threadInfoBuf.taskId;
					child.address = threadInfoBuf.address;
					child.hitTotalCount = threadInfoBuf.hitTotalCount;
					for (; threadInfoBuf.saveHitItemCount > 0; threadInfoBuf.saveHitItemCount--) {
						HW_HIT_ITEM hitItem = { 0 };
						if (recvall(m_skServer, &hitItem, sizeof(HW_HIT_ITEM), MSG_WAITALL) > 0) {
							child.vHitItem.push_back(hitItem);
						}
					}
					output.vThreadHit.push_back(child);
				}
			}
			output.allTaskCount = result.allTaskCount;
			output.hwbpInstalledCount = result.hwbpInstalledCount;
			return true;
		}
	}
	return false;
}
```

`hwBreakpointProcModule/testHwBpClient/NetworkMgr.h`:

```h
#pragma once
#include <iostream>
#include <vector>
#include<WINSOCK2.H>
#pragma comment(lib,"ws2_32.lib")
#include "../testHwBpServer/jni/hwbpserver.h"
class CNetworkMgr {
public:
	CNetworkMgr();
	~CNetworkMgr();
	bool ConnectHwBpServer(std::string ip, int port);
	bool IsConnected();
	void Disconnect();
	bool Reconnect();

	bool InstProcessHwBp(const InstProcessHwBpInfo& input, InstProcessHwBpResult& output);
private:
	std::string m_ip;
	int m_port;
	SOCKET m_skServer = NULL;

};


```

`hwBreakpointProcModule/testHwBpClient/ScaleHelper.h`:

```h
#pragma once
#include <windows.h>
static size_t GetScaleWidth(size_t originWidth) {
	static int horizontalDPI = 0;
	if (horizontalDPI == 0) {
		HDC hDesktopDC = ::GetDC(0);
		horizontalDPI = GetDeviceCaps(hDesktopDC, LOGPIXELSX);
		::ReleaseDC(0, hDesktopDC);
	}
	return MulDiv(originWidth, horizontalDPI, 96/*不可以修改*/);
}
static size_t GetScaleHeight(size_t originHeight) {
	static int verticalDPI = 0;
	if (verticalDPI == 0) {
		HDC hDesktopDC = ::GetDC(0);
		verticalDPI = GetDeviceCaps(hDesktopDC, LOGPIXELSY);
		::ReleaseDC(0, hDesktopDC);
	}
	return MulDiv(originHeight, verticalDPI, 96/*不可以修改*/);
}
```

`hwBreakpointProcModule/testHwBpClient/TextViewDlg.cpp`:

```cpp
// TextViewDlg.cpp: 实现文件
//

#include "pch.h"
#include "testHwBpClient.h"
#include "TextViewDlg.h"
#include "afxdialogex.h"
#include "ScaleHelper.h"


// CTextViewDlg 对话框

IMPLEMENT_DYNAMIC(CTextViewDlg, CDialogEx)

CTextViewDlg::CTextViewDlg(CString title, CString text)
	: CDialogEx(IDD_TEXT_VIEW_DIALOG, GetDesktopWindow()) {
	m_title = title;
	m_edit_text = text;
}

CTextViewDlg::~CTextViewDlg() {
}

void CTextViewDlg::DoDataExchange(CDataExchange* pDX) {
	CDialogEx::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_EDIT_TEXT, m_edit_text);
}


BEGIN_MESSAGE_MAP(CTextViewDlg, CDialogEx)
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	ON_WM_SIZE()
END_MESSAGE_MAP()


// CTextViewDlg 消息处理程序


BOOL CTextViewDlg::OnInitDialog() {
	CDialogEx::OnInitDialog();

	// TODO:  在此添加额外的初始化

	UpdateData(FALSE);

	m_font.CreateFont(GetScaleWidth(16), 0, 0, 0, FW_EXTRABOLD, FALSE, FALSE, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_MODERN,
		L"新宋体");

	GetDlgItem(IDC_EDIT_TEXT)->SetFont(&m_font);

	SetWindowTextW(m_title);
	return TRUE;  // return TRUE unless you set the focus to a control
				  // 异常: OCX 属性页应返回 FALSE
}


BOOL CTextViewDlg::PreTranslateMessage(MSG* pMsg) {
	// TODO: 在此添加专用代码和/或调用基类

	return CDialogEx::PreTranslateMessage(pMsg);
}


void CTextViewDlg::OnClose() {
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	CDialogEx::OnClose();
}


void CTextViewDlg::OnDestroy() {
	CDialogEx::OnDestroy();

	// TODO: 在此处添加消息处理程序代码
}


void CTextViewDlg::OnSize(UINT nType, int cx, int cy) {
	CDialogEx::OnSize(nType, cx, cy);

	CWnd * edit = GetDlgItem(IDC_EDIT_TEXT);
	if (edit) {
		::SetWindowPos(edit->m_hWnd, NULL, 0, 0, cx, cy, SWP_NOMOVE);
	}
}

```

`hwBreakpointProcModule/testHwBpClient/TextViewDlg.h`:

```h
#pragma once


// CTextViewDlg 对话框

class CTextViewDlg : public CDialogEx
{
	DECLARE_DYNAMIC(CTextViewDlg)

public:
	CTextViewDlg(CString title,CString text);   // 标准构造函数
	virtual ~CTextViewDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_TEXT_VIEW_DIALOG };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()

public:
	virtual BOOL OnInitDialog();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy); 

private:
	CString m_title;
	CString m_edit_text;
	CFont m_font;

};

```

`hwBreakpointProcModule/testHwBpClient/framework.h`:

```h
#pragma once

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的

// 关闭 MFC 的一些常见且经常可放心忽略的隐藏警告消息
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC 核心组件和标准组件
#include <afxext.h>         // MFC 扩展


#include <afxdisp.h>        // MFC 自动化类



#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC 对 Internet Explorer 4 公共控件的支持
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC 对 Windows 公共控件的支持
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // MFC 支持功能区和控制条


#include <afxsock.h>            // MFC 套接字扩展







#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`hwBreakpointProcModule/testHwBpClient/pch.cpp`:

```cpp
// pch.cpp: 与预编译标头对应的源文件

#include "pch.h"

// 当使用预编译的头时，需要使用此源文件，编译才能成功。

```

`hwBreakpointProcModule/testHwBpClient/pch.h`:

```h
// pch.h: 这是预编译标头文件。
// 下方列出的文件仅编译一次，提高了将来生成的生成性能。
// 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。
// 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。
// 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。

#ifndef PCH_H
#define PCH_H

// 添加要在此处预编译的标头
#include "framework.h"
#include <afxcontrolbars.h>
#include <afxcontrolbars.h>

#endif //PCH_H

```

`hwBreakpointProcModule/testHwBpClient/res/testHwBpClient.rc2`:

```rc2
//
// testHwBpClient.rc2 - Microsoft Visual C++ 不会直接编辑的资源
//

#ifdef APSTUDIO_INVOKED
#error 此文件不能用 Microsoft Visual C++ 编辑
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// 在此处添加手动编辑的资源...

/////////////////////////////////////////////////////////////////////////////

```

`hwBreakpointProcModule/testHwBpClient/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 testHwBpClient.rc 使用
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_TESTHWBPCLIENT_DIALOG       102
#define IDP_SOCKETS_INIT_FAILED         103
#define IDR_MAINFRAME                   128
#define IDD_NETWORK_DIALOG              129
#define IDD_TEXT_VIEW_DIALOG            132
#define IDR_MENU_LIST                   134
#define IDC_EDIT_PID                    1000
#define IDC_LIST_FIND_SERVER            1001
#define IDC_RADIO_TYPE_R                1001
#define IDC_RADIO_TYPE_W                1002
#define IDC_EDIT_TEXT                   1002
#define IDC_RADIO_TYPE_RW               1003
#define IDC_LIST_RESULT                 1004
#define IDC_RADIO_TYPE_X                1005
#define IDC_BUTTON_ADD_HWBP             1006
#define IDC_EDIT_ADDR                   1007
#define IDC_CANCEL                      1008
#define IDC_RADIO_LEN_4                 1008
#define IDC_RADIO_LEN_8                 1009
#define IDC_RADIO_REGION_ALL_THREAD     1011
#define IDC_RADIO_REGION_MAIN_OTHER_THREAD 1012
#define IDC_RADIO_REGION_MAIN_THREAD    1013
#define IDC_CHECK_PID_HEX               1014
#define IDC_CHECK_ADDR_HEX              1015
#define IDC_EDIT_KEEP_TIME              1016
#define IDC_CONNECT                     1018
#define IDC_EDIT_IP                     1019
#define IDC_EDIT_PORT                   1020
#define ID_MENUITEM_CLEAN_LIST          32773
#define ID_MENUITEM_DELETE_OTHER_COUNT  32779
#define ID_MENUITEM_DELETE_UP_COUNT     32780
#define ID_MENUITEM_DELETE_DOWN_COUNT   32781
#define ID_MENUITEM_DELETE_SELECTED_COUNT 32782
#define ID_32783                        32783
#define ID_32784                        32784
#define ID_32785                        32785
#define ID_32786                        32786
#define ID_32787                        32787
#define ID_MENUITEM_copy                32788
#define ID_MENUITEM_COPY_SELECTED       32789
#define ID_MENUITEM_COPY_OTHER_COUNT    32790
#define ID_MENUITEM_COPY_LIST           32791

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32792
#define _APS_NEXT_CONTROL_VALUE         1033
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`hwBreakpointProcModule/testHwBpClient/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`hwBreakpointProcModule/testHwBpClient/testHwBpClient.cpp`:

```cpp

// testHwBpClient.cpp: 定义应用程序的类行为。
//

#include "pch.h"
#include "framework.h"
#include "testHwBpClient.h"
#include "testHwBpClientDlg.h"
#include "NetworkDlg.h"
#include "Global.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CtestHwBpClientApp

BEGIN_MESSAGE_MAP(CtestHwBpClientApp, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CtestHwBpClientApp 构造

CtestHwBpClientApp::CtestHwBpClientApp() {
	// 支持重新启动管理器
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

	// TODO: 在此处添加构造代码，
	// 将所有重要的初始化放置在 InitInstance 中
}


// 唯一的 CtestHwBpClientApp 对象

CtestHwBpClientApp theApp;


// CtestHwBpClientApp 初始化

BOOL CtestHwBpClientApp::InitInstance() {
	// 如果一个运行在 Windows XP 上的应用程序清单指定要
	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
	//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// 将它设置为包括所有要在应用程序中使用的
	// 公共控件类。
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();

	if (!AfxSocketInit()) {
		AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
		return FALSE;
	}


	AfxEnableControlContainer();

	// 创建 shell 管理器，以防对话框包含
	// 任何 shell 树视图控件或 shell 列表视图控件。
	CShellManager *pShellManager = new CShellManager;

	// 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题
	CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

	// 标准初始化
	// 如果未使用这些功能并希望减小
	// 最终可执行文件的大小，则应移除下列
	// 不需要的特定初始化例程
	// 更改用于存储设置的注册表项
	// TODO: 应适当修改该字符串，
	// 例如修改为公司或组织名
	SetRegistryKey(_T("应用程序向导生成的本地应用程序"));

	CNetworkDlg networkDlg;
	networkDlg.DoModal();

	INT_PTR nResponse = 0;
	if (g_NetworkMgr.IsConnected()) {
		//网络连接成功，载入主窗口
		g_NetworkMgr.Disconnect();

		CtestHwBpClientDlg dlg;
		m_pMainWnd = &dlg;
		nResponse = dlg.DoModal();
	}
	if (nResponse == IDOK) {
		// TODO: 在此放置处理何时用
		//  “确定”来关闭对话框的代码
	} else if (nResponse == IDCANCEL) {
		// TODO: 在此放置处理何时用
		//  “取消”来关闭对话框的代码
	} else if (nResponse == -1) {
		TRACE(traceAppMsg, 0, "警告: 对话框创建失败，应用程序将意外终止。\n");
		TRACE(traceAppMsg, 0, "警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n");
	}

	// 删除上面创建的 shell 管理器。
	if (pShellManager != nullptr) {
		delete pShellManager;
	}

#if !defined(_AFXDLL) && !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)
	ControlBarCleanUp();
#endif

	// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，
	//  而不是启动应用程序的消息泵。
	return FALSE;
}


```

`hwBreakpointProcModule/testHwBpClient/testHwBpClient.h`:

```h

// testHwBpClient.h: PROJECT_NAME 应用程序的主头文件
//

#pragma once

#ifndef __AFXWIN_H__
	#error "include 'pch.h' before including this file for PCH"
#endif

#include "resource.h"		// 主符号


// CtestHwBpClientApp:
// 有关此类的实现，请参阅 testHwBpClient.cpp
//

class CtestHwBpClientApp : public CWinApp
{
public:
	CtestHwBpClientApp();

// 重写
public:
	virtual BOOL InitInstance();

// 实现

	DECLARE_MESSAGE_MAP()
};

extern CtestHwBpClientApp theApp;

```

`hwBreakpointProcModule/testHwBpClient/testHwBpClient.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\n"
    "LANGUAGE 4, 2\r\n"
    "#include ""res\\testHwBpClient.rc2""  // 非 Microsoft Visual C++ 编辑的资源\r\n"
    "#include ""l.CHS\\afxres.rc""      // 标准组件\r\n"
    "#if !defined(_AFXDLL)\r\n"
    "#include ""l.CHS\\afxribbon.rc""   // MFC 功能区和控制条资源\r\n"
    "#endif\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\testHwBpClient.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 testHwBpClient"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "testHwBpClient，版本 1.0",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "版权所有 (C) 2020",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

IDD_TESTHWBPCLIENT_DIALOG DIALOGEX 0, 0, 682, 369
STYLE DS_SETFONT | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
EXSTYLE WS_EX_APPWINDOW
CAPTION "Linux ARM64 硬件断点进程调试器GUI 2.0"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "全部线程",IDC_RADIO_REGION_ALL_THREAD,"Button",BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,232,15,43,10
    CONTROL         "主线程",IDC_RADIO_REGION_MAIN_THREAD,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,232,29,37,10
    CONTROL         "除主线程之外的其他线程",IDC_RADIO_REGION_MAIN_OTHER_THREAD,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,232,43,91,10
    LTEXT           "进程PID：",IDC_STATIC,26,16,37,8
    EDITTEXT        IDC_EDIT_PID,66,14,70,14,ES_AUTOHSCROLL
    CONTROL         "",IDC_LIST_RESULT,"SysListView32",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,0,102,682,267
    GROUPBOX        "设置硬件断点类型",IDC_STATIC,2,63,120,32
    CONTROL         "读",IDC_RADIO_TYPE_R,"Button",BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,7,78,23,10
    CONTROL         "写",IDC_RADIO_TYPE_W,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,31,78,23,10
    CONTROL         "读写",IDC_RADIO_TYPE_RW,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,55,78,30,10
    CONTROL         "执行",IDC_RADIO_TYPE_X,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,86,78,30,10
    PUSHBUTTON      "安装硬件断点",IDC_BUTTON_ADD_HWBP,394,5,282,92
    EDITTEXT        IDC_EDIT_ADDR,66,37,70,14,ES_AUTOHSCROLL
    LTEXT           "进程内存地址：",IDC_STATIC,8,39,55,8
    GROUPBOX        "设置硬件断点长度",IDC_STATIC,125,64,93,31
    CONTROL         "4 字节",IDC_RADIO_LEN_4,"Button",BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,135,78,36,10
    CONTROL         "8 字节",IDC_RADIO_LEN_8,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,177,78,36,10
    GROUPBOX        "设置硬件断点范围",IDC_STATIC,224,1,166,60
    CONTROL         "十六进制",IDC_CHECK_PID_HEX,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,144,16,43,10
    CONTROL         "十六进制",IDC_CHECK_ADDR_HEX,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,144,39,43,10
    GROUPBOX        "设置硬件断点时间",IDC_STATIC,223,64,166,31
    EDITTEXT        IDC_EDIT_KEEP_TIME,251,75,45,14,ES_AUTOHSCROLL
    LTEXT           "毫秒后自动取消硬件断点",IDC_STATIC,300,78,76,8
    LTEXT           "经过",IDC_STATIC,231,78,15,8
    GROUPBOX        "设置硬件断点目标",IDC_STATIC,2,1,218,60
END

IDD_NETWORK_DIALOG DIALOGEX 0, 0, 289, 246
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "连接到服务器"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "已发现的服务器",IDC_STATIC,7,7,275,179
    CONTROL         "",IDC_LIST_FIND_SERVER,"SysListView32",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,18,275,165
    LTEXT           "主机",IDC_STATIC,7,186,17,8
    EDITTEXT        IDC_EDIT_IP,7,197,120,14,ES_AUTOHSCROLL
    LTEXT           "端口",IDC_STATIC,133,186,17,8
    EDITTEXT        IDC_EDIT_PORT,131,197,40,14,ES_AUTOHSCROLL
    PUSHBUTTON      "连接",IDC_CONNECT,75,218,63,21
    PUSHBUTTON      "取消",IDC_CANCEL,143,218,63,21
END

IDD_TEXT_VIEW_DIALOG DIALOGEX 0, 0, 719, 315
STYLE DS_SETFONT | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
CAPTION "文本浏览"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    EDITTEXT        IDC_EDIT_TEXT,0,0,719,315,ES_MULTILINE | ES_AUTOHSCROLL | ES_READONLY
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404b0"
        BEGIN
            VALUE "CompanyName", "TODO: <公司名>"
            VALUE "FileDescription", "testHwBpClient"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "testHwBpClient.exe"
            VALUE "LegalCopyright", "TODO:  (C) <公司名>。  保留所有权利。"
            VALUE "OriginalFilename", "testHwBpClient.exe"
            VALUE "ProductName", "TODO: <产品名>"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_TESTHWBPCLIENT_DIALOG, DIALOG
    BEGIN
    END

    IDD_NETWORK_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 282
        TOPMARGIN, 7
        BOTTOMMARGIN, 239
    END

    IDD_TEXT_VIEW_DIALOG, DIALOG
    BEGIN
        RIGHTMARGIN, 710
        BOTTOMMARGIN, 278
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_NETWORK_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_TESTHWBPCLIENT_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_TEXT_VIEW_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MENU_LIST MENU
BEGIN
    POPUP "菜单"
    BEGIN
        MENUITEM "复制选中行",                       ID_MENUITEM_COPY_SELECTED
        MENUITEM "复制所有行",                       ID_MENUITEM_COPY_LIST
        MENUITEM SEPARATOR
        MENUITEM "删除选中行",                       ID_MENUITEM_DELETE_SELECTED_COUNT
        MENUITEM "删除非选中行",                      ID_MENUITEM_DELETE_OTHER_COUNT
        MENUITEM "删除上边所有",                      ID_MENUITEM_DELETE_UP_COUNT
        MENUITEM "删除下边所有",                      ID_MENUITEM_DELETE_DOWN_COUNT
        MENUITEM "删除所有行",                       ID_MENUITEM_CLEAN_LIST
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "关于 testHwBpClient(&A)..."
    IDP_SOCKETS_INIT_FAILED "Windows 套接字初始化失败。"
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2
#include "res\testHwBpClient.rc2"  // 非 Microsoft Visual C++ 编辑的资源
#include "l.CHS\afxres.rc"      // 标准组件
#if !defined(_AFXDLL)
#include "l.CHS\afxribbon.rc"   // MFC 功能区和控制条资源
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`hwBreakpointProcModule/testHwBpClient/testHwBpClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{6439C510-058C-47A7-BF11-1890BFD3A470}</ProjectGuid>
    <Keyword>MFCProj</Keyword>
    <RootNamespace>testHwBpClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="framework.h" />
    <ClInclude Include="Global.h" />
    <ClInclude Include="NetworkDlg.h" />
    <ClInclude Include="NetworkMgr.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="testHwBpClient.h" />
    <ClInclude Include="testHwBpClientDlg.h" />
    <ClInclude Include="TextViewDlg.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Global.cpp" />
    <ClCompile Include="NetworkDlg.cpp" />
    <ClCompile Include="NetworkMgr.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="testHwBpClient.cpp" />
    <ClCompile Include="testHwBpClientDlg.cpp" />
    <ClCompile Include="TextViewDlg.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="testHwBpClient.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\testHwBpClient.rc2" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\testHwBpClient.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`hwBreakpointProcModule/testHwBpClient/testHwBpClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="testHwBpClient.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="testHwBpClientDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="framework.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Global.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="NetworkMgr.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="NetworkDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="TextViewDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="testHwBpClient.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="testHwBpClientDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Global.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="NetworkMgr.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="NetworkDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="TextViewDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="testHwBpClient.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\testHwBpClient.rc2">
      <Filter>资源文件</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\testHwBpClient.ico">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`hwBreakpointProcModule/testHwBpClient/testHwBpClient.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <RESOURCE_FILE>testHwBpClient.rc</RESOURCE_FILE>
  </PropertyGroup>
</Project>
```

`hwBreakpointProcModule/testHwBpClient/testHwBpClientDlg.cpp`:

```cpp

// testHwBpClientDlg.cpp: 实现文件
//

#include "pch.h"
#include "framework.h"
#include "testHwBpClient.h"
#include "testHwBpClientDlg.h"
#include "afxdialogex.h"
#include "TextViewDlg.h"
#include <sstream>
#include <algorithm>
#include <thread>
#include "../testHwBp/jni/HwBreakpointMgr4.h"
#include "../testHwBpServer/jni/hwbpserver.h"
#include "ScaleHelper.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// 用于应用程序“关于”菜单项的 CAboutDlg 对话框

class CAboutDlg : public CDialogEx {
public:
	CAboutDlg();

	// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX) {
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX) {
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CtestHwBpClientDlg 对话框



CtestHwBpClientDlg::CtestHwBpClientDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_TESTHWBPCLIENT_DIALOG, pParent)
	, m_edit_pid(_T(""))
	, m_edit_addr(_T(""))
	, m_edit_keep_time(_T(""))
	, m_checkbox_pid_hex(FALSE)
	, m_checkbox_addr_hex(FALSE)
	, m_radio_type_r(FALSE)
	, m_radio_len_4(FALSE)
	, m_radio_region_all_thread(FALSE) {
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CtestHwBpClientDlg::DoDataExchange(CDataExchange* pDX) {
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_RESULT, m_list_result);
	DDX_Text(pDX, IDC_EDIT_PID, m_edit_pid);
	DDX_Text(pDX, IDC_EDIT_ADDR, m_edit_addr);
	DDX_Text(pDX, IDC_EDIT_KEEP_TIME, m_edit_keep_time);
	DDX_Check(pDX, IDC_CHECK_PID_HEX, m_checkbox_pid_hex);
	DDX_Check(pDX, IDC_CHECK_ADDR_HEX, m_checkbox_addr_hex);
	DDX_Radio(pDX, IDC_RADIO_TYPE_R, m_radio_type_r);
	DDX_Radio(pDX, IDC_RADIO_LEN_4, m_radio_len_4);
	DDX_Radio(pDX, IDC_RADIO_REGION_ALL_THREAD, m_radio_region_all_thread);
}

BEGIN_MESSAGE_MAP(CtestHwBpClientDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON_ADD_HWBP, &CtestHwBpClientDlg::OnBnClickedButtonAddHwbp)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_RESULT, &CtestHwBpClientDlg::OnDblclkListResult)
	ON_NOTIFY(NM_RCLICK, IDC_LIST_RESULT, &CtestHwBpClientDlg::OnRclickListResult)
	ON_COMMAND(ID_MENUITEM_CLEAN_LIST, &CtestHwBpClientDlg::OnMenuitemCleanList)
	ON_COMMAND(ID_MENUITEM_DELETE_SELECTED_COUNT, &CtestHwBpClientDlg::OnMenuitemDeleteSelectedCount)
	ON_COMMAND(ID_MENUITEM_DELETE_OTHER_COUNT, &CtestHwBpClientDlg::OnMenuitemDeleteOtherCount)
	ON_COMMAND(ID_MENUITEM_DELETE_UP_COUNT, &CtestHwBpClientDlg::OnMenuitemDeleteUpCount)
	ON_COMMAND(ID_MENUITEM_DELETE_DOWN_COUNT, &CtestHwBpClientDlg::OnMenuitemDeleteDownCount)
	ON_WM_SIZE()
	ON_COMMAND(ID_MENUITEM_COPY_SELECTED, &CtestHwBpClientDlg::OnMenuitemCopySelected)
	ON_COMMAND(ID_MENUITEM_COPY_LIST, &CtestHwBpClientDlg::OnMenuitemCopyList)
END_MESSAGE_MAP()


// CtestHwBpClientDlg 消息处理程序

BOOL CtestHwBpClientDlg::OnInitDialog() {
	CDialogEx::OnInitDialog();

	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != nullptr) {
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty()) {
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO: 在此添加额外的初始化代码

	//初始化列表框
	LONG lStyle;
	lStyle = GetWindowLong(m_list_result.m_hWnd, GWL_STYLE);
	lStyle &= ~LVS_TYPEMASK; //清除显示方式位
	lStyle |= LVS_REPORT;
	SetWindowLong(m_list_result.m_hWnd, GWL_STYLE, lStyle);
	DWORD dwStyle = m_list_result.GetExtendedStyle();
	dwStyle |= LVS_EX_FULLROWSELECT;//选中某行使整行高亮（只适用与report风格的listctrl）
	dwStyle |= LVS_EX_GRIDLINES;//网格线（只适用与report风格的listctrl）
	//dwStyle |= LVS_EX_CHECKBOXES;//item前生成checkbox控件
	m_list_result.SetExtendedStyle(dwStyle);

	m_list_result.InsertColumn(HIT_RESULT_COL_ID, L"ID", LVCFMT_LEFT, GetScaleWidth(35));
	m_list_result.InsertColumn(HIT_RESULT_COL_TIME, L"时间", LVCFMT_LEFT, GetScaleWidth(135));
	m_list_result.InsertColumn(HIT_RESULT_COL_PID, L"PID", LVCFMT_LEFT, GetScaleWidth(50));
	m_list_result.InsertColumn(HIT_RESULT_COL_TID, L"线程ID", LVCFMT_LEFT, GetScaleWidth(50));
	m_list_result.InsertColumn(HIT_RESULT_COL_THREAD_RANGE, L"范围", LVCFMT_LEFT, GetScaleWidth(40));
	m_list_result.InsertColumn(HIT_RESULT_COL_BP_ADDR, L"进程地址", LVCFMT_LEFT, GetScaleWidth(130));
	m_list_result.InsertColumn(HIT_RESULT_COL_BP_TYPE, L"类型", LVCFMT_LEFT, GetScaleWidth(35));
	m_list_result.InsertColumn(HIT_RESULT_COL_BP_LEN, L"长度", LVCFMT_LEFT, GetScaleWidth(35));
	m_list_result.InsertColumn(HIT_RESULT_COL_HIT_ADDR, L"硬断命中地址", LVCFMT_LEFT, GetScaleWidth(130));
	m_list_result.InsertColumn(HIT_RESULT_COL_HIT_TOTAL_COUNT, L"总命中次数", LVCFMT_LEFT, GetScaleWidth(75));
	m_list_result.InsertColumn(HIT_RESULT_COL_HIT_INFO, L"命中信息", LVCFMT_LEFT, GetScaleWidth(1500));

	m_edit_pid = L"0";
	m_edit_addr = L"0";
	m_checkbox_addr_hex = TRUE;
	m_edit_keep_time = L"1000";
	m_radio_type_r = 0;
	m_radio_len_4 = 0;
	m_radio_region_all_thread = 0;
	UpdateData(FALSE);
	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CtestHwBpClientDlg::OnSysCommand(UINT nID, LPARAM lParam) {
	if ((nID & 0xFFF0) == IDM_ABOUTBOX) {
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	} else {
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CtestHwBpClientDlg::OnPaint() {
	if (IsIconic()) {
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	} else {
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CtestHwBpClientDlg::OnQueryDragIcon() {
	return static_cast<HCURSOR>(m_hIcon);
}

int CtestHwBpClientDlg::GetInputPid() {
	UpdateData(TRUE);
	std::wstringstream ssConvert;
	ssConvert << m_edit_pid.GetString();
	int pid = 0;
	if (m_checkbox_pid_hex) {
		ssConvert >> std::hex >> pid;
	} else {
		ssConvert >> pid;
	}
	return pid;
}
UINT64 CtestHwBpClientDlg::GetInputAddress() {
	UpdateData(TRUE);
	std::wstringstream ssConvert;
	ssConvert << m_edit_addr.GetString();
	UINT64 address = 0;
	if (m_checkbox_addr_hex) {
		ssConvert >> std::hex >> address;
	} else {
		ssConvert >> address;
	}
	return address;
}
std::wstring CtestHwBpClientDlg::GetInputAddressString() {
	UpdateData(TRUE);
	std::wstringstream wssConvert;
	if (m_checkbox_addr_hex) {
		wssConvert << std::hex << m_edit_addr.GetString();
	} else {
		wssConvert << m_edit_addr.GetString();
	}
	std::wstring showAddr = m_edit_addr.GetString();
	return showAddr;
}
uint32_t CtestHwBpClientDlg::GetInputHwBpAddrLen() {
	UpdateData(TRUE);
	return m_radio_len_4 == 0 ? HW_BREAKPOINT_LEN_4 : HW_BREAKPOINT_LEN_8;
}
uint32_t CtestHwBpClientDlg::GetInputHwBpAddrType() {
	UpdateData(TRUE);
	return m_radio_type_r == 0 ? HW_BREAKPOINT_R : m_radio_type_r == 1 ? HW_BREAKPOINT_W : m_radio_type_r == 2 ? HW_BREAKPOINT_RW : HW_BREAKPOINT_X;
}
uint32_t CtestHwBpClientDlg::GetInputHwBpKeepTimeMs() {
	UpdateData(TRUE);

	std::wstringstream ssConvert;
	uint32_t hwBpKeepTimeMs = 0;
	ssConvert << m_edit_keep_time.GetString();
	ssConvert >> hwBpKeepTimeMs;
	return hwBpKeepTimeMs;
}
void CtestHwBpClientDlg::OnBnClickedButtonAddHwbp() {
	UpdateData(TRUE);
	if (m_edit_pid.IsEmpty() || m_edit_addr.IsEmpty() || m_edit_keep_time.IsEmpty()) {
		MessageBox(L"所填参数不能为空");
		return;
	}

	int pid = GetInputPid();
	UINT64 address = GetInputAddress();
	if (pid == 0 || address == 0) {
		MessageBox(L"所填参数有错误");
		return;
	}
	if (!g_NetworkMgr.Reconnect()) {
		MessageBox(L"与服务器已失去连接");
		return;
	}

	//硬件断点类型
	InstProcessHwBpInfo input;
	InstProcessHwBpResult output;

	input.pid = GetInputPid();
	input.address = GetInputAddress();
	input.hwBpAddrLen = GetInputHwBpAddrLen();
	input.hwBpAddrType = GetInputHwBpAddrType();
	input.hwBpThreadType = m_radio_region_all_thread;
	input.hwBpKeepTimeMs = GetInputHwBpKeepTimeMs();

	//开始安装硬件断点
	g_NetworkMgr.InstProcessHwBp(input, output);

	//将命中结果显示到列表框
	int nIndex = m_list_result.GetItemCount();
	for (const InstProcessHwBpResultChild & threadInfo : output.vThreadHit) {
		for (const HW_HIT_ITEM& hitItem : threadInfo.vHitItem) {
			m_list_result.InsertItem(nIndex, m_edit_pid);

			std::wstring showAddr = GetInputAddressString();
			transform(showAddr.begin(), showAddr.end(), showAddr.begin(), ::toupper);

			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_ID, std::to_wstring(nIndex).c_str());
			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_TIME, TimestampToDatetime(hitItem.hit_time).c_str());
			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_PID, std::to_wstring(input.pid).c_str());
			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_TID, std::to_wstring(hitItem.task_id).c_str());
			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_BP_ADDR, std::wstring(L"0x" + showAddr).c_str());
			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_BP_TYPE, m_radio_type_r == 0 ? L"读" : m_radio_type_r == 1 ? L"写" : m_radio_type_r == 2 ? L"读写" : L"执行");
			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_BP_LEN, m_radio_len_4 == 0 ? L"4" : L"8");
			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_THREAD_RANGE, m_radio_region_all_thread == 0 ? L"全部" : m_radio_region_all_thread == 1 ? L"主线程" : L"其他线程");

			std::wstringstream wssConvert;
			wssConvert << std::hex << hitItem.hit_addr;
			showAddr = wssConvert.str();
			transform(showAddr.begin(), showAddr.end(), showAddr.begin(), ::toupper);

			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_HIT_ADDR, std::wstring(L"0x" + showAddr).c_str());

			std::wstring strHitTotalCount = std::to_wstring(threadInfo.hitTotalCount);
			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_HIT_TOTAL_COUNT, strHitTotalCount.c_str());

			std::wstringstream ssInfoText;
			wchar_t info[4096] = { 0 };
			for (int r = 0; r < 30; r += 5) {
				memset(info, 0, sizeof(info));
				wsprintf(info, L"X%-2d=%-20p X%-2d=%-20p X%-2d=%-20p X%-2d=%-20p X%-2d=%-20p\r\n",
					r, hitItem.regs_info.regs[r],
					r + 1, hitItem.regs_info.regs[r + 1],
					r + 2, hitItem.regs_info.regs[r + 2],
					r + 3, hitItem.regs_info.regs[r + 3],
					r + 4, hitItem.regs_info.regs[r + 4]);
				ssInfoText << info;
			}
			memset(info, 0, sizeof(info));
			wsprintf(info, L"\r\nLR= %-20p SP= %-20p PC= %-20p\r\n\r\n",
				hitItem.regs_info.regs[30],
				hitItem.regs_info.sp,
				hitItem.regs_info.pc);
			ssInfoText << info;

			memset(info, 0, sizeof(info));
			wsprintf(info, L"process status: %-20p orig_x0: %-20p\r\nsyscallno: %-20p\r\n",
				hitItem.regs_info.pstate,
				hitItem.regs_info.orig_x0,
				hitItem.regs_info.syscallno);

			ssInfoText << info;

			m_list_result.SetItemText(nIndex, HIT_RESULT_COL_HIT_INFO, ssInfoText.str().c_str());

			//使刚刚插入的新项可见
			m_list_result.EnsureVisible(nIndex, FALSE);
			nIndex++;
		}
	}
	g_NetworkMgr.Disconnect();

	if (output.allTaskCount == 0) {
		MessageBox(L"目标进程的线程数为0");
	} else if (output.allTaskCount != output.hwbpInstalledCount) {
		std::wstringstream wssBuf;
		wssBuf << L"发现有硬件断点安装失败的线程！目标进程的线程总数:" << output.allTaskCount << L", 硬件断点安装成功线程数:" << output.hwbpInstalledCount;
		MessageBox(wssBuf.str().c_str());
	}
}


void CtestHwBpClientDlg::OnDblclkListResult(NMHDR *pNMHDR, LRESULT *pResult) {
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	if (pNMItemActivate->iItem != -1) {
		//按下了列表
		CString strHitAddr = m_list_result.GetItemText(pNMItemActivate->iItem, HIT_RESULT_COL_HIT_ADDR);
		CString strHitTotalCount = m_list_result.GetItemText(pNMItemActivate->iItem, HIT_RESULT_COL_HIT_TOTAL_COUNT);
		CString title;
		title.Format(L"命中地址:%s，总命中次数:%s", strHitAddr, strHitTotalCount);
		
		CString text = title;
		text += "\r\n";
		text += m_list_result.GetItemText(pNMItemActivate->iItem, HIT_RESULT_COL_HIT_INFO);
		text += "\r\n\r\n提示：\r\nR13（SP）：堆栈指针寄存器\r\nR14（LR）：子程序的返回地址";

		//显示窗口
		std::thread td([](std::shared_ptr<std::wstring>title, std::shared_ptr<std::wstring>text)->void {
			CTextViewDlg dlg(title->c_str(), text->c_str());
			dlg.DoModal();
		}, std::make_shared<std::wstring>(title.GetString()), std::make_shared<std::wstring>(text.GetString()));
		td.detach();
	}
	*pResult = 0;
}

std::wstring CtestHwBpClientDlg::TimestampToDatetime(uint64_t timestamp) {
	time_t t = (time_t)timestamp;
	struct tm* tm_info = localtime(&t);
	wchar_t buffer[256] = { 0 };
	wcsftime(buffer, 26, L"%Y-%m-%d %H:%M:%S", tm_info);
	return buffer;
}

void CtestHwBpClientDlg::OnRclickListResult(NMHDR *pNMHDR, LRESULT *pResult) {
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);

	//加载菜单
	CMenu m_Menu;
	m_Menu.LoadMenu(IDR_MENU_LIST);
	//获取鼠标位置
	CPoint ptMouse;
	GetCursorPos(&ptMouse);

	if (pNMItemActivate->iItem == -1) {
		m_Menu.GetSubMenu(0)->RemoveMenu(ID_MENUITEM_DELETE_SELECTED_COUNT, MF_BYCOMMAND);
		m_Menu.GetSubMenu(0)->RemoveMenu(ID_MENUITEM_DELETE_OTHER_COUNT, MF_BYCOMMAND);
		m_Menu.GetSubMenu(0)->RemoveMenu(ID_MENUITEM_DELETE_UP_COUNT, MF_BYCOMMAND);
		m_Menu.GetSubMenu(0)->RemoveMenu(ID_MENUITEM_DELETE_DOWN_COUNT, MF_BYCOMMAND);
	}

	//显示菜单
	m_Menu.GetSubMenu(0)->TrackPopupMenu(
		TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON,
		ptMouse.x,
		ptMouse.y,
		this);
	*pResult = 0;

}


void CtestHwBpClientDlg::OnMenuitemCleanList() {
	m_list_result.DeleteAllItems();
}


void CtestHwBpClientDlg::OnMenuitemDeleteSelectedCount() {
	std::vector<int> vDeleteIndex;
	POSITION pos = m_list_result.GetFirstSelectedItemPosition(); //返回第一个选中的行位置
	if (pos != NULL) {
		while (pos) {
			int n = m_list_result.GetNextSelectedItem(pos);  //返回下一个选中的行数(返回值从0开始)
			//做相应操作
			vDeleteIndex.push_back(n);
		}
	}
	int deleted = 0;
	for (int n : vDeleteIndex) {
		n -= deleted;
		m_list_result.DeleteItem(n);
		deleted++;
	}

}


void CtestHwBpClientDlg::OnMenuitemDeleteOtherCount() {
	std::vector<int> vSaveIndex;
	POSITION pos = m_list_result.GetFirstSelectedItemPosition(); //返回第一个选中的行位置
	if (pos != NULL) {
		while (pos) {
			int n = m_list_result.GetNextSelectedItem(pos);  //返回下一个选中的行数(返回值从0开始)
			//做相应操作
			vSaveIndex.push_back(n);
		}
	}

	std::vector<int> vDeleteIndex;
	for (int i = 0; i < m_list_result.GetItemCount(); i++) {
		bool bSave = false;
		for (int saveIndex : vSaveIndex) {
			if (saveIndex == i) {
				bSave = true;
				break;
			}
		}
		if (!bSave) {
			vDeleteIndex.push_back(i);
		}
	}
	int deleted = 0;
	for (int n : vDeleteIndex) {
		n -= deleted;
		m_list_result.DeleteItem(n);
		deleted++;
	}

}


void CtestHwBpClientDlg::OnMenuitemDeleteUpCount() {
	int nFirstIndex = -1;
	POSITION pos = m_list_result.GetFirstSelectedItemPosition(); //返回第一个选中的行位置
	if (pos != NULL) {
		while (pos) {
			nFirstIndex = m_list_result.GetNextSelectedItem(pos);  //返回下一个选中的行数(返回值从0开始)
			break;
		}
	}
	if (nFirstIndex == -1) {
		return;
	}
	for (int i = 0; i < nFirstIndex; i++) {
		m_list_result.DeleteItem(0);
	}
}


void CtestHwBpClientDlg::OnMenuitemDeleteDownCount() {
	int nFirstIndex = -1;
	POSITION pos = m_list_result.GetFirstSelectedItemPosition(); //返回第一个选中的行位置
	if (pos != NULL) {
		while (pos) {
			nFirstIndex = m_list_result.GetNextSelectedItem(pos);  //返回下一个选中的行数(返回值从0开始)
			break;
		}
	}
	if (nFirstIndex == -1) {
		return;
	}
	int deleteCount = m_list_result.GetItemCount() - 1 - nFirstIndex;
	for (int i = 0; i < deleteCount; i++) {
		m_list_result.DeleteItem(nFirstIndex + 1);
	}
}


void CtestHwBpClientDlg::OnSize(UINT nType, int cx, int cy)
{
	CDialogEx::OnSize(nType, cx, cy);

	// TODO: 在此处添加消息处理程序代码
}


void CtestHwBpClientDlg::OnMenuitemCopySelected()
{
	std::vector<int> vCopyIndex;
	POSITION pos = m_list_result.GetFirstSelectedItemPosition(); //返回第一个选中的行位置
	if (pos != NULL) {
		while (pos) {
			int n = m_list_result.GetNextSelectedItem(pos);  //返回下一个选中的行数(返回值从0开始)
			//做相应操作
			vCopyIndex.push_back(n);
		}
	}

	CString result;
	CString itemText;

	for (int row : vCopyIndex) {
		int columnCount = m_list_result.GetHeaderCtrl()->GetItemCount();
		for (int col = 0; col < columnCount; ++col) {
			itemText = m_list_result.GetItemText(row, col);
			// 添加到结果字符串，每个单元格的文本后面加一个空格作为分隔
			result += itemText;
			if (col < columnCount - 1)  // 最后一列后不加空格
				result += _T(" ");
		}
		result += _T("\n");
	}
	PutTextToClipboard(result.GetString());
}


void CtestHwBpClientDlg::OnMenuitemCopyList()
{
	CString result;
	CString itemText;

	// 获取列表控件的行数和列数
	int rowCount = m_list_result.GetItemCount();
	int columnCount = m_list_result.GetHeaderCtrl()->GetItemCount();

	// 遍历所有行和列
	for (int row = 0; row < rowCount; ++row) {
		for (int col = 0; col < columnCount; ++col) {
			itemText = m_list_result.GetItemText(row, col);
			// 添加到结果字符串，每个单元格的文本后面加一个空格作为分隔
			result += itemText;
			if (col < columnCount - 1)  // 最后一列后不加空格
				result += _T(" ");
		}
		result += _T("\n");
	}
	PutTextToClipboard(result.GetString());
}

BOOL CtestHwBpClientDlg::PutTextToClipboard(LPCTSTR pTxtData) {
	BOOL bRet = FALSE;
	if (OpenClipboard()) {
		EmptyClipboard();
		HGLOBAL hData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
			(lstrlen(pTxtData) + 1) * sizeof(TCHAR));
		if (hData != NULL) {
			LPTSTR pszData = (LPTSTR)::GlobalLock(hData);
			lstrcpy(pszData, pTxtData);
			GlobalUnlock(hData);
#ifdef _UNICODE
			bRet = (SetClipboardData(CF_UNICODETEXT, hData) != NULL);
#else
			bRet = (SetClipboardData(CF_TEXT, hData) != NULL);
#endif // _UNICODE
		}
		CloseClipboard();
	}
	return bRet;
}
```

`hwBreakpointProcModule/testHwBpClient/testHwBpClientDlg.h`:

```h

// testHwBpClientDlg.h: 头文件
//

#pragma once
#include "Global.h"

enum {
	HIT_RESULT_COL_ID = 0,
	HIT_RESULT_COL_TIME,
	HIT_RESULT_COL_PID,
	HIT_RESULT_COL_TID,
	HIT_RESULT_COL_THREAD_RANGE,
	HIT_RESULT_COL_BP_ADDR,
	HIT_RESULT_COL_BP_TYPE,
	HIT_RESULT_COL_BP_LEN,
	HIT_RESULT_COL_HIT_ADDR,
	HIT_RESULT_COL_HIT_TOTAL_COUNT,
	HIT_RESULT_COL_HIT_INFO,
};

// CtestHwBpClientDlg 对话框
class CtestHwBpClientDlg : public CDialogEx {
	// 构造
public:
	CtestHwBpClientDlg(CWnd* pParent = nullptr);	// 标准构造函数

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_TESTHWBPCLIENT_DIALOG };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持


// 实现
protected:
	HICON m_hIcon;

	// 生成的消息映射函数
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnBnClickedButtonAddHwbp();
	afx_msg void OnDblclkListResult(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnRclickListResult(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnMenuitemCleanList();
	afx_msg void OnMenuitemDeleteSelectedCount();
	afx_msg void OnMenuitemDeleteOtherCount();
	afx_msg void OnMenuitemDeleteUpCount();
	afx_msg void OnMenuitemDeleteDownCount();
	DECLARE_MESSAGE_MAP()
private:
	CListCtrl m_list_result;
	CString m_edit_pid;
	CString m_edit_addr;
	CString m_edit_keep_time;
	BOOL m_checkbox_pid_hex;
	BOOL m_checkbox_addr_hex;
	int m_radio_type_r;
	int m_radio_len_4;
	int m_radio_region_all_thread;
private:
	int GetInputPid();
	UINT64 GetInputAddress();
	std::wstring GetInputAddressString();
	uint32_t GetInputHwBpAddrLen();
	uint32_t GetInputHwBpAddrType();
	uint32_t GetInputHwBpKeepTimeMs();
	std::wstring TimestampToDatetime(uint64_t timestamp);
	BOOL PutTextToClipboard(LPCTSTR pTxtData);
public:
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMenuitemCopySelected();
	afx_msg void OnMenuitemCopyList();
};

```

`hwBreakpointProcModule/testHwBpServer/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_CPPFLAGS += -std=c++20
LOCAL_CFLAGS += -fPIE
LOCAL_CFLAGS += -fvisibility=hidden
LOCAL_LDFLAGS += -fPIE -pie
LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true
LOCAL_MODULE    := testHwBpServer
LOCAL_SRC_FILES :=  testHwBpServer.cpp api.cpp Global.cpp  porthelp.cpp
LOCAL_LDLIBS := -lz -llog
include $(BUILD_EXECUTABLE)

```

`hwBreakpointProcModule/testHwBpServer/jni/Application.mk`:

```mk
APP_ABI := arm64-v8a
APP_STL := c++_static
```

`hwBreakpointProcModule/testHwBpServer/jni/Global.cpp`:

```cpp
#include "Global.h"
CHwBreakpointMgr g_driver;

```

`hwBreakpointProcModule/testHwBpServer/jni/Global.h`:

```h
#pragma once
#include <map>
#include <vector>
#include <memory>
#include <atomic>
#include "api.h"
#include "../../testHwBp/jni/HwBreakpointMgr4.h"
extern CHwBreakpointMgr g_driver;


```

`hwBreakpointProcModule/testHwBpServer/jni/api.cpp`:

```cpp
#include "api.h"
#include <malloc.h>
#include <sstream>
#include <memory>
#include <random>
#include <dirent.h>
#include <unistd.h>
#include <fcntl.h>
#include <cinttypes>
#include "hwbpserver.h"

//获取当前进程所有的task
BOOL GetProcessTask(int pid, std::vector<int>& vOutput) {
	DIR* dir = NULL;
	struct dirent* ptr = NULL;
	char szTaskPath[256] = { 0 };
	sprintf(szTaskPath, "/proc/%d/task", pid);

	dir = opendir(szTaskPath);
	if (NULL != dir) {
		while ((ptr = readdir(dir)) != NULL)   // 循环读取路径下的每一个文件/文件夹
		{
			// 如果读取到的是"."或者".."则跳过，读取到的不是文件夹名字也跳过
			if ((strcmp(ptr->d_name, ".") == 0) || (strcmp(ptr->d_name, "..") == 0)) {
				continue;
			}
			else if (ptr->d_type != DT_DIR) {
				continue;
			}
			else if (strspn(ptr->d_name, "1234567890") != strlen(ptr->d_name)) {
				continue;
			}

			int task = atoi(ptr->d_name);
			vOutput.push_back(task);
		}
		closedir(dir);
		return TRUE;
	}
	return FALSE;
}


void ProcessInstProcessHwBp(const struct InstProcessHwBpInfo& input, struct InstProcessHwBpResult & output) {
	output.allTaskCount = 0;
	output.hwbpInstalledCount = 0;
	//储存需要下断的线程列表
	std::vector<int> vTask;
	if (input.hwBpThreadType == 0) { //硬件下断全部线程
		//获取当前进程所有的task
		GetProcessTask(input.pid, vTask);
	}
	else if (input.hwBpThreadType == 1) {//硬件下断主线程
		vTask.push_back(input.pid);
	}
	else if (input.hwBpThreadType == 2) { //硬件除主线程之外的其他线程
		//获取当前进程所有的task
		GetProcessTask(input.pid, vTask);

		//删除主线程
		for (auto iter = vTask.begin(); iter != vTask.end(); iter++) {
			if (*iter == input.pid) {
				vTask.erase(iter);
				break;
			}
		}
	}

	output.allTaskCount = vTask.size();

	//硬件断点句柄
	std::vector<uint64_t> vHwBpHandle;
	for (int taskId : vTask) {
		//打开task
		uint64_t hProcess = g_driver.OpenProcess(taskId);
		if (!hProcess) {
			continue;
		}
		//设置读写硬件断点
		uint64_t hwBpHandle = g_driver.InstProcessHwBp(hProcess, input.address, input.hwBpAddrLen, input.hwBpAddrType);
		printf("Call InstProcessHwBp(%d, %p) return:%p\n", taskId, (void*)input.address, (void*)hwBpHandle);
		if (hwBpHandle) {
			vHwBpHandle.push_back(hwBpHandle);
		}
		//关闭task
		g_driver.CloseHandle(hProcess);
		printf("Call CloseHandle:%p\n", (void*)hProcess);
	}
	output.hwbpInstalledCount = vHwBpHandle.size();
	if (output.hwbpInstalledCount) {
		//有成功的下断
		usleep(input.hwBpKeepTimeMs * 1000); //delay ms
		//暂停硬件断点
		for (uint64_t hwbpHandle : vHwBpHandle) {
			BOOL b = g_driver.SuspendProcessHwBp(hwbpHandle);
			printf("Call SuspendProcessHwBp(%p) return:%d\n", (void*)hwbpHandle, b);
		}
		//读取硬件断点命中信息
		for (uint64_t hwbpHandle : vHwBpHandle) {
			InstProcessHwBpResultChild threadHitInfo;
			BOOL b = g_driver.ReadHwBpInfo(hwbpHandle, threadHitInfo.hitTotalCount, threadHitInfo.vHitItem);
			printf("Call ReadProcessHwBp(%p) return:%d, hit_total_count:%lu, save_hit_item_count:%lu\n", (void*)hwbpHandle, b, threadHitInfo.hitTotalCount, threadHitInfo.vHitItem.size());
			if(!b || !threadHitInfo.vHitItem.size()) {
				continue;
			}
			threadHitInfo.taskId = threadHitInfo.vHitItem[0].task_id;
			threadHitInfo.address = input.address;
			output.vThreadHit.push_back(threadHitInfo);
		}

		//删除进程硬件断点
		for (uint64_t hwbpHandle : vHwBpHandle) {
			g_driver.UninstProcessHwBp(hwbpHandle);
			printf("Call UninstProcessHwBp(%p)\n", (void*)hwbpHandle);
		}
	}
}


```

`hwBreakpointProcModule/testHwBpServer/jni/api.h`:

```h
#ifndef API_H_
#define API_H_

#include <stdint.h>
#include <pthread.h>
#include <sys/queue.h>
#include "Global.h"

#include "porthelp.h"
#include "hwbpserver.h"
#ifdef __ANDROID__
#include<android/log.h>
#endif
/*

#if defined(__arm__) || defined(__ANDROID__)
#include <linux/user.h>
#else
#include <sys/user.h>
#endif
*/

#ifdef HAS_LINUX_USER_H
#include <linux/user.h>
#else
#include <sys/user.h>
#endif

#include <string>


BOOL GetProcessTask(int pid, std::vector<int> & vOutput);
void ProcessInstProcessHwBp(const struct InstProcessHwBpInfo& input, struct InstProcessHwBpResult & output);
#ifdef __ANDROID__
#define LOG_TAG "HWSERVER"
#define LOGD(fmt, args...) __android_log_vprint(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)
#endif

#endif /* API_H_ */

```

`hwBreakpointProcModule/testHwBpServer/jni/hwbpserver.h`:

```h
#ifndef HWBPSERVER_H_
#define HWBPSERVER_H_

#include <stdint.h>
#include <sys/types.h>
#include <vector>

#ifdef _linux_
#include "porthelp.h"
#include "Global.h"
#endif

#define CMD_GETVERSION 0
#define CMD_CLOSECONNECTION 1
#define CMD_TERMINATESERVER 2
#define CMD_ADDPROCESSHWBP 3

//extern char *versionstring;
#pragma pack(1)
struct HwBpVersion {
	int version = 0;
	unsigned char stringsize = 0;
	//append the versionstring
};
struct InstProcessHwBpInfo {
	uint64_t pid = 0;
	uint64_t address = 0;
	uint32_t hwBpAddrLen = 0;
	uint32_t hwBpAddrType = 0;
	uint32_t hwBpThreadType = 0;
	uint32_t hwBpKeepTimeMs = 0;
};

struct InstProcessHwBpResultChild {
	uint64_t taskId = 0;
	uint64_t address = 0;
	uint64_t hitTotalCount = 0;
	std::vector<struct HW_HIT_ITEM> vHitItem;
};

struct InstProcessHwBpResult {
	uint32_t allTaskCount = 0;
	uint32_t hwbpInstalledCount = 0;
	std::vector<struct InstProcessHwBpResultChild> vThreadHit;
};
#pragma pack()


#endif /* HWBPSERVER_H_ */
```

`hwBreakpointProcModule/testHwBpServer/jni/porthelp.cpp`:

```cpp
#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#include <random>
#include "porthelp.h"
#include "Global.h"
```

`hwBreakpointProcModule/testHwBpServer/jni/porthelp.h`:

```h

#ifndef PORTHELP_H_
#define PORTHELP_H_
#include <stdint.h>

typedef int32_t HANDLE; //just an int, in case of a 32-bit ce version and a 64-bit linux version I can not give pointers, so use ID's for handles
typedef int32_t DWORD;

typedef enum { htEmpty = 0, htProcesHandle} handleType; //The difference between ThreadHandle and NativeThreadHandle is that threadhandle is based on the processid of the thread, the NativeThreadHandle is in linux usually the pthread_t handle
typedef int BOOL;

#define TRUE 1
#define FALSE 0

#endif /* PORTHELP_H_ */

```

`hwBreakpointProcModule/testHwBpServer/jni/testHwBpServer.cpp`:

```cpp

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <dirent.h>
#include <thread>
#include <zlib.h>
#include <sys/select.h>
#include <errno.h>
#include <elf.h>
#include <signal.h>
#include <sys/prctl.h>
#include <cinttypes>
#include "hwbpserver.h"
#include "api.h"
#include "Global.h"


#define PORT 3170

char versionstring[] = "HWBP Network 1.0";
ssize_t recvall(int s, void *buf, size_t size, int flags) {
	ssize_t totalreceived = 0;
	ssize_t sizeleft = size;
	unsigned char *buffer = (unsigned char*)buf;

	// enter recvall
	flags = flags | MSG_WAITALL;

	while (sizeleft > 0) {
		ssize_t i = recv(s, &buffer[totalreceived], sizeleft, flags);
		if (i == 0) {
			printf("recv returned 0\n");
			return i;
		}
		if (i == -1) {
			printf("recv returned -1\n");
			if (errno == EINTR) {
				printf("errno = EINTR\n");
				i = 0;
			} else {
				printf("Error during recvall: %d. errno=%d\n", (int)i, errno);
				return i; //read error, or disconnected
			}
		}
		totalreceived += i;
		sizeleft -= i;
	}
	// leave recvall
	return totalreceived;
}

ssize_t sendall(int s, void *buf, size_t size, int flags) {
	ssize_t totalsent = 0;
	ssize_t sizeleft = size;
	unsigned char *buffer = (unsigned char*)buf;

	while (sizeleft > 0) {
		ssize_t i = send(s, &buffer[totalsent], sizeleft, flags);

		if (i == 0) {
			return i;
		}

		if (i == -1) {
			if (errno == EINTR) {
				i = 0;
			} else {
				printf("Error during sendall: %d. errno=%d\n", (int)i, errno);
				return i;
			}
		}
		totalsent += i;
		sizeleft -= i;
	}

	return totalsent;
}



int DispatchCommand(int currentsocket, unsigned char command) {
	int r;
	switch (command) {
	case CMD_GETVERSION:
	{
		HwBpVersion *v;
		int versionsize = strlen(versionstring);
		v = (HwBpVersion*)malloc(sizeof(HwBpVersion) + versionsize);
		v->stringsize = versionsize;
		v->version = 1;

		memcpy((char *)v + sizeof(HwBpVersion), versionstring, versionsize);

		//version request
		sendall(currentsocket, v, sizeof(HwBpVersion) + versionsize, 0);

		free(v);

		break;
	}
	case CMD_CLOSECONNECTION:
	{
		printf("Connection %d closed properly\n", currentsocket);
		fflush(stdout);
		close(currentsocket);

		return 0;
	}

	case CMD_TERMINATESERVER:
	{
		printf("Command to terminate the server received\n");
		fflush(stdout);
		close(currentsocket);
		exit(0);
	}
	case CMD_ADDPROCESSHWBP:
	{
		InstProcessHwBpInfo input;
		InstProcessHwBpResult output;

		printf("CMD_ADDPROCESSHWBP\n");
		if (recvall(currentsocket, &input, sizeof(InstProcessHwBpInfo), MSG_WAITALL) > 0) {
			printf("pid:%zu,addr:%p,len:%d,type:%d,thread:%d,time:%d\n",
				input.pid,
				(void*)input.address,
				input.hwBpAddrLen,
				input.hwBpAddrType,
				input.hwBpThreadType,
				input.hwBpKeepTimeMs);

			ProcessInstProcessHwBp(input, output);
			fflush(stdout);

#pragma pack(1)
			struct {
				uint32_t allTaskCount;
				uint32_t hwbpInstalledCount;
				uint32_t hitThreadCount;
			} buf = {0};
#pragma pack()
			buf.allTaskCount = output.allTaskCount;
			buf.hwbpInstalledCount = output.hwbpInstalledCount;
			buf.hitThreadCount = output.vThreadHit.size();
			sendall(currentsocket, &buf, sizeof(buf), 0);

			for (const struct InstProcessHwBpResultChild &resultThreadItem : output.vThreadHit) {
#pragma pack(1)
				struct {
					uint64_t taskId = 0;
					uint64_t address = 0;
					uint64_t hitTotalCount = 0;
					uint64_t saveHitItemCount = 0;
				} threadInfoBuf = {0};
#pragma pack()
				threadInfoBuf.taskId = resultThreadItem.taskId;
				threadInfoBuf.address = resultThreadItem.address;
				threadInfoBuf.hitTotalCount = resultThreadItem.hitTotalCount;
				threadInfoBuf.saveHitItemCount = resultThreadItem.vHitItem.size();
				sendall(currentsocket, &threadInfoBuf, sizeof(threadInfoBuf), 0);
				for (const struct HW_HIT_ITEM & hitItem: resultThreadItem.vHitItem) {
					sendall(currentsocket, (void*)&hitItem, sizeof(hitItem), 0);
				}
			}
		} else {
			printf("Error during read for CMD_ADDPROCESSHWBP\n");
			fflush(stdout);
			close(currentsocket);
			return 0;
		}
		break;
	}

	default:
		printf("Unknow command:%d", command);
		fflush(stdout);
		break;
	}
	return 0;
}



void newConnectionThread(int s) {
	unsigned char command;

	int currentsocket = s;
	//printf("new connection. Using socket %d\n", s);
	while (1) {
		int r = recvall(currentsocket, &command, 1, MSG_WAITALL);
		if (r > 0) {
			DispatchCommand(currentsocket, command);
		} else
			if (r == -1) {
				printf("read error on socket %d (%d)\n", s, errno);
				fflush(stdout);
				close(currentsocket);
				return;
			} else {
				if (r == 0) {
					printf("Peer has disconnected\n");
					fflush(stdout);
					close(currentsocket);
					return;
				}
			}
	}
	close(s);
	return;
}

void IdentifierThread() {
	int i;
	int s;
	int v = 1;
#pragma pack(1)
	struct {
		uint32_t checksum;
		uint16_t port;
	} packet;
#pragma pack()

	socklen_t clisize;
	struct sockaddr_in addr, addr_client;

	printf("IdentifierThread active\n");

	fflush(stdout);

	s = socket(PF_INET, SOCK_DGRAM, 0);
	i = setsockopt(s, SOL_SOCKET, SO_BROADCAST, &v, sizeof(v));

	memset(&addr, 0, sizeof(addr));

	addr.sin_family = PF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	addr.sin_port = htons(3290);
	i = bind(s, (struct sockaddr *)&addr, sizeof(addr));

	if (i >= 0) {
		while (1) {
			memset(&addr_client, 0, sizeof(addr_client));
			addr_client.sin_family = PF_INET;
			addr_client.sin_addr.s_addr = INADDR_ANY;
			addr_client.sin_port = htons(3290);

			clisize = sizeof(addr_client);

			i = recvfrom(s, &packet, sizeof(packet), 0, (struct sockaddr *)&addr_client, &clisize);

			//i=recv(s, &v, sizeof(v), 0);
			if (i >= 0) {

				printf("Identifier thread received a message :%d\n", v);
				printf("sizeof(packet)=%ld\n", sizeof(packet));

				printf("packet.checksum=%x\n", packet.checksum);
				packet.checksum *= 0xce;
				packet.port = PORT;
				printf("packet.checksum=%x\n", packet.checksum);

				// packet.checksum=00AE98E7 - y=8C7F09E2

				fflush(stdout);

				i = sendto(s, &packet, sizeof(packet), 0, (struct sockaddr *)&addr_client, clisize);
				printf("sendto returned %d\n", i);
			} else {
				printf("recvfrom failed\n");
			}

			fflush(stdout);
		}
	} else {
		printf("IdentifierThread bind port failed\n");
	}
	printf("IdentifierThread exit\n");
	return;
}


int main(int argc, char *argv[]) {
	printf("Connecting driver.\n");

	//驱动默认隐蔽通信密匙
	std::string procNodeAuthKey = "dce3771681d4c7a143d5d06b7d32548e";
	if (argc > 1) {
		//用户自定义输入驱动隐蔽通信密匙
		procNodeAuthKey = argv[1];
	}
	printf("Connecting HWBP auth key:%s\n", procNodeAuthKey.c_str());

	//连接驱动
	int err = g_driver.ConnectDriver(procNodeAuthKey.c_str());
	if (err < 0) {
		printf("Connect HWBP driver failed. error:%d\n", err);
		fflush(stdout);
		return 0;
	}

	socklen_t clisize;
	struct sockaddr_in addr, addr_client;
	printf("listening on port %d\n", PORT);
	printf("HWServer. Waiting for client connection\n");

	std::thread tdId(IdentifierThread);
	tdId.detach();

	int s = socket(AF_INET, SOCK_STREAM, 0);
	printf("socket=%d\n", s);
	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(PORT);
	addr.sin_addr.s_addr = INADDR_ANY;
	int optval = 1;
	setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
	int b = bind(s, (struct sockaddr *)&addr, sizeof(addr));
	printf("bind=%d\n", b);

	if (b != -1) {
		int l = listen(s, 32);
		printf("listen=%d\n", l);
		clisize = sizeof(addr_client);
		memset(&addr_client, 0, sizeof(addr_client));
		fflush(stdout);
		while (1) {

			int a = accept(s, (struct sockaddr *)&addr_client, &clisize);
			printf("accept=%d\n", a);
			fflush(stdout);
			int opt = 1;
			setsockopt(a, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
			if (a != -1) {
				std::thread tdConnect(newConnectionThread, a);
				tdConnect.detach();
			}
		}
	}
	printf("Terminate server\n");
	close(s);
	return 0;
}
```

`hwBreakpointProcModule/testHwBpTarget/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_CPPFLAGS += -std=c++20
LOCAL_CFLAGS += -fPIE
LOCAL_CFLAGS += -fvisibility=hidden
LOCAL_LDFLAGS += -fPIE -pie
LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true
LOCAL_MODULE    := testHwBpTarget
LOCAL_SRC_FILES :=  testHwBpTarget.cpp

include $(BUILD_EXECUTABLE)

```

`hwBreakpointProcModule/testHwBpTarget/jni/Application.mk`:

```mk
APP_ABI :=  arm64-v8a
APP_STL := c++_static
```

`hwBreakpointProcModule/testHwBpTarget/jni/testHwBpTarget.cpp`:

```cpp
#include <cstdio>
#include <string.h> 
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <memory>
#include <dirent.h>
#include <thread>
#include <sstream>
#include <cinttypes>

#include "../../testHwBp/jni/HwBreakpointMgr4.h"

BOOL GetProcessTask(int pid, std::vector<int> & vOutput) {
	DIR *dir = NULL;
	struct dirent *ptr = NULL;
	char szTaskPath[256] = { 0 };
	sprintf(szTaskPath, "/proc/%d/task", pid);

	dir = opendir(szTaskPath);
	if (NULL != dir) {
		while ((ptr = readdir(dir)) != NULL)   // 循环读取路径下的每一个文件/文件夹
		{
			// 如果读取到的是"."或者".."则跳过，读取到的不是文件夹名字也跳过
			if ((strcmp(ptr->d_name, ".") == 0) || (strcmp(ptr->d_name, "..") == 0)) {
				continue;
			} else if (ptr->d_type != DT_DIR) {
				continue;
			} else if (strspn(ptr->d_name, "1234567890") != strlen(ptr->d_name)) {
				continue;
			}

			int task = atoi(ptr->d_name);
			vOutput.push_back(task);
		}
		closedir(dir);
		return TRUE;
	}
	return FALSE;
}

std::string TimestampToDatetime(uint64_t timestamp) {
    time_t t = (time_t)timestamp;
    struct tm *tm_info = localtime(&t);
    char buffer[256] = {0};
    strftime(buffer, 26, "%Y-%m-%d %H:%M:%S", tm_info);
    return buffer;
}

void PrintHwHitItem(const std::vector<HW_HIT_ITEM> &vHit) {
	for (const HW_HIT_ITEM &hitItem : vHit) {
		printf("==========================================================================\n");
		printf("时间:%s, 线程ID:%zu, 硬断命中地址:%p\n", TimestampToDatetime(hitItem.hit_time).c_str(), hitItem.task_id, (void*)hitItem.hit_addr);
		for (int r = 0; r < 30; r += 5) {
			printf("\tX%-2d=%-20p, X%-2d=%-20p, X%-2d=%-20p, X%-2d=%-20p, X%-2d=%-20p\n",
				r, (void*)hitItem.regs_info.regs[r],
				r + 1, (void*)hitItem.regs_info.regs[r + 1],
				r + 2, (void*)hitItem.regs_info.regs[r + 2],
				r + 3, (void*)hitItem.regs_info.regs[r + 3],
				r + 4, (void*)hitItem.regs_info.regs[r + 4]);
		}
		printf("\tLR=%-20p, SP=%-20p, PC=%-20p\n",
			(void*)hitItem.regs_info.regs[30],
			(void*)hitItem.regs_info.sp,
			(void*)hitItem.regs_info.pc);

		printf("\tprocess status:%p, orig_x0:%p, syscallno:%p\n",
			(void*)hitItem.regs_info.pstate,
			(void*)hitItem.regs_info.orig_x0,
			(void*)hitItem.regs_info.syscallno);
	}
}


int main(int argc, char *argv[]) {
	printf(
		"======================================================\n"
		"本驱动名称: Linux ARM64 硬件断点进程调试驱动4\n"
		"本驱动接口列表：\n"
		"\t1.  驱动_打开进程: OpenProcess\n"
		"\t2.  驱动_关闭进程: CloseHandle\n"
		"\t3.  驱动_获取CPU硬件执行断点支持数量: GetNumBRPS\n"
		"\t4.  驱动_获取CPU硬件访问断点支持数量: GetNumWRPS\n"
		"\t5.  驱动_安装进程硬件断点: InstProcessHwBp\n"
		"\t6.  驱动_鞋子啊进程硬件断点: UninstProcessHwBp\n"
		"\t7.  驱动_暂停硬件断点: SuspendProcessHwBp\n"
		"\t8.  驱动_恢复硬件断点: ResumeProcessHwBp\n"
		"\t9.  驱动_读取硬件断点命中信息: ReadHwBpInfo\n"
		"\t10. 驱动_设置无条件Hook跳转: SetHookPC\n"
		"\t11. 驱动_隐藏驱动: HideKernelModule\n"
		"\t以上所有功能不注入、不附加进程, 不打开进程任何文件, 所有操作均为内核操作\n"
		"======================================================\n"
	);

	int opt;
	int argv_pid = 0;
	size_t argv_hwbp_addr = 0;
	int argv_hwbp_len = 0;
	int argv_hwbp_type = 0;
	int argv_sleep_time = 1;
	size_t argv_hwbp_hook_addr = 0;

	while ((opt = getopt(argc, argv, "p:a:l:t:s:")) != -1) {
		switch (opt) {
		case 'p':
			argv_pid = atoi(optarg);
			break;
		case 'a':
			argv_hwbp_addr = strtoul(optarg, NULL, 16);
			break;
		case 'l':
			argv_hwbp_len = atoi(optarg);
			break;
		case 't':
			if (strcmp(optarg, "r") == 0) {
				argv_hwbp_type = HW_BREAKPOINT_R;
			} else if (strcmp(optarg, "w") == 0) {
				argv_hwbp_type = HW_BREAKPOINT_W;
			} else if (strcmp(optarg, "rw") == 0) {
				argv_hwbp_type = HW_BREAKPOINT_R | HW_BREAKPOINT_W;
			} else if (strcmp(optarg, "x") == 0) {
				argv_hwbp_type = HW_BREAKPOINT_X;
			}
			break;
		case 's':
			argv_sleep_time = atoi(optarg);
			break;
		case 'h':
			argv_hwbp_hook_addr = strtoul(optarg, NULL, 16);
			break;
		default:
			printf("Usage: %s [-p <attach_pid>] [-a <memory_hex_addr>] [-l <hwbp_len>] [-t <hwbp_type>] [-s <hwbp_wait_time_sec>] [-h <hw_hook_hex_addr> (optional)]\n", argv[0]);
			printf("Example (without -h): %s -p 8072 -a 9ECF6140 -l 8 -t rw -s 3\n", argv[0]);
			printf("Example (with -h):    %s -p 8072 -a 9ECF6140 -l 8 -t x -s 3 -h 7BC24620\n", argv[0]);
			return 0;
			break;
		}
	}
	if (argv_pid == 0 || argv_hwbp_addr == 0 || argv_hwbp_len == 0 || argv_hwbp_type == 0) {
		printf("Error value.\n");
		return 0;
	}
	printf("pid:%d,addr:%p,len:%d,type:%d,wait sec:%d,hook addr:%p\n", argv_pid, (void*)argv_hwbp_addr, argv_hwbp_len, argv_hwbp_type, argv_sleep_time, (void*)argv_hwbp_hook_addr);

	CHwBreakpointMgr driver;
	//驱动默认隐蔽通信密匙
	std::string procNodeAuthKey = "dce3771681d4c7a143d5d06b7d32548e";
	printf("Connecting HWBP auth key:%s\n", procNodeAuthKey.c_str());
	//连接驱动
	int err = driver.ConnectDriver(procNodeAuthKey.c_str());
	if (err < 0) {
		printf("Connect HWBP driver failed. error:%d\n", err);
		fflush(stdout);
		return 0;
	}

	//获取CPU支持硬件执行和访问断点的数量
	printf("Call GetNumBRPS() return:%d\n", driver.GetNumBRPS());
	printf("Call GetNumWRPS() return:%d\n", driver.GetNumWRPS());


	//获取目标进程所有的task
	std::vector<int> vTask;
	GetProcessTask(argv_pid, vTask);
	if (vTask.size() == 0) {
		printf("GetProcessTask failed\n");
		return 0;
	}
	if(argv_hwbp_hook_addr) {
		printf("==============================SetHookPC===============================\n");
		if (driver.SetHookPC(argv_hwbp_hook_addr)) {
			printf("Call SetHookPC(%p) failed.\n", (void*)argv_hwbp_hook_addr);
		} else {
			printf("Call SetHookPC failed.\n");
			return 0;
		}
	}
	printf("==============================InstProcessHwBp===============================\n");
	//设置进程硬件断点
	std::vector<uint64_t> vHwBpHandle;
	for (int taskId : vTask) {
		//打开task
		uint64_t hProcess = driver.OpenProcess(taskId);
		if (!hProcess) {
			printf("Call OpenProcess(%d) failed.\n", taskId);
			fflush(stdout);
			continue;
		}

		//设置进程硬件断点
		uint64_t hwBpHandle = driver.InstProcessHwBp(hProcess, argv_hwbp_addr,
			argv_hwbp_len, argv_hwbp_type);
		if (hwBpHandle) {
			vHwBpHandle.push_back(hwBpHandle);
		} else {
			printf("Call InstProcessHwBp(%d) failed.\n", taskId);
		}
		//关闭task
		driver.CloseHandle(hProcess);
	}
	printf("GetProcessTask successfully, task count:%lu, install successfully count:%lu, hw addr:%p, len:%d, type:%d, sleep:%d\n", 
		vTask.size(), vHwBpHandle.size(), (void*)argv_hwbp_addr, argv_hwbp_len, argv_hwbp_type, argv_sleep_time);

	sleep(std::max(argv_sleep_time, 3));
	printf("==============================SuspendProcessHwBp=============================\n");
	//暂停硬件断点
	for (uint64_t hwbpHandle : vHwBpHandle) {
		driver.SuspendProcessHwBp(hwbpHandle);
	}
	//读取硬件断点命中信息
	for (uint64_t hwbpHandle : vHwBpHandle) {
		uint64_t nHitTotalCount = 0;
		std::vector<HW_HIT_ITEM> vHit;
		BOOL b = driver.ReadHwBpInfo(hwbpHandle, nHitTotalCount, vHit);
		if(nHitTotalCount == 0) {
			continue;
		}
		printf("============================ReadProcessHwBp===============================\n");
		printf("Call ReadProcessHwBp(%p) return:%d, hit_total_count:%lu, save_hit_item_count:%lu\n", (void*)hwbpHandle, b, nHitTotalCount, vHit.size());
		PrintHwHitItem(vHit);
	}
	printf("==============================UninstProcessHwBp================================\n");
	//删除进程硬件断点
	for (uint64_t hwbpHandle : vHwBpHandle) {
		driver.UninstProcessHwBp(hwbpHandle);
	}
	printf("done.\n");
	return 0;
}
```

`rwProcMem33Module/rwProcMem_module/Makefile`:

```
obj-m += rwProcMem_module.o

```

`rwProcMem33Module/rwProcMem_module/api_proxy.h`:

```h
#ifndef API_PROXY_H_
#define API_PROXY_H_
#include "ver_control.h"
#include "linux_kernel_api.h"
#include <linux/ctype.h>
#include <asm/uaccess.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

//声明
//////////////////////////////////////////////////////////////////////////
static inline int x_atoi(const char arr[]);
static inline bool x_isdigit(char c);
static inline struct task_struct* x_get_current(void);
static inline void * x_kmalloc(size_t size, gfp_t flags);
static inline unsigned long x_copy_from_user(void *to, const void __user *from, unsigned long n);
static inline unsigned long x_copy_to_user(void __user *to, const void *from, unsigned long n);

//实现
//////////////////////////////////////////////////////////////////////////
static inline bool x_isdigit(char c) { return (unsigned)(c - '0') < 10; }
static inline int x_atoi(const char arr[]) {
	int index = 0;
	int flag = 1;
	int num = 0;

	if (arr == NULL) { return -1; }
	while (isspace(arr[index])) { index++; }
	if (arr[index] == '-') { flag = -1; }
	if (arr[index] == '-' || arr[index] == '+') { index++; }
	while (arr[index] >= '0' && arr[index] <= '9') { num = num * 10 + arr[index] - '0';	index++; }
	return flag * num;
}

static struct task_struct *x_get_current(void) {
	unsigned long sp_el0;
	asm ("mrs %0, sp_el0" : "=r" (sp_el0));
	return (struct task_struct *)sp_el0;
}

static void * x_kmalloc(size_t size, gfp_t flags) {
	return __kmalloc(size, flags);
}

static unsigned long x_copy_from_user(void *to, const void __user *from, unsigned long n) {
	return __arch_copy_from_user(to, from, n);
}

static unsigned long x_copy_to_user(void __user *to, const void *from, unsigned long n) {
	return __arch_copy_to_user(to, from, n);
}
#endif /* API_PROXY_H_ */



```

`rwProcMem33Module/rwProcMem_module/hide_procfs_dir.h`:

```h
#ifndef _HIDE_PROCFS_DIR_H_
#define _HIDE_PROCFS_DIR_H_

#include "ver_control.h"

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kprobes.h>
#include <linux/moduleparam.h>
#include <linux/fs.h>
#include <linux/string.h>

static char g_hide_dir_name[256] = {0};

static filldir_t old_filldir;

#if MY_LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
static int my_filldir(struct dir_context *buf,
                      const char *name,
                      int namelen,
                      loff_t offset,
                      u64 ino,
                      unsigned int d_type)
{
    if (namelen == strlen(g_hide_dir_name) &&
        !strncmp(name, g_hide_dir_name, namelen))
    {
        return 0;
    }
    return old_filldir(buf, name, namelen, offset, ino, d_type);
}
#else
static bool my_filldir(struct dir_context *ctx,
                       const char *name,
                       int namelen,
                       loff_t offset,
                       u64 ino,
                       unsigned int d_type)
{
    if (namelen == strlen(g_hide_dir_name) &&
        !strncmp(name, g_hide_dir_name, namelen))
    {
        return true;
    }
    return old_filldir(ctx, name, namelen, offset, ino, d_type);
}
#endif

static int handler_pre(struct kprobe *kp, struct pt_regs *regs)
{
    struct dir_context *ctx = (struct dir_context *)regs->regs[1];
    old_filldir = ctx->actor;
    ctx->actor = my_filldir;
    return 0;
}

static struct kprobe kp_hide_procfs_dir = {
    .symbol_name = "proc_root_readdir",
    .pre_handler = handler_pre,
};

static bool start_hide_procfs_dir(const char* hide_dir_name)
{
	//这里原理上可以换成SKRoot的汇编写法。避免kprobe。
    int ret;
    strlcpy(g_hide_dir_name, hide_dir_name, sizeof(g_hide_dir_name));
    ret = register_kprobe(&kp_hide_procfs_dir);
    if (ret) {
        printk_debug("[hide_procfs_dir] register_kprobe failed: %d\n", ret);
        return false;
    }
    printk_debug("[hide_procfs_dir] kprobe installed, hiding \"%s\"\n", g_hide_dir_name);
    return true;
}

static void stop_hide_procfs_dir(void)
{
    unregister_kprobe(&kp_hide_procfs_dir);
    printk_debug("[hide_procfs_dir] kprobe removed\n");
}

#endif  // _HIDE_PROCFS_DIR_H_

```

`rwProcMem33Module/rwProcMem_module/linux_kernel_api.h`:

```h
#ifndef LINUX_KERNEL_API_H_
#define LINUX_KERNEL_API_H_
#include "ver_control.h"

#include <linux/module.h>

#if MY_LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
 
long probe_kernel_read(void* dst, const void* src, size_t size);
 
static long x_probe_kernel_read(void* bounce, const char* ptr, size_t sz) {
    return probe_kernel_read(bounce, ptr, sz);
}
 
#endif
 
#if MY_LINUX_VERSION_CODE >= KERNEL_VERSION(5,8,0)
 
long copy_from_kernel_nofault(void* dst, const void* src, size_t size);
 
static long x_probe_kernel_read(void* bounce, const char* ptr, size_t sz) {
    return copy_from_kernel_nofault(bounce, ptr, sz);
}
 
#endif


#if MY_LINUX_VERSION_CODE < KERNEL_VERSION(6,6,0)
static inline pte_t x_pte_mkwrite(pte_t pte) {
    return pte_mkwrite(pte);
}
#else
static inline pte_t x_pte_mkwrite(pte_t pte) {
    struct vm_area_struct vma = {.vm_flags = VM_READ};
    return pte_mkwrite(pte, &vma);
}
#endif

#if MY_LINUX_VERSION_CODE < KERNEL_VERSION(6,6,0)
static size_t x_read_mm_struct_rss(struct mm_struct * mm, ssize_t offset) {
        struct mm_rss_stat *rss_stat = (struct mm_rss_stat *)((size_t)&mm->rss_stat + offset);
        size_t total_rss;
		ssize_t val1, val2, val3;
		val1 = atomic_long_read(&rss_stat->count[MM_FILEPAGES]);
		val2 = atomic_long_read(&rss_stat->count[MM_ANONPAGES]);
#ifdef MM_SHMEMPAGES
		val3 = atomic_long_read(&rss_stat->count[MM_SHMEMPAGES]);
#else
		val3 = 0;
#endif
		if (val1 < 0) { val1 = 0; }
		if (val2 < 0) { val2 = 0; }
		if (val3 < 0) { val3 = 0; }
		total_rss = val1 + val2 + val3;
        return total_rss;
}
#else
static size_t x_read_mm_struct_rss(struct mm_struct * mm, ssize_t offset) {
        struct percpu_counter *rss_stat = (struct percpu_counter *)((size_t)&mm->rss_stat + offset);
        size_t total_rss;
		ssize_t val1, val2, val3;
		val1 = percpu_counter_read(&rss_stat[MM_FILEPAGES]);
        val2 = percpu_counter_read(&rss_stat[MM_ANONPAGES]);

        #ifdef MM_SHMEMPAGES
        val3 = percpu_counter_read(&rss_stat[MM_SHMEMPAGES]);
        #else
        val3 = 0;
        #endif
		if (val1 < 0) { val1 = 0; }
		if (val2 < 0) { val2 = 0; }
		if (val3 < 0) { val3 = 0; }
		total_rss = val1 + val2 + val3;
        return total_rss;
}
#endif

#endif /* LINUX_KERNEL_API_H_ */

```

`rwProcMem33Module/rwProcMem_module/phy_mem.h`:

```h
#ifndef PHY_MEM_H_
#define PHY_MEM_H_
//声明
//////////////////////////////////////////////////////////////////////////
#include <linux/fs.h>
#include <linux/pid.h>
#include <asm/page.h>
#include "phy_mem_auto_offset.h"
#include "api_proxy.h"
#include "ver_control.h"

static inline int is_pte_can_read(pte_t* pte);
static inline int is_pte_can_write(pte_t* pte);
static inline int is_pte_can_exec(pte_t* pte);
static inline int change_pte_read_status(pte_t* pte, bool can_read);
static inline int change_pte_write_status(pte_t* pte, bool can_write);
static inline int change_pte_exec_status(pte_t* pte, bool can_exec);

static inline size_t get_proc_phy_addr(struct pid* proc_pid_struct, size_t virt_addr, pte_t** out_pte);
static inline size_t read_ram_physical_addr(bool is_kernel_buf, size_t phy_addr, char* lpBuf, size_t read_size);
static inline size_t write_ram_physical_addr(size_t phy_addr, char* lpBuf, bool is_kernel_buf, size_t write_size);

//实现
//////////////////////////////////////////////////////////////////////////
#include <asm/io.h>
#include <asm/uaccess.h>
#include <linux/slab.h>

#if MY_LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,83)
#include <linux/sched/task.h>
#include <linux/sched/mm.h>
#endif


#define RETURN_VALUE(size_t_ptr___out_ret, size_t___value) *size_t_ptr___out_ret=size_t___value;break;

#include <asm/pgtable.h>

static inline size_t get_proc_phy_addr(struct pid* proc_pid_struct, size_t virt_addr, pte_t** out_pte) {
	struct task_struct* task = pid_task(proc_pid_struct, PIDTYPE_PID);
	struct mm_struct *mm = NULL;
	//////////////////////////////////////////////////////////////////////////
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;
	unsigned long paddr = 0;
	unsigned long page_addr = 0;
	unsigned long page_offset = 0;

	if (!task) { return 0; }

	mm = get_task_mm(task);
	if (!mm) { return 0; }

	*out_pte = 0;
	pgd = x_pgd_offset(mm, virt_addr);
	if (pgd == NULL) {
		printk_debug("pgd is null\n");
		goto out;
	}
	//printk_debug("pgd_val = 0x%lx pgd addr:0x%p\n", (unsigned long int)pgd_val(*pgd), (void*)pgd);
	//printk_debug("init_mm pgd val:0x%lx,pgd addr:0x%p\n", (unsigned long)pgd_val(*(mm->pgd)), (void*)mm->pgd);
	printk_debug("pgd_index = %zu\n", pgd_index(virt_addr));
	if (pgd_none(*pgd)) {
		printk_debug("not mapped in pgd\n");
		goto out;
	}
	printk_debug("pgd_offset ok\n");

	/*
	 * (p4ds are folded into pgds so this doesn't get actually called,
	 * but the define is needed for a generic inline function.)
	 */
	p4d = p4d_offset(pgd, virt_addr);
	//printk_debug("p4d_val = 0x%llx, p4d_index = %d\n", p4d_val(*p4d), p4d_index(virt_addr));
	printk_debug("p4d_val = 0x%llx\n", p4d_val(*p4d));
	if (p4d_none(*p4d))
	{
		printk_debug("not mapped in p4d\n");
		goto out;
	}

	pud = pud_offset(p4d, virt_addr);
	printk_debug("pud_val = 0x%llx \n", pud_val(*pud));
	if (pud_none(*pud)) {
		printk_debug("not mapped in pud\n");
		goto out;
	}
	printk_debug("pud_offset ok\n");

	pmd = pmd_offset(pud, virt_addr);
	printk_debug("pmd_val = 0x%llx\n", pmd_val(*pmd));
	//printk_debug("pmd_index = %d\n", pmd_index(virt_addr));
	if (pmd_none(*pmd)) {
		printk_debug("not mapped in pmd\n");
		goto out;
	}
	printk_debug("pmd_offset ok\n");

	pte = pte_offset_kernel(pmd, virt_addr);
	printk_debug("pte_val = 0x%llx\n", pte_val(*pte));
	//printk_debug("pte_index = %d\n", pte_index(virt_addr));
	if (pte_none(*pte)) {
		printk_debug("not mapped in pte\n");
		goto out;
	}
	printk_debug("pte_offset_kernel ok\n");

	page_addr = page_to_phys(pte_page(*pte));
	page_offset = virt_addr & ~PAGE_MASK;
	paddr = page_addr | page_offset;

	printk_debug("page_addr = %lx, page_offset = %lx\n", page_addr, page_offset);
	printk_debug("vaddr = %zx, paddr = %lx\n", virt_addr, paddr);

	*out_pte = pte;
out:
	mmput(mm);
	return paddr;
}


static inline int is_pte_can_read(pte_t* pte) {
						if (!pte) { return 0; }
#ifdef pte_read
						if (pte_read(*pte)) { return 1; } else { return 0; }
#endif
						return 1;
					}
static inline int is_pte_can_write(pte_t* pte) {
	if (!pte) { return 0; }
	if (pte_write(*pte)) { return 1; } else { return 0; }
}
static inline int is_pte_can_exec(pte_t* pte) {
	if (!pte) { return 0; }
#ifdef pte_exec
	if (pte_exec(*pte)) { return 1; } else { return 0; }
#endif
#ifdef pte_user_exec
	if (pte_user_exec(*pte)) { return 1; } else { return 0; }
#endif
	return 0;
}
static inline int change_pte_read_status(pte_t* pte, bool can_read) {
	if (!pte) { return 0; }
	return 1;
}
static inline int change_pte_write_status(pte_t* pte, bool can_write) {
	if (!pte) { return 0; }
	if (can_write) {
		set_pte(pte, x_pte_mkwrite(*pte));
	} else {
		set_pte(pte, pte_wrprotect(*pte));
	}
	return 1;
}
static inline int change_pte_exec_status(pte_t* pte, bool can_exec) {
	if (!pte) { return 0; }
	if (can_exec) {
#ifdef pte_mknexec
		set_pte(pte, x_pte_mkwrite(*pte));
#endif
	} else {
#ifdef pte_mkexec
		set_pte(pte, x_pte_mkwrite(*pte));
#endif
	}
	return 1;
}

static inline unsigned long size_inside_page(unsigned long start,
	unsigned long size) {
	unsigned long sz;

	sz = PAGE_SIZE - (start & (PAGE_SIZE - 1));

	return min(sz, size);
}


static inline int check_phys_addr_valid_range(size_t addr, size_t count) {
	if (g_phy_total_memory_size == 0) {
		init_phy_total_memory_size();
	}
	return (addr + count) <= g_phy_total_memory_size;
}


static inline size_t read_ram_physical_addr(bool is_kernel_buf, size_t phy_addr, char* lpBuf, size_t read_size) {
	void *bounce;
	size_t realRead = 0;
	if (!check_phys_addr_valid_range(phy_addr, read_size)) {
		printk_debug(KERN_INFO "Error in check_phys_addr_valid_range:%zu,size:%zu\n", phy_addr, read_size);
		return 0;
	}
	bounce = x_kmalloc(PAGE_SIZE, GFP_KERNEL);
	if (!bounce) {
		return 0;
	}

	while (read_size > 0) {
		size_t sz = size_inside_page(phy_addr, read_size);

		/*
		 * On ia64 if a page has been mapped somewhere as uncached, then
		 * it must also be accessed uncached by the kernel or data
		 * corruption may occur.
		 */

		char *ptr = xlate_dev_mem_ptr(phy_addr);
		int probe;

		if (!ptr) {
			printk_debug(KERN_INFO "Error in x_xlate_dev_mem_ptr:0x%zx\n", phy_addr);
			break;
		}
		probe = x_probe_kernel_read(bounce, ptr, sz);
		unxlate_dev_mem_ptr(phy_addr, ptr);
		if (probe) {
			break;
		}
		if (is_kernel_buf) {
			memcpy(lpBuf, bounce, sz);
		} else {
			unsigned long remaining = x_copy_to_user(lpBuf, bounce, sz);
			if (remaining) {
				printk_debug(KERN_INFO "Error in x_copy_to_user(\n");
				break;
			}
		}
		lpBuf += sz;
		phy_addr += sz;
		read_size -= sz;
		realRead += sz;
	}
	kfree(bounce);
	return realRead;
}

static inline size_t write_ram_physical_addr(size_t phy_addr, char* lpBuf, bool is_kernel_buf, size_t write_size) {
	size_t realWrite = 0;
	if (!check_phys_addr_valid_range(phy_addr, write_size)) {
		printk_debug(KERN_INFO "Error in check_phys_addr_valid_range:0x%zx,size:%zu\n", phy_addr, write_size);
		return 0;
	}


	while (write_size > 0) {
		size_t sz = size_inside_page(phy_addr, write_size);

		/*
			* On ia64 if a page has been mapped somewhere as uncached, then
			* it must also be accessed uncached by the kernel or data
			* corruption may occur.
			*/

		char *ptr = xlate_dev_mem_ptr(phy_addr);
		if (!ptr) {
			printk_debug(KERN_INFO "Error in xlate_dev_mem_ptr:0x%zx\n", phy_addr);
			break;
		}
		if (is_kernel_buf) {
			memcpy(ptr, lpBuf, sz);
		} else {
			unsigned long copied = x_copy_from_user(ptr, lpBuf, sz);
			if (copied) {
				unxlate_dev_mem_ptr(phy_addr, ptr);
				realWrite += sz - copied;
				printk_debug(KERN_INFO "Error in x_copy_from_user(\n");
				break;
			}
		}
		unxlate_dev_mem_ptr(phy_addr, ptr);

		lpBuf += sz;
		phy_addr += sz;
		write_size -= sz;
		realWrite += sz;
	}
	return realWrite;
}
#endif /* PHY_MEM_H_ */
```

`rwProcMem33Module/rwProcMem_module/phy_mem_auto_offset.h`:

```h
#ifndef PHY_MEM_AUTO_OFFSET_H_
#define PHY_MEM_AUTO_OFFSET_H_
#include "api_proxy.h"
#include "ver_control.h"

#undef pgd_offset
#if MY_LINUX_VERSION_CODE <= KERNEL_VERSION(3,10,84)
#define my_pgd_offset(pgd, addr)	(pgd+pgd_index(addr))
#define my_pud_offset(dir, addr) ((pud_t *)__va(pud_offset_phys((dir), (addr))))
#endif
#if MY_LINUX_VERSION_CODE < KERNEL_VERSION(5,10,43)
#define my_pgd_offset(pgd, addr)	(pgd+pgd_index(addr))
#define my_pud_offset(dir, addr) ((pud_t *)__va(pud_offset_phys((dir), (addr))))
#endif
#if MY_LINUX_VERSION_CODE >= KERNEL_VERSION(5,10,43)
#define my_pgd_offset(pgd, address)	pgd_offset_pgd(pgd, address)
#endif

#define my_get_fs()	(current_thread_info()->addr_limit)

static size_t g_phy_total_memory_size = 0;
static int init_phy_total_memory_size(void) {
	struct sysinfo si;
	unsigned long mem_total, sav_total;
	unsigned int  bitcount = 0;
	unsigned int  mem_unit = 0;
	if (g_phy_total_memory_size) {
		return 0;
	}

	si_meminfo(&si);
	mem_unit = si.mem_unit;

	mem_total = si.totalram;
	while (mem_unit > 1) {
		bitcount++;
		mem_unit >>= 1;
		sav_total = mem_total;
		mem_total <<= 1;
		if (mem_total < sav_total) {
			return 0;
		}
	}
	si.totalram <<= bitcount;
	g_phy_total_memory_size = __pa(si.totalram);
	printk_debug(KERN_INFO "MemTotal si.totalram:%ld\n", si.totalram);
	printk_debug(KERN_INFO "g_phy_total_memory_size:%ld\n", g_phy_total_memory_size);
	return 0;
}

static ssize_t g_pgd_offset_mm_struct = 0;
static bool g_init_pgd_offset_success = false;

#if MY_LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,75)

static int init_pgd_offset(struct mm_struct *mm) {
	int is_found_pgd_offset = 0;
	g_init_pgd_offset_success = false;
	for (g_pgd_offset_mm_struct = -40; g_pgd_offset_mm_struct <= 80; g_pgd_offset_mm_struct += 1) {
		char *rp;
		size_t val;
		ssize_t accurate_offset = (ssize_t)((size_t)&mm->pgd - (size_t)mm + g_pgd_offset_mm_struct);
		if (accurate_offset >= sizeof(struct mm_struct) - sizeof(ssize_t)) {
			return -EFAULT;
		}
		rp = (char*)((size_t)mm + (size_t)accurate_offset);
		val = *(size_t*)(rp);
		printk_debug(KERN_EMERG "init_pgd_offset %zd:%zd:%p:%ld\n", g_pgd_offset_mm_struct, accurate_offset, rp, val);

		if (val == TASK_SIZE) {
			g_pgd_offset_mm_struct += sizeof(unsigned long);
			printk_debug(KERN_EMERG "found g_init_pgd_offset_success:%zd\n", g_pgd_offset_mm_struct);
			is_found_pgd_offset = 1;
			break;
		}
	}
	if (!is_found_pgd_offset) {
		printk_debug(KERN_INFO "find pgd offset failed\n");
		return -ESPIPE;
	}
	g_init_pgd_offset_success = true;
	printk_debug(KERN_INFO "g_pgd_offset_mm_struct:%zu\n", g_pgd_offset_mm_struct);
	return 0;
}
#else
static int init_pgd_offset(struct mm_struct *mm) {
	int is_found_pgd_offset = 0;
	g_init_pgd_offset_success = false;
	for (g_pgd_offset_mm_struct = -40; g_pgd_offset_mm_struct <= 80; g_pgd_offset_mm_struct += 1) {
		char *rp;
		size_t val;
		ssize_t accurate_offset = (ssize_t)((size_t)&mm->pgd - (size_t)mm + g_pgd_offset_mm_struct);
		if (accurate_offset >= sizeof(struct mm_struct) - sizeof(ssize_t)) {
			return -EFAULT;
		}
		rp = (char*)((size_t)mm + (size_t)accurate_offset);
		val = *(size_t*)(rp);
		printk_debug(KERN_EMERG "init_pgd_offset %zd:%zd:%p:%ld\n", g_pgd_offset_mm_struct, accurate_offset, rp, val);

		if (val == TASK_SIZE) {
			//找到了
			g_pgd_offset_mm_struct += sizeof(unsigned long);
			g_pgd_offset_mm_struct += sizeof(unsigned long);
			printk_debug(KERN_EMERG "found g_init_pgd_offset_success:%zd\n", g_pgd_offset_mm_struct);
			is_found_pgd_offset = 1;
			break;
		}
	}
	if (!is_found_pgd_offset) {
		printk_debug(KERN_INFO "find pgd offset failed\n");
		return -ESPIPE;
	}
	g_init_pgd_offset_success = true;
	printk_debug(KERN_INFO "g_pgd_offset_mm_struct:%zu\n", g_pgd_offset_mm_struct);
	return 0;
}
#endif

static inline pgd_t *x_pgd_offset(struct mm_struct *mm, size_t addr) {
	size_t pgd;
	ssize_t accurate_offset;
	if (g_init_pgd_offset_success == false) {
		if (init_pgd_offset(mm) != 0) {
			return NULL;
		}
	}
	accurate_offset = (ssize_t)((size_t)&mm->pgd - (size_t)mm + g_pgd_offset_mm_struct);
	printk_debug(KERN_INFO "x_pgd_offset accurate_offset:%zd\n", accurate_offset);
	if (accurate_offset >= sizeof(struct mm_struct) - sizeof(ssize_t)) {
		return NULL;
	}

	//拷贝到我自己的pgd指针变量里去
	//写法一（可读性强）
	//void * rv = (size_t*)((size_t)mm + (size_t)accurate_offset);
	//pgd_t *pgd;
	//memcpy(&pgd, rv, sizeof(pgd_t *));

	//写法二（快些）
	pgd = *(size_t*)((size_t)mm + (size_t)accurate_offset);

	return my_pgd_offset((pgd_t*)pgd, addr);
}

#endif /* PHY_MEM_AUTO_OFFSET_H_ */
```

`rwProcMem33Module/rwProcMem_module/proc_cmdline.h`:

```h
#ifndef PROC_CMDLINE_H_
#define PROC_CMDLINE_H_
//声明
//////////////////////////////////////////////////////////////////////////
#include <linux/pid.h>
#include "ver_control.h"

static inline struct pid * get_proc_pid_struct(int pid);
static inline int get_proc_pid(struct pid* proc_pid_struct);
static inline void release_proc_pid_struct(struct pid* proc_pid_struct);
static inline int get_proc_cmdline_addr(struct pid* proc_pid_struct, size_t * arg_start, size_t * arg_end);

//实现
//////////////////////////////////////////////////////////////////////////
#include "phy_mem.h"
#include "proc_cmdline_auto_offset.h"
#include "api_proxy.h"

static inline struct pid * get_proc_pid_struct(int pid) {
	return find_get_pid(pid);
}
static inline int get_proc_pid(struct pid* proc_pid_struct) {
	return proc_pid_struct->numbers[0].nr;
}
static inline void release_proc_pid_struct(struct pid* proc_pid_struct) {
	put_pid(proc_pid_struct);
}

static inline int get_proc_cmdline_addr(struct pid* proc_pid_struct, size_t * arg_start, size_t * arg_end) {
	struct task_struct *task = NULL;
	struct mm_struct *mm = NULL;
	ssize_t accurate_offset = 0;

	if (g_init_arg_start_offset_success == false) {
		return -ENOENT;
	}

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) { return -EFAULT; }
	
	mm = get_task_mm(task);

	if (!mm) { return -EFAULT; }

	//精确偏移
	accurate_offset = (ssize_t)((size_t)&mm->arg_start - (size_t)mm + g_arg_start_offset);
	if (accurate_offset >= sizeof(struct mm_struct) - sizeof(ssize_t)) {
		mmput(mm);
		return -EFAULT;
	}

	if (down_read_mmap_lock(mm) != 0) {
		mmput(mm);
		return -EFAULT;
	}
	printk_debug(KERN_INFO "accurate_offset:%zd\n", accurate_offset);

	*arg_start = *(size_t*)((size_t)mm + (size_t)accurate_offset);
	*arg_end = *(size_t*)((size_t)mm + (size_t)accurate_offset + sizeof(unsigned long));

	printk_debug(KERN_INFO "arg_start addr:0x%p\n", (void*)*arg_start);

	up_read_mmap_lock(mm);
	mmput(mm);
	return 0;
}
#endif /* PROC_CMDLINE_H_ */
```

`rwProcMem33Module/rwProcMem_module/proc_cmdline_auto_offset.h`:

```h
#ifndef PROC_CMDLINE_AUTO_OFFSET_H_
#define PROC_CMDLINE_AUTO_OFFSET_H_
//声明
//////////////////////////////////////////////////////////////////////////
#include <linux/pid.h>
#include "ver_control.h"
//实现
//////////////////////////////////////////////////////////////////////////
#include "api_proxy.h"
static ssize_t g_arg_start_offset = 0;
static bool g_init_arg_start_offset_success = false;

struct mm_struct_arg_offset_helper {
	unsigned long arg_start, arg_end, env_start, env_end;
};

static inline int init_proc_cmdline_offset(const char* my_auxv, int my_auxv_size) {
    struct task_struct *mytask = x_get_current();
    struct mm_struct  *mm = NULL;
	const unsigned char *base = NULL;
	size_t limit = 0;
	size_t off = 0;
    if (g_init_arg_start_offset_success) {
        return 0;
    }

    mm = get_task_mm(mytask);
    if (!mm) {
        return -EFAULT;
    }

    base  = (const unsigned char *)mm;
    limit = sizeof(struct mm_struct);

    for (off = 0; off + (size_t)my_auxv_size <= limit; ++off) {
        size_t i = 0;
        for (; i < (size_t)my_auxv_size; ++i) {
            if (base[off + i] != (unsigned char)my_auxv[i]) {
                break;
            }
        }
        if (i == (size_t)my_auxv_size) {
            g_arg_start_offset = (ssize_t)off - sizeof(struct mm_struct_arg_offset_helper) + (ssize_t)offsetof(struct mm_struct_arg_offset_helper, arg_start) - (ssize_t)offsetof(struct mm_struct, arg_start);
            g_init_arg_start_offset_success = true;
            break;
        }
    }
    mmput(mm);
	if (!g_init_arg_start_offset_success) {
		printk_debug(KERN_INFO "find auxv offset failed\n");
		return -ESPIPE;
	}
	printk_debug(KERN_INFO "g_arg_start_offset:%zd\n", g_arg_start_offset);
    return 0;
}
#endif /* PROC_CMDLINE_AUTO_OFFSET_H_ */
```

`rwProcMem33Module/rwProcMem_module/proc_list.h`:

```h
#ifndef PROC_LIST_H_
#define PROC_LIST_H_
#include "api_proxy.h"
#include "proc_list_auto_offset.h"
#include "ver_control.h"

#include <linux/sched.h>
#include <linux/uaccess.h>
#include <linux/types.h>
#include <linux/string.h>
#include <linux/errno.h>

//声明
//////////////////////////////////////////////////////////////////////////
static ssize_t get_proc_pid_list(bool is_kernel_buf, char* buf, size_t buf_size);


//实现
//////////////////////////////////////////////////////////////////////////

static ssize_t get_proc_pid_list(bool is_kernel_buf,
                                    char* buf,
                                    size_t buf_size) {
    struct task_struct *p, *next;
    ssize_t count = 0;
    size_t buf_pos = 0;

    if (!g_init_task_next_offset_success || !g_init_task_pid_offset_success) {
        return -EFAULT;
    }

    p = &init_task;
    while (1) {
        uintptr_t list_next = *(uintptr_t *)((char *)p + g_task_next_offset);
        next = (struct task_struct *)(list_next - g_task_next_offset);
        if (next == &init_task)
            break;
        
        count++;

        // copy pid
        {
            pid_t pid_v = *(pid_t *)((char *)next + g_task_pid_offset);
            int pid_n = pid_v;
            printk_debug(KERN_INFO "iter_task: pid = %d\n", pid_n);
            if (buf_pos < buf_size) {
                if (is_kernel_buf) {
                    memcpy((void*)((size_t)buf + (size_t)buf_pos), &pid_n, sizeof(pid_n));
                } else {
                    x_copy_to_user((void*)((size_t)buf + (size_t)buf_pos), &pid_n, sizeof(pid_n));
                }
                buf_pos += sizeof(pid_n);
            }
        }
        p = next;
    }

    return count;
}

#endif /* PROC_LIST_H_ */



```

`rwProcMem33Module/rwProcMem_module/proc_list_auto_offset.h`:

```h
#ifndef PROC_LIST_AUTO_OFFSET_H_
#define PROC_LIST_AUTO_OFFSET_H_
#include <linux/ctype.h>
#include "ver_control.h"

static ssize_t g_task_next_offset = 0;
static bool g_init_task_next_offset_success = false;

static ssize_t g_task_pid_offset = 0;
static bool g_init_task_pid_offset_success = false;

static inline int init_task_next_offset(void) {
    struct task_struct *mytask = x_get_current();
    struct mm_struct  *mm    = get_task_mm(mytask);
    size_t              off_mm = 0;
    size_t              off    = 0;
    uintptr_t           addr_mytask;
    uintptr_t           addr_mm;
    if (!mm)
        return -ESRCH;
    if (g_init_task_next_offset_success) {
        mmput(mm);
        return 0;
    }

    addr_mytask = (uintptr_t)mytask;
    addr_mm     = (uintptr_t)mm;

    /* 寻找 mm_struct 在 task_struct 中的偏移 */
    for (off = 0; off <= sizeof(*mytask) - sizeof(void*); off += 4) {
        void *v = *(void **)(addr_mytask + off);
        if ((uintptr_t)v == addr_mm) {
            off_mm = off;
            break;
        }
    }

    if (off_mm == 0) {
        printk_debug(KERN_EMERG "init_task_next_offset mm_struct failed.\n");
        mmput(mm);
        return -EFAULT;
    }

    g_task_next_offset = off_mm
                         - sizeof(mytask->pushable_dl_tasks)
                         - sizeof(mytask->pushable_tasks)
                         - sizeof(mytask->tasks);
    g_init_task_next_offset_success = true;
    printk_debug(KERN_INFO "init_task_next_offset: found tasks offset = %zu bytes\n",
                 g_task_next_offset);

    mmput(mm);
    return 0;
}


static inline int init_task_pid_offset(int pid, int tgid) {
    struct task_struct *mytask = x_get_current();
    struct mm_struct   *mm     = get_task_mm(mytask);
    uintptr_t           addr_mytask = (uintptr_t)mytask;
    uintptr_t           addr_mm     = (uintptr_t)mm;
    size_t              off_mm    = 0;
    size_t              off       = 0;
    size_t off_pid_static = (uintptr_t)&mytask->pid - addr_mytask;

    printk_debug(KERN_INFO
        "init_task_pid_offset: mytask@%p, &pid@%p, static off_pid = %zu\n",
        mytask, &mytask->pid, off_pid_static);

    if (!mm)
        return -ESRCH;

    if (g_init_task_pid_offset_success) {
        mmput(mm);
        return 0;
    }

    for (off = 0; off <= sizeof(*mytask) - sizeof(void*); off += 4) {
        void *v = *(void **)(addr_mytask + off);
        if ((uintptr_t)v == addr_mm) {
            off_mm = off;
            break;
        }
    }
    if (off_mm == 0) {
        printk_debug(KERN_EMERG "init_task_pid_offset: mm_struct offset not found\n");
        mmput(mm);
        return -EFAULT;
    }
    printk_debug(KERN_INFO "init_task_pid_offset: mm_struct offset found = %zu\n", off_mm);

    /* 2) 从 mm_struct 偏移处开始，搜索 pid 和 tgid */
    for (off = off_mm; off <= sizeof(*mytask) - 2 * sizeof(pid_t); off += 4) {
        pid_t pid_v  = *(pid_t *)(addr_mytask + off);
        pid_t tgid_v = *(pid_t *)(addr_mytask + off + sizeof(pid_t));
        if (pid_v == pid && tgid_v == tgid) {
            g_task_pid_offset = off;
            g_init_task_pid_offset_success = true;
            printk_debug(KERN_INFO
                "init_task_pid_offset: found pid/tgid offset = %zu (pid=%d, tgid=%d)\n",
                g_task_pid_offset, pid, tgid);
            mmput(mm);
            return 0;
        }
    }

    printk_debug(KERN_EMERG
        "init_task_pid_offset: failed to match pid=%d, tgid=%d\n",
        pid, tgid);
    mmput(mm);
    return -ENOENT;
}


#endif /* PROC_LIST_AUTO_OFFSET_H_ */



```

`rwProcMem33Module/rwProcMem_module/proc_maps.h`:

```h
#ifndef PROC_MAPS_H_
#define PROC_MAPS_H_

//声明
//////////////////////////////////////////////////////////////////////////
#include <linux/pid.h>
#include <linux/types.h>
#include <linux/mm_types.h>
#if MY_LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,83)
#include <linux/sched/task.h>
#include <linux/sched/mm.h>
#endif

static inline int down_read_mmap_lock(struct mm_struct *mm);
static inline int up_read_mmap_lock(struct mm_struct *mm);
static inline size_t get_proc_map_count(struct pid* proc_pid_struct);
static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size);

//实现
//////////////////////////////////////////////////////////////////////////
#include <linux/err.h>
#include <linux/sched.h>
#include <linux/limits.h>
#include <linux/dcache.h>
#include <asm/uaccess.h>
#include <linux/path.h>
#include <asm-generic/mman-common.h>
#include "api_proxy.h"
#include "proc_maps_auto_offset.h"
#include "ver_control.h"

#define MY_PATH_MAX_LEN 1024
#pragma pack(push,1)
struct map_entry {
    unsigned long start;
    unsigned long end;
    unsigned char flags[4];
    char path[MY_PATH_MAX_LEN];
};
#pragma pack(pop)

static inline size_t get_proc_map_count(struct pid* proc_pid_struct) {
	ssize_t accurate_offset;
	struct task_struct *task = pid_task(proc_pid_struct, PIDTYPE_PID);
	struct mm_struct *mm = get_task_mm(task);
	size_t count = 0;
	if (g_init_map_count_offset_success == false) {
		mmput(mm);
		return 0;
	}

	if (down_read_mmap_lock(mm) != 0) {
		goto _exit;
	}

	//精确偏移
	accurate_offset = (ssize_t)((size_t)&mm->map_count - (size_t)mm + g_map_count_offset);
	printk_debug(KERN_INFO "mm->map_count accurate_offset:%zd\n", accurate_offset);
	if (accurate_offset >= sizeof(struct mm_struct) - sizeof(ssize_t)) {
		mmput(mm);
		return 0;
	}
	count = *(int *)((size_t)mm + (size_t)accurate_offset);

	up_read_mmap_lock(mm);

_exit:mmput(mm);
	return count;
}


static inline int check_proc_map_can_read(struct pid* proc_pid_struct, size_t proc_virt_addr, size_t size) {
	struct task_struct *task = pid_task(proc_pid_struct, PIDTYPE_PID);
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	int res = 0;
	if (!task) { return res; }

	mm = get_task_mm(task);

	if (!mm) { return res; }


	//printk_debug(KERN_EMERG "mm:%p\n", &mm);
	//printk_debug(KERN_EMERG "mm->map_count:%p:%lu\n", &mm->map_count, mm->map_count);
	//printk_debug(KERN_EMERG "mm->mmap_lock:%p\n", &mm->mmap_lock);
	//printk_debug(KERN_EMERG "mm->hiwater_vm:%p:%lu\n", &mm->hiwater_vm, mm->hiwater_vm);
	//printk_debug(KERN_EMERG "mm->total_vm:%p:%lu\n", &mm->total_vm, mm->total_vm);
	//printk_debug(KERN_EMERG "mm->locked_vm:%p:%lu\n", &mm->locked_vm, mm->locked_vm);
	//printk_debug(KERN_EMERG "mm->pinned_vm:%p:%lu\n", &mm->pinned_vm, mm->pinned_vm);

	//printk_debug(KERN_EMERG "mm->task_size:%p:%lu,%lu\n", &mm->task_size, mm->task_size, TASK_SIZE);
	//printk_debug(KERN_EMERG "mm->highest_vm_end:%p:%lu\n", &mm->highest_vm_end, mm->highest_vm_end);
	//printk_debug(KERN_EMERG "mm->pgd:%p:%p\n", &mm->pgd, mm->pgd);


	if (down_read_mmap_lock(mm) != 0) {
		goto _exit;
	}

	vma = find_vma(mm, proc_virt_addr);
	if (vma) {
		if (vma->vm_flags & VM_READ) {
			size_t read_end = proc_virt_addr + size;
			if (read_end <= vma->vm_end) {
				res = 1;
			}
		}
	}
	up_read_mmap_lock(mm);

_exit:mmput(mm);
	return res;
}
static inline int check_proc_map_can_write(struct pid* proc_pid_struct, size_t proc_virt_addr, size_t size) {
	struct task_struct *task = pid_task(proc_pid_struct, PIDTYPE_PID);
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	int res = 0;

	if (!task) { return res; }

	mm = get_task_mm(task);

	if (!mm) { return res; }

	if (down_read_mmap_lock(mm) != 0) {
		mmput(mm);
		return res;
	}

	vma = find_vma(mm, proc_virt_addr);
	if (vma) {
		if (vma->vm_flags & VM_WRITE) {
			size_t read_end = proc_virt_addr + size;
			if (read_end <= vma->vm_end) {
				res = 1;
			}
		}
	}
	up_read_mmap_lock(mm);
	mmput(mm);
	return res;
}


#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(3,10,0)
/* Check if the vma is being used as a stack by this task */
static int vm_is_stack_for_task(struct task_struct *t,
	struct vm_area_struct *vma) {
	return (vma->vm_start <= KSTK_ESP(t) && vma->vm_end >= KSTK_ESP(t));
}

/*
 * Check if the vma is being used as a stack.
 * If is_group is non-zero, check in the entire thread group or else
 * just check in the current task. Returns the pid of the task that
 * the vma is stack for.
 */
static pid_t my_vm_is_stack(struct task_struct *task,
	struct vm_area_struct *vma, int in_group) {
	pid_t ret = 0;

	if (vm_is_stack_for_task(task, vma))
		return task->pid;

	if (in_group) {
		struct task_struct *t;
		rcu_read_lock();
		if (!pid_alive(task))
			goto done;

		t = task;
		do {
			if (vm_is_stack_for_task(t, vma)) {
				ret = t->pid;
				goto done;
			}
		} while_each_thread(task, t);
	done:
		rcu_read_unlock();
	}

	return ret;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {

	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;
	
	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);
	if (!mm) {
        ret = -EINVAL;
        goto out;
	}


	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }


	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}

	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		/* We don't show the stack guard page in /proc/maps */
		if (stack_guard_page_start(vma, entry->start))
			entry->start += PAGE_SIZE;
		if (stack_guard_page_end(vma, entry->end))
			entry->end -= PAGE_SIZE;

		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				pid_t tid = my_vm_is_stack(task, vma, 1);
				if (tid != 0) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */

					sprintf(entry->path, "[stack:%d]", tid);
				}
			}

		}

		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}



#endif




#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(3,10,84)
/* Check if the vma is being used as a stack by this task */
static int vm_is_stack_for_task(struct task_struct *t,
	struct vm_area_struct *vma) {
	return (vma->vm_start <= KSTK_ESP(t) && vma->vm_end >= KSTK_ESP(t));
}

/*
 * Check if the vma is being used as a stack.
 * If is_group is non-zero, check in the entire thread group or else
 * just check in the current task. Returns the pid of the task that
 * the vma is stack for.
 */
static pid_t my_vm_is_stack(struct task_struct *task,
	struct vm_area_struct *vma, int in_group) {
	pid_t ret = 0;

	if (vm_is_stack_for_task(task, vma))
		return task->pid;

	if (in_group) {
		struct task_struct *t;
		rcu_read_lock();
		if (!pid_alive(task))
			goto done;

		t = task;
		do {
			if (vm_is_stack_for_task(t, vma)) {
				ret = t->pid;
				goto done;
			}
		} while_each_thread(task, t);
	done:
		rcu_read_unlock();
	}

	return ret;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {

	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;
	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);
	if (!mm) {
        ret = -EINVAL;
        goto out;
	}


	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		/* We don't show the stack guard page in /proc/maps */
		if (stack_guard_page_start(vma, entry->start))
			entry->start += PAGE_SIZE;
		if (stack_guard_page_end(vma, entry->end))
			entry->end -= PAGE_SIZE;

		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				pid_t tid = my_vm_is_stack(task, vma, 1);
				if (tid != 0) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */

					sprintf(entry->path, "[stack:%d]", tid);
				}
			}

		}


		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}

#endif


#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(3,18,71)
/* Check if the vma is being used as a stack by this task */
static int vm_is_stack_for_task(struct task_struct *t,
	struct vm_area_struct *vma) {
	return (vma->vm_start <= KSTK_ESP(t) && vma->vm_end >= KSTK_ESP(t));
}


/*
 * Check if the vma is being used as a stack.
 * If is_group is non-zero, check in the entire thread group or else
 * just check in the current task. Returns the task_struct of the task
 * that the vma is stack for. Must be called under rcu_read_lock().
 */
struct task_struct *task_of_stack(struct task_struct *task,
	struct vm_area_struct *vma, bool in_group) {
	if (vm_is_stack_for_task(task, vma))
		return task;

	if (in_group) {
		struct task_struct *t;

		for_each_thread(task, t) {
			if (vm_is_stack_for_task(t, vma))
				return t;
		}
	}

	return NULL;
}


static pid_t pid_of_stack(struct task_struct *task,
	struct vm_area_struct *vma, bool is_pid) {
	pid_t ret = 0;

	rcu_read_lock();
	task = task_of_stack(task, vma, is_pid);
	if (task) {
		ret = task->pid;
	}
	rcu_read_unlock();

	return ret;
}


static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);
	if (!mm) {
        ret = -EINVAL;
        goto out;
	}

	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				pid_t tid = pid_of_stack(task, vma, 1);
				if (tid != 0) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					if (vma->vm_start <= mm->start_stack &&
						vma->vm_end >= mm->start_stack) {
						snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
					} else {
						snprintf(entry->path, sizeof(entry->path), "[stack:%d]", tid);
					}
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}

#endif



#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(3,18,140)
/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}


static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}

	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}
			}

		}

		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}


#endif



#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,4,21)
/* Check if the vma is being used as a stack by this task */
int vma_is_stack_for_task(struct vm_area_struct *vma, struct task_struct *t) {
	return (vma->vm_start <= KSTK_ESP(t) && vma->vm_end >= KSTK_ESP(t));
}

/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct task_struct *task,
	struct vm_area_struct *vma, int is_pid) {
	int stack = 0;

	if (is_pid) {
		stack = vma->vm_start <= vma->vm_mm->start_stack &&
			vma->vm_end >= vma->vm_mm->start_stack;
	} else {
		rcu_read_lock();
		stack = vma_is_stack_for_task(vma, task);
		rcu_read_unlock();
	}
	return stack;
}


static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}

	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;

		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				pid_t tid = is_stack(task, vma, 1);
				if (tid != 0) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					sprintf(entry->path, "[stack:%d]", tid);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}



#endif




#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,4,78)
/* Check if the vma is being used as a stack by this task */
int vma_is_stack_for_task(struct vm_area_struct *vma, struct task_struct *t) {
	return (vma->vm_start <= KSTK_ESP(t) && vma->vm_end >= KSTK_ESP(t));
}

/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct task_struct *task,
	struct vm_area_struct *vma, int is_pid) {
	int stack = 0;

	if (is_pid) {
		stack = vma->vm_start <= vma->vm_mm->start_stack &&
			vma->vm_end >= vma->vm_mm->start_stack;
	} else {
		rcu_read_lock();
		stack = vma_is_stack_for_task(vma, task);
		rcu_read_unlock();
	}
	return stack;
}


static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}


	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				pid_t tid = is_stack(task, vma, 1);
				if (tid != 0) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					sprintf(entry->path, "[stack:%d]", tid);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}


#endif




#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,4,153)
/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct task_struct *task,
	struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}


static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}

	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				pid_t tid = is_stack(task, vma);
				if (tid != 0) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}

#endif



#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,4,192)
/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct task_struct *task,
	struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}


static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}

	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }


	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}

		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				pid_t tid = is_stack(task, vma);
				if (tid != 0) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}


#endif



#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,9,112)
/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}



static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;
	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}

	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区
	
	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}

#endif



#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,9,186)
/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}



static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}

	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}


#endif






#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,14,83)


/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}
	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}


#endif



#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,14,117)


/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}


	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}

		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}



#endif



#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,14,141)


/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}
	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}


#endif





#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,19,81)


/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;


	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}
	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;

		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}
#endif






#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(4,19,113)

/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}
	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}
#endif

#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(5,4,61)

/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}
	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file * vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char *path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}
#endif

#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(5,10,43)

/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct* vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct* task;
	struct mm_struct* mm;
	struct vm_area_struct* vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;


	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}
	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file* vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char* path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}
#endif

#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(5,15,41)

/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct* vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct* task;
	struct mm_struct* mm;
	struct vm_area_struct* vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}
	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		struct file* vm_file;
		if (copy_pos + sizeof(*entry) >= end_pos) {
			break;
		}
		memset(entry, 0, sizeof(*entry));
		entry->start = vma->vm_start;
		entry->end   = vma->vm_end;
		entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
		entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
		entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
		entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
		memset(entry->path, 0, sizeof(entry->path));
		vm_file = get_vm_file(vma);
		if (vm_file) {
			char* path;
			memset(path_buf, 0, MY_PATH_MAX_LEN);
			path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
			if (path > 0) {
				strncat(entry->path, path, sizeof(entry->path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void *)copy_pos, entry, sizeof(*entry));
		} else {
			if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
				break;
			}
		}
		copy_pos += sizeof(*entry);
		success_cnt++;
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}
#endif

#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(6,1,75)
#include <linux/mm_inline.h>
struct anon_vma_name * __weak anon_vma_name(struct vm_area_struct* vma) {
	return NULL;
}

/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct* vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct* task;
	struct mm_struct* mm;
	struct vm_area_struct* vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}
	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}

	{
		VMA_ITERATOR(iter, mm, 0);
		for_each_vma(iter, vma) {
			struct file* vm_file;
			struct anon_vma_name *anon_name = NULL;
			if (copy_pos + sizeof(*entry) >= end_pos) {
				break;
			}
			memset(entry, 0, sizeof(*entry));
			entry->start = vma->vm_start;
			entry->end   = vma->vm_end;
			entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
			entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
			entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
			entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
			memset(entry->path, 0, sizeof(entry->path));
			vm_file = get_vm_file(vma);
			if (vm_file) {
				char* path;
				memset(path_buf, 0, MY_PATH_MAX_LEN);
				path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
				if (path > 0) {
					strncat(entry->path, path, sizeof(entry->path) - 1);
				}
			} else if (!vma->vm_mm) {
				snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
			} else if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else if (is_stack(vma)) {
				/*
				* Thread stack in /proc/PID/task/TID/maps or
				* the main process stack.
				*/

				/* Thread stack in /proc/PID/maps */
				snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
			} else {
				anon_name = anon_vma_name(vma);
				if(anon_name) {
					snprintf(entry->path, sizeof(entry->path), "[anon:%s]", anon_name->name);
				}
			}
			
			if (is_kernel_buf) {
				memcpy((void *)copy_pos, entry, sizeof(*entry));
			} else {
				if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
					break;
				}
			}
			copy_pos += sizeof(*entry);
			success_cnt++;
		}
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}
#endif


#if MY_LINUX_VERSION_CODE == KERNEL_VERSION(6,6,30)
#include <linux/mm_inline.h>
struct anon_vma_name * __weak anon_vma_name(struct vm_area_struct* vma) {
	return NULL;
}

static int get_proc_maps_list(bool is_kernel_buf, struct pid* proc_pid_struct, char* buf, size_t buf_size) {
	struct task_struct* task;
	struct mm_struct* mm;
	struct vm_area_struct* vma;
	char *path_buf = NULL;
    struct map_entry *entry = NULL;
	int success_cnt = 0;
	int ret = 0;
	size_t copy_pos;
	size_t end_pos;

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		ret = -ESRCH;
		goto out;
	}

	mm = get_task_mm(task);

	if (!mm) {
        ret = -EINVAL;
        goto out;
	}
	if (is_kernel_buf) {
		memset(buf, 0, buf_size);
	}
	//else if (clear_user(buf, buf_size)) { return -4; } //清空用户的缓冲区

	path_buf = x_kmalloc(MY_PATH_MAX_LEN, GFP_KERNEL);
    if (!path_buf) {
        ret = -ENOMEM;
        goto out_mm;
    }
    entry = x_kmalloc(sizeof(*entry), GFP_KERNEL);
    if (!entry) {
        ret = -ENOMEM;
        goto out_kpath;
    }

	copy_pos = (size_t)buf;
	end_pos = (size_t)((size_t)buf + buf_size);

	if (down_read_mmap_lock(mm) != 0) {
        ret = -EBUSY;
        goto out_kentry;
	}

	{
		VMA_ITERATOR(iter, mm, 0);
		for_each_vma(iter, vma) {
			struct file* vm_file;
			struct anon_vma_name *anon_name = NULL;
			if (copy_pos + sizeof(*entry) >= end_pos) {
				break;
			}
			memset(entry, 0, sizeof(*entry));
			entry->start = vma->vm_start;
			entry->end   = vma->vm_end;
			entry->flags[0] = (vma->vm_flags & VM_READ)     ? 1 : 0;
			entry->flags[1] = (vma->vm_flags & VM_WRITE)    ? 1 : 0;
			entry->flags[2] = (vma->vm_flags & VM_EXEC)     ? 1 : 0;
			entry->flags[3] = (vma->vm_flags & VM_MAYSHARE) ? 1 : 0;
			memset(entry->path, 0, sizeof(entry->path));
			vm_file = get_vm_file(vma);
			if (vm_file) {
				char* path;
				memset(path_buf, 0, MY_PATH_MAX_LEN);
				path = d_path(&vm_file->f_path, path_buf, MY_PATH_MAX_LEN);
				if (path > 0) {
					strncat(entry->path, path, sizeof(entry->path) - 1);
				}
			} else if (!vma->vm_mm) {
				snprintf(entry->path, sizeof(entry->path), "%s[vdso]", entry->path);
			} else if (vma_is_initial_heap(vma)) {
				snprintf(entry->path, sizeof(entry->path), "%s[heap]", entry->path);
			} else if (vma_is_initial_stack(vma)) {
				snprintf(entry->path, sizeof(entry->path), "%s[stack]", entry->path);
			} else {
				anon_name = anon_vma_name(vma);
				if(anon_name) {
					snprintf(entry->path, sizeof(entry->path), "[anon:%s]", anon_name->name);
				}
			}
				
			if (is_kernel_buf) {
				memcpy((void *)copy_pos, entry, sizeof(*entry));
			} else {
				if (x_copy_to_user((void *)copy_pos, entry, sizeof(*entry))) {
					break;
				}
			}
			copy_pos += sizeof(*entry);
			success_cnt++;
		}
	}
    up_read_mmap_lock(mm);
    ret = success_cnt;

out_kentry:
    kfree(entry);
out_kpath:
    kfree(path_buf);
out_mm:
    mmput(mm);
out:
    return ret;
}
#endif
#endif /* PROC_MAPS_H_ */
```

`rwProcMem33Module/rwProcMem_module/proc_maps_auto_offset.h`:

```h
#ifndef PROC_MAPS_AUTO_OFFSET_H_
#define PROC_MAPS_AUTO_OFFSET_H_
#include "api_proxy.h"
#include "ver_control.h"


#ifndef MM_STRUCT_MMAP_LOCK 
#if MY_LINUX_VERSION_CODE < KERNEL_VERSION(5,10,43)
#define MM_STRUCT_MMAP_LOCK mmap_sem
#endif
#if MY_LINUX_VERSION_CODE >= KERNEL_VERSION(5,10,43)
#define MM_STRUCT_MMAP_LOCK mmap_lock
#endif
#endif

static ssize_t g_mmap_lock_offset = 0;
static bool g_init_mmap_lock_offset_success = false;

static ssize_t g_map_count_offset = 0;
static bool g_init_map_count_offset_success = false;

static ssize_t g_vm_file_offset = 0;
static bool g_init_vm_file_offset_success = false;

static int get_mytask_maps_cnt(void) {
	struct task_struct * mytask = x_get_current();
	struct mm_struct * mm = get_task_mm(mytask);
	struct vm_area_struct* vma;
	int cnt = 0;
	#if MY_LINUX_VERSION_CODE < KERNEL_VERSION(6,1,0)
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		cnt++;
	}
	#else
	{
		VMA_ITERATOR(iter, mm, 0);
		for_each_vma(iter, vma) {
			cnt++;
		}
	}
	#endif
	mmput(mm);
	return cnt;
}


static int init_mmap_lock_offset(void) {
	int is_found_mmap_lock_offset = 0;
	struct task_struct * mytask = x_get_current();
	struct mm_struct * mm = get_task_mm(mytask);
	int maps_cnt = get_mytask_maps_cnt();
	if(g_init_mmap_lock_offset_success) {
		mmput(mm);
		return 0;
	}
	printk_debug(KERN_EMERG "init_mmap_lock_offset maps_cnt:%d, mm->map_count:%p:%d\n", maps_cnt, &mm->map_count, (int)mm->map_count);
	g_init_mmap_lock_offset_success = true;
	for (g_mmap_lock_offset = -80; g_mmap_lock_offset <= 80; g_mmap_lock_offset += 1) {
		char *rp;
		int val;
		ssize_t accurate_offset = (ssize_t)((size_t)&mm->MM_STRUCT_MMAP_LOCK - (size_t)mm + g_mmap_lock_offset);
		if (accurate_offset >= sizeof(struct mm_struct) - sizeof(ssize_t)) {
			mmput(mm);
			return -EFAULT;
		}
		rp = (char*)((size_t)mm + (size_t)accurate_offset);
		val = *(int*)(rp);
		printk_debug(KERN_EMERG "init_mmap_lock_offset %zd:%zd:%p:%d\n", g_mmap_lock_offset, accurate_offset, rp, val);

		if (val == maps_cnt) {
			printk_debug(KERN_EMERG "val == maps_cnt %zd:%zd:%p:%d\n", g_mmap_lock_offset, accurate_offset, rp, val);
			g_mmap_lock_offset += sizeof(val);
			g_mmap_lock_offset += sizeof(int);
			is_found_mmap_lock_offset = 1;
			break;
		}

	}


	if (!is_found_mmap_lock_offset) {
		g_init_mmap_lock_offset_success = false;
		mmput(mm);
		printk_debug(KERN_INFO "find mmap_lock offset failed\n");
		return -ESPIPE;
	}
	mmput(mm);
	printk_debug(KERN_INFO "found g_mmap_lock_offset:%zu\n", g_mmap_lock_offset);
	return 0;
}

static inline int down_read_mmap_lock(struct mm_struct *mm) {
	ssize_t accurate_offset;
	struct rw_semaphore *sem;
	if (g_init_mmap_lock_offset_success == false) {
		return -ENOENT;
	}

	accurate_offset = (ssize_t)((size_t)&mm->MM_STRUCT_MMAP_LOCK - (size_t)mm + g_mmap_lock_offset);
	printk_debug(KERN_INFO "down_read_mmap_lock accurate_offset:%zd\n", accurate_offset);
	if (accurate_offset >= sizeof(struct mm_struct) - sizeof(ssize_t)) {
		return -ERANGE;
	}
	sem = (struct rw_semaphore *)((size_t)mm + (size_t)accurate_offset);
	down_read(sem);
	return 0;
}

static inline int up_read_mmap_lock(struct mm_struct *mm) {
	ssize_t accurate_offset;
	struct rw_semaphore *sem;
	if (g_init_mmap_lock_offset_success == false) {
		return -ENOENT;
	}
	accurate_offset = (ssize_t)((size_t)&mm->MM_STRUCT_MMAP_LOCK - (size_t)mm + g_mmap_lock_offset);
	printk_debug(KERN_INFO "accurate_offset:%zd\n", accurate_offset);
	if (accurate_offset >= sizeof(struct mm_struct) - sizeof(ssize_t)) {
		return -ERANGE;
	}
	sem = (struct rw_semaphore *)((size_t)mm + (size_t)accurate_offset);

	up_read(sem);
	return 0;
}

static int init_map_count_offset(void) {
	int is_found_map_count_offset = 0;
	struct task_struct * mytask = x_get_current();
	struct mm_struct * mm = get_task_mm(mytask);
	int maps_cnt = get_mytask_maps_cnt();
	if(g_init_map_count_offset_success) {
		mmput(mm);
		return 0;
	}
	printk_debug(KERN_EMERG "init_map_count_offset maps_cnt:%d, mm->map_count:%p:%d\n", maps_cnt, &mm->map_count, (int)mm->map_count);
	
	g_init_map_count_offset_success = true;
	for (g_map_count_offset = -40; g_map_count_offset <= 40; g_map_count_offset += 1) {
		char *rp;
		int val;
		ssize_t accurate_offset = (ssize_t)((size_t)&mm->map_count - (size_t)mm + g_map_count_offset);
		if (accurate_offset >= sizeof(struct mm_struct) - sizeof(ssize_t)) {
			mmput(mm);
			return -EFAULT;
		}
		rp = (char*)((size_t)mm + (size_t)accurate_offset);
		val = *(int*)(rp);
		printk_debug(KERN_EMERG "init_map_count_offset %zd:%zd:%p:%d\n", g_map_count_offset, accurate_offset, rp, val);

		if (val == maps_cnt) {
			printk_debug(KERN_EMERG "val == maps_cnt %zd:%zd:%p:%d\n", g_map_count_offset, accurate_offset, rp, val);
			is_found_map_count_offset = 1;
			break;
		}
	}


	if (!is_found_map_count_offset) {
		g_init_map_count_offset_success = false;
		printk_debug(KERN_INFO "find map_count offset failed\n");
		mmput(mm);
		return -ESPIPE;
	}

	mmput(mm);
	printk_debug(KERN_INFO "g_map_count_offset:%zu\n", g_map_count_offset);
	return 0;
}

#if MY_LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,75)
static int init_vm_file_offset(void) {
	int is_found_vm_file_offset = 0;
	struct vm_area_struct *vma;
	struct task_struct * mytask = x_get_current();
	struct mm_struct *mm = get_task_mm(mytask);
	if(g_init_vm_file_offset_success) {
		mmput(mm);
		return 0;
	}
	if (down_read_mmap_lock(mm) != 0) {
		mmput(mm);
		return -EFAULT;
	}

	g_init_vm_file_offset_success = false;
	{
		VMA_ITERATOR(iter, mm, 0);
		for_each_vma(iter, vma) {
			if (is_found_vm_file_offset == 1) {
				break;
			}
			for (g_vm_file_offset = -80; g_vm_file_offset <= 80; g_vm_file_offset += 1) {
				char *rp;
				size_t addr_val1;
				size_t addr_val2;
				unsigned long vm_pgoff;
				ssize_t accurate_offset = (ssize_t)((size_t)&vma->vm_file - (size_t)vma + g_vm_file_offset);
				//这里故意屏蔽，因为vm_file已经接近vm_area_struct结构体尾部了
				/*if (accurate_offset >= sizeof(struct vm_area_struct) - sizeof(struct file *))
				{
					mmput(mm);
					return -EFAULT;
				}*/
				rp = (char*)((size_t)vma + (size_t)accurate_offset);
				addr_val1 = *(size_t*)(rp);
				rp += (size_t)sizeof(void*);
				addr_val2 = *(size_t*)(rp);
				printk_debug(KERN_EMERG "init_vm_file_offset %zd:%zd:%p:%zu\n", g_vm_file_offset, accurate_offset, rp, addr_val1);
				if (addr_val1 > 0 && addr_val2 > 0 && addr_val1 == addr_val2) //struct list_head anon_vma_chain;里面两个值一样
				{
					int vm_pgoff_offset = 0;
					int found_vm_pgoff = 0;

					printk_debug(KERN_EMERG "init_vm_file_offset addr_val1 == addr_val2 %zd:%zd:%p:%zu\n", g_vm_file_offset, accurate_offset, rp, addr_val1);
					rp += (size_t)sizeof(void*);
					for (; vm_pgoff_offset < 8 * 5; vm_pgoff_offset += 4) {
						vm_pgoff = *(unsigned long*)(rp);
						if (vm_pgoff > 0 && vm_pgoff < 1000/*这个值是vm_pgoff我见过的最大值吧，如果最大值比1000还有大再改大*/) {
							found_vm_pgoff = 1;
							break;
						}
						rp += 4;
					}
					if (found_vm_pgoff) {
						rp += (size_t)sizeof(unsigned long);
						rp += (size_t)sizeof(struct file *);

						addr_val1 = *(size_t*)(rp);
						rp += (size_t)sizeof(void*);
						addr_val2 = *(size_t*)(rp);

						if (addr_val1 == 0 && addr_val2 == 0) {
							g_vm_file_offset += sizeof(void*) * 2;
							g_vm_file_offset += vm_pgoff_offset;
							g_vm_file_offset += sizeof(unsigned long);
							printk_debug(KERN_EMERG "init_vm_file_offset ok, addr_val1 == addr_val2 == 0 %zd:%d\n", g_vm_file_offset, vm_pgoff_offset);
							is_found_vm_file_offset = 1;
							break;
						}

					}


				}
			}
		}
	}

	up_read_mmap_lock(mm);
	mmput(mm);

	if (!is_found_vm_file_offset) {
		printk_debug(KERN_INFO "find vm_file offset failed\n");
		return -ESPIPE;
	}
	g_init_vm_file_offset_success = true;

	return 0;
}
#else

static int init_vm_file_offset(void) {
	int is_found_vm_file_offset = 0;
	struct vm_area_struct *vma;
	struct task_struct * mytask = x_get_current();
	struct mm_struct *mm = get_task_mm(mytask);
	if(g_init_vm_file_offset_success) {
		mmput(mm);
		return 0;
	}
	if (down_read_mmap_lock(mm) != 0) {
		mmput(mm);
		return -EFAULT;
	}

	g_init_vm_file_offset_success = false;
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		if (is_found_vm_file_offset == 1) {
			//已经找到了
			break;
		}
		for (g_vm_file_offset = -80; g_vm_file_offset <= 80; g_vm_file_offset += 1) {
			char *rp;
			size_t addr_val1;
			size_t addr_val2;
			unsigned long vm_pgoff;
			ssize_t accurate_offset = (ssize_t)((size_t)&vma->vm_file - (size_t)vma + g_vm_file_offset);
			//这里故意屏蔽，因为vm_file已经接近vm_area_struct结构体尾部了
			/*if (accurate_offset >= sizeof(struct vm_area_struct) - sizeof(struct file *))
			{
				mmput(mm);
				return -EFAULT;
			}*/
			rp = (char*)((size_t)vma + (size_t)accurate_offset);
			addr_val1 = *(size_t*)(rp);
			rp += (size_t)sizeof(void*);
			addr_val2 = *(size_t*)(rp);
			printk_debug(KERN_EMERG "init_vm_file_offset %zd:%zd:%p:%zu\n", g_vm_file_offset, accurate_offset, rp, addr_val1);
			if (addr_val1 > 0 && addr_val2 > 0 && addr_val1 == addr_val2) //struct list_head anon_vma_chain;里面两个值一样
			{
				int vm_pgoff_offset = 0;
				int found_vm_pgoff = 0;

				printk_debug(KERN_EMERG "init_vm_file_offset addr_val1 == addr_val2 %zd:%zd:%p:%zu\n", g_vm_file_offset, accurate_offset, rp, addr_val1);
				rp += (size_t)sizeof(void*);
				for (; vm_pgoff_offset < 8 * 5; vm_pgoff_offset += 4) {
					vm_pgoff = *(unsigned long*)(rp);
					if (vm_pgoff > 0 && vm_pgoff < 1000/*这个值是vm_pgoff我见过的最大值吧，如果最大值比1000还有大再改大*/) {
						found_vm_pgoff = 1;
						break;
					}
					rp += 4;
				}
				if (found_vm_pgoff) {
					rp += (size_t)sizeof(unsigned long);
					rp += (size_t)sizeof(struct file *);

					addr_val1 = *(size_t*)(rp);
					rp += (size_t)sizeof(void*);
					addr_val2 = *(size_t*)(rp);

					if (addr_val1 == 0 && addr_val2 == 0) {
						g_vm_file_offset += sizeof(void*) * 2;
						g_vm_file_offset += vm_pgoff_offset;
						g_vm_file_offset += sizeof(unsigned long);
						printk_debug(KERN_EMERG "init_vm_file_offset ok, addr_val1 == addr_val2 == 0 %zd:%d\n", g_vm_file_offset, vm_pgoff_offset);
						is_found_vm_file_offset = 1;
						break;
					}

				}


			}
		}
	}

	up_read_mmap_lock(mm);
	mmput(mm);

	if (!is_found_vm_file_offset) {	
		printk_debug(KERN_INFO "find vm_file offset failed\n");
		return -ESPIPE;
	}
	g_init_vm_file_offset_success = true;
	return 0;
}
#endif

static inline struct file * get_vm_file(struct vm_area_struct *vma) {
	struct file * vm_file;
	ssize_t accurate_offset;
	if (g_init_vm_file_offset_success == false) {
		if (init_vm_file_offset() != 0) {
			return NULL;
		}
	}

	accurate_offset = (ssize_t)((size_t)&vma->vm_file - (size_t)vma + g_vm_file_offset);
	printk_debug(KERN_INFO "get_vm_file accurate_offset:%zd\n", accurate_offset);
	//这里故意屏蔽，因为vm_file已经接近vm_area_struct结构体尾部了
	//if (accurate_offset >= sizeof(struct vm_area_struct) - sizeof(struct file *))
	//{
	//	return NULL;
	//}
	vm_file = (struct file*) *(size_t*)((size_t)vma + (size_t)accurate_offset);
	return vm_file;
}
#endif /* PROC_MAPS_AUTO_OFFSET_H_ */
```

`rwProcMem33Module/rwProcMem_module/proc_root.h`:

```h
#ifndef PROC_ROOT_H_
#define PROC_ROOT_H_
#include <linux/ctype.h>
#include <linux/cred.h>
#include "proc_root_auto_offset.h"
#include "ver_control.h"
//声明
//////////////////////////////////////////////////////////////////////////
static inline int set_process_root(struct pid* proc_pid_struct);


//实现
//////////////////////////////////////////////////////////////////////////
static uint64_t get_cap_ability_max(void) {

#if MY_LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
	uint64_t cap_default = 0x3FFFFFFFFF;
#elif MY_LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
	uint64_t cap_default = 0xFFFFFFFFFF;
#else
	uint64_t cap_default = 0x1FFFFFFFFFF;
#endif

	return cap_default;
}

static inline int set_process_root(struct pid* proc_pid_struct) {
	if (g_init_real_cred_offset_success == false) {
		return -ENOENT;
	}

	if (g_init_real_cred_offset_success) {
		struct task_struct * task = NULL;
		struct cred * cred = NULL;
		char *pCred = NULL;
		task = pid_task(proc_pid_struct, PIDTYPE_PID);
		if (!task) { return -1; }

		pCred = (char*)&task->real_cred;

		pCred += g_real_cred_offset;
		pCred += sizeof(void*);
		cred = (struct cred *)*(size_t*)pCred;
		if (cred) {
			uint64_t cap = get_cap_ability_max();
			cred->uid = cred->suid = cred->euid = cred->fsuid = GLOBAL_ROOT_UID;
			cred->gid = cred->sgid = cred->egid = cred->fsgid = GLOBAL_ROOT_GID;
			memcpy(&cred->cap_inheritable, &cap, sizeof(cap));
			memcpy(&cred->cap_permitted, &cap, sizeof(cap));
			memcpy(&cred->cap_effective, &cap, sizeof(cap));
			memcpy(&cred->cap_bset, &cap, sizeof(cap));
			memcpy(&cred->cap_ambient, &cap, sizeof(cap));
			return 0;
		}
		return -EBADF;

	}
	return -ESPIPE;

}
#endif /* PROC_ROOT_H_ */



```

`rwProcMem33Module/rwProcMem_module/proc_root_auto_offset.h`:

```h
#ifndef PROC_ROOT_AUTO_OFFSET_H_
#define PROC_ROOT_AUTO_OFFSET_H_
#include <linux/ctype.h>
#include "ver_control.h"

static ssize_t g_real_cred_offset = 0;
static bool g_init_real_cred_offset_success = false;

static inline int init_proc_root_offset(const char* my_name) {
	const ssize_t offset_lookup_min = -100;
	const ssize_t offset_lookup_max = 300;

	const ssize_t min_real_cred_offset_limit = offset_lookup_min + sizeof(void*) * 3;

	if(g_init_real_cred_offset_success) {
		return 0;
	}
	
	g_init_real_cred_offset_success = false;
	for (g_real_cred_offset = offset_lookup_min; g_real_cred_offset <= offset_lookup_max; g_real_cred_offset++) {

		char* pcomm = (char*)&current->real_cred;
		pcomm += g_real_cred_offset;

		printk_debug(KERN_EMERG "curent g_real_cred_offset:%zd, bytes:%x\n", g_real_cred_offset, *(unsigned char*)pcomm);

		if(g_real_cred_offset < min_real_cred_offset_limit) {
			continue;
		}
		if (strcmp(pcomm, my_name) == 0) {
			ssize_t maybe_real_cred_offset = g_real_cred_offset - sizeof(void*) * 2;
			char * p_test_mem1 = (char*)&current->real_cred + maybe_real_cred_offset;
			char * p_test_mem2 = (char*)&current->real_cred + maybe_real_cred_offset + sizeof(void*); // for get cred *cred;
			if(memcmp(p_test_mem1, p_test_mem2, sizeof(void*)) != 0 ) { // becasuse the real_cred is equal the cred
				maybe_real_cred_offset = g_real_cred_offset - sizeof(void*) * 3;
				p_test_mem1 = (char*)&current->real_cred + maybe_real_cred_offset;
				p_test_mem2 = (char*)&current->real_cred + maybe_real_cred_offset + sizeof(void*); // for get cred *cred;
				if(memcmp(p_test_mem1, p_test_mem2, sizeof(void*)) != 0 ) { // becasuse the real_cred is equal the cred
					break; // failed
				}
			}
			g_real_cred_offset = maybe_real_cred_offset;

			printk_debug(KERN_EMERG "strcmp found %zd\n", g_real_cred_offset);

			g_init_real_cred_offset_success = true;
			break;
		}

	}

	if (!g_init_real_cred_offset_success) {
		printk_debug(KERN_INFO "real_cred offset failed\n");
		return -ESPIPE;
	}
	printk_debug(KERN_INFO "g_real_cred_offset:%zu\n", g_real_cred_offset);
	return 0;
}
#endif /* PROC_ROOT_AUTO_OFFSET_H_ */



```

`rwProcMem33Module/rwProcMem_module/proc_rss.h`:

```h
#ifndef PROC_RSS_H_
#define PROC_RSS_H_
//声明
//////////////////////////////////////////////////////////////////////////
#include <linux/pid.h>
#include "api_proxy.h"
#include "ver_control.h"
static size_t read_proc_rss_size(struct pid* proc_pid_struct);

//实现
//////////////////////////////////////////////////////////////////////////
#include "proc_cmdline_auto_offset.h"
static size_t read_proc_rss_size(struct pid* proc_pid_struct) {
	struct task_struct *task;
	struct mm_struct *mm;
	size_t total_rss;
	ssize_t offset;
	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		return 0;
	}
	mm = get_task_mm(task);
	if(!mm) {
		return 0;
	}
	offset = g_init_arg_start_offset_success ? g_arg_start_offset : 0;
	total_rss = x_read_mm_struct_rss(mm, offset);
	mmput(mm);
	return total_rss;

}
#endif /* PROC_RSS_H_ */

```

`rwProcMem33Module/rwProcMem_module/rwProcMem_module.c`:

```c
#include "rwProcMem_module.h"

#define MY_TASK_COMM_LEN 16

#pragma pack(push,1)
struct ioctl_request {
    char     cmd;        /* 1 字节命令 */
    uint64_t param1;     /* 参数1 */
    uint64_t param2;     /* 参数2 */
    uint64_t param3;     /* 参数3 */
    uint64_t buf_size;    /* 紧随其后的动态数据长度 */
};
struct init_device_info {
	int pid;
	int tgid;
	char my_name[MY_TASK_COMM_LEN + 1];
	char my_auxv[1024];
	int my_auxv_size;
};
struct arg_info {
	uint64_t arg_start;
	uint64_t arg_end;
};
#pragma pack(pop)

static ssize_t OnCmdInitDeviceInfo(struct ioctl_request *hdr, char __user* buf) {
	long err = 0;
	struct init_device_info* pinit_device_info = (struct init_device_info*)x_kmalloc(sizeof(struct init_device_info), GFP_KERNEL);
	if (!pinit_device_info) {
		return -ENOMEM;
	}
	printk_debug(KERN_INFO "CMD_INIT_DEVICE_INFO\n");
	memset(pinit_device_info, 0, sizeof(struct init_device_info));
	if (x_copy_from_user((void*)pinit_device_info, (void*)buf, sizeof(struct init_device_info)) == 0) {
		printk_debug(KERN_INFO "my_name:%s\n", pinit_device_info->my_name);
		printk_debug(KERN_INFO "pid:%d, tgid:%d\n", pinit_device_info->pid, pinit_device_info->tgid);
		printk_debug(KERN_INFO "my_auxv_size:%d\n", pinit_device_info->my_auxv_size);
		
		do {
			err = init_mmap_lock_offset();
			if(err) { break; }
			err = init_map_count_offset();
			if(err) { break; }
			err = init_proc_cmdline_offset(&pinit_device_info->my_auxv[0], pinit_device_info->my_auxv_size);
			if(err) { break; }
			err = init_proc_root_offset(pinit_device_info->my_name);
			if(err) { break; }
			err = init_task_next_offset();
			if(err) { break; }
			err = init_task_pid_offset(pinit_device_info->pid, pinit_device_info->tgid);
		} while(0);
	} else {
		err = -EINVAL;
	}
	kfree(pinit_device_info);
	return err;
}

static ssize_t OnCmdOpenProcess(struct ioctl_request *hdr, char __user* buf) {
	uint64_t pid = hdr->param1, handle = 0;
	struct pid * proc_pid_struct = NULL;
	printk_debug(KERN_INFO "CMD_OPEN_PROCESS\n");

	printk_debug(KERN_INFO "pid:%llu,size:%ld\n", pid, sizeof(pid));

	proc_pid_struct = get_proc_pid_struct(pid);
	printk_debug(KERN_INFO "proc_pid_struct *:0x%p\n", (void*)proc_pid_struct);
	if (!proc_pid_struct) {
		return -EINVAL;
	}
	handle = (uint64_t)proc_pid_struct;

	printk_debug(KERN_INFO "handle:%llu,size:%ld\n", handle, sizeof(handle));
	if (!!x_copy_to_user((void*)buf, (void*)&handle, sizeof(handle))) {
		return -EINVAL;
	}
	return 0;
}

static ssize_t OnCmdCloseProcess(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	printk_debug(KERN_INFO "CMD_CLOSE_PROCESS\n");
	printk_debug(KERN_INFO "proc_pid_struct*:0x%p,size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));
	release_proc_pid_struct(proc_pid_struct);
	return 0;
}

static ssize_t OnCmdReadProcessMemory(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	size_t proc_virt_addr = (size_t)hdr->param2;
	bool is_force_read = hdr->param3 == 1 ? true : false;
	size_t size = (size_t)hdr->buf_size;
	size_t read_size = 0;

	printk_debug(KERN_INFO "CMD_READ_PROCESS_MEMORY\n");

	printk_debug(KERN_INFO "READ proc_pid_struct*:0x%p,size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));

	printk_debug(KERN_INFO "READ proc_virt_addr:0x%zx,size:%ld\n", proc_virt_addr, sizeof(proc_virt_addr));

	if (is_force_read == false && !check_proc_map_can_read(proc_pid_struct, proc_virt_addr, size)) {
		return -EFAULT;
	}

	while (read_size < size) {
		size_t phy_addr = 0;
		size_t pfn_sz = 0;
		char *lpOutBuf = NULL;
		pte_t *pte;

		bool old_pte_can_read;
		phy_addr = get_proc_phy_addr(proc_pid_struct, proc_virt_addr + read_size, &pte);
		printk_debug(KERN_INFO "calc phy_addr:0x%zx\n", phy_addr);

		if (phy_addr == 0) {
			break;
		}

		old_pte_can_read = is_pte_can_read(pte);
		if (is_force_read) {
			if (!old_pte_can_read) {
				if (!change_pte_read_status(pte, true)) { break; }

			}
		} else if (!old_pte_can_read) {
			break;
		} 

		pfn_sz = size_inside_page(phy_addr, ((size - read_size) > PAGE_SIZE) ? PAGE_SIZE : (size - read_size));
		printk_debug(KERN_INFO "pfn_sz:%zu\n", pfn_sz);


		lpOutBuf = (char*)(buf + read_size);
		read_ram_physical_addr(false, phy_addr, lpOutBuf, pfn_sz);

		if (is_force_read && old_pte_can_read == false) {
			change_pte_read_status(pte, false);
		}
		read_size += pfn_sz;
	}
	return read_size;
}

static ssize_t OnCmdWriteProcessMemory(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	size_t proc_virt_addr = (size_t)hdr->param2;
	bool is_force_write = hdr->param3 == 1 ? true : false;
	size_t size = (size_t)hdr->buf_size;
	size_t write_size = 0;
	printk_debug(KERN_INFO "CMD_WRITE_PROCESS_MEMORY\n");
	printk_debug(KERN_INFO "WRITE proc_pid_struct*:0x%p,size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));
	printk_debug(KERN_INFO "WRITE proc_virt_addr:0x%zx,size:%ld\n", proc_virt_addr, sizeof(proc_virt_addr));

	if (is_force_write == false && !check_proc_map_can_write(proc_pid_struct, proc_virt_addr, size)) {
		return -EFAULT;
	}

	while (write_size < size) {
		size_t phy_addr = 0;
		size_t pfn_sz = 0;
		char * input_buf = NULL;

		pte_t *pte;
		bool old_pte_can_write;
		phy_addr = get_proc_phy_addr(proc_pid_struct, proc_virt_addr + write_size, &pte);
		printk_debug(KERN_INFO "phy_addr:0x%zx\n", phy_addr);
		if (phy_addr == 0) {
			break;
		}

		old_pte_can_write = is_pte_can_write(pte);
		if (is_force_write) {
			if (!old_pte_can_write) {
				if (!change_pte_write_status(pte, true)) { break; }
			}
		} else if (!old_pte_can_write) {
			break;
		}

		pfn_sz = size_inside_page(phy_addr, ((size - write_size) > PAGE_SIZE) ? PAGE_SIZE : (size - write_size));
		printk_debug(KERN_INFO "pfn_sz:%zu\n", pfn_sz);

		input_buf = (char*)(((size_t)buf + write_size));
		write_ram_physical_addr(phy_addr, input_buf, false, pfn_sz);
		if (is_force_write && old_pte_can_write == false) {
			change_pte_write_status(pte, false);
		}

		write_size += pfn_sz;
	}
	return write_size;
}

static ssize_t OnCmdGetProcessMapsCount(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	printk_debug(KERN_INFO "CMD_GET_PROCESS_MAPS_COUNT\n");
	printk_debug(KERN_INFO "proc_pid_struct*:0x%p, size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));

	return get_proc_map_count(proc_pid_struct);
}

static ssize_t OnCmdGetProcessMapsList(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	printk_debug(KERN_INFO "CMD_GET_PROCESS_MAPS_LIST\n");
	printk_debug(KERN_INFO "proc_pid_struct*:0x%p,size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));
	printk_debug(KERN_INFO "buf_size:%llu\n", hdr->buf_size);
	return get_proc_maps_list(false, proc_pid_struct, (void*)(buf), hdr->buf_size - 1);
}

static ssize_t OnCmdCheckProcessPhyAddr(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	size_t proc_virt_addr = (size_t)hdr->param2;
	pte_t *pte;
	printk_debug(KERN_INFO "CMD_CHECK_PROCESS_ADDR_PHY\n");
	printk_debug(KERN_INFO "proc_pid_struct *:0x%p,size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));
	printk_debug(KERN_INFO "proc_virt_addr :0x%zx\n", proc_virt_addr);
	if (get_proc_phy_addr(proc_pid_struct, proc_virt_addr, &pte)) {
		return 1;
	}
	return 0;
}

static ssize_t OnCmdGetPidList(struct ioctl_request *hdr, char __user* buf) {
	printk_debug(KERN_INFO "CMD_GET_PID_LIST\n");
	printk_debug(KERN_INFO "buf_size:%llu\n", hdr->buf_size);
	return get_proc_pid_list(false, buf, hdr->buf_size);
}

static ssize_t OnCmdSetProcessRoot(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	printk_debug(KERN_INFO "CMD_SET_PROCESS_ROOT\n");
	printk_debug(KERN_INFO "proc_pid_struct*:0x%p,size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));
	return set_process_root(proc_pid_struct);
}

static ssize_t OnCmdGetProcessRss(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	uint64_t rss = 0;
	printk_debug(KERN_INFO "CMD_GET_PROCESS_RSS\n");
	printk_debug(KERN_INFO "proc_pid_struct*:0x%p,size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));
	rss = read_proc_rss_size(proc_pid_struct);
	if (!!x_copy_to_user((void*)buf, &rss, sizeof(rss))) {
		return -EINVAL;
	}
	return 0;
}

static ssize_t OnCmdGetProcessCmdlineAddr(struct ioctl_request *hdr, char __user* buf) {
	struct pid * proc_pid_struct = (struct pid *)hdr->param1;
	size_t arg_start = 0, arg_end = 0;
	int res;
	struct arg_info aginfo = {0};
	printk_debug(KERN_INFO "CMD_GET_PROCESS_CMDLINE_ADDR\n");
	printk_debug(KERN_INFO "proc_pid_struct *:0x%p,size:%ld\n", (void*)proc_pid_struct, sizeof(proc_pid_struct));
	res = get_proc_cmdline_addr(proc_pid_struct, &arg_start, &arg_end);
	aginfo.arg_start = (uint64_t)arg_start;
	aginfo.arg_end = (uint64_t)arg_end;
	if (!!x_copy_to_user((void*)buf, &aginfo, sizeof(aginfo))) {
		return -EINVAL;
	}
	return res;
}

static ssize_t OnCmdHideKernelModule(struct ioctl_request *hdr, char __user* buf) {
	printk_debug(KERN_INFO "CMD_HIDE_KERNEL_MODULE\n");

	if (g_rwProcMem_devp->is_hidden_module == false) {
		g_rwProcMem_devp->is_hidden_module = true; 
		list_del_init(&__this_module.list);
		kobject_del(&THIS_MODULE->mkobj.kobj);
	}
	return 0;
}

static inline ssize_t DispatchCommand(struct ioctl_request *hdr, char __user* buf) {
	switch (hdr->cmd) {
	case CMD_INIT_DEVICE_INFO:
		return OnCmdInitDeviceInfo(hdr, buf);
	case CMD_OPEN_PROCESS:
		return OnCmdOpenProcess(hdr, buf);
	case CMD_READ_PROCESS_MEMORY:
		return OnCmdReadProcessMemory(hdr, buf);
	case CMD_WRITE_PROCESS_MEMORY:
		return OnCmdWriteProcessMemory(hdr, buf);
	case CMD_CLOSE_PROCESS:
		return OnCmdCloseProcess(hdr, buf);
	case CMD_GET_PROCESS_MAPS_COUNT:
		return OnCmdGetProcessMapsCount(hdr, buf);
	case CMD_GET_PROCESS_MAPS_LIST:
		return OnCmdGetProcessMapsList(hdr, buf);
	case CMD_CHECK_PROCESS_ADDR_PHY:
		return OnCmdCheckProcessPhyAddr(hdr, buf);
	case CMD_GET_PID_LIST:
		return OnCmdGetPidList(hdr, buf);
	case CMD_SET_PROCESS_ROOT:
		return OnCmdSetProcessRoot(hdr, buf);
	case CMD_GET_PROCESS_RSS:
		return OnCmdGetProcessRss(hdr, buf);
	case CMD_GET_PROCESS_CMDLINE_ADDR:
		return OnCmdGetProcessCmdlineAddr(hdr, buf);
	case CMD_HIDE_KERNEL_MODULE:
		return OnCmdHideKernelModule(hdr, buf);
	default:
		return -EINVAL;
	}
	return -EINVAL;
}

static ssize_t rwProcMem_read(struct file* filp,
                              char __user* buf,
                              size_t size,
                              loff_t* ppos) {
    struct ioctl_request hdr = {0};
    size_t header_size = sizeof(hdr);

    if (size < header_size) {
        return -EINVAL;
    }

    if (x_copy_from_user(&hdr, buf, header_size)) {
        return -EFAULT;
    }

    if (size < header_size + hdr.buf_size) {
        return -EINVAL;
    }

    return DispatchCommand(&hdr, buf + header_size);
}

static int rwProcMem_dev_init(void) {
	g_rwProcMem_devp = x_kmalloc(sizeof(struct rwProcMemDev), GFP_KERNEL);
	memset(g_rwProcMem_devp, 0, sizeof(struct rwProcMemDev));

#ifdef CONFIG_USE_PROC_FILE_NODE
	g_rwProcMem_devp->proc_parent = proc_mkdir(CONFIG_PROC_NODE_AUTH_KEY, NULL);
	if(g_rwProcMem_devp->proc_parent) {
		g_rwProcMem_devp->proc_entry = proc_create(CONFIG_PROC_NODE_AUTH_KEY, S_IRUGO | S_IWUGO, g_rwProcMem_devp->proc_parent, &rwProcMem_proc_ops);
		start_hide_procfs_dir(CONFIG_PROC_NODE_AUTH_KEY);
	}
#endif

#ifdef CONFIG_DEBUG_PRINTK
	printk(KERN_EMERG "Hello, %s debug\n", CONFIG_PROC_NODE_AUTH_KEY);
	//test1();
	//test2();
	//test3();
	//test4();
	//test5();
#else
	printk(KERN_EMERG "Hello\n");
#endif
	return 0;
}

static void rwProcMem_dev_exit(void) {
#ifdef CONFIG_USE_PROC_FILE_NODE
	if(g_rwProcMem_devp->proc_entry) {
		proc_remove(g_rwProcMem_devp->proc_entry);
		g_rwProcMem_devp->proc_entry = NULL;
	}
	
	if(g_rwProcMem_devp->proc_parent) {
		proc_remove(g_rwProcMem_devp->proc_parent);
		g_rwProcMem_devp->proc_parent = NULL;
	}
	stop_hide_procfs_dir();
#endif
	kfree(g_rwProcMem_devp);
	printk(KERN_EMERG "Goodbye\n");
}

int __init init_module(void) {
    return rwProcMem_dev_init();
}

void __exit cleanup_module(void) {
    rwProcMem_dev_exit();
}

#ifndef CONFIG_MODULE_GUIDE_ENTRY
//Hook:__cfi_check_fn
unsigned char* __check_(unsigned char* result, void *ptr, void *diag)
{
	printk_debug(KERN_EMERG "my__cfi_check_fn!!!\n");
	return result;
}

//Hook:__cfi_check_fail
unsigned char * __check_fail_(unsigned char *result)
{
	printk_debug(KERN_EMERG "my__cfi_check_fail!!!\n");
	return result;
}
#endif

unsigned long __stack_chk_guard;

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Linux");
MODULE_DESCRIPTION("Linux default module");


```

`rwProcMem33Module/rwProcMem_module/rwProcMem_module.h`:

```h
#ifndef RWPROCMEM_H_
#define RWPROCMEM_H_
#include <linux/module.h>
#include <linux/list.h>
#include <linux/types.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/mm.h>
#include <linux/sched.h>
#include <linux/init.h>
#include <asm/io.h>
#include <asm/uaccess.h>
#include <linux/uaccess.h>
#include <linux/kernel.h>
#include <linux/version.h>

#include "api_proxy.h"
#include "phy_mem.h"
#include "proc_maps.h"
#include "proc_list.h"
#include "proc_root.h"
#include "proc_rss.h"
#include "proc_cmdline.h"
#include "ver_control.h"
#include "test.h"
#ifdef CONFIG_USE_PROC_FILE_NODE
#include <linux/proc_fs.h>
#include "hide_procfs_dir.h"
#endif
//////////////////////////////////////////////////////////////////

enum {
	CMD_INIT_DEVICE_INFO = 1, 		// 初始化设备信息
	CMD_OPEN_PROCESS, 				// 打开进程
	CMD_READ_PROCESS_MEMORY,       	// 读取进程内存
    CMD_WRITE_PROCESS_MEMORY,      	// 写入进程内存
	CMD_CLOSE_PROCESS, 				// 关闭进程
	CMD_GET_PROCESS_MAPS_COUNT, 	// 获取进程的内存块地址数量
	CMD_GET_PROCESS_MAPS_LIST, 		// 获取进程的内存块地址列表
	CMD_CHECK_PROCESS_ADDR_PHY,		// 检查进程内存是否有物理内存位置
	CMD_GET_PID_LIST,				// 获取进程PID列表
	CMD_SET_PROCESS_ROOT,			// 提升进程权限到Root
	CMD_GET_PROCESS_RSS,			// 获取进程的物理内存占用大小
	CMD_GET_PROCESS_CMDLINE_ADDR,	// 获取进程cmdline的内存地址
	CMD_HIDE_KERNEL_MODULE,			// 隐藏驱动
};

//////////////////////////////////////////////////////////////////
//rwProcMemDev设备结构体
struct rwProcMemDev {
#ifdef CONFIG_USE_PROC_FILE_NODE
	struct proc_dir_entry *proc_parent;
	struct proc_dir_entry *proc_entry;
#endif
	bool is_hidden_module; //是否已经隐藏过驱动列表了
};
static struct rwProcMemDev *g_rwProcMem_devp;

static ssize_t rwProcMem_read(struct file* filp, char __user* buf, size_t size, loff_t* ppos);
static const struct proc_ops rwProcMem_proc_ops = {
    .proc_read    = rwProcMem_read,
};

#endif /* RWPROCMEM_H_ */
```

`rwProcMem33Module/rwProcMem_module/test.h`:

```h
#ifndef TEST_H_
#define TEST_H_
#include "phy_mem.h"
#include "proc_maps.h"
#include "proc_list.h"
#include "proc_cmdline.h"
#include "proc_rss.h"
#include "ver_control.h"

//
//static void test1(void) {
//	size_t phy_addr;
//	struct file * pFile = open_pagemap(14861);
//	printk(KERN_INFO "open_pagemap %d\n", pFile);
//	if (pFile) {
//		phy_addr = get_pagemap_phy_addr(pFile, 0x10106000);
//		printk(KERN_INFO "pagemap phy_addr 0x%llx\n", phy_addr);
//
//		char buf[4];
//		size_t ret;
//		memset(buf, 0, 4);
//		read_ram_physical_addr(true, &ret, phy_addr, buf, 4);
//		if (ret) {
//			int i;
//			for (i = 0; i < 4; i++) {
//				printk(KERN_INFO "[%d]0x%x ", i, buf[i]);
//			}
//		}
//		close_pagemap(pFile);
//	}
//}
//
///*
//static void test2(void)
//{
//	struct pid * proc_pid_struct = get_proc_pid_struct(14861);
//	int map_count = get_proc_map_count(proc_pid_struct);
//	printk(KERN_INFO "map_count:%d\n", map_count);
//
//	char test[8 + 8 + 4 + 4096] = { 0 };
//	get_proc_maps_list(proc_pid_struct, 4096, &test,sizeof(test), true, NULL);
//
//	printk("start:0x%lx,end:0x%lx,flags:%x%x%x%x,name:%s\n",
//		*(unsigned long*)&test[0],
//		*(unsigned long*)&test[8],
//		*(unsigned char*)&test[16],
//		*(unsigned char*)&test[17],
//		*(unsigned char*)&test[18],
//		*(unsigned char*)&test[19],
//		&test[20]);
//
//
//	release_proc_pid_struct(proc_pid_struct);
//
//}
//*/
//
//static void test3(void) {
//	struct pid * proc_pid_struct = get_proc_pid_struct(14861);
//	printk(KERN_INFO "test3 get_proc_pid_struct:%ld\n", proc_pid_struct);
//	if (proc_pid_struct) {
//		size_t phy_addr = 0;
//		pte_t *pte;
//		get_proc_phy_addr(&phy_addr, proc_pid_struct, 0x10106000, &pte);
//		printk(KERN_INFO "calc phy_addr:0x%llx\n", phy_addr);
//
//		release_proc_pid_struct(proc_pid_struct);
//	}
//
//}
//
//static void test4(void) { //TODO cmdline offset. }
//
//static void test5(void) {
//	int *pid = x_kmalloc(sizeof(int) * 100, GFP_KERNEL);
//	int i = 0;
//	int count = get_proc_pid_list(true, (char*)pid, sizeof(int) * 100);
//	printk(KERN_INFO "test5 count:%d\n", count);
//
//	for (i = 0; i < 100; i++) {
//		if (!!pid[i]) {
//			printk(KERN_INFO "test5 pid[%d]:%d\n", i, pid[i]);
//		}
//	}
//
//
//	kfree(pid);
//
//}
//
//static void test6(void) {
//	int ret = 0;
//	struct pid * proc_pid_struct = get_proc_pid_struct(17597);
//
//	printk(KERN_INFO "test6 get_proc_pid_struct:%ld\n", proc_pid_struct);
//
//	ret = set_process_root(proc_pid_struct);
//
//	printk(KERN_INFO "test6 ret:%d\n", ret);
//
//	release_proc_pid_struct(proc_pid_struct);
//
//}
//
//static void test7(void) {
//	struct pid * proc_pid_struct = get_proc_pid_struct(11533);
//	size_t ret = read_proc_rss_size(proc_pid_struct);
//
//	printk(KERN_INFO "test7 get_proc_pid_struct:%ld, ret:%zu\n", proc_pid_struct, ret);
//
//	release_proc_pid_struct(proc_pid_struct);
//
//}
//
//static void test8(void) {
//	struct pid * proc_pid_struct = get_proc_pid_struct(17597);
//	printk(KERN_INFO "test8 get_proc_pid_struct:%ld\n", proc_pid_struct);
//	if (proc_pid_struct) {
//		size_t arg_start = 0, arg_end = 0;
//		int res = get_proc_cmdline_addr(proc_pid_struct, &arg_start, &arg_end);
//		printk(KERN_INFO "test8 get_proc_cmdline_addr arg_start:0x%llx arg_end:0x%llx\n", arg_start, arg_end);
//		release_proc_pid_struct(proc_pid_struct);
//	}
//
//}
//
//static void test9(void) {
//	struct pid * proc_pid_struct = get_proc_pid_struct(14861);
//	printk(KERN_INFO "test9 get_proc_pid_struct:%ld\n", proc_pid_struct);
//	if (proc_pid_struct) {
//
//		//set_process_root(proc_pid_struct);
//
//		release_proc_pid_struct(proc_pid_struct);
//	}
//
//}

#endif /* TEST_H_ */
```

`rwProcMem33Module/rwProcMem_module/ver_control.h`:

```h
#ifndef VERSION_CONTROL_H_
#define VERSION_CONTROL_H_

// 独立内核模块入口模式
#define CONFIG_MODULE_GUIDE_ENTRY

// 生成proc用户层交互节点文件
#define CONFIG_USE_PROC_FILE_NODE
// 隐蔽通信密钥
#define CONFIG_PROC_NODE_AUTH_KEY "e84523d7b60d5d341a7c4d1861773ecd"

// 打印内核调试信息
//#define CONFIG_DEBUG_PRINTK

#ifndef KERNEL_VERSION
#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
#endif
#ifndef MY_LINUX_VERSION_CODE 
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(3,10,0)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(3,10,84)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(3,18,71)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(3,18,140)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,4,21)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,4,78)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,4,153)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,4,192)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,9,112)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,9,186)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,14,83)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,14,117)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,14,141)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,19,81)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(4,19,113)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(5,4,61)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(5,10,43)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(5,15,41)
//#define MY_LINUX_VERSION_CODE KERNEL_VERSION(6,1,75)
#define MY_LINUX_VERSION_CODE KERNEL_VERSION(6,6,30)
#endif

#ifdef CONFIG_DEBUG_PRINTK
#define printk_debug printk
#else
static inline void printk_debug(char *fmt, ...) {}
#endif

#endif /* VERSION_CONTROL_H_ */

```

`rwProcMem33Module/testCEServer/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_CPPFLAGS += -std=c++20
LOCAL_CFLAGS += -fPIE
LOCAL_CFLAGS += -fvisibility=hidden
LOCAL_LDFLAGS += -fPIE -pie
LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true
LOCAL_MODULE    := testCEServer
LOCAL_SRC_FILES :=  testCEServer.cpp api.cpp porthelp.cpp native-api.cpp symbols.cpp
LOCAL_LDLIBS := -lz -llog
include $(BUILD_EXECUTABLE)

```

`rwProcMem33Module/testCEServer/jni/Application.mk`:

```mk
APP_ABI := arm64-v8a
APP_STL := c++_static
APP_CPPFLAGS := -frtti
```

`rwProcMem33Module/testCEServer/jni/api.cpp`:

```cpp
#include "api.h"
#include <malloc.h>
#include <sstream>
#include <memory>
#include <random>
#include <dirent.h>
#include <fcntl.h>
#include <inttypes.h>
#include <cinttypes>
#include "ceserver.h"
#include "../../testKo/jni/MemoryReaderWriter39.h"

CMemoryReaderWriter g_driver;

BOOL CApi::InitReadWriteDriver(const char* procNodeAuthKey, BOOL bUseBypassSELinuxMode) {
	printf("Connecting rwDriver:%s\n", procNodeAuthKey);
	//连接驱动
	int err = g_driver.ConnectDriver(procNodeAuthKey);
	if (err) {
		printf("Connect rwDriver failed. error:%d\n", err);
		fflush(stdout);
		return FALSE;
	}
	return TRUE;

}


//获取进程列表信息
//BOOL GetProcessListInfo(CMemoryReaderWriter* pDriver, BOOL bGetPhyMemorySize, std::vector<MyProcessInfo>& vOutput) {
//	//驱动_获取进程PID列表
//	std::vector<int> vPID;
//	BOOL bOutListCompleted;
//	BOOL b = pDriver->GetProcessPidList(vPID, FALSE, bOutListCompleted);
//	printf("Call GetProcessPidList return:%d\n", b);
//	if (b == FALSE) {
//		return FALSE;
//	}
//	//打印进程列表信息
//	for (int pid : vPID) {
//		uint64_t hProcess = pDriver->OpenProcess(pid);
//		if (!hProcess) { continue; }
//
//		MyProcessInfo pInfo = { 0 };
//		pInfo.pid = pid;
//		if (bGetPhyMemorySize) {
//			uint64_t outRss = 0;
//			pDriver->GetProcessPhyMemSize(hProcess, outRss);
//			pInfo.total_rss = outRss;
//		}
//		char cmdline[200] = { 0 };
//		pDriver->GetProcessCmdline(hProcess, cmdline, sizeof(cmdline));
//		pInfo.cmdline = cmdline;
//
//		pDriver->CloseHandle(hProcess);
//
//		vOutput.push_back(pInfo);
//	}
//	return TRUE;
//}
BOOL GetProcessListInfo(CMemoryReaderWriter* pDriver, BOOL bGetPhyMemorySize, std::vector<MyProcessInfo>& vOutput) {
	DIR* dir = NULL;
	struct dirent* ptr = NULL;

	dir = opendir("/proc");
	if (dir) {
		while ((ptr = readdir(dir)) != NULL) { // 循环读取路径下的每一个文件/文件夹
			// 如果读取到的是"."或者".."则跳过，读取到的不是文件夹名字也跳过
			if ((strcmp(ptr->d_name, ".") == 0) || (strcmp(ptr->d_name, "..") == 0))
			{
				continue;
			}
			else if (ptr->d_type != DT_DIR)
			{
				continue;
			}
			else if (strspn(ptr->d_name, "1234567890") != strlen(ptr->d_name))
			{
				continue;
			}

			int pid = atoi(ptr->d_name);

			uint64_t hProcess = pDriver->OpenProcess(pid);
			if (!hProcess) { continue; }

			MyProcessInfo pInfo = { 0 };
			pInfo.pid = pid;
			if (bGetPhyMemorySize) {
				uint64_t outRss = 0;
				pDriver->GetProcessPhyMemSize(hProcess, outRss);
				pInfo.total_rss = outRss;
			}
			char cmdline[200] = { 0 };
			pDriver->GetProcessCmdline(hProcess, cmdline, sizeof(cmdline));
			pInfo.cmdline = cmdline;

			pDriver->CloseHandle(hProcess);

			vOutput.push_back(pInfo);
		}
		closedir(dir);
		return TRUE;
	}
	return FALSE;
}


HANDLE CApi::CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID) {

	if (dwFlags & TH32CS_SNAPPROCESS) {
		//printf("TH32CS_SNAPPROCESS\n");
		//获取进程列表
		CeProcessList * pCeProcessList = new CeProcessList();

		//获取进程列表
		GetProcessListInfo(&g_driver, FALSE, pCeProcessList->vProcessList);


		pCeProcessList->readIter = pCeProcessList->vProcessList.begin();
		return CPortHelper::CreateHandleFromPointer((uint64_t)pCeProcessList, htTHSProcess);
	} else if (dwFlags & TH32CS_SNAPMODULE) {
		//printf("TH32CS_SNAPMODULE\n");
		HANDLE hm = CPortHelper::FindHandleByPID(th32ProcessID);
		if (!hm) {
			//如果没有打开此进程，就不允许获取此进程的模块列表
			return 0;
		}

		CeOpenProcess *pCeOpenProcess = (CeOpenProcess*)CPortHelper::GetPointerFromHandle(hm);

		//取出驱动进程句柄
		uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;


		//驱动_获取进程内存块列表
		std::vector<DRIVER_REGION_INFO> vMaps;
		BOOL b = g_driver.VirtualQueryExFull(u64DriverProcessHandle, FALSE, vMaps);
		printf("Call VirtualQueryExFull(FALSE) return:%d, size:%zu\n", b, vMaps.size());
		fflush(stdout);
		if (!vMaps.size()) {
			printf("VirtualQueryExFull failed\n");
			fflush(stdout);
			return 0;
		}

		CeModuleList * pCeModuleList = new CeModuleList();

		//显示进程内存块地址列表
		for (DRIVER_REGION_INFO rinfo : vMaps) {
			if (rinfo.protection == PAGE_NOACCESS) {
				//此地址不可访问
				continue;
			} else if (rinfo.type == MEM_MAPPED) {
				continue;
			} else if (rinfo.name[0] == '\0') {
				continue;
			} else if (strcmp(rinfo.name, "[heap]") == 0) {
				continue;
			}
			if (strcmp(rinfo.name, "[vdso]") != 0)  //ceOpenProcessorary patch as to not rename vdso, because it is treated differently by the ce symbol loader
			{
				for (int i = 0; rinfo.name[i]; i++) //strip square brackets from the name (conflicts with pointer notations)
				{
					if ((rinfo.name[i] == '[') || (rinfo.name[i] == ']')) {
						rinfo.name[i] = '_';
					}
				}
			}

			int isExist = 0;
			for (auto iter = pCeModuleList->vModuleList.begin(); iter != pCeModuleList->vModuleList.end(); iter++) {
				if (iter->moduleName == std::string(rinfo.name)) {
					isExist = 1;
					ModuleListEntry newReplace = *iter;
					newReplace.moduleSize += rinfo.size;
					iter = pCeModuleList->vModuleList.insert(iter, newReplace);
					iter++;
					if (iter != pCeModuleList->vModuleList.end()) {
						pCeModuleList->vModuleList.erase(iter);

						break;
					}
				}
			}
			if (isExist) {
				continue;
			}

			uint32_t magic = 0;
			BOOL b = g_driver.ReadProcessMemory(u64DriverProcessHandle, rinfo.baseaddress, &magic, 4, NULL, FALSE);
			if (b == FALSE) {
				//printf("%s is unreadable(%llx)\n", modulepath, start);
				continue; //unreadable
			}
			if (magic != 0x464c457f) //  7f 45 4c 46
			{
				//printf("%s is not an ELF(%llx).  tempbuf=%s\n", modulepath, start, tempbuf);
				continue; //not an ELF
			}

			ModuleListEntry newModInfo;
			newModInfo.baseAddress = rinfo.baseaddress;
			newModInfo.moduleSize = rinfo.size;
			newModInfo.moduleName = rinfo.name;
			//printf("%s\n", newModInfo.moduleName.c_str());

			pCeModuleList->vModuleList.push_back(newModInfo);

			//printf("+++Start:%llx,Size:%lld,Protection:%d,Type:%d,Name:%s\n", rinfo.baseaddress, rinfo.size, rinfo.protection, rinfo.type, rinfo.name);
		}

		pCeModuleList->readIter = pCeModuleList->vModuleList.begin();
		return CPortHelper::CreateHandleFromPointer((uint64_t)pCeModuleList, htTHSModule);
	}


	return 0;
}


BOOL CApi::Process32First(HANDLE hSnapshot, ProcessListEntry & processentry) {
	//Get a processentry from the processlist snapshot. fill the given processentry with the data.

   // printf("Process32First\n");
	if (CPortHelper::GetHandleType(hSnapshot) == htTHSProcess) {
		CeProcessList *pCeProcessList = (CeProcessList*)CPortHelper::GetPointerFromHandle(hSnapshot);
		pCeProcessList->readIter = pCeProcessList->vProcessList.begin();
		if (pCeProcessList->readIter != pCeProcessList->vProcessList.end()) {
			processentry.PID = pCeProcessList->readIter->pid;
			processentry.ProcessName = pCeProcessList->readIter->cmdline;

			return TRUE;
		}
	}
	return FALSE;
}


BOOL CApi::Process32Next(HANDLE hSnapshot, ProcessListEntry &processentry) {
	//get the current iterator of the list and increase it. If the max has been reached, return false
   // printf("Process32Next\n");

	if (CPortHelper::GetHandleType(hSnapshot) == htTHSProcess) {
		CeProcessList *pCeProcessList = (CeProcessList*)CPortHelper::GetPointerFromHandle(hSnapshot);
		pCeProcessList->readIter++;
		if (pCeProcessList->readIter != pCeProcessList->vProcessList.end()) {
			processentry.PID = pCeProcessList->readIter->pid;
			processentry.ProcessName = pCeProcessList->readIter->cmdline;
			return TRUE;
		}
	}
	return FALSE;
}


BOOL CApi::Module32First(HANDLE hSnapshot, ModuleListEntry & moduleentry) {
	if (CPortHelper::GetHandleType(hSnapshot) == htTHSModule) {
		CeModuleList *pCeModuleList = (CeModuleList*)CPortHelper::GetPointerFromHandle(hSnapshot);

		pCeModuleList->readIter = pCeModuleList->vModuleList.begin();
		if (pCeModuleList->readIter != pCeModuleList->vModuleList.end()) {
			moduleentry.baseAddress = pCeModuleList->readIter->baseAddress;
			moduleentry.moduleSize = pCeModuleList->readIter->moduleSize;
			moduleentry.moduleName = pCeModuleList->readIter->moduleName;
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CApi::Module32Next(HANDLE hSnapshot, ModuleListEntry & moduleentry) {
	//get the current iterator of the list and increase it. If the max has been reached, return false
	printf("Module32First/Next(%d)\n", hSnapshot);
	if (CPortHelper::GetHandleType(hSnapshot) == htTHSModule) {
		CeModuleList *pCeModuleList = (CeModuleList*)CPortHelper::GetPointerFromHandle(hSnapshot);
		pCeModuleList->readIter++;
		if (pCeModuleList->readIter != pCeModuleList->vModuleList.end()) {
			moduleentry.baseAddress = pCeModuleList->readIter->baseAddress;
			moduleentry.moduleSize = pCeModuleList->readIter->moduleSize;
			moduleentry.moduleName = pCeModuleList->readIter->moduleName;
			return TRUE;
		}
	}
	return FALSE;
}



HANDLE CApi::OpenProcess(DWORD pid) {
	//check if this process has already been opened
	HANDLE hm = CPortHelper::FindHandleByPID(pid);
	if (hm) {
		return hm;
	}
	//still here, so not opened yet

	//驱动_打开进程
	uint64_t u64DriverProcessHandle = g_driver.OpenProcess(pid);
	if (u64DriverProcessHandle == 0) {
		return 0;
	}
	CeOpenProcess *pCeOpenProcess = new CeOpenProcess();
	pCeOpenProcess->pid = pid;
	pCeOpenProcess->u64DriverProcessHandle = u64DriverProcessHandle;
	return CPortHelper::CreateHandleFromPointer((uint64_t)pCeOpenProcess, htProcesHandle);
}


void CApi::CloseHandle(HANDLE h) {

	int i;
	handleType ht = CPortHelper::GetHandleType(h);
	uint64_t pl = CPortHelper::GetPointerFromHandle(h);

	printf("CloseHandle %d %" PRIu64 "\n", h, pl);

	if (ht == htTHSModule) {
		auto pCeModuleList = (CeModuleList*)pl;
		delete pCeModuleList;
	} else if (ht == htTHSProcess) {
		auto pProcessList = (CeProcessList*)pl;
		delete pProcessList;
	} else if (ht == htProcesHandle) {
		auto pOpenProcess = (CeOpenProcess*)pl;

		g_driver.CloseHandle(pOpenProcess->u64DriverProcessHandle);
		delete pOpenProcess;
	}
	//else
	//{
	//	if (ht == htNativeThreadHandle)
	//	{
	//		uint64_t *th = GetPointerFromHandle(h);
	//		printf("Closing thread handle\n");

	//		free(th);
	//		RemoveHandle(h);
	//	}
	//	else
	//	{
	//		RemoveHandle(h); //no idea what it is...
	//	}

	//}
	CPortHelper::RemoveHandle(h);
}



int CApi::VirtualQueryExFull(HANDLE hProcess, uint32_t flags, std::vector<RegionInfo> & vRinfo)
/*
 * creates a full list of the maps file (less seeking)
 */
{
	printf("VirtualQueryExFull: %d \n", hProcess);

	if (CPortHelper::GetHandleType(hProcess) != htProcesHandle) {
		printf("VirtualQueryExFull handle Error: %d \n", hProcess);
		return 0;
	}
	CeOpenProcess *pCeOpenProcess = (CeOpenProcess*)CPortHelper::GetPointerFromHandle(hProcess);

	//取出驱动进程句柄
	uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;

	//int pagedonly = flags & VQE_PAGEDONLY;
	//int dirtyonly = flags & VQE_DIRTYONLY;
	int noshared = flags & VQE_NOSHARED;

	vRinfo.clear();

	//驱动_获取进程内存块列表
	std::vector<DRIVER_REGION_INFO> vMaps;
	BOOL b = g_driver.VirtualQueryExFull(u64DriverProcessHandle, FALSE, vMaps);
	printf("Call VirtualQueryExFull(FALSE) return:%d, size:%zu\n", b, vMaps.size());
	fflush(stdout);
	if (!vMaps.size()) {
		printf("VirtualQueryExFull(FALSE) failed.\n");
		fflush(stdout);
		return 0;
	}

	//显示进程内存块地址列表
	for (const DRIVER_REGION_INFO & rinfo : vMaps) {
		if (rinfo.protection == PAGE_NOACCESS) {
			//此地址不可访问
			continue;
		} else if (rinfo.type == MEM_MAPPED) //some checks to see if it passed
		{
			if (noshared) {
				continue;
			}
		}

		RegionInfo newInfo = { 0 };
		newInfo.baseaddress = rinfo.baseaddress;
		newInfo.size = rinfo.size;
		newInfo.protection = rinfo.protection;
		newInfo.type = rinfo.type;
		vRinfo.push_back(newInfo);
		//printf("+++Start:%llx,Size:%lld,Protection:%d,Type:%d,Name:%s\n", rinfo.baseaddress, rinfo.size, rinfo.protection, rinfo.type, rinfo.name);
	}
	return 1;

}

int CApi::VirtualQueryEx(HANDLE hProcess, uint64_t lpAddress, RegionInfo & rinfo, std::string & memName) {
	/*
	 * Alternate method: read pagemaps and look up the pfn in /proc/kpageflags (needs to 2 files open and random seeks through both files, so not sure if slow or painfully slow...)
	 */

	 //VirtualQueryEx stub port. Not a real port, and returns true if successful and false on error
	int found = 0;

	//printf("VirtualQueryEx %d (%p)\n", hProcess, lpAddress);


	if (CPortHelper::GetHandleType(hProcess) != htProcesHandle) {
		return 0;
	}

	CeOpenProcess *pCeOpenProcess = (CeOpenProcess*)CPortHelper::GetPointerFromHandle(hProcess);

	//取出驱动进程句柄
	uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;
	std::vector<DRIVER_REGION_INFO> vMaps;
	BOOL b = g_driver.VirtualQueryExFull(u64DriverProcessHandle, FALSE, vMaps);
	printf("Call VirtualQueryExFull(FALSE) return:%d, size:%zu\n", b, vMaps.size());
	fflush(stdout);
	if (!vMaps.size()) {
		printf("VirtualQueryExFull failed\n");
		fflush(stdout);
		return 0;
	}
	rinfo.protection = 0;
	rinfo.baseaddress = (uint64_t)lpAddress & ~0xfff;
	lpAddress = (uint64_t)(rinfo.baseaddress);

	//显示进程内存块地址列表
	for (const DRIVER_REGION_INFO & r : vMaps) {
		uint64_t stop = r.baseaddress + r.size;
		if (stop > lpAddress) //we passed it
		{
			found = 1;

			if (lpAddress >= r.baseaddress) {
				//it's inside the region, so useable

				rinfo.protection = r.protection;
				rinfo.type = r.type;
				rinfo.size = stop - rinfo.baseaddress;
			} else {
				rinfo.size = r.baseaddress - rinfo.baseaddress;
				rinfo.protection = PAGE_NOACCESS;
				rinfo.type = 0;
			}
			memName = r.name;

			//printf("+++Start:%llx,Size:%lld %lld,Protection:%d,Type:%d\n", rinfo.baseaddress, rinfo.size, r.size, rinfo.protection, rinfo.type);
			break;
		}
	}

	return found;
}




int CApi::ReadProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size) {
	//idea in case this is too slow. always read a full page and keep the last 16 accessed pages.
	//only on cache miss, or if the cache is older than 1000 milliseconds fetch the page.
	//keep in mind that this routine can get called by multiple threads at the same time


	//todo: Try process_vm_readv

	  //printf("ReadProcessMemory(%d, %p, %p, %d)\n", (int)hProcess, lpAddress, buffer, size);

	//printf("ReadProcessMemory\n");


	size_t bread = 0;

	if (CPortHelper::GetHandleType(hProcess) != htProcesHandle) {
		return 0;
	}
	CeOpenProcess *pCeOpenProcess = (CeOpenProcess*)CPortHelper::GetPointerFromHandle(hProcess);

	//取出驱动进程句柄
	uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;

	//驱动_读取进程内存
	g_driver.ReadProcessMemory(u64DriverProcessHandle, (uint64_t)lpAddress, buffer, size, &bread, FALSE);
	return (int)bread;
}


int CApi::WriteProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size) {
	size_t written = 0;
	//printf("WriteProcessMemory(%d, %p, %p, %d\n", hProcess, lpAddress, buffer, size);


	if (CPortHelper::GetHandleType(hProcess) != htProcesHandle) {
		return 0;
	}

	CeOpenProcess *pCeOpenProcess = (CeOpenProcess*)CPortHelper::GetPointerFromHandle(hProcess);

	//取出驱动进程句柄
	uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;

	//驱动_写取进程内存，分开两次写，因为强写需要改变物理内存页属性，怕出现意外死机，所以先尝试普通写入。
	if(!g_driver.WriteProcessMemory(u64DriverProcessHandle, (uint64_t)lpAddress, buffer, size, &written, FALSE)) {
		g_driver.WriteProcessMemory(u64DriverProcessHandle, (uint64_t)lpAddress, buffer, size, &written, TRUE);
	}

	return (int)written;
}


```

`rwProcMem33Module/testCEServer/jni/api.h`:

```h
#pragma once
#include <stdint.h>
#include <pthread.h>
#include <sys/queue.h>
#include <vector>
#include "porthelp.h"
#include "context.h"
/*

#if defined(__arm__) || defined(__ANDROID__)
#include <linux/user.h>
#else
#include <sys/user.h>
#endif
*/

#ifdef HAS_LINUX_USER_H
#include <linux/user.h>
#else
#include <sys/user.h>
#endif

#include <string>


#define VQE_PAGEDONLY 1
#define VQE_DIRTYONLY 2
#define VQE_NOSHARED 4


struct ModuleListEntry {
	unsigned long long baseAddress;
	int moduleSize;
	std::string moduleName;

};

struct ProcessListEntry {
	int PID;
	std::string ProcessName;

};


#pragma pack(1)
struct RegionInfo {
	uint64_t baseaddress;
	uint64_t size;
	uint32_t protection;
	uint32_t type;
};
#pragma pack()


struct MyProcessInfo {
	int pid;
	size_t total_rss;
	std::string cmdline;
};

struct CeProcessList {
	std::vector<struct MyProcessInfo> vProcessList;
	decltype(vProcessList)::iterator readIter;
};

struct CeModuleList {
	std::vector<ModuleListEntry> vModuleList;
	decltype(vModuleList)::iterator readIter;
};

struct CeOpenProcess {
	int pid;
	uint64_t u64DriverProcessHandle;
};

class CApi {
public:
	static BOOL InitReadWriteDriver(const char* procNodeAuthKey, BOOL bUseBypassSELinuxMode);
	static HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
	static BOOL Process32First(HANDLE hSnapshot, ProcessListEntry & processentry);
	static BOOL Process32Next(HANDLE hSnapshot, ProcessListEntry &processentry);
	static BOOL Module32First(HANDLE hSnapshot, ModuleListEntry & moduleentry);
	static BOOL Module32Next(HANDLE hSnapshot, ModuleListEntry & moduleentry);
	static HANDLE OpenProcess(DWORD pid);
	static void CloseHandle(HANDLE h);
	static int VirtualQueryExFull(HANDLE hProcess, uint32_t flags, std::vector<RegionInfo> & vRinfo);
	static int VirtualQueryEx(HANDLE hProcess, uint64_t lpAddress, RegionInfo & rinfo, std::string & memName);
	static int ReadProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size);
	static int WriteProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size);
protected:
};

```

`rwProcMem33Module/testCEServer/jni/ceserver.h`:

```h
#ifndef CESERVER_H_
#define CESERVER_H_

#include <stdint.h>
#include <sys/types.h>
#include "porthelp.h"

#define CMD_GETVERSION 0
#define CMD_CLOSECONNECTION 1
#define CMD_TERMINATESERVER 2
#define CMD_OPENPROCESS 3
#define CMD_CREATETOOLHELP32SNAPSHOT 4
#define CMD_PROCESS32FIRST 5
#define CMD_PROCESS32NEXT 6
#define CMD_CLOSEHANDLE 7
#define CMD_VIRTUALQUERYEX 8
#define CMD_READPROCESSMEMORY 9
#define CMD_WRITEPROCESSMEMORY 10
#define CMD_STARTDEBUG 11
#define CMD_STOPDEBUG 12
#define CMD_WAITFORDEBUGEVENT 13
#define CMD_CONTINUEFROMDEBUGEVENT 14
#define CMD_SETBREAKPOINT 15
#define CMD_REMOVEBREAKPOINT 16
#define CMD_SUSPENDTHREAD 17
#define CMD_RESUMETHREAD 18
#define CMD_GETTHREADCONTEXT 19
#define CMD_SETTHREADCONTEXT 20
#define CMD_GETARCHITECTURE 21
#define CMD_MODULE32FIRST 22
#define CMD_MODULE32NEXT 23

#define CMD_GETSYMBOLLISTFROMFILE 24
#define CMD_LOADEXTENSION         25

#define CMD_ALLOC                   26
#define CMD_FREE                    27
#define CMD_CREATETHREAD            28
#define CMD_LOADMODULE              29
#define CMD_SPEEDHACK_SETSPEED      30

#define CMD_VIRTUALQUERYEXFULL      31
#define CMD_GETREGIONINFO           32

#define CMD_AOBSCAN					200

//just in case I ever get over 255 commands this value will be reserved for a secondary command list (FF 00 -  FF 01 - ... - FF FE - FF FF 01 - FF FF 02 - .....
#define CMD_COMMANDLIST2            255





//extern char *versionstring;

#pragma pack(1)
struct CeVersion {
	int version;
	unsigned char stringsize;
	//append the versionstring
};

struct CeCreateToolhelp32Snapshot {
	DWORD dwFlags;
	DWORD th32ProcessID;
};

struct CeProcessEntry {
	int result;
	int pid;
	int processnamesize;
	//processname
};

struct CeModuleEntry {
	int result;
	int64_t modulebase;
	int modulesize;
	int modulenamesize;
	//modulename

};

struct CeVirtualQueryExInput {
	int handle;
	uint64_t baseaddress;
};

struct CeVirtualQueryExOutput {
	uint8_t result;
	uint32_t protection;
	uint32_t type;
	uint64_t baseaddress;
	uint64_t size;
};

struct CeVirtualQueryExFullInput {
	int handle;
	uint8_t flags;
};

struct CeVirtualQueryExFullOutput {
	uint32_t protection;
	uint32_t type;
	uint64_t baseaddress;
	uint64_t size;
};

struct CeReadProcessMemoryInput {
	uint32_t handle;
	uint64_t address;
	uint32_t size;
	uint8_t  compress;
};

struct CeReadProcessMemoryOutput {
	int read;
};

struct CeWriteProcessMemoryInput {
	int32_t handle;
	int64_t address;
	int32_t size;
};


struct CeWriteProcessMemoryOutput {
	int32_t written;
};


struct CeSetBreapointInput {
	HANDLE hProcess;
	int tid;
	int debugreg;
	uint64_t Address;
	int bptype;
	int bpsize;
};


struct CeSetBreapointOutput {
	int result;
};

struct CeRemoveBreapointInput {
	HANDLE hProcess;
	uint32_t tid;
	uint32_t debugreg;
	uint32_t wasWatchpoint;
};


struct CeRemoveBreapointOutput {
	int result;
};

struct CeSuspendThreadInput {
	HANDLE hProcess;
	int tid;
};


struct CeSuspendThreadOutput {
	int result;
};

struct CeResumeThreadInput {
	HANDLE hProcess;
	int tid;
};


struct CeResumeThreadOutput {
	int result;
};

struct CeAllocInput {
	HANDLE hProcess;
	uint64_t preferedBase;
	uint32_t size;
};


struct CeAllocOutput {
	uint64_t address; //0=fail
};

struct CeFreeInput {
	HANDLE hProcess;
	uint64_t address;
	uint32_t size;
};


struct CeFreeOutput {
	uint32_t result;
};

struct CeCreateThreadInput {
	HANDLE hProcess;
	uint64_t startaddress;
	uint64_t parameter;
};


struct CeCreateThreadOutput {
	HANDLE threadhandle;
};

struct CeLoadModuleInput {
	HANDLE hProcess;
	uint32_t modulepathlength;
	//modulepath
};


struct CeLoadModuleOutput {
	uint32_t result;
};


struct CeSpeedhackSetSpeedInput {
	HANDLE hProcess;
	float speed;
};


struct CeSpeedhackSetSpeedOutput {
	uint32_t result;
};

struct CeAobScanInput {
	HANDLE hProcess;
	uint64_t start;
	uint64_t end;
	int inc;
	int protection;
	int scansize;
};
#pragma pack()


#endif /* CESERVER_H_ */
```

`rwProcMem33Module/testCEServer/jni/context.h`:

```h
#ifndef CONTEXT_H_
#define CONTEXT_H_
#ifdef HAS_LINUX_USER_H
#include <linux/user.h>
#else
#include <sys/user.h>
#endif

#include <sys/ptrace.h>
#include <linux/socket.h>

#ifdef __aarch64__
#include <elf.h>
#endif



#include <sys/socket.h>


#ifdef __i386__
typedef struct user_regs_struct CONTEXT_REGS;
#endif

#ifdef __x86_64__
typedef struct user_regs_struct CONTEXT_REGS;
#endif


#ifdef __arm__
typedef struct pt_regs CONTEXT_REGS;
#endif


#ifdef __aarch64__
typedef struct user_pt_regs CONTEXT_REGS;
#endif

struct CONTEXT {
	CONTEXT_REGS regs;
};




#endif /* CONTEXT_H_ */
```

`rwProcMem33Module/testCEServer/jni/native-api.cpp`:

```cpp
#include "native-api.h"

```

`rwProcMem33Module/testCEServer/jni/native-api.h`:

```h
#pragma once
#define MAX_HIT_COUNT 5000000
```

`rwProcMem33Module/testCEServer/jni/porthelp.cpp`:

```cpp
#include "porthelp.h"
#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#include <random>
#include <map>
#include "api.h"

struct HANDLE_INFO {
	uint64_t p;//TODO：这里有空再搞成shared_ptr派生成各个基类，防止内存泄漏
	handleType type;
};
std::map<HANDLE, HANDLE_INFO> m_HandlePointList;


HANDLE CPortHelper::CreateHandleFromPointer(uint64_t p, handleType type) {
	std::random_device rd;
	HANDLE handle = 10000 + rd() / 1000;
	handle = handle < 0 ? -handle : handle;
	while (m_HandlePointList.find(handle) != m_HandlePointList.end()) {
		handle = 10000 + rd() / 1000;
		handle = handle < 0 ? -handle : handle;
	}

	HANDLE_INFO hinfo = { 0 };
	hinfo.p = p;
	hinfo.type = type;
	m_HandlePointList.insert(
		std::pair<HANDLE, HANDLE_INFO >(handle, hinfo));

	return handle;
}

handleType CPortHelper::GetHandleType(HANDLE handle) {
	auto iter = m_HandlePointList.find(handle);
	if (iter == m_HandlePointList.end()) {
		return htEmpty;
	}
	return iter->second.type;
}

uint64_t CPortHelper::GetPointerFromHandle(HANDLE handle) {
	auto iter = m_HandlePointList.find(handle);
	if (iter == m_HandlePointList.end()) {
		return 0;
	}
	return iter->second.p;
}



void CPortHelper::RemoveHandle(HANDLE handle) {
	auto iter = m_HandlePointList.find(handle);
	if (iter == m_HandlePointList.end()) {
		return;
	}
	m_HandlePointList.erase(iter);
}



HANDLE CPortHelper::FindHandleByPID(DWORD pid) {
	for (auto item = m_HandlePointList.begin(); item != m_HandlePointList.end(); item++) {
		if (item->second.type == htProcesHandle) {
			CeOpenProcess *pCeOpenProcess = (CeOpenProcess*)item->second.p;
			if (pCeOpenProcess->pid == pid) {
				return item->first;
			}
		}
	}
	return 0;
}

```

`rwProcMem33Module/testCEServer/jni/porthelp.h`:

```h
#pragma once
#include <stdint.h>

typedef int32_t HANDLE; //just an int, in case of a 32-bit ce version and a 64-bit linux version I can not give pointers, so use ID's for handles
typedef int32_t DWORD;

#define TH32CS_SNAPPROCESS  0x2
#define TH32CS_SNAPMODULE   0x8

#define PAGE_NOACCESS 1
#define PAGE_READONLY 2
#define PAGE_READWRITE 4
#define PAGE_WRITECOPY 8
#define PAGE_EXECUTE 16
#define PAGE_EXECUTE_READ 32
#define PAGE_EXECUTE_READWRITE 64

#define MEM_MAPPED 262144
#define MEM_PRIVATE 131072

#define TRUE 1
#define FALSE 0

typedef enum { 
	htEmpty = 0,
	htProcesHandle,
	htThreadHandle,
	htTHSProcess,
	htTHSModule,
	htNativeThreadHandle
} handleType; //The difference between ThreadHandle and NativeThreadHandle is that threadhandle is based on the processid of the thread, the NativeThreadHandle is in linux usually the pthread_t handle

typedef int BOOL;


class CPortHelper
{
public:
	static HANDLE CreateHandleFromPointer(uint64_t p, handleType type);
	static handleType GetHandleType(HANDLE handle);
	static uint64_t GetPointerFromHandle(HANDLE handle);
	static void RemoveHandle(HANDLE handle);
	static HANDLE FindHandleByPID(DWORD pid);
};


```

`rwProcMem33Module/testCEServer/jni/symbols.cpp`:

```cpp
#include "symbols.h"
#include <stdio.h>
#include <elf.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <string.h>
#include <zlib.h>

#pragma pack(1)
typedef struct {
	uint64_t address;
	int size;
	int type;
	unsigned char namelength;
	char name[0];
} symbolinfo, *psymbolinfo;
#pragma pack()

#define TEMPBUFSIZE 64*1024
//
//
//void loadStringTable64(int f, Elf64_Shdr *sectionHeaders, unsigned char **stringTable, int index)
//{
//  if ((stringTable[index]==NULL) && (sectionHeaders[index].sh_type==SHT_STRTAB))
//  {
//    stringTable[index]=malloc(sectionHeaders[index].sh_size);
//    if (pread(f, stringTable[index], sectionHeaders[index].sh_size, sectionHeaders[index].sh_offset)==-1)
//    {
//      debug_log("Failure loading the stringtable\n");
//      free(stringTable[index]);
//      stringTable[index]=NULL;
//    }
//
//  }
//  else
//    debug_log("Not a string table\n");
//}
//
//void loadStringTable32(int f, Elf32_Shdr *sectionHeaders, unsigned char **stringTable, int index)
//{
//  if ((stringTable[index]==NULL) && (sectionHeaders[index].sh_type==SHT_STRTAB))
//  {
//    stringTable[index]=malloc(sectionHeaders[index].sh_size);
//    if (pread(f, stringTable[index], sectionHeaders[index].sh_size, sectionHeaders[index].sh_offset)==-1)
//    {
//      debug_log("Failure loading the stringtable\n");
//      free(stringTable[index]);
//      stringTable[index]=NULL;
//    }
//
//  }
//  else
//    debug_log("Not a string table\n");
//}
//
//int ELF32(int f, Elf32_Ehdr *b, unsigned char **output)
///*
//Caller must free output manually
//*/
//{
//  int i,j;
//
//  unsigned char *tempbuffer=NULL;
//  int tempbufferpos=0;
//  int maxoutputsize=TEMPBUFSIZE;
//  tempbuffer=malloc(TEMPBUFSIZE);
//
//  //setup zlib
//  z_stream strm;
//  strm.zalloc = Z_NULL;
//  strm.zfree = Z_NULL;
//  strm.opaque = Z_NULL;
//  deflateInit(&strm, 9);
//
//  *output=malloc(maxoutputsize); //allocate 256KB. This "should" be enough, but reallocate if more is needed
//
//  strm.avail_out=maxoutputsize-3*sizeof(uint32_t); //first if it's an exe, followed by the compressed size, followed by the decompressed size
//  strm.next_out=(unsigned char *)&(*output)[sizeof(uint32_t)*3];
//
//  *(uint32_t *)(&(*output)[0])=(b->e_type==ET_EXEC);
//
///*
//
//  debug_log("e_shoff=%x\n", b->e_shoff);
//  debug_log("e_shentsize=%d\n", b->e_shentsize);
//  debug_log("e_shnum=%d\n", b->e_shnum);
//  debug_log("e_shstrndx=%d\n", b->e_shstrndx);*/
//
//  Elf32_Shdr *sectionHeaders=malloc(b->e_shentsize*b->e_shnum);
//
//  if (pread(f, sectionHeaders, b->e_shentsize*b->e_shnum, b->e_shoff)==-1)
//  {
//    //printf("Failure to read sectionHeaders\n");
//    deflateEnd(&strm);
//    if (sectionHeaders)
//      free(sectionHeaders);
//
//    if (output)
//      free(output);
//
//    if (tempbuffer)
//      free(tempbuffer);
//
//    return -1;
//  }
//
//  unsigned char **stringTable=calloc(b->e_shnum, sizeof(unsigned char*) );
//
//  loadStringTable32(f, sectionHeaders, stringTable, b->e_shstrndx);
//
//
//  for (i=0; i<b->e_shnum; i++)
//  {
//    //printf("Section %d (%x): name=%s\n", i, sectionHeaders[i].sh_addr, &stringTable[b->e_shstrndx][sectionHeaders[i].sh_name]);
//
//    if ((sectionHeaders[i].sh_type==SHT_SYMTAB) || (sectionHeaders[i].sh_type==SHT_DYNSYM))
//    {
//     // debug_log("Symbol data:\n", i);
//
//     // debug_log("sh_addr=%x\n", sectionHeaders[i].sh_addr);
//      //printf("sh_offset=%x\n", sectionHeaders[i].sh_offset);
//      //printf("sh_size=%x\n", sectionHeaders[i].sh_size);
//      //printf("sh_link=%d (string table)\n", sectionHeaders[i].sh_link);
//      //printf("sh_info=%d\n", sectionHeaders[i].sh_info);
//
//      Elf32_Sym *symbolTable=malloc(sectionHeaders[i].sh_size);
//      if (pread(f, symbolTable, sectionHeaders[i].sh_size, sectionHeaders[i].sh_offset)==-1)
//      {
//       // debug_log("Failure reading symbol table\n");
//        return -1;
//      }
//      int maxindex=sectionHeaders[i].sh_size / sizeof(Elf32_Sym);
//
//      loadStringTable32(f, sectionHeaders, stringTable, sectionHeaders[i].sh_link);
//
//      //printf("maxindex=%d\n", maxindex);
//      for (j=0; j<maxindex; j++)
//      {
//        //printf("symbolTable[%d]:\n", i);
//        //printf("st_name=%s\n", &stringTable[sectionHeaders[i].sh_link][symbolTable[j].st_name] );
//       // debug_log("st_value=%x\n", symbolTable[j].st_value);
//        //printf("st_size=%d\n", symbolTable[j].st_size);
//       // debug_log("st_info=%d\n", symbolTable[j].st_info);
//        //printf("  Bind=%d\n", ELF32_ST_BIND(symbolTable[j].st_info));
//        //printf("  Type=%d\n", ELF32_ST_TYPE(symbolTable[j].st_info));
//       // debug_log("st_other=%d\n", symbolTable[j].st_other);
//       // debug_log("st_shndx=%d\n", symbolTable[j].st_shndx);
//
//        if (symbolTable[j].st_value)
//        {
//          //add it to the tempbuffer
//          char *symbolname=(char *)&stringTable[sectionHeaders[i].sh_link][symbolTable[j].st_name];
//          size_t namelength=strlen(symbolname);
//          int entrysize=sizeof(symbolinfo)+namelength;
//          if (tempbufferpos+entrysize>=TEMPBUFSIZE)
//          {
//             //compress the current temp buffer
//             //printf("compressing\n");
//             strm.avail_in=tempbufferpos;
//             strm.next_in=tempbuffer;
//
//             while (strm.avail_in)
//             {
//               if (deflate(&strm, Z_NO_FLUSH)!=Z_OK)
//               {
//                 //printf("FAILURE TO COMPRESS!\n");
//                 return -1;
//               }
//               //printf("strm.avail_out=%d\n", strm.avail_out);
//
//               if (strm.avail_out==0)
//               {
//
//
//                 //printf("Out buffer full. Reallocating\n");
//                 *output=realloc(*output, maxoutputsize*2);
//
//                 strm.next_out=(unsigned char *)&(*output)[maxoutputsize];
//                 strm.avail_out=maxoutputsize;
//                 maxoutputsize=maxoutputsize*2;
//
//
//               }
//
//             }
//             tempbufferpos=0;
//          }
//
//
//
//          psymbolinfo si=(psymbolinfo)&tempbuffer[tempbufferpos];
//          si->address=symbolTable[j].st_value;
//          si->size=symbolTable[j].st_size;
//          si->type=symbolTable[j].st_info;
//          si->namelength=namelength;
//          memcpy(&si->name, symbolname, namelength);
//
//
//          tempbufferpos+=entrysize;
//        }
//      }
//
//      free(symbolTable);
//
//    }
//
//  }
//
//  for (i=0; i<b->e_shnum; i++)
//  {
//    if (stringTable[i])
//      free(stringTable[i]);
//  }
//  free(stringTable);
//
//  free(sectionHeaders);
//
//
//  debug_log("end:\n");
//  strm.avail_in=tempbufferpos;
//  strm.next_in=tempbuffer;
//
//  while (1)
//  {
//
//    i=deflate(&strm, Z_FINISH);
//    debug_log("i=%d\n", i);
//    if (i==Z_STREAM_END) //done
//      break;
//
//    if (i!=Z_OK)
//    {
//      debug_log("Failure to compress: %i\n", i);
//      return -1;
//    }
//
//    if (strm.avail_out==0)
//    {
//      debug_log("Out buffer full. Reallocating :%d\n", maxoutputsize*2);
//      *output=realloc(*output, maxoutputsize*2);
//
//      strm.next_out=(unsigned char *)&(*output)[maxoutputsize];
//      strm.avail_out=maxoutputsize;
//      maxoutputsize=maxoutputsize*2;
//
//    }
//    else
//      break;
//
//  };
//
//  /*printf("strm.avail_out=%d\n", strm.avail_out);
//
//  debug_log("total_in = %lu\n", strm.total_in);
//  debug_log("total_out = %lu\n", strm.total_out);*/
//
//  deflateEnd(&strm);
//
//
//  //update the size
//  *(uint32_t *)(&(*output)[4])=strm.total_out+3*sizeof(uint32_t);
//  *(uint32_t *)(&(*output)[8])=strm.total_in;
//
//  free(tempbuffer);
//
//  return 0;
//}
//
//int ELF64(int f, Elf64_Ehdr *b, unsigned char **output)
///*
//Caller must free output manually
//*/
//{
//  int i,j;
//
//
//  unsigned char *tempbuffer=NULL;
//  int tempbufferpos=0;
//  int maxoutputsize=TEMPBUFSIZE;
//  tempbuffer=malloc(TEMPBUFSIZE);
//
//  //setup zlib
//  z_stream strm;
//  strm.zalloc = Z_NULL;
//  strm.zfree = Z_NULL;
//  strm.opaque = Z_NULL;
//  deflateInit(&strm, 9);
//
//  *output=malloc(maxoutputsize); //allocate 256KB. This "should" be enough, but reallocate if more is needed
//
//  strm.avail_out=maxoutputsize-3*sizeof(uint32_t); //the first 8 bytes will contain the compressed and uncompressed size
//  strm.next_out=(unsigned char *)&(*output)[sizeof(uint32_t)*3];
//
//  *(uint32_t *)(&(*output)[0])=(b->e_type==ET_EXEC);
///*
//
//  debug_log("e_shoff=%lx\n", b->e_shoff);
//  debug_log("e_shentsize=%d\n", b->e_shentsize);
//  debug_log("e_shnum=%d\n", b->e_shnum);
//  debug_log("e_shstrndx=%d\n", b->e_shstrndx);*/
//
//  Elf64_Shdr *sectionHeaders=malloc(b->e_shentsize*b->e_shnum);
//
//  if (pread(f, sectionHeaders, b->e_shentsize*b->e_shnum, b->e_shoff)==-1)
//  {
//    //printf("Failure to read sectionHeaders\n");
//    deflateEnd(&strm);
//    if (sectionHeaders)
//      free(sectionHeaders);
//
//    if (output)
//      free(output);
//
//    if (tempbuffer)
//      free(tempbuffer);
//
//    return -1;
//  }
//
//  unsigned char **stringTable=calloc(b->e_shnum, sizeof(unsigned char*) );
//
//  loadStringTable64(f, sectionHeaders, stringTable, b->e_shstrndx);
//
//
//  for (i=0; i<b->e_shnum; i++)
//  {
//   // debug_log("Section %d (%lx): name=%s\n", i, sectionHeaders[i].sh_addr, &stringTable[b->e_shstrndx][sectionHeaders[i].sh_name]);
//
//    if ((sectionHeaders[i].sh_type==SHT_SYMTAB) || (sectionHeaders[i].sh_type==SHT_DYNSYM))
//    {/*
//      debug_log("Symbol data:\n", i);
//
//      debug_log("sh_addr=%lx\n", sectionHeaders[i].sh_addr);
//      debug_log("sh_offset=%lx\n", sectionHeaders[i].sh_offset);
//      debug_log("sh_size=%ld\n", sectionHeaders[i].sh_size);
//      debug_log("sh_link=%d (string table)\n", sectionHeaders[i].sh_link);
//      debug_log("sh_info=%d\n", sectionHeaders[i].sh_info);*/
//
//      Elf64_Sym *symbolTable=malloc(sectionHeaders[i].sh_size);
//      if (pread(f, symbolTable, sectionHeaders[i].sh_size, sectionHeaders[i].sh_offset)==-1)
//      {
//        //printf("Failure reading symbol table\n");
//        return -1;
//      }
//      int maxindex=sectionHeaders[i].sh_size / sizeof(Elf64_Sym);
//
//      loadStringTable64(f, sectionHeaders, stringTable, sectionHeaders[i].sh_link);
//
//      //printf("maxindex=%d\n", maxindex);
//      for (j=0; j<maxindex; j++)
//      {
//        /*
//        debug_log("symbolTable[%d]:\n", i);
//        debug_log("st_name=%s\n", &stringTable[sectionHeaders[i].sh_link][symbolTable[j].st_name] );
//        debug_log("st_value=%lx\n", symbolTable[j].st_value);
//        debug_log("st_size=%ld\n", symbolTable[j].st_size);
//        debug_log("st_info=%d\n", symbolTable[j].st_info);
//        debug_log("  Bind=%d\n", ELF64_ST_BIND(symbolTable[j].st_info));
//        debug_log("  Type=%d\n", ELF64_ST_TYPE(symbolTable[j].st_info));
//        debug_log("st_other=%d\n", symbolTable[j].st_other);
//        debug_log("st_shndx=%d\n", symbolTable[j].st_shndx);*/
//
//        if (symbolTable[j].st_value)
//        {
//          //add it to the tempbuffer
//          char *symbolname=(char *)&stringTable[sectionHeaders[i].sh_link][symbolTable[j].st_name];
//          size_t namelength=strlen(symbolname);
//          int entrysize=sizeof(symbolinfo)+namelength;
//          if (tempbufferpos+entrysize>=TEMPBUFSIZE)
//          {
//             //compress the current temp buffer
//             //printf("compressing\n");
//             strm.avail_in=tempbufferpos;
//             strm.next_in=tempbuffer;
//
//             while (strm.avail_in)
//             {
//               if (deflate(&strm, Z_NO_FLUSH)!=Z_OK)
//               {
//                 debug_log("FAILURE TO COMPRESS!\n");
//                 return -1;
//               }
//               //printf("strm.avail_out=%d\n", strm.avail_out);
//
//               if (strm.avail_out==0)
//               {
//
//                  // debug_log("Out buffer full. Reallocating\n");
//                 *output=realloc(*output, maxoutputsize*2);
//
//                 strm.next_out=(unsigned char *)&(*output)[maxoutputsize];
//                 strm.avail_out=maxoutputsize;
//                 maxoutputsize=maxoutputsize*2;
//               }
//
//             }
//             tempbufferpos=0;
//          }
//
//
//
//          psymbolinfo si=(psymbolinfo)&tempbuffer[tempbufferpos];
//          si->address=symbolTable[j].st_value;
//          si->size=symbolTable[j].st_size;
//          si->type=symbolTable[j].st_info;
//          si->namelength=namelength;
//          memcpy(&si->name, symbolname, namelength);
//
//
//          tempbufferpos+=entrysize;
//        }
//      }
//
//      free(symbolTable);
//
//    }
//
//  }
//
//  for (i=0; i<b->e_shnum; i++)
//  {
//    if (stringTable[i])
//      free(stringTable[i]);
//  }
//  free(stringTable);
//
//  free(sectionHeaders);
//
//
//  debug_log("end:\n");
//  strm.avail_in=tempbufferpos;
//  strm.next_in=tempbuffer;
//
//  while (1)
//  {
//
//    i=deflate(&strm, Z_FINISH);
//    debug_log("i=%d\n", i);
//    if (i==Z_STREAM_END) //done
//      break;
//
//    if (i!=Z_OK)
//    {
//      debug_log("Failure to compress: %i\n", i);
//      return -1;
//    }
//
//    if (strm.avail_out==0)
//    {
//      debug_log("Out buffer full. Reallocating :%d\n", maxoutputsize*2);
//      *output=realloc(*output, maxoutputsize*2);
//
//      strm.next_out=(unsigned char *)&(*output)[maxoutputsize];
//      strm.avail_out=maxoutputsize;
//      maxoutputsize=maxoutputsize*2;
//    }
//    else
//      break;
//
//  };
//
//  debug_log("strm.avail_out=%d\n", strm.avail_out);
//
//  debug_log("total_in = %lu\n", strm.total_in);
//  debug_log("total_out = %lu\n", strm.total_out);
//
//  deflateEnd(&strm);
//
//
//  *(uint32_t *)(&(*output)[4])=strm.total_out+3*sizeof(uint32_t);
//  *(uint32_t *)(&(*output)[8])=strm.total_in;
//
//
//  free(tempbuffer);
//
//  return 0; //still alive
//
//}
//
//int GetSymbolListFromFile(char *filename, unsigned char **output, int *outputsize)
///*
// * Returns a pointer to a compressed stream. The caller needs to free it
// */
//{
//  int i, f;
//  unsigned char *b=NULL;
//
//  debug_log("GetSymbolListFromFile(%s)\n", filename);
//
//  *output=NULL;
//  f=open(filename, O_RDONLY);
//  if (f==-1)
//    return -1;
//
//  b=malloc(sizeof(Elf64_Ehdr));
//  if (b)
//  {
//    i=pread(f, b, sizeof(Elf64_Ehdr), 0);
//
//    if (*(uint32_t *)b!=0x464c457f)
//      return -1; //not an ELF file
//
//    if (b[EI_CLASS]==ELFCLASS32)
//      i=ELF32(f, (Elf32_Ehdr *)b, output);
//    else
//      i=ELF64(f, (Elf64_Ehdr *)b, output);
//
//    free(b);
//  }
//
//  close(f);
//
//  return i;
//}
//
//
//int GetModuleSize32(int f, Elf32_Ehdr *b)
//{
// /* debug_log("32 bit\n");
//  debug_log("b->e_ehsize=%d  (%d)\n", (int)b->e_ehsize, (int)sizeof(Elf32_Ehdr));*/
//
//  //Elf32_Shdr *sectionHeaders=malloc(b->e_shentsize*b->e_shnum);
//  Elf32_Phdr *programHeaders=malloc(b->e_phentsize*b->e_phnum);
///*  debug_log("e_shoff=%x\n", b->e_shoff);
//  debug_log("e_shentsize=%d\n", b->e_shentsize);
//  debug_log("e_shnum=%d\n", b->e_shnum);
//  debug_log("e_shstrndx=%d\n", b->e_shstrndx);
//
//  debug_log("e_phoff=%x\n", b->e_phoff);
//  debug_log("e_phentsize=%d\n", b->e_phentsize);
//  debug_log("e_phnum=%d\n", b->e_phnum); */
//
//  if (pread(f, programHeaders, b->e_phentsize*b->e_phnum, b->e_phoff)==-1)
//  {
//    if (programHeaders)
//      free(programHeaders);
//
//    return 0;
//  }
//
//
//  int i;
//  unsigned long long lowest=0;//programHeaders[0].p_vaddr;
//  unsigned long long highest=0;//programHeaders[0].p_vaddr+programHeaders[0].p_memsz;
//
//  for (i=0; i<b->e_phnum; i++)
//  {
//     if (programHeaders[i].p_memsz>0)
//     {
//       if ((i==0) || (programHeaders[i].p_vaddr<lowest))
//          lowest=programHeaders[i].p_vaddr;
//
//       if ((i==0) || (programHeaders[i].p_vaddr+programHeaders[i].p_memsz>highest))
//          highest=programHeaders[i].p_vaddr+programHeaders[i].p_memsz;
//
//
///*
//       debug_log("%d: %x\n", i, programHeaders[i].p_type);
//       debug_log("Virtual Address: %llx-%llx:\n", (long long unsigned int)programHeaders[i].p_vaddr,(long long unsigned int)programHeaders[i].p_vaddr+(long long unsigned int)programHeaders[i].p_memsz);
//       debug_log("Size: %d (%x)\n", (int)programHeaders[i].p_memsz, (int)programHeaders[i].p_memsz);
//       */
//     }
//  }
//
//    if (programHeaders)
//      free(programHeaders);
//
// // debug_log("lowest=%llx highest=%llx\n", lowest, highest);
// // debug_log("size=%llx\n", highest-lowest);
//   return highest-lowest;
//}
//
//int GetModuleSize64(int f, Elf64_Ehdr *b)
//{
//  /*printf("64 bit\n");
//  debug_log("b->e_ehsize=%d  (%d)\n", (int)b->e_ehsize, (int)sizeof(Elf32_Ehdr));*/
//
//  Elf64_Phdr *programHeaders=malloc(b->e_phentsize*b->e_phnum);
///*  debug_log("e_shoff=%x\n", (int)b->e_shoff);
//  debug_log("e_shentsize=%d\n", b->e_shentsize);
//  debug_log("e_shnum=%d\n", b->e_shnum);
//  debug_log("e_shstrndx=%d\n", b->e_shstrndx);
//
//  debug_log("e_phoff=%x\n", (int)b->e_phoff);
//  debug_log("e_phentsize=%d\n", b->e_phentsize);
//  debug_log("e_phnum=%d\n", b->e_phnum);
//  */
//
//  if (pread(f, programHeaders, b->e_phentsize*b->e_phnum, b->e_phoff)==-1)
//  {
//    if (programHeaders)
//      free(programHeaders);
//
//    return 0;
//  }
//
//
//  int i;
//  unsigned long long lowest=0;//programHeaders[0].p_vaddr;
//  unsigned long long highest=0;//programHeaders[0].p_vaddr+programHeaders[0].p_memsz;
//
//  for (i=0; i<b->e_phnum; i++)
//  {
//     if (programHeaders[i].p_memsz>0)
//     {
//       if ((i==0) || (programHeaders[i].p_vaddr<lowest))
//          lowest=programHeaders[i].p_vaddr;
//
//       if ((i==0) || (programHeaders[i].p_vaddr+programHeaders[i].p_memsz>highest))
//          highest=programHeaders[i].p_vaddr+programHeaders[i].p_memsz;
//
//
///*
//       debug_log("%d: %x\n", i, programHeaders[i].p_type);
//       debug_log("Virtual Address: %llx-%llx:\n", (long long unsigned int)programHeaders[i].p_vaddr,(long long unsigned int)programHeaders[i].p_vaddr+(long long unsigned int)programHeaders[i].p_memsz);
//       debug_log("Size: %d (%x)\n", (int)programHeaders[i].p_memsz, (int)programHeaders[i].p_memsz);
//       */
//     }
//  }
//
//    if (programHeaders)
//      free(programHeaders);
//
// // debug_log("lowest=%llx highest=%llx\n", lowest, highest);
// // debug_log("size=%llx\n", highest-lowest);
//   return highest-lowest;
//}
//
//
//unsigned long long GetModuleSize(char *filename, unsigned long long defaultsize)
///*
// * Returns size the module will take in memory
// */
//{
//  int i,f;
//  unsigned char *b=NULL;
//  int result=defaultsize;
//
////  debug_log("GetModuleSize(\"%s\")=",filename);
//
//  f=open(filename, O_RDONLY);
//  if (f==-1)
//  {
//    debug_log("Failed to open %s\n", filename);
//    return defaultsize;
//  }
//  else
//  {
//    b=malloc(sizeof(Elf64_Ehdr));
//    if (b)
//    {
//      i=pread(f, b, sizeof(Elf64_Ehdr), 0);
//
//      if (*(uint32_t *)b!=0x464c457f)
//      {
//        debug_log("%s is not an elf\n", filename);
//        free(b);
//        close(f);
//        return defaultsize; //not an ELF file
//      }
//
//      if (b[EI_CLASS]==ELFCLASS32)
//        i=GetModuleSize32(f, (Elf32_Ehdr *)b);
//      else
//        i=GetModuleSize64(f, (Elf64_Ehdr *)b);
//
//      free(b);
//      close(f);
//
//      //printf("%x\n",i);
//      return i;
//    }
//    else
//    {
//      close(f);
//      return defaultsize;
//    }
//
//
//
//  }
//
//
//}

```

`rwProcMem33Module/testCEServer/jni/symbols.h`:

```h
#pragma once
class CSymbols {
public:
	//static int GetSymbolListFromFile(char *filename, unsigned char **output);
	//static unsigned long long GetModuleSize(char *filename, unsigned long long defaultsize);

};


```

`rwProcMem33Module/testCEServer/jni/testCEServer.cpp`:

```cpp

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <dirent.h>
#include <thread>
#include <zlib.h>
#include <sys/select.h>
#include <errno.h>
#include <elf.h>
#include <signal.h>
#include <sys/prctl.h>
#include <vector>
#include "ceserver.h"
#include "api.h"
#include "context.h"
#include "native-api.h"
#define PORT 3168


char versionstring[] = "CHEATENGINE Network 2.0";
ssize_t recvall(int s, void *buf, size_t size, int flags) {
	ssize_t totalreceived = 0;
	ssize_t sizeleft = size;
	unsigned char *buffer = (unsigned char*)buf;

	// enter recvall
	flags = flags | MSG_WAITALL;

	while (sizeleft > 0) {
		ssize_t i = recv(s, &buffer[totalreceived], sizeleft, flags);
		if (i == 0) {
			printf("recv returned 0\n");
			return i;
		}
		if (i == -1) {
			printf("recv returned -1\n");
			if (errno == EINTR) {
				printf("errno = EINTR\n");
				i = 0;
			} else {
				printf("Error during recvall: %d. errno=%d\n", (int)i, errno);
				return i; //read error, or disconnected
			}
		}
		totalreceived += i;
		sizeleft -= i;
	}
	// leave recvall
	return totalreceived;
}

ssize_t sendall(int s, void *buf, size_t size, int flags) {
	ssize_t totalsent = 0;
	ssize_t sizeleft = size;
	unsigned char *buffer = (unsigned char*)buf;

	while (sizeleft > 0) {
		ssize_t i = send(s, &buffer[totalsent], sizeleft, flags);

		if (i == 0) {
			return i;
		}

		if (i == -1) {
			if (errno == EINTR) {
				i = 0;
			} else {
				printf("Error during sendall: %d. errno=%d\n", (int)i, errno);
				return i;
			}
		}
		totalsent += i;
		sizeleft -= i;
	}

	return totalsent;
}



int DispatchCommand(int currentsocket, unsigned char command) {
	int r;
	switch (command) {
	case CMD_GETVERSION:
	{
		CeVersion *v;
		int versionsize = strlen(versionstring);
		v = (CeVersion*)malloc(sizeof(CeVersion) + versionsize);
		v->stringsize = versionsize;
		v->version = 1;

		memcpy((char *)v + sizeof(CeVersion), versionstring, versionsize);

		//version request
		sendall(currentsocket, v, sizeof(CeVersion) + versionsize, 0);

		free(v);

		break;
	}

	case CMD_GETARCHITECTURE:
	{
#ifdef __i386__
		unsigned char arch = 0;
#endif
#ifdef __x86_64__
		unsigned char arch = 1;
#endif
#ifdef __arm__
		unsigned char arch = 2;
#endif
#ifdef __aarch64__
		unsigned char arch = 3;
#endif

		sendall(currentsocket, &arch, sizeof(arch), 0);
		break;
	}

	case CMD_CLOSECONNECTION:
	{
		printf("Connection %d closed properly\n", currentsocket);
		fflush(stdout);
		close(currentsocket);

		return 0;
	}

	case CMD_TERMINATESERVER:
	{
		printf("Command to terminate the server received\n");
		fflush(stdout);
		close(currentsocket);
		exit(0);
	}

	case CMD_STARTDEBUG:
	{
		printf("[NOT SUPPORT!] CMD_STARTDEBUG\n");
		break;
	}
	case CMD_WAITFORDEBUGEVENT:
	{
		printf("[NOT SUPPORT!] CMD_WAITFORDEBUGEVENT\n");
		break;
	}
	case CMD_CONTINUEFROMDEBUGEVENT:
	{
		printf("[NOT SUPPORT!] CMD_CONTINUEFROMDEBUGEVENT\n");
		break;
	}
	case CMD_SETBREAKPOINT:
	{
		printf("[NOT SUPPORT!] CMD_SETBREAKPOINT\n");
		break;
	}
	case CMD_REMOVEBREAKPOINT:
	{
		printf("[NOT SUPPORT!] CMD_REMOVEBREAKPOINT\n");
		break;
	}

	case CMD_GETTHREADCONTEXT:
	{
		printf("[NOT SUPPORT!] CMD_GETTHREADCONTEXT\n");
		break;
	}
	case CMD_SETTHREADCONTEXT:
	{
		printf("[NOT SUPPORT!] CMD_SETTHREADCONTEXT\n");
		break;
	}
	case CMD_SUSPENDTHREAD:
	{
		printf("[NOT SUPPORT!] CMD_SUSPENDTHREAD\n");
		break;
	}
	case CMD_RESUMETHREAD:
	{
		printf("[NOT SUPPORT!] CMD_RESUMETHREAD\n");
		break;
	}
	case CMD_CLOSEHANDLE:
	{
		HANDLE h;
		if (recvall(currentsocket, &h, sizeof(h), MSG_WAITALL) > 0) {
			printf("CMD_CLOSEHANDLE(%d)\n", h);
			CApi::CloseHandle(h);
			int r = 1;
			sendall(currentsocket, &r, sizeof(r), 0); //stupid naggle
		} else {
			printf("Error during read for CMD_CLOSEHANDLE\n");
			close(currentsocket);
			fflush(stdout);
			return 0;
		}
		break;
	}

	case CMD_CREATETOOLHELP32SNAPSHOT:
	{
		CeCreateToolhelp32Snapshot params;
		HANDLE result;

		printf("CMD_CREATETOOLHELP32SNAPSHOT\n");

		if (recvall(currentsocket, &params, sizeof(CeCreateToolhelp32Snapshot), MSG_WAITALL) > 0) {
			//printf("Calling CreateToolhelp32Snapshot\n");

			result = CApi::CreateToolhelp32Snapshot(params.dwFlags, params.th32ProcessID);

			printf("result of CreateToolhelp32Snapshot=%d\n", result);

			fflush(stdout);
			sendall(currentsocket, &result, sizeof(HANDLE), 0);

		} else {
			printf("Error during read for CMD_CREATETOOLHELP32SNAPSHOT\n");
			fflush(stdout);
			close(currentsocket);
			return 0;
		}

		break;
	}

	case CMD_PROCESS32FIRST: //obsolete
	case CMD_PROCESS32NEXT:
	{
		HANDLE toolhelpsnapshot;
		if (recvall(currentsocket, &toolhelpsnapshot, sizeof(toolhelpsnapshot), MSG_WAITALL) > 0) {
			//printf("CMD_PROCESS32FIRST || CMD_PROCESS32NEXT %d\n", toolhelpsnapshot);

			ProcessListEntry pe;
			BOOL result = FALSE;
			CeProcessEntry *r;
			int size;

			if (command == CMD_PROCESS32FIRST) {
				result = CApi::Process32First(toolhelpsnapshot, pe);
				//printf("Process32First result=%d\n", result);
			} else {
				result = CApi::Process32Next(toolhelpsnapshot, pe);
				//printf("Process32Next result=%d\n", result);
			}

			if (result) {
				size = sizeof(CeProcessEntry) + pe.ProcessName.length();
				r = (CeProcessEntry*)malloc(size);
				r->processnamesize = pe.ProcessName.length();
				r->pid = pe.PID;
				memcpy((char *)r + sizeof(CeProcessEntry), pe.ProcessName.c_str(), r->processnamesize);
			} else {
				size = sizeof(CeProcessEntry);
				r = (CeProcessEntry*)malloc(size);
				r->processnamesize = 0;
				r->pid = 0;
			}
			r->result = result;
			sendall(currentsocket, r, size, 0);
			free(r);

		}
		break;
	}

	case CMD_MODULE32FIRST: //slightly obsolete now
	case CMD_MODULE32NEXT:
	{
		HANDLE toolhelpsnapshot;
		if (recvall(currentsocket, &toolhelpsnapshot, sizeof(toolhelpsnapshot), MSG_WAITALL) > 0) {
			BOOL result;
			ModuleListEntry me;
			CeModuleEntry *r;
			int size;

			if (command == CMD_MODULE32FIRST) {
				result = CApi::Module32First(toolhelpsnapshot, me);
			} else {
				result = CApi::Module32Next(toolhelpsnapshot, me);
			}

			if (result) {
				size = sizeof(CeModuleEntry) + me.moduleName.length();
				r = (CeModuleEntry*)malloc(size);
				r->modulebase = me.baseAddress;
				r->modulesize = me.moduleSize;
				r->modulenamesize = me.moduleName.length();
				//printf("%s\n", me.moduleName.c_str());

				// Sending %s size %x\n, me.moduleName, r->modulesize
				memcpy((char *)r + sizeof(CeModuleEntry), me.moduleName.c_str(), r->modulenamesize);
			} else {
				size = sizeof(CeModuleEntry);
				r = (CeModuleEntry*)malloc(size);
				r->modulebase = 0;
				r->modulesize = 0;
				r->modulenamesize = 0;
			}

			r->result = result;

			sendall(currentsocket, r, size, 0);

			free(r);
		}
		break;
	}

	case CMD_OPENPROCESS:
	{
		int pid = 0;

		r = recvall(currentsocket, &pid, sizeof(int), MSG_WAITALL);
		if (r > 0) {
			int processhandle;

			printf("OpenProcess(%d)\n", pid);
			processhandle = CApi::OpenProcess(pid);

			printf("processhandle=%d\n", processhandle);
			sendall(currentsocket, &processhandle, sizeof(int), 0);
		} else {
			printf("Error\n");
			fflush(stdout);
			close(currentsocket);
			return 0;
		}
		break;
	}

	case CMD_READPROCESSMEMORY:
	{
		CeReadProcessMemoryInput c;

		r = recvall(currentsocket, &c, sizeof(c), MSG_WAITALL);
		if (r > 0) {
			CeReadProcessMemoryOutput *o = NULL;
			o = (CeReadProcessMemoryOutput*)malloc(sizeof(CeReadProcessMemoryOutput) + c.size);
			memset(o, 0, sizeof(CeReadProcessMemoryOutput) + c.size);

			o->read = CApi::ReadProcessMemory(c.handle, (void *)(uintptr_t)c.address, &o[1], c.size);

			if (c.compress) {
				//printf("ReadProcessMemory compress %d %p %d\n", c.handle, c.address, c.size);

				//compress the output
#define COMPRESS_BLOCKSIZE (64*1024)
				int i;
				unsigned char *uncompressed = (unsigned char *)&o[1];
				uint32_t uncompressedSize = o->read;
				uint32_t compressedSize = 0;
				int maxBlocks = 1 + (c.size / COMPRESS_BLOCKSIZE);

				unsigned char **compressedBlocks = (unsigned char**)malloc(maxBlocks * sizeof(unsigned char *)); //send in blocks of 64kb and reallocate the pointerblock if there's not enough space
				int currentBlock = 0;

				z_stream strm;
				strm.zalloc = Z_NULL;
				strm.zfree = Z_NULL;
				strm.opaque = Z_NULL;
				deflateInit(&strm, c.compress);

				compressedBlocks[currentBlock] = (unsigned char*)malloc(COMPRESS_BLOCKSIZE);
				strm.avail_out = COMPRESS_BLOCKSIZE;
				strm.next_out = compressedBlocks[currentBlock];

				strm.next_in = uncompressed;
				strm.avail_in = uncompressedSize;

				while (strm.avail_in) {
					r = deflate(&strm, Z_NO_FLUSH);
					if (r != Z_OK) {
						if (r == Z_STREAM_END)
							break;
						else {
							printf("Error while compressing\n");
							break;
						}
					}

					if (strm.avail_out == 0) {
						//new output block
						currentBlock++;
						if (currentBlock >= maxBlocks) {
							//list was too short, reallocate
							printf("Need to realloc the pointerlist (p1)\n");

							maxBlocks *= 2;
							compressedBlocks = (unsigned char**)realloc(compressedBlocks, maxBlocks * sizeof(unsigned char*));
						}
						compressedBlocks[currentBlock] = (unsigned char*)malloc(COMPRESS_BLOCKSIZE);
						strm.avail_out = COMPRESS_BLOCKSIZE;
						strm.next_out = compressedBlocks[currentBlock];
					}
				}
				// finishing compressiong
				while (1) {

					r = deflate(&strm, Z_FINISH);

					if (r == Z_STREAM_END)
						break; //done

					if (r != Z_OK) {
						printf("Failure while finishing compression:%d\n", r);
						break;
					}

					if (strm.avail_out == 0) {
						//new output block
						currentBlock++;
						if (currentBlock >= maxBlocks) {
							//list was too short, reallocate
							printf("Need to realloc the pointerlist (p2)\n");
							maxBlocks *= 2;
							compressedBlocks = (unsigned char**)realloc(compressedBlocks, maxBlocks * sizeof(unsigned char*));
						}
						compressedBlocks[currentBlock] = (unsigned char*)malloc(COMPRESS_BLOCKSIZE);
						strm.avail_out = COMPRESS_BLOCKSIZE;
						strm.next_out = compressedBlocks[currentBlock];
					}
				}
				deflateEnd(&strm);

				compressedSize = strm.total_out;
				// Sending compressed data
				sendall(currentsocket, &uncompressedSize, sizeof(uncompressedSize), MSG_MORE); //followed by the compressed size
				sendall(currentsocket, &compressedSize, sizeof(compressedSize), MSG_MORE); //the compressed data follows
				for (i = 0; i <= currentBlock; i++) {
					if (i != currentBlock)
						sendall(currentsocket, compressedBlocks[i], COMPRESS_BLOCKSIZE, MSG_MORE);
					else
						sendall(currentsocket, compressedBlocks[i], COMPRESS_BLOCKSIZE - strm.avail_out, 0); //last one, flush

					free(compressedBlocks[i]);
				}
				free(compressedBlocks);
			} else {
				//printf("ReadProcessMemory Uncompress %d %p %d\n", c.handle, c.address, c.size);
				sendall(currentsocket, o, sizeof(CeReadProcessMemoryOutput) + o->read, 0);
			}

			if (o) {
				free(o);
			}
		}
		break;
	}

	case CMD_WRITEPROCESSMEMORY:
	{
		CeWriteProcessMemoryInput c;

		printf("CMD_WRITEPROCESSMEMORY:\n");

		r = recvall(currentsocket, &c, sizeof(c), MSG_WAITALL);
		if (r > 0) {
			CeWriteProcessMemoryOutput o;
			unsigned char *buf;

			printf("recv returned %d bytes\n", r);
			printf("c.size=%d\n", c.size);

			if (c.size) {
				buf = (unsigned char *)malloc(c.size);

				r = recvall(currentsocket, buf, c.size, MSG_WAITALL);
				if (r > 0) {
					printf("received %d bytes for the buffer. Wanted %d\n", r, c.size);
					o.written = CApi::WriteProcessMemory(c.handle, (void *)(uintptr_t)c.address, buf, c.size);

					r = sendall(currentsocket, &o, sizeof(CeWriteProcessMemoryOutput), 0);
					printf("wpm: returned %d bytes to caller\n", r);

				} else {
					printf("wpm recv error while reading the data\n");
				}
				free(buf);
			} else {
				printf("wpm with a size of 0 bytes");
				o.written = 0;
				r = sendall(currentsocket, &o, sizeof(CeWriteProcessMemoryOutput), 0);
				printf("wpm: returned %d bytes to caller\n", r);
			}
		} else {
			printf("RPM: recv failed\n");
		}
		break;
	}
	case CMD_VIRTUALQUERYEXFULL:
	{
		//printf("CMD_VIRTUALQUERYEXFULL\n");

		CeVirtualQueryExFullInput c;
		CeVirtualQueryExFullOutput o;

		r = recvall(currentsocket, &c, sizeof(c), MSG_WAITALL);
		if (r > 0) {
			std::vector<RegionInfo> vRinfo;
			if (CApi::VirtualQueryExFull(c.handle, c.flags, vRinfo)) {
				//printf("VirtualQueryExFull ok %d\n", vRinfo.size());
				uint32_t count = vRinfo.size();
				sendall(currentsocket, &count, sizeof(count), 0);

				for (RegionInfo r : vRinfo) {
					sendall(currentsocket, &r, sizeof(r), 0);
				}
				//printf("VirtualQueryExFull all %d\n", vRinfo.size());
			} else {
				//printf("VirtualQueryExFull no %d\n", vRinfo.size());
				uint32_t count = 0;
				sendall(currentsocket, &count, sizeof(count), 0);
			}
		}
		break;
	}
	case CMD_GETREGIONINFO:
	case CMD_VIRTUALQUERYEX:
	{

		CeVirtualQueryExInput c;
		r = recvall(currentsocket, &c, sizeof(c), MSG_WAITALL);
		if (r > 0) {
			RegionInfo rinfo;
			CeVirtualQueryExOutput o;
			if (sizeof(uintptr_t) == 4) {
				if (c.baseaddress > 0xFFFFFFFF) {
					o.result = 0;
					sendall(currentsocket, &o, sizeof(o), 0);
					break;
				}
			}

			std::string mapsline;

			if (command == CMD_VIRTUALQUERYEX) {
				//printf("CMD_VIRTUALQUERYEX\n");
				o.result = CApi::VirtualQueryEx(c.handle, c.baseaddress, rinfo, mapsline);
			} else if (command == CMD_GETREGIONINFO) {
				//printf("CMD_GETREGIONINFO\n");
				o.result = CApi::VirtualQueryEx(c.handle, c.baseaddress, rinfo, mapsline);
			}

			o.protection = rinfo.protection;
			o.baseaddress = rinfo.baseaddress;
			o.type = rinfo.type;
			o.size = rinfo.size;

			if (command == CMD_VIRTUALQUERYEX) {
				sendall(currentsocket, &o, sizeof(o), 0);
			} else	if (command == CMD_GETREGIONINFO) {
				sendall(currentsocket, &o, sizeof(o), MSG_MORE);
				{
					uint8_t size = mapsline.length();
					sendall(currentsocket, &size, sizeof(size), MSG_MORE);

					if (size) {
						sendall(currentsocket, (void*)mapsline.c_str(), size, 0);
					}

				}
			}


		}
		break;
	}


	case CMD_GETSYMBOLLISTFROMFILE:
	{
		//get the list and send it to the client
		//zip it first
		uint32_t symbolpathsize;

		printf("CMD_GETSYMBOLLISTFROMFILE\n");

		if (recvall(currentsocket, &symbolpathsize, sizeof(symbolpathsize), MSG_WAITALL) > 0) {
			char *symbolpath = (char *)malloc(symbolpathsize + 1);
			symbolpath[symbolpathsize] = '\0';

			if (recvall(currentsocket, symbolpath, symbolpathsize, MSG_WAITALL) > 0) {
				unsigned char *output = NULL;

				printf("symbolpath=%s\n", symbolpath);

				if (memcmp("/dev/", symbolpath, 5) != 0) //don't even bother if it's a /dev/ file
				{
					//因为这里需要open本地的.so文件，有可能会被反调试手段侦测到，而且作用不太大，所以暂时屏蔽掉。
					//解决方法一（待实现）：在被调试进程启动前，读取本地.so文件
					//GetSymbolListFromFile(symbolpath, &output);
				}
				if (output) {
					printf("output is not NULL (%p)\n", output);

					fflush(stdout);

					printf("Sending %d bytes\n", *(uint32_t *)&output[4]);
					sendall(currentsocket, output, *(uint32_t *)&output[4], 0); //the output buffer contains the size itself
					free(output);
				} else {

					printf("Sending 8 bytes (fail)\n");
					uint64_t fail = 0;
					sendall(currentsocket, &fail, sizeof(fail), 0); //just write 0
				}
			} else {
				printf("Failure getting symbol path\n");
				close(currentsocket);
			}

			free(symbolpath);
		}
		break;
	}

	case CMD_LOADEXTENSION:
	{
		printf("[NOT SUPPORT!] CMD_LOADEXTENSION\n");
		break;
	}

	case CMD_ALLOC:
	{
		printf("[NOT SUPPORT!] CMD_ALLOC\n");
		break;
	}
	case CMD_FREE:
	{
		printf("[NOT SUPPORT!] CMD_FREE\n");
		break;
	}

	case CMD_CREATETHREAD:
	{
		printf("[NOT SUPPORT!] CMD_CREATETHREAD\n");
		break;
	}
	case CMD_LOADMODULE:
	{
		printf("[NOT SUPPORT!] CMD_LOADMODULE\n");
		break;
	}
	case CMD_SPEEDHACK_SETSPEED:
	{
		printf("[NOT SUPPORT!] CMD_SPEEDHACK_SETSPEED\n");
		break;
	}
	case CMD_AOBSCAN:
	{
		CeAobScanInput c;
		printf("CESERVER: CMD_AOBSCAN\n");
		if (recvall(currentsocket, &c, sizeof(c), 0) > 0) {

			int n = c.scansize;
			char* data = (char*)malloc(n * 2);
			uint64_t* match_addr = (uint64_t*)malloc(sizeof(uint64_t) * MAX_HIT_COUNT);

			if (recvall(currentsocket, data, n * 2, 0) > 0) {
				char* pattern = (char*)malloc(n);
				char* mask = (char*)malloc(n);

				memcpy(pattern, data, n);
				memcpy(mask, &data[n], n);
				int ret = 0; //AOBScan(c.hProcess, pattern, mask, c.start, c.end, c.inc, c.protection, match_addr);
				printf("HIT_COUNT:%d\n", ret);
				free(pattern);
				free(mask);
				sendall(currentsocket, &ret, 4, 0);
				sendall(currentsocket, match_addr, sizeof(uint64_t)* ret, 0);
			}
			free(data);
			free(match_addr);
		}

		break;
	}
	default:
		printf("Unknow command:%d", command);
		fflush(stdout);
		break;
	}
	return 0;
}



void newConnectionThread(int s) {
	unsigned char command;

	int currentsocket = s;

	//printf("new connection. Using socket %d\n", s);
	while (1) {
		int r = recvall(currentsocket, &command, 1, MSG_WAITALL);

		if (r > 0) {
			DispatchCommand(currentsocket, command);
		} else
			if (r == -1) {
				printf("read error on socket %d (%d)\n", s, errno);
				fflush(stdout);
				close(currentsocket);
				return;
			} else {
				if (r == 0) {
					printf("Peer has disconnected\n");
					fflush(stdout);
					close(currentsocket);
					return;
				}
			}
	}
	close(s);
	return;
}

void IdentifierThread() {
	int i;
	int s;
	int v = 1;
#pragma pack(1)
	struct {
		uint32_t checksum;
		uint16_t port;
	} packet;
#pragma pack()

	socklen_t clisize;
	struct sockaddr_in addr, addr_client;

	printf("IdentifierThread active\n");

	fflush(stdout);

	s = socket(PF_INET, SOCK_DGRAM, 0);
	i = setsockopt(s, SOL_SOCKET, SO_BROADCAST, &v, sizeof(v));

	memset(&addr, 0, sizeof(addr));

	addr.sin_family = PF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	addr.sin_port = htons(3296);
	i = bind(s, (struct sockaddr *)&addr, sizeof(addr));

	if (i >= 0) {
		while (1) {
			memset(&addr_client, 0, sizeof(addr_client));
			addr_client.sin_family = PF_INET;
			addr_client.sin_addr.s_addr = INADDR_ANY;
			addr_client.sin_port = htons(3296);

			clisize = sizeof(addr_client);

			i = recvfrom(s, &packet, sizeof(packet), 0, (struct sockaddr *)&addr_client, &clisize);

			//i=recv(s, &v, sizeof(v), 0);
			if (i >= 0) {

				printf("Identifier thread received a message :%d\n", v);
				printf("sizeof(packet)=%d\n", (int)sizeof(packet));

				printf("packet.checksum=%x\n", packet.checksum);
				packet.checksum *= 0xce;
				packet.port = PORT;
				printf("packet.checksum=%x\n", packet.checksum);

				// packet.checksum=00AE98E7 - y=8C7F09E2

				fflush(stdout);

				i = sendto(s, &packet, sizeof(packet), 0, (struct sockaddr *)&addr_client, clisize);
				printf("sendto returned %d\n", i);
			} else {
				printf("recvfrom failed\n");
			}

			fflush(stdout);
		}
	} else {
		printf("IdentifierThread bind port failed\n");
	}
	printf("IdentifierThread exit\n");
	return;
}


int main(int argc, char *argv[]) {
	//驱动默认隐蔽通信密匙
	std::string procNodeAuthKey = "e84523d7b60d5d341a7c4d1861773ecd";
	if (argc > 1) {
		procNodeAuthKey = argv[1];
	}
	//初始化读写驱动
	if (!CApi::InitReadWriteDriver(procNodeAuthKey.c_str(), FALSE)) {
		printf("Init read write driver failed.\n");
		return 0;
	}

	socklen_t clisize;
	struct sockaddr_in addr, addr_client;

	printf("listening on port %d\n", PORT);

	printf("CEServer. Waiting for client connection\n");

	//if (broadcast)

	std::thread tdId(IdentifierThread);
	tdId.detach();

	int s = socket(AF_INET, SOCK_STREAM, 0);
	printf("socket=%d\n", s);

	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(PORT);
	addr.sin_addr.s_addr = INADDR_ANY;

	int optval = 1;
	setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)); //让端口释放后立即就可以被再次使用

	int b = bind(s, (struct sockaddr *)&addr, sizeof(addr));
	printf("bind=%d\n", b);


	if (b != -1) {
		int l = listen(s, 32);

		printf("listen=%d\n", l);

		clisize = sizeof(addr_client);
		memset(&addr_client, 0, sizeof(addr_client));

		fflush(stdout);

		while (1) {

			int a = accept(s, (struct sockaddr *)&addr_client, &clisize);

			printf("accept=%d\n", a);

			fflush(stdout);
			int opt = 1;
			setsockopt(a, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));

			if (a != -1) {
				std::thread tdConnect(newConnectionThread, a);
				tdConnect.detach();
			}
		}
	}

	printf("Terminate server\n");

	close(s);

	return 0;
}
```

`rwProcMem33Module/testDumpMem/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_C_INCLUDES += $(LOCAL_PATH)/libzip

LOCAL_CPPFLAGS += -std=c++20
LOCAL_CFLAGS += -fPIE -fvisibility=hidden
LOCAL_LDFLAGS += -fPIE -pie
LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true
LOCAL_MODULE    := testDumpMem.out

FILE_LIST += $(wildcard $(LOCAL_PATH)/libzip/*.c*)

LOCAL_SRC_FILES :=  $(FILE_LIST:$(LOCAL_PATH)/%=%) testDumpMem.cpp

LOCAL_LDLIBS := -lz

include $(BUILD_EXECUTABLE)

```

`rwProcMem33Module/testDumpMem/jni/Application.mk`:

```mk
APP_OPTIM := release
APP_ABI :=  arm64-v8a
APP_STL := c++_static
```

`rwProcMem33Module/testDumpMem/jni/libzip/config.h`:

```h
/* Config header for Android */
/* Define to 1 if you have the declaration of `tzname', and to 0 if you don't.
   */
/* #undef HAVE_DECL_TZNAME */

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you have the `fseeko' function. */
#define HAVE_FSEEKO 0

/* Define to 1 if you have the `ftello' function. */
#define HAVE_FTELLO 0

/* Define to 1 if you have the <fts.h> header file. */
#define HAVE_FTS_H 1

/* Define to 1 if you have the `getopt' function. */
#define HAVE_GETOPT 1

/* Define to 1 if the system has the type `int16_t'. */
#define HAVE_INT16_T 1

/* Define to 1 if the system has the type `int32_t'. */
#define HAVE_INT32_T 1

/* Define to 1 if the system has the type `int64_t'. */
#define HAVE_INT64_T 1

/* Define to 1 if the system has the type `int8_t'. */
#define HAVE_INT8_T 1

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 0

/* Define to 1 if you have the `MoveFileExA' function. */
/* #undef HAVE_MOVEFILEEXA */

/* Define to 1 if you have the `open' function. */
#define HAVE_OPEN 1

/* Define to 1 if you have the `snprintf' function. */
#define HAVE_SNPRINTF 1

/* Define to 1 if the system has the type `ssize_t'. */
#define HAVE_SSIZE_T 1

/* Define to 1 if you have the <stdbool.h> header file. */
#define HAVE_STDBOOL_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strcasecmp' function. */
#define HAVE_STRCASECMP 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if `tm_zone' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_ZONE 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if your `struct tm' has `tm_zone'. Deprecated, use
   `HAVE_STRUCT_TM_TM_ZONE' instead. */
#define HAVE_TM_ZONE 1

/* Define to 1 if you don't have `tm_zone' but do have the external array
   `tzname'. */
/* #undef HAVE_TZNAME */

/* Define to 1 if the system has the type `uint16_t'. */
#define HAVE_UINT16_T 1

/* Define to 1 if the system has the type `uint32_t'. */
#define HAVE_UINT32_T 1

/* Define to 1 if the system has the type `uint64_t'. */
#define HAVE_UINT64_T 1

/* Define to 1 if the system has the type `uint8_t'. */
#define HAVE_UINT8_T 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 or 0, depending whether the compiler supports simple visibility
   declarations. */
#define HAVE_VISIBILITY 1

/* Define to 1 if you have the `_close' function. */
/* #undef HAVE__CLOSE */

/* Define to 1 if you have the `_dup' function. */
/* #undef HAVE__DUP */

/* Define to 1 if you have the `_fdopen' function. */
/* #undef HAVE__FDOPEN */

/* Define to 1 if you have the `_fileno' function. */
/* #undef HAVE__FILENO */

/* Define to 1 if you have the `_open' function. */
/* #undef HAVE__OPEN */

/* Define to 1 if you have the `_snprintf' function. */
/* #undef HAVE__SNPRINTF */

/* Define to 1 if you have the `_strdup' function. */
/* #undef HAVE__STRDUP */

/* Define to 1 if you have the `_stricmp' function. */
/* #undef HAVE__STRICMP */

/* Define to the sub-directory in which libtool stores uninstalled libraries.
   */
#define LT_OBJDIR ".libs/"

/* Name of package */
#define PACKAGE "libzip"

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT "libzip@nih.at"

/* Define to the full name of this package. */
#define PACKAGE_NAME "libzip"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "libzip 1.0.1"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "libzip"

/* Define to the home page for this package. */
#define PACKAGE_URL ""

/* Define to the version of this package. */
#define PACKAGE_VERSION "1.0.1"

/* The size of `int', as computed by sizeof. */
#define SIZEOF_INT 4

/* The size of `long', as computed by sizeof. */
#define SIZEOF_LONG 8

/* The size of `long long', as computed by sizeof. */
#define SIZEOF_LONG_LONG 8

/* The size of `off_t', as computed by sizeof. */
#define SIZEOF_OFF_T 8

/* The size of `short', as computed by sizeof. */
#define SIZEOF_SHORT 2

/* The size of `size_t', as computed by sizeof. */
#define SIZEOF_SIZE_T 8

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Define to 1 if your <sys/time.h> declares `struct tm'. */
/* #undef TM_IN_SYS_TIME */

/* Version number of package */
#define VERSION "1.0.1"

/* Enable large inode numbers on Mac OS X 10.5.  */
#ifndef _DARWIN_USE_64_BIT_INODE
# define _DARWIN_USE_64_BIT_INODE 1
#endif

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */


#ifndef HAVE_SSIZE_T
#  if SIZEOF_SIZE_T == SIZEOF_INT
typedef int ssize_t;
#  elif SIZEOF_SIZE_T == SIZEOF_LONG
typedef long ssize_t;
#  elif SIZEOF_SIZE_T == SIZEOF_LONG_LONG
typedef long long ssize_t;
#  else
#error no suitable type for ssize_t found
#  endif
#endif


```

`rwProcMem33Module/testDumpMem/jni/libzip/mkstemp.c`:

```c
/* $NiH: mkstemp.c,v 1.3 2006/04/23 14:51:45 wiz Exp $ */

/* Adapted from NetBSB libc by Dieter Baron */

/*	NetBSD: gettemp.c,v 1.13 2003/12/05 00:57:36 uebayasi Exp 	*/

/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#ifndef O_BINARY
#define O_BINARY 0
#endif



int
_zip_mkstemp(char *path)
{
	int fd;   
	char *start, *trv;
	struct stat sbuf;
	pid_t pid;

	/* To guarantee multiple calls generate unique names even if
	   the file is not created. 676 different possibilities with 7
	   or more X's, 26 with 6 or less. */
	static char xtra[2] = "aa";
	int xcnt = 0;

	pid = getpid();

	/* Move to end of path and count trailing X's. */
	for (trv = path; *trv; ++trv)
		if (*trv == 'X')
			xcnt++;
		else
			xcnt = 0;	

	/* Use at least one from xtra.  Use 2 if more than 6 X's. */
	if (*(trv - 1) == 'X')
		*--trv = xtra[0];
	if (xcnt > 6 && *(trv - 1) == 'X')
		*--trv = xtra[1];

	/* Set remaining X's to pid digits with 0's to the left. */
	while (*--trv == 'X') {
		*trv = (pid % 10) + '0';
		pid /= 10;
	}

	/* update xtra for next call. */
	if (xtra[0] != 'z')
		xtra[0]++;
	else {
		xtra[0] = 'a';
		if (xtra[1] != 'z')
			xtra[1]++;
		else
			xtra[1] = 'a';
	}

	/*
	 * check the target directory; if you have six X's and it
	 * doesn't exist this runs for a *very* long time.
	 */
	for (start = trv + 1;; --trv) {
		if (trv <= path)
			break;
		if (*trv == '/') {
			*trv = '\0';
			if (stat(path, &sbuf))
				return (0);
			if (!S_ISDIR(sbuf.st_mode)) {
				errno = ENOTDIR;
				return (0);
			}
			*trv = '/';
			break;
		}
	}

	for (;;) {
		if ((fd=open(path, O_CREAT|O_EXCL|O_RDWR|O_BINARY, 0600)) >= 0)
			return (fd);
		if (errno != EEXIST)
			return (0);

		/* tricky little algorithm for backward compatibility */
		for (trv = start;;) {
			if (!*trv)
				return (0);
			if (*trv == 'z')
				*trv++ = 'a';
			else {
				if (isdigit((unsigned char)*trv))
					*trv = 'a';
				else
					++*trv;
				break;
			}
		}
	}
	/*NOTREACHED*/
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip.h`:

```h
#ifndef _HAD_ZIP_H
#define _HAD_ZIP_H

/*
  zip.h -- exported declarations.
  Copyright (C) 1999-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef ZIP_EXTERN
# ifndef ZIP_STATIC
#  ifdef _WIN32
#   define ZIP_EXTERN __declspec(dllimport)
#  elif defined(__GNUC__) && __GNUC__ >= 4
#   define ZIP_EXTERN __attribute__ ((visibility ("default")))
#  else
#   define ZIP_EXTERN
#  endif
# else
#  define ZIP_EXTERN
# endif
#endif

#ifdef __cplusplus
extern "C" {
#if 0
} /* fix autoindent */
#endif
#endif

#include <zipconf.h>

#include <sys/types.h>
#include <stdio.h>
#include <time.h>

/* flags for zip_open */

#define ZIP_CREATE           1
#define ZIP_EXCL             2
#define ZIP_CHECKCONS        4
#define ZIP_TRUNCATE         8
#define ZIP_RDONLY          16


/* flags for zip_name_locate, zip_fopen, zip_stat, ... */

#define ZIP_FL_NOCASE		1u /* ignore case on name lookup */
#define ZIP_FL_NODIR		2u /* ignore directory component */
#define ZIP_FL_COMPRESSED	4u /* read compressed data */
#define ZIP_FL_UNCHANGED	8u /* use original data, ignoring changes */
#define ZIP_FL_RECOMPRESS      16u /* force recompression of data */
#define ZIP_FL_ENCRYPTED       32u /* read encrypted data (implies ZIP_FL_COMPRESSED) */
#define ZIP_FL_ENC_GUESS        0u /* guess string encoding (is default) */
#define ZIP_FL_ENC_RAW         64u /* get unmodified string */
#define ZIP_FL_ENC_STRICT     128u /* follow specification strictly */
#define ZIP_FL_LOCAL	      256u /* in local header */
#define ZIP_FL_CENTRAL	      512u /* in central directory */
/*                           1024u    reserved for internal use */
#define ZIP_FL_ENC_UTF_8     2048u /* string is UTF-8 encoded */
#define ZIP_FL_ENC_CP437     4096u /* string is CP437 encoded */
#define ZIP_FL_OVERWRITE     8192u /* zip_file_add: if file with name exists, overwrite (replace) it */

/* archive global flags flags */

#define ZIP_AFL_RDONLY		2u /* read only -- cannot be cleared */


/* create a new extra field */

#define ZIP_EXTRA_FIELD_ALL	ZIP_UINT16_MAX
#define ZIP_EXTRA_FIELD_NEW	ZIP_UINT16_MAX


/* libzip error codes */

#define ZIP_ER_OK             0  /* N No error */
#define ZIP_ER_MULTIDISK      1  /* N Multi-disk zip archives not supported */
#define ZIP_ER_RENAME         2  /* S Renaming temporary file failed */
#define ZIP_ER_CLOSE          3  /* S Closing zip archive failed */
#define ZIP_ER_SEEK           4  /* S Seek error */
#define ZIP_ER_READ           5  /* S Read error */
#define ZIP_ER_WRITE          6  /* S Write error */
#define ZIP_ER_CRC            7  /* N CRC error */
#define ZIP_ER_ZIPCLOSED      8  /* N Containing zip archive was closed */
#define ZIP_ER_NOENT          9  /* N No such file */
#define ZIP_ER_EXISTS        10  /* N File already exists */
#define ZIP_ER_OPEN          11  /* S Can't open file */
#define ZIP_ER_TMPOPEN       12  /* S Failure to create temporary file */
#define ZIP_ER_ZLIB          13  /* Z Zlib error */
#define ZIP_ER_MEMORY        14  /* N Malloc failure */
#define ZIP_ER_CHANGED       15  /* N Entry has been changed */
#define ZIP_ER_COMPNOTSUPP   16  /* N Compression method not supported */
#define ZIP_ER_EOF           17  /* N Premature end of file */
#define ZIP_ER_INVAL         18  /* N Invalid argument */
#define ZIP_ER_NOZIP         19  /* N Not a zip archive */
#define ZIP_ER_INTERNAL      20  /* N Internal error */
#define ZIP_ER_INCONS        21  /* N Zip archive inconsistent */
#define ZIP_ER_REMOVE        22  /* S Can't remove file */
#define ZIP_ER_DELETED       23  /* N Entry has been deleted */
#define ZIP_ER_ENCRNOTSUPP   24  /* N Encryption method not supported */
#define ZIP_ER_RDONLY        25  /* N Read-only archive */ 
#define ZIP_ER_NOPASSWD      26  /* N No password provided */
#define ZIP_ER_WRONGPASSWD   27  /* N Wrong password provided */
#define ZIP_ER_OPNOTSUPP     28  /* N Operation not supported */
#define ZIP_ER_INUSE         29  /* N Resource still in use */
#define ZIP_ER_TELL          30  /* S Tell error */

/* type of system error value */

#define ZIP_ET_NONE	      0  /* sys_err unused */
#define ZIP_ET_SYS	      1  /* sys_err is errno */
#define ZIP_ET_ZLIB	      2  /* sys_err is zlib error code */

/* compression methods */

#define ZIP_CM_DEFAULT	      -1  /* better of deflate or store */
#define ZIP_CM_STORE	       0  /* stored (uncompressed) */
#define ZIP_CM_SHRINK	       1  /* shrunk */
#define ZIP_CM_REDUCE_1	       2  /* reduced with factor 1 */
#define ZIP_CM_REDUCE_2	       3  /* reduced with factor 2 */
#define ZIP_CM_REDUCE_3	       4  /* reduced with factor 3 */
#define ZIP_CM_REDUCE_4	       5  /* reduced with factor 4 */
#define ZIP_CM_IMPLODE	       6  /* imploded */
/* 7 - Reserved for Tokenizing compression algorithm */
#define ZIP_CM_DEFLATE	       8  /* deflated */
#define ZIP_CM_DEFLATE64       9  /* deflate64 */
#define ZIP_CM_PKWARE_IMPLODE 10  /* PKWARE imploding */
/* 11 - Reserved by PKWARE */
#define ZIP_CM_BZIP2          12  /* compressed using BZIP2 algorithm */
/* 13 - Reserved by PKWARE */
#define ZIP_CM_LZMA	      14  /* LZMA (EFS) */
/* 15-17 - Reserved by PKWARE */
#define ZIP_CM_TERSE	      18  /* compressed using IBM TERSE (new) */
#define ZIP_CM_LZ77           19  /* IBM LZ77 z Architecture (PFS) */
#define ZIP_CM_WAVPACK	      97  /* WavPack compressed data */
#define ZIP_CM_PPMD	      98  /* PPMd version I, Rev 1 */

/* encryption methods */

#define ZIP_EM_NONE	       0  /* not encrypted */
#define ZIP_EM_TRAD_PKWARE     1  /* traditional PKWARE encryption */
#if 0 /* Strong Encryption Header not parsed yet */
#define ZIP_EM_DES        0x6601  /* strong encryption: DES */
#define ZIP_EM_RC2_OLD    0x6602  /* strong encryption: RC2, version < 5.2 */
#define ZIP_EM_3DES_168   0x6603
#define ZIP_EM_3DES_112   0x6609
#define ZIP_EM_AES_128    0x660e
#define ZIP_EM_AES_192    0x660f
#define ZIP_EM_AES_256    0x6610
#define ZIP_EM_RC2        0x6702  /* strong encryption: RC2, version >= 5.2 */
#define ZIP_EM_RC4        0x6801
#endif
#define ZIP_EM_UNKNOWN    0xffff  /* unknown algorithm */

#define ZIP_OPSYS_DOS	  	0x00u
#define ZIP_OPSYS_AMIGA	 	0x01u
#define ZIP_OPSYS_OPENVMS	0x02u
#define ZIP_OPSYS_UNIX	  	0x03u
#define ZIP_OPSYS_VM_CMS	0x04u
#define ZIP_OPSYS_ATARI_ST	0x05u
#define ZIP_OPSYS_OS_2		0x06u
#define ZIP_OPSYS_MACINTOSH	0x07u
#define ZIP_OPSYS_Z_SYSTEM	0x08u
#define ZIP_OPSYS_CPM	  	0x09u
#define ZIP_OPSYS_WINDOWS_NTFS	0x0au
#define ZIP_OPSYS_MVS	  	0x0bu
#define ZIP_OPSYS_VSE	  	0x0cu
#define ZIP_OPSYS_ACORN_RISC	0x0du
#define ZIP_OPSYS_VFAT	  	0x0eu
#define ZIP_OPSYS_ALTERNATE_MVS	0x0fu
#define ZIP_OPSYS_BEOS	  	0x10u
#define ZIP_OPSYS_TANDEM	0x11u
#define ZIP_OPSYS_OS_400	0x12u
#define ZIP_OPSYS_OS_X	  	0x13u

#define ZIP_OPSYS_DEFAULT	ZIP_OPSYS_UNIX


enum zip_source_cmd {
    ZIP_SOURCE_OPEN,            /* prepare for reading */
    ZIP_SOURCE_READ,            /* read data */
    ZIP_SOURCE_CLOSE,           /* reading is done */
    ZIP_SOURCE_STAT,            /* get meta information */
    ZIP_SOURCE_ERROR,           /* get error information */
    ZIP_SOURCE_FREE,            /* cleanup and free resources */
    ZIP_SOURCE_SEEK,            /* set position for reading */
    ZIP_SOURCE_TELL,            /* get read position */
    ZIP_SOURCE_BEGIN_WRITE,     /* prepare for writing */
    ZIP_SOURCE_COMMIT_WRITE,    /* writing is done */
    ZIP_SOURCE_ROLLBACK_WRITE,  /* discard written changes */
    ZIP_SOURCE_WRITE,           /* write data */
    ZIP_SOURCE_SEEK_WRITE,      /* set position for writing */
    ZIP_SOURCE_TELL_WRITE,      /* get write position */
    ZIP_SOURCE_SUPPORTS,        /* check whether source supports command */
    ZIP_SOURCE_REMOVE           /* remove file */
};
typedef enum zip_source_cmd zip_source_cmd_t;

#define ZIP_SOURCE_MAKE_COMMAND_BITMASK(cmd)    (1<<(cmd))

#define ZIP_SOURCE_SUPPORTS_READABLE	(ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_OPEN) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_READ) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_CLOSE) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_STAT) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_ERROR) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_FREE))

#define ZIP_SOURCE_SUPPORTS_SEEKABLE	(ZIP_SOURCE_SUPPORTS_READABLE \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_SEEK) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_TELL) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_SUPPORTS))

#define ZIP_SOURCE_SUPPORTS_WRITABLE    (ZIP_SOURCE_SUPPORTS_SEEKABLE \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_BEGIN_WRITE) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_COMMIT_WRITE) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_ROLLBACK_WRITE) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_WRITE) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_SEEK_WRITE) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_TELL_WRITE) \
                                         | ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_REMOVE))

/* for use by sources */
struct zip_source_args_seek {
    zip_int64_t offset;
    int whence;
};

typedef struct zip_source_args_seek zip_source_args_seek_t;
#define ZIP_SOURCE_GET_ARGS(type, data, len, error) ((len) < sizeof(type) ? zip_error_set((error), ZIP_ER_INVAL, 0), (type *)NULL : (type *)(data))


/* error information */
/* use zip_error_*() to access */
struct zip_error {
    int zip_err;	/* libzip error code (ZIP_ER_*) */
    int sys_err;	/* copy of errno (E*) or zlib error code */
    char *str;		/* string representation or NULL */
};

#define ZIP_STAT_NAME			0x0001u
#define ZIP_STAT_INDEX			0x0002u
#define ZIP_STAT_SIZE			0x0004u
#define ZIP_STAT_COMP_SIZE		0x0008u
#define ZIP_STAT_MTIME			0x0010u
#define ZIP_STAT_CRC			0x0020u
#define ZIP_STAT_COMP_METHOD		0x0040u
#define ZIP_STAT_ENCRYPTION_METHOD	0x0080u
#define ZIP_STAT_FLAGS			0x0100u

struct zip_stat {
    zip_uint64_t valid;			/* which fields have valid values */
    const char *name;			/* name of the file */
    zip_uint64_t index;			/* index within archive */
    zip_uint64_t size;			/* size of file (uncompressed) */
    zip_uint64_t comp_size;		/* size of file (compressed) */
    time_t mtime;			/* modification time */
    zip_uint32_t crc;			/* crc of file data */
    zip_uint16_t comp_method;		/* compression method used */
    zip_uint16_t encryption_method;	/* encryption method used */
    zip_uint32_t flags;			/* reserved for future use */
};

struct zip;
struct zip_file;
struct zip_source;

typedef struct zip zip_t;
typedef struct zip_error zip_error_t;
typedef struct zip_file zip_file_t;
typedef struct zip_source zip_source_t;
typedef struct zip_stat zip_stat_t;

typedef zip_uint32_t zip_flags_t;    

typedef zip_int64_t (*zip_source_callback)(void *, void *, zip_uint64_t, zip_source_cmd_t);


#ifndef ZIP_DISABLE_DEPRECATED
ZIP_EXTERN zip_int64_t zip_add(zip_t *, const char *, zip_source_t *); /* use zip_file_add */
ZIP_EXTERN zip_int64_t zip_add_dir(zip_t *, const char *); /* use zip_dir_add */
ZIP_EXTERN const char *zip_get_file_comment(zip_t *, zip_uint64_t, int *, int); /* use zip_file_get_comment */
ZIP_EXTERN int zip_get_num_files(zip_t *);  /* use zip_get_num_entries instead */
ZIP_EXTERN int zip_rename(zip_t *, zip_uint64_t, const char *); /* use zip_file_rename */
ZIP_EXTERN int zip_replace(zip_t *, zip_uint64_t, zip_source_t *); /* use zip_file_replace */
ZIP_EXTERN int zip_set_file_comment(zip_t *, zip_uint64_t, const char *, int); /* use zip_file_set_comment */
ZIP_EXTERN int zip_error_get_sys_type(int); /* use zip_error_system_type */
ZIP_EXTERN void zip_error_get(zip_t *, int *, int *); /* use zip_get_error, zip_error_code_zip / zip_error_code_system */
ZIP_EXTERN int zip_error_to_str(char *, zip_uint64_t, int, int);
ZIP_EXTERN void zip_file_error_get(zip_file_t *, int *, int *); /* use zip_file_get_error, zip_error_code_zip / zip_error_code_system */
#endif

ZIP_EXTERN int zip_archive_set_tempdir(zip_t *, const char *);
ZIP_EXTERN int zip_close(zip_t *);
ZIP_EXTERN int zip_delete(zip_t *, zip_uint64_t);
ZIP_EXTERN zip_int64_t zip_dir_add(zip_t *, const char *, zip_flags_t);
ZIP_EXTERN void zip_discard(zip_t *);

ZIP_EXTERN zip_error_t *zip_get_error(zip_t *);
ZIP_EXTERN void zip_error_clear(zip_t *);
ZIP_EXTERN int zip_error_code_zip(const zip_error_t *);
ZIP_EXTERN int zip_error_code_system(const zip_error_t *);
ZIP_EXTERN void zip_error_fini(zip_error_t *);
ZIP_EXTERN void zip_error_init(zip_error_t *);
ZIP_EXTERN void zip_error_init_with_code(zip_error_t *, int);
ZIP_EXTERN void zip_error_set(zip_error_t *, int, int);
ZIP_EXTERN const char *zip_error_strerror(zip_error_t *);
ZIP_EXTERN int zip_error_system_type(const zip_error_t *);
ZIP_EXTERN zip_int64_t zip_error_to_data(const zip_error_t *, void *, zip_uint64_t);

ZIP_EXTERN int zip_fclose(zip_file_t *);
ZIP_EXTERN zip_t *zip_fdopen(int, int, int *);
ZIP_EXTERN zip_int64_t zip_file_add(zip_t *, const char *, zip_source_t *, zip_flags_t);
ZIP_EXTERN void zip_file_error_clear(zip_file_t *);
ZIP_EXTERN int zip_file_extra_field_delete(zip_t *, zip_uint64_t, zip_uint16_t, zip_flags_t);
ZIP_EXTERN int zip_file_extra_field_delete_by_id(zip_t *, zip_uint64_t, zip_uint16_t, zip_uint16_t, zip_flags_t);
ZIP_EXTERN int zip_file_extra_field_set(zip_t *, zip_uint64_t, zip_uint16_t, zip_uint16_t, const zip_uint8_t *, zip_uint16_t, zip_flags_t);
ZIP_EXTERN zip_int16_t zip_file_extra_fields_count(zip_t *, zip_uint64_t, zip_flags_t);
ZIP_EXTERN zip_int16_t zip_file_extra_fields_count_by_id(zip_t *, zip_uint64_t, zip_uint16_t, zip_flags_t);
ZIP_EXTERN const zip_uint8_t *zip_file_extra_field_get(zip_t *, zip_uint64_t, zip_uint16_t, zip_uint16_t *, zip_uint16_t *, zip_flags_t);
ZIP_EXTERN const zip_uint8_t *zip_file_extra_field_get_by_id(zip_t *, zip_uint64_t, zip_uint16_t, zip_uint16_t, zip_uint16_t *, zip_flags_t);
ZIP_EXTERN const char *zip_file_get_comment(zip_t *, zip_uint64_t, zip_uint32_t *, zip_flags_t);
ZIP_EXTERN zip_error_t *zip_file_get_error(zip_file_t *);
ZIP_EXTERN int zip_file_get_external_attributes(zip_t *, zip_uint64_t, zip_flags_t, zip_uint8_t *, zip_uint32_t *);
ZIP_EXTERN int zip_file_rename(zip_t *, zip_uint64_t, const char *, zip_flags_t);
ZIP_EXTERN int zip_file_replace(zip_t *, zip_uint64_t, zip_source_t *, zip_flags_t);
ZIP_EXTERN int zip_file_set_comment(zip_t *, zip_uint64_t, const char *, zip_uint16_t, zip_flags_t);
ZIP_EXTERN int zip_file_set_external_attributes(zip_t *, zip_uint64_t, zip_flags_t, zip_uint8_t, zip_uint32_t);
ZIP_EXTERN int zip_file_set_mtime(zip_t *, zip_uint64_t, time_t, zip_flags_t);
ZIP_EXTERN const char *zip_file_strerror(zip_file_t *);
ZIP_EXTERN zip_file_t *zip_fopen(zip_t *, const char *, zip_flags_t);
ZIP_EXTERN zip_file_t *zip_fopen_encrypted(zip_t *, const char *, zip_flags_t, const char *);
ZIP_EXTERN zip_file_t *zip_fopen_index(zip_t *, zip_uint64_t, zip_flags_t);
ZIP_EXTERN zip_file_t *zip_fopen_index_encrypted(zip_t *, zip_uint64_t, zip_flags_t, const char *);
ZIP_EXTERN zip_int64_t zip_fread(zip_file_t *, void *, zip_uint64_t);
ZIP_EXTERN const char *zip_get_archive_comment(zip_t *, int *, zip_flags_t);
ZIP_EXTERN int zip_get_archive_flag(zip_t *, zip_flags_t, zip_flags_t);
ZIP_EXTERN const char *zip_get_name(zip_t *, zip_uint64_t, zip_flags_t);
ZIP_EXTERN zip_int64_t zip_get_num_entries(zip_t *, zip_flags_t);
ZIP_EXTERN zip_int64_t zip_name_locate(zip_t *, const char *, zip_flags_t);
ZIP_EXTERN zip_t *zip_open(const char *, int, int *);
ZIP_EXTERN zip_t *zip_open_from_source(zip_source_t *, int, zip_error_t *);
ZIP_EXTERN int zip_set_archive_comment(zip_t *, const char *, zip_uint16_t);
ZIP_EXTERN int zip_set_archive_flag(zip_t *, zip_flags_t, int);
ZIP_EXTERN int zip_set_default_password(zip_t *, const char *);
ZIP_EXTERN int zip_set_file_compression(zip_t *, zip_uint64_t, zip_int32_t, zip_uint32_t);
ZIP_EXTERN int zip_source_begin_write(zip_source_t *);
ZIP_EXTERN zip_source_t *zip_source_buffer(zip_t *, const void *, zip_uint64_t, int);
ZIP_EXTERN zip_source_t *zip_source_buffer_create(const void *, zip_uint64_t, int, zip_error_t *);
ZIP_EXTERN int zip_source_close(zip_source_t *);
ZIP_EXTERN int zip_source_commit_write(zip_source_t *);
ZIP_EXTERN zip_error_t *zip_source_error(zip_source_t *src);
ZIP_EXTERN zip_source_t *zip_source_file(zip_t *, const char *, zip_uint64_t, zip_int64_t);
ZIP_EXTERN zip_source_t *zip_source_file_create(const char *, zip_uint64_t, zip_int64_t, zip_error_t *);
ZIP_EXTERN zip_source_t *zip_source_filep(zip_t *, FILE *, zip_uint64_t, zip_int64_t);
ZIP_EXTERN zip_source_t *zip_source_filep_create(FILE *, zip_uint64_t, zip_int64_t, zip_error_t *);
ZIP_EXTERN void zip_source_free(zip_source_t *);
ZIP_EXTERN zip_source_t *zip_source_function(zip_t *, zip_source_callback, void *);
ZIP_EXTERN zip_source_t *zip_source_function_create(zip_source_callback, void *, zip_error_t *);
ZIP_EXTERN int zip_source_is_deleted(zip_source_t *);
ZIP_EXTERN void zip_source_keep(zip_source_t *);
ZIP_EXTERN zip_int64_t zip_source_make_command_bitmap(zip_source_cmd_t, ...);
ZIP_EXTERN int zip_source_open(zip_source_t *);
ZIP_EXTERN zip_int64_t zip_source_read(zip_source_t *, void *, zip_uint64_t);
ZIP_EXTERN void zip_source_rollback_write(zip_source_t *);
ZIP_EXTERN int zip_source_seek(zip_source_t *, zip_int64_t, int);
ZIP_EXTERN zip_int64_t zip_source_seek_compute_offset(zip_uint64_t, zip_uint64_t, void *, zip_uint64_t, zip_error_t *);
ZIP_EXTERN int zip_source_seek_write(zip_source_t *, zip_int64_t, int);
ZIP_EXTERN int zip_source_stat(zip_source_t *, zip_stat_t *);
ZIP_EXTERN zip_int64_t zip_source_tell(zip_source_t *);
ZIP_EXTERN zip_int64_t zip_source_tell_write(zip_source_t *);
#ifdef _WIN32
ZIP_EXTERN zip_source_t *zip_source_win32a(zip_t *, const char *, zip_uint64_t, zip_int64_t);
ZIP_EXTERN zip_source_t *zip_source_win32a_create(const char *, zip_uint64_t, zip_int64_t, zip_error_t *);
ZIP_EXTERN zip_source_t *zip_source_win32handle(zip_t *, void *, zip_uint64_t, zip_int64_t);
ZIP_EXTERN zip_source_t *zip_source_win32handle_create(void *, zip_uint64_t, zip_int64_t, zip_error_t *);
ZIP_EXTERN zip_source_t *zip_source_win32w(zip_t *, const wchar_t *, zip_uint64_t, zip_int64_t);
ZIP_EXTERN zip_source_t *zip_source_win32w_create(const wchar_t *, zip_uint64_t, zip_int64_t, zip_error_t *);
#endif
ZIP_EXTERN zip_int64_t zip_source_write(zip_source_t *, const void *, zip_uint64_t);
ZIP_EXTERN zip_source_t *zip_source_zip(zip_t *, zip_t *, zip_uint64_t, zip_flags_t, zip_uint64_t, zip_int64_t);
ZIP_EXTERN int zip_stat(zip_t *, const char *, zip_flags_t, zip_stat_t *);
ZIP_EXTERN int zip_stat_index(zip_t *, zip_uint64_t, zip_flags_t, zip_stat_t *);
ZIP_EXTERN void zip_stat_init(zip_stat_t *);
ZIP_EXTERN const char *zip_strerror(zip_t *);
ZIP_EXTERN int zip_unchange(zip_t *, zip_uint64_t);
ZIP_EXTERN int zip_unchange_all(zip_t *);
ZIP_EXTERN int zip_unchange_archive(zip_t *);

#ifdef __cplusplus
}
#endif

#endif /* _HAD_ZIP_H */

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_add.c`:

```c
/*
  zip_add.c -- add file via callback function
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


/*
  NOTE: Return type is signed so we can return -1 on error.
        The index can not be larger than ZIP_INT64_MAX since the size
        of the central directory cannot be larger than
        ZIP_UINT64_MAX, and each entry is larger than 2 bytes.
*/

ZIP_EXTERN zip_int64_t
zip_add(zip_t *za, const char *name, zip_source_t *source)
{
    return zip_file_add(za, name, source, 0);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_add_dir.c`:

```c
/*
  zip_add_dir.c -- add directory
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


/* NOTE: Signed due to -1 on error.  See zip_add.c for more details. */

ZIP_EXTERN zip_int64_t
zip_add_dir(zip_t *za, const char *name)
{
    return zip_dir_add(za, name, 0);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_add_entry.c`:

```c
/*
  zip_add_entry.c -- create and init struct zip_entry
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


/* NOTE: Signed due to -1 on error.  See zip_add.c for more details. */

zip_int64_t
_zip_add_entry(zip_t *za)
{
    zip_uint64_t idx;

    if (za->nentry+1 >= za->nentry_alloc) {
	zip_entry_t *rentries;
	zip_uint64_t nalloc = za->nentry_alloc + 16;
	zip_uint64_t realloc_size = sizeof(struct zip_entry) * (size_t)nalloc;

	if (sizeof(struct zip_entry) * (size_t)za->nentry_alloc > realloc_size) {
	    zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	    return -1;
	}
	rentries = (zip_entry_t *)realloc(za->entry, sizeof(struct zip_entry) * (size_t)nalloc);
	if (!rentries) {
	    zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	    return -1;
	}
	za->entry = rentries;
	za->nentry_alloc = nalloc;
    }

    idx = za->nentry++;

    _zip_entry_init(za->entry+idx);

    return (zip_int64_t)idx;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_buffer.c`:

```c
/*
 zip_buffer.c -- bounds checked access to memory buffer
 Copyright (C) 2014 Dieter Baron and Thomas Klausner
 
 This file is part of libzip, a library to manipulate ZIP archives.
 The authors can be contacted at <libzip@nih.at>
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the
 distribution.
 3. The names of the authors may not be used to endorse or promote
 products derived from this software without specific prior
 written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>
#include <string.h>

#include "zipint.h"

zip_uint8_t *
_zip_buffer_data(zip_buffer_t *buffer)
{
    return buffer->data;
}


void
_zip_buffer_free(zip_buffer_t *buffer)
{
    if (buffer == NULL) {
        return;
    }
    
    if (buffer->free_data) {
        free(buffer->data);
    }
    
    free(buffer);
}


bool
_zip_buffer_eof(zip_buffer_t *buffer)
{
    return buffer->ok && buffer->offset == buffer->size;
}


zip_uint8_t *
_zip_buffer_get(zip_buffer_t *buffer, zip_uint64_t length)
{
    zip_uint8_t *data;
    
    if (!buffer->ok || buffer->offset + length < length || buffer->offset + length > buffer->size) {
        buffer->ok = false;
        return NULL;
    }
    
    data = buffer->data + buffer->offset;
    buffer->offset += length;
    return data;
}


zip_uint16_t
_zip_buffer_get_16(zip_buffer_t *buffer)
{
    zip_uint8_t *data = _zip_buffer_get(buffer, 2);
    
    if (data == NULL) {
        return 0;
    }
    
    return (zip_uint16_t)(data[0] + (data[1] << 8));
}


zip_uint32_t
_zip_buffer_get_32(zip_buffer_t *buffer)
{
    zip_uint8_t *data = _zip_buffer_get(buffer, 4);
    
    if (data == NULL) {
        return 0;
    }
    
    return ((((((zip_uint32_t)data[3] << 8) + data[2]) << 8) + data[1]) << 8) + data[0];
}


zip_uint64_t
_zip_buffer_get_64(zip_buffer_t *buffer)
{
    zip_uint8_t *data = _zip_buffer_get(buffer, 8);
    
    if (data == NULL) {
        return 0;
    }

    return ((zip_uint64_t)data[7] << 56) + ((zip_uint64_t)data[6] << 48) + ((zip_uint64_t)data[5] << 40) + ((zip_uint64_t)data[4] << 32) + ((zip_uint64_t)data[3] << 24) + ((zip_uint64_t)data[2] << 16) + ((zip_uint64_t)data[1] << 8) + (zip_uint64_t)data[0];
}



zip_uint8_t
_zip_buffer_get_8(zip_buffer_t *buffer)
{
    zip_uint8_t *data = _zip_buffer_get(buffer, 1);
    
    if (data == NULL) {
        return 0;
    }
    
    return data[0];
}


zip_uint64_t
_zip_buffer_left(zip_buffer_t *buffer)
{
    return buffer->ok ? buffer->size - buffer->offset : 0;
}


zip_buffer_t *
_zip_buffer_new(zip_uint8_t *data, zip_uint64_t size)
{
    bool free_data = (data == NULL);
    zip_buffer_t *buffer;
    
    if (data == NULL) {
        if ((data = (zip_uint8_t *)malloc(size)) == NULL) {
            return NULL;
        }
    }

    if ((buffer = (zip_buffer_t *)malloc(sizeof(*buffer))) == NULL) {
        if (free_data) {
            free(data);
        }
        return NULL;
    }
    
    buffer->ok = true;
    buffer->data = data;
    buffer->size = size;
    buffer->offset = 0;
    buffer->free_data = free_data;
    
    return buffer;
}


zip_buffer_t *
_zip_buffer_new_from_source(zip_source_t *src, zip_uint64_t size, zip_uint8_t *buf, zip_error_t *error)
{
    zip_buffer_t *buffer;
    
    if ((buffer = _zip_buffer_new(buf, size)) == NULL) {
        zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
    }
    
    if (_zip_read(src, buffer->data, size, error) < 0) {
        _zip_buffer_free(buffer);
        return NULL;
    }
    
    return buffer;
}


zip_uint64_t
_zip_buffer_offset(zip_buffer_t *buffer)
{
    return buffer->ok ? buffer->offset : 0;
}


bool
_zip_buffer_ok(zip_buffer_t *buffer)
{
    return buffer->ok;
}


int
_zip_buffer_put(zip_buffer_t *buffer, const void *src, size_t length)
{
    zip_uint8_t *dst = _zip_buffer_get(buffer, length);
    
    if (dst == NULL) {
        return -1;
    }
    
    memcpy(dst, src, length);
    return 0;
}


int
_zip_buffer_put_16(zip_buffer_t *buffer, zip_uint16_t i)
{
    zip_uint8_t *data = _zip_buffer_get(buffer, 2);
    
    if (data == NULL) {
        return -1;
    }

    data[0] = (zip_uint8_t)(i & 0xff);
    data[1] = (zip_uint8_t)((i >> 8) & 0xff);
    
    return 0;
}


int
_zip_buffer_put_32(zip_buffer_t *buffer, zip_uint32_t i)
{
    zip_uint8_t *data = _zip_buffer_get(buffer, 4);
    
    if (data == NULL) {
        return -1;
    }
    
    data[0] = (zip_uint8_t)(i & 0xff);
    data[1] = (zip_uint8_t)((i >> 8) & 0xff);
    data[2] = (zip_uint8_t)((i >> 16) & 0xff);
    data[3] = (zip_uint8_t)((i >> 24) & 0xff);
    
    return 0;
}


int
_zip_buffer_put_64(zip_buffer_t *buffer, zip_uint64_t i)
{
    zip_uint8_t *data = _zip_buffer_get(buffer, 8);
    
    if (data == NULL) {
        return -1;
    }
    
    data[0] = (zip_uint8_t)(i & 0xff);
    data[1] = (zip_uint8_t)((i >> 8) & 0xff);
    data[2] = (zip_uint8_t)((i >> 16) & 0xff);
    data[3] = (zip_uint8_t)((i >> 24) & 0xff);
    data[4] = (zip_uint8_t)((i >> 32) & 0xff);
    data[5] = (zip_uint8_t)((i >> 40) & 0xff);
    data[6] = (zip_uint8_t)((i >> 48) & 0xff);
    data[7] = (zip_uint8_t)((i >> 56) & 0xff);
    
    return 0;
}


int
_zip_buffer_put_8(zip_buffer_t *buffer, zip_uint8_t i)
{
    zip_uint8_t *data = _zip_buffer_get(buffer, 1);
    
    if (data == NULL) {
        return -1;
    }
    
    data[0] = i;
    
    return 0;
}


int
_zip_buffer_set_offset(zip_buffer_t *buffer, zip_uint64_t offset)
{
    if (offset > buffer->size) {
        buffer->ok = false;
        return -1;
    }
    
    buffer->ok = true;
    buffer->offset = offset;
    
    return 0;
}


zip_uint64_t
_zip_buffer_size(zip_buffer_t *buffer)
{
    return buffer->size;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_close.c`:

```c
/*
  zip_close.c -- close zip archive and update changes
  Copyright (C) 1999-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#include <errno.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <sys/types.h>
#include <sys/stat.h>
#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
#endif


/* max deflate size increase: size + ceil(size/16k)*5+6 */
#define MAX_DEFLATE_SIZE_32	4293656963u

static int add_data(zip_t *, zip_source_t *, zip_dirent_t *);
static int copy_data(zip_t *, zip_uint64_t);
static int copy_source(zip_t *, zip_source_t *);
static int write_cdir(zip_t *, const zip_filelist_t *, zip_uint64_t);


ZIP_EXTERN int
zip_close(zip_t *za)
{
    zip_uint64_t i, j, survivors;
    zip_int64_t off;
    int error;
    zip_filelist_t *filelist;
    int changed;

    if (za == NULL)
	return -1;

    changed = _zip_changed(za, &survivors);

    /* don't create zip files with no entries */
    if (survivors == 0) {
	if ((za->open_flags & ZIP_TRUNCATE) || changed) {
	    if (zip_source_remove(za->src) < 0) {
		_zip_error_set_from_source(&za->error, za->src);
		return -1;
	    }
	}
	zip_discard(za);
	return 0;
    }	       

    if (!changed) {
	zip_discard(za);
	return 0;
    }

    if (survivors > za->nentry) {
        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
        return -1;
    }
    
    if ((filelist=(zip_filelist_t *)malloc(sizeof(filelist[0])*(size_t)survivors)) == NULL)
	return -1;

    /* create list of files with index into original archive  */
    for (i=j=0; i<za->nentry; i++) {
	if (za->entry[i].deleted)
	    continue;

        if (j >= survivors) {
            free(filelist);
            zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
            return -1;
        }
        
	filelist[j].idx = i;
	j++;
    }
    if (j < survivors) {
        free(filelist);
        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
        return -1;
    }

    if (zip_source_begin_write(za->src) < 0) {
	_zip_error_set_from_source(&za->error, za->src);
	free(filelist);
	return -1;
    }
    
    error = 0;
    for (j=0; j<survivors; j++) {
	int new_data;
	zip_entry_t *entry;
	zip_dirent_t *de;

	i = filelist[j].idx;
	entry = za->entry+i;

	new_data = (ZIP_ENTRY_DATA_CHANGED(entry) || ZIP_ENTRY_CHANGED(entry, ZIP_DIRENT_COMP_METHOD));

	/* create new local directory entry */
	if (entry->changes == NULL) {
	    if ((entry->changes=_zip_dirent_clone(entry->orig)) == NULL) {
                zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
                error = 1;
                break;
	    }
	}
	de = entry->changes;

	if (_zip_read_local_ef(za, i) < 0) {
	    error = 1;
	    break;
	}

        if ((off = zip_source_tell_write(za->src)) < 0) {
            error = 1;
            break;
        }
        de->offset = (zip_uint64_t)off;

	if (new_data) {
	    zip_source_t *zs;

	    zs = NULL;
	    if (!ZIP_ENTRY_DATA_CHANGED(entry)) {
		if ((zs=_zip_source_zip_new(za, za, i, ZIP_FL_UNCHANGED, 0, 0, NULL)) == NULL) {
		    error = 1;
		    break;
		}
	    }

	    /* add_data writes dirent */
	    if (add_data(za, zs ? zs : entry->source, de) < 0) {
		error = 1;
		if (zs)
		    zip_source_free(zs);
		break;
	    }
	    if (zs)
		zip_source_free(zs);
	}
	else {
	    zip_uint64_t offset;

	    /* when copying data, all sizes are known -> no data descriptor needed */
	    de->bitflags &= (zip_uint16_t)~ZIP_GPBF_DATA_DESCRIPTOR;
	    if (_zip_dirent_write(za, de, ZIP_FL_LOCAL) < 0) {
		error = 1;
		break;
	    }
	    if ((offset=_zip_file_get_offset(za, i, &za->error)) == 0) {
		error = 1;
		break;
	    }
	    if (zip_source_seek(za->src, (zip_int64_t)offset, SEEK_SET) < 0) {
		_zip_error_set_from_source(&za->error, za->src);
		error = 1;
		break;
	    }
	    if (copy_data(za, de->comp_size) < 0) {
		error = 1;
		break;
	    }
	}
    }

    if (!error) {
	if (write_cdir(za, filelist, survivors) < 0)
	    error = 1;
    }

    free(filelist);

    if (!error) {
	if (zip_source_commit_write(za->src) != 0) {
	    _zip_error_set_from_source(&za->error, za->src);
	    error = 1;
	}
    }

    if (error) {
	zip_source_rollback_write(za->src);
	return -1;
    }

    zip_discard(za);
    
    return 0;
}


static int
add_data(zip_t *za, zip_source_t *src, zip_dirent_t *de)
{
    zip_int64_t offstart, offdata, offend;
    struct zip_stat st;
    zip_source_t *s2;
    int ret;
    int is_zip64;
    zip_flags_t flags;
    
    if (zip_source_stat(src, &st) < 0) {
	_zip_error_set_from_source(&za->error, src);
	return -1;
    }

    if ((st.valid & ZIP_STAT_COMP_METHOD) == 0) {
	st.valid |= ZIP_STAT_COMP_METHOD;
	st.comp_method = ZIP_CM_STORE;
    }

    if (ZIP_CM_IS_DEFAULT(de->comp_method) && st.comp_method != ZIP_CM_STORE)
	de->comp_method = st.comp_method;
    else if (de->comp_method == ZIP_CM_STORE && (st.valid & ZIP_STAT_SIZE)) {
	st.valid |= ZIP_STAT_COMP_SIZE;
	st.comp_size = st.size;
    }
    else {
	/* we'll recompress */
	st.valid &= ~ZIP_STAT_COMP_SIZE;
    }


    flags = ZIP_EF_LOCAL;

    if ((st.valid & ZIP_STAT_SIZE) == 0)
	flags |= ZIP_FL_FORCE_ZIP64;
    else {
	de->uncomp_size = st.size;
	
	if ((st.valid & ZIP_STAT_COMP_SIZE) == 0) {
	    if (( ((de->comp_method == ZIP_CM_DEFLATE || ZIP_CM_IS_DEFAULT(de->comp_method)) && st.size > MAX_DEFLATE_SIZE_32)
		  || (de->comp_method != ZIP_CM_STORE && de->comp_method != ZIP_CM_DEFLATE && !ZIP_CM_IS_DEFAULT(de->comp_method))))
		flags |= ZIP_FL_FORCE_ZIP64;
	}
	else
	    de->comp_size = st.comp_size;
    }

    if ((offstart = zip_source_tell_write(za->src)) < 0) {
        return -1;
    }

    /* as long as we don't support non-seekable output, clear data descriptor bit */
    de->bitflags &= (zip_uint16_t)~ZIP_GPBF_DATA_DESCRIPTOR;
    if ((is_zip64=_zip_dirent_write(za, de, flags)) < 0)
	return -1;


    if (st.comp_method == ZIP_CM_STORE || (ZIP_CM_IS_DEFAULT(de->comp_method) && st.comp_method != de->comp_method)) {
	zip_source_t *s_store, *s_crc;
	zip_compression_implementation comp_impl;
	
	if (st.comp_method != ZIP_CM_STORE) {
	    if ((comp_impl=_zip_get_compression_implementation(st.comp_method)) == NULL) {
		zip_error_set(&za->error, ZIP_ER_COMPNOTSUPP, 0);
		return -1;
	    }
	    if ((s_store=comp_impl(za, src, st.comp_method, ZIP_CODEC_DECODE)) == NULL) {
		/* error set by comp_impl */
		return -1;
	    }
	}
	else {
	    /* to have the same reference count to src as in the case where it's not stored */
	    zip_source_keep(src);
	    s_store = src;
	}

	s_crc = zip_source_crc(za, s_store, 0);
	zip_source_free(s_store);
	if (s_crc == NULL) {
	    return -1;
	}

	if (de->comp_method != ZIP_CM_STORE && ((st.valid & ZIP_STAT_SIZE) == 0 || st.size != 0)) {
	    if ((comp_impl=_zip_get_compression_implementation(de->comp_method)) == NULL) {
		zip_error_set(&za->error, ZIP_ER_COMPNOTSUPP, 0);
		zip_source_free(s_crc);
		return -1;
	    }
	    s2 = comp_impl(za, s_crc, de->comp_method, ZIP_CODEC_ENCODE);
	    zip_source_free(s_crc);
	    if (s2 == NULL) {
		return -1;
	    }
	}
	else {
	    s2 = s_crc;
	}
    }
    else {
	zip_source_keep(src);
	s2 = src;
    }

    if ((offdata = zip_source_tell_write(za->src)) < 0) {
        return -1;
    }

    ret = copy_source(za, s2);
	
    if (zip_source_stat(s2, &st) < 0)
	ret = -1;

    zip_source_free(s2);

    if (ret < 0)
	return -1;

    if ((offend = zip_source_tell_write(za->src)) < 0) {
        return -1;
    }

    if (zip_source_seek_write(za->src, offstart, SEEK_SET) < 0) {
	_zip_error_set_from_source(&za->error, za->src);
	return -1;
    }

    if ((st.valid & (ZIP_STAT_COMP_METHOD|ZIP_STAT_CRC|ZIP_STAT_SIZE)) != (ZIP_STAT_COMP_METHOD|ZIP_STAT_CRC|ZIP_STAT_SIZE)) {
	zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
	return -1;
    }

    if ((de->changed & ZIP_DIRENT_LAST_MOD) == 0) {
        if (st.valid & ZIP_STAT_MTIME)
            de->last_mod = st.mtime;
        else
            time(&de->last_mod);
    }
    de->comp_method = st.comp_method;
    de->crc = st.crc;
    de->uncomp_size = st.size;
    de->comp_size = (zip_uint64_t)(offend - offdata);

    if ((ret=_zip_dirent_write(za, de, flags)) < 0)
	return -1;
 
    if (is_zip64 != ret) {
	/* Zip64 mismatch between preliminary file header written before data and final file header written afterwards */
	zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
	return -1;
    }

   
    if (zip_source_seek_write(za->src, offend, SEEK_SET) < 0) {
	_zip_error_set_from_source(&za->error, za->src);
	return -1;
    }

    return 0;
}


static int
copy_data(zip_t *za, zip_uint64_t len)
{
    zip_uint8_t buf[BUFSIZE];
    size_t n;

    while (len > 0) {
	n = len > sizeof(buf) ? sizeof(buf) : len;
	if (_zip_read(za->src, buf, n, &za->error) < 0) {
	    return -1;
	}

	if (_zip_write(za, buf, n) < 0) {
	    return -1;
	}
	
	len -= n;
    }

    return 0;
}


static int
copy_source(zip_t *za, zip_source_t *src)
{
    zip_uint8_t buf[BUFSIZE];
    zip_int64_t n;
    int ret;

    if (zip_source_open(src) < 0) {
	_zip_error_set_from_source(&za->error, src);
	return -1;
    }

    ret = 0;
    while ((n=zip_source_read(src, buf, sizeof(buf))) > 0) {
	if (_zip_write(za, buf, (zip_uint64_t)n) < 0) {
	    ret = -1;
	    break;
	}
    }
    
    if (n < 0) {
	_zip_error_set_from_source(&za->error, src);
	ret = -1;
    }

    zip_source_close(src);
    
    return ret;
}


static int
write_cdir(zip_t *za, const zip_filelist_t *filelist, zip_uint64_t survivors)
{
    zip_int64_t cd_start, end, size;
    
    if ((cd_start = zip_source_tell_write(za->src)) < 0) {
        return -1;
    }

    if ((size=_zip_cdir_write(za, filelist, survivors)) < 0) {
	return -1;
    }
    
    if ((end = zip_source_tell_write(za->src)) < 0) {
        return -1;
    }

    return 0;
}


int
_zip_changed(const zip_t *za, zip_uint64_t *survivorsp)
{
    int changed;
    zip_uint64_t i, survivors;

    changed = 0;
    survivors = 0;

    if (za->comment_changed || za->ch_flags != za->flags)
	changed = 1;

    for (i=0; i<za->nentry; i++) {
	if (za->entry[i].deleted || za->entry[i].source || (za->entry[i].changes && za->entry[i].changes->changed != 0))
	    changed = 1;
	if (!za->entry[i].deleted)
	    survivors++;
    }

    if (survivorsp)
	*survivorsp = survivors;

    return changed;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_delete.c`:

```c
/*
  zip_delete.c -- delete file from zip archive
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_delete(zip_t *za, zip_uint64_t idx)
{
    if (idx >= za->nentry) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    /* allow duplicate file names, because the file will
     * be removed directly afterwards */
    if (_zip_unchange(za, idx, 1) != 0)
	return -1;

    za->entry[idx].deleted = 1;

    return 0;
}


```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_dir_add.c`:

```c
/*
  zip_dir_add.c -- add directory
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>
#include <string.h>

#include "zipint.h"


/* NOTE: Signed due to -1 on error.  See zip_add.c for more details. */

ZIP_EXTERN zip_int64_t
zip_dir_add(zip_t *za, const char *name, zip_flags_t flags)
{
    size_t len;
    zip_int64_t idx;
    char *s;
    zip_source_t *source;

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    if (name == NULL) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    s = NULL;
    len = strlen(name);

    if (name[len-1] != '/') {
	if ((s=(char *)malloc(len+2)) == NULL) {
	    zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	    return -1;
	}
	strcpy(s, name);
	s[len] = '/';
	s[len+1] = '\0';
    }

    if ((source=zip_source_buffer(za, NULL, 0, 0)) == NULL) {
	free(s);
	return -1;
    }
	
    idx = _zip_file_replace(za, ZIP_UINT64_MAX, s ? s : name, source, flags);

    free(s);

    if (idx < 0)
	zip_source_free(source);
    else {
	if (zip_file_set_external_attributes(za, (zip_uint64_t)idx, 0, ZIP_OPSYS_DEFAULT, ZIP_EXT_ATTRIB_DEFAULT_DIR) < 0) {
	    zip_delete(za, (zip_uint64_t)idx);
	    return -1;
	}
    }

    return idx;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_dirent.c`:

```c
/*
  zip_dirent.c -- read directory entry (local or central), clean dirent
  Copyright (C) 1999-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "zipint.h"

static time_t _zip_d2u_time(zip_uint16_t, zip_uint16_t);
static zip_string_t *_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str);
static zip_extra_field_t *_zip_ef_utf8(zip_uint16_t, zip_string_t *, zip_error_t *);


void
_zip_cdir_free(zip_cdir_t *cd)
{
    zip_uint64_t i;

    if (!cd)
	return;

    for (i=0; i<cd->nentry; i++)
	_zip_entry_finalize(cd->entry+i);
    free(cd->entry);
    _zip_string_free(cd->comment);
    free(cd);
}


zip_cdir_t *
_zip_cdir_new(zip_uint64_t nentry, zip_error_t *error)
{
    zip_cdir_t *cd;
    zip_uint64_t i;
    
    if ((cd=(zip_cdir_t *)malloc(sizeof(*cd))) == NULL) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    if (nentry == 0)
	cd->entry = NULL;
    else if ((nentry > SIZE_MAX/sizeof(*(cd->entry))) || (cd->entry=(zip_entry_t *)malloc(sizeof(*(cd->entry))*(size_t)nentry)) == NULL) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	free(cd);
	return NULL;
    }

    for (i=0; i<nentry; i++)
	_zip_entry_init(cd->entry+i);

    cd->nentry = cd->nentry_alloc = nentry;
    cd->size = cd->offset = 0;
    cd->comment = NULL;

    return cd;
}


zip_int64_t
_zip_cdir_write(zip_t *za, const zip_filelist_t *filelist, zip_uint64_t survivors)
{
    zip_uint64_t offset, size;
    zip_string_t *comment;
    zip_uint8_t buf[EOCDLEN + EOCD64LEN + EOCD64LOCLEN];
    zip_buffer_t *buffer;
    zip_int64_t off;
    zip_uint64_t i;
    bool is_zip64;
    int ret;

    if ((off = zip_source_tell_write(za->src)) < 0) {
        _zip_error_set_from_source(&za->error, za->src);
        return -1;
    }
    offset = (zip_uint64_t)off;

    is_zip64 = 0;

    for (i=0; i<survivors; i++) {
	zip_entry_t *entry = za->entry+filelist[i].idx;

	if ((ret=_zip_dirent_write(za, entry->changes ? entry->changes : entry->orig, ZIP_FL_CENTRAL)) < 0)
	    return -1;
	if (ret)
	    is_zip64 = true;
    }

    if ((off = zip_source_tell_write(za->src)) < 0) {
        _zip_error_set_from_source(&za->error, za->src);
        return -1;
    }
    size = (zip_uint64_t)off - offset;

    if (offset > ZIP_UINT32_MAX || survivors > ZIP_UINT16_MAX)
	is_zip64 = true;


    if ((buffer = _zip_buffer_new(buf, sizeof(buf))) == NULL) {
        zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
        return -1;
    }
    
    if (is_zip64) {
	_zip_buffer_put(buffer, EOCD64_MAGIC, 4);
        _zip_buffer_put_64(buffer, EOCD64LEN-12);
	_zip_buffer_put_16(buffer, 45);
	_zip_buffer_put_16(buffer, 45);
	_zip_buffer_put_32(buffer, 0);
	_zip_buffer_put_32(buffer, 0);
	_zip_buffer_put_64(buffer, survivors);
	_zip_buffer_put_64(buffer, survivors);
	_zip_buffer_put_64(buffer, size);
	_zip_buffer_put_64(buffer, offset);
	_zip_buffer_put(buffer, EOCD64LOC_MAGIC, 4);
	_zip_buffer_put_32(buffer, 0);
	_zip_buffer_put_64(buffer, offset+size);
	_zip_buffer_put_32(buffer, 1);
    }
    
    _zip_buffer_put(buffer, EOCD_MAGIC, 4);
    _zip_buffer_put_32(buffer, 0);
    _zip_buffer_put_16(buffer, (zip_uint16_t)(survivors >= ZIP_UINT16_MAX ? ZIP_UINT16_MAX : survivors));
    _zip_buffer_put_16(buffer, (zip_uint16_t)(survivors >= ZIP_UINT16_MAX ? ZIP_UINT16_MAX : survivors));
    _zip_buffer_put_32(buffer, size >= ZIP_UINT32_MAX ? ZIP_UINT32_MAX : (zip_uint32_t)size);
    _zip_buffer_put_32(buffer, offset >= ZIP_UINT32_MAX ? ZIP_UINT32_MAX : (zip_uint32_t)offset);

    comment = za->comment_changed ? za->comment_changes : za->comment_orig;

    _zip_buffer_put_16(buffer, (zip_uint16_t)(comment ? comment->length : 0));
    
    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
        _zip_buffer_free(buffer);
        return -1;
    }

    if (_zip_write(za, _zip_buffer_data(buffer), _zip_buffer_offset(buffer)) < 0) {
        _zip_buffer_free(buffer);
	return -1;
    }

    _zip_buffer_free(buffer);

    if (comment) {
	if (_zip_write(za, comment->raw, comment->length) < 0) {
	    return -1;
	}
    }

    return (zip_int64_t)size;
}


zip_dirent_t *
_zip_dirent_clone(const zip_dirent_t *sde)
{
    zip_dirent_t *tde;

    if ((tde=(zip_dirent_t *)malloc(sizeof(*tde))) == NULL)
	return NULL;

    if (sde)
	memcpy(tde, sde, sizeof(*sde));
    else
	_zip_dirent_init(tde);
    
    tde->changed = 0;
    tde->cloned = 1;

    return tde;
}


void
_zip_dirent_finalize(zip_dirent_t *zde)
{
    if (!zde->cloned || zde->changed & ZIP_DIRENT_FILENAME) {
	_zip_string_free(zde->filename);
	zde->filename = NULL;
    }
    if (!zde->cloned || zde->changed & ZIP_DIRENT_EXTRA_FIELD) {
	_zip_ef_free(zde->extra_fields);
	zde->extra_fields = NULL;
    }
    if (!zde->cloned || zde->changed & ZIP_DIRENT_COMMENT) {
	_zip_string_free(zde->comment);
	zde->comment = NULL;
    }
}


void
_zip_dirent_free(zip_dirent_t *zde)
{
    if (zde == NULL)
	return;

    _zip_dirent_finalize(zde);
    free(zde);
}


void
_zip_dirent_init(zip_dirent_t *de)
{
    de->changed = 0;
    de->local_extra_fields_read = 0;
    de->cloned = 0;

    de->version_madeby = 20 | (ZIP_OPSYS_DEFAULT << 8);
    de->version_needed = 20; /* 2.0 */
    de->bitflags = 0;
    de->comp_method = ZIP_CM_DEFAULT;
    de->last_mod = 0;
    de->crc = 0;
    de->comp_size = 0;
    de->uncomp_size = 0;
    de->filename = NULL;
    de->extra_fields = NULL;
    de->comment = NULL;
    de->disk_number = 0;
    de->int_attrib = 0;
    de->ext_attrib = ZIP_EXT_ATTRIB_DEFAULT;
    de->offset = 0;
}


bool
_zip_dirent_needs_zip64(const zip_dirent_t *de, zip_flags_t flags)
{
    if (de->uncomp_size >= ZIP_UINT32_MAX || de->comp_size >= ZIP_UINT32_MAX
	|| ((flags & ZIP_FL_CENTRAL) && de->offset >= ZIP_UINT32_MAX))
	return true;

    return false;
}


zip_dirent_t *
_zip_dirent_new(void)
{
    zip_dirent_t *de;

    if ((de=(zip_dirent_t *)malloc(sizeof(*de))) == NULL)
	return NULL;

    _zip_dirent_init(de);
    return de;
}


/* _zip_dirent_read(zde, fp, bufp, left, localp, error):
   Fills the zip directory entry zde.

   If buffer is non-NULL, data is taken from there; otherwise data is read from fp as needed.
   
   If local is true, it reads a local header instead of a central directory entry.

   Returns size of dirent read if successful. On error, error is filled in and -1 is returned.
*/

zip_int64_t
_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)
{
    zip_uint8_t buf[CDENTRYSIZE];
    zip_uint16_t dostime, dosdate;
    zip_uint32_t size, variable_size;
    zip_uint16_t filename_len, comment_len, ef_len;

    bool from_buffer = (buffer != NULL);
    
    size = local ? LENTRYSIZE : CDENTRYSIZE;

    if (buffer) {
        if (_zip_buffer_left(buffer) < size) {
            zip_error_set(error, ZIP_ER_NOZIP, 0);
            return -1;
        }
    }
    else {
        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {
            return -1;
        }
    }

    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {
	zip_error_set(error, ZIP_ER_NOZIP, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
	return -1;
    }

    /* convert buffercontents to zip_dirent */

    _zip_dirent_init(zde);
    if (!local)
	zde->version_madeby = _zip_buffer_get_16(buffer);
    else
	zde->version_madeby = 0;
    zde->version_needed = _zip_buffer_get_16(buffer);
    zde->bitflags = _zip_buffer_get_16(buffer);
    zde->comp_method = _zip_buffer_get_16(buffer);
    
    /* convert to time_t */
    dostime = _zip_buffer_get_16(buffer);
    dosdate = _zip_buffer_get_16(buffer);
    zde->last_mod = _zip_d2u_time(dostime, dosdate);
    
    zde->crc = _zip_buffer_get_32(buffer);
    zde->comp_size = _zip_buffer_get_32(buffer);
    zde->uncomp_size = _zip_buffer_get_32(buffer);
    
    filename_len = _zip_buffer_get_16(buffer);
    ef_len = _zip_buffer_get_16(buffer);
    
    if (local) {
	comment_len = 0;
	zde->disk_number = 0;
	zde->int_attrib = 0;
	zde->ext_attrib = 0;
	zde->offset = 0;
    } else {
	comment_len = _zip_buffer_get_16(buffer);
	zde->disk_number = _zip_buffer_get_16(buffer);
	zde->int_attrib = _zip_buffer_get_16(buffer);
	zde->ext_attrib = _zip_buffer_get_32(buffer);
	zde->offset = _zip_buffer_get_32(buffer);
    }
    
    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
        return -1;
    }

    zde->filename = NULL;
    zde->extra_fields = NULL;
    zde->comment = NULL;

    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;

    if (from_buffer) {
        if (_zip_buffer_left(buffer) < variable_size) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            return -1;
        }
    }
    else {
        _zip_buffer_free(buffer);
        
        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {
            return -1;
        }
    }

    if (filename_len) {
	zde->filename = _zip_read_string(buffer, src, filename_len, 1, error);
        if (!zde->filename) {
            if (zip_error_code_zip(error) == ZIP_ER_EOF) {
                zip_error_set(error, ZIP_ER_INCONS, 0);
            }
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }

	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
	    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
		zip_error_set(error, ZIP_ER_INCONS, 0);
                if (!from_buffer) {
                    _zip_buffer_free(buffer);
                }
		return -1;
	    }
	}
    }

    if (ef_len) {
	zip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);

        if (ef == NULL) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }
        if ((zde->extra_fields=_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error)) == NULL) {
	    free(ef);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
	}
	free(ef);
	if (local)
	    zde->local_extra_fields_read = 1;
    }

    if (comment_len) {
	zde->comment = _zip_read_string(buffer, src, comment_len, 0, error);
        if (!zde->comment) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }
	if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {
	    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {
		zip_error_set(error, ZIP_ER_INCONS, 0);
                if (!from_buffer) {
                    _zip_buffer_free(buffer);
                }
		return -1;
	    }
	}
    }

    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);
    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);

    /* Zip64 */

    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {
	zip_uint16_t got_len;
        zip_buffer_t *ef_buffer;
	const zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);
	/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */
        if (ef == NULL) {
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
	    return -1;
        }
        
        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {
            zip_error_set(error, ZIP_ER_MEMORY, 0);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
            return -1;
        }
	
	if (zde->uncomp_size == ZIP_UINT32_MAX)
	    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);
	else if (local)
	    ef += 8;
	if (zde->comp_size == ZIP_UINT32_MAX)
	    zde->comp_size = _zip_buffer_get_64(ef_buffer);
	if (!local) {
	    if (zde->offset == ZIP_UINT32_MAX)
		zde->offset = _zip_buffer_get_64(ef_buffer);
	    if (zde->disk_number == ZIP_UINT16_MAX)
		zde->disk_number = _zip_buffer_get_32(buffer);
	}
        
        if (!_zip_buffer_eof(ef_buffer)) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            _zip_buffer_free(ef_buffer);
            if (!from_buffer) {
                _zip_buffer_free(buffer);
            }
            return -1;
        }
        _zip_buffer_free(ef_buffer);
    }
    
    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        if (!from_buffer) {
            _zip_buffer_free(buffer);
        }
        return -1;
    }
    if (!from_buffer) {
        _zip_buffer_free(buffer);
    }

    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */
    if (zde->offset > ZIP_INT64_MAX) {
	zip_error_set(error, ZIP_ER_SEEK, EFBIG);
	return -1;
    }
    
    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);

    return (zip_int64_t)(size + variable_size);
}


static zip_string_t *
_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str)
{
    zip_uint16_t ef_len;
    zip_uint32_t ef_crc;
    zip_buffer_t *buffer;

    const zip_uint8_t *ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, id, 0, ZIP_EF_BOTH, NULL);
    
    if (ef == NULL || ef_len < 5 || ef[0] != 1) {
	return str;
    }
    
    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {
        return str;
    }
    
    _zip_buffer_get_8(buffer);
    ef_crc = _zip_buffer_get_32(buffer);

    if (_zip_string_crc32(str) == ef_crc) {
        zip_uint16_t len = (zip_uint16_t)_zip_buffer_left(buffer);
        zip_string_t *ef_str = _zip_string_new(_zip_buffer_get(buffer, len), len, ZIP_FL_ENC_UTF_8, NULL);

	if (ef_str != NULL) {
	    _zip_string_free(str);
	    str = ef_str;
	}
    }
    
    _zip_buffer_free(buffer);
    
    return str;
}


zip_int32_t
_zip_dirent_size(zip_source_t *src, zip_uint16_t flags, zip_error_t *error)
{
    zip_int32_t size;
    bool local = (flags & ZIP_EF_LOCAL) != 0;
    int i;
    zip_uint8_t b[6];
    zip_buffer_t *buffer;

    size = local ? LENTRYSIZE : CDENTRYSIZE;

    if (zip_source_seek(src, local ? 26 : 28, SEEK_CUR) < 0) {
        _zip_error_set_from_source(error, src);
	return -1;
    }
    
    if ((buffer = _zip_buffer_new_from_source(src, local ? 4 : 6, b, error)) == NULL) {
	return -1;
    }

    for (i=0; i<(local ? 2 : 3); i++) {
	size += _zip_buffer_get_16(buffer);
    }
    
    if (!_zip_buffer_eof(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
	_zip_buffer_free(buffer);
        return -1;
    }

    _zip_buffer_free(buffer);
    return size;
}


/* _zip_dirent_write
   Writes zip directory entry.

   If flags & ZIP_EF_LOCAL, it writes a local header instead of a central
   directory entry.  If flags & ZIP_EF_FORCE_ZIP64, a ZIP64 extra field is written, even if not needed.

   Returns 0 if successful, 1 if successful and wrote ZIP64 extra field. On error, error is filled in and -1 is
   returned.
*/

int
_zip_dirent_write(zip_t *za, zip_dirent_t *de, zip_flags_t flags)
{
    zip_uint16_t dostime, dosdate;
    zip_encoding_type_t com_enc, name_enc;
    zip_extra_field_t *ef;
    bool is_zip64;
    bool is_really_zip64;
    zip_uint8_t buf[CDENTRYSIZE];
    zip_buffer_t *buffer;

    ef = NULL;

    is_zip64 = false;

    name_enc = _zip_guess_encoding(de->filename, ZIP_ENCODING_UNKNOWN);
    com_enc = _zip_guess_encoding(de->comment, ZIP_ENCODING_UNKNOWN);

    if ((name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_ASCII) ||
	(name_enc == ZIP_ENCODING_ASCII && com_enc == ZIP_ENCODING_UTF8_KNOWN) ||
	(name_enc == ZIP_ENCODING_UTF8_KNOWN  && com_enc == ZIP_ENCODING_UTF8_KNOWN))
	de->bitflags |= ZIP_GPBF_ENCODING_UTF_8;
    else {
	de->bitflags &= (zip_uint16_t)~ZIP_GPBF_ENCODING_UTF_8;
	if (name_enc == ZIP_ENCODING_UTF8_KNOWN) {
	    ef = _zip_ef_utf8(ZIP_EF_UTF_8_NAME, de->filename, &za->error);
	    if (ef == NULL)
		return -1;
	}
	if ((flags & ZIP_FL_LOCAL) == 0 && com_enc == ZIP_ENCODING_UTF8_KNOWN){
	    zip_extra_field_t *ef2 = _zip_ef_utf8(ZIP_EF_UTF_8_COMMENT, de->comment, &za->error);
	    if (ef2 == NULL) {
		_zip_ef_free(ef);
		return -1;
	    }
	    ef2->next = ef;
	    ef = ef2;
	}
    }
    
    is_really_zip64 = _zip_dirent_needs_zip64(de, flags);
    is_zip64 = (flags & (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64)) == (ZIP_FL_LOCAL|ZIP_FL_FORCE_ZIP64) || is_really_zip64;
    
    if (is_zip64) {
        zip_uint8_t ef_zip64[EFZIP64SIZE];
        zip_buffer_t *ef_buffer = _zip_buffer_new(ef_zip64, sizeof(ef_zip64));
        if (ef_buffer == NULL) {
            zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	    _zip_ef_free(ef);
            return -1;
        }
        
        if (flags & ZIP_FL_LOCAL) {
            if ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX) {
                _zip_buffer_put_64(ef_buffer, de->uncomp_size);
                _zip_buffer_put_64(ef_buffer, de->comp_size);
            }
        }
        else {
            if ((flags & ZIP_FL_FORCE_ZIP64) || de->comp_size > ZIP_UINT32_MAX || de->uncomp_size > ZIP_UINT32_MAX || de->offset > ZIP_UINT32_MAX) {
                if (de->uncomp_size >= ZIP_UINT32_MAX) {
                    _zip_buffer_put_64(ef_buffer, de->uncomp_size);
                }
                if (de->comp_size >= ZIP_UINT32_MAX) {
                    _zip_buffer_put_64(ef_buffer, de->comp_size);
                }
                if (de->offset >= ZIP_UINT32_MAX) {
                    _zip_buffer_put_64(ef_buffer, de->offset);
                }
            }
        }
        
        if (!_zip_buffer_ok(ef_buffer)) {
            zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
            _zip_buffer_free(ef_buffer);
	    _zip_ef_free(ef);
            return -1;
        }

        zip_extra_field_t *ef64 = _zip_ef_new(ZIP_EF_ZIP64, (zip_uint16_t)(_zip_buffer_offset(ef_buffer)), ef_zip64, ZIP_EF_BOTH);
        _zip_buffer_free(ef_buffer);
        ef64->next = ef;
        ef = ef64;
    }

    if ((buffer = _zip_buffer_new(buf, sizeof(buf))) == NULL) {
        zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
        _zip_ef_free(ef);
        return -1;
    }
    
    _zip_buffer_put(buffer, (flags & ZIP_FL_LOCAL) ? LOCAL_MAGIC : CENTRAL_MAGIC, 4);
    
    if ((flags & ZIP_FL_LOCAL) == 0) {
        _zip_buffer_put_16(buffer, (zip_uint16_t)(is_really_zip64 ? 45 : de->version_madeby));
    }
    _zip_buffer_put_16(buffer, (zip_uint16_t)(is_really_zip64 ? 45 : de->version_needed));
    _zip_buffer_put_16(buffer, de->bitflags&0xfff9); /* clear compression method specific flags */
    _zip_buffer_put_16(buffer, (zip_uint16_t)de->comp_method);

    _zip_u2d_time(de->last_mod, &dostime, &dosdate);
    _zip_buffer_put_16(buffer, dostime);
    _zip_buffer_put_16(buffer, dosdate);

    _zip_buffer_put_32(buffer, de->crc);
    
    if (((flags & ZIP_FL_LOCAL) == ZIP_FL_LOCAL) && ((de->comp_size >= ZIP_UINT32_MAX) || (de->uncomp_size >= ZIP_UINT32_MAX))) {
	/* In local headers, if a ZIP64 EF is written, it MUST contain
	 * both compressed and uncompressed sizes (even if one of the
	 * two is smaller than 0xFFFFFFFF); on the other hand, those
	 * may only appear when the corresponding standard entry is
	 * 0xFFFFFFFF.  (appnote.txt 4.5.3) */
	_zip_buffer_put_32(buffer, ZIP_UINT32_MAX);
	_zip_buffer_put_32(buffer, ZIP_UINT32_MAX);
    }
    else {
        if (de->comp_size < ZIP_UINT32_MAX) {
	    _zip_buffer_put_32(buffer, (zip_uint32_t)de->comp_size);
        }
        else {
	    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);
        }
        if (de->uncomp_size < ZIP_UINT32_MAX) {
	    _zip_buffer_put_32(buffer, (zip_uint32_t)de->uncomp_size);
        }
        else {
	    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);
        }
    }

    _zip_buffer_put_16(buffer, _zip_string_length(de->filename));
    /* TODO: check for overflow */
    zip_uint32_t ef_total_size = (zip_uint32_t)_zip_ef_size(de->extra_fields, flags) + (zip_uint32_t)_zip_ef_size(ef, ZIP_EF_BOTH);
    _zip_buffer_put_16(buffer, (zip_uint16_t)ef_total_size);
    
    if ((flags & ZIP_FL_LOCAL) == 0) {
	_zip_buffer_put_16(buffer, _zip_string_length(de->comment));
	_zip_buffer_put_16(buffer, (zip_uint16_t)de->disk_number);
	_zip_buffer_put_16(buffer, de->int_attrib);
	_zip_buffer_put_32(buffer, de->ext_attrib);
	if (de->offset < ZIP_UINT32_MAX)
	    _zip_buffer_put_32(buffer, (zip_uint32_t)de->offset);
	else
	    _zip_buffer_put_32(buffer, ZIP_UINT32_MAX);
    }
    
    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
        _zip_buffer_free(buffer);
        _zip_ef_free(ef);
        return -1;
    }

    if (_zip_write(za, buf, _zip_buffer_offset(buffer)) < 0) {
        _zip_buffer_free(buffer);
        _zip_ef_free(ef);
        return -1;
    }
    
    _zip_buffer_free(buffer);

    if (de->filename) {
	if (_zip_string_write(za, de->filename) < 0) {
            _zip_ef_free(ef);
	    return -1;
	}
    }

    if (ef) {
	if (_zip_ef_write(za, ef, ZIP_EF_BOTH) < 0) {
            _zip_ef_free(ef);
	    return -1;
	}
    }
    _zip_ef_free(ef);
    if (de->extra_fields) {
	if (_zip_ef_write(za, de->extra_fields, flags) < 0) {
	    return -1;
	}
    }

    if ((flags & ZIP_FL_LOCAL) == 0) {
	if (de->comment) {
	    if (_zip_string_write(za, de->comment) < 0) {
		return -1;
	    }
	}
    }


    return is_zip64;
}


static time_t
_zip_d2u_time(zip_uint16_t dtime, zip_uint16_t ddate)
{
    struct tm tm;

    memset(&tm, 0, sizeof(tm));
    
    /* let mktime decide if DST is in effect */
    tm.tm_isdst = -1;
    
    tm.tm_year = ((ddate>>9)&127) + 1980 - 1900;
    tm.tm_mon = ((ddate>>5)&15) - 1;
    tm.tm_mday = ddate&31;

    tm.tm_hour = (dtime>>11)&31;
    tm.tm_min = (dtime>>5)&63;
    tm.tm_sec = (dtime<<1)&62;

    return mktime(&tm);
}


static zip_extra_field_t *
_zip_ef_utf8(zip_uint16_t id, zip_string_t *str, zip_error_t *error)
{
    const zip_uint8_t *raw;
    zip_uint32_t len;
    zip_buffer_t *buffer;
    zip_extra_field_t *ef;

    raw = _zip_string_get(str, &len, ZIP_FL_ENC_RAW, NULL);

    if (len+5 > ZIP_UINT16_MAX) {
        zip_error_set(error, ZIP_ER_INVAL, 0); /* TODO: better error code? */
        return NULL;
    }
    
    if ((buffer = _zip_buffer_new(NULL, len+5)) == NULL) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    _zip_buffer_put_8(buffer, 1);
    _zip_buffer_put_32(buffer, _zip_string_crc32(str));
    _zip_buffer_put(buffer, raw, len);

    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        _zip_buffer_free(buffer);
        return NULL;
    }
    
    ef = _zip_ef_new(id, (zip_uint16_t)(_zip_buffer_offset(buffer)), _zip_buffer_data(buffer), ZIP_EF_BOTH);
    _zip_buffer_free(buffer);

    return ef;
}


zip_dirent_t *
_zip_get_dirent(zip_t *za, zip_uint64_t idx, zip_flags_t flags, zip_error_t *error)
{
    if (error == NULL)
	error = &za->error;

    if (idx >= za->nentry) {
	zip_error_set(error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    if ((flags & ZIP_FL_UNCHANGED) || za->entry[idx].changes == NULL) {
	if (za->entry[idx].orig == NULL) {
	    zip_error_set(error, ZIP_ER_INVAL, 0);
	    return NULL;
	}
	if (za->entry[idx].deleted && (flags & ZIP_FL_UNCHANGED) == 0) {
	    zip_error_set(error, ZIP_ER_DELETED, 0);
	    return NULL;
	}
	return za->entry[idx].orig;
    }
    else
	return za->entry[idx].changes;
}




void
_zip_u2d_time(time_t intime, zip_uint16_t *dtime, zip_uint16_t *ddate)
{
    struct tm *tm;

    tm = localtime(&intime);
    *ddate = (zip_uint16_t)(((tm->tm_year+1900-1980)<<9) + ((tm->tm_mon+1)<<5) + tm->tm_mday);
    *dtime = (zip_uint16_t)(((tm->tm_hour)<<11) + ((tm->tm_min)<<5) + ((tm->tm_sec)>>1));

    return;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_discard.c`:

```c
/*
  zip_discard.c -- discard and free struct zip
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


/* zip_discard:
   frees the space allocated to a zipfile struct, and closes the
   corresponding file. */

void
zip_discard(zip_t *za)
{
    zip_uint64_t i;

    if (za == NULL)
	return;

    if (za->src) {
	zip_source_close(za->src);
	zip_source_free(za->src);
    }

    free(za->default_password);
    _zip_string_free(za->comment_orig);
    _zip_string_free(za->comment_changes);

    if (za->entry) {
	for (i=0; i<za->nentry; i++)
	    _zip_entry_finalize(za->entry+i);
	free(za->entry);
    }

    for (i=0; i<za->nopen_source; i++) {
	_zip_source_invalidate(za->open_source[i]);
    }
    free(za->open_source);

    zip_error_fini(&za->error);
    
    free(za);

    return;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_entry.c`:

```c
/*
  zip_entry.c -- struct zip_entry helper functions
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"

void
_zip_entry_finalize(zip_entry_t *e)
{
    _zip_unchange_data(e);
    _zip_dirent_free(e->orig);
    _zip_dirent_free(e->changes);
}


void
_zip_entry_init(zip_entry_t *e)
{
    e->orig = NULL;
    e->changes = NULL;
    e->source = NULL;
    e->deleted = 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_err_str.c`:

```c
/*
   This file was generated automatically by ./make_zip_err_str.sh
   from ./zip.h; make changes there.
 */

#include "zipint.h"

const char * const _zip_err_str[] = {
    "No error",
    "Multi-disk zip archives not supported",
    "Renaming temporary file failed",
    "Closing zip archive failed",
    "Seek error",
    "Read error",
    "Write error",
    "CRC error",
    "Containing zip archive was closed",
    "No such file",
    "File already exists",
    "Can't open file",
    "Failure to create temporary file",
    "Zlib error",
    "Malloc failure",
    "Entry has been changed",
    "Compression method not supported",
    "Premature end of file",
    "Invalid argument",
    "Not a zip archive",
    "Internal error",
    "Zip archive inconsistent",
    "Can't remove file",
    "Entry has been deleted",
    "Encryption method not supported",
    "Read-only archive", 
    "No password provided",
    "Wrong password provided",
    "Operation not supported",
    "Resource still in use",
    "Tell error",
};

const int _zip_nerr_str = sizeof(_zip_err_str)/sizeof(_zip_err_str[0]);

#define N ZIP_ET_NONE
#define S ZIP_ET_SYS
#define Z ZIP_ET_ZLIB

const int _zip_err_type[] = {
    N,
    N,
    S,
    S,
    S,
    S,
    S,
    N,
    N,
    N,
    N,
    S,
    S,
    Z,
    N,
    N,
    N,
    N,
    N,
    N,
    N,
    N,
    S,
    N,
    N,
    N, 
    N,
    N,
    N,
    N,
    S,
};

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_error.c`:

```c
/*
  zip_error.c -- zip_error_t helper functions
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <errno.h>
#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN int
zip_error_code_system(const zip_error_t *error) {
    return error->sys_err;
}


ZIP_EXTERN int
zip_error_code_zip(const zip_error_t *error) {
    return error->zip_err;
}


ZIP_EXTERN void
zip_error_fini(zip_error_t *err)
{
    free(err->str);
    err->str = NULL;
}


ZIP_EXTERN void
zip_error_init(zip_error_t *err)
{
    err->zip_err = ZIP_ER_OK;
    err->sys_err = 0;
    err->str = NULL;
}

ZIP_EXTERN void
zip_error_init_with_code(zip_error_t *error, int ze)
{
    zip_error_init(error);
    error->zip_err = ze;
    switch (zip_error_system_type(error)) {
    case ZIP_ET_SYS:
	error->sys_err = errno;
	break;

    default:
	error->sys_err = 0;
	break;
    }	
}


ZIP_EXTERN int
zip_error_system_type(const zip_error_t *error) {
    if (error->zip_err < 0 || error->zip_err >= _zip_nerr_str)
        return ZIP_ET_NONE;
    
    return _zip_err_type[error->zip_err];
}


void
_zip_error_clear(zip_error_t *err)
{
    if (err == NULL)
	return;

    err->zip_err = ZIP_ER_OK;
    err->sys_err = 0;
}


void
_zip_error_copy(zip_error_t *dst, const zip_error_t *src)
{
    dst->zip_err = src->zip_err;
    dst->sys_err = src->sys_err;
}


void
_zip_error_get(const zip_error_t *err, int *zep, int *sep)
{
    if (zep)
	*zep = err->zip_err;
    if (sep) {
	if (zip_error_system_type(err) != ZIP_ET_NONE)
	    *sep = err->sys_err;
	else
	    *sep = 0;
    }
}


void
zip_error_set(zip_error_t *err, int ze, int se)
{
    if (err) {
	err->zip_err = ze;
	err->sys_err = se;
    }
}


void
_zip_error_set_from_source(zip_error_t *err, zip_source_t *src)
{
    _zip_error_copy(err, zip_source_error(src));
}


zip_int64_t
zip_error_to_data(const zip_error_t *error, void *data, zip_uint64_t length)
{
    int *e = (int *)data;
    
    if (length < sizeof(int)*2) {
        return -1;
    }
    
    e[0] = zip_error_code_zip(error);
    e[1] = zip_error_code_system(error);
    return sizeof(int)*2;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_error_clear.c`:

```c
/*
  zip_error_clear.c -- clear zip error
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN void
zip_error_clear(zip_t *za)
{
    if (za == NULL)
	return;

    _zip_error_clear(&za->error);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_error_get.c`:

```c
/*
  zip_error_get.c -- get zip error
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


ZIP_EXTERN void
zip_error_get(zip_t *za, int *zep, int *sep)
{
    _zip_error_get(&za->error, zep, sep);
}


ZIP_EXTERN zip_error_t *
zip_get_error(zip_t *za)
{
    return &za->error;
}


ZIP_EXTERN zip_error_t *
zip_file_get_error(zip_file_t *f)
{
    return &f->error;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_error_get_sys_type.c`:

```c
/*
  zip_error_get_sys_type.c -- return type of system error code
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


ZIP_EXTERN int
zip_error_get_sys_type(int ze)
{
    if (ze < 0 || ze >= _zip_nerr_str)
	return 0;

    return _zip_err_type[ze];
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_error_strerror.c`:

```c
/*
  zip_error_sterror.c -- get string representation of struct zip_error
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "zipint.h"


ZIP_EXTERN const char *
zip_error_strerror(zip_error_t *err)
{
    const char *zs, *ss;
    char buf[128], *s;

    zip_error_fini(err);

    if (err->zip_err < 0 || err->zip_err >= _zip_nerr_str) {
	sprintf(buf, "Unknown error %d", err->zip_err);
	zs = NULL;
	ss = buf;
    }
    else {
	zs = _zip_err_str[err->zip_err];
	
	switch (_zip_err_type[err->zip_err]) {
	case ZIP_ET_SYS:
	    ss = strerror(err->sys_err);
	    break;

	case ZIP_ET_ZLIB:
	    ss = zError(err->sys_err);
	    break;

	default:
	    ss = NULL;
	}
    }

    if (ss == NULL)
	return zs;
    else {
	if ((s=(char *)malloc(strlen(ss)
			      + (zs ? strlen(zs)+2 : 0) + 1)) == NULL)
	    return _zip_err_str[ZIP_ER_MEMORY];
	
	sprintf(s, "%s%s%s",
		(zs ? zs : ""),
		(zs ? ": " : ""),
		ss);
	err->str = s;

	return s;
    }
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_error_to_str.c`:

```c
/*
  zip_error_to_str.c -- get string representation of zip error code
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


ZIP_EXTERN int
zip_error_to_str(char *buf, zip_uint64_t len, int ze, int se)
{
    const char *zs, *ss;

    if (ze < 0 || ze >= _zip_nerr_str)
	return snprintf(buf, len, "Unknown error %d", ze);

    zs = _zip_err_str[ze];
	
    switch (_zip_err_type[ze]) {
    case ZIP_ET_SYS:
	ss = strerror(se);
	break;
	
    case ZIP_ET_ZLIB:
	ss = zError(se);
	break;
	
    default:
	ss = NULL;
    }

    return snprintf(buf, len, "%s%s%s",
		    zs, (ss ? ": " : ""), (ss ? ss : ""));
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_extra_field.c`:

```c
/*
  zip_extra_field.c -- manipulate extra fields
  Copyright (C) 2012-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"

#include <errno.h>
#include <stdlib.h>
#include <string.h>


zip_extra_field_t *
_zip_ef_clone(const zip_extra_field_t *ef, zip_error_t *error)
{
    zip_extra_field_t *head, *prev, *def;
    
    head = prev = NULL;
    
    while (ef) {
        if ((def=_zip_ef_new(ef->id, ef->size, ef->data, ef->flags)) == NULL) {
            zip_error_set(error, ZIP_ER_MEMORY, 0);
            _zip_ef_free(head);
            return NULL;
        }
        
        if (head == NULL)
            head = def;
        if (prev)
            prev->next = def;
        prev = def;

	ef = ef->next;
    }
    
    return head;
}


zip_extra_field_t *
_zip_ef_delete_by_id(zip_extra_field_t *ef, zip_uint16_t id, zip_uint16_t id_idx, zip_flags_t flags)
{
    zip_extra_field_t *head, *prev;
    int i;

    i = 0;
    head = ef;
    prev = NULL;
    for (; ef; ef=(prev ? prev->next : head)) {
	if ((ef->flags & flags & ZIP_EF_BOTH) && ((ef->id == id) || (id == ZIP_EXTRA_FIELD_ALL))) {
	    if (id_idx == ZIP_EXTRA_FIELD_ALL || i == id_idx) {
		ef->flags &= ~(flags & ZIP_EF_BOTH);
		if ((ef->flags & ZIP_EF_BOTH) == 0) {
		    if (prev)
			prev->next = ef->next;
		    else
			head = ef->next;
		    ef->next = NULL;
		    _zip_ef_free(ef);

		    if (id_idx == ZIP_EXTRA_FIELD_ALL)
			continue;
		}
	    }
	    
	    i++;
	    if (i > id_idx)
		break;
	}
	prev = ef;
    }

    return head;
}



void
_zip_ef_free(zip_extra_field_t *ef)
{
    zip_extra_field_t *ef2;

    while (ef) {
	ef2 = ef->next;
	free(ef->data);
	free(ef);
	ef = ef2;
    }
}


const zip_uint8_t *
_zip_ef_get_by_id(const zip_extra_field_t *ef, zip_uint16_t *lenp, zip_uint16_t id, zip_uint16_t id_idx, zip_flags_t flags, zip_error_t *error)
{
    static const zip_uint8_t empty[1] = { '\0' };
    
    int i;

    i = 0;
    for (; ef; ef=ef->next) {
	if (ef->id == id && (ef->flags & flags & ZIP_EF_BOTH)) {
	    if (i < id_idx) {
		i++;
		continue;
	    }

	    if (lenp)
		*lenp = ef->size;
	    if (ef->size > 0)
		return ef->data;
	    else
		return empty;
	}
    }

    zip_error_set(error, ZIP_ER_NOENT, 0);
    return NULL;
}


zip_extra_field_t *
_zip_ef_merge(zip_extra_field_t *to, zip_extra_field_t *from)
{
    zip_extra_field_t *ef2, *tt, *tail;
    int duplicate;

    if (to == NULL)
	return from;

    for (tail=to; tail->next; tail=tail->next)
	;

    for (; from; from=ef2) {
	ef2 = from->next;

	duplicate = 0;
	for (tt=to; tt; tt=tt->next) {
	    if (tt->id == from->id && tt->size == from->size && memcmp(tt->data, from->data, tt->size) == 0) {
		tt->flags |= (from->flags & ZIP_EF_BOTH);
		duplicate = 1;
		break;
	    }
	}

	from->next = NULL;
	if (duplicate)
	    _zip_ef_free(from);
	else
	    tail = tail->next = from;
    }

    return to;
}


zip_extra_field_t *
_zip_ef_new(zip_uint16_t id, zip_uint16_t size, const zip_uint8_t *data, zip_flags_t flags)
{
    zip_extra_field_t *ef;

    if ((ef=(zip_extra_field_t *)malloc(sizeof(*ef))) == NULL)
	return NULL;

    ef->next = NULL;
    ef->flags = flags;
    ef->id = id;
    ef->size = size;
    if (size > 0) {
	if ((ef->data=(zip_uint8_t *)_zip_memdup(data, size, NULL)) == NULL) {
	    free(ef);
	    return NULL;
	}
    }
    else
	ef->data = NULL;

    return ef;
}


zip_extra_field_t *
_zip_ef_parse(const zip_uint8_t *data, zip_uint16_t len, zip_flags_t flags, zip_error_t *error)
{
    zip_buffer_t *buffer;
    zip_extra_field_t *ef, *ef2, *ef_head;

    if ((buffer = _zip_buffer_new((zip_uint8_t *)data, len)) == NULL) {
        zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
    }
    
    ef_head = ef = NULL;
    
    while (_zip_buffer_ok(buffer) && !_zip_buffer_eof(buffer)) {
        zip_uint16_t fid, flen;
        zip_uint8_t *ef_data;
        
        fid = _zip_buffer_get_16(buffer);
	flen = _zip_buffer_get_16(buffer);
        ef_data = _zip_buffer_get(buffer, flen);

        if (ef_data == NULL) {
            break;
        }
        
	if ((ef2=_zip_ef_new(fid, flen, ef_data, flags)) == NULL) {
	    zip_error_set(error, ZIP_ER_MEMORY, 0);
            _zip_buffer_free(buffer);
	    _zip_ef_free(ef_head);
	    return NULL;
	}

	if (ef_head) {
	    ef->next = ef2;
	    ef = ef2;
	}
	else
	    ef_head = ef = ef2;
    }

    if (!_zip_buffer_eof(buffer)) {
        zip_error_set(error, ZIP_ER_INCONS, 0);
        _zip_buffer_free(buffer);
        _zip_ef_free(ef_head);
        return NULL;
    }

    _zip_buffer_free(buffer);
    
    return ef_head;
}


zip_extra_field_t *
_zip_ef_remove_internal(zip_extra_field_t *ef)
{
    zip_extra_field_t *ef_head;
    zip_extra_field_t *prev, *next;
    
    ef_head = ef;
    prev = NULL;
    
    while (ef) {
        if (ZIP_EF_IS_INTERNAL(ef->id)) {
            next = ef->next;
            if (ef_head == ef)
                ef_head = next;
            ef->next = NULL;
            _zip_ef_free(ef);
            if (prev)
                prev->next = next;
            ef = next;
        }
        else {
            prev = ef;
            ef = ef->next;
        }
    }
    
    return ef_head;
}


zip_uint16_t
_zip_ef_size(const zip_extra_field_t *ef, zip_flags_t flags)
{
    zip_uint16_t size;

    size = 0;
    for (; ef; ef=ef->next) {
	if (ef->flags & flags & ZIP_EF_BOTH)
	    size = (zip_uint16_t)(size+4+ef->size);
    }

    return size;
}


int
_zip_ef_write(zip_t *za, const zip_extra_field_t *ef, zip_flags_t flags)
{
    zip_uint8_t b[4];
    zip_buffer_t *buffer = _zip_buffer_new(b, sizeof(b));

    if (buffer == NULL) {
	return -1;
    }

    for (; ef; ef=ef->next) {
	if (ef->flags & flags & ZIP_EF_BOTH) {
            _zip_buffer_set_offset(buffer, 0);
            _zip_buffer_put_16(buffer, ef->id);
	    _zip_buffer_put_16(buffer, ef->size);
            if (!_zip_buffer_ok(buffer)) {
                zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
                _zip_buffer_free(buffer);
                return -1;
            }
	    if (_zip_write(za, b, 4) < 0) {
                _zip_buffer_free(buffer);
                return -1;
	    }
	    if (ef->size > 0) {
		if (_zip_write(za, ef->data, ef->size) < 0) {
                    _zip_buffer_free(buffer);
                    return -1;
		}
	    }
	}
    }
    
    _zip_buffer_free(buffer);
    return 0;
}


int
_zip_read_local_ef(zip_t *za, zip_uint64_t idx)
{
    zip_entry_t *e;
    unsigned char b[4];
    zip_buffer_t *buffer;
    zip_uint16_t fname_len, ef_len;

    if (idx >= za->nentry) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    e = za->entry+idx;

    if (e->orig == NULL || e->orig->local_extra_fields_read)
	return 0;

    if (e->orig->offset + 26 > ZIP_INT64_MAX) {
	zip_error_set(&za->error, ZIP_ER_SEEK, EFBIG);
	return -1;
    }	

    if (zip_source_seek(za->src, (zip_int64_t)(e->orig->offset + 26), SEEK_SET) < 0) {
	_zip_error_set_from_source(&za->error, za->src);
	return -1;
    }
    
    if ((buffer = _zip_buffer_new_from_source(za->src, sizeof(b), b, &za->error)) == NULL) {
        return -1;
    }
    
    fname_len = _zip_buffer_get_16(buffer);
    ef_len = _zip_buffer_get_16(buffer);
    
    if (!_zip_buffer_eof(buffer)) {
        _zip_buffer_free(buffer);
        zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
        return -1;
    }
    
    _zip_buffer_free(buffer);
    
    if (ef_len > 0) {
	zip_extra_field_t *ef;
	zip_uint8_t *ef_raw;

	if (zip_source_seek(za->src, fname_len, SEEK_CUR) < 0) {
	    zip_error_set(&za->error, ZIP_ER_SEEK, errno);
	    return -1;
	}

	ef_raw = _zip_read_data(NULL, za->src, ef_len, 0, &za->error);

	if (ef_raw == NULL)
	    return -1;

	if ((ef=_zip_ef_parse(ef_raw, ef_len, ZIP_EF_LOCAL, &za->error)) == NULL) {
	    free(ef_raw);
	    return -1;
	}
	free(ef_raw);
	
        ef = _zip_ef_remove_internal(ef);
	e->orig->extra_fields = _zip_ef_merge(e->orig->extra_fields, ef);
    }

    e->orig->local_extra_fields_read = 1;
    
    if (e->changes && e->changes->local_extra_fields_read == 0) {
	e->changes->extra_fields = e->orig->extra_fields;
	e->changes->local_extra_fields_read = 1;
    }

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_extra_field_api.c`:

```c
/*
  zip_extra_field_api.c -- public extra fields API functions
  Copyright (C) 2012-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_file_extra_field_delete(zip_t *za, zip_uint64_t idx, zip_uint16_t ef_idx, zip_flags_t flags)
{
    zip_dirent_t *de;

    if ((flags & ZIP_EF_BOTH) == 0) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (((flags & ZIP_EF_BOTH) == ZIP_EF_BOTH) && (ef_idx != ZIP_EXTRA_FIELD_ALL)) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }
    
    if (_zip_get_dirent(za, idx, 0, NULL) == NULL)
	return -1;
    
    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    if (_zip_file_extra_field_prepare_for_change(za, idx) < 0)
        return -1;
    
    de = za->entry[idx].changes;
    
    de->extra_fields = _zip_ef_delete_by_id(de->extra_fields, ZIP_EXTRA_FIELD_ALL, ef_idx, flags);
    return 0;
}


ZIP_EXTERN int
zip_file_extra_field_delete_by_id(zip_t *za, zip_uint64_t idx, zip_uint16_t ef_id, zip_uint16_t ef_idx, zip_flags_t flags)
{
    zip_dirent_t *de;

    if ((flags & ZIP_EF_BOTH) == 0) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (((flags & ZIP_EF_BOTH) == ZIP_EF_BOTH) && (ef_idx != ZIP_EXTRA_FIELD_ALL)) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }
    
    if (_zip_get_dirent(za, idx, 0, NULL) == NULL)
	return -1;

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }
    
    if (_zip_file_extra_field_prepare_for_change(za, idx) < 0)
        return -1;
    
    de = za->entry[idx].changes;

    de->extra_fields = _zip_ef_delete_by_id(de->extra_fields, ef_id, ef_idx, flags);
    return 0;
}


ZIP_EXTERN const zip_uint8_t *
zip_file_extra_field_get(zip_t *za, zip_uint64_t idx, zip_uint16_t ef_idx, zip_uint16_t *idp, zip_uint16_t *lenp, zip_flags_t flags)
{
    static const zip_uint8_t empty[1] = { '\0' };

    zip_dirent_t *de;
    zip_extra_field_t *ef;
    int i;

    if ((flags & ZIP_EF_BOTH) == 0) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    if ((de=_zip_get_dirent(za, idx, flags, &za->error)) == NULL)
	return NULL;

    if (flags & ZIP_FL_LOCAL)
	if (_zip_read_local_ef(za, idx) < 0)
	    return NULL;

    i = 0;
    for (ef=de->extra_fields; ef; ef=ef->next) {
	if (ef->flags & flags & ZIP_EF_BOTH) {
	    if (i < ef_idx) {
		i++;
		continue;
	    }

	    if (idp)
		*idp = ef->id;
	    if (lenp)
		*lenp = ef->size;
	    if (ef->size > 0)
		return ef->data;
	    else
		return empty;
	}
    }

    zip_error_set(&za->error, ZIP_ER_NOENT, 0);
    return NULL;

}


ZIP_EXTERN const zip_uint8_t *
zip_file_extra_field_get_by_id(zip_t *za, zip_uint64_t idx, zip_uint16_t ef_id, zip_uint16_t ef_idx, zip_uint16_t *lenp, zip_flags_t flags)
{
    zip_dirent_t *de;

    if ((flags & ZIP_EF_BOTH) == 0) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    if ((de=_zip_get_dirent(za, idx, flags, &za->error)) == NULL)
	return NULL;

    if (flags & ZIP_FL_LOCAL)
	if (_zip_read_local_ef(za, idx) < 0)
	    return NULL;

    return _zip_ef_get_by_id(de->extra_fields, lenp, ef_id, ef_idx, flags, &za->error);
}


ZIP_EXTERN zip_int16_t
zip_file_extra_fields_count(zip_t *za, zip_uint64_t idx, zip_flags_t flags)
{
    zip_dirent_t *de;
    zip_extra_field_t *ef;
    zip_uint16_t n;

    if ((flags & ZIP_EF_BOTH) == 0) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if ((de=_zip_get_dirent(za, idx, flags, &za->error)) == NULL)
	return -1;

    if (flags & ZIP_FL_LOCAL)
	if (_zip_read_local_ef(za, idx) < 0)
	    return -1;

    n = 0;
    for (ef=de->extra_fields; ef; ef=ef->next)
	if (ef->flags & flags & ZIP_EF_BOTH)
	    n++;

    return (zip_int16_t)n;
}


ZIP_EXTERN zip_int16_t
zip_file_extra_fields_count_by_id(zip_t *za, zip_uint64_t idx, zip_uint16_t ef_id, zip_flags_t flags)
{
    zip_dirent_t *de;
    zip_extra_field_t *ef;
    zip_uint16_t n;

    if ((flags & ZIP_EF_BOTH) == 0) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if ((de=_zip_get_dirent(za, idx, flags, &za->error)) == NULL)
	return -1;

    if (flags & ZIP_FL_LOCAL)
	if (_zip_read_local_ef(za, idx) < 0)
	    return -1;

    n = 0;
    for (ef=de->extra_fields; ef; ef=ef->next)
	if (ef->id == ef_id && (ef->flags & flags & ZIP_EF_BOTH))
	    n++;

    return (zip_int16_t)n;
}


ZIP_EXTERN int
zip_file_extra_field_set(zip_t *za, zip_uint64_t idx, zip_uint16_t ef_id, zip_uint16_t ef_idx, const zip_uint8_t *data, zip_uint16_t len, zip_flags_t flags)
{
    zip_dirent_t *de;
    zip_uint16_t ls, cs;
    zip_extra_field_t *ef, *ef_prev, *ef_new;
    int i, found, new_len;

    if ((flags & ZIP_EF_BOTH) == 0) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (_zip_get_dirent(za, idx, 0, NULL) == NULL)
	return -1;
    
    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }
    
    if (ZIP_EF_IS_INTERNAL(ef_id)) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (_zip_file_extra_field_prepare_for_change(za, idx) < 0)
        return -1;
    
    de = za->entry[idx].changes;

    ef = de->extra_fields;
    ef_prev = NULL;
    i = 0;
    found = 0;

    for (; ef; ef=ef->next) {
	if (ef->id == ef_id && (ef->flags & flags & ZIP_EF_BOTH)) {
	    if (i == ef_idx) {
		found = 1;
		break;
	    }
	    i++;
	}
	ef_prev = ef;
    }

    if (i < ef_idx && ef_idx != ZIP_EXTRA_FIELD_NEW) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (flags & ZIP_EF_LOCAL)
	ls = _zip_ef_size(de->extra_fields, ZIP_EF_LOCAL);
    else
	ls = 0;
    if (flags & ZIP_EF_CENTRAL)
	cs = _zip_ef_size(de->extra_fields, ZIP_EF_CENTRAL);
    else
	cs = 0;

    new_len = ls > cs ? ls : cs;
    if (found)
	new_len -= ef->size + 4;
    new_len += len + 4;

    if (new_len > ZIP_UINT16_MAX) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }
    
    if ((ef_new=_zip_ef_new(ef_id, len, data, flags)) == NULL) {
	zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	return -1;
    }

    if (found) {
	if ((ef->flags & ZIP_EF_BOTH) == (flags & ZIP_EF_BOTH)) {
	    ef_new->next = ef->next;
	    ef->next = NULL;
	    _zip_ef_free(ef);
	    if (ef_prev)
		ef_prev->next = ef_new;
	    else
		de->extra_fields = ef_new;
	}
	else {
	    ef->flags &= ~(flags & ZIP_EF_BOTH);
	    ef_new->next = ef->next;
	    ef->next = ef_new;
	}	    
    }
    else if (ef_prev) {
	ef_new->next = ef_prev->next;
	ef_prev->next = ef_new;
    }
    else
	de->extra_fields = ef_new;
    
    return 0;
}



int
_zip_file_extra_field_prepare_for_change(zip_t *za, zip_uint64_t idx)
{
    zip_entry_t *e;
    
    if (idx >= za->nentry) {
        zip_error_set(&za->error, ZIP_ER_INVAL, 0);
        return -1;
    }
    
    e = za->entry+idx;
    
    if (e->changes && (e->changes->changed & ZIP_DIRENT_EXTRA_FIELD))
        return 0;

    if (e->orig) {
	if (_zip_read_local_ef(za, idx) < 0)
	    return -1;
    }
    
    if (e->changes == NULL) {
        if ((e->changes=_zip_dirent_clone(e->orig)) == NULL) {
            zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
            return -1;
        }
    }
    
    if (e->orig && e->orig->extra_fields) {
	if ((e->changes->extra_fields=_zip_ef_clone(e->orig->extra_fields, &za->error)) == NULL)
	    return -1;
    }
    e->changes->changed |= ZIP_DIRENT_EXTRA_FIELD;
    
    return 0;
}


```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_fclose.c`:

```c
/*
  zip_fclose.c -- close file in zip archive
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN int
zip_fclose(zip_file_t *zf)
{
    int ret;
    
    if (zf->src)
	zip_source_free(zf->src);

    ret = 0;
    if (zf->error.zip_err)
	ret = zf->error.zip_err;

    zip_error_fini(&zf->error);
    free(zf);
    return ret;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_fdopen.c`:

```c
/*
  zip_fdopen.c -- open read-only archive from file descriptor
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN zip_t *
zip_fdopen(int fd_orig, int _flags, int *zep)
{
    int fd;
    FILE *fp;
    zip_t *za;
    zip_source_t *src;
    struct zip_error error;

    if (_flags < 0 || (_flags & ZIP_TRUNCATE)) {
	_zip_set_open_error(zep, NULL, ZIP_ER_INVAL);
        return  NULL;
    }
        
    /* We dup() here to avoid messing with the passed in fd.
       We could not restore it to the original state in case of error. */

    if ((fd=dup(fd_orig)) < 0) {
	_zip_set_open_error(zep, NULL, ZIP_ER_OPEN);
	return NULL;
    }

    if ((fp=fdopen(fd, "rb")) == NULL) {
	close(fd);
	_zip_set_open_error(zep, NULL, ZIP_ER_OPEN);
	return NULL;
    }

    zip_error_init(&error);
    if ((src = zip_source_filep_create(fp, 0, -1, &error)) == NULL) {
	_zip_set_open_error(zep, &error, 0);
	zip_error_fini(&error);
	return NULL;
    }

    if ((za = zip_open_from_source(src, _flags, &error)) == NULL) {
	_zip_set_open_error(zep, &error, 0);
	zip_error_fini(&error);
	return NULL;
    }

    zip_error_fini(&error);
    close(fd_orig);
    return za;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_add.c`:

```c
/*
  zip_file_add.c -- add file via callback function
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"

/*
  NOTE: Return type is signed so we can return -1 on error.
        The index can not be larger than ZIP_INT64_MAX since the size
        of the central directory cannot be larger than
        ZIP_UINT64_MAX, and each entry is larger than 2 bytes.
*/

ZIP_EXTERN zip_int64_t
zip_file_add(zip_t *za, const char *name, zip_source_t *source, zip_flags_t flags)
{
    if (name == NULL || source == NULL) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }
	
    return _zip_file_replace(za, ZIP_UINT64_MAX, name, source, flags);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_error_clear.c`:

```c
/*
  zip_file_error_clear.c -- clear zip file error
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN void
zip_file_error_clear(zip_file_t *zf)
{
    if (zf == NULL)
	return;

    _zip_error_clear(&zf->error);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_error_get.c`:

```c
/*
  zip_file_error_get.c -- get zip file error
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


ZIP_EXTERN void
zip_file_error_get(zip_file_t *zf, int *zep, int *sep)
{
    _zip_error_get(&zf->error, zep, sep);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_get_comment.c`:

```c
/*
  zip_file_get_comment.c -- get file comment
  Copyright (C) 2006-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"

/* lenp is 32 bit because converted comment can be longer than ZIP_UINT16_MAX */

ZIP_EXTERN const char *
zip_file_get_comment(zip_t *za, zip_uint64_t idx, zip_uint32_t *lenp, zip_flags_t flags)
{
    zip_dirent_t *de;
    zip_uint32_t len;
    const zip_uint8_t *str;

    if ((de=_zip_get_dirent(za, idx, flags, NULL)) == NULL)
	return NULL;

    if ((str=_zip_string_get(de->comment, &len, flags, &za->error)) == NULL)
	return NULL;

    if (lenp)
	*lenp = len;

    return (const char *)str;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_get_external_attributes.c`:

```c
/*
  zip_file_get_external_attributes.c -- get opsys/external attributes
  Copyright (C) 2013-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "zipint.h"

int
zip_file_get_external_attributes(zip_t *za, zip_uint64_t idx, zip_flags_t flags, zip_uint8_t *opsys, zip_uint32_t *attributes)
{
    zip_dirent_t *de;

    if ((de=_zip_get_dirent(za, idx, flags, NULL)) == NULL)
	return -1;

    if (opsys)
	*opsys = (zip_uint8_t)((de->version_madeby >> 8) & 0xff);

    if (attributes)
	*attributes = de->ext_attrib;

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_get_offset.c`:

```c
/*
  zip_file_get_offset.c -- get offset of file data in archive.
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "zipint.h"


/* _zip_file_get_offset(za, ze):
   Returns the offset of the file data for entry ze.

   On error, fills in za->error and returns 0.
*/

zip_uint64_t
_zip_file_get_offset(const zip_t *za, zip_uint64_t idx, zip_error_t *error)
{
    zip_uint64_t offset;
    zip_int32_t size;

    offset = za->entry[idx].orig->offset;

    if (zip_source_seek(za->src, (zip_int64_t)offset, SEEK_SET) < 0) {
	_zip_error_set_from_source(error, za->src);
	return 0;
    }

    /* TODO: cache? */
    if ((size=_zip_dirent_size(za->src, ZIP_EF_LOCAL, error)) < 0)
	return 0;

    if (offset+(zip_uint32_t)size > ZIP_INT64_MAX) {
        zip_error_set(error, ZIP_ER_SEEK, EFBIG);
        return 0;
    }
    
    return offset + (zip_uint32_t)size;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_rename.c`:

```c
/*
  zip_file_rename.c -- rename file in zip archive
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <string.h>

#include "zipint.h"


ZIP_EXTERN int
zip_file_rename(zip_t *za, zip_uint64_t idx, const char *name, zip_flags_t flags)
{
    const char *old_name;
    int old_is_dir, new_is_dir;
    
    if (idx >= za->nentry || (name != NULL && strlen(name) > ZIP_UINT16_MAX)) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    if ((old_name=zip_get_name(za, idx, 0)) == NULL)
	return -1;
								    
    new_is_dir = (name != NULL && name[strlen(name)-1] == '/');
    old_is_dir = (old_name[strlen(old_name)-1] == '/');

    if (new_is_dir != old_is_dir) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    return _zip_set_name(za, idx, name, flags);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_replace.c`:

```c
/*
  zip_file_replace.c -- replace file via callback function
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_file_replace(zip_t *za, zip_uint64_t idx, zip_source_t *source, zip_flags_t flags)
{
    if (idx >= za->nentry || source == NULL) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (_zip_file_replace(za, idx, NULL, source, flags) == -1)
	return -1;

    return 0;
}



/* NOTE: Signed due to -1 on error.  See zip_add.c for more details. */

zip_int64_t
_zip_file_replace(zip_t *za, zip_uint64_t idx, const char *name, zip_source_t *source, zip_flags_t flags)
{
    zip_uint64_t za_nentry_prev;
    
    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    za_nentry_prev = za->nentry;
    if (idx == ZIP_UINT64_MAX) {
	zip_int64_t i = -1;
	
	if (flags & ZIP_FL_OVERWRITE)
	    i = _zip_name_locate(za, name, flags, NULL);

	if (i == -1) {
	    /* create and use new entry, used by zip_add */
	    if ((i=_zip_add_entry(za)) < 0)
		return -1;
	}
	idx = (zip_uint64_t)i;
    }
    
    if (name && _zip_set_name(za, idx, name, flags) != 0) {
	if (za->nentry != za_nentry_prev) {
	    _zip_entry_finalize(za->entry+idx);
	    za->nentry = za_nentry_prev;
	}
	return -1;
    }

    /* does not change any name related data, so we can do it here;
     * needed for a double add of the same file name */
    _zip_unchange_data(za->entry+idx);

    if (za->entry[idx].orig != NULL && (za->entry[idx].changes == NULL || (za->entry[idx].changes->changed & ZIP_DIRENT_COMP_METHOD) == 0)) {
        if (za->entry[idx].changes == NULL) {
            if ((za->entry[idx].changes=_zip_dirent_clone(za->entry[idx].orig)) == NULL) {
                zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
                return -1;
            }
        }

        za->entry[idx].changes->comp_method = ZIP_CM_REPLACED_DEFAULT;
        za->entry[idx].changes->changed |= ZIP_DIRENT_COMP_METHOD;
    }
	
    za->entry[idx].source = source;

    return (zip_int64_t)idx;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_set_comment.c`:

```c
/*
  zip_file_set_comment.c -- set comment for file in archive
  Copyright (C) 2006-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN int
zip_file_set_comment(zip_t *za, zip_uint64_t idx,
		     const char *comment, zip_uint16_t len, zip_flags_t flags)
{
    zip_entry_t *e;
    zip_string_t *cstr;
    int changed;

    if (_zip_get_dirent(za, idx, 0, NULL) == NULL)
	return -1;

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    if (len > 0 && comment == NULL) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (len > 0) {
	if ((cstr=_zip_string_new((const zip_uint8_t *)comment, len, flags, &za->error)) == NULL)
	    return -1;
	if ((flags & ZIP_FL_ENCODING_ALL) == ZIP_FL_ENC_GUESS && _zip_guess_encoding(cstr, ZIP_ENCODING_UNKNOWN) == ZIP_ENCODING_UTF8_GUESSED)
	    cstr->encoding = ZIP_ENCODING_UTF8_KNOWN;
    }
    else
	cstr = NULL;

    e = za->entry+idx;

    if (e->changes) {
	_zip_string_free(e->changes->comment);
	e->changes->comment = NULL;
	e->changes->changed &= ~ZIP_DIRENT_COMMENT;
    }

    if (e->orig && e->orig->comment)
	changed = !_zip_string_equal(e->orig->comment, cstr);
    else
	changed = (cstr != NULL);
	
    if (changed) {
        if (e->changes == NULL) {
            if ((e->changes=_zip_dirent_clone(e->orig)) == NULL) {
                zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
		_zip_string_free(cstr);
                return -1;
            }
        }
        e->changes->comment = cstr;
        e->changes->changed |= ZIP_DIRENT_COMMENT;
    }
    else {
	_zip_string_free(cstr);
	if (e->changes && e->changes->changed == 0) {
	    _zip_dirent_free(e->changes);
	    e->changes = NULL;
	}
    }

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_set_external_attributes.c`:

```c
/*
  zip_file_set_external_attributes.c -- set external attributes for entry
  Copyright (C) 2013-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "zipint.h"

ZIP_EXTERN int
zip_file_set_external_attributes(zip_t *za, zip_uint64_t idx, zip_flags_t flags, zip_uint8_t opsys, zip_uint32_t attributes)
{
    zip_entry_t *e;
    int changed;
    zip_uint8_t unchanged_opsys;
    zip_uint32_t unchanged_attributes;

    if (_zip_get_dirent(za, idx, 0, NULL) == NULL)
	return -1;

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    e = za->entry+idx;

    unchanged_opsys = (e->orig ? (zip_uint8_t)(e->orig->version_madeby>>8) : (zip_uint8_t)ZIP_OPSYS_DEFAULT);
    unchanged_attributes = e->orig ? e->orig->ext_attrib : ZIP_EXT_ATTRIB_DEFAULT;

    changed = (opsys != unchanged_opsys || attributes != unchanged_attributes);

    if (changed) {
        if (e->changes == NULL) {
            if ((e->changes=_zip_dirent_clone(e->orig)) == NULL) {
                zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
                return -1;
            }
        }
        e->changes->version_madeby = (zip_uint16_t)((opsys << 8) | (e->changes->version_madeby & 0xff));
	e->changes->ext_attrib = attributes;
        e->changes->changed |= ZIP_DIRENT_ATTRIBUTES;
    }
    else if (e->changes) {
	e->changes->changed &= ~ZIP_DIRENT_ATTRIBUTES;
	if (e->changes->changed == 0) {
	    _zip_dirent_free(e->changes);
	    e->changes = NULL;
	}
	else {
	    e->changes->version_madeby = (zip_uint16_t)((unchanged_opsys << 8) | (e->changes->version_madeby & 0xff));
	    e->changes->ext_attrib = unchanged_attributes;
	}
    }

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_set_mtime.c`:

```c
/*
 zip_file_set_mtime.c -- set modification time of entry.
 Copyright (C) 2014 Dieter Baron and Thomas Klausner
 
 This file is part of libzip, a library to manipulate ZIP archives.
 The authors can be contacted at <libzip@nih.at>
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the
 distribution.
 3. The names of the authors may not be used to endorse or promote
 products derived from this software without specific prior
 written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "zipint.h"

ZIP_EXTERN int zip_file_set_mtime(zip_t *za, zip_uint64_t idx, time_t mtime, zip_flags_t flags)
{
    zip_entry_t *e;
    int changed;
    
    if (_zip_get_dirent(za, idx, 0, NULL) == NULL)
        return -1;
    
    if (ZIP_IS_RDONLY(za)) {
        zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
        return -1;
    }
    
    e = za->entry+idx;

    changed = e->orig == NULL || mtime != e->orig->last_mod;
    
    if (changed) {
        if (e->changes == NULL) {
            if ((e->changes=_zip_dirent_clone(e->orig)) == NULL) {
                zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
                return -1;
            }
        }
        e->changes->last_mod = mtime;
        e->changes->changed |= ZIP_DIRENT_LAST_MOD;
    }
    else {
        if (e->changes) {
            e->changes->changed &= ~ZIP_DIRENT_LAST_MOD;
            if (e->changes->changed == 0) {
		_zip_dirent_free(e->changes);
                e->changes = NULL;
            }
        }
    }
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_file_strerror.c`:

```c
/*
  zip_file_sterror.c -- get string representation of zip file error
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN const char *
zip_file_strerror(zip_file_t *zf)
{
    return zip_error_strerror(&zf->error);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_filerange_crc.c`:

```c
/*
  zip_filerange_crc.c -- compute CRC32 for a range of a file
  Copyright (C) 2008-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdio.h>
#include <errno.h>

#include "zipint.h"



int
_zip_filerange_crc(zip_source_t *src, zip_uint64_t start, zip_uint64_t len, uLong *crcp, zip_error_t *error)
{
    Bytef buf[BUFSIZE];
    zip_int64_t n;

    *crcp = crc32(0L, Z_NULL, 0);

    if (start > ZIP_INT64_MAX) {
	zip_error_set(error, ZIP_ER_SEEK, EFBIG);
	return -1;
    }

    if (zip_source_seek(src, (zip_int64_t)start, SEEK_SET) != 0) {
	_zip_error_set_from_source(error, src);
	return -1;
    }
    
    while (len > 0) {
	n = (zip_int64_t)(len > BUFSIZE ? BUFSIZE : len);
	if ((n = zip_source_read(src, buf, (zip_uint64_t)n)) < 0) {
	    _zip_error_set_from_source(error, src);
	    return -1;
	}
	if (n == 0) {
	    zip_error_set(error, ZIP_ER_EOF, 0);
	    return -1;
	}

	*crcp = crc32(*crcp, buf, (uInt)n);

	len -= (zip_uint64_t)n;
    }

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_fopen.c`:

```c
/*
  zip_fopen.c -- open file in zip archive for reading
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN zip_file_t *
zip_fopen(zip_t *za, const char *fname, zip_flags_t flags)
{
    zip_int64_t idx;

    if ((idx=zip_name_locate(za, fname, flags)) < 0)
	return NULL;

    return zip_fopen_index_encrypted(za, (zip_uint64_t)idx, flags, za->default_password);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_fopen_encrypted.c`:

```c
/*
  zip_fopen_encrypted.c -- open file for reading with password
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN zip_file_t *
zip_fopen_encrypted(zip_t *za, const char *fname, zip_flags_t flags, const char *password)
{
    zip_int64_t idx;

    if ((idx=zip_name_locate(za, fname, flags)) < 0)
	return NULL;

    return zip_fopen_index_encrypted(za, (zip_uint64_t)idx, flags, password);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_fopen_index.c`:

```c
/*
  zip_fopen_index.c -- open file in zip archive for reading by index
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN zip_file_t *
zip_fopen_index(zip_t *za, zip_uint64_t index, zip_flags_t flags)
{
    return zip_fopen_index_encrypted(za, index, flags, za->default_password);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_fopen_index_encrypted.c`:

```c
/*
  zip_fopen_index_encrypted.c -- open file for reading by index w/ password
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

#include "zipint.h"

static zip_file_t *_zip_file_new(zip_t *za);


ZIP_EXTERN zip_file_t *
zip_fopen_index_encrypted(zip_t *za, zip_uint64_t index, zip_flags_t flags,
			  const char *password)
{
    zip_file_t *zf;
    zip_source_t *src;

    if ((src=_zip_source_zip_new(za, za, index, flags, 0, 0, password)) == NULL)
	return NULL;

    if (zip_source_open(src) < 0) {
	_zip_error_set_from_source(&za->error, src);
	zip_source_free(src);
	return NULL;
    }

    if ((zf=_zip_file_new(za)) == NULL) {
	zip_source_free(src);
	return NULL;
    }

    zf->src = src;

    return zf;
}


static zip_file_t *
_zip_file_new(zip_t *za)
{
    zip_file_t *zf;

    if ((zf=(zip_file_t *)malloc(sizeof(struct zip_file))) == NULL) {
	zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    zf->za = za;
    zip_error_init(&zf->error);
    zf->eof = 0;
    zf->src = NULL;

    return zf;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_fread.c`:

```c
/*
  zip_fread.c -- read from file
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN zip_int64_t
zip_fread(zip_file_t *zf, void *outbuf, zip_uint64_t toread)
{
    zip_int64_t n;

    if (!zf)
	return -1;

    if (zf->error.zip_err != 0)
	return -1;

    if (toread > ZIP_INT64_MAX) {
	zip_error_set(&zf->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if ((zf->eof) || (toread == 0))
	return 0;

    if ((n=zip_source_read(zf->src, outbuf, toread)) < 0) {
	_zip_error_set_from_source(&zf->error, zf->src);
	return -1;
    }

    return n;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_get_archive_comment.c`:

```c
/*
  zip_get_archive_comment.c -- get archive comment
  Copyright (C) 2006-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <string.h>

#include "zipint.h"


ZIP_EXTERN const char *
zip_get_archive_comment(zip_t *za, int *lenp, zip_flags_t flags)
{
    zip_string_t *comment;
    zip_uint32_t len;
    const zip_uint8_t *str;

    if ((flags & ZIP_FL_UNCHANGED) || (za->comment_changes == NULL))
	comment = za->comment_orig;
    else
	comment = za->comment_changes;

    if ((str=_zip_string_get(comment, &len, flags, &za->error)) == NULL)
	return NULL;

    if (lenp)
	*lenp = (int)len;

    return (const char *)str;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_get_archive_flag.c`:

```c
/*
  zip_get_archive_flag.c -- get archive global flag
  Copyright (C) 2008-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_get_archive_flag(zip_t *za, zip_flags_t flag, zip_flags_t flags)
{
    unsigned int fl;

    fl = (flags & ZIP_FL_UNCHANGED) ? za->flags : za->ch_flags;

    return (fl & flag) ? 1 : 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_get_compression_implementation.c`:

```c
/*
  zip_get_compression_implementation.c -- get compression implementation
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


zip_compression_implementation
_zip_get_compression_implementation(zip_int32_t cm)
{
    if (cm == ZIP_CM_DEFLATE || ZIP_CM_IS_DEFAULT(cm))
	return zip_source_deflate;
    return NULL;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_get_encryption_implementation.c`:

```c
/*
  zip_get_encryption_implementation.c -- get encryption implementation
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


zip_encryption_implementation
_zip_get_encryption_implementation(zip_uint16_t em)
{
    if (em == ZIP_EM_TRAD_PKWARE)
	return zip_source_pkware;
    return NULL;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_get_file_comment.c`:

```c
/*
  zip_get_file_comment.c -- get file comment
  Copyright (C) 2006-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


ZIP_EXTERN const char *
zip_get_file_comment(zip_t *za, zip_uint64_t idx, int *lenp, int flags)
{
    zip_uint32_t len;
    const char *s;

    if ((s=zip_file_get_comment(za, idx, &len, (zip_flags_t)flags)) != NULL) {
	if (lenp)
	    *lenp = (int)len;
    }

    return s;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_get_name.c`:

```c
/*
  zip_get_name.c -- get filename for a file in zip file
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <string.h>

#include "zipint.h"


ZIP_EXTERN const char *
zip_get_name(zip_t *za, zip_uint64_t idx, zip_flags_t flags)
{
    return _zip_get_name(za, idx, flags, &za->error);
}


const char *
_zip_get_name(zip_t *za, zip_uint64_t idx, zip_flags_t flags, zip_error_t *error)
{
    zip_dirent_t *de;
    const zip_uint8_t *str;

    if ((de=_zip_get_dirent(za, idx, flags, error)) == NULL)
	return NULL;

    if ((str=_zip_string_get(de->filename, NULL, flags, error)) == NULL)
	return NULL;

    return (const char *)str;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_get_num_entries.c`:

```c
/*
  zip_get_num_entries.c -- get number of entries in archive
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN zip_int64_t
zip_get_num_entries(zip_t *za, zip_flags_t flags)
{
    zip_uint64_t n;

    if (za == NULL)
	return -1;

    if (flags & ZIP_FL_UNCHANGED) {
	n = za->nentry;
	while (n>0 && za->entry[n-1].orig == NULL)
	    --n;
	return (zip_int64_t)n;
    }
    return (zip_int64_t)za->nentry;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_get_num_files.c`:

```c
/*
  zip_get_num_files.c -- get number of files in archive
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"
#include <limits.h>


ZIP_EXTERN int
zip_get_num_files(zip_t *za)
{
    if (za == NULL)
	return -1;

    if (za->nentry > INT_MAX) {
	zip_error_set(&za->error, ZIP_ER_OPNOTSUPP, 0);
	return -1;
    }

    return (int)za->nentry;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_io_util.c`:

```c
/*
 zip_io_util.c -- I/O helper functions
 Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner
 
 This file is part of libzip, a library to manipulate ZIP archives.
 The authors can be contacted at <libzip@nih.at>
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the
 distribution.
 3. The names of the authors may not be used to endorse or promote
 products derived from this software without specific prior
 written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include "zipint.h"

int
_zip_read(zip_source_t *src, zip_uint8_t *b, zip_uint64_t length, zip_error_t *error)
{
    zip_int64_t n;

    if (length > ZIP_INT64_MAX) {
	zip_error_set(error, ZIP_ER_INTERNAL, 0);
	return -1;
    }

    if ((n = zip_source_read(src, b, length)) < 0) {
	_zip_error_set_from_source(error, src);
	return -1;
    }

    if (n < (zip_int64_t)length) {
	zip_error_set(error, ZIP_ER_EOF, 0);
	return -1;
    }

    return 0;
}


zip_uint8_t *
_zip_read_data(zip_buffer_t *buffer, zip_source_t *src, size_t length, bool nulp, zip_error_t *error)
{
    zip_uint8_t *r;
    
    if (length == 0 && !nulp) {
	return NULL;
    }

    r = (zip_uint8_t *)malloc(length + (nulp ? 1 : 0));
    if (!r) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    if (buffer) {
        zip_uint8_t *data = _zip_buffer_get(buffer, length);
        
        if (data == NULL) {
            zip_error_set(error, ZIP_ER_MEMORY, 0);
            free(r);
            return NULL;
        }
	memcpy(r, data, length);
    }
    else {
	if (_zip_read(src, r, length, error) < 0) {
	    free(r);
	    return NULL;
	}
    }

    if (nulp) {
	zip_uint8_t *o;
	/* replace any in-string NUL characters with spaces */
	r[length] = 0;
	for (o=r; o<r+length; o++)
	    if (*o == '\0')
		*o = ' ';
    }

    return r;
}


zip_string_t *
_zip_read_string(zip_buffer_t *buffer, zip_source_t *src, zip_uint16_t len, bool nulp, zip_error_t *error)
{
    zip_uint8_t *raw;
    zip_string_t *s;

    if ((raw=_zip_read_data(buffer, src, len, nulp, error)) == NULL)
	return NULL;

    s = _zip_string_new(raw, len, ZIP_FL_ENC_GUESS, error);
    free(raw);
    return s;
}


int
_zip_write(zip_t *za, const void *data, zip_uint64_t length)
{
    zip_int64_t n;
    
    if ((n = zip_source_write(za->src, data, length)) < 0) {
        _zip_error_set_from_source(&za->error, za->src);
        return -1;
    }
    if ((zip_uint64_t)n != length) {
        zip_error_set(&za->error, ZIP_ER_WRITE, EINTR);
        return -1;
    }
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_memdup.c`:

```c
/*
  zip_memdup.c -- internal zip function, "strdup" with len
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <stdlib.h>
#include <string.h>

#include "zipint.h"


void *
_zip_memdup(const void *mem, size_t len, zip_error_t *error)
{
    void *ret;

    if (len == 0)
	return NULL;

    ret = malloc(len);
    if (!ret) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    memcpy(ret, mem, len);

    return ret;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_name_locate.c`:

```c
/*
  zip_name_locate.c -- get index by name
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <string.h>
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif

#include "zipint.h"


ZIP_EXTERN zip_int64_t
zip_name_locate(zip_t *za, const char *fname, zip_flags_t flags)
{
    return _zip_name_locate(za, fname, flags, &za->error);
}


zip_int64_t
_zip_name_locate(zip_t *za, const char *fname, zip_flags_t flags, zip_error_t *error)
{
    int (*cmp)(const char *, const char *);
    const char *fn, *p;
    zip_uint64_t i;

    if (za == NULL)
	return -1;

    if (fname == NULL) {
	zip_error_set(error, ZIP_ER_INVAL, 0);
	return -1;
    }

    cmp = (flags & ZIP_FL_NOCASE) ? strcasecmp : strcmp;

    for (i=0; i<za->nentry; i++) {
	fn = _zip_get_name(za, i, flags, error);

	/* newly added (partially filled) entry or error */
	if (fn == NULL)
	    continue;
	
	if (flags & ZIP_FL_NODIR) {
	    p = strrchr(fn, '/');
	    if (p)
		fn = p+1;
	}

	if (cmp(fname, fn) == 0) {
	    _zip_error_clear(error);
	    return (zip_int64_t)i;
	}
    }

    zip_error_set(error, ZIP_ER_NOENT, 0);
    return -1;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_new.c`:

```c
/*
  zip_new.c -- create and init struct zip
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


/* _zip_new:
   creates a new zipfile struct, and sets the contents to zero; returns
   the new struct. */

zip_t *
_zip_new(zip_error_t *error)
{
    zip_t *za;

    za = (zip_t *)malloc(sizeof(struct zip));
    if (!za) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    za->src = NULL;
    za->open_flags = 0;
    zip_error_init(&za->error);
    za->flags = za->ch_flags = 0;
    za->default_password = NULL;
    za->comment_orig = za->comment_changes = NULL;
    za->comment_changed = 0;
    za->nentry = za->nentry_alloc = 0;
    za->entry = NULL;
    za->nopen_source = za->nopen_source_alloc = 0;
    za->open_source = NULL;
    za->tempdir = NULL;
    
    return za;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_open.c`:

```c
/*
  zip_open.c -- open zip archive by name
  Copyright (C) 1999-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <sys/stat.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "zipint.h"

typedef enum {
    EXISTS_ERROR = -1,
    EXISTS_NOT = 0,
    EXISTS_EMPTY,
    EXISTS_NONEMPTY,
} exists_t;
static zip_t *_zip_allocate_new(zip_source_t *src, unsigned int flags, zip_error_t *error);
static zip_int64_t _zip_checkcons(zip_t *za, zip_cdir_t *cdir, zip_error_t *error);
static zip_cdir_t *_zip_find_central_dir(zip_t *za, zip_uint64_t len);
static exists_t _zip_file_exists(zip_source_t *src, zip_error_t *error);
static int _zip_headercomp(const zip_dirent_t *, const zip_dirent_t *);
static unsigned char *_zip_memmem(const unsigned char *, size_t, const unsigned char *, size_t);
static zip_cdir_t *_zip_read_cdir(zip_t *za, zip_buffer_t *buffer, zip_uint64_t buf_offset, zip_error_t *error);
static zip_cdir_t *_zip_read_eocd(zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error);
static zip_cdir_t *_zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error);


ZIP_EXTERN zip_t *
zip_open(const char *fn, int _flags, int *zep)
{
    zip_t *za;
    zip_source_t *src;
    struct zip_error error;

    zip_error_init(&error);
    if ((src = zip_source_file_create(fn, 0, -1, &error)) == NULL) {
	_zip_set_open_error(zep, &error, 0);
	zip_error_fini(&error);
	return NULL;
    }

    if ((za = zip_open_from_source(src, _flags, &error)) == NULL) {
	zip_source_free(src);
	_zip_set_open_error(zep, &error, 0);
	zip_error_fini(&error);
	return NULL;
    }

    zip_error_fini(&error);
    return za;
}


ZIP_EXTERN zip_t *
zip_open_from_source(zip_source_t *src, int _flags, zip_error_t *error)
{
    static zip_int64_t needed_support_read = -1;
    static zip_int64_t needed_support_write = -1;
    
    unsigned int flags;
    zip_int64_t supported;
    exists_t exists;
    
    if (_flags < 0 || src == NULL) {
	zip_error_set(error, ZIP_ER_INVAL, 0);
        return NULL;
    }
    flags = (unsigned int)_flags;
    
    supported = zip_source_supports(src);
    if (needed_support_read == -1) {
        needed_support_read = zip_source_make_command_bitmap(ZIP_SOURCE_OPEN, ZIP_SOURCE_READ, ZIP_SOURCE_CLOSE, ZIP_SOURCE_SEEK, ZIP_SOURCE_TELL, ZIP_SOURCE_STAT, -1);
        needed_support_write = zip_source_make_command_bitmap(ZIP_SOURCE_BEGIN_WRITE, ZIP_SOURCE_COMMIT_WRITE, ZIP_SOURCE_ROLLBACK_WRITE, ZIP_SOURCE_SEEK_WRITE, ZIP_SOURCE_TELL_WRITE, ZIP_SOURCE_REMOVE, -1);
    }
    if ((supported & needed_support_read) != needed_support_read) {
        zip_error_set(error, ZIP_ER_OPNOTSUPP, 0);
        return NULL;
    }
    if ((supported & needed_support_write) != needed_support_write) {
        flags |= ZIP_RDONLY;
    }

    if ((flags & (ZIP_RDONLY|ZIP_TRUNCATE)) == (ZIP_RDONLY|ZIP_TRUNCATE)) {
	zip_error_set(error, ZIP_ER_RDONLY, 0);
	return NULL;
    }

    exists = _zip_file_exists(src, error);
    switch (exists) { 
    case EXISTS_ERROR:
	return NULL;

    case EXISTS_NOT:
	if ((flags & ZIP_CREATE) == 0) {
	    zip_error_set(error, ZIP_ER_NOENT, 0);
	    return NULL;
	}
	return _zip_allocate_new(src, flags, error);

    default: {
	zip_t *za;
	if (flags & ZIP_EXCL) {
	    zip_error_set(error, ZIP_ER_EXISTS, 0);
	    return NULL;
	}
	if (zip_source_open(src) < 0) {
	    _zip_error_set_from_source(error, src);
	    return NULL;
	}

	if (flags & ZIP_TRUNCATE) {
	    za = _zip_allocate_new(src, flags, error);
	}
	else {
	    /* ZIP_CREATE gets ignored if file exists and not ZIP_EXCL, just like open() */
	    za = _zip_open(src, flags, error);
	}

	if (za == NULL) {
	    zip_source_close(src);
	    return NULL;
	}
	return za;
    }
    }
}

ZIP_EXTERN int
zip_archive_set_tempdir(zip_t *za, const char *tempdir)
{
    char *new_tempdir;
    
    if (tempdir) {
        if ((new_tempdir = strdup(tempdir)) == NULL) {
            zip_error_set(&za->error, ZIP_ER_MEMORY, errno);
            return -1;
        }
    }
    else
        new_tempdir = NULL;
    
    free(za->tempdir);
    za->tempdir = new_tempdir;
    
    return 0;
}

zip_t *
_zip_open(zip_source_t *src, unsigned int flags, zip_error_t *error)
{
    zip_t *za;
    zip_cdir_t *cdir;
    struct zip_stat st;
    zip_uint64_t len;

    zip_stat_init(&st);
    if (zip_source_stat(src, &st) < 0) {
	_zip_error_set_from_source(error, src);
	return NULL;
    }
    if ((st.valid & ZIP_STAT_SIZE) == 0) {
	zip_error_set(error, ZIP_ER_SEEK, EOPNOTSUPP);
	return NULL;
    }
    len = st.size;

    /* treat empty files as empty archives */
    if (len == 0) {
	if ((za=_zip_allocate_new(src, flags, error)) == NULL) {
	    zip_source_free(src);
	    return NULL;
	}

	return za;
    }

    if ((za=_zip_allocate_new(src, flags, error)) == NULL) {
        return NULL;
    }
    
    if ((cdir = _zip_find_central_dir(za, len)) == NULL) {
        _zip_error_copy(error, &za->error);
	/* keep src so discard does not get rid of it */
	zip_source_keep(src);
	zip_discard(za);
	return NULL;
    }

    za->entry = cdir->entry;
    za->nentry = cdir->nentry;
    za->nentry_alloc = cdir->nentry_alloc;
    za->comment_orig = cdir->comment;
    
    za->ch_flags = za->flags;

    free(cdir);

    return za;
}


void
_zip_set_open_error(int *zep, const zip_error_t *err, int ze)
{
    if (err) {
	ze = zip_error_code_zip(err);
	if (zip_error_system_type(err) == ZIP_ET_SYS) {
	    errno = zip_error_code_system(err);
	}
    }

    if (zep)
	*zep = ze;
}


/* _zip_readcdir:
   tries to find a valid end-of-central-directory at the beginning of
   buf, and then the corresponding central directory entries.
   Returns a struct zip_cdir which contains the central directory 
   entries, or NULL if unsuccessful. */

static zip_cdir_t *
_zip_read_cdir(zip_t *za, zip_buffer_t *buffer, zip_uint64_t buf_offset, zip_error_t *error)
{
    zip_cdir_t *cd;
    zip_uint16_t comment_len;
    zip_uint64_t i, left;
    zip_uint64_t eocd_offset = _zip_buffer_offset(buffer);
    zip_buffer_t *cd_buffer;

    if (_zip_buffer_left(buffer) < EOCDLEN) {
	/* not enough bytes left for comment */
	zip_error_set(error, ZIP_ER_NOZIP, 0);
	return NULL;
    }
    
    /* check for end-of-central-dir magic */
    if (memcmp(_zip_buffer_get(buffer, 4), EOCD_MAGIC, 4) != 0) {
	zip_error_set(error, ZIP_ER_NOZIP, 0);
	return NULL;
    }

    if (_zip_buffer_get_32(buffer) != 0) {
	zip_error_set(error, ZIP_ER_MULTIDISK, 0);
	return NULL;
    }

    if (eocd_offset >= EOCD64LOCLEN && memcmp(_zip_buffer_data(buffer) + eocd_offset - EOCD64LOCLEN, EOCD64LOC_MAGIC, 4) == 0) {
        _zip_buffer_set_offset(buffer, eocd_offset - EOCD64LOCLEN);
        cd = _zip_read_eocd64(za->src, buffer, buf_offset, za->flags, error);
    }
    else {
        _zip_buffer_set_offset(buffer, eocd_offset);
        cd = _zip_read_eocd(buffer, buf_offset, za->flags, error);
    }

    if (cd == NULL)
	return NULL;

    _zip_buffer_set_offset(buffer, eocd_offset + 20);
    comment_len = _zip_buffer_get_16(buffer);

    if (cd->offset + cd->size > buf_offset + eocd_offset) {
	/* cdir spans past EOCD record */
	zip_error_set(error, ZIP_ER_INCONS, 0);
	_zip_cdir_free(cd);
	return NULL;
    }

    if (comment_len || (za->open_flags & ZIP_CHECKCONS)) {
        zip_uint64_t tail_len;
        
        _zip_buffer_set_offset(buffer, eocd_offset + EOCDLEN);
        tail_len = _zip_buffer_left(buffer);
        
        if (tail_len < comment_len || ((za->open_flags & ZIP_CHECKCONS) && tail_len != comment_len)) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            _zip_cdir_free(cd);
            return NULL;
        }

        if (comment_len) {
            if ((cd->comment=_zip_string_new(_zip_buffer_get(buffer, comment_len), comment_len, ZIP_FL_ENC_GUESS, error)) == NULL) {
                _zip_cdir_free(cd);
                return NULL;
            }
        }
    }

    if (cd->offset >= buf_offset) {
        zip_uint8_t *data;
	/* if buffer already read in, use it */
        _zip_buffer_set_offset(buffer, cd->offset - buf_offset);
        
        if ((data = _zip_buffer_get(buffer, cd->size)) == NULL) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            _zip_cdir_free(cd);
            return NULL;
        }
        if ((cd_buffer = _zip_buffer_new(data, cd->size)) == NULL) {
            zip_error_set(error, ZIP_ER_MEMORY, 0);
            _zip_cdir_free(cd);
            return NULL;
        }
    }
    else {
        cd_buffer = NULL;
        
        if (zip_source_seek(za->src, (zip_int64_t)cd->offset, SEEK_SET) < 0) {
            _zip_error_set_from_source(error, za->src);
            _zip_cdir_free(cd);
            return NULL;
        }

	/* possible consistency check: cd->offset = len-(cd->size+cd->comment_len+EOCDLEN) ? */
	if (zip_source_tell(za->src) != (zip_int64_t)cd->offset) {
            zip_error_set(error, ZIP_ER_NOZIP, 0);
	    _zip_cdir_free(cd);
	    return NULL;
	}
    }

    left = (zip_uint64_t)cd->size;
    i=0;
    while (i<cd->nentry && left > 0) {
        zip_int64_t entry_size;
	if ((cd->entry[i].orig=_zip_dirent_new()) == NULL || (entry_size = _zip_dirent_read(cd->entry[i].orig, za->src, cd_buffer, false, error)) < 0) {
	    _zip_cdir_free(cd);
            _zip_buffer_free(cd_buffer);
	    return NULL;
	}
	i++;
        left -= (zip_uint64_t)entry_size;
    }
    
    if (i != cd->nentry) {
        zip_error_set(error, ZIP_ER_INCONS, 0);
        _zip_buffer_free(cd_buffer);
        _zip_cdir_free(cd);
        return NULL;
    }
    
    if (za->open_flags & ZIP_CHECKCONS) {
        bool ok;
        
        if (cd_buffer) {
            ok = _zip_buffer_eof(cd_buffer);
        }
        else {
            zip_int64_t offset = zip_source_tell(za->src);
            
            if (offset < 0) {
                _zip_error_set_from_source(error, za->src);
                _zip_buffer_free(cd_buffer);
                _zip_cdir_free(cd);
                return NULL;
            }
            ok = ((zip_uint64_t)offset == cd->offset + cd->size);
        }
        
        if (!ok) {
            zip_error_set(error, ZIP_ER_INCONS, 0);
            _zip_buffer_free(cd_buffer);
            _zip_cdir_free(cd);
            return NULL;
        }
    }

    _zip_buffer_free(cd_buffer);
    return cd;
}


/* _zip_checkcons:
   Checks the consistency of the central directory by comparing central
   directory entries with local headers and checking for plausible
   file and header offsets. Returns -1 if not plausible, else the
   difference between the lowest and the highest fileposition reached */

static zip_int64_t
_zip_checkcons(zip_t *za, zip_cdir_t *cd, zip_error_t *error)
{
    zip_uint64_t i;
    zip_uint64_t min, max, j;
    struct zip_dirent temp;

    _zip_dirent_init(&temp);
    if (cd->nentry) {
	max = cd->entry[0].orig->offset;
	min = cd->entry[0].orig->offset;
    }
    else
	min = max = 0;

    for (i=0; i<cd->nentry; i++) {
	if (cd->entry[i].orig->offset < min)
	    min = cd->entry[i].orig->offset;
	if (min > (zip_uint64_t)cd->offset) {
	    zip_error_set(error, ZIP_ER_NOZIP, 0);
	    return -1;
	}
	
	j = cd->entry[i].orig->offset + cd->entry[i].orig->comp_size
	    + _zip_string_length(cd->entry[i].orig->filename) + LENTRYSIZE;
	if (j > max)
	    max = j;
	if (max > (zip_uint64_t)cd->offset) {
	    zip_error_set(error, ZIP_ER_NOZIP, 0);
	    return -1;
	}
	
        if (zip_source_seek(za->src, (zip_int64_t)cd->entry[i].orig->offset, SEEK_SET) < 0) {
            _zip_error_set_from_source(error, za->src);
            return -1;
	}
	
	if (_zip_dirent_read(&temp, za->src, NULL, true, error) == -1) {
	    _zip_dirent_finalize(&temp);
	    return -1;
	}
	
	if (_zip_headercomp(cd->entry[i].orig, &temp) != 0) {
	    zip_error_set(error, ZIP_ER_INCONS, 0);
	    _zip_dirent_finalize(&temp);
	    return -1;
	}
	
	cd->entry[i].orig->extra_fields = _zip_ef_merge(cd->entry[i].orig->extra_fields, temp.extra_fields);
	cd->entry[i].orig->local_extra_fields_read = 1;
	temp.extra_fields = NULL;
	
	_zip_dirent_finalize(&temp);
    }

    return (max-min) < ZIP_INT64_MAX ? (zip_int64_t)(max-min) : ZIP_INT64_MAX;
}


/* _zip_headercomp:
   compares a central directory entry and a local file header
   Return 0 if they are consistent, -1 if not. */

static int
_zip_headercomp(const zip_dirent_t *central, const zip_dirent_t *local)
{
    if ((central->version_needed != local->version_needed)
#if 0
	/* some zip-files have different values in local
	   and global headers for the bitflags */
	|| (central->bitflags != local->bitflags)
#endif
	|| (central->comp_method != local->comp_method)
	|| (central->last_mod != local->last_mod)
	|| !_zip_string_equal(central->filename, local->filename))
	return -1;

    if ((central->crc != local->crc) || (central->comp_size != local->comp_size)
	|| (central->uncomp_size != local->uncomp_size)) {
	/* InfoZip stores valid values in local header even when data descriptor is used.
	   This is in violation of the appnote. */
	if (((local->bitflags & ZIP_GPBF_DATA_DESCRIPTOR) == 0
	     || local->crc != 0 || local->comp_size != 0 || local->uncomp_size != 0))
	    return -1;
    }

    return 0;
}


static zip_t *
_zip_allocate_new(zip_source_t *src, unsigned int flags, zip_error_t *error)
{
    zip_t *za;

    if ((za = _zip_new(error)) == NULL) {
	return NULL;
    }

    za->src = src;
    za->open_flags = flags;
    if (flags & ZIP_RDONLY) {
        za->flags |= ZIP_AFL_RDONLY;
        za->ch_flags |= ZIP_AFL_RDONLY;
    }
    return za;
}


/*
 * tests for file existence
 */
static exists_t
_zip_file_exists(zip_source_t *src, zip_error_t *error)
{
    struct zip_stat st;

    zip_stat_init(&st);
    if (zip_source_stat(src, &st) != 0) {
        zip_error_t *src_error = zip_source_error(src);
        if (zip_error_code_zip(src_error) == ZIP_ER_READ && zip_error_code_system(src_error) == ENOENT) {
	    return EXISTS_NOT;
	}
	_zip_error_copy(error, src_error);
	return EXISTS_ERROR;
    }

    return (st.valid & ZIP_STAT_SIZE) && st.size == 0 ? EXISTS_EMPTY : EXISTS_NONEMPTY;
}


static zip_cdir_t *
_zip_find_central_dir(zip_t *za, zip_uint64_t len)
{
    zip_cdir_t *cdir, *cdirnew;
    zip_uint8_t *match;
    zip_int64_t buf_offset;
    zip_uint64_t buflen;
    zip_int64_t a;
    zip_int64_t best;
    zip_error_t error;
    zip_buffer_t *buffer;

    if (len < EOCDLEN) {
	zip_error_set(&za->error, ZIP_ER_NOZIP, 0);
        return NULL;
    }

    buflen = (len < CDBUFSIZE ? len : CDBUFSIZE);
    if (zip_source_seek(za->src, -(zip_int64_t)buflen, SEEK_END) < 0) {
	zip_error_t *src_error = zip_source_error(za->src);
	if (zip_error_code_zip(src_error) != ZIP_ER_SEEK || zip_error_code_system(src_error) != EFBIG) {
	    /* seek before start of file on my machine */
	    _zip_error_copy(&za->error, src_error);
	    return NULL;
	}
    }
    if ((buf_offset = zip_source_tell(za->src)) < 0) {
        _zip_error_set_from_source(&za->error, za->src);
        return NULL;
    }
    
    if ((buffer = _zip_buffer_new_from_source(za->src, buflen, NULL, &za->error)) == NULL) {
        return NULL;
    }

    best = -1;
    cdir = NULL;
    if (buflen >= CDBUFSIZE) {
        /* EOCD64 locator is before EOCD, so leave place for it */
        _zip_buffer_set_offset(buffer, EOCD64LOCLEN);
    }
    zip_error_set(&error, ZIP_ER_NOZIP, 0);

    match = _zip_buffer_get(buffer, 0);
    while ((match=_zip_memmem(match, _zip_buffer_left(buffer)-(EOCDLEN-4), (const unsigned char *)EOCD_MAGIC, 4)) != NULL) {
        _zip_buffer_set_offset(buffer, (zip_uint64_t)(match - _zip_buffer_data(buffer)));
        if ((cdirnew = _zip_read_cdir(za, buffer, (zip_uint64_t)buf_offset, &error)) != NULL) {
            if (cdir) {
                if (best <= 0) {
                    best = _zip_checkcons(za, cdir, &error);
                }
                
                a = _zip_checkcons(za, cdirnew, &error);
                if (best < a) {
                    _zip_cdir_free(cdir);
                    cdir = cdirnew;
                    best = a;
                }
                else {
                    _zip_cdir_free(cdirnew);
                }
            }
            else {
                cdir = cdirnew;
                if (za->open_flags & ZIP_CHECKCONS)
                    best = _zip_checkcons(za, cdir, &error);
                else {
                    best = 0;
                }
            }
            cdirnew = NULL;
        }
        
        match++;
        _zip_buffer_set_offset(buffer, (zip_uint64_t)(match - _zip_buffer_data(buffer)));
    }

    _zip_buffer_free(buffer);
    
    if (best < 0) {
        _zip_error_copy(&za->error, &error);
        _zip_cdir_free(cdir);
        return NULL;
    }

    return cdir;
}


static unsigned char *
_zip_memmem(const unsigned char *big, size_t biglen, const unsigned char *little, size_t littlelen)
{
    const unsigned char *p;
    
    if ((biglen < littlelen) || (littlelen == 0))
	return NULL;
    p = big-1;
    while ((p=(const unsigned char *)
	        memchr(p+1, little[0], (size_t)(big-(p+1))+(size_t)(biglen-littlelen)+1)) != NULL) {
	if (memcmp(p+1, little+1, littlelen-1)==0)
	    return (unsigned char *)p;
    }

    return NULL;
}


static zip_cdir_t *_zip_read_eocd(zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error)
{
    zip_cdir_t *cd;
    zip_uint64_t i, nentry, size, offset, eocd_offset;

    if (_zip_buffer_left(buffer) < EOCDLEN) {
	zip_error_set(error, ZIP_ER_INCONS, 0);
	return NULL;
    }
    
    eocd_offset = _zip_buffer_offset(buffer);

    _zip_buffer_get(buffer, 8); /* magic and number of disks already verified */

    /* number of cdir-entries on this disk */
    i = _zip_buffer_get_16(buffer);
    /* number of cdir-entries */
    nentry = _zip_buffer_get_16(buffer);

    if (nentry != i) {
	zip_error_set(error, ZIP_ER_NOZIP, 0);
	return NULL;
    }

    size = _zip_buffer_get_32(buffer);
    offset = _zip_buffer_get_32(buffer);

    if (offset+size < offset) {
        zip_error_set(error, ZIP_ER_SEEK, EFBIG);
        return NULL;
    }
    
    if (offset+size > buf_offset + eocd_offset) {
	/* cdir spans past EOCD record */
	zip_error_set(error, ZIP_ER_INCONS, 0);
	return NULL;
    }

    if ((flags & ZIP_CHECKCONS) && offset+size != buf_offset + eocd_offset) {
	zip_error_set(error, ZIP_ER_INCONS, 0);
	return NULL;
    }

    if ((cd=_zip_cdir_new(nentry, error)) == NULL)
	return NULL;

    cd->size = size;
    cd->offset = offset;
    
    return cd;
}


static zip_cdir_t *
_zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error)
{
    zip_cdir_t *cd;
    zip_uint64_t offset;
    zip_uint8_t eocd[EOCD64LEN];
    zip_uint64_t eocd_offset;
    zip_uint64_t size, nentry, i, eocdloc_offset;
    bool free_buffer;

    eocdloc_offset = _zip_buffer_offset(buffer);
    
    _zip_buffer_get(buffer, 8); /* magic and single disk already verified */
    eocd_offset = _zip_buffer_get_64(buffer);
    
    if (eocd_offset > ZIP_INT64_MAX || eocd_offset + EOCD64LEN < eocd_offset) {
        zip_error_set(error, ZIP_ER_SEEK, EFBIG);
        return NULL;
    }

    if (eocd_offset + EOCD64LEN > eocdloc_offset + buf_offset) {
	zip_error_set(error, ZIP_ER_INCONS, 0);
	return NULL;
    }

    if (eocd_offset >= buf_offset && eocd_offset + EOCD64LEN <= buf_offset + _zip_buffer_size(buffer)) {
        _zip_buffer_set_offset(buffer, eocd_offset - buf_offset);
        free_buffer = false;
    }
    else {
        if (zip_source_seek(src, (zip_int64_t)eocd_offset, SEEK_SET) < 0) {
            _zip_error_set_from_source(error, src);
            return NULL;
        }
        if ((buffer = _zip_buffer_new_from_source(src, EOCD64LEN, eocd, error)) == NULL) {
            return NULL;
        }
        free_buffer = true;
    }

    if (memcmp(_zip_buffer_get(buffer, 4), EOCD64_MAGIC, 4) != 0) {
	zip_error_set(error, ZIP_ER_INCONS, 0);
        if (free_buffer) {
            _zip_buffer_free(buffer);
        }
	return NULL;
    }
    
    size = _zip_buffer_get_64(buffer);

    if ((flags & ZIP_CHECKCONS) && size + eocd_offset + 12 != buf_offset + eocdloc_offset) {
	zip_error_set(error, ZIP_ER_INCONS, 0);
        if (free_buffer) {
            _zip_buffer_free(buffer);
        }
        return NULL;
    }

    _zip_buffer_get(buffer, 12); /* skip version made by/needed and num disks */
    
    nentry = _zip_buffer_get_64(buffer);
    i = _zip_buffer_get_64(buffer);

    if (nentry != i) {
	zip_error_set(error, ZIP_ER_MULTIDISK, 0);
        if (free_buffer) {
            _zip_buffer_free(buffer);
        }
	return NULL;
    }

    size = _zip_buffer_get_64(buffer);
    offset = _zip_buffer_get_64(buffer);
    
    if (!_zip_buffer_ok(buffer)) {
        zip_error_set(error, ZIP_ER_INTERNAL, 0);
        if (free_buffer) {
            _zip_buffer_free(buffer);
        }
        return NULL;
    }

    if (free_buffer) {
        _zip_buffer_free(buffer);
    }

    if (offset > ZIP_INT64_MAX || offset+size < offset) {
        zip_error_set(error, ZIP_ER_SEEK, EFBIG);
        return NULL;
    }
    if ((flags & ZIP_CHECKCONS) && offset+size != eocd_offset) {
	zip_error_set(error, ZIP_ER_INCONS, 0);
	return NULL;
    }

    if ((cd=_zip_cdir_new(nentry, error)) == NULL)
	return NULL;

    
    cd->size = size;
    cd->offset = offset;

    return cd;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_rename.c`:

```c
/*
  zip_rename.c -- rename file in zip archive
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <string.h>

#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


ZIP_EXTERN int
zip_rename(zip_t *za, zip_uint64_t idx, const char *name)
{
    return zip_file_rename(za, idx, name, 0);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_replace.c`:

```c
/*
  zip_replace.c -- replace file via callback function
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


ZIP_EXTERN int
zip_replace(zip_t *za, zip_uint64_t idx, zip_source_t *source)
{
    return zip_file_replace(za, idx, source, 0);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_set_archive_comment.c`:

```c
/*
  zip_set_archive_comment.c -- set archive comment
  Copyright (C) 2006-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN int
zip_set_archive_comment(zip_t *za, const char *comment, zip_uint16_t len)
{
    zip_string_t *cstr;

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    if (len > 0 && comment == NULL) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (len > 0) {
	if ((cstr=_zip_string_new((const zip_uint8_t *)comment, len, ZIP_FL_ENC_GUESS, &za->error)) == NULL)
	    return -1;

	if (_zip_guess_encoding(cstr, ZIP_ENCODING_UNKNOWN) == ZIP_ENCODING_CP437) {
	    _zip_string_free(cstr);
	    zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	    return -1;
	}
    }
    else
	cstr = NULL;

    _zip_string_free(za->comment_changes);
    za->comment_changes = NULL;

    if (((za->comment_orig && _zip_string_equal(za->comment_orig, cstr))
	 || (za->comment_orig == NULL && cstr == NULL))) {
	_zip_string_free(cstr);
	za->comment_changed = 0;
    }
    else {
	za->comment_changes = cstr;
	za->comment_changed = 1;
    }
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_set_archive_flag.c`:

```c
/*
  zip_get_archive_flag.c -- set archive global flag
  Copyright (C) 2008-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_set_archive_flag(zip_t *za, zip_flags_t flag, int value)
{
    unsigned int new_flags;
    
    if (value)
	new_flags = za->ch_flags | flag;
    else
	new_flags = za->ch_flags & ~flag;

    if (new_flags == za->ch_flags)
	return 0;

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    if ((flag & ZIP_AFL_RDONLY) && value
	&& (za->ch_flags & ZIP_AFL_RDONLY) == 0) {
	if (_zip_changed(za, NULL)) {
	    zip_error_set(&za->error, ZIP_ER_CHANGED, 0);
	    return -1;
	}
    }

    za->ch_flags = new_flags;

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_set_default_password.c`:

```c
/*
  zip_set_default_password.c -- set default password for decryption
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>
#include <string.h>

#include "zipint.h"


ZIP_EXTERN int
zip_set_default_password(zip_t *za, const char *passwd)
{
    if (za == NULL)
	return -1;

    if (za->default_password)
	free(za->default_password);
    
    if (passwd) {
	if ((za->default_password=strdup(passwd)) == NULL) {
	    zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	    return -1;
	}
    }
    else
	za->default_password = NULL;

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_set_file_comment.c`:

```c
/*
  zip_set_file_comment.c -- set comment for file in archive
  Copyright (C) 2006-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#define _ZIP_COMPILING_DEPRECATED
#include "zipint.h"


ZIP_EXTERN int
zip_set_file_comment(zip_t *za, zip_uint64_t idx, const char *comment, int len)
{
    if (len < 0 || len > ZIP_UINT16_MAX) {
        zip_error_set(&za->error, ZIP_ER_INVAL, 0);
        return -1;
    }
    return zip_file_set_comment(za, idx, comment, (zip_uint16_t)len, 0);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_set_file_compression.c`:

```c
/*
  zip_set_file_compression.c -- set compression for file in archive
  Copyright (C) 2012-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_set_file_compression(zip_t *za, zip_uint64_t idx, zip_int32_t method, zip_uint32_t flags)
{
    zip_entry_t *e;
    zip_int32_t old_method;

    if (idx >= za->nentry) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    if (method != ZIP_CM_DEFAULT && method != ZIP_CM_STORE && method != ZIP_CM_DEFLATE) {
	zip_error_set(&za->error, ZIP_ER_COMPNOTSUPP, 0);
	return -1;
    }

    e = za->entry+idx;
    
    old_method = (e->orig == NULL ? ZIP_CM_DEFAULT : e->orig->comp_method);
    
    /* TODO: revisit this when flags are supported, since they may require a recompression */
    
    if (method == old_method) {
	if (e->changes) {
	    e->changes->changed &= ~ZIP_DIRENT_COMP_METHOD;
	    if (e->changes->changed == 0) {
		_zip_dirent_free(e->changes);
		e->changes = NULL;
	    }
	}
    }
    else {
        if (e->changes == NULL) {
            if ((e->changes=_zip_dirent_clone(e->orig)) == NULL) {
                zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
                return -1;
            }
        }

        e->changes->comp_method = method;
        e->changes->changed |= ZIP_DIRENT_COMP_METHOD;
    }
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_set_name.c`:

```c
/*
  zip_set_name.c -- rename helper function
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>
#include <string.h>

#include "zipint.h"


int
_zip_set_name(zip_t *za, zip_uint64_t idx, const char *name, zip_flags_t flags)
{
    zip_entry_t *e;
    zip_string_t *str;
    int changed;
    zip_int64_t i;

    if (idx >= za->nentry) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (ZIP_IS_RDONLY(za)) {
	zip_error_set(&za->error, ZIP_ER_RDONLY, 0);
	return -1;
    }

    if (name && strlen(name) > 0) {
        /* TODO: check for string too long */
	if ((str=_zip_string_new((const zip_uint8_t *)name, (zip_uint16_t)strlen(name), flags, &za->error)) == NULL)
	    return -1;
	if ((flags & ZIP_FL_ENCODING_ALL) == ZIP_FL_ENC_GUESS && _zip_guess_encoding(str, ZIP_ENCODING_UNKNOWN) == ZIP_ENCODING_UTF8_GUESSED)
	    str->encoding = ZIP_ENCODING_UTF8_KNOWN;
    }
    else
	str = NULL;

    /* TODO: encoding flags needed for CP437? */
    if ((i=_zip_name_locate(za, name, 0, NULL)) >= 0 && (zip_uint64_t)i != idx) {
	_zip_string_free(str);
	zip_error_set(&za->error, ZIP_ER_EXISTS, 0);
	return -1;
    }

    /* no effective name change */
    if (i>=0 && (zip_uint64_t)i == idx) {
	_zip_string_free(str);
	return 0;
    }

    e = za->entry+idx;

    if (e->changes) {
	_zip_string_free(e->changes->filename);
	e->changes->filename = NULL;
	e->changes->changed &= ~ZIP_DIRENT_FILENAME;
    }

    if (e->orig)
	changed = !_zip_string_equal(e->orig->filename, str);
    else
	changed = 1;
	
    if (changed) {
        if (e->changes == NULL) {
            if ((e->changes=_zip_dirent_clone(e->orig)) == NULL) {
                zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
		_zip_string_free(str);
                return -1;
            }
        }
        e->changes->filename = str;
        e->changes->changed |= ZIP_DIRENT_FILENAME;
    }
    else {
	_zip_string_free(str);
	if (e->changes && e->changes->changed == 0) {
	    _zip_dirent_free(e->changes);
	    e->changes = NULL;
	}
    }

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_begin_write.c`:

```c
/*
  zip_source_begin_write.c -- start a new file for writing
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_source_begin_write(zip_source_t *src)
{
    if (ZIP_SOURCE_IS_OPEN_WRITING(src)) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
        return -1;
    }
    
    if (_zip_source_call(src, NULL, 0, ZIP_SOURCE_BEGIN_WRITE) < 0) {
        return -1;
    }

    src->write_state = ZIP_SOURCE_WRITE_OPEN;
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_buffer.c`:

```c
/*
  zip_source_buffer.c -- create zip data source from buffer
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include "zipint.h"

#ifndef WRITE_FRAGMENT_SIZE
#define WRITE_FRAGMENT_SIZE 64*1024
#endif

struct buffer {
    zip_uint64_t fragment_size;		/* size of each fragment */

    zip_uint8_t **fragments;		/* pointers to fragments */
    zip_uint64_t nfragments;		/* number of allocated fragments */
    zip_uint64_t fragments_capacity;	/* size of fragments (number of pointers) */
    zip_uint64_t size;			/* size of data in bytes */
    zip_uint64_t offset;		/* current offset */
    int free_data;
};

typedef struct buffer buffer_t;

struct read_data {
    zip_error_t error;
    time_t mtime;
    buffer_t *in;
    buffer_t *out;
};

static void buffer_free(buffer_t *buffer);
static buffer_t *buffer_new(zip_uint64_t fragment_size);
static buffer_t *buffer_new_read(const void *data, zip_uint64_t length, int free_data);
static buffer_t *buffer_new_write(zip_uint64_t fragment_size);
static zip_int64_t buffer_read(buffer_t *buffer, zip_uint8_t *data, zip_uint64_t length);
static int buffer_seek(buffer_t *buffer, void *data, zip_uint64_t len, zip_error_t *error);
static zip_int64_t buffer_write(buffer_t *buffer, const zip_uint8_t *data, zip_uint64_t length, zip_error_t *);

static zip_int64_t read_data(void *, void *, zip_uint64_t, zip_source_cmd_t);


ZIP_EXTERN zip_source_t *
zip_source_buffer(zip_t *za, const void *data, zip_uint64_t len, int freep)
{
    if (za == NULL)
	return NULL;

    return zip_source_buffer_create(data, len, freep, &za->error);
}


ZIP_EXTERN zip_source_t *
zip_source_buffer_create(const void *data, zip_uint64_t len, int freep, zip_error_t *error)
{
    struct read_data *ctx;
    zip_source_t *zs;

    if (data == NULL && len > 0) {
	zip_error_set(error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    if ((ctx=(struct read_data *)malloc(sizeof(*ctx))) == NULL) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    if ((ctx->in = buffer_new_read(data, len, freep)) == NULL) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	free(ctx);
	return NULL;
    }

    ctx->out = NULL;
    ctx->mtime = time(NULL);
    zip_error_init(&ctx->error);
    
    if ((zs=zip_source_function_create(read_data, ctx, error)) == NULL) {
	buffer_free(ctx->in);
	free(ctx);
	return NULL;
    }

    return zs;
}


static zip_int64_t
read_data(void *state, void *data, zip_uint64_t len, zip_source_cmd_t cmd)
{
    struct read_data *ctx = (struct read_data *)state;

    switch (cmd) {
        case ZIP_SOURCE_BEGIN_WRITE:
	    if ((ctx->out = buffer_new_write(WRITE_FRAGMENT_SIZE)) == NULL) {
		zip_error_set(&ctx->error, ZIP_ER_MEMORY, 0);
		return -1;
	    }
	    return 0;

        case ZIP_SOURCE_CLOSE:
            return 0;
            
        case ZIP_SOURCE_COMMIT_WRITE:
	    buffer_free(ctx->in);
	    ctx->in = ctx->out;
	    ctx->out = NULL;
	    return 0;

        case ZIP_SOURCE_ERROR:
            return zip_error_to_data(&ctx->error, data, len);
            
        case ZIP_SOURCE_FREE:
	    buffer_free(ctx->in);
	    buffer_free(ctx->out);
            free(ctx);
            return 0;
            
        case ZIP_SOURCE_OPEN:
	    ctx->in->offset = 0;
            return 0;
	
        case ZIP_SOURCE_READ:
	    if (len > ZIP_INT64_MAX) {
		zip_error_set(&ctx->error, ZIP_ER_INVAL, 0);
		return -1;
	    }
            return buffer_read(ctx->in, data, len);
	
        case ZIP_SOURCE_REMOVE:
	{
	    buffer_t *empty = buffer_new_read(NULL, 0, 0);
	    if (empty == 0) {
		zip_error_set(&ctx->error, ZIP_ER_MEMORY, 0);
		return -1;
	    }
	
	    buffer_free(ctx->in);
	    ctx->in = empty;
	    return 0;
	}

        case ZIP_SOURCE_ROLLBACK_WRITE:
	    buffer_free(ctx->out);
	    ctx->out = NULL;
	    return 0;

        case ZIP_SOURCE_SEEK:
	    return buffer_seek(ctx->in, data, len, &ctx->error);

        case ZIP_SOURCE_SEEK_WRITE:
	    return buffer_seek(ctx->out, data, len, &ctx->error);
       
        case ZIP_SOURCE_STAT:
        {
            zip_stat_t *st;
	    
	    if (len < sizeof(*st)) {
                zip_error_set(&ctx->error, ZIP_ER_INVAL, 0);
		return -1;
	    }

	    st = (zip_stat_t *)data;

	    zip_stat_init(st);
	    st->mtime = ctx->mtime;
	    st->size = ctx->in->size;
	    st->comp_size = st->size;
	    st->comp_method = ZIP_CM_STORE;
	    st->encryption_method = ZIP_EM_NONE;
	    st->valid = ZIP_STAT_MTIME|ZIP_STAT_SIZE|ZIP_STAT_COMP_SIZE|ZIP_STAT_COMP_METHOD|ZIP_STAT_ENCRYPTION_METHOD;
	    
	    return sizeof(*st);
	}

        case ZIP_SOURCE_SUPPORTS:
	    return zip_source_make_command_bitmap(ZIP_SOURCE_OPEN, ZIP_SOURCE_READ, ZIP_SOURCE_CLOSE, ZIP_SOURCE_STAT, ZIP_SOURCE_ERROR, ZIP_SOURCE_FREE, ZIP_SOURCE_SEEK, ZIP_SOURCE_TELL, ZIP_SOURCE_BEGIN_WRITE, ZIP_SOURCE_COMMIT_WRITE, ZIP_SOURCE_REMOVE, ZIP_SOURCE_ROLLBACK_WRITE, ZIP_SOURCE_SEEK_WRITE, ZIP_SOURCE_TELL_WRITE, ZIP_SOURCE_WRITE, -1);
            
        case ZIP_SOURCE_TELL:
            if (ctx->in->offset > ZIP_INT64_MAX) {
		zip_error_set(&ctx->error, ZIP_ER_TELL, EOVERFLOW);
		return -1;
	    }
	    return (zip_int64_t)ctx->in->offset;
		
            
        case ZIP_SOURCE_TELL_WRITE:
            if (ctx->out->offset > ZIP_INT64_MAX) {
		zip_error_set(&ctx->error, ZIP_ER_TELL, EOVERFLOW);
		return -1;
	    }
	    return (zip_int64_t)ctx->out->offset;

        case ZIP_SOURCE_WRITE:
	    if (len > ZIP_INT64_MAX) {
		zip_error_set(&ctx->error, ZIP_ER_INVAL, 0);
		return -1;
	    }
	    return buffer_write(ctx->out, data, len, &ctx->error);

        default:
	    zip_error_set(&ctx->error, ZIP_ER_OPNOTSUPP, 0);
            return -1;
    }
}


static void
buffer_free(buffer_t *buffer)
{
    if (buffer == NULL) {
	return; 
    }

    if (buffer->free_data) {
	zip_uint64_t i;

	for (i=0; i < buffer->nfragments; i++) {
	    free(buffer->fragments[i]);
	}
    }
    free(buffer->fragments);
    free(buffer);
}


static buffer_t *
buffer_new(zip_uint64_t fragment_size)
{
    buffer_t *buffer;

    if ((buffer = malloc(sizeof(*buffer))) == NULL) {
	return NULL;
    }

    buffer->fragment_size = fragment_size;
    buffer->offset = 0;
    buffer->free_data = 0;
    buffer->nfragments = 0;
    buffer->fragments_capacity = 0;
    buffer->fragments = NULL;
    buffer->size = 0;

    return buffer;
}


static buffer_t *
buffer_new_read(const void *data, zip_uint64_t length, int free_data)
{
    buffer_t *buffer;

    if ((buffer = buffer_new(length)) == NULL) {
	return NULL;
    }

    buffer->size = length;

    if (length > 0) {
	if ((buffer->fragments = malloc(sizeof(*(buffer->fragments)))) == NULL) {
	    buffer_free(buffer);
	    return NULL;
	}
	buffer->fragments_capacity = 1;

	buffer->nfragments = 1;
	buffer->fragments[0] = (zip_uint8_t *)data;
	buffer->free_data = free_data;
    }

    return buffer;
}


static buffer_t *
buffer_new_write(zip_uint64_t fragment_size)
{
    buffer_t *buffer;

    if ((buffer = buffer_new(fragment_size)) == NULL) {
	return NULL;
    }

    if ((buffer->fragments = malloc(sizeof(*(buffer->fragments)))) == NULL) {
	buffer_free(buffer);
	return NULL;
    }
    buffer->fragments_capacity = 1;
    buffer->nfragments = 0;
    buffer->free_data = 1;

    return buffer;
}


static zip_int64_t
buffer_read(buffer_t *buffer, zip_uint8_t *data, zip_uint64_t length)
{
    zip_uint64_t n, i, fragment_offset;

    length = ZIP_MIN(length, buffer->size - buffer->offset);

    if (length == 0) {
	return 0;
    }
    if (length > ZIP_INT64_MAX) {
	return -1;
    }

    i = buffer->offset / buffer->fragment_size;
    fragment_offset = buffer->offset % buffer->fragment_size;
    n = 0;
    while (n < length) {
	zip_uint64_t left = ZIP_MIN(length - n, buffer->fragment_size - fragment_offset);
	
	memcpy(data + n, buffer->fragments[i] + fragment_offset, left);

	n += left;
	i++;
	fragment_offset = 0;
    }

    buffer->offset += n;
    return (zip_int64_t)n;
}


static int
buffer_seek(buffer_t *buffer, void *data, zip_uint64_t len, zip_error_t *error)
{
    zip_int64_t new_offset = zip_source_seek_compute_offset(buffer->offset, buffer->size, data, len, error);
    
    if (new_offset < 0) {
        return -1;
    }
    
    buffer->offset = (zip_uint64_t)new_offset;
    return 0;
}


static zip_int64_t
buffer_write(buffer_t *buffer, const zip_uint8_t *data, zip_uint64_t length, zip_error_t *error)
{
    zip_uint64_t n, i, fragment_offset;

    if (buffer->offset + length + buffer->fragment_size - 1 < length) {
	zip_error_set(error, ZIP_ER_INVAL, 0);
	return -1;
    }

    /* grow buffer if needed */
    if (buffer->offset + length > buffer->nfragments * buffer->fragment_size) {
	zip_uint64_t needed_fragments = (buffer->offset + length + buffer->fragment_size - 1) / buffer->fragment_size;
	
	if (needed_fragments > buffer->fragments_capacity) {
	    zip_uint64_t new_capacity = buffer->fragments_capacity;

	    while (new_capacity < needed_fragments) {
		new_capacity *= 2;
	    }

	    zip_uint8_t **fragments = realloc(buffer->fragments, new_capacity * sizeof(*fragments));

	    if (fragments == NULL) {
		zip_error_set(error, ZIP_ER_MEMORY, 0);
		return -1;
	    }

	    buffer->fragments = fragments;
	    buffer->fragments_capacity = new_capacity;
	}

	while (buffer->nfragments < needed_fragments) {
	    if ((buffer->fragments[buffer->nfragments] = malloc(buffer->fragment_size)) == NULL) {
		zip_error_set(error, ZIP_ER_MEMORY, 0);
		return -1;
	    }
	    buffer->nfragments++;
	}
    }

    i = buffer->offset / buffer->fragment_size;
    fragment_offset = buffer->offset % buffer->fragment_size;
    n = 0;
    while (n < length) {
	zip_uint64_t left = ZIP_MIN(length - n, buffer->fragment_size - fragment_offset);
		
	memcpy(buffer->fragments[i] + fragment_offset, data + n, left);

	n += left;
	i++;
	fragment_offset = 0;
    }

    buffer->offset += n;
    if (buffer->offset > buffer->size) {
	buffer->size = buffer->offset;
    }

    return (zip_int64_t)n;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_call.c`:

```c
/*
 zip_source_call.c -- invoke callback command on zip_source
 Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner
 
 This file is part of libzip, a library to manipulate ZIP archives.
 The authors can be contacted at <libzip@nih.at>
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the
 distribution.
 3. The names of the authors may not be used to endorse or promote
 products derived from this software without specific prior
 written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include "zipint.h"


zip_int64_t
_zip_source_call(zip_source_t *src, void *data, zip_uint64_t length, zip_source_cmd_t command)
{
    zip_int64_t ret;
    
    if ((src->supports & ZIP_SOURCE_MAKE_COMMAND_BITMASK(command)) == 0) {
        zip_error_set(&src->error, ZIP_ER_OPNOTSUPP, 0);
        return -1;
    }

    if (src->src == NULL) {
        ret = src->cb.f(src->ud, data, length, command);
    }
    else {
        ret = src->cb.l(src->src, src->ud, data, length, command);
    }
    
    if (ret < 0) {
        if (command != ZIP_SOURCE_ERROR && command != ZIP_SOURCE_SUPPORTS) {
            int e[2];
            
            if (_zip_source_call(src, e, sizeof(e), ZIP_SOURCE_ERROR) < 0) {
                zip_error_set(&src->error, ZIP_ER_INTERNAL, 0);
            }
            else {
                zip_error_set(&src->error, e[0], e[1]);
            }
        }
    }

    return ret;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_close.c`:

```c
/*
  zip_source_close.c -- close zip_source (stop reading)
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


int
zip_source_close(zip_source_t *src)
{
    if (!ZIP_SOURCE_IS_OPEN_READING(src)) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
        return -1;
    }
    
    src->open_count--;
    if (src->open_count == 0) {
	_zip_source_call(src, NULL, 0, ZIP_SOURCE_CLOSE);

	if (ZIP_SOURCE_IS_LAYERED(src)) {
	    if (zip_source_close(src->src) < 0) {
		zip_error_set(&src->error, ZIP_ER_INTERNAL, 0);
	    }
	}
    }

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_commit_write.c`:

```c
/*
  zip_source_commit_write.c -- commit changes to file
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_source_commit_write(zip_source_t *src)
{
    if (!ZIP_SOURCE_IS_OPEN_WRITING(src)) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
        return -1;
    }
    
    if (src->open_count > 1) {
	zip_error_set(&src->error, ZIP_ER_INUSE, 0);
	return -1;
    }
    else if (ZIP_SOURCE_IS_OPEN_READING(src)) {
        if (zip_source_close(src) < 0) {
	    return -1;
	}
    }
    
    if (_zip_source_call(src, NULL, 0, ZIP_SOURCE_COMMIT_WRITE) < 0) {
        src->write_state = ZIP_SOURCE_WRITE_FAILED;
        return -1;
    }
    
    src->write_state = ZIP_SOURCE_WRITE_CLOSED;
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_crc.c`:

```c
/*
  zip_source_crc.c -- pass-through source that calculates CRC32 and size
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "zipint.h"

struct crc_context {
    int eof;
    int validate;
    zip_error_t error;
    zip_uint64_t size;
    zip_uint32_t crc;
};

static zip_int64_t crc_read(zip_source_t *, void *, void *, zip_uint64_t, zip_source_cmd_t);


zip_source_t *
zip_source_crc(zip_t *za, zip_source_t *src, int validate)
{
    struct crc_context *ctx;

    if (src == NULL) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    if ((ctx=(struct crc_context *)malloc(sizeof(*ctx))) == NULL) {
	zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    ctx->eof = 0;
    ctx->validate = validate;
    zip_error_init(&ctx->error);
    ctx->size = 0;
    ctx->crc = 0;
    
    return zip_source_layered(za, src, crc_read, ctx);
}


static zip_int64_t
crc_read(zip_source_t *src, void *_ctx, void *data, zip_uint64_t len, zip_source_cmd_t cmd)
{
    struct crc_context *ctx;
    zip_int64_t n;

    ctx = (struct crc_context *)_ctx;

    switch (cmd) {
        case ZIP_SOURCE_OPEN:
            ctx->eof = 0;
            ctx->crc = (zip_uint32_t)crc32(0, NULL, 0);
            ctx->size = 0;
            
            return 0;
            
        case ZIP_SOURCE_READ:
            if (ctx->eof || len == 0)
                return 0;
            
            if ((n=zip_source_read(src, data, len)) < 0) {
                _zip_error_set_from_source(&ctx->error, src);
                return -1;
            }
            
            if (n == 0) {
                ctx->eof = 1;
                if (ctx->validate) {
                    struct zip_stat st;
                    
                    if (zip_source_stat(src, &st) < 0) {
                        _zip_error_set_from_source(&ctx->error, src);
                        return -1;
                    }
                    
                    if ((st.valid & ZIP_STAT_CRC) && st.crc != ctx->crc) {
                        zip_error_set(&ctx->error, ZIP_ER_CRC, 0);
                        return -1;
                    }
                    if ((st.valid & ZIP_STAT_SIZE) && st.size != ctx->size) {
                        zip_error_set(&ctx->error, ZIP_ER_INCONS, 0);
                        return -1;
                    }
                }
            }
            else {
		zip_uint64_t i, nn;

		for (i=0; i < (zip_uint64_t)n; i += nn) {
		    nn = ZIP_MIN(UINT_MAX, (zip_uint64_t)n-i);

		    ctx->crc = (zip_uint32_t)crc32(ctx->crc, (const Bytef *)data+i, (uInt)nn);
		}
                ctx->size += (zip_uint64_t)n;
            }
            return n;

        case ZIP_SOURCE_CLOSE:
            return 0;

        case ZIP_SOURCE_STAT:
        {
            zip_stat_t *st;

	    st = (zip_stat_t *)data;

	    if (ctx->eof) {
		/* TODO: Set comp_size, comp_method, encryption_method?
		        After all, this only works for uncompressed data. */
		st->size = ctx->size;
		st->crc = ctx->crc;
		st->comp_size = ctx->size;
		st->comp_method = ZIP_CM_STORE;
		st->encryption_method = ZIP_EM_NONE;
		st->valid |= ZIP_STAT_SIZE|ZIP_STAT_CRC|ZIP_STAT_COMP_SIZE|ZIP_STAT_COMP_METHOD|ZIP_STAT_ENCRYPTION_METHOD;;
	    }
            return 0;
        }
            
        case ZIP_SOURCE_ERROR:
            return zip_error_to_data(&ctx->error, data, len);

        case ZIP_SOURCE_FREE:
            free(ctx);
            return 0;
            
        case ZIP_SOURCE_SUPPORTS:
            return zip_source_make_command_bitmap(ZIP_SOURCE_OPEN, ZIP_SOURCE_READ, ZIP_SOURCE_CLOSE, ZIP_SOURCE_STAT, ZIP_SOURCE_ERROR, ZIP_SOURCE_FREE, -1);
            
        default:
            zip_error_set(&ctx->error, ZIP_ER_OPNOTSUPP, 0);
            return -1;
    }
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_deflate.c`:

```c
/*
  zip_source_deflate.c -- deflate (de)compressoin routines
  Copyright (C) 2009-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "zipint.h"

struct deflate {
    zip_error_t error;
    
    bool eof;
    bool can_store;
    bool is_stored;
    int mem_level;
    zip_uint64_t size;
    zip_uint8_t buffer[BUFSIZE];
    z_stream zstr;
};

static zip_int64_t compress_read(zip_source_t *, struct deflate *, void *, zip_uint64_t);
static zip_int64_t decompress_read(zip_source_t *, struct deflate *, void *, zip_uint64_t);
static zip_int64_t deflate_compress(zip_source_t *, void *, void *, zip_uint64_t, zip_source_cmd_t);
static zip_int64_t deflate_decompress(zip_source_t *, void *, void *, zip_uint64_t, zip_source_cmd_t);
static void deflate_free(struct deflate *);


zip_source_t *
zip_source_deflate(zip_t *za, zip_source_t *src, zip_int32_t cm, int flags)
{
    struct deflate *ctx;
    zip_source_t *s2;

    if (src == NULL || (cm != ZIP_CM_DEFLATE && !ZIP_CM_IS_DEFAULT(cm))) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    if ((ctx=(struct deflate *)malloc(sizeof(*ctx))) == NULL) {
	zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    zip_error_init(&ctx->error);
    ctx->eof = false;
    ctx->is_stored = false;
    ctx->can_store = ZIP_CM_IS_DEFAULT(cm);
    if (flags & ZIP_CODEC_ENCODE) {
	ctx->mem_level = MAX_MEM_LEVEL;
    }

    if ((s2=zip_source_layered(za, src,
			       ((flags & ZIP_CODEC_ENCODE)
				? deflate_compress : deflate_decompress),
			       ctx)) == NULL) {
	deflate_free(ctx);
	return NULL;
    }

    return s2;
}


static zip_int64_t
compress_read(zip_source_t *src, struct deflate *ctx, void *data, zip_uint64_t len)
{
    int end, ret;
    zip_int64_t n;
    zip_uint64_t out_offset;
    uInt out_len;

    if (zip_error_code_zip(&ctx->error) != ZIP_ER_OK)
	return -1;
    
    if (len == 0 || ctx->is_stored) {
	return 0;
    }
	
    out_offset = 0;
    out_len = (uInt)ZIP_MIN(UINT_MAX, len);
    ctx->zstr.next_out = (Bytef *)data;
    ctx->zstr.avail_out = out_len;

    end = 0;
    while (!end) {
	ret = deflate(&ctx->zstr, ctx->eof ? Z_FINISH : 0);

	switch (ret) {
        case Z_STREAM_END:
            if (ctx->can_store && ctx->zstr.total_in <= ctx->zstr.total_out) {
                ctx->is_stored = true;
                ctx->size = ctx->zstr.total_in;
                memcpy(data, ctx->buffer, ctx->size);
                return (zip_int64_t)ctx->size;
            }
            /* fallthrough */
	case Z_OK:
	    /* all ok */

	    if (ctx->zstr.avail_out == 0) {
		out_offset += out_len;
		if (out_offset < len) {
		    out_len = (uInt)ZIP_MIN(UINT_MAX, len-out_offset);
		    ctx->zstr.next_out = (Bytef *)data+out_offset;
		    ctx->zstr.avail_out = out_len;
		}
		else {
                    ctx->can_store = false;
		    end = 1;
		}
	    }
	    else if (ctx->eof && ctx->zstr.avail_in == 0)
		end = 1;
	    break;

	case Z_BUF_ERROR:
	    if (ctx->zstr.avail_in == 0) {
		if (ctx->eof) {
		    end = 1;
		    break;
		}

		if ((n=zip_source_read(src, ctx->buffer, sizeof(ctx->buffer))) < 0) {
                    _zip_error_set_from_source(&ctx->error, src);
		    end = 1;
		    break;
		}
		else if (n == 0) {
		    ctx->eof = true;
		    /* TODO: check against stat of src? */
		    ctx->size = ctx->zstr.total_in;
		}
		else {
                    if (ctx->zstr.total_in > 0) {
                        /* we overwrote a previously filled ctx->buffer */
                        ctx->can_store = false;
                    }
		    ctx->zstr.next_in = (Bytef *)ctx->buffer;
		    ctx->zstr.avail_in = (uInt)n;
		}
		continue;
	    }
	    /* fallthrough */
	case Z_NEED_DICT:
	case Z_DATA_ERROR:
	case Z_STREAM_ERROR:
	case Z_MEM_ERROR:
            zip_error_set(&ctx->error, ZIP_ER_ZLIB, ret);

	    end = 1;
	    break;
	}
    }

    if (ctx->zstr.avail_out < len) {
	ctx->can_store = false;
	return (zip_int64_t)(len - ctx->zstr.avail_out);
    }

    return (zip_error_code_zip(&ctx->error) == ZIP_ER_OK) ? 0 : -1;
}


static zip_int64_t
decompress_read(zip_source_t *src, struct deflate *ctx, void *data, zip_uint64_t len)
{
    int end, ret;
    zip_int64_t n;
    zip_uint64_t out_offset;
    uInt out_len;

    if (zip_error_code_zip(&ctx->error) != ZIP_ER_OK)
	return -1;
    
    if (len == 0)
	return 0;

    out_offset = 0;
    out_len = (uInt)ZIP_MIN(UINT_MAX, len);
    ctx->zstr.next_out = (Bytef *)data;
    ctx->zstr.avail_out = out_len;

    end = 0;
    while (!end) {
	ret = inflate(&ctx->zstr, Z_SYNC_FLUSH);

	switch (ret) {
	case Z_OK:
	    if (ctx->zstr.avail_out == 0) {
		out_offset += out_len;
		if (out_offset < len) {
		    out_len = (uInt)ZIP_MIN(UINT_MAX, len-out_offset);
		    ctx->zstr.next_out = (Bytef *)data+out_offset;
		    ctx->zstr.avail_out = out_len;
		}
		else {
		    end = 1;
		}
	    }
	    break;
	    
	case Z_STREAM_END:
	    ctx->eof = 1;
	    end = 1;
	    break;

	case Z_BUF_ERROR:
	    if (ctx->zstr.avail_in == 0) {
		if (ctx->eof) {
		    end = 1;
		    break;
		}

		if ((n=zip_source_read(src, ctx->buffer, sizeof(ctx->buffer))) < 0) {
                    _zip_error_set_from_source(&ctx->error, src);
		    end = 1;
		    break;
		}
		else if (n == 0) {
		    ctx->eof = 1;
		}
		else {
		    ctx->zstr.next_in = (Bytef *)ctx->buffer;
		    ctx->zstr.avail_in = (uInt)n;
		}
		continue;
	    }
	    /* fallthrough */
	case Z_NEED_DICT:
	case Z_DATA_ERROR:
	case Z_STREAM_ERROR:
	case Z_MEM_ERROR:
            zip_error_set(&ctx->error, ZIP_ER_ZLIB, ret);
	    end = 1;
	    break;
	}
    }

    if (ctx->zstr.avail_out < len)
	return (zip_int64_t)(len - ctx->zstr.avail_out);

    return (zip_error_code_zip(&ctx->error) == ZIP_ER_OK) ? 0 : -1;
}


static zip_int64_t
deflate_compress(zip_source_t *src, void *ud, void *data, zip_uint64_t len, zip_source_cmd_t cmd)
{
    struct deflate *ctx;
    int ret;

    ctx = (struct deflate *)ud;

    switch (cmd) {
    case ZIP_SOURCE_OPEN:
	ctx->zstr.zalloc = Z_NULL;
	ctx->zstr.zfree = Z_NULL;
	ctx->zstr.opaque = NULL;
	ctx->zstr.avail_in = 0;
	ctx->zstr.next_in = NULL;
	ctx->zstr.avail_out = 0;
	ctx->zstr.next_out = NULL;

	/* negative value to tell zlib not to write a header */
	if ((ret=deflateInit2(&ctx->zstr, Z_BEST_COMPRESSION, Z_DEFLATED, -MAX_WBITS, ctx->mem_level, Z_DEFAULT_STRATEGY)) != Z_OK) {
            zip_error_set(&ctx->error, ZIP_ER_ZLIB, ret);
	    return -1;
	}

	return 0;

    case ZIP_SOURCE_READ:
	return compress_read(src, ctx, data, len);

    case ZIP_SOURCE_CLOSE:
	deflateEnd(&ctx->zstr);
	return 0;

    case ZIP_SOURCE_STAT:
    	{
	    zip_stat_t *st;

	    st = (zip_stat_t *)data;

	    st->comp_method = ctx->is_stored ? ZIP_CM_STORE : ZIP_CM_DEFLATE;
	    st->valid |= ZIP_STAT_COMP_METHOD;
	    if (ctx->eof) {
		st->comp_size = ctx->size;
		st->valid |= ZIP_STAT_COMP_SIZE;
	    }
	    else
		st->valid &= ~ZIP_STAT_COMP_SIZE;
	}
	return 0;

    case ZIP_SOURCE_ERROR:
        return zip_error_to_data(&ctx->error, data, len);

    case ZIP_SOURCE_FREE:
	deflate_free(ctx);
	return 0;

    case ZIP_SOURCE_SUPPORTS:
        return ZIP_SOURCE_SUPPORTS_READABLE;
            
    default:
        zip_error_set(&ctx->error, ZIP_ER_INTERNAL, 0);
	return -1;
    }
}


static zip_int64_t
deflate_decompress(zip_source_t *src, void *ud, void *data,
		   zip_uint64_t len, zip_source_cmd_t cmd)
{
    struct deflate *ctx;
    zip_int64_t n;
    int ret;

    ctx = (struct deflate *)ud;

    switch (cmd) {
        case ZIP_SOURCE_OPEN:
            if ((n=zip_source_read(src, ctx->buffer, sizeof(ctx->buffer))) < 0) {
                _zip_error_set_from_source(&ctx->error, src);
                return -1;
            }

            ctx->zstr.zalloc = Z_NULL;
            ctx->zstr.zfree = Z_NULL;
            ctx->zstr.opaque = NULL;
            ctx->zstr.next_in = (Bytef *)ctx->buffer;
            ctx->zstr.avail_in = (uInt)n;

            /* negative value to tell zlib that there is no header */
            if ((ret=inflateInit2(&ctx->zstr, -MAX_WBITS)) != Z_OK) {
                zip_error_set(&ctx->error, ZIP_ER_ZLIB, ret);
                return -1;
            }
            return 0;

        case ZIP_SOURCE_READ:
            return decompress_read(src, ctx, data, len);

        case ZIP_SOURCE_CLOSE:
            inflateEnd(&ctx->zstr);
            return 0;

        case ZIP_SOURCE_STAT:
        {
            zip_stat_t *st;
            
            st = (zip_stat_t *)data;
            
            st->comp_method = ZIP_CM_STORE;
            if (st->comp_size > 0 && st->size > 0)
                st->comp_size = st->size;
            
            return 0;
        }

        case ZIP_SOURCE_ERROR:
            return zip_error_to_data(&ctx->error, data, len);

        case ZIP_SOURCE_FREE:
            free(ctx);
            return 0;
            
        case ZIP_SOURCE_SUPPORTS:
            return zip_source_make_command_bitmap(ZIP_SOURCE_OPEN, ZIP_SOURCE_READ, ZIP_SOURCE_CLOSE, ZIP_SOURCE_STAT, ZIP_SOURCE_ERROR, ZIP_SOURCE_FREE, -1);

        default:
            zip_error_set(&ctx->error, ZIP_ER_OPNOTSUPP, 0);
            return -1;
    }
}


static void
deflate_free(struct deflate *ctx)
{
    free(ctx);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_error.c`:

```c
/*
  zip_source_error.c -- get last error from zip_source
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


zip_error_t *
zip_source_error(zip_source_t *src)
{
    return &src->error;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_file.c`:

```c
/*
  zip_source_file.c -- create data source from file
  Copyright (C) 1999-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <errno.h>
#include <stdio.h>

#include "zipint.h"


ZIP_EXTERN zip_source_t *
zip_source_file(zip_t *za, const char *fname, zip_uint64_t start, zip_int64_t len)
{
    if (za == NULL)
	return NULL;
    
    return zip_source_file_create(fname, start, len, &za->error);
}


ZIP_EXTERN zip_source_t *
zip_source_file_create(const char *fname, zip_uint64_t start, zip_int64_t length, zip_error_t *error)
{
    if (fname == NULL || length < -1) {
	zip_error_set(error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    return _zip_source_file_or_p(fname, NULL, start, length, NULL, error);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_filep.c`:

```c
/*
  zip_source_filep.c -- create data source from FILE *
  Copyright (C) 1999-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"

#include <sys/stat.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
/* WIN32 needs <fcntl.h> for _O_BINARY */
#include <fcntl.h>
#endif

/* Windows sys/types.h does not provide these */
#ifndef S_ISREG
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif
#ifndef S_IRWXG
#define S_IRWXG (S_IRWXU >> 3)
#endif
#ifndef S_IRWXO
#define S_IRWXO (S_IRWXG >> 3)
#endif

#ifdef _MSC_VER
/* MSVC doesn't have mode_t */
typedef int mode_t;
#endif

struct read_file {
    zip_error_t error;      /* last error information */
    zip_int64_t supports;

    /* reading */
    char *fname;            /* name of file to read from */
    FILE *f;                /* file to read from */
    struct zip_stat st;     /* stat information passed in */
    zip_uint64_t start;     /* start offset of data to read */
    zip_uint64_t end;       /* end offset of data to read, 0 for up to EOF */
    zip_uint64_t current;   /* current offset */
    
    /* writing */
    char *tmpname;
    FILE *fout;
};

static zip_int64_t read_file(void *state, void *data, zip_uint64_t len, zip_source_cmd_t cmd);
static int create_temp_output(struct read_file *ctx);
static int _zip_fseek_u(FILE *f, zip_uint64_t offset, int whence, zip_error_t *error);
static int _zip_fseek(FILE *f, zip_int64_t offset, int whence, zip_error_t *error);


ZIP_EXTERN zip_source_t *
zip_source_filep(zip_t *za, FILE *file, zip_uint64_t start, zip_int64_t len)
{
    if (za == NULL)
	return NULL;
    
    return zip_source_filep_create(file, start, len, &za->error);
}


ZIP_EXTERN zip_source_t *
zip_source_filep_create(FILE *file, zip_uint64_t start, zip_int64_t length, zip_error_t *error)
{
    if (file == NULL || length < -1) {
	zip_error_set(error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    return _zip_source_file_or_p(NULL, file, start, length, NULL, error);
}


zip_source_t *
_zip_source_file_or_p(const char *fname, FILE *file, zip_uint64_t start, zip_int64_t len, const zip_stat_t *st, zip_error_t *error)
{
    struct read_file *ctx;
    zip_source_t *zs;
    
    if (file == NULL && fname == NULL) {
	zip_error_set(error, ZIP_ER_INVAL, 0);
	return NULL;
    }
    
    if ((ctx=(struct read_file *)malloc(sizeof(struct read_file))) == NULL) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    ctx->fname = NULL;
    if (fname) {
	if ((ctx->fname=strdup(fname)) == NULL) {
	    zip_error_set(error, ZIP_ER_MEMORY, 0);
	    free(ctx);
	    return NULL;
	}
    }
    ctx->f = file;
    ctx->start = start;
    ctx->end = (len < 0 ? 0 : start+(zip_uint64_t)len);
    if (st) {
	memcpy(&ctx->st, st, sizeof(ctx->st));
        ctx->st.name = NULL;
        ctx->st.valid &= ~ZIP_STAT_NAME;
    }
    else {
	zip_stat_init(&ctx->st);
    }
    
    ctx->tmpname = NULL;
    ctx->fout = NULL;
   
    zip_error_init(&ctx->error);

    ctx->supports = ZIP_SOURCE_SUPPORTS_READABLE | zip_source_make_command_bitmap(ZIP_SOURCE_SUPPORTS, ZIP_SOURCE_TELL, -1);
    if (ctx->fname) {
	struct stat sb;

	if (stat(ctx->fname, &sb) < 0 || S_ISREG(sb.st_mode)) {
            ctx->supports = ZIP_SOURCE_SUPPORTS_WRITABLE;
	}
    }
    else if (fseeko(ctx->f, 0, SEEK_CUR) == 0) {
        ctx->supports = ZIP_SOURCE_SUPPORTS_SEEKABLE;
    }

    if ((zs=zip_source_function_create(read_file, ctx, error)) == NULL) {
	free(ctx->fname);
	free(ctx);
	return NULL;
    }

    return zs;
}


static int
create_temp_output(struct read_file *ctx)
{
    char *temp;
    int tfd;
    mode_t mask;
    FILE *tfp;
    
    if ((temp=(char *)malloc(strlen(ctx->fname)+8)) == NULL) {
	zip_error_set(&ctx->error, ZIP_ER_MEMORY, 0);
	return -1;
    }
    sprintf(temp, "%s.XXXXXX", ctx->fname);

    mask = umask(S_IXUSR | S_IRWXG | S_IRWXO);
    if ((tfd=mkstemp(temp)) == -1) {
        zip_error_set(&ctx->error, ZIP_ER_TMPOPEN, errno);
	umask(mask);
        free(temp);
        return -1;
    }
    umask(mask);

    if ((tfp=fdopen(tfd, "r+b")) == NULL) {
        zip_error_set(&ctx->error, ZIP_ER_TMPOPEN, errno);
        close(tfd);
        (void)remove(temp);
        free(temp);
        return -1;
    }
    
#ifdef _WIN32
    /*
     According to Pierre Joye, Windows in some environments per
     default creates text files, so force binary mode.
     */
    _setmode(_fileno(tfp), _O_BINARY );
#endif
    
    ctx->fout = tfp;
    ctx->tmpname = temp;
    
    return 0;
}


static zip_int64_t
read_file(void *state, void *data, zip_uint64_t len, zip_source_cmd_t cmd)
{
    struct read_file *ctx;
    char *buf;
    zip_uint64_t n;
    size_t i;

    ctx = (struct read_file *)state;
    buf = (char *)data;

    switch (cmd) {
        case ZIP_SOURCE_BEGIN_WRITE:
            if (ctx->fname == NULL) {
                zip_error_set(&ctx->error, ZIP_ER_OPNOTSUPP, 0);
                return -1;
            }
            return create_temp_output(ctx);
            
        case ZIP_SOURCE_COMMIT_WRITE: {
	    mode_t mask;

            if (fclose(ctx->fout) < 0) {
                ctx->fout = NULL;
                zip_error_set(&ctx->error, ZIP_ER_WRITE, errno);
            }
            ctx->fout = NULL;
            if (rename(ctx->tmpname, ctx->fname) < 0) {
                zip_error_set(&ctx->error, ZIP_ER_RENAME, errno);
                return -1;
            }
	    mask = umask(022);
	    umask(mask);
	    /* not much we can do if chmod fails except make the whole commit fail */
	    (void)chmod(ctx->fname, 0666&~mask);
	    free(ctx->tmpname);
	    ctx->tmpname = NULL;
            return 0;
	}
            
        case ZIP_SOURCE_CLOSE:
            if (ctx->fname) {
                fclose(ctx->f);
                ctx->f = NULL;
            }
            return 0;
            
        case ZIP_SOURCE_ERROR:
            return zip_error_to_data(&ctx->error, data, len);
            
        case ZIP_SOURCE_FREE:
            free(ctx->fname);
	    free(ctx->tmpname);
            if (ctx->f)
                fclose(ctx->f);
            free(ctx);
            return 0;
            
        case ZIP_SOURCE_OPEN:
            if (ctx->fname) {
                if ((ctx->f=fopen(ctx->fname, "rb")) == NULL) {
                    zip_error_set(&ctx->error, ZIP_ER_OPEN, errno);
                    return -1;
                }
            }
            
            if (ctx->start > 0) {
                if (_zip_fseek_u(ctx->f, ctx->start, SEEK_SET, &ctx->error) < 0) {
                    return -1;
                }
            }
            ctx->current = ctx->start;
            return 0;
            
        case ZIP_SOURCE_READ:
            if (ctx->end > 0) {
                n = ctx->end-ctx->current;
                if (n > len) {
                    n = len;
                }
            }
            else {
                n = len;
            }
            
            if (n > SIZE_MAX)
                n = SIZE_MAX;

            if ((i=fread(buf, 1, (size_t)n, ctx->f)) == 0) {
                if (ferror(ctx->f)) {
                    zip_error_set(&ctx->error, ZIP_ER_READ, errno);
                    return -1;
                }
            }
            ctx->current += i;

            return (zip_int64_t)i;
            
        case ZIP_SOURCE_REMOVE:
            if (remove(ctx->fname) < 0) {
                zip_error_set(&ctx->error, ZIP_ER_REMOVE, errno);
                return -1;
            }
            return 0;
            
        case ZIP_SOURCE_ROLLBACK_WRITE:
            if (ctx->fout) {
                fclose(ctx->fout);
                ctx->fout = NULL;
            }
            (void)remove(ctx->tmpname);
	    free(ctx->tmpname);
            ctx->tmpname = NULL;
            return 0;
	
        case ZIP_SOURCE_SEEK: {
            zip_int64_t new_current;
            int need_seek;
	    zip_source_args_seek_t *args = ZIP_SOURCE_GET_ARGS(zip_source_args_seek_t, data, len, &ctx->error);

	    if (args == NULL)
		return -1;
            
            need_seek = 1;
            
            switch (args->whence) {
                case SEEK_SET:
                    new_current = args->offset;
                    break;
                    
                case SEEK_END:
                    if (ctx->end == 0) {
                        if (_zip_fseek(ctx->f, args->offset, SEEK_END, &ctx->error) < 0) {
                            return -1;
                        }
                        if ((new_current = ftello(ctx->f)) < 0) {
                            zip_error_set(&ctx->error, ZIP_ER_SEEK, errno);
                            return -1;
                        }
                        need_seek = 0;
                    }
                    else {
                        new_current = (zip_int64_t)ctx->end + args->offset;
                    }
                    break;
                case SEEK_CUR:
                    new_current = (zip_int64_t)ctx->current + args->offset;
                    break;

                default:
                    zip_error_set(&ctx->error, ZIP_ER_INVAL, 0);
                    return -1;
            }

            if (new_current < 0 || (zip_uint64_t)new_current < ctx->start || (ctx->end != 0 && (zip_uint64_t)new_current > ctx->end)) {
                zip_error_set(&ctx->error, ZIP_ER_INVAL, 0);
                return -1;
            }
            
            ctx->current = (zip_uint64_t)new_current;

            if (need_seek) {
                if (_zip_fseek_u(ctx->f, ctx->current, SEEK_SET, &ctx->error) < 0) {
                    return -1;
                }
            }
            return 0;
        }
            
        case ZIP_SOURCE_SEEK_WRITE: {
            zip_source_args_seek_t *args;
            
            args = ZIP_SOURCE_GET_ARGS(zip_source_args_seek_t, data, len, &ctx->error);
            if (args == NULL) {
                return -1;
            }
            
            if (_zip_fseek(ctx->fout, args->offset, args->whence, &ctx->error) < 0) {
                return -1;
            }
            return 0;
        }

        case ZIP_SOURCE_STAT: {
	    if (len < sizeof(ctx->st))
		return -1;

	    if (ctx->st.valid != 0)
		memcpy(data, &ctx->st, sizeof(ctx->st));
	    else {
		zip_stat_t *st;
		struct stat fst;
		int err;
	    
		if (ctx->f)
		    err = fstat(fileno(ctx->f), &fst);
		else
		    err = stat(ctx->fname, &fst);

		if (err != 0) {
                    zip_error_set(&ctx->error, ZIP_ER_READ, errno);
		    return -1;
		}

		st = (zip_stat_t *)data;
		
		zip_stat_init(st);
		st->mtime = fst.st_mtime;
		st->valid |= ZIP_STAT_MTIME;
		if (ctx->end != 0) {
                    st->size = ctx->end - ctx->start;
		    st->valid |= ZIP_STAT_SIZE;
		}
		else if ((fst.st_mode&S_IFMT) == S_IFREG) {
		    st->size = (zip_uint64_t)fst.st_size;
		    st->valid |= ZIP_STAT_SIZE;
		}
	    }
	    return sizeof(ctx->st);
	}

        case ZIP_SOURCE_SUPPORTS:
	    return ctx->supports;
            
        case ZIP_SOURCE_TELL:
            return (zip_int64_t)ctx->current;
            
        case ZIP_SOURCE_TELL_WRITE:
        {
            off_t ret = ftello(ctx->fout);
            
            if (ret < 0) {
                zip_error_set(&ctx->error, ZIP_ER_TELL, errno);
                return -1;
            }
            return ret;
        }
            
        case ZIP_SOURCE_WRITE:
        {
            size_t ret;
            
	    clearerr(ctx->fout);
            ret = fwrite(data, 1, len, ctx->fout);
            if (ret != len || ferror(ctx->fout)) {
                zip_error_set(&ctx->error, ZIP_ER_WRITE, errno);
                return -1;
            }
            
            return (zip_int64_t)ret;
        }

        default:
            zip_error_set(&ctx->error, ZIP_ER_OPNOTSUPP, 0);
            return -1;
    }
}


static int
_zip_fseek_u(FILE *f, zip_uint64_t offset, int whence, zip_error_t *error)
{
    if (offset > ZIP_INT64_MAX) {
	zip_error_set(error, ZIP_ER_SEEK, EOVERFLOW);
	return -1;
    }
    return _zip_fseek(f, (zip_int64_t)offset, whence, error);
}


static int
_zip_fseek(FILE *f, zip_int64_t offset, int whence, zip_error_t *error)
{
    if (offset > ZIP_FSEEK_MAX || offset < ZIP_FSEEK_MIN) {
	zip_error_set(error, ZIP_ER_SEEK, EOVERFLOW);
	return -1;
    }
    if (fseeko(f, (off_t)offset, whence) < 0) {
	zip_error_set(error, ZIP_ER_SEEK, errno);
	return -1;
    }
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_free.c`:

```c
/*
  zip_source_free.c -- free zip data source
  Copyright (C) 1999-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN void
zip_source_free(zip_source_t *src)
{
    if (src == NULL)
	return;

    if (src->refcount > 0) {
        src->refcount--;
    }
    if (src->refcount > 0) {
        return;
    }
    
    if (ZIP_SOURCE_IS_OPEN_READING(src)) {
	src->open_count = 1; /* force close */
	zip_source_close(src);
    }
    if (ZIP_SOURCE_IS_OPEN_WRITING(src)) {
        zip_source_rollback_write(src);
    }
    
    if (src->source_archive && !src->source_closed) {
        _zip_deregister_source(src->source_archive, src);
    }
    
    (void)_zip_source_call(src, NULL, 0, ZIP_SOURCE_FREE);
    
    if (src->src) {
        zip_source_free(src->src);
    }

    free(src);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_function.c`:

```c
/*
  zip_source_function.c -- create zip data source from callback function
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN zip_source_t *
zip_source_function(zip_t *za, zip_source_callback zcb, void *ud)
{
    if (za == NULL) {
        return NULL;
    }
    
    return zip_source_function_create(zcb, ud, &za->error);
}


ZIP_EXTERN zip_source_t *
zip_source_function_create(zip_source_callback zcb, void *ud, zip_error_t *error)
{
    zip_source_t *zs;

    if ((zs=_zip_source_new(error)) == NULL)
	return NULL;

    zs->cb.f = zcb;
    zs->ud = ud;
    
    zs->supports = zcb(ud, NULL, 0, ZIP_SOURCE_SUPPORTS);
    if (zs->supports < 0) {
        zs->supports = ZIP_SOURCE_SUPPORTS_READABLE;
    }
    
    return zs;
}


ZIP_EXTERN void
zip_source_keep(zip_source_t *src)
{
    src->refcount++;
}


zip_source_t *
_zip_source_new(zip_error_t *error)
{
    zip_source_t *src;

    if ((src=(zip_source_t *)malloc(sizeof(*src))) == NULL) {
        zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    src->src = NULL;
    src->cb.f = NULL;
    src->ud = NULL;
    src->open_count = 0;
    src->write_state = ZIP_SOURCE_WRITE_CLOSED;
    src->source_closed = false;
    src->source_archive = NULL;
    src->refcount = 1;
    zip_error_init(&src->error);

    return src;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_is_deleted.c`:

```c
/*
  zip_source_is_deleted.c -- was archive was removed?
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_source_is_deleted(zip_source_t *src)
{
    return src->write_state == ZIP_SOURCE_WRITE_REMOVED;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_layered.c`:

```c
/*
  zip_source_layered.c -- create layered source
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


zip_source_t *
zip_source_layered(zip_t *za, zip_source_t *src, zip_source_layered_callback cb, void *ud)
{
    if (za == NULL)
        return NULL;

    return zip_source_layered_create(src, cb, ud, &za->error);
}


zip_source_t *
zip_source_layered_create(zip_source_t *src, zip_source_layered_callback cb, void *ud, zip_error_t *error)
{
    zip_source_t *zs;
    
    if ((zs=_zip_source_new(error)) == NULL)
        return NULL;
    
    zip_source_keep(src);
    zs->src = src;
    zs->cb.l = cb;
    zs->ud = ud;

    zs->supports = cb(src, ud, NULL, 0, ZIP_SOURCE_SUPPORTS);
    if (zs->supports < 0) {
        zs->supports = ZIP_SOURCE_SUPPORTS_READABLE;
    }

    return zs;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_open.c`:

```c
/*
  zip_source_open.c -- open zip_source (prepare for reading)
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"

ZIP_EXTERN int
zip_source_open(zip_source_t *src)
{
    if (src->source_closed) {
        return -1;
    }
    if (src->write_state == ZIP_SOURCE_WRITE_REMOVED) {
        zip_error_set(&src->error, ZIP_ER_DELETED, 0);
	return -1;
    }

    if (ZIP_SOURCE_IS_OPEN_READING(src)) {
	if ((zip_source_supports(src) & ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_SEEK)) == 0) {
	    zip_error_set(&src->error, ZIP_ER_INUSE, 0);
	    return -1;
	}
    }
    else {
	if (ZIP_SOURCE_IS_LAYERED(src)) {
	    if (zip_source_open(src->src) < 0) {
		_zip_error_set_from_source(&src->error, src->src);
		return -1;
	    }
	}
	
	if (_zip_source_call(src, NULL, 0, ZIP_SOURCE_OPEN) < 0) {
	    if (ZIP_SOURCE_IS_LAYERED(src)) {
		zip_source_close(src->src);
	    }
	    return -1;
	}
    }

    src->open_count++;
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_pkware.c`:

```c
/*
  zip_source_pkware.c -- Traditional PKWARE de/encryption routines
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>
#include <string.h>

#include "zipint.h"

struct trad_pkware {
    zip_error_t error;
    zip_uint32_t key[3];
};

#define HEADERLEN	12
#define KEY0		305419896
#define KEY1		591751049
#define KEY2		878082192


static void decrypt(struct trad_pkware *, zip_uint8_t *,
		    const zip_uint8_t *, zip_uint64_t, int);
static int decrypt_header(zip_source_t *, struct trad_pkware *);
static zip_int64_t pkware_decrypt(zip_source_t *, void *, void *,
				  zip_uint64_t, zip_source_cmd_t);
static void pkware_free(struct trad_pkware *);


zip_source_t *
zip_source_pkware(zip_t *za, zip_source_t *src,
		  zip_uint16_t em, int flags, const char *password)
{
    struct trad_pkware *ctx;
    zip_source_t *s2;

    if (password == NULL || src == NULL || em != ZIP_EM_TRAD_PKWARE) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return NULL;
    }
    if (flags & ZIP_CODEC_ENCODE) {
	zip_error_set(&za->error, ZIP_ER_ENCRNOTSUPP, 0);
	return NULL;
    }

    if ((ctx=(struct trad_pkware *)malloc(sizeof(*ctx))) == NULL) {
	zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    zip_error_init(&ctx->error);

    ctx->key[0] = KEY0;
    ctx->key[1] = KEY1;
    ctx->key[2] = KEY2;
    decrypt(ctx, NULL, (const zip_uint8_t *)password, strlen(password), 1);

    if ((s2=zip_source_layered(za, src, pkware_decrypt, ctx)) == NULL) {
	pkware_free(ctx);
	return NULL;
    }

    return s2;
}


static void
decrypt(struct trad_pkware *ctx, zip_uint8_t *out, const zip_uint8_t *in,
	zip_uint64_t len, int update_only)
{
    zip_uint16_t tmp;
    zip_uint64_t i;
    Bytef b;

    for (i=0; i<len; i++) {
	b = in[i];

	if (!update_only) {
	    /* decrypt next byte */
	    tmp = (zip_uint16_t)(ctx->key[2] | 2);
	    tmp = (zip_uint16_t)((tmp * (tmp ^ 1)) >> 8);
	    b ^= (Bytef)tmp;
	}

	/* store cleartext */
	if (out)
	    out[i] = b;

	/* update keys */
	ctx->key[0] = (zip_uint32_t)crc32(ctx->key[0] ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL;
	ctx->key[1] = (ctx->key[1] + (ctx->key[0] & 0xff)) * 134775813 + 1;
	b = (Bytef)(ctx->key[1] >> 24);
	ctx->key[2] = (zip_uint32_t)crc32(ctx->key[2] ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL;
    }
}


static int
decrypt_header(zip_source_t *src, struct trad_pkware *ctx)
{
    zip_uint8_t header[HEADERLEN];
    struct zip_stat st;
    zip_int64_t n;
    unsigned short dostime, dosdate;

    if ((n=zip_source_read(src, header, HEADERLEN)) < 0) {
        _zip_error_set_from_source(&ctx->error, src);
	return -1;
    }
    
    if (n != HEADERLEN) {
        zip_error_set(&ctx->error, ZIP_ER_EOF, 0);
	return -1;
    }

    decrypt(ctx, header, header, HEADERLEN, 0);

    if (zip_source_stat(src, &st) < 0) {
	/* stat failed, skip password validation */
	return 0;
    }

    _zip_u2d_time(st.mtime, &dostime, &dosdate);

    if (header[HEADERLEN-1] != st.crc>>24 && header[HEADERLEN-1] != dostime>>8) {
        zip_error_set(&ctx->error, ZIP_ER_WRONGPASSWD, 0);
	return -1;
    }

    return 0;
}


static zip_int64_t
pkware_decrypt(zip_source_t *src, void *ud, void *data,
	       zip_uint64_t len, zip_source_cmd_t cmd)
{
    struct trad_pkware *ctx;
    zip_int64_t n;

    ctx = (struct trad_pkware *)ud;

    switch (cmd) {
        case ZIP_SOURCE_OPEN:
            if (decrypt_header(src, ctx) < 0)
                return -1;
            return 0;

        case ZIP_SOURCE_READ:
            if ((n=zip_source_read(src, data, len)) < 0) {
                _zip_error_set_from_source(&ctx->error, src);
                return -1;
            }

            decrypt((struct trad_pkware *)ud, (zip_uint8_t *)data, (zip_uint8_t *)data, (zip_uint64_t)n, 0);
            return n;

        case ZIP_SOURCE_CLOSE:
            return 0;

        case ZIP_SOURCE_STAT:
        {
	    zip_stat_t *st;

	    st = (zip_stat_t *)data;

	    st->encryption_method = ZIP_EM_NONE;
	    st->valid |= ZIP_STAT_ENCRYPTION_METHOD;
	    /* TODO: deduce HEADERLEN from size for uncompressed */
	    if (st->valid & ZIP_STAT_COMP_SIZE)
		st->comp_size -= HEADERLEN;
	
            return 0;
        }
            
        case ZIP_SOURCE_SUPPORTS:
            return zip_source_make_command_bitmap(ZIP_SOURCE_OPEN, ZIP_SOURCE_READ, ZIP_SOURCE_CLOSE, ZIP_SOURCE_STAT, ZIP_SOURCE_ERROR, ZIP_SOURCE_FREE, -1);

        case ZIP_SOURCE_ERROR:
            return zip_error_to_data(&ctx->error, data, len);

        case ZIP_SOURCE_FREE:
            pkware_free(ctx);
            return 0;

        default:
            zip_error_set(&ctx->error, ZIP_ER_INVAL, 0);
            return -1;
    }
}


static void
pkware_free(struct trad_pkware *ctx)
{
    free(ctx);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_read.c`:

```c
/*
  zip_source_read.c -- read data from zip_source
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


zip_int64_t
zip_source_read(zip_source_t *src, void *data, zip_uint64_t len)
{
    if (src->source_closed) {
        return -1;
    }
    if (!ZIP_SOURCE_IS_OPEN_READING(src) || len > ZIP_INT64_MAX || (len > 0 && data == NULL)) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    return _zip_source_call(src, data, len, ZIP_SOURCE_READ);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_remove.c`:

```c
/*
 zip_source_remove.c -- remove empty archive
 Copyright (C) 2014 Dieter Baron and Thomas Klausner
 
 This file is part of libzip, a library to manipulate ZIP archives.
 The authors can be contacted at <libzip@nih.at>
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the
 distribution.
 3. The names of the authors may not be used to endorse or promote
 products derived from this software without specific prior
 written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include "zipint.h"


int
zip_source_remove(zip_source_t *src)
{
    if (src->write_state == ZIP_SOURCE_WRITE_REMOVED) {
        return 0;
    }
    
    if (ZIP_SOURCE_IS_OPEN_READING(src)) {
	if (zip_source_close(src) < 0) {
	    return -1;
	}
    }
    if (src->write_state != ZIP_SOURCE_WRITE_CLOSED) {
        zip_source_rollback_write(src);
    }
    
    if (_zip_source_call(src, NULL, 0, ZIP_SOURCE_REMOVE) < 0) {
        return -1;
    }
    
    src->write_state = ZIP_SOURCE_WRITE_REMOVED;
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_rollback_write.c`:

```c
/*
  zip_source_rollback_write.c -- discard changes
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN void
zip_source_rollback_write(zip_source_t *src)
{
    if (src->write_state != ZIP_SOURCE_WRITE_OPEN && src->write_state != ZIP_SOURCE_WRITE_FAILED) {
	return;
    }
    
    _zip_source_call(src, NULL, 0, ZIP_SOURCE_ROLLBACK_WRITE);
    src->write_state = ZIP_SOURCE_WRITE_CLOSED;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_seek.c`:

```c
/*
  zip_source_seek.c -- seek to offset
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_source_seek(zip_source_t *src, zip_int64_t offset, int whence)
{
    zip_source_args_seek_t args;
    
    if (src->source_closed) {
        return -1;
    }
    if (!ZIP_SOURCE_IS_OPEN_READING(src) || (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
        return -1;
    }

    args.offset = offset;
    args.whence = whence;
    
    return (_zip_source_call(src, &args, sizeof(args), ZIP_SOURCE_SEEK) < 0 ? -1 : 0);
}


zip_int64_t
zip_source_seek_compute_offset(zip_uint64_t offset, zip_uint64_t length, void *data, zip_uint64_t data_length, zip_error_t *error)
{
    zip_int64_t new_offset;
    zip_source_args_seek_t *args = ZIP_SOURCE_GET_ARGS(zip_source_args_seek_t, data, data_length, error);
    
    if (args == NULL) {
        return -1;
    }
    
    switch (args->whence) {
        case SEEK_CUR:
            new_offset = (zip_int64_t)offset + args->offset;
            break;
            
        case SEEK_END:
            new_offset = (zip_int64_t)length + args->offset;
            break;
            
        case SEEK_SET:
            new_offset = args->offset;
            break;
            
        default:
            zip_error_set(error, ZIP_ER_INVAL, 0);
            return -1;
    }
    
    if (new_offset < 0 || (zip_uint64_t)new_offset > length) {
        zip_error_set(error, ZIP_ER_INVAL, 0);
        return -1;
    }
    
    return new_offset;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_seek_write.c`:

```c
/*
  zip_source_seek_write.c -- seek to offset for writing
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_source_seek_write(zip_source_t *src, zip_int64_t offset, int whence)
{
    zip_source_args_seek_t args;
        
    if (!ZIP_SOURCE_IS_OPEN_WRITING(src) || (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
        return -1;
    }
    
    args.offset = offset;
    args.whence = whence;
    
    return (_zip_source_call(src, &args, sizeof(args), ZIP_SOURCE_SEEK_WRITE) < 0 ? -1 : 0);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_stat.c`:

```c
/*
  zip_source_stat.c -- get meta information from zip_source
  Copyright (C) 2009-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


int
zip_source_stat(zip_source_t *src, zip_stat_t *st)
{
    if (src->source_closed) {
        return -1;
    }
    if (st == NULL) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    zip_stat_init(st);
    
    if (ZIP_SOURCE_IS_LAYERED(src)) {
        if (zip_source_stat(src->src, st) < 0) {
            _zip_error_set_from_source(&src->error, src->src);
            return -1;
        }
    }

    if (_zip_source_call(src, st, sizeof(*st), ZIP_SOURCE_STAT) < 0) {
	return -1;
    }

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_supports.c`:

```c
/*
  zip_source_supports.c -- check for supported functions
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdarg.h>

#include "zipint.h"


zip_int64_t
zip_source_supports(zip_source_t *src)
{
    return src->supports;
}


zip_int64_t
zip_source_make_command_bitmap(zip_source_cmd_t cmd0, ...)
{
    zip_int64_t bitmap;
    va_list ap;
    
    bitmap = ZIP_SOURCE_MAKE_COMMAND_BITMASK(cmd0);
    
    
    
    va_start(ap, cmd0);
    for (;;) {
        int cmd = va_arg(ap, int);
        if (cmd < 0) {
            break;
        }
        bitmap |= ZIP_SOURCE_MAKE_COMMAND_BITMASK(cmd);
    }
    va_end(ap);
    
    return bitmap;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_tell.c`:

```c
/*
  zip_source_tell.c -- report current offset
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN zip_int64_t
zip_source_tell(zip_source_t *src)
{
    if (src->source_closed) {
        return -1;
    }
    if (!ZIP_SOURCE_IS_OPEN_READING(src)) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
        return -1;
    }
    
    return _zip_source_call(src, NULL, 0, ZIP_SOURCE_TELL);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_tell_write.c`:

```c
/*
  zip_source_tell_write.c -- report current offset for writing
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN zip_int64_t
zip_source_tell_write(zip_source_t *src)
{
    if (!ZIP_SOURCE_IS_OPEN_WRITING(src)) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
        return -1;
    }
    
    return _zip_source_call(src, NULL, 0, ZIP_SOURCE_TELL_WRITE);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_window.c`:

```c
/*
  zip_source_window.c -- return part of lower source
  Copyright (C) 2012-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>
#include <string.h>

#include "zipint.h"

struct window {
    zip_uint64_t start;
    zip_uint64_t end;
    zip_uint64_t offset;
    zip_stat_t stat;
    zip_error_t error;
    zip_int64_t supports;
    bool needs_seek;
};

static zip_int64_t window_read(zip_source_t *, void *, void *, zip_uint64_t, zip_source_cmd_t);


zip_source_t *
zip_source_window(zip_t *za, zip_source_t *src, zip_uint64_t start, zip_uint64_t len)
{
    return _zip_source_window_new(src, start, len, NULL, &za->error);
}


zip_source_t *
_zip_source_window_new(zip_source_t *src, zip_uint64_t start, zip_uint64_t length, zip_stat_t *st, zip_error_t *error)
{
    struct window *ctx;
    
    if (src == NULL || start + length < start) {
        zip_error_set(error, ZIP_ER_INVAL, 0);
        return NULL;
    }
    
    if ((ctx=(struct window *)malloc(sizeof(*ctx))) == NULL) {
        zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
    }
    
    ctx->start = start;
    ctx->end = start + length;
    zip_stat_init(&ctx->stat);
    zip_error_init(&ctx->error);
    ctx->supports = (zip_source_supports(src) & ZIP_SOURCE_SUPPORTS_SEEKABLE) | (zip_source_make_command_bitmap(ZIP_SOURCE_SUPPORTS, ZIP_SOURCE_TELL, -1));
    ctx->needs_seek = (ctx->supports & ZIP_SOURCE_MAKE_COMMAND_BITMASK(ZIP_SOURCE_SEEK)) ? true : false;
    
    if (st) {
        if (_zip_stat_merge(&ctx->stat, st, error) < 0) {
            free(ctx);
            return NULL;
        }
    }
    
    return zip_source_layered_create(src, window_read, ctx, error);
}


int
_zip_source_set_source_archive(zip_source_t *src, zip_t *za)
{
    src->source_archive = za;
    return _zip_register_source(za, src);
}


/* called by zip_discard to avoid operating on file from closed archive */
void
_zip_source_invalidate(zip_source_t *src)
{
    src->source_closed = 1;

    if (zip_error_code_zip(&src->error) == ZIP_ER_OK) {
        zip_error_set(&src->error, ZIP_ER_ZIPCLOSED, 0);
    }
}


static zip_int64_t
window_read(zip_source_t *src, void *_ctx, void *data, zip_uint64_t len, zip_source_cmd_t cmd)
{
    struct window *ctx;
    zip_int64_t ret;
    zip_uint64_t n, i;
    char b[8192];

    ctx = (struct window *)_ctx;

    switch (cmd) {
        case ZIP_SOURCE_CLOSE:
            return 0;
            
        case ZIP_SOURCE_ERROR:
            return zip_error_to_data(&ctx->error, data, len);
            
        case ZIP_SOURCE_FREE:
            free(ctx);
            return 0;

        case ZIP_SOURCE_OPEN:
            if (!ctx->needs_seek) {
                for (n=0; n<ctx->start; n+=(zip_uint64_t)ret) {
                    i = (ctx->start-n > sizeof(b) ? sizeof(b) : ctx->start-n);
                    if ((ret=zip_source_read(src, b, i)) < 0) {
                        _zip_error_set_from_source(&ctx->error, src);
                        return -1;
                    }
                    if (ret==0) {
                        zip_error_set(&ctx->error, ZIP_ER_EOF, 0);
                        return -1;
                    }
                }
		
            }
	    ctx->offset = ctx->start;
            return 0;

        case ZIP_SOURCE_READ:
            if (len > ctx->end - ctx->offset)
                len = ctx->end - ctx->offset;
            
            if (len == 0)
                return 0;
            
            if (ctx->needs_seek) {
                if (zip_source_seek(src, (zip_int64_t)ctx->offset, SEEK_SET) < 0) {
                    _zip_error_set_from_source(&ctx->error, src);
                    return -1;
                }
            }
            
            if ((ret=zip_source_read(src, data, len)) < 0) {
                zip_error_set(&ctx->error, ZIP_ER_EOF, 0);
                return -1;
            }

            ctx->offset += (zip_uint64_t)ret;

            if (ret == 0) {
                if (ctx->offset < ctx->end) {
                    zip_error_set(&ctx->error, ZIP_ER_EOF, 0);
                    return -1;
                }
            }
            return ret;
            
        case ZIP_SOURCE_SEEK:
        {
            zip_int64_t new_offset = zip_source_seek_compute_offset(ctx->offset - ctx->start, ctx->end - ctx->start, data, len, &ctx->error);

            if (new_offset < 0) {
                return -1;
            }
            
            ctx->offset = (zip_uint64_t)new_offset + ctx->start;
            return 0;
        }

       case ZIP_SOURCE_STAT:
        {
            zip_stat_t *st;
            
	    st = (zip_stat_t *)data;
            
            if (_zip_stat_merge(st, &ctx->stat, &ctx->error) < 0) {
                return -1;
            }
            return 0;
        }
            
        case ZIP_SOURCE_SUPPORTS:
            return ctx->supports;
            
        case ZIP_SOURCE_TELL:
            return (zip_int64_t)(ctx->offset - ctx->start);
            
       default:
            zip_error_set(&ctx->error, ZIP_ER_OPNOTSUPP, 0);
            return -1;
    }
}


void
_zip_deregister_source(zip_t *za, zip_source_t *src)
{
    unsigned int i;
    
    for (i=0; i<za->nopen_source; i++) {
        if (za->open_source[i] == src) {
            za->open_source[i] = za->open_source[za->nopen_source-1];
            za->nopen_source--;
            break;
        }
    }
}


int
_zip_register_source(zip_t *za, zip_source_t *src)
{
    zip_source_t **open_source;
    
    if (za->nopen_source+1 >= za->nopen_source_alloc) {
        unsigned int n;
        n = za->nopen_source_alloc + 10;
        open_source = (zip_source_t **)realloc(za->open_source, n*sizeof(zip_source_t *));
        if (open_source == NULL) {
            zip_error_set(&za->error, ZIP_ER_MEMORY, 0);
            return -1;
        }
        za->nopen_source_alloc = n;
        za->open_source = open_source;
    }
    
    za->open_source[za->nopen_source++] = src;
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_write.c`:

```c
/*
  zip_source_write.c -- start a new file for writing
  Copyright (C) 2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN zip_int64_t
zip_source_write(zip_source_t *src, const void *data, zip_uint64_t length)
{
    if (!ZIP_SOURCE_IS_OPEN_WRITING(src) || length > ZIP_INT64_MAX) {
        zip_error_set(&src->error, ZIP_ER_INVAL, 0);
        return -1;
    }
    
    return _zip_source_call(src, (void *)data, length, ZIP_SOURCE_WRITE);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_zip.c`:

```c
/*
  zip_source_zip.c -- create data source from zip file
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>
#include <string.h>

#include "zipint.h"


ZIP_EXTERN zip_source_t *
zip_source_zip(zip_t *za, zip_t *srcza, zip_uint64_t srcidx,
	       zip_flags_t flags, zip_uint64_t start, zip_int64_t len)
{
    if (len < -1) {
        zip_error_set(&za->error, ZIP_ER_INVAL, 0);
        return NULL;
    }
        
    if (len == -1)
	len = 0;
    
    if (start == 0 && len == 0)
	flags |= ZIP_FL_COMPRESSED;
    else
	flags &= ~ZIP_FL_COMPRESSED;

    return _zip_source_zip_new(za, srcza, srcidx, flags, start, (zip_uint64_t)len, NULL);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_source_zip_new.c`:

```c
/*
  zip_source_zip_new.c -- prepare data structures for zip_fopen/zip_source_zip
  Copyright (C) 2012-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


zip_source_t *
_zip_source_zip_new(zip_t *za, zip_t *srcza, zip_uint64_t srcidx, zip_flags_t flags, zip_uint64_t start, zip_uint64_t len, const char *password)
{
    zip_compression_implementation comp_impl;
    zip_encryption_implementation enc_impl;
    zip_source_t *src, *s2;
    zip_uint64_t offset;
    struct zip_stat st;

    if (za == NULL)
	return NULL;

    if (srcza == NULL || srcidx >= srcza->nentry) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    if ((flags & ZIP_FL_UNCHANGED) == 0
	&& (ZIP_ENTRY_DATA_CHANGED(srcza->entry+srcidx) || srcza->entry[srcidx].deleted)) {
	zip_error_set(&za->error, ZIP_ER_CHANGED, 0);
	return NULL;
    }

    if (zip_stat_index(srcza, srcidx, flags|ZIP_FL_UNCHANGED, &st) < 0) {
	zip_error_set(&za->error, ZIP_ER_INTERNAL, 0);
	return NULL;
    }

    if (flags & ZIP_FL_ENCRYPTED)
	flags |= ZIP_FL_COMPRESSED;

    if ((start > 0 || len > 0) && (flags & ZIP_FL_COMPRESSED)) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    /* overflow or past end of file */
    if ((start > 0 || len > 0) && (start+len < start || start+len > st.size)) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return NULL;
    }

    enc_impl = NULL;
    if (((flags & ZIP_FL_ENCRYPTED) == 0) && (st.encryption_method != ZIP_EM_NONE)) {
	if (password == NULL) {
	    zip_error_set(&za->error, ZIP_ER_NOPASSWD, 0);
	    return NULL;
	}
	if ((enc_impl=_zip_get_encryption_implementation(st.encryption_method)) == NULL) {
	    zip_error_set(&za->error, ZIP_ER_ENCRNOTSUPP, 0);
	    return NULL;
	}
    }

    comp_impl = NULL;
    if ((flags & ZIP_FL_COMPRESSED) == 0) {
	if (st.comp_method != ZIP_CM_STORE) {
	    if ((comp_impl=_zip_get_compression_implementation(st.comp_method)) == NULL) {
		zip_error_set(&za->error, ZIP_ER_COMPNOTSUPP, 0);
		return NULL;
	    }
	}
    }

    if ((offset=_zip_file_get_offset(srcza, srcidx, &za->error)) == 0)
	return NULL;

    if (st.comp_size == 0) {
	return zip_source_buffer(za, NULL, 0, 0);
    }

    if (start+len > 0 && enc_impl == NULL && comp_impl == NULL) {
	struct zip_stat st2;
	
	st2.size = len ? len : st.size-start;
	st2.comp_size = st2.size;
	st2.comp_method = ZIP_CM_STORE;
	st2.mtime = st.mtime;
	st2.valid = ZIP_STAT_SIZE|ZIP_STAT_COMP_SIZE|ZIP_STAT_COMP_METHOD|ZIP_STAT_MTIME;
	
	if ((src = _zip_source_window_new(srcza->src, offset+start, st2.size, &st2, &za->error)) == NULL) {
	    return NULL;
	}
    }
    else {
	if ((src = _zip_source_window_new(srcza->src, offset, st.comp_size, &st, &za->error)) == NULL) {
	    return NULL;
	}
    }
	
    if (_zip_source_set_source_archive(src, srcza) < 0) {
	zip_source_free(src);
	return NULL;
    }

    /* creating a layered source calls zip_keep() on the lower layer, so we free it */
	
    if (enc_impl) {
	s2 = enc_impl(za, src, st.encryption_method, 0, password);
	zip_source_free(src);
	if (s2 == NULL) {
	    return NULL;
	}
	src = s2;
    }
    if (comp_impl) {
	s2 = comp_impl(za, src, st.comp_method, 0);
	zip_source_free(src);
	if (s2 == NULL) {
	    return NULL;
	}
	src = s2;
    }
    if (((flags & ZIP_FL_COMPRESSED) == 0 || st.comp_method == ZIP_CM_STORE) && (len == 0 || len == st.comp_size)) {
	/* when reading the whole file, check for CRC errors */
	s2 = zip_source_crc(za, src, 1);
	zip_source_free(src);
	if (s2 == NULL) {
	    return NULL;
	}
	src = s2;
    }

    if (start+len > 0 && (comp_impl || enc_impl)) {
	s2 = zip_source_window(za, src, start, len ? len : st.size-start);
	zip_source_free(src);
	if (s2 == NULL) {
	    return NULL;
	}
	src = s2;
    }

    return src;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_stat.c`:

```c
/*
  zip_stat.c -- get information about file by name
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_stat(zip_t *za, const char *fname, zip_flags_t flags, zip_stat_t *st)
{
    zip_int64_t idx;

    if ((idx=zip_name_locate(za, fname, flags)) < 0)
	return -1;

    return zip_stat_index(za, (zip_uint64_t)idx, flags, st);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_stat_index.c`:

```c
/*
  zip_stat_index.c -- get information about file by index
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN int
zip_stat_index(zip_t *za, zip_uint64_t index, zip_flags_t flags,
	       zip_stat_t *st)
{
    const char *name;
    zip_dirent_t *de;

    if ((de=_zip_get_dirent(za, index, flags, NULL)) == NULL)
	return -1;

    if ((name=zip_get_name(za, index, flags)) == NULL)
	return -1;
    

    if ((flags & ZIP_FL_UNCHANGED) == 0
	&& ZIP_ENTRY_DATA_CHANGED(za->entry+index)) {
	if (zip_source_stat(za->entry[index].source, st) < 0) {
	    zip_error_set(&za->error, ZIP_ER_CHANGED, 0);
	    return -1;
	}
    }
    else {
	zip_stat_init(st);

	st->crc = de->crc;
	st->size = de->uncomp_size;
	st->mtime = de->last_mod;
	st->comp_size = de->comp_size;
	st->comp_method = (zip_uint16_t)de->comp_method;
	if (de->bitflags & ZIP_GPBF_ENCRYPTED) {
	    if (de->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {
		/* TODO */
		st->encryption_method = ZIP_EM_UNKNOWN;
	    }
	    else
		st->encryption_method = ZIP_EM_TRAD_PKWARE;
	}
	else
	    st->encryption_method = ZIP_EM_NONE;
	st->valid = ZIP_STAT_CRC|ZIP_STAT_SIZE|ZIP_STAT_MTIME
	    |ZIP_STAT_COMP_SIZE|ZIP_STAT_COMP_METHOD|ZIP_STAT_ENCRYPTION_METHOD;
    }

    st->index = index;
    st->name = name;
    st->valid |= ZIP_STAT_INDEX|ZIP_STAT_NAME;
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_stat_init.c`:

```c
/*
  zip_stat_init.c -- initialize struct zip_stat.
  Copyright (C) 2006-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <string.h>

#include "zipint.h"


ZIP_EXTERN void
zip_stat_init(zip_stat_t *st)
{
    st->valid = 0;
    st->name = NULL;
    st->index = ZIP_UINT64_MAX;
    st->crc = 0;
    st->mtime = (time_t)-1;
    st->size = 0;
    st->comp_size = 0;
    st->comp_method = ZIP_CM_STORE;
    st->encryption_method = ZIP_EM_NONE;
}


int
_zip_stat_merge(zip_stat_t *dst, const zip_stat_t *src, zip_error_t *error)
{
    /* name is not merged, since zip_stat_t doesn't own it, and src may not be valid as long as dst */
    if (src->valid & ZIP_STAT_INDEX) {
        dst->index = src->index;
    }
    if (src->valid & ZIP_STAT_SIZE) {
        dst->size = src->size;
    }
    if (src->valid & ZIP_STAT_COMP_SIZE) {
        dst->comp_size = src->comp_size;
    }
    if (src->valid & ZIP_STAT_MTIME) {
        dst->mtime = src->mtime;
    }
    if (src->valid & ZIP_STAT_CRC) {
        dst->crc = src->crc;
    }
    if (src->valid & ZIP_STAT_COMP_METHOD) {
        dst->comp_method = src->comp_method;
    }
    if (src->valid & ZIP_STAT_ENCRYPTION_METHOD) {
        dst->encryption_method = src->encryption_method;
    }
    if (src->valid & ZIP_STAT_FLAGS) {
        dst->flags = src->flags;
    }
    dst->valid |= src->valid;
    
    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_strerror.c`:

```c
/*
  zip_sterror.c -- get string representation of zip error
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"


ZIP_EXTERN const char *
zip_strerror(zip_t *za)
{
    return zip_error_strerror(&za->error);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_string.c`:

```c
/*
  zip_string.c -- string handling (with encoding)
  Copyright (C) 2012-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>
#include <string.h>

#include "zipint.h"


zip_uint32_t
_zip_string_crc32(const zip_string_t *s)
{
    zip_uint32_t crc;
    
    crc = (zip_uint32_t)crc32(0L, Z_NULL, 0);

    if (s != NULL)    
	crc = (zip_uint32_t)crc32(crc, s->raw, s->length);

    return crc;
}


int
_zip_string_equal(const zip_string_t *a, const zip_string_t *b)
{
    if (a == NULL || b == NULL)
	return a == b;

    if (a->length != b->length)
	return 0;

    /* TODO: encoding */

    return (memcmp(a->raw, b->raw, a->length) == 0);
}


void
_zip_string_free(zip_string_t *s)
{
    if (s == NULL)
	return;

    free(s->raw);
    free(s->converted);
    free(s);
}


const zip_uint8_t *
_zip_string_get(zip_string_t *string, zip_uint32_t *lenp, zip_flags_t flags, zip_error_t *error)
{
    static const zip_uint8_t empty[1] = "";

    if (string == NULL) {
	if (lenp)
	    *lenp = 0;
	return empty;
    }

    if ((flags & ZIP_FL_ENC_RAW) == 0) {
	/* start guessing */
	if (string->encoding == ZIP_ENCODING_UNKNOWN)
	    _zip_guess_encoding(string, ZIP_ENCODING_UNKNOWN);

	if (((flags & ZIP_FL_ENC_STRICT)
	     && string->encoding != ZIP_ENCODING_ASCII && string->encoding != ZIP_ENCODING_UTF8_KNOWN)
	    || (string->encoding == ZIP_ENCODING_CP437)) {
	    if (string->converted == NULL) {
		if ((string->converted=_zip_cp437_to_utf8(string->raw, string->length,
							  &string->converted_length, error)) == NULL)
		    return NULL;
	    }
	    if (lenp)
		*lenp = string->converted_length;
	    return string->converted;
	}
    }
    
    if (lenp)
	*lenp = string->length;
    return string->raw;
}


zip_uint16_t
_zip_string_length(const zip_string_t *s)
{
    if (s == NULL)
	return 0;

    return s->length;
}


zip_string_t *
_zip_string_new(const zip_uint8_t *raw, zip_uint16_t length, zip_flags_t flags, zip_error_t *error)
{
    zip_string_t *s;
    zip_encoding_type_t expected_encoding;
    
    if (length == 0)
	return NULL;

    switch (flags & ZIP_FL_ENCODING_ALL) {
    case ZIP_FL_ENC_GUESS:
	expected_encoding = ZIP_ENCODING_UNKNOWN;
	break;
    case ZIP_FL_ENC_UTF_8:
	expected_encoding = ZIP_ENCODING_UTF8_KNOWN;
	break;
    case ZIP_FL_ENC_CP437:
	expected_encoding = ZIP_ENCODING_CP437;
	break;
    default:
	zip_error_set(error, ZIP_ER_INVAL, 0);
	return NULL;
    }
	
    if ((s=(zip_string_t *)malloc(sizeof(*s))) == NULL) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    if ((s->raw=(zip_uint8_t *)malloc((size_t)(length+1))) == NULL) {
	free(s);
	return NULL;
    }

    memcpy(s->raw, raw, length);
    s->raw[length] = '\0';
    s->length = length;
    s->encoding = ZIP_ENCODING_UNKNOWN;
    s->converted = NULL;
    s->converted_length = 0;

    if (expected_encoding != ZIP_ENCODING_UNKNOWN) {
	if (_zip_guess_encoding(s, expected_encoding) == ZIP_ENCODING_ERROR) {
	    _zip_string_free(s);
	    zip_error_set(error, ZIP_ER_INVAL, 0);
	    return NULL;
	}
    }
    
    return s;
}


int
_zip_string_write(zip_t *za, const zip_string_t *s)
{
    if (s == NULL)
	return 0;
    
    return _zip_write(za, s->raw, s->length);
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_unchange.c`:

```c
/*
  zip_unchange.c -- undo changes to file in zip archive
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN int
zip_unchange(zip_t *za, zip_uint64_t idx)
{
    return _zip_unchange(za, idx, 0);
}


int
_zip_unchange(zip_t *za, zip_uint64_t idx, int allow_duplicates)
{
    zip_int64_t i;
    
    if (idx >= za->nentry) {
	zip_error_set(&za->error, ZIP_ER_INVAL, 0);
	return -1;
    }

    if (!allow_duplicates && za->entry[idx].changes && (za->entry[idx].changes->changed & ZIP_DIRENT_FILENAME)) {
	i = _zip_name_locate(za, _zip_get_name(za, idx, ZIP_FL_UNCHANGED, NULL), 0, NULL);
	if (i >= 0 && (zip_uint64_t)i != idx) {
	    zip_error_set(&za->error, ZIP_ER_EXISTS, 0);
	    return -1;
	}
    }

    _zip_dirent_free(za->entry[idx].changes);
    za->entry[idx].changes = NULL;

    _zip_unchange_data(za->entry+idx);

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_unchange_all.c`:

```c
/*
  zip_unchange.c -- undo changes to all files in zip archive
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN int
zip_unchange_all(zip_t *za)
{
    int ret;
    zip_uint64_t i;

    ret = 0;
    for (i=0; i<za->nentry; i++)
	ret |= _zip_unchange(za, i, 1);

    ret |= zip_unchange_archive(za);

    return ret;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_unchange_archive.c`:

```c
/*
  zip_unchange_archive.c -- undo global changes to ZIP archive
  Copyright (C) 2006-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include <stdlib.h>

#include "zipint.h"


ZIP_EXTERN int
zip_unchange_archive(zip_t *za)
{
    if (za->comment_changed) {
	_zip_string_free(za->comment_changes);
	za->comment_changes = NULL;
	za->comment_changed = 0;
    }
    
    za->ch_flags = za->flags;

    return 0;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_unchange_data.c`:

```c
/*
  zip_unchange_data.c -- undo helper function
  Copyright (C) 1999-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"

void
_zip_unchange_data(zip_entry_t *ze)
{
    if (ze->source) {
	zip_source_free(ze->source);
	ze->source = NULL;
    }

    if (ze->changes != NULL && (ze->changes->changed & ZIP_DIRENT_COMP_METHOD) && ze->changes->comp_method == ZIP_CM_REPLACED_DEFAULT) {
	ze->changes->changed &= ~ZIP_DIRENT_COMP_METHOD;
	if (ze->changes->changed == 0) {
	    _zip_dirent_free(ze->changes);
	    ze->changes = NULL;
	}
    }

    ze->deleted = 0;
}


```

`rwProcMem33Module/testDumpMem/jni/libzip/zip_utf-8.c`:

```c
/*
  zip_utf-8.c -- UTF-8 support functions for libzip
  Copyright (C) 2011-2014 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "zipint.h"

#include <stdlib.h>


static const zip_uint16_t _cp437_to_unicode[256] = {
    /* 0x00 - 0x0F */
    0x2007, 0x263A, 0x263B, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
    0x25D8, 0x25CB, 0x25D9, 0x2642, 0x2640, 0x266A, 0x266B, 0x263C,

    /* 0x10 - 0x1F */
    0x25BA, 0x25C4, 0x2195, 0x203C, 0x00B6, 0x00A7, 0x25AC, 0x21A8,
    0x2191, 0x2193, 0x2192, 0x2190, 0x221F, 0x2194, 0x25B2, 0x25BC,

    /* 0x20 - 0x2F */
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,

    /* 0x30 - 0x3F */
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,

    /* 0x40 - 0x4F */
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,

    /* 0x50 - 0x5F */
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,

    /* 0x60 - 0x6F */
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,

    /* 0x70 - 0x7F */
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x2302,

    /* 0x80 - 0x8F */
    0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
    0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,

    /* 0x90 - 0x9F */
    0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
    0x00FF, 0x00D6, 0x00DC, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,

    /* 0xA0 - 0xAF */
    0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
    0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,

    /* 0xB0 - 0xBF */
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
    0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,

    /* 0xC0 - 0xCF */
    0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
    0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,

    /* 0xD0 - 0xDF */
    0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
    0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,

    /* 0xE0 - 0xEF */
    0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4,
    0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,

    /* 0xF0 - 0xFF */
    0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
    0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
};

#define UTF_8_LEN_2_MASK     0xe0
#define UTF_8_LEN_2_MATCH    0xc0
#define UTF_8_LEN_3_MASK     0xf0
#define UTF_8_LEN_3_MATCH    0xe0
#define UTF_8_LEN_4_MASK     0xf8
#define UTF_8_LEN_4_MATCH    0xf0
#define UTF_8_CONTINUE_MASK  0xc0
#define UTF_8_CONTINUE_MATCH 0x80


zip_encoding_type_t
_zip_guess_encoding(zip_string_t *str, zip_encoding_type_t expected_encoding)
{
    zip_encoding_type_t enc;
    const zip_uint8_t *name;
    zip_uint32_t i, j, ulen;

    if (str == NULL)
	return ZIP_ENCODING_ASCII;

    name = str->raw;

    if (str->encoding != ZIP_ENCODING_UNKNOWN)
	enc = str->encoding;
    else {
	enc = ZIP_ENCODING_ASCII;
	for (i=0; i<str->length; i++) {
	    if ((name[i] > 31 && name[i] < 128) || name[i] == '\r' || name[i] == '\n' || name[i] == '\t')
		continue;

	    enc = ZIP_ENCODING_UTF8_GUESSED;
	    if ((name[i] & UTF_8_LEN_2_MASK) == UTF_8_LEN_2_MATCH)
		ulen = 1;
	    else if ((name[i] & UTF_8_LEN_3_MASK) == UTF_8_LEN_3_MATCH)
		ulen = 2;
	    else if ((name[i] & UTF_8_LEN_4_MASK) == UTF_8_LEN_4_MATCH)
		ulen = 3;
	    else {
		enc = ZIP_ENCODING_CP437;
		break;
	    }

	    if (i + ulen >= str->length) {
		enc = ZIP_ENCODING_CP437;
		break;
	    }

	    for (j=1; j<=ulen; j++) {
		if ((name[i+j] & UTF_8_CONTINUE_MASK) != UTF_8_CONTINUE_MATCH) {
		    enc = ZIP_ENCODING_CP437;
		    goto done;
		}
	    }
	    i += ulen;
	}
    }

done:
    str->encoding = enc;

    if (expected_encoding != ZIP_ENCODING_UNKNOWN) {
	if (expected_encoding == ZIP_ENCODING_UTF8_KNOWN && enc == ZIP_ENCODING_UTF8_GUESSED)
	    str->encoding = enc = ZIP_ENCODING_UTF8_KNOWN;

	if (expected_encoding != enc && enc != ZIP_ENCODING_ASCII)
	    return ZIP_ENCODING_ERROR;
    }
    
    return enc;
}


static zip_uint32_t
_zip_unicode_to_utf8_len(zip_uint32_t codepoint)
{
    if (codepoint < 0x0080)
	return 1;
    if (codepoint < 0x0800)
	return 2;
    if (codepoint < 0x10000)
	return 3;
    return 4;
}


static zip_uint32_t
_zip_unicode_to_utf8(zip_uint32_t codepoint, zip_uint8_t *buf)
{
    if (codepoint < 0x0080) {
	buf[0] = codepoint & 0xff;
	return 1;
    }
    if (codepoint < 0x0800) {
	buf[0] = (zip_uint8_t)(UTF_8_LEN_2_MATCH | ((codepoint >> 6) & 0x1f));
	buf[1] = (zip_uint8_t)(UTF_8_CONTINUE_MATCH | (codepoint & 0x3f));
	return 2;
    }
    if (codepoint < 0x10000) {
	buf[0] = (zip_uint8_t)(UTF_8_LEN_3_MATCH | ((codepoint >> 12) & 0x0f));
	buf[1] = (zip_uint8_t)(UTF_8_CONTINUE_MATCH | ((codepoint >> 6) & 0x3f));
	buf[2] = (zip_uint8_t)(UTF_8_CONTINUE_MATCH | (codepoint & 0x3f));
	return 3;
    }
    buf[0] = (zip_uint8_t)(UTF_8_LEN_4_MATCH | ((codepoint >> 18) & 0x07));
    buf[1] = (zip_uint8_t)(UTF_8_CONTINUE_MATCH | ((codepoint >> 12) & 0x3f));
    buf[2] = (zip_uint8_t)(UTF_8_CONTINUE_MATCH | ((codepoint >> 6) & 0x3f));
    buf[3] = (zip_uint8_t)(UTF_8_CONTINUE_MATCH | (codepoint & 0x3f));
    return 4;
}


zip_uint8_t *
_zip_cp437_to_utf8(const zip_uint8_t * const _cp437buf, zip_uint32_t len,
		   zip_uint32_t *utf8_lenp, zip_error_t *error)
{
    zip_uint8_t *cp437buf = (zip_uint8_t *)_cp437buf;
    zip_uint8_t *utf8buf;
    zip_uint32_t buflen, i, offset;

    if (len == 0) {
	if (utf8_lenp)
	    *utf8_lenp = 0;
	return NULL;
    }

    buflen = 1;
    for (i=0; i<len; i++)
	buflen += _zip_unicode_to_utf8_len(_cp437_to_unicode[cp437buf[i]]);

    if ((utf8buf=(zip_uint8_t*)malloc(buflen)) == NULL) {
	zip_error_set(error, ZIP_ER_MEMORY, 0);
	return NULL;
    }

    offset = 0;
    for (i=0; i<len; i++)
	offset += _zip_unicode_to_utf8(_cp437_to_unicode[cp437buf[i]],
				       utf8buf+offset);

    utf8buf[buflen-1] = 0;
    if (utf8_lenp)
	*utf8_lenp = buflen-1;
    return utf8buf;
}

```

`rwProcMem33Module/testDumpMem/jni/libzip/zipconf.h`:

```h
#ifndef _HAD_ZIPCONF_H
#define _HAD_ZIPCONF_H

/*
   zipconf.h -- platform specific include file

   This file was generated automatically by ./make_zipconf.sh
   based on ../config.h.
 */

#define LIBZIP_VERSION "1.0.1"
#define LIBZIP_VERSION_MAJOR 1
#define LIBZIP_VERSION_MINOR 0
#define LIBZIP_VERSION_MICRO 1

#include <inttypes.h>

typedef int8_t zip_int8_t;
#define ZIP_INT8_MIN INT8_MIN
#define ZIP_INT8_MAX INT8_MAX

typedef uint8_t zip_uint8_t;
#define ZIP_UINT8_MAX UINT8_MAX

typedef int16_t zip_int16_t;
#define ZIP_INT16_MIN INT16_MIN
#define ZIP_INT16_MAX INT16_MAX

typedef uint16_t zip_uint16_t;
#define ZIP_UINT16_MAX UINT16_MAX

typedef int32_t zip_int32_t;
#define ZIP_INT32_MIN INT32_MIN
#define ZIP_INT32_MAX INT32_MAX

typedef uint32_t zip_uint32_t;
#define ZIP_UINT32_MAX UINT32_MAX

typedef int64_t zip_int64_t;
#define ZIP_INT64_MIN INT64_MIN
#define ZIP_INT64_MAX INT64_MAX

typedef uint64_t zip_uint64_t;
#define ZIP_UINT64_MAX UINT64_MAX


#endif /* zipconf.h */

```

`rwProcMem33Module/testDumpMem/jni/libzip/zipint.h`:

```h
#ifndef _HAD_ZIPINT_H
#define _HAD_ZIPINT_H

/*
  zipint.h -- internal declarations.
  Copyright (C) 1999-2015 Dieter Baron and Thomas Klausner

  This file is part of libzip, a library to manipulate ZIP archives.
  The authors can be contacted at <libzip@nih.at>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The names of the authors may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.

  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//#ifdef HAVE_CONFIG_H
#include "config.h"
//#endif

/* to have *_MAX definitions for all types when compiling with g++ */
#define __STDC_LIMIT_MACROS

#include <zlib.h>

#ifdef _WIN32
#define ZIP_EXTERN __declspec(dllexport)
/* for dup(), close(), etc. */
#include <io.h>
#endif

#ifndef _ZIP_COMPILING_DEPRECATED
#define ZIP_DISABLE_DEPRECATED
#endif

#include "zip.h"

#ifdef HAVE_STDBOOL_H
#include <stdbool.h>
#else
typedef char bool;
#define true    1
#define false   0
#endif

#ifdef _WIN32
#if defined(HAVE__CLOSE)
#define close		_close
#endif
#if defined(HAVE__DUP)
#define dup		_dup
#endif
/* crashes reported when using fdopen instead of _fdopen on Windows/Visual Studio 10/Win64 */
#if defined(HAVE__FDOPEN)
#define fdopen		_fdopen
#endif
#if defined(HAVE__FILENO)
#define fileno		_fileno
#endif
/* Windows' open() doesn't understand Unix permissions */
#if defined(HAVE__OPEN)
#define open(a, b, c)	_open((a), (b))
#endif
#if defined(HAVE__SNPRINTF)
#define snprintf	_snprintf
#endif
#if defined(HAVE__STRDUP)
#if !defined(HAVE_STRDUP) || defined(_WIN32)
#undef strdup
#define strdup		_strdup
#endif
#endif
#endif

#ifndef HAVE_FSEEKO
#define fseeko(s, o, w)	(fseek((s), (long int)(o), (w)))
#endif

#ifndef HAVE_FTELLO
#define ftello(s)	((long)ftell((s)))
#endif

#ifndef HAVE_MKSTEMP
int _zip_mkstemp(char *);
#define mkstemp _zip_mkstemp
#endif

#if !defined(HAVE_STRCASECMP)
#if defined(HAVE__STRICMP)
#define strcasecmp	_stricmp
#endif
#endif

#if SIZEOF_OFF_T == 8
#define ZIP_OFF_MAX ZIP_INT64_MAX
#define ZIP_OFF_MIN ZIP_INT64_MIN
#elif SIZEOF_OFF_T == 4
#define ZIP_OFF_MAX ZIP_INT32_MAX
#define ZIP_OFF_MIN ZIP_INT32_MIN
#elif SIZEOF_OFF_T == 2
#define ZIP_OFF_MAX ZIP_INT16_MAX
#define ZIP_OFF_MIN ZIP_INT16_MIN
#else
#error unsupported size of off_t
#endif

#if defined(HAVE_FTELLO) && defined(HAVE_FSEEKO)
#define ZIP_FSEEK_MAX ZIP_OFF_MAX
#define ZIP_FSEEK_MIN ZIP_OFF_MIN
#else
#define ZIP_FSEEK_MAX LONG_MAX
#define ZIP_FSEEK_MIN LONG_MIN
#endif

#ifndef SIZE_MAX
#if SIZEOF_SIZE_T == 8
#define SIZE_MAX ZIP_INT64_MAX
#elif SIZEOF_SIZE_T == 4
#define SIZE_MAX ZIP_INT32_MAX
#elif SIZEOF_SIZE_T == 2
#define SIZE_MAX ZIP_INT16_MAX
#else
#error unsupported size of size_t
#endif
#endif

#define CENTRAL_MAGIC "PK\1\2"
#define LOCAL_MAGIC   "PK\3\4"
#define EOCD_MAGIC    "PK\5\6"
#define DATADES_MAGIC "PK\7\8"
#define EOCD64LOC_MAGIC "PK\6\7"
#define EOCD64_MAGIC  "PK\6\6"
#define CDENTRYSIZE         46u
#define LENTRYSIZE          30
#define MAXCOMLEN        65536
#define MAXEXTLEN        65536
#define EOCDLEN             22
#define EOCD64LOCLEN	    20
#define EOCD64LEN	    56
#define CDBUFSIZE       (MAXCOMLEN+EOCDLEN+EOCD64LOCLEN)
#define BUFSIZE		8192
#define EFZIP64SIZE 28

#define ZIP_CM_REPLACED_DEFAULT	(-2)

#define ZIP_CM_IS_DEFAULT(x)	((x) == ZIP_CM_DEFAULT || (x) == ZIP_CM_REPLACED_DEFAULT)

#define ZIP_EF_UTF_8_COMMENT	0x6375
#define ZIP_EF_UTF_8_NAME	0x7075
#define ZIP_EF_ZIP64		0x0001

#define ZIP_EF_IS_INTERNAL(id)	((id) == ZIP_EF_UTF_8_COMMENT || (id) == ZIP_EF_UTF_8_NAME || (id) == ZIP_EF_ZIP64)

/* according to unzip-6.0's zipinfo.c, this corresponds to a regular file with rw permissions for everyone */
#define ZIP_EXT_ATTRIB_DEFAULT		(0100666u<<16)
/* according to unzip-6.0's zipinfo.c, this corresponds to a directory with rwx permissions for everyone */
#define ZIP_EXT_ATTRIB_DEFAULT_DIR	(0040777u<<16)


#define ZIP_MAX(a, b)		((a) > (b) ? (a) : (b))
#define ZIP_MIN(a, b)		((a) < (b) ? (a) : (b))

/* This section contains API that won't materialize like this.  It's
   placed in the internal section, pending cleanup. */

/* flags for compression and encryption sources */

#define ZIP_CODEC_DECODE	0 /* decompress/decrypt (encode flag not set) */
#define ZIP_CODEC_ENCODE	1 /* compress/encrypt */


typedef zip_source_t *(*zip_compression_implementation)(zip_t *, zip_source_t *, zip_int32_t, int);
typedef zip_source_t *(*zip_encryption_implementation)(zip_t *, zip_source_t *, zip_uint16_t, int, const char *);

zip_compression_implementation _zip_get_compression_implementation(zip_int32_t);
zip_encryption_implementation _zip_get_encryption_implementation(zip_uint16_t);



/* This API is not final yet, but we need it internally, so it's private for now. */

const zip_uint8_t *zip_get_extra_field_by_id(zip_t *, int, int, zip_uint16_t, int, zip_uint16_t *);

/* This section contains API that is of limited use until support for
   user-supplied compression/encryption implementation is finished.
   Thus we will keep it private for now. */

typedef zip_int64_t (*zip_source_layered_callback)(zip_source_t *, void *, void *, zip_uint64_t, enum zip_source_cmd);
zip_source_t *zip_source_crc(zip_t *, zip_source_t *, int);
zip_source_t *zip_source_deflate(zip_t *, zip_source_t *, zip_int32_t, int);
zip_source_t *zip_source_layered(zip_t *, zip_source_t *, zip_source_layered_callback, void *);
zip_source_t *zip_source_layered_create(zip_source_t *src, zip_source_layered_callback cb, void *ud, zip_error_t *error);
zip_source_t *zip_source_pkware(zip_t *, zip_source_t *, zip_uint16_t, int, const char *);
int zip_source_remove(zip_source_t *);
zip_int64_t zip_source_supports(zip_source_t *src);
zip_source_t *zip_source_window(zip_t *, zip_source_t *, zip_uint64_t, zip_uint64_t);


/* error source for layered sources */

enum zip_les { ZIP_LES_NONE, ZIP_LES_UPPER, ZIP_LES_LOWER, ZIP_LES_INVAL };

/* directory entry: general purpose bit flags */

#define ZIP_GPBF_ENCRYPTED		0x0001	/* is encrypted */
#define ZIP_GPBF_DATA_DESCRIPTOR	0x0008	/* crc/size after file data */
#define ZIP_GPBF_STRONG_ENCRYPTION	0x0040  /* uses strong encryption */
#define ZIP_GPBF_ENCODING_UTF_8		0x0800  /* file name encoding is UTF-8 */


/* extra fields */
#define ZIP_EF_LOCAL		ZIP_FL_LOCAL			/* include in local header */
#define ZIP_EF_CENTRAL		ZIP_FL_CENTRAL			/* include in central directory */
#define ZIP_EF_BOTH		(ZIP_EF_LOCAL|ZIP_EF_CENTRAL)	/* include in both */

#define ZIP_FL_FORCE_ZIP64	1024  /* force zip64 extra field (_zip_dirent_write) */

#define ZIP_FL_ENCODING_ALL	(ZIP_FL_ENC_GUESS|ZIP_FL_ENC_CP437|ZIP_FL_ENC_UTF_8)


/* encoding type */
enum zip_encoding_type {
    ZIP_ENCODING_UNKNOWN,       /* not yet analyzed */
    ZIP_ENCODING_ASCII,         /* plain ASCII */
    ZIP_ENCODING_UTF8_KNOWN,    /* is UTF-8 */
    ZIP_ENCODING_UTF8_GUESSED,  /* possibly UTF-8 */
    ZIP_ENCODING_CP437,         /* Code Page 437 */
    ZIP_ENCODING_ERROR          /* should be UTF-8 but isn't */
};

typedef enum zip_encoding_type zip_encoding_type_t;

typedef struct zip_cdir zip_cdir_t;
typedef struct zip_dirent zip_dirent_t;
typedef struct zip_entry zip_entry_t;
typedef struct zip_extra_field zip_extra_field_t;
typedef struct zip_string zip_string_t;
typedef struct zip_buffer zip_buffer_t;


/* zip archive, part of API */

struct zip {
    zip_source_t *src;                  /* data source for archive */
    unsigned int open_flags;		/* flags passed to zip_open */
    zip_error_t error;                  /* error information */

    unsigned int flags;			/* archive global flags */
    unsigned int ch_flags;		/* changed archive global flags */

    char *default_password;		/* password used when no other supplied */

    zip_string_t *comment_orig;         /* archive comment */
    zip_string_t *comment_changes;  /* changed archive comment */
    bool comment_changed;		/* whether archive comment was changed */

    zip_uint64_t nentry;		/* number of entries */
    zip_uint64_t nentry_alloc;		/* number of entries allocated */
    zip_entry_t *entry;                 /* entries */

    unsigned int nopen_source;		/* number of open sources using archive */
    unsigned int nopen_source_alloc;	/* number of sources allocated */
    zip_source_t **open_source;         /* open sources using archive */

    char *tempdir;                      /* custom temp dir (needed e.g. for OS X sandboxing) */
};

/* file in zip archive, part of API */

struct zip_file {
    zip_t *za;		/* zip archive containing this file */
    zip_error_t error;	/* error information */
    bool eof;
    zip_source_t *src;	/* data source */
};

/* zip archive directory entry (central or local) */

#define ZIP_DIRENT_COMP_METHOD	0x0001u
#define ZIP_DIRENT_FILENAME	0x0002u
#define ZIP_DIRENT_COMMENT	0x0004u
#define ZIP_DIRENT_EXTRA_FIELD	0x0008u
#define ZIP_DIRENT_ATTRIBUTES	0x0010u
#define ZIP_DIRENT_LAST_MOD	0x0020u
#define ZIP_DIRENT_ALL		0xffffu

struct zip_dirent {
    zip_uint32_t changed;
    bool local_extra_fields_read;	/*      whether we already read in local header extra fields */
    bool cloned;                         /*      whether this instance is cloned, and thus shares non-changed strings */

    zip_uint16_t version_madeby;	/* (c)  version of creator */
    zip_uint16_t version_needed;	/* (cl) version needed to extract */
    zip_uint16_t bitflags;		/* (cl) general purpose bit flag */
    zip_int32_t comp_method;		/* (cl) compression method used (uint16 and ZIP_CM_DEFAULT (-1)) */
    time_t last_mod;			/* (cl) time of last modification */
    zip_uint32_t crc;			/* (cl) CRC-32 of uncompressed data */
    zip_uint64_t comp_size;		/* (cl) size of compressed data */
    zip_uint64_t uncomp_size;		/* (cl) size of uncompressed data */
    zip_string_t *filename;		/* (cl) file name (NUL-terminated) */
    zip_extra_field_t *extra_fields;	/* (cl) extra fields, parsed */
    zip_string_t *comment;		/* (c)  file comment */
    zip_uint32_t disk_number;		/* (c)  disk number start */
    zip_uint16_t int_attrib;		/* (c)  internal file attributes */
    zip_uint32_t ext_attrib;		/* (c)  external file attributes */
    zip_uint64_t offset;		/* (c)  offset of local header */
};

/* zip archive central directory */

struct zip_cdir {
    zip_entry_t *entry;	 		/* directory entries */
    zip_uint64_t nentry;		/* number of entries */
    zip_uint64_t nentry_alloc;		/* number of entries allocated */

    zip_uint64_t size;                  /* size of central directory */
    zip_uint64_t offset;		/* offset of central directory in file */
    zip_string_t *comment;		/* zip archive comment */
};

struct zip_extra_field {
    zip_extra_field_t *next;
    zip_flags_t flags;			/* in local/central header */
    zip_uint16_t id;			/* header id */
    zip_uint16_t size;			/* data size */
    zip_uint8_t *data;
};

enum zip_source_write_state {
    ZIP_SOURCE_WRITE_CLOSED,    /* write is not in progress */
    ZIP_SOURCE_WRITE_OPEN,      /* write is in progress */
    ZIP_SOURCE_WRITE_FAILED,    /* commit failed, only rollback allowed */
    ZIP_SOURCE_WRITE_REMOVED    /* file was removed */
};
typedef enum zip_source_write_state zip_source_write_state_t;

struct zip_source {
    zip_source_t *src;
    union {
	zip_source_callback f;
	zip_source_layered_callback l;
    } cb;
    void *ud;
    zip_error_t error;
    zip_int64_t supports;       /* supported commands */
    unsigned int open_count;    /* number of times source was opened (directly or as lower layer) */
    zip_source_write_state_t write_state;          /* whether source is open for writing */
    bool source_closed;         /* set if source archive is closed */
    zip_t *source_archive;      /* zip archive we're reading from, NULL if not from archive */
    unsigned int refcount;
};

#define ZIP_SOURCE_IS_OPEN_READING(src) ((src)->open_count > 0)
#define ZIP_SOURCE_IS_OPEN_WRITING(src) ((src)->write_state == ZIP_SOURCE_WRITE_OPEN)
#define ZIP_SOURCE_IS_LAYERED(src)  ((src)->src != NULL)

/* entry in zip archive directory */

struct zip_entry {
    zip_dirent_t *orig;
    zip_dirent_t *changes;
    zip_source_t *source;
    bool deleted;
};


/* file or archive comment, or filename */

struct zip_string {
    zip_uint8_t *raw;			/* raw string */
    zip_uint16_t length;		/* length of raw string */
    enum zip_encoding_type encoding; 	/* autorecognized encoding */
    zip_uint8_t *converted;     	/* autoconverted string */
    zip_uint32_t converted_length;	/* length of converted */
};


/* bounds checked access to memory buffer */

struct zip_buffer {
    bool ok;
    bool free_data;

    zip_uint8_t *data;
    zip_uint64_t size;
    zip_uint64_t offset;
};

/* which files to write in which order */

struct zip_filelist {
    zip_uint64_t idx;
// TODO    const char *name;
};

typedef struct zip_filelist zip_filelist_t;


extern const char * const _zip_err_str[];
extern const int _zip_nerr_str;
extern const int _zip_err_type[];


#define ZIP_ENTRY_CHANGED(e, f)	((e)->changes && ((e)->changes->changed & (f)))

#define ZIP_ENTRY_DATA_CHANGED(x)	((x)->source != NULL)

#define ZIP_IS_RDONLY(za)	((za)->ch_flags & ZIP_AFL_RDONLY)


zip_int64_t _zip_add_entry(zip_t *);

zip_uint8_t *_zip_buffer_data(zip_buffer_t *buffer);
bool _zip_buffer_eof(zip_buffer_t *buffer);
void _zip_buffer_free(zip_buffer_t *buffer);
zip_uint8_t *_zip_buffer_get(zip_buffer_t *buffer, zip_uint64_t length);
zip_uint16_t _zip_buffer_get_16(zip_buffer_t *buffer);
zip_uint32_t _zip_buffer_get_32(zip_buffer_t *buffer);
zip_uint64_t _zip_buffer_get_64(zip_buffer_t *buffer);
zip_uint8_t _zip_buffer_get_8(zip_buffer_t *buffer);
zip_uint64_t _zip_buffer_left(zip_buffer_t *buffer);
zip_buffer_t *_zip_buffer_new(zip_uint8_t *data, zip_uint64_t size);
zip_buffer_t *_zip_buffer_new_from_source(zip_source_t *src, zip_uint64_t size, zip_uint8_t *buf, zip_error_t *error);
zip_uint64_t _zip_buffer_offset(zip_buffer_t *buffer);
bool _zip_buffer_ok(zip_buffer_t *buffer);
int _zip_buffer_put(zip_buffer_t *buffer, const void *src, size_t length);
int _zip_buffer_put_16(zip_buffer_t *buffer, zip_uint16_t i);
int _zip_buffer_put_32(zip_buffer_t *buffer, zip_uint32_t i);
int _zip_buffer_put_64(zip_buffer_t *buffer, zip_uint64_t i);
int _zip_buffer_put_8(zip_buffer_t *buffer, zip_uint8_t i);
int _zip_buffer_set_offset(zip_buffer_t *buffer, zip_uint64_t offset);
zip_uint64_t _zip_buffer_size(zip_buffer_t *buffer);

int _zip_cdir_compute_crc(zip_t *, uLong *);
void _zip_cdir_free(zip_cdir_t *);
zip_cdir_t *_zip_cdir_new(zip_uint64_t, zip_error_t *);
zip_int64_t _zip_cdir_write(zip_t *za, const zip_filelist_t *filelist, zip_uint64_t survivors);
void _zip_deregister_source(zip_t *za, zip_source_t *src);

zip_dirent_t *_zip_dirent_clone(const zip_dirent_t *);
void _zip_dirent_free(zip_dirent_t *);
void _zip_dirent_finalize(zip_dirent_t *);
void _zip_dirent_init(zip_dirent_t *);
bool _zip_dirent_needs_zip64(const zip_dirent_t *, zip_flags_t);
zip_dirent_t *_zip_dirent_new(void);
zip_int64_t _zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error);
zip_int32_t _zip_dirent_size(zip_source_t *src, zip_uint16_t, zip_error_t *);
int _zip_dirent_write(zip_t *za, zip_dirent_t *dirent, zip_flags_t flags);

zip_extra_field_t *_zip_ef_clone(const zip_extra_field_t *, zip_error_t *);
zip_extra_field_t *_zip_ef_delete_by_id(zip_extra_field_t *, zip_uint16_t, zip_uint16_t, zip_flags_t);
void _zip_ef_free(zip_extra_field_t *);
const zip_uint8_t *_zip_ef_get_by_id(const zip_extra_field_t *, zip_uint16_t *, zip_uint16_t, zip_uint16_t, zip_flags_t, zip_error_t *);
zip_extra_field_t *_zip_ef_merge(zip_extra_field_t *, zip_extra_field_t *);
zip_extra_field_t *_zip_ef_new(zip_uint16_t, zip_uint16_t, const zip_uint8_t *, zip_flags_t);
zip_extra_field_t *_zip_ef_parse(const zip_uint8_t *, zip_uint16_t, zip_flags_t, zip_error_t *);
zip_extra_field_t *_zip_ef_remove_internal(zip_extra_field_t *);
zip_uint16_t _zip_ef_size(const zip_extra_field_t *, zip_flags_t);
int _zip_ef_write(zip_t *za, const zip_extra_field_t *ef, zip_flags_t flags);

void _zip_entry_finalize(zip_entry_t *);
void _zip_entry_init(zip_entry_t *);

void _zip_error_clear(zip_error_t *);
void _zip_error_get(const zip_error_t *, int *, int *);

void _zip_error_copy(zip_error_t *dst, const zip_error_t *src);
void _zip_error_set_from_source(zip_error_t *, zip_source_t *);

const zip_uint8_t *_zip_extract_extra_field_by_id(zip_error_t *, zip_uint16_t, int, const zip_uint8_t *, zip_uint16_t, zip_uint16_t *);

int _zip_file_extra_field_prepare_for_change(zip_t *, zip_uint64_t);
int _zip_file_fillbuf(void *, size_t, zip_file_t *);
zip_uint64_t _zip_file_get_offset(const zip_t *, zip_uint64_t, zip_error_t *);

int _zip_filerange_crc(zip_source_t *src, zip_uint64_t offset, zip_uint64_t length, uLong *crcp, zip_error_t *error);

zip_dirent_t *_zip_get_dirent(zip_t *, zip_uint64_t, zip_flags_t, zip_error_t *);

enum zip_encoding_type _zip_guess_encoding(zip_string_t *, enum zip_encoding_type);
zip_uint8_t *_zip_cp437_to_utf8(const zip_uint8_t * const, zip_uint32_t, zip_uint32_t *, zip_error_t *);

zip_t *_zip_open(zip_source_t *, unsigned int, zip_error_t *);

int _zip_read(zip_source_t *src, zip_uint8_t *data, zip_uint64_t length, zip_error_t *error);
int _zip_read_at_offset(zip_source_t *src, zip_uint64_t offset, unsigned char *b, size_t length, zip_error_t *error);
zip_uint8_t *_zip_read_data(zip_buffer_t *buffer, zip_source_t *src, size_t length, bool nulp, zip_error_t *error);
int _zip_read_local_ef(zip_t *, zip_uint64_t);
zip_string_t *_zip_read_string(zip_buffer_t *buffer, zip_source_t *src, zip_uint16_t lenght, bool nulp, zip_error_t *error);
int _zip_register_source(zip_t *za, zip_source_t *src);

void _zip_set_open_error(int *zep, const zip_error_t *err, int ze);

zip_int64_t _zip_source_call(zip_source_t *src, void *data, zip_uint64_t length, zip_source_cmd_t command);
zip_source_t *_zip_source_file_or_p(const char *, FILE *, zip_uint64_t, zip_int64_t, const zip_stat_t *, zip_error_t *error);
void _zip_source_invalidate(zip_source_t *src);
zip_source_t *_zip_source_new(zip_error_t *error);
int _zip_source_set_source_archive(zip_source_t *, zip_t *);
zip_source_t *_zip_source_window_new(zip_source_t *src, zip_uint64_t start, zip_uint64_t length, zip_stat_t *st, zip_error_t *error);
zip_source_t *_zip_source_zip_new(zip_t *, zip_t *, zip_uint64_t, zip_flags_t, zip_uint64_t, zip_uint64_t, const char *);

int _zip_stat_merge(zip_stat_t *dst, const zip_stat_t *src, zip_error_t *error);
int _zip_string_equal(const zip_string_t *, const zip_string_t *);
void _zip_string_free(zip_string_t *);
zip_uint32_t _zip_string_crc32(const zip_string_t *);
const zip_uint8_t *_zip_string_get(zip_string_t *, zip_uint32_t *, zip_flags_t, zip_error_t *);
zip_uint16_t _zip_string_length(const zip_string_t *);
zip_string_t *_zip_string_new(const zip_uint8_t *, zip_uint16_t, zip_flags_t, zip_error_t *);
int _zip_string_write(zip_t *za, const zip_string_t *string);

int _zip_changed(const zip_t *, zip_uint64_t *);
const char *_zip_get_name(zip_t *, zip_uint64_t, zip_flags_t, zip_error_t *);
int _zip_local_header_read(zip_t *, int);
void *_zip_memdup(const void *, size_t, zip_error_t *);
zip_int64_t _zip_name_locate(zip_t *, const char *, zip_flags_t, zip_error_t *);
zip_t *_zip_new(zip_error_t *);

zip_int64_t _zip_file_replace(zip_t *, zip_uint64_t, const char *, zip_source_t *, zip_flags_t);
int _zip_set_name(zip_t *, zip_uint64_t, const char *, zip_flags_t);
void _zip_u2d_time(time_t, zip_uint16_t *, zip_uint16_t *);
int _zip_unchange(zip_t *, zip_uint64_t, int);
void _zip_unchange_data(zip_entry_t *);
int _zip_write(zip_t *za, const void *data, zip_uint64_t length);

#endif /* zipint.h */

```

`rwProcMem33Module/testDumpMem/jni/testDumpMem.cpp`:

```cpp
#include <cstdio>
#include <string.h> 
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <signal.h>
#include <memory>
#include <sstream>
#include <cinttypes>
#include <dirent.h>
#include <iostream>
#include <map>
#include <sys/stat.h>
#include <zlib.h>
#include "libzip/zip.h"
#include "../../../testKo/jni/MemoryReaderWriter39.h"
#include "../../../testMemSearch/jni/MapRegionType.h"

constexpr uint64_t kMaxDumpMemRegionSize = 2147483648;

std::string& replace_all_distinct(std::string& str, const std::string& old_value, const std::string& new_value) {
	for (std::string::size_type pos(0); pos != std::string::npos; pos += new_value.length()) {
		if ((pos = str.find(old_value, pos)) != std::string::npos) {
			str.replace(pos, old_value.length(), new_value);
		} else {
			break;
		}
	}
	return str;
}

int findPID(CMemoryReaderWriter *pDriver, const char *lpszCmdline) {
	int nTargetPid = 0;

	//驱动_获取进程PID列表
	std::vector<int> vPID;
	BOOL b = pDriver->GetPidList(vPID);
	printf("调用驱动 GetPidList 返回值:%d\n", b);

	//打印进程列表信息
	for (int pid : vPID) {
		//驱动_打开进程
		uint64_t hProcess = pDriver->OpenProcess(pid);
		if (!hProcess) { continue; }

		//驱动_获取进程命令行
		char cmdline[100] = { 0 };
		pDriver->GetProcessCmdline(hProcess, cmdline, sizeof(cmdline));

		//驱动_关闭进程
		pDriver->CloseHandle(hProcess);

		if (strcmp(lpszCmdline, cmdline) == 0) {
			nTargetPid = pid;
			break;
		}
	}
	return nTargetPid;
}

int main(int argc, char *argv[]) {
	printf(
		"======================================================\n"
		"本驱动名称: Linux ARM64 硬件读写进程内存驱动39\n"
		"本驱动接口列表：\n"
		"\t1.	驱动_打开进程: OpenProcess\n"
		"\t2.	驱动_读取进程内存: ReadProcessMemory\n"
		"\t3.	驱动_写入进程内存: WriteProcessMemory\n"
		"\t4.	驱动_关闭进程: CloseHandle\n"
		"\t5.	驱动_获取进程内存块列表: VirtualQueryExFull（可选：显示全部内存、仅显示物理内存）\n"
		"\t6.	驱动_获取进程PID列表: GetPidList\n"
		"\t7.	驱动_提升进程权限到Root: SetProcessRoot\n"
		"\t8.	驱动_获取进程物理内存占用大小: GetProcessPhyMemSize\n"
		"\t9.	驱动_获取进程命令行: GetProcessCmdline\n"
		"\t10.	驱动_隐藏驱动: HideKernelModule\n"
		"\t以上所有功能不注入、不附加进程，不打开进程任何文件，所有操作均为内核操作\n"
		"======================================================\n"
	);

	CMemoryReaderWriter rwDriver;

	std::string targetProcessName;
	bool targetProcessNeedSuspend = false;
	//驱动默认隐蔽通信密匙
	std::string procNodeAuthKey = "e84523d7b60d5d341a7c4d1861773ecd";
	if (argc > 1) {
		targetProcessName = argv[1];
	}
	if (argc > 2) {
		if(strcmp(argv[2], "suspend") == 0) {
			targetProcessNeedSuspend = true;
		}
	}
	if (argc > 3) {
		//用户自定义输入驱动隐蔽通信密匙
		procNodeAuthKey = argv[3];
	}

	if(targetProcessName.empty()) {
		printf("Target process name is empty.\n");
		return 0;
	}
	printf("Target process name is %s\n", targetProcessName.c_str());
	printf("Target process need suspend: %s\n", targetProcessNeedSuspend ? "true" : "false");
	printf("Connecting rwDriver auth key:%s\n", procNodeAuthKey.c_str());

	//连接驱动
	int err = rwDriver.ConnectDriver(procNodeAuthKey.c_str());
	if (err) {
		printf("Connect rwDriver failed. error:%d\n", err);
		fflush(stdout);
		return 0;
	}

	//获取目标进程PID
	pid_t pid = findPID(&rwDriver, targetProcessName.c_str());
	if (pid == 0) {
		printf("找不到进程\n");
		return 0;
	}
	printf("目标进程PID:%d\n", pid);

	//打开进程
	uint64_t hProcess = rwDriver.OpenProcess(pid);
	printf("调用驱动 OpenProcess 返回值:%" PRIu64 "\n", hProcess);
	if (!hProcess) {
		printf("调用驱动 OpenProcess 失败\n");
		fflush(stdout);
		return 0;
	}


	//写出数据到压缩包文件
	const char* lpszOutFilePath = "/sdcard/dumptest.zip";

	//新建压缩包文件
	err = 0;
	zip *z = zip_open(lpszOutFilePath, ZIP_CREATE | ZIP_EXCL, &err);
	if (!z) {
		printf("zip_open failed.\n");
		return 0;
	}

	if(targetProcessNeedSuspend) {
		kill(pid, SIGSTOP);
		printf("suspend target process done.\n");
	}

	//驱动_获取进程内存块列表（只显示在物理内存中的内存）
	std::vector<DRIVER_REGION_INFO> vMaps;
	BOOL b = rwDriver.VirtualQueryExFull(hProcess, TRUE, vMaps);
	printf("调用驱动 VirtualQueryExFull(只显示在物理内存中的内存) 返回值:%d\n", b);
	if (!vMaps.size()) {
		printf("VirtualQueryExFull 失败\n");

		//关闭进程
		rwDriver.CloseHandle(hProcess);
		printf("调用驱动 CloseHandle:%" PRIu64 "\n", hProcess);
		fflush(stdout);
		return 0;
	}


	//开始生成指针映射集
	std::vector<std::shared_ptr<char>> vspMemData;
	size_t total_size = 0;
	int pass_cnt = 0;
	for (DRIVER_REGION_INFO rinfo : vMaps) {
		printf("[%.2f%%][%zd Mb] +++Start:%p,Size:%" PRIu64 ",Type:%s,Name:%s\n",
			(float)((float)vspMemData.size() * 100 / vMaps.size()),
			total_size / 1024 / 1024,
			(void*)rinfo.baseaddress, rinfo.size,
			MapsTypeToString(&rinfo).c_str(), rinfo.name);
		
		if(rinfo.size > kMaxDumpMemRegionSize) {
			pass_cnt++;
			continue;
		}
		
		//申请内存
		std::shared_ptr<char> spMem(new char[rinfo.size], [](char *p) { delete[] p; });
		if (!spMem) {
			printf("malloc(%" PRIu64 ") failed.\n", rinfo.size);
			continue;
		}
		memset(spMem.get(), 0, rinfo.size);
		total_size += rinfo.size;


		//读取进程内存
		size_t real_read;
		auto read_res = rwDriver.ReadProcessMemory(hProcess, rinfo.baseaddress, spMem.get(), rinfo.size, &real_read, FALSE);
		printf("ReadProcessMemory(%p)=%d, %zu\n", (void*)rinfo.baseaddress, read_res, real_read);

		//压缩包里的文件名
		std::stringstream ssfilename;
		ssfilename << "/" << std::hex << (void*)rinfo.baseaddress;
		ssfilename << "_";
		ssfilename << rinfo.size;
		ssfilename << "_";
		ssfilename << MapsTypeToString(&rinfo);
		if (rinfo.name[0] != '\0') {
			//替换斜杠
			std::string specialFileName = rinfo.name;
			specialFileName = replace_all_distinct(specialFileName, "/", "／");
			ssfilename << "_" << specialFileName;
		}

		//添加进压缩包
		struct zip_source *s = zip_source_buffer(z, spMem.get(), rinfo.size, 0);
		if (!s) {
			printf("zip_source_buffer failed.\n");
			continue;
		}

		zip_file_add(z, ssfilename.str().c_str(), s,
			ZIP_FL_OVERWRITE | ZIP_FL_ENC_GUESS);

		//would be used and freed by zip_close(),
		//so don't free the zip_source here.
		//zip_source_free(s); 

		vspMemData.push_back(spMem);
	}

	//把内存页大小也添加进压缩包
	char empty = '\0';
	struct zip_source *s = zip_source_buffer(z, &empty, sizeof(empty), 0);
	if (s) {
		std::stringstream ssfilename;
		ssfilename << "/0x0_" << std::hex << getpagesize() << "_----_pagesize";
		zip_file_add(z, ssfilename.str().c_str(), s,
			ZIP_FL_OVERWRITE | ZIP_FL_ENC_GUESS);
	}

	printf("其中有[%d]个内存区域，由于内存太大被跳过\n", pass_cnt);
	//关闭压缩包
	printf("zip_closing...\n");
	err = zip_close(z);
	printf("zip_close done.\n");
	
	if(targetProcessNeedSuspend) {
		kill(pid, SIGKILL);
		printf("kill target process done.\n");
	}

	return 0;
}

```

`rwProcMem33Module/testKo/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_CPPFLAGS += -std=c++20
LOCAL_CFLAGS += -fPIE
LOCAL_CFLAGS += -fvisibility=hidden
LOCAL_LDFLAGS += -fPIE -pie
LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true
LOCAL_MODULE    := testKo.out
LOCAL_SRC_FILES :=  testKo.cpp
include $(BUILD_EXECUTABLE)

```

`rwProcMem33Module/testKo/jni/Application.mk`:

```mk
APP_ABI := arm64-v8a
APP_STL := c++_static
```

`rwProcMem33Module/testKo/jni/IMemReaderWriterProxy.h`:

```h
#ifndef MEM_READER_WRITER_PROXY_H_
#define MEM_READER_WRITER_PROXY_H_
#include <memory>
#include <vector>
#include <atomic>
#include <mutex>
#include <mutex>
#include <thread>
#include <sstream>
#include <stdint.h>

#ifdef __linux__
#include <unistd.h>
#include <sys/sysinfo.h>
typedef int BOOL;
#define TRUE 1
#define FALSE 0
#define PAGE_NOACCESS 1
#define PAGE_READONLY 2
#define PAGE_READWRITE 4
#define PAGE_WRITECOPY 8
#define PAGE_EXECUTE 16
#define PAGE_EXECUTE_READ 32
#define PAGE_EXECUTE_READWRITE 64

#define MEM_MAPPED 262144
#define MEM_PRIVATE 131072
#else
#include <windows.h>
#endif

#pragma pack(1)
typedef struct {
	uint64_t baseaddress;
	uint64_t size;
	uint32_t protection;
	uint32_t type;
	char name[4096];
} DRIVER_REGION_INFO, *PDRIVER_REGION_INFO;
#pragma pack()


struct IMemReaderWriterProxy {
	virtual BOOL ReadProcessMemory(
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		void *lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesRead = NULL,
		BOOL bIsForceRead = FALSE) = 0;
	virtual BOOL WriteProcessMemory(
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		void * lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesWritten = NULL,
		BOOL bIsForceWrite = FALSE) = 0;
	virtual BOOL VirtualQueryExFull(
		uint64_t hProcess,
		BOOL showPhy,
		std::vector<DRIVER_REGION_INFO> & vOutput) = 0;

	virtual BOOL CheckProcessMemAddrValid(
		uint64_t hProcess,
		uint64_t lpBaseAddress) = 0;
};

#endif /* MEM_READER_WRITER_PROXY_H_ */


```

`rwProcMem33Module/testKo/jni/IoctlBufferPool.h`:

```h
#ifndef IOCTL_BUFFER_POOL_H_
#define IOCTL_BUFFER_POOL_H_
#ifdef __linux__
#include <cstddef>  // for size_t
#include <new>      // for std::nothrow

// 创建一个静态内存缓冲区，避免重复分配内存
class IoctlBufferPool {
    static constexpr size_t kDefaultBuffer = 4096;   // 默认小缓冲区
    char    _smallBuf[kDefaultBuffer];               // 小缓冲区（无需动态分配）
    char*   _largeBuf     = nullptr;                 // 大缓冲区指针
    size_t  _largeBufSize = 0;                       // 已分配大缓冲区容量

public:
    ~IoctlBufferPool() {
        // 在线程退出时自动释放大缓冲区
		if(_largeBuf) {
        	delete[] _largeBuf;
		}
    }

    // 获取至少 capacity 字节的缓冲区
    char* getBuffer(size_t capacity) {
        if (capacity <= kDefaultBuffer) {
            return _smallBuf;
        }
        if (_largeBufSize < capacity) {
            // 需要更大的缓冲区，先释放旧的再分配
			if(_largeBuf) {
				delete[] _largeBuf;
			}
            _largeBuf = new (std::nothrow) char[capacity];
            _largeBufSize = _largeBuf ? capacity : 0;
        }
        return _largeBuf;
    }
};
#endif /*__linux__*/

#endif /* IOCTL_BUFFER_POOL_H_ */

```

`rwProcMem33Module/testKo/jni/MemoryReaderWriter39.h`:

```h
#ifndef MEMORY_READER_WRITER_H_
#define MEMORY_READER_WRITER_H_

#include <vector>
#include <mutex>

#include "IMemReaderWriterProxy.h"
#ifdef __linux__
#include <stdio.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/prctl.h>
#include <elf.h>
#include <errno.h>
#include <malloc.h>
#include <random>
#include <algorithm>
#include <filesystem>
#include "IoctlBufferPool.h"
//安静输出模式
#define QUIET_PRINTF
#endif /*__linux__*/

class CMemoryReaderWriter : public IMemReaderWriterProxy {
public:
	CMemoryReaderWriter() {}
	~CMemoryReaderWriter() { DisconnectDriver(); }

	// 连接驱动
	// 参数 procNodeAuthKey：隐蔽节点连接密钥
	// 返回值：>=0成功，<0错误码
	int ConnectDriver(const std::string& procNodeAuthKey) {
		return _InternalConnectDriver(procNodeAuthKey);
	}

	// 断开驱动
	// 返回值：TRUE成功，FALSE失败
	BOOL DisconnectDriver() {
		return _InternalDisconnectDriver();
	}

	// 检查驱动连接状态
	// 返回值：TRUE已连接，FALSE未连接
	BOOL IsDriverConnected() {
		return _InternalIsDriverConnected();
	}

	// 驱动_打开进程
	// 参数 pid：目标进程PID
	// 返回值：成功返回进程句柄，失败返回0
	uint64_t OpenProcess(uint64_t pid) {
		return _InternalOpenProcess(pid);
	}

	// 驱动_读取进程内存
	// 参数 hProcess：				进程句柄
	// 参数 lpBaseAddress：			进程内存地址
	// 参数 lpBuffer：				待接收数据的缓冲区
	// 参数 nSize：					待接收数据的缓冲区大小
	// 参数 lpNumberOfBytesRead		返回实际读取的字节数
	// 参数 bIsForceRead：			读取模式，FALSE-安全读取；TRUE-暴力读取
	// 返回值：TRUE成功，FALSE失败
	BOOL ReadProcessMemory(uint64_t hProcess,
						uint64_t lpBaseAddress,
						void* lpBuffer,
						size_t nSize,
						size_t* lpNumberOfBytesRead = NULL,
						BOOL bIsForceRead = FALSE) override {
		return _InternalReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead, bIsForceRead);
	}

	// 驱动_写入进程内存
	// 参数 hProcess：				进程句柄
	// 参数 lpBaseAddress：			进程内存地址
	// 参数 lpBuffer：				欲写入数据的缓冲区
	// 参数 nSize：					欲写入数据的缓冲区大小
	// 参数 lpNumberOfBytesWritten	返回实际写入的字节数
	// 参数 bIsForceWrite：			写入模式，FALSE-安全写入；TRUE-暴力写入
	// 返回值：TRUE成功，FALSE失败
	BOOL WriteProcessMemory(uint64_t hProcess,
							uint64_t lpBaseAddress,
							void* lpBuffer,
							size_t nSize,
							size_t* lpNumberOfBytesWritten = NULL,
							BOOL bIsForceWrite = FALSE) override {
		return _InternalWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten, bIsForceWrite);
	}

	// 驱动_关闭进程句柄
	// 参数 hProcess：进程句柄
	// 返回值：TRUE成功，FALSE失败
	BOOL CloseHandle(uint64_t hProcess) {
		return _InternalCloseHandle(hProcess);
	}

	// 驱动_获取进程内存块列表
	// 参数 hProcess：	进程句柄
	// 参数 showPhy：	FALSE-显示全部内存；TRUE-仅显示物理页；注非物理页驱动不可读
	// 参数 vOutput：	输出内存块列表结果
	// 返回值：TRUE成功，FALSE失败
	BOOL VirtualQueryExFull(uint64_t hProcess, BOOL showPhy, std::vector<DRIVER_REGION_INFO>& vOutput) override {
		return _InternalVirtualQueryExFull(hProcess, showPhy, vOutput);
	}

	// 驱动_检查进程内存地址有效性
	// 参数 hProcess：		进程句柄
	// 参数 lpBaseAddress：进程内存地址
	// 返回值：TRUE有效，FALSE无效
	BOOL CheckProcessMemAddrValid(uint64_t hProcess, uint64_t lpBaseAddress) override {
		return _InternalCheckProcessMemAddrValid(hProcess, lpBaseAddress);
	}

	// 驱动_获取PID列表
	// 参数 vOutput：输出进程PID列表
	// 返回值：TRUE成功，FALSE失败
	BOOL GetPidList(std::vector<int>& vOutput) {
		return _InternalGetPidList(vOutput);
	}

	// 驱动_提升进程权限至Root
	// 参数 hProcess：进程句柄
	// 返回值：TRUE成功，FALSE失败
	BOOL SetProcessRoot(uint64_t hProcess) {
		return _InternalSetProcessRoot(hProcess);
	}

	// 驱动_获取进程物理内存占用大小
	// 参数 hProcess：进程句柄
	// 参数 outRss：输出占用字节数
	// 返回值：TRUE成功，FALSE失败
	BOOL GetProcessPhyMemSize(uint64_t hProcess, uint64_t& outRss) {
		return _InternalGetProcessPhyMemSize(hProcess, outRss);
	}

	// 驱动_获取进程命令行
	// 参数 hProcess：进程句柄
	// 参数 lpOutCmdlineBuf：待接收数据的缓冲区；
	// 参数 bufSize：待接收数据的缓冲区大小
	// 返回值：TRUE成功，FALSE失败
	BOOL GetProcessCmdline(uint64_t hProcess, char* lpOutCmdlineBuf, size_t bufSize) {
		return _InternalGetProcessCmdline(hProcess, lpOutCmdlineBuf, bufSize);
	}

	// 驱动_隐藏内核模块
	// 返回值：TRUE成功，FALSE失败
	BOOL HideKernelModule() {
		return _InternalHideKernelModule();
	}

	// 驱动_获取连接FD
	// 返回值：文件描述符
	int GetLinkFD() {
		return _InternalGetLinkFD();
	}

	// 驱动_设置连接FD
	// 参数 fd：文件描述符
	void SetLinkFD(int fd) {
		_InternalSetLinkFD(fd);
	}

private:
	int _InternalConnectDriver(const std::string& procNodeAuthKey) {
#ifdef __linux__
		if (m_nFd >= 0) { return TRUE; }
		m_nFd = _rwProcMemDriver_Connect(procNodeAuthKey);
		if (m_nFd < 0) {
			return m_nFd;
		}
		_rwProcMemDriver_InitDeviceInfo(m_nFd);
		return 0;
#else 
		return -1;
#endif
	}

	BOOL _InternalDisconnectDriver() {
#ifdef __linux__
		if (m_nFd >= 0) {
			_rwProcMemDriver_Disconnect(m_nFd);
			m_nFd = -1;
			return TRUE;
		}
#endif
		return FALSE;
	}

	BOOL _InternalIsDriverConnected() {
#ifdef __linux__
		return m_nFd >= 0 ? TRUE : FALSE;
#else
		return FALSE;
#endif
	}

	BOOL _InternalHideKernelModule() {
#ifdef __linux__
		return _rwProcMemDriver_HideKernelModule(m_nFd);
#else
		return FALSE;
#endif
	}

	uint64_t _InternalOpenProcess(uint64_t pid) {
#ifdef __linux__
		return _rwProcMemDriver_OpenProcess(m_nFd, pid);
#else
		return FALSE;
#endif
	}

	BOOL _InternalReadProcessMemory(
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		void* lpBuffer,
		size_t nSize,
		size_t* lpNumberOfBytesRead = NULL,
		BOOL bIsForceRead = FALSE) {
#ifdef __linux__
		return _rwProcMemDriver_ReadProcessMemory(
			m_nFd,
			hProcess,
			lpBaseAddress,
			lpBuffer,
			nSize,
			lpNumberOfBytesRead,
			bIsForceRead);
#else
		return FALSE;
#endif
	}

	BOOL _InternalWriteProcessMemory(
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		void* lpBuffer,
		size_t nSize,
		size_t* lpNumberOfBytesWritten = NULL,
		BOOL bIsForceWrite = FALSE) {
#ifdef __linux__
		return _rwProcMemDriver_WriteProcessMemory(
			m_nFd,
			hProcess,
			lpBaseAddress,
			lpBuffer,
			nSize,
			lpNumberOfBytesWritten,
			bIsForceWrite);
#else
		return FALSE;
#endif
	}

	BOOL _InternalCloseHandle(uint64_t hProcess) {
#ifdef __linux__
		return _rwProcMemDriver_CloseHandle(m_nFd, hProcess);
#else
		return FALSE;
#endif
	}

	BOOL _InternalVirtualQueryExFull(uint64_t hProcess, BOOL showPhy, std::vector<DRIVER_REGION_INFO>& vOutput) {
#ifdef __linux__
		return _rwProcMemDriver_VirtualQueryExFull(m_nFd, hProcess, showPhy, vOutput);
#else
		return FALSE;
#endif
	}

	BOOL _InternalCheckProcessMemAddrValid(uint64_t hProcess, uint64_t lpBaseAddress) {
#ifdef __linux__
		return _rwProcMemDriver_CheckProcessMemAddrValid(m_nFd, hProcess, lpBaseAddress);
#else
		return FALSE;
#endif
	}

	BOOL _InternalGetPidList(std::vector<int>& vOutput) {
#ifdef __linux__
		return _rwProcMemDriver_GetPidList(m_nFd, vOutput);
#else
		return FALSE;
#endif
	}

	BOOL _InternalSetProcessRoot(uint64_t hProcess) {
#ifdef __linux__
		return _rwProcMemDriver_SetProcessRoot(m_nFd, hProcess);
#else
		return FALSE;
#endif
	}

	BOOL _InternalGetProcessPhyMemSize(uint64_t hProcess, uint64_t& outRss) {
#ifdef __linux__
		return _rwProcMemDriver_GetProcessPhyMemSize(m_nFd, hProcess, &outRss);
#else
		return FALSE;
#endif
	}

	BOOL _InternalGetProcessCmdline(uint64_t hProcess, char* lpOutCmdlineBuf, size_t bufSize) {
#ifdef __linux__
		return _rwProcMemDriver_GetProcessCmdline(m_nFd, hProcess, lpOutCmdlineBuf, bufSize);
#else
		return FALSE;
#endif
	}

	int _InternalGetLinkFD() {
#ifdef __linux__
		return m_nFd;
#else
		return -1;
#endif
	}

	void _InternalSetLinkFD(int fd) {
#ifdef __linux__
		m_nFd = fd;
#endif
	}

#ifdef __linux__
	#ifdef QUIET_PRINTF
	#undef TRACE
	#define TRACE(fmt, ...)
	#else
	#define TRACE(fmt, ...) printf(fmt, ##__VA_ARGS__)
	#endif
	#define MY_PATH_MAX_LEN 1024
	#define MY_TASK_COMM_LEN 16 
	enum {
		CMD_INIT_DEVICE_INFO = 1, 		// 初始化设备信息
		CMD_OPEN_PROCESS, 				// 打开进程
		CMD_READ_PROCESS_MEMORY,       	// 读取进程内存
		CMD_WRITE_PROCESS_MEMORY,      	// 写入进程内存
		CMD_CLOSE_PROCESS, 				// 关闭进程
		CMD_GET_PROCESS_MAPS_COUNT, 	// 获取进程的内存块地址数量
		CMD_GET_PROCESS_MAPS_LIST, 		// 获取进程的内存块地址列表
		CMD_CHECK_PROCESS_ADDR_PHY,		// 检查进程内存是否有物理内存位置
		CMD_GET_PID_LIST,				// 获取进程PID列表
		CMD_SET_PROCESS_ROOT,			// 提升进程权限到Root
		CMD_GET_PROCESS_RSS,			// 获取进程的物理内存占用大小
		CMD_GET_PROCESS_CMDLINE_ADDR,	// 获取进程cmdline的内存地址
		CMD_HIDE_KERNEL_MODULE,			// 隐藏驱动
	};

	#pragma pack(push,1)
	struct IoctlRequest {
		char     cmd = 0;        // 操作命令
		uint64_t param1 = 0;     // 参数1
		uint64_t param2 = 0;     // 参数2
		uint64_t param3 = 0;     // 参数3
		uint64_t bufSize = 0;    // 紧随其后的动态数据长度
	};
	struct init_device_info {
		int pid = 0;
		int tid = 0;
		char myName[MY_TASK_COMM_LEN + 1] = {0};
		char myAuxv[1024] = {0};
		int myAuxvSize = 0;
	};
	struct map_entry {
		uint64_t      start = 0;
		uint64_t      end = 0;
		unsigned char flags[4] = {0};
		char          path[MY_PATH_MAX_LEN] = {0};
	};
	struct arg_info {
		uint64_t arg_start = 0;
		uint64_t arg_end = 0;
	};
	#pragma pack(pop)

	inline ssize_t _rwProcMemDriver_MyIoctl(
		int      fd,
		char     cmd,
		uint64_t param1,
		uint64_t param2,
		uint64_t param3,
		char* buf,
		uint64_t   bufSize)
	{
		constexpr size_t headerSize = sizeof(IoctlRequest);
		size_t totalSize = headerSize + bufSize;

		static thread_local IoctlBufferPool pool;
		char* pBuf = pool.getBuffer(totalSize);
		if (!pBuf) return -ENOMEM;  

		IoctlRequest* req = reinterpret_cast<IoctlRequest*>(pBuf);
		req->cmd     = cmd;
		req->param1  = param1;
		req->param2  = param2;
		req->param3  = param3;
		req->bufSize = bufSize;
		if (bufSize > 0) {
			std::memcpy(pBuf + headerSize, buf, bufSize);
		}
		auto outRead = ::read(fd, pBuf, totalSize);
		if (bufSize > 0) {
			std::memcpy(buf, pBuf + headerSize, bufSize);
		}
		return outRead;
	}

	int _rwProcMemDriver_Connect(const std::string& procNodeAuthKey) {
	    namespace fs = std::filesystem;
		fs::path nodePath = fs::path("/proc") / procNodeAuthKey / procNodeAuthKey;
		const char* pathCStr = nodePath.c_str();
		if (chmod(pathCStr, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) != 0) {
			int err = errno;
			return -err;
		}
		int fd = open(pathCStr, O_RDWR);
		if (fd < 0) {
			int err = errno;
			return -err;
		}
		return fd;
	}

	BOOL _rwProcMemDriver_Disconnect(int nFd) {
		if (nFd < 0) { return FALSE; }
		close(nFd);
		return TRUE;
	}

	std::vector<uint8_t> generate_unique_non_zero_bytes(std::size_t count) {
		if (count == 0 || count > 255) {
			return {};
		}
		std::vector<uint8_t> pool(255);
		std::iota(pool.begin(), pool.end(), 1);
		std::random_device rd;
		std::mt19937 gen(rd());
		std::shuffle(pool.begin(), pool.end(), gen);
		return std::vector<uint8_t>(pool.begin(), pool.begin() + count);
	}

	BOOL _rwProcMemDriver_InitDeviceInfo(int nFd) {
		init_device_info oDevInfo = { 0 };
		oDevInfo.pid = getpid();
		oDevInfo.tid = gettid();
		std::vector<unsigned long> myAuxv = _GetAuxvSignature();
		int myAuxvByteCount = myAuxv.size() * sizeof(unsigned long);
		if(myAuxvByteCount == 0 || myAuxvByteCount >= sizeof(oDevInfo.myAuxv)) {
			return FALSE;
		}
		memcpy(&oDevInfo.myAuxv, reinterpret_cast<const uint8_t*>(myAuxv.data()), myAuxvByteCount);
		oDevInfo.myAuxvSize = myAuxvByteCount;
		char old_name[MY_TASK_COMM_LEN + 1] = {0};
		if (prctl(PR_GET_NAME, old_name, 0, 0, 0)) {
			return FALSE;
		}
		std::vector<uint8_t> random_name = generate_unique_non_zero_bytes(MY_TASK_COMM_LEN - 1);
		random_name.push_back(0);
		if (prctl(PR_SET_NAME, random_name.data(), 0, 0, 0)) {
			return FALSE;
		}
		strncpy(oDevInfo.myName, (char*)random_name.data(),  sizeof(oDevInfo.myName)  - 1);
		ssize_t ret = _rwProcMemDriver_MyIoctl(nFd,
									CMD_INIT_DEVICE_INFO, 0, 0, 0,
									(char*)&oDevInfo,
									sizeof(oDevInfo));

		if (prctl(PR_SET_NAME, old_name, 0, 0, 0)) {
			return FALSE;
		}
		TRACE("InitDeviceInfo ioctl return=%zd\n", ret);
		return (ret == 0) ? TRUE : FALSE;
	}

	BOOL _rwProcMemDriver_HideKernelModule(int nFd) {
		if (nFd < 0) { return FALSE; }
		ssize_t res = _rwProcMemDriver_MyIoctl(nFd, CMD_HIDE_KERNEL_MODULE, 0, 0, 0, NULL, 0);
		if (res != 0) {
			TRACE("HideKernelModule ioctl():%s\n", strerror(errno));
			return FALSE;
		}
		return TRUE;
	}

	uint64_t _rwProcMemDriver_OpenProcess(int nFd, uint64_t pid) {
		if (nFd < 0 || pid == 0) { return 0; }
		uint64_t handle = 0;
		ssize_t res = _rwProcMemDriver_MyIoctl(nFd, CMD_OPEN_PROCESS, pid, 0, 0, (char*)&handle, sizeof(handle));
		if (res != 0) {
			TRACE("OpenProcess ioctl():%s\n", strerror(errno));
			return 0;
		}
		return handle;
	}

	BOOL _rwProcMemDriver_ReadProcessMemory(
		int nFd,
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		void * lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesRead,
		BOOL bIsForceRead) {
		if (lpBaseAddress == 0 || nFd < 0 || hProcess == 0 || nSize == 0) {
			return FALSE;
		}
		static thread_local IoctlBufferPool pool;
		ssize_t outOfRead = _rwProcMemDriver_MyIoctl(nFd, CMD_READ_PROCESS_MEMORY,
			hProcess, lpBaseAddress, bIsForceRead ? 1 : 0, (char*)lpBuffer, nSize);
		if (outOfRead <= 0) {
			TRACE("ReadProcessMemory ioctl(): %s\n", strerror(errno));
			return FALSE;
		}
		if (lpNumberOfBytesRead) {
			*lpNumberOfBytesRead = outOfRead;
		}
		return TRUE;
	}

	BOOL _rwProcMemDriver_WriteProcessMemory(
		int nFd,
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		void * lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesWritten,
		BOOL bIsForceWrite) {
		if (lpBaseAddress == 0 || nFd < 0 || !hProcess || nSize == 0) {
			return FALSE;
		}
		static thread_local IoctlBufferPool pool;
		ssize_t outOfWrite = _rwProcMemDriver_MyIoctl(nFd, CMD_WRITE_PROCESS_MEMORY,
			hProcess, lpBaseAddress, bIsForceWrite ? 1 : 0, (char*)lpBuffer, nSize);
		if (outOfWrite <= 0) {
			TRACE("ReadProcessMemory ioctl(): %s\n", strerror(errno));
			return FALSE;
		}
		if (lpNumberOfBytesWritten) {
			*lpNumberOfBytesWritten = outOfWrite;
		}
		return TRUE;
	}

	BOOL _rwProcMemDriver_CloseHandle(int nFd, uint64_t hProcess) {
		if (nFd < 0 || !hProcess) { return FALSE; }
		if (_rwProcMemDriver_MyIoctl(nFd, CMD_CLOSE_PROCESS, hProcess, 0, 0, NULL, 0) != 0) {
			TRACE("CloseHandle ioctl():%s\n", strerror(errno));
			return FALSE;
		}
		return TRUE;
	}


	BOOL _rwProcMemDriver_VirtualQueryExFull(int nFd, uint64_t hProcess, BOOL showPhy, std::vector<DRIVER_REGION_INFO>& vOutput) {
		if (nFd < 0 || !hProcess) { return FALSE; }
		ssize_t count = _rwProcMemDriver_MyIoctl(nFd, CMD_GET_PROCESS_MAPS_COUNT, hProcess, 0, 0, NULL, 0);
		TRACE("VirtualQueryExFull count %zd\n", count);
		if (count <= 0) {
			TRACE("VirtualQueryExFull ioctl():%s\n", strerror(errno));
			return FALSE;
		}

		static thread_local IoctlBufferPool pool;
		uint64_t big_buf_len = sizeof(map_entry) * (count + 50);
		char*   big_buf     = pool.getBuffer(big_buf_len);
		if (!big_buf) return FALSE;
		memset(big_buf, 0, big_buf_len);
		ssize_t res = _rwProcMemDriver_MyIoctl(nFd, CMD_GET_PROCESS_MAPS_LIST, hProcess, 0, 0, big_buf, big_buf_len);
		TRACE("VirtualQueryExFull res %zd\n", res);
		if (res <= 0) {
			TRACE("VirtualQueryExFull ioctl():%s\n", strerror(errno));
			return FALSE;
		}
		auto entries = reinterpret_cast<map_entry*>(big_buf);
		for (ssize_t i = 0; i < res; ++i) {
			const map_entry& e = entries[i];
			DRIVER_REGION_INFO rInfo = {0};
			rInfo.baseaddress = e.start;
			rInfo.size        = e.end - e.start;
			bool r = e.flags[0], w = e.flags[1], x = e.flags[2];
			if (x) {
				rInfo.protection = w ? PAGE_EXECUTE_READWRITE : PAGE_EXECUTE_READ;
			} else {
				if (w)           rInfo.protection = PAGE_READWRITE;
				else if (r)      rInfo.protection = PAGE_READONLY;
				else             rInfo.protection = PAGE_NOACCESS;
			}
			// 解析 type
			rInfo.type = (e.flags[3] ? MEM_MAPPED : MEM_PRIVATE);
			// 复制名字
        	strncpy(rInfo.name, e.path, sizeof(rInfo.name)-1);
			if (showPhy) {
				DRIVER_REGION_INFO cur = rInfo;
				bool in_phy = false;
				for (uint64_t addr = e.start; addr < e.end; addr += getpagesize()) {
					if (_rwProcMemDriver_CheckProcessMemAddrValid(nFd, hProcess, addr)) {
						if (!in_phy) {
							in_phy = true;
							cur.baseaddress = addr;
						}
					} else if (in_phy) {
						in_phy = false;
						cur.size = addr - cur.baseaddress;
						vOutput.push_back(cur);
					}
				}
				if (in_phy) {
					cur.size = e.end - cur.baseaddress;
					vOutput.push_back(cur);
				}
			} else {
				vOutput.push_back(rInfo);
			}
		}
		return TRUE;
	}

	BOOL _rwProcMemDriver_CheckProcessMemAddrValid(int nFd, uint64_t hProcess, uint64_t lpBaseAddress) {
		if (nFd < 0 || !hProcess) { return FALSE; }
		if (_rwProcMemDriver_MyIoctl(nFd, CMD_CHECK_PROCESS_ADDR_PHY, hProcess, lpBaseAddress, 0, NULL, 0) == 1) {
			return TRUE;
		}
		return FALSE;
	}

	BOOL _rwProcMemDriver_GetPidList(int nFd, std::vector<int>& vOutput) {
		if (nFd < 0) return FALSE;

		ssize_t count1 = _rwProcMemDriver_MyIoctl(nFd, CMD_GET_PID_LIST, 0, 0, 0, NULL, 0);
		if (count1 <= 0) {
			return FALSE;
		}

		static thread_local IoctlBufferPool pool;
		uint64_t len  = (uint64_t)count1 * sizeof(int);
		char*    buf     = pool.getBuffer(len);
		if (!buf) {
			return FALSE;
		}
		memset(buf, 0, len);
		ssize_t count2 = _rwProcMemDriver_MyIoctl(nFd, CMD_GET_PID_LIST, 0, 0, 0, buf, len);
		if (count2 != count1) {
			return FALSE;
		}

		for (int i = 0; i < count1; i++) {
			int pid = *(int*)(buf + i * sizeof(int));
			vOutput.push_back(pid);
		}
		return TRUE;
	}

	BOOL _rwProcMemDriver_SetProcessRoot(int nFd, uint64_t hProcess) {
		if (nFd < 0 || !hProcess) { return FALSE; }
		ssize_t res = _rwProcMemDriver_MyIoctl(nFd, CMD_SET_PROCESS_ROOT, hProcess, 0, 0, NULL, 0);
		if (res != 0) {
			TRACE("SetProcessRoot ioctl():%s\n", strerror(errno));
			return FALSE;
		}
		return TRUE;
	}

	BOOL _rwProcMemDriver_GetProcessPhyMemSize(int nFd, uint64_t hProcess, uint64_t *outRss) {
		if (nFd < 0 || !hProcess) { return FALSE; }
		uint64_t out = 0;
		ssize_t res = _rwProcMemDriver_MyIoctl(nFd, CMD_GET_PROCESS_RSS, hProcess, 0, 0, (char*)&out, sizeof(out));
		if (res != 0) {
			TRACE("GetProcessPhyMemSize ioctl():%s\n", strerror(errno));
			return FALSE;
		}
		*outRss = out;
		return TRUE;
	}
	
	BOOL _rwProcMemDriver_GetProcessCmdline(int nFd, uint64_t hProcess, char *lpOutCmdlineBuf, size_t bufSize) {
		if (nFd < 0 || !hProcess || bufSize <= 0) { return FALSE; }
		arg_info aginfo = { 0 };
		ssize_t res = _rwProcMemDriver_MyIoctl(nFd, CMD_GET_PROCESS_CMDLINE_ADDR, hProcess, 0, 0, (char*)&aginfo, sizeof(aginfo));
		if (res != 0) {
			TRACE("GetProcessCmdline ioctl():%s\n", strerror(errno));
			return FALSE;
		}
		if (aginfo.arg_start == 0) {
			return FALSE;
		}
		uint64_t len = aginfo.arg_end - aginfo.arg_start;
		if (len == 0) {
			return FALSE;
		}
		if (bufSize < len) {
			len = bufSize;
		}
		memset(lpOutCmdlineBuf, 0, bufSize);
		return _rwProcMemDriver_ReadProcessMemory(nFd, hProcess, aginfo.arg_start, lpOutCmdlineBuf, len, NULL, FALSE);
	}
#endif /*__linux__*/
	std::vector<unsigned long> _GetAuxvSignature() {
		std::vector<unsigned long> sig;
		int fd = open("/proc/self/auxv", O_RDONLY);
		if (fd < 0) {
			return sig;
		}

		while (true) {
			unsigned long a_type, a_val;
			ssize_t nr;
			nr = read(fd, &a_type, sizeof(a_type));
			if (nr != sizeof(a_type)) {
				break;
			}
			nr = read(fd, &a_val, sizeof(a_val));
			if (nr != sizeof(a_val)) {
				break;
			}
			sig.push_back(a_type);
			sig.push_back(a_val);
			if (a_type == AT_NULL) {
				break;
			}
		}
		close(fd);
		return sig;
	}
private:
	int m_nFd = -1;
};

#endif /* MEMORY_READER_WRITER_H_ */

```

`rwProcMem33Module/testKo/jni/testKo.cpp`:

```cpp
#include <cstdio>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <memory>
#include <vector>
#include <dirent.h>
#include <cinttypes>
#include <algorithm>
#include "MemoryReaderWriter39.h"
#include "../../testMemSearch/jni/MapRegionType.h"


int main(int argc, char *argv[]) {
	printf(
		"======================================================\n"
		"本驱动名称: Linux ARM64 硬件读写进程内存驱动39\n"
		"本驱动接口列表：\n"
		"\t1.	驱动_打开进程: OpenProcess\n"
		"\t2.	驱动_读取进程内存: ReadProcessMemory\n"
		"\t3.	驱动_写入进程内存: WriteProcessMemory\n"
		"\t4.	驱动_关闭进程: CloseHandle\n"
		"\t5.	驱动_获取进程内存块列表: VirtualQueryExFull（可选：显示全部内存、仅显示物理内存）\n"
		"\t6.	驱动_获取进程PID列表: GetPidList\n"
		"\t7.	驱动_提升进程权限到Root: SetProcessRoot\n"
		"\t8.	驱动_获取进程物理内存占用大小: GetProcessPhyMemSize\n"
		"\t9.	驱动_获取进程命令行: GetProcessCmdline\n"
		"\t10.	驱动_隐藏驱动: HideKernelModule\n"
		"\t以上所有功能不注入、不附加进程，不打开进程任何文件，所有操作均为内核操作\n"
		"======================================================\n"
	);

	pid_t pid = getpid();
	printf("当前进程PID :%d\n", pid);

	char szBuf[1024];
	memset(szBuf, 0, sizeof(szBuf));
	snprintf(szBuf, sizeof(szBuf), "%s", "文本123");

	void *pBuf = &szBuf;
	printf("当前缓冲区内容:%s,当前缓冲区的内存地址:%p\n", szBuf, pBuf);


	printf("===========开始驱动操作演示===========================\n");

	CMemoryReaderWriter rwDriver;

	//驱动默认隐蔽通信密匙
	std::string procNodeAuthKey = "e84523d7b60d5d341a7c4d1861773ecd";
	if (argc > 1) {
		//用户自定义输入驱动隐蔽通信密匙
		procNodeAuthKey = argv[1];
	}
	printf("Connecting rwDriver auth key:%s\n", procNodeAuthKey.c_str());

	//连接驱动
	int err = rwDriver.ConnectDriver(procNodeAuthKey.c_str());
	if (err) {
		printf("Connect rwDriver failed. error:%d\n", err);
		fflush(stdout);
		return 0;
	}
	
	//驱动_打开进程
	uint64_t hProcess = rwDriver.OpenProcess(pid);
	printf("调用驱动 OpenProcess 返回值:%" PRIu64 "\n", hProcess);
	if (!hProcess) {
		printf("调用驱动 OpenProcess 失败\n");
		fflush(stdout);
		return 0;
	}

	//驱动_读取进程内存
	char readBuf[1024] = { 0 };
	size_t real_read = 0;
	BOOL read_res = rwDriver.ReadProcessMemory(hProcess, (uint64_t)pBuf, &readBuf, sizeof(readBuf), &real_read, FALSE);
	printf("调用驱动 ReadProcessMemory 读取内存地址:%p,返回值:%d,读取到的内容:%s,实际读取大小:%zu\n", pBuf, read_res, readBuf, real_read);

	//驱动_写入进程内存
	snprintf(readBuf, sizeof(readBuf), "%s", "写入456");
	size_t real_write = 0;
	BOOL write_res = rwDriver.WriteProcessMemory(hProcess, (uint64_t)pBuf, &readBuf, sizeof(readBuf), &real_write, FALSE);
	printf("调用驱动 WriteProcessMemory 写入内存地址:%p,返回值:%d,写入的内容:%s,实际写入大小:%zu\n", pBuf, write_res, readBuf, real_write);
	printf("当前缓冲区内容 :%s,当前缓冲区的内存地址:%p\n", szBuf, pBuf);


	//驱动_获取进程内存块列表（显示全部内存）
	std::vector<DRIVER_REGION_INFO> vMaps;
	BOOL b = rwDriver.VirtualQueryExFull(hProcess, FALSE, vMaps);
	printf("调用驱动 VirtualQueryExFull(显示全部内存) 返回值:%d\n", b);

	//显示进程内存块地址列表
	for (DRIVER_REGION_INFO rinfo : vMaps) {
		printf("---Start:%p,Size:%" PRIu64 ",Type:%s,Name:%s\n", (void*)rinfo.baseaddress, rinfo.size, MapsTypeToString(&rinfo).c_str(), rinfo.name);
	}

	//驱动_获取进程内存块列表（仅显示物理内存）
	vMaps.clear();
	printf("正在调用驱动接口 VirtualQueryExFull（仅显示物理内存），该操作可能耗时较长，请耐心等待…\n");
	b = rwDriver.VirtualQueryExFull(hProcess, TRUE, vMaps);
	printf("调用驱动 VirtualQueryExFull(仅显示物理内存) 返回值:%d\n", b);

	//显示进程内存块地址列表
	for (DRIVER_REGION_INFO rinfo : vMaps) {
		printf("+++Start:%p,Size:%" PRIu64 ",Type:%s,Name:%s\n", (void*)rinfo.baseaddress, rinfo.size, MapsTypeToString(&rinfo).c_str(), rinfo.name);
	}

	//驱动_获取进程物理内存占用大小
	uint64_t outRss = 0;
	b = rwDriver.GetProcessPhyMemSize(hProcess, outRss);
	printf("调用驱动 GetProcessPhyMemSize 返回值:%d,当前进程物理内存占用大小:%" PRIu64 "KB\n", b, outRss);


	//驱动_获取进程命令行
	char cmdline[100] = { 0 };
	b = rwDriver.GetProcessCmdline(hProcess, cmdline, sizeof(cmdline));
	printf("调用驱动 GetProcessCmdline 返回值:%d,当前进程命令行:%s\n", b, cmdline);

	//驱动_关闭进程
	rwDriver.CloseHandle(hProcess);
	printf("调用驱动 CloseHandle %" PRIu64 "\n", hProcess);


	//驱动_获取进程PID列表
	std::vector<int> vPID;
	b = rwDriver.GetPidList(vPID);
	printf("调用驱动 GetPidList 返回值:%d, size:%zu\n", b, vPID.size());
	printf("打印进程列表信息(仅演示最后10个进程)\n");
	for(size_t i = (vPID.size() > 10 ? vPID.size() - 10 : 0); i < vPID.size(); ++i) {
		int pid = vPID[i];
		//驱动_打开进程
		uint64_t hProcess = rwDriver.OpenProcess(pid);
		if (!hProcess) { continue; }

		//驱动_获取进程物理内存占用大小
		uint64_t outRss = 0;
		rwDriver.GetProcessPhyMemSize(hProcess, outRss);

		//驱动_获取进程命令行
		char cmdline[100] = { 0 };
		rwDriver.GetProcessCmdline(hProcess, cmdline, sizeof(cmdline));

		if (!!strstr(cmdline, "calc")) { //将计算器进程提升至ROOT
			//驱动_提升进程权限到Root
			BOOL b = rwDriver.SetProcessRoot(hProcess);
			printf("调用驱动 SetProcessRoot 返回值:%d\n", b);
		}

		//驱动_关闭进程
		rwDriver.CloseHandle(hProcess);

		printf("pid:%d,rss:%" PRIu64 ",cmdline:%s\n", pid, outRss, cmdline);
	}

	//驱动_隐藏驱动
	b = rwDriver.HideKernelModule();
	printf("调用驱动 HideKernelModule 返回值:%d\n", b);

	fflush(stdout);
	return 0;
}
```

`rwProcMem33Module/testMemSearch/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_CPPFLAGS += -std=c++20
LOCAL_CFLAGS += -fPIE
LOCAL_CFLAGS += -fvisibility=hidden
LOCAL_LDFLAGS += -fPIE -pie
LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true
LOCAL_MODULE    := testMemSearch.out
LOCAL_SRC_FILES :=  testMemSearch.cpp

include $(BUILD_EXECUTABLE)

```

`rwProcMem33Module/testMemSearch/jni/Application.mk`:

```mk
APP_ABI :=  arm64-v8a
APP_STL := c++_static
```

`rwProcMem33Module/testMemSearch/jni/MapRegionHelper.h`:

```h
//
// Created by abcz316 on 2020/2/26.
//

#ifndef MEMSEARCHER_MAPREGIONHELPER_H
#define MEMSEARCHER_MAPREGIONHELPER_H
#include "../../testKo/jni/MemoryReaderWriter39.h"
#include "MemSearchKit/MemSearchKitUmbrella.h"
#include "ProcMapsFileReader.h"

enum RegionType {
    REGION_C_HEAP = 1,
    REGION_JAVA_HEAP,
    REGION_C_ALLOC,
    REGION_C_DATA,
    REGION_C_BSS,
    REGION_ANONYMOUS,
    REGION_STACK,
    REGION_CODE_APP,
    REGION_CODE_SYS,
    REGION_JAVA,
    REGION_BAD,
    /*REGION_PPSSPP,*/
    REGION_ASHMEM,
    REGION_VIDEO,
    REGION_OTHER,
    REGION_ALL,
	REGION_X,      //执行命令内存 r0xp
	REGION_R0_0,  //可读非执行内存 r0_0
	REGION_RW_0  //可读可写非执行内存 rw_0
};

struct MemRegionItem {
	DRIVER_REGION_INFO baseInfo;
	std::string belongSoPath;
};

// 获取进程的指定内存范围列表
static BOOL GetMemRegions(IMemReaderWriterProxy *IReadWriteProxy, uint64_t hProcess, RegionType type, std::vector<MemRegionItem> & vOutput) {
	std::vector<DRIVER_REGION_INFO> vMapsList;
	IReadWriteProxy->VirtualQueryExFull(hProcess, FALSE, vMapsList);
	if (vMapsList.empty()) {
		return FALSE;
	}
	std::string lastSoPath;
	for (auto &rinfo : vMapsList) {
		if((strstr(rinfo.name, "/data/app/") || strstr(rinfo.name, "/data/data/")) && strstr(rinfo.name, ".so")) {
			lastSoPath = rinfo.name;
		}
		//printf("rinfo.name : %s\n", rinfo.name);
		bool vaild = false;
		if(type == REGION_ALL) {
			vaild = true;
		} else if(type == REGION_X) {
			vaild = is_r0xp(&rinfo);
		} else if(type == REGION_R0_0) {
			vaild = is_r0_0(&rinfo);
		} else if(type == REGION_RW_0) {
			vaild = is_rw_0(&rinfo);
		} else if(strlen(rinfo.name) == 0) {
			vaild = type == REGION_ANONYMOUS;
		} else if(strstr(rinfo.name, "/dev/asheme/")) {
			vaild = type == REGION_ASHMEM;
		} else if(strstr(rinfo.name, "/system/fonts/")) {
			vaild = type == REGION_BAD;
		} else if(strstr(rinfo.name, ".so") && is_r0xp(&rinfo)) {
			vaild = (strstr(rinfo.name, "/data/app/") || strstr(rinfo.name, "/data/data/")) ? type == REGION_CODE_APP : type == REGION_CODE_SYS;
		} else if(strstr(rinfo.name, "[anon:libc_malloc") ||  strstr(rinfo.name, "[anon:scudo:")) {
			vaild = type == REGION_C_ALLOC;
		} else if(strstr(rinfo.name, "[anon:.bss")) {
			vaild = type == REGION_C_BSS;
		} else if(strstr(rinfo.name, "/data/app/") && strstr(rinfo.name, ".so")) {
			vaild = type == REGION_C_DATA;
		} else if(strstr(rinfo.name, "[heap]")) {
			vaild = type == REGION_C_HEAP;
		} else if(strstr(rinfo.name, "dalvik-allocation") || strstr(rinfo.name, "dalvik-main") || strstr(rinfo.name, "dalvik-large") 
			|| strstr(rinfo.name, "dalvik-free")) {
			vaild = type == REGION_JAVA_HEAP;
		} else if(strstr(rinfo.name, "dalvik-CompilerMetadata") || strstr(rinfo.name, "dalvik-LinearAlloc") 
			|| strstr(rinfo.name, "dalvik-indirect") || strstr(rinfo.name, "dalvik-rosalloc") || strstr(rinfo.name, "dalvik-card") 
			|| strstr(rinfo.name, "dalvik-mark") ||  (strstr(rinfo.name, "dalvik-")  && strstr(rinfo.name, "space") )) {
			vaild = type == REGION_JAVA;
		} else if(strstr(rinfo.name, "[stack")) {
			vaild = type == REGION_STACK;
		} else if(strstr(rinfo.name, "/dev/kgsl-3d0")) {
			vaild = type == REGION_VIDEO;
		} else {
			vaild = type == REGION_OTHER;
		}
		if(vaild) {
			MemRegionItem item;
			memcpy(&item.baseInfo, &rinfo, sizeof(rinfo));
			item.belongSoPath = lastSoPath;
			vOutput.push_back(item);
		}
	}
	return TRUE;
}

// 获取内存模块第一个起始地址
static BOOL GetModuleFirstAddr(IMemReaderWriterProxy *IReadWriteProxy, uint64_t hProcess, const std::string & moduleName, uint64_t & firstAddr) {
	std::vector<DRIVER_REGION_INFO> vMapsList;
	IReadWriteProxy->VirtualQueryExFull(hProcess, FALSE, vMapsList);
	if (vMapsList.size() == 0) {
		//无内存
		return FALSE;
	}
	const char* targetModuleName = moduleName.c_str();
	for(auto & rinfo : vMapsList) {
		if(strstr(rinfo.name, targetModuleName)) {
			firstAddr = rinfo.baseaddress;
			return TRUE;
		}
	}
	return FALSE;
}

// 获取内存模块执行区域内存范围列表
static BOOL GetModuleExecAreaSection(IMemReaderWriterProxy *IReadWriteProxy, uint64_t hProcess, const std::string & moduleName, std::vector<DRIVER_REGION_INFO> & vOut) {
	std::vector<DRIVER_REGION_INFO> vMapsList;
	IReadWriteProxy->VirtualQueryExFull(hProcess, FALSE, vMapsList);
	if (vMapsList.size() == 0) {
		return FALSE;
	}
	const char* targetModuleName = moduleName.c_str();

	std::copy_if(vMapsList.begin(), vMapsList.end(), std::back_inserter(vOut), 
		[&](const DRIVER_REGION_INFO& rinfo) {
			return is_r0xp(&rinfo) && strstr(rinfo.name, targetModuleName);
		}
	);

	return TRUE;
}

// 获取内存模块数据区域内存范围列表
static BOOL GetModuleDataAreaSection(IMemReaderWriterProxy *IReadWriteProxy, uint64_t hProcess, const std::string & moduleName, std::vector<DRIVER_REGION_INFO> & vOut) {
	std::vector<DRIVER_REGION_INFO> vMapsList;
	IReadWriteProxy->VirtualQueryExFull(hProcess, FALSE, vMapsList);
	if (vMapsList.size() == 0) {
		return FALSE;
	}

	const char* targetModuleName = moduleName.c_str();

	bool bReadCheckDataSec = false;
	bool bLastIsDataSec = false;

	for (size_t x = 0; x < vMapsList.size(); x++) {
		auto & rinfo = vMapsList[x];

		if (bLastIsDataSec || bReadCheckDataSec) {
			bool bCurDataSection = is_rw_0(&rinfo) || is_r__0(&rinfo) || is_0w_0(&rinfo); // 减少了一个 is_rw_0 的调用

			if (bReadCheckDataSec && bCurDataSection) {
				bLastIsDataSec = true;
			}
			bReadCheckDataSec = false;

			if (bCurDataSection) {
				//数据段中
				vOut.push_back(rinfo);
				continue;
			}
			//数据中断了
			bLastIsDataSec = false;
		}

		if (is_r0xp(&rinfo) && strstr(rinfo.name, targetModuleName)) {
			bReadCheckDataSec = true;
		}
	}
	return !vOut.empty();
}


// 获取内存模块的内存地址范围
static BOOL GetModuleRangeAddr(IMemReaderWriterProxy *IReadWriteProxy, uint64_t hProcess, const std::string & moduleName,
	uint64_t & outModuleStartAddr, uint64_t & outModuleEndAddr) {

	//获取so的内存范围
	const char * targetModuleName = moduleName.c_str();
	uint64_t firstAddr = 0;
	std::vector<DRIVER_REGION_INFO> vExecAreaMemSec;
	std::vector<DRIVER_REGION_INFO> vDataAreaMemSec;
	GetModuleFirstAddr(IReadWriteProxy, hProcess, targetModuleName, firstAddr);
	GetModuleExecAreaSection(IReadWriteProxy, hProcess, targetModuleName, vExecAreaMemSec);
	GetModuleDataAreaSection(IReadWriteProxy, hProcess, targetModuleName, vDataAreaMemSec);
	if (!vExecAreaMemSec.size() || !vDataAreaMemSec.size()) {
		//printf("GetModuleExecAreaSection || GetModuleDataAreaSection失败");
		return FALSE;
	}
	outModuleStartAddr = min(vExecAreaMemSec[0].baseaddress, vDataAreaMemSec[0].baseaddress);
	outModuleStartAddr = min(outModuleStartAddr, firstAddr);
	outModuleEndAddr = max(vExecAreaMemSec[vExecAreaMemSec.size() - 1].baseaddress,
		vDataAreaMemSec[vDataAreaMemSec.size() - 1].baseaddress);
	return TRUE;
}


#endif //MEMSEARCHER_MAPREGIONHELPER_H

```

`rwProcMem33Module/testMemSearch/jni/MapRegionType.h`:

```h
//
// Created by abcz316 on 2020/2/26.
//

#ifndef MEMSEARCHER_MAPREGIONTYPE_H
#define MEMSEARCHER_MAPREGIONTYPE_H
#include "../../testKo/jni/MemoryReaderWriter39.h"
#ifndef __linux__
#include <windows.h>
#endif

static inline std::string MapsTypeToString(const DRIVER_REGION_INFO* rInfo) {
	std::string type;
	switch (rInfo->protection) {
		case PAGE_NOACCESS:
			type = "---";
			break;

		case PAGE_READONLY:
			type = "r--";
			break;

		case PAGE_READWRITE:
			type = "rw-";
			break;

		case PAGE_WRITECOPY:
			type = "-w-";
			break;

		case PAGE_EXECUTE:
			type = "--x";
			break;

		case PAGE_EXECUTE_READ:
			type = "r-x";
			break;

		case PAGE_EXECUTE_READWRITE:
			type = "rwx";
			break;

		default:
			break;
	}

	if (rInfo->type == MEM_PRIVATE) {
		type += "p";
	} else {
		type += "s";
	}
	return type;
}

static inline bool StringToMapsType(const std::string& type,
									uint32_t& out_protection,
									uint32_t& out_type) {
	if (type.length() < 4) {
		return false;
	}
	std::string head = type.substr(0, 3);
	if (head == "---") {
		out_protection = PAGE_NOACCESS;
	} else if (head == "r--") {
		out_protection = PAGE_READONLY;
	} else if (head == "rw-") {
		out_protection = PAGE_READWRITE;
	} else if (head == "-w-") {
		out_protection = PAGE_WRITECOPY;
	} else if (head == "--x") {
		out_protection = PAGE_EXECUTE;
	} else if (head == "r-x") {
		out_protection = PAGE_EXECUTE_READ;
	} else if (head == "rwx") {
		out_protection = PAGE_EXECUTE_READWRITE;
	} else {
		return false;
	}
	if (type[3] == 'p') {
		out_type = MEM_PRIVATE;
	} else if (type[3] == 's') {
		out_type = MEM_MAPPED;
	}
	return true;
}

static inline int is__000(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_NOACCESS) {
		return 1;
	}
	return 0;
}

static inline int is_rw_p(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_READWRITE) {
		if (rInfo->type == MEM_PRIVATE) {
			return 1;
		}
	}
	return 0;
}

static inline int is_rw_s(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_READWRITE) {
		if (rInfo->type == MEM_MAPPED) {
			return 1;
		}
	}
	return 0;
}

static inline int is_rw00(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_READWRITE) {
		return 1;
	}
	return 0;
}

static inline int is_rw_0(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_READWRITE) {
		return 1;
	}
	return 0;
}

static inline int is_r__p(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_READONLY) {
		if (rInfo->type == MEM_PRIVATE) {
			return 1;
		}
	}
	return 0;
}

static inline int is_r__s(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_READONLY) {
		if (rInfo->type == MEM_MAPPED) {
			return 1;
		}
	}
	return 0;
}

static inline int is_r0xp(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_EXECUTE_READ ||
		rInfo->protection == PAGE_EXECUTE_READWRITE) {
		if (rInfo->type == MEM_PRIVATE) {
			return 1;
		}
	}
	return 0;
}

static inline int is_r0_0(const DRIVER_REGION_INFO* rInfo) {
	if ((rInfo->protection != PAGE_EXECUTE_READ) &&
		(rInfo->protection != PAGE_EXECUTE_READWRITE) &&
		(rInfo->protection != PAGE_NOACCESS)) {
		return 1;
	}
	return 0;
}

static inline int is_r__0(const DRIVER_REGION_INFO* rInfo) {
	if ((rInfo->protection != PAGE_EXECUTE_READ) &&
		(rInfo->protection != PAGE_EXECUTE_READWRITE) &&
		(rInfo->protection != PAGE_NOACCESS)) {
		return 1;
	}
	return 0;
}

static inline int is_0w_0(const DRIVER_REGION_INFO* rInfo) {
	return is_r0_0(rInfo);
}

static inline int is_0w00(const DRIVER_REGION_INFO* rInfo) {
	if ((rInfo->protection == PAGE_READWRITE) ||
		(rInfo->protection == PAGE_WRITECOPY) ||
		(rInfo->protection == PAGE_EXECUTE_READWRITE)) {
		return 1;
	}
	return 0;
}

static inline int is_r0_p(const DRIVER_REGION_INFO* rInfo) {
	if ((rInfo->protection == PAGE_READONLY) ||
		(rInfo->protection == PAGE_READWRITE)) {
		if (rInfo->type == MEM_PRIVATE) {
			return 1;
		}
	}
	return 0;
}

static inline int is_r_xp(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_EXECUTE_READ) {
		if (rInfo->type == MEM_PRIVATE) {
			return 1;
		}
	}
	return 0;
}

static inline int is_r_xs(const DRIVER_REGION_INFO* rInfo) {
	if (rInfo->protection == PAGE_EXECUTE_READ) {
		if (rInfo->type == MEM_MAPPED) {
			return 1;
		}
	}
	return 0;
}

static inline int is_0_00(const DRIVER_REGION_INFO* rInfo) {
	return is_r__p(rInfo) || is_r__s(rInfo) || is_r_xp(rInfo) || is_r_xs(rInfo);
}

static inline int is_Ch(const DRIVER_REGION_INFO* rInfo) {
	if (is_rw_p(rInfo)) {
		if (strcmp(rInfo->name, "[heap]") == 0) {
			return 1;
		}
	}
	return 0;
}

static inline int is_Jh(const DRIVER_REGION_INFO* rInfo) {
	if (is_rw_p(rInfo)) {
		// if(strstr(rInfo->name,"/dev/ashmem/dalvik") != 0)
		if (strstr(rInfo->name, "/dev/ashmem/") != 0) {
			return 1;
		}
	}
	return 0;
}
static inline int is_S(const DRIVER_REGION_INFO* rInfo) {
	if (strstr(rInfo->name, "stack") != 0) {
		if (rInfo->name[0] == '[') {
			if (rInfo->name[strlen(rInfo->name) - 1] == ']') {
				return 1;
			}
		}
	}
	return 0;
}

static inline int is_A(const DRIVER_REGION_INFO* rInfo) {
	if (is_r0_0(rInfo)) {
		if (rInfo->name[0] == '\x00') {
			return 1;
		}
	}
	return 0;
}

static inline int is_As(const DRIVER_REGION_INFO* rInfo) {
	if (is_rw_s(rInfo)) {
		if (strstr(rInfo->name, "/dev/ashmem/") != 0) {
			if (strstr(rInfo->name, "/dev/ashmem/dalvik") == 0) {
				return 1;
			}
		}
	}
	return 0;
}

static inline int is_B(const DRIVER_REGION_INFO* rInfo) {
	if (is_r0_0(rInfo)) {
		if (strstr(rInfo->name, "/system/fonts/") != 0) {
			return 1;
		} else if (strstr(rInfo->name, "kgsl-3d0") != 0) {
			return 1;
		}
	}

	return 0;
}

static inline int is_Jb(const DRIVER_REGION_INFO* rInfo) {
	if (is_r0_p(rInfo)) {
		if (strstr(rInfo->name, "system@framework@boot.oat") != 0) {
			return 1;
		} else if (strstr(rInfo->name, "zygote") != 0) {
			return 1;
		} else if (strstr(rInfo->name, "Zygote") != 0) {
			return 1;
		}
	}
	return 0;
}

static inline int is_Xs(const DRIVER_REGION_INFO* rInfo) {
	if (strcmp(rInfo->name, "[vdso]") == 0) {
		return 1;
	}

	if (is_r_xp(rInfo)) {
		if (strstr(rInfo->name, "dalvik") != 0) {
			return 1;
		} else if (memcmp(rInfo->name, "/system", 7) == 0) {
			return 1;
		}
	}
	return 0;
}

#endif	// MEMSEARCHER_MAPREGIONTYPE_H

```

`rwProcMem33Module/testMemSearch/jni/MemSearchKit/MemSearchKitCompVal.h`:

```h
#ifndef MEM_SEARCH_KIT_COMPARE_VALUE_H_
#define MEM_SEARCH_KIT_COMPARE_VALUE_H_
#include <memory>
#include <vector>
#ifdef __linux__
#include <unistd.h>
#endif

#ifndef min
#define min(a,b) (((a)<(b))?(a):(b))
#endif
#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif
namespace MemorySearchKit {
	namespace CompareValue {
		/*
		寻找精确数值
		使用方法:
		dwAddr：要搜索的缓冲区地址
		dwLen：要搜索的缓冲区大小
		value: 要搜索的数值
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr：存放搜索完成的结果地址
		*/
		template<typename T> static inline void FindValue(size_t dwAddr, size_t dwLen, T value, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			vOutputAddr.clear();

			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < sizeof(T)) {
					//要搜索的数据已经小于T的长度了
					break;
				}

				T* pData = (T*)(dwAddr + i);

				if (*pData == value) {
					vOutputAddr.push_back((size_t)((size_t)dwAddr + (size_t)i));
				}
				continue;
			}
		}

		/*
		寻找大于的数值
		使用方法:
		dwAddr：要搜索的缓冲区地址
		dwLen：要搜索的缓冲区大小
		value: 要搜索大于的数值
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr：存放搜索完成的结果地址
		*/
		template<typename T> static inline void FindGreater(size_t dwAddr, size_t dwLen, T value, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			vOutputAddr.clear();

			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < sizeof(T)) {
					//要搜索的数据已经小于T的长度了
					break;
				}

				T* pData = (T*)(dwAddr + i);
				if (*pData > value) {
					vOutputAddr.push_back((size_t)((size_t)dwAddr + (size_t)i));
				}
				continue;
			}
		}



		/*
		寻找小于的数值
		使用方法:
		dwAddr：要搜索的缓冲区地址
		dwLen：要搜索的缓冲区大小
		value: 要搜索小于的char数值
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr：存放搜索完成的结果地址
		*/
		template<typename T> static inline void FindLess(size_t dwAddr, size_t dwLen, T value, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			vOutputAddr.clear();

			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < sizeof(T)) {
					//要搜索的数据已经小于T的长度了
					break;
				}

				T* pData = (T*)(dwAddr + i);
				if (*pData < value) {
					vOutputAddr.push_back((size_t)((size_t)dwAddr + (size_t)i));
				}
				continue;
			}
		}
		/*
		寻找两者之间的数值
		使用方法:
		dwAddr：要搜索的缓冲区地址
		dwLen：要搜索的缓冲区大小
		value1: 要搜索的数值1
		value2: 要搜索的数值2
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr：存放搜索完成的结果地址
		*/
		template<typename T> static inline void FindBetween(size_t dwAddr, size_t dwLen, T value1, T value2, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			vOutputAddr.clear();

			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < sizeof(T)) {
					//要搜索的数据已经小于T的长度了
					break;
				}

				T* pData = (T*)(dwAddr + i);
				T cData = *pData;

				if (cData >= value1 && cData <= value2) {
					vOutputAddr.push_back((size_t)((size_t)dwAddr + (size_t)i));
				}
				continue;
			}
		}

		/*
		寻找增加的数值
		使用方法:
		dwOldAddr：要搜索的旧数据缓冲区地址
		dwNewAddr：要搜索的新数据缓冲区地址
		dwLen：要搜索的缓冲区大小
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr：存放搜索完成的结果地址
		*/
		template<typename T> static inline void FindUnknowAdd(size_t dwOldAddr, size_t dwNewAddr, size_t dwLen, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			vOutputAddr.clear();

			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < sizeof(T)) {
					//要搜索的数据已经小于T的长度了
					break;
				}

				T* pOldData = (T*)(dwOldAddr + i);
				T* pNewData = (T*)(dwNewAddr + i);
				if (*pNewData > *pOldData) {
					vOutputAddr.push_back((size_t)((size_t)dwOldAddr + (size_t)i));
				}
				continue;
			}
		}

		/*
		寻找减少的数值
		使用方法:
		dwOldAddr：要搜索的旧数据缓冲区地址
		dwNewAddr：要搜索的新数据缓冲区地址
		dwLen：要搜索的缓冲区大小
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr：存放搜索完成的结果地址
		*/
		template<typename T> static inline void FindUnknowSum(size_t dwOldAddr, size_t dwNewAddr, size_t dwLen, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			vOutputAddr.clear();

			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < sizeof(T)) {
					//要搜索的数据已经小于T的长度了
					break;
				}

				T* pOldData = (T*)(dwOldAddr + i);
				T* pNewData = (T*)(dwNewAddr + i);
				if (*pNewData < *pOldData) {
					vOutputAddr.push_back((size_t)((size_t)dwOldAddr + (size_t)i));
				}
				continue;
			}
		}
	
		/*
		寻找变动的数值
		使用方法:
		dwOldAddr：要搜索的旧数据缓冲区地址
		dwNewAddr：要搜索的新数据缓冲区地址
		dwLen：要搜索的缓冲区大小
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr：存放搜索完成的结果地址
		*/
		template<typename T> static inline void FindChanged(size_t dwOldAddr, size_t dwNewAddr, size_t dwLen, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			vOutputAddr.clear();

			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < sizeof(T)) {
					//要搜索的数据已经小于T的长度了
					break;
				}

				T* pOldData = (T*)(dwOldAddr + i);
				T* pNewData = (T*)(dwNewAddr + i);
				if (*pNewData != *pOldData) {
					vOutputAddr.push_back((size_t)((size_t)dwOldAddr + (size_t)i));
				}
				continue;
			}
		}
		/*
		寻找未变动的数值
		使用方法:
		dwOldAddr：要搜索的旧数据缓冲区地址
		dwNewAddr：要搜索的新数据缓冲区地址
		dwLen：要搜索的缓冲区大小
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr：存放搜索完成的结果地址
		*/
		template<typename T> static inline void FindNoChange(size_t dwOldAddr, size_t dwNewAddr, size_t dwLen, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			vOutputAddr.clear();

			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < sizeof(T)) {
					//要搜索的数据已经小于T的长度了
					break;
				}

				T* pOldData = (T*)(dwOldAddr + i);
				T* pNewData = (T*)(dwNewAddr + i);
				if (*pNewData == *pOldData) {
					vOutputAddr.push_back((size_t)((size_t)dwOldAddr + (size_t)i));
				}
				continue;
			}
		}



		/*
		寻找字节集
		dwAddr: 要搜索的缓冲区地址
		dwLen: 要搜索的缓冲区长度
		bMask: 要搜索的字节集
		szMask: 要搜索的字节集模糊码（xx=已确定字节，??=可变化字节，支持x?、?x）
		nMaskLen: 要搜索的字节集长度
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr: 搜索出来的结果地址存放数组
		使用方法：
		std::vector<size_t> vAddr;
		FindFeaturesBytes((size_t)lpBuffer, dwBufferSize, (PBYTE)"\x8B\xE8\x00\x00\x00\x00\x33\xC0\xC7\x06\x00\x00\x00\x00\x89\x86\x40", "xxxx??xx?xx?xxxxx",17,1,vAddr);
		*/
		static inline void FindFeaturesBytes(size_t dwAddr, size_t dwLen, unsigned char *bMask, const char* szMask, size_t nMaskLen, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			vOutputAddr.clear();
			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < nMaskLen) {
					//要搜索的数据已经小于特征码的长度了
					break;
				}
				unsigned char* pData = (unsigned char*)(dwAddr + i);
				unsigned char*bTemMask = bMask;
				const char* szTemMask = szMask;

				bool bContinue = false;
				for (; *szTemMask; szTemMask += 2, ++pData, ++bTemMask) {
					if ((*szTemMask == 'x') && (*(szTemMask + 1) == 'x') && ((*pData) != (*bTemMask))) {
						bContinue = true;
						break;
					} else if ((*szTemMask == 'x') && (*(szTemMask + 1) == '?') && ((((*pData) >> 4) & 0xFu) != (((*bTemMask) >> 4) & 0xFu))) {
						bContinue = true;
						break;
					} else if ((*szTemMask == '?') && (*(szTemMask + 1) == 'x') && (((*pData) & 0xFu) != ((*bTemMask) & 0xFu))) {
						bContinue = true;
						break;
					}
				}
				if (bContinue) {
					continue;
				}

				if ((*szTemMask) == '\x00') {
					vOutputAddr.push_back((size_t)((size_t)dwAddr + (size_t)i));
				}
			}
		}
		/*
		寻找字节集
		dwWaitSearchAddress: 要搜索的缓冲区地址
		dwLen: 要搜索的缓冲区长度
		bForSearch: 要搜索的字节集
		ifLen: 要搜索的字节集长度
		nScanAlignBytesCount扫描的对齐字节数
		vOutputAddr: 搜索出来的结果地址存放数组
		使用方法：
		std::vector<size_t> vAddr;
		FindFeaturesBytes((size_t)lpBuffer, dwBufferSize, (PBYTE)"\x8B\xE8\x00\x00\x00\x00\x33\xC0\xC7\x06\x00\x00\x00\x00\x89\x86\x40", 17,1,vAddr);
		*/
		static inline void FindBytes(size_t dwWaitSearchAddress, size_t dwLen, unsigned char *bForSearch, size_t ifLen, size_t nScanAlignBytesCount, std::vector<size_t> & vOutputAddr) {
			for (size_t i = 0; i < dwLen; i += nScanAlignBytesCount) {
				if ((dwLen - i) < ifLen) {
					//要搜索的数据已经小于特征码的长度了
					break;
				}
				unsigned char* pData = (unsigned char*)(dwWaitSearchAddress + i);
				unsigned char*bTemForSearch = bForSearch;

				bool bContinue = false;
				for (size_t y = 0; y < ifLen; y++, ++pData, ++bTemForSearch) {
					if (*pData != *bTemForSearch) {
						bContinue = true;
						break;
					}
				}
				if (bContinue) {
					continue;
				}
				vOutputAddr.push_back((size_t)((size_t)dwWaitSearchAddress + (size_t)i));
			}
		}
	}
}

#endif /* MEM_SEARCH_KIT_COMPARE_VALUE_H_ */


```

`rwProcMem33Module/testMemSearch/jni/MemSearchKit/MemSearchKitCore.h`:

```h
#ifndef MEM_SEARCH_KIT_CORE_H_
#define MEM_SEARCH_KIT_CORE_H_
#include <memory>
#include <vector>
#include <atomic>
#include <mutex>
#include <thread>
#include <sstream>
#include <functional>
#include <assert.h>
#include <type_traits>
#ifdef __linux__
#include <unistd.h>
#endif
#include "../../../testKo/jni/IMemReaderWriterProxy.h"
#include "MemSearchKitSafeWorkBlockWrapper.h"
#include "MemSearchKitSafeVector.h"
#include "MemSearchKitSafeMap.h"
#include "MemSearchKitCompVal.h"
#include "MemSearchKitString.h"

namespace MemorySearchKit {
	const int TASK_BLOCK_SIZE = 1024 * 1024 * 10;

	struct COPY_MEM_INFO {
		uint64_t npSectionAddr = 0; //进程内存地址
		uint64_t nSectionSize = 0; //区域大小
		std::shared_ptr<unsigned char> spSaveMemBuf = nullptr; //保存到本地缓冲区的内存字节数据
	};
	struct ADDR_RESULT_INFO {
		uint64_t addr = 0; //进程内存地址
		uint64_t size = 0; //大小
		std::shared_ptr<unsigned char> spSaveData = nullptr; //保存到本地缓冲区的内存字节数据
	};

	template<typename T> struct BATCH_BETWEEN_VAL {
		T val1 = {}; //批量搜索值在两值之间的值1
		T val2 = {}; //批量搜索值在两值之间的值2
		union {
			char chCtx;
			short sCtx;
			int nCtx;
			long lCtx;
			unsigned long ulCtx;
			unsigned long long ullCtx;
			uint16_t u16Ctx;
			uint32_t u32Ctx;
			uint64_t u64Ctx;
			int16_t i16Ctx;
			int32_t i32Ctx;
			int64_t i64Ctx = 0;
		} markContext;  //附带的上下文，可传递消息
	};
	template<typename T> struct BATCH_BETWEEN_VAL_ADDR_RESULT {
		ADDR_RESULT_INFO addrInfo; //结果地址
		BATCH_BETWEEN_VAL<T> originalCondition; //原始搜索条件
	};

	enum SCAN_TYPE {
		ACCURATE_VAL = 0,	//精确数值
		LARGER_THAN_VAL,	//值大于
		LESS_THAN_VAL,		//值小于
		BETWEEN_VAL,		//值在两值之间
		ADD_UNKNOW_VAL,		//值增加了未知值
		ADD_ACCURATE_VAL,	//值增加了精确值
		SUB_UNKNOW_VAL,		//值减少了未知值
		SUB_ACCURATE_VAL,	//值减少了精确值
		CHANGED_VAL,		//变动了的数值
		UNCHANGED_VAL,		//未变动的数值
	};

	enum SCAN_VALUE_TYPE {
		_1 = 0,			// 1字节
		_2,				// 2字节
		_4,				// 4字节
		_8,				// 8字节
		_FLOAT = _4,	// 单精度浮点数
		_DOUBLE = _8,	// 双精度浮点数
	};

	enum MEM_SEARCH_STATUS {
		MEM_SEARCH_SUCCESS = 0, //内存搜索成功
		MEM_SEARCH_FAILED_INVALID_PARAM, //无效的参数
		MEM_SEARCH_FAILED_ALLOC_MEM, //申请内存失败
		MEM_SEARCH_FAILED_UNKNOWN, //未知错误
	};
	namespace Core {
		using namespace MemorySearchKit::CompareValue;
		using namespace MemorySearchKit::String;


		/*
		CPU多线程执行函数
		nThreadCount：线程数
		void OnThreadExecute(size_t thread_id，std::atomic<bool> *pForceStopSignal)：每条线程要执行的任务回调（线程ID号，中止信号）
		std::atomic<bool> * pForceStopSignal: 强制中止所有任务的信号
		*/
		static void MultiThreadOnCpu(
			size_t nThreadCount,
			std::function<void(size_t thread_id, std::atomic<bool>* pForceStopSignal)> OnThreadExecute,
			std::atomic<bool>* pForceStopSignal/* = nullptr*/) {
			std::vector<std::shared_ptr<std::thread>> vThread;
			for (int i = 0; i < nThreadCount; ++i) {
				//开始分配线程
				std::shared_ptr<std::thread> td = std::make_shared<std::thread>(
					[i, OnThreadExecute, pForceStopSignal]()->void {
						OnThreadExecute(i, pForceStopSignal);
					}
				);
				vThread.push_back(td);
			}
			//等待所有线程启动
			for (auto & item : vThread) {
				item->join();
			}
		}

		/*
		内存搜索数值
		pReadWriteProxy：读取进程内存数据的接口
		hProcess：被搜索的进程句柄
		spvWaitScanMemBlockList: 被搜索的进程内存区域
		value1: 要搜索的数值1
		value2: 要搜索的数值2
		errorRange: 误差范围（当搜索的数值为float或者double时此值有效，其余情况请填写0）
		scanType：搜索类型：
						ACCURATE_VAL精确数值（value1生效）、
						LARGER_THAN_VAL值大于（value1生效）、
						LESS_THAN_VAL值小于（value1生效）、
						BETWEEN_VAL值在两值之间（value1、value2生效）
		nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
		vResultList：存放搜索完成的结果地址
		nScanAlignBytesCount：扫描的对齐字节数，默认为待搜索数值的结构大小
		pForceStopSignal: 强制中止所有任务的信号
		*/
		template<typename T> static MEM_SEARCH_STATUS SearchValue(
			IMemReaderWriterProxy* pReadWriteProxy,
			uint64_t hProcess,
			std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
			T value1, T value2, float errorRange, SCAN_TYPE scanType, size_t nThreadCount,
			std::vector<ADDR_RESULT_INFO>& vResultList,
			size_t nScanAlignBytesCount/* = sizeof(T)*/,
			std::atomic<bool>* pForceStopSignal/* = nullptr*/) {

			assert(pReadWriteProxy);
			if (!pReadWriteProxy) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}

			//设置内存数据读取器
			std::shared_ptr<SimpleDriverMemDataProvider> spMemDataProvider
				= std::make_shared<SimpleDriverMemDataProvider>(pReadWriteProxy, hProcess);
			if (!spMemDataProvider) {
				return MEM_SEARCH_FAILED_ALLOC_MEM;
			}
			spvWaitScanMemBlockList->set_mem_data_provider(spMemDataProvider.get());

			size_t splitSize = TASK_BLOCK_SIZE;

			//自动排序容器
			MemSearchSafeMap<uint64_t, ADDR_RESULT_INFO> sortResultMap;

			MultiThreadOnCpu(nThreadCount, [pReadWriteProxy, nThreadCount, splitSize, hProcess,
				spvWaitScanMemBlockList, value1, value2, errorRange, scanType,
				&sortResultMap, nScanAlignBytesCount](size_t thread_id, std::atomic<bool>* pForceStopSignal)->void {

					std::vector<ADDR_RESULT_INFO> vThreadOutput; //存放当前线程的搜索结果

					constexpr bool isFloatVal = std::is_same_v<T, float> || std::is_same_v<T, double>;
					while (!pForceStopSignal || !*pForceStopSignal) {
						uint64_t curMemBlockStartAddr = 0;
						uint64_t curMemBlockSize = 0;
						std::shared_ptr<unsigned char> spOutMemData;
						uint64_t outCurWorkOffset = 0;

						spvWaitScanMemBlockList->release_useless_mem_block();
						if (!spvWaitScanMemBlockList->get_need_work_mem_block(splitSize, curMemBlockStartAddr, curMemBlockSize, spOutMemData, outCurWorkOffset)) {
							break; //没任务了
						}

						//读取这个目标内存section的内存数据时直接指针取值，节省开销
						size_t nRealReadSize = min(curMemBlockSize - outCurWorkOffset, splitSize);
						if (nRealReadSize == 0) {
							continue;
						}
						char* pReadBuf = (char*)((char*)spOutMemData.get() + outCurWorkOffset);
						//寻找数值
						std::vector<size_t> vFindAddr;

						switch (scanType) {
						case SCAN_TYPE::ACCURATE_VAL:
							//精确数值
							if constexpr (isFloatVal) {
								FindBetween<T>((size_t)(pReadBuf),
									nRealReadSize, value1 - errorRange, value1 + errorRange, nScanAlignBytesCount, vFindAddr);
							} else {
								FindValue<T>((size_t)pReadBuf, nRealReadSize, value1, nScanAlignBytesCount, vFindAddr);
							}

							break;
						case SCAN_TYPE::LARGER_THAN_VAL:
							//值大于
							FindGreater<T>((size_t)pReadBuf, nRealReadSize, value1, nScanAlignBytesCount, vFindAddr);
							break;
						case SCAN_TYPE::LESS_THAN_VAL:
							//值小于
							FindLess<T>((size_t)pReadBuf, nRealReadSize, value1, nScanAlignBytesCount, vFindAddr);
							break;
						case SCAN_TYPE::BETWEEN_VAL:
							//值在两者之间于
							FindBetween<T>((size_t)pReadBuf, nRealReadSize, min(value1, value2), max(value1, value2), nScanAlignBytesCount, vFindAddr);
							break;
						default:
							break;
						}



						for (size_t addr : vFindAddr) {
							ADDR_RESULT_INFO aInfo;
							aInfo.addr = (uint64_t)addr - (uint64_t)pReadBuf + curMemBlockStartAddr + outCurWorkOffset/*每个线程的起始位置*/;
							aInfo.size = sizeof(T);

							std::shared_ptr<unsigned char> sp(new unsigned char[aInfo.size], std::default_delete<unsigned char[]>());
							memcpy(sp.get(), (void*)addr, aInfo.size);

							aInfo.spSaveData = sp;
							vThreadOutput.push_back(aInfo);
						}
					}
					//将当前线程的搜索结果，汇总到父线程的全部搜索结果数组里
					for (ADDR_RESULT_INFO& newAddr : vThreadOutput) {
						sortResultMap.insert(newAddr.addr, newAddr);
					}

				}, pForceStopSignal);

			sortResultMap.to_vector(vResultList);
			return MEM_SEARCH_SUCCESS;
		}


		/*
		再次搜索内存数值
		pReadWriteProxy：读取进程内存数据的接口
		hProcess：被搜索的进程句柄
		vWaitScanMemAddr: 需要再次搜索的内存地址列表
		value1: 要搜索数值1
		value2: 要搜索数值2
		errorRange: 误差范围（当搜索的数值为float或者double时此值有效，其余情况请填写0）
		scanType：搜索类型：
						ACCURATE_VAL精确数值（value1生效）、
						LARGER_THAN_VAL值大于（value1生效）、
						LESS_THAN_VAL值小于（value1生效）、
						BETWEEN_VAL值在两值之间（value1、value2生效）、
						ADD_UNKNOW_VAL值增加了未知值（value1、value2均无效），
						ADD_ACCURATE_VAL值增加了精确值（value1生效），
						SUB_UNKNOW_VAL值减少了未知值（value1、value2均无效），
						SUB_ACCURATE_VAL值减少了精确值（value1生效），
						CHANGED_VAL变动了的数值（value1、value2均无效），
						UNCHANGED_VAL未变动的数值（value1、value2均无效）
		nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
		vResultList：存放搜索完成的结果地址
		vErrorList：存放实时搜索失败的结果地址
		pForceStopSignal: 强制中止所有任务的信号
		*/
		template<typename T> static MEM_SEARCH_STATUS SearchAddrNextValue(
			IMemReaderWriterProxy* pReadWriteProxy,
			uint64_t hProcess,
			const std::vector<ADDR_RESULT_INFO>& vWaitScanMemAddr,
			T value1, T value2, float errorRange, SCAN_TYPE scanType, size_t nThreadCount,
			std::vector<ADDR_RESULT_INFO>& vResultList,
			std::vector<ADDR_RESULT_INFO>& vErrorList,
			std::atomic<bool>* pForceStopSignal/* = nullptr*/) {
			assert(pReadWriteProxy);
			if (!pReadWriteProxy) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}

			MemSearchSafeVector<ADDR_RESULT_INFO> vSafeWaitScanMemAddr(vWaitScanMemAddr);

			//自动排序
			MemSearchSafeMap<uint64_t, ADDR_RESULT_INFO> sortResultMap;
			MemSearchSafeMap<uint64_t, ADDR_RESULT_INFO> sortErrorMap;

			constexpr bool isFloatVal = std::is_same_v<T, float> || std::is_same_v<T, double>;

			//内存搜索线程
			MultiThreadOnCpu(nThreadCount,
				[pReadWriteProxy, hProcess, &vSafeWaitScanMemAddr, nThreadCount,
				value1, value2, errorRange, scanType, isFloatVal, &sortResultMap, &sortErrorMap](size_t thread_id, std::atomic<bool>* pForceStopSignal)->void {

					std::vector<ADDR_RESULT_INFO> vThreadOutput; //存放当前线程的搜索结果


					//一个一个job拿会拖慢速度
					std::vector<ADDR_RESULT_INFO> vTempJobMemAddrInfo;
					while (vTempJobMemAddrInfo.size() ||
						vSafeWaitScanMemAddr.pop_back(nThreadCount * 2, vTempJobMemAddrInfo) ||
						vSafeWaitScanMemAddr.pop_back(1, vTempJobMemAddrInfo)) {

						ADDR_RESULT_INFO memAddrJob = vTempJobMemAddrInfo.back();
						vTempJobMemAddrInfo.pop_back();

						T temp = 0;
						size_t dwRead = 0;
						if (!pReadWriteProxy->ReadProcessMemory(hProcess, memAddrJob.addr, &temp, sizeof(temp), &dwRead)) {
							sortErrorMap.insert(memAddrJob.addr, memAddrJob);
							continue;
						}

						if (dwRead != sizeof(T)) {
							sortErrorMap.insert(memAddrJob.addr, memAddrJob);
							continue;
						}

						//寻找数值
						switch (scanType) {
						case SCAN_TYPE::ACCURATE_VAL:
							if constexpr (isFloatVal) {
								//当是float、double数值的情况
								if ((value1 - errorRange) > temp || temp > (value1 + errorRange)) { continue; }
							} else {
								//精确数值
								if (temp != value1) { continue; }
							}
							break;
						case SCAN_TYPE::LARGER_THAN_VAL:
							//值大于的结果保留
							if (temp < value1) { continue; }
							break;
						case SCAN_TYPE::LESS_THAN_VAL:
							//值小于的结果保留
							if (temp > value1) { continue; }
							break;
						case SCAN_TYPE::BETWEEN_VAL:
							//值在两者之间的结果保留
							if (value1 < value2) {
								if (value1 > temp || temp > value2) { continue; }
							} else {
								if (value2 > temp || temp > value1) { continue; }
							}
							break;
						case SCAN_TYPE::ADD_UNKNOW_VAL:
							//增加的数值的结果保留
							if (temp <= *(T*)(memAddrJob.spSaveData.get())) { continue; }
							break;
						case SCAN_TYPE::ADD_ACCURATE_VAL:
							if constexpr (isFloatVal) {
								//float、double数值增加了的结果保留
								T* pOldData = (T*)memAddrJob.spSaveData.get();
								T cOldData = *pOldData;
								if (temp <= cOldData) { continue; }
								T add = temp - cOldData;

								if ((value1 - errorRange) > add || add > (value1 + errorRange)) { continue; }
							} else {
								//数值增加了的结果保留
								if (((temp)-(*(T*)(memAddrJob.spSaveData.get()))) != value1) { continue; }

							}
							break;
						case SCAN_TYPE::SUB_UNKNOW_VAL:
							//减少的数值的结果保留
							if (temp >= *(T*)(memAddrJob.spSaveData.get())) { continue; }
							break;
						case SCAN_TYPE::SUB_ACCURATE_VAL:
							if constexpr (isFloatVal) {
								//float、double数值减少了的结果保留
								T* pOldData = (T*)memAddrJob.spSaveData.get();
								T cOldData = *pOldData;
								if (temp >= cOldData) { continue; }
								T sum = cOldData - temp;

								if ((value1 - errorRange) > sum || sum > (value1 + errorRange)) { continue; }

							} else {
								//数值减少了的结果保留
								if (((*(T*)(memAddrJob.spSaveData.get())) - (temp)) != value1) { continue; }
							}
							break;
						case SCAN_TYPE::CHANGED_VAL:
							if constexpr (isFloatVal) {
								//float、double变动的数值的结果保留
								T* pOldData = (T*)memAddrJob.spSaveData.get();
								if (temp > (*pOldData)) {
									if ((temp - errorRange) <= (*pOldData)) { continue; }
								}
								if (temp < (*pOldData)) {
									if ((temp + errorRange) >= (*pOldData)) { continue; }
								}

							} else {
								//变动的数值的结果保留
								if (temp == *(T*)(memAddrJob.spSaveData.get())) { continue; }
							}
							break;
						case SCAN_TYPE::UNCHANGED_VAL:
							if constexpr (isFloatVal) {
								//float、double未变动的数值的结果保留
								T* pOldData = (T*)memAddrJob.spSaveData.get();

								if (temp > (*pOldData)) {
									if ((temp - errorRange) > (*pOldData)) { continue; }
								}
								if (temp < (*pOldData)) {
									if ((temp + errorRange) < (*pOldData)) { continue; }
								}

							} else {
								//未变动的数值的结果保留
								if (temp != *(T*)(memAddrJob.spSaveData.get())) { continue; }
							}

							break;
						default:
							break;
						}

						if (memAddrJob.size != sizeof(T)) {
							memAddrJob.size = sizeof(T);
							std::shared_ptr<unsigned char> sp(new unsigned char[memAddrJob.size], std::default_delete<unsigned char[]>());
							memAddrJob.spSaveData = sp;
						}
						memcpy(memAddrJob.spSaveData.get(), &temp, 1);
						vThreadOutput.push_back(memAddrJob);
					}
					//将当前线程的搜索结果，汇总到父线程的全部搜索结果数组里
					for (ADDR_RESULT_INFO& newAddr : vThreadOutput) {
						sortResultMap.insert(newAddr.addr, newAddr);
					}

				}, pForceStopSignal);

			sortResultMap.to_vector(vResultList);
			sortErrorMap.to_vector(vErrorList);
			return MEM_SEARCH_SUCCESS;
		}


		/*
		内存批量搜索值在两值之间的内存地址
		pReadWriteProxy：读取进程内存数据的接口
		hProcess：被搜索的进程句柄
		spvWaitScanMemBlockList: 被搜索的进程内存区域
		vBatchBetweenValue: 待搜索的多个两值之间的数值数组
		nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
		vResultList：存放搜索完成的结果地址
		nScanAlignBytesCount：扫描的对齐字节数，默认为待搜索数值的结构大小
		pForceStopSignal: 强制中止所有任务的信号
		*/
		template<typename T> static MEM_SEARCH_STATUS SearchBatchBetweenValue(
			IMemReaderWriterProxy* pReadWriteProxy,
			uint64_t hProcess,
			std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
			const std::vector<BATCH_BETWEEN_VAL<T>>& vBatchBetweenValue,
			size_t nThreadCount,
			std::vector<BATCH_BETWEEN_VAL_ADDR_RESULT<T>>& vResultList,
			size_t nScanAlignBytesCount/* = sizeof(T)*/,
			std::atomic<bool>* pForceStopSignal/* = nullptr*/) {

			assert(pReadWriteProxy);
			if (!pReadWriteProxy) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}

			//设置内存数据读取器
			std::shared_ptr<SimpleDriverMemDataProvider> spMemDataProvider
				= std::make_shared<SimpleDriverMemDataProvider>(pReadWriteProxy, hProcess);
			if (!spMemDataProvider) {
				return MEM_SEARCH_FAILED_ALLOC_MEM;
			}
			spvWaitScanMemBlockList->set_mem_data_provider(spMemDataProvider.get());
			size_t splitSize = TASK_BLOCK_SIZE;

			size_t nBetweenValCount = vBatchBetweenValue.size();

			//自动排序
			MemSearchSafeMap<uint64_t, BATCH_BETWEEN_VAL_ADDR_RESULT<T>> sortResultMap;
			MultiThreadOnCpu(nThreadCount,
				[pReadWriteProxy, hProcess, spvWaitScanMemBlockList, nThreadCount, splitSize,
				&vBatchBetweenValue, nBetweenValCount, &sortResultMap, nScanAlignBytesCount]
			(size_t thread_id, std::atomic<bool>* pForceStopSignal)-> void {

					std::vector<BATCH_BETWEEN_VAL_ADDR_RESULT<T>> vThreadOutput; //存放当前线程的搜索结果
					while (!pForceStopSignal || !*pForceStopSignal) {
						uint64_t curMemBlockStartAddr = 0;
						uint64_t curMemBlockSize = 0;
						std::shared_ptr<unsigned char> spOutMemData;
						uint64_t outCurWorkOffset = 0;

						spvWaitScanMemBlockList->release_useless_mem_block();
						if (!spvWaitScanMemBlockList->get_need_work_mem_block(splitSize, curMemBlockStartAddr, curMemBlockSize, spOutMemData, outCurWorkOffset)) {
							break; //没任务了
						}
						//读取这个目标内存section的内存数据时直接指针取值，节省开销
						size_t nRealReadSize = min(curMemBlockSize - outCurWorkOffset, splitSize);
						if (nRealReadSize == 0) {
							continue;
						}
						char* pReadBuf = (char*)((char*)spOutMemData.get() + outCurWorkOffset);

						for (size_t i = 0; i < nBetweenValCount; i++) {
							auto& item = vBatchBetweenValue.at(i);

							//寻找数值
							std::vector<size_t> vFindAddr;

							//值在两者之间于
							FindBetween<T>((size_t)pReadBuf, nRealReadSize, min(item.val1, item.val2), max(item.val1, item.val2), nScanAlignBytesCount, vFindAddr);

							for (size_t addr : vFindAddr) {
								BATCH_BETWEEN_VAL_ADDR_RESULT<T> baInfo;
								baInfo.addrInfo.addr = (uint64_t)addr - (uint64_t)pReadBuf + curMemBlockStartAddr + outCurWorkOffset/*每个线程的起始位置*/;
								baInfo.addrInfo.size = sizeof(T);
								std::shared_ptr<unsigned char> sp(new unsigned char[baInfo.addrInfo.size], std::default_delete<unsigned char[]>());
								memcpy(sp.get(), (void*)addr, baInfo.addrInfo.size);
								baInfo.addrInfo.spSaveData = sp;

								//原始条件
								baInfo.originalCondition = item;

								vThreadOutput.push_back(baInfo);
							}
						}
					}
					//将当前线程的搜索结果，汇总到父线程的全部搜索结果数组里
					for (BATCH_BETWEEN_VAL_ADDR_RESULT<T>& newAddr : vThreadOutput) {
						sortResultMap.insert(newAddr.addrInfo.addr, newAddr);
					}
				}, pForceStopSignal);

			sortResultMap.to_vector(vResultList);
			return MEM_SEARCH_SUCCESS;
		}

		/*
		内存搜索字节特征码
		pReadWriteProxy：读取进程内存数据的接口
		hProcess：被搜索的进程句柄
		spvWaitScanMemBlockList: 被搜索的进程内存区域
		vFeaturesByte：字节特征码，如“char vBytes[] = {'\x68', '\x00', '\x00', '\x00', '\x40', '\x?3', '\x??', '\x7?', '\x??', '\x??', '\x??', '\x??', '\x??', '\x50', '\xE8};”
		nFeaturesByteLen：字节特征码长度
		vFuzzyBytes：模糊字节，不变动的位置用1表示，变动的位置用0表示，如“char vFuzzy[] = {'\x11', '\x11', '\x11', '\x11', '\x11', '\x01', '\x00', '\x10', '\x00', '\x00', '\x00', '\x00', '\x00', '\x11', '\x11};”
		nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
		vResultList：存放搜索完成的结果地址
		nScanAlignBytesCount：扫描的对齐字节数，默认为1
		pForceStopSignal: 强制中止所有任务的信号
		*/
		static MEM_SEARCH_STATUS SearchFeaturesBytes(
			IMemReaderWriterProxy* pReadWriteProxy,
			uint64_t hProcess,
			std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
			const char vFeaturesByte[],
			size_t nFeaturesByteLen,
			char vFuzzyBytes[],
			size_t nThreadCount,
			std::vector<ADDR_RESULT_INFO>& vResultList,
			size_t nScanAlignBytesCount/* = 1*/,
			std::atomic<bool>* pForceStopSignal/* = nullptr*/) {

			assert(pReadWriteProxy);
			if (!pReadWriteProxy) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}

			//设置内存数据读取器
			std::shared_ptr<SimpleDriverMemDataProvider> spMemDataProvider
				= std::make_shared<SimpleDriverMemDataProvider>(pReadWriteProxy, hProcess);
			if (!spMemDataProvider) {
				return MEM_SEARCH_FAILED_ALLOC_MEM;
			}
			spvWaitScanMemBlockList->set_mem_data_provider(spMemDataProvider.get());
			size_t splitSize = TASK_BLOCK_SIZE;

			//生成特征码容错文本
			std::string strFuzzyCode; //如：xxxxx????????xx
			for (size_t i = 0; i < nFeaturesByteLen; i++) {
				if (vFuzzyBytes[i] == '\x00') {
					strFuzzyCode += "??";
				} else if (vFuzzyBytes[i] == '\x01') {
					strFuzzyCode += "?x";
				} else if (vFuzzyBytes[i] == '\x10') {
					strFuzzyCode += "x?";
				} else {
					strFuzzyCode += "xx";
				}
			}

			std::shared_ptr<unsigned char> spStrFuzzyCode(new unsigned char[strFuzzyCode.length() + 1], std::default_delete<unsigned char[]>());
			memset(spStrFuzzyCode.get(), 0, strFuzzyCode.length() + 1);
			memcpy(spStrFuzzyCode.get(), strFuzzyCode.c_str(), strFuzzyCode.length());

			//是否启用特征码容错搜索
			bool isSimpleSearch = (strFuzzyCode.find("?") == -1) ? true : false;


			//自动排序
			MemSearchSafeMap<uint64_t, ADDR_RESULT_INFO> sortResultMap;

			//内存搜索线程
			MultiThreadOnCpu(nThreadCount,
				[pReadWriteProxy, hProcess, nThreadCount, splitSize, spvWaitScanMemBlockList,
				vFeaturesByte, nFeaturesByteLen, spStrFuzzyCode, isSimpleSearch,
				nScanAlignBytesCount, &sortResultMap](size_t thread_id, std::atomic<bool>* pForceStopSignal)->void {

					std::vector<ADDR_RESULT_INFO> vThreadOutput; //存放当前线程的搜索结果

					while (!pForceStopSignal || !*pForceStopSignal) {
						uint64_t curMemBlockStartAddr = 0;
						uint64_t curMemBlockSize = 0;
						std::shared_ptr<unsigned char> spOutMemData;
						uint64_t outCurWorkOffset = 0;

						spvWaitScanMemBlockList->release_useless_mem_block();
						if (!spvWaitScanMemBlockList->get_need_work_mem_block(splitSize, curMemBlockStartAddr, curMemBlockSize, spOutMemData, outCurWorkOffset)) {
							break; //没任务了
						}

						//读取这个目标内存section的内存数据时直接指针取值，节省开销
						size_t nRealReadSize = min((curMemBlockSize - outCurWorkOffset), splitSize);
						if (nRealReadSize == 0) {
							continue;
						}
						char* pReadBuf = (char*)((char*)spOutMemData.get() + outCurWorkOffset);


						//寻找字节集
						std::vector<size_t> vFindAddr;
						if (isSimpleSearch) {
							//不需要容错搜索
							FindBytes((size_t)pReadBuf, nRealReadSize, (unsigned char*)&vFeaturesByte[0], nFeaturesByteLen,
								nScanAlignBytesCount, vFindAddr);
						} else {
							//需要容错搜索
							FindFeaturesBytes((size_t)pReadBuf, nRealReadSize, (unsigned char*)&vFeaturesByte[0],
								(const char*)spStrFuzzyCode.get(), nFeaturesByteLen, nScanAlignBytesCount, vFindAddr);
						}

						for (size_t addr : vFindAddr) {
							//保存搜索结果
							ADDR_RESULT_INFO aInfo;
							aInfo.addr = (uint64_t)addr - (uint64_t)pReadBuf + curMemBlockStartAddr + outCurWorkOffset/*每个线程的起始位置*/;
							aInfo.size = nFeaturesByteLen;
							std::shared_ptr<unsigned char> sp(new unsigned char[aInfo.size], std::default_delete<unsigned char[]>());
							memcpy(sp.get(), (void*)addr, aInfo.size);
							aInfo.spSaveData = sp;
							vThreadOutput.push_back(aInfo);
						}
					}

					//将当前线程的搜索结果，汇总到父线程的全部搜索结果数组里
					for (ADDR_RESULT_INFO& newAddr : vThreadOutput) {
						sortResultMap.insert(newAddr.addr, newAddr);
					}
				}, pForceStopSignal);
			sortResultMap.to_vector(vResultList);
			return MEM_SEARCH_SUCCESS;
		}

		/*
		再次搜索内存字节特征码
		pReadWriteProxy：读取进程内存数据的接口
		hProcess：被搜索的进程句柄
		vWaitScanMemAddr: 需要再次搜索的内存地址列表
		vFeaturesByte：字节特征码，如“char vBytes[] = {0x68, 0x00, 0x00, 0x00, 0x40, 0x?3, 0x??, 0x7?, 0x??, 0x??, 0x??, 0x??, 0x??, 0x50, 0xE8};”
		nFeaturesByteLen：字节特征码长度
		vFuzzyBytes：模糊字节，不变动的位置用1表示，变动的位置用0表示，如“char vFuzzy[] = {0x11, 0x11, 0x11, 0x11, 0x11, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11};”
		nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
		vResultList：存放搜索完成的结果地址
		vErrorList：存放实时搜索失败的结果地址
		nScanAlignBytesCount：扫描的对齐字节数，默认为1
		pForceStopSignal: 强制中止所有任务的信号
		*/
		static MEM_SEARCH_STATUS SearchAddrNextFeaturesBytes(
			IMemReaderWriterProxy* pReadWriteProxy,
			uint64_t hProcess,
			const std::vector<ADDR_RESULT_INFO>& vWaitScanMemAddr,
			char vFeaturesByte[],
			size_t nFeaturesByteLen,
			char vFuzzyBytes[],
			size_t nThreadCount,
			std::vector<ADDR_RESULT_INFO>& vResultList,
			std::vector<ADDR_RESULT_INFO>& vErrorList,
			size_t nScanAlignBytesCount/* = 1*/,
			std::atomic<bool>* pForceStopSignal/* = nullptr*/) {

			assert(pReadWriteProxy);
			if (!pReadWriteProxy) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}
			//生成特征码容错文本
			std::string strFuzzyCode = ""; //如：xxxxx????????xx
			for (size_t i = 0; i < nFeaturesByteLen; i++) {
				if (vFuzzyBytes[i] == '\x00') {
					strFuzzyCode += "??";
				} else if (vFuzzyBytes[i] == '\x01') {
					strFuzzyCode += "?x";
				} else if (vFuzzyBytes[i] == '\x10') {
					strFuzzyCode += "x?";
				} else {
					strFuzzyCode += "xx";
				}
			}

			std::shared_ptr<unsigned char> spStrFuzzyCode(new unsigned char[strFuzzyCode.length() + 1], std::default_delete<unsigned char[]>());
			memset(spStrFuzzyCode.get(), 0, strFuzzyCode.length() + 1);
			memcpy(spStrFuzzyCode.get(), strFuzzyCode.c_str(), strFuzzyCode.length());

			//是否启用特征码容错搜索
			bool isSimpleSearch = (strFuzzyCode.find("?") == -1) ? true : false;

			MemSearchSafeVector<ADDR_RESULT_INFO> vSafeWaitScanMemAddr(vWaitScanMemAddr);

			//自动排序
			MemSearchSafeMap<uint64_t, ADDR_RESULT_INFO> sortResultMap;
			MemSearchSafeMap<uint64_t, ADDR_RESULT_INFO> sortErrorMap;

			//内存搜索线程
			MultiThreadOnCpu(nThreadCount,
				[pReadWriteProxy, &vSafeWaitScanMemAddr, hProcess, nThreadCount,
				vFeaturesByte, nFeaturesByteLen, spStrFuzzyCode, isSimpleSearch, nScanAlignBytesCount,
				&sortResultMap, &sortErrorMap](size_t thread_id, std::atomic<bool>* pForceStopSignal)->void {


					std::vector<ADDR_RESULT_INFO> vThreadOutput; //存放当前线程的搜索结果

					//一个一个job拿会拖慢速度
					std::vector<ADDR_RESULT_INFO> vTempJobMemAddrInfo;
					while (vTempJobMemAddrInfo.size() ||
						vSafeWaitScanMemAddr.pop_back(nThreadCount * 2, vTempJobMemAddrInfo) ||
						vSafeWaitScanMemAddr.pop_back(1, vTempJobMemAddrInfo)) {
						ADDR_RESULT_INFO memAddrJob = vTempJobMemAddrInfo.back();
						vTempJobMemAddrInfo.pop_back();

						size_t memBufSize = nFeaturesByteLen;
						unsigned char* pnew = new (std::nothrow) unsigned char[memBufSize];
						if (!pnew) {
							/*cout << "malloc "<< memSecInfo.nSectionSize  << " failed."<< endl;*/
							sortErrorMap.insert(memAddrJob.addr, memAddrJob);
							continue;
						}
						memset(pnew, 0, memBufSize);
						std::shared_ptr<unsigned char> spMemBuf(pnew, std::default_delete<unsigned char[]>());
						size_t dwRead = 0;
						if (!pReadWriteProxy->ReadProcessMemory(hProcess, memAddrJob.addr, spMemBuf.get(), memBufSize, &dwRead)) {
							sortErrorMap.insert(memAddrJob.addr, memAddrJob);
							continue;
						}
						if (dwRead != memBufSize) {
							sortErrorMap.insert(memAddrJob.addr, memAddrJob);
							continue;
						}
						//寻找字节集
						std::vector<size_t> vFindAddr;

						if (isSimpleSearch) {
							//不需要容错搜索
							FindBytes((size_t)spMemBuf.get(), dwRead, (unsigned char*)&vFeaturesByte[0], nFeaturesByteLen, nScanAlignBytesCount, vFindAddr);
						} else {
							//需要容错搜索
							FindFeaturesBytes((size_t)spMemBuf.get(), dwRead, (unsigned char*)&vFeaturesByte[0],
								(const char*)spStrFuzzyCode.get(), nFeaturesByteLen, nScanAlignBytesCount, vFindAddr);
						}

						if (vFindAddr.size()) {
							//保存搜索结果
							memcpy(memAddrJob.spSaveData.get(), spMemBuf.get(), memBufSize);
							vThreadOutput.push_back(memAddrJob);
						}

					}
					//将当前线程的搜索结果，汇总到父线程的全部搜索结果数组里
					for (ADDR_RESULT_INFO& newAddr : vThreadOutput) {
						sortResultMap.insert(newAddr.addr, newAddr);
					}

				}, pForceStopSignal);

			sortResultMap.to_vector(vResultList);
			sortErrorMap.to_vector(vErrorList);
			return MEM_SEARCH_SUCCESS;
		}


		/*
		内存搜索文本特征码
		pReadWriteProxy：读取进程内存数据的接口
		hProcess：被搜索的进程句柄
		spvWaitScanMemBlockList: 被搜索的进程内存区域
		strFeaturesByte: 十六进制的文本字节特征码，搜索规则与OD相同，如“68 00 00 00 40 ?3 7? ?? ?? ?? ?? ?? ?? 50 E8”
		nThreadCount: 用于搜索内存的线程数，推荐设置为CPU数量
		vResultList：存放搜索完成的结果地址
		nScanAlignBytesCount：扫描的对齐字节数，默认为1
		pForceStopSignal: 强制中止所有任务的信号
		*/
		static MEM_SEARCH_STATUS SearchFeaturesByteString(
			IMemReaderWriterProxy* pReadWriteProxy,
			uint64_t hProcess,
			std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
			std::string strFeaturesByte,
			size_t nThreadCount,
			std::vector<ADDR_RESULT_INFO>& vResultList,
			size_t nScanAlignBytesCount/* = 1*/,
			std::atomic<bool>* pForceStopSignal/* = nullptr*/) {

			assert(pReadWriteProxy);
			if (!pReadWriteProxy) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}

			//预处理特征码
			replace_all_distinct(strFeaturesByte, " ", "");//去除空格
			if (strFeaturesByte.length() % 2) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}

			//特征码字节数组
			std::unique_ptr<char[]> upFeaturesBytesBuf = std::make_unique<char[]>(strFeaturesByte.length() / 2); //如：68 00 00 00 40 ?3 7? ?? ?? ?? ?? ?? ?? 50 E8

			//特征码容错数组
			std::unique_ptr<char[]> upFuzzyBytesBuf = std::make_unique<char[]>(strFeaturesByte.length() / 2);

			size_t nFeaturesBytePos = 0; //记录写入特征码字节数组的位置

			//遍历每个文本字节
			for (std::string::size_type pos(0); pos < strFeaturesByte.length(); pos += 2) {
				std::string strByte = strFeaturesByte.substr(pos, 2); //每个文本字节

				//cout << strByte <<"/" << endl;

				if (strByte == "??") //判断是不是??
				{
					upFuzzyBytesBuf[nFeaturesBytePos] = '\x00';
				} else if (strByte.substr(0, 1) == "?") {
					upFuzzyBytesBuf[nFeaturesBytePos] = '\x01';
				} else if (strByte.substr(1, 2) == "?") {
					upFuzzyBytesBuf[nFeaturesBytePos] = '\x10';
				} else {
					upFuzzyBytesBuf[nFeaturesBytePos] = '\x11';
				}

				//把?替换成0
				replace_all_distinct(strByte, "?", "0");
				//cout << strByte << endl;
				int nByte = 0;
				std::stringstream ssConvertBuf;
				ssConvertBuf.str(strByte);
				ssConvertBuf >> std::hex >> nByte; //十六进制字节文本转成十进制


				upFeaturesBytesBuf[nFeaturesBytePos] = nByte; //将十进制数值写进储存起来
				nFeaturesBytePos++;

			}
			return SearchFeaturesBytes(
				pReadWriteProxy,
				hProcess,
				spvWaitScanMemBlockList,
				upFeaturesBytesBuf.get(),
				strFeaturesByte.length() / 2,
				upFuzzyBytesBuf.get(),
				nThreadCount,
				vResultList,
				nScanAlignBytesCount,
				pForceStopSignal);

		}

		/*
		再次搜索内存文本特征码
		pReadWriteProxy：读取进程内存数据的接口
		hProcess：被搜索的进程句柄
		vWaitScanMemAddr: 需要再次搜索的内存地址列表
		strFeaturesByte: 十六进制的文本字节特征码，搜索规则与OD相同，如“68 00 00 00 40 ?3 7? ?? ?? ?? ?? ?? ?? 50 E8”
		nThreadCount: 用于搜索内存的线程数，推荐设置为CPU数量
		vResultList：存放搜索完成的结果地址
		vErrorList：存放实时搜索失败的结果地址
		nScanAlignBytesCount：扫描的对齐字节数，默认为1
		pForceStopSignal: 强制中止所有任务的信号
		*/
		static MEM_SEARCH_STATUS SearchAddrNextFeaturesByteString(
			IMemReaderWriterProxy* pReadWriteProxy,
			uint64_t hProcess,
			const std::vector<ADDR_RESULT_INFO>& vWaitScanMemAddr,
			std::string strFeaturesByte,
			size_t nThreadCount,
			std::vector<ADDR_RESULT_INFO>& vResultList,
			std::vector<ADDR_RESULT_INFO>& vErrorList,
			size_t nScanAlignBytesCount/* = 1*/,
			std::atomic<bool>* pForceStopSignal/* = nullptr*/) {

			assert(pReadWriteProxy);
			if (!pReadWriteProxy) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}

			//预处理特征码
			replace_all_distinct(strFeaturesByte, " ", "");//去除空格
			if (strFeaturesByte.length() % 2) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}

			//特征码字节数组
			std::unique_ptr<char[]> upFeaturesBytesBuf = std::make_unique<char[]>(strFeaturesByte.length() / 2); //如：68 00 00 00 40 ?3 7? ?? ?? ?? ?? ?? ?? 50 E8

			//特征码容错数组
			std::unique_ptr<char[]> upFuzzyBytesBuf = std::make_unique<char[]>(strFeaturesByte.length() / 2);

			size_t nFeaturesBytePos = 0; //记录写入特征码字节数组的位置

			//遍历每个文本字节
			for (std::string::size_type pos(0); pos < strFeaturesByte.length(); pos += 2) {
				std::string strByte = strFeaturesByte.substr(pos, 2); //每个文本字节

				if (strByte == "??") //判断是不是??
				{
					upFuzzyBytesBuf[nFeaturesBytePos] = '\x00';
				} else 	if (strByte.substr(0, 1) == "?") {
					upFuzzyBytesBuf[nFeaturesBytePos] = '\x01';
				} else 	if (strByte.substr(1, 2) == "?") {
					upFuzzyBytesBuf[nFeaturesBytePos] = '\x10';
				} else {
					upFuzzyBytesBuf[nFeaturesBytePos] = '\x11';
				}

				//把?替换成0
				replace_all_distinct(strByte, "?", "0");
				int nByte = 0;
				std::stringstream ssConvertBuf;
				ssConvertBuf.str(strByte);
				ssConvertBuf >> std::hex >> nByte; //十六进制字节文本转成十进制


				upFeaturesBytesBuf[nFeaturesBytePos] = nByte; //将十进制数值写进储存起来
				nFeaturesBytePos++;

			}
			return SearchAddrNextFeaturesBytes(
				pReadWriteProxy,
				hProcess,
				vWaitScanMemAddr,
				upFeaturesBytesBuf.get(),
				strFeaturesByte.length() / 2,
				upFuzzyBytesBuf.get(),
				nThreadCount,
				vResultList,
				vErrorList,
				nScanAlignBytesCount,
				pForceStopSignal);
		}

		/*
		拷贝进程内存数据
		pReadWriteProxy：读取进程内存数据的接口
		hProcess：被搜索的进程句柄
		spvWaitScanMemBlockList: 被拷贝的进程内存区域
		nThreadCount：用于拷贝内存的线程数，推荐设置为CPU数量
		std::atomic<bool> * pForceStopSignal: 强制中止所有任务的信号
		*/
		static MEM_SEARCH_STATUS CopyProcessMemData(
			IMemReaderWriterProxy* pReadWriteProxy,
			uint64_t hProcess,
			std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
			size_t nThreadCount,
			std::atomic<bool>* pForceStopSignal/* = nullptr*/) {
			assert(pReadWriteProxy);
			if (!pReadWriteProxy) {
				return MEM_SEARCH_FAILED_INVALID_PARAM;
			}
			
			MultiThreadOnCpu(nThreadCount,
				[pReadWriteProxy, hProcess, spvWaitScanMemBlockList](size_t thread_id, std::atomic<bool>* pForceStopSignal)->void {
					std::vector<COPY_MEM_INFO> vThreadOutput; //存放当前线程的搜索结果

					while (!pForceStopSignal || !*pForceStopSignal) {
						uint64_t curMemBlockStartAddr = 0;
						uint64_t curMemBlockSize = 0;
						std::shared_ptr<unsigned char> spOutMemData;
						uint64_t outCurWorkOffset = 0;

						if (!spvWaitScanMemBlockList->get_need_work_mem_block(0, curMemBlockStartAddr, curMemBlockSize, spOutMemData, outCurWorkOffset)) {
							break; //没任务了
						}
						if (pForceStopSignal && *pForceStopSignal) {
							break;
						}
					}
				}, pForceStopSignal);
			return MEM_SEARCH_SUCCESS;
		}


	}
}

#endif /* MEM_SEARCH_KIT_CORE_H_ */


```

`rwProcMem33Module/testMemSearch/jni/MemSearchKit/MemSearchKitReverseAddrOffsetLink.h`:

```h
//
// Created by abcz316 on 2020/2/26.
//

#ifndef MEM_SEARCH_KIT_REVERSE_ADDR_OFFSET_LINK_H
#define MEM_SEARCH_KIT_REVERSE_ADDR_OFFSET_LINK_H
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <memory>
#include <sstream>
#include <assert.h>

#ifndef __linux__
typedef SSIZE_T ssize_t;
#endif

struct baseOffsetInfo {
	std::vector<std::weak_ptr<baseOffsetInfo>> vwpLastNode;
	uint64_t addr = 0;
	ssize_t offset;
	std::vector<std::weak_ptr<baseOffsetInfo>> vwpNextNode;
};

using addrAndOffset = std::tuple<uint64_t/*addr*/, ssize_t/*offset*/>;
using singleOffsetLinkPath = std::vector<addrAndOffset>;

static void AddrOffsetLinkMapToVector(std::shared_ptr<baseOffsetInfo> startNode,
	std::function<void(const singleOffsetLinkPath & newSinglePath,
		size_t deepIndex/*start from zero*/)> OnShowNewSinglePath) {

	struct DeepStackIndexInfo {
		size_t nCurStackObjNextNodeIndexNum = 0; //当前栈对象里的对象NextNode纵向深度坐标
		std::weak_ptr<baseOffsetInfo> wpStackObj; //当前栈里的对象
		singleOffsetLinkPath curStackPath; //当前栈的偏移路径全称
	} oDeepStackIndexInfo;
	std::vector<std::shared_ptr<DeepStackIndexInfo>> vspDeepStackIndexInfo; //路径栈


	std::shared_ptr<baseOffsetInfo> spCurItem = startNode;
	singleOffsetLinkPath tempNewSinglePath;
	while (spCurItem) {

		tempNewSinglePath.push_back({ spCurItem->addr,spCurItem->offset });

		OnShowNewSinglePath(tempNewSinglePath, vspDeepStackIndexInfo.size());

		if (spCurItem->vwpNextNode.size()) {

			std::shared_ptr<DeepStackIndexInfo> spLastStack = std::make_shared<DeepStackIndexInfo>();
			spLastStack->nCurStackObjNextNodeIndexNum = 0;
			spLastStack->wpStackObj = spCurItem;
			spLastStack->curStackPath.assign(tempNewSinglePath.begin(), tempNewSinglePath.end());
			vspDeepStackIndexInfo.push_back(spLastStack);

			spCurItem = spCurItem->vwpNextNode[0].lock();
		} else {
			while (vspDeepStackIndexInfo.size()) {

				std::shared_ptr<DeepStackIndexInfo> spLastStack = vspDeepStackIndexInfo.back();
				spLastStack->nCurStackObjNextNodeIndexNum++;
				auto spLastItem = spLastStack->wpStackObj.lock();
				if (spLastItem && spLastItem->vwpNextNode.size() > spLastStack->nCurStackObjNextNodeIndexNum) {
					spCurItem = spLastItem->vwpNextNode[spLastStack->nCurStackObjNextNodeIndexNum].lock();

					tempNewSinglePath.clear();
					tempNewSinglePath.assign(spLastStack->curStackPath.begin(), spLastStack->curStackPath.end());
					break;
				} else {
					vspDeepStackIndexInfo.pop_back();
				}
			}
			if (!vspDeepStackIndexInfo.size()) {
				spCurItem = nullptr;
			}

		}

	}
}
static void test_AddrOffsetLinkMapToString() {
	std::shared_ptr<baseOffsetInfo> demo1 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo21 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo22 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo23 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo31 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo32 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo33 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo34 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo41 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo42 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo43 = std::make_shared<baseOffsetInfo>();
	std::shared_ptr<baseOffsetInfo> demo44 = std::make_shared<baseOffsetInfo>();
	demo1->addr = 1;
	demo21->addr = 21;
	demo22->addr = 22;
	demo23->addr = 23;
	demo31->addr = 31;
	demo32->addr = 32;
	demo33->addr = 33;
	demo34->addr = 34;
	demo41->addr = 41;
	demo42->addr = 42;
	demo43->addr = 43;
	demo44->addr = 44;

	demo1->offset = 1;
	demo21->offset = 21;
	demo22->offset = 22;
	demo23->offset = 23;
	demo31->offset = 31;
	demo32->offset = 32;
	demo33->offset = 33;
	demo34->offset = 34;
	demo41->offset = 41;
	demo42->offset = 42;
	demo43->offset = 43;
	demo44->offset = 44;

	demo1->vwpNextNode.push_back(demo21);
	demo1->vwpNextNode.push_back(demo22);
	demo1->vwpNextNode.push_back(demo23);


	demo21->vwpNextNode.push_back(demo31);
	demo21->vwpNextNode.push_back(demo32);
	demo21->vwpNextNode.push_back(demo33);
	demo22->vwpNextNode.push_back(demo34);

	demo31->vwpNextNode.push_back(demo41);
	demo31->vwpNextNode.push_back(demo42);
	demo31->vwpNextNode.push_back(demo43);
	demo34->vwpNextNode.push_back(demo44);

	demo41->vwpLastNode.push_back(demo31);
	demo42->vwpLastNode.push_back(demo31);
	demo43->vwpLastNode.push_back(demo31);
	demo44->vwpLastNode.push_back(demo34);

	demo31->vwpLastNode.push_back(demo21);
	demo32->vwpLastNode.push_back(demo21);
	demo33->vwpLastNode.push_back(demo21);
	demo34->vwpLastNode.push_back(demo22);

	demo21->vwpLastNode.push_back(demo1);
	demo22->vwpLastNode.push_back(demo1);
	demo23->vwpLastNode.push_back(demo1);

	std::map<uint64_t, std::shared_ptr<baseOffsetInfo>> baseAddrOffsetRecordMap; //记录搜索到的地址偏移
	baseAddrOffsetRecordMap.insert({ 1, demo1 });

	baseAddrOffsetRecordMap.insert({ 21, demo21 });
	baseAddrOffsetRecordMap.insert({ 22, demo22 });
	baseAddrOffsetRecordMap.insert({ 23, demo23 });

	baseAddrOffsetRecordMap.insert({ 31, demo31 });
	baseAddrOffsetRecordMap.insert({ 32, demo32 });
	baseAddrOffsetRecordMap.insert({ 33, demo33 });
	baseAddrOffsetRecordMap.insert({ 34, demo33 });

	baseAddrOffsetRecordMap.insert({ 41, demo41 });
	baseAddrOffsetRecordMap.insert({ 42, demo42 });
	baseAddrOffsetRecordMap.insert({ 43, demo43 });
	baseAddrOffsetRecordMap.insert({ 44, demo44 });

	//打印整个链路
	std::vector<singleOffsetLinkPath> vTotalShow; //显示的总路径文本
	AddrOffsetLinkMapToVector(demo1, [&vTotalShow](const singleOffsetLinkPath & newSinglePath,
		size_t deepIndex/*start from zero*/)->void {
		vTotalShow.push_back(newSinglePath);
	});
	//去重
	std::set<singleOffsetLinkPath>s(vTotalShow.begin(), vTotalShow.end());
	vTotalShow.assign(s.begin(), s.end());

	std::stringstream sstrTotalShow;
	for (auto & item : vTotalShow) {

		//把偏移转成文本
		for (auto & child : item) {
			//十进制转十六进制
			sstrTotalShow << "+0x" << std::hex << std::get<0>(child);
			ssize_t offset = std::get<1>(child);

			if (offset < 0) {
				sstrTotalShow << "-0x" << std::hex << -offset;
			} else {
				sstrTotalShow << "+0x" << std::hex << offset;
			}
			sstrTotalShow << "]";
		}
		sstrTotalShow << "\n";
	}
	assert(sstrTotalShow.str().length());
}
#endif //MEM_SEARCH_KIT_REVERSE_ADDR_OFFSET_LINK_H

```

`rwProcMem33Module/testMemSearch/jni/MemSearchKit/MemSearchKitSafeMap.h`:

```h
//
// Created by abcz316 on 2020/6/25.
//

#ifndef MEM_SEARCH_KIT_SAFE_MAP_H
#define MEM_SEARCH_KIT_SAFE_MAP_H
#include <map>
#include <mutex>
#include <atomic>
#include <assert.h>
template<typename KeyT, typename ValT> struct MemSearchSafeMap {
	//清空
	void clear() {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		m_mapBlock.clear();
	}
	//获取数组大小
	size_t size() {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		return m_mapBlock.size();
	}
	//添加一个成员
	bool insert(const KeyT & key, const ValT & val) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		m_mapBlock[key] = val;
		return true;
	}
	//根据key获取成员对象
	bool at(const KeyT & key, ValT & out_val) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		auto iter = m_mapBlock.find(key);
		if (iter == m_mapBlock.end()) {
			return false;
		}
		out_val = iter->second;
		return true;
	}
	//删除一个成员
	bool erase(const KeyT & key) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		auto iter = m_mapBlock.find(key);
		if (iter == m_mapBlock.end()) {
			return false;
		}
		m_mapBlock.erase(iter);
		return true;
	}
	void to_vector(std::vector<ValT> & vTarget) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		for (auto iter : m_mapBlock) {
			vTarget.push_back(iter.second);
		}
	}
private:
	std::map<KeyT, ValT> m_mapBlock;
	std::mutex m_lockBlockAccess;
};


#endif //MEM_SEARCH_KIT_SAFE_MAP_H

```

`rwProcMem33Module/testMemSearch/jni/MemSearchKit/MemSearchKitSafeVector.h`:

```h
//
// Created by abcz316 on 2020/6/25.
//

#ifndef MEM_SEARCH_KIT_SAFE_VECTOR_H
#define MEM_SEARCH_KIT_SAFE_VECTOR_H
#include <vector>
#include <iterator>
#include <mutex>
#include <algorithm>
#include <atomic>
#include <assert.h>
template<typename T> struct MemSearchSafeVector {
	MemSearchSafeVector() {}
	MemSearchSafeVector(const std::vector<T> vBlock) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		m_vBlock.assign(vBlock.begin(), vBlock.end());
	}
	//清空
	void clear() {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		m_vBlock.clear();
		m_nFastBlockCount = 0;
	}
	//获取数组大小
	size_t size() {
		return m_nFastBlockCount;
	}
	//添加一个成员
	bool push_back(const T& in) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		m_vBlock.push_back(in);
		m_nFastBlockCount++;
		return true;
	}
	//获取一个成员
	bool pop_back(T& out) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		if (!m_vBlock.size()) {
			return false;
		}
		out = m_vBlock.back();
		m_vBlock.pop_back();
		m_nFastBlockCount--;
		return true;
	}
	//获取一个成员
	bool pop_back(size_t get_cnt, std::vector<T>& vOut) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		if (get_cnt > m_vBlock.size()) {
			return false;
		}
		vOut.clear();
		for (; get_cnt > 0; get_cnt--) {
			if (!m_vBlock.size()) {
				break;
			}
			auto out_obj = m_vBlock.back();
			m_vBlock.pop_back();
			vOut.push_back(out_obj);
			m_nFastBlockCount--;
		}
		return true;
	}
	//拷贝成员
	void copy_vals_to(std::vector<T>& vOut) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		vOut.clear();
		vOut.assign(m_vBlock.begin(), m_vBlock.end());
	}
	void copy_vals_to(MemSearchSafeVector& targetMemSearchSafeVector) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		targetMemSearchSafeVector.clean();
		for (auto& item : m_vBlock) {
			targetMemSearchSafeVector.push_back(item);
		}
	}
	void assign(MemSearchSafeVector& src) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		m_vBlock.assign(src.begin(), src.end());
	}
	//根据数组下标获取成员对象
	const T& at(size_t i) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		assert(i < m_nFastBlockCount);
		return m_vBlock.at(i);
	}
	//数组排序
	void sort(bool func(const T& a, const T& b)) {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		std::sort(m_vBlock.begin(), m_vBlock.end(), func);
	}
	auto begin() {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		return m_vBlock.begin();
	}
	auto end() {
		std::lock_guard<std::mutex> mlock(m_lockBlockAccess);
		return m_vBlock.end();
	}
private:
	std::vector<T> m_vBlock;
	std::atomic<size_t> m_nFastBlockCount{ 0 };
	std::mutex m_lockBlockAccess;
};


#endif //MEM_SEARCH_KIT_SAFE_VECTOR_H

```

`rwProcMem33Module/testMemSearch/jni/MemSearchKit/MemSearchKitSafeWorkBlockWrapper.h`:

```h
#ifndef MEM_SEARCH_KIT_SAFE_WORK_BLOCK_WRAPPER_H_
#define MEM_SEARCH_KIT_SAFE_WORK_BLOCK_WRAPPER_H_
#include <string>
#include <memory>
#include <mutex>
#include <vector>
#include <assert.h>
#include "../../../testKo/jni/IMemReaderWriterProxy.h"

#ifndef min
#define min(a,b) (((a)<(b))?(a):(b))
#endif
struct IMemDataProvider {
	virtual BOOL ReadMemory(
		uint64_t lpBaseAddress,
		void *lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesRead) = 0;
};

class SimpleDriverMemDataProvider : public IMemDataProvider {
public:
	SimpleDriverMemDataProvider(IMemReaderWriterProxy * pReadWriteProxy, uint64_t hProcess)
		: m_pReadWriteProxy(pReadWriteProxy), m_hProcess(hProcess) {

	}
protected:
	BOOL ReadMemory(
		uint64_t lpBaseAddress,
		void *lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesRead) override {
		if (!m_pReadWriteProxy) {
			return FALSE;
		}
		
		return m_pReadWriteProxy->ReadProcessMemory(m_hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
	}
private:
	IMemReaderWriterProxy * m_pReadWriteProxy = nullptr;
	uint64_t m_hProcess = 0;
};

class MemSearchSafeWorkBlockWrapper : public std::enable_shared_from_this<MemSearchSafeWorkBlockWrapper> {
public:
	struct MemWorkBlock {
		uint64_t startAddr = 0;
		std::shared_ptr<unsigned char> spMemData;
		uint64_t originMemDataSize = 0;

		uint64_t workLimitSize = 0;

		std::shared_ptr<std::atomic<uint64_t>> spCurWorkOffset;
		uint64_t originWorkOffset = 0;
	};

	//设置内存数据提供器
	void set_mem_data_provider(IMemDataProvider *pMemDataProvider = nullptr) {
		m_pMemDataProvider = pMemDataProvider;
	}
	//获取内存数据提供器
	IMemDataProvider * get_mem_data_provider() {
		return m_pMemDataProvider;
	}

	//添加一个可工作的内存区域
	bool push_back(uint64_t startAddr, uint64_t workLimitSize, uint64_t originWorkOffset,
		uint64_t originMemDataSize, IMemDataProvider *pMemDataProvider = nullptr) {

		std::lock_guard<std::mutex> mlock(m_lockAccess);
		MemWorkBlock oNewWorkBlock;
		oNewWorkBlock.startAddr = startAddr;
		oNewWorkBlock.workLimitSize = workLimitSize;
		oNewWorkBlock.spCurWorkOffset = std::make_shared<std::atomic<uint64_t>>(originWorkOffset);
		oNewWorkBlock.originWorkOffset = originWorkOffset;
		oNewWorkBlock.originMemDataSize = originMemDataSize;
		m_vNormalMemBlock.push_back(oNewWorkBlock);
		set_mem_data_provider(pMemDataProvider);
		return true;
	}
	bool push_back(const MemWorkBlock & block, IMemDataProvider *pMemDataProvider = nullptr) {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		m_vNormalMemBlock.push_back(block);
		set_mem_data_provider(pMemDataProvider);
		return true;
	}

	//释放无用的内存
	void release_useless_mem_block() {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		assert(m_pMemDataProvider);
		if (!m_pMemDataProvider) {
			return;
		}
		for (auto i = 0; i < normal_block_count(); i++) {
			auto & block = m_vNormalMemBlock[i];
			if (block.spCurWorkOffset->load() >= block.workLimitSize) {
				block.spMemData = nullptr;
			}
		}
	}

	//获取一个需要工作的内存区域
	bool get_need_work_mem_block(size_t canWorkSize, uint64_t & outMemStartAddr, uint64_t & outMemSize,
		std::shared_ptr<unsigned char> & spOutMemData,
		uint64_t & outCurWorkOffset) {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		assert(m_pMemDataProvider);
		if (!m_pMemDataProvider) {
			return false;
		}
		for (auto i = 0; i < normal_block_count(); i++) {
			auto & block = m_vNormalMemBlock[i];
			if (block.spCurWorkOffset->load() >= block.workLimitSize) {
				continue;
			}
			//开始读内存
			if (!block.spMemData) {
				size_t nNumberOfBytesRead = 0;
				std::shared_ptr<unsigned char> spMem(new unsigned char[block.workLimitSize], std::default_delete<unsigned char[]>());
				if (!m_pMemDataProvider->ReadMemory(block.startAddr, spMem.get(), block.workLimitSize, &nNumberOfBytesRead) ||
					nNumberOfBytesRead != block.workLimitSize) {
					spMem = nullptr;
					//读内存失败了，先跳过这段内存这样处理吧
					block.spCurWorkOffset->store(block.workLimitSize);
					m_vErrorMemBlock.push_back(block); //记录起来
					continue;
				}
				block.spMemData = spMem;
			}
			outCurWorkOffset = block.spCurWorkOffset->fetch_add(canWorkSize);
			outMemStartAddr = block.startAddr;
			outMemSize = block.workLimitSize;
			spOutMemData = block.spMemData;
			return true;

		}
		return false;
	}
	//清空全部
	void clean() {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		_clean();
	}
	//恢复内存块初始进度
	void recover_normal_block_origin_progress() {
		std::lock_guard<std::mutex> mlock(m_lockAccess);

		std::vector<MemWorkBlock> vNormalMemBlock(m_vNormalMemBlock);
		IMemDataProvider * pMemDataProvider = m_pMemDataProvider;
		_clean();
		m_pMemDataProvider = pMemDataProvider;
		m_vNormalMemBlock.assign(vNormalMemBlock.begin(), vNormalMemBlock.end());
		for (auto & item : m_vNormalMemBlock) {
			if (item.spCurWorkOffset) {
				item.spCurWorkOffset->store(item.originWorkOffset);
			}
		}
	}
	//获取内存块数量
	size_t normal_block_count() {
		return m_vNormalMemBlock.size();
	}
	//获取内存块工作失败数量
	size_t error_block_count() {
		return m_vErrorMemBlock.size();
	}
	//拷贝内存块
	void copy_normal_block_to(std::vector<MemWorkBlock> & vMemBlock) {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		vMemBlock = m_vNormalMemBlock;
	}
	void copy_normal_block_to(MemSearchSafeWorkBlockWrapper & targetWorkBlockWrapper, bool copy_new_cur_work_offset = true, bool copy_new_mem_data = true) {
		std::vector<MemWorkBlock> vMemBlock;
		copy_normal_block_to(vMemBlock);
		targetWorkBlockWrapper.clean();
		for (auto & item : vMemBlock) {
			if (copy_new_cur_work_offset && item.spCurWorkOffset) {
				std::shared_ptr<std::atomic<uint64_t>> spNewOffset = std::make_shared<std::atomic<uint64_t>>(0);
				spNewOffset->store(item.spCurWorkOffset->load());
				item.spCurWorkOffset = spNewOffset;
			}
			if (copy_new_mem_data && item.spMemData) {
				std::shared_ptr<unsigned char> spNewMem(new unsigned char[item.originMemDataSize], std::default_delete<unsigned char[]>());
				memcpy(spNewMem.get(), item.spMemData.get(), item.originMemDataSize);
				item.spMemData = spNewMem;
			}
			targetWorkBlockWrapper.push_back(item);
		}
		targetWorkBlockWrapper.set_mem_data_provider(get_mem_data_provider());
	}

	//拷贝工作失败的内存块
	void copy_error_block_to(std::vector<MemWorkBlock> & vErrorMemBlock) {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		vErrorMemBlock = m_vErrorMemBlock;
	}
	//获取内存总大小
	uint64_t get_mem_total_size() {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		uint64_t total = 0;
		for (auto & item : m_vNormalMemBlock) {
			total += item.originMemDataSize;
		}
		return total;
	}
	//获取剩余未工作的内存大小
	uint64_t get_mem_remaining_size() {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		uint64_t remainingMemSize = 0;
		for (auto & item : m_vNormalMemBlock) {
			remainingMemSize += item.workLimitSize - min(item.workLimitSize, item.spCurWorkOffset->load());
		}
		return remainingMemSize;
	}
private:
	void _clean() {
		m_vNormalMemBlock.clear();
		m_vErrorMemBlock.clear();
		m_pMemDataProvider = nullptr;
	}

private:
	std::mutex m_lockAccess;

	std::vector<MemWorkBlock> m_vNormalMemBlock;
	std::vector<MemWorkBlock> m_vErrorMemBlock;
	
	std::atomic<size_t> m_nFastNormalMemBlockCount{ 0 };
	std::atomic<size_t> m_nFastErrorMemBlockCount{ 0 };

	IMemDataProvider *m_pMemDataProvider = nullptr;
};
#endif /* MEM_SEARCH_KIT_SAFE_WORK_BLOCK_WRAPPER_H_ */


```

`rwProcMem33Module/testMemSearch/jni/MemSearchKit/MemSearchKitSafeWorkSecWrapper.h`:

```h
#ifndef MEM_SEARCH_KIT_SAFE_WORK_SEC_WRAPPER_H_
#define MEM_SEARCH_KIT_SAFE_WORK_SEC_WRAPPER_H_
#include <string>
#include <memory>
#include <mutex>
#include <vector>
#include <assert.h>
#include "../../../testKo/jni/IMemReaderWriterProxy.h"

#ifndef min
#define min(a,b) (((a)<(b))?(a):(b))
#endif
struct IMemDataProvider {
	virtual BOOL ReadMemory(
		uint64_t lpBaseAddress,
		void *lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesRead) = 0;
};

class SimpleDriverMemDataProvider : public IMemDataProvider {
public:
	SimpleDriverMemDataProvider(IMemReaderWriterProxy * pReadWriteProxy, uint64_t hProcess)
		: m_pReadWriteProxy(pReadWriteProxy), m_hProcess(hProcess) {

	}
protected:
	BOOL ReadMemory(
		uint64_t lpBaseAddress,
		void *lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesRead) override {
		if (!m_pReadWriteProxy) {
			return FALSE;
		}
		return m_pReadWriteProxy->ReadProcessMemory(m_hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
	}
private:
	IMemReaderWriterProxy * m_pReadWriteProxy = nullptr;
	uint64_t m_hProcess = 0;
};

class MemSearchSafeWorkSecWrapper : public std::enable_shared_from_this<MemSearchSafeWorkSecWrapper> {
public:
	struct WorkMemSecBlock {
		uint64_t startAddr = 0;
		uint64_t workLimitSize = 0;
		std::shared_ptr<std::atomic<uint64_t>> spCurWorkOffset;
		uint64_t originWorkOffset = 0;
		std::shared_ptr<unsigned char> spMemData;
		uint64_t originMemDataSize = 0;
	};

	//设置内存数据提供器
	void set_mem_data_provider(IMemDataProvider *pMemDataProvider = nullptr) {
		m_pMemDataProvider = pMemDataProvider;
	}
	//获取内存数据提供器
	IMemDataProvider * get_mem_data_provider() {
		return m_pMemDataProvider;
	}

	//添加一个可工作的内存区域
	bool push_back(uint64_t startAddr, uint64_t workLimitSize, uint64_t originWorkOffset,
		uint64_t originMemDataSize, IMemDataProvider *pMemDataProvider = nullptr) {

		std::lock_guard<std::mutex> mlock(m_lockAccess);
		WorkMemSecBlock oNewWorkSecBlock;
		oNewWorkSecBlock.startAddr = startAddr;
		oNewWorkSecBlock.workLimitSize = workLimitSize;
		oNewWorkSecBlock.spCurWorkOffset = std::make_shared<std::atomic<uint64_t>>(originWorkOffset);
		oNewWorkSecBlock.originWorkOffset = originWorkOffset;
		oNewWorkSecBlock.originMemDataSize = originMemDataSize;
		m_vNormalMemBlock.push_back(oNewWorkSecBlock);
		set_mem_data_provider(pMemDataProvider);
		m_nFastNormalMemBlockCount++;
		return true;
	}
	bool push_back(const WorkMemSecBlock & block, IMemDataProvider *pMemDataProvider = nullptr) {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		m_vNormalMemBlock.push_back(block);
		set_mem_data_provider(pMemDataProvider);
		m_nFastNormalMemBlockCount++;
		return true;
	}

	//获取一个需要工作的内存区域
	bool get_need_work_mem_sec(uint64_t & outMemStartAddr, uint64_t & outMemSize,
		std::shared_ptr<std::atomic<uint64_t>> & spOutCurWorkOffset,
		std::shared_ptr<unsigned char> & spOutMemDataBlock,
		bool releaseUselessBlockMemData = true) {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		assert(m_pMemDataProvider);
		if (!m_pMemDataProvider) {
			return false;
		}
		for (; m_nNormalMemIndex < normal_block_count(); m_nNormalMemIndex++) {
			auto & sec = m_vNormalMemBlock[m_nNormalMemIndex];
			if (sec.spCurWorkOffset->load() >= sec.workLimitSize) {
				if (releaseUselessBlockMemData) { //释放无用的内存
					sec.spMemData = nullptr;
				}
				continue;
			}
			//开始读内存
			if (!sec.spMemData) {
				size_t nNumberOfBytesRead = 0;
				std::shared_ptr<unsigned char> spMem(new unsigned char[sec.workLimitSize], std::default_delete<unsigned char[]>());

				if (!m_pMemDataProvider->ReadMemory(sec.startAddr, spMem.get(), sec.workLimitSize, &nNumberOfBytesRead) ||
					nNumberOfBytesRead != sec.workLimitSize) {
					//读内存失败了，先跳过这段内存这样处理吧
					sec.spCurWorkOffset->store(sec.workLimitSize);
					m_vErrorMemBlock.push_back(sec); //记录起来
					continue;
				}
				sec.spMemData = spMem;
			}
			spOutCurWorkOffset = sec.spCurWorkOffset;
			outMemStartAddr = sec.startAddr;
			outMemSize = sec.workLimitSize;
			spOutMemDataBlock = sec.spMemData;
			return true;

		}
		return false;
	}
	//清空全部
	void clean() {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		_clean();
	}
	//恢复内存块初始进度
	void recover_normal_block_origin_progress() {
		std::lock_guard<std::mutex> mlock(m_lockAccess);

		std::vector<WorkMemSecBlock> vNormalMemBlock(m_vNormalMemBlock);
		IMemDataProvider * pMemDataProvider = m_pMemDataProvider;
		_clean();
		m_pMemDataProvider = pMemDataProvider;
		m_vNormalMemBlock.assign(vNormalMemBlock.begin(), vNormalMemBlock.end());
		m_nFastNormalMemBlockCount = m_vNormalMemBlock.size();
		for (auto & item : m_vNormalMemBlock) {
			if (item.spCurWorkOffset) {
				item.spCurWorkOffset->store(item.originWorkOffset);
			}
		}
	}
	//获取内存块数量
	size_t normal_block_count() {
		return m_nFastNormalMemBlockCount;
	}
	//获取内存块工作失败数量
	size_t error_block_count() {
		return m_nFastErrorMemBlockCount;
	}
	//拷贝内存块
	void copy_normal_block_to(std::vector<WorkMemSecBlock> & vMemBlock) {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		vMemBlock = m_vNormalMemBlock;
	}
	void copy_normal_block_to(MemSearchSafeWorkSecWrapper & targetWorkSecWrapper, bool copy_new_cur_work_offset = true, bool copy_new_mem_data = true) {
		std::vector<WorkMemSecBlock> vMemBlock;
		copy_normal_block_to(vMemBlock);
		targetWorkSecWrapper.clean();
		for (auto & item : vMemBlock) {
			if (copy_new_cur_work_offset && item.spCurWorkOffset) {
				std::shared_ptr<std::atomic<uint64_t>> spNewOffset = std::make_shared<std::atomic<uint64_t>>(0);
				spNewOffset->store(item.spCurWorkOffset->load());
				item.spCurWorkOffset = spNewOffset;
			}
			if (copy_new_mem_data && item.spMemData) {
				std::shared_ptr<unsigned char> spNewMem(new unsigned char[item.originMemDataSize], std::default_delete<unsigned char[]>());
				memcpy(spNewMem.get(), item.spMemData.get(), item.originMemDataSize);
				item.spMemData = spNewMem;
			}
			targetWorkSecWrapper.push_back(item);
		}
		targetWorkSecWrapper.set_mem_data_provider(get_mem_data_provider());
	}

	//拷贝工作失败的内存块
	void copy_error_block_to(std::vector<WorkMemSecBlock> & vErrorMemBlock) {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		vErrorMemBlock = m_vErrorMemBlock;
	}
	//获取内存总大小
	uint64_t get_mem_total_size() {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		uint64_t total = 0;
		for (auto & item : m_vNormalMemBlock) {
			total += item.originMemDataSize;
		}
		return total;
	}
	//获取剩余未工作的内存大小
	uint64_t get_mem_remaining_size() {
		std::lock_guard<std::mutex> mlock(m_lockAccess);
		uint64_t remainingMemSize = 0;
		for (auto & item : m_vNormalMemBlock) {
			remainingMemSize += item.workLimitSize - min(item.workLimitSize, item.spCurWorkOffset->load());
		}
		return remainingMemSize;
	}
private:
	void _clean() {
		m_nNormalMemIndex = 0;
		m_vNormalMemBlock.clear();
		m_vErrorMemBlock.clear();
		m_nFastNormalMemBlockCount = 0;
		m_nFastErrorMemBlockCount = 0;
		m_pMemDataProvider = nullptr;
	}

private:
	std::mutex m_lockAccess;

	int m_nNormalMemIndex = 0;
	std::vector<WorkMemSecBlock> m_vNormalMemBlock;
	std::vector<WorkMemSecBlock> m_vErrorMemBlock;
	
	std::atomic<size_t> m_nFastNormalMemBlockCount{ 0 };
	std::atomic<size_t> m_nFastErrorMemBlockCount{ 0 };

	IMemDataProvider *m_pMemDataProvider = nullptr;
};
#endif /* MEM_SEARCH_KIT_SAFE_WORK_SEC_WRAPPER_H_ */


```

`rwProcMem33Module/testMemSearch/jni/MemSearchKit/MemSearchKitString.h`:

```h
#ifndef MEM_SEARCH_STRING_CORE_H_
#define MEM_SEARCH_STRING_CORE_H_
#include <stdio.h>
#include <string.h>
namespace MemorySearchKit {

	namespace String {

		static inline std::string& replace_all_distinct(std::string& str, const std::string& old_value, const std::string& new_value) {
			for (std::string::size_type pos(0); pos != std::string::npos; pos += new_value.length()) {
				if ((pos = str.find(old_value, pos)) != std::string::npos) {
					str.replace(pos, old_value.length(), new_value);
				} else {
					break;
				}
			}
			return str;
		}

	}

}
#endif /* MEM_SEARCH_STRING_CORE_H_ */


```

`rwProcMem33Module/testMemSearch/jni/MemSearchKit/MemSearchKitUmbrella.h`:

```h
#ifndef MEM_SEARCH_KIT_UMBRELLA_H_
#define MEM_SEARCH_KIT_UMBRELLA_H_
#include "MemSearchKitCore.h"
#include "MemSearchKitReverseAddrOffsetLink.h"

namespace MemorySearchKit {
	/*
	内存搜索数值
	pReadWriteProxy：读取进程内存数据的接口
	hProcess：被搜索的进程句柄
	spvWaitScanMemBlockList: 被搜索的进程内存区域
	value1: 要搜索的数值1
	value2: 要搜索的数值2
	errorRange: 误差范围（当搜索的数值为float或者double时此值有效，其余情况请填写0）
	scanType：搜索类型：
					ACCURATE_VAL精确数值（value1生效）、
					LARGER_THAN_VAL值大于（value1生效）、
					LESS_THAN_VAL值小于（value1生效）、
					BETWEEN_VAL值在两值之间（value1、value2生效）
	nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
	vResultList：存放搜索完成的结果地址
	nScanAlignBytesCount：扫描的对齐字节数，默认为待搜索数值的结构大小
	pForceStopSignal: 强制中止所有任务的信号
	)
	*/
	template<typename T> static MEM_SEARCH_STATUS SearchValue(
		IMemReaderWriterProxy* pReadWriteProxy, uint64_t hProcess,
		std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
		T value1, T value2, float errorRange, SCAN_TYPE scanType, size_t nThreadCount,
		std::vector<ADDR_RESULT_INFO> & vResultList,
		size_t nScanAlignBytesCount = sizeof(T),
		std::atomic<bool> * pForceStopSignal = nullptr) {
		return Core::SearchValue(
			pReadWriteProxy, hProcess, spvWaitScanMemBlockList, value1, value2, errorRange, scanType,
			nThreadCount, vResultList, nScanAlignBytesCount, pForceStopSignal); 
	}


	/*
	再次搜索内存数值
	pReadWriteProxy：读取进程内存数据的接口
	hProcess：被搜索的进程句柄
	vWaitScanMemAddr: 需要被再次搜索的内存地址列表
	value1: 要搜索数值1
	value2: 要搜索数值2
	errorRange: 误差范围（当搜索的数值为float或者double时此值有效，其余情况请填写0）
	scanType：搜索类型：
					ACCURATE_VAL精确数值（value1生效）、
					LARGER_THAN_VAL值大于（value1生效）、
					LESS_THAN_VAL值小于（value1生效）、
					BETWEEN_VAL值在两值之间（value1、value2生效）、
					ADD_UNKNOW_VAL值增加了未知值（value1、value2均无效），
					ADD_ACCURATE_VAL值增加了精确值（value1生效），
					SUB_UNKNOW_VAL值减少了未知值（value1、value2均无效），
					SUB_ACCURATE_VAL值减少了精确值（value1生效），
					CHANGED_VAL变动了的数值（value1、value2均无效），
					UNCHANGED_VAL未变动的数值（value1、value2均无效）
	nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
	vResultList：存放搜索完成的结果地址
	vErrorList：存放实时搜索失败的结果地址
	pForceStopSignal: 强制中止所有任务的信号
	*/
	template<typename T> static MEM_SEARCH_STATUS SearchAddrNextValue(
		IMemReaderWriterProxy* pReadWriteProxy,
		uint64_t hProcess,
		const std::vector<ADDR_RESULT_INFO> & vWaitScanMemAddr,
		T value1, T value2, float errorRange, SCAN_TYPE scanType, size_t nThreadCount,
		std::vector<ADDR_RESULT_INFO> & vResultList,
		std::vector<ADDR_RESULT_INFO> & vErrorList,
		std::atomic<bool> * pForceStopSignal = nullptr) {

		return Core::SearchAddrNextValue(
			pReadWriteProxy, hProcess, vWaitScanMemAddr,
			value1, value2, errorRange, scanType, nThreadCount,
			vResultList, vErrorList, pForceStopSignal);
	}

	/*
	内存批量搜索值在两值之间的内存地址
	pReadWriteProxy：读取进程内存数据的接口
	hProcess：被搜索的进程句柄
	spvWaitScanMemBlockList: 被搜索的进程内存区域
	vBatchBetweenValue: 待搜索的批量两值之间的数值数组
	nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
	vResultList：存放搜索完成的结果地址
	nScanAlignBytesCount：扫描的对齐字节数，默认为待搜索数值的结构大小
	pForceStopSignal: 强制中止所有任务的信号
	*/
	template<typename T> static MEM_SEARCH_STATUS SearchBatchBetweenValue(
		IMemReaderWriterProxy* pReadWriteProxy,
		uint64_t hProcess,
		std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
		const std::vector<BATCH_BETWEEN_VAL<T>> & vBatchBetweenValue,
		size_t nThreadCount,
		std::vector<BATCH_BETWEEN_VAL_ADDR_RESULT<T>> & vResultList,
		size_t nScanAlignBytesCount = sizeof(T),
		std::atomic<bool> * pForceStopSignal = nullptr) {

		return Core::SearchBatchBetweenValue(
			pReadWriteProxy, hProcess, spvWaitScanMemBlockList, vBatchBetweenValue,
			nThreadCount, vResultList, nScanAlignBytesCount, pForceStopSignal); 
	}

	/*
	内存搜索文本特征码
	pReadWriteProxy：读取进程内存数据的接口
	hProcess：被搜索的进程句柄
	spvWaitScanMemBlockList: 被搜索的进程内存区域
	strFeaturesByte: 十六进制的文本字节特征码，搜索规则与OD相同，如“68 00 00 00 40 ?3 7? ?? ?? ?? ?? ?? ?? 50 E8”
	nThreadCount: 用于搜索内存的线程数，推荐设置为CPU数量
	vResultList：存放搜索完成的结果地址
	nScanAlignBytesCount：扫描的对齐字节数，默认为1
	pForceStopSignal: 强制中止所有任务的信号
	)
	*/
	static MEM_SEARCH_STATUS SearchFeaturesByteString(
		IMemReaderWriterProxy* pReadWriteProxy,
		uint64_t hProcess,
		std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
		std::string strFeaturesByte,
		size_t nThreadCount,
		std::vector<ADDR_RESULT_INFO> & vResultList,
		size_t nScanAlignBytesCount = 1,
		std::atomic<bool> * pForceStopSignal = nullptr) {
		

		return Core::SearchFeaturesByteString(
			pReadWriteProxy, hProcess, spvWaitScanMemBlockList, strFeaturesByte,
			nThreadCount, vResultList, nScanAlignBytesCount, pForceStopSignal); 
	}


	/*
	再次搜索内存文本特征码
	pReadWriteProxy：读取进程内存数据的接口
	hProcess：被搜索的进程句柄
	vWaitScanMemAddr: 需要再次搜索的内存地址列表
	strFeaturesByte: 十六进制的文本字节特征码，搜索规则与OD相同，如“68 00 00 00 40 ?3 7? ?? ?? ?? ?? ?? ?? 50 E8”
	nThreadCount: 用于搜索内存的线程数，推荐设置为CPU数量
	vResultList：存放搜索完成的结果地址
	vErrorList：存放实时搜索失败的结果地址
	nScanAlignBytesCount：扫描的对齐字节数，默认为1
	pForceStopSignal: 强制中止所有任务的信号
	)
	*/
	static MEM_SEARCH_STATUS SearchAddrNextFeaturesByteString(
		IMemReaderWriterProxy* pReadWriteProxy,
		uint64_t hProcess,
		const std::vector<ADDR_RESULT_INFO> & vWaitScanMemAddr,
		std::string strFeaturesByte,
		size_t nThreadCount,
		std::vector<ADDR_RESULT_INFO> & vResultList,
		std::vector<ADDR_RESULT_INFO> & vErrorList,
		size_t nScanAlignBytesCount = 1,
		std::atomic<bool> * pForceStopSignal = nullptr) {
		
		
		return Core::SearchAddrNextFeaturesByteString(
			pReadWriteProxy, hProcess, vWaitScanMemAddr, strFeaturesByte,
			nThreadCount, vResultList, vErrorList, nScanAlignBytesCount, pForceStopSignal); 
	}


	/*
	内存搜索字节特征码
	pReadWriteProxy：读取进程内存数据的接口
	hProcess：被搜索的进程句柄
	spvWaitScanMemBlockList: 被搜索的进程内存区域
	vFeaturesByte：字节特征码，如“char vBytes[] = {'\x68', '\x00', '\x00', '\x00', '\x40', '\x?3', '\x??', '\x7?', '\x??', '\x??', '\x??', '\x??', '\x??', '\x50', '\xE8};”
	nFeaturesByteLen：字节特征码长度
	vFuzzyBytes：模糊字节，不变动的位置用1表示，变动的位置用0表示，如“char vFuzzy[] = {'\x11', '\x11', '\x11', '\x11', '\x11', '\x01', '\x00', '\x10', '\x00', '\x00', '\x00', '\x00', '\x00', '\x11', '\x11};”
	nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
	vResultList：存放搜索完成的结果地址
	nScanAlignBytesCount：扫描的对齐字节数，默认为1
	pForceStopSignal: 强制中止所有任务的信号
	)
	*/
	static MEM_SEARCH_STATUS SearchFeaturesBytes(
		IMemReaderWriterProxy* pReadWriteProxy,
		uint64_t hProcess,
		std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
		const char vFeaturesByte[],
		size_t nFeaturesByteLen,
		char vFuzzyBytes[],
		size_t nThreadCount,
		std::vector<ADDR_RESULT_INFO> & vResultList,
		size_t nScanAlignBytesCount = 1,
		std::atomic<bool> * pForceStopSignal = nullptr) {
		

		return Core::SearchFeaturesBytes(
			pReadWriteProxy, hProcess, spvWaitScanMemBlockList, vFeaturesByte,
			nFeaturesByteLen, vFuzzyBytes, nThreadCount, vResultList,
			nScanAlignBytesCount, pForceStopSignal); 
	}

	/*
	再次搜索内存字节特征码
	pReadWriteProxy：读取进程内存数据的接口
	hProcess：被搜索的进程句柄
	vWaitScanMemAddr: 需要再次搜索的内存地址列表
	vFeaturesByte：字节特征码，如“char vBytes[] = {0x68, 0x00, 0x00, 0x00, 0x40, 0x?3, 0x??, 0x7?, 0x??, 0x??, 0x??, 0x??, 0x??, 0x50, 0xE8};”
	nFeaturesByteLen：字节特征码长度
	vFuzzyBytes：模糊字节，不变动的位置用1表示，变动的位置用0表示，如“char vFuzzy[] = {0x11, 0x11, 0x11, 0x11, 0x11, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11};”
	nThreadCount：用于搜索内存的线程数，推荐设置为CPU数量
	vResultList：存放搜索完成的结果地址
	vErrorList：存放实时搜索失败的结果地址
	nScanAlignBytesCount：扫描的对齐字节数，默认为1
	pForceStopSignal: 强制中止所有任务的信号
	)
	*/
	static MEM_SEARCH_STATUS SearchAddrNextFeaturesBytes(
		IMemReaderWriterProxy* pReadWriteProxy,
		uint64_t hProcess,
		const std::vector<ADDR_RESULT_INFO> & vWaitScanMemAddr,
		char vFeaturesByte[],
		size_t nFeaturesByteLen,
		char vFuzzyBytes[],
		size_t nThreadCount,
		std::vector<ADDR_RESULT_INFO> & vResultList,
		std::vector<ADDR_RESULT_INFO> & vErrorList,
		size_t nScanAlignBytesCount = 1,
		std::atomic<bool> * pForceStopSignal = nullptr) {
		

		return Core::SearchAddrNextFeaturesBytes(
			pReadWriteProxy, hProcess, vWaitScanMemAddr,
			vFeaturesByte, nFeaturesByteLen, vFuzzyBytes, nThreadCount,
			vResultList, vErrorList, nScanAlignBytesCount, pForceStopSignal); 
	}


	/*
	拷贝进程内存数据
	pReadWriteProxy：读取进程内存数据的接口
	hProcess：被搜索的进程句柄
	spvWaitScanMemBlockList: 被拷贝的进程内存区域
	nThreadCount：用于拷贝内存的线程数，推荐设置为CPU数量
	std::atomic<bool> * pForceStopSignal: 强制中止所有任务的信号
	*/
	static MEM_SEARCH_STATUS CopyProcessMemData(
		IMemReaderWriterProxy* pReadWriteProxy,
		uint64_t hProcess,
		std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlockList,
		size_t nThreadCount,
		std::atomic<bool> * pForceStopSignal = nullptr) {

		return Core::CopyProcessMemData(
			pReadWriteProxy, hProcess, spvWaitScanMemBlockList,
			nThreadCount, pForceStopSignal);
	}

	/*
	CPU多线程执行函数
	nThreadCount：线程数
	void OnThreadExecute(size_t thread_id，std::atomic<bool> *pForceStopSignal)：每条线程要执行的任务回调（线程ID号，中止信号）
	std::atomic<bool> * pForceStopSignal: 强制中止所有任务的信号
	*/
	static void MultiThreadExecOnCpu(
		size_t nThreadCount,
		std::function<void(size_t thread_id, std::atomic<bool> *pForceStopSignal)> OnThreadExecut,
		std::atomic<bool> * pForceStopSignal = nullptr) {

		Core::MultiThreadOnCpu(
			nThreadCount, std::move(OnThreadExecut), pForceStopSignal);
	}


}
#endif /* MEM_SEARCH_KIT_UMBRELLA_H_ */


```

`rwProcMem33Module/testMemSearch/jni/ProcMapsFileReader.h`:

```h
//
// Created by abcz316 on 2020/2/26.
//

#ifndef PROC_MAPS_FILE_READER_H
#define PROC_MAPS_FILE_READER_H
#include "../../testKo/jni/MemoryReaderWriter39.h"
#include <fstream>
#ifndef __linux__
#include <windows.h>
#endif
#include "MapRegionType.h"

class ProcMapsFileReader : public IMemReaderWriterProxy {
   public:
	ProcMapsFileReader(int _pid) : pid(_pid) {}
	~ProcMapsFileReader() {}
	BOOL VirtualQueryExFull(uint64_t hProcess,
							BOOL showPhy,
							std::vector<DRIVER_REGION_INFO>& vOutput) override {
		vOutput.clear();
		std::stringstream ss;
		ss << "/proc/" << pid << "/maps";
		std::string mapsPath = ss.str();

		std::ifstream mapsFile(mapsPath);
		if (!mapsFile.is_open()) {
			return FALSE;
		}

		std::string line;
		while (std::getline(mapsFile, line)) {
			std::stringstream linestream(line);

			std::string addrRange, perms, offset, dev, inode;
			std::string pathname;

			linestream >> addrRange >> perms >> offset >> dev >> inode;
			if (!linestream.eof()) {
				std::getline(linestream, pathname);
				if (!pathname.empty() && pathname[0] == ' ') {
					pathname.erase(0, 1);
				}
			}
			size_t dashPos = addrRange.find('-');
			if (dashPos == std::string::npos) {
				continue;
			}

			std::string startStr = addrRange.substr(0, dashPos);
			std::string endStr = addrRange.substr(dashPos + 1);

			uint64_t startAddr = std::stoull(startStr, nullptr, 16);
			uint64_t endAddr = std::stoull(endStr, nullptr, 16);

			DRIVER_REGION_INFO info = {0};
			info.baseaddress = startAddr;
			info.size = endAddr - startAddr;
			StringToMapsType(perms, info.protection, info.type);
			if (!pathname.empty()) {
				std::strncpy(info.name, pathname.c_str(),
							 sizeof(info.name) - 1);
				info.name[sizeof(info.name) - 1] = '\0';
			}

			vOutput.push_back(info);
		}

		mapsFile.close();
		return TRUE;
	}
	BOOL ReadProcessMemory(
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		void *lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesRead = NULL,
		BOOL bIsForceRead = FALSE) override { return FALSE; }
	BOOL WriteProcessMemory(
		uint64_t hProcess,
		uint64_t lpBaseAddress,
		void * lpBuffer,
		size_t nSize,
		size_t * lpNumberOfBytesWritten = NULL,
		BOOL bIsForceWrite = FALSE) override { return FALSE; }
	BOOL CheckProcessMemAddrValid(
		uint64_t hProcess,
		uint64_t lpBaseAddress) override { return FALSE; }
   private:
	int pid = 0;
};

#endif	// PROC_MAPS_FILE_READER_H

```

`rwProcMem33Module/testMemSearch/jni/testMemSearch.cpp`:

```cpp
#include <cstdio>
#include <string.h> 
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <memory>
#include <dirent.h>
#include <cinttypes>
#include <mutex>
#include "MapRegionHelper.h"
#include "MemSearchKit/MemSearchKitUmbrella.h"


using namespace MemorySearchKit;

int findPID(CMemoryReaderWriter *pDriver, const char *lpszCmdline) {
	int nTargetPid = 0;

	//驱动_获取进程PID列表
	std::vector<int> vPID;
	BOOL b = pDriver->GetPidList(vPID);
	printf("调用驱动 GetPidList 返回值:%d\n", b);

	//打印进程列表信息
	for (int pid : vPID) {
		//驱动_打开进程
		uint64_t hProcess = pDriver->OpenProcess(pid);
		if (!hProcess) { continue; }

		//驱动_获取进程命令行
		char cmdline[100] = { 0 };
		pDriver->GetProcessCmdline(hProcess, cmdline, sizeof(cmdline));

		//驱动_关闭进程
		pDriver->CloseHandle(hProcess);

		if (strcmp(lpszCmdline, cmdline) == 0) {
			nTargetPid = pid;
			break;
		}
	}
	return nTargetPid;
}


//演示多线程普通搜索
void normal_val_search(CMemoryReaderWriter *pRwDriver, uint64_t hProcess, size_t nWorkThreadCount) {

	//获取进程数据内存区域
	std::vector<MemRegionItem> vScanMemMaps;
	GetMemRegions(pRwDriver, hProcess,
		REGION_R0_0,
		vScanMemMaps);
	if (!vScanMemMaps.size()) {
		printf("无内存可搜索\n");
		//关闭进程
		pRwDriver->CloseHandle(hProcess);
		printf("调用驱动 CloseHandle:%" PRIu64 "\n", hProcess);
		fflush(stdout);
		return;
	}
	//准备要搜索的内存区域
	std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlock = std::make_shared<MemSearchSafeWorkBlockWrapper>();
	if (!spvWaitScanMemBlock) {
		return;
	}
	for (auto & item : vScanMemMaps) {
		spvWaitScanMemBlock->push_back(item.baseInfo.baseaddress, item.baseInfo.size, 0, item.baseInfo.size);
	}

	//首次搜索
	std::vector<ADDR_RESULT_INFO> vSearchResult; //搜索结果
	{
		SearchValue<float>(
			pRwDriver,
			hProcess,
			spvWaitScanMemBlock, //待搜索的内存区域
			0.33333334327f, //搜索数值
			0.0f,
			0.01, //误差范围
			SCAN_TYPE::ACCURATE_VAL, //搜索类型: 精确搜索
			nWorkThreadCount, //搜索线程数
			vSearchResult, //搜索后的结果
			4); //扫描的对齐字节数

		printf("共搜索出%zu个地址\n", vSearchResult.size());
	}
	//再次搜索
	if (vSearchResult.size()) {
		//将每个地址往后偏移20
		std::vector<ADDR_RESULT_INFO> vWaitSearchAddr; //待搜索的内存地址列表
		for (auto item : vSearchResult) {
			item.addr += 20;
			vWaitSearchAddr.push_back(item);
		}

		//再次搜索
		vSearchResult.clear();

		std::vector<ADDR_RESULT_INFO> vErrorList;
		SearchAddrNextValue<float>(
			pRwDriver,
			hProcess,
			vWaitSearchAddr, //待搜索的内存地址列表
			1.19175350666f, //搜索数值
			0.0f,
			0.01f, //误差范围
			SCAN_TYPE::ACCURATE_VAL, //搜索类型: 精确搜索
			nWorkThreadCount, //搜索线程数
			vSearchResult,
			vErrorList); //搜索后的结果
	}

	//再次搜索
	if (vSearchResult.size()) {
		//将每个地址往后偏移952
		std::vector<ADDR_RESULT_INFO> vWaitSearchAddr; //待搜索的内存地址列表
		for (auto item : vSearchResult) {
			item.addr += 952;
			vWaitSearchAddr.push_back(item);
		}

		//再次搜索
		vSearchResult.clear();
		std::vector<ADDR_RESULT_INFO> vErrorList;
		SearchAddrNextValue<int>(
			pRwDriver,
			hProcess,
			vWaitSearchAddr, //待搜索的内存地址列表
			-2147483648, //搜索数值
			0,
			0.01, //误差范围
			SCAN_TYPE::ACCURATE_VAL, //搜索类型: 精确搜索
			nWorkThreadCount, //搜索线程数
			vSearchResult, //搜索后的结果
			vErrorList);
	}

	//减少添加的地址
	std::vector<ADDR_RESULT_INFO> vTmpResultList;
	vTmpResultList.assign(vSearchResult.begin(), vSearchResult.end());
	for (auto& item : vSearchResult) {
		int offset = 952 + 20;
		if (item.addr < offset) {
			continue;
		}
		item.addr -= offset;
		vTmpResultList.push_back(item);
	}
	vSearchResult.clear();
	vSearchResult.assign(vTmpResultList.begin(), vTmpResultList.end());

	size_t count = 0;
	for (size_t i = 0; i < vSearchResult.size(); i++) {

		ADDR_RESULT_INFO addr = vSearchResult.at(i);
		printf("addr:%p\n", (void*)addr.addr);
		count++;
		if (count > 100) {
			printf("只显示前100个地址\n");
			break;
		}

	}
	printf("共偏移搜索出%zu个地址\n", vSearchResult.size());
	if (vSearchResult.size()) {
		printf("第一个地址为:%p\n", (void*)vSearchResult.at(0).addr);
	}

}
//演示多线程正向遍历
void loop_search(CMemoryReaderWriter *pRwDriver, uint64_t hProcess, size_t nWorkThreadCount) {

	//获取进程内存块地址列表
	const char * targetModuleName = "libxxx.so";
	std::vector<DRIVER_REGION_INFO> vDataList;
	GetModuleDataAreaSection(pRwDriver, 1, targetModuleName, vDataList);

	std::vector<DRIVER_REGION_INFO> vExecList;
	GetModuleExecAreaSection(pRwDriver, 1, targetModuleName, vExecList);
	if (vExecList.size() == 0) {
		printf("GetMemModuleStartAddr失败");
		return;
	}
	uint64_t execStartAddr = vExecList[0].baseaddress;

	//整理需要工作的内存区域
	std::shared_ptr<MemSearchSafeWorkBlockWrapper> spWorkMemWrapper = std::make_shared<MemSearchSafeWorkBlockWrapper>();
	for (auto & item : vDataList) {
		spWorkMemWrapper->push_back(item.baseaddress, item.size, 0, item.size);
	}
	for (auto & item : vExecList) {
		spWorkMemWrapper->push_back(item.baseaddress, item.size, 0, item.size);
	}
	if (!spWorkMemWrapper->normal_block_count()) {
		printf("GetMemModuleDataAreaSection失败");
		return;
	}
	size_t splitSize = TASK_BLOCK_SIZE;
	struct OffsetResultInfo {
		uint64_t offset[4] = { 0 };
	};
	std::vector<OffsetResultInfo> vResultInfo; //遍历结果

	MultiThreadExecOnCpu(nWorkThreadCount,
		[pRwDriver, hProcess, splitSize, spWorkMemWrapper, execStartAddr, &vResultInfo]
		(size_t thread_id, std::atomic<bool> *pForceStopSignal)->void {

		//////////////////////////////////////////////////////////////////////////

		std::vector<OffsetResultInfo> vThreadOutput; //存放当前线程的搜索结果
		uint64_t curMemBlockStartAddr = 0;
		uint64_t curMemBlockSize = 0;
		std::shared_ptr<unsigned char> spOutMemData;
		uint64_t outCurWorkOffset = 0;

		while (!pForceStopSignal || !*pForceStopSignal) {
			if (!spWorkMemWrapper->get_need_work_mem_block(splitSize, curMemBlockStartAddr, curMemBlockSize, spOutMemData, outCurWorkOffset)) {
				break; //没任务了
			}
		
			//DEBUG
			//uint64_t debugAddr = execStartAddr + 0xAD58338;
			//if (curMemBlockStartAddr <= debugAddr && (curMemBlockStartAddr + curMemBlockSize) > debugAddr) {
			//	outCurWorkOffset = debugAddr - curMemBlockStartAddr;
			//} else {
			//	continue;
			//}

			//////////////////////////////////////////////////////////////////////////

			//读取这个目标内存section的内存数据时直接指针取值，节省开销
			size_t firstReadLen = 8;
			if ((curMemBlockSize - outCurWorkOffset) < firstReadLen) {
				continue;
			}
			uint64_t addr1 = *(uint64_t*)((char*)spOutMemData.get() + outCurWorkOffset);
			//////////////////////////////////////////////////////////////////////////
			if (!pRwDriver->CheckProcessMemAddrValid(hProcess, addr1)) {
				continue;
			}
			for (uint64_t x2 = 0; x2 < 0x200; x2 += 4) {
				uint64_t addr2 = 0;
				if (!pRwDriver->ReadProcessMemory(hProcess, addr1 + x2, &addr2, 8, NULL)) {
					continue;
				}
				if (!pRwDriver->CheckProcessMemAddrValid(hProcess, addr2)) {
					continue;
				}

				for (uint64_t x3 = 0; x3 < 0x200; x3 += 4) {
					uint64_t addr3 = 0;
					if (!pRwDriver->ReadProcessMemory(1, addr2 + x3, &addr3, 8, NULL)) {
						continue;
					}
					if (!pRwDriver->CheckProcessMemAddrValid(hProcess, addr3)) {
						continue;
					}

					for (uint64_t x4 = 0; x4 < 0x200; x4 += 4) {
						uint64_t addr4 = 0;
						if (!pRwDriver->ReadProcessMemory(1, addr3 + x4, &addr4, 8, NULL)) {
							continue;
						}
						if (!pRwDriver->CheckProcessMemAddrValid(hProcess, addr4)) {
							continue;
						}

						//目标
						uint64_t target = 0x7AF6E21600;
						if (addr4 != target) {
							continue;
						}

						OffsetResultInfo newOffset;
						newOffset.offset[0] = curMemBlockStartAddr + outCurWorkOffset - execStartAddr;
						newOffset.offset[1] = x2;
						newOffset.offset[2] = x3;
						newOffset.offset[3] = x4;
						vThreadOutput.push_back(newOffset);
					}
				}
			}
		}
		//将当前线程的搜索结果，汇总到父线程的全部搜索结果数组里
		for (auto & item : vThreadOutput) {
			vResultInfo.push_back(item);
		}
	});

	FILE *stream = fopen("result.txt", "w+"); //_wfopen
	if (stream) {
		for (OffsetResultInfo & item : vResultInfo) {
			/* write some data to the file */
			fprintf(stream, "[0]->%lx [1]->%lx [2]->%lx [3]->%lx\n",
				item.offset[0],
				item.offset[1],
				item.offset[2],
				item.offset[3]);
		}
		/* close the file */
		fclose(stream);
	}

}

//演示多线程反向遍历
void reverse_search(CMemoryReaderWriter* pRwDriver, uint64_t hProcess, size_t nWorkThreadCount) {

	//获取进程内存区域
	std::vector<MemRegionItem> vScanMemMaps;
	GetMemRegions(pRwDriver, hProcess,
		REGION_R0_0,
		vScanMemMaps);
	if (!vScanMemMaps.size()) {
		printf("无内存可搜索\n");
		//关闭进程
		pRwDriver->CloseHandle(hProcess);
		printf("调用驱动 CloseHandle:%" PRIu64 "\n", hProcess);
		fflush(stdout);
		return;
	}


	//准备要搜索的内存区域
	std::shared_ptr<MemSearchSafeWorkBlockWrapper> spvWaitScanMemBlock = std::make_shared<MemSearchSafeWorkBlockWrapper>();
	if (!spvWaitScanMemBlock) {
		return;
	}
	for (auto& item : vScanMemMaps) {
		spvWaitScanMemBlock->push_back(item.baseInfo.baseaddress, item.baseInfo.size, 0, item.baseInfo.size);
	}


	//首次反向搜索
	std::vector<std::shared_ptr<baseOffsetInfo>> vBaseAddrOffsetRecord; //记录搜索到的地址偏移
	std::map<uint64_t, std::shared_ptr<std::vector<std::shared_ptr<baseOffsetInfo>>>> linkAddrOffsetHelperMap; //辅助再次反向搜索找到父节点的map
	std::vector<BATCH_BETWEEN_VAL_ADDR_RESULT<uint64_t>> vBetweenValSearchResult; //反向搜索结果
	{

		std::vector<BATCH_BETWEEN_VAL<uint64_t>> vWaitSearchBetweenVal; //待搜索的两值之间的数值数组

		//开始批量填充待搜索的两值之间的数值数组
		//for (size_t i = 0; i < 10; i++) {
		//	BATCH_BETWEEN_VAL<uint64_t> newBeteenVal;
		//	memset(&newBeteenVal, 0, sizeof(newBeteenVal));

		//	uint64_t tmpAddr = 0x401000 + i; //演示地址
		//	newBeteenVal.val1 = tmpAddr - 0x250;
		//	newBeteenVal.val2 = tmpAddr + 0x250;
		//	newBeteenVal.markContext.u64Ctx = tmpAddr;//传递保存一个标识地址
		//	vWaitSearchBetweenVal.push_back(newBeteenVal);
		//}


		//演示只反向搜索一个地址
		BATCH_BETWEEN_VAL<uint64_t> newBeteenVal;
		memset(&newBeteenVal, 0, sizeof(newBeteenVal));
		uint64_t tmpAddr = 0x401000; //演示地址
		newBeteenVal.val1 = tmpAddr - 0x250;
		newBeteenVal.val2 = tmpAddr + 0x250;
		newBeteenVal.markContext.u64Ctx = tmpAddr;//传递保存一个标识地址
		vWaitSearchBetweenVal.push_back(newBeteenVal);

		SearchBatchBetweenValue<uint64_t>(
			pRwDriver,
			1,
			spvWaitScanMemBlock, //待搜索的内存区域
			vWaitSearchBetweenVal, //待搜索的两值之间的数值数组
			nWorkThreadCount, //搜索线程数
			vBetweenValSearchResult, //搜索后的结果
			4); //扫描的对齐字节数



		printf("1.共搜索出%zu个地址\n", vBetweenValSearchResult.size());

		//记录搜索到的偏移
		for (size_t i = 0; i < vBetweenValSearchResult.size(); i++) {
			auto& addrResult = vBetweenValSearchResult.at(i);

			uint64_t curAddrVal = *(uint64_t*)addrResult.addrInfo.spSaveData.get();

			std::shared_ptr<baseOffsetInfo> spBaseOffset = std::make_shared<baseOffsetInfo>();
			memset(spBaseOffset.get(), 0, sizeof(baseOffsetInfo));
			spBaseOffset->addr = addrResult.addrInfo.addr;
			spBaseOffset->offset = addrResult.originalCondition.markContext.u64Ctx - curAddrVal;
			vBaseAddrOffsetRecord.push_back(spBaseOffset);

			//辅助再次反向搜索找到父节点的vector
			std::shared_ptr<std::vector<std::shared_ptr<baseOffsetInfo>>> spvBaseInfoObj
				= std::make_shared<std::vector<std::shared_ptr<baseOffsetInfo>>>();
			spvBaseInfoObj->push_back(spBaseOffset);
			linkAddrOffsetHelperMap[spBaseOffset->addr] = spvBaseInfoObj;

		}
	}

	//再次反向搜索
	if (vBetweenValSearchResult.size()) {

		//进度恢复
		spvWaitScanMemBlock->recover_normal_block_origin_progress();

		std::vector<BATCH_BETWEEN_VAL<uint64_t>> vWaitSearchBetweenVal; //待搜索的两值之间的数值数组
		for (auto& addrResult : vBetweenValSearchResult) {
			BATCH_BETWEEN_VAL<uint64_t> newBeteenVal;
			memset(&newBeteenVal, 0, sizeof(newBeteenVal));
			newBeteenVal.val1 = addrResult.addrInfo.addr - 0x250;
			newBeteenVal.val2 = addrResult.addrInfo.addr + 0x250;
			newBeteenVal.markContext.u64Ctx = addrResult.addrInfo.addr;//传递保存一个标识地址
			vWaitSearchBetweenVal.push_back(newBeteenVal);
		}
		//DEBUG
		//BATCH_BETWEEN_VAL<uint64_t> newBeteenVal;
		//memset(&newBeteenVal, 0, sizeof(newBeteenVal));
		//newBeteenVal.val1 = 0x77d55d4df0 - 0x250;
		//newBeteenVal.val2 = 0x77d55d4df0 + 0x250;
		//newBeteenVal.markContext.u64Ctx = 0x77d55d4df0;//传递保存一个标值地址
		//vWaitSearchBetweenVal.push_back(newBeteenVal);


		vBetweenValSearchResult.clear();

		SearchBatchBetweenValue<uint64_t>(
			pRwDriver,
			1,
			spvWaitScanMemBlock, //待搜索的内存区域
			vWaitSearchBetweenVal, //待搜索的两值之间的数值数组
			nWorkThreadCount, //搜索线程数
			vBetweenValSearchResult, //搜索后的结果
			4); //扫描的对齐字节数

		printf("2.共搜索出%zu个地址\n", vBetweenValSearchResult.size());

		//记录搜索到的偏移
		for (size_t i = 0; i < vBetweenValSearchResult.size(); i++) {
			auto& addrResult = vBetweenValSearchResult.at(i);

			uint64_t curAddrVal = *(uint64_t*)addrResult.addrInfo.spSaveData.get();

			std::shared_ptr<baseOffsetInfo> spBaseOffset = std::make_shared<baseOffsetInfo>();
			memset(spBaseOffset.get(), 0, sizeof(baseOffsetInfo));
			spBaseOffset->addr = addrResult.addrInfo.addr;
			spBaseOffset->offset = addrResult.originalCondition.markContext.u64Ctx - curAddrVal;
			vBaseAddrOffsetRecord.push_back(spBaseOffset);

			//辅助再次反向搜索找到父节点的vector
			if (linkAddrOffsetHelperMap.find(spBaseOffset->addr) == linkAddrOffsetHelperMap.end()) {
				std::shared_ptr<std::vector<std::shared_ptr<baseOffsetInfo>>> spvBaseInfoObj
					= std::make_shared<std::vector<std::shared_ptr<baseOffsetInfo>>>();
				spvBaseInfoObj->push_back(spBaseOffset);
				linkAddrOffsetHelperMap[spBaseOffset->addr] = spvBaseInfoObj;
			}
			else {
				linkAddrOffsetHelperMap[spBaseOffset->addr]->push_back(spBaseOffset);
			}

			//将反向搜索到的地址偏移串联起来
			auto spvLastBaseInfoObj = linkAddrOffsetHelperMap[addrResult.originalCondition.markContext.u64Ctx];
			for (auto spLastAddrNode : *spvLastBaseInfoObj) {
				spLastAddrNode->vwpNextNode.push_back(spBaseOffset);
				spBaseOffset->vwpLastNode.push_back(spLastAddrNode);
			}


		}
	}

	//再次反向搜索
	if (vBetweenValSearchResult.size()) {

		//进度恢复
		spvWaitScanMemBlock->recover_normal_block_origin_progress();

		std::vector<BATCH_BETWEEN_VAL<uint64_t>> vWaitSearchBetweenVal; //待搜索的两值之间的数值数组
		for (auto& addrResult : vBetweenValSearchResult) {
			BATCH_BETWEEN_VAL<uint64_t> newBeteenVal;
			memset(&newBeteenVal, 0, sizeof(newBeteenVal));
			newBeteenVal.val1 = addrResult.addrInfo.addr - 0x250;
			newBeteenVal.val2 = addrResult.addrInfo.addr + 0x250;
			newBeteenVal.markContext.u64Ctx = addrResult.addrInfo.addr;//传递保存一个标识地址
			vWaitSearchBetweenVal.push_back(newBeteenVal);

		}
		////DEBUG
		//BATCH_BETWEEN_VAL<uint64_t> newBeteenVal;
		//memset(&newBeteenVal, 0, sizeof(newBeteenVal));
		//newBeteenVal.val1 = 0x780e7f56e0 - 0x250;
		//newBeteenVal.val2 = 0x780e7f56e0 + 0x250;
		//newBeteenVal.markContext.u64Ctx = 0x780e7f56e0;//传递保存一个标值地址
		//vWaitSearchBetweenVal.push_back(newBeteenVal);
		vBetweenValSearchResult.clear();

		SearchBatchBetweenValue<uint64_t>(
			pRwDriver,
			1,
			spvWaitScanMemBlock, //待搜索的内存区域
			vWaitSearchBetweenVal, //待搜索的两值之间的数值数组
			nWorkThreadCount, //搜索线程数
			vBetweenValSearchResult, //搜索后的结果
			4); //扫描的对齐字节数

		printf("3.共搜索出%zu个地址\n", vBetweenValSearchResult.size());

		//记录搜索到的偏移
		for (size_t i = 0; i < vBetweenValSearchResult.size(); i++) {
			auto& addrResult = vBetweenValSearchResult.at(i);

			uint64_t curAddrVal = *(uint64_t*)addrResult.addrInfo.spSaveData.get();

			std::shared_ptr<baseOffsetInfo> spBaseOffset = std::make_shared<baseOffsetInfo>();
			memset(spBaseOffset.get(), 0, sizeof(baseOffsetInfo));
			spBaseOffset->addr = addrResult.addrInfo.addr;
			spBaseOffset->offset = addrResult.originalCondition.markContext.u64Ctx - curAddrVal;
			vBaseAddrOffsetRecord.push_back(spBaseOffset);

			//辅助再次反向搜索找到父节点的vector
			if (linkAddrOffsetHelperMap.find(spBaseOffset->addr) == linkAddrOffsetHelperMap.end()) {
				std::shared_ptr<std::vector<std::shared_ptr<baseOffsetInfo>>> spvBaseInfoObj
					= std::make_shared<std::vector<std::shared_ptr<baseOffsetInfo>>>();
				spvBaseInfoObj->push_back(spBaseOffset);
				linkAddrOffsetHelperMap[spBaseOffset->addr] = spvBaseInfoObj;
			}
			else {
				linkAddrOffsetHelperMap[spBaseOffset->addr]->push_back(spBaseOffset);
			}

			//将反向搜索到的地址偏移串联起来
			auto spvLastBaseInfoObj = linkAddrOffsetHelperMap[addrResult.originalCondition.markContext.u64Ctx];
			for (auto spLastAddrNode : *spvLastBaseInfoObj) {
				spLastAddrNode->vwpNextNode.push_back(spBaseOffset);
				spBaseOffset->vwpLastNode.push_back(spLastAddrNode);
			}


		}
	}



	//反向搜索结束归纳
	if (vBetweenValSearchResult.size()) {

		//打印整个链路
		std::vector<singleOffsetLinkPath> vTotalShow; //显示的总路径文本
		for (auto iter = vBaseAddrOffsetRecord.begin(); iter != vBaseAddrOffsetRecord.end(); iter++) {
			auto spBaseAddrOffsetInfo = *iter;
			//last节点为空，next节点不为空才是头部节点
			if (spBaseAddrOffsetInfo->vwpLastNode.size() == 0 && spBaseAddrOffsetInfo->vwpNextNode.size()) {
				AddrOffsetLinkMapToVector(spBaseAddrOffsetInfo, [&vTotalShow](
					const singleOffsetLinkPath& newSinglePath, size_t deepIndex/*start from zero*/)->void {
						//TODO：这里可以限制自己想要的层级
						if (deepIndex != 3 - 1) {
							return;//层级不够深
						}
						//TODO：在这里可以对基址进行一些过滤，比如只保留某个.so范围内的addr
						//uint64_t finalBaseAddr = std::get<0>(newSinglePath[newSinglePath.size() - 1]);
						//static uint64_t moduleStartAddr = 0, moduleEndAddr = 0;
						//if (moduleStartAddr == 0 || moduleEndAddr == 0) {
						//	GetMemModuleRangeAddr(pRwDriver, hProcess, "libxxx.so", moduleStartAddr, moduleEndAddr);
						//	assert(moduleStartAddr && moduleEndAddr);
						//}
						//if (finalBaseAddr < moduleStartAddr || finalBaseAddr > moduleEndAddr) {
						//	return; //超出了某个.so的范围
						//}
						vTotalShow.push_back(newSinglePath);
					});
			}
		}
		//去重
		std::set<singleOffsetLinkPath>s(vTotalShow.begin(), vTotalShow.end());
		vTotalShow.assign(s.begin(), s.end());

		//显示出来
		std::stringstream sstrTotalShow;
		for (auto& item : vTotalShow) {

			//把偏移转成文本
			for (auto& child : item) {
				//十进制转十六进制
				sstrTotalShow << "+0x" << std::hex << std::get<0>(child);
				ssize_t offset = std::get<1>(child);

				if (offset < 0) {
					sstrTotalShow << "-0x" << std::hex << -offset;
				}
				else {
					sstrTotalShow << "+0x" << std::hex << offset;
				}
				sstrTotalShow << "]";
			}
			sstrTotalShow << "\n";
		}
		FILE* stream = fopen("result.txt", "w+"); //_wfopen
		if (stream) {
			/* write some data to the file */
			fprintf(stream, "%s\n", sstrTotalShow.str().c_str()); //%S

			/* close the file */
			fclose(stream);
		}

	}



}


int main(int argc, char *argv[]) {
	printf(
		"======================================================\n"
		"本驱动名称: Linux ARM64 硬件读写进程内存驱动39\n"
		"本驱动接口列表：\n"
		"\t1.	驱动_打开进程: OpenProcess\n"
		"\t2.	驱动_读取进程内存: ReadProcessMemory\n"
		"\t3.	驱动_写入进程内存: WriteProcessMemory\n"
		"\t4.	驱动_关闭进程: CloseHandle\n"
		"\t5.	驱动_获取进程内存块列表: VirtualQueryExFull（可选：显示全部内存、仅显示物理内存）\n"
		"\t6.	驱动_获取进程PID列表: GetPidList\n"
		"\t7.	驱动_提升进程权限到Root: SetProcessRoot\n"
		"\t8.	驱动_获取进程物理内存占用大小: GetProcessPhyMemSize\n"
		"\t9.	驱动_获取进程命令行: GetProcessCmdline\n"
		"\t10.	驱动_隐藏驱动: HideKernelModule\n"
		"\t以上所有功能不注入、不附加进程，不打开进程任何文件，所有操作均为内核操作\n"
		"======================================================\n"
	);

	CMemoryReaderWriter rwDriver;

	//驱动默认隐蔽通信密匙
	std::string procNodeAuthKey = "e84523d7b60d5d341a7c4d1861773ecd";
	if (argc > 1) {
		//用户自定义输入驱动隐蔽通信密匙
		procNodeAuthKey = argv[1];
	}
	printf("Connecting rwDriver auth key:%s\n", procNodeAuthKey.c_str());

	//连接驱动
	int err = rwDriver.ConnectDriver(procNodeAuthKey.c_str());
	if (err) {
		printf("Connect rwDriver failed. error:%d\n", err);
		fflush(stdout);
		return 0;
	}

	//获取目标进程PID
	const char *name = "com.miui.calculator";
	pid_t pid = findPID(&rwDriver, name);
	if (pid == 0) {
		printf("找不到进程\n");
		fflush(stdout);
		return 0;
	}
	printf("目标进程PID:%d\n", pid);
	//打开进程
	uint64_t hProcess = rwDriver.OpenProcess(pid);
	printf("调用驱动 OpenProcess 返回值:%" PRIu64 "\n", hProcess);
	if (!hProcess) {
		printf("调用驱动 OpenProcess 失败\n");
		fflush(stdout);
		return 0;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	size_t nWorkThreadCount = std::thread::hardware_concurrency() - 1;
	//1.演示多线程普通搜索
	normal_val_search(&rwDriver, hProcess, nWorkThreadCount);
	//2.演示多线程正向遍历
	loop_search(&rwDriver, hProcess, nWorkThreadCount);
	//3.演示多线程反向遍历
	reverse_search(&rwDriver, hProcess, nWorkThreadCount);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//关闭进程
	rwDriver.CloseHandle(hProcess);
	printf("调用驱动 CloseHandle:%" PRIu64 "\n", hProcess);
	fflush(stdout);
	return 0;
}
```

`rwProcMem33Module/testTarget/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_CPPFLAGS += -std=c++20
LOCAL_CFLAGS += -fPIE
LOCAL_CFLAGS += -fvisibility=hidden
LOCAL_LDFLAGS += -fPIE -pie
LOCAL_DISABLE_FATAL_LINKER_WARNINGS := true
LOCAL_MODULE    := testTarget.out
LOCAL_SRC_FILES :=  testTarget.cpp

include $(BUILD_EXECUTABLE)

```

`rwProcMem33Module/testTarget/jni/Application.mk`:

```mk
APP_ABI := arm64-v8a
APP_STL := c++_static
```

`rwProcMem33Module/testTarget/jni/testTarget.cpp`:

```cpp
#include <cstdio>
#include <string.h> 
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <memory>
#include <dirent.h>
#include <cinttypes>
#include "../../testKo/jni/MemoryReaderWriter39.h"
#include "../../testMemSearch/jni/MapRegionType.h"


int findPID(CMemoryReaderWriter *pDriver, const char *lpszCmdline) {
	int nTargetPid = 0;

	//驱动_获取进程PID列表
	std::vector<int> vPID;
	BOOL b = pDriver->GetPidList(vPID);
	printf("调用驱动 GetPidList 返回值:%d\n", b);

	//打印进程列表信息
	for (int pid : vPID) {
		//驱动_打开进程
		uint64_t hProcess = pDriver->OpenProcess(pid);
		if (!hProcess) { continue; }

		//驱动_获取进程命令行
		char cmdline[100] = { 0 };
		pDriver->GetProcessCmdline(hProcess, cmdline, sizeof(cmdline));

		//驱动_关闭进程
		pDriver->CloseHandle(hProcess);

		if (strcmp(lpszCmdline, cmdline) == 0) {
			nTargetPid = pid;
			break;
		}
	}
	return nTargetPid;
}


int main(int argc, char *argv[]) {
	printf(
		"======================================================\n"
		"本驱动名称: Linux ARM64 硬件读写进程内存驱动39\n"
		"本驱动接口列表：\n"
		"\t1.	驱动_打开进程: OpenProcess\n"
		"\t2.	驱动_读取进程内存: ReadProcessMemory\n"
		"\t3.	驱动_写入进程内存: WriteProcessMemory\n"
		"\t4.	驱动_关闭进程: CloseHandle\n"
		"\t5.	驱动_获取进程内存块列表: VirtualQueryExFull（可选：显示全部内存、仅显示物理内存）\n"
		"\t6.	驱动_获取进程PID列表: GetPidList\n"
		"\t7.	驱动_提升进程权限到Root: SetProcessRoot\n"
		"\t8.	驱动_获取进程物理内存占用大小: GetProcessPhyMemSize\n"
		"\t9.	驱动_获取进程命令行: GetProcessCmdline\n"
		"\t10.	驱动_隐藏驱动: HideKernelModule\n"
		"\t以上所有功能不注入、不附加进程，不打开进程任何文件，所有操作均为内核操作\n"
		"======================================================\n"
	);

	CMemoryReaderWriter rwDriver;

	//驱动默认隐蔽通信密匙
	std::string procNodeAuthKey = "e84523d7b60d5d341a7c4d1861773ecd";
	if (argc > 1) {
		//用户自定义输入驱动隐蔽通信密匙
		procNodeAuthKey = argv[1];
	}
	printf("Connecting rwDriver:%s\n", procNodeAuthKey.c_str());

	//连接驱动
	int err = rwDriver.ConnectDriver(procNodeAuthKey.c_str());
	if (err) {
		printf("Connect rwDriver failed. error:%d\n", err);
		fflush(stdout);
		return 0;
	}

	//获取目标进程PID
	const char *name = "com.miui.calculator";
	pid_t pid = findPID(&rwDriver, name);
	if (pid == 0) {
		printf("找不到进程\n");
		return 0;
	}
	printf("目标进程PID:%d\n", pid);

	//打开进程
	uint64_t hProcess = rwDriver.OpenProcess(pid);
	printf("调用驱动 OpenProcess 返回值:%" PRIu64 "\n", hProcess);
	if (!hProcess) {
		printf("调用驱动 OpenProcess 失败\n");
		fflush(stdout);
		return 0;
	}

	//驱动_获取进程内存块列表（显示全部内存）
	std::vector<DRIVER_REGION_INFO> vMaps;
	BOOL b = rwDriver.VirtualQueryExFull(hProcess, FALSE, vMaps);
	printf("调用驱动 VirtualQueryExFull(显示全部内存) 返回值:%d\n", b);

	if (!vMaps.size()) {
		printf("VirtualQueryExFull 失败\n");

		//关闭进程
		rwDriver.CloseHandle(hProcess);
		printf("调用驱动 CloseHandle:%" PRIu64 "\n", hProcess);
		fflush(stdout);
		return 0;
	}

	//显示进程内存块地址列表
	for (DRIVER_REGION_INFO rinfo : vMaps) {
		printf("---Start:%p,Size:%" PRIu64 ",Type:%s,Name:%s\n", (void*)rinfo.baseaddress, rinfo.size, MapsTypeToString(&rinfo).c_str(), rinfo.name);
	}

	//驱动_获取进程内存块列表（只显示在物理内存中的内存）
	vMaps.clear();
	b = rwDriver.VirtualQueryExFull(hProcess, TRUE, vMaps);
	printf("调用驱动 VirtualQueryExFull(只显示在物理内存中的内存) 返回值:%d\n", b);
	if (!vMaps.size()) {
		printf("VirtualQueryExFull 失败\n");

		//关闭进程
		rwDriver.CloseHandle(hProcess);
		printf("调用驱动 CloseHandle:%" PRIu64 "\n", hProcess);
		fflush(stdout);
		return 0;
	}
	//显示进程内存块地址列表
	for (DRIVER_REGION_INFO rinfo : vMaps) {
		printf("+++Start:%p,Size:%" PRIu64 ",Type:%s,Name:%s\n", (void*)rinfo.baseaddress, rinfo.size, MapsTypeToString(&rinfo).c_str(), rinfo.name);
	}


	//获取一个可读地址
	uint64_t pRead = 0;
	size_t nReadSize = 0;

	for (DRIVER_REGION_INFO rinfo : vMaps) {
		if (rinfo.protection != PAGE_NOACCESS) //此地址可以访问
		{
			//记录一个可以访问的地址信息
			pRead = rinfo.baseaddress;
			nReadSize = rinfo.size;
			break;
		}
	}

	if (pRead == 0) //没找到可以访问的地址
	{
		printf("找不到可读地址\n");

		//关闭进程
		rwDriver.CloseHandle(hProcess);
		printf("调用驱动 CloseHandle:%" PRIu64 "\n", hProcess);
		fflush(stdout);
		return 0;
	}

	//开始演示读取进程内存
	size_t real_read = 0;

	nReadSize = nReadSize > 1024 ? 1024 : nReadSize;

	char *readBuf = (char*)malloc(nReadSize);

	auto read_res = rwDriver.ReadProcessMemory(hProcess, pRead, readBuf, nReadSize, &real_read, FALSE);
	printf("调用驱动 ReadProcessMemory 读取内存地址:%p,返回值:%d,实际读取大小:%zu \n", (void*)pRead, read_res, real_read);

	for (int i = 0; i < nReadSize; i++) {
		char c = readBuf[i];
		printf("%x ", c);
	}
	printf("\n");

	/*
	//开始演示写入进程内存
	memset(readBuf, 0, sizeof(readBuf));
	snprintf(readBuf, sizeof(readBuf), "%s", "写入456");
	size_t real_write = 0;
	auto write_res = rwDriver.WriteProcessMemory(hProcess, (uint64_t)pBuf, &readBuf, sizeof(readBuf), &real_write, FALSE);
	printf("调用驱动 WriteProcessMemory 写入内存地址:%p,返回值:%d,写入的内容:%s,实际写入大小:%zu\n", pBuf, write_res, readBuf, real_write);
	*/

	free(readBuf);

	//关闭进程
	rwDriver.CloseHandle(hProcess);
	printf("调用驱动 CloseHandle:%" PRIu64 "\n", hProcess);
	fflush(stdout);
	return 0;
}
```