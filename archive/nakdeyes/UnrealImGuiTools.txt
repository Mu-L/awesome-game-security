Project Path: arc_nakdeyes_UnrealImGuiTools_740hhzh2

Source Tree:

```txt
arc_nakdeyes_UnrealImGuiTools_740hhzh2
├── ImGuiTools
│   ├── ExampleGameCode
│   │   ├── ImGuiGameToolsRegistrar.cpp
│   │   └── ImGuiGameToolsRegistrar.h
│   ├── ImGuiTools.uplugin
│   ├── Resources
│   │   ├── ImguiTools_Icon128.png
│   │   └── ImguiTools_Icon40.png
│   └── Source
│       ├── ImGuiTools
│       │   ├── ImGuiTools.Build.cs
│       │   ├── Private
│       │   │   ├── ImGuiToolWindow.cpp
│       │   │   ├── ImGuiTools.cpp
│       │   │   ├── ImGuiToolsDeveloperSettings.cpp
│       │   │   ├── ImGuiToolsGameDebugger.cpp
│       │   │   ├── ImGuiToolsManager.cpp
│       │   │   ├── Misc
│       │   │   │   ├── StreamingTextureLevelContext.cpp
│       │   │   │   └── StreamingTextureLevelContext.h
│       │   │   ├── Tools
│       │   │   │   ├── ImGuiActorComponentDebugger.cpp
│       │   │   │   ├── ImGuiActorComponentDebugger.h
│       │   │   │   ├── ImGuiCDOExplorer.cpp
│       │   │   │   ├── ImGuiCDOExplorer.h
│       │   │   │   ├── ImGuiFileLoadDebugger.cpp
│       │   │   │   ├── ImGuiFileLoadDebugger.h
│       │   │   │   ├── ImGuiMemoryDebugger.cpp
│       │   │   │   ├── ImGuiMemoryDebugger.h
│       │   │   │   ├── ImGuiShaderCompilationInfo.cpp
│       │   │   │   └── ImGuiShaderCompilationInfo.h
│       │   │   ├── Utils
│       │   │   │   ├── ClassHierarchyInfo.cpp
│       │   │   │   └── ImGuiUtils.cpp
│       │   │   └── Widgets
│       │   │       └── ClassSelectorWidget.cpp
│       │   └── Public
│       │       ├── ImGuiToolWindow.h
│       │       ├── ImGuiTools.h
│       │       ├── ImGuiToolsDeveloperSettings.h
│       │       ├── ImGuiToolsGameDebugger.h
│       │       ├── ImGuiToolsManager.h
│       │       ├── Utils
│       │       │   ├── ClassHierarchyInfo.h
│       │       │   └── ImGuiUtils.h
│       │       └── Widgets
│       │           └── ClassSelectorWidget.h
│       └── ImGuiToolsEditor
│           ├── ImGuiToolsEditor.Build.cs
│           ├── Private
│           │   ├── ImGuiEditorWidget.cpp
│           │   ├── ImGuiToolsEditor.cpp
│           │   ├── ImGuiToolsEditorCommands.cpp
│           │   ├── ImGuiToolsEditorStyle.cpp
│           │   └── ImGuiToolsEditorWidget.cpp
│           └── Public
│               ├── ImGuiEditorWidget.h
│               ├── ImGuiToolsEditor.h
│               ├── ImGuiToolsEditorCommands.h
│               ├── ImGuiToolsEditorStyle.h
│               └── ImGuiToolsEditorWidget.h
├── LICENSE
└── README.md

```

`ImGuiTools/ExampleGameCode/ImGuiGameToolsRegistrar.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiGameToolsRegistrar.h"

#if DRAW_IMGUI_TOOLS
#include <imgui.h>
#include <ImGuiTools.h>
#include <ImGuiToolsManager.h>
#endif // #if DRAW_IMGUI_TOOLS

// Function that registers module level tools. Can be called from ::StartupModule()
void GameImGuiToolsRegistrar::RegisterGameDebugTools()
{
#if DRAW_IMGUI_TOOLS
	FImGuiToolsModule& ImGuiToolsModule = FModuleManager::GetModuleChecked<FImGuiToolsModule>("ImGuiTools");
	if (ImGuiToolsModule.GetToolsManager().IsValid())
	{
		static const FName GameToolsNamespace = TEXT("Game Tools");
		ImGuiToolsModule.GetToolsManager()->RegisterToolWindow(TSharedPtr<FExampleImGuiTool>(new FExampleImGuiTool()), GameToolsNamespace);
	}
#endif // #if DRAW_IMGUI_TOOLS
}

#if DRAW_IMGUI_TOOLS
// Example ImGui Tool Window
FExampleImGuiTool::FExampleImGuiTool()
{
	ToolName = TEXT("Example ImGui Tool");
}

void FExampleImGuiTool::ImGuiUpdate(float DeltaTime)
{
	ImGui::Text("Name");
}
#endif // #if DRAW_IMGUI_TOOLS
```

`ImGuiTools/ExampleGameCode/ImGuiGameToolsRegistrar.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

/**
*	Example ImGui Game Tools Registrar. An example of how to register your game level ImGui Tools w/ the ImGuiTools plugin!
*
*	Steps to follow to put in your game.
*		1. Copy this ImGuiGameToolsRegistrar .h / .cpp to your game module somewhere you want the tools to exist.
*		2. Change "GAME_API" below to your module dll export api macro for your module.
*		3. If you haven't already add "ImGuiTools" to your included plugins in your .uproject file.
*		4. If you haven't already, add "ImGui" and "ImGuiTools" to your module's *.build.cs dependencies.
*		5. While you are there in your *.build.cs add this line when the ImGuiTools Plugin is included:
*			PublicDefinitions.Add("DRAW_IMGUI_TOOLS=1");
*		6. Somewhere in your game module ( I prefer FDefaultGameModuleImpl::StartupModule() ), you should call
*		   GameImGuiToolsRegistrar::RegisterGameDebugTools(); to register your tools.
*
*   That's it! One last tip: I recommend pulling your tools out of the registrar and into their own .h / .cpp files. Good luck!
*/

#pragma once

#include <ImGuiToolWindow.h>

#if DRAW_IMGUI_TOOLS
// Example ImGui Tool Window
class GAME_API FExampleImGuiTool 
	: public FImGuiToolWindow
{
public:
	FExampleImGuiTool();
	virtual ~FExampleImGuiTool() = default;

	// FImGuiDebugToolWindow 
	virtual void ImGuiUpdate(float DeltaTime) override;
	// ~FImGuiDebugToolWindow 
};
#endif // #if DRAW_IMGUI_TOOLS

namespace GameImGuiToolsRegistrar
{
	// Function that registers module level tools. Can be called from ::StartupModule()
	void RegisterGameDebugTools();
};

```

`ImGuiTools/ImGuiTools.uplugin`:

```uplugin
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "0.3",
	"FriendlyName": "ImGuiTools",
	"Description": "A set of tools and utilities for use with Unreal Engine projects using ImGui.",
	"Category": "Other",
	"CreatedBy": "timothy.rawcliffe@gmail.com",
	"CreatedByURL": "https://github.com/nakdeyes/UnrealImGuiTools",
	"DocsURL": "",
	"CanContainContent": false,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "ImGuiTools",
			"Type": "Runtime",
			"LoadingPhase": "PreLoadingScreen",
			"TargetConfigurationDenyList": [ "Shipping" ]
		},
		{
			"Name": "ImGuiToolsEditor",
			"Type": "Editor",
			"LoadingPhase": "PreLoadingScreen",
			"TargetConfigurationDenyList": [ "Shipping" ]
		}
	],
	"Plugins": [
		{
			"Name": "ImGui",
			"Enabled": true
		},
		{
			"Name": "StructUtils",
			"Enabled": true,
			"EngineVersions": "5.0.0-5.4.4"
		}
	]
}
```

`ImGuiTools/Source/ImGuiTools/ImGuiTools.Build.cs`:

```cs
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

using UnrealBuildTool;

public class ImGuiTools : ModuleRules
{
	public ImGuiTools(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;
		
		PublicDependencyModuleNames.AddRange(
			new string[]
			{
				"Core",
				"GameplayTags"
				// ... add other public dependencies that you statically link with here ...
			}
		);
		
		// Add StructUtils only for UE 5.4 and earlier
		if (Target.Version.MajorVersion < 5 || (Target.Version.MajorVersion == 5 && Target.Version.MinorVersion <= 4))
		{
			PublicDependencyModuleNames.Add("StructUtils");
		}
			
		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				"CoreUObject",
				"DeveloperSettings",
				"Engine",
				"InputCore",
				"Projects",
				"RenderCore",
				"RHI",
				"Slate",
				"SlateCore",
				// ... add private dependencies that you statically link with here ...	
			}
		);

		// Additional Dependencies for non-Shipping, non-dedicated server builds.
		if (Target.Configuration != UnrealTargetConfiguration.Shipping)
        {
            PrivateDependencyModuleNames.AddRange(new string[] {
                "ImGui",
            });
            
            // DRAW_IMGUI_TOOLS - is meant to be a flag that can be disabled to run the module in a minimal / mostly disabled state.
            //	It is recommended to simply not load the module for whatever builds you do not wish to use ImGuiTools with, but this
            //	flag can be disabled for corner cases where you want a mostly no-op module.
            PublicDefinitions.Add("DRAW_IMGUI_TOOLS=1");
        }
		else 
		{
			PublicDefinitions.Add("DRAW_IMGUI_TOOLS=0");
		}
	}
}

```

`ImGuiTools/Source/ImGuiTools/Private/ImGuiToolWindow.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiToolWindow.h"
#include "Utils/ImGuiUtils.h"

#include <imgui.h>

void FImGuiToolWindow::EnableTool(bool bNewEnabled)
{
	bEnabled = bNewEnabled;
}

bool& FImGuiToolWindow::GetEnabledRef()
{
	return bEnabled;
}

const FString& FImGuiToolWindow::GetToolName() const
{
	return ToolName;
}

const ImGuiWindowFlags& FImGuiToolWindow::GetFlags() const
{
	return WindowFlags;
}

void FImGuiToolWindow::UpdateTool(float DeltaTime)
{
	if (bEnabled)
	{
		if (ImGui::Begin(Ansi(*GetToolName()), &bEnabled, WindowFlags))
		{
			ImGuiUpdate(DeltaTime);
		}

		ImGui::End();
	}
}

```

`ImGuiTools/Source/ImGuiTools/Private/ImGuiTools.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiTools.h"

#include "ImGuiToolsGameDebugger.h"
#include "ImGuiToolsManager.h"
#include "Misc/MessageDialog.h"

#define LOCTEXT_NAMESPACE "FImGuiToolsModule"

void FImGuiToolsModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
	ToolsManager = MakeShareable(new FImGuiToolsManager());
	ToolsManager->Initialize();

	GameDebugger = MakeShareable(new FImGuiToolsGameDebugger());
}

void FImGuiToolsModule::ShutdownModule()
{
	ToolsManager->Deinitialize();
}

TSharedPtr<FImGuiToolsManager> FImGuiToolsModule::GetToolsManager()
{
	return ToolsManager;
}

TSharedPtr<FImGuiToolsGameDebugger> FImGuiToolsModule::GetGameDebugger()
{
	return GameDebugger;
}

#undef LOCTEXT_NAMESPACE
	
IMPLEMENT_MODULE(FImGuiToolsModule, ImGuiTools)
```

`ImGuiTools/Source/ImGuiTools/Private/ImGuiToolsDeveloperSettings.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiToolsDeveloperSettings.h"

#include "ImGuiToolsManager.h"

UImGuiToolsDeveloperSettings::UImGuiToolsDeveloperSettings()
	: Super()
{
	
	static const KeyCodePair LeftCtrlKeyCode		= { 162, 0 };
	static const KeyCodePair BackslashKeyCode		= { 220, 92 };
	static const KeyCodePair RightBracketKeyCode	= { 221, 93 };

	if (ImGuiToggleInputKeys.IsEmpty())
	{
		// Add Default Toggle input keys if none are set.
		ImGuiToggleInputKeys.Add(FInputKeyManager::Get().GetKeyFromCodes(LeftCtrlKeyCode.Get<0>(), LeftCtrlKeyCode.Get<1>()));
		ImGuiToggleInputKeys.Add(FInputKeyManager::Get().GetKeyFromCodes(BackslashKeyCode.Get<0>(), BackslashKeyCode.Get<1>()));
	}

	if (ImGuiToggleVisibilityKeys.IsEmpty())
	{
		// Add Default Toggle visibility keys if none are set.
		ImGuiToggleVisibilityKeys.Add(FInputKeyManager::Get().GetKeyFromCodes(LeftCtrlKeyCode.Get<0>(), LeftCtrlKeyCode.Get<1>()));
		ImGuiToggleVisibilityKeys.Add(FInputKeyManager::Get().GetKeyFromCodes(RightBracketKeyCode.Get<0>(), RightBracketKeyCode.Get<1>()));
	}
}

```

`ImGuiTools/Source/ImGuiTools/Private/ImGuiToolsGameDebugger.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiToolsGameDebugger.h"

#include <imgui.h>
#include "Utils/ImGuiUtils.h"
#include <GameFramework/Actor.h>
#include "Engine/World.h"
#include "UObject/UObjectIterator.h"
#include "GameFramework/PlayerController.h"


namespace GameDebuggerUtil
{
	void DrawActorMenu(const char* ActorDesc, AActor* Actor)
	{
		const bool ActorValid = IsValid(Actor);
		const FString ActorMenuStr = FString::Printf(TEXT("%s: %s"), ActorDesc, ActorValid ? *Actor->GetName() : TEXT("*none*"));

		if (!ActorValid)
		{
			ImGui::Text("%s", Ansi(*ActorMenuStr));
			return;
		}
		
		if (ImGui::BeginMenu(Ansi(*ActorMenuStr)))
		{
			
			ImGui::EndMenu();
		}
		
	}
} // namespace GameDebuggerUtil

void FImGuiToolsGameDebugger::DrawMainImGuiMenu()
{
#if 0 // This is super WIP and disabled at the moment.
	
	if (ImGui::BeginMenu("Game"))
	{
		// What types of worlds to display: 
		static const auto WorldShouldDisplay = [](UWorld* World) 
		{
			return (IsValid(World) && !World->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject) && World->bIsWorldInitialized 
				&& (World->WorldType != EWorldType::Editor) && (World->WorldType != EWorldType::EditorPreview));
		};

		APlayerController* LocalPC = nullptr;
		for (TObjectIterator<UWorld> It; It && (LocalPC == nullptr); ++It)
		{
			UWorld* World = *It;
			if (!WorldShouldDisplay(World))
			{
				continue;
			}

			LocalPC = World->GetFirstPlayerController();
		}

		if (IsValid(LocalPC))
		{
			
			ImGui::Text("World w/ PC: %s - %s", Ansi(*LocalPC->GetWorld()->GetName()), Ansi(*LocalPC->GetName()));
			if (ImGui::BeginMenu(Ansi(*FString::Printf(TEXT("%s##LocalPCMenu"), *LocalPC->GetName()))))
			{
				APawn* CurPawn = LocalPC->GetPawn();
				ImGui::Text("Current Pawn: %s", CurPawn ? Ansi(*CurPawn->GetName()) : "*none*");
					
				ImGui::EndMenu();
			}
		}

		ImGui::EndMenu(); // "Game"
	}
#endif // 0
}

void FImGuiToolsGameDebugger::RegisterActorComponentCustomization(const FActorComponentCustomization& Customization)
{
	// Unregister for any existing cusotmization of this component type
	UnregisterActorComponentCustomization(Customization.ComponentClass);

	ActorCompCustomizations.Add(Customization);
}

void FImGuiToolsGameDebugger::UnregisterActorComponentCustomization(const TSubclassOf<UActorComponent> ComponentClass)
{
	ActorCompCustomizations.RemoveAll([ComponentClass](const FActorComponentCustomization& ActorCompCustomization) -> bool {
		return (ActorCompCustomization.ComponentClass == ComponentClass);
	});
}

```

`ImGuiTools/Source/ImGuiTools/Private/ImGuiToolsManager.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiToolsManager.h"

#include "ImGuiToolsDeveloperSettings.h"

#if DRAW_IMGUI_TOOLS

#include <Engine/Console.h>

#include "ImGuiTools.h"
#include "ImGuiToolsGameDebugger.h"
#include "Tools/ImGuiActorComponentDebugger.h"
#include "Tools/ImGuiCDOExplorer.h"
#include "Tools/ImGuiFileLoadDebugger.h"
#include "Tools/ImGuiMemoryDebugger.h"
#include "Tools/ImGuiShaderCompilationInfo.h"
#include "Utils/ImGuiUtils.h"

// ImGui Plugin
#include "ImGuiContext.h"
#include "ImGuiModule.h"
#include <imgui.h>
#include <imgui_internal.h>

DEFINE_LOG_CATEGORY_STATIC(LogImGuiToolsManager, Log, All);

// CVARs
TAutoConsoleVariable<bool> ImGuiDebugCVars::CVarImGuiToolsEnabled(TEXT("imgui.tools.enabled"), false, TEXT("If true, draw ImGui Debug tools."));
static FString ToggleToolVisCVARName = TEXT("imgui.tools.toggle_tool_vis");
FAutoConsoleCommand ToggleToolVis(*ToggleToolVisCVARName, TEXT("Toggle the visibility of a particular ImGui Debug Tool by providing it's string name as an argument"),
								  FConsoleCommandWithArgsDelegate::CreateStatic(&FImGuiToolsManager::ToggleToolVisCommand));
FAutoConsoleCommand ToggleToolsVis(TEXT("imgui.tools.toggle_enabled"), TEXT("Master toggle for ImGui Tools. Will also toggle on ImGui drawing and input, so this is great if ImGui Tools is your main interactions with ImGui."),
    FConsoleCommandWithArgsDelegate::CreateStatic(&FImGuiToolsManager::ToggleToolsVisCommand));

#if WITH_EDITOR

static FString LaunchEditorToolCVARName = TEXT("imgui.tools.launch_editor_tool");
FAutoConsoleCommand LaunchEditorTool(*LaunchEditorToolCVARName, TEXT("Launch an editor tool panel by name for tools that support it."),
    FConsoleCommandWithArgsDelegate::CreateStatic(&FImGuiToolsManager::LaunchEditorTool));

#endif    // #if WITH_EDITOR

#endif	  // #if DRAW_IMGUI_TOOLS

FImGuiToolsManager::FImGuiToolsManager()
	: DrawImGuiDemo(false)
	, ShowFPS(true)
{
#if DRAW_IMGUI_TOOLS
	UConsole::RegisterConsoleAutoCompleteEntries.AddRaw(this, &FImGuiToolsManager::RegisterAutoCompleteEntries);
#endif	  // #if DRAW_IMGUI_TOOLS
}

FImGuiToolsManager::~FImGuiToolsManager()
{
#if DRAW_IMGUI_TOOLS
	UConsole::RegisterConsoleAutoCompleteEntries.RemoveAll(this);
#endif	  // #if DRAW_IMGUI_TOOLS
}

void FImGuiToolsManager::Initialize()
{
#if DRAW_IMGUI_TOOLS
	static const FName PluginToolsNamespace = TEXT("Included Plugin Tools");
	RegisterToolWindow(TSharedPtr<FImGuiToolWindow>(new FImGuiActorComponentDebugger()), PluginToolsNamespace);
    RegisterToolWindow(TSharedPtr<FImGuiToolWindow>(new FImGuiCDOExplorer()), PluginToolsNamespace);
	RegisterToolWindow(TSharedPtr<FImGuiToolWindow>(new FImGuiFileLoadDebugger()), PluginToolsNamespace);
	RegisterToolWindow(TSharedPtr<FImGuiToolWindow>(new FImGuiMemoryDebugger()), PluginToolsNamespace);
	RegisterToolWindow(TSharedPtr<FImGuiToolWindow>(new FImGuiShaderCompilationInfo()), PluginToolsNamespace);

	if (!InputProcessor && FSlateApplication::IsInitialized())
	{
		InputProcessor = MakeShared<FImGuiToolsInputProcessor>();
		FSlateApplication::Get().RegisterInputPreProcessor(InputProcessor);
	}
	
	OnWorldPostActorTickDelegateHandle = FWorldDelegates::OnWorldPostActorTick.AddLambda([&](UWorld* World, ELevelTick TickType, float DeltaSeconds)
	{
		OnWorldPostActorTick(World, TickType, DeltaSeconds);
	});
#endif	  // #if DRAW_IMGUI_TOOLS
}

void FImGuiToolsManager::Deinitialize()
{
#if DRAW_IMGUI_TOOLS
	if (OnWorldPostActorTickDelegateHandle.IsValid())
	{
		FWorldDelegates::OnWorldPostActorTick.Remove(OnWorldPostActorTickDelegateHandle);
		OnWorldPostActorTickDelegateHandle.Reset();
	}
	
	if (InputProcessor)
	{
		InputProcessor = nullptr;
	}
#endif	  // #if DRAW_IMGUI_TOOLS
}

void FImGuiToolsManager::RegisterToolWindow(TSharedPtr<FImGuiToolWindow> ToolWindow, FName ToolNamespace /*= NAME_None*/)
{
#if DRAW_IMGUI_TOOLS
	TArray<TSharedPtr<FImGuiToolWindow>>& NamespaceTools = ToolWindows.FindOrAdd(ToolNamespace);
	NamespaceTools.Add(ToolWindow);
#endif	  // #if DRAW_IMGUI_TOOLS
}

void FImGuiToolsManager::OnWorldPostActorTick(UWorld* World, ELevelTick TickType, float DeltaSeconds)
{
#if DRAW_IMGUI_TOOLS
	if (!ImGuiDebugCVars::CVarImGuiToolsEnabled.GetValueOnGameThread())
	{
		return;
	}
	
	if (!IsValid(World) || !World->IsGameWorld() || (World->GetNetMode() == NM_DedicatedServer))
	{
		return;
	}
	
	TSharedPtr<FImGuiContext> ImGuiContext = FImGuiModule::Get().FindOrCreateSessionContext();

	if (ImGuiContext.IsValid())
	{
		ImGui::SetCurrentContext(*ImGuiContext);

		if (ImGui::GetCurrentContext()->WithinFrameScope)
		{
			ImGuiContext->BeginFrame();
			
			// Draw Main Menu Bar
			if (ImGui::BeginMainMenuBar())
			{
				if (FImGuiModule* Module = FModuleManager::GetModulePtr<FImGuiModule>("ImGui"))
				{
					if (ImGui::BeginMenu("ImGui"))
					{
						ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1.0f), "Misc");
						ImGui::Checkbox("Draw ImGui demo", &DrawImGuiDemo);
						ImGui::EndMenu();
					}

				}

				if (ImGui::BeginMenu("UETools"))
				{
					if (ImGui::BeginMenu("Options"))
					{
						ImGui::Checkbox("Show FPS", &ShowFPS);
						ImGui::EndMenu();
					}

					for (TPair<FName, TArray<TSharedPtr<FImGuiToolWindow>>>& NamespaceToolWindows : ToolWindows)
					{
						ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1.0f), "%s", Ansi(*NamespaceToolWindows.Key.ToString()));
						TArray<TSharedPtr<FImGuiToolWindow>>& NamespaceTools = NamespaceToolWindows.Value;
						for (TSharedPtr<FImGuiToolWindow>& ToolWindow : NamespaceTools)
						{
							const FString ToolName = ToolWindow->GetToolName();
							ImGui::Checkbox(Ansi(*ToolName), &ToolWindow->GetEnabledRef());
						}
						ImGui::Separator();
					}
					ImGui::EndMenu();
				}

				// Draw Game Debugger menu
				FImGuiToolsGameDebugger::DrawMainImGuiMenu();
				
				if (ShowFPS)
				{
					ImGui::SameLine(180.0f);
					const int FPS = static_cast<int>(1.0f / DeltaSeconds);
					const float Millis = DeltaSeconds * 1000.0f;
					ImGui::TextColored(ImVec4(1.0f, 0.6f, 0.0f, 1.0f), "%03d FPS %.02f ms", FPS, Millis);
				}

				ImGui::SameLine(310.0f);
#if WITH_EDITOR
				ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1.0f), "'Shift+F1' to toggle input in editor.");
#else
				ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1.0f), "'~'/Console to toggle input.");
#endif
				
				ImGui::EndMainMenuBar();
			}

			if (DrawImGuiDemo)
			{
				// Draw imgui demo window if requested
				ImGui::ShowDemoWindow(&DrawImGuiDemo);
			}

			// Update any active tools:
			for (TPair<FName, TArray<TSharedPtr<FImGuiToolWindow>>>& NamespaceToolWindows : ToolWindows)
			{
				for (TSharedPtr<FImGuiToolWindow>& ToolWindow : NamespaceToolWindows.Value)
				{
					if (ToolWindow.IsValid())
					{
						ToolWindow->UpdateTool(DeltaSeconds);
					}
				}
			}
			
			ImGuiContext->EndFrame();
		}
	}
#endif	  // #if DRAW_IMGUI_TOOLS
}

ToolNamespaceMap& FImGuiToolsManager::GetToolsWindows()
{
	return ToolWindows;
}

TSharedPtr<FImGuiToolWindow> FImGuiToolsManager::GetToolWindow(const FString& ToolWindowName, FName ToolNamespace /*= NAME_None*/)
{
	const bool UseNamespace = (ToolNamespace != NAME_None);
	for (const TPair<FName, TArray<TSharedPtr<FImGuiToolWindow>>>& NamespaceToolWindows : ToolWindows)
	{
		if (!UseNamespace || (ToolNamespace == NamespaceToolWindows.Key))
		{
			const TArray<TSharedPtr<FImGuiToolWindow>>& NamespaceTools = NamespaceToolWindows.Value;
			for (const TSharedPtr<FImGuiToolWindow>& ToolWindow : NamespaceTools)
			{
				if (!ToolWindow.IsValid())
				{
					continue;
				}

				FString ToolWindowStringName(ToolWindow->GetToolName());
				if (ToolWindow->GetToolName() == ToolWindowName)
				{
					return ToolWindow;
				}
			}
		}
	}

	return nullptr;
}

void FImGuiToolsManager::ToggleToolVisCommand(const TArray<FString>& Args)
{
#if DRAW_IMGUI_TOOLS
	FImGuiToolsModule& ImGuiToolsModule = FModuleManager::GetModuleChecked<FImGuiToolsModule>("ImGuiTools");
	if (!ImGuiToolsModule.GetToolsManager().IsValid())
	{
		UE_LOG(LogTemp, Log, TEXT("CVAR'imgui.tools.toggle_tool_vis' was unable to find the ImGuiTools Module."));
		return;
	}

	if (Args.Num() < 1)
	{
		UE_LOG(LogTemp, Log, TEXT("CVAR'imgui.tools.toggle_tool_vis' must be provided a string parameter tool name to toggle visibility."));
		return;
	}

	FString ToolWindowName(TEXT(""));
	for (int i = 0; i < Args.Num(); ++i)
	{
		ToolWindowName += Args[i];
		const bool IsLast = (i == (Args.Num() - 1));
		if (!IsLast)
		{
			ToolWindowName += TEXT(" ");
		}
	}

	TSharedPtr<FImGuiToolWindow> FoundTool = ImGuiToolsModule.GetToolsManager()->GetToolWindow(ToolWindowName);
	if (!FoundTool.IsValid())
	{
		UE_LOG(LogTemp, Log, TEXT("CVAR'imgui.tools.toggle_tool_vis' was unable to find a tool with name: '%s'"), *ToolWindowName);
		return;
	}

    const bool NewToolEnabled = !FoundTool->GetEnabledRef();
    FoundTool->EnableTool(NewToolEnabled);

    if (NewToolEnabled)
    {
        // New tool enabled, flick on ImGui Tools enabled if not already set. 
		ImGuiDebugCVars::CVarImGuiToolsEnabled.AsVariable()->Set(true);
    }
    else
    {
        // Tool now disabled.. check to see if all are closed and if so - close ImGuiTools
        bool AnyToolEnabled = false;
        ToolNamespaceMap& AllToolWindows = ImGuiToolsModule.GetToolsManager()->GetToolsWindows();
        for (const TPair<FName, TArray<TSharedPtr<FImGuiToolWindow>>>& NamespaceTools : AllToolWindows)
        {
            for (const TSharedPtr<FImGuiToolWindow>& ToolSharedPtr : NamespaceTools.Value)
            {
                if (ToolSharedPtr.IsValid())
                {
                    AnyToolEnabled |= ToolSharedPtr->GetEnabledRef();
                }
            }
        }

        if (!AnyToolEnabled)
        {
            ImGuiDebugCVars::CVarImGuiToolsEnabled.AsVariable()->Set(false);
        }
    }
#endif	  // #if DRAW_IMGUI_TOOLS
}

void FImGuiToolsManager::ToggleToolsVisCommand(const TArray<FString>& Args)
{
#if DRAW_IMGUI_TOOLS
    ImGuiDebugCVars::CVarImGuiToolsEnabled.AsVariable()->Set(!ImGuiDebugCVars::CVarImGuiToolsEnabled.GetValueOnGameThread());
#endif	  // #if DRAW_IMGUI_TOOLS
}

#if WITH_EDITOR
/*static*/ void FImGuiToolsManager::LaunchEditorTool(const TArray<FString>& Args)
{
#if DRAW_IMGUI_TOOLS
	FImGuiToolsModule& ImGuiToolsModule = FModuleManager::GetModuleChecked<FImGuiToolsModule>("ImGuiTools");
	if (!ImGuiToolsModule.GetToolsManager().IsValid())
	{
		UE_LOG(LogTemp, Log, TEXT("CVAR'imgui.tools.launch_editor_tool' was unable to find the ImGuiTools Module."));
		return;
	}

	if (Args.Num() < 1)
	{
		UE_LOG(LogTemp, Log, TEXT("CVAR'imgui.tools.launch_editor_tool' must be provided a string parameter tool name to toggle visibility."));
		return;
	}

	FString ToolWindowName(TEXT(""));
	for (int i = 0; i < Args.Num(); ++i)
	{
		ToolWindowName += Args[i];
		const bool IsLast = (i == (Args.Num() - 1));
		if (!IsLast)
		{
			ToolWindowName += TEXT(" ");
		}
	}

	TSharedPtr<FImGuiToolWindow> FoundTool = ImGuiToolsModule.GetToolsManager()->GetToolWindow(ToolWindowName);
	if (!FoundTool.IsValid())
	{
		UE_LOG(LogTemp, Log, TEXT("CVAR'imgui.tools.launch_editor_tool' was unable to find a tool with name: '%s'"), *ToolWindowName);
		return;
	}

	if (!FoundTool->IsEditorToolAllowed())
	{
		UE_LOG(LogTemp, Log, TEXT("CVAR'imgui.tools.launch_editor_tool' tool '%s' is not set to be an editor tool. To enabled, override ::IsEditorToolsAllowed()."), *ToolWindowName);
		return;	
	}

	const FString EditorToolName = FString::Printf(TEXT("%s ImGuiEditorWidget"), *FoundTool->GetToolName());
	FGlobalTabmanager::Get()->TryInvokeTab(FTabId(*EditorToolName));
#endif	  // #if DRAW_IMGUI_TOOLS
}
#endif    // #if WITH_EDITOR

void FImGuiToolsManager::RegisterAutoCompleteEntries(TArray<FAutoCompleteCommand>& Commands) const
{
#if DRAW_IMGUI_TOOLS
	for (const TPair<FName, TArray<TSharedPtr<FImGuiToolWindow>>>& NamespaceToolWindows : ToolWindows)
	{
		const FName& NamespaceName = NamespaceToolWindows.Key;
		for (const TSharedPtr<FImGuiToolWindow>& ToolWindow : NamespaceToolWindows.Value)
		{
			FAutoCompleteCommand Entry;
			const FString ToolName = ToolWindow->GetToolName();
			Entry.Command = FString::Printf(TEXT("%s %s"), *ToggleToolVisCVARName, *ToolName);
			Entry.Desc = FString::Printf(TEXT("Toggle visibility for ImGui Tool '%s' in namespace '%s'"), *ToolName, *NamespaceName.ToString());
			Entry.Color = FColor::Yellow;
			Commands.Add(Entry);

#if WITH_EDITOR
			if (ToolWindow->IsEditorToolAllowed())
			{
				FAutoCompleteCommand EditorEntry;
				EditorEntry.Command = FString::Printf(TEXT("%s %s"), *LaunchEditorToolCVARName, *ToolName);
				EditorEntry.Desc = FString::Printf(TEXT("Launch editor panel tool for ImGui Tool '%s' in namespace '%s'"), *ToolName, *NamespaceName.ToString());
				EditorEntry.Color = FColor::Cyan;
				Commands.Add(EditorEntry);
			}
#endif
		}
	}
#endif // #if DRAW_IMGUI_TOOLS
}

bool FImGuiToolsInputProcessor::HandleKeyDownEvent( FSlateApplication& SlateApp, const FKeyEvent& InKeyEvent )
{
#if DRAW_IMGUI_TOOLS
	KeyCodesDown.AddUnique({ InKeyEvent.GetKeyCode(), InKeyEvent.GetCharacter() });
	
	const bool ToggleVisBefore = ToggleVisDown;
	const bool ToggleInputBefore = ToggleInputDown;

	// Will update ToggleVisDown / ToggleInput Down with new state. 
	CheckForToggleShortcutState();

	if (!ToggleVisBefore && ToggleVisDown)
	{
		ImGuiDebugCVars::CVarImGuiToolsEnabled.AsVariable()->Set(!ImGuiDebugCVars::CVarImGuiToolsEnabled.AsVariable()->GetBool());
	}
#endif // #if DRAW_IMGUI_TOOLS
	
	return false;
}

bool FImGuiToolsInputProcessor::HandleKeyUpEvent( FSlateApplication& SlateApp, const FKeyEvent& InKeyEvent )
{
#if DRAW_IMGUI_TOOLS
	KeyCodesDown.Remove({ InKeyEvent.GetKeyCode(), InKeyEvent.GetCharacter() });
	
	CheckForToggleShortcutState();
#endif // #if DRAW_IMGUI_TOOLS
	
	return false;
}

void FImGuiToolsInputProcessor::CheckForToggleShortcutState()
{
	// Toggle Input
	int32 InputKeysDown = 0;
	bool NewToggleInputDown = true;
	const TArray<FKey>& ToggleInputKeys = GetDefault<UImGuiToolsDeveloperSettings>()->ImGuiToggleInputKeys;
	for (const FKey& ToggleInputKey : ToggleInputKeys)
	{
		const bool KeyDown = KeyCodesDown.ContainsByPredicate([ToggleInputKey](const KeyCodePair& KeyCode)
		{
			const uint32* KeyCodePtr;
			const uint32* CharCodePtr;
			FInputKeyManager::Get().GetCodesFromKey(ToggleInputKey, KeyCodePtr, CharCodePtr);

			return (KeyCodePtr && (*KeyCodePtr == KeyCode.Get<0>())) || (CharCodePtr && (*CharCodePtr == KeyCode.Get<1>()));
		});

		if (KeyDown)
		{
			InputKeysDown++;
		}
		
		NewToggleInputDown &= KeyDown;
	}

	ToggleInputDown = NewToggleInputDown;

	// Toggle Vis
	bool NewToggleVisDown = true;
	const TArray<FKey>& ToggleVisKeys = GetDefault<UImGuiToolsDeveloperSettings>()->ImGuiToggleVisibilityKeys;
	for (const FKey& ToggleVisKey : ToggleVisKeys)
	{
		const bool KeyDown = KeyCodesDown.ContainsByPredicate([ToggleVisKey](const KeyCodePair& KeyCode)
		{
			const uint32* KeyCodePtr;
			const uint32* CharCodePtr;
			FInputKeyManager::Get().GetCodesFromKey(ToggleVisKey, KeyCodePtr, CharCodePtr);

			return (KeyCodePtr && (*KeyCodePtr == KeyCode.Get<0>())) || (CharCodePtr && (*CharCodePtr == KeyCode.Get<1>()));
		});
		
		NewToggleVisDown &= KeyDown;
	}

	ToggleVisDown = NewToggleVisDown;
}

```

`ImGuiTools/Source/ImGuiTools/Private/Misc/StreamingTextureLevelContext.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.
//	NOTE (ImGuiDebugTools) : This UE Engine class is simply copied in here as it is not exported for use in other modules in UE 4.27

#include "StreamingTextureLevelContext.h"

#if ENGINE_MAJOR_VERSION == 4

#include <RHI.h>
#include <Logging/MessageLog.h>
#include <Misc/UObjectToken.h>

namespace ImGuiDebugToolsUtils
{
FStreamingTextureLevelContext::FStreamingTextureLevelContext(EMaterialQualityLevel::Type InQualityLevel, const UPrimitiveComponent* Primitive)
	: TextureGuidToLevelIndex(nullptr)
	, bUseRelativeBoxes(false)
	, BuildDataTimestamp(0)
	, ComponentBuildData(nullptr)
	, QualityLevel(InQualityLevel)
	, FeatureLevel(static_cast<ERHIFeatureLevel::Type>(GMaxRHIFeatureLevel))
{
	if (Primitive)
	{
		const UWorld* World = Primitive->GetWorld();
		if (World)
		{
			FeatureLevel = static_cast<ERHIFeatureLevel::Type>(World->FeatureLevel.GetValue());
		}
	}
}

FStreamingTextureLevelContext::FStreamingTextureLevelContext(EMaterialQualityLevel::Type InQualityLevel, ERHIFeatureLevel::Type InFeatureLevel, bool InUseRelativeBoxes)
	: TextureGuidToLevelIndex(nullptr)
	, bUseRelativeBoxes(InUseRelativeBoxes)
	, BuildDataTimestamp(0)
	, ComponentBuildData(nullptr)
	, QualityLevel(InQualityLevel)
	, FeatureLevel(InFeatureLevel)
{}

FStreamingTextureLevelContext::FStreamingTextureLevelContext(EMaterialQualityLevel::Type InQualityLevel, const ULevel* InLevel, const TMap<FGuid, int32>* InTextureGuidToLevelIndex)
	: TextureGuidToLevelIndex(nullptr)
	, bUseRelativeBoxes(false)
	, BuildDataTimestamp(0)
	, ComponentBuildData(nullptr)
	, QualityLevel(InQualityLevel)
	, FeatureLevel(static_cast<ERHIFeatureLevel::Type>(GMaxRHIFeatureLevel))
{
	if (InLevel)
	{
		const UWorld* World = InLevel->GetWorld();
		if (World)
		{
			FeatureLevel = static_cast<ERHIFeatureLevel::Type>(World->FeatureLevel.GetValue());
		}

		if (InLevel && InTextureGuidToLevelIndex && InLevel->StreamingTextureGuids.Num() > 0 && InLevel->StreamingTextureGuids.Num() == InTextureGuidToLevelIndex->Num())
		{
			bUseRelativeBoxes = !InLevel->bTextureStreamingRotationChanged;
			TextureGuidToLevelIndex = InTextureGuidToLevelIndex;

			// Extra transient data for each texture.
			BoundStates.AddZeroed(InLevel->StreamingTextureGuids.Num());
		}
	}
}

FStreamingTextureLevelContext::~FStreamingTextureLevelContext()
{
	// Reset the level indices for the next use.
	for (const FTextureBoundState& BoundState : BoundStates)
	{
		if (BoundState.Texture)
		{
			BoundState.Texture->LevelIndex = INDEX_NONE;
		}
	}
}

void FStreamingTextureLevelContext::BindBuildData(const TArray<FStreamingTextureBuildInfo>* BuildData)
{
	// Increment the component timestamp, used to know when a texture is processed by a component for the first time.
	// Using a timestamp allows to not reset state in between components.
	++BuildDataTimestamp;

	if (TextureGuidToLevelIndex && CVarStreamingUseNewMetrics.GetValueOnGameThread() != 0)	  // No point in binding data if there is no possible remapping.
	{
		// Process the build data in order to be able to map a texture object to the build data entry.
		ComponentBuildData = BuildData;
		if (BuildData && BoundStates.Num() > 0)
		{
			for (int32 Index = 0; Index < BuildData->Num(); ++Index)
			{
				int32 TextureLevelIndex = (*BuildData)[Index].TextureLevelIndex;
				if (BoundStates.IsValidIndex(TextureLevelIndex))
				{
					FTextureBoundState& BoundState = BoundStates[TextureLevelIndex];
					BoundState.BuildDataIndex = Index;					   // The index of this texture in the component build data.
					BoundState.BuildDataTimestamp = BuildDataTimestamp;	   // The component timestamp will indicate that the index is valid to be used.
				}
			}
		}
	}
	else
	{
		ComponentBuildData = nullptr;
	}
}

int32* FStreamingTextureLevelContext::GetBuildDataIndexRef(UTexture2D* Texture2D)
{
	if (ComponentBuildData)	   // If there is some build data to map to.
	{
		if (Texture2D->LevelIndex == INDEX_NONE)
		{
			check(TextureGuidToLevelIndex);	   // Can't bind ComponentData without the remapping.
			const int32* LevelIndex = TextureGuidToLevelIndex->Find(Texture2D->GetLightingGuid());
			if (LevelIndex)	   // If the index is found in the map, the index is valid in BoundStates
			{
				// Here we need to support the invalid case where 2 textures have the same GUID.
				// If this happens, BoundState.Texture will already be set.
				FTextureBoundState& BoundState = BoundStates[*LevelIndex];
				if (!BoundState.Texture)
				{
					Texture2D->LevelIndex = *LevelIndex;
					BoundState.Texture = Texture2D;	   // Update the mapping now!
				}
				else	// Don't allow 2 textures to be using the same level index otherwise UTexture2D::LevelIndex won't be reset properly in the destructor.
				{
					FMessageLog("AssetCheck")
						.Error()
						->AddToken(FUObjectToken::Create(BoundState.Texture))
						->AddToken(FUObjectToken::Create(Texture2D))
						->AddToken(
							FTextToken::Create(NSLOCTEXT("AssetCheck", "TextureError_NonUniqueLightingGuid",
														 "Same lighting guid, modify or touch any property in the texture editor to generate a new guid and fix the issue.")));

					// This will fallback not using the precomputed data. Note also that the other texture might be using the wrong precomputed data.
					return nullptr;
				}
			}
			else	// Otherwise add a dummy entry to prevent having to search in the map multiple times.
			{
				Texture2D->LevelIndex = BoundStates.Add(FTextureBoundState(Texture2D));
			}
		}

		FTextureBoundState& BoundState = BoundStates[Texture2D->LevelIndex];
		check(BoundState.Texture == Texture2D);

		if (BoundState.BuildDataTimestamp == BuildDataTimestamp)
		{
			return &BoundState.BuildDataIndex;	  // Only return the bound static if it has data relative to this component.
		}
	}
	return nullptr;
}

void FStreamingTextureLevelContext::ProcessMaterial(const FBoxSphereBounds& ComponentBounds,
													const FPrimitiveMaterialInfo& MaterialData,
													float ComponentScaling,
													TArray<FStreamingRenderAssetPrimitiveInfo>& OutStreamingTextures)
{
	ensure(MaterialData.IsValid());

	TArray<UTexture*> Textures;
	MaterialData.Material->GetUsedTextures(Textures, QualityLevel, false, static_cast<::ERHIFeatureLevel::Type>(FeatureLevel), false);

	for (UTexture* Texture : Textures)
	{
		UTexture2D* Texture2D = Cast<UTexture2D>(Texture);
		if (!Texture2D || !Texture2D->IsStreamable())
		{
			continue;
		}

		int32* BuildDataIndex = GetBuildDataIndexRef(Texture2D);
		if (BuildDataIndex)
		{
			if (*BuildDataIndex != INDEX_NONE)
			{
				FStreamingRenderAssetPrimitiveInfo& Info = *new (OutStreamingTextures) FStreamingRenderAssetPrimitiveInfo();
				const FStreamingTextureBuildInfo& BuildInfo = (*ComponentBuildData)[*BuildDataIndex];

				Info.RenderAsset = Texture2D;
				Info.TexelFactor = BuildInfo.TexelFactor * ComponentScaling;
				Info.PackedRelativeBox = bUseRelativeBoxes ? BuildInfo.PackedRelativeBox : PackedRelativeBox_Identity;
				UnpackRelativeBox(ComponentBounds, Info.PackedRelativeBox, Info.Bounds);

				// Indicate that this texture build data has already been processed.
				// The build data use the merged results of all material so it only needs to be processed once.
				*BuildDataIndex = INDEX_NONE;
			}
		}
		else	// Otherwise create an entry using the available data.
		{
			float TextureDensity = MaterialData.Material->GetTextureDensity(Texture->GetFName(), *MaterialData.UVChannelData);

			if (!TextureDensity)
			{
				// Fallback assuming a sampling scale of 1 using the UV channel 0;
				TextureDensity = MaterialData.UVChannelData->LocalUVDensities[0];
			}

			if (TextureDensity)
			{
				FStreamingRenderAssetPrimitiveInfo& Info = *new (OutStreamingTextures) FStreamingRenderAssetPrimitiveInfo();

				Info.RenderAsset = Texture2D;
				Info.TexelFactor = TextureDensity * ComponentScaling;
				Info.PackedRelativeBox = bUseRelativeBoxes ? MaterialData.PackedRelativeBox : PackedRelativeBox_Identity;
				UnpackRelativeBox(ComponentBounds, Info.PackedRelativeBox, Info.Bounds);
			}
		}
	}
}
} // namespace ImGuiDebugToolsUtils
#endif // #if ENGINE_MAJOR_VERSION == 4
```

`ImGuiTools/Source/ImGuiTools/Private/Misc/StreamingTextureLevelContext.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
//	NOTE (ImGuiDebugTools) : This UE Engine class is simply copied in here as it is not exported for use in other modules in UE 4.27

#pragma once

#include "Runtime/Launch/Resources/Version.h"

#if ENGINE_MAJOR_VERSION == 4

#include <SceneTypes.h>
#include <RHIDefinitions.h>

namespace ImGuiDebugToolsUtils
{
/**
	* The RHI's feature level indicates what level of support can be relied upon.
	* Note: these are named after graphics API's like ES3 but a feature level can be used with a different API (eg ERHIFeatureLevel::ES3.1 on D3D11)
	* As long as the graphics API supports all the features of the feature level (eg no ERHIFeatureLevel::SM5 on OpenGL ES3.1)
	*/
namespace ERHIFeatureLevel
{
	enum Type
	{
		/** Feature level defined by the core capabilities of OpenGL ES2. Deprecated */
		ES2_REMOVED,

		/** Feature level defined by the core capabilities of OpenGL ES3.1 & Metal/Vulkan. */
		ES3_1,

		/**
			* Feature level defined by the capabilities of DX10 Shader Model 4.
			* SUPPORT FOR THIS FEATURE LEVEL HAS BEEN ENTIRELY REMOVED.
			*/
			SM4_REMOVED,

			/**
			* Feature level defined by the capabilities of DX11 Shader Model 5.
			*   Compute shaders with shared memory, group sync, UAV writes, integer atomics
			*   Indirect drawing
			*   Pixel shaders with UAV writes
			*   Cubemap arrays
			*   Read-only depth or stencil views (eg read depth buffer as SRV while depth test and stencil write)
			* Tessellation is not considered part of Feature Level SM5 and has a separate capability flag.
			*/
			SM5,
			Num
	};
};
/**
 * Context used to resolve FStreamingTextureBuildInfo to FStreamingRenderAssetPrimitiveInfo
 * The context make sure that build data and each texture is only processed once per component (with constant time).
 * It manage internally structures used to accelerate the binding between precomputed data and textures,
 * so that there is only one map lookup per texture per level.
 * There is some complexity here because the build data does not reference directly texture objects to avoid hard references
 * which would load texture when the component is loaded, which could be wrong since the build data is built for a specific
 * feature level and quality level. The current feature and quality could reference more or less textures.
 * This requires the logic to not submit a streaming entry for precomputed data, as well as submit fallback data for
 * texture that were referenced in the texture streaming build.
 */
class FStreamingTextureLevelContext
{
	/** Reversed lookup for ULevel::StreamingTextureGuids. */
	const TMap<FGuid, int32>* TextureGuidToLevelIndex;

	/** Whether the precomputed relative bounds should be used or not.  Will be false if the transform level was rotated since the last texture streaming build. */
	bool bUseRelativeBoxes;

	/** An id used to identify the component build data. */
	int32 BuildDataTimestamp;

	/** The last bound component texture streaming build data. */
	const TArray<FStreamingTextureBuildInfo>* ComponentBuildData;

	struct FTextureBoundState
	{
		FTextureBoundState() {}

		FTextureBoundState(UTexture2D* InTexture) : BuildDataTimestamp(0), BuildDataIndex(0), Texture(InTexture) {}

		/** The timestamp of the build data to indentify whether BuildDataIndex is valid or not. */
		int32 BuildDataTimestamp;
		/** The ComponentBuildData Index referring this texture. */
		int32 BuildDataIndex;
		/**  The texture relative to this entry. */
		UTexture2D* Texture;
	};

	/*
	 * The component state of the each texture. Used to prevent processing each texture several time.
	 * Also used to find quickly the build data relating to each texture.
	 */
	TArray<FTextureBoundState> BoundStates;

	EMaterialQualityLevel::Type QualityLevel;
	ERHIFeatureLevel::Type FeatureLevel;

	int32* GetBuildDataIndexRef(UTexture2D* Texture2D);

public:

	// Needs InLevel to use precomputed data from 
	FStreamingTextureLevelContext(EMaterialQualityLevel::Type InQualityLevel, const ULevel* InLevel = nullptr, const TMap<FGuid, int32>* InTextureGuidToLevelIndex = nullptr);
	FStreamingTextureLevelContext(EMaterialQualityLevel::Type InQualityLevel, ERHIFeatureLevel::Type InFeatureLevel, bool InUseRelativeBoxes);
	FStreamingTextureLevelContext(EMaterialQualityLevel::Type InQualityLevel, const UPrimitiveComponent* Primitive);
	~FStreamingTextureLevelContext();

	void BindBuildData(const TArray<FStreamingTextureBuildInfo>* PreBuiltData);
	void ProcessMaterial(const FBoxSphereBounds& ComponentBounds, const FPrimitiveMaterialInfo& MaterialData, float ComponentScaling, TArray<FStreamingRenderAssetPrimitiveInfo>& OutStreamingTextures);

	EMaterialQualityLevel::Type GetQualityLevel() { return QualityLevel; }
	ERHIFeatureLevel::Type GetFeatureLevel() { return FeatureLevel; }
};

} // namespace ImGuiDebugToolsUtils

#endif // #if ENGINE_MAJOR_VERSION == 4
```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiActorComponentDebugger.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiActorComponentDebugger.h"

#include "Utils/ClassHierarchyInfo.h"
#include "Utils/ImGuiUtils.h"

#include <imgui.h>
#include <EngineUtils.h>
#include <UObject/UObjectIterator.h>

namespace ImGuiActorCompUtils
{
    ///////////////////////////////////////
    /////////  Static Drawing functions

	// Get a nice string representations of an actors replication settings
	FString GetReplicationString_Actor(AActor* Act)
	{
		return Act->GetIsReplicated()
			? FString::Printf(TEXT("true - %s"), *StaticEnum<ENetRole>()->GetNameStringByValue(Act->GetLocalRole()))
			: FString(TEXT("false"));
	}
	FString GetReplicationString_Component(UActorComponent* Comp)
	{
		return Comp->GetIsReplicated()
			? FString::Printf(TEXT("true - %s"), *StaticEnum<ENetRole>()->GetNameStringByValue(Comp->GetOwnerRole()))
			: FString(TEXT("false"));
	}

	void DrawUProperties(UObject* Obj)
	{
		ImGui::Columns(4);

		ImGui::Text("Property Name"); ImGui::NextColumn();
		ImGui::Text("Property Value"); ImGui::NextColumn();
		ImGui::Text("Property Type"); ImGui::NextColumn();
		ImGui::Text("Property CPP Type"); ImGui::NextColumn();
		
		ImGui::Columns(1);

		ImGui::BeginChild(Ansi(*FString::Printf(TEXT("%s-Props"), *Obj->GetName())), ImVec2(0, 300.0f), true);
		ImGui::Columns(4);

		UClass* ObjClass = Obj->GetClass();

		for (FProperty* Prop : TFieldRange<FProperty>(ObjClass))
		{
			ImGui::Text("%s", Ansi(*Prop->GetName())); ImGui::NextColumn();
			ImGuiTools::Utils::DrawPropertyValue(Prop, Obj); ImGui::NextColumn();
			ImGui::Text("%s", Ansi(*Prop->GetClass()->GetName())); ImGui::NextColumn();
			ImGui::Text("%s", Ansi(*Prop->GetCPPType())); ImGui::NextColumn();
		}

		ImGui::Columns(1);
		ImGui::EndChild();
	}

    void DrawImGuiComponentTreeNode(USceneComponent* SceneComp)
    {
        TArray<USceneComponent*> ChildComps;
        SceneComp->GetChildrenComponents(/*IncludeAllDescendants*/false, ChildComps);
        const bool HasChildren = ChildComps.Num() > 0;

        const FString CompLabel = SceneComp->GetName();

        if (HasChildren)
        {
            const bool NodeOpen = ImGui::TreeNode(Ansi(*CompLabel));
            ImGui::NextColumn();
			ImGui::Text("%s", Ansi(*SceneComp->GetClass()->GetName())); ImGui::NextColumn();
			ImGui::Text(SceneComp->IsActive() ? "true" : "false"); ImGui::NextColumn();
			ImGui::Text(SceneComp->IsComponentTickEnabled() ? "true" : "false"); ImGui::NextColumn();
			ImGui::Text(SceneComp->GetIsReplicated() ? "true" : "false"); ImGui::NextColumn();
            if (NodeOpen)
            {
                for (USceneComponent* ChildSceneComp : ChildComps)
                {
                    DrawImGuiComponentTreeNode(ChildSceneComp);
                }

                ImGui::TreePop();
            }
        }
        else
        {
            ImGui::Text("%s", Ansi(*CompLabel)); ImGui::NextColumn();
			ImGui::Text("%s", Ansi(*SceneComp->GetClass()->GetName())); ImGui::NextColumn();
			ImGui::Text(SceneComp->IsActive() ? "true" : "false"); ImGui::NextColumn();
			ImGui::Text(SceneComp->IsComponentTickEnabled() ? "true" : "false"); ImGui::NextColumn();
			ImGui::Text(SceneComp->GetIsReplicated() ? "true" : "false"); ImGui::NextColumn();
        }
    }

    void DrawImGuiActorWindow(AActor* Act)
    {
        const TSet<UActorComponent*>& Components = Act->GetComponents();
        const int NumComps = Components.Num();

        if (ImGui::CollapsingHeader("Actor Info", ImGuiTreeNodeFlags_DefaultOpen))
        {
            ImGui::BeginChild(Ansi(*FString::Printf(TEXT("a:%sw:%s##ActorInfo"), *Act->GetName(), *Act->GetWorld()->GetName())), ImVec2(0.0f, 130.0f));
            ImGui::Columns(2);

            ImGui::Text("Actor Name"); ImGui::NextColumn();
            ImGui::Text("%s", Ansi(*Act->GetName())); ImGui::Separator(); ImGui::NextColumn();

            ImGui::Text("Replicates"); ImGui::NextColumn();
            ImGui::Text("%s", Ansi(*GetReplicationString_Actor(Act))); ImGui::NextColumn();

			ImGui::Text("Replicates Movement"); ImGui::NextColumn();
			ImGui::Text(Act->IsReplicatingMovement() ? "true" : "false"); ImGui::NextColumn();
            
            ImGui::Text("World"); ImGui::NextColumn();
            ImGui::Text("%s", Ansi(*Act->GetWorld()->GetName())); ImGui::NextColumn();
            
            ImGui::Text("Actor Tick"); ImGui::NextColumn();
            ImGui::Text(Act->IsActorTickEnabled() ? "true" : "false"); ImGui::NextColumn();

            ImGui::Text("Component Count"); ImGui::NextColumn();
            ImGui::Text("%d", NumComps); ImGui::NextColumn();

            int TickingComponentsCount = 0;
            for (UActorComponent* Comp : Components)
            {
                if (Comp && Comp->IsComponentTickEnabled())
                {
                    ++TickingComponentsCount;
                }
            }

			ImGui::Text("Ticking Component Count"); ImGui::NextColumn();
			ImGui::Text("%d", TickingComponentsCount); ImGui::NextColumn();

            ImGui::Columns(1);
            ImGui::EndChild();
        }

		if (ImGui::CollapsingHeader("Class Hierarchy"))
		{
			ImGuiTools::DrawClassHierarchy(Act, AActor::StaticClass());
		}

		if (ImGui::CollapsingHeader("UProperties"))
		{
			DrawUProperties(Act);
		}
        
        if (ImGui::CollapsingHeader("Components", ImGuiTreeNodeFlags_DefaultOpen))
        {
            ImGui::BeginChild(Ansi(*FString::Printf(TEXT("a:%sw:%s##Comps"), *Act->GetName(), *Act->GetWorld()->GetName())), ImVec2(0.0f, 250.0f));
            
            ImGui::Columns(5);

            ImGui::Text("Component Name"); ImGui::NextColumn();
			ImGui::Text("Component Class"); ImGui::NextColumn();
            ImGui::Text("Active"); ImGui::NextColumn();
            ImGui::Text("Ticks"); ImGui::NextColumn();
            ImGui::Text("Replicates"); ImGui::NextColumn();


            if (USceneComponent* RootSceneComp = Act->GetRootComponent())
            {
                ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1.0f), "Scene Components:");
                ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn();
                DrawImGuiComponentTreeNode(RootSceneComp);
            }

            int CompCount = 1;
            bool AnyActorComps = false;
            for (UActorComponent* Comp : Components)
            {
                if (Comp && !Cast<USceneComponent>(Comp))
                {
                    if (!AnyActorComps)
                    {
                        AnyActorComps = true;
                        ImGui::TextColored(ImVec4(0.6f, 0.6f, 0.6f, 1.0f), "Actor Components:");
                        ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn();
                    }
                    ImGui::Text("%s", Ansi(*FString::Printf(TEXT(" %d - %s "), CompCount, *Comp->GetName())));

					ImGui::NextColumn();
					ImGui::Text("%s", Ansi(*Comp->GetClass()->GetName())); ImGui::NextColumn();
					ImGui::Text(Comp->IsActive() ? "true" : "false"); ImGui::NextColumn();
					ImGui::Text(Comp->IsComponentTickEnabled() ? "true" : "false"); ImGui::NextColumn();
					ImGui::Text(Comp->GetIsReplicated() ? "true" : "false"); ImGui::NextColumn();

                    ++CompCount;
                }
            }

            ImGui::Columns(1);
            ImGui::EndChild();
        }
    }

	void DrawImGuiComponentWindow(UActorComponent* Comp)
	{
		if (ImGui::CollapsingHeader("Component Info", ImGuiTreeNodeFlags_DefaultOpen))
		{
			ImGui::BeginChild(Ansi(*FString::Printf(TEXT("a:%sw:%s##CompInfo"), *Comp->GetName(), *Comp->GetWorld()->GetName())), ImVec2(0.0f, 130.0f));
			ImGui::Columns(2);

			ImGui::Text("Component Name"); ImGui::NextColumn();
			ImGui::Text("%s", Ansi(*Comp->GetName())); ImGui::Separator(); ImGui::NextColumn();

			ImGui::Text("Owner"); ImGui::NextColumn();
			ImGui::Text("%s", Comp->GetOwner() ? Ansi(*Comp->GetOwner()->GetName()) : "*none*"); ImGui::NextColumn();

			ImGui::Text("World"); ImGui::NextColumn();
			ImGui::Text("%s", Ansi(*Comp->GetWorld()->GetName())); ImGui::NextColumn();

			ImGui::Text("Activated"); ImGui::NextColumn();
			ImGui::Text(Comp->IsActive() ? "active" : "not active"); ImGui::NextColumn();

			ImGui::Text("Ticking"); ImGui::NextColumn();
			ImGui::Text(Comp->IsComponentTickEnabled() ? "enabled" : "disabled"); ImGui::NextColumn();

			ImGui::Text("Replicates"); ImGui::NextColumn();
			ImGui::Text("%s", Ansi(*GetReplicationString_Component(Comp))); ImGui::NextColumn();

			ImGui::Columns(1);
			ImGui::EndChild();
		}

		if (ImGui::CollapsingHeader("Class Hierarchy"))
		{
			ImGuiTools::DrawClassHierarchy(Comp, UActorComponent::StaticClass());
		}

		if (ImGui::CollapsingHeader("UProperties"))
		{
			DrawUProperties(Comp);
		}
	}

	bool CachedClass_DoesAnyDescendantPassFilter(FCachedClassInfo& CachedClassInfo, ImGuiTextFilter& ClassFilter, TArray<FCachedClassInfo>& ParentContainer)
	{
		if (ClassFilter.PassFilter(Ansi(*CachedClassInfo.Class->GetName())))
		{
			// main class passes filter, we can just say we pass the filter
			return true;
		}
		
		// Check for child classes passing the filter
		for (int ChildClassIndex : CachedClassInfo.ChildClassIndicies)
		{
			FCachedClassInfo& ChildCachedInfo = ParentContainer[ChildClassIndex];
			if (CachedClass_DoesAnyDescendantPassFilter(ChildCachedInfo, ClassFilter, ParentContainer))
			{
				return true;
			}
		}

		// nothing passed filter. we fail!
		return false;
	}

	// Draw ImGui for this cached class - Actor version - provide a pointer to an optional parent container to draw Child classes
	void CachedClass_DrawImGui_Actor(FCachedClassInfo& CachedClassInfo, TArray<TWeakObjectPtr<AActor>>& ActorWindows, ImGuiTextFilter& ClassFilter, TArray<FCachedClassInfo>* OptionalParentContainer = nullptr, bool ForceOpen = false, bool ForceOpenChildren = false)
	{
		// Check to see if we should draw ourselves
		if (OptionalParentContainer)
		{
			// Hierarchical view.. draw ourselves if this class or any descendants pass name filter
			if (!CachedClass_DoesAnyDescendantPassFilter(CachedClassInfo, ClassFilter, *OptionalParentContainer))
			{
				return;
			}
		}
		else
		{
			// Non-Hierarchical view.. Draw ourselves if we pass name filter and we have child actors
			if (CachedClassInfo.Objects.Num() == 0)
			{
				return;
			}
			if (!ClassFilter.PassFilter(Ansi(*CachedClassInfo.Class->GetName())))
			{
				return;
			}
		}

		static ImGuiTreeNodeFlags base_flags = ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_AllowOverlap;
		ImGuiTreeNodeFlags node_flags = base_flags;
		if (ForceOpen)
		{
			node_flags |= ImGuiTreeNodeFlags_DefaultOpen;
		}

		const bool TreeOpen = ImGui::TreeNodeEx(Ansi(*FString::Printf(TEXT("%s"), *CachedClassInfo.Class->GetName())), node_flags);
		ImGui::NextColumn();
		ImGui::Text("%03d", CachedClassInfo.CachedActorHierarchyCount);
		ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn();
		if (TreeOpen)
		{
			// Sort actors of this class alphabetically if this node is open.
            CachedClassInfo.Objects.Sort([](const TWeakObjectPtr<UObject>& A, const TWeakObjectPtr<UObject>& B) { return A->GetName() < B->GetName(); });

			// Display Actors
			for (int i = 0; i < CachedClassInfo.Objects.Num(); ++i)
			{
				//ImGui::SameLine(16.0f);
				TWeakObjectPtr<UObject>& Actor = CachedClassInfo.Objects[i];
				AActor* ActorPtr = Cast<AActor>(Actor.Get());
				if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Inspect Actor %03d - %s"), i + 1, *Actor->GetName()))))
				{
					ActorWindows.AddUnique(TWeakObjectPtr<AActor>(ActorPtr));
				}
				ImGui::NextColumn(); ImGui::NextColumn();

				ImGui::Text("%s", Ansi(*GetReplicationString_Actor(ActorPtr))); ImGui::NextColumn();
				ImGui::Text(ActorPtr->IsActorTickEnabled() ? "true" : "false"); ImGui::NextColumn();

				int TickingComps = 0;
				const TSet<UActorComponent*>& ActorComps = ActorPtr->GetComponents();
				for (UActorComponent* ActorComp : ActorComps)
				{
					if (ActorComp && ActorComp->IsComponentTickEnabled())
					{
						++TickingComps;
					}
				}
				ImGui::Text("%d", ActorComps.Num()); ImGui::NextColumn();
				ImGui::Text("%d", TickingComps); ImGui::NextColumn();
			}

			// Display Child classes
			if (OptionalParentContainer)
			{
				TArray<FCachedClassInfo>& ParentContainer = *OptionalParentContainer;
				// If we were provided an optional parent container, we can display classes in hierarchy
				for (int ChildClassIndex : CachedClassInfo.ChildClassIndicies)
				{
                    CachedClass_DrawImGui_Actor(ParentContainer[ChildClassIndex], ActorWindows, ClassFilter, OptionalParentContainer, (CachedClassInfo.Objects.Num() == 0) || ForceOpenChildren, ForceOpenChildren);
				}
			}

			ImGui::Separator();
			ImGui::TreePop();
		}
	}

	// Draw ImGui for this cached class - Component version - provide a pointer to an optional parent container to draw Child classes
	void CachedClass_DrawImGui_Component(FCachedClassInfo& CachedClassInfo, TArray<TWeakObjectPtr<UActorComponent>>& ComponentWindows, TArray<FCachedClassInfo>* OptionalParentContainer = nullptr, bool ForceOpen = false, bool ForceOpenChildren = false)
	{
		static ImGuiTreeNodeFlags base_flags = ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_AllowOverlap;
		ImGuiTreeNodeFlags node_flags = base_flags;
		if (ForceOpen)
		{
			node_flags |= ImGuiTreeNodeFlags_DefaultOpen;
		}

		const bool TreeOpen = ImGui::TreeNodeEx(Ansi(*FString::Printf(TEXT("%s"), *CachedClassInfo.Class->GetName())), node_flags);
		ImGui::NextColumn();
		ImGui::Text("%03d", CachedClassInfo.CachedActorHierarchyCount);
		ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn(); ImGui::NextColumn();
		if (TreeOpen)
		{
			// Sort objects of this class alphabetically if this node is open.
			CachedClassInfo.Objects.Sort([](const TWeakObjectPtr<UObject>& A, const TWeakObjectPtr<UObject>& B) { return A->GetName() < B->GetName(); });

			// Display Components
			for (int i = 0; i < CachedClassInfo.Objects.Num(); ++i)
			{
				TWeakObjectPtr<UObject>& Comp = CachedClassInfo.Objects[i];
				UActorComponent* CompPtr = Cast<UActorComponent>(Comp.Get());
				if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Inspect Component %03d - %s"), i + 1, *CompPtr->GetName()))))
				{
					ComponentWindows.AddUnique(TWeakObjectPtr<UActorComponent>(CompPtr));
				}
				ImGui::NextColumn(); ImGui::NextColumn();

				
				ImGui::Text("%s", CompPtr->GetOwner() ? Ansi(*CompPtr->GetOwner()->GetName()) : "*none*"); ImGui::NextColumn();
				ImGui::Text(CompPtr->IsActive() ? "active" : "not active"); ImGui::NextColumn();
				ImGui::Text(CompPtr->IsComponentTickEnabled() ? "enabled" : "disabled"); ImGui::NextColumn();
				ImGui::Text("%s", Ansi(*GetReplicationString_Component(CompPtr))); ImGui::NextColumn();
			}

			// Display Child classes
			if (OptionalParentContainer)
			{
				TArray<FCachedClassInfo>& ParentContainer = *OptionalParentContainer;
				// If we were provided an optional parent container, we can display classes in hierarchy
				for (int ChildClassIndex : CachedClassInfo.ChildClassIndicies)
				{
					CachedClass_DrawImGui_Component(ParentContainer[ChildClassIndex], ComponentWindows, OptionalParentContainer, (CachedClassInfo.Objects.Num() == 0) || ForceOpenChildren, ForceOpenChildren);
				}
			}

			ImGui::Separator();
			ImGui::TreePop();
		}
	}


	///////////////////////////////////////
	/////////  Helper structs and enums

    enum class EClassSortType : int
    {
        Alphabetical = 0,
        ActorCount
    };

    // Settings for the entire window
    struct FSettings
    {
        // How often to refresh the actor cache. <= 0.0f means every frame
        float RefreshTimer = -1.0f;
    };

    // Per-World settings
    struct FWorldSettings
    {
        // Should the classes be displayed in a hierarchy or in a flat list
        bool            ClassHierarchy  = true;

        // How to sort the actor classes
        EClassSortType  ClassSortType   = EClassSortType::ActorCount;
    };

	// Will cache actor hierarchy count on this class cache ( and any children as a by product ) and return the result.
	int FCachedClassInfo::CacheActorHierarchyCount(TArray<FCachedClassInfo>& ParentContainer)
	{
		CachedActorHierarchyCount = Objects.Num();
		for (int ChildClassIndex : ChildClassIndicies)
		{
			CachedActorHierarchyCount += ParentContainer[ChildClassIndex].CacheActorHierarchyCount(ParentContainer);
		}
		return CachedActorHierarchyCount;
	}   

    // cached data for a single world
    struct FCachedWorldInfo
    {
        void SortAndBuildHierarchy(TArray<FCachedClassInfo>& CachedClassInfos)
        {
			// Loop through and cache actor counts ( do this before sorting by actor count! ) 
			//  NOTE: we know index 0 is the root class AActor right now as we are pre-sort.
			CachedClassInfos[0].CacheActorHierarchyCount(CachedClassInfos);

			// All classes and actors added. Now sort classes. 
			switch (WorldSettings.ClassSortType)
			{
			    default:
			    case ImGuiActorCompUtils::EClassSortType::Alphabetical:
				    CachedClassInfos.Sort([](const FCachedClassInfo& A, const FCachedClassInfo& B) { return A.Class->GetName() < B.Class->GetName(); });
				    break;

			    case ImGuiActorCompUtils::EClassSortType::ActorCount:
				    CachedClassInfos.Sort([](const FCachedClassInfo& A, const FCachedClassInfo& B) {
					    const int ASize = A.CachedActorHierarchyCount;
					    const int BSize = B.CachedActorHierarchyCount;
					    if (ASize == BSize)
					    {
						    // Sort alphabetically for class with same actor count
						    return A.Class->GetName() < B.Class->GetName();
					    }
					    return ASize > BSize;
					    });
				    break;
			}

			// Classes sorted but our child class indices will now be all messed up, now clear and traverse list and set child class indices with sorted array.
			const int ClassCount = CachedClassInfos.Num();
			for (int i = 0; i < ClassCount; ++i)
			{
				CachedClassInfos[i].ChildClassIndicies.Empty();
			}
			for (int i = 0; i < ClassCount; ++i)
			{
				UClass* SuperClass = CachedClassInfos[i].Class->GetSuperClass();

				// For each class, loop through again and check for our direct parent class, if found add our index as a child class index
				for (FCachedClassInfo& PotentialParentClassInfo : CachedClassInfos)
				{
					if (PotentialParentClassInfo.Class == SuperClass)
					{
						PotentialParentClassInfo.ChildClassIndicies.Add(i);
					}
				}
			}
        }

        void TryCacheActorHierarchy()
        {
            // Clear previous cached actor info
            ActorClassInfos.Empty();

            // Add a stub for root class AActor
            FCachedClassInfo& ActorCachedClassInfo = ActorClassInfos.AddDefaulted_GetRef();
            ActorCachedClassInfo.Class = AActor::StaticClass();

            // Grab actors from the associated world and cache them.
            for (TActorIterator<AActor> It(World.Get()); It; ++It)
            {
                AActor* Actor = *It;
                if (!Actor || !IsValid(Actor))
                {
                    continue;
                }

                UClass* ActorClass = Actor->GetClass();

                // See if we already have this class accounted for, else add a new entry
                FCachedClassInfo* CachedClassInfo = ActorClassInfos.FindByPredicate([ActorClass](const FCachedClassInfo& ClassInfo) { return (ClassInfo.Class.Get() == ActorClass); });
                if (CachedClassInfo)
                {
                    // Found the class info! Just add this actor
                    CachedClassInfo->Objects.Add(Actor);
                }
                else
                {
                    // New class not found, add a cached class info, then look for parent classes upwards until you hit some found class. 
                    FCachedClassInfo& NewClassInfo = ActorClassInfos.AddDefaulted_GetRef();
                    NewClassInfo.Class = ActorClass;
                    NewClassInfo.Objects.Add(Actor);
                    
                    UClass* NewClass = ActorClass;
                    int NewClassIndex = ActorClassInfos.Num() - 1;

                    bool FoundParentClass = false;
                    while (!FoundParentClass)
                    {
                        UClass* NewClassSuper = NewClass->GetSuperClass();

                        FCachedClassInfo* SuperClassInfo = ActorClassInfos.FindByPredicate([NewClassSuper](const FCachedClassInfo& ClassInfo) { return (ClassInfo.Class.Get() == NewClassSuper); });
                        if (SuperClassInfo)
                        {
                            // Found our super class! Add this new class as child 
                            SuperClassInfo->ChildClassIndicies.Add(NewClassIndex);
                            FoundParentClass = true;
                        }
                        else
                        {
                            // We didn't find our super class, so add an empty entry for our immediate super class,
                            //  link our index, and keep looking for our super class' super class.
                            FCachedClassInfo& NewSuperClassInfo = ActorClassInfos.AddDefaulted_GetRef();
                            NewSuperClassInfo.Class = NewClassSuper;
                            NewSuperClassInfo.ChildClassIndicies.Add(NewClassIndex);

                            NewClass = NewClassSuper;
                            NewClassIndex = ActorClassInfos.Num() - 1;
                        }
                    }
                }
               
            }

            SortAndBuildHierarchy(ActorClassInfos);
        }

		void TryCacheComponentHierarchy()
		{
			// Clear previous cached component info
			ComponentClassInfos.Empty();

			// Add a stub for root class AActorComp
			FCachedClassInfo& RootCachedClassInfo = ComponentClassInfos.AddDefaulted_GetRef();
            RootCachedClassInfo.Class = UActorComponent::StaticClass();

			// Grab actors from the associated world and cache them.
			//for (TActorIterator<AActor> It(World.Get()); It; ++It)
            for (TObjectIterator<UActorComponent> It(RF_ArchetypeObject | RF_ClassDefaultObject); It; ++It)
			{
				UActorComponent* ActorComp = *It;
				if (!ActorComp || !IsValid(ActorComp) || ActorComp->GetWorld() != World.Get())
				{
					continue;
				}

				UClass* ActorCompClass = ActorComp->GetClass();

				// See if we already have this class accounted for, else add a new entry
				FCachedClassInfo* CachedClassInfo = ComponentClassInfos.FindByPredicate([ActorCompClass](const FCachedClassInfo& ClassInfo) { return (ClassInfo.Class.Get() == ActorCompClass); });
				if (CachedClassInfo)
				{
					// Found the class info! Just add this actor
					CachedClassInfo->Objects.Add(ActorComp);
				}
				else
				{
					// New class not found, add a cached class info, then look for parent classes upwards until you hit some found class. 
					FCachedClassInfo& NewClassInfo = ComponentClassInfos.AddDefaulted_GetRef();
					NewClassInfo.Class = ActorCompClass;
					NewClassInfo.Objects.Add(ActorComp);

					UClass* NewClass = ActorCompClass;
					int NewClassIndex = ComponentClassInfos.Num() - 1;

					bool FoundParentClass = false;
					while (!FoundParentClass)
					{
						UClass* NewClassSuper = NewClass->GetSuperClass();

						FCachedClassInfo* SuperClassInfo = ComponentClassInfos.FindByPredicate([NewClassSuper](const FCachedClassInfo& ClassInfo) { return (ClassInfo.Class.Get() == NewClassSuper); });
						if (SuperClassInfo)
						{
							// Found our super class! Add this new class as child 
							SuperClassInfo->ChildClassIndicies.Add(NewClassIndex);
							FoundParentClass = true;
						}
						else
						{
							// We didn't find our super class, so add an empty entry for our immediate super class,
							//  link our index, and keep looking for our super class' super class.
							FCachedClassInfo& NewSuperClassInfo = ComponentClassInfos.AddDefaulted_GetRef();
							NewSuperClassInfo.Class = NewClassSuper;
							NewSuperClassInfo.ChildClassIndicies.Add(NewClassIndex);

							NewClass = NewClassSuper;
							NewClassIndex = ComponentClassInfos.Num() - 1;
						}
					}
				}

			}

			SortAndBuildHierarchy(ComponentClassInfos);
		}

        void DrawComponentsImGui(float DeltaTime)
        {
			// TODO: Cache based on timers and such as well. 
			TryCacheComponentHierarchy();

			if (ImGui::BeginTabItem(Ansi(*World->GetDebugDisplayName())))
			{
				ImGui::BeginChild(Ansi(*FString::Printf(TEXT("CompHeader##%s"), *World->GetDebugDisplayName())), ImVec2(0.0f, 80.0f), true);
				ImGui::Text("%s", Ansi(*World->GetDebugDisplayName()));

				ImGui::Separator();

				// layout config
				static const float ActorCountColWidth = 60.0f;

				ImGui::Columns(2);
				ImGui::SameLine((ImGui::GetColumnWidth() * 0.5f) - 50.0f);
				ImGui::Text("Class Info"); ImGui::NextColumn();
				ImGui::SameLine((ImGui::GetColumnWidth() * 0.5f) - 50.0f);
				ImGui::Text("Component Info"); ImGui::NextColumn();
				const float ClassInfoWidth = ImGui::GetColumnWidth(0);
				const float ActorInfoWidth = ImGui::GetColumnWidth(1);
				ImGui::Separator();
				ImGui::Columns(1);


				static const int Columns = 6;

				const float ActorInfoColWidth = ActorInfoWidth * 0.25f;
				float LabelColWidths[Columns] = {
					ClassInfoWidth - ActorCountColWidth,
					ActorCountColWidth,
					ActorInfoColWidth,
					ActorInfoColWidth,
					ActorInfoColWidth,
					ActorInfoColWidth
				};
				static auto SetColumnWidths = [LabelColWidths]() {
					for (int i = 0; i < 6; ++i)
					{
						ImGui::SetColumnWidth(i, LabelColWidths[i]);
					}
				};


				ImGui::Columns(Columns);
				ImGui::Text("Class Name"); ImGui::NextColumn();
				ImGui::Text("Comp\nCount"); ImGui::NextColumn();

				ImGui::Text("Owner"); ImGui::NextColumn();
				ImGui::Text("Component Active"); ImGui::NextColumn();
				ImGui::Text("Component Ticks"); ImGui::NextColumn();
				ImGui::Text("Component Replicates"); ImGui::NextColumn();

				SetColumnWidths();
				ImGui::Columns(1);

				ImGui::EndChild(); // Header


				ImGui::BeginChild(Ansi(*FString::Printf(TEXT("CompContents##%s"), *World->GetDebugDisplayName())), ImVec2(0, 0), true);
				ImGui::Columns(Columns);

				if (WorldSettings.ClassHierarchy)
				{
					// Draw with class hierarchy
					ImGuiActorCompUtils::FCachedClassInfo* ClassInfo = ComponentClassInfos.FindByPredicate([](const FCachedClassInfo& ClassInfo) {
						return (ClassInfo.Class == UActorComponent::StaticClass());
						});

					if (ClassInfo)
					{
						// Draw just the AActor class info and rely on it to draw all it's children.
						CachedClass_DrawImGui_Component(*ClassInfo, CompWindows, &ComponentClassInfos, true);
					}
				}
				else
				{
					// Draw as flat list
					for (ImGuiActorCompUtils::FCachedClassInfo& ClassInfo : ComponentClassInfos)
					{
						CachedClass_DrawImGui_Component(ClassInfo, CompWindows);
					}
				}
				SetColumnWidths();
				ImGui::Columns(1);
				ImGui::EndChild(); // Contents

				ImGui::EndTabItem();
			}
        }

        void DrawActorsImGui(float DeltaTime)
        {
            // TODO: Cache based on timers and such as well. 
            TryCacheActorHierarchy();

			if (ImGui::BeginTabItem(Ansi(*World->GetDebugDisplayName())))
			{

				ImGui::BeginChild(Ansi(*FString::Printf(TEXT("ActorHeader##%s"), *World->GetDebugDisplayName())), ImVec2(0, 110.0f), true);

				ImGui::Columns(2, 0, false);

				static ImGuiTextFilter ActorClassFilter;
				static ImGuiTextFilter ActorNameFilter;
				static bool ActorClassFilterEnabled = true;
				static bool ActorNameFilterEnabled = true;
				ImGui::Text("Class Filter"); ImGui::SameLine();
				ImGui::Checkbox("##ActorClassFilterEnabled", &ActorClassFilterEnabled); ImGui::SameLine();
				ImGui::PushID("##ActorClassFilter");
				ActorClassFilter.Draw();
				ImGui::PopID();

				ImGui::NextColumn();

				ImGui::Text("View Style:"); ImGui::SameLine();
				static int ViewStyleComboValue = WorldSettings.ClassHierarchy ? 0 : 1;
				ImGui::Combo("##ViewStyleCombo", &ViewStyleComboValue, "Hierarchical\0Flat List");
				WorldSettings.ClassHierarchy = (ViewStyleComboValue == 0);

				ImGui::NextColumn();

				ImGui::Text(" Name Filter"); ImGui::SameLine();
				ImGui::Checkbox("##ActorNameFilterEnabled", &ActorNameFilterEnabled); ImGui::SameLine();
				ImGui::PushID("##ActorNameFilter");
				ActorNameFilter.Draw();
				ImGui::PopID();

				ImGui::NextColumn();

				ImGui::Text(" Sort Type:"); ImGui::SameLine();
				static int SortTypeComboValue = (int)WorldSettings.ClassSortType;
				ImGui::Combo("##SortTypeCombo", &SortTypeComboValue, "Alphabetical\0Actor Count");
				WorldSettings.ClassSortType = (EClassSortType)SortTypeComboValue;

				ImGui::Separator();

                // layout config
                static const float ActorCountColWidth = 60.0f;

				ImGui::Columns(2);
                ImGui::SameLine((ImGui::GetColumnWidth() * 0.5f) - 50.0f);
				ImGui::Text("Class Info"); ImGui::NextColumn();
                ImGui::SameLine((ImGui::GetColumnWidth() * 0.5f) - 50.0f);
				ImGui::Text("Actor Info"); ImGui::NextColumn();
                const float ClassInfoWidth = ImGui::GetColumnWidth(0);
                const float ActorInfoWidth = ImGui::GetColumnWidth(1);
                ImGui::Separator();
				ImGui::Columns(1);

				static const int Columns = 6;

                const float ActorInfoColWidth = ActorInfoWidth * 0.25f;
                float LabelColWidths[Columns] = { 
                    ClassInfoWidth - ActorCountColWidth,
                    ActorCountColWidth,
                    ActorInfoColWidth,
                    ActorInfoColWidth,
                    ActorInfoColWidth,
                    ActorInfoColWidth
                };
                auto SetColumnWidths = [LabelColWidths]() {
                    for (int i = 0; i < 6; ++i)
                    {
                        ImGui::SetColumnWidth(i, LabelColWidths[i]);
                    }
                };

				ImGui::Columns(Columns);
				ImGui::Text("Class Name"); ImGui::NextColumn();
                ImGui::Text("Actor\nCount"); ImGui::NextColumn();

				ImGui::Text("Replicates"); ImGui::NextColumn();
				ImGui::Text("ActorTicks"); ImGui::NextColumn();
				ImGui::Text("Component Count"); ImGui::NextColumn();
				ImGui::Text("Ticking Comps"); ImGui::NextColumn();
				
                SetColumnWidths();
				ImGui::Columns(1);

				ImGui::EndChild(); // Header


				ImGui::BeginChild(Ansi(*FString::Printf(TEXT("ActorContents##%s"), *World->GetDebugDisplayName())), ImVec2(0, 0), true);
                ImGui::Columns(Columns);

				if (WorldSettings.ClassHierarchy)
				{
					// Draw with class hierarchy
					ImGuiActorCompUtils::FCachedClassInfo* ClassInfo = ActorClassInfos.FindByPredicate([](const FCachedClassInfo& ClassInfo) {
						return (ClassInfo.Class == AActor::StaticClass());
					});

					if (ClassInfo)
					{
						// Draw just the AActor class info and rely on it to draw all it's children.
                        CachedClass_DrawImGui_Actor(*ClassInfo, ActorWindows, ActorClassFilter, &ActorClassInfos, true, true);
					}
				}
				else
				{
					// Draw as flat list
					for (ImGuiActorCompUtils::FCachedClassInfo& ClassInfo : ActorClassInfos)
					{
                        CachedClass_DrawImGui_Actor(ClassInfo, ActorWindows, ActorClassFilter, nullptr, true);
					}
				}
                SetColumnWidths();
                ImGui::Columns(1);
				ImGui::EndChild(); // Contents

				ImGui::EndTabItem();
			}
        }

        // The World associated with this cache
        TWeakObjectPtr<UWorld>					World;
        // Sorted array of cached class info
        TArray<FCachedClassInfo>				ActorClassInfos;
        // Sorted array of cached components. 
        TArray<FCachedClassInfo>				ComponentClassInfos;

        // Array of weak object pointers to actors that should have their own windows
        TArray<TWeakObjectPtr<AActor>>			ActorWindows;

		TArray<TWeakObjectPtr<UActorComponent>> CompWindows;

        // Will this World display
        bool									Display = true;

        FWorldSettings							WorldSettings;
    };

    // cached data for all worlds. probably only one fo these!
    struct FCachedWorldsInfo
    {
        void TryCacheWorlds()
        {
            // Remove any WorldInfos that may now have an invalid World.
            WorldInfos.RemoveAll([](const FCachedWorldInfo& WorldInfo) {
                return !IsValid(WorldInfo.World.Get());
            });
            
            // What types of worlds to display: 
            static const auto WorldShouldDisplay = [](UWorld* World) 
            {
                return (IsValid(World) && !World->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject) && World->bIsWorldInitialized 
                    && (World->WorldType != EWorldType::Editor) && (World->WorldType != EWorldType::EditorPreview));
            };

            for (TObjectIterator<UWorld> It; It; ++It)
            {
                UWorld* World = *It;
                if (!WorldShouldDisplay(World))
                {
                    continue;
                }

                // if this is a new world, add a new cached world actor object.
                if (!WorldInfos.ContainsByPredicate([World](const FCachedWorldInfo& WorldInfo) { return (WorldInfo.World.Get() == World); }))
                {
                    FCachedWorldInfo& WorldInfo = WorldInfos.AddDefaulted_GetRef();
                    WorldInfo.World = World;
                }
            }
        }

        TArray<FCachedWorldInfo>   WorldInfos;
    };
    

}   // namespace ImGuiActorCompUtils

// Cached data needed only in this file.
static ImGuiActorCompUtils::FCachedWorldsInfo   CachedWorlds;

FImGuiActorComponentDebugger::FImGuiActorComponentDebugger()
{
	ToolName = TEXT("Actor/Component Debugger");
    WindowFlags = ImGuiWindowFlags_MenuBar;
}

void FImGuiActorComponentDebugger::ImGuiUpdate(float DeltaTime)
{
    static float                                    TimeSinceLastRefresh = 0.0f;
	static ImGuiActorCompUtils::FSettings           Settings;

	CachedWorlds.TryCacheWorlds();

    if (ImGui::BeginMenuBar())
    {
        if (ImGui::BeginMenu("Settings"))
        {
            ImGui::SliderFloat("Refresh Rate (<= 0 is every frame)", &Settings.RefreshTimer, -1.0f, 30.0f);
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Worlds"))
        {
            static auto ToggleWorlds = [](ENetMode WorldMode, bool Enable, bool TurnOffOtherModes = false) {
                for (ImGuiActorCompUtils::FCachedWorldInfo& WorldInfo : CachedWorlds.WorldInfos)
                {
                    if (WorldInfo.World->GetNetMode() == WorldMode)
                    {
                        WorldInfo.Display = Enable;
                    }
                    else if (TurnOffOtherModes)
                    {
                        WorldInfo.Display = false;
                    }
                }
            };

            static auto DrawWorldNetModeSelector = [](const char* ButtonName, ENetMode WorldMode) {
                // Only draw options for world modes that have worlds in play
                bool HasWorldOfMode = false;
                for (const ImGuiActorCompUtils::FCachedWorldInfo& WorldInfo : CachedWorlds.WorldInfos)
                {
                    if (WorldInfo.World->GetNetMode() == WorldMode)
                    {
                        HasWorldOfMode = true;
                        break;
                    }
                }
                if (HasWorldOfMode)
                {
                    const FString ButtonNameString(ButtonName);
                    ImGui::Text("%s", ButtonName); ImGui::SameLine();
				    if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Enable##%s"), *ButtonNameString))))
				    {
					    ToggleWorlds(WorldMode, /*enable*/ true);
				    }
				    ImGui::SameLine();
                    if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Disable##%s"), *ButtonNameString))))
				    {
					    ToggleWorlds(WorldMode, /*enable*/ false);
				    }
				    ImGui::SameLine();
                    if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Exclusive##%s"), *ButtonNameString))))
				    {
					    ToggleWorlds(WorldMode, /*enable*/ true, /*TurnOffOtherModes*/ true);
				    }
                }
            };

            DrawWorldNetModeSelector("Client        ", ENetMode::NM_Client);
            DrawWorldNetModeSelector("Ded Server    ", ENetMode::NM_DedicatedServer);
            DrawWorldNetModeSelector("Listen Server ", ENetMode::NM_ListenServer);
            DrawWorldNetModeSelector("Standalone    ", ENetMode::NM_Standalone);

			ImGui::BeginChild("WorldSelector", ImVec2(400, 240), true);
			for (ImGuiActorCompUtils::FCachedWorldInfo& WorldInfo : CachedWorlds.WorldInfos)
			{
				ImGui::Checkbox(Ansi(*WorldInfo.World->GetDebugDisplayName()), &WorldInfo.Display);
			}
			ImGui::EndChild();  // World Selector
            ImGui::EndMenu();
        }

        if (Settings.RefreshTimer <= 0.0f)
        {
            ImGui::SameLine(ImGui::GetWindowWidth() - 180.0f);
            ImGui::Text("Refresh Every Frame");
        }
        else
        {
            ImGui::SameLine(ImGui::GetWindowWidth() - 250.0f);
            ImGui::ProgressBar((TimeSinceLastRefresh / Settings.RefreshTimer), ImVec2(230.0f, 0.0f), Ansi(*FString::Printf(TEXT("Refresh Timer %.01f/%.01f"), TimeSinceLastRefresh, Settings.RefreshTimer)));
        }

        ImGui::EndMenuBar();
    }
	static ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
    if (ImGui::BeginTabBar("ActorComponents", tab_bar_flags))
    {
		if (ImGui::BeginTabItem("Actors"))
		{
			if (ImGui::BeginTabBar("ActorWorldTabs", tab_bar_flags))
			{
				for (ImGuiActorCompUtils::FCachedWorldInfo& WorldInfo : CachedWorlds.WorldInfos)
				{
					if (WorldInfo.Display)
					{
						WorldInfo.DrawActorsImGui(DeltaTime);
					}
				}

				ImGui::EndTabBar(); // WorldTabs
			}
			ImGui::EndTabItem();
		}
		if (ImGui::BeginTabItem("Components"))
		{
			if (ImGui::BeginTabBar("CompWorldTabs", tab_bar_flags))
			{
				for (ImGuiActorCompUtils::FCachedWorldInfo& WorldInfo : CachedWorlds.WorldInfos)
				{
					if (WorldInfo.Display)
					{
                        WorldInfo.DrawComponentsImGui(DeltaTime);
					}
				}

				ImGui::EndTabBar(); // WorldTabs
			}
			ImGui::EndTabItem();
		}

        ImGui::EndTabBar();
    }
}

void FImGuiActorComponentDebugger::UpdateTool(float DeltaTime)
{
    FImGuiToolWindow::UpdateTool(DeltaTime);

    for (ImGuiActorCompUtils::FCachedWorldInfo& WorldInfo : CachedWorlds.WorldInfos)
    {
        if (WorldInfo.Display)
        {
            // Iterate backwards through the actor windows in case one closes itself.
            const int ActorWindowsCount = WorldInfo.ActorWindows.Num();
            for (int i = ActorWindowsCount - 1; i >= 0; --i)
            {
                TWeakObjectPtr<AActor>& ActorForWindow = WorldInfo.ActorWindows[i];
                if (ActorForWindow.IsValid())
                {
                    bool WindowOpen = true;
                    if (ImGui::Begin(Ansi(*FString::Printf(TEXT("actor %s - world %s"), *ActorForWindow->GetName(), *ActorForWindow->GetWorld()->GetName())), &WindowOpen))
                    {
                        ImGuiActorCompUtils::DrawImGuiActorWindow(ActorForWindow.Get());
                        ImGui::End();
                    }

                    if (!WindowOpen)
                    {
                        WorldInfo.ActorWindows.RemoveAt(i);
                    }
                }
            }

			// Iterate backwards through the actor windows in case one closes itself.
			const int CompWindowsCount = WorldInfo.CompWindows.Num();
			for (int i = CompWindowsCount - 1; i >= 0; --i)
			{
				TWeakObjectPtr<UActorComponent>& CompForWindow = WorldInfo.CompWindows[i];
				if (CompForWindow.IsValid())
				{
					bool WindowOpen = true;
					if (ImGui::Begin(Ansi(*FString::Printf(TEXT("comp %s - world %s"), *CompForWindow->GetName(), *CompForWindow->GetWorld()->GetName())), &WindowOpen))
					{
						ImGuiActorCompUtils::DrawImGuiComponentWindow(CompForWindow.Get());
						ImGui::End();
					}

					if (!WindowOpen)
					{
						WorldInfo.CompWindows.RemoveAt(i);
					}
				}
			}
        }
    }
}

```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiActorComponentDebugger.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include "CoreMinimal.h"
#include "ImGuiToolWindow.h"
#include "UObject/WeakObjectPtr.h"

class UClass;
class UObject;

namespace ImGuiActorCompUtils
{
	// Cached info for a given UClass such as object instances and child class indicies.
	struct FCachedClassInfo
	{
		// A class and array of objects of that class.
		TWeakObjectPtr<UClass>          Class;
		TArray<TWeakObjectPtr<UObject>> Objects;

		// Array of indices in parent container array that point at direct child classes
		TArray<int> ChildClassIndicies;
		// A cached count of actors in this class and child classes down the hierarchy. Can be invalidated by setting to -1
		int CachedActorHierarchyCount = -1;

		// Will cache actor hierarchy count on this class cache ( and any children as a by product ) and return the result.
		int CacheActorHierarchyCount(TArray<FCachedClassInfo>& ParentContainer);
	};
}   // namespace ImGuiActorCompUtils

class IMGUITOOLS_API FImGuiActorComponentDebugger : public FImGuiToolWindow
{
public:
	FImGuiActorComponentDebugger();
	virtual ~FImGuiActorComponentDebugger() = default;

	// FImGuiToolWindow Interface
	virtual void ImGuiUpdate(float DeltaTime) override;
	virtual void UpdateTool(float DeltaTime) override;
	// FImGuiToolWindow Interface
};
```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiCDOExplorer.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiCDOExplorer.h"

#include <imgui.h>

#include "UObject/Class.h"
#include "GameFramework/Actor.h"
#include "Components/PrimitiveComponent.h"
#include "Utils/ImGuiUtils.h"
#include "Widgets/ClassSelectorWidget.h"

namespace ImGuiCDOExUtil
{
    enum EDrawClassType
    {
        Native,
        BP,
        NativeAndBP,
    };

    namespace EDrawColumnType
    {
        enum Type
        {
            NativeClass = 0,
            ActorTicks,
            ActorReplicates,
            ActorComponentsCount,
            SceneComponentsCount,
            PrimitiveComponentCount,
            GenerateOverlapsCompsCount,
            TickingCompsCount,
        
            COUNT
        };

		static bool DefaultVisibility[Type::COUNT] =
		{
			/*NativeClass */		        true,
            /*ActorTicks*/                  true,
            /*ActorReplicates*/             true,
            /*ActorComponentsCount*/        true,
            /*SceneComponentsCount*/        true,
            /*PrimitiveComponentCount*/     true,
            /*GenerateOverlapsCompsCount*/   true,
            /*TickingCompsCount*/           true,
		};
    };

    struct FColumnSettings
    {
        EDrawColumnType::Type SortColumnType = EDrawColumnType::SceneComponentsCount;
        ImGuiTools::Utils::FShowCols ShowCols = ImGuiTools::Utils::FShowCols(EDrawColumnType::COUNT, &EDrawColumnType::DefaultVisibility[0]);
    };

    static EDrawClassType sDrawClassType = EDrawClassType::BP;
    static FColumnSettings sColumnSettings;

    // Forward declaration
    static bool ShouldDrawCDO(ImGuiTools::FHierarchicalClassInfo& ClassInfo);
    static bool ShouldDrawAnyCDOChildren(ImGuiTools::FHierarchicalClassInfo& ClassInfo)
    {
        // Only returns true if one or more of our children should be drawn (ignoring if the provided class info should or not)
		for (ImGuiTools::FHierarchicalClassInfo& LoadedChildInfo : ClassInfo.mLoadedChildren)
		{
			if (ShouldDrawCDO(LoadedChildInfo))
			{
				return true;
			}
		}

        return false;
    }

    static bool ShouldDrawCDO(ImGuiTools::FHierarchicalClassInfo& ClassInfo)
    {
        // First, see if we are just drawing all
        if (ImGuiCDOExUtil::sDrawClassType == EDrawClassType::NativeAndBP)
        {
            return true;
        }
        
        // Next, check to see if this class matches the Native/BP type
		UClass* LoadedClass = ClassInfo.mClass.Get();
		const bool IsNative = LoadedClass && LoadedClass->IsNative();
        if ((IsNative && (ImGuiCDOExUtil::sDrawClassType == EDrawClassType::Native)) ||
            (!IsNative && (ImGuiCDOExUtil::sDrawClassType == EDrawClassType::BP)))
        {
            return true;
        }

        // Finally, we also need to draw ourselves if any of our children are of that type.
        return ShouldDrawAnyCDOChildren(ClassInfo);
    }

    static void DrawCDO(ImGuiTools::FHierarchicalClassInfo& ClassInfo)
    {
        // See if we should draw ourselves first
        if (!ShouldDrawCDO(ClassInfo))
        {
            return;
        }

		bool TreeOpen = false;
        FString ClassLabel = ClassInfo.mClass->GetFName().ToString();
        //const bool DrawAsTree = (ClassInfo.mLoadedChildren.Num() == 0) && (ClassInfo.mUnloadedChildren.Num() == 0);
        const bool DrawAsTree = ShouldDrawAnyCDOChildren(ClassInfo);
		if (DrawAsTree)
		{
			TreeOpen = ImGui::TreeNode(Ansi(*ClassLabel)); ImGui::NextColumn();
		}
		else
		{
			ImGui::Text("   %s", Ansi(*ClassLabel)); ImGui::NextColumn();
		}
        if (ClassInfo.mCachedAllUnloadedDecendants > 0)
        {
            ImGui::TextColored(ImGuiTools::Colors::Red, "!! %d Unloaded descendants found when they really shouldn't be", ClassInfo.mCachedAllUnloadedDecendants);
        }

        if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::NativeClass)) { ImGui::Text(ClassInfo.mClass->IsNative() ? "Native" : "BP"); ImGui::NextColumn(); }

        if (AActor* CDOAct = Cast<AActor>(ClassInfo.mClass->GetDefaultObject()))
        {
            TArray<UActorComponent*> ActComps; CDOAct->GetComponents(UActorComponent::StaticClass(), ActComps);
            TArray<UActorComponent*> SceneComps; CDOAct->GetComponents(USceneComponent::StaticClass(), SceneComps);
            TArray<UActorComponent*> PrimitiveComps; CDOAct->GetComponents(UPrimitiveComponent::StaticClass(), PrimitiveComps);
		    if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::ActorTicks)) { ImGui::Text(CDOAct->IsActorTickEnabled() ? "ticking" : "not ticking"); ImGui::NextColumn(); }
		    if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::ActorReplicates)) { ImGui::Text(CDOAct->GetIsReplicated() ? "replicated" : "not replicated"); ImGui::NextColumn(); }
		    if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::ActorComponentsCount)) { ImGui::Text("%02d", ActComps.Num()); ImGui::NextColumn(); }
		    if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::SceneComponentsCount)) { ImGui::Text("%02d", SceneComps.Num()); ImGui::NextColumn(); }
            if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::PrimitiveComponentCount)) { ImGui::Text("%02d", PrimitiveComps.Num()); ImGui::NextColumn(); }
		    if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::GenerateOverlapsCompsCount)) { 
                int PrimsGeneratingOverlaps = 0;
                for (UActorComponent* ActComp : PrimitiveComps)
                {
                    UPrimitiveComponent* PrimComp = Cast<UPrimitiveComponent>(ActComp);
					if (PrimComp && PrimComp->GetGenerateOverlapEvents())
						++PrimsGeneratingOverlaps;
                }
                ImGui::Text("%02d", PrimsGeneratingOverlaps); ImGui::NextColumn(); 
            }
		    if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::TickingCompsCount)) { 
                int TickingComps = 0;
                for (UActorComponent* ActComp : ActComps)
                {
                    if (ActComp->IsComponentTickEnabled())
                        ++TickingComps;
                }
                ImGui::Text("%02d", TickingComps); ImGui::NextColumn(); 
            }
        }
        else
        {
			if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::ActorTicks)) { ImGui::Text("*not_actor*"); ImGui::NextColumn(); }
			if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::ActorReplicates)) { ImGui::Text("*not_actor*"); ImGui::NextColumn(); }
			if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::ActorComponentsCount)) { ImGui::Text("*not_actor*"); ImGui::NextColumn(); }
			if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::SceneComponentsCount)) { ImGui::Text("*not_actor*"); ImGui::NextColumn(); }
            if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::PrimitiveComponentCount)) { ImGui::Text("*not_actor*"); ImGui::NextColumn(); }
			if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::GenerateOverlapsCompsCount)) { ImGui::Text("*not_actor*"); ImGui::NextColumn(); }
			if (sColumnSettings.ShowCols.GetShowCol(EDrawColumnType::TickingCompsCount)) { ImGui::Text("*not_actor*"); ImGui::NextColumn(); }
        }

        if (TreeOpen)
        {
			for (ImGuiTools::FHierarchicalClassInfo& LoadedChildInfo : ClassInfo.mLoadedChildren)
			{
                DrawCDO(LoadedChildInfo);
			}
            ImGui::TreePop();
        }
    }
}   //  namespace FImGuiCDOExUtil

FImGuiCDOExplorer::FImGuiCDOExplorer()
{
	ToolName = "CDO Explorer";
}

void FImGuiCDOExplorer::ImGuiUpdate(float DeltaTime)
{
    static ImGuiTools::FClassSelector CDOExplorerClassSelector(UObject::StaticClass());
    if (ImGui::CollapsingHeader("Parent Class to Explore", ImGuiTreeNodeFlags_DefaultOpen))
    {
        const float ClassExplorerHeight = FMath::Max(250.0f, ImGui::GetWindowHeight() * 0.5f);
        ImGui::BeginChild("CDOExplorerClassSelection", ImVec2(0, ClassExplorerHeight), true);
        CDOExplorerClassSelector.Draw("CDOExplorerClassSel", ImVec2(0, ClassExplorerHeight - 48.0f));
    
        UClass* SelectedClass = CDOExplorerClassSelector.GetSelectedClass();
        if (SelectedClass)
        {
            if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Load and View X BP CDOs from class: %s"), *SelectedClass->GetName()))))
            {
                mCDOExplorerClasses.ResetToRootClass(SelectedClass);
                mCDOExplorerClasses.mRootClassInfo.LoadChildren();
            }
        }
        else
        {
            ImGui::TextColored(ImGuiTools::Colors::Orange, "Select a Class type above to explore.");
        }
        ImGui::EndChild();  // "CDOExplorerClassSelection"
    }

    if (ImGui::CollapsingHeader("CDO Explorer Settings", ImGuiTreeNodeFlags_DefaultOpen))
    {
        static float TempHeight = 124.0f;
        ImGui::BeginChild("CDOExplorerSettings", ImVec2(0, TempHeight), true);
        ImGui::Columns(2);

        if (ImGui::RadioButton("##Native", ImGuiCDOExUtil::sDrawClassType == ImGuiCDOExUtil::EDrawClassType::Native)) { ImGuiCDOExUtil::sDrawClassType = ImGuiCDOExUtil::EDrawClassType::Native; } ImGui::SameLine();
        ImGui::Text("Native"); ImGui::SameLine();
		if (ImGui::RadioButton("##BP", ImGuiCDOExUtil::sDrawClassType == ImGuiCDOExUtil::EDrawClassType::BP)) { ImGuiCDOExUtil::sDrawClassType = ImGuiCDOExUtil::EDrawClassType::BP; } ImGui::SameLine();
		ImGui::Text("BP"); ImGui::SameLine();
		if (ImGui::RadioButton("##Native/BP", ImGuiCDOExUtil::sDrawClassType == ImGuiCDOExUtil::EDrawClassType::NativeAndBP)) { ImGuiCDOExUtil::sDrawClassType = ImGuiCDOExUtil::EDrawClassType::NativeAndBP; } ImGui::SameLine();
		ImGui::Text("Native/BP");

        ImGui::NextColumn();

        static const float RadWidth = 54.0f;
        ImGui::Text("Include/Sort:");
		ImGui::BeginChild("IncSortCDOExp", ImVec2(390.0f, 0.0f));
		ImGui::Columns(2);
		ImGui::Checkbox("##NativeCh", &ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::NativeClass)); ImGui::SameLine();
		if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::NativeClass))
		{ if (ImGui::RadioButton("##NativeRB", ImGuiCDOExUtil::sColumnSettings.SortColumnType == ImGuiCDOExUtil::EDrawColumnType::NativeClass)) { ImGuiCDOExUtil::sColumnSettings.SortColumnType = ImGuiCDOExUtil::EDrawColumnType::NativeClass; } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("Native"); ImGui::NextColumn();

		ImGui::Checkbox("##ActorTicksCh", &ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::ActorTicks)); ImGui::SameLine();
		if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::ActorTicks))
		{ if (ImGui::RadioButton("##ActorTicksRB", ImGuiCDOExUtil::sColumnSettings.SortColumnType == ImGuiCDOExUtil::EDrawColumnType::ActorTicks)) { ImGuiCDOExUtil::sColumnSettings.SortColumnType = ImGuiCDOExUtil::EDrawColumnType::ActorTicks; } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("Actor Ticks"); ImGui::NextColumn();

		ImGui::Checkbox("##ActorReplicatesCh", &ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::ActorReplicates)); ImGui::SameLine();
		if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::ActorReplicates))
		{ if (ImGui::RadioButton("##ActorReplicatesRB", ImGuiCDOExUtil::sColumnSettings.SortColumnType == ImGuiCDOExUtil::EDrawColumnType::ActorReplicates)) { ImGuiCDOExUtil::sColumnSettings.SortColumnType = ImGuiCDOExUtil::EDrawColumnType::ActorReplicates; } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("Replicates"); ImGui::NextColumn();

		ImGui::Checkbox("##ActorCompsCh", &ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::ActorComponentsCount)); ImGui::SameLine();
		if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::ActorComponentsCount))
		{ if (ImGui::RadioButton("##ActorCompsCRB", ImGuiCDOExUtil::sColumnSettings.SortColumnType == ImGuiCDOExUtil::EDrawColumnType::ActorComponentsCount)) { ImGuiCDOExUtil::sColumnSettings.SortColumnType = ImGuiCDOExUtil::EDrawColumnType::ActorReplicates; } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("Actor Comps"); ImGui::NextColumn();

		ImGui::Checkbox("##SceneCompsCh", &ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::SceneComponentsCount)); ImGui::SameLine();
		if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::SceneComponentsCount))
		{ if (ImGui::RadioButton("##SceneCompsRB", ImGuiCDOExUtil::sColumnSettings.SortColumnType == ImGuiCDOExUtil::EDrawColumnType::SceneComponentsCount)) { ImGuiCDOExUtil::sColumnSettings.SortColumnType = ImGuiCDOExUtil::EDrawColumnType::ActorReplicates; } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("Scene Comps"); ImGui::NextColumn();

		ImGui::Checkbox("##PrimCompsCh", &ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::PrimitiveComponentCount)); ImGui::SameLine();
		if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::PrimitiveComponentCount))
		{ if (ImGui::RadioButton("##PrimCompsRB", ImGuiCDOExUtil::sColumnSettings.SortColumnType == ImGuiCDOExUtil::EDrawColumnType::PrimitiveComponentCount)) { ImGuiCDOExUtil::sColumnSettings.SortColumnType = ImGuiCDOExUtil::EDrawColumnType::ActorReplicates; } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("Primitive Comps"); ImGui::NextColumn();

		ImGui::Checkbox("##OverlapCompsCh", &ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::GenerateOverlapsCompsCount)); ImGui::SameLine();
		if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::GenerateOverlapsCompsCount))
		{ if (ImGui::RadioButton("##OverlapCompsRB", ImGuiCDOExUtil::sColumnSettings.SortColumnType == ImGuiCDOExUtil::EDrawColumnType::GenerateOverlapsCompsCount)) { ImGuiCDOExUtil::sColumnSettings.SortColumnType = ImGuiCDOExUtil::EDrawColumnType::ActorReplicates; } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("Overlap Comps"); ImGui::NextColumn();

		ImGui::Checkbox("##TickingCompsCh", &ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::TickingCompsCount)); ImGui::SameLine();
		if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::TickingCompsCount))
		{ if (ImGui::RadioButton("##TickingCompsRB", ImGuiCDOExUtil::sColumnSettings.SortColumnType == ImGuiCDOExUtil::EDrawColumnType::TickingCompsCount)) { ImGuiCDOExUtil::sColumnSettings.SortColumnType = ImGuiCDOExUtil::EDrawColumnType::ActorReplicates; } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("Ticking Comps"); ImGui::NextColumn();
        ImGui::Columns(1);
        ImGui::EndChild();  // "IncSortCDOExp"
        ImGui::Columns(1);
        ImGui::EndChild();  // "CDOExplorerSettings"
    }
	
    const int VisibleColCount = ImGuiCDOExUtil::sColumnSettings.ShowCols.CacheShowColCount() + 1;

    ImGui::BeginChild("CDOExplorerHeader", ImVec2(0, 36), true);
    ImGui::Columns(VisibleColCount + 1);
	ImGui::Text("Class"); ImGui::NextColumn();
	if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::NativeClass)) {                ImGui::Text("Native Class"); ImGui::NextColumn(); }
    if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::ActorTicks)) {                 ImGui::Text("Ticks"); ImGui::NextColumn(); }
    if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::ActorReplicates)) {            ImGui::Text("Replicates"); ImGui::NextColumn(); }
    if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::ActorComponentsCount)) {       ImGui::Text("Actor Comps"); ImGui::NextColumn(); }
    if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::SceneComponentsCount)) {       ImGui::Text("Scene Comps"); ImGui::NextColumn(); }
    if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::PrimitiveComponentCount)) { ImGui::Text("Primitive Comps"); ImGui::NextColumn(); }
    if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::GenerateOverlapsCompsCount)) {  ImGui::Text("Generate Overlaps"); ImGui::NextColumn(); }
    if (ImGuiCDOExUtil::sColumnSettings.ShowCols.GetShowCol(ImGuiCDOExUtil::EDrawColumnType::TickingCompsCount)) {          ImGui::Text("Ticking Comps"); ImGui::NextColumn(); }

    ImGui::Columns(1);
    ImGui::EndChild();  // "CDOExplorerHeader"
    
    ImGui::BeginChild("CDOExplorerBody", ImVec2(0, 0), true);


    if (mCDOExplorerClasses.mRootClassInfo.mClass.IsValid())
    {
    	ImGui::Columns(VisibleColCount, "CDODataCols");
        
        ImGuiCDOExUtil::DrawCDO(mCDOExplorerClasses.mRootClassInfo);
        
        ImGui::Columns(1);
    }
    else
    {
        ImGui::TextColored(ImGuiTools::Colors::Orange, "Select a parent class above to view CDOs");
    }

    ImGui::EndChild();  // "CDOExplorerBody"
}
```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiCDOExplorer.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include "ImGuiToolWindow.h"
#include "Utils/ClassHierarchyInfo.h"

class IMGUITOOLS_API FImGuiCDOExplorer : public FImGuiToolWindow
{
public:
	FImGuiCDOExplorer();
	virtual ~FImGuiCDOExplorer() = default;

	// FImGuiToolWindow Interface
	virtual void ImGuiUpdate(float DeltaTime) override;
	virtual bool IsEditorToolAllowed() override { return true;}
	// FImGuiToolWindow Interface

	void SelectClassLoadSubclasses(UClass* ParentClass, bool LoadAll);

private:
	ImGuiTools::FHierarchicalRootClassInfo mCDOExplorerClasses;
};
```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiFileLoadDebugger.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiFileLoadDebugger.h"

#include <imgui.h>
#include <ImGuiTools.h>
#include <ImGuiToolsManager.h>
#include <Utils/ImGuiUtils.h>

// Log Category
DEFINE_LOG_CATEGORY_STATIC(LogImGuiDebugLoad, Warning, All);

// CVARs
FAutoConsoleCommand ToggleFileLoadRecordCMD(TEXT("imgui.tools.file_load.toggle_record"),
											TEXT("Toggle the recording state of the ImGui File Load Debugger"),
											FConsoleCommandWithArgsDelegate::CreateStatic(&FImGuiFileLoadDebugger::ToggleRecordCommand));

namespace ImGuiFileLoadDebuggerConsts
{
	static const FString ToolName = "LoadDebugger";
}	// namespace ImGuiFileLoadDebuggerConsts

namespace ImGuiFileLoadUtils
{
	void DrawLoadList(ImVec4 ColorVec, const TArray<FString>& LoadList)
	{
		for (int i = LoadList.Num() - 1; i >= 0; --i)
		{
			ImGui::TextColored(ColorVec, "%05d - %s", i + 1, Ansi(*LoadList[i]));

		}
	}
}	// namespace ImGuiFileLoadUtils

void FImGuiFileLoadDebugger::ToggleRecordCommand(const TArray<FString>& Args)
{
	FImGuiToolsModule& ImGuiToolsModule = FModuleManager::GetModuleChecked<FImGuiToolsModule>("ImGuiTools");
	if (!ImGuiToolsModule.GetToolsManager().IsValid())
	{
		UE_LOG(LogTemp, Log, TEXT("CVAR'imgui.tools.file_load.toggle_record' was unable to find the ImGuiTools Module."));
		return;
	}

	TSharedPtr<FImGuiFileLoadDebugger> FileLoadDebugger = StaticCastSharedPtr<FImGuiFileLoadDebugger>(ImGuiToolsModule.GetToolsManager()->GetToolWindow(ImGuiFileLoadDebuggerConsts::ToolName));
	if (!FileLoadDebugger.IsValid())
	{
		UE_LOG(LogTemp, Log, TEXT("CVAR'imgui.tools.file_load.toggle_record' was unable to find a tool with name: '%s'"), *ImGuiFileLoadDebuggerConsts::ToolName);
		return;
	}

	FileLoadDebugger->ToggleRecord();
}

FImGuiFileLoadDebugger::FImGuiFileLoadDebugger()
{
	ToolName = ImGuiFileLoadDebuggerConsts::ToolName;
}

void FImGuiFileLoadDebugger::ImGuiUpdate(float DeltaTime)
{
	bool bRecordingLoadsPreCheckbox = bRecordingLoads;
	ImGui::Checkbox("Recording File Loads", &bRecordingLoadsPreCheckbox);
	if (bRecordingLoadsPreCheckbox != bRecordingLoads)
	{
		// Checkbox toggled
		ToggleRecord();
	}
	ImGui::SameLine();
	if (ImGui::SmallButton("Clear All"))
	{
		SyncLoadFiles.Empty();
		AsyncLoadFiles.Empty();
	}
	ImGui::Checkbox("Spew File Loads to Log", &bSpewToLog);

	if (ImGui::CollapsingHeader("Sync Loads", ImGuiTreeNodeFlags_DefaultOpen))
	{
		ImGui::BeginChild("SyncLoads", ImVec2(0, 250.0f), true);
		ImGuiFileLoadUtils::DrawLoadList(ImVec4(1.0f, 0.4f, 0.0f, 1.0f), SyncLoadFiles);
		ImGui::EndChild(); //	"SyncLoads"
	}

	if (ImGui::CollapsingHeader("Async Loads", ImGuiTreeNodeFlags_DefaultOpen))
	{
		ImGui::BeginChild("AsyncLoads", ImVec2(0, 250.0f), true);
		ImGuiFileLoadUtils::DrawLoadList(ImVec4(0.0f, 0.4f, 1.0f, 1.0f), AsyncLoadFiles);
		ImGui::EndChild(); //	"AsyncLoads"
	}
}

void FImGuiFileLoadDebugger::ToggleRecord()
{
	bRecordingLoads = !bRecordingLoads;

	if (bRecordingLoads)
	{
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
		AsyncLoadDelegateHandle = FCoreDelegates::GetOnAsyncLoadPackage().AddRaw(this, &FImGuiFileLoadDebugger::OnAsyncLoadPackage);
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
        AsyncLoadDelegateHandle = FCoreDelegates::OnAsyncLoadPackage.AddRaw(this, &FImGuiFileLoadDebugger::OnAsyncLoadPackage);
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
		SyncLoadDelegateHandle = FCoreDelegates::OnSyncLoadPackage.AddRaw(this, &FImGuiFileLoadDebugger::OnSyncLoadPackage);
	}
	else
	{
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
        FCoreDelegates::GetOnAsyncLoadPackage().Remove(AsyncLoadDelegateHandle);
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
        FCoreDelegates::OnAsyncLoadPackage.Remove(AsyncLoadDelegateHandle);
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
		AsyncLoadDelegateHandle.Reset();

		FCoreDelegates::OnSyncLoadPackage.Remove(SyncLoadDelegateHandle);
		SyncLoadDelegateHandle.Reset();
	}
	UE_LOG(LogImGuiDebugLoad, Warning, TEXT("FImGuiFileLoadDebugger::ToggleRecord. New Recording state: %s"), bRecordingLoads ? TEXT("enabled") : TEXT("disabled"));
}

#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
void FImGuiFileLoadDebugger::OnAsyncLoadPackage(const FStringView PackageNameStrView)
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
void FImGuiFileLoadDebugger::OnAsyncLoadPackage(const FString& PackageName)
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
{
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
    const FString PackageName(PackageNameStrView);
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4

	// NOTE: sync loads will kick off an async request with this callback, then flush it within the callstack. So true Async loads are loads that
	//	come through this path, but didn't already come through via the SyncLoadPackage callback.
	if (!SyncLoadFiles.Contains(PackageName))
	{
		if (bSpewToLog)
		{
			UE_LOG(LogImGuiDebugLoad, Log, TEXT("FImGuiFileLoadDebugger::OnAsyncLoadPackage - Async Loading Package: '%s'"), *PackageName);
		}

		AsyncLoadFiles.Add(PackageName);
	}
}

void FImGuiFileLoadDebugger::OnSyncLoadPackage(const FString& PackageName)
{
	if (bSpewToLog)
	{
		UE_LOG(LogImGuiDebugLoad, Error, TEXT("FImGuiFileLoadDebugger::OnSyncLoadPackage - Sync Loading Package: '%s'"), *PackageName);
	}

	SyncLoadFiles.Add(PackageName);
}

```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiFileLoadDebugger.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include "ImGuiToolWindow.h"

#include "Misc/CoreDelegates.h"
#include "Runtime/Launch/Resources/Version.h"

class IMGUITOOLS_API FImGuiFileLoadDebugger : public FImGuiToolWindow
{
public:
	FImGuiFileLoadDebugger();
	virtual ~FImGuiFileLoadDebugger() = default;

	// FImGuiToolWindow Interface
	virtual void ImGuiUpdate(float DeltaTime) override;
	// FImGuiToolWindow Interface

	static void ToggleRecordCommand(const TArray<FString>& Args);
	void ToggleRecord();

	// Core Delegate callbacks
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
	void OnAsyncLoadPackage(const FStringView PackageNameStrView);
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
    void OnAsyncLoadPackage(const FString& PackageName);
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 4
	void OnSyncLoadPackage(const FString& PackageName);

private:
	// Are loads currently being recorded
	bool bRecordingLoads = false;
	bool bSpewToLog = true;

	TArray<FString> AsyncLoadFiles;
	TArray<FString> SyncLoadFiles;

	FDelegateHandle AsyncLoadDelegateHandle;
	FDelegateHandle SyncLoadDelegateHandle;
};
```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiMemoryDebugger.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiMemoryDebugger.h"
#include "Runtime/Launch/Resources/Version.h"

#if ENGINE_MAJOR_VERSION == 4
#include "Misc/StreamingTextureLevelContext.h"	// StreamingTexture copy for UE 4.XX where this is not exported in engine. (fixed in UE5)
#endif // #if ENGINE_MAJOR_VERSION == 4

#include "Utils/ImGuiUtils.h"

#include <Components/PrimitiveComponent.h>
#include <Engine/Texture2D.h>
#include <Engine/TextureCube.h>
#include <Engine/TextureLODSettings.h>
#include <Engine/TextureStreamingTypes.h>
#include <RenderUtils.h>
#include <UObject/UObjectIterator.h>

#include <imgui.h>

// Log Category
DEFINE_LOG_CATEGORY_STATIC(LogImGuiDebugMem, Warning, All);

namespace MemDebugUtils
{
	float IntBytesToFltMB(uint64 bytes)
	{
		return (float) bytes / 1000000.0f;
	}

	struct FSortedTexture
	{
		int32 MaxAllowedSizeX;	  // This is the disk size when cooked.
		int32 MaxAllowedSizeY;
		EPixelFormat Format;
		int32 CurSizeX;
		int32 CurSizeY;
		int32 LODBias;
		int32 MaxAllowedSize;
		int32 CurrentSize;
		FString Name;
		int32 LODGroup;
		bool bIsStreaming;
		int32 UsageCount;

		/** Constructor, initializing every member variable with passed in values. */
		FSortedTexture(int32 InMaxAllowedSizeX,
					   int32 InMaxAllowedSizeY,
					   EPixelFormat InFormat,
					   int32 InCurSizeX,
					   int32 InCurSizeY,
					   int32 InLODBias,
					   int32 InMaxAllowedSize,
					   int32 InCurrentSize,
					   const FString& InName,
					   int32 InLODGroup,
					   bool bInIsStreaming,
					   int32 InUsageCount)
			: MaxAllowedSizeX(InMaxAllowedSizeX)
			, MaxAllowedSizeY(InMaxAllowedSizeY)
			, Format(InFormat)
			, CurSizeX(InCurSizeX)
			, CurSizeY(InCurSizeY)
			, LODBias(InLODBias)
			, MaxAllowedSize(InMaxAllowedSize)
			, CurrentSize(InCurrentSize)
			, Name(InName)
			, LODGroup(InLODGroup)
			, bIsStreaming(bInIsStreaming)
			, UsageCount(InUsageCount)
		{}
	};

	struct FCompareFSortedTexture
	{
		bool bAlphaSort;
		FCompareFSortedTexture(bool InAlphaSort)
			: bAlphaSort(InAlphaSort)
		{}
		FORCEINLINE bool operator()(const FSortedTexture& A, const FSortedTexture& B) const
		{
			if (bAlphaSort || A.CurrentSize == B.CurrentSize)
			{
				return A.Name < B.Name;
			}

			return B.CurrentSize < A.CurrentSize;
		}
	};

	struct FMemInfo
	{
		float TotalMemoryMB = 0.0f;
		float UnknownMemoryMB = 0.0f;
		float DedSysMemoryMB = 0.0f;
		float DedVidMemoryMB = 0.0f;
		float SharedSysMemoryMB = 0.0f;
		float SharedVidMemoryMB = 0.0f;
	};

	struct FCachedClassInfo
	{
		// Class Info
		TWeakObjectPtr<UClass> Class;
		bool bAbstract = false;
		TArray<int> ChildIndicies;

		// Current MemReport Info
		FMemInfo MemInfo;
		int Instances = 0;
	};

	namespace EColumnTypes
	{
		enum Type
		{
			Instances = 0,
			IsDefaultObject,
			Outer,
			TotalMem,
			UnknownMem,
			DedSysMem,
			DedVidMem,
			SharedSysMem,
			SharedVidMem,

			COUNT
		};

		static bool DefaultVisibility[Type::COUNT] =
		{
			/*Instances*/		true,
			/*IsDefaultObject*/ true,
			/*Outer*/           true,
			/*TotalMem*/        true,
			/*UnknownMem*/      true,
			/*DedSysMem*/       true,
			/*DedVidMem*/       true,
			/*SharedSysMem*/    false,
			/*SharedVidMem*/    false,
		};
	}	// namespace EColumnTypes

	namespace EMemSortType
	{
		enum Type
		{
			None,
			Alpha,
			Instances,
			TotalMem,
			UnknownMem,
			DedSysMem,
			DedVidMem,
			SharedSysMem,
			SharedVidMem,
		};
	}	// namespace EMemSortType

	struct FCachedClassTree
	{
		void TryCacheEntries(bool ForceRecache = false)
		{
			if (Classes.Num() > 0)
			{
				if (!ForceRecache)
				{
					return;
				}
				
				Classes.Empty();
			}

			for (TObjectIterator<UClass> It; It; ++It)
			{
				FCachedClassInfo& ClassInfo = Classes.AddDefaulted_GetRef();
				ClassInfo.Class = *It;
				ClassInfo.bAbstract = It->HasAnyClassFlags(CLASS_Abstract);
			}

			const int NumClasses = Classes.Num();
			for (int i = 0; i < NumClasses; ++i)
			{
				FCachedClassInfo& ClassInfo = Classes[i];
				if (ClassInfo.Class == UObject::StaticClass())
				{
					RootIndex = i;
				}

				for (int j = 0; j < NumClasses; ++j)
				{
					FCachedClassInfo& PotentialChild = Classes[j];
					if (PotentialChild.Class.IsValid() && PotentialChild.Class->GetSuperClass() == ClassInfo.Class)
					{
						ClassInfo.ChildIndicies.Add(j);
					}
				}
			}
		}

		void UpdateMemoryStats(bool IncludeCDO, EResourceSizeMode::Type ResourceSizeMode = EResourceSizeMode::Exclusive)
		{
			// Caching Class Entires is quick compared to what we are about to do.. refresh latest class info.
			TryCacheEntries(/*ForceRecache*/true);

			for (FCachedClassInfo& ClassInfo : Classes)
			{
				ClassInfo.MemInfo = {};
				ClassInfo.Instances = 0;
			}

			for (FThreadSafeObjectIterator It; It; ++It)
			{
#if WITH_EDITORONLY_DATA
				if ((!IncludeCDO && It->IsTemplate(RF_ClassDefaultObject)) || !It->GetPackage()->GetHasBeenEndLoaded())
#else
				if (!IncludeCDO && It->IsTemplate(RF_ClassDefaultObject))
#endif
				{
					continue;
				}
				FResourceSizeEx TrueResourceSize = FResourceSizeEx(ResourceSizeMode);
				It->GetResourceSizeEx(TrueResourceSize);
				for (FCachedClassInfo& ClassInfo : Classes)
				{
					if (It->GetClass()->IsChildOf(ClassInfo.Class.Get()))
					{
						ClassInfo.MemInfo.TotalMemoryMB += (float) TrueResourceSize.GetTotalMemoryBytes();
						ClassInfo.MemInfo.UnknownMemoryMB += (float)TrueResourceSize.GetUnknownMemoryBytes();
						ClassInfo.MemInfo.DedSysMemoryMB += (float)TrueResourceSize.GetDedicatedSystemMemoryBytes();
						ClassInfo.MemInfo.DedVidMemoryMB += (float)TrueResourceSize.GetDedicatedVideoMemoryBytes();
#if ENGINE_MAJOR_VERSION == 4
						ClassInfo.MemInfo.SharedSysMemoryMB += (float)TrueResourceSize.GetSharedSystemMemoryBytes();
						ClassInfo.MemInfo.SharedVidMemoryMB += (float)TrueResourceSize.GetSharedVideoMemoryBytes();
#endif // #if ENGINE_MAJOR_VERSION == 4
						
						++ClassInfo.Instances;
					}
				}

			}

			// convert B to MB
			for (FCachedClassInfo& ClassInfo : Classes)
			{
				ClassInfo.MemInfo.TotalMemoryMB = ClassInfo.MemInfo.TotalMemoryMB /1024.0f/1024.0f;
				ClassInfo.MemInfo.UnknownMemoryMB = ClassInfo.MemInfo.UnknownMemoryMB / 1024.0f / 1024.0f;
				ClassInfo.MemInfo.DedSysMemoryMB = ClassInfo.MemInfo.DedSysMemoryMB / 1024.0f / 1024.0f;
				ClassInfo.MemInfo.DedVidMemoryMB = ClassInfo.MemInfo.DedVidMemoryMB / 1024.0f / 1024.0f;
				ClassInfo.MemInfo.SharedSysMemoryMB = ClassInfo.MemInfo.SharedSysMemoryMB / 1024.0f / 1024.0f;
				ClassInfo.MemInfo.SharedVidMemoryMB = ClassInfo.MemInfo.SharedVidMemoryMB / 1024.0f / 1024.0f;
			}
		}

		void SortBy(EMemSortType::Type SortType)
		{
			switch(SortType)
			{
				case EMemSortType::Alpha:
					for (FCachedClassInfo& ClassInfo : Classes)
					{
						ClassInfo.ChildIndicies.Sort([this](int LHS, int RHS) { return GetNameSafe(Classes[LHS].Class.Get()) < GetNameSafe(Classes[RHS].Class.Get()); });
					}
					break;

				case EMemSortType::Instances:
					for (FCachedClassInfo& ClassInfo : Classes)
					{
						ClassInfo.ChildIndicies.Sort([this](int LHS, int RHS) { return Classes[LHS].Instances > Classes[RHS].Instances; });
					}
					break;

				case EMemSortType::TotalMem:
					for (FCachedClassInfo& ClassInfo : Classes)
					{
						ClassInfo.ChildIndicies.Sort([this](int LHS, int RHS) { return Classes[LHS].MemInfo.TotalMemoryMB > Classes[RHS].MemInfo.TotalMemoryMB; });
					}
					break;

				case EMemSortType::UnknownMem:
					for (FCachedClassInfo& ClassInfo : Classes)
					{
						ClassInfo.ChildIndicies.Sort([this](int LHS, int RHS) { return Classes[LHS].MemInfo.UnknownMemoryMB > Classes[RHS].MemInfo.UnknownMemoryMB; });
					}
					break;

				case EMemSortType::DedSysMem:
					for (FCachedClassInfo& ClassInfo : Classes)
					{
						ClassInfo.ChildIndicies.Sort([this](int LHS, int RHS) { return Classes[LHS].MemInfo.DedSysMemoryMB > Classes[RHS].MemInfo.DedSysMemoryMB; });
					}
					break;

				case EMemSortType::DedVidMem:
					for (FCachedClassInfo& ClassInfo : Classes)
					{
						ClassInfo.ChildIndicies.Sort([this](int LHS, int RHS) { return Classes[LHS].MemInfo.DedVidMemoryMB > Classes[RHS].MemInfo.DedVidMemoryMB; });
					}
					break;

				case EMemSortType::SharedSysMem:
					for (FCachedClassInfo& ClassInfo : Classes)
					{
						ClassInfo.ChildIndicies.Sort([this](int LHS, int RHS) { return Classes[LHS].MemInfo.SharedSysMemoryMB > Classes[RHS].MemInfo.SharedSysMemoryMB; });
					}
					break;

				case EMemSortType::SharedVidMem:
					for (FCachedClassInfo& ClassInfo : Classes)
					{
						ClassInfo.ChildIndicies.Sort([this](int LHS, int RHS) { return Classes[LHS].MemInfo.SharedVidMemoryMB > Classes[RHS].MemInfo.SharedVidMemoryMB; });
					}
					break;

				default:
					UE_LOG(LogImGuiDebugMem, Error, TEXT("FCachedClassTree::SortBy() - sorting with unimplemented type. not doing anything!"));
					break;
			}
		}

		int RootIndex;
		TArray<FCachedClassInfo> Classes;
	};

	// Struct for each instance in the list of all instances per-class
	struct FInstanceInspectorInstanceInfo
	{
		TWeakObjectPtr<UObject> InstanceWkPtr = nullptr;
		FMemInfo MemInfo;
	};

	// holds referencer info in a memory safe way
	struct FReferencerInfo
	{
		TWeakObjectPtr<UObject> ReferencerWkPtr = nullptr;
		TArray<FString> ReferencingProperties;
		int TotalReferences = 0;
	};

	// Struct for a single inspected instance
	struct FInspectedInstanceInfo
	{
		TWeakObjectPtr<UObject> InspectedWkPtr = nullptr;
		TArray<FReferencerInfo> CachedInternalReferencers;
		TArray<FReferencerInfo> CachedExternalReferencers;

		void UpdateInspectedInstanceReferencers()
		{
			// This caching exists because FReferencerInformation holds raw UObject pointers and UObject::RetrieveReferencers() is slllooooww
			//  so just run it on demand and cache the results in 
			CachedInternalReferencers.Empty();
			CachedExternalReferencers.Empty();

			UObject* InspectedInstanceRawPtr = InspectedWkPtr.Get();
			if (IsValid(InspectedInstanceRawPtr))
			{
				TArray<FReferencerInformation> ReferencerInfos_Internal;
				TArray<FReferencerInformation> ReferencerInfos_External;
				InspectedInstanceRawPtr->RetrieveReferencers(&ReferencerInfos_Internal, &ReferencerInfos_External);

				for (const FReferencerInformation& ReferencerInternal : ReferencerInfos_Internal)
				{
					FReferencerInfo& NewReferencerInfo = CachedInternalReferencers.AddDefaulted_GetRef();
					
					NewReferencerInfo.ReferencerWkPtr = ReferencerInternal.Referencer;
					NewReferencerInfo.TotalReferences = ReferencerInternal.TotalReferences;

					for (const FProperty* ReferencingProperty : ReferencerInternal.ReferencingProperties)
					{
						NewReferencerInfo.ReferencingProperties.Add(ReferencingProperty->GetNameCPP());
					}
				}
			}
		}

		void SetInpectedInstance(const TWeakObjectPtr<UObject>& NewInpectedInstance)
		{
			if (NewInpectedInstance.IsValid())
			{
				InspectedWkPtr = NewInpectedInstance;
				UpdateInspectedInstanceReferencers();
			}
		}
	};

	struct FInstanceInspectorInfo
	{
		TWeakObjectPtr<UClass> Class = nullptr;
		FMemInfo MemInfo;
		int Instances = 0;
		EMemSortType::Type SortType = EMemSortType::TotalMem;
		ImGuiTools::Utils::FShowCols ShowCols = ImGuiTools::Utils::FShowCols(EColumnTypes::COUNT, &EColumnTypes::DefaultVisibility[0]);
		FInspectedInstanceInfo InspectedInstance;
		TArray<FInstanceInspectorInstanceInfo> InstanceInfos;
		ImGuiTextFilter NameFilter;
		bool bAutoRefresh = false;	// option to auto refresh the instance view
		float AutoRefreshTime = 4.0f; // interval to auto refresh the instance view
		float AutoRefreshTimer = 0.0f;	// current timer from last time auto refresh occurred.

		void UpdateObjectMemoryInfo(bool IncludeCDO, EResourceSizeMode::Type ResourceSizeMode = EResourceSizeMode::Exclusive)
		{
			MemInfo = {};
			Instances = 0;
			InstanceInfos.Empty();

			for (FThreadSafeObjectIterator It; It; ++It)
			{
				if (!It->GetClass()->IsChildOf(Class.Get()) || (!IncludeCDO && It->IsTemplate(RF_ClassDefaultObject)))
				{
					continue;
				}

				FResourceSizeEx TrueResourceSize = FResourceSizeEx(ResourceSizeMode);
				It->GetResourceSizeEx(TrueResourceSize);
				const float InstTotalMemMB = (float)TrueResourceSize.GetTotalMemoryBytes()/1024.0f/1024.0f;
				const float InstUnknownMemMB = (float)TrueResourceSize.GetUnknownMemoryBytes() / 1024.0f / 1024.0f;
				const float InstDedSysMemMB = (float)TrueResourceSize.GetDedicatedSystemMemoryBytes() / 1024.0f / 1024.0f;
				const float InstDedVidMemMB = (float)TrueResourceSize.GetDedicatedVideoMemoryBytes() / 1024.0f / 1024.0f;
#if ENGINE_MAJOR_VERSION == 4
				const float InstSharedSysMemMB = (float)TrueResourceSize.GetSharedSystemMemoryBytes() / 1024.0f / 1024.0f;
				const float InstSharedVidMemMB = (float)TrueResourceSize.GetSharedVideoMemoryBytes() / 1024.0f / 1024.0f;
#endif // #if ENGINE_MAJOR_VERSION == 4
				MemInfo.TotalMemoryMB += InstTotalMemMB;
				MemInfo.UnknownMemoryMB += InstUnknownMemMB;
				MemInfo.DedSysMemoryMB += InstDedSysMemMB;
				MemInfo.DedVidMemoryMB += InstDedVidMemMB;
#if ENGINE_MAJOR_VERSION == 4
				MemInfo.SharedSysMemoryMB += InstSharedSysMemMB;
				MemInfo.SharedVidMemoryMB += InstSharedVidMemMB;
#endif // #if ENGINE_MAJOR_VERSION == 4
				++Instances;

				FInstanceInspectorInstanceInfo& InstInfo = InstanceInfos.AddZeroed_GetRef();
				InstInfo.InstanceWkPtr = *It;
				InstInfo.MemInfo.TotalMemoryMB = InstTotalMemMB;
				InstInfo.MemInfo.UnknownMemoryMB = InstUnknownMemMB;
				InstInfo.MemInfo.DedSysMemoryMB = InstDedSysMemMB;
				InstInfo.MemInfo.DedVidMemoryMB = InstDedVidMemMB;
#if ENGINE_MAJOR_VERSION == 4
				InstInfo.MemInfo.SharedSysMemoryMB = InstSharedSysMemMB;
				InstInfo.MemInfo.SharedVidMemoryMB = InstSharedVidMemMB;
#endif // #if ENGINE_MAJOR_VERSION == 4
			}

			SortBy(SortType);
		}

		void SortBy(EMemSortType::Type InSortType)
		{
			SortType = InSortType;
			switch (SortType)
			{
				case EMemSortType::Alpha:
					InstanceInfos.Sort([this](const FInstanceInspectorInstanceInfo& LHS, const FInstanceInspectorInstanceInfo& RHS) { return LHS.InstanceWkPtr->GetName() < RHS.InstanceWkPtr->GetName(); });
					break;

				case EMemSortType::TotalMem:
					InstanceInfos.Sort([this](const FInstanceInspectorInstanceInfo& LHS, const FInstanceInspectorInstanceInfo& RHS) { return LHS.MemInfo.TotalMemoryMB > RHS.MemInfo.TotalMemoryMB; });
					break;

				case EMemSortType::UnknownMem:
					InstanceInfos.Sort([this](const FInstanceInspectorInstanceInfo& LHS, const FInstanceInspectorInstanceInfo& RHS) { return LHS.MemInfo.UnknownMemoryMB > RHS.MemInfo.UnknownMemoryMB; });
					break;

				case EMemSortType::DedSysMem:
					InstanceInfos.Sort([this](const FInstanceInspectorInstanceInfo& LHS, const FInstanceInspectorInstanceInfo& RHS) { return LHS.MemInfo.DedSysMemoryMB > RHS.MemInfo.DedSysMemoryMB; });
					break;

				case EMemSortType::DedVidMem:
					InstanceInfos.Sort([this](const FInstanceInspectorInstanceInfo& LHS, const FInstanceInspectorInstanceInfo& RHS) { return LHS.MemInfo.DedVidMemoryMB > RHS.MemInfo.DedVidMemoryMB; });
					break;

				case EMemSortType::SharedSysMem:
					InstanceInfos.Sort([this](const FInstanceInspectorInstanceInfo& LHS, const FInstanceInspectorInstanceInfo& RHS) { return LHS.MemInfo.SharedSysMemoryMB > RHS.MemInfo.SharedSysMemoryMB; });
					break;

				case EMemSortType::SharedVidMem:
					InstanceInfos.Sort([this](const FInstanceInspectorInstanceInfo& LHS, const FInstanceInspectorInstanceInfo& RHS) { return LHS.MemInfo.SharedVidMemoryMB > RHS.MemInfo.SharedVidMemoryMB; });
					break;

				default:
				case EMemSortType::Instances:
					UE_LOG(LogImGuiDebugMem, Error, TEXT("FInstanceInspectorInfo::SortBy() - sorting with unimplemented type. not doing anything!"));
					break;
			}
		}
	};

	TArray<FInstanceInspectorInfo> InstanceInspectors;
	TWeakObjectPtr<UClass> PopupClass;
	bool DrawClassChildTreeIndex(FCachedClassTree& ClassTree, int Index, bool FilterZeroInstances, ImGuiTextFilter& ClassNameFilter, ImGuiTools::Utils::FShowCols& ShowCols)
	{
		FCachedClassInfo& CachedClassInfo = ClassTree.Classes[Index];
		if (CachedClassInfo.Class.IsStale() || !CachedClassInfo.Class.IsValid())
		{
			return false; // return false when data is bad ( or child data is bad )
		}

		if (FilterZeroInstances && (CachedClassInfo.Instances == 0))
		{
			return true;
		}

		if (ClassNameFilter.IsActive())
		{
			if (!ClassNameFilter.PassFilter(TCHAR_TO_ANSI(*CachedClassInfo.Class->GetName())))
			{
				for (int ChildIndex : CachedClassInfo.ChildIndicies)
				{
					if (!DrawClassChildTreeIndex(ClassTree, ChildIndex, FilterZeroInstances, ClassNameFilter, ShowCols))
					{
						return false;
					}
				}
				return true;
			}
		}

		static ImGuiTreeNodeFlags base_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_AllowOverlap;
		ImGuiTreeNodeFlags node_flags = base_flags;
		if (CachedClassInfo.ChildIndicies.Num() == 0)
		{
			node_flags |= ImGuiTreeNodeFlags_Leaf;
		}
		if (ClassNameFilter.IsActive() || (Index == ClassTree.RootIndex))
		{
			node_flags |= ImGuiTreeNodeFlags_DefaultOpen;
		}

		const bool TreeOpen = ImGui::TreeNodeEx((void*)CachedClassInfo.Class.Get(), node_flags, "%s%s", Ansi(*CachedClassInfo.Class->GetName()), CachedClassInfo.bAbstract ? "(abstract)" : "");
		ImGui::SameLine(ImGui::GetWindowWidth() - ((ShowCols.GetCachedShowColCount() + 1) * 110.0f) + 44.0f);

		if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Inspect##%.54ls"), *CachedClassInfo.Class->GetName()))))
		{
			FInstanceInspectorInfo& InstInfo = InstanceInspectors.AddDefaulted_GetRef();
			InstInfo.Class = CachedClassInfo.Class;
		}

		ImGui::NextColumn();
		if (ShowCols.GetShowCol(EColumnTypes::Instances)) { ImGui::Text("%d", CachedClassInfo.Instances);ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(EColumnTypes::TotalMem)) { ImGui::Text("%.04f MB", CachedClassInfo.MemInfo.TotalMemoryMB); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(EColumnTypes::UnknownMem)) { ImGui::Text("%.04f MB", CachedClassInfo.MemInfo.UnknownMemoryMB); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(EColumnTypes::DedSysMem)) { ImGui::Text("%.04f MB", CachedClassInfo.MemInfo.DedSysMemoryMB); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(EColumnTypes::DedVidMem)) { ImGui::Text("%.04f MB", CachedClassInfo.MemInfo.DedVidMemoryMB); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(EColumnTypes::SharedSysMem)) { ImGui::Text("%.04f MB", CachedClassInfo.MemInfo.SharedSysMemoryMB); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(EColumnTypes::SharedVidMem)) { ImGui::Text("%.04f MB", CachedClassInfo.MemInfo.SharedVidMemoryMB); ImGui::NextColumn(); }
		ImGui::Separator();

		if (TreeOpen)
		{
			for (int ChildIndex : CachedClassInfo.ChildIndicies)
			{
				if (!DrawClassChildTreeIndex(ClassTree, ChildIndex, FilterZeroInstances, ClassNameFilter, ShowCols))
				{
					return false;
				}
			}

			ImGui::TreePop();
		}

		return true;
	}

	void DrawHoveredItemInstanceTooltip(UObject* InstanceObject)
	{
		ImGui::BeginTooltip();
		if (IsValid(InstanceObject))
		{
			ImGui::Text("        Object: %s", Ansi(*GetNameSafe(InstanceObject)));
			ImGui::Text("         Outer: %s", Ansi(*GetNameSafe(InstanceObject->GetOuter())));
			ImGui::Text("default SubObj: %d", InstanceObject->IsDefaultSubobject());
		}
		else
		{
			ImGui::Text(" Invalid / Stale Object!");
		}

		ImGui::EndTooltip();
	}

	void DrawObjectInspectorPopup(FInstanceInspectorInfo& InstInspInfo, float DeltaTime)
	{
		static EResourceSizeMode::Type ResourceSizeMode = EResourceSizeMode::EstimatedTotal;
		ImGui::Text("%s", Ansi(*InstInspInfo.Class->GetName()));
		ImGui::SameLine();
		if (ImGui::SmallButton("Update Instance Memory Data"))
		{
			InstInspInfo.UpdateObjectMemoryInfo(false, ResourceSizeMode);
		}
		
		ImGui::SameLine(0.0f, 50.0f);

		static int ResourceSizeModeComboValue = static_cast<int>(ResourceSizeMode);
		ImGui::BeginChild("ResourceSizeModeCombo", ImVec2(230.0f, 18.0f));
		ImGui::Combo("##ResourceSizeModeCombo", &ResourceSizeModeComboValue, "Exclusive\0Estimated Total");
		ResourceSizeMode = static_cast<EResourceSizeMode::Type>(ResourceSizeModeComboValue);
		ImGui::EndChild();

		ImGui::Checkbox("Auto-Update", &InstInspInfo.bAutoRefresh);
		if (InstInspInfo.bAutoRefresh)
		{
			ImGui::SameLine(); ImGui::DragFloat("Interval", &InstInspInfo.AutoRefreshTime, 0.01f, 0.01f, 10.0f);
			ImGui::SameLine(); ImGui::ProgressBar(FMath::Clamp<float>(InstInspInfo.AutoRefreshTimer / InstInspInfo.AutoRefreshTime, 0.0f, 1.0f));

			InstInspInfo.AutoRefreshTimer -= DeltaTime;

			if (InstInspInfo.AutoRefreshTimer <= 0.0f)
			{
				InstInspInfo.AutoRefreshTimer = InstInspInfo.AutoRefreshTime;
				InstInspInfo.UpdateObjectMemoryInfo(false, ResourceSizeMode);
			}
		}
		ImGui::Separator();
		ImGui::Columns(2);
		ImGui::SetColumnWidth(0, 330.0f);
		ImGui::Text("Include/Sort:");
		ImGui::BeginChild("IncSort", ImVec2(0.0f, 90.0f));
		ImGui::Columns(2);
		static const float RadWidth = 54.0f;
		ImGui::SameLine(27.0f);
		if (ImGui::RadioButton("##Alpha", InstInspInfo.SortType == MemDebugUtils::EMemSortType::Alpha)) { InstInspInfo.SortBy(MemDebugUtils::EMemSortType::Alpha); } ImGui::SameLine();
		ImGui::Text("Alpha"); ImGui::NextColumn();

		ImGui::Checkbox("##IsDefaultObject", &InstInspInfo.ShowCols.GetShowCol(EColumnTypes::IsDefaultObject)); ImGui::SameLine();
		ImGui::Text("IsDefaultObject"); 
		ImGui::Checkbox("##Outer", &InstInspInfo.ShowCols.GetShowCol(EColumnTypes::Outer)); ImGui::SameLine();
		ImGui::Text("Outer"); ImGui::NextColumn();

		ImGui::Checkbox("##TotalMemCh", &InstInspInfo.ShowCols.GetShowCol(EColumnTypes::TotalMem)); ImGui::SameLine();
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::TotalMem))
		{ if (ImGui::RadioButton("##TotalMem", InstInspInfo.SortType == MemDebugUtils::EMemSortType::TotalMem)) { InstInspInfo.SortBy(MemDebugUtils::EMemSortType::TotalMem); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("TotalMem"); ImGui::NextColumn();

		ImGui::Checkbox("##UnknownMemCh", &InstInspInfo.ShowCols.GetShowCol(EColumnTypes::UnknownMem)); ImGui::SameLine();
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::UnknownMem))
		{ if (ImGui::RadioButton("##UnknownMem", InstInspInfo.SortType == MemDebugUtils::EMemSortType::UnknownMem)) { InstInspInfo.SortBy(MemDebugUtils::EMemSortType::UnknownMem); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("UnknownMem"); ImGui::NextColumn();

		ImGui::Checkbox("##DedSysMemCh", &InstInspInfo.ShowCols.GetShowCol(EColumnTypes::DedSysMem)); ImGui::SameLine();
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::DedSysMem))
		{ if (ImGui::RadioButton("##DedSysMem", InstInspInfo.SortType == MemDebugUtils::EMemSortType::DedSysMem)) { InstInspInfo.SortBy(MemDebugUtils::EMemSortType::DedSysMem); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("DedSysMem"); ImGui::NextColumn();

		ImGui::Checkbox("##DedVidMemCh", &InstInspInfo.ShowCols.GetShowCol(EColumnTypes::DedVidMem)); ImGui::SameLine();
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::DedVidMem))
		{ if (ImGui::RadioButton("##DedVidMem", InstInspInfo.SortType == MemDebugUtils::EMemSortType::DedVidMem)) { InstInspInfo.SortBy(MemDebugUtils::EMemSortType::DedVidMem); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("DedVidMem"); ImGui::NextColumn();

		ImGui::Checkbox("##SharedSysMemCh", &InstInspInfo.ShowCols.GetShowCol(EColumnTypes::SharedSysMem)); ImGui::SameLine();
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::SharedSysMem))
		{ if (ImGui::RadioButton("##SharedSysMem", InstInspInfo.SortType == MemDebugUtils::EMemSortType::SharedSysMem)) { InstInspInfo.SortBy(MemDebugUtils::EMemSortType::SharedSysMem); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("SharedSysMem"); ImGui::NextColumn();

		ImGui::Checkbox("##SharedVidMemCh", &InstInspInfo.ShowCols.GetShowCol(EColumnTypes::SharedVidMem)); ImGui::SameLine();
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::SharedVidMem))
		{ if (ImGui::RadioButton("##SharedVidMem", InstInspInfo.SortType == MemDebugUtils::EMemSortType::SharedVidMem)) { InstInspInfo.SortBy(MemDebugUtils::EMemSortType::SharedVidMem); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("SharedVidMem"); ImGui::NextColumn();

		ImGui::Columns(1);
		ImGui::EndChild(); // "IncSort"
		ImGui::SetColumnWidth(1, 330.0f);


		ImGui::NextColumn();
		InstInspInfo.NameFilter.Draw("Name Filter", ImGui::GetColumnWidth() - 100.0f);
		ImGui::Columns(1);
		ImGui::BeginChild("InstLabel", ImVec2(0, 50.0f), true);

		ImGui::Text("Total Instances: %d    Total Size: % .04fMB", InstInspInfo.Instances, InstInspInfo.MemInfo.TotalMemoryMB);
		ImGui::Separator();

		static constexpr int ColumnCount = 9;
		InstInspInfo.ShowCols.GetShowCol(EColumnTypes::Instances) = false; // gross: Instances is disabled for this view so ensure it is off so CacheColCount() is contextually correct
		const int VisibleColCount = InstInspInfo.ShowCols.CacheShowColCount() + 1;
		ImGui::Columns(VisibleColCount, "ObjInstCol");
		static float ColumnWidths[ColumnCount];
		static constexpr float InfoColWidth = 110.0f;
		ColumnWidths[0] = ImGui::GetWindowWidth() - (InfoColWidth * (VisibleColCount - 1)); // Object col
		if (VisibleColCount > 1)
		{
			for (int i = 0; i < VisibleColCount; ++i)
			{
				if (i > 0)
				{
					ColumnWidths[i] = InfoColWidth;
				}
				ImGui::SetColumnWidth(i, ColumnWidths[i]);
			}
		}
		ImGui::Text("Object"); ImGui::NextColumn();
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::IsDefaultObject)) { ImGui::Text("Is Default Obj"); ImGui::NextColumn(); }
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::Outer)) { ImGui::Text("Outer"); ImGui::NextColumn(); }
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::TotalMem)) { ImGui::Text("Total Mem"); ImGui::NextColumn(); }
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::UnknownMem)) { ImGui::Text("Unknown Mem"); ImGui::NextColumn(); }
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::DedSysMem)) { ImGui::Text("DedSys Mem"); ImGui::NextColumn(); }
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::DedVidMem)) { ImGui::Text("DedVid Mem"); ImGui::NextColumn(); }
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::SharedSysMem)) { ImGui::Text("SharedSys Mem"); ImGui::NextColumn(); }
		if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::SharedVidMem)) { ImGui::Text("SharedVid Mem"); ImGui::NextColumn(); }
		ImGui::Columns(1);
		ImGui::EndChild();	  // "InstLabel"

		if (ImGui::CollapsingHeader("All Instances", ImGuiTreeNodeFlags_DefaultOpen))
		{
			ImGui::BeginChild("InstInfo", ImVec2(0, 360.0f), true);
			ImGui::Columns(VisibleColCount, "ObjInstCol");
			if (VisibleColCount > 1)
			{
				for (int i = 0; i < VisibleColCount; ++i)
				{
					ImGui::SetColumnWidth(i, ColumnWidths[i]);
				}
			}
			for (const FInstanceInspectorInstanceInfo& InspInstance : InstInspInfo.InstanceInfos)
			{
				if (!InstInspInfo.NameFilter.IsActive() || InstInspInfo.NameFilter.PassFilter(TCHAR_TO_ANSI(*GetNameSafe(InspInstance.InstanceWkPtr.Get()))))
				{
					if (InspInstance.InstanceWkPtr.IsValid() && !InspInstance.InstanceWkPtr.IsStale())
					{
						if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Inspect##%.54ls"), *GetNameSafe(InspInstance.InstanceWkPtr.Get())))))
						{
							InstInspInfo.InspectedInstance.SetInpectedInstance(InspInstance.InstanceWkPtr);
						}
						ImGui::SameLine();
						ImGui::Text("%s", Ansi(*InspInstance.InstanceWkPtr->GetName()));
						if (ImGui::IsItemHovered())
						{
							DrawHoveredItemInstanceTooltip(InspInstance.InstanceWkPtr.Get());
						}
						ImGui::NextColumn();

						if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::IsDefaultObject)) { ImGui::Text(InspInstance.InstanceWkPtr->IsDefaultSubobject() ? "true" : "false"); ImGui::NextColumn(); }
						if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::Outer)) { 
							ImGui::Text("%s", Ansi(*GetNameSafe(InspInstance.InstanceWkPtr->GetOuter()))); 
							if (ImGui::IsItemHovered())
							{
								DrawHoveredItemInstanceTooltip(InspInstance.InstanceWkPtr.Get());
							}
						
							ImGui::NextColumn(); 
						}
					}
					else
					{
						ImGui::Text("STALE/INVALID PTR"); ImGui::NextColumn();
						if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::IsDefaultObject)) { ImGui::NextColumn(); }
						if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::Outer)) { ImGui::NextColumn(); }
					}
				
					if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::TotalMem)) { ImGui::Text("%.04f MB", InspInstance.MemInfo.TotalMemoryMB); ImGui::NextColumn(); }
					if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::UnknownMem)) { ImGui::Text("%.04f MB", InspInstance.MemInfo.UnknownMemoryMB); ImGui::NextColumn(); }
					if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::DedSysMem)) { ImGui::Text("%.04f MB", InspInstance.MemInfo.DedSysMemoryMB); ImGui::NextColumn(); }
					if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::DedVidMem)) { ImGui::Text("%.04f MB", InspInstance.MemInfo.DedVidMemoryMB); ImGui::NextColumn(); }
					if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::SharedSysMem)) { ImGui::Text("%.04f MB", InspInstance.MemInfo.SharedSysMemoryMB); ImGui::NextColumn(); }
					if (InstInspInfo.ShowCols.GetShowCol(EColumnTypes::SharedVidMem)) { ImGui::Text("%.04f MB", InspInstance.MemInfo.SharedVidMemoryMB); ImGui::NextColumn(); }
				}
			}
			ImGui::Columns(1);
			ImGui::EndChild(); // "InstInfo"
		}

		if (ImGui::CollapsingHeader("Inspected Instance", ImGuiTreeNodeFlags_DefaultOpen))
		{
			ImGui::BeginChild("InspectedInstance", ImVec2(0, 440.0f), true);

			UObject* InspectedInstanceRawPtr = InstInspInfo.InspectedInstance.InspectedWkPtr.Get();
			if (IsValid(InspectedInstanceRawPtr))
			{
				ImGui::Text("        Object: %s (%p)", Ansi(*GetNameSafe(InspectedInstanceRawPtr)), InspectedInstanceRawPtr);
				ImGui::Text("         Class: %s", Ansi(*GetNameSafe(InspectedInstanceRawPtr->GetClass())));
				ImGui::Text("         World: %s (%p)", Ansi(*GetNameSafe(InspectedInstanceRawPtr->GetWorld())), InspectedInstanceRawPtr->GetWorld());
				ImGui::Text("         Outer: %s", Ansi(*GetNameSafe(InspectedInstanceRawPtr->GetOuter())));
				ImGui::Text("default SubObj: %d", InspectedInstanceRawPtr->IsDefaultSubobject());

				if (ImGui::Button("Refresh Referencers (SLOW!)"))
				{
					InstInspInfo.InspectedInstance.UpdateInspectedInstanceReferencers();
				}

				const auto DrawReferencers = [](const TArray<FReferencerInfo>& CachedReferencerInfo, const FString& HeaderString)
				{
					static constexpr int RefInfoColumnCount = 4;
					ImGui::Columns(RefInfoColumnCount);
					ImGui::Text("Name"); ImGui::NextColumn();
					ImGui::Text("Class"); ImGui::NextColumn();
					ImGui::Text("World"); ImGui::NextColumn();
					ImGui::Text("Properties"); ImGui::NextColumn();
					ImGui::Columns(1);

					ImGui::BeginChild(Ansi(*HeaderString), ImVec2(0, 200.0f), true);
					ImGui::Columns(RefInfoColumnCount);

					int RefIter = 0;
					for (const FReferencerInfo& ReferencerInfo : CachedReferencerInfo)
					{
						UObject* ReferencerRawPtr = ReferencerInfo.ReferencerWkPtr.Get();
						ImGui::Text("%03d: %s(%p) (refs: %d)", ++RefIter, Ansi(*GetNameSafe(ReferencerRawPtr)), ReferencerRawPtr, ReferencerInfo.TotalReferences); ImGui::NextColumn();

						if (IsValid(ReferencerRawPtr))
						{
							ImGui::Text("%s", Ansi(*GetNameSafe(ReferencerRawPtr->GetClass()))); ImGui::NextColumn();
							ImGui::Text("%s", Ansi(*GetNameSafe(ReferencerRawPtr->GetWorld()))); ImGui::NextColumn();
							for (int i = 0; i < ReferencerInfo.ReferencingProperties.Num(); ++i)
							{
								const FString& RefPropName = ReferencerInfo.ReferencingProperties[i];
								ImGui::Text("%02d: %s", (i+1), Ansi(*RefPropName));
							}
							ImGui::NextColumn();
						}
						else
						{
							ImGui::Text("*invalid*"); ImGui::NextColumn();
							ImGui::Text("*invalid*"); ImGui::NextColumn();
							ImGui::Text("*invalid*"); ImGui::NextColumn();
						}
					}

					ImGui::Columns(1);
					ImGui::EndChild();
				};


				const FString& InternalRefHeader = FString::Printf(TEXT("Internal Referencers count: %d"), InstInspInfo.InspectedInstance.CachedInternalReferencers.Num());
				const FString& ExternalRefHeader = FString::Printf(TEXT("External Referencers count: %d"), InstInspInfo.InspectedInstance.CachedExternalReferencers.Num());
				if (ImGui::CollapsingHeader(Ansi(*InternalRefHeader)))
				{
					DrawReferencers(InstInspInfo.InspectedInstance.CachedInternalReferencers, InternalRefHeader);
				}
				if (ImGui::CollapsingHeader(Ansi(*ExternalRefHeader), ImGuiTreeNodeFlags_DefaultOpen))
				{
					DrawReferencers(InstInspInfo.InspectedInstance.CachedExternalReferencers, InternalRefHeader);
				}
			}
			else
			{
				ImGui::Text("Inspected Instance Invalid / Stale / Null - Please select an instance in the list above.");
			}

			ImGui::EndChild(); // "InspectedInstance"
		}
	}
}

FImGuiMemoryDebugger::FImGuiMemoryDebugger()
{
	ToolName = TEXT("MemoryDebugger");
}

void FImGuiMemoryDebugger::ImGuiUpdate(float DeltaTime)
{
	if (ImGui::CollapsingHeader("Platform Memory Stats", ImGuiTreeNodeFlags_DefaultOpen))
	{
		FPlatformMemoryStats MemoryStats = FPlatformMemory::GetStats();
		// Physical mem
		const float PhysMemPercent = (float)MemoryStats.UsedPhysical / (float)MemoryStats.TotalPhysical;

		ImGui::Text("Physical Memory:");
		ImGui::SameLine();
		{
			const FString& ProgStr = FString::Printf(TEXT("%.02f MB / %.02f MB (%.02f%%)"), MemDebugUtils::IntBytesToFltMB(MemoryStats.UsedPhysical), MemDebugUtils::IntBytesToFltMB(MemoryStats.TotalPhysical), PhysMemPercent * 100.0f);
			ImGui::ProgressBar(PhysMemPercent, ImVec2(-1,0), Ansi(*ProgStr));
		}

		ImGui::Columns(3, "memcols");
		ImGui::Text("Peak Used"); ImGui::NextColumn();
		ImGui::Text("Cur Used"); ImGui::NextColumn();
		ImGui::Text("Total Available"); ImGui::NextColumn();

		ImGui::Text("%.02fMB", MemDebugUtils::IntBytesToFltMB(MemoryStats.PeakUsedPhysical)); ImGui::NextColumn();
		ImGui::Text("%.02fMB", MemDebugUtils::IntBytesToFltMB(MemoryStats.UsedPhysical)); ImGui::NextColumn();
		ImGui::Text("%.02fMB", MemDebugUtils::IntBytesToFltMB(MemoryStats.TotalPhysical)); ImGui::NextColumn();
		ImGui::Columns(1);
		ImGui::Separator();


		// Virtual mem
		const float VirtMemPercent = (float) MemoryStats.UsedVirtual / (float) MemoryStats.TotalVirtual;

		ImGui::Text("Virtual Memory:");
		ImGui::SameLine();
		{
			const FString& ProgStr = FString::Printf(TEXT("%.02f MB / %.02f MB (%.02f%%)"), MemDebugUtils::IntBytesToFltMB(MemoryStats.UsedVirtual), MemDebugUtils::IntBytesToFltMB(MemoryStats.TotalVirtual), VirtMemPercent * 100.0f);
			ImGui::ProgressBar(VirtMemPercent, ImVec2(-1, 0), Ansi(*ProgStr));
		}

		ImGui::Columns(3, "memcols");
		ImGui::Text("Peak Used");
		ImGui::NextColumn();
		ImGui::Text("Cur Used");
		ImGui::NextColumn();
		ImGui::Text("Total Available");
		ImGui::NextColumn();

		ImGui::Text("%.02fMB", MemDebugUtils::IntBytesToFltMB(MemoryStats.PeakUsedVirtual));
		ImGui::NextColumn();
		ImGui::Text("%.02fMB", MemDebugUtils::IntBytesToFltMB(MemoryStats.UsedVirtual));
		ImGui::NextColumn();
		ImGui::Text("%.02fMB", MemDebugUtils::IntBytesToFltMB(MemoryStats.TotalVirtual));
		ImGui::NextColumn();
		ImGui::Columns(1);
		ImGui::Separator();
	}

	if (ImGui::CollapsingHeader("Texture Memory"))
	{
		ImGui::Text("Currently Loaded Textures: "); ImGui::SameLine();
		enum ETextureListMode
		{
			All,
			Streaming,
			NonStreaming,
			Forced
		};
		static int TextureMode = 0;
		if (ImGui::RadioButton("All", TextureMode == ETextureListMode::All)) { TextureMode = ETextureListMode::All; } ImGui::SameLine();
		if (ImGui::RadioButton("Streaming", TextureMode == ETextureListMode::Streaming)) { TextureMode = ETextureListMode::Streaming; } ImGui::SameLine();
		if (ImGui::RadioButton("NonStreaming", TextureMode == ETextureListMode::NonStreaming)) { TextureMode = ETextureListMode::NonStreaming; } ImGui::SameLine();
		if (ImGui::RadioButton("Forced", TextureMode == ETextureListMode::Forced)) { TextureMode = ETextureListMode::Forced; } ImGui::SameLine();
		static bool bAlphaSort = false;
		ImGui::Checkbox("Alpha Sort", &bAlphaSort);
		ImGui::Separator();

		// Find out how many primitive components reference a texture.
		TMap<UTexture2D*, int32> TextureToUsageMap;
		for (TObjectIterator<UPrimitiveComponent> It; It; ++It)
		{
			UPrimitiveComponent* PrimitiveComponent = *It;

			// Use the existing texture streaming functionality to gather referenced textures. Worth noting
			// that GetStreamingTextureInfo doesn't check whether a texture is actually streamable or not
			// and is also implemented for skeletal meshes and such.
#if ENGINE_MAJOR_VERSION == 4
			ImGuiDebugToolsUtils::FStreamingTextureLevelContext LevelContext(EMaterialQualityLevel::Num, PrimitiveComponent);
#elif ENGINE_MAJOR_VERSION == 5
			FStreamingTextureLevelContext LevelContext(EMaterialQualityLevel::Num, PrimitiveComponent);
#endif
			TArray<FStreamingRenderAssetPrimitiveInfo> StreamingTextures;
			PrimitiveComponent->GetStreamingRenderAssetInfo((FStreamingTextureLevelContext&)LevelContext, StreamingTextures);

			//// Increase usage count for all referenced textures
			for (int32 TextureIndex = 0; TextureIndex < StreamingTextures.Num(); TextureIndex++)
			{
				UTexture2D* Texture = Cast<UTexture2D>(StreamingTextures[TextureIndex].RenderAsset);
				if (Texture)
				{
					// Initializes UsageCount to 0 if texture is not found.
					int32 UsageCount = TextureToUsageMap.FindRef(Texture);
					TextureToUsageMap.Add(Texture, UsageCount + 1);
				}
			}
		}
		int32 NumApplicableToMinSize = 0;
		// Collect textures.
		TArray<MemDebugUtils::FSortedTexture> SortedTextures;
		for (TObjectIterator<UTexture> It; It; ++It)
		{
			UTexture* Texture = *It;
			UTexture2D* Texture2D = Cast<UTexture2D>(Texture);
			UTextureCube* TextureCube = Cast<UTextureCube>(Texture);

			int32 LODGroup = Texture->LODGroup;
			int32 NumMips = 0;
			int32 MaxResLODBias = 0;
			int32 MaxAllowedSizeX = 0;
			int32 MaxAllowedSizeY = 0;
			EPixelFormat Format = PF_Unknown;
			int32 DroppedMips = 0;
			int32 CurSizeX = 0;
			int32 CurSizeY = 0;
			bool bIsStreamingTexture = false;
			int32 MaxAllowedSize = Texture->CalcTextureMemorySizeEnum(TMC_AllMipsBiased);
			int32 CurrentSize = Texture->CalcTextureMemorySizeEnum(TMC_ResidentMips);
			int32 UsageCount = 0;
			bool bIsForced = false;

			if (Texture2D != nullptr)
			{
				NumMips = Texture2D->GetNumMips();
				MaxResLODBias = NumMips - Texture2D->GetNumMipsAllowed(false);
				MaxAllowedSizeX = FMath::Max<int32>(Texture2D->GetSizeX() >> MaxResLODBias, 1);
				MaxAllowedSizeY = FMath::Max<int32>(Texture2D->GetSizeY() >> MaxResLODBias, 1);
				Format = Texture2D->GetPixelFormat();
				DroppedMips = Texture2D->GetNumMips() - Texture2D->GetNumResidentMips();
				CurSizeX = FMath::Max<int32>(Texture2D->GetSizeX() >> DroppedMips, 1);
				CurSizeY = FMath::Max<int32>(Texture2D->GetSizeY() >> DroppedMips, 1);
				bIsStreamingTexture = Texture2D->GetStreamingIndex() != INDEX_NONE;
				UsageCount = TextureToUsageMap.FindRef(Texture2D);
				bIsForced = Texture2D->ShouldMipLevelsBeForcedResident() && bIsStreamingTexture;

				if ((NumMips >= Texture2D->GetMinTextureResidentMipCount()) && bIsStreamingTexture)
				{
					NumApplicableToMinSize++;
				}
			}
			else if (TextureCube != nullptr)
			{
				NumMips = TextureCube->GetNumMips();
				Format = TextureCube->GetPixelFormat();
			}

			if (((TextureMode == ETextureListMode::Streaming) && bIsStreamingTexture) ||
				((TextureMode == ETextureListMode::NonStreaming) && !bIsStreamingTexture) ||
				((TextureMode == ETextureListMode::Forced) && bIsForced) ||
				(TextureMode == ETextureListMode::All))
			{
				new (SortedTextures) MemDebugUtils::FSortedTexture(MaxAllowedSizeX, MaxAllowedSizeY, Format, CurSizeX, CurSizeY, MaxResLODBias, MaxAllowedSize, CurrentSize,
													Texture->GetPathName(), LODGroup, bIsStreamingTexture, UsageCount);
			}
		}

		// Retrieve mapping from LOD group enum value to text representation.
		TArray<FString> TextureGroupNames = UTextureLODSettings::GetTextureGroupNames();

		TArray<uint64> TextureGroupCurrentSizes;
		TArray<uint64> TextureGroupMaxAllowedSizes;

		TArray<uint64> FormatCurrentSizes;
		TArray<uint64> FormatMaxAllowedSizes;

		TextureGroupCurrentSizes.AddZeroed(TextureGroupNames.Num());
		TextureGroupMaxAllowedSizes.AddZeroed(TextureGroupNames.Num());

		FormatCurrentSizes.AddZeroed(PF_MAX);
		FormatMaxAllowedSizes.AddZeroed(PF_MAX);

		// Display.
		uint64 TotalMaxAllowedSize = 0;
		uint64 TotalCurrentSize = 0;
		ImGui::BeginChild("TextureList", ImVec2(0, 500.0f));

		// Sort textures by cost.
		SortedTextures.Sort(MemDebugUtils::FCompareFSortedTexture(bAlphaSort));

		ImGui::Columns(7);
		static float ColumnWidths[7];
		for (int i = 0; i <= 6; ++i)
		{
			ImGui::SetColumnWidth(i, ColumnWidths[i]);
		}
		ImGui::Text("OnDisk: Size, Bias- W x H"); ImGui::NextColumn();
		ImGui::Text("InMem: Size- W x H"); ImGui::NextColumn();
		ImGui::Text("Format"); ImGui::NextColumn();
		ImGui::Text("LODGroup"); ImGui::NextColumn();
		ImGui::Text("Name"); ImGui::NextColumn();
		ImGui::Text("Streaming"); ImGui::NextColumn();
		ImGui::Text("Usage Count"); ImGui::NextColumn();
		ImGui::Columns(1);
		ImGui::Separator();
		ImGui::BeginChild("TextureListContents", ImVec2(0, ImGui::GetFrameHeight() - 60.0f));
		ImGui::Columns(7);
		for (int32 TextureIndex = 0; TextureIndex < SortedTextures.Num(); TextureIndex++)
		{
			const MemDebugUtils::FSortedTexture& SortedTexture = SortedTextures[TextureIndex];
			const bool bValidTextureGroup = TextureGroupNames.IsValidIndex(SortedTexture.LODGroup);

			FString AuthoredBiasString(TEXT("?"));
			if (!FPlatformProperties::RequiresCookedData())
			{
				AuthoredBiasString.Empty();
				AuthoredBiasString.AppendInt(SortedTexture.LODBias);
			}
			ImGui::Text(" %i KB, %s- %ix%i", (SortedTexture.MaxAllowedSize + 512) / 1024, Ansi(*AuthoredBiasString), SortedTexture.MaxAllowedSizeX, SortedTexture.MaxAllowedSizeY); ImGui::NextColumn();
			ImGui::Text("%i KB- %ix%i", (SortedTexture.CurrentSize + 512) / 1024, SortedTexture.CurSizeX, SortedTexture.CurSizeY); ImGui::NextColumn();
			ImGui::Text("%s", Ansi(GetPixelFormatString(SortedTexture.Format))); ImGui::NextColumn();
			ImGui::Text("%s", bValidTextureGroup ? Ansi(*TextureGroupNames[SortedTexture.LODGroup]) : "INVALID"); ImGui::NextColumn();
			ImGui::Text("%s", Ansi(*SortedTexture.Name)); ImGui::NextColumn();
			ImGui::Text("%s", SortedTexture.bIsStreaming ? "YES" : "NO"); ImGui::NextColumn();
			ImGui::Text("%i", SortedTexture.UsageCount); ImGui::NextColumn();

			if (bValidTextureGroup)
			{
				TextureGroupCurrentSizes[SortedTexture.LODGroup] += SortedTexture.CurrentSize;
				TextureGroupMaxAllowedSizes[SortedTexture.LODGroup] += SortedTexture.MaxAllowedSize;
			}

			if (SortedTexture.Format >= 0 && SortedTexture.Format < PF_MAX)
			{
				FormatCurrentSizes[SortedTexture.Format] += SortedTexture.CurrentSize;
				FormatMaxAllowedSizes[SortedTexture.Format] += SortedTexture.MaxAllowedSize;
			}

			TotalMaxAllowedSize += SortedTexture.MaxAllowedSize;
			TotalCurrentSize += SortedTexture.CurrentSize;
		}
		for (int i = 0; i <= 6; ++i)
		{
			ColumnWidths[i] = ImGui::GetColumnWidth(i);
		}
		ImGui::Columns(1);
		ImGui::EndChild(); // "TextureListContents"

		ImGui::Separator();
		ImGui::Columns(4);
		ImGui::Text("Total OnDisk"); ImGui::NextColumn();
		ImGui::Text("Total InMem"); ImGui::NextColumn();
		ImGui::Text("Count"); ImGui::NextColumn();
		ImGui::Text("CountApplicableToMin"); ImGui::NextColumn();

		ImGui::Text("%.2f MB", (double)TotalMaxAllowedSize / 1024. / 1024.); ImGui::NextColumn();
		ImGui::Text("%.2f MB", (double)TotalCurrentSize / 1024. / 1024.); ImGui::NextColumn();
		ImGui::Text("%d", SortedTextures.Num()); ImGui::NextColumn();
		ImGui::Text("%d", NumApplicableToMinSize); ImGui::NextColumn();

		ImGui::Columns(1);
		ImGui::EndChild(); // "TextureList"
	}


	if (ImGui::CollapsingHeader("Object Memory"))
	{
		static MemDebugUtils::EMemSortType::Type SortMode = MemDebugUtils::EMemSortType::TotalMem;
		static MemDebugUtils::FCachedClassTree CachedClassTree;
		static bool IncludeCDO = false;
		CachedClassTree.TryCacheEntries();
		static EResourceSizeMode::Type ResourceSizeMode = EResourceSizeMode::EstimatedTotal;
		ImGui::Columns(3);
		if (ImGui::Button("Update (SLOW!)"))
		{
			CachedClassTree.UpdateMemoryStats(IncludeCDO, ResourceSizeMode);
			CachedClassTree.SortBy(SortMode);
		}

		static bool AutoUpdateOnStale = true;
		ImGui::Checkbox("Update on Stale", &AutoUpdateOnStale);
		ImGui::BeginChild("##ResourceSizeModeComboMain", ImVec2(210.0f, 18.0f));
		static int ResourceSizeModeComboValue = static_cast<int>(ResourceSizeMode);
		ImGui::Combo("##ResourceSizeModeCombo", &ResourceSizeModeComboValue, "Exclusive\0Estimated Total");
		ResourceSizeMode = static_cast<EResourceSizeMode::Type>(ResourceSizeModeComboValue);
		ImGui::EndChild();
		ImGui::SetColumnWidth(0, 150.0f);
		ImGui::NextColumn();
		ImGui::Text("Include/Sort:");
		ImGui::BeginChild("IncSort", ImVec2(0.0f, 90.0f));
		ImGui::Columns(2);
		static const float RadWidth = 54.0f;
		static ImGuiTools::Utils::FShowCols ShowCols(MemDebugUtils::EColumnTypes::COUNT, &MemDebugUtils::EColumnTypes::DefaultVisibility[0]);
		ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::IsDefaultObject) = false;
		ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::Outer) = false;

		ImGui::SameLine(27.0f);
		if (ImGui::RadioButton("##Alpha", SortMode == MemDebugUtils::EMemSortType::Alpha)) { SortMode = MemDebugUtils::EMemSortType::Alpha; CachedClassTree.SortBy(SortMode); } ImGui::SameLine();
		ImGui::Text("Alpha"); ImGui::NextColumn();

		ImGui::Checkbox("##InstancesCh", &ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::Instances)); ImGui::SameLine();
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::Instances))
		{	if (ImGui::RadioButton("##Instances", SortMode == MemDebugUtils::EMemSortType::Instances)) { SortMode = MemDebugUtils::EMemSortType::Instances; CachedClassTree.SortBy(SortMode); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("Instances"); ImGui::NextColumn();

		ImGui::Checkbox("##TotalMemCh", &ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::TotalMem)); ImGui::SameLine();
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::TotalMem))
		{ if (ImGui::RadioButton("##TotalMem", SortMode == MemDebugUtils::EMemSortType::TotalMem)) { SortMode = MemDebugUtils::EMemSortType::TotalMem; CachedClassTree.SortBy(SortMode); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("TotalMem"); ImGui::NextColumn();

		ImGui::Checkbox("##UnknownMemCh", &ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::UnknownMem)); ImGui::SameLine();
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::UnknownMem))
		{	if (ImGui::RadioButton("##UnknownMem", SortMode == MemDebugUtils::EMemSortType::UnknownMem)) { SortMode = MemDebugUtils::EMemSortType::UnknownMem; CachedClassTree.SortBy(SortMode); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("UnknownMem"); ImGui::NextColumn();

		ImGui::Checkbox("##DedSysMemCh", &ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::DedSysMem)); ImGui::SameLine();
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::DedSysMem))
		{	if (ImGui::RadioButton("##DedSysMem", SortMode == MemDebugUtils::EMemSortType::DedSysMem)) { SortMode = MemDebugUtils::EMemSortType::DedSysMem; CachedClassTree.SortBy(SortMode); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("DedSysMem"); ImGui::NextColumn();

		ImGui::Checkbox("##DedVidMemCh", &ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::DedVidMem)); ImGui::SameLine();
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::DedVidMem))
		{	if (ImGui::RadioButton("##DedVidMem", SortMode == MemDebugUtils::EMemSortType::DedVidMem)) { SortMode = MemDebugUtils::EMemSortType::DedVidMem; CachedClassTree.SortBy(SortMode); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("DedVidMem"); ImGui::NextColumn();

		ImGui::Checkbox("##SharedSysMemCh", &ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::SharedSysMem)); ImGui::SameLine();
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::SharedSysMem))
		{	if (ImGui::RadioButton("##SharedSysMem", SortMode == MemDebugUtils::EMemSortType::SharedSysMem)) { SortMode = MemDebugUtils::EMemSortType::SharedSysMem; CachedClassTree.SortBy(SortMode); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("SharedSysMem"); ImGui::NextColumn();

		ImGui::Checkbox("##SharedVidMemCh", &ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::SharedVidMem)); ImGui::SameLine();
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::SharedVidMem))
		{	if (ImGui::RadioButton("##SharedVidMem", SortMode == MemDebugUtils::EMemSortType::SharedVidMem)) { SortMode = MemDebugUtils::EMemSortType::SharedVidMem; CachedClassTree.SortBy(SortMode); } ImGui::SameLine(); }
		else { ImGui::SameLine(RadWidth); }
		ImGui::Text("SharedVidMem"); ImGui::NextColumn();

		ImGui::Columns(1);
		ImGui::EndChild(); // "IncSort"
		ImGui::SetColumnWidth(1, 330.0f);
		ImGui::NextColumn();
		static ImGuiTextFilter ClassNameFilter;
		static bool FilterZeroInstances = false;
		ClassNameFilter.Draw("Name Filter", ImGui::GetColumnWidth() - 100.0f);
		ImGui::Checkbox("Filter 0 instances", &FilterZeroInstances);
		ImGui::Checkbox("Include CDO", &IncludeCDO);
		ImGui::Columns(1);
		
		ImGui::BeginChild("ClassListHeader", ImVec2(0, 30.0f), true);
		static constexpr int ColumnCount = 8;
		const int VisibleColCount = ShowCols.CacheShowColCount() + 1;
		ImGui::Columns(VisibleColCount, "ObjMemCol");
		static float ColumnWidths[ColumnCount];
		static constexpr float InfoColWidth = 110.0f;
		ColumnWidths[0] = ImGui::GetWindowWidth() - (InfoColWidth * (VisibleColCount - 1));
		if (VisibleColCount > 1)
		{
			for (int i = 0; i < VisibleColCount; ++i)
			{
				if (i > 0)
				{
					ColumnWidths[i] = InfoColWidth;
				}
				ImGui::SetColumnWidth(i, ColumnWidths[i]);
			}
		}
		ImGui::Text("Class"); ImGui::NextColumn();
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::Instances)) { ImGui::Text("InstanceCount"); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::TotalMem)) { ImGui::Text("Total Mem"); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::UnknownMem)) { ImGui::Text("Unknown Mem"); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::DedSysMem)) { ImGui::Text("DedSys Mem"); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::DedVidMem)) { ImGui::Text("DedVid Mem"); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::SharedSysMem)) { ImGui::Text("SharedSys Mem"); ImGui::NextColumn(); }
		if (ShowCols.GetShowCol(MemDebugUtils::EColumnTypes::SharedVidMem)) { ImGui::Text("SharedVid Mem"); ImGui::NextColumn(); }
		ImGui::Columns(1);
		ImGui::EndChild(); // "ClassListHeader"

		ImGui::BeginChild("ClassList", ImVec2(0, 350.0f), true);
		ImGui::Columns(VisibleColCount, "ObjMemCol");
		if (VisibleColCount > 1)
		{
			for (int i = 0; i < VisibleColCount; ++i)
			{
				ImGui::SetColumnWidth(i, ColumnWidths[i]);
			}
		}
		
		if (!MemDebugUtils::DrawClassChildTreeIndex(CachedClassTree, CachedClassTree.RootIndex, FilterZeroInstances, ClassNameFilter, ShowCols))
		{
			if (AutoUpdateOnStale)
			{
				// Update on Stale will be slow, but will run full memory stats when class data goes stale.
				CachedClassTree.UpdateMemoryStats(IncludeCDO, ResourceSizeMode);
			}
			else
			{
				// If not auto updating, at least re-fetch Class data, which is quick and allows us to show something
				CachedClassTree.TryCacheEntries(/*ForceRecache*/ true);
			}

			// re-sort
			CachedClassTree.SortBy(SortMode);
		}
		ImGui::Columns(1);

		ImGui::EndChild(); // "ClassList"
	}
}

void FImGuiMemoryDebugger::UpdateTool(float DeltaTime)
{
	FImGuiToolWindow::UpdateTool(DeltaTime);

	for (int i = MemDebugUtils::InstanceInspectors.Num() - 1; i >= 0; --i)
	{
		MemDebugUtils::FInstanceInspectorInfo& InstInsp = MemDebugUtils::InstanceInspectors[i];
		if (InstInsp.Class.IsStale() || !InstInsp.Class.IsValid())
		{
			MemDebugUtils::InstanceInspectors.RemoveAt(i);
			continue;
		}

		const FString& InspName = FString::Printf(TEXT("Insp-%.25ls"), *InstInsp.Class->GetName());
		bool WindowOpen = true;
		if (ImGui::Begin(Ansi(*InspName), &WindowOpen))
		{
			MemDebugUtils::DrawObjectInspectorPopup(InstInsp, DeltaTime);
			ImGui::End();
		}

		if (!WindowOpen)
		{
			MemDebugUtils::InstanceInspectors.RemoveAt(i);
		}
	}
}

```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiMemoryDebugger.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include "ImGuiToolWindow.h"

class IMGUITOOLS_API FImGuiMemoryDebugger : public FImGuiToolWindow
{
public:
	FImGuiMemoryDebugger();
	virtual ~FImGuiMemoryDebugger() = default;

	// FImGuiToolWindow Interface
	virtual void ImGuiUpdate(float DeltaTime) override;
	virtual void UpdateTool(float DeltaTime) override;
	// FImGuiToolWindow Interface
};
```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiShaderCompilationInfo.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiShaderCompilationInfo.h"

#include "Utils/ImGuiUtils.h"

#include <ShaderCompiler.h>

#include <imgui.h>

FImGuiShaderCompilationInfo::FImGuiShaderCompilationInfo()
{
	ToolName = TEXT("Shader Compilation Info");
    WindowFlags = ImGuiWindowFlags_MenuBar;
}

void FImGuiShaderCompilationInfo::ImGuiUpdate(float DeltaTime)
{
    ImGui::Text("Shader Compilation Info");

    if (ImGui::CollapsingHeader("Shader Comp Manager", ImGuiTreeNodeFlags_DefaultOpen))
	{
    	ImGui::Text("  * GetStaticAssetTypeName:			%s", Ansi(*GShaderCompilingManager->GetStaticAssetTypeName().ToString()));
    	ImGui::Text("  * IsCompiling:					%d", GShaderCompilingManager->IsCompiling());
    	ImGui::Text("  * HasShaderJobs:					%d", GShaderCompilingManager->HasShaderJobs());
    	ImGui::Text("  * IsShaderCompilationSkipped:		%d", GShaderCompilingManager->IsShaderCompilationSkipped());
    	ImGui::Text("  * GetNumLocalWorkers:				%d", GShaderCompilingManager->GetNumLocalWorkers());
    	ImGui::Text("  * GetNumOutstandingJobs:			%d", GShaderCompilingManager->GetNumOutstandingJobs());
    	ImGui::Text("  * GetNumPendingJobs:				%d", GShaderCompilingManager->GetNumPendingJobs());
    	ImGui::Text("  * GetNumRemainingJobs:			%d", GShaderCompilingManager->GetNumRemainingJobs());
    	ImGui::Text("  * ShouldDisplayCompilingNotification:		%d", GShaderCompilingManager->ShouldDisplayCompilingNotification());	
	}

	if (ImGui::CollapsingHeader("Shader Comp Stats", ImGuiTreeNodeFlags_DefaultOpen))
	{
		//ImGui::Text("  * GetTimeShaderCompilationWasActive:		% .02f", GShaderCompilerStats->GetTimeShaderCompilationWasActive());
		//ImGui::Text("  * GetTotalShadersCompiled:				%d", GShaderCompilerStats->GetTotalShadersCompiled());
		// ImGui::Text("  * GetDDCHits:					%d", GShaderCompilerStats->GetDDCHits());
		// ImGui::Text("  * GetDDCMisses:				%d", GShaderCompilerStats->GetDDCMisses());

		const TSparseArray<FShaderCompilerStats::ShaderCompilerStats>& ShaderCompStats = GShaderCompilerStats->GetShaderCompilerStats();
		const int NumShaderCompStats = ShaderCompStats.Num();
		int CurShaderCompStat = 0;
		for (const FShaderCompilerStats::ShaderCompilerStats& ShaderCompStat : ShaderCompStats)
		{
			const int NumShaderCompStatMap = ShaderCompStat.Num();
			ImGui::Text("  ShaderCompStat %02d / %02d - map size: %02d", ++CurShaderCompStat, NumShaderCompStats, NumShaderCompStatMap);
#if (ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION <= 4)
			// NOTE (tim): This stuff changed significantly in UE 5.5 so excluding it there until it can get some love.
			for (const TPair<FString, FShaderCompilerStats::FShaderStats>& ShaderStatEntry : ShaderCompStat)
			{
				ImGui::Text("      key %s - compiled: %d (d: %d) - cooked: %d (d: %d) - compile time: % .04f - perms: %d", Ansi(*ShaderStatEntry.Key), ShaderStatEntry.Value.Compiled, ShaderStatEntry.Value.CompiledDouble, ShaderStatEntry.Value.Cooked, ShaderStatEntry.Value.CookedDouble, ShaderStatEntry.Value.CompileTime, ShaderStatEntry.Value.PermutationCompilations.Num());
				for (const FShaderCompilerStats::FShaderCompilerSinglePermutationStat& PermStat : ShaderStatEntry.Value.PermutationCompilations)
				{
					ImGui::Text("            perm: %s - compiled: %d (d: %d) - cooked: %d (d: %d)", Ansi(*PermStat.PermutationString), PermStat.Compiled, PermStat.CompiledDouble, PermStat.Cooked, PermStat.CookedDouble);
				}
			}
#endif
		}
	}
}

```

`ImGuiTools/Source/ImGuiTools/Private/Tools/ImGuiShaderCompilationInfo.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include "ImGuiToolWindow.h"

class IMGUITOOLS_API FImGuiShaderCompilationInfo : public FImGuiToolWindow
{
public:
	FImGuiShaderCompilationInfo();
	virtual ~FImGuiShaderCompilationInfo() = default;

	// FImGuiToolWindow Interface
	virtual void ImGuiUpdate(float DeltaTime) override;
	// FImGuiToolWindow Interface
};
```

`ImGuiTools/Source/ImGuiTools/Private/Utils/ClassHierarchyInfo.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "Utils/ClassHierarchyInfo.h"

#include "Utils/ImGuiUtils.h"

#include "AssetRegistry/AssetRegistryModule.h"
#include "Engine/Blueprint.h"
#include "Runtime/Launch/Resources/Version.h"
#include "UObject/UObjectIterator.h"

namespace ClassHierarchyUtil
{
	void CreateAndSortLoadedHierarchy(ImGuiTools::FHierarchicalClassInfo& ClassInfo, TArray<UClass*>& LoadedClasses)
	{
		for (UClass* PotentialChildClass : LoadedClasses)
		{
			if (PotentialChildClass && (PotentialChildClass->GetSuperClass() == ClassInfo.mClass.Get()))
			{
				ImGuiTools::FHierarchicalClassInfo& ChildClassInfo = ClassInfo.mLoadedChildren.AddDefaulted_GetRef();
				ChildClassInfo.mClass = PotentialChildClass;

				CreateAndSortLoadedHierarchy(ChildClassInfo, LoadedClasses);
			}
		}

		// Sort child classes alphabetically
		ClassInfo.mLoadedChildren.Sort([](const ImGuiTools::FHierarchicalClassInfo& A, const ImGuiTools::FHierarchicalClassInfo& B) {
			return A.mClass->GetFName().Compare(B.mClass->GetFName()) < 0;
		});
	}

	bool InsertIntoChildOrSelf(ImGuiTools::FHierarchicalClassInfo& ClassInfo, ImGuiTools::FHierarchicalClassInfo::UnloadedClassInfo& UnloadedClass, IAssetRegistry& AssetRegistry)
	{
		// for this unloaded class, see if class info class is an ancestor, if so, see if any children are as well first to claim ownership.
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
		TArray<FTopLevelAssetPath> AncestorNames;
		AssetRegistry.GetAncestorClassNames(UnloadedClass.ClassAssetPath, AncestorNames);

		if (AncestorNames.Contains(ClassInfo.mClass->GetClassPathName()))
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
        TArray<FName> AncestorNames;
        AssetRegistry.GetAncestorClassNames(FName(UnloadedClass.ClassName), AncestorNames);

        if (AncestorNames.Contains(ClassInfo.mClass->GetFName()))
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
		{
			// check for child inheritance first
			bool ChildInherited = false;
			for (ImGuiTools::FHierarchicalClassInfo& ChildClassInfo : ClassInfo.mLoadedChildren)
			{
				ChildInherited |= InsertIntoChildOrSelf(ChildClassInfo, UnloadedClass, AssetRegistry);
			}

			if (!ChildInherited)
			{
				// No children claimed, so claim it for this class.
				ClassInfo.mUnloadedChildren.Add(UnloadedClass);
				return true;
			}
			return ChildInherited;
		}

		return false;
	}

	void SortUnloadedHierarchy(ImGuiTools::FHierarchicalClassInfo& ClassInfo, TArray<ImGuiTools::FHierarchicalClassInfo::UnloadedClassInfo>& UnloadedClasses, IAssetRegistry& AssetRegistry)
	{
		for (ImGuiTools::FHierarchicalClassInfo::UnloadedClassInfo& UnloadedClass : UnloadedClasses)
		{
			InsertIntoChildOrSelf(ClassInfo, UnloadedClass, AssetRegistry);
		}
	}

	// Cache ClassInfo Descendant Count of self and all descendants, returning the count for the current classinfo
	int CacheUnloadedDescendantCounts(ImGuiTools::FHierarchicalClassInfo& ClassInfo)
	{
		int DescendantCount = 0;
		for (ImGuiTools::FHierarchicalClassInfo& LoadedChild : ClassInfo.mLoadedChildren)
		{
			DescendantCount += CacheUnloadedDescendantCounts(LoadedChild);
		}
		DescendantCount += ClassInfo.mUnloadedChildren.Num();
		ClassInfo.mCachedAllUnloadedDecendants = DescendantCount;
		return DescendantCount;
	}
}

void ImGuiTools::FHierarchicalClassInfo::LoadChildren(bool LoadAllDescendants /*= true*/)
{
	if (LoadAllDescendants)
	{
		for (ImGuiTools::FHierarchicalClassInfo& LoadedChildInfo : mLoadedChildren)
		{
			LoadedChildInfo.LoadChildren(LoadAllDescendants);
		}
	}

	for (ImGuiTools::FHierarchicalClassInfo::UnloadedClassInfo& UnloadedChildInfo : mUnloadedChildren)
	{
		UnloadedChildInfo.SoftClassInfo.LoadSynchronous();
	}
}

// Reset the view to this root class
void ImGuiTools::FHierarchicalRootClassInfo::ResetToRootClass(UClass* RootClass, FString SearchDirectory /*= FString(TEXT("/Game/"))*/)
{
	// Set desired parameters then reset()
	mSearchDirectory = SearchDirectory;
	mRootClassInfo.mClass = RootClass;

	Reset();
}
// Reset to the currently selected root class
void ImGuiTools::FHierarchicalRootClassInfo::Reset()
{
	mRootClassInfo.mLoadedChildren.Empty();
	mRootClassInfo.mUnloadedChildren.Empty();
	mRootClassInfo.mCachedAllUnloadedDecendants = 0;

	// Load the asset registry module
	FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(FName("AssetRegistry"));
	IAssetRegistry& AssetRegistry = AssetRegistryModule.Get();
	// The asset registry is populated asynchronously at startup, so there's no guarantee it has finished.
	// This simple approach just runs a synchronous scan on the entire content directory.
	TArray<FString> PathsToScan;
	PathsToScan.Add(mSearchDirectory);
	AssetRegistry.ScanPathsSynchronous(PathsToScan);

	TArray<UClass*>                                                 LoadedClasses;
	TArray<ImGuiTools::FHierarchicalClassInfo::UnloadedClassInfo>   UnloadedClasses;

	// Gather Native classes, they are loaded already
	for (TObjectIterator< UClass > ClassIt; ClassIt; ++ClassIt)
	{
		UClass* Class = *ClassIt;

		// Only interested in native C++ classes
		if (!Class->IsNative())
		{
			continue;
		}

		// Ignore deprecated
		if (Class->HasAnyClassFlags(CLASS_Deprecated | CLASS_NewerVersionExists))
		{
			continue;
		}

		// Check this class is a subclass of Base
		if (!Class->IsChildOf(mRootClassInfo.mClass.Get()))
		{
			continue;
		}

		LoadedClasses.Add(Class);
	}

	// Get all BP Classes
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
	TSet<FTopLevelAssetPath> DerivedNames;
	{
		TArray<FTopLevelAssetPath> BaseNames;

        BaseNames.Add(mRootClassInfo.mClass->GetClassPathName());

		TSet<FTopLevelAssetPath> Excluded;
		AssetRegistry.GetDerivedClassNames(BaseNames, Excluded, DerivedNames);
	}
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
    TSet<FName> DerivedNames;
    {
        TArray<FName> BaseNames;
        BaseNames.Add(mRootClassInfo.mClass->GetFName());

        TSet<FName> Excluded;
        AssetRegistry.GetDerivedClassNames(BaseNames, Excluded, DerivedNames);
    }
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1

	// Get all assets in the path, does not load them
	TArray<FAssetData> ScriptAssetList;
	AssetRegistry.GetAssetsByPath(*mSearchDirectory, ScriptAssetList, /*bRecursive=*/true);

	// Iterate through all assets and find the appropriate ones.
	for (const FAssetData& Asset : ScriptAssetList)
	{
		if (UClass* Class = Asset.GetClass())
		{
			if (Class == UBlueprint::StaticClass())
			{
				FString GeneratedClassPath;
				if (Asset.GetTagValue(TEXT("GeneratedClass"), GeneratedClassPath))
				{
					// Get class name and object path.
					const FString ClassObjectPath = FPackageName::ExportTextPathToObjectPath(*GeneratedClassPath);
					const FString ClassName = FPackageName::ObjectPathToObjectName(ClassObjectPath);

#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
                    FTopLevelAssetPath BaseNameAssetPath;
                    BaseNameAssetPath.TrySetPath(ClassObjectPath);

					if (DerivedNames.Contains(BaseNameAssetPath))
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
                    if (DerivedNames.Contains(*ClassName))
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
					{
						TSoftClassPtr<UObject> AssetSubClass = TSoftClassPtr<UObject>(FSoftObjectPath(ClassObjectPath));
						if (UClass* SubClassUClass = Cast<UClass>(AssetSubClass.Get()))
						{
							// Loaded classes have UClass available already.
							LoadedClasses.Add(SubClassUClass);
						}
						else
						{
							// Unloaded classes, we store a copy to the soft class ptr for loading later
							ImGuiTools::FHierarchicalClassInfo::UnloadedClassInfo& UnloadedClassInfo = UnloadedClasses.AddDefaulted_GetRef();
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
							UnloadedClassInfo.ClassAssetPath    = BaseNameAssetPath;
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
                            UnloadedClassInfo.ClassName         = ClassName;
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
							UnloadedClassInfo.SoftClassInfo     = AssetSubClass;
						}
					}
				}
			}
		}
	}

	// We should have all loaded and unloaded subclasses. Build hierarchy with loaded classes first, then find unloaded parents.
	ClassHierarchyUtil::CreateAndSortLoadedHierarchy(mRootClassInfo, LoadedClasses);
	ClassHierarchyUtil::SortUnloadedHierarchy(mRootClassInfo, UnloadedClasses, AssetRegistry);

	// Cache descendant count
	ClassHierarchyUtil::CacheUnloadedDescendantCounts(mRootClassInfo);
}

////// Drawing helper functions
void ImGuiTools::DrawClassHierarchy(UObject* Obj, UClass* TerminatingParentClass /*= UObject::StaticClass()*/)
{
	UClass* CurClass = Obj->GetClass();
	TArray<UClass*> ClassHierarchy;
	ClassHierarchy.Add(CurClass);
	while (CurClass && CurClass != TerminatingParentClass)
	{
		CurClass = CurClass->GetSuperClass();
		ClassHierarchy.Add(CurClass);
	}

	int j = 0;
	for (int i = ClassHierarchy.Num() - 1; i >= 0; --i)
	{
		if (UClass* Class = ClassHierarchy[i])
		{
			const bool FirstEntry = (j++ == 0);
			if (FirstEntry)
			{
				ImGui::Text("%s", Ansi(*Class->GetName()));
			}
			else
			{
				ImGui::NewLine();
				ImGui::SameLine(j * 8);
				ImGui::Text("|-> %s", Ansi(*Class->GetName()));
			}
		}
	}
}

```

`ImGuiTools/Source/ImGuiTools/Private/Utils/ImGuiUtils.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "Utils/ImGuiUtils.h"

#include "GameplayTagContainer.h"
#if (ENGINE_MAJOR_VERSION > 5) || (ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 5)
#include "StructUtils/InstancedStruct.h"
#else
#include "InstancedStruct.h"
#endif

ImGuiTools::Utils::FShowCols::FShowCols(int ColCount, bool* OptionalDefaultColArray /*= nullptr*/)
{
	if (ColCount > MAX_COLUMNS)
	{
		// horrible error!
	}

	TotalShowColCount = ColCount;
	CachedShowColCount = 0;
	for (int i = 0; i < TotalShowColCount; ++i)
	{
		ShowColFlags[i] = (OptionalDefaultColArray == nullptr) ? 0 : OptionalDefaultColArray[i];
	}
}

bool& ImGuiTools::Utils::FShowCols::GetShowCol(int ColIndex)
{
	// error if ColIndex out of bounds?
	return ShowColFlags[ColIndex];
}

int ImGuiTools::Utils::FShowCols::CacheShowColCount()
{
	CachedShowColCount = 0;
	for (int i = 0; i < TotalShowColCount; ++i)
	{
		if (ShowColFlags[i])
		{
			++CachedShowColCount;
		}
	}
	return CachedShowColCount;
}

int ImGuiTools::Utils::FShowCols::GetCachedShowColCount()
{
	return CachedShowColCount;
}

void ImGuiTools::Utils::FWorldCache::TryCacheWorlds()
{
    // Remove any Worlds that may now be invalid.
    CachedWorlds.RemoveAll([](const TWeakObjectPtr<UWorld>& World) {
        return !IsValid(World.Get());
    });

    // What types of worlds to display: 
    static const auto WorldShouldDisplay = [](UWorld* World)
    {
        return (IsValid(World) && !World->HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject) && World->bIsWorldInitialized
            && (World->WorldType != EWorldType::Editor) && (World->WorldType != EWorldType::EditorPreview));
    };

    for (TObjectIterator<UWorld> It; It; ++It)
    {
        UWorld* World = *It;
        if (!WorldShouldDisplay(World))
        {
            continue;
        }

        // if this is a new world, add a new cached world actor object.
        if (!CachedWorlds.ContainsByPredicate([World](const TWeakObjectPtr<UWorld>& CachedWorldWeakPtr) { return (CachedWorldWeakPtr.Get() == World); }))
        {
            CachedWorlds.Add(TWeakObjectPtr<UWorld>(World));
        }
    }
}

void ImGuiTools::Utils::DrawInstancedStructTable(const char* StringId, const FInstancedStruct& InstancedStruct, ImVec2 Size /*= ImVec2(0,0)*/, bool DoTreeNode /*= false*/)
{
	if (!InstancedStruct.IsValid())
	{
		return;
	}


	const bool TreeNodeOpen = DoTreeNode && ImGui::TreeNode(StringId);
	
	static constexpr ImGuiTableFlags flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_RowBg | ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable;
	if (!DoTreeNode || TreeNodeOpen)
	{
		ImGui::BeginChild(ImGui::GetID(InstancedStruct.GetMemory()), Size);

		if (ImGui::BeginTable("PropertyTable", 2, flags))
		{
			ImGui::TableSetupColumn("Property", ImGuiTableColumnFlags_WidthFixed);
			ImGui::TableSetupColumn("Value", ImGuiTableColumnFlags_WidthStretch);

			const void* ItemDataMem = static_cast<const void*>(InstancedStruct.GetMemory());

			for (FProperty* Prop : TFieldRange<FProperty>(InstancedStruct.GetScriptStruct()))
			{
				if (Prop)
				{

					ImGui::TableNextColumn();
					ImGui::Text("%s", Ansi(*Prop->GetName()));
					ImGui::Text("%s", Ansi(*Prop->GetClass()->GetName()));
					ImGui::TableNextColumn();

					DrawPropertyValue(Prop, ItemDataMem);
				}
			}
										
			ImGui::EndTable();
			ImGui::EndChild();
		}
	}

	if (TreeNodeOpen)
	{
		ImGui::TreePop();
	}
}

void ImGuiTools::Utils::DrawPropertyValue(const FProperty* Prop, const void* Obj)
{
	const void* ObjValuePtr = Prop->ContainerPtrToValuePtr<void>(Obj);

	if (Prop->IsA(FBoolProperty::StaticClass()))
	{
		const bool Value = *(const bool*)ObjValuePtr;
		ImGui::Text(Value ? "true" : "false");
	}
	else if (Prop->IsA(FFloatProperty::StaticClass()) ||
		Prop->IsA(FDoubleProperty::StaticClass()))
	{
		const float Value = *(const float*)ObjValuePtr;
		ImGui::Text("% .05f", Value);
	}
	else if (Prop->IsA(FIntProperty::StaticClass()))
	{
		const int32 Value = *(const int32*)ObjValuePtr;
		ImGui::Text("% d", Value);
	}
	else if (Prop->IsA(FInt64Property::StaticClass()))
	{
		const int64 Value = *(const int64*)ObjValuePtr;
		ImGui::Text("% lld", Value);
	}
	else if (Prop->IsA(FNameProperty::StaticClass()))
	{
		const FName Value = *(const FName*)ObjValuePtr;
		ImGui::Text("%s", Ansi(*Value.ToString()));
	}
	else if (Prop->IsA(FStrProperty::StaticClass()))
	{
		const FString Value = *(const FString*)ObjValuePtr;
		ImGui::Text("%s", Ansi(*Value));
	}
	else if (Prop->IsA(FTextProperty::StaticClass()))
	{
		const FText& Value = *(const FText*)ObjValuePtr;
		ImGui::Text("%s", Ansi(*Value.ToString()));
	}
	else if (const FObjectProperty* ObjProp = CastField<FObjectProperty>(Prop))
	{
		UObject* ObjValue = ObjProp->GetObjectPropertyValue_InContainer(Obj);
		ImGui::Text("%s", ObjValue ? Ansi(*ObjValue->GetName()) : "*none*");
	}
	else if (const FWeakObjectProperty* WeakObjProp = CastField<FWeakObjectProperty>(Prop))
	{
		UObject* ObjValue = WeakObjProp->GetObjectPropertyValue_InContainer(Obj);
		ImGui::Text("%s", ObjValue ? Ansi(*ObjValue->GetName()) : "*none*");
	}
	else if (const FStructProperty* StructProp = CastField<FStructProperty>(Prop))
	{
		UScriptStruct* ScriptStruct = StructProp->Struct.Get();
		
		DrawScriptStructProperty(ScriptStruct, ObjValuePtr);
	}
	else if (const FArrayProperty* ArrayProp = CastField<FArrayProperty>(Prop))
	{
		if (FProperty* Inner = ArrayProp->Inner)
		{
			ImGui::BeginChild(ImGui::GetID(Prop), ImVec2(0, 80.0f), false);

			auto* ObjArray = ArrayProp->ContainerPtrToValuePtr<TArray<float>>(Obj);
		
			FString CPPType;
			ArrayProp->GetCPPType(&CPPType, 0);
			FName CPPTypeName(CPPType);
			const TFunction<void(int32, const void*)>* PrintItemFunc = nullptr;

			if (CPPTypeName == TEXT("<float>"))
			{
				static const TFunction<void(int32, const void*)> StaticConverstionFunction = [](int32 index, const void* VoidPtr) {
					const float* TypePtr = static_cast<const float*>(VoidPtr);
					ImGui::Text("%02d - % .03f", index, *TypePtr);
				};
				PrintItemFunc = &StaticConverstionFunction;
			}
			else if (CPPTypeName == TEXT("<uint8>"))
			{
				static const TFunction<void(int32, const void*)> StaticConverstionFunction = [](int32 index, const void* VoidPtr) {
					const uint8* TypePtr = static_cast<const uint8*>(VoidPtr);
					ImGui::Text("%02d - %2hhx", index, *TypePtr);
				};
				PrintItemFunc = &StaticConverstionFunction;
			}
			else if (CPPTypeName == TEXT("<UObject*>"))
			{
				static const TFunction<void(int32, const void*)> StaticConverstionFunction = [](int32 index, const void* VoidPtr) {
					//const UObject* TypePtr = static_cast<const UObject*>(VoidPtr);
					//ImGui::Text("%02d - %s", index, Ansi(*(*TypePtr)->GetName()));
				};
				PrintItemFunc = &StaticConverstionFunction;
			}
			
			// TODO - type size always reporting 4 with that auto.. but can get type size from the prop.. maybe cast to char size array and do multiples? 
			ImGui::Text("size: %d - type : %s - type size: %d - prop size: %d", ObjArray->Num(), Ansi(*CPPType), ObjArray->GetTypeSize(), (int)ArrayProp->GetMinAlignment());

			if (PrintItemFunc)
			{
				for (int i = 0; i < ObjArray->Num(); ++i)
				{
					auto& ArrayEntryData = (*ObjArray)[i];

					(*PrintItemFunc)(i, static_cast<const void*>(&ArrayEntryData));
				}
			}
			else
			{
				ImGui::Text(" type '%s' not implemented", Ansi(*CPPType));
			}
			
			ImGui::EndChild();
		}
		else
		{
			ImGui::Text("ARRAY. Inner Property not found :(");
		}
	}
	else if (const FMapProperty* MapProp = CastField<FMapProperty>(Prop))
	{
		ImGui::Text("MAP!! Not Implemented :(");
	}
	else if (const FSetProperty* SetProp = CastField<FSetProperty>(Prop))
	{
		ImGui::Text("SET!! Not Implemented :(");
	}
	else if (const FEnumProperty* ENumProp = CastField<FEnumProperty>(Prop))
	{
		if (UEnum* Enum = ENumProp->GetEnum())
		{
			const int64 Value = *(const int64*)ObjValuePtr;
			ImGui::Text("%s", Ansi(*FString::Printf(TEXT("(%d)%s::%s"), Value, *Enum->GetName(), *Enum->GetDisplayNameTextByValue(Value).ToString())));
		}
		else
		{
			ImGui::Text("ENUM not valid :(");
		}
	}
	else if (const FByteProperty* ByteProp = CastField<FByteProperty>(Prop))
	{
		const int64 Value = ((int64)(*(const int8*)ObjValuePtr));
		if (UEnum* Enum = ByteProp->Enum)
		{
			ImGui::Text("%s", Ansi(*FString::Printf(TEXT("(%d)%s::%s"), Value, *Enum->GetName(), *Enum->GetDisplayNameTextByValue(Value).ToString())));
		}
		else
		{
			ImGui::Text("% lld", Value);
		}
	}
	else if (const FDelegateProperty* DelegateProp = CastField<FDelegateProperty>(Prop))
	{
		if (UFunction* SignatureFunction = DelegateProp->SignatureFunction)
		{
			ImGui::Text("%s", Ansi(*SignatureFunction->GetName()));
		}
		else
		{
			ImGui::Text("Delegate has no signature function");
		}
	}
	else if (const FMulticastDelegateProperty* MultiDelegateProp = CastField<FMulticastDelegateProperty>(Prop))
	{
		//if (const FMulticastScriptDelegate* MultiDelegate = MultiDelegateProp->GetMulticastDelegate())
		//{

		//}
		ImGui::Text("MULTICAST DELEGATE!! Not Implemented :(");
	}
	else if (const FMulticastInlineDelegateProperty* MultiInlineDelegateProp = CastField<FMulticastInlineDelegateProperty>(Prop))
	{
		ImGui::Text("MULTICAST INLINE DELEGATE!! Not Implemented :(");
	}
	else if (const FMulticastSparseDelegateProperty* MultiSparseDelegateProp = CastField<FMulticastSparseDelegateProperty>(Prop))
	{
		ImGui::Text("MULTICAST SPARSE DELEGATE!! Not Implemented :(");
	}
	else
	{
		ImGui::Text("Unimplemented!");
	}
}

void ImGuiTools::Utils::DrawScriptStructProperty(const UScriptStruct* StructType, const void* Obj)
{
	if (StructType == FGameplayTag::StaticStruct())
	{
		const FGameplayTag& Value = *(const FGameplayTag*)Obj;
		ImGui::Text("FGameplayTag: \n%s", Ansi(*Value.ToString()));
	}
	else if (StructType == FGameplayTagContainer::StaticStruct())
	{
		const FGameplayTagContainer& Value = *(const FGameplayTagContainer*)Obj;
		ImGui::Text("FGameplayTagContainer: \n%s", Ansi(*Value.ToString()));
	}
	else if (StructType == FGameplayTagQuery::StaticStruct())
	{
		const FGameplayTagQuery& Value = *(const FGameplayTagQuery*)Obj;
		ImGui::Text("FGameplayTagQuery: \n%s", Ansi(*Value.GetDescription()));
	}
	else if (StructType == TBaseStructure<FVector>::Get())
	{
		const FVector& Value = *(const FVector*)Obj;
		ImGui::Text("FVector| \nx: %.03f, y: %.03f, z: %.03f", Value.X, Value.Y, Value.Z);
	}
	else if (StructType == TBaseStructure<FRotator>::Get())
	{
		const FRotator& Value = *(const FRotator*)Obj;
		ImGui::Text("FRotator| \np: %.03f, r: %.03f, y: %.03f", Value.Pitch, Value.Roll, Value.Yaw);
	}
	else if (StructType == TBaseStructure<FQuat>::Get())
	{
		const FQuat& Value = *(const FQuat*)Obj;
		ImGui::Text("FQuat| \nx: %.03f, y: %.03f, z: %.03f, w: % .03f", Value.X, Value.Y, Value.Z, Value.W);
	}
	else if (StructType == TBaseStructure<FTransform>::Get())
	{
		const FTransform& Value = *(const FTransform*)Obj;
		ImGui::Text("FTransform| loc| x:% .03f, y:% .03f, z:% .03f", Value.GetLocation().X, Value.GetLocation().Y, Value.GetLocation().Z);
		ImGui::Text("            rot| x:% .03f, y:% .03f, z:% .03f, w:% .03f", Value.GetRotation().X, Value.GetRotation().Y, Value.GetRotation().Z, Value.GetRotation().W);
		ImGui::Text("          scale| x:% .03f, y:% .03f, z:% .03f", Value.GetScale3D().X, Value.GetScale3D().Y, Value.GetScale3D().Z);
	}
	else
	{
		const FString NodeTitle = FString::Printf(TEXT("%s (struct)##%p"), *GetNameSafe(StructType), Obj);
		if (ImGui::TreeNode(Ansi(*NodeTitle)))
		{
			static constexpr ImGuiTableFlags flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_RowBg | ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable;
			if (ImGui::BeginTable("PropertyTable", 2, flags))
			{
				ImGui::TableSetupColumn("Property", ImGuiTableColumnFlags_WidthFixed);
				ImGui::TableSetupColumn("Value", ImGuiTableColumnFlags_WidthStretch);
					
				for (FProperty* StructChildProp : TFieldRange<FProperty>(StructType))
				{
					if (StructChildProp)
					{
						ImGui::TableNextColumn();
						ImGui::Text("%s", Ansi(*StructChildProp->GetName()));
						ImGui::Text("%s", Ansi(*StructChildProp->GetClass()->GetName()));
						ImGui::TableNextColumn();
			
						DrawPropertyValue(StructChildProp, Obj);
					}
				}
											
				ImGui::EndTable();
			}
				
			ImGui::TreePop();
		}
	}
}

ImVec4 ImGuiTools::Utils::InterpolateImGuiColor(const ImVec4& StartColor, const ImVec4& EndColor, float Time)
{
	return ImVec4(
		StartColor.x + ((EndColor.x - StartColor.x) * Time),
		StartColor.y + ((EndColor.y - StartColor.y) * Time),
		StartColor.z + ((EndColor.z - StartColor.z) * Time),
		StartColor.w + ((EndColor.w - StartColor.w) * Time)
	);
}

```

`ImGuiTools/Source/ImGuiTools/Private/Widgets/ClassSelectorWidget.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "Widgets/ClassSelectorWidget.h"

#include "Runtime/Launch/Resources/Version.h"

#include "Utils/ImGuiUtils.h"

namespace ClassSelectorUtil
{
    static bool ClassPassesNameFilter(ImGuiTools::FHierarchicalClassInfo& ClassInfo, ImGuiTextFilter& ClassNameFilter)
    {
        // We pass if our class name passes filter...
        if (ClassNameFilter.PassFilter(Ansi(*ClassInfo.mClass->GetFName().ToString())))
        {
            return true;
        }
        
        // .. or if any unloaded classes match filter
        for (ImGuiTools::FHierarchicalClassInfo::UnloadedClassInfo& UnloadedClassInfo : ClassInfo.mUnloadedChildren)
        {
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
            if (ClassNameFilter.PassFilter(Ansi(*UnloadedClassInfo.ClassAssetPath.ToString())))
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
            if (ClassNameFilter.PassFilter(Ansi(*UnloadedClassInfo.ClassName)))
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
            {
                return true;
            }
        }

        // .. or finally, any loaded children and their potential children pass filter
        for (ImGuiTools::FHierarchicalClassInfo& LoadedClassInfo : ClassInfo.mLoadedChildren)
        {
            if (ClassPassesNameFilter(LoadedClassInfo, ClassNameFilter))
            {
                return true;
            }
        }

        return false;
    }

    static void DrawClass(ImGuiTools::FHierarchicalClassInfo& ClassInfo, TWeakObjectPtr<UClass>& OUT_SelectedUClass, ImGuiTools::FClassSelector& ClassSelector)
    {
        
        ImGuiTextFilter& ClassTextFilter = ClassSelector.GetClassNameFilter();
        const bool InFilter = ClassPassesNameFilter(ClassInfo, ClassTextFilter);
        if (!InFilter)
        {
            return;
        }

        bool TreeOpen = false;
        if ((ClassInfo.mLoadedChildren.Num() == 0) && (ClassInfo.mUnloadedChildren.Num() == 0))
        {
            ImGui::Text("   %s", Ansi(*ClassInfo.mClass->GetFName().ToString()));
        }
        else
        {
            ImGuiTreeNodeFlags NodeFlags = ClassTextFilter.IsActive() ? ImGuiTreeNodeFlags_DefaultOpen : 0;
            TreeOpen = ImGui::TreeNodeEx(Ansi(*ClassInfo.mClass->GetFName().ToString()), NodeFlags);
        }
        if (ClassInfo.mCachedAllUnloadedDecendants > 0)
        {
            ImGui::SameLine(ImGui::GetWindowWidth() - 180.0f);
            if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Load %d BPs##%s"), ClassInfo.mCachedAllUnloadedDecendants, *ClassInfo.mClass->GetFName().ToString()))))
            {
                ClassInfo.LoadChildren();
                ClassSelector.QueueReset();
            }
        }

        ImGui::SameLine(ImGui::GetWindowWidth() - 80.0f);
        if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Select##%s"), *ClassInfo.mClass->GetFName().ToString()))))
        {
            OUT_SelectedUClass = ClassInfo.mClass;
        }

        if (TreeOpen)
        {
            for (ImGuiTools::FHierarchicalClassInfo& LoadedChildInfo : ClassInfo.mLoadedChildren)
            {
                DrawClass(LoadedChildInfo, OUT_SelectedUClass, ClassSelector);
            }

            for (ImGuiTools::FHierarchicalClassInfo::UnloadedClassInfo& UnloadedChildInfo : ClassInfo.mUnloadedChildren)
            {
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
                if (ClassSelector.GetClassNameFilter().PassFilter(Ansi(*UnloadedChildInfo.ClassAssetPath.ToString())))
                {
                    ImGui::TextColored(ImGuiTools::Colors::Purple, " Unloaded BP: %s (inf: %s)", Ansi(*UnloadedChildInfo.ClassAssetPath.ToString()), Ansi(*UnloadedChildInfo.SoftClassInfo.ToString()));
					ImGui::SameLine(ImGui::GetWindowWidth() - 160.0f);
					if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Load##%s"), *UnloadedChildInfo.ClassAssetPath.ToString()))))
					{
                        UnloadedChildInfo.SoftClassInfo.LoadSynchronous();
                        ClassSelector.QueueReset();
					}
                }
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
                if (ClassSelector.GetClassNameFilter().PassFilter(Ansi(*UnloadedChildInfo.ClassName)))
                {
                    ImGui::TextColored(ImGuiTools::Colors::Purple, " Unloaded BP: %s (inf: %s)", Ansi(*UnloadedChildInfo.ClassName), Ansi(*UnloadedChildInfo.SoftClassInfo.ToString()));
                    ImGui::SameLine(ImGui::GetWindowWidth() - 160.0f);
                    if (ImGui::SmallButton(Ansi(*FString::Printf(TEXT("Load##%s"), *UnloadedChildInfo.ClassName))))
                    {
                        UnloadedChildInfo.SoftClassInfo.LoadSynchronous();
                        ClassSelector.QueueReset();
                    }
                }
#endif  // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
            }

            ImGui::TreePop();
        }
    }
}

ImGuiTools::FClassSelector::FClassSelector(UClass* RootClass, FString SearchDirectory /*= FString(TEXT("/Game/"))*/, bool HierarchicalView /*= true*/)
{
    mHierarchicalView = HierarchicalView;

    mRootClassInfo.ResetToRootClass(RootClass, SearchDirectory);
}

void ImGuiTools::FClassSelector::QueueReset()
{
    mResetQueued = true;
}

void ImGuiTools::FClassSelector::Draw(const char* ID, ImVec2 Size)
{
    // Execute any queued resets from last frame
    if (mResetQueued)
    {
        mResetQueued = false;
        mRootClassInfo.Reset();
    }

    ImGui::BeginChild(ID, Size);

    ImGui::BeginChild(Ansi(*FString::Printf(TEXT("%s_Options"), ID)), ImVec2(0.0f, 36.0f), true);
    ImGui::SameLine();
    if (ImGui::SmallButton("Refresh Hierarchy"))
    {
        mRootClassInfo.Reset();
    }
    ImGui::SameLine();
    ClassNameFilter.Draw();
    ImGui::EndChild();  // Options

    ImGui::BeginChild(Ansi(*FString::Printf(TEXT("%s_Body"), ID)), ImVec2(0.0f, 0.0f), true);
    ClassSelectorUtil::DrawClass(mRootClassInfo.mRootClassInfo, mSelectedClass, *this);
    ImGui::EndChild();  // Body

    ImGui::EndChild();  // ID
}

UClass* ImGuiTools::FClassSelector::GetSelectedClass()
{
    return mSelectedClass.Get();
}

ImGuiTextFilter& ImGuiTools::FClassSelector::GetClassNameFilter()
{
    return ClassNameFilter;
}

```

`ImGuiTools/Source/ImGuiTools/Public/ImGuiToolWindow.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once
#include "CoreMinimal.h"

// types
typedef int ImGuiWindowFlags;

class IMGUITOOLS_API FImGuiToolWindow
{
public:
	FImGuiToolWindow() = default;
	virtual ~FImGuiToolWindow() = default;

	// Implement these in your tools
	virtual void ImGuiUpdate(float DeltaTime) = 0;

	// Called by ImGuiToolsManager
	void EnableTool(bool bNewEnabled);
	bool& GetEnabledRef();
	const FString& GetToolName() const;
	const ImGuiWindowFlags& GetFlags() const;
	virtual void UpdateTool(float DeltaTime);
	virtual bool IsEditorToolAllowed() { return false;};
	
protected:
	bool bEnabled = false;
	FString ToolName;
	ImGuiWindowFlags WindowFlags = 0;
};
```

`ImGuiTools/Source/ImGuiTools/Public/ImGuiTools.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include <CoreMinimal.h>
#include <Modules/ModuleManager.h>

// forward declarations
class FImGuiToolsGameDebugger;
class FImGuiToolsManager;

class IMGUITOOLS_API FImGuiToolsModule : public IModuleInterface
{
public:

	// IModuleInterface
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
	// ~IModuleInterface
	
	TSharedPtr<FImGuiToolsManager> GetToolsManager();
	TSharedPtr<FImGuiToolsGameDebugger> GetGameDebugger();

private:
	TSharedPtr<FImGuiToolsManager> ToolsManager;
	TSharedPtr<FImGuiToolsGameDebugger> GameDebugger;
};

```

`ImGuiTools/Source/ImGuiTools/Public/ImGuiToolsDeveloperSettings.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include <Engine/DeveloperSettings.h>

#include "ImGuiToolsDeveloperSettings.generated.h"

UCLASS(config = ImGui, meta = (DisplayName = "ImGui Tools Settings"))
class IMGUITOOLS_API UImGuiToolsDeveloperSettings : public UDeveloperSettings
{
public:
	GENERATED_BODY()

	UImGuiToolsDeveloperSettings();

	// Display the ImGui Tools Editor Button. Requires Editor restart to take effect.
	UPROPERTY(config, EditAnywhere)
	bool DisplayEditorButton = true;

	// If true, when the ImGui Tools are enabled, ImGui Input is enabled, when they are disabled, the input is disabled. If the tools aren't enabled/disabled, the input is not toggled.
	UPROPERTY(config, EditAnywhere)
	bool SetImGuiInputOnToolsEnabled = true;

	// Array of keys for a key chord, defining a key short cut to toggle ImGui Input.
	UPROPERTY(config, EditAnywhere)
	TArray<FKey> ImGuiToggleInputKeys;

	// Array of keys for a key chord, defining a key short cut to toggle ImGui Visibility.
	UPROPERTY(config, EditAnywhere)
	TArray<FKey> ImGuiToggleVisibilityKeys;
};
```

`ImGuiTools/Source/ImGuiTools/Public/ImGuiToolsGameDebugger.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"

struct IMGUITOOLS_API FActorComponentCustomization
{
	TSubclassOf<UActorComponent> ComponentClass;
	TFunction<void()> CustomizationDrawFunction;
};

class IMGUITOOLS_API FImGuiToolsGameDebugger
{
public:
	// The draw function that is called when you want to draw the Game Debugger Main Menu, menu.
	static void DrawMainImGuiMenu();

	void RegisterActorComponentCustomization(const FActorComponentCustomization& Customization);
	void UnregisterActorComponentCustomization(const TSubclassOf<UActorComponent> ComponentClass);

private:
	TArray<FActorComponentCustomization> ActorCompCustomizations;
};

```

`ImGuiTools/Source/ImGuiTools/Public/ImGuiToolsManager.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include <ConsoleSettings.h>
#include <Framework/Application/IInputProcessor.h>
#include <HAL/IConsoleManager.h>
#include <Tickable.h>

// forward declarations
class FImGuiToolWindow;

// types
typedef TTuple<uint32, uint32> KeyCodePair;
typedef TMap<FName, TArray<TSharedPtr<FImGuiToolWindow>>> ToolNamespaceMap;

// CVARs
namespace ImGuiDebugCVars
{
	extern IMGUITOOLS_API TAutoConsoleVariable<bool> CVarImGuiToolsEnabled;
} // namespace ImGuiDebugCVars

class FImGuiToolsInputProcessor : public IInputProcessor
{
public:
	//~ IInputProcess overrides
	bool HandleKeyDownEvent( FSlateApplication& SlateApp, const FKeyEvent& InKeyEvent ) override;
	bool HandleKeyUpEvent( FSlateApplication& SlateApp, const FKeyEvent& InKeyEvent ) override;
	void Tick(const float DeltaTime, FSlateApplication& SlateApp, TSharedRef<ICursor> Cursor) override {};

private:
	TArray<KeyCodePair> KeyCodesDown;

	void CheckForToggleShortcutState();
	bool ToggleInputDown = false;
	bool ToggleVisDown = false;
};

class IMGUITOOLS_API FImGuiToolsManager
{
public:
	FImGuiToolsManager();
	virtual ~FImGuiToolsManager();

	// Used to init/register any tools that internal to this plugin
	void Initialize();
	void Deinitialize();

	// Used to register tools externally
	void RegisterToolWindow(TSharedPtr<FImGuiToolWindow> ToolWindow, FName ToolNamespace = NAME_None);

	ToolNamespaceMap& GetToolsWindows();
	TSharedPtr<FImGuiToolWindow> GetToolWindow(const FString& ToolWindowName, FName ToolNamespace = NAME_None);

	static void ToggleToolVisCommand(const TArray<FString>& Args);
    static void ToggleToolsVisCommand(const TArray<FString>& Args);

#if WITH_EDITOR
	static void LaunchEditorTool(const TArray<FString>& Args);
#endif

	// Delegate callbacks
	void OnWorldPostActorTick(UWorld* World, ELevelTick TickType, float DeltaSeconds);

private:
	ToolNamespaceMap ToolWindows;
	bool DrawImGuiDemo;
	bool ShowFPS;

	void RegisterAutoCompleteEntries(TArray<FAutoCompleteCommand>& Commands) const;

	FConsoleVariableDelegate OnEnabledCVarValueChanged;

	TSharedPtr<FImGuiToolsInputProcessor> InputProcessor = nullptr;

	FDelegateHandle OnWorldPostActorTickDelegateHandle;
};

```

`ImGuiTools/Source/ImGuiTools/Public/Utils/ClassHierarchyInfo.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once
#include "UObject/SoftObjectPtr.h"
#include "Runtime/Launch/Resources/Version.h"

// forward declarations
class UClass;
class UObject;

namespace ImGuiTools
{
	void DrawClassHierarchy(UObject* Obj, UClass* TerminatingParentClass = UObject::StaticClass());

	struct IMGUITOOLS_API FHierarchicalClassInfo
	{
		// This will only be set for loaded classes, check validity for load status.
		TWeakObjectPtr<UClass> mClass;

		TArray<FHierarchicalClassInfo> mLoadedChildren;

		struct UnloadedClassInfo
		{
			TSoftClassPtr<UObject>  SoftClassInfo;
#if ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
			FTopLevelAssetPath      ClassAssetPath;
#else   // ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
            FString                 ClassName;
#endif  // EENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 1
		};
		TArray<UnloadedClassInfo> mUnloadedChildren;

		// How many unloaded descendants of this class exist. Cached once after hierarchy is built.
		int mCachedAllUnloadedDecendants = 0;

		// Load any unloaded child classes, if LoadAllDescendants is true, all descendants even past direct children will be loaded
		void LoadChildren(bool LoadAllDescendants = true);
	};

	// A root class info that holds additional data for the whole tree like search directory, etc.
	struct IMGUITOOLS_API FHierarchicalRootClassInfo
	{
		FString mSearchDirectory;
		FHierarchicalClassInfo mRootClassInfo;

		// Reset the view to this root class
		void ResetToRootClass(UClass* RootClass, FString SearchDirectory = FString(TEXT("/Game/")));
		// Reset to the currently selected root class
		void Reset();
	};
}
```

`ImGuiTools/Source/ImGuiTools/Public/Utils/ImGuiUtils.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include <imgui.h>

// forward declarations
struct FInstancedStruct;

#define Ansi(ws) StringCast<char>(ws).Get()

namespace ImGuiTools
{
	namespace Colors
	{
		// 8 Bit (0<->255) RGBA to ImVec4 Color conversion utility
		constexpr ImVec4 RGBColorToImVec4Color(uint8 R, uint8 G, uint8 B, uint8 A = 255)
		{
			return ImVec4(
				static_cast<float>(R) / 255.0f,
				static_cast<float>(G) / 255.0f,
				static_cast<float>(B) / 255.0f,
				static_cast<float>(A) / 255.0f
			);
		}

		static constexpr ImVec4 Aqua			= RGBColorToImVec4Color(0,	255, 255);
		static constexpr ImVec4 Black			= RGBColorToImVec4Color(0,	0,	0);
		static constexpr ImVec4 Blue			= RGBColorToImVec4Color(0,	0,	255);
		static constexpr ImVec4 Blue_Dark		= RGBColorToImVec4Color(0,	0,	139);
		static constexpr ImVec4 Blue_Light		= RGBColorToImVec4Color(173, 216, 230);
		static constexpr ImVec4 Brown			= RGBColorToImVec4Color(165, 42,	42);
		static constexpr ImVec4 Brown_Dark		= RGBColorToImVec4Color(92,	64,	51);
		static constexpr ImVec4 Brown_Light		= RGBColorToImVec4Color(196, 164, 132);
		static constexpr ImVec4 Cyan			= RGBColorToImVec4Color(0,	255, 255);
		static constexpr ImVec4 Green			= RGBColorToImVec4Color(0,	128, 0);
		static constexpr ImVec4 Green_Dark		= RGBColorToImVec4Color(2,	48,	32);
		static constexpr ImVec4 Green_Light		= RGBColorToImVec4Color(144, 238, 144);
		static constexpr ImVec4 Gray			= RGBColorToImVec4Color(169, 169, 169);
		static constexpr ImVec4 Gray_Dark		= RGBColorToImVec4Color(128, 128, 128);
		static constexpr ImVec4 Gray_Light		= RGBColorToImVec4Color(211, 211, 211);
		static constexpr ImVec4 Orange			= RGBColorToImVec4Color(255, 165, 0);
		static constexpr ImVec4 Orange_Dark		= RGBColorToImVec4Color(210, 125, 45);
		static constexpr ImVec4 Orange_Light	= RGBColorToImVec4Color(255, 213, 128);
		static constexpr ImVec4 Purple			= RGBColorToImVec4Color(128, 0,	128);
		static constexpr ImVec4 Purple_Dark		= RGBColorToImVec4Color(48,	25,	52);
		static constexpr ImVec4 Purple_Light	= RGBColorToImVec4Color(203, 195, 227);
		static constexpr ImVec4 Red				= RGBColorToImVec4Color(255, 0,	0);
		static constexpr ImVec4 Red_Dark		= RGBColorToImVec4Color(139, 0,	0);
		static constexpr ImVec4 Red_Light		= RGBColorToImVec4Color(250, 128, 144);
		static constexpr ImVec4 Teal			= RGBColorToImVec4Color(0,	128, 128);
		static constexpr ImVec4 White			= RGBColorToImVec4Color(1,	1,	1);
		static constexpr ImVec4 Yellow			= RGBColorToImVec4Color(255, 255, 0);
		static constexpr ImVec4 Yellow_Dark		= RGBColorToImVec4Color(218, 165, 32);
		static constexpr ImVec4 Yellow_Light	= RGBColorToImVec4Color(250, 250, 51);
	}	// namespace Colors


	namespace Utils
	{
          // FShowCols - small object to manage column visibility states.
		struct IMGUITOOLS_API FShowCols
		{
			FShowCols(int ColCount, bool* OptionalDefaultColArray = nullptr);

			// We provide a way to cache col count so we can query multiple times in a frame without constantly traversing an array
			int CacheShowColCount();
			int GetCachedShowColCount();

			// Main interface to get and set a columns show flag
			bool& GetShowCol(int ColIndex);

		private:
			// Hide default constructor
			FShowCols() = default;

			// max columns used in a lame effort to avoid vector
			static constexpr int MAX_COLUMNS = 10;

			bool ShowColFlags[MAX_COLUMNS];
			int CachedShowColCount = 0;
			int TotalShowColCount = 0;
		};

        // FWorldCache - small object to manage caching valid worlds, for use in situations where there is no relevant world context.
        struct IMGUITOOLS_API FWorldCache
        {
            void TryCacheWorlds();
            TArray<TWeakObjectPtr<UWorld>> CachedWorlds;
        };

		// Draw details of an instanced struct in table form.
		void IMGUITOOLS_API DrawInstancedStructTable(const char* StringId, const FInstancedStruct& InstancedStruct, ImVec2 Size = ImVec2(0,0), bool DoTreeNode = false);

		// Draw the value of a property of unknown type on the provided uobject.
		void IMGUITOOLS_API DrawPropertyValue(const FProperty* Prop, const void* Obj);

		// Given a UStruct, draw it either explicitly or generically.
		void IMGUITOOLS_API DrawScriptStructProperty(const UScriptStruct* StructType, const void* Obj);

		// Given a start and end color, and a time 0 <-> 1, give the interpolated color at that time.
		ImVec4 IMGUITOOLS_API InterpolateImGuiColor(const ImVec4& StartColor, const ImVec4& EndColor, float Time);
	}	// namespace Utils
}		// namespace ImGuiTools

```

`ImGuiTools/Source/ImGuiTools/Public/Widgets/ClassSelectorWidget.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include <imgui.h>

#include "Utils/ClassHierarchyInfo.h"

// forward declarations
class UClass;

namespace ImGuiTools
{
    struct IMGUITOOLS_API FClassSelector
    {
        FClassSelector(UClass* RootClass, FString SearchDirectory = FString(TEXT("/Game/")), bool HierarchicalView = true);
        void Draw(const char* ID, ImVec2 Size);
        UClass* GetSelectedClass();
        ImGuiTextFilter& GetClassNameFilter();

        // Queue a reset for the next draw
        void QueueReset();

    private:
        FHierarchicalRootClassInfo mRootClassInfo;
        ImGuiTextFilter ClassNameFilter;
        TWeakObjectPtr<UClass> mSelectedClass;
        bool mHierarchicalView = true;
        bool mResetQueued = false;
    };
}

```

`ImGuiTools/Source/ImGuiToolsEditor/ImGuiToolsEditor.Build.cs`:

```cs
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

using UnrealBuildTool;

public class ImGuiToolsEditor : ModuleRules
{
	public ImGuiToolsEditor(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;
		
		PublicDependencyModuleNames.AddRange(
			new string[]
			{
				"Core",
				"GameplayTags"
				// ... add other public dependencies that you statically link with here ...
			}
		);	
		
		// Add StructUtils only for UE 5.4 and earlier
		if (Target.Version.MajorVersion < 5 || (Target.Version.MajorVersion == 5 && Target.Version.MinorVersion <= 4))
		{
			PublicDependencyModuleNames.Add("StructUtils");
		}
		
		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				"ImGuiTools",

				"CoreUObject",
				"Engine",
				"InputCore",
				"Projects",
				"RenderCore",
				"RHI",
				"Slate",
				"SlateCore",
				"ToolMenus",
				"UnrealEd",
				// ... add private dependencies that you statically link with here ...	
			}
		);

		// Additional Dependencies for non-Shipping builds.
		if (Target.Configuration != UnrealTargetConfiguration.Shipping)
		{
			PrivateDependencyModuleNames.AddRange(new string[] {
				"ImGui",
			});

			// DRAW_IMGUI_TOOLS - is meant to be a flag that can be disabled to run the module in a minimal / mostly disabled state.
			//	It is recommended to simply not load the module for whatever builds you do not wish to use ImGuiTools with, but this
			//	flag can be disabled for corner cases where you want a mostly no-op module.
			PublicDefinitions.Add("DRAW_IMGUI_TOOLS=1");
		}
		else
		{
			PublicDefinitions.Add("DRAW_IMGUI_TOOLS=0");
		}
	}
}

```

`ImGuiTools/Source/ImGuiToolsEditor/Private/ImGuiEditorWidget.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)
 
#include "ImGuiEditorWidget.h"

#include <imgui_internal.h>
 
#include "ImGuiContext.h"
#include "ImGuiModule.h"
#include "Widgets/SWindow.h"
#include "Widgets/Text/STextBlock.h"

SImGuiEditorWidget::~SImGuiEditorWidget()
{
}
 
void SImGuiEditorWidget::Construct(const FArguments& InArgs)
{
	SetCanTick(true); // Ensure the widget updates
	SetVisibility(EVisibility::HitTestInvisible); // Ensures the widget is interactive but doesn't block transparency
}

void SImGuiEditorWidget::Tick(const FGeometry& AllottedGeometry, const double InCurrentTime, const float InDeltaTime)
{
	TSharedPtr<SWindow> ParentWindow = FSlateApplication::Get().FindWidgetWindow(AsShared());
#if (ENGINE_MAJOR_VERSION == 5 && ENGINE_MINOR_VERSION >= 5)
	TSharedPtr<FImGuiContext> ImGuiContext = FImGuiModule::Get().FindOrCreateSessionContext(UE::GetPlayInEditorID());
#else
	TSharedPtr<FImGuiContext> ImGuiContext = FImGuiModule::Get().FindOrCreateSessionContext(GPlayInEditorID);
#endif
	
	if (ImGuiContext.IsValid())
	{
		ImGui::SetCurrentContext(*ImGuiContext);

		if (ImGui::GetCurrentContext()->WithinFrameScope)
		{
			const ImVec2 WindowPos = ImVec2(GetCachedGeometry().GetAbsolutePosition());
			const ImVec2 WindowSize = ImVec2(AllottedGeometry.GetAbsoluteSize());
			ImGui::GetCurrentContext()->CurrentViewport->Pos = WindowPos;
			ImGui::GetCurrentContext()->CurrentViewport->Size = WindowSize;
			
			ImGuiContext->BeginFrame();

			// Begin a full-screen ImGui window
			ImGui::SetNextWindowPos(WindowPos); // Top-left corner
			ImGui::SetNextWindowSize(WindowSize); // Full size

			ImGui::Begin("ImGuiEditorWidgetRoot", nullptr, WindowFlags);

			ImGuiUpdate();

			if ((CachedWindowPosition.x != WindowPos.x) || (CachedWindowPosition.y != WindowPos.y) || (CachedWindowSize.x != WindowSize.x) || (CachedWindowSize.y != WindowSize.y))
			{
				CachedWindowPosition = WindowPos;
				CachedWindowSize = WindowSize;
				
				FImGuiViewportData* ViewportData = FImGuiViewportData::GetOrCreate(ImGui::GetWindowViewport());
				if (ViewportData && ViewportData->Window.IsValid())
				{
					ViewportData->Window.Pin()->BringToFront(true);
				}
			}
			ImGui::End();

			ImGuiContext->EndFrame();
		}
	}	
}

void SImGuiEditorWidget::ImGuiUpdate()
{
	ImGui::Text("Subclass this widget and override \n SImGuiEditorWidget::ImGuiUpdate to draw ImGui on it!");
}
```

`ImGuiTools/Source/ImGuiToolsEditor/Private/ImGuiToolsEditor.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiToolsEditor.h"

#include "ImGuiToolsEditorStyle.h"
#include "ImGuiToolsEditorCommands.h"
#include "Misc/MessageDialog.h"
#include "ToolMenus.h"

#define LOCTEXT_NAMESPACE "FImGuiToolsModule"

void FImGuiToolsEditorModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
	
	FImGuiToolsEditorStyle::Initialize();
	FImGuiToolsEditorStyle::ReloadTextures();
	
	FImGuiToolsEditorCommands::Register();

	ToolsElements = MakeShareable(new FImGuiToolsEditorElements());
	ToolsElements->RegisterElements();
}

void FImGuiToolsEditorModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.

	UToolMenus::UnRegisterStartupCallback(this);

	UToolMenus::UnregisterOwner(this);

	FImGuiToolsEditorStyle::Shutdown();

	FImGuiToolsEditorCommands::Unregister();
}

#undef LOCTEXT_NAMESPACE
	
IMPLEMENT_MODULE(FImGuiToolsEditorModule, ImGuiToolsEditor)
```

`ImGuiTools/Source/ImGuiToolsEditor/Private/ImGuiToolsEditorCommands.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiToolsEditorCommands.h"

#include "ImGuiTools.h"
#include "ImGuiToolWindow.h"
#include "ImGuiToolsDeveloperSettings.h"
#include "ImGuiToolsManager.h"
#include "ImGuiToolsEditorStyle.h"

#include <ImGuiModule.h>
#include <Internationalization/Text.h>
#include <LevelEditor.h>
 
#include "ImGuiToolsEditorWidget.h"
 
#define LOCTEXT_NAMESPACE "FImGuiToolsModule"
 
//______________________________________________________________________________________________________________________
 
namespace ImGuiEditorUtils
{
	bool IsModuleLoaded(FName ModuleName)
	{
		FModuleStatus ModuleStatus;
		FModuleManager::Get().QueryModule(ModuleName, ModuleStatus);
        return ModuleStatus.bIsLoaded;
	}

	bool AreRequiredModulesLoaded()
	{
        // Check if modules are loaded..
        const bool RequiredModulesLoaded = (IsModuleLoaded(TEXT("LevelEditor")) && IsModuleLoaded(TEXT("ImGui")));

        // If all required modules are loaded, ensure the level editor extensibility manager is also available. So dumb that this is required, but stems from nuances of
        //  the module manager code, where modules can be not "ready" (and thus extensibilitymanager not init'ed), but still report as loaded. Checking that state is private
        //  to the module manager, so lets just manually check if the level editor modules' extensibility manager is init'ed yet as that is what we need it for.
        bool LevelEditorModuleReady = false;
        if (RequiredModulesLoaded)
        {
            FLevelEditorModule& LevelEditorModule = FModuleManager::GetModuleChecked<FLevelEditorModule>("LevelEditor");
            LevelEditorModuleReady = LevelEditorModule.GetToolBarExtensibilityManager().IsValid();
        }

        return RequiredModulesLoaded && LevelEditorModuleReady;
	}
}
 
//______________________________________________________________________________________________________________________
 
FImGuiToolsEditorCommands::FImGuiToolsEditorCommands()
    : TCommands<FImGuiToolsEditorCommands>(TEXT("ImGuiTools"), NSLOCTEXT("Contexts", "ImGuiTools", "ImGuiTools Plugin"), NAME_None, FImGuiToolsEditorStyle::GetStyleSetName())
{
}

void FImGuiToolsEditorCommands::RegisterCommands()
{
	UI_COMMAND(ImGuiToolEnabledCommand, "ImGuiTools Enabled", "When enabled, the ImGui Tools menu bar will be drawn on screen. Can also be controlled via CVAR 'imgui.tools.enabled'.", EUserInterfaceActionType::ToggleButton, FInputGesture());
}
 
//______________________________________________________________________________________________________________________
 
// Entry point to register elements. Do it now if able, else wait until able then do it.
void FImGuiToolsEditorElements::RegisterElements()
{
	if (ImGuiEditorUtils::AreRequiredModulesLoaded())
	{
		// Ready to register the elements
		RegisterElements_Internal();
	}
	else
	{
		// Module not yet loaded, subscribe and wait for the module to be loaded 
		OnModulesChangedHandler = FModuleManager::Get().OnModulesChanged().AddRaw(this, &FImGuiToolsEditorElements::OnModulesChanged);
	}
}

void FImGuiToolsEditorElements::OnModulesChanged(FName Name, EModuleChangeReason Reason)
{
	if (ImGuiEditorUtils::AreRequiredModulesLoaded())
	{
		// Modules loaded. Unsub from OnModulesChanged and register the elements.
		FModuleManager::Get().OnModulesChanged().Remove(OnModulesChangedHandler);
		OnModulesChangedHandler.Reset();
		RegisterElements_Internal();
	}
}

// Actually registers the elements, assuming the level editor module is present. 
void FImGuiToolsEditorElements::RegisterElements_Internal()
{
	CommandList = MakeShareable(new FUICommandList);

	CommandList->MapAction(FImGuiToolsEditorCommands::Get().ImGuiToolEnabledCommand,
		FExecuteAction::CreateLambda([]() { ImGuiDebugCVars::CVarImGuiToolsEnabled.AsVariable()->Set(!ImGuiDebugCVars::CVarImGuiToolsEnabled.GetValueOnGameThread()); }), FCanExecuteAction(),
		FIsActionChecked::CreateLambda([]() -> bool { return ImGuiDebugCVars::CVarImGuiToolsEnabled.GetValueOnGameThread(); }));

	// Register Editor Tool window Editor Panels.
	FImGuiToolsModule& ImGuiToolsModule = FModuleManager::GetModuleChecked<FImGuiToolsModule>("ImGuiTools");
	if (ImGuiToolsModule.GetToolsManager().IsValid())
	{
		ToolNamespaceMap& ToolsWindows = ImGuiToolsModule.GetToolsManager()->GetToolsWindows();
		for (TPair<FName, TArray<TSharedPtr<FImGuiToolWindow>>>& NamespaceToolWindows : ToolsWindows)
		{
			const TArray<TSharedPtr<FImGuiToolWindow>>& NamespaceTools = NamespaceToolWindows.Value;
			for (TSharedPtr<FImGuiToolWindow> ToolWindow : NamespaceTools)
			{
				if (ToolWindow->IsEditorToolAllowed())
				{
					const FString EditorToolName = FString::Printf(TEXT("%s ImGuiEditorWidget"), *ToolWindow->GetToolName());
					FGlobalTabmanager::Get()->RegisterNomadTabSpawner(
						*EditorToolName,
						FOnSpawnTab::CreateLambda([ToolWindow] (const FSpawnTabArgs& args)
						{
							TSharedRef<SDockTab> MyTab = SNew(SDockTab)
								.TabRole(ETabRole::NomadTab)
								[
									SNew(SImGuiToolsEditorWidget) // Embed the custom ImGui widget here
									.ToolWindow(ToolWindow) // Explicitly capture ToolWindow
								];
							return MyTab;
						})
					)
					.SetDisplayName(FText::FromString(EditorToolName))
					.SetMenuType(ETabSpawnerMenuType::Hidden);
				}
			}
		}
	}
	
	struct Local
	{
		static void FillToolWindowsSubmenu(FMenuBuilder& MenuBuilder)
		{
			FImGuiToolsModule& ImGuiToolsModule = FModuleManager::GetModuleChecked<FImGuiToolsModule>("ImGuiTools");
			if (ImGuiToolsModule.GetToolsManager().IsValid())
			{
				ToolNamespaceMap& ToolsWindows = ImGuiToolsModule.GetToolsManager()->GetToolsWindows();
				for (TPair<FName, TArray<TSharedPtr<FImGuiToolWindow>>>& NamespaceToolWindows : ToolsWindows)
				{
					MenuBuilder.BeginSection(FName(FString::Printf(TEXT("ImGuiTools.%s"), *NamespaceToolWindows.Key.ToString())), FText::FromName(NamespaceToolWindows.Key));
					const TArray<TSharedPtr<FImGuiToolWindow>>& NamespaceTools = NamespaceToolWindows.Value;
					for (TSharedPtr<FImGuiToolWindow> ToolWindow : NamespaceTools)
					{
						if (!ToolWindow->IsEditorToolAllowed())
						{
							MenuBuilder.AddMenuEntry(FText::FromString(FString(ToolWindow->GetToolName())), FText(), FSlateIcon(),
								FUIAction(FExecuteAction::CreateLambda([ToolWindow]() { ToolWindow->EnableTool(!ToolWindow->GetEnabledRef()); }), FCanExecuteAction(),
									FIsActionChecked::CreateLambda([ToolWindow]() -> bool { return ToolWindow->GetEnabledRef(); })), NAME_None, EUserInterfaceActionType::ToggleButton);
						}
						else
						{
							const FString EditorToolName = FString::Printf(TEXT("%s ImGuiEditorWidget"), *ToolWindow->GetToolName());
							MenuBuilder.AddWidget(
								SNew(SHorizontalBox)
								+ SHorizontalBox::Slot()
								.AutoWidth()
								.Padding(FMargin(13, 0))
								[
									SNew(SCheckBox)
									.IsChecked_Lambda([ToolWindow]() { return ToolWindow->GetEnabledRef() ? ECheckBoxState::Checked : ECheckBoxState::Unchecked; })
									.OnCheckStateChanged_Lambda([ToolWindow](ECheckBoxState NewState)
									{
										 ToolWindow->EnableTool(!ToolWindow->GetEnabledRef());
									})
									.Style(FAppStyle::Get(), "Menu.CheckBox") // Ensures it looks like a menu checkbox
									.Padding(FMargin(13, 0))
									[
										SNew(STextBlock).Text(FText::FromString(FString(ToolWindow->GetToolName()))) // Checkbox label
									]
								]
								+ SHorizontalBox::Slot()
								.AutoWidth()
								.HAlign(HAlign_Right)
								.Padding(FMargin(12, 0))
								[
									SNew(SButton)
									.Text(FText::FromString("Editor"))
									.HAlign(HAlign_Right)
									.OnClicked_Lambda([EditorToolName]()
									{
										FGlobalTabmanager::Get()->TryInvokeTab(FTabId(*EditorToolName));
										return FReply::Handled();
									})
								],
								FText::GetEmpty() // No label above
							);
						}
					}
					MenuBuilder.EndSection();
				}
			}
		}

		static TSharedRef<SWidget> FillImGuiToolsMenu(TSharedPtr<FUICommandList> CommandList) 
		{
			FMenuBuilder MenuBuilder(true, CommandList);

			MenuBuilder.BeginSection(TEXT("ImGuiTools.Main"), LOCTEXT("ImGuiTools", "ImGui Tools"));
			MenuBuilder.AddMenuEntry(FImGuiToolsEditorCommands::Get().ImGuiToolEnabledCommand);
			MenuBuilder.AddSubMenu(LOCTEXT("ImGuiTools_ToolWindows", "Tool Windows"), FText(), FMenuExtensionDelegate::CreateStatic(&Local::FillToolWindowsSubmenu));
			MenuBuilder.EndSection();

			if (FImGuiModule* ImGuiModule = FModuleManager::GetModulePtr<FImGuiModule>("ImGui"))
			{
				MenuBuilder.BeginSection(TEXT("ImGuiTools.ImGuiOptions"), LOCTEXT("ImGuiOptions", "ImGui Options"));
				MenuBuilder.EndSection();
			}

			return MenuBuilder.MakeWidget();
		}

		static void FillToolbar(FToolBarBuilder& Builder, TSharedPtr<FUICommandList> CommandList)
		{
			Builder.AddComboButton(FUIAction(), FOnGetContent::CreateStatic(Local::FillImGuiToolsMenu, CommandList), LOCTEXT("ImGuiTools", "ImGuiTools"),
					LOCTEXT("ImGuiTools_Tooltip", "Tools for use with the ImGui plugin."), FSlateIcon(FImGuiToolsEditorStyle::Get().GetStyleSetName(), "ImGuiTools.EditorIcon"));
		}
	};

	if (GetDefault<UImGuiToolsDeveloperSettings>()->DisplayEditorButton)
	{
		FLevelEditorModule& LevelEditorModule = FModuleManager::GetModuleChecked<FLevelEditorModule>("LevelEditor");

		TSharedPtr<FExtender> NewToolbarExtender = MakeShareable(new FExtender);
#if ENGINE_MAJOR_VERSION == 4
		NewToolbarExtender->AddToolBarExtension("Build", EExtensionHook::Before, CommandList, FToolBarExtensionDelegate::CreateStatic(&Local::FillToolbar, CommandList));
#elif ENGINE_MAJOR_VERSION == 5
		NewToolbarExtender->AddToolBarExtension("Play", EExtensionHook::After, CommandList, FToolBarExtensionDelegate::CreateStatic(&Local::FillToolbar, CommandList));
#endif

		LevelEditorModule.GetToolBarExtensibilityManager()->AddExtender(NewToolbarExtender);
	}
}
 
//______________________________________________________________________________________________________________________
 
#undef LOCTEXT_NAMESPACE

```

`ImGuiTools/Source/ImGuiToolsEditor/Private/ImGuiToolsEditorStyle.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#include "ImGuiToolsEditorStyle.h"

#include "ImGuiTools.h"
#include "Framework/Application/SlateApplication.h"
#include "Styling/SlateStyleRegistry.h"
#include "Slate/SlateGameResources.h"
#include "Interfaces/IPluginManager.h"

TSharedPtr< FSlateStyleSet > FImGuiToolsEditorStyle::StyleInstance = NULL;

void FImGuiToolsEditorStyle::Initialize()
{
	if (!StyleInstance.IsValid())
	{
		StyleInstance = Create();
		FSlateStyleRegistry::RegisterSlateStyle(*StyleInstance);
	}
}

void FImGuiToolsEditorStyle::Shutdown()
{
	FSlateStyleRegistry::UnRegisterSlateStyle(*StyleInstance);
	ensure(StyleInstance.IsUnique());
	StyleInstance.Reset();
}

FName FImGuiToolsEditorStyle::GetStyleSetName()
{
	static FName StyleSetName(TEXT("ImGuiToolsEditorStyle"));
	return StyleSetName;
}

#define IMAGE_BRUSH( RelativePath, ... ) FSlateImageBrush( Style->RootToContentDir( RelativePath, TEXT(".png") ), __VA_ARGS__ )
#define BOX_BRUSH( RelativePath, ... ) FSlateBoxBrush( Style->RootToContentDir( RelativePath, TEXT(".png") ), __VA_ARGS__ )
#define BORDER_BRUSH( RelativePath, ... ) FSlateBorderBrush( Style->RootToContentDir( RelativePath, TEXT(".png") ), __VA_ARGS__ )
#define TTF_FONT( RelativePath, ... ) FSlateFontInfo( Style->RootToContentDir( RelativePath, TEXT(".ttf") ), __VA_ARGS__ )
#define OTF_FONT( RelativePath, ... ) FSlateFontInfo( Style->RootToContentDir( RelativePath, TEXT(".otf") ), __VA_ARGS__ )

const FVector2D Icon16x16(16.0f, 16.0f);
const FVector2D Icon20x20(20.0f, 20.0f);
const FVector2D Icon40x40(40.0f, 40.0f);

TSharedRef< FSlateStyleSet > FImGuiToolsEditorStyle::Create()
{
	TSharedRef< FSlateStyleSet > Style = MakeShareable(new FSlateStyleSet("ImGuiToolsStyle"));
	Style->SetContentRoot(IPluginManager::Get().FindPlugin("ImGuiTools")->GetBaseDir() / TEXT("Resources"));

	Style->Set("ImGuiTools.EditorIcon", new IMAGE_BRUSH(TEXT("ImguiTools_Icon40"), Icon40x40));

	return Style;
}

#undef IMAGE_BRUSH
#undef BOX_BRUSH
#undef BORDER_BRUSH
#undef TTF_FONT
#undef OTF_FONT

void FImGuiToolsEditorStyle::ReloadTextures()
{
	if (FSlateApplication::IsInitialized())
	{
		FSlateApplication::Get().GetRenderer()->ReloadTextureResources();
	}
}

const ISlateStyle& FImGuiToolsEditorStyle::Get()
{
	return *StyleInstance;
}

```

`ImGuiTools/Source/ImGuiToolsEditor/Private/ImGuiToolsEditorWidget.cpp`:

```cpp
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)
 
#include "ImGuiToolsEditorWidget.h"

#include "ImGuiToolWindow.h"

SImGuiToolsEditorWidget::~SImGuiToolsEditorWidget()
{
}
 
void SImGuiToolsEditorWidget::Construct(const FArguments& InArgs)
{
	ToolWindowPtr = InArgs._ToolWindow;
	if (ToolWindowPtr.IsValid())
	{
		WindowFlags = WindowFlags | ToolWindowPtr->GetFlags();
	}
}

void SImGuiToolsEditorWidget::ImGuiUpdate()
{
	if (ToolWindowPtr.IsValid())
	{
		ToolWindowPtr->ImGuiUpdate(0.001f);
	}
}

```

`ImGuiTools/Source/ImGuiToolsEditor/Public/ImGuiEditorWidget.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)
 
#pragma once
 
#include "Widgets/SCompoundWidget.h"
#include <imgui.h>
 
// forward declarations
class FImGuiContext;
class SImGuiOverlay;
class UTextureRenderTarget2D;
 
class SImGuiEditorWidget : public SCompoundWidget
{
public:
	SLATE_BEGIN_ARGS(SImGuiEditorWidget) {}
	SLATE_END_ARGS()
 
	virtual ~SImGuiEditorWidget();
 
	void Construct(const FArguments& InArgs);

	// The main function to override to draw ImGui things in this Slate Widget.
	virtual void ImGuiUpdate();

protected:
	void Tick(const FGeometry& AllottedGeometry, const double InCurrentTime, const float InDeltaTime) override;

	// Window flags that will be passed to the ImGui window that contains whatever you draw in ImGuiUpdate();
	ImGuiWindowFlags WindowFlags = ImGuiWindowFlags_NoTitleBar |
		                           ImGuiWindowFlags_NoResize |
                                   ImGuiWindowFlags_NoMove;
 
private:
	ImVec2 CachedWindowPosition = ImVec2(0, 0);
	ImVec2 CachedWindowSize = ImVec2(0, 0);
};

```

`ImGuiTools/Source/ImGuiToolsEditor/Public/ImGuiToolsEditor.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include <CoreMinimal.h>
#include <Modules/ModuleManager.h>

class FImGuiToolsEditorElements;

class IMGUITOOLSEDITOR_API FImGuiToolsEditorModule : public IModuleInterface
{
public:

	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;

private:
	TSharedPtr<FImGuiToolsEditorElements> ToolsElements;
};

```

`ImGuiTools/Source/ImGuiToolsEditor/Public/ImGuiToolsEditorCommands.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once
 
#include <CoreMinimal.h>
#include <Framework/Commands/Commands.h>

// forward declarations
class FImGuiToolWindow;
 
//______________________________________________________________________________________________________________________
 
class FImGuiToolsEditorCommands : public TCommands<FImGuiToolsEditorCommands>
{
public:
    FImGuiToolsEditorCommands();

	// TCommands<> interface
	virtual void RegisterCommands() override;

public:
	TSharedPtr<FUICommandInfo> ImGuiToolEnabledCommand;
};
 
//______________________________________________________________________________________________________________________
 
class FImGuiToolsEditorElements
{
public:
	// Should be called by the owner.. probably at module startup time
	void RegisterElements();

private:
	void OnModulesChanged(FName Name, EModuleChangeReason Reason);
	FDelegateHandle OnModulesChangedHandler;
	
	// Actually registers the elements, assuming the level editor module is present. 
	void RegisterElements_Internal();
	TSharedPtr<FUICommandList> CommandList;
};
 
//______________________________________________________________________________________________________________________
 
```

`ImGuiTools/Source/ImGuiToolsEditor/Public/ImGuiToolsEditorStyle.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)

#pragma once

#include "CoreMinimal.h"
#include "Styling/SlateStyle.h"

class FImGuiToolsEditorStyle
{
public:

	static void Initialize();

	static void Shutdown();

	/** reloads textures used by slate renderer */
	static void ReloadTextures();

	static const ISlateStyle& Get();

	static FName GetStyleSetName();

private:

	static TSharedRef< class FSlateStyleSet > Create();

private:

	static TSharedPtr< class FSlateStyleSet > StyleInstance;
};
```

`ImGuiTools/Source/ImGuiToolsEditor/Public/ImGuiToolsEditorWidget.h`:

```h
// Distributed under the MIT License (MIT) (see accompanying LICENSE file)
 
#pragma once
 
#include "ImGuiEditorWidget.h"

#include "Templates/SharedPointer.h"

class FImGuiToolWindow;

class SImGuiToolsEditorWidget : public SImGuiEditorWidget
{
public:
	SLATE_BEGIN_ARGS(SImGuiToolsEditorWidget)
		: _ToolWindow(nullptr)
		{}
		SLATE_ARGUMENT(TSharedPtr<FImGuiToolWindow>, ToolWindow)
	SLATE_END_ARGS()
 
	virtual ~SImGuiToolsEditorWidget();
 
	void Construct(const FArguments& InArgs);

	// The main function to override to draw ImGui things in this Slate Widget.
	virtual void ImGuiUpdate() override;

protected:
	TSharedPtr<FImGuiToolWindow> ToolWindowPtr = nullptr;
};

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Timothy Rawcliffe

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# UnrealImGuiTools
A set of tools and utilities for use with Unreal Engine projects using ImGui.

# Description
This plugin includes tools for use with Unreal Engine projects. It also provides a small framework to make writing your own game specific tool windows a bit more quickly and easily.

The plugin itself does not contain ImGui, but has ~~[segross' UnrealImGui plugin](https://github.com/segross/UnrealImGui)~~ [Vescodes' UE ImGui plugin](https://github.com/VesCodes/ImGui) as a dependant plugin. This plugin, ~~segross'~~ Vescodes' plugin, and [Omar Cornut's fantastic Dear ImGui](https://github.com/ocornut/imgui) are all released under MIT license.

### Compatibility
Most of these tools were written with UE 4.27, then it was later updated to UE 5.0 (it was a very minimal change). So currently only UE 5.0 is currently supported, but I plan to formalize 4.27 support with a flag or something in the future. For now, if you drop this in 4.27 it will still mostly work with perhaps 1 or 2 tweaks.

# Controlling ImGui Tools and ImGui
### Editor Button
To increase discoverability and ease of use, there is an editor button menu that provides options for interacting with both ImGui Tools plugin and the ImGui plugin itself. Find it in the main editor toolbar:
<img width="827" alt="image" src="https://user-images.githubusercontent.com/15803559/178165495-6f463492-0ca9-4f76-987a-2b66294df0ff.png">

Here you will find:
 * Top level ImGui Tools enable switch
 * Buttons to enable / disable individual tools
 * Buttons to enable different Input features of the ImGui plugin

### CVars
When outside the editor (like in Standalone builds) the main way to interact with the plugin is via CVars. Here is a list of useful ones:
```imgui.tools.enabled true```

<!-- Generated at https://www.tablesgenerator.com/markdown_tables# -->
| CVAR                                                 | Example                                                                                   | Description                                                                                                                                                                                                                                                             |
|------------------------------------------------------|-------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ```imgui.tools.enabled <bool: enable>```             | ```imgui.tools.enabled true imgui.tools.enabled false```                                  | Top-level switch that will enable / disable all ImGui Tools.                                                                                                                                                                                                            |
| ```imgui.tools.toggle_tool_vis <string:tool name>``` | ```imgui.tools.toggle_tool_vis MemoryDebugger imgui.tools.toggle_tool_vis LoadDebugger``` | Toggle visibility of a particular imgui tool. This list auto-completes with all registered tools, so it is a good way to explore all registered tools. If the top level switch is disabled when this CVAR is executed, the top level switch will be toggled on as well. |
| ```imgui.tools.file_load.toggle_record```            | ```imgui.tools.file_load.toggle_record```                                                 | For the Load Debugger - toggle recording of UE file loads.                                                                                                                                                                                                              |
 
![image](https://user-images.githubusercontent.com/15803559/178166803-b6f8494c-2fbd-49ce-8f98-a85c94417487.png)

### Creating game level ImGui Tool windows
Create your own ImGui tool windows in your game module! 

There is example game module code in the ```ExampleGameCode``` directory that will show you how to register tools with the plugin.

***Question:*** Why the heck should I pipe my game ImGui tools through the plugin? 

***Answer:*** Really, it just gives you a nice ImGui drawing entry point, an editor button, in-game menu button, and a CVAR via ```imgui.tools.toggle_tool_vis``` to toggle the visibility of your tool. Boiler plate that you might find yourself doing often when writing bespoke ImGui tool windows.

# Included Tools
## Memory Debugger
The Memory Debugger was built to show detailed memory information at runtime. While Memory Insights is largely useful for debugging individual allocations and some high level data, and the STAT commands can show you some useful buckets at a glance, this memory debugger is meant to fit somewhere in the middle. It is meant to compliment the existing memory debugging tools. There are a few parts to the Memory Debugger
#### Platform Memory Stats
These are real-time top level memory stats.

![image](https://user-images.githubusercontent.com/15803559/178167968-c0cb0aae-16e0-4eb5-a5f6-b11e3c81dc86.png)

#### Texture Memory
These are real-time stats for the textures currently loaded into the texture streaming system. This is useful to sanity check texture sizes at a glance, see which textures are marked for streaming or not, see usage counts and more! 

![image](https://user-images.githubusercontent.com/15803559/178168099-097a906b-3357-4cc4-b15f-282eda38b8c4.png)

#### Object Memory
This one is super cool! This will show you the memory size of all loaded UObjects in a cool heirarchical view. However, it is not real-time but instead 'snapshot' based. When you are ready to inspect your memory press the "Update (SLOW!)' button and give it ~10 seconds while the memory data is gathered. Then you can search through it by name, sort it by size / instances, and more! You can 'Inspect' any UClass to show a dedicated window for instances of that class (with an option to update those in real time). 

***NOTE: UObjects must implement UObject::GetResourceSizeEx() for the tool to correctly gather resource sizes. This is implemented for 99% of Epic UObjects (but watch out for the occasional exception!), but may require closer inspection for some third party libs/plugins (this had to be implemented manually for WWISE UObjects for instance)***

![image](https://user-images.githubusercontent.com/15803559/178168475-9c4a678b-17ba-48e1-bbef-f4cb29c419a6.png)
![image](https://user-images.githubusercontent.com/15803559/178168651-b0a98998-bfd0-443b-a741-80d58d95fdb1.png)

## Load Debugger
Synchronous loading hitches got you down? We have you covered! The LoadDebugger is a very small and simple tools that can track all sync and async class loads that happen during gameplay. Simply enable recording, spew the loads to the log output if desired, and clear the load list when needed. This is a great tool for hunting down unintentional / unknown sync file loads to eliminate those last hitches before ship by enabling recording and playing through the game a few times.

<img width="386" alt="image" src="https://user-images.githubusercontent.com/15803559/178175432-220c778f-de33-4e62-8c31-171293352c4b.png">

## Actor Component Debugger (ALPHA)
***NOTE: This tool is very much in progress and maybe only 50% complete. But perhaps is already a tiny bit useful***

This is a tool meant to help explore, analyze, and debug AActors and UActorComponents ( and more! ). It provides an in-game actor and component explorer and shows you useful information like counts of actors and components that replicate or tick, all represented in a heirarchical class view. You can tear off a window for any given actor or component to inspect it more closely. 

***Coming soon: advanced text search and sorting options a'la the memory debugger, and a mechanism to provide custom debug per actor or component class***

<img width="886" alt="image" src="https://user-images.githubusercontent.com/15803559/178176100-98cb1172-1f25-46d7-adc3-e4acd3dcbaf7.png">

```