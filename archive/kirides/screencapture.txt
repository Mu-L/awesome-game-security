Project Path: arc_kirides_screencapture_cs8nk9n2

Source Tree:

```txt
arc_kirides_screencapture_cs8nk9n2
├── LICENSE
├── README.md
├── app.manifest
├── cmd
│   └── example
│       ├── jpeg_native.go
│       ├── jpeg_turbo.go
│       ├── main.go
│       └── screencapture.go
├── d3d
│   ├── com_utils.go
│   ├── d3d11.go
│   ├── d3d11_types.go
│   ├── d3d11_vtbl.go
│   ├── d3d11debug.go
│   ├── dxgi.go
│   ├── dxgi_types.go
│   ├── dxgi_types_string.go
│   ├── dxgi_vtbl.go
│   ├── hresult.go
│   ├── hresult_string.go
│   ├── iunknown_vtbl.go
│   └── output_duplication.go
├── go.mod
├── go.sum
├── screenshot
│   └── native_windows.go
├── swizzle
│   ├── LICENSE
│   ├── swizzle_amd64.go
│   ├── swizzle_amd64.s
│   ├── swizzle_common.go
│   ├── swizzle_other.go
│   └── swizzle_test.go
└── win
    ├── syscall_windows.go
    └── zsyscall_windows.go

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 kirides

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

#
# golang.org/x/exp/shiny/driver/internal/swizzle
#

Copyright (c) 2009 The Go Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# Screencapture

This repository has been moved to https://github.com/kirides/go-d3d

## Motivation

I wanted to learn more about `COM` interop with Go and create a somewhat usable screen sharing tool

## Libaries used

This application uses D3D11 `IDXGIOutputDuplication` to create a somewhat _realtime_ desktop presentation

- `github.com/mattn/go-mjpeg` for mjpeg streaming
- `github.com/kbinani/screenshot` for comparison with GDI `BitBlt` (slightly modified source, to support re-using `image.RGBA`)
- `golang.org/x/exp/shiny/driver/internal/swizzle` for faster BGRA -> RGBA conversion (see [shiny LICENSE](./swizzle/LICENSE))
- `github.com/pixiv/go-libjpeg/jpeg` for fast jpeg encoding
  - enable with `go build -tag jpegturbo`

## Demo

Just build the application and run it.
It should serve all your monitors on an URL like `http://127.0.0.1:8023/watch?screen=N`  
where `screen=N <- N` is the monitor index, starting at zero (`0`).

By changing the lines in `cmd/example/main.go` regarding the streaming, you can switch between GDI `BitBlt` or `IDXGIOutputDuplication`

```go
// ...
framerate := 10
for i := 0; i < n; i++ {
    // ...
    // streamDisplay(ctx, i, framerate, stream)  // <= USE GDI BitBlt
    streamDisplayDXGI(ctx, i, framerate, stream) // <= USE IDXGIOutputDuplication
    // captureScreenTranscode(ctx, i, desiredFps)
    http.HandleFunc(fmt.Sprintf("/mjpeg%d", i), stream.ServeHTTP)
}
// ...
```

### screen recording with ffmpeg

The code contains the function `captureScreenTranscode` which allows you to record the
selected screen directly into ffmpeg and transcode it to h264 in an mp4 container.

## Performance

Performance _is not_ optimized to 100%, there are still thing that could be improved.

- only copying the dirty-rectangles (less GPU<->CPU communication)
- faster swizzle implementation using AVX/2 (less time for converting the BGRA texture)
- _profile ... profile ... profile_

Overall the current implementation is about 2-5x faster than GDI `BitBlt` (depending on the resolution, 
the higher the bigger the difference) and uses a lot less resources for cases where there arent any changes to the screen.

## app.manifest

To make use of `IDXGIOutput5::DuplicateOutput1`, an application has to provide support for `PerMonitorV2` DPI-Awareness (Windows 10 1703+)
This is usually done by providing an my-executable.exe.manifest file either next to the executable, or as an embedded resource.

In this application there are calls to `IsValidDpiAwarenessContext` and `SetThreadDpiAwarenessContext` which circumvent the requirement.

```

`app.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />
    </application>
  </compatibility>
  <asmv3:application>
    <asmv3:windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </asmv3:windowsSettings>
  </asmv3:application>
</assembly>

```

`cmd/example/jpeg_native.go`:

```go
// +build !jpegturbo
//go:build !jpegturbo

package main

import (
	"image"
	"image/jpeg"
	"io"
)

func jpegQuality(q int) *jpeg.Options {
	return &jpeg.Options{Quality: q}
}

func encodeJpeg(w io.Writer, src image.Image, opts *jpeg.Options) {
	jpeg.Encode(w, src, opts)
}

```

`cmd/example/jpeg_turbo.go`:

```go
// +build jpegturbo
//go:build jpegturbo

package main

import (
	"image"
	"io"

	jpegturbo "github.com/pixiv/go-libjpeg/jpeg"
)

func jpegQuality(q int) *jpegturbo.EncoderOptions {
	return &jpegturbo.EncoderOptions{Quality: q}
}

func encodeJpeg(w io.Writer, src image.Image, opts *jpegturbo.EncoderOptions) {
	jpegturbo.Encode(w, src, opts)
}

```

`cmd/example/main.go`:

```go
package main

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"image"
	"net/http"
	"runtime"

	// _ "net/http/pprof"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/kirides/screencapture/d3d"
	forkscreenshot "github.com/kirides/screencapture/screenshot"
	"github.com/kirides/screencapture/win"
	"github.com/nfnt/resize"

	"github.com/kbinani/screenshot"
	"github.com/mattn/go-mjpeg"
)

func main() {
	n := screenshot.NumActiveDisplays()
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer cancel()
	http.HandleFunc("/watch", func(w http.ResponseWriter, r *http.Request) {
		screen := r.URL.Query().Get("screen")
		if screen == "" {
			screen = "0"
		}
		screenNo, err := strconv.Atoi(screen)
		if err != nil {
			w.WriteHeader(500)
			return
		}
		if screenNo >= n || screenNo < 0 {
			screenNo = 0
		}

		w.Header().Set("Content-Type", "text/html")
		w.Write([]byte(`<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title> Screen ` + strconv.Itoa(screenNo) + `</title>
	</head>
		<body style="margin:0">
	<img src="/mjpeg` + strconv.Itoa(screenNo) + `" style="max-width: 100vw; max-height: 100vh;object-fit: contain;display: block;margin: 0 auto;" />
</body>`))
	})

	framerate := 15
	for i := 0; i < n; i++ {
		fmt.Fprintf(os.Stderr, "Registering stream %d\n", i)
		stream := mjpeg.NewStream()
		defer stream.Close()
		// go streamDisplay(ctx, i, framerate, stream)
		go streamDisplayDXGI(ctx, i, framerate, stream)
		// go captureScreenTranscode(ctx, i, framerate)
		http.HandleFunc(fmt.Sprintf("/mjpeg%d", i), stream.ServeHTTP)
	}
	go func() {
		http.ListenAndServe("0.0.0.0:8023", nil)

	}()
	<-ctx.Done()
	<-time.After(time.Second)
}

// Capture using "github.com/kbinani/screenshot" (modified to reuse image.RGBA)
func streamDisplay(ctx context.Context, n int, framerate int, out *mjpeg.Stream) {
	max := screenshot.NumActiveDisplays()
	if n >= max {
		fmt.Printf("Not enough displays\n")
		return
	}
	buf := &bufferFlusher{}
	opts := jpegQuality(75)
	limiter := NewFrameLimiter(framerate)

	var err error
	finalBounds := screenshot.GetDisplayBounds(n)
	imgBuf := image.NewRGBA(finalBounds)

	lastBounds := finalBounds
	for {
		select {
		case <-ctx.Done():
			return
		default:
			limiter.Wait()
		}
		bounds := screenshot.GetDisplayBounds(n)

		x, y, hw, hh := bounds.Min.X, 0, bounds.Dx(), bounds.Dy()
		newBounds := image.Rect(0, 0, int(hw), int(hh))
		if newBounds != lastBounds {
			lastBounds = newBounds
			imgBuf = image.NewRGBA(lastBounds)
		}
		err = forkscreenshot.CaptureImg(imgBuf, int(x), int(y), int(hw), int(hh))
		if err != nil {
			fmt.Printf("Err CaptureImg: %v\n", err)
			continue
		}
		buf.Reset()

		encodeJpeg(buf, imgBuf, opts)
		out.Update(buf.Bytes())
	}
}

// Capture using IDXGIOutputDuplication
//     https://docs.microsoft.com/en-us/windows/win32/api/dxgi1_2/nn-dxgi1_2-idxgioutputduplication
func streamDisplayDXGI(ctx context.Context, n int, framerate int, out *mjpeg.Stream) {
	max := screenshot.NumActiveDisplays()
	if n >= max {
		fmt.Printf("Not enough displays\n")
		return
	}

	// Keep this thread, so windows/d3d11/dxgi can use their threadlocal caches, if any
	runtime.LockOSThread()

	// Make thread PerMonitorV2 Dpi aware if supported on OS
	// allows to let windows handle BGRA -> RGBA conversion and possibly more things
	if win.IsValidDpiAwarenessContext(win.DpiAwarenessContextPerMonitorAwareV2) {
		_, err := win.SetThreadDpiAwarenessContext(win.DpiAwarenessContextPerMonitorAwareV2)
		if err != nil {
			fmt.Printf("Could not set thread DPI awareness to PerMonitorAwareV2. %v\n", err)
		} else {
			fmt.Printf("Enabled PerMonitorAwareV2 DPI awareness.\n")
		}
	}

	// Setup D3D11 stuff
	device, deviceCtx, err := d3d.NewD3D11Device()
	if err != nil {
		fmt.Printf("Could not create D3D11 Device. %v\n", err)
		return
	}
	defer device.Release()
	defer deviceCtx.Release()

	var ddup *d3d.OutputDuplicator
	defer func() {
		if ddup != nil {
			ddup.Release()
			ddup = nil
		}
	}()

	buf := &bufferFlusher{Buffer: bytes.Buffer{}}
	opts := jpegQuality(50)
	limiter := NewFrameLimiter(framerate)
	// Create image that can contain the wanted output (desktop)
	finalBounds := screenshot.GetDisplayBounds(n)
	imgBuf := image.NewRGBA(finalBounds)
	lastBounds := finalBounds

	// TODO: This is just there, so that people can see how resizing might look
	_ = resize.Resize(1920, 1080, imgBuf, resize.Bicubic)

	for {
		select {
		case <-ctx.Done():
			return
		default:
			limiter.Wait()
		}
		bounds := screenshot.GetDisplayBounds(n)
		newBounds := image.Rect(0, 0, int(bounds.Dx()), int(bounds.Dy()))
		if newBounds != lastBounds {
			lastBounds = newBounds
			imgBuf = image.NewRGBA(lastBounds)

			// Throw away old ddup
			if ddup != nil {
				ddup.Release()
				ddup = nil
			}
		}
		// create output duplication if doesn't exist yet (maybe due to resolution change)
		if ddup == nil {
			ddup, err = d3d.NewIDXGIOutputDuplication(device, deviceCtx, uint(n))
			if err != nil {
				fmt.Printf("err: %v\n", err)
				continue
			}
		}

		// Grab an image.RGBA from the current output presenter
		err = ddup.GetImage(imgBuf, 0)
		if err != nil {
			if errors.Is(err, d3d.ErrNoImageYet) {
				// don't update
				continue
			}
			fmt.Printf("Err ddup.GetImage: %v\n", err)
			// Retry with new ddup, can occur when changing resolution
			ddup.Release()
			ddup = nil
			continue
		}
		buf.Reset()
		encodeJpeg(buf, imgBuf, opts)
		out.Update(buf.Bytes())
	}
}

// Workaround for jpeg.Encode(), which requires a Flush()
// method to not call `bufio.NewWriter`
type bufferFlusher struct {
	bytes.Buffer
}

func (*bufferFlusher) Flush() error { return nil }

```

`cmd/example/screencapture.go`:

```go
package main

import (
	"context"
	"errors"
	"fmt"
	"image"
	"io"
	"os/exec"
	"runtime"
	"time"

	"github.com/kirides/screencapture/d3d"

	"github.com/kbinani/screenshot"
)

func captureScreenTranscode(ctx context.Context, n int, framerate int) {
	max := screenshot.NumActiveDisplays()
	if n >= max {
		fmt.Printf("Not enough displays\n")
		return
	}
	screenBounds := screenshot.GetDisplayBounds(n)
	transcoder := newVideotranscoder(fmt.Sprintf("screen_%d.mp4", n), screenBounds.Dx(), screenBounds.Dy(), float32(framerate))

	// Keep this thread, so windows/d3d11/dxgi can use their threadlocal caches, if any
	runtime.LockOSThread()
	// Setup D3D11 stuff
	device, deviceCtx, err := d3d.NewD3D11Device()
	if err != nil {
		fmt.Printf("Could not create D3D11 Device. %v\n", err)
		return
	}
	defer device.Release()
	defer deviceCtx.Release()

	ddup, err := d3d.NewIDXGIOutputDuplication(device, deviceCtx, uint(n))
	if err != nil {
		fmt.Printf("Err NewIDXGIOutputDuplication: %v\n", err)
		return
	}
	defer ddup.Release()

	limiter := NewFrameLimiter(framerate)

	// Create image that can contain the wanted output (desktop)
	imgBuf := image.NewRGBA(screenBounds)

	defer transcoder.Close()
	t1 := time.Now()
	numFrames := 0
	for {
		if time.Since(t1).Seconds() >= 1 {
			fmt.Printf("%d: written %d frames in 1s\n", n, numFrames)
			t1 = time.Now()
			numFrames = 0
		}
		select {
		case <-ctx.Done():
			return
		default:
			limiter.Wait()
		}
		// Grab an image.RGBA from the current output presenter
		err = ddup.GetImage(imgBuf, 0)
		if err != nil && !errors.Is(err, d3d.ErrNoImageYet) {
			fmt.Printf("Err ddup.GetImage: %v\n", err)
			return
		}

		numFrames++

		n, err := transcoder.Write(imgBuf.Pix)
		if err != nil || n != len(imgBuf.Pix) {
			fmt.Printf("Failed to write image: %v\n", err)
			return
		}
	}
}

type videotranscoder struct {
	cmd *exec.Cmd

	in io.WriteCloser
}

func newVideotranscoder(filePath string, width, height int, framerate float32) *videotranscoder {
	cmd := exec.Command("ffmpeg",
		"-y",
		"-vsync", "0",
		"-f", "rawvideo",
		"-video_size", fmt.Sprintf("%dx%d", width, height),
		"-pixel_format", "rgba",
		"-framerate", fmt.Sprintf("%f", framerate),
		"-i", "-",
		// "-vf", "scale=-1:1080",
		"-c:v", "libx264", "-preset", "ultrafast",
		"-crf", "26",
		"-tune", "zerolatency",
		filePath,
	)

	wc, err := cmd.StdinPipe()
	if err != nil {
		panic(err)
	}
	if err := cmd.Start(); err != nil {
		panic(err)
	}
	return &videotranscoder{
		cmd: cmd,
		in:  wc,
	}
}
func (v *videotranscoder) Write(buf []byte) (int, error) {
	return v.in.Write(buf)
}
func (v *videotranscoder) Close() error {
	// v.out.Close()
	v.in.Close()
	return nil
}

// finer granularity for sleeping
type frameLimiter struct {
	DesiredFps  int
	frameTimeNs int64

	LastFrameTime     time.Time
	LastSleepDuration time.Duration

	DidSleep bool
	DidSpin  bool
}

func NewFrameLimiter(desiredFps int) *frameLimiter {
	return &frameLimiter{
		DesiredFps:    desiredFps,
		frameTimeNs:   (time.Second / time.Duration(desiredFps)).Nanoseconds(),
		LastFrameTime: time.Now(),
	}
}

func (l *frameLimiter) Wait() {
	l.DidSleep = false
	l.DidSpin = false

	now := time.Now()
	spinWaitUntil := now

	sleepTime := l.frameTimeNs - now.Sub(l.LastFrameTime).Nanoseconds()

	if sleepTime > int64(1*time.Millisecond) {
		if sleepTime < int64(30*time.Millisecond) {
			l.LastSleepDuration = time.Duration(sleepTime / 8)
		} else {
			l.LastSleepDuration = time.Duration(sleepTime / 4 * 3)
		}
		time.Sleep(time.Duration(l.LastSleepDuration))
		l.DidSleep = true

		newNow := time.Now()
		spinWaitUntil = newNow.Add(time.Duration(sleepTime) - newNow.Sub(now))
		now = newNow

		for spinWaitUntil.After(now) {
			now = time.Now()
			// SPIN WAIT
			l.DidSpin = true
		}
	} else {
		l.LastSleepDuration = 0
		spinWaitUntil = now.Add(time.Duration(sleepTime))
		for spinWaitUntil.After(now) {
			now = time.Now()
			// SPIN WAIT
			l.DidSpin = true
		}
	}
	l.LastFrameTime = time.Now()
}

```

`d3d/com_utils.go`:

```go
package d3d

import (
	"reflect"
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

func reflectQueryInterface(self interface{}, method uintptr, interfaceID *windows.GUID, obj interface{}) int32 {
	selfValue := reflect.ValueOf(self).Elem()
	objValue := reflect.ValueOf(obj).Elem()

	hr, _, _ := syscall.Syscall(
		method,
		3,
		selfValue.UnsafeAddr(),
		uintptr(unsafe.Pointer(interfaceID)),
		objValue.Addr().Pointer())

	return int32(hr)
}

```

`d3d/d3d11.go`:

```go
package d3d

import (
	"fmt"
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var (
	modD3D11              = windows.NewLazySystemDLL("d3d11.dll")
	procD3D11CreateDevice = modD3D11.NewProc("D3D11CreateDevice")

	// iid_ID3D11Device1, _   = windows.GUIDFromString("{a04bfb29-08ef-43d6-a49c-a9bdbdcbe686}")
	iid_ID3D11Texture2D, _ = windows.GUIDFromString("{6f15aaf2-d208-4e89-9ab4-489535d34f9c}")
	iid_ID3D11Debug, _     = windows.GUIDFromString("{79cf2233-7536-4948-9d36-1e4692dc5760}")
	iid_ID3D11InfoQueue, _ = windows.GUIDFromString("{6543dbb6-1b48-42f5-ab82-e97ec74326f6}")
)

const (
	D3D11_USAGE_DEFAULT = 0
	D3D11_USAGE_STAGING = 3

	D3D11_CPU_ACCESS_READ = 0x20000

	D3D11_RLDO_SUMMARY         = 0x1
	D3D11_RLDO_DETAIL          = 0x2
	D3D11_RLDO_IGNORE_INTERNAL = 0x4

	D3D11_CREATE_DEVICE_DEBUG        = 0x2
	D3D11_CREATE_DEVICE_BGRA_SUPPORT = 0x20

	D3D11_SDK_VERSION = 7
)

func _D3D11CreateDevice(ppDevice **ID3D11Device, ppDeviceContext **ID3D11DeviceContext) error {
	var factory1 *IDXGIFactory1
	if err := _CreateDXGIFactory1(&factory1); err != nil {
		return fmt.Errorf("CreateDXGIFactory1: %w", err)
	}
	defer factory1.Release()

	var adapter1 *IDXGIAdapter1
	if hr := factory1.EnumAdapters1(0, &adapter1); failed(hr) {
		return fmt.Errorf("failed to enumerate desktop adapter. %w", HRESULT(hr))
	}
	defer adapter1.Release()

	fflags := [...]uint32{
		// 0xc100, // D3D_FEATURE_LEVEL_12_1
		// 0xc000, // D3D_FEATURE_LEVEL_12_0
		0xb100, // D3D_FEATURE_LEVEL_11_1
		0xb000, // D3D_FEATURE_LEVEL_11_0
		// 0xa100, // D3D_FEATURE_LEVEL_10_1
		// 0xa000, // D3D_FEATURE_LEVEL_10_0
		// 0x9300, // D3D_FEATURE_LEVEL_9_3
		// 0x9200, // D3D_FEATURE_LEVEL_9_2
		// 0x9100, // D3D_FEATURE_LEVEL_9_1
		// 0x1000, // D3D_FEATURE_LEVEL_1_0_CORE <-- unsupported!
	}
	featureLevel := 0x9100
	flags :=
		//  D3D11_CREATE_DEVICE_DEBUG |
		0

	ret, _, _ := syscall.Syscall12(
		procD3D11CreateDevice.Addr(),
		10,
		uintptr(unsafe.Pointer(adapter1)),   // pAdapter
		uintptr(0),                          // driverType: 1 = Hardware
		0,                                   // software
		uintptr(flags),                      // flags
		uintptr(unsafe.Pointer(&fflags[0])), // supported feature levels
		uintptr(len(fflags)),                // number of levels
		uintptr(D3D11_SDK_VERSION),
		uintptr(unsafe.Pointer(ppDevice)),        // *D3D11Device
		uintptr(unsafe.Pointer(&featureLevel)),   // feature level
		uintptr(unsafe.Pointer(ppDeviceContext)), // *D3D11DeviceContext
		0,
		0,
	)

	if ret != 0 {
		return HRESULT(ret)
	}
	return nil
}

func NewD3D11Device() (*ID3D11Device, *ID3D11DeviceContext, error) {
	var device *ID3D11Device
	var deviceCtx *ID3D11DeviceContext

	err := _D3D11CreateDevice(&device, &deviceCtx)

	if err != nil || device == nil || deviceCtx == nil {
		return nil, nil, err
	}

	return device, deviceCtx, nil
}

type ID3D11Texture2D struct {
	vtbl *iD3D11Texture2DVtbl
}

func (obj *ID3D11Texture2D) GetDesc(desc *_D3D11_TEXTURE2D_DESC) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetDesc,
		2,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(desc)),
		0,
	)
	return int32(ret)
}
func (obj *ID3D11Texture2D) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}
func (obj *ID3D11Texture2D) QueryInterface(iid windows.GUID, pp interface{}) int32 {
	return reflectQueryInterface(obj, obj.vtbl.QueryInterface, &iid, pp)
}

type ID3D11Device struct {
	vtbl *iD3D11DeviceVtbl
}

func (obj *ID3D11Device) QueryInterface(iid windows.GUID, pp interface{}) int32 {
	return reflectQueryInterface(obj, obj.vtbl.QueryInterface, &iid, pp)
}

func (obj *ID3D11Device) CreateTexture2D(desc *_D3D11_TEXTURE2D_DESC, ppTexture2D **ID3D11Texture2D) int32 {
	ret, _, _ := syscall.Syscall6(
		obj.vtbl.CreateTexture2D,
		4,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(desc)),
		0,
		uintptr(unsafe.Pointer(ppTexture2D)),
		0,
		0,
	)
	return int32(ret)
}

func (obj *ID3D11Device) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type ID3D11Device1 struct {
	vtbl *iD3D11DeviceVtbl
}

func (obj *ID3D11Device1) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

func (obj *ID3D11Device1) CreateTexture2D(desc *_D3D11_TEXTURE2D_DESC, ppTexture2D **ID3D11Texture2D) int32 {
	ret, _, _ := syscall.Syscall6(
		obj.vtbl.CreateTexture2D,
		4,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(desc)),
		0,
		uintptr(unsafe.Pointer(ppTexture2D)),
		0,
		0,
	)
	return int32(ret)
}

type ID3D11DeviceContext struct {
	vtbl *iD3D11DeviceContextVtbl
}

func (obj *ID3D11DeviceContext) CopyResourceDXGI(dst, src *IDXGIResource) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.CopyResource,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(dst)),
		uintptr(unsafe.Pointer(src)),
	)
	return int32(ret)
}
func (obj *ID3D11DeviceContext) CopyResource2D(dst, src *ID3D11Texture2D) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.CopyResource,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(dst)),
		uintptr(unsafe.Pointer(src)),
	)
	return int32(ret)
}
func (obj *ID3D11DeviceContext) CopySubresourceRegion2D(dst *ID3D11Texture2D, dstSubResource, dstX, dstY, dstZ uint32, src *ID3D11Texture2D, srcSubResource uint32, pSrcBox *_D3D11_BOX) int32 {
	ret, _, _ := syscall.Syscall9(
		obj.vtbl.CopySubresourceRegion,
		9,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(dst)),
		uintptr(dstSubResource),
		uintptr(dstX),
		uintptr(dstY),
		uintptr(dstZ),
		uintptr(unsafe.Pointer(src)),
		uintptr(srcSubResource),
		uintptr(unsafe.Pointer(pSrcBox)),
	)
	return int32(ret)
}

func (obj *ID3D11DeviceContext) CopySubresourceRegion(dst *ID3D11Resource, dstSubResource, dstX, dstY, dstZ uint32, src *ID3D11Resource, srcSubResource uint32, pSrcBox *_D3D11_BOX) int32 {
	ret, _, _ := syscall.Syscall9(
		obj.vtbl.CopySubresourceRegion,
		9,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(dst)),
		uintptr(dstSubResource),
		uintptr(dstX),
		uintptr(dstY),
		uintptr(dstZ),
		uintptr(unsafe.Pointer(src)),
		uintptr(srcSubResource),
		uintptr(unsafe.Pointer(pSrcBox)),
	)
	return int32(ret)
}
func (obj *ID3D11DeviceContext) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type ID3D11Resource struct {
	vtbl *iD3D11ResourceVtbl
}

func (obj *ID3D11Resource) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

```

`d3d/d3d11_types.go`:

```go
package d3d

type _D3D11_BOX struct {
	Left, Top, Front, Right, Bottom, Back uint32
}

type _D3D11_TEXTURE2D_DESC struct {
	Width          uint32
	Height         uint32
	MipLevels      uint32
	ArraySize      uint32
	Format         uint32
	SampleDesc     _DXGI_SAMPLE_DESC
	Usage          uint32
	BindFlags      uint32
	CPUAccessFlags uint32
	MiscFlags      uint32
}

```

`d3d/d3d11_vtbl.go`:

```go
package d3d

type iD3D11DeviceChildVtbl struct {
	iUnknownVtbl

	GetDevice               uintptr
	GetPrivateData          uintptr
	SetPrivateData          uintptr
	SetPrivateDataInterface uintptr
}

type iD3D11DeviceContextVtbl struct {
	iD3D11DeviceChildVtbl

	VSSetConstantBuffers                      uintptr
	PSSetShaderResources                      uintptr
	PSSetShader                               uintptr
	PSSetSamplers                             uintptr
	VSSetShader                               uintptr
	DrawIndexed                               uintptr
	Draw                                      uintptr
	Map                                       uintptr
	Unmap                                     uintptr
	PSSetConstantBuffers                      uintptr
	IASetInputLayout                          uintptr
	IASetVertexBuffers                        uintptr
	IASetIndexBuffer                          uintptr
	DrawIndexedInstanced                      uintptr
	DrawInstanced                             uintptr
	GSSetConstantBuffers                      uintptr
	GSSetShader                               uintptr
	IASetPrimitiveTopology                    uintptr
	VSSetShaderResources                      uintptr
	VSSetSamplers                             uintptr
	Begin                                     uintptr
	End                                       uintptr
	GetData                                   uintptr
	SetPredication                            uintptr
	GSSetShaderResources                      uintptr
	GSSetSamplers                             uintptr
	OMSetRenderTargets                        uintptr
	OMSetRenderTargetsAndUnorderedAccessViews uintptr
	OMSetBlendState                           uintptr
	OMSetDepthStencilState                    uintptr
	SOSetTargets                              uintptr
	DrawAuto                                  uintptr
	DrawIndexedInstancedIndirect              uintptr
	DrawInstancedIndirect                     uintptr
	Dispatch                                  uintptr
	DispatchIndirect                          uintptr
	RSSetState                                uintptr
	RSSetViewports                            uintptr
	RSSetScissorRects                         uintptr
	CopySubresourceRegion                     uintptr
	CopyResource                              uintptr

	/// .....
}

type iD3D11DeviceVtbl struct {
	iUnknownVtbl

	CreateBuffer                         uintptr
	CreateTexture1D                      uintptr
	CreateTexture2D                      uintptr
	CreateTexture3D                      uintptr
	CreateShaderResourceView             uintptr
	CreateUnorderedAccessView            uintptr
	CreateRenderTargetView               uintptr
	CreateDepthStencilView               uintptr
	CreateInputLayout                    uintptr
	CreateVertexShader                   uintptr
	CreateGeometryShader                 uintptr
	CreateGeometryShaderWithStreamOutput uintptr
	CreatePixelShader                    uintptr
	CreateHullShader                     uintptr
	CreateDomainShader                   uintptr
	CreateComputeShader                  uintptr
	CreateClassLinkage                   uintptr
	CreateBlendState                     uintptr
	CreateDepthStencilState              uintptr
	CreateRasterizerState                uintptr
	CreateSamplerState                   uintptr
	CreateQuery                          uintptr
	CreatePredicate                      uintptr
	CreateCounter                        uintptr
	CreateDeferredContext                uintptr
	OpenSharedResource                   uintptr
	CheckFormatSupport                   uintptr
	CheckMultisampleQualityLevels        uintptr
	CheckCounterInfo                     uintptr
	CheckCounter                         uintptr
	CheckFeatureSupport                  uintptr
	GetPrivateData                       uintptr
	SetPrivateData                       uintptr
	SetPrivateDataInterface              uintptr
	GetFeatureLevel                      uintptr
	GetCreationFlags                     uintptr
	GetDeviceRemovedReason               uintptr
	GetImmediateContext                  uintptr
	SetExceptionMode                     uintptr
	GetExceptionMode                     uintptr
}

type iD3D11DebugVtbl struct {
	iUnknownVtbl

	SetFeatureMask             uintptr
	GetFeatureMask             uintptr
	SetPresentPerRenderOpDelay uintptr
	GetPresentPerRenderOpDelay uintptr
	SetSwapChain               uintptr
	GetSwapChain               uintptr
	ValidateContext            uintptr
	ReportLiveDeviceObjects    uintptr
	ValidateContextForDispatch uintptr
}

type iD3D11InfoQueueVtbl struct {
	iUnknownVtbl

	AddApplicationMessage                        uintptr
	AddMessage                                   uintptr
	AddRetrievalFilterEntries                    uintptr
	AddStorageFilterEntries                      uintptr
	ClearRetrievalFilter                         uintptr
	ClearStorageFilter                           uintptr
	ClearStoredMessages                          uintptr
	GetBreakOnCategory                           uintptr
	GetBreakOnID                                 uintptr
	GetBreakOnSeverity                           uintptr
	GetMessage                                   uintptr
	GetMessageCountLimit                         uintptr
	GetMuteDebugOutput                           uintptr
	GetNumMessagesAllowedByStorageFilter         uintptr
	GetNumMessagesDeniedByStorageFilter          uintptr
	GetNumMessagesDiscardedByMessageCountLimit   uintptr
	GetNumStoredMessages                         uintptr
	GetNumStoredMessagesAllowedByRetrievalFilter uintptr
	GetRetrievalFilter                           uintptr
	GetRetrievalFilterStackSize                  uintptr
	GetStorageFilter                             uintptr
	GetStorageFilterStackSize                    uintptr
	PopRetrievalFilter                           uintptr
	PopStorageFilter                             uintptr
	PushCopyOfRetrievalFilter                    uintptr
	PushCopyOfStorageFilter                      uintptr
	PushEmptyRetrievalFilter                     uintptr
	PushEmptyStorageFilter                       uintptr
	PushRetrievalFilter                          uintptr
	PushStorageFilter                            uintptr
	SetBreakOnCategory                           uintptr
	SetBreakOnID                                 uintptr
	SetBreakOnSeverity                           uintptr
	SetMessageCountLimit                         uintptr
	SetMuteDebugOutput                           uintptr
}
type iD3D11ResourceVtbl struct {
	iD3D11DeviceChildVtbl

	GetType             uintptr
	SetEvictionPriority uintptr
	GetEvictionPriority uintptr
}

type iD3D11Texture2DVtbl struct {
	iD3D11ResourceVtbl

	GetDesc uintptr
}

```

`d3d/d3d11debug.go`:

```go
package d3d

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

type ID3D11Debug struct {
	vtbl *iD3D11DebugVtbl
}

func (obj *ID3D11Debug) QueryInterface(iid windows.GUID, pp interface{}) int32 {
	return reflectQueryInterface(obj, obj.vtbl.QueryInterface, &iid, pp)
}
func (obj *ID3D11Debug) ReportLiveDeviceObjects(flags uint32) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.ReportLiveDeviceObjects,
		2,
		uintptr(unsafe.Pointer(obj)),
		uintptr(flags),
		0,
	)
	return int32(ret)
}
func (obj *ID3D11Debug) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type ID3D11InfoQueue struct {
	vtbl *iD3D11InfoQueueVtbl
}

func (obj *ID3D11InfoQueue) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

```

`d3d/dxgi.go`:

```go
package d3d

import (
	"fmt"
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var (
	modDXGI                = windows.NewLazySystemDLL("dxgi.dll")
	procCreateDXGIFactory1 = modDXGI.NewProc("CreateDXGIFactory1")

	// iid_IDXGIDevice, _   = windows.GUIDFromString("{54ec77fa-1377-44e6-8c32-88fd5f44c84c}")
	iid_IDXGIDevice1, _ = windows.GUIDFromString("{77db970f-6276-48ba-ba28-070143b4392c}")
	// iid_IDXGIAdapter, _  = windows.GUIDFromString("{2411E7E1-12AC-4CCF-BD14-9798E8534DC0}")
	iid_IDXGIAdapter1, _ = windows.GUIDFromString("{29038f61-3839-4626-91fd-086879011a05}")
	// iid_IDXGIOutput, _   = windows.GUIDFromString("{ae02eedb-c735-4690-8d52-5a8dc20213aa}")
	iid_IDXGIOutput1, _  = windows.GUIDFromString("{00cddea8-939b-4b83-a340-a685226666cc}")
	iid_IDXGIOutput5, _  = windows.GUIDFromString("{80A07424-AB52-42EB-833C-0C42FD282D98}")
	iid_IDXGIFactory1, _ = windows.GUIDFromString("{770aae78-f26f-4dba-a829-253c83d1b387}")
	// iid_IDXGIResource, _ = windows.GUIDFromString("{035f3ab4-482e-4e50-b41f-8a7f8bd8960b}")
	iid_IDXGISurface, _ = windows.GUIDFromString("{cafcb56c-6ac3-4889-bf47-9e23bbd260ec}")
)

const (
	DXGI_MAP_READ    = 1 << 0
	DXGI_MAP_WRITE   = 1 << 1
	DXGI_MAP_DISCARD = 1 << 2
)

type IDXGIFactory1 struct {
	vtbl *iDXGIFactory1Vtbl
}

func (obj *IDXGIFactory1) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

func (obj *IDXGIFactory1) EnumAdapters1(adapter uint, pp **IDXGIAdapter1) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.EnumAdapters1,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(adapter),
		uintptr(unsafe.Pointer(pp)),
	)
	return int32(ret)
}

func _CreateDXGIFactory1(ppFactory **IDXGIFactory1) error {
	ret, _, _ := syscall.Syscall(
		procCreateDXGIFactory1.Addr(),
		2,
		uintptr(unsafe.Pointer(&iid_IDXGIFactory1)),
		uintptr(unsafe.Pointer(ppFactory)),
		0,
	)
	if ret != 0 {
		return HRESULT(ret)
	}

	return nil
}

// NewXASession casts your ppv from above to a *XASession
func NewIDXGIOutputDuplication(device *ID3D11Device, deviceCtx *ID3D11DeviceContext, output uint) (*OutputDuplicator, error) {
	var hr int32

	// DEBUG

	var d3dDebug *ID3D11Debug
	hr = device.QueryInterface(iid_ID3D11Debug, &d3dDebug)
	if !failed(hr) {
		defer d3dDebug.Release()

		var d3dInfoQueue *ID3D11InfoQueue
		hr = d3dDebug.QueryInterface(iid_ID3D11InfoQueue, &d3dInfoQueue)
		if failed(hr) {
			return nil, fmt.Errorf("failed at device.QueryInterface. %w", HRESULT(hr))
		}
		defer d3dInfoQueue.Release()
		// defer d3dDebug.ReportLiveDeviceObjects(D3D11_RLDO_SUMMARY | D3D11_RLDO_DETAIL)
	}

	var dxgiDevice1 *IDXGIDevice1
	hr = device.QueryInterface(iid_IDXGIDevice1, &dxgiDevice1)
	if failed(hr) {
		return nil, fmt.Errorf("failed at device.QueryInterface. %w", HRESULT(hr))
	}
	defer dxgiDevice1.Release()

	var pdxgiAdapter unsafe.Pointer
	hr = dxgiDevice1.GetParent(iid_IDXGIAdapter1, &pdxgiAdapter)
	if failed(hr) {
		return nil, fmt.Errorf("failed at dxgiDevice1.GetAdapter. %w", HRESULT(hr))
	}
	dxgiAdapter := (*IDXGIAdapter1)(pdxgiAdapter)
	defer dxgiAdapter.Release()

	var dxgiOutput *IDXGIOutput
	// const DXGI_ERROR_NOT_FOUND = 0x887A0002
	hr = int32(dxgiAdapter.EnumOutputs(output, &dxgiOutput))
	if failed(hr) {
		return nil, fmt.Errorf("failed at dxgiAdapter.EnumOutputs. %w", HRESULT(hr))
	}
	defer dxgiOutput.Release()

	var dxgiOutput5 *IDXGIOutput5
	hr = dxgiOutput.QueryInterface(iid_IDXGIOutput5, &dxgiOutput5)
	if failed(hr) {
		return nil, fmt.Errorf("failed at dxgiOutput.QueryInterface. %w", HRESULT(hr))
	}
	defer dxgiOutput5.Release()
	var dup *IDXGIOutputDuplication
	hr = dxgiOutput5.DuplicateOutput1(dxgiDevice1, 0, []DXGI_FORMAT{
		DXGI_FORMAT_R8G8B8A8_UNORM,
		// using the former, we don't have to swizzle ourselves
		// DXGI_FORMAT_B8G8R8A8_UNORM,
	}, &dup)
	needsSwizzle := false
	if failed(hr) {
		needsSwizzle = true
		// fancy stuff not supported :/
		// fmt.Printf("Info: failed to use dxgiOutput5.DuplicateOutput1, falling back to dxgiOutput1.DuplicateOutput. Missing manifest with DPI awareness set to \"PerMonitorV2\"? %v\n", _DXGI_ERROR(hr))
		var dxgiOutput1 *IDXGIOutput1
		hr = dxgiOutput.QueryInterface(iid_IDXGIOutput1, &dxgiOutput1)
		if failed(hr) {
			return nil, fmt.Errorf("failed at dxgiOutput.QueryInterface. %w", HRESULT(hr))
		}
		defer dxgiOutput1.Release()
		hr = dxgiOutput1.DuplicateOutput(dxgiDevice1, &dup)
		if failed(hr) {
			return nil, fmt.Errorf("failed at dxgiOutput1.DuplicateOutput. %w", HRESULT(hr))
		}
	}

	return &OutputDuplicator{device: device, deviceCtx: deviceCtx, outputDuplication: dup, needsSwizzle: needsSwizzle}, nil
}

type IDXGIAdapter1 struct {
	vtbl *IDXGIAdapter1Vtbl
}

func (obj *IDXGIAdapter1) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

func (obj *IDXGIAdapter1) EnumOutputs(output uint, pp **IDXGIOutput) uint32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.EnumOutputs,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(output),
		uintptr(unsafe.Pointer(pp)),
	)
	return uint32(ret)
}

type IDXGIAdapter struct {
	vtbl *IDXGIAdapterVtbl
}

func (obj *IDXGIAdapter) EnumOutputs(output uint, pp **IDXGIOutput) uint32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.EnumOutputs,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(output),
		uintptr(unsafe.Pointer(pp)),
	)
	return uint32(ret)
}

func (obj *IDXGIAdapter) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type IDXGIDevice struct {
	vtbl *iDXGIDeviceVtbl
}

func (obj *IDXGIDevice) GetGPUThreadPriority(priority *int) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetGPUThreadPriority,
		2,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(priority)),
		0,
	)
	return int32(ret)
}
func (obj *IDXGIDevice) QueryInterface(iid windows.GUID, pp interface{}) int32 {
	return reflectQueryInterface(obj, obj.vtbl.QueryInterface, &iid, pp)
}
func (obj *IDXGIDevice) GetParent(iid windows.GUID, pp *unsafe.Pointer) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetParent,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(&iid)),
		uintptr(unsafe.Pointer(pp)),
	)
	return int32(ret)
}
func (obj *IDXGIDevice) GetAdapter(pAdapter **IDXGIAdapter) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetAdapter,
		2,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(pAdapter)),
		0,
	)
	return int32(ret)
}
func (obj *IDXGIDevice) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type IDXGIDevice1 struct {
	vtbl *iDXGIDevice1Vtbl
}

func (obj *IDXGIDevice1) QueryInterface(iid windows.GUID, pp interface{}) int32 {
	return reflectQueryInterface(obj, obj.vtbl.QueryInterface, &iid, pp)
}

func (obj *IDXGIDevice1) GetParent(iid windows.GUID, pp *unsafe.Pointer) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetParent,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(&iid)),
		uintptr(unsafe.Pointer(pp)),
	)

	return int32(ret)
}
func (obj *IDXGIDevice1) GetAdapter(pAdapter *IDXGIAdapter) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetAdapter,
		2,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(&pAdapter)),
		0,
	)

	return int32(ret)
}
func (obj *IDXGIDevice1) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type IDXGIOutput struct {
	vtbl *iDXGIOutputVtbl
}

func (obj *IDXGIOutput) QueryInterface(iid windows.GUID, pp interface{}) int32 {
	return reflectQueryInterface(obj, obj.vtbl.QueryInterface, &iid, pp)
}

func (obj *IDXGIOutput) GetParent(iid windows.GUID, pp *unsafe.Pointer) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetParent,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(&iid)),
		uintptr(unsafe.Pointer(pp)),
	)
	return int32(ret)
}

func (obj *IDXGIOutput) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type IDXGIOutput1 struct {
	vtbl *iDXGIOutput1Vtbl
}

func (obj *IDXGIOutput1) DuplicateOutput(device1 *IDXGIDevice1, ppOutputDuplication **IDXGIOutputDuplication) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.DuplicateOutput,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(device1)),
		uintptr(unsafe.Pointer(ppOutputDuplication)),
	)
	return int32(ret)
}

func (obj *IDXGIOutput1) GetParent(iid windows.GUID, pp *unsafe.Pointer) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetParent,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(&iid)),
		uintptr(unsafe.Pointer(pp)),
	)
	return int32(ret)
}

func (obj *IDXGIOutput1) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type IDXGIOutput5 struct {
	vtbl *iDXGIOutput5Vtbl
}

type DXGI_FORMAT uint32

func (obj *IDXGIOutput5) DuplicateOutput1(device1 *IDXGIDevice1, flags uint, pSupportedFormats []DXGI_FORMAT, ppOutputDuplication **IDXGIOutputDuplication) int32 {
	pFormats := &pSupportedFormats[0]
	ret, _, _ := syscall.Syscall6(
		obj.vtbl.DuplicateOutput1,
		6,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(device1)),
		uintptr(flags),
		uintptr(len(pSupportedFormats)),
		uintptr(unsafe.Pointer(pFormats)),
		uintptr(unsafe.Pointer(ppOutputDuplication)),
	)
	return int32(ret)
}

func (obj *IDXGIOutput5) GetParent(iid windows.GUID, pp *unsafe.Pointer) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetParent,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(&iid)),
		uintptr(unsafe.Pointer(pp)),
	)
	return int32(ret)
}

func (obj *IDXGIOutput5) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type IDXGIResource struct {
	vtbl *iDXGIResourceVtbl
}

func (obj *IDXGIResource) QueryInterface(iid windows.GUID, pp interface{}) int32 {
	return reflectQueryInterface(obj, obj.vtbl.QueryInterface, &iid, pp)
}
func (obj *IDXGIResource) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type IDXGISurface struct {
	vtbl *iDXGISurfaceVtbl
}

func (obj *IDXGISurface) QueryInterface(iid windows.GUID, pp interface{}) int32 {
	return reflectQueryInterface(obj, obj.vtbl.QueryInterface, &iid, pp)
}
func (obj *IDXGISurface) Map(pLockedRect *DXGI_MAPPED_RECT, mapFlags uint32) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Map,
		3,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(pLockedRect)),
		uintptr(mapFlags),
	)
	return int32(ret)
}
func (obj *IDXGISurface) Unmap() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Unmap,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}
func (obj *IDXGISurface) Release() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}

type IDXGIOutputDuplication struct {
	vtbl *iDXGIOutputDuplicationVtbl
}

func (obj *IDXGIOutputDuplication) GetFrameMoveRects(buffer []_DXGI_OUTDUPL_MOVE_RECT, rectsRequired *uint32) int32 {
	var buf *_DXGI_OUTDUPL_MOVE_RECT
	if len(buffer) > 0 {
		buf = &buffer[0]
	}
	size := uint32(len(buffer) * 24)
	ret, _, _ := syscall.Syscall6(
		obj.vtbl.GetFrameMoveRects,
		4,
		uintptr(unsafe.Pointer(obj)),
		uintptr(size),
		uintptr(unsafe.Pointer(buf)),
		uintptr(unsafe.Pointer(rectsRequired)),
		0,
		0,
	)
	*rectsRequired = *rectsRequired / 24
	return int32(ret)
}
func (obj *IDXGIOutputDuplication) GetFrameDirtyRects(buffer []RECT, rectsRequired *uint32) int32 {
	var buf *RECT
	if len(buffer) > 0 {
		buf = &buffer[0]
	}
	size := uint32(len(buffer) * 16)
	ret, _, _ := syscall.Syscall6(
		obj.vtbl.GetFrameDirtyRects,
		4,
		uintptr(unsafe.Pointer(obj)),
		uintptr(size),
		uintptr(unsafe.Pointer(buf)),
		uintptr(unsafe.Pointer(rectsRequired)),
		0,
		0,
	)
	*rectsRequired = *rectsRequired / 16
	return int32(ret)
}

func (obj *IDXGIOutputDuplication) GetFramePointerShape(pointerShapeBufferSize uint32,
	pPointerShapeBuffer []byte,
	pPointerShapeBufferSizeRequired *uint32,
	pPointerShapeInfo *_DXGI_OUTDUPL_POINTER_SHAPE_INFO) int32 {

	var buf *byte
	if len(pPointerShapeBuffer) > 0 {
		buf = &pPointerShapeBuffer[0]
	}

	ret, _, _ := syscall.Syscall6(
		obj.vtbl.GetFramePointerShape,
		5,
		uintptr(unsafe.Pointer(obj)),
		uintptr(pointerShapeBufferSize),
		uintptr(unsafe.Pointer(buf)),
		uintptr(unsafe.Pointer(pPointerShapeBufferSizeRequired)),
		uintptr(unsafe.Pointer(pPointerShapeInfo)),
		0,
	)

	return int32(ret)
}
func (obj *IDXGIOutputDuplication) GetDesc(desc *_DXGI_OUTDUPL_DESC) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.GetDesc,
		2,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(desc)),
		0,
	)
	return int32(ret)
}

func (obj *IDXGIOutputDuplication) MapDesktopSurface(pLockedRect *DXGI_MAPPED_RECT) int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.MapDesktopSurface,
		2,
		uintptr(unsafe.Pointer(obj)),
		uintptr(unsafe.Pointer(pLockedRect)),
		0,
	)
	return int32(ret)
}
func (obj *IDXGIOutputDuplication) UnMapDesktopSurface() int32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.UnMapDesktopSurface,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return int32(ret)
}
func (obj *IDXGIOutputDuplication) AddRef() uint32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.AddRef,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return uint32(ret)
}

func (obj *IDXGIOutputDuplication) Release() uint32 {
	ret, _, _ := syscall.Syscall(
		obj.vtbl.Release,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
	return uint32(ret)
}

func (obj *IDXGIOutputDuplication) AcquireNextFrame(timeoutMs uint, pFrameInfo *_DXGI_OUTDUPL_FRAME_INFO, ppDesktopResource **IDXGIResource) uint32 {
	ret, _, _ := syscall.Syscall6(
		obj.vtbl.AcquireNextFrame,    // function address
		4,                            // number of parameters to this function
		uintptr(unsafe.Pointer(obj)), // always pass the COM object address first
		uintptr(timeoutMs),           // then all function parameters follow
		uintptr(unsafe.Pointer(pFrameInfo)),
		uintptr(unsafe.Pointer(ppDesktopResource)),
		0,
		0,
	)
	return uint32(ret)
}

func (obj *IDXGIOutputDuplication) ReleaseFrame() {
	syscall.Syscall(
		obj.vtbl.ReleaseFrame,
		1,
		uintptr(unsafe.Pointer(obj)),
		0,
		0,
	)
}

```

`d3d/dxgi_types.go`:

```go
package d3d

//go:generate stringer -type=_DXGI_OUTDUPL_POINTER_SHAPE_TYPE -output=dxgi_types_string.go

type _DXGI_RATIONAL struct {
	Numerator   uint32
	Denominator uint32
}
type _DXGI_MODE_DESC struct {
	Width            uint32
	Height           uint32
	Rational         _DXGI_RATIONAL
	Format           uint32 // DXGI_FORMAT
	ScanlineOrdering uint32 // DXGI_MODE_SCANLINE_ORDER
	Scaling          uint32 // DXGI_MODE_SCALING
}

type _DXGI_OUTDUPL_DESC struct {
	ModeDesc                   _DXGI_MODE_DESC
	Rotation                   uint32 // DXGI_MODE_ROTATION
	DesktopImageInSystemMemory uint32 // BOOL
}

type _DXGI_SAMPLE_DESC struct {
	Count   uint32
	Quality uint32
}

type POINT struct {
	X int32
	Y int32
}
type RECT struct {
	Left, Top, Right, Bottom int32
}

type _DXGI_OUTDUPL_MOVE_RECT struct {
	Src  POINT
	Dest RECT
}
type _DXGI_OUTDUPL_POINTER_POSITION struct {
	Position POINT
	Visible  uint32
}
type _DXGI_OUTDUPL_FRAME_INFO struct {
	LastPresentTime           int64
	LastMouseUpdateTime       int64
	AccumulatedFrames         uint32
	RectsCoalesced            uint32
	ProtectedContentMaskedOut uint32
	PointerPosition           _DXGI_OUTDUPL_POINTER_POSITION
	TotalMetadataBufferSize   uint32
	PointerShapeBufferSize    uint32
}
type DXGI_MAPPED_RECT struct {
	Pitch int32
	PBits uintptr
}

const (
	DXGI_FORMAT_R8G8B8A8_UNORM DXGI_FORMAT = 28
	DXGI_FORMAT_B8G8R8A8_UNORM DXGI_FORMAT = 87
)

type _DXGI_OUTDUPL_POINTER_SHAPE_TYPE uint32

const (
	DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROME   _DXGI_OUTDUPL_POINTER_SHAPE_TYPE = 1
	DXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR        _DXGI_OUTDUPL_POINTER_SHAPE_TYPE = 2
	DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR _DXGI_OUTDUPL_POINTER_SHAPE_TYPE = 4
)

type _DXGI_OUTDUPL_POINTER_SHAPE_INFO struct {
	Type    _DXGI_OUTDUPL_POINTER_SHAPE_TYPE
	Width   uint32
	Height  uint32
	Pitch   uint32
	HotSpot POINT
}

```

`d3d/dxgi_types_string.go`:

```go
// Code generated by "stringer -type=_DXGI_OUTDUPL_POINTER_SHAPE_TYPE -output=dxgi_types_string.go"; DO NOT EDIT.

package d3d

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROME-1]
	_ = x[DXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR-2]
	_ = x[DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR-4]
}

const (
	__DXGI_OUTDUPL_POINTER_SHAPE_TYPE_name_0 = "DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROMEDXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR"
	__DXGI_OUTDUPL_POINTER_SHAPE_TYPE_name_1 = "DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR"
)

var (
	__DXGI_OUTDUPL_POINTER_SHAPE_TYPE_index_0 = [...]uint8{0, 42, 79}
)

func (i _DXGI_OUTDUPL_POINTER_SHAPE_TYPE) String() string {
	switch {
	case 1 <= i && i <= 2:
		i -= 1
		return __DXGI_OUTDUPL_POINTER_SHAPE_TYPE_name_0[__DXGI_OUTDUPL_POINTER_SHAPE_TYPE_index_0[i]:__DXGI_OUTDUPL_POINTER_SHAPE_TYPE_index_0[i+1]]
	case i == 4:
		return __DXGI_OUTDUPL_POINTER_SHAPE_TYPE_name_1
	default:
		return "_DXGI_OUTDUPL_POINTER_SHAPE_TYPE(" + strconv.FormatInt(int64(i), 10) + ")"
	}
}

```

`d3d/dxgi_vtbl.go`:

```go
package d3d

type iDXGIObjectVtbl struct {
	iUnknownVtbl

	SetPrivateData          uintptr
	SetPrivateDataInterface uintptr
	GetPrivateData          uintptr
	GetParent               uintptr
}

type IDXGIAdapterVtbl struct {
	iDXGIObjectVtbl

	EnumOutputs           uintptr
	GetDesc               uintptr
	CheckInterfaceSupport uintptr
}
type IDXGIAdapter1Vtbl struct {
	IDXGIAdapterVtbl

	GetDesc1 uintptr
}

type iDXGIDeviceVtbl struct {
	iDXGIObjectVtbl

	CreateSurface          uintptr
	GetAdapter             uintptr
	GetGPUThreadPriority   uintptr
	QueryResourceResidency uintptr
	SetGPUThreadPriority   uintptr
}

type iDXGIDevice1Vtbl struct {
	iDXGIDeviceVtbl

	GetMaximumFrameLatency uintptr
	SetMaximumFrameLatency uintptr
}

type iDXGIDeviceSubObjectVtbl struct {
	iDXGIObjectVtbl

	GetDevice uintptr
}

type iDXGISurfaceVtbl struct {
	iDXGIDeviceSubObjectVtbl

	GetDesc uintptr
	Map     uintptr
	Unmap   uintptr
}

type iDXGIResourceVtbl struct {
	iDXGIDeviceSubObjectVtbl

	GetSharedHandle     uintptr
	GetUsage            uintptr
	SetEvictionPriority uintptr
	GetEvictionPriority uintptr
}

type iDXGIOutputVtbl struct {
	iDXGIObjectVtbl

	GetDesc                     uintptr
	GetDisplayModeList          uintptr
	FindClosestMatchingMode     uintptr
	WaitForVBlank               uintptr
	TakeOwnership               uintptr
	ReleaseOwnership            uintptr
	GetGammaControlCapabilities uintptr
	SetGammaControl             uintptr
	GetGammaControl             uintptr
	SetDisplaySurface           uintptr
	GetDisplaySurfaceData       uintptr
	GetFrameStatistics          uintptr
}

type iDXGIOutput1Vtbl struct {
	iDXGIOutputVtbl

	GetDisplayModeList1      uintptr
	FindClosestMatchingMode1 uintptr
	GetDisplaySurfaceData1   uintptr
	DuplicateOutput          uintptr
}

type iDXGIOutput2Vtbl struct {
	iDXGIOutput1Vtbl

	SupportsOverlays uintptr
}

type iDXGIOutput3Vtbl struct {
	iDXGIOutput2Vtbl

	CheckOverlaySupport uintptr
}

type iDXGIOutput4Vtbl struct {
	iDXGIOutput3Vtbl

	CheckOverlayColorSpaceSupport uintptr
}
type iDXGIOutput5Vtbl struct {
	iDXGIOutput4Vtbl

	DuplicateOutput1 uintptr
}

type iDXGIOutputDuplicationVtbl struct {
	iDXGIObjectVtbl

	GetDesc              uintptr
	AcquireNextFrame     uintptr
	GetFrameDirtyRects   uintptr
	GetFrameMoveRects    uintptr
	GetFramePointerShape uintptr
	MapDesktopSurface    uintptr
	UnMapDesktopSurface  uintptr
	ReleaseFrame         uintptr
}
type iDXGIFactoryVtbl struct {
	iDXGIObjectVtbl

	EnumAdapters          uintptr
	MakeWindowAssociation uintptr
	GetWindowAssociation  uintptr
	CreateSwapChain       uintptr
	CreateSoftwareAdapter uintptr
}
type iDXGIFactory1Vtbl struct {
	iDXGIFactoryVtbl

	EnumAdapters1 uintptr
	IsCurrent     uintptr
}

```

`d3d/hresult.go`:

```go
package d3d

/*
	Contains common D3D11 / DXGI errorcodes and allows to use them as Go errors
*/

//go:generate stringer -type=HRESULT -output=hresult_string.go

import (
	"strconv"
	"strings"
)

type HRESULT uint32

func failed(hr int32) bool {
	return hr < 0
}

const (
	S_OK                                     HRESULT = 0x0
	E_INVALIDARG                             HRESULT = 0x80070057
	DXGI_STATUS_OCCLUDED                     HRESULT = 0x087A0001
	DXGI_STATUS_CLIPPED                      HRESULT = 0x087A0002
	DXGI_STATUS_NO_REDIRECTION               HRESULT = 0x087A0004
	DXGI_STATUS_NO_DESKTOP_ACCESS            HRESULT = 0x087A0005
	DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE HRESULT = 0x087A0006
	DXGI_STATUS_MODE_CHANGED                 HRESULT = 0x087A0007
	DXGI_STATUS_MODE_CHANGE_IN_PROGRESS      HRESULT = 0x087A0008
	DXGI_ERROR_INVALID_CALL                  HRESULT = 0x887A0001
	DXGI_ERROR_NOT_FOUND                     HRESULT = 0x887A0002
	DXGI_ERROR_MORE_DATA                     HRESULT = 0x887A0003
	DXGI_ERROR_UNSUPPORTED                   HRESULT = 0x887A0004
	DXGI_ERROR_DEVICE_REMOVED                HRESULT = 0x887A0005
	DXGI_ERROR_DEVICE_HUNG                   HRESULT = 0x887A0006
	DXGI_ERROR_DEVICE_RESET                  HRESULT = 0x887A0007
	DXGI_ERROR_WAS_STILL_DRAWING             HRESULT = 0x887A000A
	DXGI_ERROR_FRAME_STATISTICS_DISJOINT     HRESULT = 0x887A000B
	DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE  HRESULT = 0x887A000C
	DXGI_ERROR_DRIVER_INTERNAL_ERROR         HRESULT = 0x887A0020
	DXGI_ERROR_NONEXCLUSIVE                  HRESULT = 0x887A0021
	DXGI_ERROR_NOT_CURRENTLY_AVAILABLE       HRESULT = 0x887A0022
	DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED    HRESULT = 0x887A0023
	DXGI_ERROR_REMOTE_OUTOFMEMORY            HRESULT = 0x887A0024
	DXGI_ERROR_ACCESS_LOST                   HRESULT = 0x887A0026
	DXGI_ERROR_WAIT_TIMEOUT                  HRESULT = 0x887A0027
	DXGI_ERROR_SESSION_DISCONNECTED          HRESULT = 0x887A0028
	DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE      HRESULT = 0x887A0029
	DXGI_ERROR_CANNOT_PROTECT_CONTENT        HRESULT = 0x887A002A
	DXGI_ERROR_ACCESS_DENIED                 HRESULT = 0x887A002B
	DXGI_ERROR_NAME_ALREADY_EXISTS           HRESULT = 0x887A002C
	DXGI_ERROR_SDK_COMPONENT_MISSING         HRESULT = 0x887A002D
	DXGI_ERROR_NOT_CURRENT                   HRESULT = 0x887A002E
	DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY     HRESULT = 0x887A0030
	DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION HRESULT = 0x887A0031
	DXGI_ERROR_NON_COMPOSITED_UI             HRESULT = 0x887A0032
	DXGI_STATUS_UNOCCLUDED                   HRESULT = 0x087A0009
	DXGI_STATUS_DDA_WAS_STILL_DRAWING        HRESULT = 0x087A000A
	DXGI_ERROR_MODE_CHANGE_IN_PROGRESS       HRESULT = 0x887A0025
	DXGI_STATUS_PRESENT_REQUIRED             HRESULT = 0x087A002F
	DXGI_ERROR_CACHE_CORRUPT                 HRESULT = 0x887A0033
	DXGI_ERROR_CACHE_FULL                    HRESULT = 0x887A0034
	DXGI_ERROR_CACHE_HASH_COLLISION          HRESULT = 0x887A0035
	DXGI_ERROR_ALREADY_EXISTS                HRESULT = 0x887A0036
	DXGI_DDI_ERR_WASSTILLDRAWING             HRESULT = 0x887B0001
	DXGI_DDI_ERR_UNSUPPORTED                 HRESULT = 0x887B0002
	DXGI_DDI_ERR_NONEXCLUSIVE                HRESULT = 0x887B0003
)

func (e HRESULT) Error() string {
	str := e.String()

	if strings.HasSuffix(str, ")") {
		// Workaround: return just the hex code as error if no name found
		return "0x" + strconv.FormatUint(uint64(e), 16)
	}
	// return name and hex value
	return str + " (0x" + strconv.FormatUint(uint64(e), 16) + ")"
}

```

`d3d/hresult_string.go`:

```go
// Code generated by "stringer -type=HRESULT -output=hresult_string.go"; DO NOT EDIT.

package d3d

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[S_OK-0]
	_ = x[E_INVALIDARG-2147942487]
	_ = x[DXGI_STATUS_OCCLUDED-142213121]
	_ = x[DXGI_STATUS_CLIPPED-142213122]
	_ = x[DXGI_STATUS_NO_REDIRECTION-142213124]
	_ = x[DXGI_STATUS_NO_DESKTOP_ACCESS-142213125]
	_ = x[DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE-142213126]
	_ = x[DXGI_STATUS_MODE_CHANGED-142213127]
	_ = x[DXGI_STATUS_MODE_CHANGE_IN_PROGRESS-142213128]
	_ = x[DXGI_ERROR_INVALID_CALL-2289696769]
	_ = x[DXGI_ERROR_NOT_FOUND-2289696770]
	_ = x[DXGI_ERROR_MORE_DATA-2289696771]
	_ = x[DXGI_ERROR_UNSUPPORTED-2289696772]
	_ = x[DXGI_ERROR_DEVICE_REMOVED-2289696773]
	_ = x[DXGI_ERROR_DEVICE_HUNG-2289696774]
	_ = x[DXGI_ERROR_DEVICE_RESET-2289696775]
	_ = x[DXGI_ERROR_WAS_STILL_DRAWING-2289696778]
	_ = x[DXGI_ERROR_FRAME_STATISTICS_DISJOINT-2289696779]
	_ = x[DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE-2289696780]
	_ = x[DXGI_ERROR_DRIVER_INTERNAL_ERROR-2289696800]
	_ = x[DXGI_ERROR_NONEXCLUSIVE-2289696801]
	_ = x[DXGI_ERROR_NOT_CURRENTLY_AVAILABLE-2289696802]
	_ = x[DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED-2289696803]
	_ = x[DXGI_ERROR_REMOTE_OUTOFMEMORY-2289696804]
	_ = x[DXGI_ERROR_ACCESS_LOST-2289696806]
	_ = x[DXGI_ERROR_WAIT_TIMEOUT-2289696807]
	_ = x[DXGI_ERROR_SESSION_DISCONNECTED-2289696808]
	_ = x[DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE-2289696809]
	_ = x[DXGI_ERROR_CANNOT_PROTECT_CONTENT-2289696810]
	_ = x[DXGI_ERROR_ACCESS_DENIED-2289696811]
	_ = x[DXGI_ERROR_NAME_ALREADY_EXISTS-2289696812]
	_ = x[DXGI_ERROR_SDK_COMPONENT_MISSING-2289696813]
	_ = x[DXGI_ERROR_NOT_CURRENT-2289696814]
	_ = x[DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY-2289696816]
	_ = x[DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION-2289696817]
	_ = x[DXGI_ERROR_NON_COMPOSITED_UI-2289696818]
	_ = x[DXGI_STATUS_UNOCCLUDED-142213129]
	_ = x[DXGI_STATUS_DDA_WAS_STILL_DRAWING-142213130]
	_ = x[DXGI_ERROR_MODE_CHANGE_IN_PROGRESS-2289696805]
	_ = x[DXGI_STATUS_PRESENT_REQUIRED-142213167]
	_ = x[DXGI_ERROR_CACHE_CORRUPT-2289696819]
	_ = x[DXGI_ERROR_CACHE_FULL-2289696820]
	_ = x[DXGI_ERROR_CACHE_HASH_COLLISION-2289696821]
	_ = x[DXGI_ERROR_ALREADY_EXISTS-2289696822]
	_ = x[DXGI_DDI_ERR_WASSTILLDRAWING-2289762305]
	_ = x[DXGI_DDI_ERR_UNSUPPORTED-2289762306]
	_ = x[DXGI_DDI_ERR_NONEXCLUSIVE-2289762307]
}

const (
	_HRESULT_name_0 = "S_OK"
	_HRESULT_name_1 = "DXGI_STATUS_OCCLUDEDDXGI_STATUS_CLIPPED"
	_HRESULT_name_2 = "DXGI_STATUS_NO_REDIRECTIONDXGI_STATUS_NO_DESKTOP_ACCESSDXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USEDXGI_STATUS_MODE_CHANGEDDXGI_STATUS_MODE_CHANGE_IN_PROGRESSDXGI_STATUS_UNOCCLUDEDDXGI_STATUS_DDA_WAS_STILL_DRAWING"
	_HRESULT_name_3 = "DXGI_STATUS_PRESENT_REQUIRED"
	_HRESULT_name_4 = "E_INVALIDARG"
	_HRESULT_name_5 = "DXGI_ERROR_INVALID_CALLDXGI_ERROR_NOT_FOUNDDXGI_ERROR_MORE_DATADXGI_ERROR_UNSUPPORTEDDXGI_ERROR_DEVICE_REMOVEDDXGI_ERROR_DEVICE_HUNGDXGI_ERROR_DEVICE_RESET"
	_HRESULT_name_6 = "DXGI_ERROR_WAS_STILL_DRAWINGDXGI_ERROR_FRAME_STATISTICS_DISJOINTDXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE"
	_HRESULT_name_7 = "DXGI_ERROR_DRIVER_INTERNAL_ERRORDXGI_ERROR_NONEXCLUSIVEDXGI_ERROR_NOT_CURRENTLY_AVAILABLEDXGI_ERROR_REMOTE_CLIENT_DISCONNECTEDDXGI_ERROR_REMOTE_OUTOFMEMORYDXGI_ERROR_MODE_CHANGE_IN_PROGRESSDXGI_ERROR_ACCESS_LOSTDXGI_ERROR_WAIT_TIMEOUTDXGI_ERROR_SESSION_DISCONNECTEDDXGI_ERROR_RESTRICT_TO_OUTPUT_STALEDXGI_ERROR_CANNOT_PROTECT_CONTENTDXGI_ERROR_ACCESS_DENIEDDXGI_ERROR_NAME_ALREADY_EXISTSDXGI_ERROR_SDK_COMPONENT_MISSINGDXGI_ERROR_NOT_CURRENT"
	_HRESULT_name_8 = "DXGI_ERROR_HW_PROTECTION_OUTOFMEMORYDXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATIONDXGI_ERROR_NON_COMPOSITED_UIDXGI_ERROR_CACHE_CORRUPTDXGI_ERROR_CACHE_FULLDXGI_ERROR_CACHE_HASH_COLLISIONDXGI_ERROR_ALREADY_EXISTS"
	_HRESULT_name_9 = "DXGI_DDI_ERR_WASSTILLDRAWINGDXGI_DDI_ERR_UNSUPPORTEDDXGI_DDI_ERR_NONEXCLUSIVE"
)

var (
	_HRESULT_index_1 = [...]uint8{0, 20, 39}
	_HRESULT_index_2 = [...]uint8{0, 26, 55, 95, 119, 154, 176, 209}
	_HRESULT_index_5 = [...]uint8{0, 23, 43, 63, 85, 110, 132, 155}
	_HRESULT_index_6 = [...]uint8{0, 28, 64, 103}
	_HRESULT_index_7 = [...]uint16{0, 32, 55, 89, 126, 155, 189, 211, 234, 265, 300, 333, 357, 387, 419, 441}
	_HRESULT_index_8 = [...]uint8{0, 36, 76, 104, 128, 149, 180, 205}
	_HRESULT_index_9 = [...]uint8{0, 28, 52, 77}
)

func (i HRESULT) String() string {
	switch {
	case i == 0:
		return _HRESULT_name_0
	case 142213121 <= i && i <= 142213122:
		i -= 142213121
		return _HRESULT_name_1[_HRESULT_index_1[i]:_HRESULT_index_1[i+1]]
	case 142213124 <= i && i <= 142213130:
		i -= 142213124
		return _HRESULT_name_2[_HRESULT_index_2[i]:_HRESULT_index_2[i+1]]
	case i == 142213167:
		return _HRESULT_name_3
	case i == 2147942487:
		return _HRESULT_name_4
	case 2289696769 <= i && i <= 2289696775:
		i -= 2289696769
		return _HRESULT_name_5[_HRESULT_index_5[i]:_HRESULT_index_5[i+1]]
	case 2289696778 <= i && i <= 2289696780:
		i -= 2289696778
		return _HRESULT_name_6[_HRESULT_index_6[i]:_HRESULT_index_6[i+1]]
	case 2289696800 <= i && i <= 2289696814:
		i -= 2289696800
		return _HRESULT_name_7[_HRESULT_index_7[i]:_HRESULT_index_7[i+1]]
	case 2289696816 <= i && i <= 2289696822:
		i -= 2289696816
		return _HRESULT_name_8[_HRESULT_index_8[i]:_HRESULT_index_8[i+1]]
	case 2289762305 <= i && i <= 2289762307:
		i -= 2289762305
		return _HRESULT_name_9[_HRESULT_index_9[i]:_HRESULT_index_9[i+1]]
	default:
		return "HRESULT(" + strconv.FormatInt(int64(i), 10) + ")"
	}
}

```

`d3d/iunknown_vtbl.go`:

```go
package d3d

type iUnknownVtbl struct {
	// every COM object starts with these three
	QueryInterface uintptr
	AddRef         uintptr
	Release        uintptr
	// _QueryInterface2 uintptr
}

```

`d3d/output_duplication.go`:

```go
package d3d

import (
	"errors"
	"fmt"
	"image"

	"unsafe"

	"github.com/kirides/screencapture/swizzle"
)

type PointerInfo struct {
	pos POINT

	size           POINT
	shapeInBuffer  []byte
	shapeOutBuffer *image.RGBA
	visible        bool
}

type OutputDuplicator struct {
	device            *ID3D11Device
	deviceCtx         *ID3D11DeviceContext
	outputDuplication *IDXGIOutputDuplication

	stagedTex  *ID3D11Texture2D
	surface    *IDXGISurface
	mappedRect DXGI_MAPPED_RECT
	size       POINT

	pointerInfo PointerInfo
	DrawPointer bool

	// TODO: handle DPI? Do we need it?
	dirtyRects    []RECT
	movedRects    []_DXGI_OUTDUPL_MOVE_RECT
	acquiredFrame bool
	needsSwizzle  bool // in case we use DuplicateOutput1, swizzle is not neccessery
}

func (dup *OutputDuplicator) initializeStage(texture *ID3D11Texture2D) int32 {

	/*
		TODO: Only do this on changes!
	*/
	var hr int32
	desc := _D3D11_TEXTURE2D_DESC{}
	hr = texture.GetDesc(&desc)
	if failed(hr) {
		return hr
	}

	desc.Usage = D3D11_USAGE_STAGING
	desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ
	desc.BindFlags = 0
	desc.MipLevels = 1
	desc.ArraySize = 1
	desc.MiscFlags = 0
	desc.SampleDesc.Count = 1

	hr = dup.device.CreateTexture2D(&desc, &dup.stagedTex)
	if failed(hr) {
		return hr
	}

	hr = dup.stagedTex.QueryInterface(iid_IDXGISurface, &dup.surface)
	if failed(hr) {
		return hr
	}
	dup.size = POINT{X: int32(desc.Width), Y: int32(desc.Height)}

	return 0
}

func (dup *OutputDuplicator) Release() {
	if dup.stagedTex != nil {
		dup.stagedTex.Release()
		dup.stagedTex = nil
	}
	if dup.surface != nil {
		dup.surface.Release()
		dup.surface = nil
	}
	if dup.outputDuplication != nil {
		dup.outputDuplication.Release()
		dup.outputDuplication = nil
	}
}

var ErrNoImageYet = errors.New("no image yet")

type unmapFn func() int32

func (dup *OutputDuplicator) ReleaseFrame() {
	if dup.acquiredFrame {
		dup.outputDuplication.ReleaseFrame()
		dup.acquiredFrame = false
	}
}

// returns DXGI_FORMAT_B8G8R8A8_UNORM data
func (dup *OutputDuplicator) Snapshot(timeoutMs uint) (unmapFn, *DXGI_MAPPED_RECT, *POINT, error) {
	var hr int32
	desc := _DXGI_OUTDUPL_DESC{}
	hr = dup.outputDuplication.GetDesc(&desc)
	if failed(hr) {
		return nil, nil, nil, fmt.Errorf("failed to get the description. %w", HRESULT(hr))
	}

	if desc.DesktopImageInSystemMemory != 0 {
		// TODO: Figure out WHEN exactly this can occur, and if we can make use of it
		dup.size = POINT{int32(desc.ModeDesc.Width), int32(desc.ModeDesc.Height)}
		hr = dup.outputDuplication.MapDesktopSurface(&dup.mappedRect)
		if !failed(hr) {
			return dup.outputDuplication.UnMapDesktopSurface, &dup.mappedRect, &dup.size, nil
		}
	}

	var desktop *IDXGIResource
	var frameInfo _DXGI_OUTDUPL_FRAME_INFO

	// Release a possible previous frame
	// TODO: Properly use ReleaseFrame...

	dup.ReleaseFrame()
	hrF := dup.outputDuplication.AcquireNextFrame(timeoutMs, &frameInfo, &desktop)
	dup.acquiredFrame = true
	if failed(int32(hrF)) {
		if HRESULT(hrF) == DXGI_ERROR_WAIT_TIMEOUT {
			return nil, nil, nil, ErrNoImageYet
		}
		return nil, nil, nil, fmt.Errorf("failed to AcquireNextFrame. %w", HRESULT(hrF))
	}
	// If we do not release the frame ASAP, we only get FPS / 2 frames :/
	// Something wrong here?
	defer dup.ReleaseFrame()
	defer desktop.Release()

	if dup.DrawPointer {
		if err := dup.updatePointer(&frameInfo); err != nil {
			return nil, nil, nil, err
		}
	}

	if frameInfo.AccumulatedFrames == 0 {
		return nil, nil, nil, ErrNoImageYet
	}
	var desktop2d *ID3D11Texture2D
	hr = desktop.QueryInterface(iid_ID3D11Texture2D, &desktop2d)
	if failed(hr) {
		return nil, nil, nil, fmt.Errorf("failed to QueryInterface(iid_ID3D11Texture2D, ...). %w", HRESULT(hr))
	}
	defer desktop2d.Release()

	if dup.stagedTex == nil {
		hr = dup.initializeStage(desktop2d)
		if failed(hr) {
			return nil, nil, nil, fmt.Errorf("failed to InitializeStage. %w", HRESULT(hr))
		}
	}

	// NOTE: we could use a single, large []byte buffer and use it as storage for moved rects & dirty rects
	if frameInfo.TotalMetadataBufferSize > 0 {
		// Handling moved / dirty rects, to reduce GPU<->CPU memory copying
		moveRectsRequired := uint32(1)
		for {
			if len(dup.movedRects) < int(moveRectsRequired) {
				dup.movedRects = make([]_DXGI_OUTDUPL_MOVE_RECT, moveRectsRequired)
			}
			hr = dup.outputDuplication.GetFrameMoveRects(dup.movedRects, &moveRectsRequired)
			if failed(hr) {
				if HRESULT(hr) == DXGI_ERROR_MORE_DATA {
					continue
				}
				return nil, nil, nil, fmt.Errorf("failed to GetFrameMoveRects. %w", HRESULT(hr))
			}
			dup.movedRects = dup.movedRects[:moveRectsRequired]
			break
		}

		dirtyRectsRequired := uint32(1)
		for {
			if len(dup.dirtyRects) < int(dirtyRectsRequired) {
				dup.dirtyRects = make([]RECT, dirtyRectsRequired)
			}
			hr = dup.outputDuplication.GetFrameDirtyRects(dup.dirtyRects, &dirtyRectsRequired)
			if failed(hr) {
				if HRESULT(hr) == DXGI_ERROR_MORE_DATA {
					continue
				}
				return nil, nil, nil, fmt.Errorf("failed to GetFrameDirtyRects. %w", HRESULT(hr))
			}
			dup.dirtyRects = dup.dirtyRects[:dirtyRectsRequired]
			break
		}

		box := _D3D11_BOX{
			Front: 0,
			Back:  1,
		}
		if len(dup.movedRects) == 0 {
			for i := 0; i < len(dup.dirtyRects); i++ {
				box.Left = uint32(dup.dirtyRects[i].Left)
				box.Top = uint32(dup.dirtyRects[i].Top)
				box.Right = uint32(dup.dirtyRects[i].Right)
				box.Bottom = uint32(dup.dirtyRects[i].Bottom)

				dup.deviceCtx.CopySubresourceRegion2D(dup.stagedTex, 0, box.Left, box.Top, 0, desktop2d, 0, &box)
			}
		} else {
			// TODO: handle moved rects, then dirty rects
			// for now, just update the whole image instead
			dup.deviceCtx.CopyResource2D(dup.stagedTex, desktop2d)
		}
	} else {
		// no frame metadata, copy whole image
		dup.deviceCtx.CopyResource2D(dup.stagedTex, desktop2d)
		if !dup.needsSwizzle {
			dup.needsSwizzle = true
		}
		print("no frame metadata\n")
	}

	hr = dup.surface.Map(&dup.mappedRect, DXGI_MAP_READ)
	if failed(hr) {
		return nil, nil, nil, fmt.Errorf("failed to surface_.Map(...). %v", HRESULT(hr))
	}
	return dup.surface.Unmap, &dup.mappedRect, &dup.size, nil
}

func (dup *OutputDuplicator) GetImage(img *image.RGBA, timeoutMs uint) error {
	unmap, mappedRect, size, err := dup.Snapshot(timeoutMs)
	if err != nil {
		return err
	}
	defer unmap()
	hMem := mappedRect.PBits

	bitmapDataSize := int32(((int64(size.X)*32 + 31) / 32) * 4 * int64(size.Y))

	// copy source bytes into image.RGBA.Pix using memory interpretation
	imageBytes := ((*[1 << 30]byte)(unsafe.Pointer(hMem)))[:bitmapDataSize:bitmapDataSize]
	copy(img.Pix[:bitmapDataSize], imageBytes)
	dup.drawPointer(img)
	if dup.needsSwizzle {
		swizzle.BGRA(img.Pix)
	}

	// manual swizzle B <-> R

	// for i := int32(0); i < bitmapDataSize; i += 4 {
	// 	v0 := *(*uint8)(unsafe.Pointer(hMem + uintptr(i)))
	// 	v1 := *(*uint8)(unsafe.Pointer(hMem + uintptr(i) + 1))
	// 	v2 := *(*uint8)(unsafe.Pointer(hMem + uintptr(i) + 2))

	// 	// BGRA => RGBA, no need to read alpha, always 255.
	// 	img.Pix[i], img.Pix[i+1], img.Pix[i+2], img.Pix[i+3] = v2, v1, v0, 255
	// }
	return nil
}

func (dup *OutputDuplicator) updatePointer(info *_DXGI_OUTDUPL_FRAME_INFO) error {
	if info.LastMouseUpdateTime == 0 {
		return nil
	}
	dup.pointerInfo.visible = info.PointerPosition.Visible != 0
	dup.pointerInfo.pos = info.PointerPosition.Position

	if info.PointerShapeBufferSize != 0 {
		// new shape
		if len(dup.pointerInfo.shapeInBuffer) < int(info.PointerShapeBufferSize) {
			dup.pointerInfo.shapeInBuffer = make([]byte, info.PointerShapeBufferSize)
		}
		var requiredSize uint32
		var pointerInfo _DXGI_OUTDUPL_POINTER_SHAPE_INFO

		hr := dup.outputDuplication.GetFramePointerShape(info.PointerShapeBufferSize,
			dup.pointerInfo.shapeInBuffer,
			&requiredSize,
			&pointerInfo,
		)
		if hr != 0 {
			return fmt.Errorf("unable to obtain frame pointer shape")
		}
		neededSize := pointerInfo.Width * pointerInfo.Height * 4
		dup.pointerInfo.shapeOutBuffer = image.NewRGBA(image.Rect(0, 0, int(pointerInfo.Width), int(pointerInfo.Height)))
		if len(dup.pointerInfo.shapeOutBuffer.Pix) < int(neededSize) {
			dup.pointerInfo.shapeOutBuffer.Pix = make([]byte, neededSize)
		}

		if pointerInfo.Type == DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROME {
			dup.pointerInfo.size = POINT{int32(pointerInfo.Width), int32(pointerInfo.Height)}

			xor_offset := pointerInfo.Pitch * (pointerInfo.Height / 2)
			andMap := dup.pointerInfo.shapeInBuffer
			xorMap := dup.pointerInfo.shapeInBuffer[:xor_offset]
			out_pixels := dup.pointerInfo.shapeOutBuffer.Pix
			widthBytes := (pointerInfo.Width + 7) / 8

			imgHeight := pointerInfo.Height / 2

			for j := 0; j < int(imgHeight); j++ {
				bit := byte(0x80)

				for i := 0; i < int(pointerInfo.Width); i++ {
					andByte := andMap[j*int(widthBytes)+i/8]
					xorByte := xorMap[j*int(widthBytes)+i/8]
					andBit := 0
					if (andByte & bit) != 0 {
						andBit = 1
					}
					xorBit := 0
					if (xorByte & bit) != 0 {
						xorBit = 1
					}
					outDx := j*int(pointerInfo.Width)*4 + i*4
					if andBit == 0 {
						if xorBit == 0 {
							out_pixels[outDx+0] = 0x00
							out_pixels[outDx+1] = 0x00
							out_pixels[outDx+2] = 0x00
							out_pixels[outDx+3] = 0x00
						} else {
							out_pixels[outDx+0] = 0xFF
							out_pixels[outDx+1] = 0xFF
							out_pixels[outDx+2] = 0xFF
							out_pixels[outDx+3] = 0xFF
						}
					} else {
						if xorBit == 0 {
							out_pixels[outDx+0] = 0x00
							out_pixels[outDx+1] = 0x00
							out_pixels[outDx+2] = 0x00
							out_pixels[outDx+3] = 0x00
						} else {
							out_pixels[outDx+0] = 0x00
							out_pixels[outDx+1] = 0x00
							out_pixels[outDx+2] = 0x00
							out_pixels[outDx+3] = 0xFF
						}
					}
					if bit == 0x01 {
						bit = 0x80
					} else {
						bit = bit >> 1
					}
				}
			}
		} else if pointerInfo.Type == DXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR {
			dup.pointerInfo.size = POINT{int32(pointerInfo.Width), int32(pointerInfo.Height)}

			out, in := dup.pointerInfo.shapeOutBuffer.Pix, dup.pointerInfo.shapeInBuffer
			for j := 0; j < int(pointerInfo.Height); j++ {
				tout := out[j*int(pointerInfo.Pitch):]
				tin := in[j*int(pointerInfo.Pitch):]
				copy(tout, tin[:pointerInfo.Pitch])
			}
		} else if pointerInfo.Type == DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR {
			dup.pointerInfo.size = POINT{int32(pointerInfo.Width), int32(pointerInfo.Height)}

			// TODO: Properly add mask
			out, in := dup.pointerInfo.shapeOutBuffer.Pix, dup.pointerInfo.shapeInBuffer
			for j := 0; j < int(pointerInfo.Height); j++ {
				tout := out[j*int(pointerInfo.Pitch):]
				tin := in[j*int(pointerInfo.Pitch):]
				copy(tout, tin[:pointerInfo.Pitch])
			}
		} else {
			dup.pointerInfo.size = POINT{0, 0}
			return fmt.Errorf("unsupported type %v", pointerInfo.Type)
		}
	}
	return nil
}

func (dup *OutputDuplicator) drawPointer(img *image.RGBA) error {
	if !dup.DrawPointer {
		return nil
	}

	for j := 0; j < int(dup.pointerInfo.size.Y); j++ {
		for i := 0; i < int(dup.pointerInfo.size.X); i++ {
			col := dup.pointerInfo.shapeOutBuffer.At(i, j)
			_, _, _, a := col.RGBA()
			if a == 0 {
				// just dont draw invisible pixel?
				// TODO: correctly apply mask
				continue
			}

			img.Set(int(dup.pointerInfo.pos.X)+i, int(dup.pointerInfo.pos.Y)+j, col)
		}
	}
	return nil
}

```

`go.mod`:

```mod
module github.com/kirides/screencapture

go 1.17

require (
	github.com/kbinani/screenshot v0.0.0-20210720154843-7d3a670d8329
	github.com/lxn/win v0.0.0-20210218163916-a377121e959e
	github.com/mattn/go-mjpeg v0.0.3
	github.com/nfnt/resize v0.0.0-20180221191011-83c6a9932646
	github.com/pixiv/go-libjpeg v0.0.0-20190822045933-3da21a74767d
	golang.org/x/sys v0.0.0-20211031064116-611d5d643895
)

require (
	github.com/gen2brain/shm v0.0.0-20210511105953-083dbc7d9d83 // indirect
	github.com/jezek/xgb v0.0.0-20210312150743-0e0f116e1240 // indirect
)

```

`go.sum`:

```sum
github.com/gen2brain/shm v0.0.0-20200228170931-49f9650110c5/go.mod h1:uF6rMu/1nvu+5DpiRLwusA6xB8zlkNoGzKn8lmYONUo=
github.com/gen2brain/shm v0.0.0-20210511105953-083dbc7d9d83 h1:fRNwUddc/xxdx5kQ38X4+q/Grnqlp9zfV/ssKzSzVk0=
github.com/gen2brain/shm v0.0.0-20210511105953-083dbc7d9d83/go.mod h1:uF6rMu/1nvu+5DpiRLwusA6xB8zlkNoGzKn8lmYONUo=
github.com/jezek/xgb v0.0.0-20210312150743-0e0f116e1240 h1:dy+DS31tGEGCsZzB45HmJJNHjur8GDgtRNX9U7HnSX4=
github.com/jezek/xgb v0.0.0-20210312150743-0e0f116e1240/go.mod h1:3P4UH/k22rXyHIJD2w4h2XMqPX4Of/eySEZq9L6wqc4=
github.com/kbinani/screenshot v0.0.0-20210720154843-7d3a670d8329 h1:qq2nCpSrXrmvDGRxW0ruW9BVEV1CN2a9YDOExdt+U0o=
github.com/kbinani/screenshot v0.0.0-20210720154843-7d3a670d8329/go.mod h1:2VPVQDR4wO7KXHwP+DAypEy67rXf+okUx2zjgpCxZw4=
github.com/lxn/win v0.0.0-20210218163916-a377121e959e h1:H+t6A/QJMbhCSEH5rAuRxh+CtW96g0Or0Fxa9IKr4uc=
github.com/lxn/win v0.0.0-20210218163916-a377121e959e/go.mod h1:KxxjdtRkfNoYDCUP5ryK7XJJNTnpC8atvtmTheChOtk=
github.com/mattn/go-mjpeg v0.0.3 h1:0G/+KddrbI5Hnq83B11O1O4vP7Q6L9MsBu6aW71jhUM=
github.com/mattn/go-mjpeg v0.0.3/go.mod h1:65z7Cj+u5y5K3B8Sy5NtrJFTWAhguGHs9FEkADdx6kE=
github.com/nfnt/resize v0.0.0-20180221191011-83c6a9932646 h1:zYyBkD/k9seD2A7fsi6Oo2LfFZAehjjQMERAvZLEDnQ=
github.com/nfnt/resize v0.0.0-20180221191011-83c6a9932646/go.mod h1:jpp1/29i3P1S/RLdc7JQKbRpFeM1dOBd8T9ki5s+AY8=
github.com/pixiv/go-libjpeg v0.0.0-20190822045933-3da21a74767d h1:ls+7AYarUlUSetfnN/DKVNcK6W8mQWc6VblmOm4XwX0=
github.com/pixiv/go-libjpeg v0.0.0-20190822045933-3da21a74767d/go.mod h1:DO7ixpslN6XfbWzeNH9vkS5CF2FQUX81B85rYe9zDxU=
golang.org/x/sys v0.0.0-20201018230417-eeed37f84f13/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20211031064116-611d5d643895 h1:iaNpwpnrgL5jzWS0vCNnfa8HqzxveCFpFx3uC/X4Tps=
golang.org/x/sys v0.0.0-20211031064116-611d5d643895/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=

```

`screenshot/native_windows.go`:

```go
package screenshot

import (
	"errors"
	"image"
	"syscall"
	"unsafe"

	"github.com/kirides/screencapture/swizzle"

	"github.com/lxn/win"

	thiswin "github.com/kirides/screencapture/win"
)

func CaptureImg(img *image.RGBA, x, y, width, height int) error {
	return captureImg(img, x, y, width, height)
}

// code is mostly from github.com/kbinani/screenshot
func captureImg(img *image.RGBA, x, y, width, height int) error {
	hWnd := syscall.Handle(thiswin.GetDesktopWindow())
	hdc := win.GetDC(win.HWND(hWnd))
	if hdc == 0 {
		return errors.New("GetDC failed")
	}
	defer win.ReleaseDC(win.HWND(hWnd), hdc)

	memory_device := win.CreateCompatibleDC(hdc)
	if memory_device == 0 {
		return errors.New("CreateCompatibleDC failed")
	}
	defer win.DeleteDC(memory_device)

	bitmap := win.CreateCompatibleBitmap(hdc, int32(width), int32(height))
	if bitmap == 0 {
		return errors.New("CreateCompatibleBitmap failed")
	}
	defer win.DeleteObject(win.HGDIOBJ(bitmap))

	old := win.SelectObject(memory_device, win.HGDIOBJ(bitmap))
	if old == 0 {
		return errors.New("SelectObject failed")
	}
	defer win.SelectObject(memory_device, old)

	if !win.BitBlt(memory_device, 0, 0, int32(width), int32(height), hdc, int32(x), int32(y), win.SRCCOPY) {
		return errors.New("BitBlt failed")
	}
	var bm win.BITMAP
	win.GetObject(win.HGDIOBJ(bitmap), unsafe.Sizeof(win.BITMAP{}), unsafe.Pointer(&bm))

	var header thiswin.BITMAPINFOHEADER
	header.BiSize = uint32(unsafe.Sizeof(header))
	header.BiPlanes = 1
	header.BiBitCount = 32
	header.BiWidth = bm.BmWidth
	header.BiHeight = -bm.BmHeight
	header.BiCompression = win.BI_RGB

	// GetDIBits balks at using Go memory on some systems.
	bitmapDataSize := int32(((int64(bm.BmWidth)*int64(header.BiBitCount) + 31) / 32) * 4 * int64(bm.BmHeight))

	hHeap, _ := thiswin.GetProcessHeap()
	hMem, _ := thiswin.HeapAlloc(hHeap, 0, uintptr(bitmapDataSize))
	defer thiswin.HeapFree(hHeap, 0, hMem)

	if v, _ := thiswin.GetDIBits(syscall.Handle(hdc), syscall.Handle(bitmap), 0, uint32(height), (*uint8)(unsafe.Pointer(hMem)), (*thiswin.BITMAPINFO)(unsafe.Pointer(&header)), win.DIB_RGB_COLORS); v == 0 {
		return errors.New("GetDIBits failed")
	}

	// using memory interpretation
	bgra := ((*[1 << 30]byte)(unsafe.Pointer(hMem)))[:bitmapDataSize:bitmapDataSize]
	swizzle.BGRA(bgra)
	copy(img.Pix[:bitmapDataSize], bgra)

	// manual swizzle B <-> R, A = 255

	// for i := int32(0); i < bitmapDataSize; i += 4 {
	// 	v0 := *(*uint8)(unsafe.Pointer(hMem + uintptr(i)))
	// 	v1 := *(*uint8)(unsafe.Pointer(hMem + uintptr(i) + 1))
	// 	v2 := *(*uint8)(unsafe.Pointer(hMem + uintptr(i) + 2))

	// 	// BGRA => RGBA, and set A to 255
	// 	img.Pix[i], img.Pix[i+1], img.Pix[i+2], img.Pix[i+3] = v2, v1, v0, 255
	// }
	return nil
}

```

`swizzle/LICENSE`:

```
Copyright (c) 2009 The Go Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`swizzle/swizzle_amd64.go`:

```go
// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package swizzle

// haveSSSE3 returns whether the CPU supports SSSE3 instructions (i.e. PSHUFB).
//
// Note that this is SSSE3, not SSE3.
func haveSSSE3() bool

var useBGRA16 = haveSSSE3()

const useBGRA4 = true

func bgra16(p []byte)
func bgra4(p []byte)

```

`swizzle/swizzle_amd64.s`:

```s
// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "textflag.h"

// func haveSSSE3() bool
TEXT ·haveSSSE3(SB),NOSPLIT,$0
	MOVQ	$1, AX
	CPUID
	SHRQ	$9, CX
	ANDQ	$1, CX
	MOVB	CX, ret+0(FP)
	RET

// func bgra16(p []byte)
TEXT ·bgra16(SB),NOSPLIT,$0-24
	MOVQ	p+0(FP), SI
	MOVQ	len+8(FP), DI

	// Sanity check that len is a multiple of 16.
	MOVQ	DI, AX
	ANDQ	$15, AX
	JNZ	done

	// Make the shuffle control mask (16-byte register X0) look like this,
	// where the low order byte comes first:
	//
	// 02 01 00 03  06 05 04 07  0a 09 08 0b  0e 0d 0c 0f
	//
	// Load the bottom 8 bytes into X0, the top into X1, then interleave them
	// into X0.
	MOVQ	$0x0704050603000102, AX
	MOVQ	AX, X0
	MOVQ	$0x0f0c0d0e0b08090a, AX
	MOVQ	AX, X1
	PUNPCKLQDQ	X1, X0

	ADDQ	SI, DI
loop:
	CMPQ	SI, DI
	JEQ	done

	MOVOU	(SI), X1
	PSHUFB	X0, X1
	MOVOU	X1, (SI)

	ADDQ	$16, SI
	JMP	loop
done:
	RET

// func bgra4(p []byte)
TEXT ·bgra4(SB),NOSPLIT,$0-24
	MOVQ	p+0(FP), SI
	MOVQ	len+8(FP), DI

	// Sanity check that len is a multiple of 4.
	MOVQ	DI, AX
	ANDQ	$3, AX
	JNZ	done

	ADDQ	SI, DI
loop:
	CMPQ	SI, DI
	JEQ	done

	MOVB	0(SI), AX
	MOVB	2(SI), BX
	MOVB	BX, 0(SI)
	MOVB	AX, 2(SI)

	ADDQ	$4, SI
	JMP	loop
done:
	RET

```

`swizzle/swizzle_common.go`:

```go
// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package swizzle provides functions for converting between RGBA pixel
// formats.
package swizzle // import "golang.org/x/exp/shiny/driver/internal/swizzle"

// BGRA converts a pixel buffer between Go's RGBA and other systems' BGRA byte
// orders.
//
// It panics if the input slice length is not a multiple of 4.
func BGRA(p []byte) {
	if len(p)%4 != 0 {
		panic("input slice length is not a multiple of 4")
	}

	// Use asm code for 16- or 4-byte chunks, if supported.
	if useBGRA16 {
		n := len(p) &^ (16 - 1)
		bgra16(p[:n])
		p = p[n:]
	} else if useBGRA4 {
		bgra4(p)
		return
	}

	for i := 0; i < len(p); i += 4 {
		p[i+0], p[i+2] = p[i+2], p[i+0]
	}
}

```

`swizzle/swizzle_other.go`:

```go
// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !amd64

package swizzle

const (
	useBGRA16 = false
	useBGRA4  = false
)

func bgra16(p []byte) { panic("unreachable") }
func bgra4(p []byte)  { panic("unreachable") }

```

`swizzle/swizzle_test.go`:

```go
// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package swizzle

import (
	"bytes"
	"math/rand"
	"testing"
)

func TestBGRAShortInput(t *testing.T) {
	const s = "012.456.89A.CDE.GHI.KLM.O"
	testCases := []string{
		0: "012.456.89A.CDE.GHI.KLM.O",
		1: "210.456.89A.CDE.GHI.KLM.O",
		2: "210.654.89A.CDE.GHI.KLM.O",
		3: "210.654.A98.CDE.GHI.KLM.O",
		4: "210.654.A98.EDC.GHI.KLM.O",
		5: "210.654.A98.EDC.IHG.KLM.O",
		6: "210.654.A98.EDC.IHG.MLK.O",
	}
	for i, want := range testCases {
		b := []byte(s)
		BGRA(b[:4*i])
		got := string(b)
		if got != want {
			t.Errorf("i=%d: got %q, want %q", i, got, want)
		}
		changed := got != s
		wantChanged := i != 0
		if changed != wantChanged {
			t.Errorf("i=%d: changed=%t, want %t", i, changed, wantChanged)
		}
	}
}

func TestBGRARandomInput(t *testing.T) {
	r := rand.New(rand.NewSource(1))
	fastBuf := make([]byte, 1024)
	slowBuf := make([]byte, 1024)
	for i := range fastBuf {
		fastBuf[i] = uint8(r.Intn(256))
	}
	copy(slowBuf, fastBuf)

	for i := 0; i < 100000; i++ {
		o := r.Intn(len(fastBuf))
		n := r.Intn(len(fastBuf)-o) &^ 0x03
		BGRA(fastBuf[o : o+n])
		pureGoBGRA(slowBuf[o : o+n])
		if bytes.Equal(fastBuf, slowBuf) {
			continue
		}
		for j := range fastBuf {
			x := fastBuf[j]
			y := slowBuf[j]
			if x != y {
				t.Fatalf("iter %d: swizzling [%d:%d+%d]: bytes differ at offset %d (aka %d+%d): %#02x vs %#02x",
					i, o, o, n, j, o, j-o, x, y)
			}
		}
	}
}

func pureGoBGRA(p []byte) {
	if len(p)%4 != 0 {
		return
	}
	for i := 0; i < len(p); i += 4 {
		p[i+0], p[i+2] = p[i+2], p[i+0]
	}
}

func benchmarkBGRA(b *testing.B, f func([]byte)) {
	const w, h = 1920, 1080 // 1080p RGBA.
	buf := make([]byte, 4*w*h)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		f(buf)
	}
}

func BenchmarkBGRA(b *testing.B)       { benchmarkBGRA(b, BGRA) }
func BenchmarkPureGoBGRA(b *testing.B) { benchmarkBGRA(b, pureGoBGRA) }

```

`win/syscall_windows.go`:

```go
package win

//go:generate mkwinsyscall -output zsyscall_windows.go syscall_windows.go

type (
	BOOL          uint32
	BOOLEAN       byte
	BYTE          byte
	DWORD         uint32
	DWORD64       uint64
	HANDLE        uintptr
	HLOCAL        uintptr
	LARGE_INTEGER int64
	LONG          int32
	LPVOID        uintptr
	SIZE_T        uintptr
	UINT          uint32
	ULONG_PTR     uintptr
	ULONGLONG     uint64
	WORD          uint16

	HWND uintptr
)

type BITMAPINFOHEADER struct {
	BiSize          uint32
	BiWidth         int32
	BiHeight        int32
	BiPlanes        uint16
	BiBitCount      uint16
	BiCompression   uint32
	BiSizeImage     uint32
	BiXPelsPerMeter int32
	BiYPelsPerMeter int32
	BiClrUsed       uint32
	BiClrImportant  uint32
}
type RGBQUAD struct {
	RgbBlue     byte
	RgbGreen    byte
	RgbRed      byte
	RgbReserved byte
}

type BITMAPINFO struct {
	BmiHeader BITMAPINFOHEADER
	BmiColors *RGBQUAD
}

const (
	OBJ_BITMAP = 7
)

//sys	GetDesktopWindow() (h HWND) = User32.GetDesktopWindow
//sys	GetDIBits(hdc syscall.Handle, hbmp syscall.Handle, uStartScan uint32, cScanLines uint32, lpvBits *byte, lpbi *BITMAPINFO, uUsage uint32) (v int32, err error) = Gdi32.GetDIBits
//sys	GetCurrentObject(hdc syscall.Handle, typ uint16) (h syscall.Handle) = Gdi32.GetCurrentObject

//sys	setWindowsHookExW(idHook int32, lpfn unsafe.Pointer, hmod syscall.Handle, dwThreadId uint32) (h syscall.Handle, err error) = User32.SetWindowsHookExW

//sys	openClipboard(h syscall.Handle) (err error) = User32.OpenClipboard
//sys	closeClipboard() (err error) = User32.CloseClipboard
//sys	emptyClipboard() (err error) = User32.EmptyClipboard
//sys	registerClipboardFormat(name string) (id uint32, err error) = User32.RegisterClipboardFormatW
//sys	enumClipboardFormats(format uint32) (id uint32, err error) = User32.EnumClipboardFormats
//sys	getClipboardFormatName(format uint32, lpszFormatName *uint16, cchMaxCount int32) (len int32, err error) = User32.GetClipboardFormatNameW
//sys	getClipboardData(uFormat uint32) (h syscall.Handle, err error) = User32.GetClipboardData
//sys	setClipboardData(uFormat uint32, hMem syscall.Handle) (h syscall.Handle, err error) = User32.SetClipboardData
//sys	isClipboardFormatAvailable(uFormat uint32) (err error) = User32.IsClipboardFormatAvailable
//sys	AddClipboardFormatListener(hWnd syscall.Handle) (err error) = User32.AddClipboardFormatListener
//sys	RemoveClipboardFormatListener(hWnd syscall.Handle) (err error) = User32.RemoveClipboardFormatListener

//sys	GetProcessHeap() (hHeap syscall.Handle, err error) = Kernel32.GetProcessHeap
//sys	HeapAlloc(hHeap syscall.Handle, dwFlags uint32, dwSize uintptr) (lpMem uintptr, err error) = Kernel32.HeapAlloc
//sys	HeapFree(hHeap syscall.Handle, dwFlags uint32, lpMem uintptr) (err error) = Kernel32.HeapFree
//sys	heapSize(hHeap syscall.Handle, dwFlags uint32, lpMem uintptr) (size uintptr, err error) [failretval==^uintptr(r0)] = Kernel32.HeapSize

//sys	dragQueryFile(hDrop syscall.Handle, iFile int, buf *uint16, len uint32) (n int, err error) = Shell32.DragQueryFileW

const (
	DpiAwarenessContextUndefined         = 0
	DpiAwarenessContextUnaware           = -1
	DpiAwarenessContextSystemAware       = -2
	DpiAwarenessContextPerMonitorAware   = -3
	DpiAwarenessContextPerMonitorAwareV2 = -4
	DpiAwarenessContextUnawareGdiScaled  = -5
)

//sys	SetThreadDpiAwarenessContext(value int32) (n int, err error) = User32.SetThreadDpiAwarenessContext
//sys	IsValidDpiAwarenessContext(value int32) (n bool) = User32.IsValidDpiAwarenessContext

```

`win/zsyscall_windows.go`:

```go
// Code generated by 'go generate'; DO NOT EDIT.

package win

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modGdi32    = windows.NewLazySystemDLL("Gdi32.dll")
	modKernel32 = windows.NewLazySystemDLL("Kernel32.dll")
	modShell32  = windows.NewLazySystemDLL("Shell32.dll")
	modUser32   = windows.NewLazySystemDLL("User32.dll")

	procGetCurrentObject              = modGdi32.NewProc("GetCurrentObject")
	procGetDIBits                     = modGdi32.NewProc("GetDIBits")
	procGetProcessHeap                = modKernel32.NewProc("GetProcessHeap")
	procHeapAlloc                     = modKernel32.NewProc("HeapAlloc")
	procHeapFree                      = modKernel32.NewProc("HeapFree")
	procHeapSize                      = modKernel32.NewProc("HeapSize")
	procDragQueryFileW                = modShell32.NewProc("DragQueryFileW")
	procAddClipboardFormatListener    = modUser32.NewProc("AddClipboardFormatListener")
	procCloseClipboard                = modUser32.NewProc("CloseClipboard")
	procEmptyClipboard                = modUser32.NewProc("EmptyClipboard")
	procEnumClipboardFormats          = modUser32.NewProc("EnumClipboardFormats")
	procGetClipboardData              = modUser32.NewProc("GetClipboardData")
	procGetClipboardFormatNameW       = modUser32.NewProc("GetClipboardFormatNameW")
	procGetDesktopWindow              = modUser32.NewProc("GetDesktopWindow")
	procIsClipboardFormatAvailable    = modUser32.NewProc("IsClipboardFormatAvailable")
	procIsValidDpiAwarenessContext    = modUser32.NewProc("IsValidDpiAwarenessContext")
	procOpenClipboard                 = modUser32.NewProc("OpenClipboard")
	procRegisterClipboardFormatW      = modUser32.NewProc("RegisterClipboardFormatW")
	procRemoveClipboardFormatListener = modUser32.NewProc("RemoveClipboardFormatListener")
	procSetClipboardData              = modUser32.NewProc("SetClipboardData")
	procSetThreadDpiAwarenessContext  = modUser32.NewProc("SetThreadDpiAwarenessContext")
	procSetWindowsHookExW             = modUser32.NewProc("SetWindowsHookExW")
)

func GetCurrentObject(hdc syscall.Handle, typ uint16) (h syscall.Handle) {
	r0, _, _ := syscall.Syscall(procGetCurrentObject.Addr(), 2, uintptr(hdc), uintptr(typ), 0)
	h = syscall.Handle(r0)
	return
}

func GetDIBits(hdc syscall.Handle, hbmp syscall.Handle, uStartScan uint32, cScanLines uint32, lpvBits *byte, lpbi *BITMAPINFO, uUsage uint32) (v int32, err error) {
	r0, _, e1 := syscall.Syscall9(procGetDIBits.Addr(), 7, uintptr(hdc), uintptr(hbmp), uintptr(uStartScan), uintptr(cScanLines), uintptr(unsafe.Pointer(lpvBits)), uintptr(unsafe.Pointer(lpbi)), uintptr(uUsage), 0, 0)
	v = int32(r0)
	if v == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetProcessHeap() (hHeap syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGetProcessHeap.Addr(), 0, 0, 0, 0)
	hHeap = syscall.Handle(r0)
	if hHeap == 0 {
		err = errnoErr(e1)
	}
	return
}

func HeapAlloc(hHeap syscall.Handle, dwFlags uint32, dwSize uintptr) (lpMem uintptr, err error) {
	r0, _, e1 := syscall.Syscall(procHeapAlloc.Addr(), 3, uintptr(hHeap), uintptr(dwFlags), uintptr(dwSize))
	lpMem = uintptr(r0)
	if lpMem == 0 {
		err = errnoErr(e1)
	}
	return
}

func HeapFree(hHeap syscall.Handle, dwFlags uint32, lpMem uintptr) (err error) {
	r1, _, e1 := syscall.Syscall(procHeapFree.Addr(), 3, uintptr(hHeap), uintptr(dwFlags), uintptr(lpMem))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func heapSize(hHeap syscall.Handle, dwFlags uint32, lpMem uintptr) (size uintptr, err error) {
	r0, _, e1 := syscall.Syscall(procHeapSize.Addr(), 3, uintptr(hHeap), uintptr(dwFlags), uintptr(lpMem))
	size = uintptr(r0)
	if size == ^uintptr(r0) {
		err = errnoErr(e1)
	}
	return
}

func dragQueryFile(hDrop syscall.Handle, iFile int, buf *uint16, len uint32) (n int, err error) {
	r0, _, e1 := syscall.Syscall6(procDragQueryFileW.Addr(), 4, uintptr(hDrop), uintptr(iFile), uintptr(unsafe.Pointer(buf)), uintptr(len), 0, 0)
	n = int(r0)
	if n == 0 {
		err = errnoErr(e1)
	}
	return
}

func AddClipboardFormatListener(hWnd syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procAddClipboardFormatListener.Addr(), 1, uintptr(hWnd), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func closeClipboard() (err error) {
	r1, _, e1 := syscall.Syscall(procCloseClipboard.Addr(), 0, 0, 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func emptyClipboard() (err error) {
	r1, _, e1 := syscall.Syscall(procEmptyClipboard.Addr(), 0, 0, 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func enumClipboardFormats(format uint32) (id uint32, err error) {
	r0, _, e1 := syscall.Syscall(procEnumClipboardFormats.Addr(), 1, uintptr(format), 0, 0)
	id = uint32(r0)
	if id == 0 {
		err = errnoErr(e1)
	}
	return
}

func getClipboardData(uFormat uint32) (h syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGetClipboardData.Addr(), 1, uintptr(uFormat), 0, 0)
	h = syscall.Handle(r0)
	if h == 0 {
		err = errnoErr(e1)
	}
	return
}

func getClipboardFormatName(format uint32, lpszFormatName *uint16, cchMaxCount int32) (len int32, err error) {
	r0, _, e1 := syscall.Syscall(procGetClipboardFormatNameW.Addr(), 3, uintptr(format), uintptr(unsafe.Pointer(lpszFormatName)), uintptr(cchMaxCount))
	len = int32(r0)
	if len == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetDesktopWindow() (h HWND) {
	r0, _, _ := syscall.Syscall(procGetDesktopWindow.Addr(), 0, 0, 0, 0)
	h = HWND(r0)
	return
}

func isClipboardFormatAvailable(uFormat uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procIsClipboardFormatAvailable.Addr(), 1, uintptr(uFormat), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func IsValidDpiAwarenessContext(value int32) (n bool) {
	r0, _, _ := syscall.Syscall(procIsValidDpiAwarenessContext.Addr(), 1, uintptr(value), 0, 0)
	n = r0 != 0
	return
}

func openClipboard(h syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procOpenClipboard.Addr(), 1, uintptr(h), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func registerClipboardFormat(name string) (id uint32, err error) {
	var _p0 *uint16
	_p0, err = syscall.UTF16PtrFromString(name)
	if err != nil {
		return
	}
	return _registerClipboardFormat(_p0)
}

func _registerClipboardFormat(name *uint16) (id uint32, err error) {
	r0, _, e1 := syscall.Syscall(procRegisterClipboardFormatW.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)
	id = uint32(r0)
	if id == 0 {
		err = errnoErr(e1)
	}
	return
}

func RemoveClipboardFormatListener(hWnd syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procRemoveClipboardFormatListener.Addr(), 1, uintptr(hWnd), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func setClipboardData(uFormat uint32, hMem syscall.Handle) (h syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procSetClipboardData.Addr(), 2, uintptr(uFormat), uintptr(hMem), 0)
	h = syscall.Handle(r0)
	if h == 0 {
		err = errnoErr(e1)
	}
	return
}

func SetThreadDpiAwarenessContext(value int32) (n int, err error) {
	r0, _, e1 := syscall.Syscall(procSetThreadDpiAwarenessContext.Addr(), 1, uintptr(value), 0, 0)
	n = int(r0)
	if n == 0 {
		err = errnoErr(e1)
	}
	return
}

func setWindowsHookExW(idHook int32, lpfn unsafe.Pointer, hmod syscall.Handle, dwThreadId uint32) (h syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procSetWindowsHookExW.Addr(), 4, uintptr(idHook), uintptr(lpfn), uintptr(hmod), uintptr(dwThreadId), 0, 0)
	h = syscall.Handle(r0)
	if h == 0 {
		err = errnoErr(e1)
	}
	return
}

```