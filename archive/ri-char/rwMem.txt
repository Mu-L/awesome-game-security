Project Path: arc_ri-char_rwMem_yfuyr71k

Source Tree:

```txt
arc_ri-char_rwMem_yfuyr71k
├── CEServer
│   ├── IMemReaderWriterProxy.h
│   ├── MemoryReaderWriter37.hpp
│   ├── api.cpp
│   ├── api.h
│   ├── ceserver.h
│   ├── context.h
│   ├── main.cpp
│   ├── native-api.cpp
│   ├── native-api.h
│   ├── porthelp.cpp
│   ├── porthelp.h
│   ├── symbols.cpp
│   └── symbols.h
├── Cargo.lock
├── Cargo.toml
├── README.md
├── cli
│   ├── Cargo.toml
│   └── src
│       └── main.rs
├── librwmem
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── examples
│   │   └── test.rs
│   └── src
│       ├── errors.rs
│       └── lib.rs
├── patch
│   └── overflow_handler_context.patch
└── rwMem
    ├── Makefile
    ├── api_proxy.h
    ├── bp.c
    ├── bp.h
    ├── phy_mem.h
    ├── proc_maps.h
    ├── sys.c
    ├── sys.h
    └── ver_control.h

```

`CEServer/IMemReaderWriterProxy.h`:

```h
#ifndef MEM_READER_WRITER_PROXY_H_
#define MEM_READER_WRITER_PROXY_H_
#include <atomic>
#include <memory>
#include <mutex>
#include <sstream>
#include <stdint.h>
#include <thread>
#include <vector>


#include <sys/sysinfo.h>
#include <unistd.h>

typedef int BOOL;
#define TRUE 1
#define FALSE 0
#define PAGE_NOACCESS 1
#define PAGE_READONLY 2
#define PAGE_READWRITE 4
#define PAGE_WRITECOPY 8
#define PAGE_EXECUTE 16
#define PAGE_EXECUTE_READ 32
#define PAGE_EXECUTE_READWRITE 64

#define MEM_MAPPED 262144
#define MEM_PRIVATE 131072

#pragma pack(1)
typedef struct {
    uint64_t baseaddress;
    uint64_t size;
    uint32_t protection;
    uint32_t type;
    char name[4096];
} DRIVER_REGION_INFO, *PDRIVER_REGION_INFO;
#pragma pack()

#endif /* MEM_READER_WRITER_PROXY_H_ */

```

`CEServer/MemoryReaderWriter37.hpp`:

```hpp
#ifndef MEMORY_READER_WRITER_H_
#define MEMORY_READER_WRITER_H_

#include <cstddef>
#include <cstdint>
#include <fstream>
#include <mutex>
#include <vector>

#include "IMemReaderWriterProxy.h"
#include <errno.h>
#include <fcntl.h>
#include <malloc.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

// 默认驱动文件名
#define RWPROCMEM_FILE_NODE "/dev/rwMem"

// 安静输出模式
#define QUIET_PRINTF

#ifdef QUIET_PRINTF
#undef TRACE
#define TRACE(fmt, ...)
#else
#define TRACE(fmt, ...) printf(fmt, ##__VA_ARGS__)
#endif

#define MAJOR_NUM 100
#define IOCTL_GET_PROCESS_MAPS_COUNT _IOWR(MAJOR_NUM, 0, char *) // 获取进程的内存块地址数量
#define IOCTL_GET_PROCESS_MAPS_LIST _IOWR(MAJOR_NUM, 1, char *)  // 获取进程的内存块地址列表
#define IOCTL_CHECK_PROCESS_ADDR_PHY _IOWR(MAJOR_NUM, 2, char *) // 检查进程内存是否有物理内存位置

class CMemoryReaderWriter {
  public:
    CMemoryReaderWriter() {}
    ~CMemoryReaderWriter() { DisconnectDriver(); }

    // 连接驱动（驱动节点文件路径名，是否使用躲避SELinux的通信方式，错误代码，机器码ID），返回值：驱动连接句柄，>=0代表成功
    BOOL ConnectDriver(const char *lpszDriverFileNodePath, BOOL bUseBypassSELinuxMode, int &err) {
        if (m_nDriverLink >= 0) {
            return TRUE;
        }
        m_nDriverLink = _rwProcMemDriver_Connect(lpszDriverFileNodePath);
        if (m_nDriverLink < 0) {
            err = m_nDriverLink;
            return FALSE;
        }
        _rwProcMemDriver_UseBypassSELinuxMode(bUseBypassSELinuxMode);
        err = 0;
        return TRUE;
    }

    // 断开驱动，返回值：TRUE成功，FALSE失败
    BOOL DisconnectDriver() {
        if (m_nDriverLink >= 0) {
            _rwProcMemDriver_Disconnect(m_nDriverLink);
            m_nDriverLink = -1;
            return TRUE;
        } else {
            return FALSE;
        }
    }

    // 驱动是否连接正常，返回值：TRUE已连接，FALSE未连接
    BOOL IsDriverConnected() { return m_nDriverLink >= 0; }

    // 驱动_打开进程（进程PID），返回值：进程句柄，0为失败
    uint64_t OpenProcess(uint64_t pid) { return pid; }

    // 驱动_读取进程内存（进程句柄，进程内存地址，读取结果缓冲区，读取结果缓冲区大小，实际读取字节数，是否暴力读取），返回值：TRUE成功，FALSE失败
    BOOL ReadProcessMemory(uint64_t hProcess, uint64_t lpBaseAddress, void *lpBuffer, size_t nSize, size_t *lpNumberOfBytesRead = NULL, BOOL bIsForceRead = FALSE) {
        return _rwProcMemDriver_ReadProcessMemory(m_nDriverLink, hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead, bIsForceRead);
    }

    // 驱动_读取进程内存_单线程极速版（进程句柄，进程内存地址，读取结果缓冲区，读取结果缓冲区大小，实际读取字节数，是否暴力读取），返回值：TRUE成功，FALSE失败
    BOOL ReadProcessMemory_Fast(uint64_t hProcess, uint64_t lpBaseAddress, void *lpBuffer, size_t nSize, size_t *lpNumberOfBytesRead = NULL, BOOL bIsForceRead = FALSE) {
        return _rwProcMemDriver_ReadProcessMemory_Fast(m_nDriverLink, hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead, bIsForceRead);
    }

    // 驱动_写入进程内存（进程句柄，进程内存地址，写入数据缓冲区，写入数据缓冲区大小，实际写入字节数，是否暴力写入），返回值：TRUE成功，FALSE失败
    BOOL WriteProcessMemory(uint64_t hProcess, uint64_t lpBaseAddress, void *lpBuffer, size_t nSize, size_t *lpNumberOfBytesWritten = NULL, BOOL bIsForceWrite = FALSE) {
        return _rwProcMemDriver_WriteProcessMemory(m_nDriverLink, hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten, bIsForceWrite);
    }

    // 驱动_写入进程内存_单线程极速版（进程句柄，进程内存地址，写入数据缓冲区，写入数据缓冲区大小，实际写入字节数，是否暴力写入），返回值：TRUE成功，FALSE失败
    BOOL WriteProcessMemory_Fast(uint64_t hProcess, uint64_t lpBaseAddress, void *lpBuffer, size_t nSize, size_t *lpNumberOfBytesWritten = NULL, BOOL bIsForceWrite = FALSE) {
        return _rwProcMemDriver_WriteProcessMemory_Fast(m_nDriverLink, hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten, bIsForceWrite);
    }

    // 驱动_关闭进程（进程句柄），返回值：TRUE成功，FALSE失败
    BOOL CloseHandle(uint64_t hProcess) { return TRUE; }

    // 驱动_获取进程内存块列表（进程句柄，是否仅显示物理内存，输出缓冲区，输出是否完整），返回值：TRUE成功，FALSE失败
    // （参数showPhy说明: FALSE为显示全部内存，TRUE为只显示在物理内存中的内存，注意：如果进程内存不存在于物理内存中，驱动将无法读取该内存位置的值）
    // （参数bOutListCompleted说明: 若输出FALSE，则代表输出缓冲区里的进程内存块列表不完整，若输出TRUE，则代表输出缓冲区里的进程内存块列表完整可靠）
    BOOL VirtualQueryExFull(uint64_t hProcess, BOOL showPhy, std::vector<DRIVER_REGION_INFO> &vOutput, BOOL &bOutListCompleted) {
        return _rwProcMemDriver_VirtualQueryExFull(m_nDriverLink, hProcess, showPhy, vOutput, &bOutListCompleted);
    }

    // 获取驱动连接FD，返回值：驱动连接的FD
    int GetLinkFD() { return m_nDriverLink; }

    // 设置驱动连接FD
    void SetLinkFD(int fd) { m_nDriverLink = fd; }

    // 设置是否使用躲避SELinux的通信方式
    void SeUseBypassSELinuxMode(BOOL bUseBypassSELinuxMode) { _rwProcMemDriver_UseBypassSELinuxMode(bUseBypassSELinuxMode); }

  private:
    int _rwProcMemDriver_MyIoctl(int fd, unsigned int cmd, unsigned long buf, unsigned long bufSize) {
        if (m_bUseBypassSELinuxMode == TRUE) {
            // 驱动通信方式：lseek，躲开系统SELinux拦截
            char *lseekBuf = (char *)malloc(sizeof(cmd) + bufSize);
            *(unsigned long *)lseekBuf = cmd;
            memcpy((void *)((size_t)lseekBuf + (size_t)sizeof(cmd)), (void *)buf, bufSize);
            uint64_t ret = lseek64(fd, (off64_t)lseekBuf, SEEK_CUR);
            memcpy((void *)buf, (void *)((size_t)lseekBuf + (size_t)sizeof(cmd)), bufSize);
            free(lseekBuf);
            return ret;
        } else {
            // 驱动通信方式：ioctl
            return ioctl(fd, cmd, buf);
        }
    }

    int _rwProcMemDriver_Connect(const char *lpszDriverFileNodePath) {
        int nDriverLink = open(lpszDriverFileNodePath, O_RDWR);
        if (nDriverLink < 0) {
            int last_err = errno;
            if (last_err == EACCES) {
                chmod(lpszDriverFileNodePath, 666);
                nDriverLink = open(lpszDriverFileNodePath, O_RDWR);
                last_err = errno;
                chmod(lpszDriverFileNodePath, 0600);
            }
            if (nDriverLink < 0) {
                TRACE("open error():%s\n", strerror(last_err));
                return -last_err;
            }
        }
        return nDriverLink;
    }

    BOOL _rwProcMemDriver_Disconnect(int nDriverLink) {
        if (nDriverLink < 0) {
            return FALSE;
        }
        close(nDriverLink);
        return TRUE;
    }

    void _rwProcMemDriver_UseBypassSELinuxMode(BOOL bUseBypassSELinuxMode) { m_bUseBypassSELinuxMode = bUseBypassSELinuxMode; }
    BOOL _rwProcMemDriver_ReadProcessMemory(int nDriverLink, uint64_t hProcess, uint64_t lpBaseAddress, void *lpBuffer, size_t nSize, size_t *lpNumberOfBytesRead,
                                            BOOL bIsForceRead) {

        if (lpBaseAddress <= 0) {
            return FALSE;
        }
        if (nDriverLink < 0) {
            return FALSE;
        }
        if (!hProcess) {
            return FALSE;
        }
        if (nSize <= 0) {
            return FALSE;
        }
        if (nSize < 17) {
            char *buf = (char *)calloc(1, 17);
            *(uint64_t *)&buf[0] = hProcess;
            *(uint64_t *)&buf[8] = lpBaseAddress;
            buf[16] = bIsForceRead == TRUE ? '\x01' : '\x00';
            ssize_t realRead = read(nDriverLink, buf, nSize);
            if (realRead <= 0) {
                TRACE("read(): %s\n", strerror(errno));
                free(buf);
                return FALSE;
            }
            if (realRead > 0) {
                memcpy(lpBuffer, buf, realRead);
            }

            if (lpNumberOfBytesRead) {
                *lpNumberOfBytesRead = realRead;
            }
            free(buf);
        } else {
            char *buf = (char *)lpBuffer;
            *(uint64_t *)&buf[0] = hProcess;
            *(uint64_t *)&buf[8] = lpBaseAddress;
            buf[16] = bIsForceRead == TRUE ? '\x01' : '\x00';
            ssize_t realRead = read(nDriverLink, buf, nSize);
            if (realRead <= 0) {
                TRACE("read(): %s\n", strerror(errno));
                return FALSE;
            }

            if (lpNumberOfBytesRead) {
                *lpNumberOfBytesRead = realRead;
            }
        }
        return TRUE;
    }

    BOOL _rwProcMemDriver_ReadProcessMemory_Fast(int nDriverLink, uint64_t hProcess, uint64_t lpBaseAddress, void *lpBuffer, size_t nSize, size_t *lpNumberOfBytesRead,
                                                 BOOL bIsForceRead) {

        if (lpBaseAddress <= 0) {
            return FALSE;
        }
        if (nDriverLink < 0) {
            return FALSE;
        }
        if (!hProcess) {
            return FALSE;
        }
        if (nSize <= 0) {
            return FALSE;
        }
        int bufSize = nSize < 17 ? 17 : nSize;

        // 上一次读内存申请的缓冲区，下一次继续用，可以提速
        static char *lastMallocReadMemBuf = NULL;
        static size_t lastMallocReadMemSize = 0;

        if (lastMallocReadMemSize < bufSize) {
            if (lastMallocReadMemBuf) {
                free(lastMallocReadMemBuf);
            }
            lastMallocReadMemBuf = (char *)malloc(bufSize);
            lastMallocReadMemSize = bufSize;
        }
        memset(lastMallocReadMemBuf, 0, bufSize);
        *(uint64_t *)&lastMallocReadMemBuf[0] = hProcess;
        *(uint64_t *)&lastMallocReadMemBuf[8] = lpBaseAddress;
        lastMallocReadMemBuf[16] = bIsForceRead == TRUE ? '\x01' : '\x00';

        ssize_t realRead = read(nDriverLink, lastMallocReadMemBuf, nSize);

        if (realRead <= 0) {
            TRACE("read(): %s\n", strerror(errno));
            return FALSE;
        }
        if (realRead > 0) {
            memcpy(lpBuffer, lastMallocReadMemBuf, realRead);
        }

        if (lpNumberOfBytesRead) {
            *lpNumberOfBytesRead = realRead;
        }
        return TRUE;
    }

    BOOL _rwProcMemDriver_WriteProcessMemory(int nDriverLink, uint64_t hProcess, uint64_t lpBaseAddress, void *lpBuffer, size_t nSize, size_t *lpNumberOfBytesWritten,
                                             BOOL bIsForceWrite) {
        if (lpBaseAddress <= 0) {
            return FALSE;
        }
        if (nDriverLink < 0) {
            return FALSE;
        }
        if (!hProcess) {
            return FALSE;
        }
        if (nSize <= 0) {
            return FALSE;
        }
        int bufSize = nSize + 17;

        char *buf = (char *)malloc(bufSize);
        memset(buf, 0, bufSize);
        *(uint64_t *)&buf[0] = hProcess;
        *(uint64_t *)&buf[8] = lpBaseAddress;
        buf[16] = bIsForceWrite == TRUE ? '\x01' : '\x00';
        memcpy((void *)((size_t)buf + (size_t)17), lpBuffer, nSize);

        ssize_t realWrite = write(nDriverLink, buf, nSize);
        if (realWrite <= 0) {
            TRACE("write(): %s\n", strerror(errno));
            free(buf);
            return FALSE;
        }

        if (lpNumberOfBytesWritten) {
            *lpNumberOfBytesWritten = realWrite;
        }
        free(buf);
        return TRUE;
    }
    BOOL _rwProcMemDriver_WriteProcessMemory_Fast(int nDriverLink, uint64_t hProcess, uint64_t lpBaseAddress, void *lpBuffer, size_t nSize, size_t *lpNumberOfBytesWritten,
                                                  BOOL bIsForceWrite) {
        if (lpBaseAddress <= 0) {
            return FALSE;
        }
        if (nDriverLink < 0) {
            return FALSE;
        }
        if (!hProcess) {
            return FALSE;
        }
        if (nSize <= 0) {
            return FALSE;
        }
        int bufSize = nSize + 17;

        // 上一次读内存申请的缓冲区，下一次继续用，可以提速
        static char *lastMallocWriteMemBuf = NULL;
        static size_t lastMallocWriteMemSize = 0;

        if (lastMallocWriteMemSize < bufSize) {
            if (lastMallocWriteMemBuf) {
                free(lastMallocWriteMemBuf);
            }
            lastMallocWriteMemBuf = (char *)malloc(bufSize);
            lastMallocWriteMemSize = bufSize;
        }
        *(uint64_t *)&lastMallocWriteMemBuf[0] = hProcess;
        *(uint64_t *)&lastMallocWriteMemBuf[8] = lpBaseAddress;
        lastMallocWriteMemBuf[16] = bIsForceWrite == TRUE ? '\x01' : '\x00';
        memcpy((void *)((size_t)lastMallocWriteMemBuf + (size_t)17), lpBuffer, nSize);

        ssize_t realWrite = write(nDriverLink, lastMallocWriteMemBuf, nSize);
        if (realWrite <= 0) {
            TRACE("write(): %s\n", strerror(errno));
            return FALSE;
        }

        if (lpNumberOfBytesWritten) {
            *lpNumberOfBytesWritten = realWrite;
        }
        return TRUE;
    }

    BOOL _rwProcMemDriver_VirtualQueryExFull(int nDriverLink, uint64_t hProcess, BOOL showPhy, std::vector<DRIVER_REGION_INFO> &vOutput, BOOL *bOutListCompleted) {
        if (nDriverLink < 0) {
            return FALSE;
        }
        if (!hProcess) {
            return FALSE;
        }
        int count = _rwProcMemDriver_MyIoctl(nDriverLink, IOCTL_GET_PROCESS_MAPS_COUNT, (unsigned long)hProcess, sizeof(hProcess));
        TRACE("VirtualQueryExFull count %d\n", count);
        if (count <= 0) {
            TRACE("VirtualQueryExFull ioctl():%s\n", strerror(errno));
            return FALSE;
        }

        uint64_t big_buf_len = 8 + (8 + 8 + 4 + 512) * (count + 50);
        char *big_buf = (char *)calloc(1, big_buf_len);
        *(uint64_t *)&big_buf[0] = hProcess;

        uint64_t name_len = 512;
        *(uint64_t *)&big_buf[8] = name_len;
        *(uint64_t *)&big_buf[16] = big_buf_len;

        int unfinish = _rwProcMemDriver_MyIoctl(nDriverLink, IOCTL_GET_PROCESS_MAPS_LIST, (unsigned long)big_buf, big_buf_len);
        TRACE("VirtualQueryExFull unfinish %d\n", unfinish);
        if (unfinish < 0) {
            TRACE("VirtualQueryExFull ioctl():%s\n", strerror(errno));
            free(big_buf);
            return FALSE;
        }
        size_t copy_pos = (size_t)big_buf;
        uint64_t res = *(uint64_t *)big_buf;
        *bOutListCompleted = unfinish;
        copy_pos += 8;
        for (; res > 0; res--) {
            uint64_t vma_start = 0;
            uint64_t vma_end = 0;
            char vma_flags[4] = {0};
            char name[512] = {0};

            vma_start = *(uint64_t *)copy_pos;
            copy_pos += 8;
            vma_end = *(uint64_t *)copy_pos;
            copy_pos += 8;
            memcpy(&vma_flags, (void *)copy_pos, 4);
            copy_pos += 4;
            memcpy(&name, (void *)copy_pos, 512);
            name[sizeof(name) - 1] = '\0';
            copy_pos += 512;

            DRIVER_REGION_INFO rInfo = {0};
            rInfo.baseaddress = vma_start;
            rInfo.size = vma_end - vma_start;
            if (vma_flags[2] == '\x01') {
                // executable
                if (vma_flags[1] == '\x01') {
                    rInfo.protection = PAGE_EXECUTE_READWRITE;
                } else {
                    rInfo.protection = PAGE_EXECUTE_READ;
                }
            } else {
                // not executable
                if (vma_flags[1] == '\x01') {
                    rInfo.protection = PAGE_READWRITE;
                } else if (vma_flags[0] == '\x01') {
                    rInfo.protection = PAGE_READONLY;
                } else {
                    rInfo.protection = PAGE_NOACCESS;
                }
            }
            if (vma_flags[3] == '\x01') {
                rInfo.type = MEM_MAPPED;
            } else {
                rInfo.type = MEM_PRIVATE;
            }
            memcpy(&rInfo.name, &name, 512);
            rInfo.name[sizeof(rInfo.name) - 1] = '\0';
            if (showPhy) {
                // 只显示在物理内存中的内存
                DRIVER_REGION_INFO rPhyInfo = {0};

                uint64_t addr;
                int isPhyRegion = 0;
                char *isphy = _rwProcMemDriver_CheckMemAddrIsValid(nDriverLink, hProcess, vma_start, vma_end);
                if(!isphy) {
                    continue;
                }
                int i;
                for (addr = vma_start, i = 0; addr < vma_end; addr += getpagesize(), i++) {
                    if (isphy[i / 8] & ((char)1 << (i % 8))) {
                        if (isPhyRegion == 0) {
                            isPhyRegion = 1;
                            rPhyInfo.baseaddress = addr;
                            rPhyInfo.protection = rInfo.protection;
                            rPhyInfo.type = rInfo.type;
                            strcpy(rPhyInfo.name, rInfo.name);
                        }

                    } else {
                        if (isPhyRegion == 1) {
                            isPhyRegion = 0;
                            rPhyInfo.size = addr - rPhyInfo.baseaddress;
                            vOutput.push_back(rPhyInfo);
                        }
                    }
                }

                if (isPhyRegion == 1) {
                    // all vma region inside phy memory
                    rPhyInfo.size = vma_end - rPhyInfo.baseaddress;
                    vOutput.push_back(rPhyInfo);
                }
                delete[] isphy;

            } else {
                // 显示全部内存
                vOutput.push_back(rInfo);
            }
        }
        free(big_buf);

        return !unfinish;
    }

    char *_rwProcMemDriver_CheckMemAddrIsValid(int nDriverLink, uint64_t hProcess, uint64_t BeginAddress, uint64_t EndAddress) {
        if (nDriverLink < 0) {
            return FALSE;
        }
        if (!hProcess) {
            return FALSE;
        }
        size_t bufSize = std::max<int>(24, ((EndAddress/getpagesize()) - (BeginAddress/getpagesize()) + 7) / 8);
        char *ptr_buf = new char[bufSize];
        *(uint64_t *)&ptr_buf[0] = hProcess;
        *(uint64_t *)&ptr_buf[8] = BeginAddress;
        *(uint64_t *)&ptr_buf[16] = EndAddress;
        int r = _rwProcMemDriver_MyIoctl(nDriverLink, IOCTL_CHECK_PROCESS_ADDR_PHY, (unsigned long)ptr_buf, bufSize);
        if (r > 0) {
            return ptr_buf;
        }
        return nullptr;
    }

  private:
    int m_nDriverLink = -1;
    BOOL m_bUseBypassSELinuxMode = FALSE; // 记录是否有SELinux拦截
};

#endif /* MEMORY_READER_WRITER_H_ */

```

`CEServer/api.cpp`:

```cpp
#include "api.h"
#include "ceserver.h"
#include "porthelp.h"
#include <cinttypes>
#include <dirent.h>
#include <fcntl.h>
#include <inttypes.h>
#include <malloc.h>
#include <memory>
#include <random>
#include <sstream>

CMemoryReaderWriter m_Driver;

BOOL CApi::InitReadWriteDriver(const char *lpszDevFileName, BOOL bUseBypassSELinuxMode) {
    if (!lpszDevFileName) {
        // 驱动默认文件名
        lpszDevFileName = RWPROCMEM_FILE_NODE;
    }

    printf("Connecting rwDriver:%s\n", lpszDevFileName);

    // 连接驱动
    int err = 0;
    if (!m_Driver.ConnectDriver(lpszDevFileName, bUseBypassSELinuxMode, err)) {
        printf("Connect rwDriver failed. error:%d\n", err);
        fflush(stdout);
        return FALSE;
    }

    return TRUE;
}

BOOL GetProcessListInfo(CMemoryReaderWriter *pDriver, BOOL bGetPhyMemorySize, std::vector<MyProcessInfo> &vOutput) {
    DIR *dir = NULL;
    struct dirent *ptr = NULL;

    dir = opendir("/proc");
    if (dir) {
        while ((ptr = readdir(dir)) != NULL) { // 循环读取路径下的每一个文件/文件夹
            // 如果读取到的是"."或者".."则跳过，读取到的不是文件夹名字也跳过
            if ((strcmp(ptr->d_name, ".") == 0) || (strcmp(ptr->d_name, "..") == 0)) {
                continue;
            } else if (ptr->d_type != DT_DIR) {
                continue;
            } else if (strspn(ptr->d_name, "1234567890") != strlen(ptr->d_name)) {
                continue;
            }

            int pid = atoi(ptr->d_name);

            MyProcessInfo pInfo = {0};
            pInfo.pid = pid;
            if (bGetPhyMemorySize) {
                uint64_t outRss, vmSize;
                char statm_file_path[200] = {0};
                sprintf(statm_file_path, "/proc/%d/statm", pid);
                FILE *stat_file = fopen(statm_file_path, "r");
                if (fscanf(stat_file, "%lu %lu", &vmSize, &outRss) == EOF)
                    perror("fscanf");
                pInfo.total_rss = outRss * 4;
                fclose(stat_file);
            }
            char cmdline[500] = {0};
            char cmdline_file_path[32] = {0};
            sprintf(cmdline_file_path, "/proc/%d/cmdline", pid);
            FILE *cmdline_file = fopen(cmdline_file_path, "r");
            size_t read = fread(cmdline, 1, sizeof(cmdline), cmdline_file);
            if (read > 1) {
                for (int i = 0; i < read; i++) {
                    if (cmdline[i] == '\0')
                        cmdline[i] = ' ';
                }
            }
            fclose(cmdline_file);
            pInfo.cmdline = std::string(cmdline, read);
            vOutput.push_back(pInfo);
        }
        closedir(dir);
        return TRUE;
    }
    return FALSE;
}

HANDLE CApi::CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID) {

    if (dwFlags & TH32CS_SNAPPROCESS) {
        // printf("TH32CS_SNAPPROCESS\n");
        // 获取进程列表
        CeProcessList *pCeProcessList = new CeProcessList();

        // 获取进程列表
        GetProcessListInfo(&m_Driver, FALSE, pCeProcessList->vProcessList);

        pCeProcessList->readIter = pCeProcessList->vProcessList.begin();
        return CPortHelper::CreateHandleFromPointer((uint64_t)pCeProcessList, htTHSProcess);
    } else if (dwFlags & TH32CS_SNAPMODULE) {
        // printf("TH32CS_SNAPMODULE\n");
        HANDLE hm = CPortHelper::FindHandleByPID(th32ProcessID);
        if (!hm) {
            // 如果没有打开此进程，就不允许获取此进程的模块列表
            return 0;
        }

        CeOpenProcess *pCeOpenProcess = (CeOpenProcess *)CPortHelper::GetPointerFromHandle(hm);

        // 取出驱动进程句柄
        uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;

        // 驱动_获取进程内存块列表（显示全部内存）
        std::vector<DRIVER_REGION_INFO> vMaps;
        BOOL bOutListCompleted;
        BOOL b = m_Driver.VirtualQueryExFull(u64DriverProcessHandle, FALSE, vMaps, bOutListCompleted);

        if (!vMaps.size()) {
            printf("VirtualQueryExFull failed\n");
            fflush(stdout);
            return 0;
        }

        CeModuleList *pCeModuleList = new CeModuleList();

        // 显示进程内存块地址列表
        for (DRIVER_REGION_INFO rinfo : vMaps) {
            if (rinfo.protection == PAGE_NOACCESS) {
                // 此地址不可访问
                continue;
            } else if (rinfo.type == MEM_MAPPED) {
                continue;
            } else if (rinfo.name[0] == '\0') {
                continue;
            } else if (strcmp(rinfo.name, "[heap]") == 0) {
                continue;
            }
            if (strcmp(rinfo.name, "[vdso]") != 0) // ceOpenProcessorary patch as to not rename vdso, because it is treated differently by the ce symbol loader
            {
                for (int i = 0; rinfo.name[i]; i++) // strip square brackets from the name (conflicts with pointer notations)
                {
                    if ((rinfo.name[i] == '[') || (rinfo.name[i] == ']')) {
                        rinfo.name[i] = '_';
                    }
                }
            }

            int isExist = 0;
            for (auto iter = pCeModuleList->vModuleList.begin(); iter != pCeModuleList->vModuleList.end(); iter++) {
                if (iter->moduleName == std::string(rinfo.name)) {
                    isExist = 1;
                    ModuleListEntry newReplace = *iter;
                    newReplace.moduleSize += rinfo.size;
                    iter = pCeModuleList->vModuleList.insert(iter, newReplace);
                    iter++;
                    if (iter != pCeModuleList->vModuleList.end()) {
                        pCeModuleList->vModuleList.erase(iter);

                        break;
                    }
                }
            }
            if (isExist) {
                continue;
            }

            uint32_t magic = 0;
            BOOL b = m_Driver.ReadProcessMemory(u64DriverProcessHandle, rinfo.baseaddress, &magic, 4, NULL, FALSE);
            if (b == FALSE) {
                // printf("%s is unreadable(%llx)\n", modulepath, start);
                continue; // unreadable
            }
            if (magic != 0x464c457f) //  7f 45 4c 46
            {
                // printf("%s is not an ELF(%llx).  tempbuf=%s\n", modulepath, start, tempbuf);
                continue; // not an ELF
            }

            ModuleListEntry newModInfo;
            newModInfo.baseAddress = rinfo.baseaddress;
            newModInfo.moduleSize = rinfo.size;
            newModInfo.moduleName = rinfo.name;
            // printf("%s\n", newModInfo.moduleName.c_str());

            pCeModuleList->vModuleList.push_back(newModInfo);

            // printf("+++Start:%llx,Size:%lld,Protection:%d,Type:%d,Name:%s\n", rinfo.baseaddress, rinfo.size, rinfo.protection, rinfo.type, rinfo.name);
        }

        pCeModuleList->readIter = pCeModuleList->vModuleList.begin();
        return CPortHelper::CreateHandleFromPointer((uint64_t)pCeModuleList, htTHSModule);
    } else if (dwFlags & TH32CS_SNAPTHREAD) {
        int max = 64;
        char _taskdir[255];
        DIR *taskdir;

        if (th32ProcessID == 0)
            return 0; // not handled (unlike the windows TH32CS_SNAPTHREAD, this only gets the threads of the provided processid)

        sprintf(_taskdir, "/proc/%d/task", th32ProcessID);

        taskdir = opendir(_taskdir);
        if (taskdir) {
            struct dirent *d;
            PThreadList tl = (PThreadList)malloc(sizeof(ThreadList));

            tl->ReferenceCount = 1;
            tl->threadCount = 0;
            tl->threadList = (int *)malloc(max * sizeof(int));

            d = readdir(taskdir);
            while (d) {
                int tid = atoi(d->d_name);

                if (tid) {
                    tl->threadList[tl->threadCount] = tid;
                    tl->threadCount++;
                    if (tl->threadCount >= max) {
                        max = max * 2;
                        tl->threadList = (int *)realloc(tl->threadList, max * sizeof(int));
                    }
                }
                d = readdir(taskdir);
            }
            closedir(taskdir);

            return CPortHelper::CreateHandleFromPointer((uint64_t)tl, htTHSThread);
        }
    }

    return 0;
}

BOOL CApi::Process32First(HANDLE hSnapshot, ProcessListEntry &processentry) {
    // Get a processentry from the processlist snapshot. fill the given processentry with the data.

    // printf("Process32First\n");
    if (CPortHelper::GetHandleType(hSnapshot) == htTHSProcess) {
        CeProcessList *pCeProcessList = (CeProcessList *)CPortHelper::GetPointerFromHandle(hSnapshot);
        pCeProcessList->readIter = pCeProcessList->vProcessList.begin();
        if (pCeProcessList->readIter != pCeProcessList->vProcessList.end()) {
            processentry.PID = pCeProcessList->readIter->pid;
            processentry.ProcessName = pCeProcessList->readIter->cmdline;

            return TRUE;
        }
    }
    return FALSE;
}

BOOL CApi::Process32Next(HANDLE hSnapshot, ProcessListEntry &processentry) {
    // get the current iterator of the list and increase it. If the max has been reached, return false
    // printf("Process32Next\n");

    if (CPortHelper::GetHandleType(hSnapshot) == htTHSProcess) {
        CeProcessList *pCeProcessList = (CeProcessList *)CPortHelper::GetPointerFromHandle(hSnapshot);
        pCeProcessList->readIter++;
        if (pCeProcessList->readIter != pCeProcessList->vProcessList.end()) {
            processentry.PID = pCeProcessList->readIter->pid;
            processentry.ProcessName = pCeProcessList->readIter->cmdline;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CApi::Module32First(HANDLE hSnapshot, ModuleListEntry &moduleentry) {
    if (CPortHelper::GetHandleType(hSnapshot) == htTHSModule) {
        CeModuleList *pCeModuleList = (CeModuleList *)CPortHelper::GetPointerFromHandle(hSnapshot);

        pCeModuleList->readIter = pCeModuleList->vModuleList.begin();
        if (pCeModuleList->readIter != pCeModuleList->vModuleList.end()) {
            moduleentry.baseAddress = pCeModuleList->readIter->baseAddress;
            moduleentry.moduleSize = pCeModuleList->readIter->moduleSize;
            moduleentry.moduleName = pCeModuleList->readIter->moduleName;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CApi::Module32Next(HANDLE hSnapshot, ModuleListEntry &moduleentry) {
    // get the current iterator of the list and increase it. If the max has been reached, return false
    if (CPortHelper::GetHandleType(hSnapshot) == htTHSModule) {
        CeModuleList *pCeModuleList = (CeModuleList *)CPortHelper::GetPointerFromHandle(hSnapshot);
        pCeModuleList->readIter++;
        if (pCeModuleList->readIter != pCeModuleList->vModuleList.end()) {
            moduleentry.baseAddress = pCeModuleList->readIter->baseAddress;
            moduleentry.moduleSize = pCeModuleList->readIter->moduleSize;
            moduleentry.moduleName = pCeModuleList->readIter->moduleName;
            return TRUE;
        }
    }
    return FALSE;
}

HANDLE CApi::OpenProcess(DWORD pid) {
    // check if this process has already been opened
    HANDLE hm = CPortHelper::FindHandleByPID(pid);
    if (hm) {
        return hm;
    }
    // still here, so not opened yet

    // 驱动_打开进程
    uint64_t u64DriverProcessHandle = m_Driver.OpenProcess(pid);
    if (u64DriverProcessHandle == 0) {
        return 0;
    }
    CeOpenProcess *pCeOpenProcess = new CeOpenProcess();
    pCeOpenProcess->pid = pid;
    pCeOpenProcess->u64DriverProcessHandle = u64DriverProcessHandle;
    pCeOpenProcess->nLastGetMapsTime = 0;
    return CPortHelper::CreateHandleFromPointer((uint64_t)pCeOpenProcess, htProcesHandle);
}

void CApi::CloseHandle(HANDLE h) {

    int i;
    handleType ht = CPortHelper::GetHandleType(h);
    uint64_t pl = CPortHelper::GetPointerFromHandle(h);

    if (ht == htTHSModule) {
        auto pCeModuleList = (CeModuleList *)pl;
        delete pCeModuleList;
    } else if (ht == htTHSProcess) {
        auto pProcessList = (CeProcessList *)pl;
        delete pProcessList;
    } else if (ht == htProcesHandle) {
        auto pOpenProcess = (CeOpenProcess *)pl;
        m_Driver.CloseHandle(pOpenProcess->u64DriverProcessHandle);
        delete pOpenProcess;
    } else if (ht == htTHSThread) {
        auto pThreadList = (PThreadList)pl;
        free(pThreadList->threadList);
        free(pThreadList);
    }
    // else
    //{
    //	if (ht == htNativeThreadHandle)
    //	{
    //		uint64_t *th = GetPointerFromHandle(h);
    //		printf("Closing thread handle\n");

    //		free(th);
    //		RemoveHandle(h);
    //	}
    //	else
    //	{
    //		RemoveHandle(h); //no idea what it is...
    //	}

    //}
    CPortHelper::RemoveHandle(h);
}

int CApi::VirtualQueryExFull(HANDLE hProcess, uint32_t flags, std::vector<RegionInfo> &vRinfo)
/*
 * creates a full list of the maps file (less seeking)
 */
{
    printf("VirtualQueryExFull: %d \n", hProcess);

    if (CPortHelper::GetHandleType(hProcess) != htProcesHandle) {
        printf("VirtualQueryExFull handle Error: %d \n", hProcess);
        return 0;
    }
    CeOpenProcess *pCeOpenProcess = (CeOpenProcess *)CPortHelper::GetPointerFromHandle(hProcess);

    // 取出驱动进程句柄
    uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;

    // int pagedonly = flags & VQE_PAGEDONLY;
    // int dirtyonly = flags & VQE_DIRTYONLY;
    int noshared = flags & VQE_NOSHARED;

    vRinfo.clear();

    // 驱动_获取进程内存块列表（只显示在物理内存中的内存）
    std::lock_guard<std::mutex> mtxLock(pCeOpenProcess->mtxLockLastMaps);
    pCeOpenProcess->vLastMaps.clear();
    BOOL bOutListCompleted;
    m_Driver.VirtualQueryExFull(u64DriverProcessHandle, TRUE, pCeOpenProcess->vLastMaps, bOutListCompleted);
    printf("m_Driver.VirtualQueryExFull(showPhy) :%zu\n", pCeOpenProcess->vLastMaps.size());
    fflush(stdout);

    if (!pCeOpenProcess->vLastMaps.size()) {
        pCeOpenProcess->nLastGetMapsTime = 0;

        printf("m_Driver.VirtualQueryExFull(showPhy)  failed.\n");
        fflush(stdout);

        return 0;
    } else {
        // 记录当前系统运行毫秒
        struct timespec times = {0, 0};
        clock_gettime(CLOCK_MONOTONIC, &times);
        pCeOpenProcess->nLastGetMapsTime = times.tv_sec * 1000 + times.tv_nsec / 1000000;
    }

    // 显示进程内存块地址列表
    for (DRIVER_REGION_INFO rinfo : pCeOpenProcess->vLastMaps) {
        if (rinfo.protection == PAGE_NOACCESS) {
            // 此地址不可访问
            continue;
        } else if (rinfo.type == MEM_MAPPED) // some checks to see if it passed
        {
            if (noshared) {
                continue;
            }
        }

        RegionInfo newInfo = {0};
        newInfo.baseaddress = rinfo.baseaddress;
        newInfo.size = rinfo.size;
        newInfo.protection = rinfo.protection;
        newInfo.type = rinfo.type;
        vRinfo.push_back(newInfo);
        // printf("+++Start:%llx,Size:%lld,Protection:%d,Type:%d,Name:%s\n", rinfo.baseaddress, rinfo.size, rinfo.protection, rinfo.type, rinfo.name);
    }
    return 1;
}

int CApi::VirtualQueryEx(HANDLE hProcess, uint64_t lpAddress, RegionInfo &rinfo, std::string &memName) {
    /*
     * Alternate method: read pagemaps and look up the pfn in /proc/kpageflags (needs to 2 files open and random seeks through both files, so not sure if slow or painfully slow...)
     */

    // VirtualQueryEx stub port. Not a real port, and returns true if successful and false on error
    int found = 0;

    // printf("VirtualQueryEx %d (%p)\n", hProcess, lpAddress);

    if (CPortHelper::GetHandleType(hProcess) != htProcesHandle) {
        return 0;
    }

    CeOpenProcess *pCeOpenProcess = (CeOpenProcess *)CPortHelper::GetPointerFromHandle(hProcess);

    // 取出驱动进程句柄
    uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;

    // 驱动_获取进程内存块列表（只显示在物理内存中的内存）
    std::lock_guard<std::mutex> mtxLock(pCeOpenProcess->mtxLockLastMaps);

    // 记录当前系统运行毫秒
    struct timespec times = {0, 0};
    clock_gettime(CLOCK_MONOTONIC, &times);
    auto nowTime = times.tv_sec * 1000 + times.tv_nsec / 1000000;
    if ((nowTime - pCeOpenProcess->nLastGetMapsTime) > 1000 * 60) // 每60秒获取一次内存列表
    {
        // 上次的列表超时了，重新获取一份新的
        pCeOpenProcess->vLastMaps.clear();
        BOOL bOutListCompleted;
        BOOL b = m_Driver.VirtualQueryExFull(u64DriverProcessHandle, TRUE, pCeOpenProcess->vLastMaps, bOutListCompleted);
        fflush(stdout);

        if (!pCeOpenProcess->vLastMaps.size()) {
            pCeOpenProcess->nLastGetMapsTime = 0;
            printf("VirtualQueryExFull failed\n");
            fflush(stdout);
            return 0;
        } else {
            // 记录这次列表的获取时间
            memset(&times, 0, sizeof(times));
            clock_gettime(CLOCK_MONOTONIC, &times);
            pCeOpenProcess->nLastGetMapsTime = times.tv_sec * 1000 + times.tv_nsec / 1000000;
        }
    }

    rinfo.protection = 0;
    rinfo.baseaddress = (uint64_t)lpAddress & ~0xfff;
    lpAddress = (uint64_t)(rinfo.baseaddress);

    // 显示进程内存块地址列表
    for (DRIVER_REGION_INFO r : pCeOpenProcess->vLastMaps) {
        uint64_t stop = r.baseaddress + r.size;
        if (stop > lpAddress) // we passed it
        {
            found = 1;

            if (lpAddress >= r.baseaddress) {
                // it's inside the region, so useable

                rinfo.protection = r.protection;
                rinfo.type = r.type;
                rinfo.size = stop - rinfo.baseaddress;
            } else {
                rinfo.size = r.baseaddress - rinfo.baseaddress;
                rinfo.protection = PAGE_NOACCESS;
                rinfo.type = 0;
            }
            memName = r.name;

            // printf("+++Start:%llx,Size:%lld %lld,Protection:%d,Type:%d\n", rinfo.baseaddress, rinfo.size, r.size, rinfo.protection, rinfo.type);
            break;
        }
    }

    return found;
}

int CApi::ReadProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size) {
    // idea in case this is too slow. always read a full page and keep the last 16 accessed pages.
    // only on cache miss, or if the cache is older than 1000 milliseconds fetch the page.
    // keep in mind that this routine can get called by multiple threads at the same time

    // todo: Try process_vm_readv

    // printf("ReadProcessMemory(%d, %p, %p, %d)\n", (int)hProcess, lpAddress, buffer, size);

    // printf("ReadProcessMemory\n");

    size_t bread = 0;

    if (CPortHelper::GetHandleType(hProcess) != htProcesHandle) {
        return 0;
    }
    CeOpenProcess *pCeOpenProcess = (CeOpenProcess *)CPortHelper::GetPointerFromHandle(hProcess);

    // 取出驱动进程句柄
    uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;

    // valid handle
    // 驱动_读取进程内存
    m_Driver.ReadProcessMemory(u64DriverProcessHandle, (uint64_t)lpAddress, buffer, size, &bread, FALSE);
    return (int)bread;
}

int CApi::WriteProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size) {
    size_t written = 0;
    // printf("WriteProcessMemory(%d, %p, %p, %d\n", hProcess, lpAddress, buffer, size);

    if (CPortHelper::GetHandleType(hProcess) != htProcesHandle) {
        return 0;
    }

    CeOpenProcess *pCeOpenProcess = (CeOpenProcess *)CPortHelper::GetPointerFromHandle(hProcess);

    // 取出驱动进程句柄
    uint64_t u64DriverProcessHandle = pCeOpenProcess->u64DriverProcessHandle;

    // valid handle
    // 驱动_读取进程内存
    m_Driver.WriteProcessMemory(u64DriverProcessHandle, (uint64_t)lpAddress, buffer, size, &written, FALSE);

    return (int)written;
}

```

`CEServer/api.h`:

```h
#pragma once
#include "MemoryReaderWriter37.hpp"
#include "context.h"
#include "porthelp.h"
#include <pthread.h>
#include <stdint.h>
#include <sys/queue.h>
/*

#if defined(__arm__) || defined(__ANDROID__)
#include <linux/user.h>
#else
#include <sys/user.h>
#endif
*/

#ifdef HAS_LINUX_USER_H
#include <linux/user.h>
#else
#include <sys/user.h>
#endif

#include <string>

#define VQE_PAGEDONLY 1
#define VQE_DIRTYONLY 2
#define VQE_NOSHARED 4

struct ModuleListEntry {
    unsigned long long baseAddress;
    int moduleSize;
    std::string moduleName;
};

struct ProcessListEntry {
    int PID;
    std::string ProcessName;
};

#pragma pack(1)
struct RegionInfo {
    uint64_t baseaddress;
    uint64_t size;
    uint32_t protection;
    uint32_t type;
};
#pragma pack()

struct MyProcessInfo {
    int pid;
    size_t total_rss;
    std::string cmdline;
};

struct CeProcessList {
    std::vector<MyProcessInfo> vProcessList;
    decltype(vProcessList)::iterator readIter;
};

struct CeModuleList {
    std::vector<ModuleListEntry> vModuleList;
    decltype(vModuleList)::iterator readIter;
};

struct CeOpenProcess {
    int pid;
    uint64_t u64DriverProcessHandle;

    // 短时间内保留上次获取的内存Maps，避免频繁调用驱动获取
    std::mutex mtxLockLastMaps; // 访问冲突锁
    std::vector<DRIVER_REGION_INFO> vLastMaps;
    std::atomic<uint64_t> nLastGetMapsTime;
};

class CApi {
  public:
    static BOOL InitReadWriteDriver(const char *lpszDevFileName, BOOL bUseBypassSELinuxMode);
    static HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
    static BOOL Process32First(HANDLE hSnapshot, ProcessListEntry &processentry);
    static BOOL Process32Next(HANDLE hSnapshot, ProcessListEntry &processentry);
    static BOOL Module32First(HANDLE hSnapshot, ModuleListEntry &moduleentry);
    static BOOL Module32Next(HANDLE hSnapshot, ModuleListEntry &moduleentry);
    static HANDLE OpenProcess(DWORD pid);
    static void CloseHandle(HANDLE h);
    static int VirtualQueryExFull(HANDLE hProcess, uint32_t flags, std::vector<RegionInfo> &vRinfo);
    static int VirtualQueryEx(HANDLE hProcess, uint64_t lpAddress, RegionInfo &rinfo, std::string &memName);
    static int ReadProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size);
    static int WriteProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size);

  protected:
};

```

`CEServer/ceserver.h`:

```h
#ifndef CESERVER_H_
#define CESERVER_H_

#include "porthelp.h"
#include <stdint.h>
#include <sys/types.h>

#define CMD_GETVERSION 0
#define CMD_CLOSECONNECTION 1
#define CMD_TERMINATESERVER 2
#define CMD_OPENPROCESS 3
#define CMD_CREATETOOLHELP32SNAPSHOT 4
#define CMD_PROCESS32FIRST 5
#define CMD_PROCESS32NEXT 6
#define CMD_CLOSEHANDLE 7
#define CMD_VIRTUALQUERYEX 8
#define CMD_READPROCESSMEMORY 9
#define CMD_WRITEPROCESSMEMORY 10
#define CMD_STARTDEBUG 11
#define CMD_STOPDEBUG 12
#define CMD_WAITFORDEBUGEVENT 13
#define CMD_CONTINUEFROMDEBUGEVENT 14
#define CMD_SETBREAKPOINT 15
#define CMD_REMOVEBREAKPOINT 16
#define CMD_SUSPENDTHREAD 17
#define CMD_RESUMETHREAD 18
#define CMD_GETTHREADCONTEXT 19
#define CMD_SETTHREADCONTEXT 20
#define CMD_GETARCHITECTURE 21
#define CMD_MODULE32FIRST 22
#define CMD_MODULE32NEXT 23

#define CMD_GETSYMBOLLISTFROMFILE 24
#define CMD_LOADEXTENSION 25

#define CMD_ALLOC 26
#define CMD_FREE 27
#define CMD_CREATETHREAD 28
#define CMD_LOADMODULE 29
#define CMD_SPEEDHACK_SETSPEED 30

#define CMD_VIRTUALQUERYEXFULL 31
#define CMD_GETREGIONINFO 32
#define CMD_GETABI 33
// 4
#define CMD_SET_CONNECTION_NAME 34

#define CMD_CREATETOOLHELP32SNAPSHOTEX 35

#define CMD_CHANGEMEMORYPROTECTION 36

#define CMD_GETOPTIONS 37
#define CMD_GETOPTIONVALUE 38
#define CMD_SETOPTIONVALUE 39

// when injection won't work but ptrace does:
#define CMD_PTRACE_MMAP 40

// returns a fake filehandle to be used by CE (handled by the internal handle list)
#define CMD_OPENNAMEDPIPE 41
#define CMD_PIPEREAD 42
#define CMD_PIPEWRITE 43

#define CMD_GETCESERVERPATH 44
#define CMD_ISANDROID 45

#define CMD_LOADMODULEEX 46

#define CMD_SETCURRENTPATH 47
#define CMD_GETCURRENTPATH 48
#define CMD_ENUMFILES 49
#define CMD_GETFILEPERMISSIONS 50
#define CMD_SETFILEPERMISSIONS 51
#define CMD_GETFILE 52
#define CMD_PUTFILE 53
#define CMD_CREATEDIR 54
#define CMD_DELETEFILE 55

#define CMD_AOBSCAN 200

// just in case I ever get over 255 commands this value will be reserved for a secondary command list (FF 00 -  FF 01 - ... - FF FE - FF FF 01 - FF FF 02 - .....
#define CMD_COMMANDLIST2 255

// extern char *versionstring;

#pragma pack(1)
struct CeVersion {
    int version;
    unsigned char stringsize;
    // append the versionstring
};

struct CeCreateToolhelp32Snapshot {
    DWORD dwFlags;
    DWORD th32ProcessID;
};

struct CeProcessEntry {
    int result;
    int pid;
    int processnamesize;
    // processname
};

typedef struct {
    int ReferenceCount;
    int threadListIterator;
    int threadCount;
    int *threadList;
} ThreadList, *PThreadList;

struct CeModuleEntry {
    int32_t result;
    int64_t modulebase;
    int32_t modulepart;
    int32_t modulesize;
    uint32_t modulefileoffset;
    int32_t modulenamesize;
};

struct CeVirtualQueryExInput {
    int handle;
    uint64_t baseaddress;
};

struct CeVirtualQueryExOutput {
    uint8_t result;
    uint32_t protection;
    uint32_t type;
    uint64_t baseaddress;
    uint64_t size;
};

struct CeVirtualQueryExFullInput {
    int handle;
    uint8_t flags;
};

struct CeVirtualQueryExFullOutput {
    uint32_t protection;
    uint32_t type;
    uint64_t baseaddress;
    uint64_t size;
};

struct CeReadProcessMemoryInput {
    uint32_t handle;
    uint64_t address;
    uint32_t size;
    uint8_t compress;
};

struct CeReadProcessMemoryOutput {
    int read;
};

struct CeWriteProcessMemoryInput {
    int32_t handle;
    int64_t address;
    int32_t size;
};

struct CeWriteProcessMemoryOutput {
    int32_t written;
};

struct CeSetBreapointInput {
    HANDLE hProcess;
    int tid;
    int debugreg;
    uint64_t Address;
    int bptype;
    int bpsize;
};

struct CeSetBreapointOutput {
    int result;
};

struct CeRemoveBreapointInput {
    HANDLE hProcess;
    uint32_t tid;
    uint32_t debugreg;
    uint32_t wasWatchpoint;
};

struct CeRemoveBreapointOutput {
    int result;
};

struct CeSuspendThreadInput {
    HANDLE hProcess;
    int tid;
};

struct CeSuspendThreadOutput {
    int result;
};

struct CeResumeThreadInput {
    HANDLE hProcess;
    int tid;
};

struct CeResumeThreadOutput {
    int result;
};

struct CeAllocInput {
    HANDLE hProcess;
    uint64_t preferedBase;
    uint32_t size;
    uint32_t windowsprotection;
};

struct CeAllocOutput {
    uint64_t address; // 0=fail
};

struct CeFreeInput {
    HANDLE hProcess;
    uint64_t address;
    uint32_t size;
};

struct CeFreeOutput {
    uint32_t result;
};

struct CeCreateThreadInput {
    HANDLE hProcess;
    uint64_t startaddress;
    uint64_t parameter;
};

struct CeCreateThreadOutput {
    HANDLE threadhandle;
};

struct CeLoadModuleInput {
    HANDLE hProcess;
    uint32_t modulepathlength;
    // modulepath
};

struct CeLoadModuleOutput {
    uint32_t result;
};

struct CeSpeedhackSetSpeedInput {
    HANDLE hProcess;
    float speed;
};

struct CeSpeedhackSetSpeedOutput {
    uint32_t result;
};

struct CeAobScanInput {
    HANDLE hProcess;
    uint64_t start;
    uint64_t end;
    int inc;
    int protection;
    int scansize;
};
#pragma pack()

#endif /* CESERVER_H_ */
```

`CEServer/context.h`:

```h
#ifndef CONTEXT_H_
#define CONTEXT_H_
#ifdef HAS_LINUX_USER_H
#include <linux/user.h>
#else
#include <sys/user.h>
#endif

#include <linux/ptrace.h>
#include <linux/socket.h>

#ifdef __aarch64__
#include <elf.h>
#endif

#include <sys/socket.h>

#ifdef __i386__
typedef struct user_regs_struct CONTEXT_REGS;
#endif

#ifdef __x86_64__
typedef struct user_regs_struct CONTEXT_REGS;
#endif

#ifdef __arm__
typedef struct pt_regs CONTEXT_REGS;
#endif

#ifdef __aarch64__
typedef struct user_pt_regs CONTEXT_REGS;
#endif

struct CONTEXT {
    CONTEXT_REGS regs;
};

#endif /* CONTEXT_H_ */
```

`CEServer/main.cpp`:

```cpp

#include "api.h"
#include "ceserver.h"
#include "context.h"
#include "native-api.h"
#include "porthelp.h"
#include <arpa/inet.h>
#include <dirent.h>
#include <elf.h>
#include <errno.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <thread>
#include <unistd.h>
#include <vector>
#include <zlib.h>

#define PORT 3168

char versionstring[] = "CHEATENGINE Network 2.3";
ssize_t recvall(int s, void *buf, size_t size, int flags) {
    ssize_t totalreceived = 0;
    ssize_t sizeleft = size;
    unsigned char *buffer = (unsigned char *)buf;

    // enter recvall
    flags = flags | MSG_WAITALL;

    while (sizeleft > 0) {
        ssize_t i = recv(s, &buffer[totalreceived], sizeleft, flags);
        if (i == 0) {
            printf("recv returned 0\n");
            return i;
        }
        if (i == -1) {
            printf("recv returned -1\n");
            if (errno == EINTR) {
                printf("errno = EINTR\n");
                i = 0;
            } else {
                printf("Error during recvall: %d. errno=%d\n", (int)i, errno);
                return i; // read error, or disconnected
            }
        }
        totalreceived += i;
        sizeleft -= i;
    }
    // leave recvall
    return totalreceived;
}

ssize_t sendall(int s, void *buf, size_t size, int flags) {
    ssize_t totalsent = 0;
    ssize_t sizeleft = size;
    unsigned char *buffer = (unsigned char *)buf;

	// debug print
	// printf("send: ");
	// for(int i=0; i<size; i++)
	// 	printf("%02X ", buffer[i]);
	// printf("\n");

    while (sizeleft > 0) {
        ssize_t i = send(s, &buffer[totalsent], sizeleft, flags);

        if (i == 0) {
            return i;
        }

        if (i == -1) {
            if (errno == EINTR) {
                i = 0;
            } else {
                printf("Error during sendall: %d. errno=%d\n", (int)i, errno);
                return i;
            }
        }
        totalsent += i;
        sizeleft -= i;
    }

    return totalsent;
}

int DispatchCommand(int currentsocket, unsigned char command) {
    int r;
    switch (command) {
    case CMD_GETVERSION: {
        CeVersion *v;
        int versionsize = strlen(versionstring);
        v = (CeVersion *)malloc(sizeof(CeVersion) + versionsize);
        v->stringsize = versionsize;
        v->version = 6;

        memcpy((char *)v + sizeof(CeVersion), versionstring, versionsize);

        // version request
        sendall(currentsocket, v, sizeof(CeVersion) + versionsize, 0);

        free(v);

        break;
    }

    case CMD_GETARCHITECTURE: {
#ifdef __i386__
        unsigned char arch = 0;
#endif
#ifdef __x86_64__
        unsigned char arch = 1;
#endif
#ifdef __arm__
        unsigned char arch = 2;
#endif
#ifdef __aarch64__
        unsigned char arch = 3;
#endif

        HANDLE h;
        // ce 7.4.1+ : Added the processhandle

        if (recvall(currentsocket, &h, sizeof(h), MSG_WAITALL) > 0) {
            // intel i386=0
            // intel x86_64=1
            // arm 32 = 2
            // arm 64 = 3
			// TODO
        }

        sendall(currentsocket, &arch, sizeof(arch), 0);
        break;
    }

    case CMD_CLOSECONNECTION: {
        printf("Connection %d closed properly\n", currentsocket);
        fflush(stdout);
        close(currentsocket);

        return 0;
    }

    case CMD_TERMINATESERVER: {
        printf("Command to terminate the server received\n");
        fflush(stdout);
        close(currentsocket);
        exit(0);
    }

    case CMD_STARTDEBUG: {
        printf("[NOT SUPPORT!] CMD_STARTDEBUG\n");
        break;
    }
    case CMD_WAITFORDEBUGEVENT: {
        printf("[NOT SUPPORT!] CMD_WAITFORDEBUGEVENT\n");
        break;
    }
    case CMD_CONTINUEFROMDEBUGEVENT: {
        printf("[NOT SUPPORT!] CMD_CONTINUEFROMDEBUGEVENT\n");
        break;
    }
    case CMD_SETBREAKPOINT: {
        printf("[NOT SUPPORT!] CMD_SETBREAKPOINT\n");
        break;
    }
    case CMD_REMOVEBREAKPOINT: {
        printf("[NOT SUPPORT!] CMD_REMOVEBREAKPOINT\n");
        break;
    }

    case CMD_GETTHREADCONTEXT: {
        printf("[NOT SUPPORT!] CMD_GETTHREADCONTEXT\n");
        break;
    }
    case CMD_SETTHREADCONTEXT: {
        printf("[NOT SUPPORT!] CMD_SETTHREADCONTEXT\n");
        break;
    }
    case CMD_SUSPENDTHREAD: {
        printf("[NOT SUPPORT!] CMD_SUSPENDTHREAD\n");
        break;
    }
    case CMD_RESUMETHREAD: {
        printf("[NOT SUPPORT!] CMD_RESUMETHREAD\n");
        break;
    }
    case CMD_CLOSEHANDLE: {
        HANDLE h;
        if (recvall(currentsocket, &h, sizeof(h), MSG_WAITALL) > 0) {
            printf("CMD_CLOSEHANDLE(%d)\n", h);
            CApi::CloseHandle(h);
            int r = 1;
            sendall(currentsocket, &r, sizeof(r), 0); // stupid naggle
        } else {
            printf("Error during read for CMD_CLOSEHANDLE\n");
            close(currentsocket);
            fflush(stdout);
            return 0;
        }
        break;
    }

    case CMD_CREATETOOLHELP32SNAPSHOT: {
        CeCreateToolhelp32Snapshot params;
        HANDLE result;

        printf("CMD_CREATETOOLHELP32SNAPSHOT\n");

        if (recvall(currentsocket, &params, sizeof(CeCreateToolhelp32Snapshot), MSG_WAITALL) > 0) {
            // printf("Calling CreateToolhelp32Snapshot\n");

            result = CApi::CreateToolhelp32Snapshot(params.dwFlags, params.th32ProcessID);

            printf("result of CreateToolhelp32Snapshot=%d\n", result);

            fflush(stdout);
            sendall(currentsocket, &result, sizeof(HANDLE), 0);

        } else {
            printf("Error during read for CMD_CREATETOOLHELP32SNAPSHOT\n");
            fflush(stdout);
            close(currentsocket);
            return 0;
        }

        break;
    }

    case CMD_PROCESS32FIRST: // obsolete
    case CMD_PROCESS32NEXT: {
        HANDLE toolhelpsnapshot;
        if (recvall(currentsocket, &toolhelpsnapshot, sizeof(toolhelpsnapshot), MSG_WAITALL) > 0) {
            // printf("CMD_PROCESS32FIRST || CMD_PROCESS32NEXT %d\n", toolhelpsnapshot);

            ProcessListEntry pe;
            BOOL result = FALSE;
            CeProcessEntry *r;
            int size;

            if (command == CMD_PROCESS32FIRST) {
                result = CApi::Process32First(toolhelpsnapshot, pe);
                // printf("Process32First result=%d\n", result);
            } else {
                result = CApi::Process32Next(toolhelpsnapshot, pe);
                // printf("Process32Next result=%d\n", result);
            }

            if (result) {
                size = sizeof(CeProcessEntry) + pe.ProcessName.length();
                r = (CeProcessEntry *)malloc(size);
                r->processnamesize = pe.ProcessName.length();
                r->pid = pe.PID;
                memcpy((char *)r + sizeof(CeProcessEntry), pe.ProcessName.c_str(), r->processnamesize);
            } else {
                size = sizeof(CeProcessEntry);
                r = (CeProcessEntry *)malloc(size);
                r->processnamesize = 0;
                r->pid = 0;
            }
            r->result = result;
            sendall(currentsocket, r, size, 0);
            free(r);
        }
        break;
    }

    case CMD_MODULE32FIRST: // slightly obsolete now
    case CMD_MODULE32NEXT: {
        HANDLE toolhelpsnapshot;
        if (recvall(currentsocket, &toolhelpsnapshot, sizeof(toolhelpsnapshot), MSG_WAITALL) > 0) {
            BOOL result;
            ModuleListEntry me;
            CeModuleEntry *r;
            int size;

            if (command == CMD_MODULE32FIRST) {
                result = CApi::Module32First(toolhelpsnapshot, me);
            } else {
                result = CApi::Module32Next(toolhelpsnapshot, me);
            }

            if (result) {
                size = sizeof(CeModuleEntry) + me.moduleName.length();
                r = (CeModuleEntry *)malloc(size);
                r->modulebase = me.baseAddress;
                r->modulesize = me.moduleSize;
                r->modulenamesize = me.moduleName.length();
                r->modulefileoffset = 0;
                r->modulepart = 0;
                // printf("%s\n", me.moduleName.c_str());

                // Sending %s size %x\n, me.moduleName, r->modulesize
                memcpy((char *)r + sizeof(CeModuleEntry), me.moduleName.c_str(), r->modulenamesize);
            } else {
                size = sizeof(CeModuleEntry);
                r = (CeModuleEntry *)malloc(size);
                r->modulebase = 0;
                r->modulesize = 0;
                r->modulenamesize = 0;
                r->modulefileoffset = 0;
                r->modulepart = 0;
            }

            r->result = result;

            sendall(currentsocket, r, size, 0);

            free(r);
        }
        break;
    }

    case CMD_OPENPROCESS: {
        int pid = 0;

        r = recvall(currentsocket, &pid, sizeof(int), MSG_WAITALL);
        if (r > 0) {
            int processhandle;

            printf("OpenProcess(%d)\n", pid);
            processhandle = CApi::OpenProcess(pid);

            printf("processhandle=%d\n", processhandle);
            sendall(currentsocket, &processhandle, sizeof(int), 0);
        } else {
            printf("Error\n");
            fflush(stdout);
            close(currentsocket);
            return 0;
        }
        break;
    }

    case CMD_READPROCESSMEMORY: {
        CeReadProcessMemoryInput c;

        r = recvall(currentsocket, &c, sizeof(c), MSG_WAITALL);
        if (r > 0) {
            CeReadProcessMemoryOutput *o = NULL;
            o = (CeReadProcessMemoryOutput *)malloc(sizeof(CeReadProcessMemoryOutput) + c.size);
            memset(o, 0, sizeof(CeReadProcessMemoryOutput) + c.size);

            o->read = CApi::ReadProcessMemory(c.handle, (void *)(uintptr_t)c.address, &o[1], c.size);

            if (c.compress) {
                // printf("ReadProcessMemory compress %d %p %d\n", c.handle, c.address, c.size);

                // compress the output
#define COMPRESS_BLOCKSIZE (64 * 1024)
                int i;
                unsigned char *uncompressed = (unsigned char *)&o[1];
                uint32_t uncompressedSize = o->read;
                uint32_t compressedSize = 0;
                int maxBlocks = 1 + (c.size / COMPRESS_BLOCKSIZE);

                unsigned char **compressedBlocks =
                    (unsigned char **)malloc(maxBlocks * sizeof(unsigned char *)); // send in blocks of 64kb and reallocate the pointerblock if there's not enough space
                int currentBlock = 0;

                z_stream strm;
                strm.zalloc = Z_NULL;
                strm.zfree = Z_NULL;
                strm.opaque = Z_NULL;
                deflateInit(&strm, c.compress);

                compressedBlocks[currentBlock] = (unsigned char *)malloc(COMPRESS_BLOCKSIZE);
                strm.avail_out = COMPRESS_BLOCKSIZE;
                strm.next_out = compressedBlocks[currentBlock];

                strm.next_in = uncompressed;
                strm.avail_in = uncompressedSize;

                while (strm.avail_in) {
                    r = deflate(&strm, Z_NO_FLUSH);
                    if (r != Z_OK) {
                        if (r == Z_STREAM_END)
                            break;
                        else {
                            printf("Error while compressing\n");
                            break;
                        }
                    }

                    if (strm.avail_out == 0) {
                        // new output block
                        currentBlock++;
                        if (currentBlock >= maxBlocks) {
                            // list was too short, reallocate
                            printf("Need to realloc the pointerlist (p1)\n");

                            maxBlocks *= 2;
                            compressedBlocks = (unsigned char **)realloc(compressedBlocks, maxBlocks * sizeof(unsigned char *));
                        }
                        compressedBlocks[currentBlock] = (unsigned char *)malloc(COMPRESS_BLOCKSIZE);
                        strm.avail_out = COMPRESS_BLOCKSIZE;
                        strm.next_out = compressedBlocks[currentBlock];
                    }
                }
                // finishing compressiong
                while (1) {

                    r = deflate(&strm, Z_FINISH);

                    if (r == Z_STREAM_END)
                        break; // done

                    if (r != Z_OK) {
                        printf("Failure while finishing compression:%d\n", r);
                        break;
                    }

                    if (strm.avail_out == 0) {
                        // new output block
                        currentBlock++;
                        if (currentBlock >= maxBlocks) {
                            // list was too short, reallocate
                            printf("Need to realloc the pointerlist (p2)\n");
                            maxBlocks *= 2;
                            compressedBlocks = (unsigned char **)realloc(compressedBlocks, maxBlocks * sizeof(unsigned char *));
                        }
                        compressedBlocks[currentBlock] = (unsigned char *)malloc(COMPRESS_BLOCKSIZE);
                        strm.avail_out = COMPRESS_BLOCKSIZE;
                        strm.next_out = compressedBlocks[currentBlock];
                    }
                }
                deflateEnd(&strm);

                compressedSize = strm.total_out;
                // Sending compressed data
                sendall(currentsocket, &uncompressedSize, sizeof(uncompressedSize), MSG_MORE); // followed by the compressed size
                sendall(currentsocket, &compressedSize, sizeof(compressedSize), MSG_MORE);     // the compressed data follows
                for (i = 0; i <= currentBlock; i++) {
                    if (i != currentBlock)
                        sendall(currentsocket, compressedBlocks[i], COMPRESS_BLOCKSIZE, MSG_MORE);
                    else
                        sendall(currentsocket, compressedBlocks[i], COMPRESS_BLOCKSIZE - strm.avail_out, 0); // last one, flush

                    free(compressedBlocks[i]);
                }
                free(compressedBlocks);
            } else {
                // printf("ReadProcessMemory Uncompress %d %p %d\n", c.handle, c.address, c.size);
                sendall(currentsocket, o, sizeof(CeReadProcessMemoryOutput) + o->read, 0);
            }

            if (o) {
                free(o);
            }
        }
        break;
    }

    case CMD_WRITEPROCESSMEMORY: {
        CeWriteProcessMemoryInput c;

        printf("CMD_WRITEPROCESSMEMORY:\n");

        r = recvall(currentsocket, &c, sizeof(c), MSG_WAITALL);
        if (r > 0) {
            CeWriteProcessMemoryOutput o;
            unsigned char *buf;

            printf("recv returned %d bytes\n", r);
            printf("c.size=%d\n", c.size);

            if (c.size) {
                buf = (unsigned char *)malloc(c.size);

                r = recvall(currentsocket, buf, c.size, MSG_WAITALL);
                if (r > 0) {
                    printf("received %d bytes for the buffer. Wanted %d\n", r, c.size);
                    o.written = CApi::WriteProcessMemory(c.handle, (void *)(uintptr_t)c.address, buf, c.size);

                    r = sendall(currentsocket, &o, sizeof(CeWriteProcessMemoryOutput), 0);
                    printf("wpm: returned %d bytes to caller\n", r);

                } else {
                    printf("wpm recv error while reading the data\n");
                }
                free(buf);
            } else {
                printf("wpm with a size of 0 bytes");
                o.written = 0;
                r = sendall(currentsocket, &o, sizeof(CeWriteProcessMemoryOutput), 0);
                printf("wpm: returned %d bytes to caller\n", r);
            }
        } else {
            printf("RPM: recv failed\n");
        }
        break;
    }
    case CMD_VIRTUALQUERYEXFULL: {
        // printf("CMD_VIRTUALQUERYEXFULL\n");

        CeVirtualQueryExFullInput c;
        CeVirtualQueryExFullOutput o;

        r = recvall(currentsocket, &c, sizeof(c), MSG_WAITALL);
        if (r > 0) {
            std::vector<RegionInfo> vRinfo;
            if (CApi::VirtualQueryExFull(c.handle, c.flags, vRinfo)) {
                // printf("VirtualQueryExFull ok %d\n", vRinfo.size());
                uint32_t count = vRinfo.size();
                sendall(currentsocket, &count, sizeof(count), 0);

                for (RegionInfo r : vRinfo) {
                    sendall(currentsocket, &r, sizeof(r), 0);
                }
                // printf("VirtualQueryExFull all %d\n", vRinfo.size());
            } else {
                // printf("VirtualQueryExFull no %d\n", vRinfo.size());
                uint32_t count = 0;
                sendall(currentsocket, &count, sizeof(count), 0);
            }
        }
        break;
    }
    case CMD_GETREGIONINFO:
    case CMD_VIRTUALQUERYEX: {

        CeVirtualQueryExInput c;
        r = recvall(currentsocket, &c, sizeof(c), MSG_WAITALL);
        if (r > 0) {
            RegionInfo rinfo;
            CeVirtualQueryExOutput o;
            if (sizeof(uintptr_t) == 4) {
                if (c.baseaddress > 0xFFFFFFFF) {
                    o.result = 0;
                    sendall(currentsocket, &o, sizeof(o), 0);
                    break;
                }
            }

            std::string mapsline;

            if (command == CMD_VIRTUALQUERYEX) {
                // printf("CMD_VIRTUALQUERYEX\n");
                o.result = CApi::VirtualQueryEx(c.handle, c.baseaddress, rinfo, mapsline);
            } else if (command == CMD_GETREGIONINFO) {
                // printf("CMD_GETREGIONINFO\n");
                o.result = CApi::VirtualQueryEx(c.handle, c.baseaddress, rinfo, mapsline);
            }

            o.protection = rinfo.protection;
            o.baseaddress = rinfo.baseaddress;
            o.type = rinfo.type;
            o.size = rinfo.size;

            if (command == CMD_VIRTUALQUERYEX) {
                sendall(currentsocket, &o, sizeof(o), 0);
            } else if (command == CMD_GETREGIONINFO) {
                sendall(currentsocket, &o, sizeof(o), MSG_MORE);
                {
                    uint8_t size = mapsline.length();
                    sendall(currentsocket, &size, sizeof(size), MSG_MORE);

                    if (size) {
                        sendall(currentsocket, (void *)mapsline.c_str(), size, 0);
                    }
                }
            }
        }
        break;
    }

    case CMD_GETSYMBOLLISTFROMFILE: {
        // get the list and send it to the client
        // zip it first
        uint32_t symbolpathsize;


        if (recvall(currentsocket, &symbolpathsize, sizeof(symbolpathsize), MSG_WAITALL) > 0) {
            char *symbolpath = (char *)malloc(symbolpathsize + 1);
            symbolpath[symbolpathsize] = '\0';

            if (recvall(currentsocket, symbolpath, symbolpathsize, MSG_WAITALL) > 0) {
                unsigned char *output = NULL;

                // printf("symbolpath=%s\n", symbolpath);

                if (memcmp("/dev/", symbolpath, 5) != 0) // don't even bother if it's a /dev/ file
                {
                    // 因为这里需要open本地的.so文件，有可能会被反调试手段侦测到，而且作用不太大，所以暂时屏蔽掉。
                    // 解决方法一（待实现）：在被调试进程启动前，读取本地.so文件
                    // GetSymbolListFromFile(symbolpath, &output);
                }
                if (output) {
                    // printf("output is not NULL (%p)\n", output);

                    fflush(stdout);

                    // printf("Sending %d bytes\n", *(uint32_t *)&output[4]);
                    sendall(currentsocket, output, *(uint32_t *)&output[4], 0); // the output buffer contains the size itself
                    free(output);
                } else {

                    // printf("Sending 8 bytes (fail)\n");
                    uint64_t fail = 0;
                    sendall(currentsocket, &fail, sizeof(fail), 0); // just write 0
                }
            } else {
                printf("Failure getting symbol path\n");
                close(currentsocket);
            }

            free(symbolpath);
        }
        break;
    }

    case CMD_LOADEXTENSION: {
        printf("[NOT SUPPORT!] CMD_LOADEXTENSION\n");
        break;
    }

    case CMD_ALLOC: {
        printf("[NOT SUPPORT!] CMD_ALLOC\n");
        break;
    }
    case CMD_FREE: {
        printf("[NOT SUPPORT!] CMD_FREE\n");
        break;
    }
    case CMD_CREATETHREAD: {
        printf("[NOT SUPPORT!] CMD_CREATETHREAD\n");
        break;
    }
    case CMD_LOADMODULE: {
        printf("[NOT SUPPORT!] CMD_LOADMODULE\n");
        break;
    }
    case CMD_SPEEDHACK_SETSPEED: {
        printf("[NOT SUPPORT!] CMD_SPEEDHACK_SETSPEED\n");
        break;
    }
    case CMD_AOBSCAN: {
        CeAobScanInput c;
        printf("CESERVER: CMD_AOBSCAN\n");
        if (recvall(currentsocket, &c, sizeof(c), 0) > 0) {

            int n = c.scansize;
            char *data = (char *)malloc(n * 2);
            uint64_t *match_addr = (uint64_t *)malloc(sizeof(uint64_t) * MAX_HIT_COUNT);

            if (recvall(currentsocket, data, n * 2, 0) > 0) {
                char *pattern = (char *)malloc(n);
                char *mask = (char *)malloc(n);

                memcpy(pattern, data, n);
                memcpy(mask, &data[n], n);
                int ret = 0; // AOBScan(c.hProcess, pattern, mask, c.start, c.end, c.inc, c.protection, match_addr);
                printf("HIT_COUNT:%d\n", ret);
                free(pattern);
                free(mask);
                sendall(currentsocket, &ret, 4, 0);
                sendall(currentsocket, match_addr, sizeof(uint64_t) * ret, 0);
            }
            free(data);
            free(match_addr);
        }

        break;
    }
    case CMD_CREATETOOLHELP32SNAPSHOTEX: {
        CeCreateToolhelp32Snapshot params;
        // debug_log("CMD_CREATETOOLHELP32SNAPSHOTEX\n");

        if (recvall(currentsocket, &params, sizeof(CeCreateToolhelp32Snapshot), MSG_WAITALL) > 0) {
            HANDLE r = CApi::CreateToolhelp32Snapshot(params.dwFlags, params.th32ProcessID);

            if ((params.dwFlags & TH32CS_SNAPTHREAD) == TH32CS_SNAPTHREAD) {
                // send the list of threadid's

                if (r) {
                    ThreadList *tl = (ThreadList *)CPortHelper::GetPointerFromHandle(r);
                    sendall(currentsocket, &tl->threadCount, sizeof(int), MSG_MORE);
                    sendall(currentsocket, &tl->threadList[0], tl->threadCount * sizeof(int), 0);

                    CApi::CloseHandle(r);
                } else {
                    int n = 0;
                    sendall(currentsocket, &n, sizeof(int), 0);
                }
            } else if ((params.dwFlags & TH32CS_SNAPMODULE) == TH32CS_SNAPMODULE) {
                ModuleListEntry me;

                char *outputstream;
                int pos = 0;

                // debug_log("CMD_CREATETOOLHELP32SNAPSHOTEX with TH32CS_SNAPMODULE\n");

                outputstream = (char *)calloc(65536, 1);

                if (r && (CApi::Module32First(r, me)))
                    do {
                        int namelen = me.moduleName.length();
                        CeModuleEntry *m;

                        if ((pos + sizeof(CeModuleEntry) + namelen) > 65536) {
                            // flush the stream
                            // debug_log("CMD_CREATETOOLHELP32SNAPSHOTEX: ModuleList flush in loop\n");
                            sendall(currentsocket, outputstream, pos, 0);
                            pos = 0;
                        }

                        m = (CeModuleEntry *)&outputstream[pos];
                        m->modulebase = me.baseAddress;
                        m->modulesize = me.moduleSize;
                        m->modulenamesize = namelen;
                        m->modulefileoffset = 0;
                        m->modulepart = 0;
                        m->result = 1;

                        // Sending %s size %x\n, me.moduleName, r->modulesize
                        memcpy((char *)m + sizeof(CeModuleEntry), me.moduleName.data(), namelen);

                        pos += sizeof(CeModuleEntry) + namelen;

                    } while (CApi::Module32Next(r, me));

                if (pos) // flush the stream
                {
                    // debug_log("CMD_CREATETOOLHELP32SNAPSHOTEX: ModuleList flush after loop\n");
                    sendall(currentsocket, outputstream, pos, 0);
                }

                // send the end of list module
                // debug_log("CMD_CREATETOOLHELP32SNAPSHOTEX: ModuleList end of list\n");

                CeModuleEntry eol;
                eol.result = 0;
                eol.modulenamesize = 0;
                sendall(currentsocket, &eol, sizeof(eol), 0);

                free(outputstream);

                if (r)
                    CApi::CloseHandle(r);

            } else {
                sendall(currentsocket, &r, sizeof(HANDLE), 0); // the others are not yet implemented
            }
        } else {
            printf("Error during read for CMD_CREATETOOLHELP32SNAPSHOTEX\n");
            fflush(stdout);
            close(currentsocket);
            return 0;
        }
        break;
    }
    case CMD_GETOPTIONS: {
        uint16_t count = 0;
        sendall(currentsocket, &count, sizeof(count), 0);
		break;
    }
    case CMD_GETABI: {
#ifdef WINDOWS
        unsigned char abi = 0;
#else
        unsigned char abi = 1;
#endif
        sendall(currentsocket, &abi, sizeof(abi), 0);
        break;
    }
    case CMD_ISANDROID: {
        unsigned char r;
#ifdef __ANDROID__
        r = 1;
#else
        r = 0;
#endif
        sendall(currentsocket, &r, sizeof(r), 0);

        break;
    }
    default:
        printf("Unknow command:%d\n", command);
        fflush(stdout);
        break;
    }
    return 0;
}

void newConnectionThread(int s) {
    unsigned char command;

    int currentsocket = s;

    // printf("new connection. Using socket %d\n", s);
    while (1) {
        int r = recvall(currentsocket, &command, 1, MSG_WAITALL);

        if (r > 0) {
            DispatchCommand(currentsocket, command);
        } else if (r == -1) {
            printf("read error on socket %d (%d)\n", s, errno);
            fflush(stdout);
            close(currentsocket);
            return;
        } else {
            if (r == 0) {
                printf("Peer has disconnected\n");
                fflush(stdout);
                close(currentsocket);
                return;
            }
        }
    }
    close(s);
    return;
}

void IdentifierThread() {
    int i;
    int s;
    int v = 1;
#pragma pack(1)
    struct {
        uint32_t checksum;
        uint16_t port;
    } packet;
#pragma pack()

    socklen_t clisize;
    struct sockaddr_in addr, addr_client;

    printf("IdentifierThread active\n");

    fflush(stdout);

    s = socket(PF_INET, SOCK_DGRAM, 0);
    i = setsockopt(s, SOL_SOCKET, SO_BROADCAST, &v, sizeof(v));

    memset(&addr, 0, sizeof(addr));

    addr.sin_family = PF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(3296);
    i = bind(s, (struct sockaddr *)&addr, sizeof(addr));

    if (i >= 0) {
        while (1) {
            memset(&addr_client, 0, sizeof(addr_client));
            addr_client.sin_family = PF_INET;
            addr_client.sin_addr.s_addr = INADDR_ANY;
            addr_client.sin_port = htons(3296);

            clisize = sizeof(addr_client);

            i = recvfrom(s, &packet, sizeof(packet), 0, (struct sockaddr *)&addr_client, &clisize);

            // i=recv(s, &v, sizeof(v), 0);
            if (i >= 0) {

                printf("Identifier thread received a message :%d\n", v);
                printf("sizeof(packet)=%d\n", (int)sizeof(packet));

                printf("packet.checksum=%x\n", packet.checksum);
                packet.checksum *= 0xce;
                packet.port = PORT;
                printf("packet.checksum=%x\n", packet.checksum);

                // packet.checksum=00AE98E7 - y=8C7F09E2

                fflush(stdout);

                i = sendto(s, &packet, sizeof(packet), 0, (struct sockaddr *)&addr_client, clisize);
                printf("sendto returned %d\n", i);
            } else {
                printf("recvfrom failed\n");
            }

            fflush(stdout);
        }
    } else {
        printf("IdentifierThread bind port failed\n");
    }
    printf("IdentifierThread exit\n");
    return;
}

int main(int argc, char *argv[]) {
    // 初始化读写驱动
    if (!CApi::InitReadWriteDriver(argc > 1 ? argv[1] : NULL, FALSE)) {
        printf("Init read write driver failed.\n");
        return 0;
    }

    socklen_t clisize;
    struct sockaddr_in addr, addr_client;

    printf("listening on port %d\n", PORT);

    printf("CEServer. Waiting for client connection\n");

    // if (broadcast)

    std::thread tdId(IdentifierThread);
    tdId.detach();

    int s = socket(AF_INET, SOCK_STREAM, 0);
    printf("socket=%d\n", s);

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;

    int optval = 1;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)); // 让端口释放后立即就可以被再次使用

    int b = bind(s, (struct sockaddr *)&addr, sizeof(addr));
    printf("bind=%d\n", b);

    if (b != -1) {
        int l = listen(s, 32);

        printf("listen=%d\n", l);

        clisize = sizeof(addr_client);
        memset(&addr_client, 0, sizeof(addr_client));

        fflush(stdout);

        while (1) {

            int a = accept(s, (struct sockaddr *)&addr_client, &clisize);

            printf("accept=%d\n", a);

            fflush(stdout);
            int opt = 1;
            setsockopt(a, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));

            if (a != -1) {
                std::thread tdConnect(newConnectionThread, a);
                tdConnect.detach();
            }
        }
    }

    printf("Terminate server\n");

    close(s);

    return 0;
}
```

`CEServer/native-api.cpp`:

```cpp
#include "native-api.h"

```

`CEServer/native-api.h`:

```h
#pragma once
#define MAX_HIT_COUNT 5000000
```

`CEServer/porthelp.cpp`:

```cpp
#include "porthelp.h"
#include "api.h"
#include <map>
#include <random>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>


struct HANDLE_INFO {
    uint64_t p; // TODO：这里有空再搞成shared_ptr派生成各个基类，防止内存泄漏
    handleType type;
};
std::map<HANDLE, HANDLE_INFO> m_HandlePointList;

HANDLE CPortHelper::CreateHandleFromPointer(uint64_t p, handleType type) {
    std::random_device rd;
    HANDLE handle = 10000 + rd() / 1000;
    handle = handle < 0 ? -handle : handle;
    while (m_HandlePointList.find(handle) != m_HandlePointList.end()) {
        handle = 10000 + rd() / 1000;
        handle = handle < 0 ? -handle : handle;
    }

    HANDLE_INFO hinfo = {0};
    hinfo.p = p;
    hinfo.type = type;
    m_HandlePointList.insert(std::pair<HANDLE, HANDLE_INFO>(handle, hinfo));

    return handle;
}

handleType CPortHelper::GetHandleType(HANDLE handle) {
    auto iter = m_HandlePointList.find(handle);
    if (iter == m_HandlePointList.end()) {
        return htEmpty;
    }
    return iter->second.type;
}

uint64_t CPortHelper::GetPointerFromHandle(HANDLE handle) {
    auto iter = m_HandlePointList.find(handle);
    if (iter == m_HandlePointList.end()) {
        return 0;
    }
    return iter->second.p;
}

void CPortHelper::RemoveHandle(HANDLE handle) {
    auto iter = m_HandlePointList.find(handle);
    if (iter == m_HandlePointList.end()) {
        return;
    }
    m_HandlePointList.erase(iter);
}

HANDLE CPortHelper::FindHandleByPID(DWORD pid) {
    for (auto item = m_HandlePointList.begin(); item != m_HandlePointList.end(); item++) {
        if (item->second.type == htProcesHandle) {
            CeOpenProcess *pCeOpenProcess = (CeOpenProcess *)item->second.p;
            if (pCeOpenProcess->pid == pid) {
                return item->first;
            }
        }
    }
    return 0;
}

```

`CEServer/porthelp.h`:

```h
#pragma once
#include <stdint.h>

typedef int32_t HANDLE; // just an int, in case of a 32-bit ce version and a 64-bit linux version I can not give pointers, so use ID's for handles
typedef int32_t DWORD;

#define TH32CS_SNAPPROCESS 0x2
#define TH32CS_SNAPTHREAD 0x4
#define TH32CS_SNAPMODULE 0x8

#define PAGE_NOACCESS 1
#define PAGE_READONLY 2
#define PAGE_READWRITE 4
#define PAGE_WRITECOPY 8
#define PAGE_EXECUTE 16
#define PAGE_EXECUTE_READ 32
#define PAGE_EXECUTE_READWRITE 64

#define MEM_MAPPED 262144
#define MEM_PRIVATE 131072

#define TRUE 1
#define FALSE 0

typedef enum {
    htEmpty = 0,
    htProcesHandle,
    htThreadHandle,
    htTHSProcess,
    htTHSModule,
    htTHSThread,
    htNativeThreadHandle
} handleType; // The difference between ThreadHandle and NativeThreadHandle is that threadhandle is based on the processid of the thread, the NativeThreadHandle is in linux usually
              // the pthread_t handle

typedef int BOOL;

class CPortHelper {
  public:
    static HANDLE CreateHandleFromPointer(uint64_t p, handleType type);
    static handleType GetHandleType(HANDLE handle);
    static uint64_t GetPointerFromHandle(HANDLE handle);
    static void RemoveHandle(HANDLE handle);
    static HANDLE FindHandleByPID(DWORD pid);
};

```

`CEServer/symbols.cpp`:

```cpp
#include "symbols.h"
#include <stdio.h>
#include <elf.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <string.h>
#include <zlib.h>

#pragma pack(1)
typedef struct {
	uint64_t address;
	int size;
	int type;
	unsigned char namelength;
	char name[0];
} symbolinfo, *psymbolinfo;
#pragma pack()

#define TEMPBUFSIZE 64*1024
//
//
//void loadStringTable64(int f, Elf64_Shdr *sectionHeaders, unsigned char **stringTable, int index)
//{
//  if ((stringTable[index]==NULL) && (sectionHeaders[index].sh_type==SHT_STRTAB))
//  {
//    stringTable[index]=malloc(sectionHeaders[index].sh_size);
//    if (pread(f, stringTable[index], sectionHeaders[index].sh_size, sectionHeaders[index].sh_offset)==-1)
//    {
//      debug_log("Failure loading the stringtable\n");
//      free(stringTable[index]);
//      stringTable[index]=NULL;
//    }
//
//  }
//  else
//    debug_log("Not a string table\n");
//}
//
//void loadStringTable32(int f, Elf32_Shdr *sectionHeaders, unsigned char **stringTable, int index)
//{
//  if ((stringTable[index]==NULL) && (sectionHeaders[index].sh_type==SHT_STRTAB))
//  {
//    stringTable[index]=malloc(sectionHeaders[index].sh_size);
//    if (pread(f, stringTable[index], sectionHeaders[index].sh_size, sectionHeaders[index].sh_offset)==-1)
//    {
//      debug_log("Failure loading the stringtable\n");
//      free(stringTable[index]);
//      stringTable[index]=NULL;
//    }
//
//  }
//  else
//    debug_log("Not a string table\n");
//}
//
//int ELF32(int f, Elf32_Ehdr *b, unsigned char **output)
///*
//Caller must free output manually
//*/
//{
//  int i,j;
//
//  unsigned char *tempbuffer=NULL;
//  int tempbufferpos=0;
//  int maxoutputsize=TEMPBUFSIZE;
//  tempbuffer=malloc(TEMPBUFSIZE);
//
//  //setup zlib
//  z_stream strm;
//  strm.zalloc = Z_NULL;
//  strm.zfree = Z_NULL;
//  strm.opaque = Z_NULL;
//  deflateInit(&strm, 9);
//
//  *output=malloc(maxoutputsize); //allocate 256KB. This "should" be enough, but reallocate if more is needed
//
//  strm.avail_out=maxoutputsize-3*sizeof(uint32_t); //first if it's an exe, followed by the compressed size, followed by the decompressed size
//  strm.next_out=(unsigned char *)&(*output)[sizeof(uint32_t)*3];
//
//  *(uint32_t *)(&(*output)[0])=(b->e_type==ET_EXEC);
//
///*
//
//  debug_log("e_shoff=%x\n", b->e_shoff);
//  debug_log("e_shentsize=%d\n", b->e_shentsize);
//  debug_log("e_shnum=%d\n", b->e_shnum);
//  debug_log("e_shstrndx=%d\n", b->e_shstrndx);*/
//
//  Elf32_Shdr *sectionHeaders=malloc(b->e_shentsize*b->e_shnum);
//
//  if (pread(f, sectionHeaders, b->e_shentsize*b->e_shnum, b->e_shoff)==-1)
//  {
//    //printf("Failure to read sectionHeaders\n");
//    deflateEnd(&strm);
//    if (sectionHeaders)
//      free(sectionHeaders);
//
//    if (output)
//      free(output);
//
//    if (tempbuffer)
//      free(tempbuffer);
//
//    return -1;
//  }
//
//  unsigned char **stringTable=calloc(b->e_shnum, sizeof(unsigned char*) );
//
//  loadStringTable32(f, sectionHeaders, stringTable, b->e_shstrndx);
//
//
//  for (i=0; i<b->e_shnum; i++)
//  {
//    //printf("Section %d (%x): name=%s\n", i, sectionHeaders[i].sh_addr, &stringTable[b->e_shstrndx][sectionHeaders[i].sh_name]);
//
//    if ((sectionHeaders[i].sh_type==SHT_SYMTAB) || (sectionHeaders[i].sh_type==SHT_DYNSYM))
//    {
//     // debug_log("Symbol data:\n", i);
//
//     // debug_log("sh_addr=%x\n", sectionHeaders[i].sh_addr);
//      //printf("sh_offset=%x\n", sectionHeaders[i].sh_offset);
//      //printf("sh_size=%x\n", sectionHeaders[i].sh_size);
//      //printf("sh_link=%d (string table)\n", sectionHeaders[i].sh_link);
//      //printf("sh_info=%d\n", sectionHeaders[i].sh_info);
//
//      Elf32_Sym *symbolTable=malloc(sectionHeaders[i].sh_size);
//      if (pread(f, symbolTable, sectionHeaders[i].sh_size, sectionHeaders[i].sh_offset)==-1)
//      {
//       // debug_log("Failure reading symbol table\n");
//        return -1;
//      }
//      int maxindex=sectionHeaders[i].sh_size / sizeof(Elf32_Sym);
//
//      loadStringTable32(f, sectionHeaders, stringTable, sectionHeaders[i].sh_link);
//
//      //printf("maxindex=%d\n", maxindex);
//      for (j=0; j<maxindex; j++)
//      {
//        //printf("symbolTable[%d]:\n", i);
//        //printf("st_name=%s\n", &stringTable[sectionHeaders[i].sh_link][symbolTable[j].st_name] );
//       // debug_log("st_value=%x\n", symbolTable[j].st_value);
//        //printf("st_size=%d\n", symbolTable[j].st_size);
//       // debug_log("st_info=%d\n", symbolTable[j].st_info);
//        //printf("  Bind=%d\n", ELF32_ST_BIND(symbolTable[j].st_info));
//        //printf("  Type=%d\n", ELF32_ST_TYPE(symbolTable[j].st_info));
//       // debug_log("st_other=%d\n", symbolTable[j].st_other);
//       // debug_log("st_shndx=%d\n", symbolTable[j].st_shndx);
//
//        if (symbolTable[j].st_value)
//        {
//          //add it to the tempbuffer
//          char *symbolname=(char *)&stringTable[sectionHeaders[i].sh_link][symbolTable[j].st_name];
//          size_t namelength=strlen(symbolname);
//          int entrysize=sizeof(symbolinfo)+namelength;
//          if (tempbufferpos+entrysize>=TEMPBUFSIZE)
//          {
//             //compress the current temp buffer
//             //printf("compressing\n");
//             strm.avail_in=tempbufferpos;
//             strm.next_in=tempbuffer;
//
//             while (strm.avail_in)
//             {
//               if (deflate(&strm, Z_NO_FLUSH)!=Z_OK)
//               {
//                 //printf("FAILURE TO COMPRESS!\n");
//                 return -1;
//               }
//               //printf("strm.avail_out=%d\n", strm.avail_out);
//
//               if (strm.avail_out==0)
//               {
//
//
//                 //printf("Out buffer full. Reallocating\n");
//                 *output=realloc(*output, maxoutputsize*2);
//
//                 strm.next_out=(unsigned char *)&(*output)[maxoutputsize];
//                 strm.avail_out=maxoutputsize;
//                 maxoutputsize=maxoutputsize*2;
//
//
//               }
//
//             }
//             tempbufferpos=0;
//          }
//
//
//
//          psymbolinfo si=(psymbolinfo)&tempbuffer[tempbufferpos];
//          si->address=symbolTable[j].st_value;
//          si->size=symbolTable[j].st_size;
//          si->type=symbolTable[j].st_info;
//          si->namelength=namelength;
//          memcpy(&si->name, symbolname, namelength);
//
//
//          tempbufferpos+=entrysize;
//        }
//      }
//
//      free(symbolTable);
//
//    }
//
//  }
//
//  for (i=0; i<b->e_shnum; i++)
//  {
//    if (stringTable[i])
//      free(stringTable[i]);
//  }
//  free(stringTable);
//
//  free(sectionHeaders);
//
//
//  debug_log("end:\n");
//  strm.avail_in=tempbufferpos;
//  strm.next_in=tempbuffer;
//
//  while (1)
//  {
//
//    i=deflate(&strm, Z_FINISH);
//    debug_log("i=%d\n", i);
//    if (i==Z_STREAM_END) //done
//      break;
//
//    if (i!=Z_OK)
//    {
//      debug_log("Failure to compress: %i\n", i);
//      return -1;
//    }
//
//    if (strm.avail_out==0)
//    {
//      debug_log("Out buffer full. Reallocating :%d\n", maxoutputsize*2);
//      *output=realloc(*output, maxoutputsize*2);
//
//      strm.next_out=(unsigned char *)&(*output)[maxoutputsize];
//      strm.avail_out=maxoutputsize;
//      maxoutputsize=maxoutputsize*2;
//
//    }
//    else
//      break;
//
//  };
//
//  /*printf("strm.avail_out=%d\n", strm.avail_out);
//
//  debug_log("total_in = %lu\n", strm.total_in);
//  debug_log("total_out = %lu\n", strm.total_out);*/
//
//  deflateEnd(&strm);
//
//
//  //update the size
//  *(uint32_t *)(&(*output)[4])=strm.total_out+3*sizeof(uint32_t);
//  *(uint32_t *)(&(*output)[8])=strm.total_in;
//
//  free(tempbuffer);
//
//  return 0;
//}
//
//int ELF64(int f, Elf64_Ehdr *b, unsigned char **output)
///*
//Caller must free output manually
//*/
//{
//  int i,j;
//
//
//  unsigned char *tempbuffer=NULL;
//  int tempbufferpos=0;
//  int maxoutputsize=TEMPBUFSIZE;
//  tempbuffer=malloc(TEMPBUFSIZE);
//
//  //setup zlib
//  z_stream strm;
//  strm.zalloc = Z_NULL;
//  strm.zfree = Z_NULL;
//  strm.opaque = Z_NULL;
//  deflateInit(&strm, 9);
//
//  *output=malloc(maxoutputsize); //allocate 256KB. This "should" be enough, but reallocate if more is needed
//
//  strm.avail_out=maxoutputsize-3*sizeof(uint32_t); //the first 8 bytes will contain the compressed and uncompressed size
//  strm.next_out=(unsigned char *)&(*output)[sizeof(uint32_t)*3];
//
//  *(uint32_t *)(&(*output)[0])=(b->e_type==ET_EXEC);
///*
//
//  debug_log("e_shoff=%lx\n", b->e_shoff);
//  debug_log("e_shentsize=%d\n", b->e_shentsize);
//  debug_log("e_shnum=%d\n", b->e_shnum);
//  debug_log("e_shstrndx=%d\n", b->e_shstrndx);*/
//
//  Elf64_Shdr *sectionHeaders=malloc(b->e_shentsize*b->e_shnum);
//
//  if (pread(f, sectionHeaders, b->e_shentsize*b->e_shnum, b->e_shoff)==-1)
//  {
//    //printf("Failure to read sectionHeaders\n");
//    deflateEnd(&strm);
//    if (sectionHeaders)
//      free(sectionHeaders);
//
//    if (output)
//      free(output);
//
//    if (tempbuffer)
//      free(tempbuffer);
//
//    return -1;
//  }
//
//  unsigned char **stringTable=calloc(b->e_shnum, sizeof(unsigned char*) );
//
//  loadStringTable64(f, sectionHeaders, stringTable, b->e_shstrndx);
//
//
//  for (i=0; i<b->e_shnum; i++)
//  {
//   // debug_log("Section %d (%lx): name=%s\n", i, sectionHeaders[i].sh_addr, &stringTable[b->e_shstrndx][sectionHeaders[i].sh_name]);
//
//    if ((sectionHeaders[i].sh_type==SHT_SYMTAB) || (sectionHeaders[i].sh_type==SHT_DYNSYM))
//    {/*
//      debug_log("Symbol data:\n", i);
//
//      debug_log("sh_addr=%lx\n", sectionHeaders[i].sh_addr);
//      debug_log("sh_offset=%lx\n", sectionHeaders[i].sh_offset);
//      debug_log("sh_size=%ld\n", sectionHeaders[i].sh_size);
//      debug_log("sh_link=%d (string table)\n", sectionHeaders[i].sh_link);
//      debug_log("sh_info=%d\n", sectionHeaders[i].sh_info);*/
//
//      Elf64_Sym *symbolTable=malloc(sectionHeaders[i].sh_size);
//      if (pread(f, symbolTable, sectionHeaders[i].sh_size, sectionHeaders[i].sh_offset)==-1)
//      {
//        //printf("Failure reading symbol table\n");
//        return -1;
//      }
//      int maxindex=sectionHeaders[i].sh_size / sizeof(Elf64_Sym);
//
//      loadStringTable64(f, sectionHeaders, stringTable, sectionHeaders[i].sh_link);
//
//      //printf("maxindex=%d\n", maxindex);
//      for (j=0; j<maxindex; j++)
//      {
//        /*
//        debug_log("symbolTable[%d]:\n", i);
//        debug_log("st_name=%s\n", &stringTable[sectionHeaders[i].sh_link][symbolTable[j].st_name] );
//        debug_log("st_value=%lx\n", symbolTable[j].st_value);
//        debug_log("st_size=%ld\n", symbolTable[j].st_size);
//        debug_log("st_info=%d\n", symbolTable[j].st_info);
//        debug_log("  Bind=%d\n", ELF64_ST_BIND(symbolTable[j].st_info));
//        debug_log("  Type=%d\n", ELF64_ST_TYPE(symbolTable[j].st_info));
//        debug_log("st_other=%d\n", symbolTable[j].st_other);
//        debug_log("st_shndx=%d\n", symbolTable[j].st_shndx);*/
//
//        if (symbolTable[j].st_value)
//        {
//          //add it to the tempbuffer
//          char *symbolname=(char *)&stringTable[sectionHeaders[i].sh_link][symbolTable[j].st_name];
//          size_t namelength=strlen(symbolname);
//          int entrysize=sizeof(symbolinfo)+namelength;
//          if (tempbufferpos+entrysize>=TEMPBUFSIZE)
//          {
//             //compress the current temp buffer
//             //printf("compressing\n");
//             strm.avail_in=tempbufferpos;
//             strm.next_in=tempbuffer;
//
//             while (strm.avail_in)
//             {
//               if (deflate(&strm, Z_NO_FLUSH)!=Z_OK)
//               {
//                 debug_log("FAILURE TO COMPRESS!\n");
//                 return -1;
//               }
//               //printf("strm.avail_out=%d\n", strm.avail_out);
//
//               if (strm.avail_out==0)
//               {
//
//                  // debug_log("Out buffer full. Reallocating\n");
//                 *output=realloc(*output, maxoutputsize*2);
//
//                 strm.next_out=(unsigned char *)&(*output)[maxoutputsize];
//                 strm.avail_out=maxoutputsize;
//                 maxoutputsize=maxoutputsize*2;
//               }
//
//             }
//             tempbufferpos=0;
//          }
//
//
//
//          psymbolinfo si=(psymbolinfo)&tempbuffer[tempbufferpos];
//          si->address=symbolTable[j].st_value;
//          si->size=symbolTable[j].st_size;
//          si->type=symbolTable[j].st_info;
//          si->namelength=namelength;
//          memcpy(&si->name, symbolname, namelength);
//
//
//          tempbufferpos+=entrysize;
//        }
//      }
//
//      free(symbolTable);
//
//    }
//
//  }
//
//  for (i=0; i<b->e_shnum; i++)
//  {
//    if (stringTable[i])
//      free(stringTable[i]);
//  }
//  free(stringTable);
//
//  free(sectionHeaders);
//
//
//  debug_log("end:\n");
//  strm.avail_in=tempbufferpos;
//  strm.next_in=tempbuffer;
//
//  while (1)
//  {
//
//    i=deflate(&strm, Z_FINISH);
//    debug_log("i=%d\n", i);
//    if (i==Z_STREAM_END) //done
//      break;
//
//    if (i!=Z_OK)
//    {
//      debug_log("Failure to compress: %i\n", i);
//      return -1;
//    }
//
//    if (strm.avail_out==0)
//    {
//      debug_log("Out buffer full. Reallocating :%d\n", maxoutputsize*2);
//      *output=realloc(*output, maxoutputsize*2);
//
//      strm.next_out=(unsigned char *)&(*output)[maxoutputsize];
//      strm.avail_out=maxoutputsize;
//      maxoutputsize=maxoutputsize*2;
//    }
//    else
//      break;
//
//  };
//
//  debug_log("strm.avail_out=%d\n", strm.avail_out);
//
//  debug_log("total_in = %lu\n", strm.total_in);
//  debug_log("total_out = %lu\n", strm.total_out);
//
//  deflateEnd(&strm);
//
//
//  *(uint32_t *)(&(*output)[4])=strm.total_out+3*sizeof(uint32_t);
//  *(uint32_t *)(&(*output)[8])=strm.total_in;
//
//
//  free(tempbuffer);
//
//  return 0; //still alive
//
//}
//
//int GetSymbolListFromFile(char *filename, unsigned char **output, int *outputsize)
///*
// * Returns a pointer to a compressed stream. The caller needs to free it
// */
//{
//  int i, f;
//  unsigned char *b=NULL;
//
//  debug_log("GetSymbolListFromFile(%s)\n", filename);
//
//  *output=NULL;
//  f=open(filename, O_RDONLY);
//  if (f==-1)
//    return -1;
//
//  b=malloc(sizeof(Elf64_Ehdr));
//  if (b)
//  {
//    i=pread(f, b, sizeof(Elf64_Ehdr), 0);
//
//    if (*(uint32_t *)b!=0x464c457f)
//      return -1; //not an ELF file
//
//    if (b[EI_CLASS]==ELFCLASS32)
//      i=ELF32(f, (Elf32_Ehdr *)b, output);
//    else
//      i=ELF64(f, (Elf64_Ehdr *)b, output);
//
//    free(b);
//  }
//
//  close(f);
//
//  return i;
//}
//
//
//int GetModuleSize32(int f, Elf32_Ehdr *b)
//{
// /* debug_log("32 bit\n");
//  debug_log("b->e_ehsize=%d  (%d)\n", (int)b->e_ehsize, (int)sizeof(Elf32_Ehdr));*/
//
//  //Elf32_Shdr *sectionHeaders=malloc(b->e_shentsize*b->e_shnum);
//  Elf32_Phdr *programHeaders=malloc(b->e_phentsize*b->e_phnum);
///*  debug_log("e_shoff=%x\n", b->e_shoff);
//  debug_log("e_shentsize=%d\n", b->e_shentsize);
//  debug_log("e_shnum=%d\n", b->e_shnum);
//  debug_log("e_shstrndx=%d\n", b->e_shstrndx);
//
//  debug_log("e_phoff=%x\n", b->e_phoff);
//  debug_log("e_phentsize=%d\n", b->e_phentsize);
//  debug_log("e_phnum=%d\n", b->e_phnum); */
//
//  if (pread(f, programHeaders, b->e_phentsize*b->e_phnum, b->e_phoff)==-1)
//  {
//    if (programHeaders)
//      free(programHeaders);
//
//    return 0;
//  }
//
//
//  int i;
//  unsigned long long lowest=0;//programHeaders[0].p_vaddr;
//  unsigned long long highest=0;//programHeaders[0].p_vaddr+programHeaders[0].p_memsz;
//
//  for (i=0; i<b->e_phnum; i++)
//  {
//     if (programHeaders[i].p_memsz>0)
//     {
//       if ((i==0) || (programHeaders[i].p_vaddr<lowest))
//          lowest=programHeaders[i].p_vaddr;
//
//       if ((i==0) || (programHeaders[i].p_vaddr+programHeaders[i].p_memsz>highest))
//          highest=programHeaders[i].p_vaddr+programHeaders[i].p_memsz;
//
//
///*
//       debug_log("%d: %x\n", i, programHeaders[i].p_type);
//       debug_log("Virtual Address: %llx-%llx:\n", (long long unsigned int)programHeaders[i].p_vaddr,(long long unsigned int)programHeaders[i].p_vaddr+(long long unsigned int)programHeaders[i].p_memsz);
//       debug_log("Size: %d (%x)\n", (int)programHeaders[i].p_memsz, (int)programHeaders[i].p_memsz);
//       */
//     }
//  }
//
//    if (programHeaders)
//      free(programHeaders);
//
// // debug_log("lowest=%llx highest=%llx\n", lowest, highest);
// // debug_log("size=%llx\n", highest-lowest);
//   return highest-lowest;
//}
//
//int GetModuleSize64(int f, Elf64_Ehdr *b)
//{
//  /*printf("64 bit\n");
//  debug_log("b->e_ehsize=%d  (%d)\n", (int)b->e_ehsize, (int)sizeof(Elf32_Ehdr));*/
//
//  Elf64_Phdr *programHeaders=malloc(b->e_phentsize*b->e_phnum);
///*  debug_log("e_shoff=%x\n", (int)b->e_shoff);
//  debug_log("e_shentsize=%d\n", b->e_shentsize);
//  debug_log("e_shnum=%d\n", b->e_shnum);
//  debug_log("e_shstrndx=%d\n", b->e_shstrndx);
//
//  debug_log("e_phoff=%x\n", (int)b->e_phoff);
//  debug_log("e_phentsize=%d\n", b->e_phentsize);
//  debug_log("e_phnum=%d\n", b->e_phnum);
//  */
//
//  if (pread(f, programHeaders, b->e_phentsize*b->e_phnum, b->e_phoff)==-1)
//  {
//    if (programHeaders)
//      free(programHeaders);
//
//    return 0;
//  }
//
//
//  int i;
//  unsigned long long lowest=0;//programHeaders[0].p_vaddr;
//  unsigned long long highest=0;//programHeaders[0].p_vaddr+programHeaders[0].p_memsz;
//
//  for (i=0; i<b->e_phnum; i++)
//  {
//     if (programHeaders[i].p_memsz>0)
//     {
//       if ((i==0) || (programHeaders[i].p_vaddr<lowest))
//          lowest=programHeaders[i].p_vaddr;
//
//       if ((i==0) || (programHeaders[i].p_vaddr+programHeaders[i].p_memsz>highest))
//          highest=programHeaders[i].p_vaddr+programHeaders[i].p_memsz;
//
//
///*
//       debug_log("%d: %x\n", i, programHeaders[i].p_type);
//       debug_log("Virtual Address: %llx-%llx:\n", (long long unsigned int)programHeaders[i].p_vaddr,(long long unsigned int)programHeaders[i].p_vaddr+(long long unsigned int)programHeaders[i].p_memsz);
//       debug_log("Size: %d (%x)\n", (int)programHeaders[i].p_memsz, (int)programHeaders[i].p_memsz);
//       */
//     }
//  }
//
//    if (programHeaders)
//      free(programHeaders);
//
// // debug_log("lowest=%llx highest=%llx\n", lowest, highest);
// // debug_log("size=%llx\n", highest-lowest);
//   return highest-lowest;
//}
//
//
//unsigned long long GetModuleSize(char *filename, unsigned long long defaultsize)
///*
// * Returns size the module will take in memory
// */
//{
//  int i,f;
//  unsigned char *b=NULL;
//  int result=defaultsize;
//
////  debug_log("GetModuleSize(\"%s\")=",filename);
//
//  f=open(filename, O_RDONLY);
//  if (f==-1)
//  {
//    debug_log("Failed to open %s\n", filename);
//    return defaultsize;
//  }
//  else
//  {
//    b=malloc(sizeof(Elf64_Ehdr));
//    if (b)
//    {
//      i=pread(f, b, sizeof(Elf64_Ehdr), 0);
//
//      if (*(uint32_t *)b!=0x464c457f)
//      {
//        debug_log("%s is not an elf\n", filename);
//        free(b);
//        close(f);
//        return defaultsize; //not an ELF file
//      }
//
//      if (b[EI_CLASS]==ELFCLASS32)
//        i=GetModuleSize32(f, (Elf32_Ehdr *)b);
//      else
//        i=GetModuleSize64(f, (Elf64_Ehdr *)b);
//
//      free(b);
//      close(f);
//
//      //printf("%x\n",i);
//      return i;
//    }
//    else
//    {
//      close(f);
//      return defaultsize;
//    }
//
//
//
//  }
//
//
//}

```

`CEServer/symbols.h`:

```h
#pragma once
class CSymbols {
public:
	//static int GetSymbolListFromFile(char *filename, unsigned char **output);
	//static unsigned long long GetModuleSize(char *filename, unsigned long long defaultsize);

};


```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "anstream"
version = "0.6.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64e15c1ab1f89faffbf04a634d5e1962e9074f2741eef6d97f3c4e322426d526"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bec1de6f59aedf83baf9ff929c98f2ad654b97c9510f4e70cf6f661d49fd5b1"

[[package]]
name = "anstyle-parse"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb47de1e80c2b463c735db5b217a0ddc39d612e7ac9e2e96a5aed1f57616c1cb"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d36fc52c7f6c869915e99412912f22093507da8d9e942ceaf66fe4b7c14422a"
dependencies = [
 "windows-sys",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5bf74e1b6e971609db8ca7a9ce79fd5768ab6ae46441c572e46cf596f59e57f8"
dependencies = [
 "anstyle",
 "windows-sys",
]

[[package]]
name = "anyhow"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3d1d046238990b9cf5bcde22a3fb3584ee5cf65fb2765f454ed428c7a0063da"

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "backtrace"
version = "0.3.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"

[[package]]
name = "bitvec"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c"
dependencies = [
 "funty",
 "radium",
 "tap",
 "wyz",
]

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "cc"
version = "1.1.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57b6a275aa2903740dc87da01c62040406b8812552e97129a63ea8850a17c6e6"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "clap"
version = "4.5.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed6719fffa43d0d87e5fd8caeab59be1554fb028cd30edc88fc4369b17971019"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap-num"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e063d263364859dc54fb064cedb7c122740cd4733644b14b176c097f51e8ab7"
dependencies = [
 "num-traits",
]

[[package]]
name = "clap_builder"
version = "4.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "216aec2b177652e3846684cbfe25c9964d18ec45234f0f5da5157b207ed1aab6"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "501d359d5f3dcaf6ecdeee48833ae73ec6e42723a1e52419c79abf9507eec0a0"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1462739cb27611015575c0c11df5df7601141071f07518d56fcc1be504cbec97"

[[package]]
name = "colorchoice"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3fd119d74b830634cea2a0f58bbd0d54540518a14397557951e79340abc28c0"

[[package]]
name = "funty"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c"

[[package]]
name = "gimli"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "libc"
version = "0.2.158"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439"

[[package]]
name = "librwmem"
version = "0.1.0"
dependencies = [
 "bitvec",
 "byteorder",
 "libc",
 "nix",
 "thiserror",
 "tokio",
]

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "miniz_oxide"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
dependencies = [
 "adler",
]

[[package]]
name = "mio"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
dependencies = [
 "hermit-abi",
 "libc",
 "wasi",
 "windows-sys",
]

[[package]]
name = "nix"
version = "0.27.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2eb04e9c688eff1c89d72b407f168cf79bb9e867a9d3323ed6c01519eb9cc053"
dependencies = [
 "bitflags",
 "cfg-if",
 "libc",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "object"
version = "0.36.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b64972346851a39438c60b341ebc01bba47464ae329e55cf343eb93964efd9"
dependencies = [
 "memchr",
]

[[package]]
name = "pin-project-lite"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"

[[package]]
name = "pretty-hex"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbc83ee4a840062f368f9096d80077a9841ec117e17e7f700df81958f1451254"

[[package]]
name = "proc-macro2"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "radium"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09"

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rwmemctl"
version = "0.1.0"
dependencies = [
 "anyhow",
 "clap",
 "clap-num",
 "hex",
 "librwmem",
 "pretty-hex",
 "shellish_parse",
 "tokio",
]

[[package]]
name = "shellish_parse"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c29b912ad681a28566f37b936bba1f3580a93b9391c4a0b12cb1c6b4ed79973"

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "socket2"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
dependencies = [
 "libc",
 "windows-sys",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "2.0.76"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "578e081a14e0cefc3279b0472138c513f37b41a08d5a3cca9b6e4e8ceb6cd525"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tap"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369"

[[package]]
name = "thiserror"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio"
version = "1.39.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babc99b9923bfa4804bd74722ff02c0381021eafa4db9949217e3be8e84fff5"
dependencies = [
 "backtrace",
 "libc",
 "mio",
 "pin-project-lite",
 "socket2",
 "tokio-macros",
 "windows-sys",
]

[[package]]
name = "tokio-macros"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "wyz"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed"
dependencies = [
 "tap",
]

```

`Cargo.toml`:

```toml
[workspace]
resolver = "2"
members = [
  "cli",
  "librwmem",
]

```

`README.md`:

```md
# RwMem

A modified kernel to read and write memory and set hardware breakpoint in a remote process.

## Features

1. read and write memory
2. set hardware breakpoint and memory watchpoint
3. suspend the remote process when the breakpoint or watchpoint is hit
4. run the remote process instruction by instruction
5. get and set the register value

## Why?

There are many ways to do this, but most of them are not very reliable. This modified kernel is a reliable and easy way to read and write memory and set hardware breakpoint in a remote process.

**Why not ptrace?** `ptrace` is a good way to debug a process, but it has some limitations. For example, the target process can easily detect the debugger.

**Why not uprobe?** `uprobe` is a good way to set breakpoint, but it will modify the memory of target instruction. Also it can not set watchpoint. [More details](https://www.cnxct.com/defeating-ebpf-uprobe-monitoring/#ftoc-heading-14)

## Example

```rust
use librwmem::{BreakpointType, Device, DEFAULT_DRIVER_PATH};

let device = Device::new(DEFAULT_DRIVER_PATH)?;
let pid = 0x1234;
let addr = 0x12345678;

// write to remote process memory
device.write_mem(pid, addr, &[0xcc, 0xcc, 0xcc, 0xcc])?;

// read from remote process memory
let mut buf = [0u8; 1024];
device.read_mem(pid, addr, &mut buf)?;

// add a breakpoint
let bp = device.add_bp(pid, BreakpointType::ReadWrite, 8, addr)?;

// wait for the breakpoint to be hit
bp.wait().await?;

// print the registers
println!("{:x?}", bp.get_regs()?);

// set the registers, set X8 to 0
bp.set_reg(8, 0)?;

// run a single instruction
bp.step()?;
bp.wait().await?;

// continue the process
bp.cont()?;

// remove the breakpoint
std::mem::drop(bp);
```

## How to build?

### Kernel module

1. Build the android kernel according to the [KernelSU document](https://kernelsu.org/guide/how-to-build.html)
2. Apply patches in `patch` folder
3. Copy the `rwMem` folder to the `drivers` folder in the kernel source code
4. Add a line `obj-$(CONFIG_RW_MEM) += rwMem/` to the end of `drivers/Makefile`
5. Build the kernel again

### CEServer

The CEServer is a modified version of the official CEServer. It support the **master** branch of Cheat Engine.

```bash
aarch64-linux-gnu-g++ *.cpp -lz -o CEServer
```

### CLI tool

```bash
cargo build --release --target aarch64-unknown-linux-musl
```

## How to use?

Install the kernel module and the run the CEServer on your android device.

You can also use the librwmem to communicate with the kernel module.

## Project Structure

```
.
├── rwMem         # The kernel module
├── patch         # Some patches for the kernel
├── CEServer      # A modified CEServer which uses the kernel module to read and write memory
├── librwmem      # A rust library to communicate with the kernel module
└── cli           # A cli tool for developers
```

# Acknowledgements

`librwmem` is inspired and modified by [rwMwmProc33](https://github.com/abcz316/rwProcMem33).

`KernelSU` is a great project to build a custom kernel for android.

```

`cli/Cargo.toml`:

```toml
[package]
name = "rwmemctl"
version = "0.1.0"
edition = "2021"

[dependencies]
clap = {version = "^4", features = ["derive"]}
anyhow = "1"
shellish_parse = "2.2"
clap-num = "^1.1"
pretty-hex = "0.4"
hex = "*"
tokio = { version = "1", features = ["rt", "net"] }
librwmem = { path = "../librwmem", features = ["async"]}


```

`cli/src/main.rs`:

```rs
use std::{collections::HashMap, io::Write};

use clap::{Parser, Subcommand};
use clap_num::maybe_hex;
use librwmem::{Breakpoint, BreakpointType, Device};

#[derive(Parser)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    AddBp {
        pid: i32,
        #[clap(value_parser=clap::value_parser!(BreakpointType))]
        bp_type: BreakpointType,
        len: u8,
        #[clap(value_parser=maybe_hex::<u64>)]
        addr: u64,
    },
    DelBp {
        id: i32,
    },
    Continue {
        id: i32,
    },
    SetReg {
        id: i32,
        #[clap(value_parser=maybe_hex::<u8>)]
        reg_id: u8,
        #[clap(value_parser=maybe_hex::<u64>)]
        value: u64,
    },
    SetSimdReg {
        id: i32,
        #[clap(value_parser=maybe_hex::<u8>)]
        reg_id: u8,
        #[clap(value_parser=maybe_hex::<u128>)]
        value: u128,
    },
    GetRegs {
        id: i32,
        #[clap(short)]
        simd: bool,
    },
    Wait {
        id: i32,
    },
    GetMemMap {
        pid: i32,
    },
    WriteMem {
        pid: i32,
        #[clap(value_parser=maybe_hex::<u64>)]
        addr: u64,
        #[clap(value_parser=clap::value_parser!(MyBytes))]
        value: MyBytes,
    },
    ReadMem {
        pid: i32,
        #[clap(value_parser=maybe_hex::<u64>)]
        addr: u64,
        #[clap(value_parser=maybe_hex::<u64>)]
        size: u64,
    },
    Step {
        id: i32,
    },
    IsStopped {
        id: i32,
    },
}

#[derive(Debug, Clone)]
struct MyBytes(Vec<u8>);
impl std::str::FromStr for MyBytes {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        hex::decode(s).map_err(|e| e.to_string()).map(MyBytes)
    }
}

fn run_cmd(
    cmd: Commands,
    device: &Device,
    bps: &mut HashMap<i32, Breakpoint>,
) -> anyhow::Result<()> {
    match cmd {
        Commands::AddBp {
            pid,
            bp_type,
            len,
            addr,
        } => {
            let bp = device.add_bp(pid, bp_type, len, addr)?;
            let id = bp.as_raw_fd();
            bps.insert(id, bp);
            println!("Breakpoint added: {:?}", id);
        }
        Commands::DelBp { id } => {
            let bp = bps
                .remove(&id)
                .ok_or_else(|| anyhow::anyhow!("Breakpoint not found"))?;
            std::mem::drop(bp);
        }
        Commands::Continue { id } => {
            let bp = bps
                .get(&id)
                .ok_or_else(|| anyhow::anyhow!("Breakpoint not found"))?;
            bp.cont()?;
        }
        Commands::SetReg { id, reg_id, value } => {
            let bp = bps
                .get(&id)
                .ok_or_else(|| anyhow::anyhow!("Breakpoint not found"))?;
            bp.set_reg(reg_id, value)?;
        }
        Commands::SetSimdReg { id, reg_id, value } => {
            let bp = bps
                .get(&id)
                .ok_or_else(|| anyhow::anyhow!("Breakpoint not found"))?;
            bp.set_simd_reg(reg_id, value)?;
        }
        Commands::GetRegs { id, simd } => {
            let bp = bps
                .get(&id)
                .ok_or_else(|| anyhow::anyhow!("Breakpoint not found"))?;
            if simd {
                let regs = bp.get_regs_with_simd()?;
                println!("Hit breakpoint: {:#?}", regs);
            } else {
                let regs = bp.get_regs()?;
                println!("Hit breakpoint: {:#?}", regs);
            }
        }
        Commands::Wait { id } => {
            let bp = bps
                .get(&id)
                .ok_or_else(|| anyhow::anyhow!("Breakpoint not found"))?;
            tokio::runtime::Builder::new_current_thread()
                .enable_io()
                .build()?
                .block_on(async {
                    bp.wait().await?;
                    Result::<(), librwmem::errors::Error>::Ok(())
                })?;
        }
        Commands::GetMemMap { pid } => {
            let map = device.get_mem_map(pid, true)?;
            println!("Memory map: {:#?}", map);
        }
        Commands::WriteMem { pid, addr, value } => {
            device.write_mem(pid, addr, &value.0)?;
        }
        Commands::ReadMem { pid, addr, size } => {
            let mut buf = vec![0u8; size as usize];
            device.read_mem(pid, addr, &mut buf)?;
            println!("Data:\n{}", pretty_hex::pretty_hex(&buf));
        }
        Commands::Step { id } => {
            let bp = bps
                .get(&id)
                .ok_or_else(|| anyhow::anyhow!("Breakpoint not found"))?;
            bp.step()?;
        }
        Commands::IsStopped { id } => {
            let bp = bps
                .get(&id)
                .ok_or_else(|| anyhow::anyhow!("Breakpoint not found"))?;
            let stopped = bp.is_stopped()?;
            println!("Stopped: {:?}", stopped);
        }
    }
    Ok(())
}

fn read_and_run(device: &Device, bps: &mut HashMap<i32, Breakpoint>) -> anyhow::Result<()> {
    print!("> ");
    std::io::stdout().flush().unwrap();
    let mut line = String::new();
    std::io::stdin().read_line(&mut line)?;
    if line.trim().is_empty() {
        println!();
        return Ok(());
    }
    let mut ast = shellish_parse::parse(&line, false)?;
    ast.insert(0, "rwmem".to_string());
    let cli = Cli::try_parse_from(&ast)?;

    if let Err(e) = run_cmd(cli.command, device, bps) {
        eprintln!("Error: {:?}", e);
    }
    Ok(())
}

fn main() -> anyhow::Result<()> {
    let device = Device::new(librwmem::DEFAULT_DRIVER_PATH).unwrap();
    println!("Brps: {:?}", device.get_num_brps());
    println!("Wrps: {:?}", device.get_num_wrps());
    let mut bps: HashMap<i32, Breakpoint> = HashMap::new();
    loop {
        if let Err(e) = read_and_run(&device, &mut bps) {
            eprintln!("Error: {:?}", e);
        };
    }
}

```

`librwmem/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "anstream"
version = "0.6.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64e15c1ab1f89faffbf04a634d5e1962e9074f2741eef6d97f3c4e322426d526"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bec1de6f59aedf83baf9ff929c98f2ad654b97c9510f4e70cf6f661d49fd5b1"

[[package]]
name = "anstyle-parse"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb47de1e80c2b463c735db5b217a0ddc39d612e7ac9e2e96a5aed1f57616c1cb"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d36fc52c7f6c869915e99412912f22093507da8d9e942ceaf66fe4b7c14422a"
dependencies = [
 "windows-sys",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5bf74e1b6e971609db8ca7a9ce79fd5768ab6ae46441c572e46cf596f59e57f8"
dependencies = [
 "anstyle",
 "windows-sys",
]

[[package]]
name = "anyhow"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3d1d046238990b9cf5bcde22a3fb3584ee5cf65fb2765f454ed428c7a0063da"

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "backtrace"
version = "0.3.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"

[[package]]
name = "bitvec"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c"
dependencies = [
 "funty",
 "radium",
 "tap",
 "wyz",
]

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "cc"
version = "1.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50d2eb3cd3d1bf4529e31c215ee6f93ec5a3d536d9f578f93d9d33ee19562932"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cfg_aliases"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e"

[[package]]
name = "clap"
version = "4.5.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed6719fffa43d0d87e5fd8caeab59be1554fb028cd30edc88fc4369b17971019"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap-num"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e063d263364859dc54fb064cedb7c122740cd4733644b14b176c097f51e8ab7"
dependencies = [
 "num-traits",
]

[[package]]
name = "clap_builder"
version = "4.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "216aec2b177652e3846684cbfe25c9964d18ec45234f0f5da5157b207ed1aab6"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "501d359d5f3dcaf6ecdeee48833ae73ec6e42723a1e52419c79abf9507eec0a0"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1462739cb27611015575c0c11df5df7601141071f07518d56fcc1be504cbec97"

[[package]]
name = "clipboard-win"
version = "5.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15efe7a882b08f34e38556b14f2fb3daa98769d06c7f0c1b076dfd0d983bc892"
dependencies = [
 "error-code",
]

[[package]]
name = "colorchoice"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3fd119d74b830634cea2a0f58bbd0d54540518a14397557951e79340abc28c0"

[[package]]
name = "endian-type"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c34f04666d835ff5d62e058c3995147c06f42fe86ff053337632bca83e42702d"

[[package]]
name = "errno"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
dependencies = [
 "libc",
 "windows-sys",
]

[[package]]
name = "error-code"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0474425d51df81997e2f90a21591180b38eccf27292d755f3e30750225c175b"

[[package]]
name = "fd-lock"
version = "4.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e5768da2206272c81ef0b5e951a41862938a6070da63bcea197899942d3b947"
dependencies = [
 "cfg-if",
 "rustix",
 "windows-sys",
]

[[package]]
name = "funty"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c"

[[package]]
name = "gimli"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "home"
version = "0.5.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3d1354bf6b7235cb4a0576c2619fd4ed18183f689b12b006a0ee7329eeff9a5"
dependencies = [
 "windows-sys",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "libc"
version = "0.2.158"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439"

[[package]]
name = "librwmem"
version = "0.1.0"
dependencies = [
 "anyhow",
 "bitvec",
 "byteorder",
 "clap",
 "clap-num",
 "hex",
 "libc",
 "nix 0.27.1",
 "pretty-hex",
 "rustyline",
 "shellish_parse",
 "thiserror",
 "tokio",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "miniz_oxide"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
dependencies = [
 "adler",
]

[[package]]
name = "mio"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
dependencies = [
 "hermit-abi",
 "libc",
 "wasi",
 "windows-sys",
]

[[package]]
name = "nibble_vec"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a5d83df9f36fe23f0c3648c6bbb8b0298bb5f1939c8f2704431371f4b84d43"
dependencies = [
 "smallvec",
]

[[package]]
name = "nix"
version = "0.27.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2eb04e9c688eff1c89d72b407f168cf79bb9e867a9d3323ed6c01519eb9cc053"
dependencies = [
 "bitflags",
 "cfg-if",
 "libc",
]

[[package]]
name = "nix"
version = "0.28.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab2156c4fce2f8df6c499cc1c763e4394b7482525bf2a9701c9d79d215f519e4"
dependencies = [
 "bitflags",
 "cfg-if",
 "cfg_aliases",
 "libc",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "object"
version = "0.36.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b64972346851a39438c60b341ebc01bba47464ae329e55cf343eb93964efd9"
dependencies = [
 "memchr",
]

[[package]]
name = "pin-project-lite"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"

[[package]]
name = "pretty-hex"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbc83ee4a840062f368f9096d80077a9841ec117e17e7f700df81958f1451254"

[[package]]
name = "proc-macro2"
version = "1.0.86"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "radium"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09"

[[package]]
name = "radix_trie"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c069c179fcdc6a2fe24d8d18305cf085fdbd4f922c041943e203685d6a1c58fd"
dependencies = [
 "endian-type",
 "nibble_vec",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustix"
version = "0.38.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70dc5ec042f7a43c4a73241207cecc9873a06d45debb38b329f8541d85c2730f"
dependencies = [
 "bitflags",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys",
]

[[package]]
name = "rustyline"
version = "14.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7803e8936da37efd9b6d4478277f4b2b9bb5cdb37a113e8d63222e58da647e63"
dependencies = [
 "bitflags",
 "cfg-if",
 "clipboard-win",
 "fd-lock",
 "home",
 "libc",
 "log",
 "memchr",
 "nix 0.28.0",
 "radix_trie",
 "termios",
 "unicode-segmentation",
 "unicode-width",
 "utf8parse",
 "windows-sys",
]

[[package]]
name = "shellish_parse"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c29b912ad681a28566f37b936bba1f3580a93b9391c4a0b12cb1c6b4ed79973"

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "socket2"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
dependencies = [
 "libc",
 "windows-sys",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "2.0.76"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "578e081a14e0cefc3279b0472138c513f37b41a08d5a3cca9b6e4e8ceb6cd525"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tap"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369"

[[package]]
name = "termios"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "411c5bf740737c7918b8b1fe232dca4dc9f8e754b8ad5e20966814001ed0ac6b"
dependencies = [
 "libc",
]

[[package]]
name = "thiserror"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio"
version = "1.39.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babc99b9923bfa4804bd74722ff02c0381021eafa4db9949217e3be8e84fff5"
dependencies = [
 "backtrace",
 "libc",
 "mio",
 "pin-project-lite",
 "socket2",
 "windows-sys",
]

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "unicode-segmentation"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202"

[[package]]
name = "unicode-width"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0336d538f7abc86d282a4189614dfaa90810dfc2c6f6427eaf88e16311dd225d"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "wyz"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed"
dependencies = [
 "tap",
]

```

`librwmem/Cargo.toml`:

```toml
[package]
name = "librwmem"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
nix = { version = "0.27", features = ["ioctl", "fs"] }
libc = "0.2"
byteorder = "1.5"
bitvec = "1"
thiserror = "1"
tokio = {version = "1", features = ["net", "rt", "macros"], default-features = false, optional = true}

[features]
default = ["async"]
async = ["dep:tokio"]


```

`librwmem/examples/test.rs`:

```rs
use librwmem::{BreakpointType, Device, DEFAULT_DRIVER_PATH};

#[tokio::main(flavor = "current_thread")]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let device = Device::new(DEFAULT_DRIVER_PATH)?;
    let pid = 0x1234;
    let addr = 0x12345678;

    // write to remote process memory
    device.write_mem(pid, addr, &[0xcc, 0xcc, 0xcc, 0xcc])?;

    // read from remote process memory
    let mut buf = [0u8; 1024];
    device.read_mem(pid, addr, &mut buf)?;

    // add a breakpoint
    let bp = device.add_bp(pid, BreakpointType::ReadWrite, 8, addr)?;

    // wait for the breakpoint to be hit
    bp.wait().await?;

    // print the registers
    println!("{:x?}", bp.get_regs()?);

    // set the registers, set X8 to 0
    bp.set_reg(8, 0)?;

    // run a single instruction
    bp.step()?;
    bp.wait().await?;

    // continue the process
    bp.cont()?;

    // remove the breakpoint
    std::mem::drop(bp);
    Ok(())
}

```

`librwmem/src/errors.rs`:

```rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("IO error: {0}")]
    Errno(#[from] nix::errno::Errno),
    #[error("read too short: expect read {0} bytes, but short {1} bytes")]
    ReadFailed(usize, usize),
    #[error("write too short: expect write {0} bytes, but short {1} bytes")]
    WriteFailed(usize, usize),
    #[error("maps too long")]
    MapsTooLong,
    #[error("maps parse error: {0}")]
    MapsParseError(#[from] std::io::Error),
    #[error("not aligned")]
    NotAligned,
    #[error("begin address {0} is larger than end address {1}")]
    BeginLargerThanEnd(u64, u64),
    #[error("invalid register: {0}")]
    InvalidRegister(u64),
    #[error("invalid breakpoint type: {0}")]
    InvalidBreakpointType(String),
}

```

`librwmem/src/lib.rs`:

```rs
use bitvec::{order::Lsb0, vec::BitVec};
use byteorder::{NativeEndian, ReadBytesExt};
use nix::{ioctl_none, ioctl_write_int, ioctl_write_ptr, request_code_readwrite};
use std::{
    cmp::max,
    io::{Cursor, Read},
    os::fd::{AsRawFd, FromRawFd, OwnedFd, RawFd},
    path::Path,
};

pub mod errors;

type Result<T> = std::result::Result<T, errors::Error>;

const RWMEM_MAGIC: u8 = 100;
const RWMEM_BP_MAGIC: u8 = 101;
const IOCTL_GET_PROCESS_MAPS_COUNT: u8 = 0;
const IOCTL_GET_PROCESS_MAPS_LIST: u8 = 1;
const IOCTL_CHECK_PROCESS_ADDR_PHY: u8 = 2;

#[derive(Debug, PartialEq, Eq)]
pub struct MapsEntry {
    pub start: u64,
    pub end: u64,
    pub read_permission: bool,
    pub write_permission: bool,
    pub execute_permission: bool,
    pub shared: bool,
    pub name: String,
}

pub const DEFAULT_DRIVER_PATH: &str = "/dev/rwmem";

#[repr(transparent)]
#[derive(Debug)]
pub struct Device {
    fd: OwnedFd,
}

#[allow(dead_code)]
impl Device {
    /// Create a new device. The default path is `DEFAULT_DRIVER_PATH`.
    pub fn new<P: AsRef<Path>>(path: P) -> Result<Self> {
        let fd = nix::fcntl::open(
            path.as_ref(),
            nix::fcntl::OFlag::O_RDWR,
            nix::sys::stat::Mode::empty(),
        )?;
        Ok(Self {
            fd: unsafe { OwnedFd::from_raw_fd(fd) },
        })
    }

    pub fn from_raw_fd(fd: RawFd) -> Self {
        Self {
            fd: unsafe { OwnedFd::from_raw_fd(fd) },
        }
    }
    pub fn as_raw_fd(&self) -> RawFd {
        self.fd.as_raw_fd()
    }
    /// read the memory of a process.
    pub fn read_mem(&self, pid: i32, addr: u64, buf: &mut [u8]) -> Result<()> {
        if buf.len() < 17 {
            let new_buf = &mut [0u8; 17];
            new_buf[0..8].copy_from_slice(&(pid as i64).to_ne_bytes());
            new_buf[8..16].copy_from_slice(&addr.to_ne_bytes());
            let real_read = nix::errno::Errno::result(unsafe {
                libc::read(
                    self.fd.as_raw_fd(),
                    new_buf.as_mut_ptr() as *mut libc::c_void,
                    buf.len(),
                )
            })?;
            if real_read != buf.len() as isize {
                return Err(errors::Error::ReadFailed(buf.len(), real_read as usize));
            }
            buf.copy_from_slice(&new_buf[..buf.len()]);
        } else {
            buf[0..8].copy_from_slice(&(pid as i64).to_ne_bytes());
            buf[8..16].copy_from_slice(&addr.to_ne_bytes());
            buf[17] = 0;
            let real_read = nix::errno::Errno::result(unsafe {
                libc::read(
                    self.fd.as_raw_fd(),
                    buf.as_mut_ptr() as *mut libc::c_void,
                    buf.len(),
                )
            })?;
            if real_read != buf.len() as isize {
                return Err(errors::Error::ReadFailed(buf.len(), real_read as usize));
            }
        }
        Ok(())
    }

    /// write the memory of a process.
    pub fn write_mem(&self, pid: i32, addr: u64, buf: &[u8]) -> Result<()> {
        let mut new_buf = vec![0u8; 17 + buf.len()];
        new_buf[0..8].copy_from_slice(&(pid as i64).to_ne_bytes());
        new_buf[8..16].copy_from_slice(&addr.to_ne_bytes());
        new_buf[16] = 1;
        new_buf[17..].copy_from_slice(buf);
        let real_write = nix::errno::Errno::result(unsafe {
            libc::write(
                self.fd.as_raw_fd(),
                new_buf.as_ptr() as *const libc::c_void,
                buf.len(),
            )
        })?;
        if real_write != buf.len() as isize {
            return Err(errors::Error::WriteFailed(buf.len(), real_write as usize));
        }
        Ok(())
    }

    /// get the memory map of a process.
    pub fn get_mem_map(&self, pid: i32, phy_only: bool) -> Result<Vec<MapsEntry>> {
        let count = self.get_mem_map_count(pid)?;
        let buf_len = 8 + (8 + 8 + 4 + 512) * (count + 50);
        let mut buf = vec![0u8; buf_len];
        buf[0..8].copy_from_slice(&(pid as i64).to_ne_bytes());
        buf[8..16].copy_from_slice(&512usize.to_ne_bytes());
        buf[16..24].copy_from_slice(&buf_len.to_ne_bytes());

        let unfinished = nix::errno::Errno::result(unsafe {
            libc::ioctl(
                self.fd.as_raw_fd(),
                request_code_readwrite!(
                    RWMEM_MAGIC,
                    IOCTL_GET_PROCESS_MAPS_LIST,
                    std::mem::size_of::<usize>()
                ),
                buf.as_mut_ptr(),
                buf.len(),
            )
        })?;
        if unfinished != 0 {
            return Err(errors::Error::MapsTooLong);
        }
        let mut cursor = Cursor::new(buf);
        let real_count = cursor.read_u64::<NativeEndian>()?;
        let mut result = Vec::with_capacity(real_count as usize);
        for _ in 0..real_count {
            let start = cursor.read_u64::<NativeEndian>()?;
            let end = cursor.read_u64::<NativeEndian>()?;
            let read_permission = cursor.read_u8()? != 0;
            let write_permission = cursor.read_u8()? != 0;
            let execute_permission = cursor.read_u8()? != 0;
            let shared = cursor.read_u8()? != 0;
            let mut name = [0u8; 512];
            cursor.read_exact(&mut name)?;
            let mut name_length = 512usize;
            for (i, v) in name.iter().enumerate() {
                if *v == 0 {
                    name_length = i;
                    break;
                }
            }
            let name = String::from_utf8_lossy(&name[0..name_length]).to_string();
            if phy_only {
                let is_mem_phy = self.is_mem_phy(pid, start, end)?;
                let mut is_last_phy = false;
                let mut begin_phy = 0u64;
                for (i, is_phy) in is_mem_phy.iter().enumerate() {
                    if *is_phy {
                        if !is_last_phy {
                            begin_phy = start + i as u64 * 0x1000;
                            is_last_phy = true;
                        }
                    } else if is_last_phy {
                        let entry = MapsEntry {
                            start: begin_phy,
                            end: start + i as u64 * 0x1000,
                            read_permission,
                            write_permission,
                            execute_permission,
                            shared,
                            name: name.clone(),
                        };
                        is_last_phy = false;
                        result.push(entry);
                    }
                }
                if is_last_phy {
                    let entry = MapsEntry {
                        start: begin_phy,
                        end,
                        read_permission,
                        write_permission,
                        execute_permission,
                        shared,
                        name,
                    };
                    result.push(entry);
                }
            } else {
                let entry = MapsEntry {
                    start,
                    end,
                    read_permission,
                    write_permission,
                    execute_permission,
                    shared,
                    name,
                };
                result.push(entry);
            }
        }
        Ok(result)
    }

    /// get the count of memory map entries.
    fn get_mem_map_count(&self, pid: i32) -> Result<usize> {
        ioctl_write_int!(get_mem_map_count, RWMEM_MAGIC, IOCTL_GET_PROCESS_MAPS_COUNT);
        let count = unsafe { get_mem_map_count(self.fd.as_raw_fd(), pid as u64) }?;
        Ok(count as usize)
    }

    /// check if the memory is physical.
    /// begin_addr and end_addr must be page aligned.
    /// return a bitvec, each bit represents a page.
    pub fn is_mem_phy(&self, pid: i32, begin_addr: u64, end_addr: u64) -> Result<BitVec<u8, Lsb0>> {
        if begin_addr & 0xfff != 0 {
            return Err(errors::Error::NotAligned);
        }
        if end_addr & 0xfff != 0 {
            return Err(errors::Error::NotAligned);
        }
        if begin_addr >= end_addr {
            return Err(errors::Error::BeginLargerThanEnd(begin_addr, end_addr));
        }
        let buf_size = max(24, ((end_addr >> 12) - (begin_addr >> 12) + 7) / 8) as usize;
        let mut buf = vec![0u8; buf_size];
        buf[0..8].copy_from_slice(&(pid as i64).to_ne_bytes());
        buf[8..16].copy_from_slice(&begin_addr.to_ne_bytes());
        buf[16..24].copy_from_slice(&end_addr.to_ne_bytes());
        nix::errno::Errno::result(unsafe {
            libc::ioctl(
                self.fd.as_raw_fd(),
                request_code_readwrite!(
                    RWMEM_MAGIC,
                    IOCTL_CHECK_PROCESS_ADDR_PHY,
                    std::mem::size_of::<usize>()
                ),
                buf.as_mut_ptr(),
                buf_size,
            )
        })?;
        let mut result = BitVec::<u8, Lsb0>::from_vec(buf);
        result.truncate(((end_addr >> 12) - (begin_addr >> 12)) as usize);
        Ok(result)
    }

    /// add bp
    pub fn add_bp(
        &self,
        pid: i32,
        bp_type: BreakpointType,
        len: u8,
        addr: u64,
    ) -> Result<Breakpoint> {
        let mut buf = [0u8; 16];

        buf[0..4].copy_from_slice(&pid.to_ne_bytes());
        buf[4] = match bp_type {
            BreakpointType::Read => 1,
            BreakpointType::Write => 2,
            BreakpointType::ReadWrite => 3,
            BreakpointType::Execute => 4,
        };
        buf[5] = len;
        buf[8..16].copy_from_slice(&addr.to_ne_bytes());
        let fd = nix::errno::Errno::result(unsafe {
            libc::ioctl(
                self.fd.as_raw_fd(),
                request_code_readwrite!(RWMEM_MAGIC, 3, std::mem::size_of::<usize>()),
                buf.as_ptr(),
                16,
            )
        })?;
        Ok(Breakpoint::from_raw_fd(fd))
    }

    pub fn get_num_brps(&self) -> Result<i32> {
        ioctl_none!(get_num_brps, RWMEM_MAGIC, 4);
        let num = unsafe { get_num_brps(self.fd.as_raw_fd()) }?;
        Ok(num)
    }

    pub fn get_num_wrps(&self) -> Result<i32> {
        ioctl_none!(get_num_wrps, RWMEM_MAGIC, 5);
        let num = unsafe { get_num_wrps(self.fd.as_raw_fd()) }?;
        Ok(num)
    }
}

#[derive(Debug)]
pub struct Breakpoint {
    fd: OwnedFd,
}

#[repr(C)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Regs {
    pub regs: [u64; 31],
    pub sp: u64,
    pub pc: u64,
    pub pstate: u64,
}

#[repr(C)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SimdRegs {
    pub regs: [u128; 32],
    pub fpsr: u32,
    pub fpcr: u32,
    __: [u32; 2],
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BreakpointType {
    Read,
    Write,
    ReadWrite,
    Execute,
}

impl std::str::FromStr for BreakpointType {
    type Err = errors::Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "r" => Ok(Self::Read),
            "w" => Ok(Self::Write),
            "rw" => Ok(Self::ReadWrite),
            "x" => Ok(Self::Execute),
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            "readwrite" => Ok(Self::ReadWrite),
            "read_write" => Ok(Self::ReadWrite),
            "execute" => Ok(Self::Execute),
            _ => Err(errors::Error::InvalidBreakpointType(s.to_string())),
        }
    }
}

pub type AllRegs = (Regs, SimdRegs);

#[allow(dead_code)]
impl Breakpoint {
    pub fn from_raw_fd(fd: RawFd) -> Self {
        Self {
            fd: unsafe { OwnedFd::from_raw_fd(fd) },
        }
    }

    pub fn as_raw_fd(&self) -> RawFd {
        self.fd.as_raw_fd()
    }

    pub fn cont(&self) -> Result<i32> {
        ioctl_none!(bp_continue, RWMEM_BP_MAGIC, 0);
        let num = unsafe { bp_continue(self.fd.as_raw_fd()) }?;
        Ok(num)
    }

    pub fn set_reg(&self, reg: u8, value: u64) -> Result<()> {
        #[repr(C)]
        struct SetRegParam {
            reg: u64,
            value: u64,
        }
        ioctl_write_ptr!(bp_set_reg, RWMEM_BP_MAGIC, 1, SetRegParam);
        if reg >= 34 {
            return Err(errors::Error::InvalidRegister(reg as u64));
        }
        let param = SetRegParam {
            reg: reg as u64,
            value,
        };
        unsafe { bp_set_reg(self.fd.as_raw_fd(), &param) }?;
        Ok(())
    }

    pub fn set_simd_reg(&self, reg: u8, value: u128) -> Result<()> {
        #[repr(C)]
        struct SetSimdRegParam {
            reg: u64,
            value: u128,
        }
        ioctl_write_ptr!(bp_set_simd_reg, RWMEM_BP_MAGIC, 2, SetSimdRegParam);
        if reg >= 34 {
            return Err(errors::Error::InvalidRegister(reg as u64));
        }
        let param = SetSimdRegParam {
            reg: reg as u64,
            value,
        };
        unsafe { bp_set_simd_reg(self.fd.as_raw_fd(), &param) }?;
        Ok(())
    }

    pub fn get_regs(&self) -> Result<Regs> {
        const BUF_SIZE: usize = std::mem::size_of::<Regs>();
        let mut buf = [0u8; BUF_SIZE];
        nix::unistd::read(self.fd.as_raw_fd(), &mut buf)?;
        let regs = unsafe { std::mem::transmute::<[u8; BUF_SIZE], Regs>(buf) };
        Ok(regs)
    }

    pub fn get_regs_with_simd(&self) -> Result<(Regs, SimdRegs)> {
        const BUF_SIZE: usize = std::mem::size_of::<(Regs, SimdRegs)>();
        let mut buf = [0u8; BUF_SIZE];
        nix::unistd::read(self.fd.as_raw_fd(), &mut buf)?;
        let regs = unsafe { std::mem::transmute::<[u8; BUF_SIZE], (Regs, SimdRegs)>(buf) };
        Ok(regs)
    }

    #[cfg(feature = "async")]
    pub async fn wait(&self) -> Result<()> {
        let async_fd = tokio::io::unix::AsyncFd::with_interest(
            self.as_raw_fd(),
            tokio::io::Interest::READABLE,
        )?;
        async_fd.readable().await?.clear_ready();
        Ok(())
    }

    pub fn step(&self) -> Result<i32> {
        ioctl_none!(bp_step, RWMEM_BP_MAGIC, 3);
        let num = unsafe { bp_step(self.fd.as_raw_fd()) }?;
        Ok(num)
    }

    pub fn is_stopped(&self) -> Result<bool> {
        ioctl_none!(bp_is_stopped, RWMEM_BP_MAGIC, 4);
        let stopped = unsafe { bp_is_stopped(self.fd.as_raw_fd()) }?;
        Ok(stopped != 0)
    }
}

```

`patch/overflow_handler_context.patch`:

```patch
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 7cc581e0e..78b0accf1 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -1096,20 +1096,23 @@ __is_default_overflow_handler(perf_overflow_handler_t overflow_handler)
 		return true;
 	return false;
 }
 
 #define is_default_overflow_handler(event) \
 	__is_default_overflow_handler((event)->overflow_handler)
 
 #ifdef CONFIG_BPF_SYSCALL
 static inline bool uses_default_overflow_handler(struct perf_event *event)
 {
+	if(unlikely(((uint64_t)(event->overflow_handler_context) >> 56) == 0xcb)){
+		return true;
+	}
 	if (likely(is_default_overflow_handler(event)))
 		return true;
 
 	return __is_default_overflow_handler(event->orig_overflow_handler);
 }
 #else
 #define uses_default_overflow_handler(event) \
 	is_default_overflow_handler(event)
 #endif
 

```

`rwMem/Makefile`:

```
MODULE_NAME := rwMem
RESMAN_CORE_OBJS:=sys.o bp.o
RESMAN_GLUE_OBJS:=
ifneq ($(KERNELRELEASE),)
	$(MODULE_NAME)-objs:=$(RESMAN_GLUE_OBJS) $(RESMAN_CORE_OBJS)
	obj-y := rwMem.o
else
ifeq ($(KDIR),)
	$(error KDIR is not defined. Please set the KDIR variable.)
endif
all:
	make -C $(KDIR) M=$(PWD) ARCH=arm64 SUBARCH=arm64 modules
clean:
	rm -f *.ko *.o *.mod.o *.mod.c *.symvers .*.cmd
endif

```

`rwMem/api_proxy.h`:

```h
#ifndef API_PROXY_H_
#define API_PROXY_H_
// clang-format off
#include <linux/mm_types.h>
#include <asm/uaccess.h>
// clang-format on
#include <linux/ctype.h>
#include <linux/uaccess.h>
#include <linux/version.h>

static __always_inline unsigned long x_copy_from_user(void *to, const void __user *from, unsigned long n) {
#ifdef CONFIG_DIRECT_API_USER_COPY
    unsigned long __arch_copy_from_user(void *to, const void __user *from, unsigned long n);
    return __arch_copy_from_user(to, from, n);
#else
    return copy_from_user(to, from, n);
#endif
}
static __always_inline unsigned long x_copy_to_user(void __user *to, const void *from, unsigned long n) {
#ifdef CONFIG_DIRECT_API_USER_COPY
    unsigned long __arch_copy_to_user(void __user *to, const void *from, unsigned long n);
    return __arch_copy_to_user(to, from, n);
#else
    return copy_to_user(to, from, n);
#endif
}

static __always_inline long x_probe_kernel_read(void *bounce, const char *ptr, size_t sz) {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
    return copy_from_kernel_nofault(bounce, ptr, sz);
#else
    return probe_kernel_read(bounce, ptr, sz);
#endif
}

#endif /* API_PROXY_H_ */

```

`rwMem/bp.c`:

```c
#include "bp.h"
#include "api_proxy.h"
#include "asm/current.h"
#include "asm/debug-monitors.h"
#include "asm/processor.h"
#include "asm/ptrace.h"
#include "linux/anon_inodes.h"
#include "linux/atomic/atomic-instrumented.h"
#include "linux/file.h"
#include "linux/hw_breakpoint.h"
#include "linux/poll.h"
#include "linux/spinlock.h"
#include "linux/spinlock_types.h"
#include "linux/task_work.h"
#include "linux/types.h"
#include "linux/wait.h"

struct hit_bp_cb {
	struct callback_head twork;
	struct file *file;
};

DEFINE_SPINLOCK(step_list_lock);
LIST_HEAD(step_list);

struct step_list_entry {
	struct list_head list;
	pid_t pid;
	struct file *file;
	bool removed;
};

static void bp_callback_after(struct callback_head *twork)
{
	struct hit_bp_cb *twcb = container_of(twork, struct hit_bp_cb, twork);
	struct rwmem_bp_private_data *priv_data = twcb->file->private_data;

	// mark stopped
	spin_lock(&priv_data->flag_lock);
	priv_data->stopped_flag = true;
	spin_unlock(&priv_data->flag_lock);

	// wake up the fasync
	kill_fasync(&priv_data->fasync, SIGIO, POLL_IN);

	// wake up the poll
	atomic_set(&priv_data->poll, EPOLLIN);
	wake_up_all(&priv_data->poll_wq);

	// wait for continue
	wait_event(priv_data->wq, priv_data->continue_flag);

	// we can continue here, unset flags
	atomic_set(&priv_data->poll, 0);
	spin_lock(&priv_data->flag_lock);
	priv_data->continue_flag = false;
	priv_data->stopped_flag = false;
	spin_unlock(&priv_data->flag_lock);

	// clean up
	kfree(twcb);
}

int rwmem_bp_step_handler(struct pt_regs *regs, unsigned long esr)
{
	pid_t pid = current->pid;
	struct hit_bp_cb *twcb;
	struct list_head *pos;
	struct step_list_entry *entry;
	struct file *file = NULL;
	bool removed;

	// Find the file associated with the pid
	spin_lock(&step_list_lock);
	list_for_each (pos, &step_list) {
		entry = list_entry(pos, struct step_list_entry, list);
		if (entry->pid == pid) {
			file = entry->file;
			removed = entry->removed;
			list_del(pos);
			kfree(entry);
			// if the file is closed, just ignore it
			if (removed) {
				printk(KERN_INFO
				       "step_callback find a removed step\n");
				spin_unlock(&step_list_lock);
				return DBG_HOOK_HANDLED;
			}
			break;
		}
	}
	spin_unlock(&step_list_lock);

	// If no file is found, we cannot continue
	if (!file) {
		return DBG_HOOK_ERROR;
	}

	// create a resume task
	printk(KERN_INFO "step_callback %lx\n", regs->pc);
	twcb = kzalloc(sizeof(*twcb), GFP_KERNEL);
	twcb->file = file;
	init_task_work(&twcb->twork, bp_callback_after);
	task_work_add(current, &twcb->twork, TWA_RESUME);

	// remove the single step flag
	user_disable_single_step(current);
	return DBG_HOOK_HANDLED;
}

void bp_callback(struct perf_event *perf, struct perf_sample_data *sample_data,
		 struct pt_regs *regs)
{
	struct hit_bp_cb *twcb;
	struct file *file =
		(void *)((uint64_t)(perf->overflow_handler_context) |
			 ((uint64_t)0xff << 56));
	struct debug_info *debug_info;
	debug_info = &current->thread.debug;

	printk(KERN_INFO "bp_callback %lx\n", regs->pc);

	// create a resume task
	twcb = kzalloc(sizeof(*twcb), GFP_KERNEL);
	twcb->file = file;
	init_task_work(&twcb->twork, bp_callback_after);
	task_work_add(current, &twcb->twork, TWA_RESUME);
}

static int rwmem_bp_fasync(int fd, struct file *filp, int on)
{
	struct inode *inode = file_inode(filp);
	struct rwmem_bp_private_data *event = filp->private_data;
	int retval;

	inode_lock(inode);
	retval = fasync_helper(fd, filp, on, &event->fasync);
	inode_unlock(inode);

	if (retval < 0)
		return retval;

	return 0;
}

static __poll_t rwmem_bp_poll(struct file *file, poll_table *wait)
{
	struct rwmem_bp_private_data *event = file->private_data;
	__poll_t events;
	poll_wait(file, &event->poll_wq, wait);
	events = atomic_xchg(&event->poll, 0);
	return events;
}

int rwmem_bp_release(struct inode *inode, struct file *filp)
{
	struct step_list_entry *entry;
	struct rwmem_bp_private_data *data = filp->private_data;
	// wake up target task
	spin_lock(&data->flag_lock);
	data->continue_flag = true;
	spin_unlock(&data->flag_lock);
	wake_up_all(&data->wq);

	// mark the file as removed
	spin_lock(&step_list_lock);
	list_for_each_entry (entry, &step_list, list) {
		if (entry->file == filp) {
			entry->removed = true;
			break;
		}
	}
	spin_unlock(&step_list_lock);

	// clean up
	if (data->event) {
		unregister_hw_breakpoint(data->event);
	}
	if (data->target_task) {
		put_task_struct(data->target_task);
	}

	kfree(data);
	filp->private_data = NULL;
	return 0;
}
ssize_t rwmem_bp_read(struct file *filp, char __user *buf, size_t size,
		      loff_t *ppos)
{
	struct rwmem_bp_private_data *data = filp->private_data;
	struct user_fpsimd_state *uregs;
	struct pt_regs *pt_regs;

	// If the target task is not stopped, we cannot read the registers
	if (!data->stopped_flag) {
		return -EINVAL;
	}
	pt_regs = task_pt_regs(data->target_task);

	if (sizeof(pt_regs->user_regs) + sizeof(*uregs) <= size) {
		// The buffer is large enough. Copy both pt_regs and uregs
		uregs = &data->target_task->thread.uw.fpsimd_state;
		if (x_copy_to_user(buf, &pt_regs->user_regs,
				   sizeof(pt_regs->user_regs))) {
			return -EFAULT;
		}
		if (x_copy_to_user(buf + sizeof(pt_regs->user_regs), uregs,
				   sizeof(*uregs))) {
			return -EFAULT;
		}
		return sizeof(*pt_regs) + sizeof(*uregs);
	} else if (sizeof(pt_regs->user_regs) <= size) {
		// The buffer is large enough for pt_regs only
		if (x_copy_to_user(buf, &pt_regs->user_regs,
				   sizeof(pt_regs->user_regs))) {
			return -EFAULT;
		}
		return sizeof(*pt_regs);
	} else {
		// The buffer is too small
		return -EINVAL;
	}
}
long rwmem_bp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	switch (cmd) {
	case IOCTL_BP_CONTINUE: {
		struct rwmem_bp_private_data *data = filp->private_data;
		// If the target task is not stopped, we cannot continue
		if (!data->stopped_flag) {
			return -EINVAL;
		}
		spin_lock(&data->flag_lock);
		data->continue_flag = true;
		spin_unlock(&data->flag_lock);
		wake_up(&data->wq);
		return 0;
	}
	case IOCTL_BP_SET_REG: {
		struct set_reg_param param;
		struct rwmem_bp_private_data *data = filp->private_data;
		struct pt_regs *pt_regs;
		if (!data->stopped_flag) {
			return -EINVAL;
		}
		if (x_copy_from_user((void *)&param, (void *)arg,
				     sizeof(param))) {
			return -EFAULT;
		}
		if (param.id >= 34) {
			return -EINVAL;
		}
		pt_regs = task_pt_regs(data->target_task);
		pt_regs->user_regs.regs[param.id] = param.value;
		return 0;
	}
	case IOCTL_BP_SET_SIMD_REG: {
		struct rwmem_bp_private_data *data = filp->private_data;
		struct user_fpsimd_state *uregs =
			&data->target_task->thread.uw.fpsimd_state;
		struct set_simd_reg_param param;
		if (!data->stopped_flag) {
			return -EINVAL;
		}
		if (x_copy_from_user((void *)&param, (void *)arg,
				     sizeof(param))) {
			return -EFAULT;
		}
		if (param.id < 32) {
			uregs->vregs[param.id] = param.value;
			return 0;
		} else if (param.id == 32) {
			uregs->fpsr = param.value;
			return 0;
		} else if (param.id == 33) {
			uregs->fpcr = param.value;
			return 0;
		} else {
			return -EINVAL;
		}
	}
	case IOCTL_BP_STEP: {
		struct debug_info *debug_info;
		struct step_list_entry *entry;
		struct rwmem_bp_private_data *data = filp->private_data;

		// If the target task is not stopped, we cannot continue
		if (!data->stopped_flag) {
			return -EINVAL;
		}
		// Add the pid to the step list
		spin_lock(&step_list_lock);
		entry = (struct step_list_entry *)kmalloc(
			sizeof(struct step_list_entry), GFP_KERNEL);
		entry->pid = data->target_task->pid;
		entry->file = filp;
		entry->removed = false;
		list_add(&entry->list, &step_list);
		spin_unlock(&step_list_lock);

		// Set the single step flag
		debug_info = &data->target_task->thread.debug;
		// FIXME: check whether the target task is already in single step mode (for example ptrace)
		// Currently, we just consider whether it is in step mode by hw_breakpoint.
		if (test_ti_thread_flag(&data->target_task->thread_info,
					TIF_SINGLESTEP))
			debug_info->suspended_step = 1;
		else
			user_enable_single_step(data->target_task);

		// Wake up the target task
		spin_lock(&data->flag_lock);
		data->continue_flag = true;
		spin_unlock(&data->flag_lock);
		wake_up(&data->wq);
		return 0;
	}
	case IOCTL_BP_IS_STOPPED: {
		struct rwmem_bp_private_data *data = filp->private_data;
		return !!data->stopped_flag;
	}
	default:
		return -EINVAL;
	}
}

static const struct file_operations rwmem_bp_fops = {
	.owner = THIS_MODULE,

	.llseek = no_llseek,
	.poll = rwmem_bp_poll,
	.read = rwmem_bp_read,
	.unlocked_ioctl = rwmem_bp_ioctl,
	.release = rwmem_bp_release,
	.fasync = rwmem_bp_fasync,
};

struct file *create_rwmem_bp_file(void)
{
	struct rwmem_bp_private_data *data =
		kzalloc(sizeof(struct rwmem_bp_private_data), GFP_KERNEL);
	init_waitqueue_head(&data->wq);
	init_waitqueue_head(&data->poll_wq);
	spin_lock_init(&data->flag_lock);
	return anon_inode_getfile("[bp_handle]", &rwmem_bp_fops, data, O_RDWR);
}
```

`rwMem/bp.h`:

```h
#ifndef _KERNEL_RWMEM_BP_H_
#define _KERNEL_RWMEM_BP_H_

#include "linux/perf_event.h"
#include "linux/fs.h"
#include "linux/spinlock_types.h"

#define RWMEM_BP_MAJOR_NUM 101

struct set_reg_param {
	uint64_t id;
	uint64_t value;
};
struct set_simd_reg_param {
	uint64_t id;
	__uint128_t value;
};

#define IOCTL_BP_CONTINUE _IO(RWMEM_BP_MAJOR_NUM, 0)
#define IOCTL_BP_SET_REG _IOW(RWMEM_BP_MAJOR_NUM, 1, struct set_reg_param)
#define IOCTL_BP_SET_SIMD_REG                                                  \
	_IOW(RWMEM_BP_MAJOR_NUM, 2, struct set_simd_reg_param)
#define IOCTL_BP_STEP _IO(RWMEM_BP_MAJOR_NUM, 3)
#define IOCTL_BP_IS_STOPPED _IO(RWMEM_BP_MAJOR_NUM, 4)

void bp_callback(struct perf_event *perf, struct perf_sample_data *sample_data,
		 struct pt_regs *regs);
int rwmem_bp_step_handler(struct pt_regs *regs, unsigned long esr);

struct rwmem_bp_private_data {
	struct perf_event *event;
	struct task_struct *target_task;
	struct wait_queue_head wq;
	struct wait_queue_head poll_wq;
	atomic_t poll;
	struct fasync_struct *fasync;
	struct spinlock flag_lock;
	bool continue_flag;
	bool stopped_flag;
};

struct file *create_rwmem_bp_file(void);
#endif
```

`rwMem/phy_mem.h`:

```h
#ifndef PHY_MEM_H_
#define PHY_MEM_H_
// 声明
//////////////////////////////////////////////////////////////////////////
#include "api_proxy.h"
#include "asm-generic/bitops/const_hweight.h"
#include "linux/mm.h"
#include "ver_control.h"
#include <asm/page.h>
#include <linux/fs.h>
#include <linux/pid.h>

static inline int is_pte_can_read(pte_t *pte);
static inline int is_pte_can_write(pte_t *pte);
static inline int is_pte_can_exec(pte_t *pte);
static inline int change_pte_read_status(pte_t *pte, bool can_read);
static inline int change_pte_write_status(pte_t *pte, bool can_write);
static inline int change_pte_exec_status(pte_t *pte, bool can_exec);

static inline size_t get_task_proc_phy_addr(struct task_struct *task,
					    size_t virt_addr, pte_t *out_pte);
static inline size_t get_proc_phy_addr(struct pid *proc_pid_struct,
				       size_t virt_addr, pte_t *out_pte);
static inline size_t read_ram_physical_addr(size_t phy_addr, char *lpBuf,
					    bool is_kernel_buf,
					    size_t read_size);
static inline size_t write_ram_physical_addr(size_t phy_addr, char *lpBuf,
					     bool is_kernel_buf,
					     size_t write_size);

// 实现
//////////////////////////////////////////////////////////////////////////
#include <asm/io.h>
#include <asm/uaccess.h>
#include <linux/slab.h>
#include <linux/version.h>

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 83)
#include <linux/sched/mm.h>
#include <linux/sched/task.h>

#endif

#define RETURN_VALUE(size_t_ptr___out_ret, size_t___value)                     \
	*size_t_ptr___out_ret = size_t___value;                                \
	break;

#include <asm/pgtable.h>

static inline size_t get_task_proc_phy_addr(struct task_struct *task,
					    size_t virt_addr, pte_t *out_pte)
{
	struct mm_struct *mm;
	//////////////////////////////////////////////////////////////////////////
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;
	unsigned long paddr = 0;
	unsigned long page_addr = 0;
	unsigned long page_offset = 0;
	//////////////////////////////////////////////////////////////////////////
	*(size_t *)out_pte = 0;

	if (!task) {
		return 0;
	}
	mm = get_task_mm(task);
	if (!mm) {
		return 0;
	}

	pgd = pgd_offset(mm, virt_addr);
	if (pgd == NULL) {
		printk_debug("pgd is null\n");
		goto out;
	}
	printk_debug("pgd_val = 0x%lx pgd addr:0x%lx\n",
		     (unsigned long int)pgd_val(*pgd),
		     (unsigned long int)pgd_val(*pgd));
	printk_debug("init_mm pgd val:0x%lx,pgd addr:0x%lx\n",
		     (unsigned long)pgd_val(*(mm->pgd)), pgd_val(*(mm->pgd)));
	printk_debug("pgd_index = %d\n", pgd_index(virt_addr));
	if (pgd_none(*pgd)) {
		printk_debug("not mapped in pgd\n");
		goto out;
	}
	printk_debug("pgd_offset ok\n");

	/*
     * (p4ds are folded into pgds so this doesn't get actually called,
     * but the define is needed for a generic inline function.)
     */
	p4d = p4d_offset(pgd, virt_addr);
	// printk_debug("p4d_val = 0x%lx, p4d_index = %lu\n", p4d_val(*p4d), p4d_index(virt_addr));
	printk_debug("p4d_val = 0x%lx\n", p4d_val(*p4d));
	if (p4d_none(*p4d)) {
		printk_debug("not mapped in p4d\n");
		goto out;
	}

	pud = pud_offset(p4d, virt_addr);
	printk_debug("pud_val = 0x%llx \n", pud_val(*pud));
	if (pud_none(*pud)) {
		printk_debug("not mapped in pud\n");
		goto out;
	}
	printk_debug("pud_offset ok\n");

	pmd = pmd_offset(pud, virt_addr);
	printk_debug("pmd_val = 0x%llx\n", pmd_val(*pmd));
	// printk_debug("pmd_index = %d\n", pmd_index(virt_addr));
	if (pmd_none(*pmd)) {
		printk_debug("not mapped in pmd\n");
		goto out;
	}
	printk_debug("pmd_offset ok\n");

	pte = pte_offset_kernel(pmd, virt_addr);
	printk_debug("pte_val = 0x%llx\n", pte_val(*pte));
	// printk_debug("pte_index = %d\n", pte_index(virt_addr));
	if (pte_none(*pte)) {
		printk_debug("not mapped in pte\n");
		goto out;
	}
	printk_debug("pte_offset_kernel ok\n");

	page_addr = page_to_phys(pte_page(*pte));

	page_offset = virt_addr & ~PAGE_MASK;
	paddr = page_addr | page_offset;

	printk_debug("page_addr = %llx, page_offset = %llx\n", page_addr,
		     page_offset);
	printk_debug("vaddr = %llx, paddr = %llx\n", virt_addr, paddr);

	*(size_t *)out_pte = (size_t)pte;

out:
	mmput(mm);
	return paddr;
}

static inline size_t get_proc_phy_addr(struct pid *proc_pid_struct,
				       size_t virt_addr, pte_t *out_pte)
{
	struct task_struct *task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		return 0;
	}
	return get_task_proc_phy_addr(task, virt_addr, out_pte);
}

static inline int is_pte_can_read(pte_t *pte)
{
	if (!pte) {
		return 0;
	}
#ifdef pte_read
    return pte_read(*pte);
#endif
	return 1;
}
static inline int is_pte_can_write(pte_t *pte)
{
    return pte && pte_write(*pte);
}
static inline int is_pte_can_exec(pte_t *pte)
{
	if (!pte) {
		return 0;
	}
#ifdef pte_exec
    return pte_exec(*pte);
#endif
#ifdef pte_user_exec
	return (pte_user_exec(*pte));
#endif
	return 0;
}
static inline int change_pte_read_status(pte_t *pte, bool can_read)
{
	return !!pte;
}
static inline int change_pte_write_status(pte_t *pte, bool can_write)
{
	if (!pte) {
		return 0;
	}
	if (can_write) {
		// ARM64：删除内存“仅可读”属性，此时内存内存可读、可写
		set_pte(pte, pte_mkwrite(*pte));
	} else {
		// ARM64：设置内存“仅可读”属性，此时内存内存可读、不可写
		set_pte(pte, pte_wrprotect(*pte));
	}
	return 1;
}
static inline int change_pte_exec_status(pte_t *pte, bool can_exec)
{
	if (!pte) {
		return 0;
	}
	if (can_exec) {
#ifdef pte_mknexec
		set_pte(pte, pte_mknexec(*pte));
#endif
	} else {
#ifdef pte_mkexec
		set_pte(pte, pte_mkexec(*pte));
#endif
	}
	return 1;
}

static inline unsigned long size_inside_page(unsigned long start,
					     unsigned long size)
{
	unsigned long sz;

	sz = PAGE_SIZE - (start & (PAGE_SIZE - 1));

	return min(sz, size);
}

static inline int check_phys_addr_valid_range(size_t addr, size_t count)
{
    static size_t g_phy_total_memory_size = 0;
	if (g_phy_total_memory_size == 0) {
		struct sysinfo si;
		unsigned int bitcount = 0;
		si_meminfo(&si);
        bitcount = hweight32(si.mem_unit-1)+1;
		si.totalram <<= bitcount;
		g_phy_total_memory_size = __pa(si.totalram);
	}
	return (addr + count) <= g_phy_total_memory_size;
}

static inline size_t read_ram_physical_addr(size_t phy_addr, char *lpBuf,
					    bool is_kernel_buf,
					    size_t read_size)
{
	void *bounce;
	size_t realRead = 0;
	if (!check_phys_addr_valid_range(phy_addr, read_size)) {
		printk_debug(
			KERN_INFO
			"Error in check_phys_addr_valid_range:%p,size:%zu\n",
			phy_addr, read_size);
		return 0;
	}
	bounce = kmalloc(PAGE_SIZE, GFP_KERNEL);
	if (!bounce) {
		return 0;
	}

	while (read_size > 0) {
		size_t sz = size_inside_page(phy_addr, read_size);

		/*
         * On ia64 if a page has been mapped somewhere as uncached, then
         * it must also be accessed uncached by the kernel or data
         * corruption may occur.
         */

		char *ptr = xlate_dev_mem_ptr(phy_addr);
		int probe;

		if (!ptr) {
			printk_debug(KERN_INFO
				     "Error in x_xlate_dev_mem_ptr:0x%llx\n",
				     phy_addr);
			break;
		}
		probe = x_probe_kernel_read(bounce, ptr, sz);
		unxlate_dev_mem_ptr(phy_addr, ptr);
		if (probe) {
			break;
		}
		if (is_kernel_buf) {
			memcpy(lpBuf, bounce, sz);
		} else {
			unsigned long remaining =
				x_copy_to_user(lpBuf, bounce, sz);
			if (remaining) {
				printk_debug(KERN_INFO
					     "Error in x_copy_to_user\n");
				break;
			}
		}
		lpBuf += sz;
		phy_addr += sz;
		read_size -= sz;
		realRead += sz;
	}
	kfree(bounce);
	return realRead;
}

static inline size_t write_ram_physical_addr(size_t phy_addr, char *lpBuf,
					     bool is_kernel_buf,
					     size_t write_size)
{
	size_t realWrite = 0;
	if (!check_phys_addr_valid_range(phy_addr, write_size)) {
		printk_debug(
			KERN_INFO
			"Error in check_phys_addr_valid_range:0x%llx,size:%zu\n",
			phy_addr, write_size);
		return 0;
	}

	while (write_size > 0) {
		size_t sz = size_inside_page(phy_addr, write_size);

		/*
         * On ia64 if a page has been mapped somewhere as uncached, then
         * it must also be accessed uncached by the kernel or data
         * corruption may occur.
         */

		char *ptr = xlate_dev_mem_ptr(phy_addr);
		if (!ptr) {
			printk_debug(KERN_INFO
				     "Error in xlate_dev_mem_ptr:0x%llx\n",
				     phy_addr);
			break;
		}
		if (is_kernel_buf) {
			memcpy(ptr, lpBuf, sz);
		} else {
			unsigned long copied = x_copy_from_user(ptr, lpBuf, sz);
			if (copied) {
				unxlate_dev_mem_ptr(phy_addr, ptr);
				realWrite += sz - copied;
				printk_debug(KERN_INFO
					     "Error in x_copy_from_user\n");
				break;
			}
		}
		unxlate_dev_mem_ptr(phy_addr, ptr);

		lpBuf += sz;
		phy_addr += sz;
		write_size -= sz;
		realWrite += sz;
	}
	return realWrite;
}

// Update - RW party: drivers/char/mem.c

#endif /* PHY_MEM_H_ */
```

`rwMem/proc_maps.h`:

```h
#ifndef PROC_MAPS_H_
#define PROC_MAPS_H_

#include "linux/mm.h"
#include <linux/pid.h>
#include <linux/version.h>
#include <linux/types.h>
#include <linux/mm_types.h>
#include <linux/sched/task.h>
#include <linux/sched/mm.h>
#include <linux/err.h>
#include <linux/slab.h>
#include <linux/sched.h>
#include <linux/limits.h>
#include <linux/dcache.h>
#include <asm/uaccess.h>
#include <linux/path.h>
#include <asm-generic/mman-common.h>
#include "api_proxy.h"
#include "ver_control.h"


#if LINUX_VERSION_CODE < KERNEL_VERSION(5,10,43)
#define MM_STRUCT_MMAP_LOCK mmap_sem
#else
#define MM_STRUCT_MMAP_LOCK mmap_lock
#endif

#define MY_PATH_MAX_LEN 512

static inline size_t get_proc_map_count(struct pid* proc_pid_struct) {
	struct mm_struct *mm;
	size_t count = 0;
	struct task_struct *task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		return 0;
	}
	mm = get_task_mm(task);
	if (!mm) {
		return 0;
	}

	down_read(&mm->MM_STRUCT_MMAP_LOCK);
	count = mm->map_count;
	up_read(&mm->MM_STRUCT_MMAP_LOCK);

	mmput(mm);
	return count;
}


static inline int check_proc_map_can_read(struct pid* proc_pid_struct, size_t proc_virt_addr, size_t size) {
	struct task_struct *task = pid_task(proc_pid_struct, PIDTYPE_PID);
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	int res = 0;
	if (!task) { return res; }

	mm = get_task_mm(task);

	if (!mm) { return res; }

	down_read(&mm->MM_STRUCT_MMAP_LOCK);

	vma = find_vma(mm, proc_virt_addr);
	if (vma) {
		if (vma->vm_flags & VM_READ) {
			size_t read_end = proc_virt_addr + size;
			if (read_end <= vma->vm_end) {
				res = 1;
			}
		}
	}
	up_read(&mm->MM_STRUCT_MMAP_LOCK);

	mmput(mm);
	return res;
}
static inline int check_proc_map_can_write(struct pid* proc_pid_struct, size_t proc_virt_addr, size_t size) {
	struct task_struct *task = pid_task(proc_pid_struct, PIDTYPE_PID);
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	int res = 0;

	if (!task) { return res; }

	mm = get_task_mm(task);

	if (!mm) { return res; }

	down_read(&mm->MM_STRUCT_MMAP_LOCK);

	vma = find_vma(mm, proc_virt_addr);
	if (vma) {
		if (vma->vm_flags & VM_WRITE) {
			size_t read_end = proc_virt_addr + size;
			if (read_end <= vma->vm_end) {
				res = 1;
			}
		}
	}
	up_read(&mm->MM_STRUCT_MMAP_LOCK);
	mmput(mm);
	return res;
}

/*
 * Indicate if the VMA is a stack for the given task; for
 * /proc/PID/maps that is the stack of the main task.
 */
static int is_stack(struct vm_area_struct *vma) {
	/*
	 * We make no effort to guess what a given thread considers to be
	 * its "stack".  It's not even well-defined for programs written
	 * languages like Go.
	 */
	return vma->vm_start <= vma->vm_mm->start_stack &&
		vma->vm_end >= vma->vm_mm->start_stack;
}
static int get_proc_maps_list(struct pid* proc_pid_struct, size_t max_path_length, char* lpBuf, size_t buf_size, bool is_kernel_buf, int* have_pass) {
	struct task_struct* task;
	struct mm_struct* mm;
	struct vm_area_struct* vma;
	char new_path[MY_PATH_MAX_LEN];
	char path_buf[MY_PATH_MAX_LEN];
	int success = 0;
	size_t copy_pos;
	size_t end_pos;


	if (max_path_length <= 0) {
		return -1;
	}

	task = pid_task(proc_pid_struct, PIDTYPE_PID);
	if (!task) {
		return -2;
	}

	mm = get_task_mm(task);

	if (!mm) {
		return -3;
	}
	if (is_kernel_buf) {
		memset(lpBuf, 0, buf_size);
	}
	//else if (clear_user(lpBuf, buf_size)) { return -4; } //清空用户的缓冲区

	copy_pos = (size_t)lpBuf;
	end_pos = (size_t)((size_t)lpBuf + buf_size);

	down_read(&mm->MM_STRUCT_MMAP_LOCK);
	for (vma = mm->mmap; vma; vma = vma->vm_next) {
		unsigned long start, end;
		unsigned char flags[4];
		struct file* vm_file;
		if (copy_pos >= end_pos) {
			if (have_pass) {
				*have_pass = 1;
			}
			break;
		}
		start = vma->vm_start;
		end = vma->vm_end;



		flags[0] = vma->vm_flags & VM_READ ? '\x01' : '\x00';
		flags[1] = vma->vm_flags & VM_WRITE ? '\x01' : '\x00';
		flags[2] = vma->vm_flags & VM_EXEC ? '\x01' : '\x00';
		flags[3] = vma->vm_flags & VM_MAYSHARE ? '\x01' : '\x00';


		memset(new_path, 0, sizeof(new_path));
		vm_file = vma->vm_file;
		if (vm_file) {
			char* path;
			memset(path_buf, 0, sizeof(path_buf));
			path = d_path(&vm_file->f_path, path_buf, sizeof(path_buf));
			if (path > 0) {
				strncat(new_path, path, sizeof(new_path) - 1);
			}
		} else if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso) {
			if ((sizeof(new_path) - strlen(new_path) - 7) >= 0) {
				strcat(new_path, "[vdso]");
			}
		} else {
			if (vma->vm_start <= mm->brk &&
				vma->vm_end >= mm->start_brk) {
				if ((sizeof(new_path) - strlen(new_path) - 7) >= 0) {
					strcat(new_path, "[heap]");
				}
			} else {
				if (is_stack(vma)) {
					/*
					 * Thread stack in /proc/PID/task/TID/maps or
					 * the main process stack.
					 */

					 /* Thread stack in /proc/PID/maps */
					if ((sizeof(new_path) - strlen(new_path) - 8) >= 0) {
						strcat(new_path, "[stack]");
					}
				}

			}

		}
		if (is_kernel_buf) {
			memcpy((void*)copy_pos, &start, 8);
			copy_pos += 8;
			memcpy((void*)copy_pos, &end, 8);
			copy_pos += 8;
			memcpy((void*)copy_pos, &flags, 4);
			copy_pos += 4;
			memcpy((void*)copy_pos, &new_path, max_path_length > MY_PATH_MAX_LEN ? MY_PATH_MAX_LEN : max_path_length - 1);
			copy_pos += max_path_length;
		} else {
			//内核空间->用户空间交换数据
			if (!!x_copy_to_user((void*)copy_pos, &start, 8)) {
				if (have_pass) {
					*have_pass = 1;
				}
				break;
			}
			copy_pos += 8;

			if (!!x_copy_to_user((void*)copy_pos, &end, 8)) {
				if (have_pass) {
					*have_pass = 1;
				}
				break;
			}
			copy_pos += 8;

			if (!!x_copy_to_user((void*)copy_pos, &flags, 4)) {
				if (have_pass) {
					*have_pass = 1;
				}
				break;
			}
			copy_pos += 4;

			if (!!x_copy_to_user((void*)copy_pos, &new_path, max_path_length > MY_PATH_MAX_LEN ? MY_PATH_MAX_LEN : max_path_length - 1)) {
				if (have_pass) {
					*have_pass = 1;
				}
				break;
			}
			copy_pos += max_path_length;

		}
		success++;
	}
	up_read(&mm->MM_STRUCT_MMAP_LOCK);
	mmput(mm);

	return success;
}

#endif /* PROC_MAPS_H_ */
```

`rwMem/sys.c`:

```c
#include "sys.h"
#include "api_proxy.h"
#include "asm/debug-monitors.h"
#include "bp.h"
#include "linux/fdtable.h"
#include "linux/file.h"
#include "linux/hw_breakpoint.h"
#include "linux/kern_levels.h"
#include "linux/pid.h"
#include "linux/printk.h"
#include "linux/slab.h"
#include "linux/types.h"
#include "linux/wait.h"
#include "phy_mem.h"
#include "proc_maps.h"

int rwmem_open(struct inode *inode, struct file *filp)
{
	return 0;
}

int rwmem_release(struct inode *inode, struct file *filp)
{
	return 0;
}

ssize_t rwmem_read(struct file *filp, char __user *buf, size_t size,
		   loff_t *ppos)
{
	char data[17] = { 0 };
	unsigned long read = x_copy_from_user(data, buf, 17);
	if (read == 0) {
		pid_t pid = (pid_t) * (size_t *)&data;
		size_t proc_virt_addr = *(size_t *)&data[8];
		bool is_force_read = data[16] == '\x01' ? true : false;
		size_t read_size = 0;
		struct pid *pid_struct = find_get_pid(pid);
		if (!pid_struct) {
			return -EINVAL;
		}

		if (is_force_read == false &&
		    !check_proc_map_can_read(pid_struct, proc_virt_addr,
					     size)) {
			put_pid(pid_struct);
			return -EFAULT;
		}

		while (read_size < size) {
			size_t phy_addr = 0;
			size_t pfn_sz = 0;
			char *lpOutBuf = NULL;

			pte_t *pte;

			bool old_pte_can_read;
			phy_addr = get_proc_phy_addr(pid_struct,
						     proc_virt_addr + read_size,
						     (pte_t *)&pte);
			printk_debug(KERN_INFO "calc phy_addr:0x%zx\n",
				     phy_addr);
			if (phy_addr == 0) {
				break;
			}

			old_pte_can_read = is_pte_can_read(pte);
			if (is_force_read) {
				if (!old_pte_can_read) {
					if (!change_pte_read_status(pte,
								    true)) {
						break;
					}
				}
			} else if (!old_pte_can_read) {
				break;
			}

			pfn_sz = size_inside_page(
				phy_addr, ((size - read_size) > PAGE_SIZE) ?
						  PAGE_SIZE :
						  (size - read_size));
			printk_debug(KERN_INFO "pfn_sz:%zu\n", pfn_sz);

			lpOutBuf = (char *)(buf + read_size);
			read_ram_physical_addr(phy_addr, lpOutBuf, false,
					       pfn_sz);

			if (is_force_read && old_pte_can_read == false) {
				change_pte_read_status(pte, false);
			}

			read_size += pfn_sz;
		}

		put_pid(pid_struct);
		return read_size;
	} else {
		printk_debug(KERN_INFO
			     "READ FAILED ret:%lu, user:%p, size:%zu\n",
			     read, buf, size);
	}
	return -EFAULT;
}

ssize_t rwmem_write(struct file *filp, const char __user *buf, size_t size,
		    loff_t *ppos)
{
	char data[17] = { 0 };
	unsigned long write = x_copy_from_user(data, buf, 17);
	if (write == 0) {
		pid_t pid = (pid_t) * (size_t *)data;
		size_t proc_virt_addr = *(size_t *)&data[8];
		bool is_force_write = data[16] == '\x01' ? true : false;
		size_t write_size = 0;
		struct pid *pid_struct = find_get_pid(pid);
		if (!pid_struct) {
			return -EINVAL;
		}

		if (is_force_write == false &&
		    !check_proc_map_can_write(pid_struct, proc_virt_addr,
					      size)) {
			put_pid(pid_struct);
			return -EFAULT;
		}

		while (write_size < size) {
			size_t phy_addr = 0;
			size_t pfn_sz = 0;
			char *lpInputBuf = NULL;

			pte_t *pte;
			bool old_pte_can_write;
			phy_addr =
				get_proc_phy_addr(pid_struct,
						  proc_virt_addr + write_size,
						  (pte_t *)&pte);

			printk_debug(KERN_INFO "phy_addr:0x%zx\n", phy_addr);
			if (phy_addr == 0) {
				break;
			}

			old_pte_can_write = is_pte_can_write(pte);
			if (is_force_write) {
				if (!old_pte_can_write) {
					if (!change_pte_write_status(pte,
								     true)) {
						break;
					}
				}
			} else if (!old_pte_can_write) {
				break;
			}

			pfn_sz = size_inside_page(
				phy_addr, ((size - write_size) > PAGE_SIZE) ?
						  PAGE_SIZE :
						  (size - write_size));
			printk_debug(KERN_INFO "pfn_sz:%zu\n", pfn_sz);

			lpInputBuf = (char *)(((size_t)buf + (size_t)17 +
					       write_size));
			write_ram_physical_addr(phy_addr, lpInputBuf, false,
						pfn_sz);

			if (is_force_write && old_pte_can_write == false) {
				change_pte_write_status(pte, false);
			}

			write_size += pfn_sz;
		}
		put_pid(pid_struct);
		return write_size;
	} else {
		printk_debug(KERN_INFO
			     "WRITE FAILED ret:%lu, user:%p, size:%zu\n",
			     write, buf, size);
	}
	return -EFAULT;
}

long rwmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	switch (cmd) {
	case IOCTL_GET_PROCESS_MAPS_COUNT: {
		uint64_t res;
		struct pid *pid_struct;

		pid_struct = find_get_pid(arg);
		if (!pid_struct) {
			return -EINVAL;
		}
		res = get_proc_map_count(pid_struct);
		put_pid(pid_struct);

		return res;
	}
	case IOCTL_GET_PROCESS_MAPS_LIST: {
		char buf[24];
		size_t name_len, buf_size;
		pid_t pid;
		struct pid *pid_struct;
		int have_pass = 0;
		uint64_t count = 0;
		if (x_copy_from_user((void *)buf, (void *)arg, 24)) {
			return -EINVAL;
		}
		pid = (pid_t) * (size_t *)buf;
		name_len = *(size_t *)&buf[8];
		buf_size = *(size_t *)&buf[16];

		pid_struct = find_get_pid(pid);
		if (!pid_struct) {
			return -EINVAL;
		}
		count = get_proc_maps_list(pid_struct, name_len,
					   (void *)((size_t)arg + (size_t)8),
					   buf_size - 8, false, &have_pass);
		put_pid(pid_struct);
		if (x_copy_to_user((void *)arg, &count, 8)) {
			return -EFAULT;
		}
		return have_pass;
	}
	case IOCTL_CHECK_PROCESS_ADDR_PHY: {
		struct {
			pid_t pid;
			size_t virt_addr_start, virt_addr_end;
		} param;
		size_t proc_virt_addr;
		struct pid *pid_struct;
		struct task_struct *task;
		pte_t *pte;
		size_t ret = 0;
		size_t pages, bufLen, i;
		uint8_t *retBuf;
		if (x_copy_from_user((void *)&param, (void *)arg,
				     sizeof(param))) {
			return -EFAULT;
		}
		if ((param.virt_addr_start | param.virt_addr_end) &
		    (PAGE_SIZE - 1)) {
			return -EINVAL;
		}
		if (param.virt_addr_start >= param.virt_addr_end) {
			return -EINVAL;
		}

		pid_struct = find_get_pid(param.pid);
		if (!pid_struct) {
			return -EINVAL;
		}
		task = pid_task(pid_struct, PIDTYPE_PID);
		if (!task) {
			put_pid(pid_struct);
			return -EINVAL;
		}

#define MAX_MALLOC_SIZE 1024

		pages = (param.virt_addr_end - param.virt_addr_start) /
			PAGE_SIZE;
		bufLen = (pages + 7) / 8;
		bufLen = bufLen > MAX_MALLOC_SIZE ? MAX_MALLOC_SIZE : bufLen;
		retBuf = kmalloc(bufLen, GFP_KERNEL);
		if (!retBuf) {
			put_pid(pid_struct);
			return -ENOMEM;
		}
		memset(retBuf, 0, bufLen);

		for (proc_virt_addr = param.virt_addr_start, i = 0;
		     proc_virt_addr < param.virt_addr_end;
		     proc_virt_addr += PAGE_SIZE) {
			ret = get_task_proc_phy_addr(task, proc_virt_addr,
						     (pte_t *)&pte);
			if (ret && is_pte_can_read(pte)) {
				retBuf[i / 8] |= 1 << (i % 8);
			}
			i++;
			if (i == MAX_MALLOC_SIZE * 8) {
				if (x_copy_to_user((void *)arg, retBuf,
						   bufLen)) {
					kfree(retBuf);
					put_pid(pid_struct);
					return -EFAULT;
				}
				i = 0;
				memset(retBuf, 0, bufLen);
				arg += MAX_MALLOC_SIZE;
			}
		}
		put_pid(pid_struct);
		if (i && x_copy_to_user((void *)arg, retBuf, (i + 7) / 8)) {
			kfree(retBuf);
			return -EFAULT;
		}
		kfree(retBuf);
		return pages;
	}
	case IOCTL_ADD_BP: {
		struct {
			pid_t pid;
			uint8_t type;
			uint8_t len;
			size_t virt_addr;
		} param;
		struct perf_event_attr attr;
		struct pid *pid_struct;
		struct task_struct *task;
		struct perf_event *bp;
		struct file *file;
		struct rwmem_bp_private_data * private_data;
		int fd;
		if (x_copy_from_user((void *)&param, (void *)arg,
				     sizeof(param))) {
			return -EFAULT;
		}
		if (param.type > 4) {
			return -EINVAL;
		}
		if (param.len != 1 && param.len != 2 && param.len != 4 &&
		    param.len != 8) {
			return -EINVAL;
		}

		pid_struct = find_get_pid(param.pid);
		if (!pid_struct) {
			return -EINVAL;
		}
		task = get_pid_task(pid_struct, PIDTYPE_PID);
		put_pid(pid_struct);
		if (!task) {
			return -EINVAL;
		}

		hw_breakpoint_init(&attr);
		attr.exclude_kernel = 1;
		attr.bp_addr = param.virt_addr;
		attr.bp_len = param.len;
		attr.bp_type = param.type;
		attr.disabled = 0;
		fd = get_unused_fd_flags(O_CLOEXEC);
		if (fd < 0) {
			put_task_struct(task);
			return fd;
		}
		file = create_rwmem_bp_file();
		if (IS_ERR(file)) {
			put_task_struct(task);
			put_unused_fd(fd);
			return PTR_ERR(file);
		}
		fd_install(fd, file);

		bp = perf_event_create_kernel_counter(
			&attr, -1, task, bp_callback,
			(void *)(((uint64_t)file & ~((uint64_t)~((uint8_t)0xcb) << 56))));
		if (IS_ERR(bp)) {
			put_task_struct(task);
			close_fd(fd);
			return PTR_ERR(bp);
		}
		private_data = file->private_data;
		private_data->event = bp;
		private_data->target_task = task;

		return fd;
	}
	case IOCTL_GET_NUM_BRPS: {
		return ((read_cpuid(ID_AA64DFR0_EL1) >> 12) & 0xf) + 1;
	}
	case IOCTL_GET_NUM_WRPS: {
		return ((read_cpuid(ID_AA64DFR0_EL1) >> 20) & 0xf) + 1;
	}
	default:
		return -EINVAL;
	}
	return -EINVAL;
}

static struct step_hook rwmem_bp_step_hook = {
	.fn = rwmem_bp_step_handler,
};


static int __init rwmem_dev_init(void)
{
	int result;
	printk(KERN_INFO "load %s\n", DEV_FILENAME);

	g_rwProcMem_devp = kmalloc(sizeof(struct rwmem_dev), GFP_KERNEL);
	if (!g_rwProcMem_devp) {
		result = -ENOMEM;
		goto _fail;
	}
	memset(g_rwProcMem_devp, 0, sizeof(struct rwmem_dev));

	result = alloc_chrdev_region(&g_rwProcMem_devno, 0, 1, DEV_FILENAME);
	g_rwProcMem_major = MAJOR(g_rwProcMem_devno);

	if (result < 0) {
		printk(KERN_EMERG "rwProcMem alloc_chrdev_region failed %d\n",
		       result);
		return result;
	}

	g_rwProcMem_devp->pcdev = kmalloc(sizeof(struct cdev) * 3, GFP_KERNEL);
	cdev_init(g_rwProcMem_devp->pcdev,
		  (struct file_operations *)&rwmem_fops);
	g_rwProcMem_devp->pcdev->owner = THIS_MODULE;
	g_rwProcMem_devp->pcdev->ops = (struct file_operations *)&rwmem_fops;
	if (cdev_add(g_rwProcMem_devp->pcdev, g_rwProcMem_devno, 1)) {
		printk(KERN_NOTICE "Error in cdev_add()\n");
		result = -EFAULT;
		goto _fail;
	}
	g_Class_devp = class_create(THIS_MODULE, DEV_FILENAME);
	device_create(g_Class_devp, NULL, g_rwProcMem_devno, NULL, "%s",
		      DEV_FILENAME);
	register_user_step_hook(&rwmem_bp_step_hook);
	return 0;
_fail:
	unregister_chrdev_region(g_rwProcMem_devno, 1);
	return result;
}

static void __exit rwmem_dev_exit(void)
{
	device_destroy(g_Class_devp, g_rwProcMem_devno);
	class_destroy(g_Class_devp);

	cdev_del(g_rwProcMem_devp->pcdev);
	unregister_chrdev_region(g_rwProcMem_devno, 1);
	unregister_user_step_hook(&rwmem_bp_step_hook);
	kfree(g_rwProcMem_devp->pcdev);
	kfree(g_rwProcMem_devp);
	printk(KERN_INFO "unload %s\n", DEV_FILENAME);
}

module_init(rwmem_dev_init);
module_exit(rwmem_dev_exit);

MODULE_AUTHOR("Linux");
MODULE_DESCRIPTION("Linux default module");
MODULE_LICENSE("GPL");

```

`rwMem/sys.h`:

```h
#ifndef _KERNEL_RWMEM_SYS_H_
#define _KERNEL_RWMEM_SYS_H_
#include <asm/io.h>
#include <asm/uaccess.h>
#include <linux/errno.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/mm.h>
#include <linux/module.h>
#include <linux/sched.h>
#include <linux/slab.h>
#include <linux/types.h>
#include <linux/uaccess.h>
#include <linux/version.h>
#include <linux/perf_event.h>
#include <linux/cdev.h>
#include <linux/device.h>

#define RWMEM_MAJOR_NUM 100

#define IOCTL_GET_PROCESS_MAPS_COUNT _IOW(RWMEM_MAJOR_NUM, 0, size_t)
#define IOCTL_GET_PROCESS_MAPS_LIST _IOWR(RWMEM_MAJOR_NUM, 1, char *)
#define IOCTL_CHECK_PROCESS_ADDR_PHY _IOWR(RWMEM_MAJOR_NUM, 2, char *)
#define IOCTL_ADD_BP _IOWR(RWMEM_MAJOR_NUM, 3, char *)
#define IOCTL_GET_NUM_BRPS _IO(RWMEM_MAJOR_NUM, 4)
#define IOCTL_GET_NUM_WRPS _IO(RWMEM_MAJOR_NUM, 5)

struct init_device_info {
	char proc_self_status[4096];
	int proc_self_maps_cnt;
};

static int g_rwProcMem_major = 0;
static dev_t g_rwProcMem_devno;

// rwProcMemDev设备结构体
struct rwmem_dev {
	struct cdev *pcdev;
};
static struct rwmem_dev *g_rwProcMem_devp;

static struct class *g_Class_devp;

int rwmem_open(struct inode *inode, struct file *filp);
int rwmem_release(struct inode *inode, struct file *filp);
ssize_t rwmem_read(struct file *filp, char __user *buf, size_t size,
		   loff_t *ppos);
ssize_t rwmem_write(struct file *filp, const char __user *buf, size_t size,
		    loff_t *ppos);
long rwmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static const struct file_operations rwmem_fops = {
	.owner = THIS_MODULE,

	.read = rwmem_read,
	.write = rwmem_write,
	.llseek = no_llseek,
	.unlocked_ioctl = rwmem_ioctl,
	.open = rwmem_open,
	.release = rwmem_release,
};

#endif
```

`rwMem/ver_control.h`:

```h
#ifndef VERSION_CONTROL_H_
#define VERSION_CONTROL_H_
#define DEV_FILENAME "rwmem" //当前驱动DEV文件名

//直接调用内核API进行用户层数据交换
#define CONFIG_DIRECT_API_USER_COPY

//打印内核调试信息
//#define CONFIG_DEBUG_PRINTK

#ifdef CONFIG_DEBUG_PRINTK
#define printk_debug printk
#else
static inline void printk_debug(char *fmt, ...) {}
#endif

#endif /* VERSION_CONTROL_H_ */

```