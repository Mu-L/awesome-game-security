Project Path: arc_walzer_game-engine-detector_7fon5_17

Source Tree:

```txt
arc_walzer_game-engine-detector_7fon5_17
├── README.md
├── common.py
├── config.json
├── detector.py
├── lib
│   ├── 7z-mac
│   │   └── 7zz
│   └── 7z-win
│       └── 7z.dll
├── main.py
└── packages

```

`README.md`:

```md
game-engine-detector
====================

Automatically detect which game engine is an .apk or .ipa using.

## Usage

### For Mac users

1. Put all ipa and apk files to `packages` folder
2. open terminal and enter `game-engine-detector` folder
3. Execute `main.py`

```
    $ python main.py
```

### For Windows users

1. Install python2.7 from [python-2.7.6](https://www.python.org/ftp/python/2.7.6/python-2.7.6.msi)

2. Put all ipa and apk files to `packages` folder
3. Open windows commandline tool (cmd.exe), enter `game-engine-detector` folder
4. Execute `main.py`

```
    > python main.py
        
```
```

`common.py`:

```py
#!/usr/bin/env python
#coding=utf-8
import json
import re
import os
import subprocess
import platform

def to_unix_path(path):
    return path.replace('\\', '/')

def normalize_utf8_path(path, index):
    dir = os.path.split(path)[0]
    ext = os.path.splitext(path)[1]
    new_path = os.path.join(dir, str(index) + ext)
    return new_path

def unzip_package(file_path, out_dir, seven_zip_path=None):
    if not seven_zip_path:
        os_name = platform.system().lower()
        if os_name == "darwin":
            seven_zip_path = './lib/7z-mac/7zz'
        elif os_name == "windows":
            seven_zip_path = '.\\lib\\7z-win\\7z.exe'
        else:
            seven_zip_path = '7z'

    ret = subprocess.call([seven_zip_path, 'x', file_path, "-o" + out_dir], stdout=open(os.devnull, 'w'))
    return ret

def to_absolute_path(basePath, relativePath):
    if relativePath and not os.path.isabs(relativePath):
        relativePath = os.path.join(basePath, relativePath)
    return relativePath


def read_object_from_json_file(jsonFilePath):
    ret = None
    with open(jsonFilePath, 'r') as json_file:
        ret = json.load(json_file)
    return ret


# Returns True of callback indicates to stop iteration
def deep_iterate_dir(rootDir, callback, to_iter=True):
    for lists in os.listdir(rootDir):
        path = os.path.join(rootDir, lists)
        if os.path.isdir(path):
            if not to_iter:
                print("*** Skip sub directory: " + path)
                continue
            if callback(path, True):
                return True
            else:
                if deep_iterate_dir(path, callback, to_iter):
                    return True
        elif os.path.isfile(path):
            if callback(path, False):
                return True
    return False

def result_csv_output(result, output_path):
    import csv

    with open(output_path, "wb") as f:
        csv_writer = csv.writer(f, delimiter=",", quotechar='"', quoting=csv.QUOTE_MINIMAL)
        csv_writer.writerow(["File",
                             "Engine",
                             "EngineVersion",
                             "Subtypes",
                             "matched_content_file_name",
                             "matched_content_keywords"])
        for e in result:
            if len(e["error_info"]) > 0:
                engine = ", ".join(e["error_info"])
                engine_version = "UNKNOWN"
            else:
                engine = e["engine"]
                engine_version = e["engine_version"]

            sub_types = ", ".join(e["sub_types"])
            matched_content_keywords = ",".join(e["matched_content_keywords"])

            csv_writer.writerow([e["file_name"].encode("utf-8"),
                                 engine.encode("utf-8"),
                                 engine_version.encode("utf-8"),
                                 sub_types.encode("utf-8"),
                                 e["matched_content_file_name"].encode("utf-8"),
                                 matched_content_keywords.encode("utf-8")])
            f.flush()

```

`config.json`:

```json
{
    "package_dirs":
    [
        "packages"
    ],

    "package_suffixes":
    [
        ".apk",
        ".ipa",
        ".zip"
    ],

    "check_file_content_keywords":
    [
        "[^/]+\\.so$",
        "[^/]+\\.app/.*"
    ],

    "no_need_to_check_file_content":
    [
        "[^/]+\\.png$",
        "[^/]+\\.jpg$",
        "[^/]+\\.jpeg$",
        "[^/]+\\.plist$",
        "[^/]+\\.caf",
        "[^/]+\\.pvr",
        "[^/]+\\.swf",
        "[^/]+\\.json",
        "[^/]+\\.txt",
        "[^/]+\\.mp3",
        "[^/]+\\.ogg",
        "[^/]+\\.wav",
        "PkgInfo$",
        "iTunesArtwork$"
    ],

    "engines":
    [
        {
            "name": "cocos2d",
            "file_name_keywords": ["cocos2d"],
            "file_content_keywords": ["CCFileUtils", "cocos2dVersion", "cocos2d"],
            "sub_types":
            {
                "lua": ["CCLuaEngine", "LuaEngine"],
                "js": ["ScriptingCore"],
                "CocosCreator": ["Scale9SpriteV2"]
            },
            "engine_version_keyword": "\\0cocos2d-x[\\s-](\\d+\\..*?)\\0"
        },

        {
            "name": "unity",
            "file_name_keywords": ["libunity\\.so", "unity3d", "unityengine", "unityscript"],
            "file_content_keywords": ["mono_unity", "unity3d", "unityengine", "unityscript"],
            "sub_types": {}
        },

        {
            "name": "flash",
            "file_name_keywords": ["flash.*\\.so"],
            "file_content_keywords": [],
            "sub_types":
            {
                "Stage3D": ["AIRStage3D"],
                "ActionScript": ["ActionScript"],
                "FlashAir": ["flash air", "flash_air", "flashair"]
            }
        },

        {
            "name": "Unreal",
            "file_name_keywords": ["libUE4.so", "UE4Game"],
            "file_content_keywords": ["UProjectileMovementComponent", "UPrimitiveComponent", "UE4Game"],
            "sub_types": {}
        },

        {
            "name": "libgdx",
            "file_name_keywords": ["libgdx.so"],
            "file_content_keywords": ["com_badlogic_gdx"],
            "sub_types": {}
        },

        {
            "name": "egret",
            "file_name_keywords": [],
            "file_content_keywords": ["egretframeworknative", "EGTTexture"],
            "sub_types": {}
        }
    ]
}
```

`detector.py`:

```py
#!/usr/bin/env python
import os
import shutil
import common
import re

TAG = "GameEngineDetector: "

class PackageScanner:
    def __init__(self, workspace, engines, file_name):
        self.result = None
        self.workspace = workspace
        self.engines = engines
        self.file_name = file_name
        self.prev_engine_name = None
        self._reset_result()


    def unzip_package(self, pkg_path, out_dir, seven_zip_path):

        ret = common.unzip_package(pkg_path, out_dir, seven_zip_path)

        if 0 != ret:
            print("==> ERROR: unzip package ( %s ) failed!" % self.file_name)
            self.result["error_info"].append("Unzip package failed")
        return ret

    def _set_engine_name(self, name):
        self.result["engine"] = name
        if self.prev_engine_name and self.prev_engine_name != name:
            self.result["error_info"].append("Previous check result is (%s), but now is (%s), please check config.json")

    def _remove_prefix(self, path):
        pos = path.find(self.workspace)
        if pos != -1:
            return path[len(self.workspace):]
        return path

    def _check_chunk(self, path, chunk, engine):
        "@return True if we could confirm the engine type"
        ret = False
        chunk = chunk.lower()

        for keyword in engine["file_content_keywords"]:
            keyword = keyword.lower()
            if re.search(keyword, chunk):
                #print("==> FOUND (engine: %s, keyword: %s)" % (engine["name"], keyword))
                self._set_engine_name(engine["name"])
                self.result["matched_content_file_name"] = self._remove_prefix(path)
                self.result["matched_content_keywords"].add(keyword)
                ret = True

        for (k, v) in engine["sub_types"].items():
            for keyword in v:
                keyword = keyword.lower()
                if re.search(keyword, chunk):

                    #print("==> FOUND sub type ( %s )" % v)
                    self._set_engine_name(engine["name"])
                    self.result["matched_content_file_name"] = self._remove_prefix(path)
                    self.result["sub_types"].add(k)
                    self.result["matched_sub_type_keywords"].add(keyword)
                    ret = True

        return ret


    def check_file_name(self, path):
        found = False
        path = common.to_unix_path(path)
        for engine in self.engines:
            #print("==> Checking whether the game is made by " + engine["name"])

            for keyword in engine["file_name_keywords"]:
                if re.search(keyword, path):
                    self._set_engine_name(engine["name"])
                    self.result["matched_file_name_keywords"].add(keyword)

            if self.result["engine"] != "unknown":
                found = True
                break

        return found

    def check_file_content(self, path, chunk_size=81920):
        #print("==> Checking executable file ( %s )" % path)

        found = False
        found_engine = None
        for engine in self.engines:
            #print("==> Checking whether the game is made by " + engine["name"])

            with open(path, "rb") as f:
                while True:
                    chunk = f.read(chunk_size)
                    if chunk:
                        ret = self._check_chunk(path, chunk, engine)
                        if not found and ret:
                            found = True
                            found_engine = engine
                    else:
                        break

            if found:
                print("RESULT: " + str(self.result))
                break

        # Check engine version
        if found:
            # Re-open so file
            if 'engine_version_keyword' in found_engine and path.endswith('.so'):
                engine_version_keyword = found_engine['engine_version_keyword']
                with open(path, "rb") as f:
                    while True:
                        chunk = f.read(chunk_size)
                        if chunk:
                            matched = re.search(engine_version_keyword, chunk)
                            if matched:
                                self.result['engine_version'] = matched.group(1)
                        else:
                            break

        return found


    def _reset_result(self):
        self.result = {
            "file_name": self.file_name,
            "engine": "unknown",
            "engine_version": "unknown",
            "matched_file_name_keywords": set(),
            "matched_content_file_name": "",
            "matched_content_keywords": set(),
            "sub_types": set(),
            "matched_sub_type_keywords": set(),
            "error_info": []
        }
        return


class GameEngineDetector:
    def __init__(self, workspace, opts):
        "Constructor"

        self.workspace = workspace
        self.package_index = 0
        self.opts = opts
        self.all_results = []

        print(TAG + str(opts))

        self.temp_dir = os.path.join(self.workspace, "temp")

        self.engines = opts["engines"]
        self.package_dirs = opts["package_dirs"]
        self.package_suffixes = opts["package_suffixes"]
        self._normalize_package_dirs()
        self.check_file_content_keywords = opts["check_file_content_keywords"]
        self.no_need_to_check_file_content = opts["no_need_to_check_file_content"]


    def _normalize_package_dirs(self):
        for i in range(0, len(self.package_dirs)):
            self.package_dirs[i] = common.to_absolute_path(self.workspace, self.package_dirs[i])
        print("package_dirs: " + str(self.package_dirs))


    def _need_to_check_file_content(self, path):
        "Check whether the file is an executable file"
        path = common.to_unix_path(path)
        
        for k in self.no_need_to_check_file_content:
            m = re.search(k, path)
            if m:
                #print("==> Not need to check content: (%s)" % m.group(0))
                return False

        for keyword in self.check_file_content_keywords:
            m = re.search(keyword, path)
            if m:
                #print("==> Found file to check content: (%s)" % m.group(0))
                return True
        return False

    def _scan_package(self, pkg_path):

        file_name = os.path.split(pkg_path)[-1]

        print("==> Scanning package ( %s )" % file_name.encode('utf-8'))
        print("==> Unzip package ...")
        out_dir = os.path.join(self.temp_dir, file_name)

        scanner = PackageScanner(self.workspace, self.engines, file_name)

        # FIXME: rename the file path to avoid to use utf8 encoding string since 7z.exe on windows will complain.
        new_pkg_path = common.normalize_utf8_path(pkg_path, self.package_index)

        if new_pkg_path != pkg_path:
            os.rename(pkg_path, new_pkg_path)

        new_out_dir = common.normalize_utf8_path(out_dir, self.package_index)
        os.mkdir(new_out_dir)

        try:
            if 0 == scanner.unzip_package(new_pkg_path, new_out_dir, self.opts["7z_path"]):
                def callback(path, is_dir):
                    if is_dir:
                        return False

                    scanner.check_file_name(path)

                    if self._need_to_check_file_content(path):
                        if scanner.check_file_content(path):
                            return True

                    return False

                common.deep_iterate_dir(new_out_dir, callback)

            self.all_results.append(scanner.result)
            if pkg_path != new_pkg_path:
                os.rename(new_pkg_path, pkg_path)

        except Exception as e:
            if pkg_path != new_pkg_path:
                os.rename(new_pkg_path, pkg_path)
            raise Exception(e)

        self.package_index += 1

        return


    def _iteration_callback(self, path, is_dir):
        for suffix in self.package_suffixes:
            if path.endswith(suffix):
                self._scan_package(path)

        return False

    def run(self):
        self.clean()
        # Re-create the temporary directory, it's an empty directory now
        os.mkdir(self.temp_dir)

        for d in self.package_dirs:
            common.deep_iterate_dir(d, self._iteration_callback, False)

        self.clean()
        print("==> DONE!")
        return

    def clean(self):
        print("==> Cleaning ...")
        # Remove temporary directory
        if os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)

        return

    def get_all_results(self):
        return self.all_results






```

`main.py`:

```py
#!/usr/bin/env python
import sys
import os
import traceback

import common
import detector


def main():
    print("main entry!")

    workspace = os.getcwd()
    print("workspace: " + workspace)

    from optparse import OptionParser

    parser = OptionParser(usage="./main.py -o csv_path")

    parser.add_option("-c", "--configfile",
                      action="store", type="string", dest="config_file", default=None,
                      help="The config file path")

    parser.add_option("-z", "--zip",
                      action="store", type="string", dest="seven_zip_path", default=None,
                      help="7z path")

    parser.add_option("-p", "--pkg-dir",
                      action="store", type="string", dest="pkg_dir", default=None,
                      help="Directory that contains packages")

    parser.add_option("-o", "--out-file",
                      action="store", type="string", dest="out_file", default=None,
                      help="The result file")

    (opts, args) = parser.parse_args()

    if opts.config_file is None:
        opts.config_file = "config.json"

    cfg = common.read_object_from_json_file(opts.config_file)

    cfg["7z_path"]= opts.seven_zip_path

    if opts.pkg_dir is not None:
        cfg["package_dirs"]= [opts.pkg_dir.decode("utf-8")]

    d = detector.GameEngineDetector(workspace, cfg)
    d.run()
    r = d.get_all_results()

    out_file_name = os.path.join(workspace, "result.csv")

    if opts.out_file:
        out_file_name = opts.out_file

    common.result_csv_output(r, out_file_name)

    for e in r:
        str = "package: " + e["file_name"] + ", engine: " + e["engine"] + ", version: " + e["engine_version"] + ", "
        if e["sub_types"]:
            for sub_type in e["sub_types"]:
                str += "subtype: " + sub_type + ", "

        if len(e["error_info"]) > 0:
            for err in e["error_info"]:
                str += ", error info: " + err + ", "

        str += "matched:" + e["matched_content_file_name"]

        print(str.encode('utf-8'))

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        traceback.print_exc()
        sys.exit(1)

```