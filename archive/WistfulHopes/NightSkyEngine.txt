Project Path: arc_WistfulHopes_NightSkyEngine_gcziyusd

Source Tree:

```txt
arc_WistfulHopes_NightSkyEngine_gcziyusd
├── Config
│   ├── DefaultEditor.ini
│   ├── DefaultEngine.ini
│   ├── DefaultGame.ini
│   ├── DefaultGameplayTags.ini
│   └── DefaultInput.ini
├── LICENSE
├── NightSkyEngine.uproject
├── Plugins
│   └── NightSkyEngine
│       ├── NightSkyEngine.uplugin
│       └── Source
│           ├── CollisionEditor
│           │   ├── CollisionEditor.Build.cs
│           │   ├── Private
│           │   │   ├── AssetTypeActions_CollisionData.cpp
│           │   │   ├── CelAssetTree.cpp
│           │   │   ├── CollisionDataDetails.cpp
│           │   │   ├── CollisionDataEditorToolkit.cpp
│           │   │   ├── CollisionEditor.cpp
│           │   │   ├── Logging.cpp
│           │   │   ├── Logging.h
│           │   │   └── Viewport
│           │   │       ├── CollisionAnimationPreviewScene.cpp
│           │   │       ├── CollisionAnimationViewport.cpp
│           │   │       └── CollisionAnimationViewportClient.cpp
│           │   └── Public
│           │       ├── AssetTypeActions_CollisionData.h
│           │       ├── CelAssetTree.h
│           │       ├── CelAssetTreeNode.h
│           │       ├── CollisionDataDetails.h
│           │       ├── CollisionDataEditorToolkit.h
│           │       ├── CollisionEditor.h
│           │       └── Viewport
│           │           ├── CollisionAnimationPreviewScene.h
│           │           ├── CollisionAnimationViewport.h
│           │           └── CollisionAnimationViewportClient.h
│           ├── GGPOUE4
│           │   ├── GGPOUE4.Build.cs
│           │   ├── LICENSE
│           │   ├── Private
│           │   │   ├── GGPOGameInstance.cpp
│           │   │   ├── GGPOUE4.cpp
│           │   │   ├── backends
│           │   │   │   ├── backend.h
│           │   │   │   ├── p2p.cpp
│           │   │   │   ├── p2p.h
│           │   │   │   ├── spectator.cpp
│           │   │   │   ├── spectator.h
│           │   │   │   ├── synctest.cpp
│           │   │   │   └── synctest.h
│           │   │   ├── bitvector.cpp
│           │   │   ├── bitvector.h
│           │   │   ├── game_input.cpp
│           │   │   ├── game_input.h
│           │   │   ├── include
│           │   │   │   └── connection_manager.cpp
│           │   │   ├── input_queue.cpp
│           │   │   ├── input_queue.h
│           │   │   ├── log.cpp
│           │   │   ├── log.h
│           │   │   ├── main.cpp
│           │   │   ├── network
│           │   │   │   ├── udp.cpp
│           │   │   │   ├── udp.h
│           │   │   │   ├── udp_msg.h
│           │   │   │   ├── udp_proto.cpp
│           │   │   │   └── udp_proto.h
│           │   │   ├── pevents.cpp
│           │   │   ├── pevents.h
│           │   │   ├── platform_unix.cpp
│           │   │   ├── platform_unix.h
│           │   │   ├── platform_windows.cpp
│           │   │   ├── platform_windows.h
│           │   │   ├── poll.cpp
│           │   │   ├── poll.h
│           │   │   ├── ring_buffer.h
│           │   │   ├── static_buffer.h
│           │   │   ├── sync.cpp
│           │   │   ├── sync.h
│           │   │   ├── timesync.cpp
│           │   │   ├── timesync.h
│           │   │   ├── types.h
│           │   │   ├── zconf.h
│           │   │   └── zlib.h
│           │   ├── Public
│           │   │   ├── GGPOGameInstance.h
│           │   │   ├── GGPOUE4.h
│           │   │   └── include
│           │   │       ├── connection_manager.h
│           │   │       ├── ggponet.cpp
│           │   │       └── ggponet.h
│           │   ├── README.md
│           │   └── doc
│           │       ├── DeveloperGuide.ja.md
│           │       ├── DeveloperGuide.md
│           │       ├── README.ja.md
│           │       ├── README.md
│           │       └── images
│           │           ├── ggpo_header.png
│           │           ├── ggpo_open_graph_cropped.png
│           │           ├── overview_image1.png
│           │           ├── overview_image2.png
│           │           ├── overview_image3.png
│           │           ├── overview_image4.png
│           │           └── overview_image5.png
│           ├── NightSkyEngine
│           │   ├── Battle
│           │   │   ├── Actors
│           │   │   │   ├── AudioManager.cpp
│           │   │   │   ├── AudioManager.h
│           │   │   │   ├── LinkActor.cpp
│           │   │   │   ├── LinkActor.h
│           │   │   │   ├── ParticleManager.cpp
│           │   │   │   └── ParticleManager.h
│           │   │   ├── Animation
│           │   │   │   ├── NightSkyAnimInstance.cpp
│           │   │   │   ├── NightSkyAnimInstance.h
│           │   │   │   ├── NightSkyAnimMetaData.cpp
│           │   │   │   ├── NightSkyAnimMetaData.h
│           │   │   │   ├── NightSkyAnimSequenceUserData.cpp
│           │   │   │   └── NightSkyAnimSequenceUserData.h
│           │   │   ├── CPU
│           │   │   │   ├── NightSkyAIController.cpp
│           │   │   │   └── NightSkyAIController.h
│           │   │   ├── FighterRunners
│           │   │   │   ├── FighterLocalRunner.cpp
│           │   │   │   ├── FighterLocalRunner.h
│           │   │   │   ├── FighterMultiplayerRunner.cpp
│           │   │   │   ├── FighterMultiplayerRunner.h
│           │   │   │   ├── FighterReplayRunner.cpp
│           │   │   │   ├── FighterReplayRunner.h
│           │   │   │   ├── FighterSynctestRunner.cpp
│           │   │   │   └── FighterSynctestRunner.h
│           │   │   ├── Misc
│           │   │   │   ├── Bitflags.h
│           │   │   │   ├── CollisionBox.h
│           │   │   │   ├── Globals.cpp
│           │   │   │   ├── Globals.h
│           │   │   │   ├── InputBuffer.cpp
│           │   │   │   ├── InputBuffer.h
│           │   │   │   ├── NightSkyBlueprintFunctionLibrary.cpp
│           │   │   │   ├── NightSkyBlueprintFunctionLibrary.h
│           │   │   │   ├── RandomManager.cpp
│           │   │   │   ├── RandomManager.h
│           │   │   │   ├── SerializableObj.cpp
│           │   │   │   └── SerializableObj.h
│           │   │   ├── NightSkyGameState.cpp
│           │   │   ├── NightSkyGameState.h
│           │   │   ├── NightSkyPlayerController.cpp
│           │   │   ├── NightSkyPlayerController.h
│           │   │   ├── Objects
│           │   │   │   ├── BattleObject.cpp
│           │   │   │   ├── BattleObject.h
│           │   │   │   ├── PlayerObject.cpp
│           │   │   │   └── PlayerObject.h
│           │   │   └── Script
│           │   │       ├── BattleExtension.cpp
│           │   │       ├── BattleExtension.h
│           │   │       ├── State.cpp
│           │   │       ├── State.h
│           │   │       ├── StateAlias.h
│           │   │       ├── StateMachine.cpp
│           │   │       ├── StateMachine.h
│           │   │       ├── Subroutine.cpp
│           │   │       ├── Subroutine.h
│           │   │       └── SubroutineState.h
│           │   ├── CharaSelect
│           │   │   ├── NightSkyCharaSelectGameState.cpp
│           │   │   └── NightSkyCharaSelectGameState.h
│           │   ├── Data
│           │   │   ├── BattleExtensionData.cpp
│           │   │   ├── BattleExtensionData.h
│           │   │   ├── CameraShakeData.h
│           │   │   ├── CollisionData.cpp
│           │   │   ├── CollisionData.h
│           │   │   ├── FlipbookData.h
│           │   │   ├── LinkActorData.h
│           │   │   ├── MaterialData.h
│           │   │   ├── ParticleData.cpp
│           │   │   ├── ParticleData.h
│           │   │   ├── PrimaryCharaData.h
│           │   │   ├── PrimaryStageData.h
│           │   │   ├── SequenceData.h
│           │   │   ├── SoundData.cpp
│           │   │   ├── SoundData.h
│           │   │   ├── StateData.cpp
│           │   │   ├── StateData.h
│           │   │   ├── SubroutineData.cpp
│           │   │   └── SubroutineData.h
│           │   ├── Input
│           │   │   ├── NSEEnhancedInputUserSettings.cpp
│           │   │   ├── NSEEnhancedInputUserSettings.h
│           │   │   ├── NSEPlayerMappableKeyProfile.cpp
│           │   │   ├── NSEPlayerMappableKeyProfile.h
│           │   │   ├── NSEPlayerMappableKeySettings.cpp
│           │   │   └── NSEPlayerMappableKeySettings.h
│           │   ├── Miscellaneous
│           │   │   ├── NightSkyEditorSettings.cpp
│           │   │   ├── NightSkyEditorSettings.h
│           │   │   ├── NightSkyEngineGameModeBase.cpp
│           │   │   ├── NightSkyEngineGameModeBase.h
│           │   │   ├── NightSkyGameInstance.cpp
│           │   │   ├── NightSkyGameInstance.h
│           │   │   ├── NightSkySaveInfo.cpp
│           │   │   ├── NightSkySaveInfo.h
│           │   │   ├── NightSkySettingsInfo.h
│           │   │   ├── ReplayInfo.cpp
│           │   │   └── ReplayInfo.h
│           │   ├── Network
│           │   │   ├── FighterRunners.h
│           │   │   ├── NSESessionSubsystem.cpp
│           │   │   ├── NSESessionSubsystem.h
│           │   │   ├── NetworkPawn.cpp
│           │   │   ├── NetworkPawn.h
│           │   │   ├── RpcConnectionManager.cpp
│           │   │   └── RpcConnectionManager.h
│           │   ├── NightSkyEngine.Build.cs
│           │   ├── NightSkyEngine.cpp
│           │   ├── NightSkyEngine.h
│           │   ├── UI
│           │   │   ├── ExtendedCommonActivatableWidget.cpp
│           │   │   ├── ExtendedCommonActivatableWidget.h
│           │   │   ├── NightSkyBattleHudActor.cpp
│           │   │   ├── NightSkyBattleHudActor.h
│           │   │   ├── NightSkyBattleWidget.cpp
│           │   │   └── NightSkyBattleWidget.h
│           │   ├── VSInfo
│           │   │   ├── NightSkyVSInfoGameState.cpp
│           │   │   └── NightSkyVSInfoGameState.h
│           │   └── WT
│           │       ├── NightSkyWTGameState.cpp
│           │       ├── NightSkyWTGameState.h
│           │       ├── NightSkyWTPlayerController.cpp
│           │       ├── NightSkyWTPlayerController.h
│           │       ├── WTCharacter.cpp
│           │       └── WTCharacter.h
│           └── NightSkyEngineEditor
│               ├── NightSkyEngineEditor.Build.cs
│               ├── Private
│               │   ├── NightSkyEditorBlueprintLibrary.cpp
│               │   └── NightSkyEngineEditor.cpp
│               └── Public
│                   ├── NightSkyEditorBlueprintLibrary.h
│                   └── NightSkyEngineEditor.h
├── README.md
├── Source
│   ├── NightSkyEngine.Target.cs
│   ├── NightSkyEngineDemo
│   │   ├── NightSkyEngineDemo.Build.cs
│   │   ├── NightSkyEngineDemo.cpp
│   │   └── NightSkyEngineDemo.h
│   └── NightSkyEngineEditor.Target.cs
└── docs
    ├── docs
    │   ├── basics
    │   │   ├── anim-data-example.png
    │   │   ├── basics.md
    │   │   ├── box.png
    │   │   ├── bp-select-collision.png
    │   │   ├── cel-example.png
    │   │   ├── collision-data.md
    │   │   ├── collision-preview.png
    │   │   └── structure.md
    │   ├── getting-started
    │   │   ├── about.md
    │   │   ├── bearings.md
    │   │   ├── create-state.md
    │   │   ├── installing.md
    │   │   ├── licenses.md
    │   │   ├── quick-start.md
    │   │   ├── state-data.md
    │   │   ├── state-example.png
    │   │   ├── state-p1.md
    │   │   └── state-p2.md
    │   └── index.md
    └── mkdocs.yml

```

`Config/DefaultEditor.ini`:

```ini
[/Script/CommonUI.CommonUIEditorSettings]
TemplateTextStyle=/Game/NightSkyEngine/Shared/UI/BP_CommonTextStyle.BP_CommonTextStyle_C
TemplateBorderStyle=/Game/NightSkyEngine/Shared/UI/BP_CommonBorderStyle.BP_CommonBorderStyle_C
TemplateButtonStyle=/Game/NightSkyEngine/Shared/UI/BP_CommonButtonStyle.BP_CommonButtonStyle_C

[BlueprintNativizationSettings]
+ExcludedAssets=/OnlineSubsystemRedpointEOS/EOSDefaultUserInterface_EnterDevicePinCode
+ExcludedAssets=/OnlineSubsystemRedpointEOS/EOSDefaultUserInterface_SignInOrCreateAccount

[EpicOnlineServices]
DedicatedServerDistributionMode=DevelopersAndPlayers
DedicatedServerClientId=
DedicatedServerClientSecret=
DedicatedServerPrivateKey=cIxkI+WuPv4lkEC6NBDOaTY8axsI3qfKFbHFUg32rBW6PQESCkyTnG+aVpmWm5VzkiQslBxDtCBTA9Fn7PppHg==

[/Script/AdvancedPreviewScene.SharedProfiles]
+Profiles=(ProfileName="Epic Headquarters",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=1.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=1.000000,bRotateLightingRig=False,bShowEnvironment=True,bShowFloor=False,bShowGrid=False,EnvironmentColor=(R=0.200000,G=0.200000,B=0.200000,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/EpicQuadPanorama_CC+EV1.EpicQuadPanorama_CC+EV1",bPostProcessingEnabled=True,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomGaussianIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionIntensity=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureHighlightThresholdStrength=False,bOverride_LocalExposureShadowThresholdStrength=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldPetzvalBokeh=False,bOverride_DepthOfFieldPetzvalBokehFalloff=False,bOverride_DepthOfFieldPetzvalExclusionBoxExtents=False,bOverride_DepthOfFieldPetzvalExclusionBoxRadius=False,bOverride_DepthOfFieldAspectRatioScalar=False,bOverride_DepthOfFieldMatteBoxFlags=False,bOverride_DepthOfFieldBarrelRadius=False,bOverride_DepthOfFieldBarrelLength=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_RayTracingTranslucencyMaxPrimaryHitEvents=False,bOverride_RayTracingTranslucencyMaxSecondaryHitEvents=False,bOverride_RayTracingTranslucencyUseRayTracedRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenSkylightLeakingTint=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomGaussianIntensity=1.000000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionIntensity=1.000000,BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenSkylightLeakingTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureHighlightThresholdStrength=1.000000,LocalExposureShadowThresholdStrength=1.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldPetzvalBokeh=0.000000,DepthOfFieldPetzvalBokehFalloff=1.000000,DepthOfFieldPetzvalExclusionBoxExtents=(X=0.000000,Y=0.000000),DepthOfFieldPetzvalExclusionBoxRadius=0.000000,DepthOfFieldAspectRatioScalar=1.000000,DepthOfFieldBarrelRadius=5.000000,DepthOfFieldBarrelLength=0.000000,DepthOfFieldMatteBoxFlags[0]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[1]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[2]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyMaxPrimaryHitEvents=4,RayTracingTranslucencyMaxSecondaryHitEvents=2,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,RayTracingTranslucencyUseRayTracedRefraction=False,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=True,bShowMeshEdges=False)
+Profiles=(ProfileName="Grey Wireframe",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=1.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=1.000000,bRotateLightingRig=False,bShowEnvironment=False,bShowFloor=False,bShowGrid=True,EnvironmentColor=(R=0.039216,G=0.039216,B=0.039216,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/EpicQuadPanorama_CC+EV1.EpicQuadPanorama_CC+EV1",bPostProcessingEnabled=False,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomGaussianIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionIntensity=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureHighlightThresholdStrength=False,bOverride_LocalExposureShadowThresholdStrength=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldPetzvalBokeh=False,bOverride_DepthOfFieldPetzvalBokehFalloff=False,bOverride_DepthOfFieldPetzvalExclusionBoxExtents=False,bOverride_DepthOfFieldPetzvalExclusionBoxRadius=False,bOverride_DepthOfFieldAspectRatioScalar=False,bOverride_DepthOfFieldMatteBoxFlags=False,bOverride_DepthOfFieldBarrelRadius=False,bOverride_DepthOfFieldBarrelLength=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_RayTracingTranslucencyMaxPrimaryHitEvents=False,bOverride_RayTracingTranslucencyMaxSecondaryHitEvents=False,bOverride_RayTracingTranslucencyUseRayTracedRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenSkylightLeakingTint=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomGaussianIntensity=1.000000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionIntensity=1.000000,BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenSkylightLeakingTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureHighlightThresholdStrength=1.000000,LocalExposureShadowThresholdStrength=1.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldPetzvalBokeh=0.000000,DepthOfFieldPetzvalBokehFalloff=1.000000,DepthOfFieldPetzvalExclusionBoxExtents=(X=0.000000,Y=0.000000),DepthOfFieldPetzvalExclusionBoxRadius=0.000000,DepthOfFieldAspectRatioScalar=1.000000,DepthOfFieldBarrelRadius=5.000000,DepthOfFieldBarrelLength=0.000000,DepthOfFieldMatteBoxFlags[0]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[1]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[2]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyMaxPrimaryHitEvents=4,RayTracingTranslucencyMaxSecondaryHitEvents=2,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,RayTracingTranslucencyUseRayTracedRefraction=False,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=False,bShowMeshEdges=True)
+Profiles=(ProfileName="Grey Ambient",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=4.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=2.000000,bRotateLightingRig=False,bShowEnvironment=True,bShowFloor=True,bShowGrid=True,EnvironmentColor=(R=0.200000,G=0.200000,B=0.200000,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/T_GreyAmbient",bPostProcessingEnabled=False,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomGaussianIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionIntensity=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureHighlightThresholdStrength=False,bOverride_LocalExposureShadowThresholdStrength=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldPetzvalBokeh=False,bOverride_DepthOfFieldPetzvalBokehFalloff=False,bOverride_DepthOfFieldPetzvalExclusionBoxExtents=False,bOverride_DepthOfFieldPetzvalExclusionBoxRadius=False,bOverride_DepthOfFieldAspectRatioScalar=False,bOverride_DepthOfFieldMatteBoxFlags=False,bOverride_DepthOfFieldBarrelRadius=False,bOverride_DepthOfFieldBarrelLength=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_RayTracingTranslucencyMaxPrimaryHitEvents=False,bOverride_RayTracingTranslucencyMaxSecondaryHitEvents=False,bOverride_RayTracingTranslucencyUseRayTracedRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenSkylightLeakingTint=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomGaussianIntensity=1.000000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionIntensity=1.000000,BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenSkylightLeakingTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureHighlightThresholdStrength=1.000000,LocalExposureShadowThresholdStrength=1.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldPetzvalBokeh=0.000000,DepthOfFieldPetzvalBokehFalloff=1.000000,DepthOfFieldPetzvalExclusionBoxExtents=(X=0.000000,Y=0.000000),DepthOfFieldPetzvalExclusionBoxRadius=0.000000,DepthOfFieldAspectRatioScalar=1.000000,DepthOfFieldBarrelRadius=5.000000,DepthOfFieldBarrelLength=0.000000,DepthOfFieldMatteBoxFlags[0]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[1]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[2]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyMaxPrimaryHitEvents=4,RayTracingTranslucencyMaxSecondaryHitEvents=2,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,RayTracingTranslucencyUseRayTracedRefraction=False,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=False,bShowMeshEdges=False)


```

`Config/DefaultEngine.ini`:

```ini
[/Script/EngineSettings.GameMapsSettings]
GameDefaultMap=/Game/NightSkyEngine/Maps/MainMenu_PL.MainMenu_PL
EditorStartupMap=/Game/NightSkyEngine/Maps/TestMap/TestMap_PL.TestMap_PL
GameInstanceClass=/Game/NightSkyEngine/Blueprints/Common/BP_NightSkyGameInstance.BP_NightSkyGameInstance_C
TransitionMap=/Game/NightSkyEngine/Maps/TransitionLevel_PL.TransitionLevel_PL
bUseSplitscreen=False
GlobalDefaultGameMode=/Game/NightSkyEngine/Blueprints/Battle/BP_NightSkyGameMode.BP_NightSkyGameMode_C

[/Script/WindowsTargetPlatform.WindowsTargetSettings]
DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
-D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM6
-D3D11TargetedShaderFormats=PCD3D_SM5
+D3D11TargetedShaderFormats=PCD3D_SM5
bGenerateNaniteFallbackMeshes=True
Compiler=Default
AudioSampleRate=48000
AudioCallbackBufferFrameSize=1024
AudioNumBuffersToEnqueue=1
AudioMaxChannels=0
AudioNumSourceWorkers=4
SpatializationPlugin=
SourceDataOverridePlugin=
ReverbPlugin=
OcclusionPlugin=
CompressionOverrides=(bOverrideCompressionTimes=False,DurationThreshold=5.000000,MaxNumRandomBranches=0,SoundCueQualityIndex=0)
CacheSizeKB=65536
MaxChunkSizeOverrideKB=0
bResampleForDevice=False
MaxSampleRate=48000.000000
HighSampleRate=32000.000000
MedSampleRate=24000.000000
LowSampleRate=12000.000000
MinSampleRate=8000.000000
CompressionQualityModifier=1.000000
AutoStreamingThreshold=0.000000
SoundCueCookQualityIndex=-1

[/Script/HardwareTargeting.HardwareTargetingSettings]
TargetedHardwareClass=Desktop
AppliedTargetedHardwareClass=Desktop
DefaultGraphicsPerformance=Maximum
AppliedDefaultGraphicsPerformance=Maximum

[/Script/Engine.RendererSettings]
r.GenerateMeshDistanceFields=True
r.DynamicGlobalIlluminationMethod=0
r.ReflectionMethod=0
r.Shadow.Virtual.Enable=1
r.DefaultFeature.AutoExposure.ExtendDefaultLuminanceRange=True
r.AntiAliasingMethod=5
r.TextureStreaming=False
r.ShaderPipelineCache.Enabled=1
r.DefaultFeature.AutoExposure=False
r.DefaultFeature.AutoExposure.Method=2
r.DefaultFeature.AutoExposure.Bias=-0.500000

[SystemSettings]
r.VSync=0
r.TonemapperFilm=0
r.FullScreenMode=0
r.HZBOcclusion=0
r.SeparateTranslucency=True

[/Script/WorldPartitionEditor.WorldPartitionEditorSettings]
CommandletClass=Class'/Script/UnrealEd.WorldPartitionConvertCommandlet'

[/Script/Engine.UserInterfaceSettings]
bAuthorizeAutomaticWidgetVariableCreation=False
RenderFocusRule=Never

[/Script/Engine.Engine]
+ActiveGameNameRedirects=(OldGameName="TP_Blank",NewGameName="/Script/NightSkyEngine")
+ActiveGameNameRedirects=(OldGameName="/Script/TP_Blank",NewGameName="/Script/NightSkyEngine")
+ActiveClassRedirects=(OldClassName="TP_BlankGameModeBase",NewClassName="NightSkyEngineGameModeBase")
CustomTimeStepClassName=None
MinDesiredFrameRate=60.000000
GameViewportClientClassName=/Script/CommonUI.CommonGameViewportClient
bUseFixedFrameRate=True
FixedFrameRate=60.000000
!NetDriverDefinitions=ClearArray
+NetDriverDefinitions=(DefName="GameNetDriver",DriverClassName="OnlineSubsystemSteam.SteamNetDriver",DriverClassNameFallback="OnlineSubsystemUtils.IpNetDriver")
+NetDriverDefinitions=(DefName="DemoNetDriver",DriverClassName="/Script/Engine.DemoNetDriver",DriverClassNameFallback="/Script/Engine.DemoNetDriver")

[OnlineSubsystem]
DefaultPlatformService=Steam

[OnlineSubsystemSteam]
bEnabled=true
SteamDevAppId=480

[/Script/OnlineSubsystemSteam.SteamNetDriver]
NetConnectionClassName="OnlineSubsystemSteam.SteamNetConnection"

[/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]
bEnablePlugin=True
bAllowNetworkConnection=True
SecurityToken=29D365AE4E46D98521FAA99B4C7D465C
bIncludeInShipping=False
bAllowExternalStartInShipping=False
bCompileAFSProject=False
bUseCompression=False
bLogFiles=False
bReportStats=False
ConnectionType=USBOnly
bUseManualIPAddress=False
ManualIPAddress=

[/Script/AndroidRuntimeSettings.AndroidRuntimeSettings]
MinSDKVersion=23
PackageName=com.WistfulHopes.NightSkyEngine
MaxAspectRatio=1.666667
bAllowResizing=True
bSupportSizeChanges=True

[PacketHandlerComponents]
EncryptionComponent=AESGCMHandlerComponent

[/Script/IOSRuntimeSettings.IOSRuntimeSettings]
bShipForBitcode=False

[/Script/PythonScriptPlugin.PythonScriptPluginSettings]
bRemoteExecution=True

[CoreRedirects]
+FunctionRedirects=(OldName="/Script/NightSkyEngine.NightSkyPlayerController.SendCharaData",NewName="/Script/NightSkyEngine.NightSkyPlayerController.SendBattleData")
+FunctionRedirects=(OldName="/Script/NightSkyEngine.NetworkPawn.ClientGetCharaData",NewName="/Script/NightSkyEngine.NetworkPawn.ClientGetBattleData")
+FunctionRedirects=(OldName="/Script/NightSkyEngine.PlayerObject.PlayVoice",NewName="/Script/NightSkyEngine.PlayerObject.PlayVoiceLine")
+FunctionRedirects=(OldName="/Script/NightSkyEngine.BattleObject.SetPushWidthFront",NewName="/Script/NightSkyEngine.BattleObject.SetPushWidthExtend")
+StructRedirects=(OldName="/Script/NightSkyEngine.BattleInfo",NewName="/Script/NightSkyEngine.BattleData")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.NightSkyGameInstance.BattleInfo",NewName="/Script/NightSkyEngine.NightSkyGameInstance.BattleData")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.BattleObject.PrevBlendPosition",NewName="/Script/NightSkyEngine.BattleObject.AnimBlendPosition")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.BattleObject.BlendPosition",NewName="/Script/NightSkyEngine.BattleObject.FrameBlendPosition")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.NightSkyBattleHudActor.Widget",NewName="/Script/NightSkyEngine.NightSkyBattleHudActor.TopWidget")
+FunctionRedirects=(OldName="/Script/NightSkyEngine.BattleObject.FlipCharacter",NewName="/Script/NightSkyEngine.BattleObject.FlipObject")
+FunctionRedirects=(OldName="/Script/NightSkyEngine.BattleObject.DeactivateIfBeyondBounds",NewName="/Script/NightSkyEngine.BattleObject.EnableDeactivateIfBeyondBounds")
+EnumRedirects=(OldName="/Script/NightSkyEngine.EEntryState",NewName="/Script/NightSkyEngine.EEntryStance")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.State.InputConditionList",NewName="/Script/NightSkyEngine.State.InputConditionLists")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.State.EntryState",NewName="/Script/NightSkyEngine.State.EntryStance")
+ClassRedirects=(OldName="/Script/NightSkyEngine.LinkedActorData",NewName="/Script/NightSkyEngine.LinkActorData")
+StructRedirects=(OldName="/Script/NightSkyEngine.LinkedActorStruct",NewName="/Script/NightSkyEngine.LinkActorStruct")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.BattleObject.ScaleForLink",NewName="/Script/NightSkyEngine.BattleObject.ObjectScale")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.BattleObject.RotationForLink",NewName="/Script/NightSkyEngine.BattleObject.ObjectRotation")
+FunctionRedirects=(OldName="/Script/NightSkyEngine.NightSkyGameInstance.SeamlessTravel",NewName="/Script/NightSkyEngine.NightSkyGameInstance.TravelToVSInfo")
+FunctionRedirects=(OldName="/Script/NightSkyEngine.PlayerObject.JumpToState",NewName="/Script/NightSkyEngine.PlayerObject.JumpToStateByName")
+FunctionRedirects=(OldName="/Script/NightSkyEngine.PlayerObject.JumpToStateByName",NewName="/Script/NightSkyEngine.PlayerObject.JumpToState")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.CameraShakeData.CamerShakeStructs",NewName="/Script/NightSkyEngine.CameraShakeData.CameraShakeStructs")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.ScreenData.DefaultMaxZoomOutWidth",NewName="/Script/NightSkyEngine.ScreenData.DefaultMaxWidth")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.ScreenData.DefaultZoomOutBeginX",NewName="/Script/NightSkyEngine.ScreenData.DefaultWidth")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.BattleData.PlayerList",NewName="/Script/NightSkyEngine.BattleData.PlayerListP1")
+FunctionRedirects=(OldName="/Script/NightSkyEngine.NightSkyGameState.EndMatch",NewName="/Script/NightSkyEngine.NightSkyGameState.EndMatch_BP")
+EnumRedirects=(OldName="/Script/NightSkyEngine.ERoundFormat",NewName="/Script/NightSkyEngine.EBattleFormat")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.BattleState.RoundFormat",NewName="/Script/NightSkyEngine.BattleState.BattleFormat")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.BattleData.ColorIndices",NewName="/Script/NightSkyEngine.BattleData.ColorIndicesP1")
+PropertyRedirects=(OldName="/Script/NightSkyEngine.BattleData.RoundFormat",NewName="/Script/NightSkyEngine.BattleData.BattleFormat")

[/Script/Engine.GameEngine]
!NetDriverDefinitions=ClearArray
+NetDriverDefinitions=(DefName="GameNetDriver",DriverClassName="OnlineSubsystemSteam.SteamNetDriver",DriverClassNameFallback="OnlineSubsystemUtils.IpNetDriver")
+NetDriverDefinitions=(DefName="DemoNetDriver",DriverClassName="/Script/Engine.DemoNetDriver",DriverClassNameFallback="/Script/Engine.DemoNetDriver")

[/Script/Engine.PhysicsSettings]
bTickPhysicsAsync=True
bSubsteppingAsync=True


```

`Config/DefaultGame.ini`:

```ini
[/Script/EngineSettings.GeneralProjectSettings]
ProjectID=5C3B3B39496B56AF5B50658D94CCC269
ProjectName=NightSkyEngine
CompanyName=WistfulHopes
ProjectDisplayedTitle=NSLOCTEXT("[/Script/EngineSettings]", "86CAC369433359718F5450920C370B8B", "Night Sky Engine")
ProjectDebugTitleInfo=NSLOCTEXT("[/Script/EngineSettings]", "2725369A44FE8CE4D94802BE567D1211", "NightSkyEngine")
bAllowWindowResize=False
Description=An open source fighting game framework made in Unreal Engine.

[CommonInputPlatformSettings_Windows CommonInputPlatformSettings]
DefaultInputType=Gamepad
bSupportsMouseAndKeyboard=True
bSupportsTouch=False
bSupportsGamepad=True
DefaultGamepadName=Generic
bCanChangeGamepadType=True
+ControllerData=/Game/NightSkyEngine/Shared/UI/BP_MenuControllerDataGamepad.BP_MenuControllerDataGamepad_C
+ControllerData=/Game/NightSkyEngine/Shared/UI/BP_MenuControllerDataKeyboard.BP_MenuControllerDataKeyboard_C

[/Script/CommonInput.CommonInputSettings]
InputData=/Game/NightSkyEngine/Shared/UI/BP_CommonInputUIData.BP_CommonInputUIData_C
ActionDomainTable=/Game/NightSkyEngine/Shared/UI/DA_ActionDomainTable.DA_ActionDomainTable
bEnableEnhancedInputSupport=True

[/Script/UnrealEd.ProjectPackagingSettings]
Build=IfProjectHasCode
BuildConfiguration=PPBC_Shipping
BuildTarget=
FullRebuild=False
ForDistribution=False
IncludeDebugFiles=False
BlueprintNativizationMethod=Disabled
bIncludeNativizedAssetsInProjectGeneration=False
bExcludeMonolithicEngineHeadersInNativizedCode=False
UsePakFile=True
bUseIoStore=True
bUseZenStore=False
bMakeBinaryConfig=False
bGenerateChunks=False
bGenerateNoChunks=False
bChunkHardReferencesOnly=False
bForceOneChunkPerFile=False
MaxChunkSize=0
bBuildHttpChunkInstallData=False
HttpChunkInstallDataDirectory=(Path="")
WriteBackMetadataToAssetRegistry=Disabled
bCompressed=True
PackageCompressionFormat=Oodle
bForceUseProjectCompressionFormatIgnoreHardwareOverride=False
PackageAdditionalCompressionOptions=
PackageCompressionMethod=Kraken
PackageCompressionLevel_DebugDevelopment=4
PackageCompressionLevel_TestShipping=5
PackageCompressionLevel_Distribution=7
PackageCompressionMinBytesSaved=1024
PackageCompressionMinPercentSaved=5
bPackageCompressionEnableDDC=False
PackageCompressionMinSizeToConsiderDDC=0
HttpChunkInstallDataVersion=
IncludePrerequisites=True
IncludeAppLocalPrerequisites=False
bShareMaterialShaderCode=True
bDeterministicShaderCodeOrder=False
bSharedMaterialNativeLibraries=True
ApplocalPrerequisitesDirectory=(Path="")
IncludeCrashReporter=False
InternationalizationPreset=English
-CulturesToStage=en
+CulturesToStage=en
LocalizationTargetCatchAllChunkId=0
bCookAll=False
bCookMapsOnly=False
bSkipEditorContent=False
bSkipMovies=False
-IniKeyDenylist=KeyStorePassword
-IniKeyDenylist=KeyPassword
-IniKeyDenylist=rsa.privateexp
-IniKeyDenylist=rsa.modulus
-IniKeyDenylist=rsa.publicexp
-IniKeyDenylist=aes.key
-IniKeyDenylist=SigningPublicExponent
-IniKeyDenylist=SigningModulus
-IniKeyDenylist=SigningPrivateExponent
-IniKeyDenylist=EncryptionKey
-IniKeyDenylist=DevCenterUsername
-IniKeyDenylist=DevCenterPassword
-IniKeyDenylist=IOSTeamID
-IniKeyDenylist=SigningCertificate
-IniKeyDenylist=MobileProvision
-IniKeyDenylist=IniKeyDenylist
-IniKeyDenylist=IniSectionDenylist
+IniKeyDenylist=KeyStorePassword
+IniKeyDenylist=KeyPassword
+IniKeyDenylist=rsa.privateexp
+IniKeyDenylist=rsa.modulus
+IniKeyDenylist=rsa.publicexp
+IniKeyDenylist=aes.key
+IniKeyDenylist=SigningPublicExponent
+IniKeyDenylist=SigningModulus
+IniKeyDenylist=SigningPrivateExponent
+IniKeyDenylist=EncryptionKey
+IniKeyDenylist=DevCenterUsername
+IniKeyDenylist=DevCenterPassword
+IniKeyDenylist=IOSTeamID
+IniKeyDenylist=SigningCertificate
+IniKeyDenylist=MobileProvision
+IniKeyDenylist=IniKeyDenylist
+IniKeyDenylist=IniSectionDenylist
-IniSectionDenylist=HordeStorageServers
-IniSectionDenylist=StorageServers
+IniSectionDenylist=HordeStorageServers
+IniSectionDenylist=StorageServers
+DirectoriesToNeverCook=(Path="/Game/Editor")

[/Script/Engine.AssetManagerSettings]
-PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass=/Script/Engine.World,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/NightSkyEngine/Maps")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
-PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass=/Script/Engine.PrimaryAssetLabel,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
+PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass="/Script/Engine.World",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/NightSkyEngine/Maps")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
+PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass="/Script/Engine.PrimaryAssetLabel",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
+PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryCharaData",AssetBaseClass="/Script/NightSkyEngine.PrimaryCharaData",bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="/Game/NightSkyEngine/Blueprints/Characters")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=AlwaysCook))
+PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryStageData",AssetBaseClass="/Script/NightSkyEngine.PrimaryStageData",bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="/Game/NightSkyEngine/Maps")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=AlwaysCook))
bOnlyCookProductionAssets=False
bShouldManagerDetermineTypeAndName=False
bShouldGuessTypeAndNameInEditor=True
bShouldAcquireMissingChunksOnLoad=False
bShouldWarnAboutInvalidAssets=True
MetaDataTagsForAssetRegistry=()


```

`Config/DefaultGameplayTags.ini`:

```ini
;METADATA=(Diff=true, UseCommands=true)
[/Script/GameplayTags.GameplayTagsSettings]
ImportTagsFromConfig=True
WarnOnInvalidTags=True
ClearInvalidTags=False
AllowEditorTagUnloading=True
AllowGameTagUnloading=False
FastReplication=False
bDynamicReplication=False
InvalidTagCharacters="\"\',"
NumBitsForContainerSize=6
NetIndexFirstBitSegment=16
+GameplayTagRedirects=(OldTagName="State.Universal.BDash",NewTagName="State.Universal.Dash.B")
+GameplayTagRedirects=(OldTagName="State.Universal.BAirJump",NewTagName="State.Universal.AirJump.B")
+GameplayTagRedirects=(OldTagName="State.Universal.BJump",NewTagName="State.Universal.Jump.B")
+GameplayTagRedirects=(OldTagName="State.Universal.BJumpPre",NewTagName="State.Universal.Jump.Pre.B")
+GameplayTagRedirects=(OldTagName="State.Universal.BSuperJump",NewTagName="State.Universal.SuperJump.B")
+GameplayTagRedirects=(OldTagName="State.Universal.BSuperJumpPre",NewTagName="State.Universal.SuperJump.Pre.B")
+GameplayTagRedirects=(OldTagName="State.Universal.BWalk",NewTagName="State.Universal.Walk.B")
+GameplayTagRedirects=(OldTagName="State.Universal.FJump",NewTagName="State.Universal.Jump.F")
+GameplayTagRedirects=(OldTagName="State.Label.Landing",NewTagName="State.Label.Common.Landing")
+GameplayTagRedirects=(OldTagName="Manny.AirDash.00",NewTagName="Manny.AirDash.F.00")
+GameplayTagRedirects=(OldTagName="Sound.AirDash",NewTagName="Sound.Dash")
+GameplayTagList=(Tag="Esther.000.00",DevComment="")
+GameplayTagList=(Tag="Esther.000.01",DevComment="")
+GameplayTagList=(Tag="Esther.000.02",DevComment="")
+GameplayTagList=(Tag="Esther.000.03",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Crouch.00",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Crouch.01",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Crouch.02",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Crouch.Flip.00",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.00",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.01",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.02",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.03",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.04",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.05",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.06",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.07",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.08",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.Landing.00",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Jump.Pre.00",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Stand.00",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Stand.01",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Stand.02",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Stand.03",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Stand.04",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Stand.05",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Stand.Flip.00",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Walk.B.00",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Walk.B.01",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Walk.F.00",DevComment="")
+GameplayTagList=(Tag="KungFuMan.Walk.F.01",DevComment="")
+GameplayTagList=(Tag="LevelSequence.KO.Large",DevComment="")
+GameplayTagList=(Tag="LevelSequence.KO.Medium",DevComment="")
+GameplayTagList=(Tag="LevelSequence.KO.Small",DevComment="")
+GameplayTagList=(Tag="Manny.5A.00",DevComment="")
+GameplayTagList=(Tag="Manny.5A.01",DevComment="")
+GameplayTagList=(Tag="Manny.5A.02",DevComment="")
+GameplayTagList=(Tag="Manny.5A.03",DevComment="")
+GameplayTagList=(Tag="Manny.5A.04",DevComment="")
+GameplayTagList=(Tag="Manny.5B",DevComment="")
+GameplayTagList=(Tag="Manny.5B.00",DevComment="")
+GameplayTagList=(Tag="Manny.5B.01",DevComment="")
+GameplayTagList=(Tag="Manny.5B.02",DevComment="")
+GameplayTagList=(Tag="Manny.5B.03",DevComment="")
+GameplayTagList=(Tag="Manny.5B.04",DevComment="")
+GameplayTagList=(Tag="Manny.5B.05",DevComment="")
+GameplayTagList=(Tag="Manny.5B.06",DevComment="")
+GameplayTagList=(Tag="Manny.Air.Turn.00",DevComment="")
+GameplayTagList=(Tag="Manny.Air.Turn.01",DevComment="")
+GameplayTagList=(Tag="Manny.AirDash.B.00",DevComment="")
+GameplayTagList=(Tag="Manny.AirDash.B.01",DevComment="")
+GameplayTagList=(Tag="Manny.AirDash.F.00",DevComment="")
+GameplayTagList=(Tag="Manny.AirDash.F.01",DevComment="")
+GameplayTagList=(Tag="Manny.AirTech.00",DevComment="")
+GameplayTagList=(Tag="Manny.AirTech.01",DevComment="")
+GameplayTagList=(Tag="Manny.Block.Air.00",DevComment="")
+GameplayTagList=(Tag="Manny.Block.Crouch.00",DevComment="")
+GameplayTagList=(Tag="Manny.Block.Stand.00",DevComment="")
+GameplayTagList=(Tag="Manny.Crouch.00",DevComment="")
+GameplayTagList=(Tag="Manny.Crouch.01",DevComment="")
+GameplayTagList=(Tag="Manny.Crouch.02",DevComment="")
+GameplayTagList=(Tag="Manny.Crouch.03",DevComment="")
+GameplayTagList=(Tag="Manny.Crouch.Flip.00",DevComment="")
+GameplayTagList=(Tag="Manny.Crouch.Flip.01",DevComment="")
+GameplayTagList=(Tag="Manny.Crumple.00",DevComment="")
+GameplayTagList=(Tag="Manny.Crumple.01",DevComment="")
+GameplayTagList=(Tag="Manny.Crumple.02",DevComment="")
+GameplayTagList=(Tag="Manny.Crumple.03",DevComment="")
+GameplayTagList=(Tag="Manny.Dash.B.00",DevComment="")
+GameplayTagList=(Tag="Manny.Dash.B.01",DevComment="")
+GameplayTagList=(Tag="Manny.Dash.B.02",DevComment="")
+GameplayTagList=(Tag="Manny.Dash.B.03",DevComment="")
+GameplayTagList=(Tag="Manny.Dash.F.00",DevComment="")
+GameplayTagList=(Tag="Manny.Dash.F.01",DevComment="")
+GameplayTagList=(Tag="Manny.Dash.F.02",DevComment="")
+GameplayTagList=(Tag="Manny.Dash.F.Stop.00",DevComment="")
+GameplayTagList=(Tag="Manny.Dash.F.Stop.01",DevComment="")
+GameplayTagList=(Tag="Manny.FaceDown.00",DevComment="")
+GameplayTagList=(Tag="Manny.FaceDown.01",DevComment="")
+GameplayTagList=(Tag="Manny.FaceUp.00",DevComment="")
+GameplayTagList=(Tag="Manny.FaceUp.01",DevComment="")
+GameplayTagList=(Tag="Manny.FaceUp.WakeUp",DevComment="")
+GameplayTagList=(Tag="Manny.FaceUp.WakeUp.00",DevComment="")
+GameplayTagList=(Tag="Manny.FaceUp.WakeUp.01",DevComment="")
+GameplayTagList=(Tag="Manny.Fireball.00",DevComment="")
+GameplayTagList=(Tag="Manny.Fireball.01",DevComment="")
+GameplayTagList=(Tag="Manny.Fireball.02",DevComment="")
+GameplayTagList=(Tag="Manny.Fireball.03",DevComment="")
+GameplayTagList=(Tag="Manny.Fireball.04",DevComment="")
+GameplayTagList=(Tag="Manny.Fireball.A",DevComment="")
+GameplayTagList=(Tag="Manny.Fireball.B",DevComment="")
+GameplayTagList=(Tag="Manny.Fireball.C",DevComment="")
+GameplayTagList=(Tag="Manny.Fireball.Obj.00",DevComment="")
+GameplayTagList=(Tag="Manny.Hitstun.00",DevComment="")
+GameplayTagList=(Tag="Manny.Hitstun.01",DevComment="")
+GameplayTagList=(Tag="Manny.Jump.00",DevComment="")
+GameplayTagList=(Tag="Manny.Jump.01",DevComment="")
+GameplayTagList=(Tag="Manny.Jump.02",DevComment="")
+GameplayTagList=(Tag="Manny.Jump.03",DevComment="")
+GameplayTagList=(Tag="Manny.Jump.04",DevComment="")
+GameplayTagList=(Tag="Manny.Jump.05",DevComment="")
+GameplayTagList=(Tag="Manny.Launch.B.00",DevComment="")
+GameplayTagList=(Tag="Manny.Launch.B.01",DevComment="")
+GameplayTagList=(Tag="Manny.Stand.00",DevComment="")
+GameplayTagList=(Tag="Manny.Stand.01",DevComment="")
+GameplayTagList=(Tag="Manny.Stand.Turn.00",DevComment="")
+GameplayTagList=(Tag="Manny.Stand.Turn.01",DevComment="")
+GameplayTagList=(Tag="Manny.Walk.B.00",DevComment="")
+GameplayTagList=(Tag="Manny.Walk.B.01",DevComment="")
+GameplayTagList=(Tag="Manny.Walk.B.02",DevComment="")
+GameplayTagList=(Tag="Manny.Walk.F.00",DevComment="")
+GameplayTagList=(Tag="Manny.Walk.F.01",DevComment="")
+GameplayTagList=(Tag="Manny.Walk.F.02",DevComment="")
+GameplayTagList=(Tag="Particle.AirDash.B",DevComment="")
+GameplayTagList=(Tag="Particle.AirDash.F",DevComment="")
+GameplayTagList=(Tag="Particle.Burst.Blue",DevComment="")
+GameplayTagList=(Tag="Particle.DashSmoke",DevComment="")
+GameplayTagList=(Tag="Particle.DoubleJump",DevComment="")
+GameplayTagList=(Tag="Particle.Manny.5BSmear",DevComment="")
+GameplayTagList=(Tag="Particle.Manny.Fireball",DevComment="")
+GameplayTagList=(Tag="Particle.Manny.Fireball.End",DevComment="")
+GameplayTagList=(Tag="Particle.SuperArmor",DevComment="")
+GameplayTagList=(Tag="Sound.Dash",DevComment="")
+GameplayTagList=(Tag="Sound.Jump",DevComment="")
+GameplayTagList=(Tag="Sound.Land",DevComment="")
+GameplayTagList=(Tag="Sound.Step.0",DevComment="")
+GameplayTagList=(Tag="State.Label.Common.End",DevComment="")
+GameplayTagList=(Tag="State.Label.Common.Landing",DevComment="")
+GameplayTagList=(Tag="State.Label.Common.Loop",DevComment="")
+GameplayTagList=(Tag="State.Label.Jump.Down",DevComment="")
+GameplayTagList=(Tag="State.Label.Jump.Top",DevComment="")
+GameplayTagList=(Tag="State.Label.Jump.TopToDown",DevComment="")
+GameplayTagList=(Tag="State.Label.Jump.Upper",DevComment="")
+GameplayTagList=(Tag="State.Label.Jump.UpperToTop",DevComment="")
+GameplayTagList=(Tag="State.Manny.5A",DevComment="")
+GameplayTagList=(Tag="State.Manny.BattleObject.5BSmear",DevComment="")
+GameplayTagList=(Tag="State.Universal.AirDash.B",DevComment="")
+GameplayTagList=(Tag="State.Universal.AIrDash.F",DevComment="")
+GameplayTagList=(Tag="State.Universal.AirJump.B",DevComment="")
+GameplayTagList=(Tag="State.Universal.AirJump.F",DevComment="")
+GameplayTagList=(Tag="State.Universal.AirJump.V",DevComment="")
+GameplayTagList=(Tag="State.Universal.Assist",DevComment="")
+GameplayTagList=(Tag="State.Universal.Assist.2nd",DevComment="")
+GameplayTagList=(Tag="State.Universal.Assist.3rd",DevComment="")
+GameplayTagList=(Tag="State.Universal.Assist.Exit",DevComment="")
+GameplayTagList=(Tag="State.Universal.CrouchToStand",DevComment="")
+GameplayTagList=(Tag="State.Universal.Dash.B",DevComment="")
+GameplayTagList=(Tag="State.Universal.Dash.F.Stop",DevComment="")
+GameplayTagList=(Tag="State.Universal.FaceUp.Bounce",DevComment="")
+GameplayTagList=(Tag="State.Universal.Jump.B",DevComment="")
+GameplayTagList=(Tag="State.Universal.Jump.F",DevComment="")
+GameplayTagList=(Tag="State.Universal.Jump.Pre.B",DevComment="")
+GameplayTagList=(Tag="State.Universal.Jump.Pre.F",DevComment="")
+GameplayTagList=(Tag="State.Universal.Jump.Pre.V",DevComment="")
+GameplayTagList=(Tag="State.Universal.StandToCrouch",DevComment="")
+GameplayTagList=(Tag="State.Universal.SuperJump.B",DevComment="")
+GameplayTagList=(Tag="State.Universal.SuperJump.F",DevComment="")
+GameplayTagList=(Tag="State.Universal.SuperJump.Pre.B",DevComment="")
+GameplayTagList=(Tag="State.Universal.SuperJump.Pre.F",DevComment="")
+GameplayTagList=(Tag="State.Universal.SuperJump.Pre.V",DevComment="")
+GameplayTagList=(Tag="State.Universal.SuperJump.V",DevComment="")
+GameplayTagList=(Tag="State.Universal.Tech.Air",DevComment="")
+GameplayTagList=(Tag="State.Universal.Walk.B",DevComment="")
+GameplayTagList=(Tag="State.Universal.Walk.F",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.AnyCancel.Crouch",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.AnyCancel.Stand",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.Assist.2nd",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.Assist.3rd",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.AttackLevel.0",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.AttackLevel.1",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.AttackLevel.2",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.AttackLevel.3",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.AttackLevel.4",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.AttackLevel.5",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.Float.Body",DevComment="")
+GameplayTagList=(Tag="Subroutine.Cmn.Float.Head",DevComment="")


```

`Config/DefaultInput.ini`:

```ini
[/Script/Engine.InputSettings]
-AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
bAltEnterTogglesFullscreen=True
bF11TogglesFullscreen=True
bUseMouseForTouch=False
bEnableMouseSmoothing=True
bEnableFOVScaling=True
bCaptureMouseOnLaunch=True
bEnableLegacyInputScales=True
bEnableMotionControls=True
bFilterInputByPlatformUser=False
bShouldFlushPressedKeysOnViewportFocusLost=True
bAlwaysShowTouchInterface=False
bShowConsoleOnFourFingerTap=True
bEnableGestureRecognizer=False
bUseAutocorrect=False
DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
DefaultViewportMouseLockMode=LockOnCapture
FOVScale=0.011110
DoubleClickTime=0.200000
DefaultPlayerInputClass=/Script/EnhancedInput.EnhancedPlayerInput
DefaultInputComponentClass=/Script/EnhancedInput.EnhancedInputComponent
DefaultTouchInterface=/Game/NightSkyEngine/Shared/Input/Battle/TouchInterface.TouchInterface
-ConsoleKeys=Tilde
+ConsoleKeys=Tilde
+ConsoleKeys=Caret

[/Script/EnhancedInput.EnhancedInputDeveloperSettings]
bEnableUserSettings=True
UserSettingsClass=/Script/NightSkyEngine.NSEEnhancedInputUserSettings
DefaultPlayerMappableKeyProfileClass=/Script/NightSkyEngine.NSEPlayerMappableKeyProfile


```

`LICENSE`:

```
MIT License

Copyright (c) 2023 WistfulHopes

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`NightSkyEngine.uproject`:

```uproject
{
	"FileVersion": 3,
	"EngineAssociation": "5.7",
	"Category": "",
	"Description": "",
	"Modules": [
		{
			"Name": "NightSkyEngineDemo",
			"Type": "Runtime",
			"LoadingPhase": "Default",
			"AdditionalDependencies": [
				"Engine",
				"CoreUObject",
				"NightSkyEngine",
				"GGPOUE4"
			]
		}
	],
	"Plugins": [
		{
			"Name": "ModelingToolsEditorMode",
			"Enabled": true
		},
		{
			"Name": "CommonUI",
			"Enabled": true
		},
		{
			"Name": "OnlineSubsystemSteam",
			"Enabled": true
		},
		{
			"Name": "NNEDenoiser",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win64",
				"Linux",
				"Mac"
			]
		}
	],
	"TargetPlatforms": [],
	"AdditionalRootDirectories": [],
	"AdditionalPluginDirectories": [],
	"EpicSampleNameHash": ""
}
```

`Plugins/NightSkyEngine/NightSkyEngine.uplugin`:

```uplugin
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "1.0",
	"FriendlyName": "Night Sky Engine",
	"Description": "A fighting game framework designed for Unreal Engine 5",
	"Category": "Gameplay",
	"CreatedBy": "WistfulHopes",
	"CreatedByURL": "https://x.com/WistfulHopes",
	"DocsURL": "https://wistfulhopes.github.io/NightSkyEngine/",
	"MarketplaceURL": "",
	"SupportURL": "",
	"CanContainContent": true,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "NightSkyEngine",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		},
		{
			"Name": "GGPOUE4",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		},
		{
			"Name": "CollisionEditor",
			"Type": "Editor",
			"LoadingPhase": "PostEngineInit"
		},
		{
			"Name": "NightSkyEngineEditor",
			"Type": "Editor",
			"LoadingPhase": "Default"
		}
	],
	"Plugins": [
		{
			"Name": "OnlineSubsystem",
			"Enabled": true
		},
		{
			"Name": "OnlineSubsystemUtils",
			"Enabled": true
		},
		{
			"Name": "EnhancedInput",
			"Enabled": true
		},
		{
			"Name": "Niagara",
			"Enabled": true
		},
		{
			"Name": "Paper2D",
			"Enabled": true
		},
		{
			"Name": "CommonUI",
			"Enabled": true
		},
		{
			"Name": "StateTree",
			"Enabled": true
		}
	]
}
```

`Plugins/NightSkyEngine/Source/CollisionEditor/CollisionEditor.Build.cs`:

```cs
// Copyright Screaming Goose Games. All Rights Reserved.

using UnrealBuildTool;

public class CollisionEditor : ModuleRules
{
	public CollisionEditor(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

        PrivateIncludePaths.AddRange(
            new string[] {
                "CollisionEditor/Public",
				// Because the other way wasn't working for me, fix later
				"NightSkyEngine"
            }
        );

        PublicDependencyModuleNames.AddRange(new string[] 
			{ 
				"Core",
				"CoreUObject",
				"Engine"
			});
		
		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
                "NightSkyEngine",
				"UnrealEd",
				"AssetTools",
				"EditorFramework",
				"EditorStyle",
                "Slate",
                "SlateCore",
				"InputCore",
				"EditorWidgets",
				"PropertyEditor",
				"AdvancedPreviewScene",
				"GameplayTags",
				"GameplayTagsEditor"
            });
		
		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
				
			});
	}
}

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/AssetTypeActions_CollisionData.cpp`:

```cpp
#include "AssetTypeActions_CollisionData.h"
#include "CollisionDataEditorToolkit.h"
#include "Toolkits/IToolkit.h"
#include "Math/Color.h"
#include "Internationalization/Internationalization.h" // included to use LOCTEXT

#define LOCTEXT_NAMESPACE "NightSkyCollisionEditor"

FColor FAssetTypeActions_CollisionData::GetTypeColor() const
{
	return FColor(0, 255, 0);
}

UClass* FAssetTypeActions_CollisionData::GetSupportedClass() const
{
    return UCollisionData::StaticClass();
}

void FAssetTypeActions_CollisionData::OpenAssetEditor(const TArray<UObject*>& InObjects, TSharedPtr<IToolkitHost> EditWithinLevelEditor)
{
    for (auto ObjIt = InObjects.CreateConstIterator(); ObjIt; ++ObjIt)
    {
        auto CollisionData = Cast<UCollisionData>(*ObjIt);
        if (CollisionData != nullptr)
        {
            // Create an instance of the editor. Let Unreal manage the editor's lifecycle.
            TSharedRef<FCollisionDataEditorToolkit> Editor = MakeShareable(new FCollisionDataEditorToolkit());
            Editor->Initialize(CollisionData, EToolkitMode::Standalone, EditWithinLevelEditor);
        }
    }
}


FText FAssetTypeActions_CollisionData::GetName() const
{
    return NSLOCTEXT("AssetTypeActions", "FAssetTypeActionsCollisionDataName", "Collision Data");
}

uint32 FAssetTypeActions_CollisionData::GetCategories()
{
    return AssetCategory;
}

#undef LOCTEXT_NAMESPACE
```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/CelAssetTree.cpp`:

```cpp
#include "CelAssetTree.h"

#include "Logging.h"
#include "Data/CollisionData.h"
#include "Styling/AppStyle.h"
#include "Widgets/Layout/SBorder.h"
#include "Widgets/Text/STextBlock.h"

TSharedPtr<FCelAssetTreeNode> FCelAssetTreeNode::FindOrCreateChild(const FString& ChildName, int32 ChildCelIndex)
{
	// Look for existing child with this name
	for (const TSharedPtr<FCelAssetTreeNode>& Child : Children)
	{
		if (Child->GetDisplayName() == ChildName)
		{
			// If we're trying to set a cel index on an existing category node, update it
			// This happens when e.g. "Attack" exists as both a parent for "Attack.00" and as a cel itself
			if (ChildCelIndex != INDEX_NONE && Child->IsCategory())
			{
				Child->SetCelIndex(ChildCelIndex);
			}
			return Child;
		}
	}

	// Create new child
	TSharedPtr<FCelAssetTreeNode> NewChild = MakeShared<FCelAssetTreeNode>(ChildName, ChildCelIndex);
	NewChild->Parent = AsShared();
	Children.Add(NewChild);
	return NewChild;
}

void SCelAssetTree::Construct(const FArguments& InArgs, UCollisionData* InCollisionData)
{
	CollisionData = InCollisionData;
	OnCelSelectedDelegate = InArgs._OnCelSelected;

	ChildSlot
	[
		// TODO: When we implement filtering, add a new SVerticalBox at the top
		SNew(SVerticalBox)
		+ SVerticalBox::Slot()
		.FillHeight(1.f)
		[
			SNew(SBorder)
			.BorderImage(FAppStyle::GetBrush("ToolPanel.GroupBorder"))
			.Padding(2.f)
			[
				SAssignNew(TreeView, STreeView<TSharedPtr<FCelAssetTreeNode>>)
				.TreeItemsSource(&RootNodes)
				.SelectionMode(ESelectionMode::Single)
				.OnGenerateRow(this, &SCelAssetTree::GenerateTreeRow)
				.OnGetChildren(this, &SCelAssetTree::GetChildrenForNode)
				.OnSelectionChanged(this, &SCelAssetTree::OnSelectionChanged)
			]
		]
	];

	RefreshTree();
}

void SCelAssetTree::RefreshTree()
{
	RootNodes.Empty();
	AllNodes.Empty();
	CelIndexToNodeMap.Empty();

	BuildTreeFromCollisionData();

	if (TreeView.IsValid())
	{
		TreeView->RequestTreeRefresh();

		// Expand all root nodes by default
		for (const TSharedPtr<FCelAssetTreeNode>& RootNode : RootNodes)
		{
			TreeView->SetItemExpansion(RootNode, true);
		}
	}
}

void SCelAssetTree::BuildTreeFromCollisionData()
{
	UCollisionData* Data = CollisionData.Get();
	if (!Data)
	{
		return;
	}

	// Build a map of category paths to nodes
	TMap<FString, TSharedPtr<FCelAssetTreeNode>> CategoryMap;
	
	TMap<FGameplayTag, int32> SeenTags;  // For duplicate detection
	TSharedPtr<FCelAssetTreeNode> ProblemsCategory;

	for (int32 CelIdx = 0; CelIdx < Data->CollisionFrames.Num(); ++CelIdx)
	{
		const FCollisionStruct& Cel = Data->CollisionFrames[CelIdx];
		
		// Check for problems
		bool bIsUnnamed = !Cel.CelName.IsValid();
		bool bIsDuplicate = false;
		if (!bIsUnnamed)
		{
			if (SeenTags.Find(Cel.CelName))
			{
				bIsDuplicate = true;
			}
			else
			{
				SeenTags.Add(Cel.CelName, CelIdx);
			}
		}
        
		if (bIsUnnamed || bIsDuplicate)
		{
			// Create Problems category on first problematic cel
			if (!ProblemsCategory.IsValid())
			{
				ProblemsCategory = MakeShared<FCelAssetTreeNode>(TEXT("Problems"));
				RootNodes.Insert(ProblemsCategory, 0);  // Always at the top
			}
            
			FString ProblemName = bIsUnnamed 
				? FString::Printf(TEXT("Unnamed Cel at Index [%d]"), CelIdx)
				: FString::Printf(TEXT("[%s] Duplicate at [%d])"), *Cel.CelName.ToString(), CelIdx);
			
			const TCHAR* ProblemChars = *ProblemName;
			UE_LOG(LogCollisionEditor, Error, TEXT("%s"), ProblemChars);
            
			auto ProblemNode = MakeShared<FCelAssetTreeNode>(CelIdx, ProblemName, true);
			ProblemNode->Parent = ProblemsCategory;
			ProblemsCategory->Children.Add(ProblemNode);
			CelIndexToNodeMap.Add(CelIdx, ProblemNode);
			continue;
		}

		// Parse the GameplayTag path
		// We currently use the form Character.StateCategory[.Subcategory].State.[Substate].[Index]
		FString TagString = Cel.CelName.ToString();
		TArray<FString> PathParts;
		TagString.ParseIntoArray(PathParts, TEXT("."));

		if (PathParts.Num() == 0)
		{
			continue;
		}

		// Build tree structure from path
		// Skip the first part if it's a common prefix like "Cel"
		int32 StartIndex = 0;
		if (PathParts.Num() > 1 && PathParts[0].Equals(TEXT("Cel"), ESearchCase::IgnoreCase))
		{
			StartIndex = 1;
		}

		TSharedPtr<FCelAssetTreeNode> CurrentParent;
		FString CurrentPath;

		for (int32 i = StartIndex; i < PathParts.Num(); ++i)
		{
			const FString& Part = PathParts[i];
			CurrentPath = CurrentPath.IsEmpty() ? Part : (CurrentPath + TEXT(".") + Part);

			bool bIsLeaf = (i == PathParts.Num() - 1);

			if (!CurrentParent.IsValid())
			{
				// Looking for/creating a root node
				TSharedPtr<FCelAssetTreeNode>* ExistingRoot = CategoryMap.Find(CurrentPath);
				if (ExistingRoot && ExistingRoot->IsValid())
				{
					// If this is a leaf and the existing node is a category, update its CelIndex
					if (bIsLeaf && (*ExistingRoot)->IsCategory())
					{
						(*ExistingRoot)->SetCelIndex(CelIdx);
						CelIndexToNodeMap.Add(CelIdx, *ExistingRoot);
					}
					CurrentParent = *ExistingRoot;
				}
				else
				{
					TSharedPtr<FCelAssetTreeNode> NewNode = MakeShared<FCelAssetTreeNode>(
						Part,
						bIsLeaf ? CelIdx : INDEX_NONE
					);
					RootNodes.Add(NewNode);
					AllNodes.Add(NewNode);
					CategoryMap.Add(CurrentPath, NewNode);
					CurrentParent = NewNode;

					if (bIsLeaf)
					{
						CelIndexToNodeMap.Add(CelIdx, NewNode);
					}
				}
			}
			else
			{
				// Creating/finding a child node
				TSharedPtr<FCelAssetTreeNode>* ExistingNode = CategoryMap.Find(CurrentPath);
				if (ExistingNode && ExistingNode->IsValid())
				{
					// If this is a leaf and the existing node is a category, update its CelIndex
					if (bIsLeaf && (*ExistingNode)->IsCategory())
					{
						(*ExistingNode)->SetCelIndex(CelIdx);
						CelIndexToNodeMap.Add(CelIdx, *ExistingNode);
					}
					CurrentParent = *ExistingNode;
				}
				else
				{
					TSharedPtr<FCelAssetTreeNode> NewNode = CurrentParent->FindOrCreateChild(
						Part,
						bIsLeaf ? CelIdx : INDEX_NONE
					);
					AllNodes.Add(NewNode);
					CategoryMap.Add(CurrentPath, NewNode);
					CurrentParent = NewNode;

					if (bIsLeaf)
					{
						CelIndexToNodeMap.Add(CelIdx, NewNode);
					}
				}
			}
		}
	}

	// Sort root nodes and their children alphabetically
	auto SortNodes = [](TArray<TSharedPtr<FCelAssetTreeNode>>& Nodes)
	{
		Nodes.Sort([](const TSharedPtr<FCelAssetTreeNode>& A, const TSharedPtr<FCelAssetTreeNode>& B)
		{
			// Categories before cels, then alphabetical
			if (A->IsCategory() != B->IsCategory())
			{
				return A->IsCategory();
			}
			return A->GetDisplayName() < B->GetDisplayName();
		});
	};

	TFunction<void(TSharedPtr<FCelAssetTreeNode>&)> SortRecursive = [&](TSharedPtr<FCelAssetTreeNode>& Node)
	{
		SortNodes(Node->Children);
		for (TSharedPtr<FCelAssetTreeNode>& Child : Node->Children)
		{
			SortRecursive(Child);
		}
	};

	SortNodes(RootNodes);
	for (TSharedPtr<FCelAssetTreeNode>& RootNode : RootNodes)
	{
		SortRecursive(RootNode);
	}
}

void SCelAssetTree::SetSelectedCel(const FGameplayTag& CelName)
{
	if (!TreeView.IsValid() || !CollisionData.IsValid())
	{
		return;
	}

	// Find cel index
	UCollisionData* Data = CollisionData.Get();
	for (int32 i = 0; i < Data->CollisionFrames.Num(); ++i)
	{
		if (Data->CollisionFrames[i].CelName == CelName)
		{
			TSharedPtr<FCelAssetTreeNode>* NodePtr = CelIndexToNodeMap.Find(i);
			if (NodePtr && NodePtr->IsValid())
			{
				// Expand parents
				TSharedPtr<FCelAssetTreeNode> Parent = (*NodePtr)->Parent.Pin();
				while (Parent.IsValid())
				{
					TreeView->SetItemExpansion(Parent, true);
					Parent = Parent->Parent.Pin();
				}

				TreeView->SetSelection(*NodePtr);
				TreeView->RequestScrollIntoView(*NodePtr);
			}
			break;
		}
	}
}

TSharedRef<ITableRow> SCelAssetTree::GenerateTreeRow(
	TSharedPtr<FCelAssetTreeNode> InNode,
	const TSharedRef<STableViewBase>& OwnerTable)
{
	FText DisplayText = FText::FromString(InNode->GetDisplayName());

	// Use different styling for categories vs cels
	FSlateFontInfo Font = InNode->IsCategory()
		? FAppStyle::GetFontStyle("NormalFontBold")
		: FAppStyle::GetFontStyle("NormalFont");

	return SNew(STableRow<TSharedPtr<FCelAssetTreeNode>>, OwnerTable)
		[
			SNew(SHorizontalBox)
			+ SHorizontalBox::Slot()
			.AutoWidth()
			.Padding(2.f, 1.f)
			.VAlign(VAlign_Center)
			[
				SNew(STextBlock)
				.Text(DisplayText)
				.Font(Font)
			]
		];
}

void SCelAssetTree::GetChildrenForNode(
	TSharedPtr<FCelAssetTreeNode> InNode,
	TArray<TSharedPtr<FCelAssetTreeNode>>& OutChildren)
{
	if (InNode.IsValid())
	{
		OutChildren = InNode->Children;
	}
}

void SCelAssetTree::OnSelectionChanged(
	TSharedPtr<FCelAssetTreeNode> SelectedNode,
	ESelectInfo::Type SelectInfo)
{
	if (!SelectedNode.IsValid() || !SelectedNode->IsCel())
	{
		return;
	}

	UCollisionData* Data = CollisionData.Get();
	if (!Data)
	{
		return;
	}

	int32 CelIdx = SelectedNode->GetCelIndex();
	if (Data->CollisionFrames.IsValidIndex(CelIdx))
	{
		OnCelSelectedDelegate.ExecuteIfBound(CelIdx);
	}
}

void SCelAssetTree::OnFilterTextChanged(const FText& InText)
{
	CurrentFilterString = InText.ToString();
	RefreshTree();
}

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/CollisionDataDetails.cpp`:

```cpp
#include "CollisionDataDetails.h"
#include "DetailCategoryBuilder.h"
#include "DetailLayoutBuilder.h"
#include "DetailWidgetRow.h"
#include "GameplayTagsEditorModule.h"
#include "PropertyHandle.h"
#include "ScopedTransaction.h"
#include "Data/CollisionData.h"
#include "Styling/AppStyle.h"
#include "Widgets/Input/SButton.h"
#include "Widgets/Layout/SBox.h"
#include "Widgets/Layout/SUniformGridPanel.h"
#include "Widgets/Text/STextBlock.h"

#define LOCTEXT_NAMESPACE "NightSkyCollisionEditor"

TSharedRef<IDetailCustomization> FCollisionDataDetails::MakeInstance()
{
	return MakeShareable(new FCollisionDataDetails);
}

void FCollisionDataDetails::CustomizeDetails(IDetailLayoutBuilder& DetailBuilder)
{
	CachedDetailBuilder = &DetailBuilder;

	TArray<TWeakObjectPtr<UObject>> ObjectsBeingCustomized;
	DetailBuilder.GetObjectsBeingCustomized(ObjectsBeingCustomized);

	if (ObjectsBeingCustomized.Num() != 1)
	{
		return;
	}

	CollisionDataPtr = Cast<UCollisionData>(ObjectsBeingCustomized[0].Get());
	if (!CollisionDataPtr.IsValid())
	{
		return;
	}

	CollisionFramesHandle = DetailBuilder.GetProperty(
		GET_MEMBER_NAME_CHECKED(UCollisionData, CollisionFrames));

	// Hide the default array display
	DetailBuilder.HideProperty(CollisionFramesHandle);

	// Also hide the transient editor property
	DetailBuilder.HideProperty(GET_MEMBER_NAME_CHECKED(UCollisionData, EditorSelectedIndex));

	IDetailCategoryBuilder& Category = DetailBuilder.EditCategory(
		"Selected Cel",
		LOCTEXT("SelectedCelCategory", "Selected Cel"),
		ECategoryPriority::Important);

	BuildSelectedCelView(DetailBuilder, Category);
}

void FCollisionDataDetails::BuildSelectedCelView(IDetailLayoutBuilder& DetailBuilder, IDetailCategoryBuilder& Category)
{
	UCollisionData* CollisionData = CollisionDataPtr.Get();
	if (!CollisionData)
	{
		return;
	}

	// Add "Add New Cel" button at the top
	Category.AddCustomRow(LOCTEXT("AddCelRow", "Add Cel"))
		.WholeRowContent()
		.HAlign(HAlign_Center)
		.VAlign(VAlign_Center)
		[
			SNew(SHorizontalBox)
			+ SHorizontalBox::Slot()
			.AutoWidth()
			[
				SNew(SButton)
				.Text(LOCTEXT("AddNewCel", "Add New Cel"))
				.HAlign(HAlign_Center)
				.VAlign(VAlign_Center)
				.OnClicked(this, &FCollisionDataDetails::OnAddNewCel)
			]
			+ SHorizontalBox::Slot()
			.AutoWidth()
			.Padding(2.f)
			[
				SNew(SButton)
				.Text(LOCTEXT("DeleteSelectedCel", "Delete Selected"))
				.HAlign(HAlign_Center)
				.VAlign(VAlign_Center)
				.IsEnabled(this, &FCollisionDataDetails::CanDeleteSelectedCel)
				.OnClicked(this, &FCollisionDataDetails::OnDeleteSelectedCel)
			]
		];
	
	Category.AddCustomRow(LOCTEXT("TemplateSelectedCelRow", "New Cel From Selected"))
		.WholeRowContent()
		[
			SNew(SButton)
			.Text(LOCTEXT("NewCelFromSelected", "New Cel From Selected"))
			.VAlign(VAlign_Center)
			.HAlign(HAlign_Center)
			.IsEnabled(this, &FCollisionDataDetails::CanTemplateSelectedCel)
			.OnClicked(this, &FCollisionDataDetails::OnTemplateSelectedCel)
		];
	
	Category.AddCustomRow(LOCTEXT("RefreshTreeRow", "Refresh Tree"))
		.WholeRowContent()
		[
			SNew(SButton)
			.HAlign(HAlign_Center)
			.VAlign(VAlign_Center)
			.Text(LOCTEXT("RefreshTree", "Refresh Tree"))
			.VAlign(VAlign_Center)
			.HAlign(HAlign_Center)
			.OnClicked(this, &FCollisionDataDetails::OnRefreshTree)
		];

#if WITH_EDITORONLY_DATA
	const int32 SelectedIndex = CollisionData->EditorSelectedIndex;

	if (SelectedIndex == INDEX_NONE || !CollisionData->CollisionFrames.IsValidIndex(SelectedIndex))
	{
		Category.AddCustomRow(LOCTEXT("NoSelectionRow", "No Selection"))
			.WholeRowContent()
			[
				SNew(SBox)
				.Padding(FMargin(8.f, 16.f))
				[
					SNew(STextBlock)
					.Text(LOCTEXT("SelectCelPrompt", "Select a cel from the tree to edit its properties"))
					.Font(FAppStyle::GetFontStyle("NormalFont"))
					.ColorAndOpacity(FSlateColor::UseSubduedForeground())
				]
			];
		return;
	}

	const FCollisionStruct& SelectedCel = CollisionData->CollisionFrames[SelectedIndex];

	// Show header with cel name
	Category.AddCustomRow(LOCTEXT("CelNameRow", "Tree View Name"))
		.NameContent()
		[
			SNew(STextBlock)
			.Text(LOCTEXT("CelNameLabel", "Registered Cel Name"))
			.Font(FAppStyle::GetFontStyle("NormalFontBold"))
		]
		.ValueContent()
		[
			SNew(STextBlock)
			.Text(FText::FromString(SelectedCel.CelName.ToString()))
			.Font(FAppStyle::GetFontStyle("NormalFont"))
		];

	// Get the property handle for this specific array element
	TSharedPtr<IPropertyHandle> ElementHandle = CollisionFramesHandle->GetChildHandle(SelectedIndex);
	if (!ElementHandle.IsValid())
	{
		return;
	}

	// Add all child properties
	uint32 NumChildren = 0;
	ElementHandle->GetNumChildren(NumChildren);

	for (uint32 ChildIdx = 0; ChildIdx < NumChildren; ++ChildIdx)
	{
		TSharedPtr<IPropertyHandle> ChildHandle = ElementHandle->GetChildHandle(ChildIdx);
		if (ChildHandle.IsValid())
		{
			// Show all properties including CelName (it's editable here)
			Category.AddProperty(ChildHandle);
		}
	}
#endif
}

FReply FCollisionDataDetails::OnAddNewCel()
{
	UCollisionData* CollisionData = CollisionDataPtr.Get();
	if (!CollisionData)
	{
		return FReply::Handled();
	}

	FScopedTransaction Transaction(LOCTEXT("AddNewCelTransaction", "Add New Cel"));
	CollisionData->Modify();

	FCollisionStruct NewCel;
	CollisionData->CollisionFrames.Add(NewCel);

#if WITH_EDITORONLY_DATA
	// Select the new cel
	CollisionData->EditorSelectedIndex = CollisionData->CollisionFrames.Num() - 1;
	CollisionData->NotifyCollisionFramesChanged();
#endif

	if (CachedDetailBuilder)
	{
		CachedDetailBuilder->ForceRefreshDetails();
	}

	return FReply::Handled();
}

FReply FCollisionDataDetails::OnDeleteSelectedCel()
{
	UCollisionData* CollisionData = CollisionDataPtr.Get();
	if (!CollisionData)
	{
		return FReply::Handled();
	}

#if WITH_EDITORONLY_DATA
	const int32 SelectedIndex = CollisionData->EditorSelectedIndex;
	if (SelectedIndex == INDEX_NONE || !CollisionData->CollisionFrames.IsValidIndex(SelectedIndex))
	{
		return FReply::Handled();
	}

	FScopedTransaction Transaction(LOCTEXT("DeleteCelTransaction", "Delete Cel"));
	CollisionData->Modify();

	CollisionData->CollisionFrames.RemoveAt(SelectedIndex);

	// Adjust selection
	if (CollisionData->CollisionFrames.Num() == 0)
	{
		CollisionData->EditorSelectedIndex = INDEX_NONE;
	}
	else if (SelectedIndex >= CollisionData->CollisionFrames.Num())
	{
		CollisionData->EditorSelectedIndex = CollisionData->CollisionFrames.Num() - 1;
	}

	CollisionData->NotifyCollisionFramesChanged();

	if (CachedDetailBuilder)
	{
		CachedDetailBuilder->ForceRefreshDetails();
	}
#endif

	return FReply::Handled();
}

FReply FCollisionDataDetails::OnTemplateSelectedCel()
{
	UCollisionData* CollisionData = CollisionDataPtr.Get();
	if (!CollisionData)
	{
		return FReply::Handled();
	}

#if WITH_EDITORONLY_DATA
	const int32 SelectedIndex = CollisionData->EditorSelectedIndex;
	if (SelectedIndex == INDEX_NONE || !CollisionData->CollisionFrames.IsValidIndex(SelectedIndex))
	{
		return FReply::Handled();
	}

	const FCollisionStruct& SourceCel = CollisionData->CollisionFrames[SelectedIndex];

	// Default name: same as original but without the ending index (numbers) portion of the tag
	FGameplayTag NewCelDefaultName;
	if (SourceCel.CelName.IsValid())
	{
		FString TagString = SourceCel.CelName.ToString();
		int32 LastPeriodIndex;
		TagString.FindLastChar('.', LastPeriodIndex);
		if (LastPeriodIndex != INDEX_NONE)
		{
			// If the last portion of the tag is numeric, we use its parent as the default name
			auto LastTagString = TagString.RightChop(TagString.Len() - LastPeriodIndex);
			if (LastTagString.IsNumeric())
			{
				NewCelDefaultName = SourceCel.CelName.RequestDirectParent();
			}
			else
			{
				NewCelDefaultName = SourceCel.CelName;
			}
		}
		else
		{
			NewCelDefaultName = SourceCel.CelName;
		}
	}

	// ---- Dialog window for selecting the new tag name ----

	// Store result
	bool bUserConfirmed = false;
	
	const FVector2D InitialSize(450.0f, 500.0f);
	
	FWindowSizeLimits WindowSizeLimits;
	WindowSizeLimits.SetMinWidth(InitialSize.X).SetMinHeight(InitialSize.Y);
	
	// Need a shared ptr for the window so we can close it from button handlers
	TSharedRef<SWindow> PickerWindow = SNew(SWindow)
		.Title(LOCTEXT("PickCelTagTitle", "Pick Cel Tag"))
		.ClientSize(InitialSize)
		.SupportsMinimize(false)
		.SupportsMaximize(false)
		.SizingRule(ESizingRule::Autosized);

	PickerWindow->SetSizeLimits(WindowSizeLimits);
	
	// Build tag widget
	// IGameplayTagsEditorModule::Get invokes LoadModuleChecked
	IGameplayTagsEditorModule& TagsEditorModule = IGameplayTagsEditorModule::Get();

	// Editable single-tag field
	TSharedPtr<FGameplayTag> EditableNewName = MakeShared<FGameplayTag>(NewCelDefaultName);

	// Build widget
	TSharedRef<SWidget> TagWidget =
		TagsEditorModule.MakeGameplayTagWidget(
			FOnSetGameplayTag::CreateLambda(
				[&EditableNewName](FGameplayTag InTag)
				{
					*EditableNewName = InTag;
				}),
			EditableNewName,
			FString("") // TODO: second button with filtering
		);
	
	// Compose window content with tag widget + OK/Cancel
	PickerWindow->SetContent(
		SNew(SBorder)
		.BorderImage(FAppStyle::GetBrush("ToolPanel.GroupBorder"))
		[
			SNew(SVerticalBox)

			+ SVerticalBox::Slot()
			.AutoHeight()
			.Padding(8.0f)
			[
				SNew(STextBlock)
				.Text(LOCTEXT("PickCelTagLabel", "Select a new cel tag"))
			]

			+ SVerticalBox::Slot()
			.FillHeight(1.0f)
			.Padding(8.0f)
			[
				TagWidget
			]

			+ SVerticalBox::Slot()
			.AutoHeight()
			.HAlign(HAlign_Right)
			.Padding(8.0f)
			[
				SNew(SUniformGridPanel)
				.SlotPadding(FMargin(2.0f))

				+ SUniformGridPanel::Slot(0, 0)
				[
					SNew(SButton)
					.Text(LOCTEXT("OK", "OK"))
					.HAlign(HAlign_Center)
					.VAlign(VAlign_Center)
					.OnClicked_Lambda(
						[&PickerWindow, &bUserConfirmed]()
						{
							bUserConfirmed = true;
							FSlateApplication::Get().RequestDestroyWindow(PickerWindow);
							return FReply::Handled();
						})
				]

				+ SUniformGridPanel::Slot(1, 0)
				[
					SNew(SButton)
					.Text(LOCTEXT("Cancel", "Cancel"))
					.HAlign(HAlign_Center)
					.VAlign(VAlign_Center)
					.OnClicked_Lambda(
						[&PickerWindow]()
						{
							FSlateApplication::Get().RequestDestroyWindow(PickerWindow);
							return FReply::Handled();
						})
				]
			]
		]);

	// This call BLOCKS until the modal window is closed
	FSlateApplication::Get().AddModalWindow(PickerWindow, nullptr);
	
	if (bUserConfirmed && EditableNewName.IsValid() && EditableNewName->IsValid())
	{
		// Re-validate after the modal dialog closes in case the array changed
		if (!CollisionData->CollisionFrames.IsValidIndex(SelectedIndex))
		{
			return FReply::Handled();
		}
		
		FScopedTransaction Transaction(LOCTEXT("TemplateSelectedCelTransaction", "New Cel From Selected"));
		CollisionData->Modify();
		
		FCollisionStruct NewCel = CollisionData->CollisionFrames[SelectedIndex];
		NewCel.CelName = *EditableNewName;

		const int32 NewIndex = CollisionData->CollisionFrames.Add(NewCel);
		CollisionData->EditorSelectedIndex = NewIndex;
		
		// Notify tree view and refresh the details panel to prevent stale property handles
		CollisionData->NotifyCollisionFramesChanged();
		
		if (CachedDetailBuilder)
		{
			CachedDetailBuilder->ForceRefreshDetails();
		}
	}
#endif
	
	return FReply::Handled();
}

bool FCollisionDataDetails::CanTemplateSelectedCel() const
{
#if WITH_EDITORONLY_DATA
	UCollisionData* CollisionData = CollisionDataPtr.Get();
	if (CollisionData)
	{
		const int32 SelectedIndex = CollisionData->EditorSelectedIndex;
		return SelectedIndex != INDEX_NONE && CollisionData->CollisionFrames.IsValidIndex(SelectedIndex);
	}
#endif
	return false;
}

bool FCollisionDataDetails::CanDeleteSelectedCel() const
{
#if WITH_EDITORONLY_DATA
	UCollisionData* CollisionData = CollisionDataPtr.Get();
	if (CollisionData)
	{
		const int32 SelectedIndex = CollisionData->EditorSelectedIndex;
		return SelectedIndex != INDEX_NONE && CollisionData->CollisionFrames.IsValidIndex(SelectedIndex);
	}
#endif
	return false;
}

FReply FCollisionDataDetails::OnRefreshTree()
{
	UCollisionData* CollisionData = CollisionDataPtr.Get();
	if (!CollisionData)
	{
		return FReply::Handled();
	}

#if WITH_EDITORONLY_DATA
	CollisionData->NotifyCollisionFramesChanged();
#endif

	if (CachedDetailBuilder)
	{
		CachedDetailBuilder->ForceRefreshDetails();
	}

	return FReply::Handled();
}

void FCollisionDataDetails::OnCelSelected(const FGameplayTag& CelName)
{
	SelectedCelName = CelName;
	if (CachedDetailBuilder)
	{
		CachedDetailBuilder->ForceRefreshDetails();
	}
}

#undef LOCTEXT_NAMESPACE

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/CollisionDataEditorToolkit.cpp`:

```cpp
#include "CollisionDataEditorToolkit.h"
#include "Logging.h"
#include "CelAssetTree.h"
#include "Battle/Objects/PlayerObject.h"
#include "Data/CollisionData.h"
#include "Editor/PropertyEditor/Public/PropertyEditorModule.h"
#include "Viewport/CollisionAnimationPreviewScene.h"
#include "Viewport/CollisionAnimationViewport.h"
#include "Widgets/Docking/SDockTab.h"
#include "Widgets/Layout/SBorder.h"
#include "Widgets/Text/STextBlock.h"


#define LOCTEXT_NAMESPACE "NightSkyCollisionEditor"

FCollisionDataEditorToolkit::FCollisionDataEditorToolkit()
{
}

FCollisionDataEditorToolkit::~FCollisionDataEditorToolkit()
{
}

void FCollisionDataEditorToolkit::Initialize(UCollisionData* InCollisionData, const EToolkitMode::Type Mode,
                                             const TSharedPtr<IToolkitHost>& InitToolkitHost)
{
	CollisionData = InCollisionData;
	
	for (auto& Collision : CollisionData->CollisionFrames)
	{
		for (auto& Box : Collision.Boxes)
		{
			Box.EditorInit();
		}
	}

	// Setup details view
	FPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>("PropertyEditor");
	FDetailsViewArgs DetailsViewArgs;
	DetailsViewArgs.bUpdatesFromSelection = true;
	DetailsViewArgs.bLockable = false;
	DetailsViewArgs.bAllowSearch = true;
	DetailsViewArgs.bHideSelectionTip = true;

	DetailsView = PropertyModule.CreateDetailView(DetailsViewArgs);
	DetailsView->SetObject(CollisionData);

	// Setup PlayerObject BP picker
	InitializePlayerObjectBPPicker();
	// Setup cel asset tree
	InitializeCelAssetTree();

#if WITH_EDITORONLY_DATA
	// Subscribe to collision frames changes to refresh tree
	CollisionData->OnCollisionFramesChanged.AddSP(this, &FCollisionDataEditorToolkit::OnCollisionFramesChanged);
#endif

	// Set up viewport
	InitializePreviewScene();

	// Define the layout
	const TSharedRef<FTabManager::FLayout> StandaloneLayout = FTabManager::NewLayout(
		"Standalone_CollisionDataEditor_Layout")
		->AddArea
		(
			FTabManager::NewPrimaryArea()
			->SetOrientation(Orient_Horizontal)
			->Split
			(
				// Left side
				FTabManager::NewStack()
				->AddTab("PlayerObjectSelectorTab", ETabState::OpenedTab)
				->SetSizeCoefficient(0.15f)
			)
			->Split
			(
				// Middle
				FTabManager::NewStack()
				->AddTab("ViewportTab", ETabState::OpenedTab)
				->SetHideTabWell(true)
				->SetSizeCoefficient(0.55f)
			)
			->Split
			(
				// Right side
				FTabManager::NewStack()
				->AddTab("CollisionDataDetailsTab", ETabState::OpenedTab)
				->SetSizeCoefficient(0.3f)
			)
		);

	// Register tab spawners
	// Ensure the ToolkitHost is valid and has a valid TabManager
	if (InitToolkitHost.IsValid() && InitToolkitHost->GetTabManager().IsValid())
	{
		TabManager = InitToolkitHost->GetTabManager(); // Do I need to set this or is it already set?
		RegisterTabSpawners(TabManager.ToSharedRef());
	}
	else
	{
		// Handle the error condition here, e.g., log an error or assert
		UE_LOG(LogCollisionEditor, Warning, TEXT("Toolkit host or tab manager is not valid."));
	}

	InitAssetEditor(Mode, InitToolkitHost, FName("CollisionDataEditorApp"), StandaloneLayout, true, true,
	                TArray<UObject*>({CollisionData}));
	PreviewScene->SetupScene(CollisionData);
}

void FCollisionDataEditorToolkit::InitializePlayerObjectBPPicker()
{
	PlayerObjectBPPicker = SNew(SClassPropertyEntryBox)
		.MetaClass(APlayerObject::StaticClass())
		.SelectedClass(PlayerObjectClass)
		.OnSetClass(this, &FCollisionDataEditorToolkit::OnPlayerObjectBPSelected)
		.AllowNone(false);
}

FGameplayTag FCollisionDataEditorToolkit::GetCurrentCelName() const
{
	if (PlayerObject && PlayerObject->CelName.IsValid())
		return PlayerObject->CelName;

	return FGameplayTag::EmptyTag;
}

void FCollisionDataEditorToolkit::OnClose()
{
#if WITH_EDITORONLY_DATA
	if (CollisionData)
	{
		CollisionData->OnCollisionFramesChanged.RemoveAll(this);
	}
#endif
	FAssetEditorToolkit::OnClose();
}

void FCollisionDataEditorToolkit::InitializeCelAssetTree()
{
	SAssignNew(CelAssetTree, SCelAssetTree, CollisionData)
		.OnCelSelected(this, &FCollisionDataEditorToolkit::OnCelSelected);
}

void FCollisionDataEditorToolkit::OnCelSelected(int32 CelIndex)
{
	if (!CollisionData || !CollisionData->CollisionFrames.IsValidIndex(CelIndex))
	{
		return;
	}

	const FGameplayTag& CelName = CollisionData->CollisionFrames[CelIndex].CelName;
	SelectedCel = CelName;

	if (PlayerObject && CelName.IsValid())
	{
		PlayerObject->SetCelName(CelName);
	}

#if WITH_EDITORONLY_DATA
	CollisionData->EditorSelectedIndex = CelIndex;
	if (DetailsView.IsValid())
	{
		DetailsView->ForceRefresh();
	}
#endif
}

void FCollisionDataEditorToolkit::OnCollisionFramesChanged()
{
	if (CelAssetTree.IsValid())
	{
		CelAssetTree->RefreshTree();
	}
}

void FCollisionDataEditorToolkit::OnPlayerObjectBPSelected(const UClass* Class)
{
	if (!Class) return;
	PlayerObjectClass = const_cast<UClass*>(Class);
	PlayerObject = PreviewScene->SetPlayerObject(Class);
	// CollisionData->SelectedPlayerObjectClass = Class;
	PlayerObject->SetCelName(SelectedCel);
	UE_LOG(LogCollisionEditor, Log, TEXT("Selected PlayerObject: %s"), *PlayerObject->GetName());
}

TSharedRef<SDockTab> FCollisionDataEditorToolkit::SpawnTab_CollisionDataDetails(const FSpawnTabArgs& Args)
{
	return SNew(SDockTab)
		.Label(LOCTEXT("CollisionDataDetailsTabLabel", "Collision Data Details"))
		.TabRole(ETabRole::NomadTab)
		[
			SNew(SBorder)
			.Padding(4)
			[
				DetailsView->AsShared()
			]
		];
}

TSharedRef<SDockTab> FCollisionDataEditorToolkit::SpawnTab_PlayerObjectSelector(const FSpawnTabArgs& Args)
{
	return SNew(SDockTab)
		.Label(LOCTEXT("PlayerObjectSelectorTabLabel", "Cel Browser"))
		.TabRole(ETabRole::NomadTab)
		[
			SNew(SVerticalBox)
			+ SVerticalBox::Slot()
			.AutoHeight()
			[
				SNew(SBorder)
				.Padding(4)
				[
					PlayerObjectBPPicker.ToSharedRef()
				]
			]
			+ SVerticalBox::Slot()
			.FillHeight(1.f)
			[
				SNew(SBorder)
				.Padding(4)
				[
					CelAssetTree.ToSharedRef()
				]
			]
		];
}

TSharedRef<SDockTab> FCollisionDataEditorToolkit::SpawnTab_ViewportTab(const FSpawnTabArgs& Args)
{
	return SNew(SDockTab)
		.Label(LOCTEXT("ViewportTabLabel", "Viewport"))
		.TabRole(ETabRole::MajorTab)
		[
			SNew(SBorder)
			.Padding(4)
			[
				PreviewViewportWidget.ToSharedRef() // Make sure to use the viewport widget
			]
		];
}

FText FCollisionDataEditorToolkit::GetSelectedState() const
{
	return FText::FromString(SelectedCel.ToString());
}

// Code to set the animation to a specific frames
void FCollisionDataEditorToolkit::UpdateAnimationPlayback(int32 Frame)
{
	if (PlayerObject)
	{
		PlayerObject->CelIndex = Frame;
	}
}

void FCollisionDataEditorToolkit::InitializePreviewScene()
{
	if (!PreviewScene.IsValid())
	{
		PreviewScene = MakeShareable(new FCollisionAnimationPreviewScene(
			FPreviewScene::ConstructionValues()
			.AllowAudioPlayback(false)
			.ShouldSimulatePhysics(false)
			, SharedThis(this)
		));
	}

	PreviewViewportWidget = SNew(SCollisionAnimationViewport, SharedThis(this), PreviewScene);
}

FName FCollisionDataEditorToolkit::GetToolkitFName() const
{
	return FName("CollisionDataEditor");
}

FText FCollisionDataEditorToolkit::GetBaseToolkitName() const
{
	return LOCTEXT("AppLabel", "Collision Data Editor");
}

FText FCollisionDataEditorToolkit::GetToolkitName() const
{
	return FText::FromString(CollisionData->GetName());
}

FString FCollisionDataEditorToolkit::GetWorldCentricTabPrefix() const
{
	return FString("CollisionDataEditor");
}

FLinearColor FCollisionDataEditorToolkit::GetWorldCentricTabColorScale() const
{
	return FLinearColor::White;
}

void FCollisionDataEditorToolkit::RegisterTabSpawners(const TSharedRef<FTabManager>& InTabManager)
{
	UE_LOG(LogCollisionEditor, Warning, TEXT("Registering Tab Spawners"));
	WorkspaceMenuCategory = InTabManager->AddLocalWorkspaceMenuCategory(
		LOCTEXT("WorkspaceMenu_CollisionDataEditor", "Collision Data Editor"));

	FAssetEditorToolkit::RegisterTabSpawners(InTabManager);

	InTabManager->RegisterTabSpawner("CollisionDataDetailsTab",
	                                 FOnSpawnTab::CreateSP(
		                                 this, &FCollisionDataEditorToolkit::SpawnTab_CollisionDataDetails))
	            .SetDisplayName(LOCTEXT("CollisionDataDetailsTab", "Collision Data Details"))
	            .SetGroup(WorkspaceMenuCategory.ToSharedRef());

	InTabManager->RegisterTabSpawner("PlayerObjectSelectorTab",
	                                 FOnSpawnTab::CreateSP(
		                                 this, &FCollisionDataEditorToolkit::SpawnTab_PlayerObjectSelector))
	            .SetDisplayName(LOCTEXT("PlayerObjectSelectorTab", "Cel Browser"))
	            .SetGroup(WorkspaceMenuCategory.ToSharedRef());

	InTabManager->RegisterTabSpawner("ViewportTab",
	                                 FOnSpawnTab::CreateSP(this, &FCollisionDataEditorToolkit::SpawnTab_ViewportTab))
	            .SetDisplayName(LOCTEXT("ViewportTab", "Viewport"))
	            .SetGroup(WorkspaceMenuCategory.ToSharedRef());
}

void FCollisionDataEditorToolkit::UnregisterTabSpawners(const TSharedRef<FTabManager>& InTabManager)
{
	FAssetEditorToolkit::UnregisterTabSpawners(InTabManager);

	InTabManager->UnregisterTabSpawner("CollisionDataDetailsTab");
	InTabManager->UnregisterTabSpawner("PlayerObjectSelectorTab");
	InTabManager->UnregisterTabSpawner("ViewportTab");
}

#undef LOCTEXT_NAMESPACE

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/CollisionEditor.cpp`:

```cpp
#include "CollisionEditor.h"
#include "AssetToolsModule.h"
#include "AssetTypeActions_CollisionData.h"
#include "CollisionDataDetails.h"
#include "IAssetTools.h"
#include "Logging.h"
#include "PropertyEditorModule.h"
#include "Data/CollisionData.h"
#include "Modules/ModuleManager.h"

#define LOCTEXT_NAMESPACE "NightSkyCollisionEditor"

void FCollisionEditor::StartupModule()
{
	UE_LOG(LogCollisionEditor, Log, TEXT("CollisionEditor Starting"));
	RegisterAssetTools();
	RegisterPropertyCustomizations();
}

void FCollisionEditor::ShutdownModule()
{
	UnregisterPropertyCustomizations();

	if (FModuleManager::Get().IsModuleLoaded("AssetTools"))
	{
		IAssetTools& AssetTools = FModuleManager::GetModuleChecked<FAssetToolsModule>("AssetTools").Get();
		AssetTools.UnregisterAssetTypeActions(MakeShareable(new FAssetTypeActions_CollisionData(CollisionAssetCategoryBit)));
	}
}

void FCollisionEditor::RegisterAssetTools()
{
	// Register the asset tools
	IAssetTools& AssetTools = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools").Get();
	CollisionAssetCategoryBit = AssetTools.RegisterAdvancedAssetCategory(FName(TEXT("CollisionData")), LOCTEXT("CollisionDataAssetCategory", "Collision Data"));
	TSharedRef<IAssetTypeActions> CollisionDataTypeActions = MakeShareable(new FAssetTypeActions_CollisionData(CollisionAssetCategoryBit));
	AssetTools.RegisterAssetTypeActions(CollisionDataTypeActions);
}

void FCollisionEditor::RegisterPropertyCustomizations()
{
	FPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>("PropertyEditor");

	PropertyModule.RegisterCustomClassLayout(
		UCollisionData::StaticClass()->GetFName(),
		FOnGetDetailCustomizationInstance::CreateStatic(&FCollisionDataDetails::MakeInstance)
	);

	PropertyModule.NotifyCustomizationModuleChanged();
}

void FCollisionEditor::UnregisterPropertyCustomizations()
{
	if (FModuleManager::Get().IsModuleLoaded("PropertyEditor"))
	{
		FPropertyEditorModule& PropertyModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>("PropertyEditor");
		PropertyModule.UnregisterCustomClassLayout(UCollisionData::StaticClass()->GetFName());
	}
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FCollisionEditor, CollisionEditor);
```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/Logging.cpp`:

```cpp
// Copyright Screaming Goose Games. All Rights Reserved.

#include "Logging.h"

DEFINE_LOG_CATEGORY(LogCollisionEditor);
```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/Logging.h`:

```h
// Copyright Screaming Goose Games. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"

DECLARE_LOG_CATEGORY_EXTERN(LogCollisionEditor, Log, All);
```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/Viewport/CollisionAnimationPreviewScene.cpp`:

```cpp
#include "Viewport/CollisionAnimationPreviewScene.h"
#include "Components/SkeletalMeshComponent.h"
#include "Data/CollisionData.h"
#include "CollisionDataEditorToolkit.h"
#include "DrawDebugHelpers.h"
#include "Battle/Objects/PlayerObject.h"

FCollisionAnimationPreviewScene::FCollisionAnimationPreviewScene(ConstructionValues CVS, const TSharedRef<FCollisionDataEditorToolkit>& EditorToolkit)
    : FAdvancedPreviewScene(CVS), EditorPtr(EditorToolkit)
{
    // Disable the default floor to customize the scene
    SetFloorVisibility(true, true);

    // Setup events or additional components if necessary
}

FCollisionAnimationPreviewScene::~FCollisionAnimationPreviewScene()
{
    // Cleanup or unregister anything necessary
}

void FCollisionAnimationPreviewScene::Tick(float InDeltaTime)
{
    FAdvancedPreviewScene::Tick(InDeltaTime);

    // Update animations and Collisiones as needed
    UpdateMeshAndAnimation(InDeltaTime);
    UpdateCollisionView();
}

APlayerObject* FCollisionAnimationPreviewScene::SetPlayerObject(const UClass* Class)
{
    if (PreviewPlayerObject) PreviewPlayerObject->Destroy();

    const auto PlayerObject = GetWorld()->SpawnActor<APlayerObject>(const_cast<UClass*>(Class));
    PreviewPlayerObject = PlayerObject;
    PreviewPlayerObject->InitPlayer();
    PreviewPlayerObject->SetDefaultComponentVisibility();

    TArray<USkeletalMeshComponent*> SkeletalMeshComponents;
    PreviewPlayerObject->GetComponents(USkeletalMeshComponent::StaticClass(), SkeletalMeshComponents);
    for (auto* Component : SkeletalMeshComponents)
    {
        // TODO: Uncomment if it crashes again
        // if (Component->GetSkeletalMeshAsset() && Component->GetNumBones() > 0)
        // {
        //     Component->InitAnim(true);
        //     Component->SetUpdateAnimationInEditor(true);
        // }
        Component->InitAnim(true);
        Component->SetUpdateAnimationInEditor(true);
    }

    return PreviewPlayerObject;
}

void FCollisionAnimationPreviewScene::SetupScene(UCollisionData* CollisionData)
{
    CurrentCollisionData = CollisionData;
}

void FCollisionAnimationPreviewScene::UpdateMeshAndAnimation(float DeltaTime)
{
    if (!PreviewPlayerObject) return;
    PreviewPlayerObject->EditorUpdate();

    TArray<USkeletalMeshComponent*> SkeletalMeshComponents;
    PreviewPlayerObject->GetComponents(USkeletalMeshComponent::StaticClass(), SkeletalMeshComponents);
    for (auto* Component : SkeletalMeshComponents)
    {
        if (Component->GetSkeletalMeshAsset() && Component->GetNumBones() > 0)
        {
            Component->TickComponent(DeltaTime, ELevelTick::LEVELTICK_ViewportsOnly, nullptr);
        }
    }
}

void FCollisionAnimationPreviewScene::DrawCollisionData()
{
    PreviewPlayerObject->CollisionView();
}

void FCollisionAnimationPreviewScene::UpdateCollisionView()
{
    if (!CurrentCollisionData || !PreviewPlayerObject) // || !PreviewComponent)
      return;

  //Clear Debug Draw Debug Lines
  FlushPersistentDebugLines(GetWorld());

  // Get Cel name and call DrawCollisionData
  DrawCollisionData();
}

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/Viewport/CollisionAnimationViewport.cpp`:

```cpp
#include "Viewport/CollisionAnimationViewport.h"
#include "Viewport/CollisionAnimationPreviewScene.h"
#include "CollisionDataEditorToolkit.h"
#include "Viewport/CollisionAnimationViewportClient.h"
#include "Modules/ModuleManager.h"
#include "PropertyEditorModule.h"

#define LOCTEXT_NAMESPACE "NightSkyCollisionEditor"

SCollisionAnimationViewport::~SCollisionAnimationViewport()
{
    if (ViewportClient.IsValid())
    {
        ViewportClient->Viewport = nullptr;
    }
}

void SCollisionAnimationViewport::Construct(const FArguments& InArgs, TSharedPtr<FCollisionDataEditorToolkit> InEditorToolkit, TSharedPtr<FCollisionAnimationPreviewScene> InPreviewScene)
{
    EditorToolkit = InEditorToolkit;
    PreviewScene = InPreviewScene;

    SEditorViewport::Construct(SEditorViewport::FArguments());

    // What to put here?
}

FString SCollisionAnimationViewport::GetReferencerName() const
{
    return TEXT("SCollisionAnimationViewport");
}

TSharedRef<SEditorViewport> SCollisionAnimationViewport::GetViewportWidget()
{
    return SharedThis(this);
}

TSharedPtr<FExtender> SCollisionAnimationViewport::GetExtenders() const
{
    TSharedPtr<FExtender> Extender = MakeShareable(new FExtender);
    return Extender;
}

void SCollisionAnimationViewport::OnFloatingButtonClicked()
{
    // Handle special button actions here
}

void SCollisionAnimationViewport::OnFocusViewportToSelection()
{
    if (PreviewScene.IsValid())
    {
        // Implement FocusOnSelection
        //PreviewScene->FocusOnSelection();
    }
}

TSharedRef<FEditorViewportClient> SCollisionAnimationViewport::MakeEditorViewportClient()
{
    if (!ViewportClient.IsValid())
    {
        ViewportClient = MakeShareable(new FCollisionAnimationViewportClient(SharedThis(this), PreviewScene.ToSharedRef()));
    }

    return ViewportClient.ToSharedRef();
}

#undef LOCTEXT_NAMESPACE

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Private/Viewport/CollisionAnimationViewportClient.cpp`:

```cpp
#include "Viewport/CollisionAnimationViewportClient.h"
#include "AdvancedPreviewScene.h"

FCollisionAnimationViewportClient::FCollisionAnimationViewportClient(const TSharedRef<SEditorViewport>& InEditorViewport, const TSharedRef<FAdvancedPreviewScene>& InPreviewScene)
    : FEditorViewportClient(nullptr, &InPreviewScene.Get(), StaticCastSharedRef<SEditorViewport>(InEditorViewport))
{
    AdvancedPreviewScene = static_cast<FAdvancedPreviewScene*>(PreviewScene);

    // Set initial viewport properties
    SetRealtime(true);
    DrawHelper.bDrawGrid = false;
    DrawHelper.bDrawPivot = false;
    DrawHelper.AxesLineThickness = 5;
    DrawHelper.PivotSize = 5;

    // Enable screen percentage rendering
    EngineShowFlags.SetScreenPercentage(true);

    // Set perspective as default view mode
    SetViewportType(LVT_Perspective);
    SetViewModes(VMI_Lit, VMI_Lit);
}

void FCollisionAnimationViewportClient::Tick(float DeltaSeconds)
{
    FEditorViewportClient::Tick(DeltaSeconds);

    // Set initial camera position and orientation
    SetViewLocation(FVector(0, 720, 175));
    SetViewRotation(FRotator(0, -90, 0));
    ViewFOV = 54;
}

FCollisionAnimationViewportClient::~FCollisionAnimationViewportClient()
{
    // Clean up code if necessary
}
```

`Plugins/NightSkyEngine/Source/CollisionEditor/Public/AssetTypeActions_CollisionData.h`:

```h
#pragma once

// Note: My intellisense is not working so I'm just including everything I may need
#include "CoreMinimal.h"
#include "AssetTypeActions_Base.h"
#include "Math/Color.h"

class COLLISIONEDITOR_API FAssetTypeActions_CollisionData : public FAssetTypeActions_Base
{
public:

	FAssetTypeActions_CollisionData(EAssetTypeCategories::Type InAssetCategory)
		: AssetCategory(InAssetCategory){}

	virtual FColor GetTypeColor() const override;
	virtual UClass* GetSupportedClass() const override;

	virtual void OpenAssetEditor(const TArray<UObject*>& InObjects, TSharedPtr<IToolkitHost> EditWithinLevelEditor) override;

	virtual FText GetName() const override;

	virtual bool CanFilter() override { return true; }

	virtual uint32 GetCategories() override;

private:
	EAssetTypeCategories::Type AssetCategory;
};
```

`Plugins/NightSkyEngine/Source/CollisionEditor/Public/CelAssetTree.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "CelAssetTreeNode.h"
#include "GameplayTagContainer.h"
#include "Widgets/SCompoundWidget.h"
#include "Widgets/Views/STreeView.h"

class UCollisionData;

DECLARE_DELEGATE_OneParam(FOnCelSelected, int32 /*SelectedCelIndex*/);

/**
 * Tree view widget for browsing cels grouped by GameplayTag hierarchy.
 */
class SCelAssetTree : public SCompoundWidget
{
public:
	SLATE_BEGIN_ARGS(SCelAssetTree) {}
		SLATE_EVENT(FOnCelSelected, OnCelSelected)
	SLATE_END_ARGS()

	void Construct(const FArguments& InArgs, UCollisionData* InCollisionData);

	void RefreshTree();
	void SetSelectedCel(const FGameplayTag& CelName);

private:
	TSharedRef<ITableRow> GenerateTreeRow(
		TSharedPtr<FCelAssetTreeNode> InNode,
		const TSharedRef<STableViewBase>& OwnerTable);

	void GetChildrenForNode(
		TSharedPtr<FCelAssetTreeNode> InNode,
		TArray<TSharedPtr<FCelAssetTreeNode>>& OutChildren);

	void OnSelectionChanged(
		TSharedPtr<FCelAssetTreeNode> SelectedNode,
		ESelectInfo::Type SelectInfo);

	void OnFilterTextChanged(const FText& InText);

	void BuildTreeFromCollisionData();
	
	// TODO: Search box filtering
	// void ApplyFilter(const FString& FilterString);

	TWeakObjectPtr<UCollisionData> CollisionData;
	TSharedPtr<STreeView<TSharedPtr<FCelAssetTreeNode>>> TreeView;
	TArray<TSharedPtr<FCelAssetTreeNode>> RootNodes;
	TArray<TSharedPtr<FCelAssetTreeNode>> AllNodes;

	FString CurrentFilterString;
	FOnCelSelected OnCelSelectedDelegate;

	// Maps cel index to its tree node for quick lookup
	TMap<int32, TSharedPtr<FCelAssetTreeNode>> CelIndexToNodeMap;
};

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Public/CelAssetTreeNode.h`:

```h
#pragma once

#include "CoreMinimal.h"

/**
 * Node for the cel asset tree view.
 * Can represent either a category (intermediate node) or a cel (leaf node).
 */
class FCelAssetTreeNode : public TSharedFromThis<FCelAssetTreeNode>
{
public:
	/** Category constructor */
	FCelAssetTreeNode(const FString& InDisplayName, int32 InCelIndex = INDEX_NONE)
		: DisplayName(InDisplayName)
		, CelIndex(InCelIndex)
		, bHasProblem(false)
	{
	}
	
	/** Cel node constructor, requires an index */
	FCelAssetTreeNode(int32 InCelIndex, const FString& InDisplayName, bool bInHasProblem = false)
		: DisplayName(InDisplayName)
		, CelIndex(InCelIndex)
		, bHasProblem(bInHasProblem) {}

	bool IsCategory() const { return CelIndex == INDEX_NONE; }
	bool IsCel() const { return CelIndex != INDEX_NONE; }
	bool IsValid() const { return bHasProblem; }

	FString GetDisplayName() const { return DisplayName; }
	int32 GetCelIndex() const { return CelIndex; }
	void SetCelIndex(int32 InCelIndex) { CelIndex = InCelIndex; }

	TSharedPtr<FCelAssetTreeNode> FindOrCreateChild(const FString& ChildName, int32 ChildCelIndex = INDEX_NONE);

	TWeakPtr<FCelAssetTreeNode> Parent;
	TArray<TSharedPtr<FCelAssetTreeNode>> Children;

private:
	FString DisplayName;
	int32 CelIndex;
	bool bHasProblem;
};

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Public/CollisionDataDetails.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "IDetailCustomization.h"
#include "GameplayTagContainer.h"
#include "Input/Reply.h"

class UCollisionData;
class IDetailCategoryBuilder;


/**
 * Detail customization for UCollisionData that displays CollisionFrames
 * in a hierarchical tree organized by GameplayTag.
 */
class FCollisionDataDetails : public IDetailCustomization
{
public:
	static TSharedRef<IDetailCustomization> MakeInstance();

	virtual void CustomizeDetails(IDetailLayoutBuilder& DetailBuilder) override;

private:
	void BuildSelectedCelView(IDetailLayoutBuilder& DetailBuilder, IDetailCategoryBuilder& Category);
	void OnCelSelected(const FGameplayTag& CelName);

	FReply OnAddNewCel();
	FReply OnDeleteSelectedCel();
	FReply OnTemplateSelectedCel();
	FReply OnRefreshTree();

	bool CanDeleteSelectedCel() const;
	bool CanTemplateSelectedCel() const;

	TWeakObjectPtr<UCollisionData> CollisionDataPtr;
	TSharedPtr<IPropertyHandle> CollisionFramesHandle;
	IDetailLayoutBuilder* CachedDetailBuilder = nullptr;
	FGameplayTag SelectedCelName;
};

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Public/CollisionDataEditorToolkit.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Toolkits/AssetEditorToolkit.h"
#include "Toolkits/IToolkitHost.h"
#include "Widgets/Docking/SDockTab.h"
#include "Widgets/Layout/SBorder.h"
#include "Widgets/Text/STextBlock.h"
#include "PropertyCustomizationHelpers.h"
#include "Data/CollisionData.h"

class APlayerObject;
class FCollisionAnimationPreviewScene;
class SCollisionAnimationViewport;
class SCelAssetTree;


//These aren't used yet
/**
 * The different modes of interaction in the Scene.
 */
enum ESceneInteractionMode
{
	Interaction_CameraMove,
	Interaction_EditCollisionBoxes
};

/**
 * The different modes of editing collision boxes.
 */
enum EBoxEditMode
{
	EditMode_None,
	EditMode_Add,
	EditMode_Move,
	EditMode_Delete
};

/**
 * Toolkit for editing collision data assets for Night Sky.
 */
class FCollisionDataEditorToolkit : public FAssetEditorToolkit
{
public:
	FCollisionDataEditorToolkit();
	virtual ~FCollisionDataEditorToolkit() override;

	// Move some of these to private

	// Initializes the editor with the asset to be edited
	void Initialize(UCollisionData* InCollisionData, const EToolkitMode::Type Mode,
	                const TSharedPtr<IToolkitHost>& InitToolkitHost);

	// FAssetEditorToolkit interface
	virtual FName GetToolkitFName() const override; // Unique name for this toolkit type
	virtual FText GetBaseToolkitName() const override; // Display name for the toolkit
	virtual FText GetToolkitName() const override;
	virtual FString GetWorldCentricTabPrefix() const override; // Prefix for tabs in world-centric mode
	virtual FLinearColor GetWorldCentricTabColorScale() const override;

	// Tab management
	virtual void RegisterTabSpawners(const TSharedRef<FTabManager>& InTabManager) override;
	virtual void UnregisterTabSpawners(const TSharedRef<FTabManager>& InTabManager) override;

	TSharedRef<SDockTab> SpawnTab_CollisionDataDetails(const FSpawnTabArgs& Args);
	TSharedRef<SDockTab> SpawnTab_PlayerObjectSelector(const FSpawnTabArgs& Args);
	TSharedRef<SDockTab> SpawnTab_ViewportTab(const FSpawnTabArgs& Args);

	// Do I need to initialize a scene?
	void InitializePreviewScene();

	// Accessors
	// Get current animation name
	FText GetSelectedState() const;

private:
	TSharedPtr<IDetailsView> DetailsView;
	TSharedPtr<SClassPropertyEntryBox> PlayerObjectBPPicker;

	TSharedPtr<FCollisionAnimationPreviewScene> PreviewScene;
	TSharedPtr<SCollisionAnimationViewport> PreviewViewportWidget;

	UCollisionData* CollisionData{};
	TSharedPtr<SCelAssetTree> CelAssetTree;
	FGameplayTag SelectedCel;
	UClass* PlayerObjectClass = nullptr;
	APlayerObject* PlayerObject{};

	void InitializeCelAssetTree();
	void OnCelSelected(int32 CelIndex);
	void OnCollisionFramesChanged();

	void OnPlayerObjectBPSelected(const UClass* Class);
	void InitializePlayerObjectBPPicker();

	FGameplayTag GetCurrentCelName() const;

	void UpdateAnimationPlayback(int32 frame);

protected:
	virtual void OnClose() override;
};

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Public/CollisionEditor.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "AssetTypeCategories.h"
#include "Modules/ModuleManager.h"


class COLLISIONEDITOR_API FCollisionEditor : public IModuleInterface
{
public:

	/** IModuleInterface implementation */
	void StartupModule() override;
	void ShutdownModule() override;

private:
	EAssetTypeCategories::Type CollisionAssetCategoryBit;

	void RegisterAssetTools();
	void RegisterPropertyCustomizations();
	void UnregisterPropertyCustomizations();
};

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/CollisionAnimationPreviewScene.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "AdvancedPreviewScene.h"
#include "Components/SkeletalMeshComponent.h"
#include "Data/CollisionData.h"

class APlayerObject;
class FCollisionDataEditorToolkit;

class FCollisionAnimationPreviewScene : public FAdvancedPreviewScene
{
public:
    FCollisionAnimationPreviewScene(ConstructionValues CVS, const TSharedRef<FCollisionDataEditorToolkit>& EditorToolkit);
    virtual ~FCollisionAnimationPreviewScene() override;

    virtual void Tick(float InDeltaTime) override;

    // Switch skeletal mesh on component
    APlayerObject* SetPlayerObject(const UClass* Class);
    
    // Setup the scene with animation data
    void SetupScene(UCollisionData* CollisionData);

    // Update the animation hitboxes
    void UpdateCollisionView();

private:
    APlayerObject* PreviewPlayerObject = nullptr;
    TWeakPtr<FCollisionDataEditorToolkit> EditorPtr;
    UCollisionData* CurrentCollisionData = nullptr;
    
    // Functions to update mesh and animations
    void UpdateMeshAndAnimation(float DeltaTime);

    // Draw hitboxes based on loaded collision data
    void DrawCollisionData();
};

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/CollisionAnimationViewport.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "SCommonEditorViewportToolbarBase.h"
#include "SEditorViewport.h"
#include "CollisionAnimationPreviewScene.h"
#include "CollisionDataEditorToolkit.h"
#include "CollisionAnimationViewportClient.h"

class SCollisionAnimationViewport : public SEditorViewport, public FGCObject, public ICommonEditorViewportToolbarInfoProvider
{
public:
    SLATE_BEGIN_ARGS(SCollisionAnimationViewport) {}
    SLATE_END_ARGS()

    // The scene
    TSharedPtr<FCollisionAnimationPreviewScene> PreviewScene;

    // Construct the viewport
    void Construct(const FArguments& InArgs, TSharedPtr<FCollisionDataEditorToolkit> InEditorToolkit, TSharedPtr<FCollisionAnimationPreviewScene> InPreviewScene);
    virtual ~SCollisionAnimationViewport() override;

    // FGCObject interface
    virtual void AddReferencedObjects(FReferenceCollector& Collector) override {};
    virtual FString GetReferencerName() const override;
    // Toolbar interface
    virtual TSharedRef<SEditorViewport> GetViewportWidget() override;
    virtual TSharedPtr<FExtender> GetExtenders() const override;
    virtual void OnFloatingButtonClicked() override;
    virtual void OnFocusViewportToSelection() override; // Not sure this is needed yet

    // Construct the viewport
    virtual TSharedRef<FEditorViewportClient> MakeEditorViewportClient() override;

private:
    TSharedPtr<FCollisionAnimationViewportClient> ViewportClient;
    TWeakPtr<FCollisionDataEditorToolkit> EditorToolkit;
};

```

`Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/CollisionAnimationViewportClient.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "SEditorViewport.h"
#include "AdvancedPreviewScene.h"
#include "SCommonEditorViewportToolbarBase.h"

class UAnimationAsset;
class FCollisionAnimationPreviewScene;
class FCollisionDataEditorToolkit;

// Define the viewport client
class FCollisionAnimationViewportClient : public FEditorViewportClient
{
public:
    FCollisionAnimationViewportClient(const TSharedRef<SEditorViewport>& InEditorViewport, const TSharedRef<FAdvancedPreviewScene>& InPreviewScene);
    virtual void Tick(float DeltaSeconds) override;
    
    virtual ~FCollisionAnimationViewportClient();

    /*FRenderTarget* GetRenderTarget() { return Viewport->GetRenderTargetTexture(); }
    FSceneInterface* GetScene() const { return (FSceneInterface*)(GetWorld()->Scene); }*/

private:

    FAdvancedPreviewScene* AdvancedPreviewScene;
};
```

`Plugins/NightSkyEngine/Source/GGPOUE4/GGPOUE4.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class GGPOUE4 : ModuleRules
{
	public GGPOUE4(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicIncludePaths.AddRange(
			new string[] {
				// ... add public include paths required here ...
			}
			);

		PrivateIncludePaths.AddRange(
			new string[] {
				// ... add other private include paths required here ...
			}
			);


		PublicDependencyModuleNames.AddRange(new string[] { "Core" });

		PrivateDependencyModuleNames.AddRange(new string[] { "CoreUObject", "Engine", "InputCore" });


		if (Target.Platform == UnrealTargetPlatform.Win64)
		{
			PublicDefinitions.Add("_WINDOWS");
		}
		else if (Target.Platform == UnrealTargetPlatform.Mac)
        {
			PublicDefinitions.Add("MACOS");
		}
	
		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });

		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");


		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
				// ... add any modules that your module loads dynamically here ...
			}
			);
	}
}

```

`Plugins/NightSkyEngine/Source/GGPOUE4/LICENSE`:

```
The MIT License

Copyright (c) 2009-2019 GroundStorm Studios, LLC. (http://ggpo.net)
Copyright (c) 2020 BwdYeti
Copyright (c) 2020 Friendly Fish Games LLC.


Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/GGPOGameInstance.cpp`:

```cpp
// Copyright 2020 BwdYeti.


#include "GGPOGameInstance.h"
#include "include/ggponet.h"

void UGGPOGameInstance::CreateNetwork(int32 NumPlayers, int32 PlayerIndex, int32 LocalPort, TArray<FString> RemoteAddresses)
{
	UGGPONetwork* addresses = UGGPONetwork::CreateNetwork(
		this,
		FName(FString(TEXT("GGPONetwork"))),
		NumPlayers,
		PlayerIndex,
		LocalPort,
		RemoteAddresses);
	NetworkAddresses = addresses;
}


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/GGPOUE4.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "GGPOUE4.h"

#define LOCTEXT_NAMESPACE "FGGPOUE4Module"

DEFINE_LOG_CATEGORY(GGPOLOG);

void FGGPOUE4Module::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
}

void FGGPOUE4Module::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}

#undef LOCTEXT_NAMESPACE
	
IMPLEMENT_MODULE(FGGPOUE4Module, GGPOUE4)
```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/backend.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _BACKEND_H
#define _BACKEND_H

#include "include/ggponet.h"
#include "types.h"

struct GGPOSession {
    virtual ~GGPOSession() { }
    virtual GGPOErrorCode DoPoll(int timeout) { return GGPO_OK; }
    virtual GGPOErrorCode AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle) = 0;
    virtual GGPOErrorCode AddLocalInput(GGPOPlayerHandle player, void *values, int size) = 0;
    virtual GGPOErrorCode SyncInput(void *values, int size, int *disconnect_flags) = 0;
    virtual GGPOErrorCode IncrementFrame(void) { return GGPO_OK; }
    virtual GGPOErrorCode Chat(char *text) { return GGPO_OK; }
    virtual GGPOErrorCode DisconnectPlayer(GGPOPlayerHandle handle) { return GGPO_OK; }
    virtual GGPOErrorCode GetNetworkStats(FGGPONetworkStats *stats, GGPOPlayerHandle handle) { return GGPO_OK; }
    virtual GGPOErrorCode Logv(const char *fmt, va_list list) { ::Logv(fmt, list); return GGPO_OK; }

    virtual GGPOErrorCode SetFrameDelay(GGPOPlayerHandle player, int delay) { return GGPO_ERRORCODE_UNSUPPORTED; }
	virtual GGPOErrorCode SetDisconnectTimeout(int timeout) { return GGPO_ERRORCODE_UNSUPPORTED; }
	virtual GGPOErrorCode SetDisconnectNotifyStart(int timeout) { return GGPO_ERRORCODE_UNSUPPORTED; }
	virtual GGPOErrorCode TrySynchronizeLocal() { return GGPO_ERRORCODE_UNSUPPORTED; } 
};

typedef struct GGPOSession Quark, IQuarkBackend; /* XXX: nuke this */

#endif


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/p2p.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "p2p.h"

#include "GGPOUE4.h"

static const int RECOMMENDATION_INTERVAL           = 240;
static const int DEFAULT_DISCONNECT_TIMEOUT        = 5000;
static const int DEFAULT_DISCONNECT_NOTIFY_START   = 750;

Peer2PeerBackend::Peer2PeerBackend(GGPOSessionCallbacks *cb,
                                   const char *gamename,
                                   ConnectionManager* connection_manager,
                                   int num_players,
                                   int input_size) :
    _sync(_local_connect_status),
    _num_spectators(0),
    _input_size(input_size),
    _num_players(num_players),
    _next_spectator_frame(0),
    _disconnect_timeout(DEFAULT_DISCONNECT_TIMEOUT),
    _disconnect_notify_start(DEFAULT_DISCONNECT_NOTIFY_START)
{
   _callbacks = *cb;
   _synchronizing = true;
   _next_recommended_sleep = 0;

   /*
    * Initialize the synchronziation layer
    */
   Sync::Config config = Sync::Config();
   config.num_players = num_players;
   config.input_size = input_size;
   config.callbacks = _callbacks;
   config.num_prediction_frames = MAX_PREDICTION_FRAMES;
   _sync.Init(config);

   /*
    * Initialize the UDP port
    */
   _udp.Init(&_poll, this, connection_manager);

   _endpoints = new UdpProtocol[_num_players];
   memset(_local_connect_status, 0, sizeof(_local_connect_status));
   for (int i = 0; i < ARRAY_SIZE(_local_connect_status); i++) {
      _local_connect_status[i].last_frame = -1;
   }

   /*
    * Preload the ROM
    */
   _callbacks.begin_game(gamename);
}
  
Peer2PeerBackend::~Peer2PeerBackend()
{
   delete [] _endpoints;
}

void
Peer2PeerBackend::AddRemotePlayer(int connection_id,
                                  int queue)
{
   /*
    * Start the state machine (xxx: no)
    */
   _synchronizing = true;
   remoteplayerId = connection_id;
   remoteplayerQueueu = queue;
   _endpoints[queue].Init(&_udp, _poll, queue, connection_id, _local_connect_status);
   _endpoints[queue].SetDisconnectTimeout(_disconnect_timeout);
   _endpoints[queue].SetDisconnectNotifyStart(_disconnect_notify_start);
   _endpoints[queue].Synchronize();
}

GGPOErrorCode Peer2PeerBackend::AddSpectator(int connection_id)
{
   if (_num_spectators == GGPO_MAX_SPECTATORS) {
      return GGPO_ERRORCODE_TOO_MANY_SPECTATORS;
   }
   /*
    * Currently, we can only add spectators before the game starts.
    */
   if (!_synchronizing) {
      return GGPO_ERRORCODE_INVALID_REQUEST;
   }
   int queue = _num_spectators++;

   _spectators[queue].Init(&_udp, _poll, queue + 1000, connection_id, _local_connect_status);
   _spectators[queue].SetDisconnectTimeout(_disconnect_timeout);
   _spectators[queue].SetDisconnectNotifyStart(_disconnect_notify_start);
   _spectators[queue].Synchronize();

   return GGPO_OK;
}

GGPOErrorCode
Peer2PeerBackend::DoPoll(int timeout)
{
   if (!_sync.InRollback()) {
      _poll.Pump(0);

      PollUdpProtocolEvents();

      if (!_synchronizing) {
         _sync.CheckSimulation(timeout);

         // notify all of our endpoints of their local frame number for their
         // next connection quality report
         int current_frame = _sync.GetFrameCount();
         for (int i = 0; i < _num_players; i++) {
            _endpoints[i].SetLocalFrameNumber(current_frame);
         }

         int total_min_confirmed;
         if (_num_players <= 2) {
            total_min_confirmed = Poll2Players(current_frame);
         } else {
            total_min_confirmed = PollNPlayers(current_frame);
         }

         Log("last confirmed frame in p2p backend is %d.\n", total_min_confirmed);
         if (total_min_confirmed >= 0) {
            ASSERT(total_min_confirmed != INT_MAX);
            if (_num_spectators > 0) {
               while (_next_spectator_frame <= total_min_confirmed) {
                  Log("pushing frame %d to spectators.\n", _next_spectator_frame);
   
                  GameInput input;
                  input.frame = _next_spectator_frame;
                  input.size = _input_size * _num_players;
                  _sync.GetConfirmedInputs(input.bits, _input_size * _num_players, _next_spectator_frame);
                  for (int i = 0; i < _num_spectators; i++) {
                     _spectators[i].SendInput(input);
                  }
                  _next_spectator_frame++;
               }
            }
            Log("setting confirmed frame in sync to %d.\n", total_min_confirmed);
            _sync.SetLastConfirmedFrame(total_min_confirmed);
         }

         // send timesync notifications if now is the proper time
         if (current_frame > _next_recommended_sleep) {
            int interval = 0;
            for (int i = 0; i < _num_players; i++) {
               interval = MAX(interval, _endpoints[i].RecommendFrameDelay());
            }

            if (interval > 0) {
               GGPOEvent info;
               info.code = GGPO_EVENTCODE_TIMESYNC;
               info.u.timesync.frames_ahead = interval;
               _callbacks.on_event(&info);
               _next_recommended_sleep = current_frame + RECOMMENDATION_INTERVAL;
            }
         }
         // XXX: this is obviously a farce...
         if (timeout) {
            Platform::SleepMS(1);
         }
      }
   }
   return GGPO_OK;
}

int Peer2PeerBackend::Poll2Players(int current_frame)
{
   int i;

   // discard confirmed frames as appropriate
   int total_min_confirmed = MAX_INT;
   for (i = 0; i < _num_players; i++) {
      bool queue_connected = true;
      if (_endpoints[i].IsRunning()) {
         int ignore;
         queue_connected = _endpoints[i].GetPeerConnectStatus(i, &ignore);
      }
      if (!_local_connect_status[i].disconnected) {
         total_min_confirmed = MIN(_local_connect_status[i].last_frame, total_min_confirmed);
      }
      Log("  local endp: connected = %d, last_received = %d, total_min_confirmed = %d.\n", !_local_connect_status[i].disconnected, _local_connect_status[i].last_frame, total_min_confirmed);
      if (!queue_connected && !_local_connect_status[i].disconnected) {
         Log("disconnecting i %d by remote request.\n", i);
         DisconnectPlayerQueue(i, total_min_confirmed);
      }
      Log("  total_min_confirmed = %d.\n", total_min_confirmed);
   }
   return total_min_confirmed;
}

int Peer2PeerBackend::PollNPlayers(int current_frame)
{
   int i, queue, last_received;

   // discard confirmed frames as appropriate
   int total_min_confirmed = MAX_INT;
   for (queue = 0; queue < _num_players; queue++) {
      bool queue_connected = true;
      int queue_min_confirmed = MAX_INT;
      Log("considering queue %d.\n", queue);
      for (i = 0; i < _num_players; i++) {
         // we're going to do a lot of logic here in consideration of endpoint i.
         // keep accumulating the minimum confirmed point for all n*n packets and
         // throw away the rest.
         if (_endpoints[i].IsRunning()) {
            bool connected = _endpoints[i].GetPeerConnectStatus(queue, &last_received);

            queue_connected = queue_connected && connected;
            queue_min_confirmed = MIN(last_received, queue_min_confirmed);
            Log("  endpoint %d: connected = %d, last_received = %d, queue_min_confirmed = %d.\n", i, connected, last_received, queue_min_confirmed);
         } else {
            Log("  endpoint %d: ignoring... not running.\n", i);
         }
      }
      // merge in our local status only if we're still connected!
      if (!_local_connect_status[queue].disconnected) {
         queue_min_confirmed = MIN(_local_connect_status[queue].last_frame, queue_min_confirmed);
      }
      Log("  local endp: connected = %d, last_received = %d, queue_min_confirmed = %d.\n", !_local_connect_status[queue].disconnected, _local_connect_status[queue].last_frame, queue_min_confirmed);

      if (queue_connected) {
         total_min_confirmed = MIN(queue_min_confirmed, total_min_confirmed);
      } else {
         // check to see if this disconnect notification is further back than we've been before.  If
         // so, we need to re-adjust.  This can happen when we detect our own disconnect at frame n
         // and later receive a disconnect notification for frame n-1.
         if (!_local_connect_status[queue].disconnected || _local_connect_status[queue].last_frame > queue_min_confirmed) {
            Log("disconnecting queue %d by remote request.\n", queue);
            DisconnectPlayerQueue(queue, queue_min_confirmed);
         }
      }
      Log("  total_min_confirmed = %d.\n", total_min_confirmed);
   }
   return total_min_confirmed;
}


GGPOErrorCode
Peer2PeerBackend::AddPlayer(GGPOPlayer *player,
                            GGPOPlayerHandle *handle)
{
   if (player->type == GGPO_PLAYERTYPE_SPECTATOR) {
      return AddSpectator(player->connection_id);
   }

   int queue = player->player_num - 1;
   if (player->player_num < 1 || player->player_num > _num_players) {
      return GGPO_ERRORCODE_PLAYER_OUT_OF_RANGE;
   }
   *handle = QueueToPlayerHandle(queue);

   if (player->type == GGPO_PLAYERTYPE_REMOTE) {
      AddRemotePlayer(player->connection_id, queue);
   }
   return GGPO_OK;
}

GGPOErrorCode
Peer2PeerBackend::AddLocalInput(GGPOPlayerHandle player,
                                void *values,
                                int size)
{
   int queue;
   GameInput input;
   GGPOErrorCode result;

   if (_sync.InRollback()) {
      return GGPO_ERRORCODE_IN_ROLLBACK;
   }
   if (_synchronizing) {
      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;
   }
   
   result = PlayerHandleToQueue(player, &queue);
   if (!GGPO_SUCCEEDED(result)) {
      return result;
   }

   input.init(-1, (char *)values, size);

   // Feed the input for the current frame into the synchronzation layer.
   if (!_sync.AddLocalInput(queue, input)) {
      return GGPO_ERRORCODE_PREDICTION_THRESHOLD;
   }

   if (input.frame != GameInput::NullFrame) { // xxx: <- comment why this is the case
      // Update the local connect status state to indicate that we've got a
      // confirmed local frame for this player.  this must come first so it
      // gets incorporated into the next packet we send.

      Log("setting local connect status for local queue %d to %d", queue, input.frame);
      _local_connect_status[queue].last_frame = input.frame;

      // Send the input to all the remote players.
      for (int i = 0; i < _num_players; i++) {
         if (_endpoints[i].IsInitialized()) {
            _endpoints[i].SendInput(input);
         }
      }
   }

   return GGPO_OK;
}


GGPOErrorCode
Peer2PeerBackend::SyncInput(void *values,
                            int size,
                            int *disconnect_flags)
{
   int flags;

   // Wait until we've started to return inputs.
   if (_synchronizing) {
      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;
   }
   flags = _sync.SynchronizeInputs(values, size);
   if (disconnect_flags) {
      *disconnect_flags = flags;
   }
   return GGPO_OK;
}

GGPOErrorCode
Peer2PeerBackend::IncrementFrame(void)
{  
   Log("End of frame (%d)...\n", _sync.GetFrameCount());
   _sync.IncrementFrame();
   DoPoll(0);
   PollSyncEvents();

   return GGPO_OK;
}


void
Peer2PeerBackend::PollSyncEvents(void)
{
   Sync::Event e;
   while (_sync.GetEvent(e)) {
      OnSyncEvent(e);
   }
   return;
}

void
Peer2PeerBackend::PollUdpProtocolEvents(void)
{
   UdpProtocol::Event evt;
   for (int i = 0; i < _num_players; i++) {
      while (_endpoints[i].GetEvent(evt)) {
         OnUdpProtocolPeerEvent(evt, i);
      }
   }
   for (int i = 0; i < _num_spectators; i++) {
      while (_spectators[i].GetEvent(evt)) {
         OnUdpProtocolSpectatorEvent(evt, i);
      }
   }
}

void
Peer2PeerBackend::OnUdpProtocolPeerEvent(UdpProtocol::Event &evt, int queue)
{
   OnUdpProtocolEvent(evt, QueueToPlayerHandle(queue));
   switch (evt.type) {
      case UdpProtocol::Event::Input:
         if (!_local_connect_status[queue].disconnected) {
            int current_remote_frame = _local_connect_status[queue].last_frame;
            int new_remote_frame = evt.u.input.input.frame;
            ASSERT(current_remote_frame == -1 || new_remote_frame == (current_remote_frame + 1));

            _sync.AddRemoteInput(queue, evt.u.input.input);
            // Notify the other endpoints which frame we received from a peer
            Log("setting remote connect status for queue %d to %d\n", queue, evt.u.input.input.frame);
            _local_connect_status[queue].last_frame = evt.u.input.input.frame;
         }
         break;

   case UdpProtocol::Event::Disconnected:
      DisconnectPlayer(QueueToPlayerHandle(queue));
      break;
   }
}


void
Peer2PeerBackend::OnUdpProtocolSpectatorEvent(UdpProtocol::Event &evt, int queue)
{
   GGPOPlayerHandle handle = QueueToSpectatorHandle(queue);
   OnUdpProtocolEvent(evt, handle);

   GGPOEvent info;

   switch (evt.type) {
   case UdpProtocol::Event::Disconnected:
      _spectators[queue].Disconnect();

      info.code = GGPO_EVENTCODE_DISCONNECTED_FROM_PEER;
      info.u.disconnected.player = handle;
      _callbacks.on_event(&info);

      break;
   }
}

void
Peer2PeerBackend::OnUdpProtocolEvent(UdpProtocol::Event &evt, GGPOPlayerHandle handle)
{
   GGPOEvent info;

   switch (evt.type) {
   case UdpProtocol::Event::Connected:
      info.code = GGPO_EVENTCODE_CONNECTED_TO_PEER;
      info.u.connected.player = handle;
      _callbacks.on_event(&info);
      break;
   case UdpProtocol::Event::Synchronizing:
      info.code = GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER;
      info.u.synchronizing.player = handle;
      info.u.synchronizing.count = evt.u.synchronizing.count;
      info.u.synchronizing.total = evt.u.synchronizing.total;
      _callbacks.on_event(&info);
      break;
   case UdpProtocol::Event::Synchronzied:
      info.code = GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER;
      info.u.synchronized.player = handle;
      _callbacks.on_event(&info);

      CheckInitialSync();
      break;

   case UdpProtocol::Event::NetworkInterrupted:
      info.code = GGPO_EVENTCODE_CONNECTION_INTERRUPTED;
      info.u.connection_interrupted.player = handle;
      info.u.connection_interrupted.disconnect_timeout = evt.u.network_interrupted.disconnect_timeout;
      _callbacks.on_event(&info);
      break;

   case UdpProtocol::Event::NetworkResumed:
      info.code = GGPO_EVENTCODE_CONNECTION_RESUMED;
      info.u.connection_resumed.player = handle;
      _callbacks.on_event(&info);
      break;
   }
}

/*
 * Called only as the result of a local decision to disconnect.  The remote
 * decisions to disconnect are a result of us parsing the peer_connect_settings
 * blob in every endpoint periodically.
 */
GGPOErrorCode
Peer2PeerBackend::DisconnectPlayer(GGPOPlayerHandle player)
{
   int queue;
   GGPOErrorCode result;

   result = PlayerHandleToQueue(player, &queue);
   if (!GGPO_SUCCEEDED(result)) {
      return result;
   }
   
   if (_local_connect_status[queue].disconnected) {
      return GGPO_ERRORCODE_PLAYER_DISCONNECTED;
   }

   if (!_endpoints[queue].IsInitialized()) {
      int current_frame = _sync.GetFrameCount();
      // xxx: we should be tracking who the local player is, but for now assume
      // that if the endpoint is not initalized, this must be the local player.
      Log("Disconnecting local player %d at frame %d by user request.\n", queue, _local_connect_status[queue].last_frame);
      for (int i = 0; i < _num_players; i++) {
         if (_endpoints[i].IsInitialized()) {
            DisconnectPlayerQueue(i, current_frame);
         }
      }
   } else {
      Log("Disconnecting queue %d at frame %d by user request.\n", queue, _local_connect_status[queue].last_frame);
      DisconnectPlayerQueue(queue, _local_connect_status[queue].last_frame);
   }
   return GGPO_OK;
}

void
Peer2PeerBackend::DisconnectPlayerQueue(int queue, int syncto)
{
   GGPOEvent info;
   int framecount = _sync.GetFrameCount();

   _endpoints[queue].Disconnect();

   Log("Changing queue %d local connect status for last frame from %d to %d on disconnect request (current: %d).\n",
       queue, _local_connect_status[queue].last_frame, syncto, framecount);

   _local_connect_status[queue].disconnected = 1;
   _local_connect_status[queue].last_frame = syncto;

   if (syncto < framecount) {
      Log("adjusting simulation to account for the fact that %d disconnected @ %d.\n", queue, syncto);
      _sync.AdjustSimulation(syncto);
      Log("finished adjusting simulation.\n");
   }

   info.code = GGPO_EVENTCODE_DISCONNECTED_FROM_PEER;
   info.u.disconnected.player = QueueToPlayerHandle(queue);
   _callbacks.on_event(&info);

   CheckInitialSync();
}


GGPOErrorCode
Peer2PeerBackend::GetNetworkStats(FGGPONetworkStats *stats, GGPOPlayerHandle player)
{
   int queue;
   GGPOErrorCode result;

   result = PlayerHandleToQueue(player, &queue);
   if (!GGPO_SUCCEEDED(result)) {
      return result;
   }

   memset(stats, 0, sizeof *stats);
   _endpoints[queue].GetNetworkStats(stats);

   return GGPO_OK;
}

GGPOErrorCode
Peer2PeerBackend::SetFrameDelay(GGPOPlayerHandle player, int delay) 
{ 
   int queue;
   GGPOErrorCode result;

   result = PlayerHandleToQueue(player, &queue);
   if (!GGPO_SUCCEEDED(result)) {
      return result;
   }
   _sync.SetFrameDelay(queue, delay);
   return GGPO_OK; 
}

GGPOErrorCode
Peer2PeerBackend::SetDisconnectTimeout(int timeout)
{
   _disconnect_timeout = timeout;
   for (int i = 0; i < _num_players; i++) {
      if (_endpoints[i].IsInitialized()) {
         _endpoints[i].SetDisconnectTimeout(_disconnect_timeout);
      }
   }
   return GGPO_OK;
}

GGPOErrorCode
Peer2PeerBackend::SetDisconnectNotifyStart(int timeout)
{
   _disconnect_notify_start = timeout;
   for (int i = 0; i < _num_players; i++) {
      if (_endpoints[i].IsInitialized()) {
         _endpoints[i].SetDisconnectNotifyStart(_disconnect_notify_start);
      }
   }
   return GGPO_OK;
}

GGPOErrorCode
Peer2PeerBackend::TrySynchronizeLocal()
{
   if (_num_players <= 1 && _num_spectators == 0)
   {
      if (_num_players == 0 || !_endpoints[0].IsInitialized())
         CheckInitialSync();
   }

   if (_synchronizing)
      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;
   UE_LOG(GGPOLOG, Verbose, TEXT("Peer2PeerBackend::TrySynchronizeLocal Synchronized local-only simulation."))
   return GGPO_OK;
}


GGPOErrorCode
Peer2PeerBackend::PlayerHandleToQueue(GGPOPlayerHandle player, int *queue)
{
   int offset = ((int)player - 1);
   if (offset < 0 || offset >= _num_players) {
      return GGPO_ERRORCODE_INVALID_PLAYER_HANDLE;
   }
   *queue = offset;
   return GGPO_OK;
}

 
void
Peer2PeerBackend::OnMsg(int connection_id, UdpMsg *msg, int len)
{
   for (int i = 0; i < _num_players; i++) {
      if (_endpoints[i].HandlesMsg(connection_id, msg)) {
         _endpoints[i].OnMsg(msg, len);
         return;
      }
   }
   for (int i = 0; i < _num_spectators; i++) {
      if (_spectators[i].HandlesMsg(connection_id, msg)) {
         _spectators[i].OnMsg(msg, len);
         return;
      }
   }
}

void
Peer2PeerBackend::CheckInitialSync()
{
   int i;

   if (_synchronizing) {
      // Check to see if everyone is now synchronized.  If so,
      // go ahead and tell the client that we're ok to accept input.
      for (i = 0; i < _num_players; i++) {
         // xxx: IsInitialized() must go... we're actually using it as a proxy for "represents the local player"
         if (_endpoints[i].IsInitialized() && !_endpoints[i].IsSynchronized() && !_local_connect_status[i].disconnected) {
            return;
         }
      }
      for (i = 0; i < _num_spectators; i++) {
         if (_spectators[i].IsInitialized() && !_spectators[i].IsSynchronized()) {
            return;
         }
      }

      GGPOEvent info;
      info.code = GGPO_EVENTCODE_RUNNING;
      _callbacks.on_event(&info);
      _synchronizing = false;
   }
}

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/p2p.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _P2P_H
#define _P2P_H

#include "types.h"
#include "poll.h"
#include "sync.h"
#include "backend.h"
#include "timesync.h"
#include "network/udp_proto.h"

class Peer2PeerBackend : public IQuarkBackend, IPollSink, Udp::Callbacks {
public:
   Peer2PeerBackend(GGPOSessionCallbacks *cb, const char *gamename, ConnectionManager* connection_manager, int num_players, int input_size);
   virtual ~Peer2PeerBackend();


public:
   int remoteplayerId;
   int remoteplayerQueueu;
   virtual GGPOErrorCode DoPoll(int timeout);
   virtual GGPOErrorCode AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle);
   virtual GGPOErrorCode AddLocalInput(GGPOPlayerHandle player, void *values, int size);
   virtual GGPOErrorCode SyncInput(void *values, int size, int *disconnect_flags);
   virtual GGPOErrorCode IncrementFrame(void);
   virtual GGPOErrorCode DisconnectPlayer(GGPOPlayerHandle handle);
   virtual GGPOErrorCode GetNetworkStats(FGGPONetworkStats *stats, GGPOPlayerHandle handle) override;
   virtual GGPOErrorCode SetFrameDelay(GGPOPlayerHandle player, int delay);
   virtual GGPOErrorCode SetDisconnectTimeout(int timeout);
   virtual GGPOErrorCode SetDisconnectNotifyStart(int timeout);
   virtual GGPOErrorCode TrySynchronizeLocal() override;

public:
   virtual void OnMsg(int connection_id, UdpMsg *msg, int len) override;

protected:
   GGPOErrorCode PlayerHandleToQueue(GGPOPlayerHandle player, int *queue);
   GGPOPlayerHandle QueueToPlayerHandle(int queue) { return (GGPOPlayerHandle)(queue + 1); }
   GGPOPlayerHandle QueueToSpectatorHandle(int queue) { return (GGPOPlayerHandle)(queue + 1000); } /* out of range of the player array, basically */
   void DisconnectPlayerQueue(int queue, int syncto);
   void PollSyncEvents(void);
   void PollUdpProtocolEvents(void);
   void CheckInitialSync(void);
   int Poll2Players(int current_frame);
   int PollNPlayers(int current_frame);
   void AddRemotePlayer(int connection_id, int queue);
   GGPOErrorCode AddSpectator(int connection_id);
   virtual void OnSyncEvent(Sync::Event &e) { }
   virtual void OnUdpProtocolEvent(UdpProtocol::Event &e, GGPOPlayerHandle handle);
   virtual void OnUdpProtocolPeerEvent(UdpProtocol::Event &e, int queue);
   virtual void OnUdpProtocolSpectatorEvent(UdpProtocol::Event &e, int queue);

protected:
   GGPOSessionCallbacks  _callbacks;
   Poll                  _poll;
   Sync                  _sync;
   Udp                   _udp;
   UdpProtocol           *_endpoints;
   UdpProtocol           _spectators[GGPO_MAX_SPECTATORS];
   int                   _num_spectators;
   int                   _input_size;

   bool                  _synchronizing;
   int                   _num_players;
   int                   _next_recommended_sleep;

   int                   _next_spectator_frame;
   int                   _disconnect_timeout;
   int                   _disconnect_notify_start;

   UdpMsg::connect_status _local_connect_status[UDP_MSG_MAX_PLAYERS];
};

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/spectator.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "spectator.h"

SpectatorBackend::SpectatorBackend(GGPOSessionCallbacks *cb,
                                   const char* gamename,
                                   ConnectionManager* connection_manager,
                                   int num_players,
                                   int input_size,
                                   int connection_id) :
   _input_size(input_size),
   _num_players(num_players),
   _next_input_to_send(0)
{
   _callbacks = *cb;
   _synchronizing = true;

   for (int i = 0; i < ARRAY_SIZE(_inputs); i++) {
      _inputs[i].frame = -1;
   }

   /*
    * Initialize the UDP port
    */
   _udp.Init(&_poll, this, connection_manager);

   /*
    * Init the host endpoint
    */
   _host.Init(&_udp, _poll, 0, connection_id, NULL);
   _host.Synchronize();

   /*
    * Preload the ROM
    */
   _callbacks.begin_game(gamename);
}
  
SpectatorBackend::~SpectatorBackend()
{
}

GGPOErrorCode
SpectatorBackend::DoPoll(int timeout)
{
   _poll.Pump(0);

   PollUdpProtocolEvents();
   return GGPO_OK;
}

GGPOErrorCode
SpectatorBackend::SyncInput(void *values,
                            int size,
                            int *disconnect_flags)
{
   // Wait until we've started to return inputs.
   if (_synchronizing) {
      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;
   }

   GameInput &input = _inputs[_next_input_to_send % SPECTATOR_FRAME_BUFFER_SIZE];
   if (input.frame < _next_input_to_send) {
      // Haven't received the input from the host yet.  Wait
      return GGPO_ERRORCODE_PREDICTION_THRESHOLD;
   }
   if (input.frame > _next_input_to_send) {
      // The host is way way way far ahead of the spectator.  How'd this
      // happen?  Anyway, the input we need is gone forever.
      return GGPO_ERRORCODE_GENERAL_FAILURE;
   }

   ASSERT(size >= _input_size * _num_players);
   memcpy(values, input.bits, _input_size * _num_players);
   if (disconnect_flags) {
      *disconnect_flags = 0; // xxx: should get them from the host!
   }
   _next_input_to_send++;

   return GGPO_OK;
}

GGPOErrorCode
SpectatorBackend::IncrementFrame(void)
{  
   Log("End of frame (%d)...\n", _next_input_to_send - 1);
   DoPoll(0);
   PollUdpProtocolEvents();

   return GGPO_OK;
}

void
SpectatorBackend::PollUdpProtocolEvents(void)
{
   UdpProtocol::Event evt;
   while (_host.GetEvent(evt)) {
      OnUdpProtocolEvent(evt);
   }
}

void
SpectatorBackend::OnUdpProtocolEvent(UdpProtocol::Event &evt)
{
   GGPOEvent info;

   switch (evt.type) {
   case UdpProtocol::Event::Connected:
      info.code = GGPO_EVENTCODE_CONNECTED_TO_PEER;
      info.u.connected.player = 0;
      _callbacks.on_event(&info);
      break;
   case UdpProtocol::Event::Synchronizing:
      info.code = GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER;
      info.u.synchronizing.player = 0;
      info.u.synchronizing.count = evt.u.synchronizing.count;
      info.u.synchronizing.total = evt.u.synchronizing.total;
      _callbacks.on_event(&info);
      break;
   case UdpProtocol::Event::Synchronzied:
      if (_synchronizing) {
         info.code = GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER;
         info.u.synchronized.player = 0;
         _callbacks.on_event(&info);

         info.code = GGPO_EVENTCODE_RUNNING;
         _callbacks.on_event(&info);
         _synchronizing = false;
      }
      break;

   case UdpProtocol::Event::NetworkInterrupted:
      info.code = GGPO_EVENTCODE_CONNECTION_INTERRUPTED;
      info.u.connection_interrupted.player = 0;
      info.u.connection_interrupted.disconnect_timeout = evt.u.network_interrupted.disconnect_timeout;
      _callbacks.on_event(&info);
      break;

   case UdpProtocol::Event::NetworkResumed:
      info.code = GGPO_EVENTCODE_CONNECTION_RESUMED;
      info.u.connection_resumed.player = 0;
      _callbacks.on_event(&info);
      break;

   case UdpProtocol::Event::Disconnected:
      info.code = GGPO_EVENTCODE_DISCONNECTED_FROM_PEER;
      info.u.disconnected.player = 0;
      _callbacks.on_event(&info);
      break;

   case UdpProtocol::Event::Input:
      GameInput& input = evt.u.input.input;

      _host.SetLocalFrameNumber(input.frame);
      _host.SendInputAck();
      _inputs[input.frame % SPECTATOR_FRAME_BUFFER_SIZE] = input;
      break;
   }
}
 
void
SpectatorBackend::OnMsg(int connection_id, UdpMsg *msg, int len)
{
   if (_host.HandlesMsg(connection_id, msg)) {
      _host.OnMsg(msg, len);
   }
}


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/spectator.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _SPECTATOR_H
#define _SPECTATOR_H

#include "types.h"
#include "poll.h"
#include "sync.h"
#include "backend.h"
#include "timesync.h"
#include "network/udp_proto.h"

#define SPECTATOR_FRAME_BUFFER_SIZE    64

class SpectatorBackend : public IQuarkBackend, IPollSink, Udp::Callbacks {
public:
   SpectatorBackend(GGPOSessionCallbacks *cb, const char *gamename, ConnectionManager* connection_manager, int num_players, int input_size, int connection_id);
   virtual ~SpectatorBackend();


public:
   virtual GGPOErrorCode DoPoll(int timeout);
   virtual GGPOErrorCode AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle) { return GGPO_ERRORCODE_UNSUPPORTED; }
   virtual GGPOErrorCode AddLocalInput(GGPOPlayerHandle player, void *values, int size) { return GGPO_OK; }
   virtual GGPOErrorCode SyncInput(void *values, int size, int *disconnect_flags);
   virtual GGPOErrorCode IncrementFrame(void);
   virtual GGPOErrorCode DisconnectPlayer(GGPOPlayerHandle handle) { return GGPO_ERRORCODE_UNSUPPORTED; }
   virtual GGPOErrorCode GetNetworkStats(FGGPONetworkStats *stats, GGPOPlayerHandle handle) { return GGPO_ERRORCODE_UNSUPPORTED; }
   virtual GGPOErrorCode SetFrameDelay(GGPOPlayerHandle player, int delay) { return GGPO_ERRORCODE_UNSUPPORTED; }
   virtual GGPOErrorCode SetDisconnectTimeout(int timeout) { return GGPO_ERRORCODE_UNSUPPORTED; }
   virtual GGPOErrorCode SetDisconnectNotifyStart(int timeout) { return GGPO_ERRORCODE_UNSUPPORTED; }

public:
   virtual void OnMsg(int connection_id, UdpMsg *msg, int len);

protected:
   void PollUdpProtocolEvents(void);
   void CheckInitialSync(void);

   void OnUdpProtocolEvent(UdpProtocol::Event &e);

protected:
   GGPOSessionCallbacks  _callbacks;
   Poll                  _poll;
   Udp                   _udp;
   UdpProtocol           _host;
   bool                  _synchronizing;
   int                   _input_size;
   int                   _num_players;
   int                   _next_input_to_send;
   GameInput             _inputs[SPECTATOR_FRAME_BUFFER_SIZE];
};

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/synctest.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "synctest.h"

#include "Kismet/KismetSystemLibrary.h"

SyncTestBackend::SyncTestBackend(GGPOSessionCallbacks *cb,
                                 const char *gamename,
                                 int frames,
                                 int num_players) :
   _sync(NULL)
{
   _callbacks = *cb;
   _num_players = num_players;
   _check_distance = frames;
   _last_verified = 0;
   _rollingback = false;
   _running = false;
   _logfp = NULL;
   _current_input.erase();
   strcpy(_game, gamename);

   /*
    * Initialize the synchronziation layer
    */
   Sync::Config config = Sync::Config();
   config.callbacks = _callbacks;
   config.num_prediction_frames = MAX_PREDICTION_FRAMES;
   _sync.Init(config);

   /*
    * Preload the ROM
    */
   _callbacks.begin_game(gamename);
}

SyncTestBackend::~SyncTestBackend()
{
}

GGPOErrorCode
SyncTestBackend::DoPoll(int timeout)
{
   if (!_running) {
      GGPOEvent info;

      info.code = GGPO_EVENTCODE_RUNNING;
      _callbacks.on_event(&info);
      _running = true;
   }
   return GGPO_OK;
}

GGPOErrorCode
SyncTestBackend::AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle)
{
   if (player->player_num < 1 || player->player_num > _num_players) {
      return GGPO_ERRORCODE_PLAYER_OUT_OF_RANGE;
   }
   *handle = (GGPOPlayerHandle)(player->player_num - 1);
   return GGPO_OK;
}

GGPOErrorCode
SyncTestBackend::AddLocalInput(GGPOPlayerHandle player, void *values, int size)
{
   if (!_running) {
      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;
   }

   int index = (int)player;
   for (int i = 0; i < size; i++) {
      _current_input.bits[(index * size) + i] |= ((char *)values)[i];
   }
   return GGPO_OK;
}

GGPOErrorCode
SyncTestBackend::SyncInput(void *values,
                           int size,
                           int *disconnect_flags)
{
   BeginLog(false);
   if (_rollingback) {
      _last_input = _saved_frames.front().input;
   } else {
      if (_sync.GetFrameCount() == 0) {
         _sync.SaveCurrentFrame();
      }
      _last_input = _current_input;
   }
   memcpy(values, _last_input.bits, size);
   if (disconnect_flags) {
      *disconnect_flags = 0;
   }
   return GGPO_OK;
}

GGPOErrorCode
SyncTestBackend::IncrementFrame(void)
{  
   _sync.IncrementFrame();
   _current_input.erase();
   
   Log("End of frame(%d)...\n", _sync.GetFrameCount());
   EndLog();

   if (_rollingback) {
      return GGPO_OK;
   }

   int frame = _sync.GetFrameCount();
   // Hold onto the current frame in our queue of saved states.  We'll need
   // the checksum later to verify that our replay of the same frame got the
   // same results.
   SavedInfo info;
   info.frame = frame;
   info.input = _last_input;
   info.cbuf = _sync.GetLastSavedFrame().cbuf;
   info.buf = (char *)malloc(info.cbuf);
   memcpy(info.buf, _sync.GetLastSavedFrame().buf, info.cbuf);
   info.checksum = _sync.GetLastSavedFrame().checksum;
   _saved_frames.push(info);

   if (frame - _last_verified == _check_distance) {
      // We've gone far enough ahead and should now start replaying frames.
      // Load the last verified frame and set the rollback flag to true.
      _sync.LoadFrame(_last_verified);

      _rollingback = true;
      while(!_saved_frames.empty()) {
         _callbacks.advance_frame(0);

         // Verify that the checksumn of this frame is the same as the one in our
         // list.
         info = _saved_frames.front();
         _saved_frames.pop();

         if (info.frame != _sync.GetFrameCount()) {
            RaiseSyncError("Frame number %d does not match saved frame number %d", info.frame, frame);
         }
         int checksum = _sync.GetLastSavedFrame().checksum;
         if (info.checksum != checksum) {
            LogSaveStates(info);
            RaiseSyncError("Checksum for frame %d does not match saved (%d != %d)", frame, checksum, info.checksum);
         }
         printf("Checksum %08d for frame %d matches.\n", checksum, info.frame);
         free(info.buf);
      }
      _last_verified = frame;
      _rollingback = false;
   }

   return GGPO_OK;
}

void
SyncTestBackend::RaiseSyncError(const char *fmt, ...)
{
   char buf[1024];
   va_list args;
   va_start(args, fmt);
   vsprintf(buf, fmt, args);
   va_end(args);

   puts(buf);
   EndLog();
   DebugBreak();
}

GGPOErrorCode
SyncTestBackend::Logv(const char *fmt, va_list list)
{
   if (_logfp) {
      vfprintf(_logfp, fmt, list);
   }
   return GGPO_OK;
}

void
SyncTestBackend::BeginLog(int saving)
{
   EndLog();

   char filename[MAX_PATH];
   Platform::CreateDirectory(TCHAR_TO_ANSI(*(UKismetSystemLibrary::GetProjectSavedDirectory() + "synclogs")), NULL);
   sprintf(filename, "synclogs\\%s-%04d-%s.log",
           saving ? "state" : "log",
           _sync.GetFrameCount(),
           _rollingback ? "replay" : "original");

    fopen(filename, "w");
}

void
SyncTestBackend::EndLog()
{
   if (_logfp) {
      fprintf(_logfp, "Closing log file.\n");
      fclose(_logfp);
      _logfp = NULL;
   }
}
void
SyncTestBackend::LogSaveStates(SavedInfo &info)
{
   char filename[MAX_PATH];
   sprintf(filename,  "synclogs\\state-%04d-original.log", _sync.GetFrameCount());
   _callbacks.log_game_state(filename, (unsigned char *)info.buf, info.cbuf);

   sprintf(filename, "synclogs\\state-%04d-replay.log", _sync.GetFrameCount());
   _callbacks.log_game_state(filename, _sync.GetLastSavedFrame().buf, _sync.GetLastSavedFrame().cbuf);
}

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/synctest.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _SYNCTEST_H
#define _SYNCTEST_H

#include "types.h"
#include "backend.h"
#include "sync.h"
#include "ring_buffer.h"

class SyncTestBackend : public IQuarkBackend {
public:
   SyncTestBackend(GGPOSessionCallbacks *cb, const char *gamename, int frames, int num_players);
   virtual ~SyncTestBackend();

   virtual GGPOErrorCode DoPoll(int timeout);
   virtual GGPOErrorCode AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle);
   virtual GGPOErrorCode AddLocalInput(GGPOPlayerHandle player, void *values, int size);
   virtual GGPOErrorCode SyncInput(void *values, int size, int *disconnect_flags);
   virtual GGPOErrorCode IncrementFrame(void);
   virtual GGPOErrorCode Logv(const char *fmt, va_list list) override;

protected:
   struct SavedInfo {
      int         frame;
      int         checksum;
      char        *buf;
      int         cbuf;
      GameInput   input;
   };

   void RaiseSyncError(const char *fmt, ...);
   void BeginLog(int saving);
   void EndLog();
   void LogSaveStates(SavedInfo &info);

protected:
   GGPOSessionCallbacks   _callbacks;
   Sync                   _sync;
   int                    _num_players;
   int                    _check_distance;
   int                    _last_verified;
   bool                   _rollingback;
   bool                   _running;
   FILE                   *_logfp;
   char                   _game[128];

   GameInput                  _current_input;
   GameInput                  _last_input;
   RingBuffer<SavedInfo, 32>  _saved_frames;
};

#endif


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/bitvector.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "bitvector.h"
#include "types.h"

void
BitVector_SetBit(uint8 *vector, int *offset)
{
   vector[(*offset) / 8] |= (1 << ((*offset) % 8));
   *offset += 1;
}

void
BitVector_ClearBit(uint8 *vector, int *offset)
{
   vector[(*offset) / 8] &= ~(1 << ((*offset) % 8));
   *offset += 1;
}

void
BitVector_WriteNibblet(uint8 *vector, int nibble, int *offset)
{
   ASSERT(nibble < (1 << BITVECTOR_NIBBLE_SIZE));
   for (int i = 0; i < BITVECTOR_NIBBLE_SIZE; i++) {
      if (nibble & (1 << i)) {
         BitVector_SetBit(vector, offset);
      } else {
         BitVector_ClearBit(vector, offset);
      }
   }
}

int
BitVector_ReadBit(uint8 *vector, int *offset)
{
   int retval = !!(vector[(*offset) / 8] & (1 << ((*offset) % 8)));
   *offset += 1;
   return retval;
}

int
BitVector_ReadNibblet(uint8 *vector, int *offset)
{
   int nibblet = 0;
   for (int i = 0; i < BITVECTOR_NIBBLE_SIZE; i++) {
      nibblet |= (BitVector_ReadBit(vector, offset) << i);
   }
   return nibblet;
}


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/bitvector.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _BITVECTOR_H
#define _BITVECTOR_H

#define BITVECTOR_NIBBLE_SIZE 8

void BitVector_SetBit(uint8 *vector, int *offset);
void BitVector_ClearBit(uint8 *vector, int *offset);
void BitVector_WriteNibblet(uint8 *vector, int nibble, int *offset);
int BitVector_ReadBit(uint8 *vector, int *offset);
int BitVector_ReadNibblet(uint8 *vector, int *offset);

#endif // _BITVECTOR_H

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/game_input.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "game_input.h"
#include "types.h"
#include "log.h"

void
GameInput::init(int iframe, char *ibits, int isize, int offset)
{
   ASSERT(isize);
   ASSERT(isize <= GAMEINPUT_MAX_BYTES);
   frame = iframe;
   size = isize;
   memset(bits, 0, sizeof(bits));
   if (ibits) {
      memcpy(bits + (offset * isize), ibits, isize);
   }
}

void
GameInput::init(int iframe, char *ibits, int isize)
{
   ASSERT(isize);
   ASSERT(isize <= GAMEINPUT_MAX_BYTES * GAMEINPUT_MAX_PLAYERS);
   frame = iframe;
   size = isize;
   memset(bits, 0, sizeof(bits));
   if (ibits) {
      memcpy(bits, ibits, isize);
   }
}

void
GameInput::desc(char *buf, size_t buf_size, bool show_frame) const
{
   ASSERT(size);
   size_t remaining = buf_size;
   if (show_frame) {
      remaining -= sprintf(buf, "(frame:%d size:%d ", frame, size);
   } else {
      remaining -= sprintf(buf, "(size:%d ", size);
   }

   for (int i = 0; i < size * 8; i++) {
      char buf2[16];
      if (value(i)) {
         int c = sprintf(buf2, "%2d ", i);
         strncat(buf, buf2, ARRAY_SIZE(buf2));
         remaining -= c;
      }
   }
   strncat(buf, ")", 1);
}

void
GameInput::log(char *prefix, bool show_frame) const
{
	char buf[1024];
   size_t c = strlen(prefix);
	strcpy(buf, prefix);
	desc(buf + c, ARRAY_SIZE(buf) - c, show_frame);
   strncat(buf, "\n", 1);
	Log(buf);
}

bool
GameInput::equal(GameInput &other, bool bitsonly)
{
   if (!bitsonly && frame != other.frame) {
      Log("frames don't match: %d, %d\n", frame, other.frame);
   }
   if (size != other.size) {
      Log("sizes don't match: %d, %d\n", size, other.size);
   }
   if (memcmp(bits, other.bits, size)) {
      Log("bits don't match\n");
   }
   ASSERT(size && other.size);
   return (bitsonly || frame == other.frame) &&
          size == other.size &&
          memcmp(bits, other.bits, size) == 0;
}


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/game_input.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _GAMEINPUT_H
#define _GAMEINPUT_H

#include <stdio.h>
#include <memory.h>

// GAMEINPUT_MAX_BYTES * GAMEINPUT_MAX_PLAYERS * 8 must be less than
// 2^BITVECTOR_NIBBLE_SIZE (see bitvector.h)

#define GAMEINPUT_MAX_BYTES      9
#define GAMEINPUT_MAX_PLAYERS    2

struct GameInput {
   enum Constants {
      NullFrame = -1
   };
   int      frame;
   int      size; /* size in bytes of the entire input for all players */
   char     bits[GAMEINPUT_MAX_BYTES * GAMEINPUT_MAX_PLAYERS];

   bool is_null() { return frame == NullFrame; }
   void init(int frame, char *bits, int size, int offset);
   void init(int frame, char *bits, int size);
   bool value(int i) const { return (bits[i/8] & (1 << (i%8))) != 0; }
   void set(int i) { bits[i/8] |= (1 << (i%8)); }
   void clear(int i) { bits[i/8] &= ~(1 << (i%8)); }
   void erase() { memset(bits, 0, sizeof(bits)); }
   void desc(char *buf, size_t buf_size, bool show_frame = true) const;
   void log(char *prefix, bool show_frame = true) const;
   bool equal(GameInput &input, bool bitsonly = false);
};

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/include/connection_manager.cpp`:

```cpp

#include "include/connection_manager.h"
#include "types.h"
#include "GGPOUE4.h"


#if defined(_WINDOWS)
SOCKET
CreateSocket(uint16 bind_port, int retries)
{
	SOCKET s;
	sockaddr_in sin;
	uint16 port;
	int optval = 1;

	s = socket(AF_INET, SOCK_DGRAM, 0);
	setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (const char*)&optval, sizeof optval);
	setsockopt(s, SOL_SOCKET, SO_DONTLINGER, (const char*)&optval, sizeof optval);

	// non-blocking...
	u_long iMode = 1;
	ioctlsocket(s, FIONBIO, &iMode);

	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = htonl(INADDR_ANY);
	for (port = bind_port; port <= bind_port + retries; port++) {
		sin.sin_port = htons(port);
		if (bind(s, (sockaddr*)&sin, sizeof sin) != SOCKET_ERROR) {
			UE_LOG(GGPOLOG, Verbose, TEXT("Udp bound to port: %d."), port);
			return s;
		}
	}
	closesocket(s);
	return INVALID_SOCKET;
}
#endif

ConnectionManager::~ConnectionManager() {
	_connection_map.clear();
}

std::string ConnectionManager::ToString(int connection_id) {
	check(_connection_map.count(connection_id));
	std::shared_ptr<ConnectionInfo> dest_addr = _connection_map.find(connection_id)->second;
	return dest_addr->ToString();
}


#if defined(_WINDOWS)
UDPConnectionManager::UDPConnectionManager() : _socket(INVALID_SOCKET), _peer_addr() {}

int UDPConnectionManager::SendTo(const char* buffer, int len, int flags, int connection_id) {
	
	check(_connection_map.count(connection_id));
	if (_connection_map.count(connection_id) == 0) {
		UE_LOG(GGPOLOG, Warning, TEXT("Connection not in map Connection ID: %d)."), connection_id);
	}

	std::shared_ptr<ConnectionInfo> dest_addr = _connection_map.find(connection_id)->second;

	int res = sendto(_socket, buffer, len, flags,
		(struct sockaddr*) & static_cast <UPDInfo&>(*dest_addr).addr,
		sizeof(static_cast <UPDInfo&>(*dest_addr).addr));

	if (res == SOCKET_ERROR) {
		DWORD err = WSAGetLastError();

		UE_LOG(GGPOLOG, Error, TEXT("Unknown error in sendto (erro: %d  wsaerr: %d), Connection ID: %d.\n"), res, err, connection_id)		
		check(false && "Unknown error in sendto");
	}
	UE_LOG(GGPOLOG, Verbose, TEXT("Connection not in map Connection ID: %d)."), len,
		ToString(connection_id).c_str(), res);
	
	return 0;
}

int UDPConnectionManager::RecvFrom(char* buffer, int len, int flags, int* connection_id) {
	
	sockaddr_in    recv_addr;
	int            recv_addr_len;
	recv_addr_len = sizeof(recv_addr);

	// >0 indicates data length.
	// 0 indicates a disconnect.
	// -1 indicates no data or some other error.
	int inlen = recvfrom(_socket, (char*)buffer, len, flags, (struct sockaddr*) & recv_addr, &recv_addr_len);

	// Assign connection_id to the id we recieved the data from.
	*connection_id = FindIDFromIP(&recv_addr);

	// Platform specific error message handling should be done in the connection manager.
	if (inlen == -1) {
		int error = WSAGetLastError();
		if (error != WSAEWOULDBLOCK) {
			UE_LOG(GGPOLOG, Error, TEXT("recvfrom WSAGetLastError returned %d (%x)."), error, error);
		}
	}

	return inlen;
}

int UDPConnectionManager::FindIDFromIP(sockaddr_in* addr) {

	for (std::map<int, std::shared_ptr<ConnectionInfo>>::iterator it = _connection_map.begin();
		it != _connection_map.end();
		++it) {
		std::shared_ptr<ConnectionInfo> dest_addr(it->second);
		// Note: dynamic casts don't work here because UE4 doesn't allow for normal dynamic casting.
		if( static_cast <UPDInfo&>(*dest_addr).addr.sin_addr.S_un.S_addr == addr->sin_addr.S_un.S_addr
			&&
			static_cast <UPDInfo&>(*dest_addr).addr.sin_port == addr->sin_port) {
			return it->first;
		}
	}
	return -1;
}

void UDPConnectionManager::Init(uint16 port) {
	UE_LOG(GGPOLOG, Verbose, TEXT("Binding udp socket to port %d."), port);
	_socket = CreateSocket(port, 0);
}

int UDPConnectionManager::AddConnection(const char* ip_address, uint16 port) {
	return ConnectionManager::AddConnection(BuildConnectionInfo(ip_address, port));
}

UDPConnectionManager::~UDPConnectionManager() {
	if (_socket != INVALID_SOCKET) {
		closesocket(_socket);
		_socket = INVALID_SOCKET;
	}
}

std::shared_ptr<ConnectionInfo> UDPConnectionManager::BuildConnectionInfo(const char* ip_address, uint16 port) {
	return std::static_pointer_cast<ConnectionInfo>(std::make_shared<UPDInfo>(ip_address, port));
}

UPDInfo::UPDInfo(const char* ip_address, uint16 port) {
	addr.sin_family = AF_INET;
	inet_pton(AF_INET, ip_address, &addr.sin_addr.s_addr);
	addr.sin_port = htons(port);
}

std::string UPDInfo::ToString() {
	char dst_ip[1024];
	char buffer[100];
	sprintf(buffer, "Connection: IP: %s, Port: %d",
		inet_ntop(AF_INET, (void*)(&addr.sin_addr), dst_ip, ARRAY_SIZE(dst_ip)),
		ntohs(addr.sin_port));
	return std::string(buffer);

}
#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/input_queue.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "input_queue.h"
#include "types.h"

#define PREVIOUS_FRAME(offset)   (((offset) == 0) ? (INPUT_QUEUE_LENGTH - 1) : ((offset) - 1))

InputQueue::InputQueue(int input_size)
{
   Init(-1, input_size);
}

InputQueue::~InputQueue()
{
}

void
InputQueue::Init(int id, int input_size)
{
   _id = id;
   _head = 0;
   _tail = 0;
   _length = 0;
   _frame_delay = 0;
   _first_frame = true;
   _last_user_added_frame = GameInput::NullFrame;
   _first_incorrect_frame = GameInput::NullFrame;
   _last_frame_requested = GameInput::NullFrame;
   _last_added_frame = GameInput::NullFrame;

   _prediction.init(GameInput::NullFrame, NULL, input_size);

   /*
    * This is safe because we know the GameInput is a proper structure (as in,
    * no virtual methods, no contained classes, etc.).
    */
   memset(_inputs, 0, sizeof _inputs);
   for (int i = 0; i < ARRAY_SIZE(_inputs); i++) {
      _inputs[i].size = input_size;
   }
}

int
InputQueue::GetLastConfirmedFrame()
{
   Log("returning last confirmed frame %d.\n", _last_added_frame);
   return _last_added_frame;
}

int
InputQueue::GetFirstIncorrectFrame()
{
   return _first_incorrect_frame;
}

void
InputQueue::DiscardConfirmedFrames(int frame)
{
   ASSERT(frame >= 0);

   if (_last_frame_requested != GameInput::NullFrame) {
      frame = MIN(frame, _last_frame_requested);
   }

   Log("discarding confirmed frames up to %d (last_added:%d length:%d [head:%d tail:%d]).\n", 
       frame, _last_added_frame, _length, _head, _tail);
   if (frame >= _last_added_frame) {
      _tail = _head;
   } else {
      int offset = frame - _inputs[_tail].frame + 1;
      
      Log("difference of %d frames.\n", offset);
      ASSERT(offset >= 0);

      _tail = (_tail + offset) % INPUT_QUEUE_LENGTH;
      _length -= offset;
   }

   Log("after discarding, new tail is %d (frame:%d).\n", _tail, _inputs[_tail].frame);
   ASSERT(_length >= 0);
}

void
InputQueue::ResetPrediction(int frame)
{
   ASSERT(_first_incorrect_frame == GameInput::NullFrame || frame <= _first_incorrect_frame);

   Log("resetting all prediction errors back to frame %d.\n", frame);

   /*
    * There's nothing really to do other than reset our prediction
    * state and the incorrect frame counter...
    */
   _prediction.frame = GameInput::NullFrame;
   _first_incorrect_frame = GameInput::NullFrame;
   _last_frame_requested = GameInput::NullFrame;
}

bool
InputQueue::GetConfirmedInput(int requested_frame, GameInput *input)
{
   ASSERT(_first_incorrect_frame == GameInput::NullFrame || requested_frame < _first_incorrect_frame);
   int offset = requested_frame % INPUT_QUEUE_LENGTH; 
   if (_inputs[offset].frame != requested_frame) {
      return false;
   }
   *input = _inputs[offset];
   return true;
}

bool
InputQueue::GetInput(int requested_frame, GameInput *input)
{
   Log("requesting input frame %d.\n", requested_frame);

   /*
    * No one should ever try to grab any input when we have a prediction
    * error.  Doing so means that we're just going further down the wrong
    * path.  ASSERT this to verify that it's true.
    */
   ASSERT(_first_incorrect_frame == GameInput::NullFrame);

   /*
    * Remember the last requested frame number for later.  We'll need
    * this in AddInput() to drop out of prediction mode.
    */
   _last_frame_requested = requested_frame;

   ASSERT(requested_frame >= _inputs[_tail].frame);

   if (_prediction.frame == GameInput::NullFrame) {
      /*
       * If the frame requested is in our range, fetch it out of the queue and
       * return it.
       */
      int offset = requested_frame - _inputs[_tail].frame;

      if (offset < _length) {
         offset = (offset + _tail) % INPUT_QUEUE_LENGTH;
         ASSERT(_inputs[offset].frame == requested_frame);
         *input = _inputs[offset];
         Log("returning confirmed frame number %d.\n", input->frame);
         return true;
      }

      /*
       * The requested frame isn't in the queue.  Bummer.  This means we need
       * to return a prediction frame.  Predict that the user will do the
       * same thing they did last time.
       */
      if (requested_frame == 0) {
         Log("basing new prediction frame from nothing, you're client wants frame 0.\n");
         _prediction.erase();
      } else if (_last_added_frame == GameInput::NullFrame) {
         Log("basing new prediction frame from nothing, since we have no frames yet.\n");
         _prediction.erase();
      } else {
         Log("basing new prediction frame from previously added frame (queue entry:%d, frame:%d).\n",
              PREVIOUS_FRAME(_head), _inputs[PREVIOUS_FRAME(_head)].frame);
         _prediction = _inputs[PREVIOUS_FRAME(_head)];
      }
      _prediction.frame++;
   }

   ASSERT(_prediction.frame >= 0);

   /*
    * If we've made it this far, we must be predicting.  Go ahead and
    * forward the prediction frame contents.  Be sure to return the
    * frame number requested by the client, though.
    */
   *input = _prediction;
   input->frame = requested_frame;
   Log("returning prediction frame number %d (%d).\n", input->frame, _prediction.frame);

   return false;
}

void
InputQueue::AddInput(GameInput &input)
{
   int new_frame;

   Log("adding input frame number %d to queue.\n", input.frame);

   /*
    * These next two lines simply verify that inputs are passed in 
    * sequentially by the user, regardless of frame delay.
    */
   ASSERT(_last_user_added_frame == GameInput::NullFrame ||
          input.frame == _last_user_added_frame + 1);
   _last_user_added_frame = input.frame;

   /*
    * Move the queue head to the correct point in preparation to
    * input the frame into the queue.
    */
   new_frame = AdvanceQueueHead(input.frame);
   if (new_frame != GameInput::NullFrame) {
      AddDelayedInputToQueue(input, new_frame);
   }
   
   /*
    * Update the frame number for the input.  This will also set the
    * frame to GameInput::NullFrame for frames that get dropped (by
    * design).
    */
   input.frame = new_frame;
}

void
InputQueue::AddDelayedInputToQueue(GameInput &input, int frame_number)
{
   Log("adding delayed input frame number %d to queue.\n", frame_number);

   ASSERT(input.size == _prediction.size);

   ASSERT(_last_added_frame == GameInput::NullFrame || frame_number == _last_added_frame + 1);

   ASSERT(frame_number == 0 || _inputs[PREVIOUS_FRAME(_head)].frame == frame_number - 1);

   /*
    * Add the frame to the back of the queue
    */ 
   _inputs[_head] = input;
   _inputs[_head].frame = frame_number;
   _head = (_head + 1) % INPUT_QUEUE_LENGTH;
   _length++;
   _first_frame = false;

   _last_added_frame = frame_number;

   if (_prediction.frame != GameInput::NullFrame) {
      ASSERT(frame_number == _prediction.frame);

      /*
       * We've been predicting...  See if the inputs we've gotten match
       * what we've been predicting.  If so, don't worry about it.  If not,
       * remember the first input which was incorrect so we can report it
       * in GetFirstIncorrectFrame()
       */
      if (_first_incorrect_frame == GameInput::NullFrame && !_prediction.equal(input, true)) {
         Log("frame %d does not match prediction.  marking error.\n", frame_number);
         _first_incorrect_frame = frame_number;
      }

      /*
       * If this input is the same frame as the last one requested and we
       * still haven't found any mis-predicted inputs, we can dump out
       * of predition mode entirely!  Otherwise, advance the prediction frame
       * count up.
       */
      if (_prediction.frame == _last_frame_requested && _first_incorrect_frame == GameInput::NullFrame) {
         Log("prediction is correct!  dumping out of prediction mode.\n");
         _prediction.frame = GameInput::NullFrame;
      } else {
         _prediction.frame++;
      }
   }
   ASSERT(_length <= INPUT_QUEUE_LENGTH);
}

int
InputQueue::AdvanceQueueHead(int frame)
{
   Log("advancing queue head to frame %d.\n", frame);

   int expected_frame = _first_frame ? 0 : _inputs[PREVIOUS_FRAME(_head)].frame + 1;

   frame += _frame_delay;

   if (expected_frame > frame) {
      /*
       * This can occur when the frame delay has dropped since the last
       * time we shoved a frame into the system.  In this case, there's
       * no room on the queue.  Toss it.
       */
      Log("Dropping input frame %d (expected next frame to be %d).\n",
          frame, expected_frame);
      return GameInput::NullFrame;
   }

   while (expected_frame < frame) {
      /*
       * This can occur when the frame delay has been increased since the last
       * time we shoved a frame into the system.  We need to replicate the
       * last frame in the queue several times in order to fill the space
       * left.
       */
      Log("Adding padding frame %d to account for change in frame delay.\n",
          expected_frame);
      GameInput &last_frame = _inputs[PREVIOUS_FRAME(_head)];     
      AddDelayedInputToQueue(last_frame, expected_frame);
      expected_frame++;
   }

   ASSERT(frame == 0 || frame == _inputs[PREVIOUS_FRAME(_head)].frame + 1);
   return frame;
}


void
InputQueue::Log(const char *fmt, ...)
{
   char buf[1024];
   size_t offset;
   va_list args;

   offset = sprintf(buf, "input q%d | ", _id);
   va_start(args, fmt);
   vsnprintf(buf + offset, ARRAY_SIZE(buf) - offset - 1, fmt, args);
   buf[ARRAY_SIZE(buf)-1] = '\0';
   ::Log(buf);
   va_end(args);
}

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/input_queue.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _INPUT_QUEUE_H
#define _INPUT_QUEUE_H

#include "game_input.h"

#define INPUT_QUEUE_LENGTH    128
#define DEFAULT_INPUT_SIZE      4

class InputQueue {
public:
   InputQueue(int input_size = DEFAULT_INPUT_SIZE);
   ~InputQueue();

public:
   void Init(int id, int input_size);
   int GetLastConfirmedFrame();
   int GetFirstIncorrectFrame();
   int GetLength() { return _length; }

   void SetFrameDelay(int delay) { _frame_delay = delay; }
   void ResetPrediction(int frame);
   void DiscardConfirmedFrames(int frame);
   bool GetConfirmedInput(int frame, GameInput *input);
   bool GetInput(int frame, GameInput *input);
   void AddInput(GameInput &input);

protected:
   int AdvanceQueueHead(int frame);
   void AddDelayedInputToQueue(GameInput &input, int i);
   void Log(const char *fmt, ...);

protected:
   int                  _id;
   int                  _head;
   int                  _tail;
   int                  _length;
   bool                 _first_frame;

   int                  _last_user_added_frame;
   int                  _last_added_frame;
   int                  _first_incorrect_frame;
   int                  _last_frame_requested;

   int                  _frame_delay;

   GameInput            _inputs[INPUT_QUEUE_LENGTH];
   GameInput            _prediction;
};

#endif




```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/log.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "log.h"
#include "types.h"

static FILE *logfile = NULL;

void LogFlush()
{
   if (logfile) {
      fflush(logfile);
   }
}

static char logbuf[4 * 1024 * 1024];

void Log(const char *fmt, ...)
{
   va_list args;
   va_start(args, fmt);
   Logv(fmt, args);
   va_end(args);
}

void Logv(const char *fmt, va_list args)
{
   if (!getenv("GGPO_LOG") || getenv("GGPO_LOG_IGNORE")) {
      return;
   }
   if (!logfile) {
      sprintf(logbuf, "log-%d.log", static_cast<int>(Platform::GetProcessID()));
      fopen(logbuf, "w");
   }
   Logv(logfile, fmt, args);
}

void Logv(FILE *fp, const char *fmt, va_list args)
{
   static int start = 0;
   int t = 0;
   if (!start) {
      start = Platform::GetCurrentTimeMS();
   } else {
      t = Platform::GetCurrentTimeMS() - start;
   }
   fprintf(fp, "%d.%03d : ", t / 1000, t % 1000);

   vfprintf(fp, fmt, args);
   fflush(fp);
   
   vsprintf(logbuf, fmt, args);
}


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/log.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _LOG_H
#define _LOG_H

extern void Log(const char *fmt, ...);
extern void Logv(const char *fmt, va_list list);
extern void Logv(FILE *fp, const char *fmt, va_list args);
extern void LogFlush();
extern void LogFlushOnLog(bool flush);

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/main.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "types.h"
#include "backends/p2p.h"
#include "backends/synctest.h"
#include "backends/spectator.h"
#include "include/ggponet.h"

void
ggpo_log(GGPOSession *ggpo, const char *fmt, ...)
{
   va_list args;
   va_start(args, fmt);
   //GGPONet::ggpo_logv(ggpo, fmt, args);
   va_end(args);
}

void
ggpo_logv(GGPOSession *ggpo, const char *fmt, va_list args)
{
   if (ggpo) {
      ggpo->Logv(fmt, args);
   }
}

GGPOErrorCode
GGPONet::ggpo_start_session(GGPOSession **session,
                   GGPOSessionCallbacks *cb,
                   ConnectionManager* connection_manager,
                   const char *game,
                   int num_players,
                   int input_size)
{
   *session= (GGPOSession *)new Peer2PeerBackend(cb,
                                                 game,
                                                 connection_manager,
                                                 num_players,
                                                 input_size);
   return GGPO_OK;
}

GGPOErrorCode
GGPONet::ggpo_add_player(GGPOSession *ggpo,
                GGPOPlayer *player,
                GGPOPlayerHandle *handle)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->AddPlayer(player, handle);
}



GGPOErrorCode
GGPONet::ggpo_start_synctest(GGPOSession **ggpo,
                    GGPOSessionCallbacks *cb,
                    const char *game,
                    int num_players,
                    int input_size,
                    int frames)
{
   *ggpo = (GGPOSession *)new SyncTestBackend(cb, game, frames, num_players);
   return GGPO_OK;
}

GGPOErrorCode
GGPONet::ggpo_set_frame_delay(GGPOSession *ggpo,
                     GGPOPlayerHandle player,
                     int frame_delay)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->SetFrameDelay(player, frame_delay);
}

GGPOErrorCode
GGPONet::ggpo_idle(GGPOSession *ggpo, int timeout)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->DoPoll(timeout);
}

GGPOErrorCode
GGPONet::ggpo_add_local_input(GGPOSession *ggpo,
                     GGPOPlayerHandle player,
                     void *values,
                     int size)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->AddLocalInput(player, values, size);
}

GGPOErrorCode
GGPONet::ggpo_synchronize_input(GGPOSession *ggpo,
                       void *values,
                       int size,
                       int *disconnect_flags)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->SyncInput(values, size, disconnect_flags);
}

GGPOErrorCode GGPONet::ggpo_disconnect_player(GGPOSession *ggpo,
                                     GGPOPlayerHandle player)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->DisconnectPlayer(player);
}

GGPOErrorCode
GGPONet::ggpo_advance_frame(GGPOSession *ggpo)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->IncrementFrame();
}

GGPOErrorCode
ggpo_client_chat(GGPOSession *ggpo, char *text)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->Chat(text);
}

GGPOErrorCode
GGPONet::ggpo_get_network_stats(GGPOSession *ggpo,
                       GGPOPlayerHandle player,
                       FGGPONetworkStats *stats)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->GetNetworkStats(stats, player);
}


GGPOErrorCode
GGPONet::ggpo_close_session(GGPOSession *ggpo)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   delete ggpo;
   return GGPO_OK;
}

GGPOErrorCode
GGPONet::ggpo_set_disconnect_timeout(GGPOSession *ggpo, int timeout)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->SetDisconnectTimeout(timeout);
}

GGPOErrorCode
GGPONet::ggpo_set_disconnect_notify_start(GGPOSession *ggpo, int timeout)
{
   if (!ggpo) {
      return GGPO_ERRORCODE_INVALID_SESSION;
   }
   return ggpo->SetDisconnectNotifyStart(timeout);
}

GGPOErrorCode GGPONet::ggpo_try_synchronize_local(GGPOSession* ggpo)
{
   if (!ggpo)
      return GGPO_ERRORCODE_INVALID_SESSION;
   return ggpo->TrySynchronizeLocal();
}

GGPOErrorCode GGPONet::ggpo_start_spectating(GGPOSession **session,
                                    GGPOSessionCallbacks *cb,
                                    ConnectionManager* connection_manager,
                                    const char *game,
                                    int num_players,
                                    int input_size,
                                    int connection_id)
{
   *session= (GGPOSession *)new SpectatorBackend(cb,
                                                 game,
                                                 connection_manager,
                                                 num_players,
                                                 input_size,
                                                 connection_id);
   return GGPO_OK;
}


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "udp.h"
#include "types.h"

Udp::Udp() :
   _connection_manager(),
   _callbacks(NULL),
   _poll(NULL)
{
}

Udp::~Udp(void)
{
}

void
Udp::Init(Poll *poll, Callbacks *callbacks, ConnectionManager* connection_manager)
{
   _callbacks = callbacks;

   _poll = poll;
   _connection_manager = connection_manager;
   _poll->RegisterLoop(this);
}

void
Udp::SendTo(char *buffer, int len, int flags, int connection_id)
{
   _connection_manager->SendTo(buffer, len, flags, connection_id);
}

bool
Udp::OnLoopPoll(void *cookie)
{
   uint8          recv_buf[MAX_UDP_PACKET_SIZE];

   for (;;) {
      int connection_id = -1;
      int len = _connection_manager->RecvFrom((char*)recv_buf, MAX_UDP_PACKET_SIZE, 0, &connection_id);

      // TODO: handle len == 0... indicates a disconnect.

      if (len == -1 || connection_id == -1) {
#ifdef _WIN32
         int error = WSAGetLastError();
#else
         int error = 1;
#endif
         if (error != WSAEWOULDBLOCK) {
            Log("recvfrom WSAGetLastError returned %d (%x).\n", error, error);
         }
         break;
      } else if (len > 0) {
         //Log("recvfrom returned (len:%d  from:%s).\n", len, _connection_manager->ToString(connection_id).c_str());
         UdpMsg *msg = (UdpMsg *)recv_buf;
         _callbacks->OnMsg(connection_id, msg, len);
      } 
   }
   return true;
}


void
Udp::Log(const char *fmt, ...)
{
   char buf[1024];
   size_t offset;
   va_list args;

   strcpy(buf, "udp | ");
   offset = strlen(buf);
   va_start(args, fmt);
   vsnprintf(buf + offset, ARRAY_SIZE(buf) - offset - 1, fmt, args);
   buf[ARRAY_SIZE(buf)-1] = '\0';
   ::Log(buf);
   va_end(args);
}

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _UDP_H
#define _UDP_H

#include "poll.h"
#include "udp_msg.h"
#include "include/ggponet.h"
#include "include/connection_manager.h"

#define MAX_UDP_ENDPOINTS     16

static const int MAX_UDP_PACKET_SIZE = 4096;

class Udp : public IPollSink
{
public:
   struct Stats {
      int      bytes_sent;
      int      packets_sent;
      float    kbps_sent;
   };

   struct Callbacks {
      virtual ~Callbacks() { }
      virtual void OnMsg(int connection_id, UdpMsg *msg, int len) = 0;
   };


protected:
   void Log(const char *fmt, ...);

public:
   Udp();

   void Init(Poll *p, Callbacks *callbacks, ConnectionManager* connection_manager);
   
   void SendTo(char *buffer, int len, int flags, int connection_id);

   virtual bool OnLoopPoll(void *cookie);

public:
   ~Udp(void);

protected:
   ConnectionManager* _connection_manager;

   // state management
   Callbacks      *_callbacks;
   Poll           *_poll;
};

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_msg.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _UDP_MSG_H
#define _UDP_MSG_H

#define MAX_COMPRESSED_BITS       4096
#define UDP_MSG_MAX_PLAYERS          4

#pragma pack(push, 1)

struct UdpMsg
{
   enum MsgType {
      Invalid       = 0,
      SyncRequest   = 1,
      SyncReply     = 2,
      Input         = 3,
      QualityReport = 4,
      QualityReply  = 5,
      KeepAlive     = 6,
      InputAck      = 7,
   };

   struct connect_status {
      unsigned int   disconnected:1;
      int            last_frame:31;
   };

   struct {
      uint16         magic;
      uint16         sequence_number;
      uint8          type;            /* packet type */
   } hdr;
   union {
      struct {
         uint32      random_request;  /* please reply back with this random data */
         uint16      remote_magic;
         uint8       remote_endpoint;
      } sync_request;
      
      struct {
         uint32      random_reply;    /* OK, here's your random data back */
      } sync_reply;
      
      struct {
         int8        frame_advantage; /* what's the other guy's frame advantage? */
         uint32      ping;
      } quality_report;
      
      struct {
         uint32      pong;
      } quality_reply;

      struct {
         connect_status    peer_connect_status[UDP_MSG_MAX_PLAYERS];

         uint32            start_frame;

         int               disconnect_requested:1;
         int               ack_frame:31;

         uint16            num_bits;
         uint8             input_size; // XXX: shouldn't be in every single packet!
         uint8             bits[MAX_COMPRESSED_BITS]; /* must be last */
      } input;

      struct {
         int               ack_frame:31;
      } input_ack;

   } u;

public:
   int PacketSize() {
      return sizeof(hdr) + PayloadSize();
   }

   int PayloadSize() {
      int size;

      switch (hdr.type) {
      case SyncRequest:   return sizeof(u.sync_request);
      case SyncReply:     return sizeof(u.sync_reply);
      case QualityReport: return sizeof(u.quality_report);
      case QualityReply:  return sizeof(u.quality_reply);
      case InputAck:      return sizeof(u.input_ack);
      case KeepAlive:     return 0;
      case Input:
         size = (int)((char *)&u.input.bits - (char *)&u.input);
         size += (u.input.num_bits + 7) / 8;
         return size;
      }
      ASSERT(false);
      return 0;
   }

   UdpMsg(MsgType t) { hdr.type = (uint8)t; }
};

#pragma pack(pop)

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_proto.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "udp_proto.h"
#include "types.h"
#include "bitvector.h"

static const int UDP_HEADER_SIZE = 28;     /* Size of IP + UDP headers */
static const int NUM_SYNC_PACKETS = 5;
static const int SYNC_RETRY_INTERVAL = 2000;
static const int SYNC_FIRST_RETRY_INTERVAL = 500;
static const int RUNNING_RETRY_INTERVAL = 200;
static const int KEEP_ALIVE_INTERVAL    = 200;
static const int QUALITY_REPORT_INTERVAL = 1000;
static const int NETWORK_STATS_INTERVAL  = 1000;
static const int UDP_SHUTDOWN_TIMER = 5000;
static const int MAX_SEQ_DISTANCE = (1 << 15);

UdpProtocol::UdpProtocol() :
   _udp(NULL),
   _magic_number(0),
   _queue(-1),
   _remote_magic_number(0),
   _connected(false),
   _packets_sent(0),
   _bytes_sent(0),
   _stats_start_time(0),
   _local_frame_advantage(0),
   _remote_frame_advantage(0),
   _last_send_time(0),
   _shutdown_timeout(0),
   _disconnect_event_sent(false),
   _disconnect_timeout(0),
   _disconnect_notify_start(0),
   _disconnect_notify_sent(false),
   _next_send_seq(0),
   _next_recv_seq(0)
{
   _last_sent_input.init(-1, NULL, 1);
   _last_received_input.init(-1, NULL, 1);
   _last_acked_input.init(-1, NULL, 1);

   memset(&_state, 0, sizeof _state);
   memset(_peer_connect_status, 0, sizeof(_peer_connect_status));
   for (int i = 0; i < ARRAY_SIZE(_peer_connect_status); i++) {
      _peer_connect_status[i].last_frame = -1;
   }
   _oo_packet.msg = NULL;

   _send_latency = 2;
   _oop_percent = 0;
}

UdpProtocol::~UdpProtocol()
{
   ClearSendQueue();
}

void
UdpProtocol::Init(Udp *udp,
                  Poll &poll,
                  int queue,
                  int connection_id,
                  UdpMsg::connect_status *status)
{  
   _udp = udp;
   _queue = queue;
   _local_connect_status = status;
   
   _connection_id = connection_id;

   do {
      _magic_number = (uint16)rand();
   } while (_magic_number == 0);
   poll.RegisterLoop(this);
}

void
UdpProtocol::SendInput(GameInput &input)
{
   if (_udp) {
      if (_current_state == Running) {
         /*
          * Check to see if this is a good time to adjust for the rift...
          */
         _timesync.advance_frame(input, _local_frame_advantage, _remote_frame_advantage);

         /*
          * Save this input packet
          *
          * XXX: This queue may fill up for spectators who do not ack input packets in a timely
          * manner.  When this happens, we can either resize the queue (ug) or disconnect them
          * (better, but still ug).  For the meantime, make this queue really big to decrease
          * the odds of this happening...
          */
         _pending_output.push(input);
      }
      SendPendingOutput();
   }  
}

void
UdpProtocol::SendPendingOutput()
{
   UdpMsg *msg = new UdpMsg(UdpMsg::Input);
   int i, j, offset = 0;
   uint8 *bits;
   GameInput last;

   if (_pending_output.size()) {
      last = _last_acked_input;
      bits = msg->u.input.bits;

      msg->u.input.start_frame = _pending_output.front().frame;
      msg->u.input.input_size = (uint8)_pending_output.front().size;

      ASSERT(last.frame == -1 || last.frame + 1 == msg->u.input.start_frame);
      for (j = 0; j < _pending_output.size(); j++) {
         GameInput &current = _pending_output.item(j);
         if (memcmp(current.bits, last.bits, current.size) != 0) {
            ASSERT((GAMEINPUT_MAX_BYTES * GAMEINPUT_MAX_PLAYERS * 8) < (1 << BITVECTOR_NIBBLE_SIZE));
            for (i = 0; i < current.size * 8; i++) {
               ASSERT(i < (1 << BITVECTOR_NIBBLE_SIZE));
               if (current.value(i) != last.value(i)) {
                  BitVector_SetBit(msg->u.input.bits, &offset);
                  (current.value(i) ? BitVector_SetBit : BitVector_ClearBit)(bits, &offset);
                  BitVector_WriteNibblet(bits, i, &offset);
               }
            }
         }
         BitVector_ClearBit(msg->u.input.bits, &offset);
         last = _last_sent_input = current;
      }
   } else {
      msg->u.input.start_frame = 0;
      msg->u.input.input_size = 0;
   }
   msg->u.input.ack_frame = _last_received_input.frame;
   msg->u.input.num_bits = (uint16)offset;

   msg->u.input.disconnect_requested = _current_state == Disconnected;
   if (_local_connect_status) {
      memcpy(msg->u.input.peer_connect_status, _local_connect_status, sizeof(UdpMsg::connect_status) * UDP_MSG_MAX_PLAYERS);
   } else {
      memset(msg->u.input.peer_connect_status, 0, sizeof(UdpMsg::connect_status) * UDP_MSG_MAX_PLAYERS);
   }

   ASSERT(offset < MAX_COMPRESSED_BITS);

   SendMsg(msg);
}

void
UdpProtocol::SendInputAck()
{
   UdpMsg *msg = new UdpMsg(UdpMsg::InputAck);
   msg->u.input_ack.ack_frame = _last_received_input.frame;
   SendMsg(msg);
}

bool
UdpProtocol::GetEvent(UdpProtocol::Event &e)
{
   if (_event_queue.size() == 0) {
      return false;
   }
   e = _event_queue.front();
   _event_queue.pop();
   return true;
}


bool
UdpProtocol::OnLoopPoll(void *cookie)
{
   if (!_udp) {
      return true;
   }

   unsigned int now = Platform::GetCurrentTimeMS();
   unsigned int next_interval;

   PumpSendQueue();
   switch (_current_state) {
   case Syncing:
      next_interval = (_state.sync.roundtrips_remaining == NUM_SYNC_PACKETS) ? SYNC_FIRST_RETRY_INTERVAL : SYNC_RETRY_INTERVAL;
      if (_last_send_time && _last_send_time + next_interval < now) {
         Log("No luck syncing after %d ms... Re-queueing sync packet.\n", next_interval);
         SendSyncRequest();
      }
      break;

   case Running:
      // xxx: rig all this up with a timer wrapper
      if (!_state.running.last_input_packet_recv_time || _state.running.last_input_packet_recv_time + RUNNING_RETRY_INTERVAL < now) {
         Log("Haven't exchanged packets in a while (last received:%d  last sent:%d).  Resending.\n", _last_received_input.frame, _last_sent_input.frame);
         SendPendingOutput();
         _state.running.last_input_packet_recv_time = now;
      }

      if (!_state.running.last_quality_report_time || _state.running.last_quality_report_time + QUALITY_REPORT_INTERVAL < now) {
         UdpMsg *msg = new UdpMsg(UdpMsg::QualityReport);
         msg->u.quality_report.ping = Platform::GetCurrentTimeMS();
         msg->u.quality_report.frame_advantage = (uint8)_local_frame_advantage;
         SendMsg(msg);
         _state.running.last_quality_report_time = now;
      }

      if (!_state.running.last_network_stats_interval || _state.running.last_network_stats_interval + NETWORK_STATS_INTERVAL < now) {
         UpdateNetworkStats();
         _state.running.last_network_stats_interval =  now;
      }

      if (_last_send_time && _last_send_time + KEEP_ALIVE_INTERVAL < now) {
         Log("Sending keep alive packet\n");
         SendMsg(new UdpMsg(UdpMsg::KeepAlive));
      }

      if (_disconnect_timeout && _disconnect_notify_start && 
         !_disconnect_notify_sent && (_last_recv_time + _disconnect_notify_start < now)) {
         Log("Endpoint has stopped receiving packets for %d ms.  Sending notification.\n", _disconnect_notify_start);
         Event e(Event::NetworkInterrupted);
         e.u.network_interrupted.disconnect_timeout = _disconnect_timeout - _disconnect_notify_start;
         QueueEvent(e);
         _disconnect_notify_sent = true;
      }

      if (_disconnect_timeout && (_last_recv_time + _disconnect_timeout < now)) {
         if (!_disconnect_event_sent) {
            Log("Endpoint has stopped receiving packets for %d ms.  Disconnecting.\n", _disconnect_timeout);
            QueueEvent(Event(Event::Disconnected));
            _disconnect_event_sent = true;
         }
      }
      break;

   case Disconnected:
      if (_shutdown_timeout < now) {
         Log("Shutting down udp connection.\n");
         _udp = NULL;
         _shutdown_timeout = 0;
      }

   }


   return true;
}

void
UdpProtocol::Disconnect()
{
   _current_state = Disconnected;
   _shutdown_timeout = Platform::GetCurrentTimeMS() + UDP_SHUTDOWN_TIMER;
}

void
UdpProtocol::SendSyncRequest()
{
   _state.sync.random = rand() & 0xFFFF;
   UdpMsg *msg = new UdpMsg(UdpMsg::SyncRequest);
   msg->u.sync_request.random_request = _state.sync.random;
   SendMsg(msg);
}

void
UdpProtocol::SendMsg(UdpMsg *msg)
{
   LogMsg("send", msg);

   _packets_sent++;
   _last_send_time = Platform::GetCurrentTimeMS();
   _bytes_sent += msg->PacketSize();

   msg->hdr.magic = _magic_number;
   msg->hdr.sequence_number = _next_send_seq++;

   _send_queue.push(QueueEntry(Platform::GetCurrentTimeMS(), _connection_id, msg));
   PumpSendQueue();
}

bool
UdpProtocol::HandlesMsg(int connection_id,
                        UdpMsg *msg)
{
   if (!_udp) {
      return false;
   }
   return _connection_id == connection_id;
}

void
UdpProtocol::OnMsg(UdpMsg *msg, int len)
{
   bool handled = false;
   typedef bool (UdpProtocol::*DispatchFn)(UdpMsg *msg, int len);
   static const DispatchFn table[] = {
      &UdpProtocol::OnInvalid,             /* Invalid */
      &UdpProtocol::OnSyncRequest,         /* SyncRequest */
      &UdpProtocol::OnSyncReply,           /* SyncReply */
      &UdpProtocol::OnInput,               /* Input */
      &UdpProtocol::OnQualityReport,       /* QualityReport */
      &UdpProtocol::OnQualityReply,        /* QualityReply */
      &UdpProtocol::OnKeepAlive,           /* KeepAlive */
      &UdpProtocol::OnInputAck,            /* InputAck */
   };

   // filter out messages that don't match what we expect
   uint16 seq = msg->hdr.sequence_number;
   if (msg->hdr.type != UdpMsg::SyncRequest &&
       msg->hdr.type != UdpMsg::SyncReply) {
      if (msg->hdr.magic != _remote_magic_number) {
         LogMsg("recv rejecting", msg);
         return;
      }

      // filter out out-of-order packets
      uint16 skipped = (uint16)((int)seq - (int)_next_recv_seq);
      // Log("checking sequence number -> next - seq : %d - %d = %d\n", seq, _next_recv_seq, skipped);
      if (skipped > MAX_SEQ_DISTANCE) {
         Log("dropping out of order packet (seq: %d, last seq:%d)\n", seq, _next_recv_seq);
         return;
      }
   }

   _next_recv_seq = seq;
   LogMsg("recv", msg);
   if (msg->hdr.type >= ARRAY_SIZE(table)) {
      OnInvalid(msg, len);
   } else {
      handled = (this->*(table[msg->hdr.type]))(msg, len);
   }
   if (handled) {
      _last_recv_time = Platform::GetCurrentTimeMS();
      if (_disconnect_notify_sent && _current_state == Running) {
         QueueEvent(Event(Event::NetworkResumed));   
         _disconnect_notify_sent = false;
      }
   }
}

void
UdpProtocol::UpdateNetworkStats(void)
{
   int now = Platform::GetCurrentTimeMS();

   if (_stats_start_time == 0) {
      _stats_start_time = now;
   }

   int total_bytes_sent = _bytes_sent + (UDP_HEADER_SIZE * _packets_sent);
   float seconds = (float)((now - _stats_start_time) / 1000.0);
   float Bps = total_bytes_sent / seconds;
   float udp_overhead = (float)(100.0 * (UDP_HEADER_SIZE * _packets_sent) / _bytes_sent);

   _kbps_sent = int(Bps / 1024);

   Log("Network Stats -- Bandwidth: %.2f KBps   Packets Sent: %5d (%.2f pps)   "
       "KB Sent: %.2f    UDP Overhead: %.2f %%.\n",
       _kbps_sent, 
       _packets_sent,
       (float)_packets_sent * 1000 / (now - _stats_start_time),
       total_bytes_sent / 1024.0,
       udp_overhead);
}


void
UdpProtocol::QueueEvent(const UdpProtocol::Event &evt)
{
   LogEvent("Queuing event", evt);
   _event_queue.push(evt);
}

void
UdpProtocol::Synchronize()
{
   if (_udp) {
      _current_state = Syncing;
      _state.sync.roundtrips_remaining = NUM_SYNC_PACKETS;
      SendSyncRequest();
   }
}

bool
UdpProtocol::GetPeerConnectStatus(int id, int *frame)
{
   *frame = _peer_connect_status[id].last_frame;
   return !_peer_connect_status[id].disconnected;
}

void
UdpProtocol::Log(const char *fmt, ...)
{
   char buf[1024];
   size_t offset;
   va_list args;

   sprintf(buf, "udpproto%d | ", _queue);
   offset = strlen(buf);
   va_start(args, fmt);
   vsnprintf(buf + offset, ARRAY_SIZE(buf) - offset - 1, fmt, args);
   buf[ARRAY_SIZE(buf)-1] = '\0';
   ::Log(buf);
   va_end(args);
}

void
UdpProtocol::LogMsg(const char *prefix, UdpMsg *msg)
{
   switch (msg->hdr.type) {
   case UdpMsg::SyncRequest:
      Log("%s sync-request (%d).\n", prefix,
          msg->u.sync_request.random_request);
      break;
   case UdpMsg::SyncReply:
      Log("%s sync-reply (%d).\n", prefix,
          msg->u.sync_reply.random_reply);
      break;
   case UdpMsg::QualityReport:
      Log("%s quality report.\n", prefix);
      break;
   case UdpMsg::QualityReply:
      Log("%s quality reply.\n", prefix);
      break;
   case UdpMsg::KeepAlive:
      Log("%s keep alive.\n", prefix);
      break;
   case UdpMsg::Input:
      Log("%s game-compressed-input %d (+ %d bits).\n", prefix, msg->u.input.start_frame, msg->u.input.num_bits);
      break;
   case UdpMsg::InputAck:
      Log("%s input ack.\n", prefix);
      break;
   default:
      ASSERT(false && "Unknown UdpMsg type.");
   }
}

void
UdpProtocol::LogEvent(const char *prefix, const UdpProtocol::Event &evt)
{
   switch (evt.type) {
   case UdpProtocol::Event::Synchronzied:
      Log("%s (event: Synchronzied).\n", prefix);
      break;
   }
}

bool
UdpProtocol::OnInvalid(UdpMsg *msg, int len)
{
   ASSERT(false && "Invalid msg in UdpProtocol");
   return false;
}

bool
UdpProtocol::OnSyncRequest(UdpMsg *msg, int len)
{
   if (_remote_magic_number != 0 && msg->hdr.magic != _remote_magic_number) {
      Log("Ignoring sync request from unknown endpoint (%d != %d).\n", 
           msg->hdr.magic, _remote_magic_number);
      return false;
   }
   UdpMsg *reply = new UdpMsg(UdpMsg::SyncReply);
   reply->u.sync_reply.random_reply = msg->u.sync_request.random_request;
   SendMsg(reply);
   return true;
}

bool
UdpProtocol::OnSyncReply(UdpMsg *msg, int len)
{
   if (_current_state != Syncing) {
      Log("Ignoring SyncReply while not synching.\n");
      return msg->hdr.magic == _remote_magic_number;
   }

   if (msg->u.sync_reply.random_reply != _state.sync.random) {
      Log("sync reply %d != %d.  Keep looking...\n",
          msg->u.sync_reply.random_reply, _state.sync.random);
      return false;
   }

   if (!_connected) {
      QueueEvent(Event(Event::Connected));
      _connected = true;
   }

   Log("Checking sync state (%d round trips remaining).\n", _state.sync.roundtrips_remaining);
   if (--_state.sync.roundtrips_remaining == 0) {
      Log("Synchronized!\n");
      QueueEvent(UdpProtocol::Event(UdpProtocol::Event::Synchronzied));
      _current_state = Running;
      _last_received_input.frame = -1;
      _remote_magic_number = msg->hdr.magic;
   } else {
      UdpProtocol::Event evt(UdpProtocol::Event::Synchronizing);
      evt.u.synchronizing.total = NUM_SYNC_PACKETS;
      evt.u.synchronizing.count = NUM_SYNC_PACKETS - _state.sync.roundtrips_remaining;
      QueueEvent(evt);
      SendSyncRequest();
   }
   return true;
}

bool
UdpProtocol::OnInput(UdpMsg *msg, int len)
{
   /*
    * If a disconnect is requested, go ahead and disconnect now.
    */
   bool disconnect_requested = msg->u.input.disconnect_requested;
   if (disconnect_requested) {
      if (_current_state != Disconnected && !_disconnect_event_sent) {
         Log("Disconnecting endpoint on remote request.\n");
         QueueEvent(Event(Event::Disconnected));
         _disconnect_event_sent = true;
      }
   } else {
      /*
       * Update the peer connection status if this peer is still considered to be part
       * of the network.
       */
      UdpMsg::connect_status* remote_status = msg->u.input.peer_connect_status;
      for (int i = 0; i < ARRAY_SIZE(_peer_connect_status); i++) {
         ASSERT(remote_status[i].last_frame >= _peer_connect_status[i].last_frame);
         _peer_connect_status[i].disconnected = _peer_connect_status[i].disconnected || remote_status[i].disconnected;
         _peer_connect_status[i].last_frame = MAX(_peer_connect_status[i].last_frame, remote_status[i].last_frame);
      }
   }

   /*
    * Decompress the input.
    */
   int last_received_frame_number = _last_received_input.frame;
   if (msg->u.input.num_bits) {
      int offset = 0;
      uint8 *bits = (uint8 *)msg->u.input.bits;
      int numBits = msg->u.input.num_bits;
      int currentFrame = msg->u.input.start_frame;

      _last_received_input.size = msg->u.input.input_size;
      if (_last_received_input.frame < 0) {
         _last_received_input.frame = msg->u.input.start_frame - 1;
      }
      while (offset < numBits) {
         /*
          * Keep walking through the frames (parsing bits) until we reach
          * the inputs for the frame right after the one we're on.
          */
         ASSERT(currentFrame <= (_last_received_input.frame + 1));
         bool useInputs = currentFrame == _last_received_input.frame + 1;

         while (BitVector_ReadBit(bits, &offset)) {
            int on = BitVector_ReadBit(bits, &offset);
            int button = BitVector_ReadNibblet(bits, &offset);
            if (useInputs) {
               if (on) {
                  _last_received_input.set(button);
               } else {
                  _last_received_input.clear(button);
               }
            }
         }
         ASSERT(offset <= numBits);

         /*
          * Now if we want to use these inputs, go ahead and send them to
          * the emulator.
          */
         if (useInputs) {
            /*
             * Move forward 1 frame in the stream.
             */
            char desc[1024];
            ASSERT(currentFrame == _last_received_input.frame + 1);
            _last_received_input.frame = currentFrame;

            /*
             * Send the event to the emualtor
             */
            UdpProtocol::Event evt(UdpProtocol::Event::Input);
            evt.u.input.input = _last_received_input;

            _last_received_input.desc(desc, ARRAY_SIZE(desc));

            _state.running.last_input_packet_recv_time = Platform::GetCurrentTimeMS();

            Log("Sending frame %d to emu queue %d (%s).\n", _last_received_input.frame, _queue, desc);
            QueueEvent(evt);

         } else {
            Log("Skipping past frame:(%d) current is %d.\n", currentFrame, _last_received_input.frame);
         }

         /*
          * Move forward 1 frame in the input stream.
          */
         currentFrame++;
      }
   }
   ASSERT(_last_received_input.frame >= last_received_frame_number);

   /*
    * Get rid of our buffered input
    */
   while (_pending_output.size() && _pending_output.front().frame < msg->u.input.ack_frame) {
      Log("Throwing away pending output frame %d\n", _pending_output.front().frame);
      _last_acked_input = _pending_output.front();
      _pending_output.pop();
   }
   return true;
}


bool
UdpProtocol::OnInputAck(UdpMsg *msg, int len)
{
   /*
    * Get rid of our buffered input
    */
   while (_pending_output.size() && _pending_output.front().frame < msg->u.input_ack.ack_frame) {
      Log("Throwing away pending output frame %d\n", _pending_output.front().frame);
      _last_acked_input = _pending_output.front();
      _pending_output.pop();
   }
   return true;
}

bool
UdpProtocol::OnQualityReport(UdpMsg *msg, int len)
{
   // send a reply so the other side can compute the round trip transmit time.
   UdpMsg *reply = new UdpMsg(UdpMsg::QualityReply);
   reply->u.quality_reply.pong = msg->u.quality_report.ping;
   SendMsg(reply);

   _remote_frame_advantage = msg->u.quality_report.frame_advantage;
   return true;
}

bool
UdpProtocol::OnQualityReply(UdpMsg *msg, int len)
{
   _round_trip_time = Platform::GetCurrentTimeMS() - msg->u.quality_reply.pong;
   return true;
}

bool
UdpProtocol::OnKeepAlive(UdpMsg *msg, int len)
{
   return true;
}

void
UdpProtocol::GetNetworkStats(struct FGGPONetworkStats *s)
{
   s->network.ping = _round_trip_time;
   s->network.send_queue_len = _pending_output.size();
   s->network.kbps_sent = _kbps_sent;
   s->timesync.remote_frames_behind = _remote_frame_advantage;
   s->timesync.local_frames_behind = _local_frame_advantage;
}

void
UdpProtocol::SetLocalFrameNumber(int localFrame)
{
   /*
    * Estimate which frame the other guy is one by looking at the
    * last frame they gave us plus some delta for the one-way packet
    * trip time.
    */
   int remoteFrame = _last_received_input.frame + (_round_trip_time * 60 / 1000);

   /*
    * Our frame advantage is how many frames *behind* the other guy
    * we are.  Counter-intuative, I know.  It's an advantage because
    * it means they'll have to predict more often and our moves will
    * pop more frequenetly.
    */
   _local_frame_advantage = remoteFrame - localFrame;
}

int
UdpProtocol::RecommendFrameDelay()
{
   // XXX: require idle input should be a configuration parameter
   return _timesync.recommend_frame_wait_duration(false);
}


void
UdpProtocol::SetDisconnectTimeout(int timeout)
{
   _disconnect_timeout = timeout;
}

void
UdpProtocol::SetDisconnectNotifyStart(int timeout)
{
   _disconnect_notify_start = timeout;
}

void
UdpProtocol::PumpSendQueue()
{
   while (!_send_queue.empty()) {
      QueueEntry &entry = _send_queue.front();

      if (_send_latency) {
         // should really come up with a gaussian distributation based on the configured
         // value, but this will do for now.
         int jitter = (_send_latency * 2 / 3) + ((rand() % _send_latency) / 3);
         if (Platform::GetCurrentTimeMS() < _send_queue.front().queue_time + jitter) {
            break;
         }
      }
      if (_oop_percent && !_oo_packet.msg && ((rand() % 100) < _oop_percent)) {
         int delay = rand() % (_send_latency * 10 + 1000);
         Log("creating rogue oop (seq: %d  delay: %d)\n", entry.msg->hdr.sequence_number, delay);
         _oo_packet.send_time = Platform::GetCurrentTimeMS() + delay;
         _oo_packet.msg = entry.msg;
         _oo_packet.connection_id = entry.connection_id;
      } else {
         _udp->SendTo((char *)entry.msg, entry.msg->PacketSize(), 0, entry.connection_id);

         delete entry.msg;
      }
      _send_queue.pop();
   }
   if (_oo_packet.msg && _oo_packet.send_time < Platform::GetCurrentTimeMS()) {
      Log("sending rogue oop!");
      _udp->SendTo((char *)_oo_packet.msg, _oo_packet.msg->PacketSize(), 0, _oo_packet.connection_id);

      delete _oo_packet.msg;
      _oo_packet.msg = NULL;
   }
}

void
UdpProtocol::ClearSendQueue()
{
   while (!_send_queue.empty()) {
      delete _send_queue.front().msg;
      _send_queue.pop();
   }
}

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_proto.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _UDP_PROTO_H_
#define _UDP_PROTO_H_

#include "poll.h"
#include "udp.h"
#include "udp_msg.h"
#include "game_input.h"
#include "timesync.h"
#include "include/ggponet.h"
#include "ring_buffer.h"

class UdpProtocol : public IPollSink
{
public:
   struct Stats {
      int                 ping;
      int                 remote_frame_advantage;
      int                 local_frame_advantage;
      int                 send_queue_len;
      Udp::Stats          udp;
   };

   struct Event {
      enum Type {
         Unknown = -1,
         Connected,
         Synchronizing,
         Synchronzied,
         Input,
         Disconnected,
         NetworkInterrupted,
         NetworkResumed,
      };

      Type      type;
      union {
         struct {
            GameInput   input;
         } input;
         struct {
            int         total;
            int         count;
         } synchronizing;
         struct {
            int         disconnect_timeout;
         } network_interrupted;
      } u;

      Event(Type t = Unknown) : type(t) { }
   };

public:
   virtual bool OnLoopPoll(void *cookie);

public:
   UdpProtocol();
   virtual ~UdpProtocol();

   void Init(Udp *udp, Poll &p, int queue, int connection_id, UdpMsg::connect_status *status);

   void Synchronize();
   bool GetPeerConnectStatus(int id, int *frame);
   bool IsInitialized() { return _udp != NULL; }
   bool IsSynchronized() { return _current_state == Running; }
   bool IsRunning() { return _current_state == Running; }
   void SendInput(GameInput &input);
   void SendInputAck();
   bool HandlesMsg(int connection_id, UdpMsg *msg);
   void OnMsg(UdpMsg *msg, int len);
   void Disconnect();
  
   void GetNetworkStats(struct FGGPONetworkStats *stats);
   bool GetEvent(UdpProtocol::Event &e);
   void GGPONetworkStats(Stats *stats);
   void SetLocalFrameNumber(int num);
   int RecommendFrameDelay();

   void SetDisconnectTimeout(int timeout);
   void SetDisconnectNotifyStart(int timeout);

protected:
   enum State {
      Syncing,
      Synchronzied,
      Running,
      Disconnected
   };
   struct QueueEntry {
      int         queue_time;
      int         connection_id;
      UdpMsg      *msg;

      QueueEntry() {}
      QueueEntry(int time, int conn_id, UdpMsg *m) : queue_time(time), connection_id(conn_id), msg(m) { }
   };

   bool CreateSocket(int retries);
   void UpdateNetworkStats(void);
   void QueueEvent(const UdpProtocol::Event &evt);
   void ClearSendQueue(void);
   void Log(const char *fmt, ...);
   void LogMsg(const char *prefix, UdpMsg *msg);
   void LogEvent(const char *prefix, const UdpProtocol::Event &evt);
   void SendSyncRequest();
   void SendMsg(UdpMsg *msg);
   void PumpSendQueue();
   void DispatchMsg(uint8 *buffer, int len);
   void SendPendingOutput();
   bool OnInvalid(UdpMsg *msg, int len);
   bool OnSyncRequest(UdpMsg *msg, int len);
   bool OnSyncReply(UdpMsg *msg, int len);
   bool OnInput(UdpMsg *msg, int len);
   bool OnInputAck(UdpMsg *msg, int len);
   bool OnQualityReport(UdpMsg *msg, int len);
   bool OnQualityReply(UdpMsg *msg, int len);
   bool OnKeepAlive(UdpMsg *msg, int len);

protected:
   /*
    * Network transmission information
    */
   ConnectionManager* connection_manager;
   Udp            *_udp;
   int             _connection_id; 
   uint16         _magic_number;
   int            _queue;
   uint16         _remote_magic_number;
   bool           _connected;
   int            _send_latency;
   int            _oop_percent;
   struct {
      int         send_time;
      int         connection_id;
      UdpMsg*     msg;
   }              _oo_packet;
   RingBuffer<QueueEntry, 64> _send_queue;

   /*
    * Stats
    */
   int            _round_trip_time;
   int            _packets_sent;
   int            _bytes_sent;
   int            _kbps_sent;
   int            _stats_start_time;

   /*
    * The state machine
    */
   UdpMsg::connect_status *_local_connect_status;
   UdpMsg::connect_status _peer_connect_status[UDP_MSG_MAX_PLAYERS];

   State          _current_state;
   union {
      struct {
         uint32   roundtrips_remaining;
         uint32   random;
      } sync;
      struct {
         uint32   last_quality_report_time;
         uint32   last_network_stats_interval;
         uint32   last_input_packet_recv_time;
      } running;
   } _state;

   /*
    * Fairness.
    */
   int               _local_frame_advantage;
   int               _remote_frame_advantage;

   /*
    * Packet loss...
    */
   RingBuffer<GameInput, 64>  _pending_output;
   GameInput                  _last_received_input;
   GameInput                  _last_sent_input;
   GameInput                  _last_acked_input;
   unsigned int               _last_send_time;
   unsigned int               _last_recv_time;
   unsigned int               _shutdown_timeout;
   unsigned int               _disconnect_event_sent;
   unsigned int               _disconnect_timeout;
   unsigned int               _disconnect_notify_start;
   bool                       _disconnect_notify_sent;

   uint16                     _next_send_seq;
   uint16                     _next_recv_seq;

   /*
    * Rift synchronization.
    */
   TimeSync                   _timesync;

   /*
    * Event queue
    */
   RingBuffer<UdpProtocol::Event, 64>  _event_queue;
};

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/pevents.cpp`:

```cpp
/*
 * WIN32 Events for POSIX
 * Author: Mahmoud Al-Qudsi <mqudsi@neosmart.net>
 * Copyright (C) 2011 - 2019 by NeoSmart Technologies
 * This code is released under the terms of the MIT License
 */

#ifndef _WIN32

#include "pevents.h"
#include <assert.h>
#include <errno.h>
#include <pthread.h>
#include <sys/time.h>
#ifdef WFMO
#include <algorithm>
#include <deque>
#endif

namespace neosmart {
#ifdef WFMO
    // Each call to WaitForMultipleObjects initializes a neosmart_wfmo_t object which tracks
    // the progress of the caller's multi-object wait and dispatches responses accordingly.
    // One neosmart_wfmo_t struct is shared for all events in a single WFMO call
    struct neosmart_wfmo_t_ {
        pthread_mutex_t Mutex;
        pthread_cond_t CVariable;
        int RefCount;
        union {
            int FiredEvent; // WFSO
            int EventsLeft; // WFMO
        } Status;
        bool WaitAll;
        bool StillWaiting;

        void Destroy() {
            pthread_mutex_destroy(&Mutex);
            pthread_cond_destroy(&CVariable);
        }
    };
    typedef neosmart_wfmo_t_ *neosmart_wfmo_t;

    // A neosmart_wfmo_info_t object is registered with each event waited on in a WFMO
    // This reference to neosmart_wfmo_t_ is how the event knows whom to notify when triggered
    struct neosmart_wfmo_info_t_ {
        neosmart_wfmo_t Waiter;
        int WaitIndex;
    };
    typedef neosmart_wfmo_info_t_ *neosmart_wfmo_info_t;
#endif // WFMO

    // The basic event structure, passed to the caller as an opaque pointer when creating events
    struct neosmart_event_t_ {
        pthread_cond_t CVariable;
        pthread_mutex_t Mutex;
        bool AutoReset;
        bool State;
#ifdef WFMO
        std::deque<neosmart_wfmo_info_t_> RegisteredWaits;
#endif
    };

#ifdef WFMO
    bool RemoveExpiredWaitHelper(neosmart_wfmo_info_t_ wait) {
        int result = pthread_mutex_trylock(&wait.Waiter->Mutex);

        if (result == EBUSY) {
            return false;
        }

        assert(result == 0);

        if (wait.Waiter->StillWaiting == false) {
            --wait.Waiter->RefCount;
            assert(wait.Waiter->RefCount >= 0);
            bool destroy = wait.Waiter->RefCount == 0;
            result = pthread_mutex_unlock(&wait.Waiter->Mutex);
            assert(result == 0);
            if (destroy) {
                wait.Waiter->Destroy();
                delete wait.Waiter;
            }

            return true;
        }

        result = pthread_mutex_unlock(&wait.Waiter->Mutex);
        assert(result == 0);

        return false;
    }
#endif // WFMO

    neosmart_event_t CreateEvent(bool manualReset, bool initialState) {
        neosmart_event_t event = new neosmart_event_t_;

        int result = pthread_cond_init(&event->CVariable, 0);
        assert(result == 0);

        result = pthread_mutex_init(&event->Mutex, 0);
        assert(result == 0);

        event->State = false;
        event->AutoReset = !manualReset;

        if (initialState) {
            result = SetEvent(event);
            assert(result == 0);
        }

        return event;
    }

    int UnlockedWaitForEvent(neosmart_event_t event, uint64_t milliseconds) {
        int result = 0;
        if (!event->State) {
            // Zero-timeout event state check optimization
            if (milliseconds == 0) {
                return WAIT_TIMEOUT;
            }

            timespec ts;
            if (milliseconds != (uint64_t)-1) {
                timeval tv;
                gettimeofday(&tv, NULL);

                uint64_t nanoseconds = ((uint64_t)tv.tv_sec) * 1000 * 1000 * 1000 +
                                       milliseconds * 1000 * 1000 + ((uint64_t)tv.tv_usec) * 1000;

                ts.tv_sec = nanoseconds / 1000 / 1000 / 1000;
                ts.tv_nsec = (nanoseconds - ((uint64_t)ts.tv_sec) * 1000 * 1000 * 1000);
            }

            do {
                // Regardless of whether it's an auto-reset or manual-reset event:
                // wait to obtain the event, then lock anyone else out
                if (milliseconds != (uint64_t)-1) {
                    result = pthread_cond_timedwait(&event->CVariable, &event->Mutex, &ts);
                } else {
                    result = pthread_cond_wait(&event->CVariable, &event->Mutex);
                }
            } while (result == 0 && !event->State);

            if (result == 0 && event->AutoReset) {
                // We've only accquired the event if the wait succeeded
                event->State = false;
            }
        } else if (event->AutoReset) {
            // It's an auto-reset event that's currently available;
            // we need to stop anyone else from using it
            result = 0;
            event->State = false;
        }
        // Else we're trying to obtain a manual reset event with a signaled state;
        // don't do anything

        return result;
    }

    int WaitForEvent(neosmart_event_t event, uint64_t milliseconds) {
        int tempResult;
        if (milliseconds == 0) {
            tempResult = pthread_mutex_trylock(&event->Mutex);
            if (tempResult == EBUSY) {
                return WAIT_TIMEOUT;
            }
        } else {
            tempResult = pthread_mutex_lock(&event->Mutex);
        }

        assert(tempResult == 0);

        int result = UnlockedWaitForEvent(event, milliseconds);

        tempResult = pthread_mutex_unlock(&event->Mutex);
        assert(tempResult == 0);

        return result;
    }

#ifdef WFMO
    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,
                              uint64_t milliseconds) {
        int unused;
        return WaitForMultipleEvents(events, count, waitAll, milliseconds, unused);
    }

    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,
                              uint64_t milliseconds, int &waitIndex) {
        neosmart_wfmo_t wfmo = new neosmart_wfmo_t_;

        int result = 0;
        int tempResult = pthread_mutex_init(&wfmo->Mutex, 0);
        assert(tempResult == 0);

        tempResult = pthread_cond_init(&wfmo->CVariable, 0);
        assert(tempResult == 0);

        neosmart_wfmo_info_t_ waitInfo;
        waitInfo.Waiter = wfmo;
        waitInfo.WaitIndex = -1;

        wfmo->WaitAll = waitAll;
        wfmo->StillWaiting = true;
        wfmo->RefCount = 1;

        if (waitAll) {
            wfmo->Status.EventsLeft = count;
        } else {
            wfmo->Status.FiredEvent = -1;
        }

        tempResult = pthread_mutex_lock(&wfmo->Mutex);
        assert(tempResult == 0);

        bool done = false;
        waitIndex = -1;

        for (int i = 0; i < count; ++i) {
            waitInfo.WaitIndex = i;

            // Must not release lock until RegisteredWait is potentially added
            tempResult = pthread_mutex_lock(&events[i]->Mutex);
            assert(tempResult == 0);

            // Before adding this wait to the list of registered waits, let's clean up old, expired
            // waits while we have the event lock anyway
            events[i]->RegisteredWaits.erase(std::remove_if(events[i]->RegisteredWaits.begin(),
                                                            events[i]->RegisteredWaits.end(),
                                                            RemoveExpiredWaitHelper),
                                             events[i]->RegisteredWaits.end());

            if (UnlockedWaitForEvent(events[i], 0) == 0) {
                tempResult = pthread_mutex_unlock(&events[i]->Mutex);
                assert(tempResult == 0);

                if (waitAll) {
                    --wfmo->Status.EventsLeft;
                    assert(wfmo->Status.EventsLeft >= 0);
                } else {
                    wfmo->Status.FiredEvent = i;
                    waitIndex = i;
                    done = true;
                    break;
                }
            } else {
                events[i]->RegisteredWaits.push_back(waitInfo);
                ++wfmo->RefCount;

                tempResult = pthread_mutex_unlock(&events[i]->Mutex);
                assert(tempResult == 0);
            }
        }

        // We set the `done` flag above in case of WaitAny and at least one event was set.
        // But we need to check again here if we were doing a WaitAll or else we'll incorrectly
        // return WAIT_TIMEOUT.
        if (waitAll && wfmo->Status.EventsLeft == 0) {
            done = true;
        }

        timespec ts;
        if (!done) {
            if (milliseconds == 0) {
                result = WAIT_TIMEOUT;
                done = true;
            } else if (milliseconds != (uint64_t)-1) {
                timeval tv;
                gettimeofday(&tv, NULL);

                uint64_t nanoseconds = ((uint64_t)tv.tv_sec) * 1000 * 1000 * 1000 +
                                       milliseconds * 1000 * 1000 + ((uint64_t)tv.tv_usec) * 1000;

                ts.tv_sec = nanoseconds / 1000 / 1000 / 1000;
                ts.tv_nsec = (nanoseconds - ((uint64_t)ts.tv_sec) * 1000 * 1000 * 1000);
            }
        }

        while (!done) {
            // One (or more) of the events we're monitoring has been triggered?

            // If we're waiting for all events, assume we're done and check if there's an event that
            // hasn't fired But if we're waiting for just one event, assume we're not done until we
            // find a fired event
            done = (waitAll && wfmo->Status.EventsLeft == 0) ||
                   (!waitAll && wfmo->Status.FiredEvent != -1);

            if (!done) {
                if (milliseconds != (uint64_t)-1) {
                    result = pthread_cond_timedwait(&wfmo->CVariable, &wfmo->Mutex, &ts);
                } else {
                    result = pthread_cond_wait(&wfmo->CVariable, &wfmo->Mutex);
                }

                if (result != 0) {
                    break;
                }
            }
        }

        waitIndex = wfmo->Status.FiredEvent;
        wfmo->StillWaiting = false;

        --wfmo->RefCount;
        assert(wfmo->RefCount >= 0);
        bool destroy = wfmo->RefCount == 0;
        tempResult = pthread_mutex_unlock(&wfmo->Mutex);
        assert(tempResult == 0);
        if (destroy) {
            wfmo->Destroy();
            delete wfmo;
        }

        return result;
    }
#endif // WFMO

    int DestroyEvent(neosmart_event_t event) {
        int result = 0;

#ifdef WFMO
        result = pthread_mutex_lock(&event->Mutex);
        assert(result == 0);
        event->RegisteredWaits.erase(std::remove_if(event->RegisteredWaits.begin(),
                                                    event->RegisteredWaits.end(),
                                                    RemoveExpiredWaitHelper),
                                     event->RegisteredWaits.end());
        result = pthread_mutex_unlock(&event->Mutex);
        assert(result == 0);
#endif

        result = pthread_cond_destroy(&event->CVariable);
        assert(result == 0);

        result = pthread_mutex_destroy(&event->Mutex);
        assert(result == 0);

        delete event;

        return 0;
    }

    int SetEvent(neosmart_event_t event) {
        int result = pthread_mutex_lock(&event->Mutex);
        assert(result == 0);

        event->State = true;

        // Depending on the event type, we either trigger everyone or only one
        if (event->AutoReset) {
#ifdef WFMO
            while (!event->RegisteredWaits.empty()) {
                neosmart_wfmo_info_t i = &event->RegisteredWaits.front();

                result = pthread_mutex_lock(&i->Waiter->Mutex);
                assert(result == 0);

                --i->Waiter->RefCount;
                assert(i->Waiter->RefCount >= 0);
                if (!i->Waiter->StillWaiting) {
                    bool destroy = i->Waiter->RefCount == 0;
                    result = pthread_mutex_unlock(&i->Waiter->Mutex);
                    assert(result == 0);
                    if (destroy) {
                        i->Waiter->Destroy();
                        delete i->Waiter;
                    }
                    event->RegisteredWaits.pop_front();
                    continue;
                }

                event->State = false;

                if (i->Waiter->WaitAll) {
                    --i->Waiter->Status.EventsLeft;
                    assert(i->Waiter->Status.EventsLeft >= 0);
                    // We technically should do i->Waiter->StillWaiting = Waiter->Status.EventsLeft
                    // != 0 but the only time it'll be equal to zero is if we're the last event, so
                    // no one else will be checking the StillWaiting flag. We're good to go without
                    // it.
                } else {
                    i->Waiter->Status.FiredEvent = i->WaitIndex;
                    i->Waiter->StillWaiting = false;
                }

                result = pthread_mutex_unlock(&i->Waiter->Mutex);
                assert(result == 0);

                result = pthread_cond_signal(&i->Waiter->CVariable);
                assert(result == 0);

                event->RegisteredWaits.pop_front();

                result = pthread_mutex_unlock(&event->Mutex);
                assert(result == 0);

                return 0;
            }
#endif // WFMO
       // event->State can be false if compiled with WFMO support
            if (event->State) {
                result = pthread_mutex_unlock(&event->Mutex);
                assert(result == 0);

                result = pthread_cond_signal(&event->CVariable);
                assert(result == 0);

                return 0;
            }
        } else {
#ifdef WFMO
            for (size_t i = 0; i < event->RegisteredWaits.size(); ++i) {
                neosmart_wfmo_info_t info = &event->RegisteredWaits[i];

                result = pthread_mutex_lock(&info->Waiter->Mutex);
                assert(result == 0);

                --info->Waiter->RefCount;
                assert(info->Waiter->RefCount >= 0);

                if (!info->Waiter->StillWaiting) {
                    bool destroy = info->Waiter->RefCount == 0;
                    result = pthread_mutex_unlock(&info->Waiter->Mutex);
                    assert(result == 0);
                    if (destroy) {
                        info->Waiter->Destroy();
                        delete info->Waiter;
                    }
                    continue;
                }

                if (info->Waiter->WaitAll) {
                    --info->Waiter->Status.EventsLeft;
                    assert(info->Waiter->Status.EventsLeft >= 0);
                    // We technically should do i->Waiter->StillWaiting = Waiter->Status.EventsLeft
                    // != 0 but the only time it'll be equal to zero is if we're the last event, so
                    // no one else will be checking the StillWaiting flag. We're good to go without
                    // it.
                } else {
                    info->Waiter->Status.FiredEvent = info->WaitIndex;
                    info->Waiter->StillWaiting = false;
                }

                result = pthread_mutex_unlock(&info->Waiter->Mutex);
                assert(result == 0);

                result = pthread_cond_signal(&info->Waiter->CVariable);
                assert(result == 0);
            }
            event->RegisteredWaits.clear();
#endif // WFMO
            result = pthread_mutex_unlock(&event->Mutex);
            assert(result == 0);

            result = pthread_cond_broadcast(&event->CVariable);
            assert(result == 0);
        }

        return 0;
    }

    int ResetEvent(neosmart_event_t event) {
        int result = pthread_mutex_lock(&event->Mutex);
        assert(result == 0);

        event->State = false;

        result = pthread_mutex_unlock(&event->Mutex);
        assert(result == 0);

        return 0;
    }

#ifdef PULSE
    int PulseEvent(neosmart_event_t event) {
        // This may look like it's a horribly inefficient kludge with the sole intention of reducing
        // code duplication, but in reality this is what any PulseEvent() implementation must look
        // like. The only overhead (function calls aside, which your compiler will likely optimize
        // away, anyway), is if only WFMO auto-reset waits are active there will be overhead to
        // unnecessarily obtain the event mutex for ResetEvent() after. In all other cases (being no
        // pending waits, WFMO manual-reset waits, or any WFSO waits), the event mutex must first be
        // released for the waiting thread to resume action prior to locking the mutex again in
        // order to set the event state to unsignaled, or else the waiting threads will loop back
        // into a wait (due to checks for spurious CVariable wakeups).

        int result = SetEvent(event);
        assert(result == 0);
        result = ResetEvent(event);
        assert(result == 0);

        return 0;
    }
#endif
} // namespace neosmart

#else //_WIN32

#include <Windows.h>
#include "pevents.h"

namespace neosmart {
    neosmart_event_t CreateEvent(bool manualReset, bool initialState) {
        return static_cast<neosmart_event_t>(::CreateEvent(NULL, manualReset, initialState, NULL));
    }

    int DestroyEvent(neosmart_event_t event) {
        HANDLE handle = static_cast<HANDLE>(event);
        return CloseHandle(handle) ? 0 : GetLastError();
    }

    int WaitForEvent(neosmart_event_t event, uint64_t milliseconds) {
        uint32_t result = 0;
        HANDLE handle = static_cast<HANDLE>(event);

        // WaitForSingleObject(Ex) and WaitForMultipleObjects(Ex) only support 32-bit timeout
        if (milliseconds == ((uint64_t)-1) || (milliseconds >> 32) == 0) {
            result = WaitForSingleObject(handle, static_cast<uint32_t>(milliseconds));
        } else {
            // Cannot wait for 0xFFFFFFFF because that means infinity to WIN32
            uint32_t waitUnit = (INFINITE - 1);
            uint64_t rounds = milliseconds / waitUnit;
            uint32_t remainder = milliseconds % waitUnit;

            result = WaitForSingleObject(handle, remainder);
            while (result == WAIT_TIMEOUT && rounds-- != 0) {
                result = WaitForSingleObject(handle, waitUnit);
            }
        }

        if (result == WAIT_OBJECT_0 || result == WAIT_ABANDONED) {
            // We must swallow WAIT_ABANDONED because there is no such equivalent on *nix
            return 0;
        }

        if (result == WAIT_TIMEOUT) {
            return WAIT_TIMEOUT;
        }

        return GetLastError();
    }

    int SetEvent(neosmart_event_t event) {
        HANDLE handle = static_cast<HANDLE>(event);
        return ::SetEvent(handle) ? 0 : GetLastError();
    }

    int ResetEvent(neosmart_event_t event) {
        HANDLE handle = static_cast<HANDLE>(event);
        return ::ResetEvent(handle) ? 0 : GetLastError();
    }

#ifdef WFMO
    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,
                              uint64_t milliseconds) {
        int index = 0;
        return WaitForMultipleEvents(events, count, waitAll, milliseconds, index);
    }

    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,
                              uint64_t milliseconds, int &index) {
        HANDLE *handles = reinterpret_cast<HANDLE *>(events);
        uint32_t result = 0;

        // WaitForSingleObject(Ex) and WaitForMultipleObjects(Ex) only support 32-bit timeout
        if (milliseconds == ((uint64_t)-1) || (milliseconds >> 32) == 0) {
            result = WaitForMultipleObjects(count, handles, waitAll,
                                            static_cast<uint32_t>(milliseconds));
        } else {
            // Cannot wait for 0xFFFFFFFF because that means infinity to WIN32
            uint32_t waitUnit = (INFINITE - 1);
            uint64_t rounds = milliseconds / waitUnit;
            uint32_t remainder = milliseconds % waitUnit;

            uint32_t result2 = WaitForMultipleObjects(count, handles, waitAll, remainder);
            while (result2 == WAIT_TIMEOUT && rounds-- != 0) {
                result2 = WaitForMultipleObjects(count, handles, waitAll, waitUnit);
            }
        }

        if (result >= WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + count) {
            index = result - WAIT_OBJECT_0;
            return 0;
        } else if (result >= WAIT_ABANDONED_0 && result < WAIT_ABANDONED_0 + count) {
            index = result - WAIT_ABANDONED_0;
            return 0;
        }

        if (result == WAIT_FAILED) {
            return GetLastError();
        }
        return result;
    }
#endif

#ifdef PULSE
    int PulseEvent(neosmart_event_t event) {
        HANDLE handle = static_cast<HANDLE>(event);
        return ::PulseEvent(handle) ? 0 : GetLastError();
    }
#endif
} // namespace neosmart

#endif //_WIN32
```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/pevents.h`:

```h
/*
 * WIN32 Events for POSIX
 * Author: Mahmoud Al-Qudsi <mqudsi@neosmart.net>
 * Copyright (C) 2011 - 2019 by NeoSmart Technologies
 * This code is released under the terms of the MIT License
 */

#pragma once

#if defined(_WIN32) && !defined(CreateEvent)
#error Must include Windows.h prior to including pevents.h!
#endif
#ifndef WAIT_TIMEOUT
#include <errno.h>
#define WAIT_TIMEOUT ETIMEDOUT
#endif

#include <stdint.h>

#define WFMO 1

namespace neosmart {
    // Type declarations
    struct neosmart_event_t_;
    typedef neosmart_event_t_ *neosmart_event_t;

    // Function declarations
    neosmart_event_t CreateEvent(bool manualReset = false, bool initialState = false);
    int DestroyEvent(neosmart_event_t event);
    int WaitForEvent(neosmart_event_t event, uint64_t milliseconds = -1);
    int SetEvent(neosmart_event_t event);
    int ResetEvent(neosmart_event_t event);
#ifdef WFMO
    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,
                              uint64_t milliseconds);
    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,
                              uint64_t milliseconds, int &index);
#endif
#ifdef PULSE
    int PulseEvent(neosmart_event_t event);
#endif
} // namespace neosmart
```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/platform_unix.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */
#ifdef __linux__

#include "platform_unix.h"

uint32_t Platform::GetCurrentTimeMS() {
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  return (ts.tv_sec * 1000) + (ts.tv_nsec / (1000*1000));
}

void Platform::SleepMS(int milliseconds) {
  usleep(milliseconds * 1000);
}

void Platform::CreateDirectory(const char* pathname, const void* junk) {
  mkdir(pathname, -1);
}

static void __attribute__((constructor)) DllMain() {
   srand(Platform::GetCurrentTimeMS() + Platform::GetProcessID());
}
#endif
```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/platform_unix.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifdef __linux__

#ifndef _GGPO_UNIX_H_
#define _GGPO_UNIX_H_

#include <sys/stat.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <unistd.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <climits>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <arpa/inet.h>

#include "pevents.h"

#define DebugBreak() (raise(SIGTRAP))
#define ioctlsocket ioctl
#define closesocket close
#define WSAEWOULDBLOCK EWOULDBLOCK
#define INFINITE (-1)
#define WAIT_OBJECT_0 (0x00000000L)
#define FALSE (false)
#define MAX_PATH (4096)
#define INVALID_SOCKET ((SOCKET)(~0))
#define SOCKET_ERROR (-1)

typedef neosmart::neosmart_event_t HANDLE;
typedef uint8_t byte;
typedef int SOCKET;
typedef uint32_t DWORD;

class Platform {
public:  // types
   typedef pid_t ProcessID;
public:  // functions
   static ProcessID GetProcessID() { return getpid(); }
   static void AssertFailed(char *msg) { }
   static uint32_t GetCurrentTimeMS();
   static void SleepMS(int milliseconds);
   static void CreateDirectory(const char* pathname, const void* junk);
};

#endif
#endif
```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/platform_windows.cpp`:

```cpp
/* -----------------------------------------------------------------------
* GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */
#ifdef _WINDOWS
#include "platform_windows.h"

BOOL WINAPI
DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
   srand(Platform::GetCurrentTimeMS() + Platform::GetProcessID());
   return true;
}

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/platform_windows.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifdef _WINDOWS
#ifndef _GGPO_WINDOWS_H_
#define _GGPO_WINDOWS_H_

#include "Windows/AllowWindowsPlatformTypes.h"
#include "Windows/WindowsHWrapper.h"

#include <winsock2.h>
#include <WS2tcpip.h>
#include <windows.h>
#include <stdio.h>
#include <stdint.h>
#include <timeapi.h>
#include "types.h"

class Platform {
public:  // types
   typedef DWORD ProcessID;

public:  // functions
   static ProcessID GetProcessID() { return GetCurrentProcessId(); }
   static void AssertFailed(char *msg) { MessageBoxA(NULL, msg, "GGPO Assertion Failed", MB_OK | MB_ICONEXCLAMATION); }
   static uint32_t GetCurrentTimeMS() { return timeGetTime(); }
   static void SleepMS(int ms) { Sleep(ms); }
   static void CreateDirectory(const char* pathname, const void* junk) { CreateDirectoryA(pathname, (LPSECURITY_ATTRIBUTES)junk); }
};

#include "Windows/WindowsHWrapper.h"
#include "Windows/HideWindowsPlatformTypes.h"

#endif
#endif
```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/poll.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "poll.h"
#include "types.h"

#ifndef _WIN32
using namespace neosmart;
#endif

Poll::Poll(void) :
   _start_time(0),
   _handle_count(0)
{
   /*
    * Create a dummy handle to simplify things.
    */
#ifdef _WIN32
   _handles[_handle_count++] = CreateEvent(NULL, true, false, NULL);
#else
   _handles[_handle_count++] = CreateEvent(true, false);
#endif
}

void
Poll::RegisterHandle(IPollSink *sink, HANDLE h, void *cookie)
{
   ASSERT(_handle_count < MAX_POLLABLE_HANDLES - 1);

   _handles[_handle_count] = h;
   _handle_sinks[_handle_count] = PollSinkCb(sink, cookie);
   _handle_count++;
}

void
Poll::RegisterMsgLoop(IPollSink *sink, void *cookie)
{
   _msg_sinks.push_back(PollSinkCb(sink, cookie));
}

void
Poll::RegisterLoop(IPollSink *sink, void *cookie)
{
   _loop_sinks.push_back(PollSinkCb(sink, cookie));
}
void
Poll::RegisterPeriodic(IPollSink *sink, int interval, void *cookie)
{
   _periodic_sinks.push_back(PollPeriodicSinkCb(sink, cookie, interval));
}

void
Poll::Run()
{
   while (Pump(100)) {
      continue;
   }
}

bool
Poll::Pump(int timeout)
{
   int i, res;
   bool finished = false;

   if (_start_time == 0) {
      _start_time = Platform::GetCurrentTimeMS();
   }
   int elapsed = Platform::GetCurrentTimeMS() - _start_time;
   int maxwait = ComputeWaitTime(elapsed);
   if (maxwait != INFINITE) {
      timeout = MIN(timeout, maxwait);
   }

#ifdef _WIN32
   res = WaitForMultipleObjects(_handle_count, _handles, false, timeout);
#else
   res = WaitForMultipleEvents(_handles, _handle_count, false, timeout);
#endif
   if (res >= WAIT_OBJECT_0 && res < WAIT_OBJECT_0 + _handle_count) {
      i = res - WAIT_OBJECT_0;
      finished = !_handle_sinks[i].sink->OnHandlePoll(_handle_sinks[i].cookie) || finished;
   }
   for (i = 0; i < _msg_sinks.size(); i++) {
      PollSinkCb &cb = _msg_sinks[i];
      finished = !cb.sink->OnMsgPoll(cb.cookie) || finished;
   }

   for (i = 0; i < _periodic_sinks.size(); i++) {
      PollPeriodicSinkCb &cb = _periodic_sinks[i];
      if (cb.interval + cb.last_fired <= elapsed) {
         cb.last_fired = (elapsed / cb.interval) * cb.interval;
         finished = !cb.sink->OnPeriodicPoll(cb.cookie, cb.last_fired) || finished;
      }
   }

   for (i = 0; i < _loop_sinks.size(); i++) {
      PollSinkCb &cb = _loop_sinks[i];
      finished = !cb.sink->OnLoopPoll(cb.cookie) || finished;
   }
   return finished;
}

int
Poll::ComputeWaitTime(int elapsed)
{
   int waitTime = INFINITE;
   size_t count = _periodic_sinks.size();

   if (count > 0) {
      for (int i = 0; i < count; i++) {
         PollPeriodicSinkCb &cb = _periodic_sinks[i];
         int timeout = (cb.interval + cb.last_fired) - elapsed;
         if (waitTime == INFINITE || (timeout < waitTime)) {
            waitTime = MAX(timeout, 0);
         }         
      }
   }
   return waitTime;
}

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/poll.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _POLL_H
#define _POLL_H

#include "static_buffer.h"

#define MAX_POLLABLE_HANDLES     64


class IPollSink {
public:
   virtual ~IPollSink() { }
   virtual bool OnHandlePoll(void *) { return true; }
   virtual bool OnMsgPoll(void *) { return true; }
   virtual bool OnPeriodicPoll(void *, int ) { return true; }
   virtual bool OnLoopPoll(void *) { return true; }
};

class Poll {
public:
   Poll(void);
   void RegisterHandle(IPollSink *sink, HANDLE h, void *cookie = NULL);
   void RegisterMsgLoop(IPollSink *sink, void *cookie = NULL);
   void RegisterPeriodic(IPollSink *sink, int interval, void *cookie = NULL);
   void RegisterLoop(IPollSink *sink, void *cookie = NULL);

   void Run();
   bool Pump(int timeout);

protected:
   int ComputeWaitTime(int elapsed);

   struct PollSinkCb {
      IPollSink   *sink;
      void        *cookie;
      PollSinkCb() : sink(NULL), cookie(NULL) { }
      PollSinkCb(IPollSink *s, void *c) : sink(s), cookie(c) { }
   };

   struct PollPeriodicSinkCb : public PollSinkCb {
      int         interval;
      int         last_fired;
      PollPeriodicSinkCb() : PollSinkCb(NULL, NULL), interval(0), last_fired(0) { }
      PollPeriodicSinkCb(IPollSink *s, void *c, int i) :
         PollSinkCb(s, c), interval(i), last_fired(0) { }
   };

   int               _start_time;
   int               _handle_count;
   HANDLE            _handles[MAX_POLLABLE_HANDLES];
   PollSinkCb        _handle_sinks[MAX_POLLABLE_HANDLES];

   StaticBuffer<PollSinkCb, 16>          _msg_sinks;
   StaticBuffer<PollSinkCb, 16>          _loop_sinks;
   StaticBuffer<PollPeriodicSinkCb, 16>  _periodic_sinks;
};

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/ring_buffer.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _RING_BUFFER_H
#define _RING_BUFFER_H

#include <types.h>

template<class T, int N> class RingBuffer
{
public:
   RingBuffer<T, N>() : 
      _head(0),
      _tail(0),
      _size(0) {
  } 

   T &front() {
      ASSERT(_size != N);
      return _elements[_tail];
   }
   
   T &item(int i) {
      ASSERT(i < _size);
      return _elements[(_tail + i) % N];
   }

   void pop() {
      ASSERT(_size != N);
      _tail = (_tail + 1) % N;
      _size--;
   }

   void push(const T &t) {
      ASSERT(_size != (N-1));
      _elements[_head] = t;
      _head = (_head + 1) % N;
      _size++;
   }

   int size() {
      return _size;
   }

   bool empty() {
      return _size == 0;
   }

protected:
   T        _elements[N];
   int      _head;
   int      _tail;
   int      _size;
};

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/static_buffer.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _STATIC_BUFFER_H
#define _STATIC_BUFFER_H

#include <types.h>

template<class T, int N> class StaticBuffer
{
public:
   StaticBuffer<T, N>() :
      _size(0) {
   } 

   T& operator[](int i) {
      ASSERT(i >= 0 && i < _size);
      return _elements[i];
   }

   void push_back(const T &t) {
      ASSERT(_size != (N-1));
      _elements[_size++] = t;
   }

   int size() {
      return _size;
   }


protected:
   T        _elements[N];
   int      _size;
};

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/sync.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "sync.h"

Sync::Sync(UdpMsg::connect_status *connect_status) :
 _input_queues(NULL),
 _local_connect_status(connect_status)
{
   _framecount = 0;
   _last_confirmed_frame = -1;
   _max_prediction_frames = 0;
   memset(&_savedstate, 0, sizeof(_savedstate));
}

Sync::~Sync()
{
   /*
    * Delete frames manually here rather than in a destructor of the SavedFrame
    * structure so we can efficently copy frames via weak references.
    */
   for (int i = 0; i < ARRAY_SIZE(_savedstate.frames); i++) {
      _callbacks.free_buffer(_savedstate.frames[i].buf);
   }
   delete [] _input_queues;
   _input_queues = NULL;
}

void
Sync::Init(Sync::Config &config)
{
   _config = config;
   _callbacks = config.callbacks;
   _framecount = 0;
   _rollingback = false;

   _max_prediction_frames = config.num_prediction_frames;

   CreateQueues(config);
}

void
Sync::SetLastConfirmedFrame(int frame) 
{   
   _last_confirmed_frame = frame;
   if (_last_confirmed_frame > 0) {
      for (int i = 0; i < _config.num_players; i++) {
         _input_queues[i].DiscardConfirmedFrames(frame - 1);
      }
   }
}

bool
Sync::AddLocalInput(int queue, GameInput &input)
{
   int frames_behind = _framecount - _last_confirmed_frame; 
   if (_framecount >= _max_prediction_frames && frames_behind >= _max_prediction_frames) {
      Log("Rejecting input from emulator: reached prediction barrier.\n");
      return false;
   }

   if (_framecount == 0) {
      SaveCurrentFrame();
   }

   Log("Sending undelayed local frame %d to queue %d.\n", _framecount, queue);
   input.frame = _framecount;
   _input_queues[queue].AddInput(input);

   return true;
}

void
Sync::AddRemoteInput(int queue, GameInput &input)
{
   _input_queues[queue].AddInput(input);
}

int
Sync::GetConfirmedInputs(void *values, int size, int frame)
{
   int disconnect_flags = 0;
   char *output = (char *)values;

   ASSERT(size >= _config.num_players * _config.input_size);

   memset(output, 0, size);
   for (int i = 0; i < _config.num_players; i++) {
      GameInput input;
      if (_local_connect_status[i].disconnected && frame > _local_connect_status[i].last_frame) {
         disconnect_flags |= (1 << i);
         input.erase();
      } else {
         _input_queues[i].GetConfirmedInput(frame, &input);
      }
      memcpy(output + (i * _config.input_size), input.bits, _config.input_size);
   }
   return disconnect_flags;
}

int
Sync::SynchronizeInputs(void *values, int size)
{
   int disconnect_flags = 0;
   char *output = (char *)values;

   ASSERT(size >= _config.num_players * _config.input_size);

   memset(output, 0, size);
   for (int i = 0; i < _config.num_players; i++) {
      GameInput input;
      if (_local_connect_status[i].disconnected && _framecount > _local_connect_status[i].last_frame) {
         disconnect_flags |= (1 << i);
         input.erase();
      } else {
         _input_queues[i].GetInput(_framecount, &input);
      }
      memcpy(output + (i * _config.input_size), input.bits, _config.input_size);
   }
   return disconnect_flags;
}

void
Sync::CheckSimulation(int timeout)
{
   int seek_to;
   if (!CheckSimulationConsistency(&seek_to)) {
      AdjustSimulation(seek_to);
   }
}

void
Sync::IncrementFrame(void)
{
   _framecount++;
   SaveCurrentFrame();
}

void
Sync::AdjustSimulation(int seek_to)
{
   int framecount = _framecount;
   int count = _framecount - seek_to;

   Log("Catching up\n");
   _rollingback = true;

   /*
    * Flush our input queue and load the last frame.
    */
   LoadFrame(seek_to);
   ASSERT(_framecount == seek_to);

   /*
    * Advance frame by frame (stuffing notifications back to 
    * the master).
    */
   ResetPrediction(_framecount);
   for (int i = 0; i < count; i++) {
      _callbacks.advance_frame(0);
   }
   ASSERT(_framecount == framecount);

   _rollingback = false;

   Log("---\n");   
}

void
Sync::LoadFrame(int frame)
{
   // find the frame in question
   if (frame == _framecount) {
      Log("Skipping NOP.\n");
      return;
   }

   // Move the head pointer back and load it up
   _savedstate.head = FindSavedFrameIndex(frame);
   SavedFrame *state = _savedstate.frames + _savedstate.head;

   Log("=== Loading frame info %d (size: %d  checksum: %08x).\n",
       state->frame, state->cbuf, state->checksum);

   ASSERT(state->buf && state->cbuf);
   _callbacks.load_game_state(state->buf, state->cbuf);

   // Reset framecount and the head of the state ring-buffer to point in
   // advance of the current frame (as if we had just finished executing it).
   _framecount = state->frame;
   _savedstate.head = (_savedstate.head + 1) % ARRAY_SIZE(_savedstate.frames);
}

void
Sync::SaveCurrentFrame()
{
   /*
    * See StateCompress for the real save feature implemented by FinalBurn.
    * Write everything into the head, then advance the head pointer.
    */
   SavedFrame *state = _savedstate.frames + _savedstate.head;
   if (state->buf) {
      _callbacks.free_buffer(state->buf);
      state->buf = NULL;
   }
   state->frame = _framecount;
   _callbacks.save_game_state(&state->buf, &state->cbuf, &state->checksum, state->frame);

   Log("=== Saved frame info %d (size: %d  checksum: %08x).\n", state->frame, state->cbuf, state->checksum);
   _savedstate.head = (_savedstate.head + 1) % ARRAY_SIZE(_savedstate.frames);
}

Sync::SavedFrame&
Sync::GetLastSavedFrame()
{
   int i = _savedstate.head - 1;
   if (i < 0) {
      i = ARRAY_SIZE(_savedstate.frames) - 1;
   }
   return _savedstate.frames[i];
}


int
Sync::FindSavedFrameIndex(int frame)
{
   int i, count = ARRAY_SIZE(_savedstate.frames);
   for (i = 0; i < count; i++) {
      if (_savedstate.frames[i].frame == frame) {
         break;
      }
   }
   if (i == count) {
      ASSERT(false);
   }
   return i;
}


bool
Sync::CreateQueues(Config &config)
{
   delete [] _input_queues;
   _input_queues = new InputQueue[_config.num_players];

   for (int i = 0; i < _config.num_players; i++) {
      _input_queues[i].Init(i, _config.input_size);
   }
   return true;
}

bool
Sync::CheckSimulationConsistency(int *seekTo)
{
   int first_incorrect = GameInput::NullFrame;
   for (int i = 0; i < _config.num_players; i++) {
      int incorrect = _input_queues[i].GetFirstIncorrectFrame();
      Log("considering incorrect frame %d reported by queue %d.\n", incorrect, i);

      if (incorrect != GameInput::NullFrame && (first_incorrect == GameInput::NullFrame || incorrect < first_incorrect)) {
         first_incorrect = incorrect;
      }
   }

   if (first_incorrect == GameInput::NullFrame) {
      Log("prediction ok.  proceeding.\n");
      return true;
   }
   *seekTo = first_incorrect;
   return false;
}

void
Sync::SetFrameDelay(int queue, int delay)
{
   _input_queues[queue].SetFrameDelay(delay);
}


void
Sync::ResetPrediction(int frameNumber)
{
   for (int i = 0; i < _config.num_players; i++) {
      _input_queues[i].ResetPrediction(frameNumber);
   }
}


bool
Sync::GetEvent(Event &e)
{
   if (_event_queue.size()) {
      e = _event_queue.front();
      _event_queue.pop();
      return true;
   }
   return false;
}



```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/sync.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _SYNC_H
#define _SYNC_H

#include "types.h"
#include "include/ggponet.h"
#include "game_input.h"
#include "input_queue.h"
#include "ring_buffer.h"
#include "network/udp_msg.h"

#define MAX_PREDICTION_FRAMES    8

class SyncTestBackend;

class Sync {
public:
   struct Config {
      GGPOSessionCallbacks    callbacks;
      int                     num_prediction_frames;
      int                     num_players;
      int                     input_size;
   };
   struct Event {
      enum {
         ConfirmedInput,
      } type;
      union {
         struct {
            GameInput   input;
         } confirmedInput;
      } u;
   };

public:
   Sync(UdpMsg::connect_status *connect_status);
   virtual ~Sync();

   void Init(Config &config);

   void SetLastConfirmedFrame(int frame);
   void SetFrameDelay(int queue, int delay);
   bool AddLocalInput(int queue, GameInput &input);
   void AddRemoteInput(int queue, GameInput &input);
   int GetConfirmedInputs(void *values, int size, int frame);
   int SynchronizeInputs(void *values, int size);

   void CheckSimulation(int timeout);
   void AdjustSimulation(int seek_to);
   void IncrementFrame(void);

   int GetFrameCount() { return _framecount; }
   bool InRollback() { return _rollingback; }

   bool GetEvent(Event &e);

protected:
   friend SyncTestBackend;

   struct SavedFrame {
      byte    *buf;
      int      cbuf;
      int      frame;
      int      checksum;
      SavedFrame() : buf(NULL), cbuf(0), frame(-1), checksum(0) { }
   };
   struct SavedState {
      SavedFrame frames[MAX_PREDICTION_FRAMES + 2];
      int head;
   };

   void LoadFrame(int frame);
   void SaveCurrentFrame();
   int FindSavedFrameIndex(int frame);
   SavedFrame &GetLastSavedFrame();

   bool CreateQueues(Config &config);
   bool CheckSimulationConsistency(int *seekTo);
   void ResetPrediction(int frameNumber);

protected:
   GGPOSessionCallbacks _callbacks;
   SavedState     _savedstate;
   Config         _config;

   bool           _rollingback;
   int            _last_confirmed_frame;
   int            _framecount;
   int            _max_prediction_frames;

   InputQueue     *_input_queues;

   RingBuffer<Event, 32> _event_queue;
   UdpMsg::connect_status *_local_connect_status;
};

#endif


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/timesync.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "timesync.h"

TimeSync::TimeSync()
{
   memset(_local, 0, sizeof(_local));
   memset(_remote, 0, sizeof(_remote));
   _next_prediction = FRAME_WINDOW_SIZE * 3;
}

TimeSync::~TimeSync()
{
}

void
TimeSync::advance_frame(GameInput &input, int advantage, int radvantage)
{
   // Remember the last frame and frame advantage
   _last_inputs[input.frame % ARRAY_SIZE(_last_inputs)] = input;
   _local[input.frame % ARRAY_SIZE(_local)] = advantage;
   _remote[input.frame % ARRAY_SIZE(_remote)] = radvantage;
}

int
TimeSync::recommend_frame_wait_duration(bool require_idle_input)
{
   // Average our local and remote frame advantages
   int i, sum = 0;
   float advantage, radvantage;
   for (i = 0; i < ARRAY_SIZE(_local); i++) {
      sum += _local[i];
   }
   advantage = sum / (float)ARRAY_SIZE(_local);

   sum = 0;
   for (i = 0; i < ARRAY_SIZE(_remote); i++) {
      sum += _remote[i];
   }
   radvantage = sum / (float)ARRAY_SIZE(_remote);

   static int count = 0;
   count++;

   // See if someone should take action.  The person furthest ahead
   // needs to slow down so the other user can catch up.
   // Only do this if both clients agree on who's ahead!!
   if (advantage >= radvantage) {
      return 0;
   }

   // Both clients agree that we're the one ahead.  Split
   // the difference between the two to figure out how long to
   // sleep for.
   int sleep_frames = (int)(((radvantage - advantage) / 2) + 0.5);

   Log("iteration %d:  sleep frames is %d\n", count, sleep_frames);

   // Some things just aren't worth correcting for.  Make sure
   // the difference is relevant before proceeding.
   if (sleep_frames < MIN_FRAME_ADVANTAGE) {
      return 0;
   }

   // Make sure our input had been "idle enough" before recommending
   // a sleep.  This tries to make the emulator sleep while the
   // user's input isn't sweeping in arcs (e.g. fireball motions in
   // Street Fighter), which could cause the player to miss moves.
   if (require_idle_input) {
      for (i = 1; i < ARRAY_SIZE(_last_inputs); i++) {
         if (!_last_inputs[i].equal(_last_inputs[0], true)) {
            Log("iteration %d:  rejecting due to input stuff at position %d...!!!\n", count, i);
            return 0;
         }
      }
   }

   // Success!!! Recommend the number of frames to sleep and adjust
   return MIN(sleep_frames, MAX_FRAME_ADVANTAGE);
}

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/timesync.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _TIMESYNC_H
#define _TIMESYNC_H

#include "types.h"
#include "game_input.h"

#define FRAME_WINDOW_SIZE           40
#define MIN_UNIQUE_FRAMES           10
#define MIN_FRAME_ADVANTAGE          3
#define MAX_FRAME_ADVANTAGE          9

class TimeSync {
public:
   TimeSync();
   virtual ~TimeSync ();

   void advance_frame(GameInput &input, int advantage, int radvantage);
   int recommend_frame_wait_duration(bool require_idle_input);

protected:
   int         _local[FRAME_WINDOW_SIZE];
   int         _remote[FRAME_WINDOW_SIZE];
   GameInput   _last_inputs[MIN_UNIQUE_FRAMES];
   int         _next_prediction;
};

#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/types.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#ifndef _TYPES_H
#define _TYPES_H
/*
 * Keep the compiler happy
 */

/*
 * Disable specific compiler warnings
 *   4018 - '<' : signed/unsigned mismatch
 *   4100 - 'xxx' : unreferenced formal parameter
 *   4127 - conditional expression is constant
 *   4201 - nonstandard extension used : nameless struct/union
 *   4389 - '!=' : signed/unsigned mismatch
 *   4800 - 'int' : forcing value to bool 'true' or 'false' (performance warning)
 */
#pragma warning(disable: 4018 4100 4127 4201 4389 4800)

/*
 * Simple types
 */
typedef unsigned char byte;

/*
 * Additional headers
 */
#if defined(_WINDOWS)
#  include "platform_windows.h"
#elif defined(__APPLE__) or defined(__GNUC__)
#  include "platform_unix.h"
#else
#  error Unsupported platform
#endif

#include "log.h"



/*
 * Macros
 */
#define ASSERT(x)                                           \
   do {                                                     \
      if (!(x)) {                                           \
         char assert_buf[1024];                             \
         snprintf(assert_buf, sizeof(assert_buf) - 1, "Assertion: %s @ %s:%d (pid:%d)", #x, __FILE__, __LINE__, (int)Platform::GetProcessID()); \
         Log("%s\n", assert_buf);                           \
         Log("\n");                                         \
         Log("\n");                                         \
         Log("\n");                                         \
         Platform::AssertFailed(assert_buf);                \
         exit(0);                                           \
      }                                                     \
   } while (false)

#ifndef ARRAY_SIZE
#  define ARRAY_SIZE(a)    (sizeof(a) / sizeof((a)[0]))
#endif

#ifndef MAX_INT
#  define MAX_INT          0xEFFFFFF
#endif

#ifndef MAX
#  define MAX(x, y)        (((x) > (y)) ? (x) : (y))
#endif

#ifndef MIN
#  define MIN(x, y)        (((x) < (y)) ? (x) : (y))
#endif

#endif // _TYPES_H

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/zconf.h`:

```h
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

// Dave:
#define ZEXPORT __fastcall
#define ZEXPORTVA __cdecl

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tsted only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT EXPORT WINAPI
#      define ZEXPORTRVA EXPORT WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern EXPORT
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
#  define ZEXTERN extern
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

#endif /* _ZCONF_H */

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Private/zlib.h`:

```h
 /* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.4, March 11th, 2002

  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Public/GGPOGameInstance.h`:

```h
// Copyright 2020 BwdYeti.

#pragma once

#include "CoreMinimal.h"
#include "Engine/GameInstance.h"
#include "GGPOGameInstance.generated.h"

// Forward declarations
class UGGPONetwork;

/**
 * 
 */
UCLASS()
class GGPOUE4_API UGGPOGameInstance : public UGameInstance
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		UGGPONetwork* NetworkAddresses;

    /** Creates a collection of network addresses. */
    UFUNCTION(BlueprintCallable, Category = "GGPO")
        void CreateNetwork(int32 NumPlayers, int32 PlayerIndex, int32 LocalPort, TArray<FString> RemoteAddresses);
	
};

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Public/GGPOUE4.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

DECLARE_LOG_CATEGORY_EXTERN(GGPOLOG, Log, All);

class FGGPOUE4Module : public IModuleInterface
{
public:

	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/connection_manager.h`:

```h

#ifndef _CONNECTION_MANAGER_H
#define _CONNECTION_MANAGER_H

#include <map>
#include <memory>
#include <string>
#include "../../Private/types.h"

/**
* ConnectionInfo is an abstract base class for defining connections.
*
* Derived classes from this class must provide a ToString function
* that provides a useful string for logging purposes about the
* details of the given connection.
*/
class ConnectionInfo {
public:
	ConnectionInfo() {}
	virtual ~ConnectionInfo() {
	}
	virtual std::string ToString() = 0;
};

/**
* Abstract class to define a connection manager interface
*
* This is a class whos purpose is to provide an abstraction from
* underlying network system calls. It must provide a non-blocking
* upd style send recv interface. When adding a connection it should
* return a unique int ID for the connection to be referred to by in
* future interactions with the manager.
*/

class GGPOUE4_API ConnectionManager {
public:
	ConnectionManager() : _id_to_issue(0) {}

	virtual ~ConnectionManager();

	/**
	* SendTo is a sendto upd style interface
	*
	* This function is expected to function similar to a standard upd
	* socket style send.
	*/
	virtual int SendTo(const char* buffer, int len, int flags, int connection_id) = 0;

	/**
	* RecvFrom is a recvfrom upd style interface
	*
	* This function is expected to function similar to a standard upd
	* socket style recvfrom. Return values are as follows:
	* greater than 0 values indicate data length.
	* 0 indicates a disconnect.
	* -1 indicates no data or some other error.
	*/
	virtual int RecvFrom(char* buffer, int len, int flags, int* connection_id) = 0;

	/**
	* ResetManager is a reset function to clear the connection_map
	*
	* This should be called if there is a need to clear all existing
	* connections without creating a new connection manager.
	*/
	virtual int ResetManager() {
		_connection_map.clear();
		return 0;
	}

	/**
	* ToString converts relevant information to a string
	*
	* This function should convert relevant information from the
	* connection info object identified by connection_id to a
	* string. The default implementation should be valid for most
	* use cases. Overload the ToString function in the derived
	* ConnectionInfo definition.
	*/
	virtual std::string ToString(int connection_id);

	void Log(const char* fmt, ...);

protected:
	/**
	* AddConnection adds a connection to the manager and returns the ID.
	*
	* This function takes in a ConnectionInfo smartpointer to an object
	* that implicitly must be a defined type that inheriteds from
	* ConnectionInfo. Derived ConnectionManagers should define their own
	* AddConnection functions with args that provide the relevant information
	* for the specific connection desired. This function should then be called
	* to add a derived ConnectionInfo object to the _connection_map and it will
	* return the connection id. Having monotonically increasing IDs is fine
	* for this use case. It is up to the user to correctly manage IDs to
	* ensure they are only used with the ConnectionManager that issued them
	* as the same IDs will likely be valid in multiple ConnectionManagers on
	* the same process.
	*/
	int AddConnection(std::shared_ptr<ConnectionInfo> info) {
		_connection_map.insert({_id_to_issue, info});
		return _id_to_issue++;
	}

	/// The current ID value to be issued to the next connection added.
	int _id_to_issue;
	/// A map of connection IDs and smart pointers to their respective info objects.
	std::map <int, std::shared_ptr<ConnectionInfo>> _connection_map;
};

#if defined(_WINDOWS)
/// UDPConnectionManager is a windows only ip address based connection manager
class UPDInfo : public ConnectionInfo   {
public:
	UPDInfo(const char* ip_address, uint16 port);

	sockaddr_in addr;

	~UPDInfo() {
	}

	virtual std::string ToString();
};

class GGPOUE4_API UDPConnectionManager : public ConnectionManager {

public:
	UDPConnectionManager();
	virtual ~UDPConnectionManager();

	virtual int SendTo(const char* buffer, int len, int flags, int connection_id);

	virtual int RecvFrom(char* buffer, int len, int flags, int* connection_id);

	int AddConnection(const char* ip_address, uint16 port);

	void Init(uint16 port);

	int FindIDFromIP(sockaddr_in* sockaddr);

protected:
	std::shared_ptr<ConnectionInfo> BuildConnectionInfo(const char* ip_address, uint16 port);

	sockaddr_in _peer_addr;

	SOCKET _socket;

};
#endif


#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.cpp`:

```cpp
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#include "ggponet.h"
#include "UObject/UObjectGlobals.h"

#define ARRAYSIZEOF(a) sizeof(a) / sizeof(a[0])

//UGGPONetworkAddress

UGGPONetworkAddress* UGGPONetworkAddress::CreateNetworkAddress(UObject* Outer, const FName Name, const FString Address)
{
    UGGPONetworkAddress* Result = NewObject<UGGPONetworkAddress>(Outer, Name);
    // Same type, apparently?
    const wchar_t* address = (wchar_t*)*Address;

    wchar_t WideIpBuffer[128];
    uint32 WideIpBufferSize = (uint32)ARRAYSIZEOF(WideIpBuffer);
    // Check and get port
    if (swscanf(address, L"%[^:]:%hd", WideIpBuffer, &Result->Port) != 2) {
        Result->bValidAddress = false;
    }
    else
    {
        // Get address
#ifdef _WIN32
		wcstombs_s(nullptr, Result->IpAddress, ARRAYSIZEOF(Result->IpAddress), WideIpBuffer, _TRUNCATE);
#else
		// FIXME: Implement this case.
#endif
	}

    return Result;
}
UGGPONetworkAddress* UGGPONetworkAddress::CreateLocalAddress(UObject* Outer, const FName Name, int32 LocalPort)
{
    UGGPONetworkAddress* Result = NewObject<UGGPONetworkAddress>(Outer, Name);

    Result->bValidAddress = true;
    Result->Port = (uint16)LocalPort;
    strcpy(Result->IpAddress, "127.0.0.1");

    return Result;
}

void UGGPONetworkAddress::GetIpAddress(char OutAddress[32]) const
{
    std::memcpy(OutAddress, IpAddress, sizeof(IpAddress));
}

bool UGGPONetworkAddress::IsValidAddress() const
{
    return bValidAddress;
}
FString UGGPONetworkAddress::GetIpAddressString() const
{
    auto address = FString(ANSI_TO_TCHAR(IpAddress));
    return address;
}
int32 UGGPONetworkAddress::GetPort() const
{
    return Port;
}

bool UGGPONetworkAddress::IsSameAddress(const UGGPONetworkAddress* Other) const
{
    if (bValidAddress != Other->bValidAddress)
        return false;
    if (!std::equal(std::begin(IpAddress), std::end(IpAddress), std::begin(Other->IpAddress)))
        return false;
    if (Port != Other->Port)
        return false;

    return true;
}

// UGGPONetwork

UGGPONetwork* UGGPONetwork::CreateNetwork(UObject* Outer, const FName Name, int32 NumPlayers, int32 PlayerIndex, int32 LocalPort, TArray<FString> RemoteAddresses)
{
    UGGPONetwork* Result = NewObject<UGGPONetwork>(Outer, Name);

    Result->LocalPlayerIndex = PlayerIndex - 1;
    int32 remoteIndex = 0;
    for (int32 i = 0; i < NumPlayers; i++)
    {
        // Only the port matters for local player
        if (i == Result->LocalPlayerIndex)
        {
            // Create a GGPO Network Address and add to the addresses
            UGGPONetworkAddress* address = UGGPONetworkAddress::CreateLocalAddress(
                Outer,
                FName(FString::Printf(TEXT("P%dIPAddress"), i + 1)),
                LocalPort);
            Result->Addresses.Add(address);
        }
        else
        {
            // If we ran out of remote addresses, clear the addresses and break
            if (remoteIndex >= RemoteAddresses.Num())
            {
                Result->Addresses.Empty();
                break;
            }

            // Create a GGPO Network Address and add to the addresses
            UGGPONetworkAddress* address = UGGPONetworkAddress::CreateNetworkAddress(
                Outer,
                FName(FString::Printf(TEXT("P%dIPAddress"), i + 1)),
                RemoteAddresses[remoteIndex]);
            Result->Addresses.Add(address);
            remoteIndex++;
        }
    }

    return Result;
}

bool UGGPONetwork::AllValidAddresses() const
{
    // If there are no players, this isn't valid
    if (Addresses.Num() == 0)
        return false;

    for (int32 i = 0; i < Addresses.Num(); i++)
    {
        // If an address is invalid, return false
        UGGPONetworkAddress* address = Addresses[i];
        if (!address->IsValidAddress())
            return false;
    }

    return AllUniqueAddresses();
}
bool UGGPONetwork::AllUniqueAddresses() const
{
    for (int32 i = 0; i < Addresses.Num(); i++)
    {
        for (int32 j = i + 1; j < Addresses.Num(); j++)
        {
            // If the address is the same, return false
            if (Addresses[i]->IsSameAddress(Addresses[j]))
                return false;
        }
    }

    return true;
}

UGGPONetworkAddress* UGGPONetwork::GetAddress(int32 Index) const
{
    if (Index < 0 || Index >= Addresses.Num())
        return nullptr;

    return Addresses[Index];
}
int32 UGGPONetwork::NumPlayers() const
{
    return Addresses.Num();
}
int32 UGGPONetwork::GetPlayerIndex() const
{
    return LocalPlayerIndex;
}
int32 UGGPONetwork::GetLocalPort() const
{
    // Just in case
    if (LocalPlayerIndex <= -1)
        return 7000;

    return Addresses[LocalPlayerIndex]->GetPort();
}


```

`Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h`:

```h
/* -----------------------------------------------------------------------
 * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.
 *
 * Use of this software is governed by the MIT license that can be found
 * in the LICENSE file.
 */

#pragma once

#include "CoreMinimal.h"
#include <stdarg.h>
#include "connection_manager.h"
#include <functional>
#include "ggponet.generated.h"

typedef enum
{
	GGPO_PLAYERTYPE_LOCAL,
	GGPO_PLAYERTYPE_REMOTE,
	GGPO_PLAYERTYPE_SPECTATOR,
} GGPOPlayerType;

/*
 * The GGPONetworkStats function contains some statistics about the current
 * session.
 *
 * network.send_queue_len - The length of the queue containing UDP packets
 * which have not yet been acknowledged by the end client.  The length of
 * the send queue is a rough indication of the quality of the connection.
 * The longer the send queue, the higher the round-trip time between the
 * clients.  The send queue will also be longer than usual during high
 * packet loss situations.
 *
 * network.recv_queue_len - The number of inputs currently buffered by the
 * GGPO.net network layer which have yet to be validated.  The length of
 * the prediction queue is roughly equal to the current frame number
 * minus the frame number of the last packet in the remote queue.
 *
 * network.ping - The roundtrip packet transmission time as calcuated
 * by GGPO.net.  This will be roughly equal to the actual round trip
 * packet transmission time + 2 the interval at which you call ggpo_idle
 * or ggpo_advance_frame.
 *
 * network.kbps_sent - The estimated bandwidth used between the two
 * clients, in kilobits per second.
 *
 * timesync.local_frames_behind - The number of frames GGPO.net calculates
 * that the local client is behind the remote client at this instant in
 * time.  For example, if at this instant the current game client is running
 * frame 1002 and the remote game client is running frame 1009, this value
 * will mostly likely roughly equal 7.
 *
 * timesync.remote_frames_behind - The same as local_frames_behind, but
 * calculated from the perspective of the remote player.
 *
 */
USTRUCT(BlueprintType)
struct FGGPONetworkInfo
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 send_queue_len;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 recv_queue_len;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 ping;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 kbps_sent;
};

USTRUCT(BlueprintType)
struct FGGPOSyncInfo
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 local_frames_behind;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 remote_frames_behind;
};

USTRUCT(BlueprintType)
struct FGGPONetworkStats
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	FGGPONetworkInfo network;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	FGGPOSyncInfo timesync;
};

/**
 * A network address object.
 * Composed of an ip address and a port.
 */
UCLASS(Blueprintable)
class GGPOUE4_API UGGPONetworkAddress : public UObject
{
	GENERATED_BODY()

private:
	UPROPERTY()
	bool bValidAddress = true;
	char IpAddress[32];
	uint16 Port = 0;

public:
	UGGPONetworkAddress()
	{
	}

	/** Creates a GGPO network address. */
	UFUNCTION(BlueprintCallable, Category = "GGPO")
	static UGGPONetworkAddress* CreateNetworkAddress(UObject* Outer, const FName Name, const FString Address);
	/** Creates a GGPO local address. */
	UFUNCTION(BlueprintCallable, Category = "GGPO")
	static UGGPONetworkAddress* CreateLocalAddress(UObject* Outer, const FName Name, int32 LocalPort);

	/** Outputs the ip address array to the passed pointer. */
	void GetIpAddress(char OutAddress[32]) const;

	/** Returns whether the address is valid. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	bool IsValidAddress() const;
	/** Gets the ip address as a string. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	FString GetIpAddressString() const;
	/** Gets the port. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	int32 GetPort() const;

	/** Gets the port. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	bool IsSameAddress(const UGGPONetworkAddress* Other) const;
};

/**
 * A collection of network addresses.
 */
UCLASS(Blueprintable)
class GGPOUE4_API UGGPONetwork : public UObject
{
	GENERATED_BODY()

private:
	UPROPERTY()
	int32 LocalPlayerIndex = -1;
	UPROPERTY()
	TArray<UGGPONetworkAddress*> Addresses;

public:
	UGGPONetwork()
	{
	}

	/** Creates a collection of network addresses. */
	UFUNCTION(BlueprintCallable, Category = "GGPO")
	static UGGPONetwork* CreateNetwork(UObject* Outer, const FName Name, int32 NumPlayers, int32 PlayerIndex,
	                                   int32 LocalPort, TArray<FString> RemoteAddresses);

	/** Returns whether all addresses are valid. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	bool AllValidAddresses() const;
	/** Returns whether all addresses are unique. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	bool AllUniqueAddresses() const;

	/** Gets one network address. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	UGGPONetworkAddress* GetAddress(int32 Index) const;
	/** Gets the total number of players on the network. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	int32 NumPlayers() const;
	/** Gets the local player index. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	int32 GetPlayerIndex() const;
	/** Gets the local port. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "GGPO")
	int32 GetLocalPort() const;
};


#ifdef __cplusplus
extern "C" {
#endif


// On windows, export at build time and import at runtime.
// ELF systems don't need an explicit export/import.
#ifdef _WIN32
#  if defined(GGPO_SHARED_LIB)
#  ifdef GGPO_SDK_EXPORT
#       define GGPO_API __declspec(dllexport)
#     else
#       define GGPO_API __declspec(dllimport)
#     endif
#  else
#     define GGPO_API
#  endif
#else
#  define GGPO_API
#endif

#define GGPO_MAX_PLAYERS                  4
#define GGPO_MAX_PREDICTION_FRAMES        8
#define GGPO_MAX_SPECTATORS              32

#define GGPO_SPECTATOR_INPUT_INTERVAL     4

typedef struct GGPOSession GGPOSession;

typedef int32 GGPOPlayerHandle;

/*
 * The GGPOPlayer structure used to describe players in ggpo_add_player
 *
 * size: Should be set to the sizeof(GGPOPlayer)
 *
 * type: One of the GGPOPlayerType values describing how inputs should be handled
 *       Local players must have their inputs updated every frame via
 *       ggpo_add_local_inputs.  Remote players values will come over the
 *       network.
 *
 * player_num: The player number.  Should be between 1 and the number of players
 *       In the game (e.g. in a 2 player game, either 1 or 2).
 *
 * If type == GGPOPlayerType::REMOTE:
 * 
 * u.remote.ip_address:  The ip address of the ggpo session which will host this
 *       player.
 *
 * u.remote.port: The port where udp packets should be sent to reach this player.
 *       All the local inputs for this session will be sent to this player at
 *       ip_address:port.
 *
 */

typedef struct GGPOPlayer
{
	int size;
	GGPOPlayerType type;
	int player_num;
	int connection_id;
} GGPOPlayer;

typedef struct GGPOLocalEndpoint
{
	int player_num;
} GGPOLocalEndpoint;


#define GGPO_ERRORLIST                                               \
   GGPO_ERRORLIST_ENTRY(GGPO_OK,                               0)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_SUCCESS,                0)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_GENERAL_FAILURE,        -1)   \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_INVALID_SESSION,        1)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_INVALID_PLAYER_HANDLE,  2)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_PLAYER_OUT_OF_RANGE,    3)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_PREDICTION_THRESHOLD,   4)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_UNSUPPORTED,            5)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_NOT_SYNCHRONIZED,       6)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_IN_ROLLBACK,            7)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_INPUT_DROPPED,          8)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_PLAYER_DISCONNECTED,    9)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_TOO_MANY_SPECTATORS,   10)    \
   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_INVALID_REQUEST,       11)

#define GGPO_ERRORLIST_ENTRY(name, value)       name = value,

typedef enum
{
	GGPO_ERRORLIST
} GGPOErrorCode;
#undef GGPO_ERRORLIST_ENTRY

#define GGPO_SUCCEEDED(result)      ((result) == GGPO_ERRORCODE_SUCCESS)


#define GGPO_INVALID_HANDLE      (-1)


/*
 * The GGPOEventCode enumeration describes what type of event just happened.
 *
 * GGPO_EVENTCODE_CONNECTED_TO_PEER - Handshake with the game running on the
 * other side of the network has been completed.
 * 
 * GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER - Beginning the synchronization
 * process with the client on the other end of the networking.  The count
 * and total fields in the u.synchronizing struct of the GGPOEvent
 * object indicate progress.
 *
 * GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER - The synchronziation with this
 * peer has finished.
 *
 * GGPO_EVENTCODE_RUNNING - All the clients have synchronized.  You may begin
 * sending inputs with ggpo_synchronize_inputs.
 *
 * GGPO_EVENTCODE_DISCONNECTED_FROM_PEER - The network connection on 
 * the other end of the network has closed.
 *
 * GGPO_EVENTCODE_TIMESYNC - The time synchronziation code has determined
 * that this client is too far ahead of the other one and should slow
 * down to ensure fairness.  The u.timesync.frames_ahead parameter in
 * the GGPOEvent object indicates how many frames the client is.
 *
 */
typedef enum
{
	GGPO_EVENTCODE_CONNECTED_TO_PEER = 1000,
	GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER = 1001,
	GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER = 1002,
	GGPO_EVENTCODE_RUNNING = 1003,
	GGPO_EVENTCODE_DISCONNECTED_FROM_PEER = 1004,
	GGPO_EVENTCODE_TIMESYNC = 1005,
	GGPO_EVENTCODE_CONNECTION_INTERRUPTED = 1006,
	GGPO_EVENTCODE_CONNECTION_RESUMED = 1007,
	GGPO_EVENTCODE_TIMESYNC_BEHIND = 1008,
} GGPOEventCode;

/*
 * The GGPOEvent structure contains an asynchronous event notification sent
 * by the on_event callback.  See GGPOEventCode, above, for a detailed
 * explanation of each event.
 */
typedef struct
{
	GGPOEventCode code;

	union
	{
		struct
		{
			GGPOPlayerHandle player;
		} connected;

		struct
		{
			GGPOPlayerHandle player;
			int count;
			int total;
		} synchronizing;

		struct
		{
			GGPOPlayerHandle player;
		} synchronized;

		struct
		{
			GGPOPlayerHandle player;
		} disconnected;

		struct
		{
			int frames_ahead;
		} timesync;

		struct
		{
			GGPOPlayerHandle player;
			int disconnect_timeout;
		} connection_interrupted;

		struct
		{
			GGPOPlayerHandle player;
		} connection_resumed;
	} u;
} GGPOEvent;


// If C++11, use std::function instead of function pointers for GGPOSessionCallbacks
#if __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1900)

// Close extern "C"
};

/*
 * The GGPOSessionCallbacks structure contains the callback functions that
 * your application must implement.  GGPO.net will periodically call these
 * functions during the game.  All callback functions must be implemented.
 */
struct GGPOSessionCallbacks
{
	/*
	 * begin_game callback - This callback has been deprecated.  You must
	 * implement it, but should ignore the 'game' parameter.
	 */
	std::function<bool(const char* game)> begin_game;

	/*
	 * save_game_state - The client should allocate a buffer, copy the
	 * entire contents of the current game state into it, and copy the
	 * length into the *len parameter.  Optionally, the client can compute
	 * a checksum of the data and store it in the *checksum argument.
	 */
	std::function<bool(unsigned char** buffer, int* len, int* checksum, int frame)> save_game_state;

	/*
	 * load_game_state - GGPO.net will call this function at the beginning
	 * of a rollback.  The buffer and len parameters contain a previously
	 * saved state returned from the save_game_state function.  The client
	 * should make the current game state match the state contained in the
	 * buffer.
	 */
	std::function<bool(unsigned char* buffer, int len)> load_game_state;

	/*
	 * log_game_state - Used in diagnostic testing.  The client should use
	 * the ggpo_log function to write the contents of the specified save
	 * state in a human readible form.
	 */
	std::function<bool(const char* filename, unsigned char* buffer, int len)> log_game_state;

	/*
	 * free_buffer - Frees a game state allocated in save_game_state.  You
	 * should deallocate the memory contained in the buffer.
	 */
	std::function<void(void* buffer)> free_buffer;

	/*
	 * advance_frame - Called during a rollback.  You should advance your game
	 * state by exactly one frame.  Before each frame, call ggpo_synchronize_input
	 * to retrieve the inputs you should use for that frame.  After each frame,
	 * you should call ggpo_advance_frame to notify GGPO.net that you're
	 * finished.
	 *
	 * The flags parameter is reserved.  It can safely be ignored at this time.
	 */
	std::function<bool(int flags)> advance_frame;

	/*
	 * on_event - Notification that something has happened.  See the GGPOEventCode
	 * structure above for more information.
	 */
	std::function<bool(GGPOEvent* info)> on_event;
};

extern "C" {
#else

/*
 * The GGPOSessionCallbacks structure contains the callback functions that
 * your application must implement.  GGPO.net will periodically call these
 * functions during the game.  All callback functions must be implemented.
 */
 typedef struct {
     /*
      * begin_game callback - This callback has been deprecated.  You must
      * implement it, but should ignore the 'game' parameter.
      */
     bool(__cdecl* begin_game)(const char* game);

     /*
      * save_game_state - The client should allocate a buffer, copy the
      * entire contents of the current game state into it, and copy the
      * length into the *len parameter.  Optionally, the client can compute
      * a checksum of the data and store it in the *checksum argument.
      */
     bool(__cdecl* save_game_state)(unsigned char** buffer, int* len, int* checksum, int frame);

     /*
      * load_game_state - GGPO.net will call this function at the beginning
      * of a rollback.  The buffer and len parameters contain a previously
      * saved state returned from the save_game_state function.  The client
      * should make the current game state match the state contained in the
      * buffer.
      */
     bool(__cdecl* load_game_state)(unsigned char* buffer, int len);

     /*
      * log_game_state - Used in diagnostic testing.  The client should use
      * the ggpo_log function to write the contents of the specified save
      * state in a human readible form.
      */
     bool(__cdecl* log_game_state)(char* filename, unsigned char* buffer, int len);

     /*
      * free_buffer - Frees a game state allocated in save_game_state.  You
      * should deallocate the memory contained in the buffer.
      */
     void(__cdecl* free_buffer)(void* buffer);

     /*
      * advance_frame - Called during a rollback.  You should advance your game
      * state by exactly one frame.  Before each frame, call ggpo_synchronize_input
      * to retrieve the inputs you should use for that frame.  After each frame,
      * you should call ggpo_advance_frame to notify GGPO.net that you're
      * finished.
      *
      * The flags parameter is reserved.  It can safely be ignored at this time.
      */
     bool(__cdecl* advance_frame)(int flags);

     /*
      * on_event - Notification that something has happened.  See the GGPOEventCode
      * structure above for more information.
      */
     bool(__cdecl* on_event)(GGPOEvent* info);
 } GGPOSessionCallbacks;

#endif


class GGPOUE4_API GGPONet
{
public:
	/*
	 * ggpo_start_session --
	 *
	 * Used to being a new GGPO.net session.  The ggpo object returned by ggpo_start_session
	 * uniquely identifies the state for this session and should be passed to all other
	 * functions.
	 *
	 * session - An out parameter to the new ggpo session object.
	 *
	 * cb - A GGPOSessionCallbacks structure which contains the callbacks you implement
	 * to help GGPO.net synchronize the two games.  You must implement all functions in
	 * cb, even if they do nothing but 'return true';
	 *
	 * game - The name of the game.  This is used internally for GGPO for logging purposes only.
	 *
	 * num_players - The number of players which will be in this game.  The number of players
	 * per session is fixed.  If you need to change the number of players or any player
	 * disconnects, you must start a new session.
	 *
	 * input_size - The size of the game inputs which will be passsed to ggpo_add_local_input.
	 *
	 * local_port - The port GGPO should bind to for UDP traffic.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_start_session(GGPOSession** session,
	                                                         GGPOSessionCallbacks* cb,
	                                                         ConnectionManager* connection_manager,
	                                                         const char* game,
	                                                         int num_players,
	                                                         int input_size);


	/*
	 * ggpo_add_player --
	 *
	 * Must be called for each player in the session (e.g. in a 3 player session, must
	 * be called 3 times).
	 *
	 * player - A GGPOPlayer struct used to describe the player.
	 *
	 * handle - An out parameter to a handle used to identify this player in the future.
	 * (e.g. in the on_event callbacks).
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_add_player(GGPOSession* session,
	                                                      GGPOPlayer* player,
	                                                      GGPOPlayerHandle* handle);


	/*
	 * ggpo_start_synctest --
	 *
	 * Used to being a new GGPO.net sync test session.  During a sync test, every
	 * frame of execution is run twice: once in prediction mode and once again to
	 * verify the result of the prediction.  If the checksums of your save states
	 * do not match, the test is aborted.
	 *
	 * cb - A GGPOSessionCallbacks structure which contains the callbacks you implement
	 * to help GGPO.net synchronize the two games.  You must implement all functions in
	 * cb, even if they do nothing but 'return true';
	 *
	 * game - The name of the game.  This is used internally for GGPO for logging purposes only.
	 *
	 * num_players - The number of players which will be in this game.  The number of players
	 * per session is fixed.  If you need to change the number of players or any player
	 * disconnects, you must start a new session.
	 *
	 * input_size - The size of the game inputs which will be passsed to ggpo_add_local_input.
	 *
	 * frames - The number of frames to run before verifying the prediction.  The
	 * recommended value is 1.
	 *
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_start_synctest(GGPOSession** session,
	                                                          GGPOSessionCallbacks* cb,
	                                                          const char* game,
	                                                          int num_players,
	                                                          int input_size,
	                                                          int frames);


	/*
	 * ggpo_start_spectating --
	 *
	 * Start a spectator session.
	 *
	 * cb - A GGPOSessionCallbacks structure which contains the callbacks you implement
	 * to help GGPO.net synchronize the two games.  You must implement all functions in
	 * cb, even if they do nothing but 'return true';
	 *
	 * game - The name of the game.  This is used internally for GGPO for logging purposes only.
	 *
	 * num_players - The number of players which will be in this game.  The number of players
	 * per session is fixed.  If you need to change the number of players or any player
	 * disconnects, you must start a new session.
	 *
	 * input_size - The size of the game inputs which will be passsed to ggpo_add_local_input.
	 *
	 * local_port - The port GGPO should bind to for UDP traffic.
	 *
	 * host_ip - The IP address of the host who will serve you the inputs for the game.  Any
	 * player partcipating in the session can serve as a host.
	 *
	 * host_port - The port of the session on the host
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_start_spectating(GGPOSession** session,
	                                                            GGPOSessionCallbacks* cb,
	                                                            ConnectionManager* connection_manager,
	                                                            const char* game,
	                                                            int num_players,
	                                                            int input_size,
	                                                            int connection_id);

	/*
	 * ggpo_close_session --
	 * Used to close a session.  You must call ggpo_close_session to
	 * free the resources allocated in ggpo_start_session.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_close_session(GGPOSession*);


	/*
	 * ggpo_set_frame_delay --
	 *
	 * Change the amount of frames ggpo will delay local input.  Must be called
	 * before the first call to ggpo_synchronize_input.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_set_frame_delay(GGPOSession*,
	                                                           GGPOPlayerHandle player,
	                                                           int frame_delay);

	/*
	 * ggpo_idle --
	 * Should be called periodically by your application to give GGPO.net
	 * a chance to do some work.  Most packet transmissions and rollbacks occur
	 * in ggpo_idle.
	 *
	 * timeout - The amount of time GGPO.net is allowed to spend in this function,
	 * in milliseconds.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_idle(GGPOSession*,
	                                                int timeout);

	/*
	 * ggpo_add_local_input --
	 *
	 * Used to notify GGPO.net of inputs that should be trasmitted to remote
	 * players.  ggpo_add_local_input must be called once every frame for
	 * all player of type GGPOPlayerType::LOCAL.
	 *
	 * player - The player handle returned for this player when you called
	 * ggpo_add_local_player.
	 *
	 * values - The controller inputs for this player.
	 *
	 * size - The size of the controller inputs.  This must be exactly equal to the
	 * size passed into ggpo_start_session.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_add_local_input(GGPOSession*,
	                                                           GGPOPlayerHandle player,
	                                                           void* values,
	                                                           int size);

	/*
	 * ggpo_synchronize_input --
	 *
	 * You should call ggpo_synchronize_input before every frame of execution,
	 * including those frames which happen during rollback.
	 *
	 * values - When the function returns, the values parameter will contain
	 * inputs for this frame for all players.  The values array must be at
	 * least (size * players) large.
	 *
	 * size - The size of the values array.
	 *
	 * disconnect_flags - Indicated whether the input in slot (1 << flag) is
	 * valid.  If a player has disconnected, the input in the values array for
	 * that player will be zeroed and the i-th flag will be set.  For example,
	 * if only player 3 has disconnected, disconnect flags will be 8 (i.e. 1 << 3).
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_synchronize_input(GGPOSession*,
	                                                             void* values,
	                                                             int size,
	                                                             int* disconnect_flags);

	/*
	 * ggpo_disconnect_player --
	 *
	 * Disconnects a remote player from a game.  Will return GGPO_ERRORCODE_PLAYER_DISCONNECTED
	 * if you try to disconnect a player who has already been disconnected.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_disconnect_player(GGPOSession*,
	                                                             GGPOPlayerHandle player);

	/*
	 * ggpo_advance_frame --
	 *
	 * You should call ggpo_advance_frame to notify GGPO.net that you have
	 * advanced your gamestate by a single frame.  You should call this everytime
	 * you advance the gamestate by a frame, even during rollbacks.  GGPO.net
	 * may call your save_state callback before this function returns.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_advance_frame(GGPOSession*);

	/*
	 * ggpo_get_network_stats --
	 *
	 * Used to fetch some statistics about the quality of the network connection.
	 *
	 * player - The player handle returned from the ggpo_add_player function you used
	 * to add the remote player.
	 *
	 * stats - Out parameter to the network statistics.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_get_network_stats(GGPOSession*,
	                                                             GGPOPlayerHandle player,
	                                                             FGGPONetworkStats* stats);


	/*
	 * ggpo_set_disconnect_timeout --
	 *
	 * Sets the disconnect timeout.  The session will automatically disconnect
	 * from a remote peer if it has not received a packet in the timeout window.
	 * You will be notified of the disconnect via a GGPO_EVENTCODE_DISCONNECTED_FROM_PEER
	 * event.
	 *
	 * Setting a timeout value of 0 will disable automatic disconnects.
	 *
	 * timeout - The time in milliseconds to wait before disconnecting a peer.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_set_disconnect_timeout(GGPOSession*,
	                                                                  int timeout);

	/*
	 * ggpo_set_disconnect_notify_start --
	 *
	 * The time to wait before the first GGPO_EVENTCODE_NETWORK_INTERRUPTED timeout
	 * will be sent.
	 *
	 * timeout - The amount of time which needs to elapse without receiving a packet
	 *           before the GGPO_EVENTCODE_NETWORK_INTERRUPTED event is sent.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_set_disconnect_notify_start(GGPOSession*,
	                                                                       int timeout);

	/*
	 * ggpo_try_synchronize_local --
	 *
	 * Attempts to skip waiting for a synchronize message, if the session is single
	 * player with no spectators ie. completely local.
	 */
	static GGPO_API GGPOErrorCode __cdecl ggpo_try_synchronize_local(GGPOSession* ggpo);
};

typedef long long ggpo_milliseconds_t;
#define GGPONET_CONVENTION __cdecl

#ifdef __cplusplus
};
#endif

```

`Plugins/NightSkyEngine/Source/GGPOUE4/README.md`:

```md
# GGPOUE4

A port of [GGPO](http://ggpo.net) to an Unreal Engine 4 plugin. This was branched from ErebusWolf's ggpo repo with network abstraction [here](https://github.com/erebuswolf/ggpo-Unreal-Plugin-with-Network-Abstraction), which was in turn branched from BwdYeti's great initial work on this repo [here](https://github.com/BwdYeti/GGPOUE4).

## Setup & Usage

Add to the Plugins folder of your Unreal project.

See [doc/README.md](doc/README.md), [doc/DeveloperGuide.md](doc/DeveloperGuide.md), and the [GGPO GitHub](https://github.com/pond3r/ggpo) for more information.

### Sample Application

Use branched repo of BwdYeti's [VectorWar UE4](https://github.com/erebuswolf/VectorWarUE4) which is a port of the GGPO sample game VectorWar, using GGPOUE4 for netcode.

### Issues

Currently the Connection Manager abstraction interface only has ip based connections implimented which only work on windows. Adding support for Steam and Epic network communication libraries is completely possible with this codebase, but requries setting up a project with those backends and testing which I do not currently have time for.

## Licensing

GGPO is available under The MIT License. This means GGPO is free for commercial and non-commercial use. Attribution is not required, but appreciated. 

```

`Plugins/NightSkyEngine/Source/GGPOUE4/doc/DeveloperGuide.ja.md`:

```md
# GGPO開発者ガイド

GGPOネットワークライブラリ開発者ガイドは、アプリケーションにGGPOネットワークライブラリを実装する開発者向けに用意されたドキュメントです。

## ゲームステートと入力

ゲームには数多くの変化するパートがあるかと思います。GGPOは次の2つだけに依存します。

- **ゲームステート**はゲームでの全ての状態を表します。シューティングゲームの場合、画面上にある自機と敵機の位置、ショットや敵弾の位置、敵機の体力、現在のスコアなどになります。

- **ゲーム入力**はゲームステートを変更する一連のものを指します。言うまでもなく、プレイヤーが操作したジョイスティックやボタンの押下が含まれますが、入力以外のものも含みます。例えば、現在時刻を使って何かを計算した場合、フレームを開始した時の時刻も入力になります。

ゲームエンジンにはゲームステートでも入力でもないものが他にもたくさんあります。例えばオーディオやビデオレンダラーはゲームの結果に影響を与えないため、ゲームステートではありません。ゲームに影響を与えない特殊効果を生成する特殊効果エンジンがあったとしたら、それもゲームステートから除外できます。

## 同期にステートと入力を使用する

GGPOを使ったゲームで遊ぶ各プレイヤーは、プレイしているゲームの完全なコピーを持っています。両プレイヤーが同じゲーム内容で遊べるよう、保持しているゲームステートのコピーを同期し続ける必要があります。フレームが進む度にプレイヤー間でゲームステートの全コピーを送信するのは大きな負荷になります。代わりにGGPOはお互いの入力を送信し、各プレイヤーのゲームを進めます。これが機能するには、ゲームエンジンが3つの条件を満たしている必要があります。

- ゲームのシミュレーションは完全に決定的でなければなりません。つまり、特定のゲームステートと入力があった時に、ゲームステートを1フレーム進めると全プレイヤーのゲームステートが同じにならなければいけません。
- ゲームステートが完全にカプセル化され、シリアライズが可能であること。
- ゲームエンジンはそのフレームのゲーム内容をレンダリングすることなく、復元、保存、フレームのシミュレーションができなくてはなりません。これはロールバックを実装するために使用されます。

## プログラミングガイド

次のセクションではあなたのアプリケーションをGGPO上で動作させるための一連の流れを紹介しています。GGPO APIの詳細な説明については、以下のGGPOリファレンスセクションを参照してください。

### GGPOとの繋ぎ込み

GGPOは新規および既存のゲームエンジンと簡単に繋ぎ込みができるよう設計されています。`GGPOSessionCallbacks`フックを介してアプリケーションを呼び出すことにより、ほとんどのロールバックの実装を行います。

### GGPOSessionオブジェクトの生成

`GGPOSession`オブジェクトはGGPOフレームワークへのインターフェースです。ローカルのポートと、対戦したいプレイヤーのIPアドレスとポートを`ggponet_start_session`関数を渡して作成します。またゲームステートを管理するコールバック関数で満たされた`GGPOSessionCallbacks`オブジェクトと、このセッションで遊ぶプレイヤーの数を渡す必要があります。全ての`GGPOSessionCallback`関数を実装しなければなりません。詳細は以下を参照してください。
例えば、ポート8001にバインドされた別のプレイヤーと同じホストで新しいセッションを開始する場合、次のようになります。

```
   GGPOSession ggpo;
   GGPOErrorCode result;
   GGPOSessionCallbacks cb;

   /* fill in all callback functions */
   cb.begin_game = vw_begin_game_callback;
   cb.advance_frame = vw_advance_frame_callback;
   cb.load_game_state = vw_load_game_state_callback;
   cb.save_game_state = vw_save_game_state_callback;
   cb.free_buffer = vw_free_buffer;
   cb.on_event = vw_on_event_callback;

   /* Start a new session */
   result = ggpo_start_session(&ggpo,         // the new session object
                               &cb,           // our callbacks
                               "test_app",    // application name
                               2,             // 2 players
                               sizeof(int),   // size of an input packet
                               8001);         // our local udp port
```



`GGPOSession`オブジェクトは単一のゲームセッションだけに使われるべきです。別の相手と接続する必要がある場合、`ggpo_close_session`を使用して既存のオブジェクトを閉じ、新しいオブジェクトを開始します。

```
   /* Close the current session and start a new one */
   ggpo_close_session(ggpo);
```

### プレイヤーの場所を送信する

GGPOSessionオブジェクトを作成した時、ゲームに参加しているプレイヤーの数を渡しましたが、実際にそれらを連携をする方法について説明していませんでした。これを行うには、各プレイヤーを表す`GGPOPlayer`オブジェクトを`ggpo_add_player`関数に渡して呼び出します。次の例は、2人用のゲームでの`ggpo_add_player`の使い方です。

```
GGPOPlayer p1, p2;
GGPOPlayerHandle player_handles[2];

p1.size = p2.size = sizeof(GGPOPlayer);
p1.type = GGPO_PLAYERTYPE_LOCAL;                // local player
p2.type = GGPO_PLAYERTYPE_REMOTE;               // remote player
strcpy(p2.remote.ip_address, "192.168.0.100");  // ip addess of the player
p2.remote.ip_address.port = 8001;               // port of that player

result = ggpo_add_player(ggpo, &p1,  &player_handles[0]);
...
result = ggpo_add_player(ggpo, &p2,  &player_handles[1]);
```

### ローカルと遠隔プレイヤーによる入力の同期

入力の同期は各ゲームフレームの最初に行われます。各ローカルプレイヤーに対する`ggpo_add_local_input`の呼び出しと、遠隔プレイヤーの入力を取得する`ggpo_synchronize_input`の呼び出しによって行われます。
`ggpo_synchronize_inputs`の戻り値は必ず確認するようにしてください。`GGPO_OK`以外の値が返ってきた場合、ゲームステートを進めないでください。これは通常、GGPOがしばらくの間、遠隔プレイヤーからパケットを受信せず、内部の予測制限に達したことで発生します。

例えば、ローカルゲームのコードが次のようになっている場合、

```
   GameInputs &p1, &p2;
   GetControllerInputs(0, &p1); /* read p1's controller inputs */
   GetControllerInputs(1, &p2); /* read p2's controller inputs */
   AdvanceGameState(&p1, &p2, &gamestate); /* send p1 and p2 to the game */
```

次のように変更する必要があります。

```
   GameInputs p[2];
   GetControllerInputs(0, &p[0]); /* read the controller */

   /* notify ggpo of the local player's inputs */
   result = ggpo_add_local_input(ggpo,               // the session object
                                 player_handles[0],  // handle for p1
                                 &p[0],              // p1's inputs
                                 sizeof(p[0]));      // size of p1's inputs

   /* synchronize the local and remote inputs */
   if (GGPO_SUCCEEDED(result)) {
      result = ggpo_synchronize_inputs(ggpo,         // the session object
                                       p,            // array of inputs
                                       sizeof(p));   // size of all inputs
      if (GGPO_SUCCEEDED(result)) {
         /* pass both inputs to our advance function */
         AdvanceGameState(&p[0], &p[1], &gamestate);
      }
   }
```

ロールバック中に発生したものも含め、全てのフレームで`ggpo_synchronize_inputs`を呼び出す必要があります。ゲームステートを進めるためには、ローカルコントローラーから得られた値を読むのではなく、常に`ggpo_synchronize_inputs`から返された値を使用してください。ロールバック中に`ggpo_synchronize_inputs`は`ggpo_add_local_input`に渡された値を前のフレームに使われた値に置き換えます。また、ロールバックの影響を緩和するためにローカルプレイヤー向けの入力遅延を加えた場合、`ggpo_add_local_input`に渡された入力はフレーム遅延が終わるまで`ggpo_synchronize_inputs`に返されません。

### 保存、復元、解放コールバックの実装

GGPOはゲームステートを定期的に保存または復元するために、`load_game_state`と`save_game_state`コールバックを使用します。`save_game_state`関数はゲームの現在のステートを復元し、それを`buffer`出力パラメーターで返すのに十分な情報を含むバッファーを作成する必要があります。`load_game_state`関数は以前に保存したバッファーからゲームステートを復元します。例えば、

```
struct GameState gamestate;  // Suppose the authoritative value of our game's state is in here.

bool __cdecl
ggpo_save_game_state_callback(unsigned char **buffer, int *len,
                              int *checksum, int frame)
{
   *len = sizeof(gamestate);
   *buffer = (unsigned char *)malloc(*len);
   if (!*buffer) {
      return false;
   }
   memcpy(*buffer, &gamestate, *len);
   return true;
}

bool __cdecl
ggpo_load_game_state_callback(unsigned char *buffer, int len)
{
   memcpy(&gamestate, buffer, len);
   return true;
}
```

不要になったら、GGPOは`free_buffer`コールバックを呼び出して、`save_game_state`コールバックで割り当てたメモリを解放します。

```
void __cdecl 
ggpo_free_buffer(void *buffer)
{
   free(buffer);
}
```

### 残っているコールバックの実装

前述のように、`GGPOSessionCallbacks`構造体にはオプション扱いのコールバックはありません。これらは少なくとも`return true`である必要がありますが、残りのコールバックは必ずしもすぐに実装する必要はありません。詳細については`ggponet.h`のコメントを参照してください。

### ggpo_advance_frameとggpo_idle関数の呼び出し

いよいよ終わりに近づいてきました。大丈夫、お約束します。最後のステップはゲームステートを1フレーム進める度にGGPOへ通知することです。1フレームを終えた後、次のフレームを開始する前に`ggpo_advance_frame`を呼び出すだけです。

GGPOは内部記録を行うパケットを送受信するために、一定の時間が必要になります。GGPOに許可したミリ秒単位で、最低でもフレームごとに1回は`ggpo_idle`関数を呼び出す必要があります。

## アプリケーションのチューニング: フレーム遅延 vs 投機的実行

GGPOは遅延を感じさせないようにするために、フレーム遅延と投機的実行の両方を使用します。これは、アプリケーション開発者が入力を遅延させるフレーム数を選択できるようにすることで実現します。もしゲームのフレーム数よりパケットの送信に時間がかかった場合、GGPOは投機的実行を使って残りの遅延を隠します。この数値は、必要に応じてゲーム中でも調整することができます。フレーム遅延の適切な値はゲームに大きく依存します。役に立つヒントをいくつか紹介しましょう。

まずはゲームを遊ぶ感覚に影響を与えない範囲で、フレーム遅延を出来るだけ大きく設定してみてください。例えば格闘ゲームではドット単位の精度、寸分違わぬタイミング、非常に正確なアーケードコントローラーの操作が必要となります。このタイプのゲームでは、ほとんどの中級プレイヤーは2フレームの遅延に気付き、上級プレイヤーであれば1フレームの遅延に気付くこともあります。一方、厳密な操作を必要としないボードゲームやパズルゲームであれば、4～5のフレーム遅延を設定すればユーザーが気付く前に上手くゲームを進められるかもしれません。

フレーム遅延を大きく設定するもうひとつの理由は、ロールバック中に発生し得るグリッチ(不具合)を排除することにあります。ロールバックが長くなればなるほど、間違った予測フレームを一時的に実行したことによって生じた、本来存在しないシーンを継ぎ接ぎした様子が表示される可能性が高くなります。例えば、ユーザーがボタンを押した瞬間に2フレームの画面フラッシュが起きるゲームがあったとします。フレーム遅延を1に設定し、パケット送信に4フレームかかった場合、ロールバックは約3フレーム分(4 - 1 = 3)になります。フラッシュがロールバックの最初のフレームで発生した場合、2フレームのフラッシュはロールバックによって完全に消失してしまい、遠隔で遊ぶプレイヤーはフラッシュ演出を見ることができなくなります。この場合、さらに大きなフレーム遅延値を設定するか、ロールバック発生後までフラッシュを遅らせるようビデオレンダラーを再設計するのが良いでしょう。

## サンプルアプリケーション

ソースディレクトリ内のVector Warには、GGPOを使った2つのクライアントを同期する単純なアプリケーションが含まれています。コマンドライン引数は以下の通りです。

```
vectorwar.exe  <localport>  <num players> ('local' | <remote ip>:<remote port>) for each player
```

2～4プレイヤーでのゲーム開始方法の例については、binディレクトリにある.cmdファイルを参照してください。

## ベストプラクティスとトラブルシューティング

以下はアプリケーションをGGPO上で動作させる際に検討したいベストプラクティスの一覧です。これら推奨事項は、まだゲームを作り初めていない段階でも簡単に理解できます。多くのアプリケーションは既にほとんどの推奨事項を満たしています。

### ゲームステートを非ゲームステートから分離する

GGPOは定期的にゲームステート全体の保存と復元を要求します。ほとんどのゲームにおいて、保存が必要なステートはゲーム全体のごく一部です。通常、ビデオやオーディオレンダラー、テーブルの検索、テクスチャー、サウンドデータ、コードセグメントは、フレームごとに不変であるか、ゲームステートの計算には影響しません。これらを保存または復元する必要はありません。

できるだけゲーム以外の状態をゲームステートから分離する必要があります。例えば、全ゲームステートをC言語の構造体にカプセル化することを考えるかもしれません。これは、ゲームステートであるものとそうでないものが明確に区別され、保存と復元のコールバック実装が簡単になります(詳細についてはリファレンスガイドを参照してください)。

### ゲームステートを進める際の固定時間を定義する

GGPOは、フレームごとにアプリケーションのロールバックとシングルステップ実行を必要とすることがあります。もしゲームステートを可変ティックレートで進めている場合、実行は困難になります。レンダーループがそうでない場合でも、フレームごとに固定時間単位でゲームステートを進めるようにしてください。

### ゲームループ内にあるレンダリングからゲームステートの更新を分離する

GGPOはロールバック中に、advance frameコールバックを何度も呼び出します。ロールバック中に発生するエフェクトやサウンドはロールバックが完了するまで先延ばしする必要があります。これはゲームステートとレンダーステートを分離することで最も簡単に実現できます。分離が出来たら、ゲームループは次のようになるでしょう。

```
   Bool finished = FALSE;
   GameState state;
   Inputs inputs;

   do {
      GetControllerInputs(&inputs);
      finished = AdvanceGameState(&inputs, &state);
      if (!finished) {
         RenderCurrentFrame(&gamestate);
      }
   while (!finished);
```

言い換えると、ゲームステートは入力のみで決定され、レンダリングは現在のゲームステートによって実行される必要があります。また、レンダリングせずに一連の入力を元にゲームステートを簡単に進める方法が必要です。

### ゲームステートの進行が決定的であることを確認する

ゲームステートを特定したら、次のゲームステートが入力のみから計算されることを確認します。これは、全てのゲームステートと入力を正しく識別できていれば自然とそうなりますが、時には注意が必要です。見落とされがちなことをいくつか紹介します。

#### 乱数ジェネレーターに気を付ける

次のゲームステートを計算するうえで、多くのゲームは乱数を使用します。もし乱数を使う場合、それらが完全に決定的であること、乱数ジェネレーターのシードが両プレイヤーの0フレーム目で同じであること、乱数ジェネレーターの状態がゲームステートに含まれていることを確認してください。これらのことが行われていれば、特定のフレームに対して生成される乱数は、GGPOがそのフレームをロールバックする回数に関係なく、常に同じ値になります。

#### 外部の時刻情報(壁時計時間)に気を付ける

ゲームステートの計算に現在時刻を使う場合は注意してください。ゲームに影響を与えたり、別のゲームステートに導く可能性があります(例: 乱数ジェネレーターのシードにタイマーを使う)。2台のコンピューターまたはゲームコンソールの時刻が同期することはほとんどないため、ゲームステートの計算に時刻を使用すると同期のトラブルに繋がります。ゲームステートに時刻を使うのを止めるか、プレイヤーの現在時刻をフレームへの入力の一部として含め、常にその時刻を使って計算を行う必要があります。

ゲームステート以外の計算に外部の時刻情報を使う分には問題ありません(例: 画面上のエフェクト時間の計算やオーディオサンプルの減衰など)。

### ダングリングポインターに気を付ける

ゲームステートに動的に割り当てられたメモリが含まれる場合、データの保存や復元の際に十分に気を付けながらポインターの再配置を行ってください。これを緩和するひとつの方法は、ポインターの代わりにベースとオフセットを使って割り当てられたメモリを参照することです。これにより再配置が必要なポインターの数を大幅に減らすことができます。

### 静的変数や隠れたステートに気を付ける

ゲームが記述されている言語には、全てのステートの追跡を困難にさせる機能があるかもしれません。C言語の静的自動変数はこの動作の一例です。該当する全ての箇所を探し出し、保存可能な形式に変換する必要があります。例えば、以下を見比べてください。

```
   // This will totally get you into trouble.
   int get_next_counter(void) {
      static int counter = 0; /* no way to roll this back... */
      counter++;
      return counter;
   }
```

次のように書き換えます。
```
   // If you must, this is better
   static int global_counter = 0; /* move counter to a global */

   int get_next_counter(void) {
      global_counter++;
      return global_counter; /* use the global value */
   }

   bool __cdecl
   ggpo_load_game_state_callback(unsigned char *buffer, int len)
   {
      ...
      global_counter = *((int *)buffer) /* restore it in load callback */
      ...
      return true;
   }
```

### GGPOの同期テスト機能をたくさん使いましょう

あなたのアプリケーションがGGPO上で動作するようになったら、`ggpo_start_synctest`関数を使ってゲームステートの漏れによる同期問題を追跡することができます。

この同期テストセッションは、シミュレーション決定論におけるエラーを探すために設計された特別なシングルプレイヤーセッションです。同期テストセッションで実行すると、GGPOは全てのフレームに対して1フレームのロールバックを行います。フレームが最初に実行されたときのステートとロールバック中に実行されたステートを比較し、それらが異なっていた場合はエラーを発生させます。ゲーム実行中に`ggpo_log`関数を使用すると、初回フレームのログとロールバックフレームのログを比較してエラーを追跡することができます。

ゲームコードを書いている時に開発システム上で同期テストを継続的に実行することで、同期ズレの原因となったバグをすぐに見つけることができます。

## さらに詳しく知りたい方は

このドキュメントではGGPOの基本的な機能について紹介しました。さらに知りたい方は、`ggponet.h`ヘッダーにあるコメント、そしてコードを直接読むことをお勧めします。それではみなさん頑張ってください！

```

`Plugins/NightSkyEngine/Source/GGPOUE4/doc/DeveloperGuide.md`:

```md
# GGPO Developer Guide

The GGPO Network Library Developer Guide is for developers who are integrating the GGPO Network Library into their applications.

## Game State and Inputs

Your game probably has many moving parts.  GGPO only depends on these two: 

- **Game State** describes the current state of everything in your game.  In a shooter, this would include the position of the ship and all the enemies on the screen, the location of all the bullets, how much health each opponent has, the current score, etc. etc. 

- **Game Inputs** are the set of things which modify the game state.  These obviously include the joystick and button presses done by the player, but can include other non-obvious inputs as well.  For example, if your game uses the current time of day to calculate something in the game, the current time of day at the beginning of a frame is also an input.

There are many other things in your game engine that are neither game state nor inputs.  For example, your audio and video renderers are not game state since they don't have an effect on the outcome of the game.  If you have a special effects engine that's generating effects that do not have an impact on the game, they can be excluded from the game state as well.

## Using State and Inputs for Synchronization

Each player in a GGPO networked game has a complete copy of your game running.  GGPO needs to keep both copies of the game state in sync to ensure that both players are experiencing the same game.  It would be much too expensive to send an entire copy of the game state between players every frame.  Instead GGPO sends the players' inputs to each other and has each player step the game forward.  In order for this to work, your game engine must meet three criteria:

- The game simulation must be fully deterministic.  That is, for any given game state and inputs, advancing the game state by exactly 1 frame must result in identical game states for all players.
- The game state must be fully encapsulated and serializable.  
- Your game engine must be able to load, save, and execute a single simulation frame without rendering the result of that frame.  This will be used to implement rollbacks.

## Programming Guide

The following section contains a walk-through for porting your application to GGPO.  For a detailed description of the GGPO API, please see the GGPO Reference section, below.

### Interfacing with GGPO

GGPO is designed to be easy to interface with new and existing game engines.  It handles most of the implementation of handling rollbacks by calling out to your application via the `GGPOSessionCallbacks` hooks.

### Creating the GGPOSession Object

The `GGPOSession` object is your interface to the GGPO framework.  Create one with the `ggponet_start_session` function passing the port to bind to locally and the IP address and port of the player you'd like to play against.   You should also pass in a `GGPOSessionCallbacks` object filled in with your game's callback functions for managing game state and whether this session is for player 1 or player 2.  All `GGPOSessionCallback` functions must be implemented.  See the reference for more details. 
For example, to start a new session on the same host with another player bound to port 8001, you would do:

```
   GGPOSession ggpo;
   GGPOErrorCode result;
   GGPOSessionCallbacks cb;

   /* fill in all callback functions */
   cb.begin_game = vw_begin_game_callback;
   cb.advance_frame = vw_advance_frame_callback;
   cb.load_game_state = vw_load_game_state_callback;
   cb.save_game_state = vw_save_game_state_callback;
   cb.free_buffer = vw_free_buffer;
   cb.on_event = vw_on_event_callback;

   /* Start a new session */
   result = ggpo_start_session(&ggpo,         // the new session object
                               &cb,           // our callbacks
                               "test_app",    // application name
                               2,             // 2 players
                               sizeof(int),   // size of an input packet
                               8001);         // our local udp port
```



The `GGPOSession` object should only be used for a single game session.  If you need to connect to another opponent, close your existing object using `ggpo_close_session` and start a new one:

```
   /* Close the current session and start a new one */
   ggpo_close_session(ggpo);
```

### Sending Player Locations

When you created the GGPOSession object passed in the number of players participating in the game, but didn't actually describe how to contact them.  To do so, call the `ggpo_add_player` function with a `GGPOPlayer` object describing each player.   The following example show how you might use ggpo_add_player in a 2 player game:

```
GGPOPlayer p1, p2;
GGPOPlayerHandle player_handles[2];

p1.size = p2.size = sizeof(GGPOPlayer);
p1.type = GGPO_PLAYERTYPE_LOCAL;                // local player
p2.type = GGPO_PLAYERTYPE_REMOTE;               // remote player
strcpy(p2.remote.ip_address, "192.168.0.100");  // ip addess of the player
p2.remote.ip_address.port = 8001;               // port of that player

result = ggpo_add_player(ggpo, &p1,  &player_handles[0]);
...
result = ggpo_add_player(ggpo, &p2,  &player_handles[1]);
```

### Synchronizing Local and Remote Inputs

Input synchronization happens at the top of each game frame.  This is done by calling `ggpo_add_local_input` for each local player and `ggpo_synchronize_input` to fetch the inputs for remote players.
Be sure to check the return value of `ggpo_synchronize_inputs`.  If it returns a value other than `GGPO_OK`, you should not advance your game state.  This usually happens because GGPO has not received packets from the remote player in a while and has reached its internal prediction limit.

For example, if your code looks like this currently for a local game:

```
   GameInputs &p1, &p2;
   GetControllerInputs(0, &p1); /* read p1's controller inputs */
   GetControllerInputs(1, &p2); /* read p2's controller inputs */
   AdvanceGameState(&p1, &p2, &gamestate); /* send p1 and p2 to the game */
```

You should change it to read as follows:

```
   GameInputs p[2];
   GetControllerInputs(0, &p[0]); /* read the controller */

   /* notify ggpo of the local player's inputs */
   result = ggpo_add_local_input(ggpo,               // the session object
                                 player_handles[0],  // handle for p1
                                 &p[0],              // p1's inputs
                                 sizeof(p[0]));      // size of p1's inputs

   /* synchronize the local and remote inputs */
   if (GGPO_SUCCEEDED(result)) {
      result = ggpo_synchronize_inputs(ggpo,         // the session object
                                       p,            // array of inputs
                                       sizeof(p));   // size of all inputs
      if (GGPO_SUCCEEDED(result)) {
         /* pass both inputs to our advance function */
         AdvanceGameState(&p[0], &p[1], &gamestate);
      }
   }
```

You should call `ggpo_synchronize_inputs` every frame, even those that happen during a rollback.  Make sure you always use the values returned from `ggpo_synchronize_inputs` rather than the values you've read from the local controllers to advance your game state. During a rollback `ggpo_synchronize_inputs` will replace the values passed into `ggpo_add_local_input` with the values used for previous frames.  Also, if you've manually added input delay for the local player to smooth out the effect of rollbacks, the inputs you pass into `ggpo_add_local_input` won't actually be returned in `ggpo_synchronize_inputs` until after the frame delay.

### Implementing your save, load, and free Callbacks

GGPO will use the `load_game_state` and `save_game_state` callbacks to periodically save and restore the state of your game.  The `save_game_state` function should create a buffer containing enough information to restore the current state of the game and return it in the `buffer` out parameter.  The `load_game_state` function should restore the game state from a previously saved buffer.  For example:

```
struct GameState gamestate;  // Suppose the authoritative value of our game's state is in here.

bool __cdecl
ggpo_save_game_state_callback(unsigned char **buffer, int *len,
                              int *checksum, int frame)
{
   *len = sizeof(gamestate);
   *buffer = (unsigned char *)malloc(*len);
   if (!*buffer) {
      return false;
   }
   memcpy(*buffer, &gamestate, *len);
   return true;
}

bool __cdecl
ggpo_load_game_state_callback(unsigned char *buffer, int len)
{
   memcpy(&gamestate, buffer, len);
   return true;
}
```

GGPO will call your `free_buffer` callback to dispose of the memory you allocated in your `save_game_state` callback when it is no longer need.  

```
void __cdecl 
ggpo_free_buffer(void *buffer)
{
   free(buffer);
}
```

### Implementing Remaining Callbacks

As mentioned previously, there are no optional callbacks in the `GGPOSessionCallbacks` structure.  They all need to at least `return true`, but the remaining callbacks do not necessarily need to be implemented right away.  See the comments in `ggponet.h` for more information.

### Calling the GGPO Advance and Idle Functions

We're almost done.  Promise.  The last step is notify GGPO every time your gamestate finishes advancing by one frame.  Just call `ggpo_advance_frame` after you've finished one frame but before you've started the next.

GGPO also needs some amount of time to send and receive packets do its own internal bookkeeping.  At least once per-frame you should call the `ggpo_idle` function with the number of milliseconds you're allowing GGPO to spend. 

## Tuning Your Application: Frame Delay vs. Speculative Execution

GGPO uses both frame delay and speculative execution to hide latency.  It does so by allowing the application developer the choice of how many frames that they'd like to delay input by.  If it takes more time to transmit a packet than the number of frames specified by the game, GGPO will use speculative execution to hide the remaining latency.  This number can be tuned by the application mid-game if you so desire.  Choosing a proper value for the frame delay depends very much on your game.  Here are some helpful hints.

In general you should try to make your frame delay as high as possible without affecting the qualitative experience of the game.  For example, a fighting game requires pixel perfect accuracy, excellent timing, and extremely tightly controlled joystick motions.  For this type of game, any frame delay larger than 1 can be noticed by most intermediate players, and expert players may even notice a single frame of delay.  On the other hand, board games or puzzle games which do not have very strict timing requirements may get away with setting the frame latency as high as 4 or 5 before users begin to notice.

Another reason to set the frame delay high is to eliminate the glitching that can occur during a rollback. The longer the rollback, the more likely the user is to notice the discontinuities caused by temporarily executing the incorrect prediction frames.  For example, suppose your game has a feature where the entire screen will flash for exactly 2 frames immediately after the user presses a button.  Suppose further that you've chosen a value of 1 for the frame latency and the time to transmit a packet is 4 frames.  In this case, a rollback is likely to be around 3 frames (4 – 1 = 3).  If the flash occurs on the first frame of the rollback, your 2-second flash will be entirely consumed by the rollback, and the remote player will never get to see it!  In this case, you're better off either specifying a higher frame latency value or redesigning your video renderer to delay the flash until after the rollback occurs.

## Sample Application

The Vector War application in the source directory contains a simple application which uses GGPO to synchronize the two clients.  The command line arguments are:

```
vectorwar.exe  <localport>  <num players> ('local' | <remote ip>:<remote port>) for each player
```

See the .cmd files in the bin directory for examples on how to start 2, 3, and 4 player games.

## Best Practices and Troubleshooting

Below is a list of recommended best practices you should consider while porting your application to GGPO.  Many of these recommendations are easy to follow even if you're not starting a game from scratch.  Most applications will already conform to most of the recommendations below.

### Isolate Game State from Non-Game State

GGPO will periodically request that you save and load the entire state of your game.  For most games the state that needs to be saved is a tiny fraction of the entire game.  Usually the video and audio renderers, look up tables, textures, sound data and your code segments are either constant from frame to frame or not involved in the calculation of game state.  These do not need to be saved or restored.

You should isolate non-game state from the game state as much as possible.  For example, you may consider encapsulating all your game state into a single C structure.  This both clearly delineates what is game state and was is not and makes it trivial to implement the save and load callbacks (see the Reference Guide for more information).

### Define a Fixed Time Quanta for Advancing Your Game State

GGPO will occasionally need to rollback and single-step your application frame by frame.  This is difficult to do if your game state advances by a variable tick rate.  You should try to make your game state advanced by a fixed time quanta per frame, even if your render loop does not.

### Separate Updating Game State from Rendering in Your Game Loop

GGPO will call your advance frame callback many times during a rollback.  Any effects or sounds which are genearted during the rollback need to be deferred until after the rollback is finished.  This is most easily accomplished by separating your game state from your render state.  When you're finished, your game loop may look something like this:

```
   Bool finished = FALSE;
   GameState state;
   Inputs inputs;

   do {
      GetControllerInputs(&inputs);
      finished = AdvanceGameState(&inputs, &state);
      if (!finished) {
         RenderCurrentFrame(&gamestate);
      }
   while (!finished);
```

In other words, your game state should be determined solely by the inputs, your rendering code should be driven by the current game state, and you should have a way to easily advance the game state forward using a set of inputs without rendering.

### Make Sure Your Game State Advances Deterministically

Once you have your game state identified, make sure the next game state is computed solely from your game inputs.  This should happen naturally if you have correctly identified all the game state and inputs, but it can be tricky sometimes.  Here are some things which are easy to overlook:

#### Beware of Random Number Generators

Many games use random numbers in the computing of the next game state.  If you use one, you must ensure that they are fully deterministic, that the seed for the random number generator is same at frame 0 for both players, and that the state of the random number generator is included in your game state.  Doing both of these will ensure that the random numbers which get generated for a particular frame are always the same, regardless of how many times GGPO needs to rollback to that frame.

#### Beware of External Time Sources (aka. Wall clock time)

Be careful if you use the current time of day in your game state calculation.  This may be used for an effect on the game or to derive other game state (e.g. using the timer as a seed to the random number generator).  The time on two computers or game consoles is almost never in sync and using time in your game state calculations can lead to synchronization issues.  You should either eliminate the use of time in your game state or include the current time for one of the players as part of the input to a frame and always use that time in your calculations.

The use of external time sources in non-gamestate calculations is fine (e.g. computing the duration of effects on screen, or the attenuation of audio samples).

### Beware of Dangling References

If your game state contains any dynamically allocated memory be very careful in your save and load functions to rebase your pointers as you save and load your data.  One way to mitigate this is to use a base and offset to reference allocated memory instead of a pointer.  This can greatly reduce the number of pointers you need to rebase.

### Beware of Static Variables or Other Hidden State

The language your game is written in may have features which make it difficult to track down all your state.   Static automatic variables in C are an example of this behavior.  You need to track down all these locations and convert them to a form which can be saved.  For example, compare:

```
   // This will totally get you into trouble.
   int get_next_counter(void) {
      static int counter = 0; /* no way to roll this back... */
      counter++;
      return counter;
   }
```

To:
```
   // If you must, this is better
   static int global_counter = 0; /* move counter to a global */

   int get_next_counter(void) {
      global_counter++;
      return global_counter; /* use the global value */
   }

   bool __cdecl
   ggpo_load_game_state_callback(unsigned char *buffer, int len)
   {
      ...
      global_counter = *((int *)buffer) /* restore it in load callback */
      ...
      return true;
   }
```

### Use the GGPO SyncTest Feature.  A Lot.

Once you've ported your application to GGPO, you can use the `ggpo_start_synctest` function to help track down synchronization issues which may be the result of leaky game state.  

The sync test session is a special, single player session which is designed to find errors in your simulation's determinism.  When running in a synctest session, GGPO will execute a 1 frame rollback for every frame of your game.  It compares the state of the frame when it was executed the first time to the state executed during the rollback, and raises an error if they differ.  If you used the `ggpo_log` function during your game's execution, you can diff the log of the initial frame vs the log of the rollback frame to track down errors.  

By running synctest on developer systems continuously when writing game code, you can identify desync causing bugs immediately after they're introduced.

## Where to Go from Here

This document describes the most basic features of GGPO.  To learn more, I recommend starting with reading the comments in the `ggponet.h` header and just diving into the code.  Good luck!

```

`Plugins/NightSkyEngine/Source/GGPOUE4/doc/README.ja.md`:

```md
# GGPOとは

2009年に開発されたGGPOネットワーキングSDKは、P2Pゲームにおけるロールバックネットワーキング実用化の先駆けとなったシステムです。正確な入力や、フレームごとの完璧な処理を必要とし、ゲーム展開が速くかつ配信に適したゲームにおいて、ネットワーク遅延を目立たなくさせることに重点を置いて開発されました。

従来の技術はプレイヤーの入力に遅延を織り込んで通信を行っており、その結果反応が遅く、ラグを感じるプレイ感になっていました。ロールバックネットワーキングは入力予測と投機的実行を行って、プレイヤーの入力を即座に送信するため、遅延を感じさせないネット環境をもたらします。ロールバックがあれば、タイミングや相手の動きや効果音に対する反応、指が覚えている入力、これらオフラインで行えた内容が、そのままオンラインでも行えます。GGPOネットワーキングSDKは、ロールバックネットワーキングを新作や発売されているゲームに極力簡単に組み込めるよう作られています。

# 仕組み

ロールバックネットワーキングは決定的P2Pエンジンに統合できるよう設計されています。完全に決定的なエンジンなら、同じ入力をした場合にゲームは必ず同じ内容のプログラム再生をします。その内容を実現する一つの方法としては、ネットワーク上の全プレイヤーと入力のやりとりをする方法があげられますが、これは全プレイヤーがピアから入力を全て受け取った時にのみゲームプレイロジックが1フレームだけ実行される形になります。この方法ではゲーム内でキャラの動きがぎくしゃくし、反応の悪いゲーム内容になりがちです。ネットワークを介して入力を受け取る時間が長くなるほど、ゲーム展開も遅くなってしまいます。

## 入力遅延を用いたネットワーキング

### 理論上は…

下の図を見てください。2つのクライアントが遅延0msの理想的なネットワークで同期されている図になっています。1プレイヤー側の入力が青、2プレイヤー側の入力は赤、ネットワーク層は緑です。黒の矢印は入力がシステム内で送信され、ゲームステートが推移する流れを表します。各フレームは破線で区切られています。図は1プレイヤー側から見たものになっていますが、2プレイヤー側も全く同じ手順になっています。

![](images/overview_image1.png)

1プレイヤーの入力は、ネットワーク層によって2プレイヤーの入力とマージされ、ゲームエンジンに送信されます。エンジンはその入力を用いて現在のフレームのゲームステートを変更します。2プレイヤー側も同様に自分と1プレイヤーの入力をマージしてゲームエンジンに送信します。プレイヤーの入力に応じたロジックを適用し、過去のフレームのゲームステートを変更しながら、フレームごとにゲームが進行します。1プレイヤーと2プレイヤー両方が同じゲームステートで、それぞれのエンジンに送信される入力が同じなので、両プレイヤーのゲームステートは毎フレーム同期されたままになります。

### 実際は…

理想的なネットワークの例では、パケットがネットワークを介して即時に送信されるものとされていますが、現実はそう甘くはありません。一般的なブロードバンド接続では、プレイヤー間の距離や回線の品質に応じて、パケットの送信に5～150msかかります。ゲームが1秒間に60フレームで実行されるとするならば、遅延は1～9フレーム相当になります。

ゲームは両プレイヤーの入力を受信するまでフレームを処理することができないので、各プレイヤーの入力に1～9フレームの遅延、つまり「ラグ」を適用しなければなりません。遅延を考慮に入れ、先程の図を変更してみると…

![](images/overview_image3.png)

この例では、パケットの送信に3フレームかかります。2プレイヤーによって遠隔から送信された入力は、1フレーム目に1プレイヤー側に届かず、3フレーム後になるまでゲーム機に届きません。1プレイヤー側のゲームエンジンは入力を受信するまでゲームを進めることができないので、1フレーム目を3フレーム遅延せざるを得なくなります。続きのフレームも同様に3フレームの遅延が発生します。ネットワーク層は両プレイヤー間で送信されるパケットの最長転送時間だけ、マージされた入力を遅延せざるを得なくなります。理想的なネットワーク環境を除いては、大半のゲームジャンルにおいてこのラグはプレイ感に大きく影響を与えることとなります。

## ロールバックネットワーキングで入力遅延を取り除く

### 投機的実行

GGPOは投機的実行を用いることで、パケット送信に必要な遅延を隠し、入力ラグの発生を防ぎます。それでは、もう一つの図を見てみましょう。

![](images/overview_image2.png)

GGPOは遠隔のプレイヤーから入力が届くのを待つ代わりに、過去の入力に基づいて他プレイヤーが行いそうな入力を予測します。予測された入力と1プレイヤーの入力をマージし、すぐにゲームエンジンへ渡すので、仮に他プレイヤーの入力が届かなくとも次のフレームへ進めることができます。
GGPOの予測が完璧であれば、オンラインで遊ぶユーザー体験はオフラインと同一のものになります。もちろん、未来を予測することは誰にもできません！GGPOも2プレイヤーの入力を間違って予測することがあります。上の図をもう一度見てください。もしGGPOが1フレーム目に2プレイヤーに間違った入力を送信したらどうなるでしょうか。1プレイヤー側に表示される2プレイヤーの入力は、2プレイヤー側で表示されるものと異なってしまいます。両サイドのゲームは同期を失い、プレイヤーは違ったゲーム画面を見ながら相手の動きに反応することになります。同期のズレは、1プレイヤー側が2プレイヤーの正しい入力が届く4フレーム目まで検出することができませんが、それでは遅すぎます。
そういうことから、GGPOの手法は「投機的実行(speculative execution)」と呼ばれます。遊んでいるプレイヤーがその時に見ているものは正しいかもしれませんが、そうでないこともあります。GGPOが遠隔プレイヤーの入力を誤って予測した場合、次のフレームへ進める前にエラーを修正する必要があります。次の例では、その方法を説明します。

### 投機的実行エラーをロールバックで修正する

GGPOは遠隔プレイヤーの入力を間違って予測する度に、ロールバックを使ってクライアントを再同期します。「ロールバック」という単語は、ステートを巻き戻し、プレイヤーの入力に関する、より正しく新しい情報を元に結果を予測する過程を指します。前のセクションでは、遠隔の入力1における予測したフレームが間違っていたらどうなるか、ということについて考えました。それでは、GGPOがエラーを修正する過程を見てみましょう。

![](images/overview_image5.png)

GGPOは遠隔の入力を受信したら、その都度前回のフレームで予測した品質をチェックします。先程触れたように、GGPOは4フレーム目まで2プレイヤー側の入力が届きません。4フレーム目で、GGPOは以前に予測した入力とネットワークから受信した入力が一致しないことに気付きます。両サイドのゲームを再同期するため、GGPOは3フレーム分の誤った入力によって発生したダメージや間違いを取り消す必要があります。誤って予測した入力を送信する前のフレームまで戻るよう、ゲームエンジンに要求します(つまり過去のステートまで「ロールバック」します)。以前のステートを復元したら、GGPOはエンジンに正しい入力で1フレーム進めるよう要求します。このフレームは水色で示しています。ゲームエンジンはこのフレームをユーザーに見えない形で出来る限り素早く進める必要があります。例えば、ビデオレンダラーはこのフレームを画面に描写するべきではありません。オーディオレンダラーは原則、音声を生成し続けるべきですが、ロールバックが終わるまでレンダーすべきではなく、サンプルが生成されたフレームを引いた現在のフレームであるnフレームでサンプルがスタートする必要があります。
エンジンがGGPOがエラーを見つける前のフレームまで到達したら、GGPOはロールバックモードを止め、ゲームを通常どおり進めることを許可します。図の5フレームと6フレーム目はGGPOの予測が正しく行われた場合を示しています。ゲームステートが正しいので、ロールバックをする理由はありません。

# コード構造

次の図はGGPOセッションで主に動作するパーツ、また各パーツごとの関連性を示しています。各コンポーネントの詳細は以下に示しています。

![](images/overview_image4.png)

## GGPOインタフェース(GGPO Interface)

GGPOインターフェースはP2Pと同期テストバックエンド間の詳細な実装を抽象化しています。適切なバックエンドは`ggpo_start_session`か`ggpo_start_synctest`エントリーポイントを呼び出した時に、自動的に生成されます。

## P2Pバックエンド(P2P Backend)

P2Pバックエンドはプレイヤー間でゲームを調整します。`ggpo_start_session` APIの呼び出しによって生成されます。大きな情報の処理の大半は含まれているヘルパークラスによって行われます。

## ポーリングオブジェクト(Poll Object)

(図にはありません)ポーリングオブジェクトはコード内で他のオブジェクトによって用いられる登録方式です。待機可能なオブジェクトが準備できたときに通知とタイマーを送信します。例としてUDPバックエンドは新たなパケットが到着したときに、通知を受信するためポーリングオブジェクトを使用します。

## 同期オブジェクト(Sync Object)

同期オブジェクトはゲームステートのnフレームを追跡するために用いられます。埋め込まれた予測(prediction)オブジェクトが予測エラーを通知された時、同期バックエンドがより正確なステートまでゲームを巻き戻し、予測エラーを修正するためシングルステップ処理を進めます。

## 入力キューオブジェクト(Input Queue Object)

入力キューオブジェクトはローカル、または遠隔プレイヤー用に受信した全入力を追跡します。所持していない入力を要求された場合、入力キューは次の入力を予測し、後の情報を追跡します。そうすることで同期オブジェクトは予測が誤った場合にどこまでロールバックすればよいのか分かります。リクエストがあった場合、入力キューはフレーム遅延も実行します。

## UDPプロトコルオブジェクト(UDP Protocol Object)

UDPプロトコルオブジェクトは両プレイヤー間の同期と入力交換プロトコルを扱います。また、ゲーム入力の圧縮と信頼できるUDP層も実装しています。各UDPプロトコルオブジェクトにはTimeSyncオブジェクトが含まれ、プレイヤー間の時間のずれを推測するために利用しています。

## UDPオブジェクト(UDP Object)

UDPオブジェクトは単純なUDPパケットの送受信を行います。他のプラットフォームへの移植を簡単にするため、UDPプロトコルから切り離されています。

## 同期テストバックエンド(Sync Test Backend)

(図にはありません)同期テストバックエンドは、P2Pバックエンドがアプリのセーブステートと決定的に機能上実行していることを確認するときに同じ同期オブジェクトを使用します。同期テストの使用に関する詳しい情報は、開発者ガイドを参照してください。

```

`Plugins/NightSkyEngine/Source/GGPOUE4/doc/README.md`:

```md
# What's GGPO?

Created in 2009, the GGPO networking SDK pioneered the use of rollback networking in peer-to-peer games.  It's designed specifically to hide network latency in fast paced, twitch style games which require very precise inputs and frame perfect execution.

Traditional techniques account for network transmission time by adding delay to a players input, resulting in a sluggish, laggy game-feel.  Rollback networking uses input prediction and speculative execution to send player inputs to the game immediately, providing the illusion of a zero-latency network.  Using rollback, the same timings, reactions, visual and audio queues, and muscle memory your players build up playing offline will translate directly online.  The GGPO networking SDK is designed to make incorporating rollback networking into new and existing games as easy as possible.  

# How Does It Work?

Rollback networking is designed to be integrated into a fully deterministic peer-to-peer engine.  With full determinism, the game is guaranteed to play out the same way on all players computers if we simply feed them the same inputs.  One way to achieve this is to exchange inputs for all players over the network, only executing a frame of gameplay logic when all players have received all the inputs from their peers.  This often results in sluggish, unresponsive gameplay.  The longer it takes to get inputs over the network, the slower the game becomes.

## Networking Using Input Delay

### In Theory...

Take a look at the diagram below.  It shows how 2 clients are kept synchronized in an ideal network with 0 milliseconds of latency.  Player 1's inputs and game state are shown in blue, player 2's inputs are shown in red, and the network layer is shown in green.   The black arrows indicate how inputs move through the system and transitions from one game state to the next.  Each frame is separated by a horizontal, dashed line.  Although the diagram only shows what happens from the perspective of player 1, the game on player 2's end goes through the exact same steps.  

![](images/overview_image1.png)

The inputs for player 1 are merged with the inputs from player 2 by the network layer before sending them to the game engine.  The engine modifies the game state for the current frame using those inputs.  Player 2 does the same thing: merging player 1's inputs with his own before sending the combined inputs to the game engine.  The game proceeds in this manner every frame, modifying the previous frame's game state by applying logic according to the value of the the player inputs.  Since player 1 and player 2 both began with the same game state and the inputs they send to their respective engines are the same, the game states of the two players will remain synchronized on every frame.

### In Practice..

The Ideal Network example assumes that packets are transmitted over the network instantaneously.  Reality isn't quite so rosy.  Typical broadband connections take anywhere between 5 and 150 milliseconds to transmit a packet, depending on the distance between the players and the quality of the infrastructure where the players live.  That could be anywhere between 1 and 9 frames if your game runs at 60 frames per seconds.

Since the game cannot process the frame until it has received the inputs from both players, it must apply 1 to 9 frames of delay, or "lag", on each player's inputs.  Let's modify the previous diagram to take latency into account:

![](images/overview_image3.png)

In this example it takes 3 frames to transmit a packet.  This means the remote inputs sent by player 2 at frame 1 don't arrive at player 1's game console until 3 frames later.  The game engine for player 1 cannot advance until it receives the input, so it's forced to delay the frame 1 for 3 frames.  All subsequent frames are delayed by 3 frames as well.  The network layer is generally forced to delay all merged inputs by the maximum one way transit time of the packets sent between the two players.  This lag is enough to substantially affect the quality of the game play experience for many game types in all but the most ideal networking conditions.

## Removing Input Delay with Rollback Networking

### Speculative Execution

GGPO prevents the input lag by hiding the latency required to send a packet using speculative execution.  Let's see another diagram:

![](images/overview_image2.png)

Instead of waiting for the input to arrive from the remote player, GGPO predicts what the other player is likely to do based on past inputs.  It combines the predicted input with player 1's local input and immediately passes the merged inputs to your game engine so it can proceed executing the next frame, even though you have not yet received the packet containing the inputs from the other player.  
If GGPO's prediction were perfect, the user experience playing online would be identical to playing offline.  Of course, no one can predict the future!  GGPO will occasionally incorrectly predict player 2's inputs.  Take another look at the diagram above.  What happens if GGPO sent the wrong inputs for player 2 at frame 1?  The inputs for player 2 would be different on player 1's game than in player 2's.  The two games will lose synchronization and the players will be left interacting with different versions of reality.  The synchronization loss cannot possibly be discovered until frame 4 when player 1 receives the correct inputs for player 2, but by then it's too late.  
This is why GGPO's method is called "speculative execution".  What the current player sees at the current frame may be correct, but it may not be.  When GGPO incorrectly predicts the inputs for the remote player, it needs to correct that error before proceeding on to the next frame.  The next example explains how that happens.

### Correcting Speculative Execution Errors with Rollbacks

GGPO uses rollbacks to resynchronize the clients whenever it incorrectly predicts what the remote player will do.  The term "rollback" refers to the process of rewinding state and predicting new outcomes based on new, more correct information about a player's input.  In the previous section we wondered what would happen if the predicted frame for remote input 1 was incorrect.  Let's see how GGPO corrects the error:

![](images/overview_image5.png)

GGPO checks the quality of its prediction for previous frames every time it receives a remote input.  As mentioned earlier, GGPO doesn't receive the inputs for player 2's first frame until player 1's fourth.  At frame 4, GGPO notices that the inputs received from the network do not match the predicted inputs sent earlier.  To resynchronize the two games, GGPO needs to undo the damage caused by running the game with incorrect inputs for 3 frames.  It does this by asking the game engine to go back in time to a frame before the erroneously speculated inputs were sent (i.e. to "rollback" to a previous state).   Once the previous state has been restored, GGPO asks the engine to move forward one frame at a time with the corrected input stream.  These frames are shown in light blue.  Your game engine should advance through these frames as quickly as possible with no visible effect to the user.  For example, your video renderer should not draw these frames to the screen.  Your audio renderer should ideally continue to generate audio, but it should not be rendered until after the rollback, at which point samples should start playing n frames in, where n is the current frame minus the frame where the sample was generated.
Once your engine reaches the frame it was on before GGPO discovered the error, GGPO drops out of rollback mode and allows the game to proceed as normal.  Frames 5 and 6 in the diagram show what happens when GGPO predicts correctly.  Since the game state is correct, there's no reason to rollback.

# Code Structure

The following diagram shows the major moving parts in the GGPO session object and their relationship to each other.  Each component is described in detail below.

![](images/overview_image4.png)

## GGPO Interface

The GGPO interface abstracts away the implementation details between the P2P and the Sync Test backends.  The proper backend is created automatically when you call the ggpo_start_session or ggpo_start_synctest entry points.

## P2P Backend

The P2P backend orchestrates a game between players.  It is created by the ggpo_start_session API call.  Most of the heavy lifting is done by the contained helper classes.

## Poll Object

(not pictured).  The poll object is a registration mechanism used by the other objects in the code.  It delivers timers and notifications when waitable objects become ready.  For example, the UDP backend uses the Poll object to receive notifications when new packets arrive. 

## Sync Object

The sync object is used to keep track of the last n-frames of game state.  When its embedded prediction object notifies it of a prediction error, the Sync backend rewinds the game to the more-correct state and single-steps forward to correct the prediction error.

## Input Queue Object

The InputQueue object keeps track of all the inputs received for a local or remote player.  When asked for an input which it doesn't have, the input queue predicts the next input, and keeps track of this information for later so the sync object will know where to rollback to if the prediction was incorrect.  The input queue also implements the frame-delay if requested.

## UDP Protocol Object

The UDP protocol object handles the synchronization and input exchange protocols between any two players.  It also implements the game input compression and reliable-UDP layer.  Each UDP Protocol object has a contained TimeSync object which is uses to approximate the wall clock time skew between two players.

## UDP Object

The UDP object is simply a dumb UDP packet sender/receiver.  It's divorced from UDP protocol to ease ports to other platforms.

## Sync Test Backend

(not pictured) The Sync Test backend uses the same Sync object as the P2P backend to verify your application's save state and stepping functionality execute deterministically.  For more information on sync test uses, consult the Developer Guide.

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/AudioManager.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AudioManager.h"

#include "Components/AudioComponent.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(AudioManager)

// Sets default values
AAudioManager::AAudioManager()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;

	RootComponent = CreateDefaultSubobject<USceneComponent>(FName("RootComponent"));
	for (int i = 0; i < CommonAudioChannelCount; i++)
	{
		FString Name = "CommonAudioPlayer";
		Name.AppendInt(i);
		CommonAudioPlayers[i] = CreateDefaultSubobject<UAudioComponent>(FName(Name));
		CommonAudioPlayers[i]->AutoAttachParent = RootComponent;
	}
	for (int i = 0; i < CharaAudioChannelCount; i++)
	{
		FString Name = "CharaAudioPlayer";
		Name.AppendInt(i);
		CharaAudioPlayers[i] = CreateDefaultSubobject<UAudioComponent>(FName(Name));
		CharaAudioPlayers[i]->AutoAttachParent = RootComponent;
	}
	for (int i = 0; i < CharaVoiceChannelCount; i++)
	{
		FString Name = "CharaVoicePlayer";
		Name.AppendInt(i);
		CharaVoicePlayers[i] = CreateDefaultSubobject<UAudioComponent>(FName(Name));
		CharaVoicePlayers[i]->AutoAttachParent = RootComponent;
	}
	AnnouncerVoicePlayer = CreateDefaultSubobject<UAudioComponent>(TEXT("AnnouncerVoicePlayer"));
	AnnouncerVoicePlayer->bAutoActivate = false;
	AnnouncerVoicePlayer->AutoAttachParent = RootComponent;
	MusicPlayer = CreateDefaultSubobject<UAudioComponent>(TEXT("MusicPlayer"));
	MusicPlayer->bAutoActivate = true;
	MusicPlayer->AutoAttachParent = RootComponent;
}

// Called when the game starts or when spawned
void AAudioManager::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AAudioManager::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

void AAudioManager::PauseAllAudio()
{
	for (const auto Player : CommonAudioPlayers)
	{
		Player->Stop();
	}
	for (const auto Player : CharaAudioPlayers)
	{
		Player->Stop();
	}
	for (const auto Player : CharaVoicePlayers)
	{
		Player->Stop();
	}
	AnnouncerVoicePlayer->Stop();
}
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/AudioManager.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "AudioManager.generated.h"

constexpr int CommonAudioChannelCount = 32;
constexpr int CharaAudioChannelCount = 32;
constexpr int CharaVoiceChannelCount = 6;

UCLASS()
class NIGHTSKYENGINE_API AAudioManager : public AActor
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AAudioManager();

	UPROPERTY()
	UAudioComponent* CommonAudioPlayers[CommonAudioChannelCount];
	UPROPERTY()
	UAudioComponent* CharaAudioPlayers[CharaAudioChannelCount];
	UPROPERTY()
	UAudioComponent* CharaVoicePlayers[CharaVoiceChannelCount];
	UPROPERTY()
	UAudioComponent* AnnouncerVoicePlayer;
	UPROPERTY()
	UAudioComponent* MusicPlayer;
	
protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;
	void PauseAllAudio();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/LinkActor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "LinkActor.h"


// Sets default values
ALinkActor::ALinkActor()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}

// Called when the game starts or when spawned
void ALinkActor::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void ALinkActor::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}


```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/LinkActor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "LinkActor.generated.h"

UCLASS()
class NIGHTSKYENGINE_API ALinkActor : public AActor
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ALinkActor();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;
	
	UFUNCTION(BlueprintImplementableEvent)
	void Init();
	
	UFUNCTION(BlueprintImplementableEvent)
	void Update();
	
	UFUNCTION(BlueprintImplementableEvent)
	void Exit();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/ParticleManager.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ParticleManager.h"
#include "NiagaraComponent.h"
#include "NightSkyEngine/Battle/NightSkyGameState.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(ParticleManager)

// Sets default values
AParticleManager::AParticleManager()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;
}

// Called when the game starts or when spawned
void AParticleManager::BeginPlay()
{
	Super::BeginPlay();
}

// Called every frame
void AParticleManager::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

void AParticleManager::UpdateParticles()
{
	BattleParticles.RemoveAll([=](const FBattleParticle& Particle)
	{
		return !IsValid(Particle.NiagaraComponent);
	});
	for (const auto [NiagaraComponent, ParticleOwner] : BattleParticles)
	{
		if (IsValid(ParticleOwner) && ParticleOwner->IsStopped())
		{
			NiagaraComponent->SetPaused(false);
			NiagaraComponent->AdvanceSimulation(1, OneFrame / 1000);
			NiagaraComponent->SetDesiredAge(NiagaraComponent->GetDesiredAge());
			if (NiagaraComponent->IsComplete())
				NiagaraComponent->Deactivate();
			continue;
		}
		NiagaraComponent->SetPaused(false);
		NiagaraComponent->AdvanceSimulation(1, OneFrame);
		NiagaraComponent->SetDesiredAge(NiagaraComponent->GetDesiredAge() + OneFrame);
		if (NiagaraComponent->IsComplete())
			NiagaraComponent->Deactivate();
	}
}

void AParticleManager::PauseParticles()
{
	BattleParticles.RemoveAll([=](const FBattleParticle& Particle)
	{
		return !IsValid(Particle.NiagaraComponent);
	});
	for (const auto BattleParticle : BattleParticles)
	{
		BattleParticle.NiagaraComponent->SetPaused(true);
	}
}

void AParticleManager::RollbackParticles(int RollbackFrames)
{
	for (const auto BattleParticle : BattleParticles)
	{
		const auto NiagaraComponent = BattleParticle.NiagaraComponent;
		const int32 RollbackTime = NiagaraComponent->GetDesiredAge() * (1 / OneFrame) - RollbackFrames;
		if (RollbackTime < 0)
		{
			NiagaraComponent->Deactivate();
			continue;
		}
		NiagaraComponent->ResetSystem();
		NiagaraComponent->AdvanceSimulation(RollbackTime, OneFrame);
	}
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/ParticleManager.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "ParticleManager.generated.h"

class UNiagaraComponent;
class ABattleObject;

USTRUCT()
struct FBattleParticle
{
	GENERATED_BODY()
	
	FBattleParticle()
	{
		NiagaraComponent = nullptr;
		ParticleOwner = nullptr;
	}
	
	FBattleParticle(UNiagaraComponent* InNiagaraComponent, ABattleObject* InOwner)
		: NiagaraComponent(InNiagaraComponent), ParticleOwner(InOwner) {}
	
	UPROPERTY()
	UNiagaraComponent* NiagaraComponent;
	UPROPERTY()
	ABattleObject* ParticleOwner;
};

UCLASS()
class NIGHTSKYENGINE_API AParticleManager : public AActor
{
	GENERATED_BODY()

public:
	UPROPERTY()
	TArray<FBattleParticle> BattleParticles;

	// Sets default values for this actor's properties
	AParticleManager();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;
	void UpdateParticles();
	void PauseParticles();
	void RollbackParticles(int RollbackFrames);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimInstance.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyAnimInstance.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyAnimInstance)

void UNightSkyAnimInstance::Montage_Advance(float DeltaSeconds)
{
	if (!RootMontage)
	{
		Super::Montage_Advance(DeltaSeconds);
		return;
	}
	
	Montage_SetPosition(RootMontage, CurrentAnimTime);
}

void UNightSkyAnimInstance::CreateRootMontage(UAnimSequenceBase* Asset, const FAlphaBlendArgs& BlendIn, const FAlphaBlendArgs& BlendOut)
{
	if (!Asset) return;
	RootMontage = PlaySlotAnimationAsDynamicMontage_WithBlendArgs(Asset, "Root", BlendIn, BlendOut, 1, 1, -1,
	                                                              CurrentAnimTime);
	Montage_SetNextSection("Default", "Default", RootMontage);
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimInstance.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimInstance.h"
#include "NightSkyAnimInstance.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UNightSkyAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

protected:
	virtual void Montage_Advance(float DeltaSeconds) override;
	
public:
	UPROPERTY(BlueprintReadWrite)
	UAnimMontage* RootMontage;
	
	UPROPERTY(BlueprintReadWrite)
	float CurrentAnimTime;

	UFUNCTION(BlueprintCallable, meta = (BlueprintThreadSafe))
	void CreateRootMontage(UAnimSequenceBase* Asset, const FAlphaBlendArgs& BlendIn, const FAlphaBlendArgs& BlendOut);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimMetaData.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyAnimMetaData.h"

#include "NightSkyAnimSequenceUserData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyAnimMetaData)

UNightSkyAnimMetaData::UNightSkyAnimMetaData()
{
	const auto AnimSequence = Cast<UAnimSequence>(GetOuter());

	if (!AnimSequence) return;
	if (IsValid(AnimSequence->GetAssetUserData<UNightSkyAnimSequenceUserData>())) return;

	AnimSequence->AddAssetUserDataOfClass(UNightSkyAnimSequenceUserData::StaticClass());
	UserData = static_cast<UNightSkyAnimSequenceUserData*>(AnimSequence->GetAssetUserDataOfClass(
		UNightSkyAnimSequenceUserData::StaticClass()));
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimMetaData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimMetaData.h"
#include "NightSkyAnimMetaData.generated.h"

class UNightSkyAnimSequenceUserData;
/**
 * 
 */
UCLASS(CollapseCategories, EditInlineNew)
class NIGHTSKYENGINE_API UNightSkyAnimMetaData : public UAnimMetaData
{
	GENERATED_BODY()

public:
	UNightSkyAnimMetaData();

	UPROPERTY(EditAnywhere, Category = "Baked Animation")
	TSet<FName> CachedBoneNames;

	UPROPERTY(BlueprintReadOnly, Category = "Baked Animation")
	TObjectPtr<UNightSkyAnimSequenceUserData> UserData;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyAnimSequenceUserData.h"

#include "NightSkyAnimMetaData.h"
#include "NightSkyEngine/Battle/Misc/Globals.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyAnimSequenceUserData)

void UNightSkyAnimSequenceUserData::Serialize(FArchive& Ar)
{
	Super::Serialize(Ar);

	Ar << MeshSpaceBoneTransforms;
	Ar << RootTranslation;
}

void UNightSkyAnimSequenceUserData::PostEditChangeOwner(const FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeOwner(PropertyChangedEvent);
	
	// We can't call blueprint implemented functions while routing post load
	if (FUObjectThreadContext::Get().IsRoutingPostLoad)
	{
		return;
	}

	// Skip interactive changes
	if (PropertyChangedEvent.ChangeType == EPropertyChangeType::Interactive)
	{
		return;
	}

	MeshSpaceBoneTransforms.Empty();
	RootTranslation.Empty();

	auto AnimSequence = Cast<UAnimSequence>(GetOuter());
	if (!IsValid(AnimSequence)) return;
	
	UNightSkyAnimMetaData* AnimMetaData = nullptr;

	for (auto& MetaData : AnimSequence->GetMetaData())
	{
		AnimMetaData = Cast<UNightSkyAnimMetaData>(MetaData);
		if (IsValid(MetaData)) break;
	}

	if (!IsValid(AnimMetaData))
	{
		ConditionalBeginDestroy();
		return;
	}

	FrameCount = AnimSequence->GetPlayLength() * AnimSequence->GetSamplingFrameRate().AsDecimal();
	FrameRate = AnimSequence->GetSamplingFrameRate().AsDecimal();

	auto ReferenceSkeleton = AnimSequence->GetSkeleton()->GetReferenceSkeleton();

	for (auto& BoneName : AnimMetaData->CachedBoneNames)
	{
		if (ReferenceSkeleton.FindBoneIndex(BoneName) == INDEX_NONE) continue;
		TMap<int32, FAnimTransform> BoneTransforms;

		for (int i = 0; i < FrameCount; i++)
		{
			FTransform Transform;
			FAnimExtractContext Context{
				static_cast<double>(i) / AnimSequence->GetSamplingFrameRate().AsDecimal()
			};
			AnimSequence->GetBoneTransform(
				Transform, FSkeletonPoseBoneIndex(ReferenceSkeleton.FindBoneIndex(BoneName)),
				Context, true);

			FAnimTransform AnimTransform;
			AnimTransform.Position.X = Transform.GetTranslation().X * COORD_SCALE;
			AnimTransform.Position.Y = Transform.GetTranslation().Y * COORD_SCALE;
			AnimTransform.Position.Z = Transform.GetTranslation().Z * COORD_SCALE;

			auto Rotation = Transform.GetRotation().Rotator();
			AnimTransform.Rotation.Pitch = Rotation.Pitch * 1000;
			AnimTransform.Rotation.Yaw = Rotation.Yaw * 1000;
			AnimTransform.Rotation.Roll = Rotation.Roll * 1000;

			AnimTransform.Scale.X = Transform.GetScale3D().X * 1000;
			AnimTransform.Scale.Y = Transform.GetScale3D().Y * 1000;
			AnimTransform.Scale.Z = Transform.GetScale3D().Z * 1000;

			BoneTransforms.Add(i, AnimTransform);
		}

		MeshSpaceBoneTransforms.Add(BoneName, BoneTransforms);
	}

	for (int i = 0; i < FrameCount; i++)
	{
		FAnimExtractContext Context{
			static_cast<double>(i) / AnimSequence->GetSamplingFrameRate().AsDecimal(),
			true,
		};

		FVector Translation = AnimSequence->ExtractRootTrackTransform(Context, nullptr).GetTranslation();
		FAnimVector AnimTranslation;

		AnimTranslation.X = Translation.X * COORD_SCALE;
		AnimTranslation.Y = Translation.Y * COORD_SCALE;
		AnimTranslation.Z = Translation.Z * COORD_SCALE;

		RootTranslation.Add(i, AnimTranslation);
	}
}

FAnimVector UNightSkyAnimSequenceUserData::GetRootTranslationAtTime(int32 Time) const
{
	if (!RootTranslation.Contains(Time)) return FAnimVector{};
	return RootTranslation[Time];
}

FAnimTransform UNightSkyAnimSequenceUserData::GetCachedBoneTransformAtTime(FName BoneName, int32 Time,
                                                                           bool bRelativeToRoot) const
{
	if (!MeshSpaceBoneTransforms.Contains(BoneName)) return FAnimTransform{};
	if (!MeshSpaceBoneTransforms[BoneName].Contains(Time)) return FAnimTransform{};
	auto Transform = MeshSpaceBoneTransforms[BoneName][Time];

	if (!bRelativeToRoot) return Transform;
	if (!RootTranslation.Contains(Time)) return Transform;

	auto Root = RootTranslation[Time];
	Transform.Position.X += Root.X;
	Transform.Position.Y += Root.Y;
	Transform.Position.Z += Root.Z;
	return Transform;
}

FAnimVector UNightSkyAnimSequenceUserData::GetCachedBoneLocationAtTime(FName BoneName, int32 Time,
	bool bRelativeToRoot) const
{
	if (!MeshSpaceBoneTransforms.Contains(BoneName)) return FAnimVector{};
	if (!MeshSpaceBoneTransforms[BoneName].Contains(Time)) return FAnimVector{};
	auto Transform = MeshSpaceBoneTransforms[BoneName][Time];

	if (!bRelativeToRoot) return Transform.Position;
	if (!RootTranslation.Contains(Time)) return Transform.Position;

	auto Root = RootTranslation[Time];
	Transform.Position.X += Root.X;
	Transform.Position.Y += Root.Y;
	Transform.Position.Z += Root.Z;
	return Transform.Position;
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/AssetUserData.h"
#include "NightSkyAnimSequenceUserData.generated.h"

USTRUCT(BlueprintType)
struct FAnimVector
{
	GENERATED_BODY()

	int32 X;
	int32 Y;
	int32 Z;
};

FORCEINLINE FArchive operator <<(FArchive& Ar, FAnimVector& InVal)
{
	Ar << InVal.X;
	Ar << InVal.Y;
	Ar << InVal.Z;
	return Ar;
}

USTRUCT(BlueprintType)
struct FAnimRotator
{
	GENERATED_BODY()

	int32 Pitch;
	int32 Yaw;
	int32 Roll;
};

FORCEINLINE FArchive operator <<(FArchive& Ar, FAnimRotator& InVal)
{
	Ar << InVal.Pitch;
	Ar << InVal.Yaw;
	Ar << InVal.Roll;
	return Ar;
}

USTRUCT(BlueprintType)
struct FAnimTransform
{
	GENERATED_BODY()

	FAnimVector Position;
	FAnimRotator Rotation;
	FAnimVector Scale;
};

FORCEINLINE FArchive operator <<(FArchive& Ar, FAnimTransform& InVal)
{
	Ar << InVal.Position;
	Ar << InVal.Rotation;
	Ar << InVal.Scale;
	return Ar;
}

/**
 * 
 */
UCLASS(EditInlineNew)
class NIGHTSKYENGINE_API UNightSkyAnimSequenceUserData : public UAssetUserData
{
	GENERATED_BODY()

private:
	UPROPERTY()
	int32 FrameCount;
	
	UPROPERTY()
	int32 FrameRate;

	TMap<FName, TMap<int32, FAnimTransform>> MeshSpaceBoneTransforms;
	TMap<int32, FAnimVector> RootTranslation;

	virtual void Serialize(FArchive& Ar) override;

public:
	virtual void PostEditChangeOwner(const FPropertyChangedEvent& PropertyChangedEvent) override;

	UFUNCTION(BlueprintPure)
	int32 GetFrameCount() const
	{
		return FrameCount;
	}

	UFUNCTION(BlueprintPure)
	int32 GetFrameRate() const
	{
		return FrameRate;
	}
	
	UFUNCTION(BlueprintPure)
	FAnimVector GetRootTranslationAtTime(int32 Time) const;

	UFUNCTION(BlueprintPure)
	FAnimTransform GetCachedBoneTransformAtTime(FName BoneName, int32 Time, bool bRelativeToRoot) const;
    
	UFUNCTION(BlueprintPure)
	FAnimVector GetCachedBoneLocationAtTime(FName BoneName, int32 Time, bool bRelativeToRoot) const;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/CPU/NightSkyAIController.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyAIController.h"

#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "NightSkyEngine/Battle/Objects/PlayerObject.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyAIController)

// Sets default values
ANightSkyAIController::ANightSkyAIController()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}

// Called when the game starts or when spawned
void ANightSkyAIController::BeginPlay()
{
	Super::BeginPlay();

	GameState = Cast<ANightSkyGameState>(GetWorld()->GetGameState());
}

void ANightSkyAIController::Update()
{
	if (!Player) Player = GetPawn<APlayerObject>();
	
	if (GameState->BattleState.TimeUntilRoundStart || Player->PlayerFlags & PLF_RoundWinInputLock || !Player->IsOnScreen())
	{
		Player->StoredInputBuffer.Update(INP_Neutral, Player->IsStopped());
		return;
	}

	if (Player->CurrentHealth <= 0) return;

	Player->StoredInputBuffer.Update(INP_Neutral);
	bBlock = false;
	
	bool bDefendOnly = false;
	
	if (Player->Enemy->CheckIsAttacking()
		&& Player->Enemy->CheckEnemyInRange(
			Player->Enemy->PrimaryStateMachine.CurrentState->CPUData.AttackXBeginRange, 
			Player->Enemy->PrimaryStateMachine.CurrentState->CPUData.AttackXEndRange,
			Player->Enemy->PrimaryStateMachine.CurrentState->CPUData.AttackYBeginRange, 
			Player->Enemy->PrimaryStateMachine.CurrentState->CPUData.AttackYEndRange)
		&& WaitCount <= WaitLimit)
	{
		bDefendOnly = true;
	}
	else
	{
		WaitCount++;
		if (WaitCount <= WaitLimit) return;
	}
	
	TArray<UState*> AvailableStates{};
	for (auto State : Player->PrimaryStateMachine.States)
	{
		if (!Player->CanEnterState(State, StateMachine_Primary)) continue;
		AvailableStates.Add(State);
	}

	if (AvailableStates.Num() == 1)
	{
		ResetParams();
		TargetState = AvailableStates[0];
	}
	else
	{
		auto MaxWeight = 0;
		UState* CurState = nullptr;
		for (const auto State : AvailableStates)
		{
			int Weight;
			if (bDefendOnly)
			{
				if (!State->CPUData.bAttack)
				{
					Weight = CheckDefenseWeight(State);
					if (Weight > MaxWeight)
					{
						MaxWeight = Weight;
						CurState = State;
					}
				}
				else
				{
					Weight = CheckAttackWeight(State);
					if (Weight > MaxWeight)
					{
						MaxWeight = Weight;
						CurState = State;
					}
				}
			}
			else if (!State->CPUData.bAttack)
			{
				Weight = CheckBasicWeight(State);
				if (Weight > MaxWeight)
				{
					MaxWeight = Weight;
					CurState = State;
				}
			}
			else
			{
				Weight = CheckAttackWeight(State);
				if (Weight > MaxWeight)
				{
					MaxWeight = Weight;
					CurState = State;
				}
			}
		}
		if (TargetState != CurState && CurState != nullptr)
		{
			ResetParams();
			TargetState = CurState;
		}
	}
	
	InputCount = FMath::Max(InputCount - InputCountLimit, 0);
	if (SetInputs()) ResetParams();
}

void ANightSkyAIController::ResetParams()
{
	WaitCount = 0;
	InputCount = 0;
	WaitLimit = 7;
	TargetState = nullptr;
}

bool ANightSkyAIController::SetInputs()
{
	if (!TargetState || TargetState->InputConditionLists.Num() == 0) return false;
	for (auto Condition : TargetState->InputConditionLists[0].InputConditions)
	{
		if (InputCount > InputCountLimit) return false;
		
		Player->StoredInputBuffer.WriteInputCondition(Condition);
		InputCount += Condition.Sequence.Num();
	}

	if (bBlock)
	{
		Player->StoredInputBuffer.InputBufferInternal[InputBufferSize - 1] |= INP_Left;
	}
	
	TargetState = nullptr;
	return true;
}

int32 ANightSkyAIController::GetEnemyDistanceX() const
{
	if (!IsValid(Player)) return 0;
	return Player->CalculateDistanceBetweenPoints(DIST_DistanceX, OBJ_Self, POS_Player, OBJ_Enemy, POS_Player);
}

int32 ANightSkyAIController::GetEnemyDistanceY() const
{
	if (!IsValid(Player)) return 0;
	return Player->CalculateDistanceBetweenPoints(DIST_DistanceY, OBJ_Self, POS_Player, OBJ_Enemy, POS_Player);
}

int32 ANightSkyAIController::CheckBasicWeight(const UState* State) const
{
	if (!IsValid(Player)) return 0;

	int Weight = 50;
	
	switch (State->StateType)
	{
	case EStateType::Standing:
	case EStateType::Crouching:
		break;
	case EStateType::NeutralJump:
	case EStateType::ForwardJump:
		if (GetEnemyDistanceY() > 105000 && Player->PosY < Player->Enemy->PosY)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(10, 25);
		}
		break;
	case EStateType::ForwardAirDash:
		if (GetEnemyDistanceX() > 360000)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(25, 50);
		}
		break;
	case EStateType::BackwardJump:
	case EStateType::BackwardAirDash:
		Weight = GameState->BattleState.RandomManager.RandRange(10, 15);
		if (Player->Enemy->CheckIsAttacking() && GetEnemyDistanceX() < 360000)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(25, 50);
		}
		break;
	case EStateType::ForwardWalk:
		Weight += GameState->BattleState.RandomManager.RandRange(25, 80);
		if (GetEnemyDistanceX() > 420000)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(30, 50);
		}
		if (Player->Enemy->CheckIsStunned())
		{
			Weight += GameState->BattleState.RandomManager.RandRange(15, 30);
		}
		break;
	case EStateType::ForwardDash:
		Weight += GameState->BattleState.RandomManager.RandRange(50, 100);
		if (GetEnemyDistanceX() > 640000)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(15, 30);
		}
		if (Player->Enemy->CheckIsAttacking() && GetEnemyDistanceX() < 480000)
		{
			Weight -= GameState->BattleState.RandomManager.RandRange(25, 50);
		}
		if (Player->Enemy->CheckIsStunned())
		{
			Weight += GameState->BattleState.RandomManager.RandRange(15, 30);
		}
		if (Player->Direction == Player->Enemy->Direction)
		{
			Weight = 0;
		}
		break;
	case EStateType::BackwardWalk:
		Weight += GameState->BattleState.RandomManager.RandRange(10, 30);
		if (Player->Enemy->CheckIsAttacking() && GetEnemyDistanceX() < 540000)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(5, 20);
		}
		if (Player->Enemy->CheckIsStunned())
		{
			Weight -= GameState->BattleState.RandomManager.RandRange(5, 20);
		}
		break;
	case EStateType::BackwardDash:
		Weight += GameState->BattleState.RandomManager.RandRange(5, 10);
		if (Player->Enemy->CheckIsAttacking() && GetEnemyDistanceX() < 540000)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(5, 10);
		}
		if (Player->Enemy->CheckIsStunned())
		{
			Weight -= GameState->BattleState.RandomManager.RandRange(25, 50);
		}
		break;
	case EStateType::Tech:
		// TODO tech weight
		Weight = 250;
		break;
	default:
		break;
	}

	Weight += GameState->BattleState.RandomManager.RandRange(-50, 50);
	
	return Weight;
}

int32 ANightSkyAIController::CheckAttackWeight(const UState* State) const
{
	if (!IsValid(Player)) return 0;

	int32 Weight = GameState->BattleState.RandomManager.RandRange(50, 100);

	if (!Player->CheckEnemyInRange(State->CPUData.AttackXBeginRange, State->CPUData.AttackXEndRange,
								   State->CPUData.AttackYBeginRange, State->CPUData.AttackYEndRange))
		Weight -= 50;

	if (Player->PosY < Player->Enemy->PosY && State->CPUData.bAntiAir) Weight += GameState->BattleState.RandomManager.RandRange(15, 40);

	if (State->CPUData.bUsesResource) Weight -= GameState->BattleState.RandomManager.RandRange(15, 40);
	if (State->CPUData.bBigDamage) Weight += GameState->BattleState.RandomManager.RandRange(15, 40);
	if (State->CPUData.bNoCombo && Player->ComboCounter) Weight -= GameState->BattleState.RandomManager.RandRange(15, 40);
	
	switch (State->CPUData.AttackSpeed)
	{
	case ASPD_Fast:
		Weight += GameState->BattleState.RandomManager.RandRange(15, 30);
		break;
	case ASPD_Medium:
		break;
	case ASPD_Slow:
		Weight -= GameState->BattleState.RandomManager.RandRange(15, 30);
		break;
	default: break;
	}

	if (Player->Enemy->PrimaryStateMachine.CurrentState->StateType == EStateType::Hitstun)
	{
		if (State->CPUData.bThrow && !State->CPUData.bCombo) Weight = 0;
		if (State->CPUData.bCombo) Weight += GameState->BattleState.RandomManager.RandRange(80, 250);
	}
	else if (Player->IsEnemyBlocking())
	{
		if (State->CPUData.bBlockstring) Weight += GameState->BattleState.RandomManager.RandRange(15, 40);
		if (Player->Enemy->GetCurrentStateName(StateMachine_Primary) == State_Universal_StandBlock)
		{
			if (State->CPUData.BlockType == BLK_Low) Weight += GameState->BattleState.RandomManager.RandRange(15, 40);
		}
		else if (Player->Enemy->GetCurrentStateName(StateMachine_Primary) == State_Universal_CrouchBlock)
		{
			if (State->CPUData.BlockType == BLK_High) Weight += GameState->BattleState.RandomManager.RandRange(15, 40);
		}
		else if (State->CPUData.BlockType == BLK_None) Weight += GameState->BattleState.RandomManager.RandRange(15, 40);

		if (State->CPUData.bThrow)
		{
			if (Player->Enemy->CheckIsStunned()) Weight = 0;
			else Weight += GameState->BattleState.RandomManager.RandRange(15, 40);
		}
	}
	else
	{
		if (Player->Enemy->IsEnemyAttackState() && State->CPUData.bPunish)
		{
			bool bInPunishRange = false;
			switch (State->CPUData.PunishRange)
			{
			case RAN_Near:
				bInPunishRange = GetEnemyDistanceX() <= 360000;
				break;
			case RAN_Mid:
				bInPunishRange = GetEnemyDistanceX() > 360000 && GetEnemyDistanceX() <= 720000;
				break;
			case RAN_Far:
				bInPunishRange = GetEnemyDistanceX() > 720000;
				break;
			default:
				break;
			}

			Weight += bInPunishRange ? GameState->BattleState.RandomManager.RandRange(15, 40) : 0;
		}

		if (State->CPUData.bInvuln) Weight += GameState->BattleState.RandomManager.RandRange(15, 40);
	}
	Weight += GameState->BattleState.RandomManager.RandRange(-50, 50);
	
	return Weight;
}

int32 ANightSkyAIController::CheckDefenseWeight(const UState* State)
{
	if (!IsValid(Player)) return 0;

	int Weight = 0;
	
	switch (State->StateType)
	{
	case EStateType::Crouching:
		Weight += GameState->BattleState.RandomManager.RandRange(50, 80);
		if (Player->Enemy->GetAttackBlockType() == BLK_High)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(25, 50);
		}
		break;
	case EStateType::BackwardJump:
	case EStateType::BackwardAirDash:
		Weight += GameState->BattleState.RandomManager.RandRange(25, 50);
		if (Player->Enemy->CheckIsAttacking() && GetEnemyDistanceX() < 360000)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(25, 50);
		}
		break;
	case EStateType::BackwardWalk:
		Weight += GameState->BattleState.RandomManager.RandRange(25, 100);
		if (Player->Enemy->CheckIsAttacking() && GetEnemyDistanceX() < 360000)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(15, 35);
		}
		if (Player->Enemy->GetAttackBlockType() == BLK_Low)
		{
			Weight -= GameState->BattleState.RandomManager.RandRange(25, 50);
		}
		break;
	case EStateType::BackwardDash:
		Weight += GameState->BattleState.RandomManager.RandRange(50, 80);
		if (Player->Enemy->CheckIsAttacking() && GetEnemyDistanceX() < 360000)
		{
			Weight += GameState->BattleState.RandomManager.RandRange(10, 20);
		}
		if (Player->Enemy->CheckIsStunned())
		{
			Weight -= GameState->BattleState.RandomManager.RandRange(25, 50);
		}
		break;
	case EStateType::Tech:
		// TODO tech weight
		Weight = 250;
		break;
	default:
		break;
	}
	
	bBlock = true;
	
	Weight += GameState->BattleState.RandomManager.RandRange(-25, 50);
	
	return Weight;
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/CPU/NightSkyAIController.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NightSkyEngine/Battle/Script/State.h"
#include "Runtime/AIModule/Classes/AIController.h"
#include "NightSkyAIController.generated.h"

class ANightSkyGameState;
class UState;
class APlayerObject;

UCLASS()
class NIGHTSKYENGINE_API ANightSkyAIController : public AAIController
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ANightSkyAIController();

	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<APlayerObject> Player = nullptr;
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<ANightSkyGameState> GameState = nullptr;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

private:
	static constexpr int InputCountLimit = 2;

	UPROPERTY()
	UState* TargetState{};
	int WaitCount = 0;
	int WaitLimit = 7;
	int InputCount = 0;
	bool bBlock = false;
	
public:
	// Called every frame
	void Update();
	void ResetParams();
	bool SetInputs();
	
	UFUNCTION(BlueprintCallable)
	int32 GetEnemyDistanceX() const;
	UFUNCTION(BlueprintCallable)
	int32 GetEnemyDistanceY() const;

	UFUNCTION(BlueprintCallable)
	int32 CheckBasicWeight(const UState* State) const;
	UFUNCTION(BlueprintCallable)
	int32 CheckAttackWeight(const UState* State) const;
	UFUNCTION(BlueprintCallable)
	int32 CheckDefenseWeight(const UState* State);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterLocalRunner.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "FighterLocalRunner.h"

#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "Kismet/GameplayStatics.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(FighterLocalRunner)

// Sets default values
AFighterLocalRunner::AFighterLocalRunner()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;
	bReplicates = false;
}

// Called when the game starts or when spawned
void AFighterLocalRunner::BeginPlay()
{
	Super::BeginPlay();
	TArray<AActor*> FoundFighterGameStates;
	UGameplayStatics::GetAllActorsOfClass(GetWorld(), ANightSkyGameState::StaticClass(), FoundFighterGameStates);
	if (FoundFighterGameStates.Num() > 0)
	{
		GameState = Cast<ANightSkyGameState>(FoundFighterGameStates[0]);
	}
}

void AFighterLocalRunner::Update(float DeltaTime)
{
	if (GameState->bPauseGame)
		return;
	ElapsedTime += DeltaTime;
	while (ElapsedTime >= OneFrame)
	{
		//while elapsed time is greater than one frame...
		GameState->UpdateGameState();
		ElapsedTime -= OneFrame;
	}
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterLocalRunner.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "FighterLocalRunner.generated.h"

UCLASS()
class NIGHTSKYENGINE_API AFighterLocalRunner : public AActor
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AFighterLocalRunner();

protected:
	virtual void BeginPlay() override;

public:
	virtual void Update(float DeltaTime);

protected:
	float ElapsedTime = 0;

	UPROPERTY()
	class ANightSkyGameState* GameState;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterMultiplayerRunner.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "FighterMultiplayerRunner.h"

#include <fstream>

#include "Kismet/GameplayStatics.h"
#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "NightSkyEngine/Network/RpcConnectionManager.h"
#include <iostream>

#include "Serialization/BufferArchive.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(FighterMultiplayerRunner)

// Sets default values
AFighterMultiplayerRunner::AFighterMultiplayerRunner()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;
	bReplicates = false;
	connectionManager = nullptr;
}

// Called when the game starts or when spawned
void AFighterMultiplayerRunner::BeginPlay()
{
	Super::BeginPlay();
	GGPOSessionCallbacks cb = CreateCallbacks();
	connectionManager = new RpcConnectionManager();
	GGPONet::ggpo_start_session(&ggpo, &cb, connectionManager, "", 2, sizeof(int));
	GGPONet::ggpo_set_disconnect_timeout(ggpo, 45000);
	GGPONet::ggpo_set_disconnect_notify_start(ggpo, 15000);
	for (int i = 0; i < 2; i++)
	{
		GGPOPlayerHandle handle;
		GGPOPlayer* player = new GGPOPlayer();
		player->type = GGPO_PLAYERTYPE_REMOTE;
		if (i == GameState->GameInstance->PlayerIndex)
		{
			player->type = GGPO_PLAYERTYPE_LOCAL;
			connectionManager->playerIndex = i == 0 ? 1 : 0;
		}
		player->player_num = i + 1;
		player->connection_id = i;
		GGPONet::ggpo_add_player(ggpo, player, &handle);
		if (player->type == GGPO_PLAYERTYPE_LOCAL)
			GGPONet::ggpo_set_frame_delay(ggpo, handle, 2);
		// TODO: Logic for framedelay (based on ping? or make user choose?)
		Players.Add(player);
		PlayerInputIndex.Add(-1);
		PlayerHandles.Add(handle);
	}
	GGPONet::ggpo_try_synchronize_local(ggpo);
}

void AFighterMultiplayerRunner::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	delete connectionManager;
}


GGPOSessionCallbacks AFighterMultiplayerRunner::CreateCallbacks()
{
	GGPOSessionCallbacks cb = {0};

	cb.begin_game = std::bind(&AFighterMultiplayerRunner::BeginGameCallback, this, std::placeholders::_1);
	cb.save_game_state = std::bind(&AFighterMultiplayerRunner::SaveGameStateCallback, this,
	                               std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
	                               std::placeholders::_4);
	cb.load_game_state = std::bind(&AFighterMultiplayerRunner::LoadGameStateCallback, this,
	                               std::placeholders::_1, std::placeholders::_2);
	cb.log_game_state = std::bind(&AFighterMultiplayerRunner::LogGameState, this,
	                              std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);
	cb.free_buffer = std::bind(&AFighterMultiplayerRunner::FreeBuffer, this, std::placeholders::_1);
	cb.advance_frame = std::bind(&AFighterMultiplayerRunner::AdvanceFrameCallback, this, std::placeholders::_1);
	cb.on_event = std::bind(&AFighterMultiplayerRunner::OnEventCallback, this, std::placeholders::_1);

	return cb;
}

bool AFighterMultiplayerRunner::BeginGameCallback(const char*)
{
	return true;
}

bool AFighterMultiplayerRunner::SaveGameStateCallback(unsigned char** buffer, int32* len, int32* checksum, int32)
{
	FRollbackData RollbackData = FRollbackData();
	GameState->SaveGameState(RollbackData, checksum);
	FBufferArchive Ar(false);
	Ar.SetWantBinaryPropertySerialization(true);
	RollbackData.Serialize(Ar);

	*len = Ar.Num();
	*buffer = new unsigned char[*len];

	FMemory::Memcpy(*buffer, Ar.GetData(), Ar.Num());
	return true;
}

bool AFighterMultiplayerRunner::LoadGameStateCallback(unsigned char* buffer, int32 len)
{
	FRollbackData RollbackData = FRollbackData();

	const TArray BPArray(buffer, len);
	FMemoryReader Ar(BPArray);
	Ar.SetWantBinaryPropertySerialization(true);
	RollbackData.Serialize(Ar);

	GameState->LoadGameState(RollbackData);
	return true;
}

bool AFighterMultiplayerRunner::LogGameState(const char* filename, unsigned char* buffer, int len)
{
	FString savedDir = FPaths::ConvertRelativePathToFull(FPaths::ProjectSavedDir());

	savedDir.Append(filename);
	std::ofstream file;
	file.open(TCHAR_TO_ANSI(*savedDir));
	if (file.is_open())
	{
		FRollbackData RollbackData = FRollbackData();
		const TArray BPArray(buffer, len);
		FMemoryReader Ar(BPArray);
		Ar.SetWantBinaryPropertySerialization(true);
		RollbackData.Serialize(Ar);
		
		file << "GameState:\n";
		FBattleState BattleState = FBattleState();
		FMemory::Memcpy(&BattleState.BattleStateSync, RollbackData.BattleStateBuffer.GetData(), SizeOfBattleState);
		file << "\tFrameNumber: " << BattleState.FrameNumber << std::endl;
		file << "\tActiveObjectCount: " << BattleState.ActiveObjectCount << std::endl;
		for (int i = 0; i < GameState->MaxBattleObjects; i++)
		{
			if (RollbackData.ObjActive[i])
			{
				FBattleObjectLog BattleObject = FBattleObjectLog();
				FMemory::Memcpy(reinterpret_cast<char*>(&BattleObject) + offsetof(FBattleObjectLog, ObjSync),
				                RollbackData.ObjBuffer[i].GetData(), SizeOfBattleObject);
				BattleObject.LogForSyncTestFile(file);
			}
		}
		for (int i = GameState->MaxBattleObjects; i < GameState->MaxBattleObjects + GameState->Players.Num(); i++)
		{
			FPlayerObjectLog PlayerObject = FPlayerObjectLog();
			FMemory::Memcpy(reinterpret_cast<char*>(&PlayerObject) + offsetof(FBattleObjectLog, ObjSync),
			                RollbackData.ObjBuffer[i].GetData(), SizeOfBattleObject);
			FMemory::Memcpy(reinterpret_cast<char*>(&PlayerObject) + offsetof(FPlayerObjectLog, PlayerSync),
			                RollbackData.CharBuffer[i - GameState->MaxBattleObjects].GetData(), SizeOfPlayerObject);
			PlayerObject.LogForSyncTestFile(file);
		}

		file << "RawRollbackData:\n";
		file << "\tStateBuffer:\n";
		file << "\n\t0: ";
		for (int x = 0; x < SizeOfBattleState; x++)
		{
			file << std::hex << std::uppercase << static_cast<int>(RollbackData.BattleStateBuffer[x]) << " ";
			if ((x + 1) % 16 == 0)
			{
				file << "\n\t" << std::hex << std::uppercase << x + 1 << ": ";
			}
		}
		file << "\n";
		file << "\tStateData:\n";
		file << "\n\t0: ";
		for (int x = 0; x < RollbackData.BattleStateData.Num(); x++)
		{
			file << std::hex << std::uppercase << static_cast<int>(RollbackData.BattleStateData[x]) << " ";
			if ((x + 1) % 16 == 0)
			{
				file << "\n\t" << std::hex << std::uppercase << x + 1 << ": ";
			}
		}
		file << "\n";
		file << "\tObjBuffer:\n";
		for (int i = 0; i < GameState->MaxBattleObjects + GameState->Players.Num(); i++)
		{
			file << "Object " << i << ":\n";
			file << "\n\t0: ";
			for (int x = 0; x < SizeOfBattleObject; x++)
			{
				if (RollbackData.ObjBuffer[i].IsEmpty()) continue;
				file << std::hex << std::uppercase << static_cast<int>(RollbackData.ObjBuffer[i][x]) << " ";
				if ((x + 1) % 16 == 0)
				{
					file << "\n\t" << std::hex << std::uppercase << x + 1 << ": ";
				}
			}
			file << "\n";
		}
		file << "\n";
		file << "\tObjActive:\n";
		for (int i = 0; i < GameState->MaxBattleObjects; i++)
		{
			file << RollbackData.ObjActive[i] << " ";
		}
		file << "\n";
		file << "\tPlayerBuffer:\n";
		for (int i = 0; i < GameState->Players.Num(); i++)
		{
			file << "Player " << i << ":\n";
			file << "\n\t0: ";
			for (int x = 0; x < SizeOfPlayerObject; x++)
			{
				file << std::hex << std::uppercase << static_cast<int>(RollbackData.CharBuffer[i][x]) << " ";
				if ((x + 1) % 16 == 0)
				{
					file << "\n\t" << std::hex << std::uppercase << x + 1 << ": ";
				}
			}
			file << "\n";
		}
		file << "\tPlayerData:\n";
		file << "\n\t0: ";
		for (int i = 0; i < GameState->Players.Num(); i++)
		{
			file << "Player " << i << ":\n";
			file << "\n\t0: ";
			for (int x = 0; x < RollbackData.PlayerData[i].Num(); x++)
			{
				file << std::hex << std::uppercase << static_cast<int>(RollbackData.PlayerData[i][x]) << " ";
				if ((x + 1) % 16 == 0)
				{
					file << "\n\t" << std::hex << std::uppercase << x + 1 << ": ";
				}
			}
			file << "\n";
		}
		file << "\n";
		
		file.close();
	}
	return true;
}

void AFighterMultiplayerRunner::FreeBuffer(void* buffer)
{
	delete[] static_cast<char*>(buffer);
}

bool AFighterMultiplayerRunner::AdvanceFrameCallback(int flag)
{
	int inputs[2] = {0};
	int disconnect_flags;
	GGPONet::ggpo_synchronize_input(ggpo, (void*)inputs, sizeof(int) * 2, &disconnect_flags);
	GameState->UpdateGameState(inputs[0], inputs[1], true);
	GGPONet::ggpo_advance_frame(ggpo);
	return true;
}

bool AFighterMultiplayerRunner::OnEventCallback(GGPOEvent* info)
{
	int progress;
	switch (info->code)
	{
	case GGPO_EVENTCODE_CONNECTED_TO_PEER:
		UE_LOG(LogTemp, Warning, TEXT("GGPO_EVENTCODE_CONNECTED_TO_PEER"));
		break;
	case GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER:
		UE_LOG(LogTemp, Warning, TEXT("GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER"));
	//synchronized = false;
		progress = 100 * info->u.synchronizing.count / info->u.synchronizing.total;
		break;
	case GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER:
		UE_LOG(LogTemp, Warning, TEXT("GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER"));
		if (GameState->GameInstance->FighterRunner == Multiplayer && !GameState->GameInstance->IsReplay)
		{
			GameState->GameInstance->EndRecordReplay();
			GameState->GameInstance->RecordReplay();
		}
	//synchronized = true;
		break;
	case GGPO_EVENTCODE_RUNNING:
		UE_LOG(LogTemp, Warning, TEXT("GGPO_EVENTCODE_RUNNING"));

		break;
	case GGPO_EVENTCODE_CONNECTION_INTERRUPTED:
		UE_LOG(LogTemp, Warning, TEXT("GGPO_EVENTCODE_CONNECTION_INTERRUPTED"));
	// connectionLost = true;
	// FightGameInstance->ErrorMessage = FString("Connection interrupted");
	// EndOnline(true);
		UGameplayStatics::OpenLevel(GetGameInstance(), FName(TEXT("MainMenu_PL")));
		break;
	case GGPO_EVENTCODE_CONNECTION_RESUMED:
		//connectionLost = false;
		UE_LOG(LogTemp, Warning, TEXT("GGPO_EVENTCODE_CONNECTION_RESUMED"));

		break;
	case GGPO_EVENTCODE_DISCONNECTED_FROM_PEER:
		UE_LOG(LogTemp, Warning, TEXT("GGPO_EVENTCODE_DISCONNECTED_FROM_PEER"));
		UGameplayStatics::OpenLevel(GetGameInstance(), FName(TEXT("MainMenu_PL")));
	//FightGameInstance->ErrorMessage = FString("Enemy disconnected");
	//EndOnline(true);
		break;
	case GGPO_EVENTCODE_TIMESYNC:
		UE_LOG(LogTemp, Warning, TEXT("GGPO_EVENTCODE_TIMESYNC"));
	//if(MultipliedFramesAhead>3)
		{
			MultipliedFramesAhead = info->u.timesync.frames_ahead * TimesyncMultiplier;
		}
		break;
	case GGPO_EVENTCODE_TIMESYNC_BEHIND:
		UE_LOG(LogTemp, Warning, TEXT("GGPO_EVENTCODE_TIMESYNC_BEHIND"));
	//MultipliedFramesBehind=info->u.timesync.frames_ahead*TimesyncMultiplier;
		break;
	}
	return true;
}


void AFighterMultiplayerRunner::GgpoUpdate()
{
	GGPOErrorCode result = GGPOErrorCode::GGPO_OK;
	int disconnect_flags;
	int inputs[2] = {0};
	for (int i = 0; i < 2; ++i)
	{
		if (Players[i]->type == GGPO_PLAYERTYPE_LOCAL)
		{
			int input = 0;
			if (PlayerInputIndex[i] == -1)
			{
				for (int index = 0; index < 4; index++)
				{
					input |= GameState->GetLocalInputs(index);
				}
			}
			else
			{
				input = GameState->GetLocalInputs(PlayerInputIndex[i]);
			}

			result = GGPONet::ggpo_add_local_input(ggpo, PlayerHandles[i], &input, sizeof(input));
		}
	}
	if (GGPO_SUCCEEDED(result))
	{
		result = GGPONet::ggpo_synchronize_input(ggpo, (void*)inputs, sizeof(int) * 2, &disconnect_flags);
		if (GGPO_SUCCEEDED(result))
		{
			GameState->UpdateGameState(inputs[0], inputs[1], false);
			GGPONet::ggpo_advance_frame(ggpo);
		}
	}
}

void AFighterMultiplayerRunner::Update(float DeltaTime)
{
	ElapsedTime += DeltaTime;

	while (ElapsedTime >= OneFrame)
	{
		if (MultipliedFramesAhead > 0)
		{
			int ahead = MultipliedFramesAhead;
			MultipliedFramesAhead--;
			if (ahead % TimesyncMultiplier == 0)
			{
				ElapsedTime = 0;
				break;
			}
		}
		GgpoUpdate();
		ElapsedTime -= OneFrame;
		// if(MultipliedFramesBehind>0)
		// {
		// 	MultipliedFramesBehind--;
		// 	if(MultipliedFramesBehind%TimesyncMultiplier)
		// 	{
		// 		accumulatorBreaker=0;
		// 		ElapsedTime += OneFrame;
		// 	}	
		// }
		//
	}
	GGPONet::ggpo_idle(ggpo, 1);
}


//TODO refactor to a static libaray
int
AFighterMultiplayerRunner::fletcher32_checksum(short* data, size_t len)
{
	int sum1 = 0xffff, sum2 = 0xffff;

	while (len)
	{
		size_t tlen = len > 360 ? 360 : len;
		len -= tlen;
		do
		{
			sum1 += *data++;
			sum2 += sum1;
		}
		while (--tlen);
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);
	}

	/* Second reduction step to reduce sums to 16 bits */
	sum1 = (sum1 & 0xffff) + (sum1 >> 16);
	sum2 = (sum2 & 0xffff) + (sum2 >> 16);
	return sum2 << 16 | sum1;
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterMultiplayerRunner.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "FighterLocalRunner.h"
#include "include/ggponet.h"
#include "FighterMultiplayerRunner.generated.h"

constexpr int TimesyncMultiplier = 4;

UCLASS()
class NIGHTSKYENGINE_API AFighterMultiplayerRunner : public AFighterLocalRunner
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AFighterMultiplayerRunner();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

	GGPOSessionCallbacks CreateCallbacks();
	bool __cdecl BeginGameCallback(const char*);
	bool __cdecl SaveGameStateCallback(unsigned char** buffer, int32* len, int32* checksum, int32);
	bool __cdecl LoadGameStateCallback(unsigned char* buffer, int32 len);
	bool __cdecl LogGameState(const char* filename, unsigned char* buffer, int len);
	void __cdecl FreeBuffer(void* buffer);
	bool __cdecl AdvanceFrameCallback(int32);
	bool __cdecl OnEventCallback(GGPOEvent* info);

public:
	GGPOSession* ggpo = nullptr;
	TArray<GGPOPlayerHandle> PlayerHandles;
	TArray<GGPOPlayer*> Players;

protected:
	TArray<int> PlayerInputIndex;
	void GgpoUpdate();

	int MultipliedFramesAhead = 0;
	int MultipliedFramesBehind = 0;

public:
	virtual void Update(float DeltaTime) override;
	class RpcConnectionManager* connectionManager;

	static int fletcher32_checksum(short* data, size_t len);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterReplayRunner.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "FighterReplayRunner.h"

#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(FighterReplayRunner)

// Sets default values
AFighterReplayRunner::AFighterReplayRunner()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}

// Called when the game starts or when spawned
void AFighterReplayRunner::BeginPlay()
{
	Super::BeginPlay();
	GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
}

void AFighterReplayRunner::Update(float DeltaTime)
{
	if (GameState->bPauseGame)
		return;
	ElapsedTime += DeltaTime;
	while (ElapsedTime >= OneFrame)
	{
		//while elapsed time is greater than one frame...
		int32 P1Input = 0;
		int32 P2Input = 0;

		GameInstance->PlayReplayToGameState(GameState->LocalFrame, P1Input, P2Input);

		GameState->UpdateGameState(P1Input, P2Input, false);
		ElapsedTime -= OneFrame;
	}
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterReplayRunner.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "FighterLocalRunner.h"
#include "FighterReplayRunner.generated.h"

class UNightSkyGameInstance;

UCLASS()
class NIGHTSKYENGINE_API AFighterReplayRunner : public AFighterLocalRunner
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AFighterReplayRunner();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	UPROPERTY()
	UNightSkyGameInstance* GameInstance;

public:
	// Called every frame
	virtual void Update(float DeltaTime) override;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterSynctestRunner.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "FighterSynctestRunner.h"
#include "NightSkyEngine/Battle/NightSkyGameState.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(FighterSynctestRunner)

// Sets default values
AFighterSynctestRunner::AFighterSynctestRunner()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;
	bReplicates = false;
}

// Called when the game starts or when spawned
void AFighterSynctestRunner::BeginPlay()
{
	AFighterLocalRunner::BeginPlay();
	GGPOSessionCallbacks cb = CreateCallbacks();
	GGPONet::ggpo_start_synctest(&ggpo, &cb, "", 2, sizeof(int), 6);
	GGPONet::ggpo_set_disconnect_timeout(ggpo, 45000);
	GGPONet::ggpo_set_disconnect_notify_start(ggpo, 15000);
	for (int i = 0; i < 2; i++)
	{
		GGPOPlayerHandle handle;
		GGPOPlayer* player = new GGPOPlayer();
		player->type = GGPO_PLAYERTYPE_LOCAL;
		player->player_num = i + 1;
		GGPONet::ggpo_add_player(ggpo, player, &handle);
		Players.Add(player);
		PlayerInputIndex.Add(i);
		PlayerHandles.Add(handle);
	}
	GGPONet::ggpo_try_synchronize_local(ggpo);
}

void AFighterSynctestRunner::Update(float DeltaTime)
{
	ElapsedTime += DeltaTime;
	while (ElapsedTime >= OneFrame)
	{
		GgpoUpdate();
		ElapsedTime -= OneFrame;
	}
	GGPONet::ggpo_idle(ggpo, 1);
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterSynctestRunner.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "FighterMultiplayerRunner.h"
#include "FighterSynctestRunner.generated.h"

UCLASS()
class NIGHTSKYENGINE_API AFighterSynctestRunner : public AFighterMultiplayerRunner
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	AFighterSynctestRunner();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	virtual void Update(float DeltaTime) override;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/Bitflags.h`:

```h
#pragma once

#include "CoreMinimal.h"

/**
 * Input bitmasks. A layer of abstraction between the physical controller and the internal battle state.
 */
UENUM(Meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = "true"))
enum EInputFlags
{
	INP_None = 0x0 UMETA(DisplayName = "None"),
	INP_Up = 0x1 UMETA(DisplayName = "Up"),
	INP_Down = 0x2 UMETA(DisplayName = "Down"),
	INP_Left = 0x4 UMETA(DisplayName = "Left"),
	INP_Right = 0x8 UMETA(DisplayName = "Right"),
	INP_UpLeft = INP_Up + INP_Left UMETA(Hidden),
	INP_UpRight = INP_Up + INP_Right UMETA(Hidden),
	INP_DownLeft = INP_Down + INP_Left UMETA(Hidden),
	INP_DownRight = INP_Down + INP_Right UMETA(Hidden),
	INP_Neutral = 0x10 UMETA(DisplayName = "Neutral"),
	INP_A = 0x20 UMETA(DisplayName = "A"),
	INP_B = 0x40 UMETA(DisplayName = "B"),
	INP_C = 0x80 UMETA(DisplayName = "C"),
	INP_D = 0x100 UMETA(DisplayName = "D"),
	INP_E = 0x200 UMETA(DisplayName = "E"),
	INP_F = 0x400 UMETA(DisplayName = "F"),
	INP_G = 0x800 UMETA(DisplayName = "G"),
	INP_H = 0x1000 UMETA(DisplayName = "H"),
	INP_ResetTraining = 0x40000000 UMETA(Hidden),
	INP_Rematch = 0x80000000 UMETA(Hidden),
};

ENUM_CLASS_FLAGS(EInputFlags);

/**
 * Flags used to enable or disable specific states or actions.
 */
UENUM(Meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = "true"))
enum EEnableFlags
{
	ENB_None = 0x0 UMETA(Hidden),
	ENB_Standing = 0x1 UMETA(DisplayName = "Standing"),
	ENB_Crouching = 0x2 UMETA(DisplayName = "Crouching"),
	ENB_Jumping = 0x4 UMETA(DisplayName = "Jumping"),
	ENB_ForwardWalk = 0x8 UMETA(DisplayName = "Forward Walk"),
	ENB_BackWalk = 0x10 UMETA(DisplayName = "Backward Walk"),
	ENB_ForwardDash = 0x20 UMETA(DisplayName = "Forward Dash"),
	ENB_BackDash = 0x40 UMETA(DisplayName = "Backward Dash"),
	ENB_ForwardAirDash = 0x80 UMETA(DisplayName = "Forward Air Dash"),
	ENB_BackAirDash = 0x100 UMETA(DisplayName = "Backward Air Dash"),
	ENB_NormalAttack = 0x200 UMETA(DisplayName = "Normal Attack"),
	ENB_SpecialAttack = 0x400 UMETA(DisplayName = "Special Attack"),
	ENB_SuperAttack = 0x800 UMETA(DisplayName = "Super Attack"),
	ENB_Block = 0x1000 UMETA(DisplayName = "Block"),
	ENB_ProximityBlock = 0x2000 UMETA(DisplayName = "Proximity Block"),
	ENB_Tech = 0x4000 UMETA(DisplayName = "Tech"),
	ENB_Burst = 0x8000 UMETA(DisplayName = "Burst"),
	ENB_Tag = 0x10000 UMETA(DisplayName = "Tag"),
	ENB_Assist = 0x20000 UMETA(DisplayName = "Assist"),
};

ENUM_CLASS_FLAGS(EEnableFlags);

/**
 * Miscellaneous object flags.
 */
UENUM()
enum EMiscFlags
{
	/**
	 * Flag sets if inertia is enabled.
	 * @see ABattleObject.Inertia
	 */
	MISC_InertiaEnable = 0x1 UMETA(DisplayName = "Inertia Enabled"),
	/**
	 * Flag sets if object can switch sides.
	 */
	MISC_FlipEnable = 0x2 UMETA(DisplayName = "Flip Enabled"),
	/**
	 * Flag sets if object is subject to wall collision.
	 */
	MISC_WallCollisionActive = 0x4 UMETA(DisplayName = "Wall Collision Active"),
	/**
	 * Flag sets if object is subject to floor collision.
	 */
	MISC_FloorCollisionActive = 0x8 UMETA(DisplayName = "Floor Collision Active"),
	/**
	 * Flag sets if object is subject to push collision.
	 */
	MISC_PushCollisionActive = 0x10 UMETA(DisplayName = "Push Collision Active"),
	/**
	 * Flag sets if object is to be deactivated next update.
	 */
	MISC_DeactivateOnNextUpdate = 0x20 UMETA(DisplayName = "Deactivate On Next Update"),
	/**
	 * Flag sets if object is to be deactivated upon leaving screen bounds.
	 */
	MISC_DeactivateIfBeyondBounds = 0x40 UMETA(DisplayName = "Deactivate If Beyond Bounds"),
	/**
	 * Flag sets if object is to be deactivated on the owning player object's state change.
	 */
	MISC_DeactivateOnStateChange = 0x80 UMETA(DisplayName = "Deactivate On State Change"),
	/**
	* Flag sets if object is to be deactivated when the owning player object takes damage.
	 */
	MISC_DeactivateOnReceiveHit = 0x100 UMETA(DisplayName = "Deactivate On Receive Hit"),
	/**
	* Flag sets if object will ignore super freeze.
	 */
	MISC_IgnoreSuperFreeze = 0x200 UMETA(DisplayName = "Ignore Super Freeze"),
};

/**
 * Object attack flags.
 */
UENUM()
enum EAttackFlags
{
	/**
	 * Flag sets if object can hit.
	 */
	ATK_HitActive = 0x1 UMETA(DisplayName = "Hit Active"),
	/**
	 * Flag sets if object is attacking.
	 */
	ATK_IsAttacking = 0x2 UMETA(DisplayName = "Is Attacking"),
	/**
	 * Flag sets if object has the head attack attribute. Used on air attacks.
	 */
	ATK_AttackHeadAttribute = 0x4 UMETA(DisplayName = "Head Attribute"),
	/**
	 * Flag sets if object has the projectile attack attribute.
	 */
	ATK_AttackProjectileAttribute = 0x8 UMETA(DisplayName = "Projectile Attribute"),
	/**
	 * Flag sets if object has hit an object with the active hit.
	 */
	ATK_HasHit = 0x10 UMETA(DisplayName = "Has Hit"),
	/**
	 * Flag sets if object will only prorate once this state.
	 */
	ATK_ProrateOnce = 0x20 UMETA(DisplayName = "Prorate Once"),
	/**
	 * Flag sets if object will ignore OTG limits and proration.
	 */
	ATK_IgnoreOTG = 0x40 UMETA(DisplayName = "Ignore OTG"),
	/**
	 * Flag sets if object will ignore pushback scaling.
	 */
	ATK_IgnorePushbackScaling = 0x80 UMETA(DisplayName = "Ignore Pushback Scaling"),
	/**
	 * Flag sets if object will ignore hitstun scaling.
	 */
	ATK_IgnoreHitstunScaling = 0x100 UMETA(DisplayName = "Ignore Hitstun Scaling"),
	/**
	 * Flag sets if object will set ATK_HasHit in owning player on hit. Does nothing if already is a player object.
	 */
	ATK_SetPlayerHit = 0x200 UMETA(DisplayName = "Ignore Hitstun Scaling"),
	/**
	 * Flag sets if object can hit opponents during knockdown.
	 */
	ATK_HitOTG = 0x400 UMETA(DisplayName = "Hit OTG"),
};

/**
 * Miscellaneous player flags.
 */
UENUM()
enum EPlayerFlags
{
	/**
	 * Flag sets if player is dead.
	 */
	PLF_IsDead = 0x1 UMETA(DisplayName = "Is Dead"),
	/**
	 * Flag sets if player can throw opponent.
	 */
	PLF_ThrowActive = 0x2 UMETA(DisplayName = "Throw Active"),
	/**
	 * Flag sets if player is stunned.
	 */
	PLF_IsStunned = 0x4 UMETA(DisplayName = "Is Stunned"),
	/**
	 * Flag sets if player is locked by a throw.
	 */
	PLF_IsThrowLock = 0x8 UMETA(DisplayName = "Is In Throw Lock"),
	/**
	 * Flag sets if player is on screen (e.g. not tagged out in a versus game).
	 */
	PLF_IsOnScreen = 0x10 UMETA(DisplayName = "Is On Screen"),
	/**
	 * Flag sets if player manually overrides the death camera animation.
	 */
	PLF_DeathCamOverride = 0x20 UMETA(DisplayName = "Override Death Camera Animation"),
	/**
	 * Flag sets if player is knocked down.
	 */
	PLF_IsKnockedDown = 0x40 UMETA(DisplayName = "Is Knocked Down"),
	/**
	 * Flag sets if player is hard knocked down.
	 */
	PLF_IsHardKnockedDown = 0x80 UMETA(DisplayName = "Is Hard Knocked Down"),
	/**
	 * Flag sets if player is unable to input actions because the round is over.
	 */
	PLF_RoundWinInputLock = 0x100 UMETA(DisplayName = "Is Round Win Input Lock"),
	/**
	 * Flag sets if player's current attack locks the opponent's burst on hit.
	 */
	PLF_LockOpponentBurst = 0x200 UMETA(DisplayName = "Is Opponent Burst Locked"),
	/**
	 * Flag sets if player jumps to the JumpLanding state upon landing.
	 */
	PLF_DefaultLandingAction = 0x400 UMETA(DisplayName = "Is Default Landing Action"),
	/**
	 * Flag sets if player's far proximity normals are forcibly enabled.
	 */
	PLF_ForceEnableFarNormal = 0x800 UMETA(DisplayName = "Force Enable Far Proximity Normal"),
	/**
	 * Flag sets if player is touching wall.
	 */
	PLF_TouchingWall = 0x1000 UMETA(DisplayName = "Is Touching Wall"),
	/**
	 * Flag sets if player's next hit is a hitgrab.
	 */
	PLF_HitgrabActive = 0x2000 UMETA(DisplayName = "Hitgrab Active"),
	/**
	 * Flag sets if player received counter hit.
	 */
	PLF_ReceivedCounterHit = 0x4000 UMETA(DisplayName = "Received Counter Hit"),
	/**
	 * Flag sets if player kara canceled into the current state.
	 */
	PLF_DidKaraCancel = 0x8000 UMETA(DisplayName = "Did Kara Cancel"),
};

/**
 * Player cancel flags.
 */
UENUM()
enum ECancelFlags
{
	/**
	 * Flag sets if chain cancel is enabled.
	 */
	CNC_ChainCancelEnabled = 0x1 UMETA(DisplayName = "Is Chain Cancel Enabled"),
	/**
	 * Flag sets if whiff cancel is enabled.
	 */
	CNC_WhiffCancelEnabled = 0x2 UMETA(DisplayName = "Is Whiff Cancel Enabled"),
	/**
	 * Flag sets if special cancel is enabled.
	 */
	CNC_SpecialCancel = 0x4 UMETA(DisplayName = "Is Special Cancel Enabled"),
	/**
	 * Flag sets if super cancel is enabled.
	 */
	CNC_SuperCancel = 0x8 UMETA(DisplayName = "Is Super Cancel Enabled"),
	/**
	 * Flag sets if jump cancel is enabled.
	 */
	CNC_JumpCancel = 0x10 UMETA(DisplayName = "Is Jump Cancel Enabled"),
	/**
	 * Flag sets if forward air dash cancel is enabled.
	 */
	CNC_FAirDashCancel = 0x20 UMETA(DisplayName = "Is Forward Air Dash Cancel Enabled"), 
	/**
	 * Flag sets if backward air dash cancel is enabled.
	 */
	CNC_BAirDashCancel = 0x40 UMETA(DisplayName = "Is Backward Air Dash Cancel Enabled"),
	/**
	 * Flag sets if kara cancel is enabled.
	 */
	CNC_EnableKaraCancel = 0x80 UMETA(DisplayName = "Is Kara Cancel Enabled"),
	/**
	 * Flag sets if cancelling into the player's current state is enabled.
	 */
	CNC_CancelIntoSelf = 0x100 UMETA(DisplayName = "Is Cancel Into Self Enabled"),
	/**
	 * Flag sets if reverse beat is enabled. Only takes effect if the character can reverse beat.
	 */
	CNC_EnableReverseBeat = 0x200 UMETA(DisplayName = "Is Reverse Beat Enabled"),
};

/**
 * Player invulnerability flags.
 */
UENUM()
enum EInvulnFlags
{
	/**
	 * Flag sets if player is strike invulnerable.
	 */
	INV_StrikeInvulnerable = 0x1 UMETA(DisplayName = "Is Strike Invulnerable"),
	/**
	 * Flag sets if player is throw invulnerable.
	 */
	INV_ThrowInvulnerable = 0x2 UMETA(DisplayName = "Is Throw Invulnerable"),
	/**
	 * Flag sets if player is projectile invulnerable.
	 */
	INV_ProjectileInvulnerable = 0x4 UMETA(DisplayName = "Is Projectile Invulnerable"),
	/**
	 * Flag sets if player is invulnerable to head attribute attacks.
	 */
	INV_HeadInvulnerable = 0x8 UMETA(DisplayName = "Is Head Invulnerable"),
};
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/CollisionBox.h`:

```h
#pragma once
#include "Globals.h"

#include "CollisionBox.generated.h"

/**
 * The type of collision box.
 */
UENUM(BlueprintType)
enum EBoxType
{
	/**
	 * Pushbox. Currently unimplmeneted.
	 */
	BOX_Push UMETA(DisplayName="Pushbox"),
	/**
	 * Hurtbox.
	 */
	BOX_Hurt UMETA(DisplayName="Hurtbox"),
	/**
	 * Hitbox.
	 */
	BOX_Hit UMETA(DisplayName="Hitbox"),
	/**
	 * Offset. The X and Y positions are used as a semi-root motion system.
	 */
	BOX_Offset UMETA(DisplayName="Offset"),
	/**
	 * Custom. Set the Custom Box Type as well.
	 */
	BOX_Custom UMETA(DisplayName="Custom"),
};

/**
 * @brief  A collision box.
 *
 * Primarily used for push and hit collision, but some box types are used for specific operations.
 */
USTRUCT(BlueprintType)
struct FCollisionBox
{
	GENERATED_BODY()

	/**
	 * The type of box.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, SaveGame)
	TEnumAsByte<EBoxType> Type = BOX_Hurt;
	/**
	 * The custom box type. Used with BOX_Custom to define custom box behaviors.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, SaveGame)
	FGameplayTag CustomType;
	/**
	 * X position.
	 */
	UPROPERTY(BlueprintReadOnly, SaveGame)
	int32 PosX = 0;
	/**
	 * Y position.
	 */
	UPROPERTY(BlueprintReadOnly, SaveGame)
	int32 PosY = 0;
	/**
	 * X size.
	 */
	UPROPERTY(BlueprintReadOnly, SaveGame)
	int32 SizeX = 0;
	/**
	 * Y size.
	 */
	UPROPERTY(BlueprintReadOnly, SaveGame)
	int32 SizeY = 0;

#if WITH_EDITORONLY_DATA
	// Values for editor only, used for easy editing/display
	
	UPROPERTY(EditAnywhere, meta=(DisplayName="X Position"))
	float PosXEdit = 0;
	UPROPERTY(EditAnywhere, meta=(DisplayName="Y Position"))
	float PosYEdit = 0;
	UPROPERTY(EditAnywhere, meta=(DisplayName="X Size"))
	float SizeXEdit = 0;
	UPROPERTY(EditAnywhere, meta=(DisplayName="Y Size"))
	float SizeYEdit = 0;
	UPROPERTY(EditAnywhere, meta=(DisplayName="X Position (Unreal)", Units = "cm"))
	float UEPosX = 0;
	UPROPERTY(EditAnywhere, meta=(DisplayName="Y Position (Unreal)", Units = "cm"))
	float UEPosY = 0;
	UPROPERTY(EditAnywhere, meta=(DisplayName="X Size (Unreal)", Units = "cm"))
	float UESizeX = 0;
	UPROPERTY(EditAnywhere, meta=(DisplayName="Y Size (Unreal)", Units = "cm"))
	float UESizeY = 0;

	void EditorInit()
	{
		PosXEdit = static_cast<float>(PosX) / 1000;
		PosYEdit = static_cast<float>(PosY) / 1000;
		SizeXEdit = static_cast<float>(SizeX) / 1000;
		SizeYEdit = static_cast<float>(SizeY) / 1000;
		UEPosX = static_cast<float>(PosX) / COORD_SCALE;
		UEPosY = static_cast<float>(PosY) / COORD_SCALE;
		UESizeX = static_cast<float>(SizeX) / COORD_SCALE;
		UESizeY = static_cast<float>(SizeY) / COORD_SCALE;
	}
	
	void PostEditChangeProperty()
	{
		if (static_cast<float>(PosX) / 1000 != PosXEdit)
		{
			PosX = PosXEdit * 1000;
			UEPosX = static_cast<float>(PosX) / COORD_SCALE;
		}
		if (static_cast<float>(PosY) / 1000 != PosYEdit)
		{
			PosY = PosYEdit * 1000;
			UEPosY = static_cast<float>(PosY) / COORD_SCALE;
		}
		if (static_cast<float>(SizeX) / 1000 != SizeXEdit)
		{
			SizeX = SizeXEdit * 1000;
			UESizeX = static_cast<float>(SizeX) / COORD_SCALE;
		}
		if (static_cast<float>(SizeY) / 1000 != SizeYEdit)
		{
			SizeY = SizeYEdit * 1000;
			UESizeY = static_cast<float>(SizeY) / COORD_SCALE;
		}
		if (static_cast<float>(PosX) / COORD_SCALE != UEPosX)
		{
			PosX = UEPosX * COORD_SCALE;
			PosXEdit = static_cast<float>(PosX) / 1000;
		}
		if (static_cast<float>(PosY) / COORD_SCALE != UEPosY)
		{
			PosY = UEPosY * COORD_SCALE;
			PosYEdit = static_cast<float>(PosY) / 1000;
		}
		if (static_cast<float>(SizeX) / COORD_SCALE != UESizeX)
		{
			SizeX = UESizeX * COORD_SCALE;
			SizeXEdit = static_cast<float>(SizeX) / 1000;
		}
		if (static_cast<float>(SizeY) / COORD_SCALE != UESizeY)
		{
			SizeY = UESizeY * COORD_SCALE;
			SizeYEdit = static_cast<float>(SizeY) / 1000;
		}
	}
#endif
	
	/**
	 * Compares against another collision box for inequality.
	 * 
	 * @param OtherBox The box to compare against.
	 * @return If any of the fields of the other box are different, return true. Otherwise return false.
	 */
	bool operator!=(const FCollisionBox& OtherBox) const
	{
		return this->Type != OtherBox.Type || this->CustomType != OtherBox.CustomType || this->PosX != OtherBox.PosX
			|| this->PosY != OtherBox.PosY || this->SizeX != OtherBox.SizeX || this->SizeY != OtherBox.SizeY;
	}
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/Globals.cpp`:

```cpp
#include "Globals.h"

uint32 isqrt_impl(
	uint64 const n,
	uint64 const xk)
{
	uint64 const xk1 = (xk + n / xk) / 2;
	return (xk1 >= xk) ? xk : isqrt_impl(n, xk1);
}

uint32 isqrt(uint64 const n)
{
	if (n == 0) return 0;
	if (n == 18446744073709551615ULL) return 4294967295U;
	return isqrt_impl(n, n);
}
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/Globals.h`:

```h
#pragma once

#define COORD_SCALE ((double)1000 / 0.43)

/**
 * Implementation of integer square root.
 */
uint32 isqrt_impl(uint64 const n, uint64 const xk);

/**
 * Takes the square root of an integer n without floats.
 * 
 * @param n The integer to take the square root of.
 * @return Returns the square root of n.
 */
uint32 isqrt(uint64 const n);

constexpr int gSinTable[900] =
{
  0,
  1,
  3,
  5,
  6,
  8,
  10,
  12,
  13,
  15,
  17,
  19,
  20,
  22,
  24,
  26,
  27,
  29,
  31,
  33,
  34,
  36,
  38,
  40,
  41,
  43,
  45,
  47,
  48,
  50,
  52,
  54,
  55,
  57,
  59,
  61,
  62,
  64,
  66,
  68,
  69,
  71,
  73,
  74,
  76,
  78,
  80,
  81,
  83,
  85,
  87,
  88,
  90,
  92,
  94,
  95,
  97,
  99,
  101,
  102,
  104,
  106,
  107,
  109,
  111,
  113,
  114,
  116,
  118,
  120,
  121,
  123,
  125,
  127,
  128,
  130,
  132,
  133,
  135,
  137,
  139,
  140,
  142,
  144,
  146,
  147,
  149,
  151,
  152,
  154,
  156,
  158,
  159,
  161,
  163,
  165,
  166,
  168,
  170,
  171,
  173,
  175,
  177,
  178,
  180,
  182,
  183,
  185,
  187,
  189,
  190,
  192,
  194,
  195,
  197,
  199,
  201,
  202,
  204,
  206,
  207,
  209,
  211,
  213,
  214,
  216,
  218,
  219,
  221,
  223,
  224,
  226,
  228,
  230,
  231,
  233,
  235,
  236,
  238,
  240,
  241,
  243,
  245,
  246,
  248,
  250,
  252,
  253,
  255,
  257,
  258,
  260,
  262,
  263,
  265,
  267,
  268,
  270,
  272,
  273,
  275,
  277,
  278,
  280,
  282,
  284,
  285,
  287,
  289,
  290,
  292,
  294,
  295,
  297,
  299,
  300,
  302,
  304,
  305,
  307,
  309,
  310,
  312,
  313,
  315,
  317,
  318,
  320,
  322,
  323,
  325,
  327,
  328,
  330,
  332,
  333,
  335,
  337,
  338,
  340,
  342,
  343,
  345,
  346,
  348,
  350,
  351,
  353,
  355,
  356,
  358,
  359,
  361,
  363,
  364,
  366,
  368,
  369,
  371,
  372,
  374,
  376,
  377,
  379,
  381,
  382,
  384,
  385,
  387,
  389,
  390,
  392,
  393,
  395,
  397,
  398,
  400,
  401,
  403,
  405,
  406,
  408,
  409,
  411,
  413,
  414,
  416,
  417,
  419,
  421,
  422,
  424,
  425,
  427,
  428,
  430,
  432,
  433,
  435,
  436,
  438,
  439,
  441,
  443,
  444,
  446,
  447,
  449,
  450,
  452,
  453,
  455,
  457,
  458,
  460,
  461,
  463,
  464,
  466,
  467,
  469,
  471,
  472,
  474,
  475,
  477,
  478,
  480,
  481,
  483,
  484,
  486,
  487,
  489,
  490,
  492,
  493,
  495,
  496,
  498,
  500,
  501,
  503,
  504,
  506,
  507,
  509,
  510,
  512,
  513,
  515,
  516,
  518,
  519,
  521,
  522,
  523,
  525,
  526,
  528,
  529,
  531,
  532,
  534,
  535,
  537,
  538,
  540,
  541,
  543,
  544,
  546,
  547,
  549,
  550,
  551,
  553,
  554,
  556,
  557,
  559,
  560,
  562,
  563,
  564,
  566,
  567,
  569,
  570,
  572,
  573,
  575,
  576,
  577,
  579,
  580,
  582,
  583,
  584,
  586,
  587,
  589,
  590,
  592,
  593,
  594,
  596,
  597,
  599,
  600,
  601,
  603,
  604,
  605,
  607,
  608,
  610,
  611,
  612,
  614,
  615,
  617,
  618,
  619,
  621,
  622,
  623,
  625,
  626,
  627,
  629,
  630,
  632,
  633,
  634,
  636,
  637,
  638,
  640,
  641,
  642,
  644,
  645,
  646,
  648,
  649,
  650,
  652,
  653,
  654,
  656,
  657,
  658,
  660,
  661,
  662,
  663,
  665,
  666,
  667,
  669,
  670,
  671,
  673,
  674,
  675,
  676,
  678,
  679,
  680,
  681,
  683,
  684,
  685,
  687,
  688,
  689,
  690,
  692,
  693,
  694,
  695,
  697,
  698,
  699,
  700,
  702,
  703,
  704,
  705,
  707,
  708,
  709,
  710,
  712,
  713,
  714,
  715,
  716,
  718,
  719,
  720,
  721,
  722,
  724,
  725,
  726,
  727,
  728,
  730,
  731,
  732,
  733,
  734,
  736,
  737,
  738,
  739,
  740,
  741,
  743,
  744,
  745,
  746,
  747,
  748,
  750,
  751,
  752,
  753,
  754,
  755,
  756,
  758,
  759,
  760,
  761,
  762,
  763,
  764,
  766,
  767,
  768,
  769,
  770,
  771,
  772,
  773,
  774,
  776,
  777,
  778,
  779,
  780,
  781,
  782,
  783,
  784,
  785,
  786,
  788,
  789,
  790,
  791,
  792,
  793,
  794,
  795,
  796,
  797,
  798,
  799,
  800,
  801,
  802,
  803,
  804,
  805,
  806,
  807,
  809,
  810,
  811,
  812,
  813,
  814,
  815,
  816,
  817,
  818,
  819,
  820,
  821,
  822,
  823,
  824,
  825,
  826,
  827,
  828,
  829,
  830,
  830,
  831,
  832,
  833,
  834,
  835,
  836,
  837,
  838,
  839,
  840,
  841,
  842,
  843,
  844,
  845,
  846,
  847,
  848,
  848,
  849,
  850,
  851,
  852,
  853,
  854,
  855,
  856,
  857,
  858,
  858,
  859,
  860,
  861,
  862,
  863,
  864,
  865,
  866,
  866,
  867,
  868,
  869,
  870,
  871,
  872,
  872,
  873,
  874,
  875,
  876,
  877,
  877,
  878,
  879,
  880,
  881,
  882,
  882,
  883,
  884,
  885,
  886,
  887,
  887,
  888,
  889,
  890,
  891,
  891,
  892,
  893,
  894,
  894,
  895,
  896,
  897,
  898,
  898,
  899,
  900,
  901,
  901,
  902,
  903,
  904,
  904,
  905,
  906,
  907,
  907,
  908,
  909,
  909,
  910,
  911,
  912,
  912,
  913,
  914,
  914,
  915,
  916,
  917,
  917,
  918,
  919,
  919,
  920,
  921,
  921,
  922,
  923,
  923,
  924,
  925,
  925,
  926,
  927,
  927,
  928,
  929,
  929,
  930,
  931,
  931,
  932,
  932,
  933,
  934,
  934,
  935,
  936,
  936,
  937,
  937,
  938,
  939,
  939,
  940,
  940,
  941,
  942,
  942,
  943,
  943,
  944,
  944,
  945,
  946,
  946,
  947,
  947,
  948,
  948,
  949,
  949,
  950,
  951,
  951,
  952,
  952,
  953,
  953,
  954,
  954,
  955,
  955,
  956,
  956,
  957,
  957,
  958,
  958,
  959,
  959,
  960,
  960,
  961,
  961,
  962,
  962,
  963,
  963,
  964,
  964,
  965,
  965,
  965,
  966,
  966,
  967,
  967,
  968,
  968,
  969,
  969,
  969,
  970,
  970,
  971,
  971,
  971,
  972,
  972,
  973,
  973,
  973,
  974,
  974,
  975,
  975,
  975,
  976,
  976,
  977,
  977,
  977,
  978,
  978,
  978,
  979,
  979,
  979,
  980,
  980,
  980,
  981,
  981,
  981,
  982,
  982,
  982,
  983,
  983,
  983,
  984,
  984,
  984,
  985,
  985,
  985,
  985,
  986,
  986,
  986,
  987,
  987,
  987,
  987,
  988,
  988,
  988,
  989,
  989,
  989,
  989,
  990,
  990,
  990,
  990,
  990,
  991,
  991,
  991,
  991,
  992,
  992,
  992,
  992,
  992,
  993,
  993,
  993,
  993,
  993,
  994,
  994,
  994,
  994,
  994,
  995,
  995,
  995,
  995,
  995,
  995,
  996,
  996,
  996,
  996,
  996,
  996,
  996,
  997,
  997,
  997,
  997,
  997,
  997,
  997,
  997,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  998,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999,
  999
};
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/InputBuffer.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "InputBuffer.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(InputBuffer)

void FInputBuffer::WriteInputCondition(const FInputCondition& InputCondition)
{
	switch (InputCondition.Method)
	{
	case EInputMethod::Normal:
	case EInputMethod::Strict:
		{
			for (int i = 0; i < InputCondition.Sequence.Num(); i++)
			{
				Update(InputCondition.Sequence[i].InputFlag);
			}
			break;
		}
	case EInputMethod::Once:
	case EInputMethod::OnceStrict:
		{
			Update(INP_Neutral);
			for (int i = 0; i < InputCondition.Sequence.Num(); i++)
			{
				Update(InputCondition.Sequence[i].InputFlag);
			}
			break;
		}
	case EInputMethod::PressAndRelease:
	case EInputMethod::PressAndReleaseStrict:
		{
			for (int i = 0; i < InputCondition.Sequence.Num(); i++)
			{
				for (int j = 0; j < InputCondition.Sequence[i].Hold; j++)
				{
					Update(InputCondition.Sequence[i].InputFlag);
				}
			}
			break;
		}
	case EInputMethod::Negative:
	case EInputMethod::NegativeStrict:
		{
			for (int i = 0; i < InputCondition.Sequence.Num(); i++)
			{
				Update(InputCondition.Sequence[i].InputFlag);
				Update(INP_Neutral);
			}
			break;
		}
	default:
		break;
	}
}

void FInputBuffer::Update(int32 Input, bool bStopped)
{
	if (!bStopped)
	{
		for (auto& Window : InputTime)
		{
			Window++;
		}
	}

	if (Input == InputBufferInternal[InputBufferSize - 1]) 
		return;
	
	for (int32 i = 0; i < InputBufferSize - 1; i++)
	{
		InputBufferInternal[i] = InputBufferInternal[i + 1];
		InputTime[i] = InputTime[i + 1];
	}
	InputBufferInternal[InputBufferSize - 1] = Input;
	InputTime[InputBufferSize - 1] = 0;
}

void FInputBuffer::Emplace(int32 Input, uint32 Index)
{
	if (Index > InputBufferSize - 1) return;

	InputBufferInternal[Index] |= Input;
}

bool FInputBuffer::CheckInputCondition(const FInputCondition& InputCondition)
{
	for (int i = 0; i < InputSequenceSize; i++)
	{
		if (i >= InputCondition.Sequence.Num())
		{
			InputSequence[i].InputFlag = -1;
			continue;
		}
		InputSequence[i] = InputCondition.Sequence[i];
	}
	DisallowedInputs = InputCondition.DisallowedInputs;
	ImpreciseInputCount = InputCondition.ImpreciseInputCount;
	switch (InputCondition.Method)
	{
	case EInputMethod::Normal:
		return CheckInputSequence();
	case EInputMethod::Strict:
		return CheckInputSequenceStrict();
	case EInputMethod::Once:
		return CheckInputSequenceOnce();
	case EInputMethod::OnceStrict:
		return CheckInputSequenceOnceStrict();
	case EInputMethod::PressAndRelease:
		return CheckInputSequencePressAndRelease();
	case EInputMethod::PressAndReleaseStrict:
		return CheckInputSequencePressAndReleaseStrict();
	case EInputMethod::Negative:
		return CheckInputSequenceNegative();
	case EInputMethod::NegativeStrict:
		return CheckInputSequenceNegativeStrict();
	default:
		return false;
	}
}

bool FInputBuffer::CheckInputSequence() const
{
	int32 InputIndex = -10;
	for (int32 i = InputSequenceSize - 1; i > -1; i--)
	{
		if (InputSequence[i].InputFlag != -1)
		{
			InputIndex = i;
			break;
		}
	}
	int32 FramesSinceLastMatch = 0; //how long it's been since last input match

	for (int32 i = InputBufferSize - 1; i >= 0;)
	{
		if (InputIndex == -1) //check if input sequence has been fully read
			return true;
		
		const int32 NeededInput = InputSequence[InputIndex].InputFlag;
		if (FramesSinceLastMatch > InputSequence[InputIndex].Lenience)
			return false;
		
		FramesSinceLastMatch += InputTime[i];
		
		for (auto DisallowedInput : DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}
		
		if ((InputBufferInternal[i] & NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...
		{
			if (InputSequence[InputIndex].Hold > 0 && FramesSinceLastMatch < InputSequence[InputIndex].Hold) //if button held for less than required...
			{
				i--;
				continue;
			}
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
		}
		i--;
	}

	return false;
}

bool FInputBuffer::CheckInputSequenceStrict() const
{
	int32 InputIndex = -10;
	for (int32 i = InputSequenceSize - 1; i > -1; i--)
	{
		if (InputSequence[i].InputFlag != -1)
		{
			InputIndex = i;
			break;
		}
	}
	int32 FramesSinceLastMatch = 0; //how long it's been since last input match
	int32 ImpreciseMatches = 0;

	for (int32 i = InputBufferSize - 1; i >= 0;)
	{
		if (InputIndex == -1) //check if input sequence has been fully read
			return true;
		
		const int32 NeededInput = InputSequence[InputIndex].InputFlag;
		if (FramesSinceLastMatch > InputSequence[InputIndex].Lenience)
			return false;

		FramesSinceLastMatch += InputTime[i];

		for (auto DisallowedInput : DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		if ((InputBufferInternal[i] ^ NeededInput) << 27 == 0 || NeededInput == INP_None) //if input matches...
		{
			if (InputSequence[InputIndex].Hold > 0 && FramesSinceLastMatch < InputSequence[InputIndex].Hold) //if button held for less than required...
			{
				i--;
				continue;
			}
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
			i--;
			continue;
		}
		if ((InputBufferInternal[i] & NeededInput) == NeededInput || NeededInput == INP_None) //if input doesn't match precisely...
		{
			if (ImpreciseMatches >= ImpreciseInputCount)
			{
				FramesSinceLastMatch += InputTime[i];
				i--;
				continue;
			}
			if (InputSequence[InputIndex].Hold > 0 && FramesSinceLastMatch < InputSequence[InputIndex].Hold) //if button held for less than required...
			{
				i--;
				continue;
			}
			ImpreciseMatches++;
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
		}
		i--;
	}

	return false;
}

bool FInputBuffer::CheckInputSequenceOnce() const
{
	int32 InputIndex = -10;
	for (int32 i = InputSequenceSize - 1; i > -1; i--)
	{
		if (InputSequence[i].InputFlag != -1)
		{
			InputIndex = i;
			break;
		}
	}
	int32 FramesSinceLastMatch = 0; //how long it's been since last input match

	for (int32 i = InputBufferSize - 1; i >= 0;)
	{
		if (InputIndex < 0) //check if input sequence has been fully read
		{
			FramesSinceLastMatch += InputTime[i + 1];
			if (FramesSinceLastMatch > InputSequence[0].Lenience + InputSequence[InputIndex + 1].Hold) return false;
			if (!(InputBufferInternal[i] & InputSequence[0].InputFlag))
				return true;
			i--;
			continue;
		}
		
		if (FramesSinceLastMatch > InputSequence[InputIndex].Lenience)
			return false;
		
		FramesSinceLastMatch += InputTime[i];

		const int32 NeededInput = InputSequence[InputIndex].InputFlag;

		for (auto DisallowedInput : DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		if ((InputBufferInternal[i] & NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...
		{
			if (InputSequence[InputIndex].Hold > 0 && FramesSinceLastMatch < InputSequence[InputIndex].Hold) //if button held for less than required...
			{
				i--;
				continue;
			}
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
		}
		i--;
	}

	return false;
}

bool FInputBuffer::CheckInputSequenceOnceStrict() const
{
	int32 InputIndex = -10;
	for (int32 i = InputSequenceSize - 1; i > -1; i--)
	{
		if (InputSequence[i].InputFlag!= -1)
		{
			InputIndex = i;
			break;
		}
	}
	int32 FramesSinceLastMatch = 0; //how long it's been since last input match
	int32 ImpreciseMatches = 0;

	for (int32 i = InputBufferSize - 1; i >= 0;)
	{
		if (InputIndex < 0) //check if input sequence has been fully read
		{
			FramesSinceLastMatch += InputTime[i + 1];
			if (FramesSinceLastMatch > InputSequence[0].Lenience + InputSequence[InputIndex + 1].Hold) return false;
			if ((InputBufferInternal[i] ^ InputSequence[0].InputFlag) << 27 == 0)
				return true;
			i--;
			continue;
		}
		
		if (FramesSinceLastMatch > InputSequence[InputIndex].Lenience)
			return false;
		
		FramesSinceLastMatch += InputTime[i];

		const int32 NeededInput = InputSequence[InputIndex].InputFlag;

		for (auto DisallowedInput : DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		if ((InputBufferInternal[i] ^ NeededInput) << 27 == 0 || NeededInput == INP_None) //if input matches...
		{
			if (InputSequence[InputIndex].Hold > 0 && FramesSinceLastMatch < InputSequence[InputIndex].Hold) //if button held for less than required...
			{
				i--;
				continue;
			}
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
			i--;
			continue;
		}
		if ((InputBufferInternal[i] & NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...
		{
			if (ImpreciseMatches >= ImpreciseInputCount)
			{
				FramesSinceLastMatch += InputTime[i];
				i--;
				continue;
			}
			if (InputSequence[InputIndex].Hold > 0 && FramesSinceLastMatch < InputSequence[InputIndex].Hold) //if button held for less than required...
			{
				i--;
				continue;
			}
			ImpreciseMatches++;
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
		}
		i--;
	}

	return false;
}

bool FInputBuffer::CheckInputSequencePressAndRelease() const
{
	int32 InputIndex = -10;
	for (int32 i = InputSequenceSize - 1; i > -1; i--)
	{
		if (InputSequence[i].InputFlag != -1)
		{
			InputIndex = i;
			break;
		}
	}
	int32 FramesSinceLastMatch = 0; //how long it's been since last input match
	int32 FirstMatch = -1;
	const int32 LastInputIndex = InputIndex;

	for (int32 i = InputBufferSize - 2; i >= 0;)
	{
		if (InputIndex < 0) //check if input sequence has been fully read
		{
			if (FramesSinceLastMatch > InputSequence[0].Lenience + InputSequence[InputIndex + 1].Hold) return false;
			if (!(InputBufferInternal[i] & InputSequence[0].InputFlag))
				break;
			FramesSinceLastMatch += InputTime[i] - InputTime[i + 1];
			i--;
			continue;
		}
		
		const int32 NeededInput = InputSequence[InputIndex].InputFlag;
		if (FramesSinceLastMatch > InputSequence[InputIndex].Lenience)
			return false;

		FramesSinceLastMatch += InputTime[i];

		for (auto DisallowedInput : DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		if ((InputBufferInternal[i] & NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...
		{
			if (InputSequence[InputIndex].Hold > 0 && FramesSinceLastMatch < InputSequence[InputIndex].Hold) //if button held for less than required...
			{
				i--;
				continue;
			}
			if (FirstMatch == -1) FirstMatch = i;
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
		}
		i--;
	}

	if (FirstMatch == -1) return false;
	for (int i = FirstMatch + 1; i < InputBufferSize; i++)
	{
		if ((InputBufferInternal[i] & InputSequence[LastInputIndex].InputFlag) != InputSequence[LastInputIndex].InputFlag) return true;
	}

	return false;
}

bool FInputBuffer::CheckInputSequencePressAndReleaseStrict() const
{
	int32 InputIndex = -10;
	for (int32 i = InputSequenceSize - 1; i > -1; i--)
	{
		if (InputSequence[i].InputFlag!= -1)
		{
			InputIndex = i;
			break;
		}
	}
	int32 FramesSinceLastMatch = 0; //how long it's been since last input match
	int32 ImpreciseMatches = 0;
	int32 FirstMatch = -1;
	const int32 LastInputIndex = InputIndex;

	for (int32 i = InputBufferSize - 2; i >= 0;)
	{
		if (InputIndex < 0) //check if input sequence has been fully read
		{
			if (FramesSinceLastMatch > InputSequence[0].Lenience + InputSequence[InputIndex + 1].Hold) return false;
			if ((InputBufferInternal[i] ^ InputSequence[0].InputFlag) << 27 != 0)
				break;
			FramesSinceLastMatch += InputTime[i] - InputTime[i + 1];
			i--;
			continue;
		}
		
		const int32 NeededInput = InputSequence[InputIndex].InputFlag;
		FramesSinceLastMatch += InputTime[i];

		for (auto DisallowedInput : DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		if ((InputBufferInternal[i] ^ NeededInput) << 27 == 0 || NeededInput == INP_None) //if input matches...
		{
			if (InputSequence[InputIndex].Hold > 0 && FramesSinceLastMatch < InputSequence[InputIndex].Hold) //if button held for less than required...
			{
				i--;
				continue;
			}
			if (FirstMatch == -1) FirstMatch = i;
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
			i--;
			continue;
		}
		if ((InputBufferInternal[i] & NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...
		{
			if (ImpreciseMatches >= ImpreciseInputCount)
			{
				FramesSinceLastMatch += InputTime[i];
				i--;
				continue;
			}
			if (InputSequence[InputIndex].Hold > 0 && FramesSinceLastMatch < InputSequence[InputIndex].Hold) //if button held for less than required...
			{
				i--;
				continue;
			}
			if (FirstMatch == -1) FirstMatch = i;
			ImpreciseMatches++;
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
		}
		i--;
	}

	if (FirstMatch == -1) return false;
	for (int i = FirstMatch + 1; i < InputBufferSize; i++)
	{
		if ((InputBufferInternal[i] & InputSequence[LastInputIndex].InputFlag) != InputSequence[LastInputIndex].InputFlag) return true;
	}
	
	return false;
}

bool FInputBuffer::CheckInputSequenceNegative() const
{
	int32 InputIndex = -10;
	for (int32 i = InputSequenceSize - 1; i > -1; i--)
	{
		if (InputSequence[i].InputFlag != -1)
		{
			InputIndex = i;
			break;
		}
	}
	int32 FramesSinceLastMatch = 0; //how long it's been since last input match
	
	for (int32 i = InputBufferSize - 2; i >= 0;)
	{
		if (InputIndex == -1) //check if input sequence has been fully read
			return true;

		const int32 NeededInput = InputSequence[InputIndex].InputFlag;

		if (FramesSinceLastMatch > InputSequence[InputIndex].Lenience)
			return false;

		FramesSinceLastMatch += InputTime[i];

		for (auto DisallowedInput : DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		if ((InputBufferInternal[i] & NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...
		{
			if ((InputBufferInternal[i + 1] & NeededInput) == NeededInput || NeededInput == INP_None) continue;
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
		}
		i--;
	}

	return false;
}

bool FInputBuffer::CheckInputSequenceNegativeStrict() const
{
	int32 InputIndex = -10;
	for (int32 i = InputSequenceSize - 1; i > -1; i--)
	{
		if (InputSequence[i].InputFlag!= -1)
		{
			InputIndex = i;
			break;
		}
	}
	int32 FramesSinceLastMatch = 0; //how long it's been since last input match
	int32 ImpreciseMatches = 0;

	for (int32 i = InputBufferSize - 2; i >= 0;)
	{
		if (InputIndex == -1) //check if input sequence has been fully read
			return true;

		const int32 NeededInput = InputSequence[InputIndex].InputFlag;

		if (FramesSinceLastMatch > InputSequence[InputIndex].Lenience)
			return false;

		FramesSinceLastMatch += InputTime[i];

		for (auto DisallowedInput : DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)
		{
			if ((InputBufferInternal[i] & DisallowedInput) == DisallowedInput) return false;
		}

		if ((InputBufferInternal[i] ^ NeededInput) << 27 == 0 || NeededInput == INP_None) //if input matches...
		{
			if ((InputBufferInternal[i + 1] & NeededInput) == NeededInput || NeededInput == INP_None) continue;
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
			i--;
			continue;
		}
		if ((InputBufferInternal[i] & NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...
		{
			if (ImpreciseMatches >= ImpreciseInputCount)
			{
				FramesSinceLastMatch += InputTime[i];
				i--;
				continue;
			}
			if ((InputBufferInternal[i + 1] & NeededInput) == NeededInput || NeededInput == INP_None) continue;
			ImpreciseMatches++;
			FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match
			InputIndex--; //advance sequence
		}
		i--;
	}

	return false;
}

void FInputBuffer::FlipInputsInBuffer()
{
	for (int i = 0; i < InputBufferSize; i++)
	{
		const unsigned int Bit1 = (InputBufferInternal[i] >> 2) & 1;
		const unsigned int Bit2 = (InputBufferInternal[i] >> 3) & 1;
		unsigned int x = (Bit1 ^ Bit2);

		x = x << 2 | x << 3;

		InputBufferInternal[i] = InputBufferInternal[i] ^ x;
	}
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/InputBuffer.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NightSkyEngine/Battle/Script/State.h"
#include "InputBuffer.generated.h"

constexpr int32 InputSequenceSize = 0x10;
constexpr int32 InputBufferSize = 0x20;

/**
 * @brief The input buffer for a player object.
 *
 * Stores inputs every frame, and handles input checking.
 */
USTRUCT()
struct FInputBuffer
{
	GENERATED_BODY()
	
private:
	/**
	 * The input sequence. Updated by the input being checked.
	 */
	FInputBitmask InputSequence[InputSequenceSize] = {  };
	/**
	 * How much time is allowed between inputs. Updated by the input being checked.
	 */
	int32 ImpreciseInputCount = 0;
	/**
	 * Disallowed inputs. If any inputs in this array are detected, the entire condition is invalidated.
	 */
	TArray<TEnumAsByte<EInputFlags>> DisallowedInputs{};

	
public:
	/**
	 * All stored inputs.
	 * Inputs are stored with the newest at the end and the oldest at the beginning.
	 */
	int32 InputBufferInternal[InputBufferSize] = { 16 };
	/**
	 * All input times.
	 * Input times are looped over and incremented every actionable frame.
	 */
	int32 InputTime[InputBufferSize] = {};

	/**
	 * Writes an input condition to the buffer. For use with CPU.
	 * @param InputCondition The input condition to write.
	 */
	void WriteInputCondition(const FInputCondition& InputCondition);
	
	/**
	 * @brief Stores the input for this frame.
	 * 
	 * @param Input The input bitmask to store.
	 * @param bStopped If the owning object is in hitstop/super freeze.
	 */
	void Update(int32 Input, bool bStopped = false);
	/**
	 * @brief Stores the input at an arbitrary buffer position. Intended for CPU usage.
	 * 
	 * @param Input The input bitmask to store.
	 * @param Index The index of the buffer to store at.
	 */
	void Emplace(int32 Input, uint32 Index);
	/**
	 * @brief Checks an input condition against the buffer.
	 * 
	 * @param InputCondition The input condition to check.
	 * @return If the input condition matches the buffer, return true. Otherwise return false.
	 */
	bool CheckInputCondition(const FInputCondition& InputCondition);

	/**
	 * Checks the input sequence against the buffer with the Normal method.
	 * @see EInputMethod
	 * 
	 * @return If the input sequence matches the buffer, return true. Otherwise return false. 
	 */
	bool CheckInputSequence() const;
	/**
	 * Checks the input sequence against the buffer with the Strict method.
	 * @see EInputMethod
	 * 
	 * @return If the input sequence matches the buffer, return true. Otherwise return false. 
	 */
	bool CheckInputSequenceStrict() const;
	/**
	 * Checks the input sequence against the buffer with the Once method.
	 * @see EInputMethod
	 * 
	 * @return If the input sequence matches the buffer, return true. Otherwise return false. 
	 */
	bool CheckInputSequenceOnce() const;
	/**
	 * Checks the input sequence against the buffer with the Once Strict method.
	 * @see EInputMethod
	 * 
	 * @return If the input sequence matches the buffer, return true. Otherwise return false. 
	 */
	bool CheckInputSequenceOnceStrict() const;
	/**
	 * Checks the input sequence against the buffer with the Once method.
	 * @see EInputMethod
	 * 
	 * @return If the input sequence matches the buffer, return true. Otherwise return false. 
	 */
	bool CheckInputSequencePressAndRelease() const;
	/**
	 * Checks the input sequence against the buffer with the Once Strict method.
	 * @see EInputMethod
	 * 
	 * @return If the input sequence matches the buffer, return true. Otherwise return false. 
	 */
	bool CheckInputSequencePressAndReleaseStrict() const;
	/**
	 * Checks the input sequence against the buffer with the Negative method.
	 * @see EInputMethod
	 * 
	 * @return If the input sequence matches the buffer, return true. Otherwise return false. 
	 */
	bool CheckInputSequenceNegative() const;
	/**
	 * Checks the input sequence against the buffer with the Negative Strict method.
	 * @see EInputMethod
	 * 
	 * @return If the input sequence matches the buffer, return true. Otherwise return false. 
	 */
	bool CheckInputSequenceNegativeStrict() const;
	/**
	 * Flips the directional inputs in the buffer. For use after a character switches sides.
	 */
	void FlipInputsInBuffer();
};
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/NightSkyBlueprintFunctionLibrary.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyBlueprintFunctionLibrary.h"

#include "Globals.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyBlueprintFunctionLibrary)

int32 UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(int32 x, int32 y)
{
	int32 Angle = static_cast<int>(atan2(y, x) * 57295.77791868204) % 360000;
	if (Angle < 0)
		Angle += 360000;
	return Angle;
}

int32 UNightSkyBlueprintFunctionLibrary::Cos_x1000(int32 Deg_x10)
{
	int32 Tmp1 = (Deg_x10 + 900) % 3600;
	int32 Tmp2 = Deg_x10 + 3600;
	if (Tmp1 >= 0)
		Tmp2 = Tmp1;
	if (Tmp2 < 900)
		return gSinTable[Tmp2];
	if (Tmp2 < 1800)
		return gSinTable[1799 - Tmp2];
	if (Tmp2 >= 2700)
		return -gSinTable[3599 - Tmp2];
	return -gSinTable[Tmp2 - 1800];
}

int32 UNightSkyBlueprintFunctionLibrary::Sin_x1000(int32 Deg_x10)
{
	int32 Tmp1 = Deg_x10 % 3600;
	int32 Tmp2 = Deg_x10 + 3600;
	if (Tmp1 >= 0)
		Tmp2 = Tmp1;
	if (Tmp2 < 900)
		return gSinTable[Tmp2];
	if (Tmp2 < 1800)
		return gSinTable[1799 - Tmp2];
	if (Tmp2 >= 2700)
		return -gSinTable[3599 - Tmp2];
	return -gSinTable[Tmp2 - 1800];
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/NightSkyBlueprintFunctionLibrary.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "NightSkyBlueprintFunctionLibrary.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UNightSkyBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintPure)
	static int32 Vec2Angle_x1000(int32 x, int32 y);
	UFUNCTION(BlueprintPure)
	static int32 Cos_x1000(int32 Deg_x10);
	UFUNCTION(BlueprintPure)
	static int32 Sin_x1000(int32 Deg_x10);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/RandomManager.cpp`:

```cpp
#include "RandomManager.h"
#include "GenericPlatform/GenericPlatformMath.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RandomManager)

int32 FRandomManager::GenerateRandomNumber()
{
	return FGenericPlatformMath::Rand();
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/RandomManager.h`:

```h
#pragma once
#include "CoreMinimal.h"
#include "RandomManager.generated.h"

USTRUCT()
struct FRandomManager
{
	GENERATED_BODY()
private:
	uint32 Seed = 1;
public:
	FRandomManager() {}
	FRandomManager(uint32 InSeed) : Seed(InSeed) {}

	int Rand()
	{
		Seed = Seed * 1103515245 + 12345;
		return Seed / 65536 % 32768;
	}

	int RandRange(int Min, int Max)
	{
		if (Min > Max)
		{
			const int32 Temp = Max;
			Max = Min;
			Min = Temp;
		}
		int32 Result = Rand();
		Result = Result % (Max - Min + 1) + Min;
		return Result;
	}
	
	void Reseed(uint32 InSeed)
	{
		Seed = InSeed;
	}

	uint32 GetSeed() const
	{
		return Seed;
	}

	int32 GenerateRandomNumber();
};
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/SerializableObj.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "SerializableObj.h"

#include "Serialization/ObjectReader.h"
#include "Serialization/ObjectWriter.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(SerializableObj)

TArray<uint8> USerializableObj::SaveForRollback()
{
	TArray<uint8> SaveData;
	FObjectWriter Writer(SaveData);
	Writer.ArIsSaveGame = true;
	GetClass()->SerializeBin(Writer, this);
	return SaveData;
}

void USerializableObj::LoadForRollback(const TArray<uint8>& InBytes)
{
	if (InBytes.Num() <= 1) return;
	FObjectReader Reader(InBytes);
	Reader.ArIsSaveGame = true;
	GetClass()->SerializeBin(Reader, this);
}

void USerializableObj::ResetToCDO()
{
	const auto CDO = Cast<USerializableObj>(GetClass()->GetDefaultObject());
	LoadForRollback(CDO->SaveForRollback());
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/SerializableObj.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "SerializableObj.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API USerializableObj : public UObject
{
	GENERATED_BODY()
	
public:
	TArray<uint8> SaveForRollback();
	void LoadForRollback(const TArray<uint8>& InBytes);
	void ResetToCDO();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyGameState.h"
#include "LevelSequenceActor.h"
#include "LevelSequencePlayer.h"
#include "NightSkyPlayerController.h"
#include "Actors/ParticleManager.h"
#include "Camera/CameraActor.h"
#include "CineCameraActor.h"
#include "Camera/CameraComponent.h"
#include "Components/AudioComponent.h"
#include "Components/SlateWrapperTypes.h"
#include "FighterRunners/FighterReplayRunner.h"
#include "FighterRunners/FighterSynctestRunner.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetMathLibrary.h"
#include "Misc/Globals.h"
#include "NightSkyEngine/Battle/CPU/NightSkyAIController.h"
#include "NightSkyEngine/Data/BattleExtensionData.h"
#include "NightSkyEngine/Data/PrimaryCharaData.h"
#include "NightSkyEngine/Data/SubroutineData.h"
#include "NightSkyEngine/Network/FighterRunners.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "NightSkyEngine/UI/NightSkyBattleHudActor.h"
#include "NightSkyEngine/UI/NightSkyBattleWidget.h"
#include "Serialization/ObjectReader.h"
#include "Serialization/ObjectWriter.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyGameState)

void FRollbackData::Serialize(FArchive& Ar)
{
	Ar << ObjActive;
	Ar << ObjBuffer;
	Ar << CharBuffer;
	Ar << BattleStateBuffer;
	Ar << BattleStateData;
	Ar << PlayerData;
	Ar << StateData;
	Ar << ExtensionData;
	Ar << WidgetAnimationData;
}

// Sets default values
ANightSkyGameState::ANightSkyGameState()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	SequenceCameraActorClass = ACineCameraActor::StaticClass();
}

// Called when the game starts or when spawned
void ANightSkyGameState::BeginPlay()
{
	Super::BeginPlay();

	FActorSpawnParameters SpawnParameters;
	ParticleManager = GetWorld()->SpawnActor<AParticleManager>();
	AudioManager = GetWorld()->SpawnActor<AAudioManager>();
	GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
	CameraActor = GetWorld()->SpawnActor<ACameraActor>(ACameraActor::StaticClass());
	CameraActor->GetCameraComponent()->SetFieldOfView(54);
	SequenceCameraActor = GetWorld()->SpawnActor<ACineCameraActor>(SequenceCameraActorClass);
	SequenceActor = GetWorld()->SpawnActor<ALevelSequenceActor>(ALevelSequenceActor::StaticClass());

	UpdateCamera();

	Init();
}

void ANightSkyGameState::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);
	GameInstance->EndRecordReplay();
}

void ANightSkyGameState::Init()
{
	if (IsValid(BattleExtensionData))
	{
		for (auto Extension : BattleExtensionData->ExtensionArray)
		{
			BattleExtensions.Add(NewObject<UBattleExtension>(this, Extension));
			BattleExtensions.Last()->Parent = this;
			BattleExtensionNames.Add(BattleExtensions.Last()->Name);
		}
	}

	for (int i = 0; i < GameInstance->BattleData.PlayerListP1.Num(); i++)
	{
		APlayerObject* SpawnedPlayer;
		if (const auto Player = GameInstance->BattleData.PlayerListP1[i]; Player != nullptr)
		{
			Players.Add(GetWorld()->SpawnActor<APlayerObject>(Player->PlayerClass,
			                                                  BattleSceneTransform));
			SpawnedPlayer = Players.Last();
			SpawnedPlayer->ColorIndex = 1;
			if (GameInstance->BattleData.ColorIndicesP1.Num() > i)
				SpawnedPlayer->ColorIndex = GameInstance->BattleData.ColorIndicesP1[i];
		}
		else
		{
			Players.Add(GetWorld()->SpawnActor<APlayerObject>(APlayerObject::StaticClass(), BattleSceneTransform));
			SpawnedPlayer = Players.Last();
		}
		SortedObjects.Add(SpawnedPlayer);
		SpawnedPlayer->GameState = this;
	}

	for (int i = 0; i < GameInstance->BattleData.PlayerListP2.Num(); i++)
	{
		APlayerObject* SpawnedPlayer;
		if (const auto Player = GameInstance->BattleData.PlayerListP2[i]; Player != nullptr)
		{
			Players.Add(GetWorld()->SpawnActor<APlayerObject>(Player->PlayerClass,
			                                                  BattleSceneTransform));
			SpawnedPlayer = Players.Last();
			SpawnedPlayer->ColorIndex = 1;
			if (GameInstance->BattleData.ColorIndicesP2.Num() > i)
				SpawnedPlayer->ColorIndex = GameInstance->BattleData.ColorIndicesP2[i];
			for (int j = 0; j < GameInstance->BattleData.PlayerListP1.Num(); j++)
			{
				if (IsValid(GameInstance->BattleData.PlayerListP1[j]))
				{
					if (SpawnedPlayer->IsA(GameInstance->BattleData.PlayerListP1[j]->PlayerClass))
					{
						if (SpawnedPlayer->ColorIndex == Players[j]->ColorIndex)
						{
							if (SpawnedPlayer->ColorIndex > 1)
								SpawnedPlayer->ColorIndex = 1;
							else
								SpawnedPlayer->ColorIndex = 2;
						}
						break;
					}
				}
			}
		}
		else
		{
			Players.Add(GetWorld()->SpawnActor<APlayerObject>(APlayerObject::StaticClass(), BattleSceneTransform));
			SpawnedPlayer = Players.Last();
		}
		SortedObjects.Add(SpawnedPlayer);
		SpawnedPlayer->GameState = this;

		if (GameInstance->IsCPUBattle && !GameInstance->IsTraining)
		{
			SpawnedPlayer->SpawnDefaultController();
			SpawnedPlayer->bIsCpu = true;
		}
	}

	for (int i = 0; i < MaxBattleObjects; i++)
	{
		Objects.Add(GetWorld()->SpawnActor<ABattleObject>(BattleObjectClass, BattleSceneTransform));
		Objects[i]->GameState = this;
		SortedObjects.Add(Objects.Last());
	}

	MatchInit();
	HUDInit();

	if (!GameInstance->IsReplay)
	{
		GameInstance->EndRecordReplay();
		// GameInstance->RecordReplay();
	}
}

void ANightSkyGameState::PlayIntros()
{
	if (GameInstance->IsTraining)
	{
		BattleState.BattlePhase = EBattlePhase::Battle;
		GetMainPlayer(true)->JumpToStatePrimary(State_Universal_Stand);
		GetMainPlayer(false)->JumpToStatePrimary(State_Universal_Stand);
		return;
	}
	BattleState.BattlePhase = EBattlePhase::Intro;
	BattleState.CurrentIntroSide = INT_P1;
	GetMainPlayer(true)->JumpToStatePrimary(GetMainPlayer(true)->IntroName);
	BattleHudVisibility(false);
}

void ANightSkyGameState::RoundInit()
{
	BattleState.PauseTimer = false;
	BattleState.RandomManager.Reseed(BattleState.RandomManager.Rand() + BattleState.RoundCount);
	BattleState.RoundCount++;

	BattleState.SuperFreezeSelfDuration = 0;
	BattleState.SuperFreezeDuration = 0;
	BattleState.SuperFreezeCaller = nullptr;
	BattleState.BattlePhase = EBattlePhase::Battle;
	BattleState.FadeTimer = BattleState.MaxFadeTimer;

	if (BattleState.BattleFormat == EBattleFormat::Rounds || BattleState.RoundCount == 1)
	{
		BattleState.ScreenData = Cast<ANightSkyGameState>(GetClass()->GetDefaultObject())->BattleState.ScreenData;

		if (!GameInstance->IsTraining)
			BattleState.TimeUntilRoundStart = BattleState.MaxTimeUntilRoundStart;
		for (int i = 0; i < MaxBattleObjects; i++)
			Objects[i]->ResetObject();

		for (const auto Player : Players)
		{
			Player->RoundInit(true);
			if (!Player->IsMainPlayer()) Player->SetOnScreen(false);
		}

		GetMainPlayer(true)->JumpToStatePrimary(State_Universal_Stand);
		GetMainPlayer(false)->JumpToStatePrimary(State_Universal_Stand);

		Players[0]->PlayerFlags = PLF_IsOnScreen;
		Players[BattleState.TeamData[0].TeamCount]->PlayerFlags = PLF_IsOnScreen;

		BattleState.MaxMeter[0] = Players[0]->MaxMeter;
		BattleState.MaxMeter[1] = Players[BattleState.TeamData[0].TeamCount]->MaxMeter;

		BattleState.RoundTimer = GameInstance->BattleData.StartRoundTimer * 60;
		BattleState.bHUDVisible = true;

		UpdateCamera();
		CallBattleExtension(BattleExtension_RoundInit);
	}
	else if (BattleState.BattleFormat == EBattleFormat::Tag)
	{
		const bool IsP1 = GetMainPlayer(true)->CurrentHealth == 0;
		GetMainPlayer(IsP1)->SetOnScreen(false);
		const auto NewPosX = GetMainPlayer(IsP1)->PosX;
		const auto NewDirection = GetMainPlayer(IsP1)->Direction;
		if (!SwitchMainPlayer(GetMainPlayer(IsP1), 1, true)) return;
		GetMainPlayer(IsP1)->PosX = NewPosX;
		GetMainPlayer(IsP1)->Direction = NewDirection;
		GetMainPlayer(IsP1)->PosY = 0;
		GetMainPlayer(IsP1)->JumpToStatePrimary(State_Universal_TagIn);

		GetMainPlayer(true)->PlayerFlags &= ~PLF_RoundWinInputLock;
		GetMainPlayer(false)->PlayerFlags &= ~PLF_RoundWinInputLock;

		for (const auto& Player : Players) Player->RoundWinTimer = 120;
	}
	else
	{
		BattleState.ScreenData = Cast<ANightSkyGameState>(GetClass()->GetDefaultObject())->BattleState.ScreenData;

		const bool IsP1 = GetMainPlayer(true)->CurrentHealth == 0;
		GetMainPlayer(IsP1)->SetOnScreen(false);
		SwitchMainPlayer(GetMainPlayer(IsP1), 1, true);

		if (!GameInstance->IsTraining)
			BattleState.TimeUntilRoundStart = BattleState.MaxTimeUntilRoundStart;
		for (int i = 0; i < MaxBattleObjects; i++)
			Objects[i]->ResetObject();

		for (const auto Player : Players)
		{
			Player->RoundInit(true);
			if (!Player->IsMainPlayer()) Player->SetOnScreen(false);
		}

		GetMainPlayer(true)->JumpToStatePrimary(State_Universal_Stand);
		GetMainPlayer(false)->JumpToStatePrimary(State_Universal_Stand);

		GetMainPlayer(true)->PlayerFlags = PLF_IsOnScreen;
		GetMainPlayer(false)->PlayerFlags = PLF_IsOnScreen;

		BattleState.MaxMeter[0] = GetMainPlayer(true)->MaxMeter;
		BattleState.MaxMeter[1] = GetMainPlayer(false)->MaxMeter;

		BattleState.RoundTimer = GameInstance->BattleData.StartRoundTimer * 60;
		BattleState.bHUDVisible = true;

		UpdateCamera();
		CallBattleExtension(BattleExtension_RoundInit);
	}

	BattleState.ScreenData.TargetObjects.AddUnique(GetMainPlayer(true));
	BattleState.ScreenData.TargetObjects.AddUnique(GetMainPlayer(false));
	AssignEnemy();
}

void ANightSkyGameState::AssignEnemy()
{
	for (int i = 0; i < Players.Num(); i++)
	{
		if (i < BattleState.TeamData[0].TeamCount)
		{
			Players[i]->Enemy = GetMainPlayer(false);
		}
		else
		{
			Players[i]->Enemy = GetMainPlayer(true);
		}
	}
}

void ANightSkyGameState::UpdateLocalInput()
{
	LocalInputs[0] = GetLocalInputs(0);
	LocalInputs[1] = GetLocalInputs(1);
}

// Called every frame
void ANightSkyGameState::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	FighterRunner->Update(DeltaTime);
}

void ANightSkyGameState::MatchInit()
{
	if (!FighterRunner)
	{
		FActorSpawnParameters SpawnParameters;
		SpawnParameters.Owner = GetOwner();

		switch (GameInstance->FighterRunner)
		{
		case LocalPlay:
			FighterRunner = GetWorld()->SpawnActor<AFighterLocalRunner>(SpawnParameters);
			break;
		case Multiplayer:
			if (GameInstance->IsReplay)
				FighterRunner = GetWorld()->SpawnActor<AFighterReplayRunner>(SpawnParameters);
			else
				FighterRunner = GetWorld()->SpawnActor<AFighterMultiplayerRunner>(SpawnParameters);
			break;
		case SyncTest:
			FighterRunner = GetWorld()->SpawnActor<AFighterSynctestRunner>(SpawnParameters);
			break;
		default:
			FighterRunner = GetWorld()->SpawnActor<AFighterLocalRunner>(SpawnParameters);
			break;
		}
	}

	BattleState = Cast<ANightSkyGameState>(GetClass()->GetDefaultObject())->BattleState;

	BattleState.RandomManager = GameInstance->BattleData.Random;
	BattleState.TeamData[0].TeamCount = GameInstance->BattleData.PlayerListP1.Num();
	BattleState.TeamData[0].CooldownTimer.AddDefaulted(GameInstance->BattleData.PlayerListP1.Num());
	BattleState.TeamData[1].TeamCount = GameInstance->BattleData.PlayerListP2.Num();
	BattleState.TeamData[1].CooldownTimer.AddDefaulted(GameInstance->BattleData.PlayerListP2.Num());
	BattleState.GaugeP1.Empty();
	BattleState.GaugeP2.Empty();
	BattleState.GaugeP1.AddDefaulted(BattleState.MaxGauge.Num());
	BattleState.GaugeP2.AddDefaulted(BattleState.MaxGauge.Num());

	CallBattleExtension(BattleExtension_MatchInit);

	for (int i = 0; i < Players.Num(); i++)
	{
		Players[i]->PlayerIndex = i >= BattleState.TeamData[0].TeamCount;
		Players[i]->TeamIndex = i >= BattleState.TeamData[0].TeamCount ? i - BattleState.TeamData[0].TeamCount : i;
		Players[i]->PlayerFlags &= ~PLF_IsOnScreen;
		Players[i]->ObjNumber = i + MaxBattleObjects;
		Players[i]->CallSubroutine(Subroutine_Cmn_MatchInit);
		Players[i]->CallSubroutine(Subroutine_MatchInit);
	}
	for (int i = 0; i < MaxBattleObjects; i++)
	{
		Objects[i]->ObjNumber = i;
	}
	for (int i = SortedObjects.Num() - 1; i >= 0; i--)
	{
		SetDrawPriorityFront(SortedObjects[i]);
	}

	BattleState.MainPlayer[0] = Players[0];
	BattleState.MainPlayer[0]->PlayerFlags |= PLF_IsOnScreen;
	BattleState.MainPlayer[1] = Players[BattleState.TeamData[0].TeamCount];
	BattleState.MainPlayer[1]->PlayerFlags |= PLF_IsOnScreen;
	BattleState.BattleFormat = GameInstance->BattleData.BattleFormat;
	BattleState.MaxTimeUntilRoundStart = GameInstance->BattleData.TimeUntilRoundStart;
	BattleState.MaxRoundCount = GameInstance->BattleData.RoundCount;
	BattleState.RoundTimer = GameInstance->BattleData.StartRoundTimer * 60;

	PlayMusic(GameInstance->BattleData.MusicName);
	BattleHudActor->BottomWidget->PlayFadeOutAnim();
	RoundInit();
	PlayIntros();
}

void ANightSkyGameState::UpdateGameState(int32 Input1, int32 Input2, bool bShouldResimulate)
{
	if ((Input1 & INP_Rematch) == INP_Rematch && (Input2 & INP_Rematch) == INP_Rematch)
	{
		MatchInit();
		ANightSkyPlayerController* Controller1 = Cast<ANightSkyPlayerController>(
			UGameplayStatics::GetPlayerController(GetWorld(), 0));
		ANightSkyPlayerController* Controller2 = Cast<ANightSkyPlayerController>(
			UGameplayStatics::GetPlayerController(GetWorld(), 1));
		if (Controller1) Controller1->PostRematch();
		if (Controller2) Controller2->PostRematch();
	}
	if (Input1 & INP_ResetTraining || Input2 & INP_ResetTraining)
	{
		ResetTraining();
	}

	if (bShouldResimulate == false && bIsResimulating == true) RollbackStartAudio(BattleState.FrameNumber);
	bIsResimulating = bShouldResimulate;
	LocalFrame++;

	ParticleManager->UpdateParticles();
	UpdateScreen();

	AssignEnemy();

	if (BattleState.BattlePhase == EBattlePhase::Intro)
	{
		if (BattleState.CurrentIntroSide == INT_P1)
		{
			if (GetMainPlayer(true)->IntroEndFlag)
			{
				GetMainPlayer(true)->JumpToStatePrimary(State_Universal_Stand);
				SequenceActor->GetSequencePlayer()->Stop();
				BattleState.CurrentSequenceTime = -1;
				BattleState.IsPlayingSequence = false;
			}
			if (GetMainPlayer(true)->GetCurrentStateName(StateMachine_Primary) != GetMainPlayer(true)->IntroName)
			{
				GetMainPlayer(false)->JumpToStatePrimary(GetMainPlayer(false)->IntroName);
				BattleState.CurrentIntroSide = INT_P2;
			}
		}
		else if (BattleState.CurrentIntroSide == INT_P2)
		{
			bool bIsP1 = false;
			if (GetMainPlayer(false)->bIsCpu)
			{
				bIsP1 = true;
			}
			if (GetMainPlayer(bIsP1)->IntroEndFlag)
			{
				GetMainPlayer(false)->JumpToStatePrimary(State_Universal_Stand);
				SequenceActor->GetSequencePlayer()->Stop();
				BattleState.CurrentSequenceTime = -1;
				BattleState.IsPlayingSequence = false;
			}
			if (GetMainPlayer(false)->GetCurrentStateName(StateMachine_Primary) != GetMainPlayer(false)->IntroName)
			{
				GetMainPlayer(true)->OrthoBlendActive = 1;
				GetMainPlayer(false)->OrthoBlendActive = 1;
				GetMainPlayer(true)->JumpToStatePrimary(State_Universal_Stand);
				GetMainPlayer(false)->JumpToStatePrimary(State_Universal_Stand);
				BattleState.CurrentIntroSide = INT_None;
				BattleState.BattlePhase = EBattlePhase::Battle;
				BattleHudVisibility(true);
				BattleHudActor->BottomWidget->PlayRoundInitAnim();
				BattleState.FadeTimer = BattleState.MaxFadeTimer;
			}
		}
	}
	else
	{
		if (!GameInstance->IsTraining && !BattleState.PauseTimer)
		{
			if (BattleState.TimeUntilRoundStart > 0)
				BattleState.TimeUntilRoundStart--;
			else
				BattleState.RoundTimer--;
		}
	}

	if (BattleState.RoundTimer < 0)
		BattleState.RoundTimer = 0;
	BattleState.FrameNumber++;

	if (!BattleState.SuperFreezeDuration)
	{
		CallBattleExtension(BattleExtension_Update);
		for (int i = 0; i < 2; i++)
		{
			for (auto& Cooldown : BattleState.TeamData[i].CooldownTimer)
			{
				if (Cooldown == 0) continue;
				if (GameInstance->IsTraining && !GetMainPlayer(i == 0)->ComboCounter) Cooldown = 0;
				else Cooldown--;
			}
		}
	}

	if (BattleState.CurrentSequenceTime != -1)
		BattleState.CurrentSequenceTime++;

	SortObjects();

	if (!BattleState.MainPlayer[0]->bIsCpu) BattleState.MainPlayer[0]->Inputs = Input1;
	else if (const auto CPU = Cast<ANightSkyAIController>(BattleState.MainPlayer[0]->Controller); CPU && !bShouldResimulate)
		CPU->Update();
	if (!BattleState.MainPlayer[1]->bIsCpu) BattleState.MainPlayer[1]->Inputs = Input2;
	else if (const auto CPU = Cast<ANightSkyAIController>(BattleState.MainPlayer[1]->Controller); CPU && !bShouldResimulate)
		CPU->Update();

	for (int i = 0; i < SortedObjects.Num(); i++)
	{
		if (i == BattleState.ActiveObjectCount)
			break;
		if (((BattleState.SuperFreezeSelfDuration && SortedObjects[i] == BattleState.SuperFreezeCaller)
				|| (BattleState.SuperFreezeDuration && SortedObjects[i] != BattleState.SuperFreezeCaller))
			&& (SortedObjects[i]->MiscFlags & MISC_IgnoreSuperFreeze) == 0)
		{
			if (SortedObjects[i]->IsPlayer)
			{
				if (SortedObjects[i]->Player->PlayerFlags & PLF_IsStunned)
					SortedObjects[i]->Player->HandleBufferedState();
				SortedObjects[i]->GetBoxes();
				SortedObjects[i]->Player->HandleFlipInput();
				SortedObjects[i]->Player->StoredInputBuffer.Update(SortedObjects[i]->Player->Inputs, true);

				// Handle state transitions
				SortedObjects[i]->Player->HandleStateMachine(
					true, SortedObjects[i]->Player->GetStateMachine(StateMachine_Primary));
				for (auto& StateMachine : SortedObjects[i]->Player->SubStateMachines)
				{
					SortedObjects[i]->Player->HandleStateMachine(false, StateMachine);
				}
			}
			SortedObjects[i]->PositionLinkUpdate();
			if (!SortedObjects[i]->IsPlayer && SortedObjects[i]->MiscFlags & MISC_DeactivateOnNextUpdate)
			{
				SortedObjects[i]->ResetObject();
			}
			continue;
		}
		SortedObjects[i]->Update();
	}

	SortObjects();
	HandleHitCollision();

	if (BattleState.SuperFreezeSelfDuration == 1)
	{
		BattleState.SuperFreezeCaller->TriggerEvent(EVT_SuperFreezeEnd, StateMachine_Primary);
	}
	if (BattleState.SuperFreezeDuration == 1)
	{
		for (int i = 0; i < SortedObjects.Num(); i++)
		{
			SortedObjects[i]->TriggerEvent(EVT_SuperFreezeEnd, StateMachine_Primary);
		}

		BattleState.PauseTimer = false;
		BattleState.SuperFreezeCaller = nullptr;
	}

	if (BattleState.SuperFreezeSelfDuration) BattleState.SuperFreezeSelfDuration--;
	if (BattleState.SuperFreezeDuration) BattleState.SuperFreezeDuration--;

	GetMainPlayer(true)->HandleEndCombo();
	GetMainPlayer(false)->HandleEndCombo();

	SetScreenBounds();
	HandlePushCollision();
	SetScreenBounds();
	if (!BattleState.SuperFreezeDuration)
	{
		HandleRoundWin();
	}

	// these aren't strictly game state related, but tying them to game state update makes things better	

	if (!GameInstance->IsReplay)
	{
		// GameInstance->UpdateReplay(Input1, Input2);
	}

	CollisionView();

	const auto [network, timesync] = GetNetworkStats();
	NetworkStats.Ping = network.ping;
	const int32 LocalFramesBehind = timesync.local_frames_behind;
	const int32 RemoteFramesBehind = timesync.remote_frames_behind;

	if (LocalFramesBehind < 0 && RemoteFramesBehind < 0)
	{
		NetworkStats.RollbackFrames = abs(abs(LocalFramesBehind) - abs(RemoteFramesBehind));
	}
	else if (LocalFramesBehind > 0 && RemoteFramesBehind > 0)
	{
		NetworkStats.RollbackFrames = 0;
	}
	else
	{
		NetworkStats.RollbackFrames = abs(LocalFramesBehind) + abs(RemoteFramesBehind);
	}

	for (int i = 0; i < 2; i++)
	{
		if (BattleState.Meter[i] > BattleState.MaxMeter[i])
			BattleState.Meter[i] = BattleState.MaxMeter[i];
		if (BattleState.Meter[i] < 0)
			BattleState.Meter[i] = 0;
	}

	for (int i = 0; i < BattleState.MaxGauge.Num(); i++)
	{
		if (BattleState.GaugeP1[i] > BattleState.MaxGauge[i])
			BattleState.GaugeP1[i] = BattleState.MaxGauge[i];
		if (BattleState.GaugeP1[i] < 0)
			BattleState.GaugeP1[i] = 0;
		if (BattleState.GaugeP2[i] > BattleState.MaxGauge[i])
			BattleState.GaugeP2[i] = BattleState.MaxGauge[i];
		if (BattleState.GaugeP2[i] < 0)
			BattleState.GaugeP2[i] = 0;
	}

	ParticleManager->PauseParticles();
	UpdateVisuals(bShouldResimulate);
	UpdateCamera();
	UpdateHUD();
	ManageAudio();
}

void ANightSkyGameState::SetScreenCorners()
{
	const auto ScreenData = &BattleState.ScreenData;

	if (ScreenData->TargetObjects.Num() == 0)
	{
		ScreenData->ObjTop = 0;
		ScreenData->ObjBottom = 0;
		ScreenData->HigherObjBottom = 0;
		ScreenData->ObjLeft = 0;
		ScreenData->ObjRight = 0;
		ScreenData->ObjLength = 0;
		ScreenData->ObjHeight = 0;

		return;
	}

	bool bIsFirst = true;

	for (const auto Target : ScreenData->TargetObjects)
	{
		if (Target == nullptr) break;

		Target->CalculatePushbox();

		auto TargetL = Target->PosX - 85000;
		auto TargetR = Target->PosX + 85000;

		if (bIsFirst)
		{
			ScreenData->ObjTop = Target->T / 1000;
			ScreenData->ObjBottom = Target->B / 1000;
			ScreenData->HigherObjBottom = Target->B / 1000;
			ScreenData->ObjLeft = TargetL / 1000;
			ScreenData->ObjRight = TargetR / 1000;

			bIsFirst = false;
		}
		else
		{
			if (Target->T > ScreenData->ObjTop * 1000) ScreenData->ObjTop = Target->T / 1000;
			if (Target->B < ScreenData->ObjBottom * 1000) ScreenData->ObjBottom = Target->B / 1000;
			if (Target->B > ScreenData->HigherObjBottom * 1000) ScreenData->HigherObjBottom = Target->B / 1000;
			if (TargetL < ScreenData->ObjLeft * 1000) ScreenData->ObjLeft = TargetL / 1000;
			if (TargetR > ScreenData->ObjRight * 1000) ScreenData->ObjRight = TargetR / 1000;
		}
	}

	ScreenData->ObjLength = ScreenData->ObjRight - ScreenData->ObjLeft;
	ScreenData->ObjHeight = ScreenData->ObjTop - ScreenData->ObjBottom;
	ScreenData->ObjDistanceY = ScreenData->HigherObjBottom - ScreenData->ObjBottom;
}

void ANightSkyGameState::UpdateScreen()
{
	const auto ScreenData = &BattleState.ScreenData;

	ScreenData->MaxZoomOutWidth = ScreenData->DefaultMaxWidth;
	ScreenData->ZoomOutBeginX = ScreenData->DefaultWidth;

	SetScreenCorners();

	if ((ScreenData->Flags & SCR_Lock) == 0)
	{
		if ((ScreenData->Flags & SCR_LockXPos) == 0)
			ScreenData->TargetCenterX = ScreenData->ObjLeft + ScreenData->
				ObjLength / 2;

		if ((ScreenData->Flags & SCR_LockWidth) == 0)
		{
			auto XWidth = ScreenData->ObjLength + ScreenData->ZoomOutBeginX / 4;
			auto YWidth = FMath::Max(ScreenData->ObjDistanceY - ScreenData->ZoomOutBeginY, 0) + ScreenData->
				ZoomOutBeginX;
			auto HWidth = FMath::Max(ScreenData->ObjHeight - ScreenData->ZoomOutBeginH, 0) + ScreenData->ZoomOutBeginX;

			ScreenData->TargetWidth = FMath::Max(XWidth, FMath::Max(YWidth, HWidth));
			if (ScreenData->TargetWidth < ScreenData->ZoomOutBeginX)
				ScreenData->TargetWidth = ScreenData->
					ZoomOutBeginX;
			if (ScreenData->TargetWidth > ScreenData->MaxZoomOutWidth)
				ScreenData->TargetWidth = ScreenData->
					MaxZoomOutWidth;
		}

		if ((ScreenData->Flags & SCR_LockYPos) == 0)
		{
			int TargetOffsetY;

			auto Ratio = ScreenData->DefaultWidth * 1000 / ScreenData->TargetWidth;

			if (Ratio * ScreenData->ObjBottom / 1000 <= ScreenData->TargetOffsetAirYPos ||
				Ratio * (ScreenData->HigherObjBottom - ScreenData->ObjBottom) / 1000 >= ScreenData->
				TargetOffsetAirYDist)
			{
				TargetOffsetY = FMath::Min(ScreenData->TargetOffsetY + ScreenData->TargetOffsetLandYAdd,
				                           ScreenData->TargetOffsetLandYMax);
			}
			else
			{
				TargetOffsetY = FMath::Max(ScreenData->TargetOffsetY - ScreenData->TargetOffsetAirYAdd,
				                           ScreenData->TargetOffsetAirYMax);
			}

			ScreenData->TargetOffsetY = TargetOffsetY;

			Ratio = Ratio * ScreenData->HigherObjBottom / 1000 - Ratio * TargetOffsetY / 1000;
			ScreenData->TargetCenterY = FMath::Clamp(Ratio, 0, ScreenData->StageBoundsTop);
		}
	}

	const auto Width = ScreenData->TargetWidth - ScreenData->ScreenWorldWidth;
	ScreenData->WidthVelocity = Width / 14 - 1;
	ScreenData->ScreenWorldWidth += ScreenData->WidthVelocity;

	auto ScreenXSpeedFrame = 10;
	auto ScreenXSpeed = 50;

	ScreenData->CenterXVelocity = (ScreenData->TargetCenterX - ScreenData->ScreenWorldCenterX) / ScreenXSpeedFrame;

	if (ScreenData->CenterXVelocity > ScreenXSpeed) ScreenData->CenterXVelocity = ScreenXSpeed;
	else if (ScreenData->CenterXVelocity < -ScreenXSpeed) ScreenData->CenterXVelocity = -ScreenXSpeed;

	if (ScreenData->TargetCenterX - ScreenData->ScreenWorldCenterX > 0)
	{
		ScreenData->CenterXVelocity++;
	}
	else if (ScreenData->TargetCenterX - ScreenData->ScreenWorldCenterX < 0)
	{
		ScreenData->CenterXVelocity--;
	}

	ScreenData->ScreenWorldCenterX += ScreenData->CenterXVelocity;

	auto CenterYVelocity = ScreenData->TargetCenterY - ScreenData->ScreenWorldCenterY > 0 ? 3000 : 1000;
	auto ScreenYSpeed = 250;

	if (ScreenData->TargetCenterY - ScreenData->ScreenWorldCenterY <= 0) CenterYVelocity = 3000;

	ScreenData->CenterYVelocity = (ScreenData->TargetCenterY - ScreenData->ScreenWorldCenterY) * 1000 / CenterYVelocity;

	if (ScreenData->CenterYVelocity > ScreenYSpeed) ScreenData->CenterYVelocity = ScreenYSpeed;
	else if (ScreenData->CenterYVelocity < -ScreenYSpeed) ScreenData->CenterYVelocity = -ScreenYSpeed;

	if (ScreenData->TargetCenterY - ScreenData->ScreenWorldCenterY > 0)
	{
		ScreenData->CenterYVelocity++;
	}
	else if (ScreenData->TargetCenterY - ScreenData->ScreenWorldCenterY < 0)
	{
		ScreenData->CenterYVelocity--;
	}

	ScreenData->ScreenWorldCenterY += ScreenData->CenterYVelocity;

	ScreenData->bTouchingWorldSide = false;

	if (ScreenData->ScreenWorldCenterX + ScreenData->ScreenWorldWidth / 2 >= ScreenData->StageBoundsRight)
	{
		ScreenData->ScreenWorldCenterX = ScreenData->StageBoundsRight - ScreenData->ScreenWorldWidth / 2;
		ScreenData->bTouchingWorldSide = true;
	}

	if (ScreenData->ScreenWorldCenterX - ScreenData->ScreenWorldWidth / 2 <= ScreenData->StageBoundsLeft)
	{
		ScreenData->ScreenWorldCenterX = ScreenData->StageBoundsLeft + ScreenData->ScreenWorldWidth / 2;
		ScreenData->bTouchingWorldSide = true;
	}

	ScreenData->ScreenBoundsLeft = ScreenData->ScreenWorldCenterX - ScreenData->ScreenWorldWidth / 2;
	ScreenData->ScreenBoundsRight = ScreenData->ScreenWorldCenterX + ScreenData->ScreenWorldWidth / 2;

	if (ScreenData->Flags & SCR_DisableScreenSides)
	{
		ScreenData->ScreenBoundsLeft = ScreenData->StageBoundsLeft;
		ScreenData->ScreenBoundsRight = ScreenData->StageBoundsRight;
	}

	ScreenData->ScreenBoundsTop = 106432 / (ScreenData->ZoomOutBeginX * 1000 / ScreenData->ScreenWorldWidth) +
		368000 / (ScreenData->ZoomOutBeginX * 1000 / ScreenData->ScreenWorldWidth) + ScreenData->ScreenWorldCenterY;

	ScreenData->FinalScreenX = ScreenData->ScreenWorldCenterX;
	ScreenData->FinalScreenY = ScreenData->ScreenWorldCenterY;
	ScreenData->FinalScreenWidth = ScreenData->ScreenWorldWidth;

	if (ScreenData->FinalScreenY >= ScreenData->StageBoundsTop - 106)
		ScreenData->FinalScreenY = ScreenData->
			StageBoundsTop - 106;

	ScreenData->ScreenYZoom = 106 * (1
		- static_cast<float>(ScreenData->FinalScreenWidth) / static_cast<float>(ScreenData->DefaultWidth));
}

void ANightSkyGameState::UpdateGameState()
{
	RemoteFrame++;
	UpdateLocalInput();
	UpdateGameState(LocalInputs[0], LocalInputs[1], false);
}

void ANightSkyGameState::SortObjects()
{
	BattleState.ActiveObjectCount = Players.Num();
	for (int i = Players.Num(); i < SortedObjects.Num(); i++)
	{
		for (int j = i + 1; j < SortedObjects.Num(); j++)
		{
			if (SortedObjects[j]->IsActive && !SortedObjects[i]->IsActive)
			{
				ABattleObject* Temp = SortedObjects[i];
				SortedObjects[i] = SortedObjects[j];
				SortedObjects[j] = Temp;
			}
		}
		if (SortedObjects[i]->IsActive)
		{
			BattleState.ActiveObjectCount++;
		}
	}
}

void ANightSkyGameState::HandlePushCollision() const
{
	for (int i = 0; i < Players.Num(); i++)
	{
		for (int j = 0; j < Players.Num(); j++)
		{
			if (Players[i]->PlayerIndex != Players[j]->PlayerIndex && Players[i]->PlayerFlags & PLF_IsOnScreen &&
				Players[j]->PlayerFlags & PLF_IsOnScreen)
			{
				Players[i]->HandlePushCollision(Players[j]);
			}
		}
	}
}

void ANightSkyGameState::HandleHitCollision() const
{
	for (int i = 0; i < SortedObjects.Num(); i++)
	{
		if (i == BattleState.ActiveObjectCount)
			break;
		for (int j = 0; j < SortedObjects.Num(); j++)
		{
			if (j == BattleState.ActiveObjectCount)
				break;
			if (SortedObjects[i]->Player->PlayerIndex != SortedObjects[j]->Player->PlayerIndex
				&& SortedObjects[i]->Player->PlayerFlags & PLF_IsOnScreen
				&& SortedObjects[j]->Player->PlayerFlags & PLF_IsOnScreen)
			{
				SortedObjects[i]->HandleCustomCollision_PreHit(SortedObjects[j]);
				SortedObjects[i]->HandleClashCollision(SortedObjects[j]);
				SortedObjects[i]->HandleHitCollision(SortedObjects[j]);
				SortedObjects[i]->HandleCustomCollision_PostHit(SortedObjects[j]);
			}
		}
	}
}

void ANightSkyGameState::UpdateVisuals(bool bShouldResimulate) const
{
	for (int i = 0; i < SortedObjects.Num(); i++)
	{
		SortedObjects[i]->UpdateVisuals();
		if (!bShouldResimulate)
			SortedObjects[i]->UpdateVisualsNoRollback();
	}
}

void ANightSkyGameState::HandleRoundWin()
{
	if (BattleState.BattlePhase == EBattlePhase::EndScreen) return;

	if (GetMainPlayer(true)->CurrentHealth > 0 && GetMainPlayer(false)->CurrentHealth <= 0)
	{
		if ((GetMainPlayer(true)->PlayerFlags & PLF_RoundWinInputLock) == 0)
			BattleState.P1RoundsWon++;
		GetMainPlayer(true)->RoundWinTimer--;
		GetMainPlayer(true)->PlayerFlags |= PLF_RoundWinInputLock;
		if (BattleState.BattlePhase < EBattlePhase::RoundEnd)
			BattleState.BattlePhase = EBattlePhase::RoundEnd;
		BattleState.PauseTimer = true;
		if (GetMainPlayer(true)->RoundWinTimer == 0 && !IsTagBattle())
		{
			GetMainPlayer(true)->JumpToStatePrimary(State_Universal_RoundWin);
		}
		NextRoundTransition(true);
	}
	else if (GetMainPlayer(false)->CurrentHealth > 0 && GetMainPlayer(true)->CurrentHealth <= 0)
	{
		if ((GetMainPlayer(false)->PlayerFlags & PLF_RoundWinInputLock) == 0)
			BattleState.P2RoundsWon++;
		GetMainPlayer(false)->RoundWinTimer--;
		GetMainPlayer(false)->PlayerFlags |= PLF_RoundWinInputLock;
		if (BattleState.BattlePhase < EBattlePhase::RoundEnd)
			BattleState.BattlePhase = EBattlePhase::RoundEnd;
		BattleState.PauseTimer = true;
		if (GetMainPlayer(false)->RoundWinTimer == 0 && !IsTagBattle())
		{
			GetMainPlayer(false)->JumpToStatePrimary(State_Universal_RoundWin);
		}
		NextRoundTransition(false);
	}
	else if (GetMainPlayer(true)->CurrentHealth <= 0 && GetMainPlayer(false)->CurrentHealth <= 0)
	{
		if ((GetMainPlayer(true)->PlayerFlags & PLF_RoundWinInputLock) == 0)
		{
			BattleState.P1RoundsWon++;
			BattleState.P2RoundsWon++;
		}
		GetMainPlayer(true)->PlayerFlags |= PLF_RoundWinInputLock;
		GetMainPlayer(false)->PlayerFlags |= PLF_RoundWinInputLock;
		GetMainPlayer(true)->RoundWinTimer--;
		if (BattleState.BattlePhase < EBattlePhase::RoundEnd)
			BattleState.BattlePhase = EBattlePhase::RoundEnd;
		BattleState.PauseTimer = true;
		NextRoundTransition(true);
	}
	else if (BattleState.RoundTimer <= 0)
	{
		if (GetMainPlayer(true)->CurrentHealth > GetMainPlayer(false)->CurrentHealth)
		{
			if ((GetMainPlayer(true)->PlayerFlags & PLF_RoundWinInputLock) == 0)
				BattleState.P1RoundsWon++;
			GetMainPlayer(true)->RoundWinTimer--;
			GetMainPlayer(true)->PlayerFlags |= PLF_RoundWinInputLock;
			GetMainPlayer(false)->PlayerFlags |= PLF_RoundWinInputLock;
			if (BattleState.BattlePhase < EBattlePhase::RoundEnd)
				BattleState.BattlePhase = EBattlePhase::RoundEnd;
			BattleState.PauseTimer = true;
			if (GetMainPlayer(true)->RoundWinTimer == 0 && !IsTagBattle())
			{
				GetMainPlayer(true)->JumpToStatePrimary(State_Universal_RoundWin);
				GetMainPlayer(false)->JumpToStatePrimary(State_Universal_RoundLose);
			}
			NextRoundTransition(true);
		}
		else if (GetMainPlayer(false)->CurrentHealth > GetMainPlayer(true)->CurrentHealth)
		{
			if ((GetMainPlayer(false)->PlayerFlags & PLF_RoundWinInputLock) == 0)
				BattleState.P2RoundsWon++;
			GetMainPlayer(false)->RoundWinTimer--;
			GetMainPlayer(true)->PlayerFlags |= PLF_RoundWinInputLock;
			GetMainPlayer(false)->PlayerFlags |= PLF_RoundWinInputLock;
			if (BattleState.BattlePhase < EBattlePhase::RoundEnd)
				BattleState.BattlePhase = EBattlePhase::RoundEnd;
			BattleState.PauseTimer = true;
			if (GetMainPlayer(false)->RoundWinTimer == 0 && !IsTagBattle())
			{
				GetMainPlayer(false)->JumpToStatePrimary(State_Universal_RoundWin);
				GetMainPlayer(true)->JumpToStatePrimary(State_Universal_RoundLose);
			}
			NextRoundTransition(false);
		}
		else if (GetMainPlayer(true)->CurrentHealth == GetMainPlayer(false)->CurrentHealth)
		{
			if ((GetMainPlayer(true)->PlayerFlags & PLF_RoundWinInputLock) == 0)
			{
				BattleState.P1RoundsWon++;
				BattleState.P2RoundsWon++;
			}
			GetMainPlayer(true)->PlayerFlags |= PLF_RoundWinInputLock;
			GetMainPlayer(false)->PlayerFlags |= PLF_RoundWinInputLock;
			if (BattleState.BattlePhase < EBattlePhase::RoundEnd)
				BattleState.BattlePhase = EBattlePhase::RoundEnd;
			GetMainPlayer(true)->RoundWinTimer--;
			BattleState.PauseTimer = true;
			if (GetMainPlayer(true)->RoundWinTimer == 0 && !IsTagBattle())
			{
				GetMainPlayer(true)->JumpToStatePrimary(State_Universal_RoundLose);
				GetMainPlayer(false)->JumpToStatePrimary(State_Universal_RoundLose);
			}
			NextRoundTransition(true);
		}
	}
}

void ANightSkyGameState::NextRoundTransition(bool bIsP1)
{
	if (GetMainPlayer(bIsP1)->RoundWinTimer <= 0)
	{
		if (IsTagBattle())
		{
			if (!HandleMatchWin())
			{
				RoundInit();
			}
		}
		else if (!HandleMatchWin() && GetMainPlayer(bIsP1)->RoundEndFlag == true)
		{
			if (BattleState.BattlePhase != EBattlePhase::Fade)
			{
				BattleHudActor->BottomWidget->PlayFadeAnim();
				BattleState.BattlePhase = EBattlePhase::Fade;
			}
			BattleState.FadeTimer--;
			if (BattleState.FadeTimer <= 0)
			{
				RoundInit();
				BattleHudActor->BottomWidget->PlayRoundInitAnim();
			}
		}
	}
}

bool ANightSkyGameState::HandleMatchWin()
{
	if (BattleState.CurrentWinSide != WIN_None)
	{
		if (BattleState.BattlePhase == EBattlePhase::EndScreen) return true;
		if (BattleState.CurrentWinSide == WIN_P2)
		{
			if (GetMainPlayer(false)->RoundEndFlag == true)
			{
				EndMatch();
			}
		}
		else
		{
			if (GetMainPlayer(true)->RoundEndFlag == true)
			{
				EndMatch();
			}
		}
		return true;
	}
	switch (BattleState.BattleFormat)
	{
	case EBattleFormat::Rounds:
		{
			if (BattleState.P1RoundsWon >= BattleState.MaxRoundCount && BattleState.P2RoundsWon < BattleState.
				P1RoundsWon)
			{
				GetMainPlayer(true)->JumpToStatePrimary(State_Universal_MatchWin);
				GameInstance->EndRecordReplay();
				BattleState.CurrentWinSide = WIN_P1;
				return true;
			}
			if (BattleState.P2RoundsWon >= BattleState.MaxRoundCount && BattleState.P1RoundsWon < BattleState.
				P2RoundsWon)
			{
				GetMainPlayer(false)->JumpToStatePrimary(State_Universal_MatchWin);
				GameInstance->EndRecordReplay();
				BattleState.CurrentWinSide = WIN_P2;
				return true;
			}
			if (BattleState.P1RoundsWon > BattleState.MaxRoundCount && BattleState.P2RoundsWon > BattleState.
				MaxRoundCount)
			{
				GameInstance->EndRecordReplay();
				BattleState.CurrentWinSide = WIN_Draw;
				return true;
			}
		}
		return false;
	case EBattleFormat::Tag:
	case EBattleFormat::KOF:
		{
			if (BattleState.P1RoundsWon >= BattleState.TeamData[1].TeamCount && BattleState.P2RoundsWon < BattleState.
				P1RoundsWon)
			{
				GetMainPlayer(true)->JumpToStatePrimary(State_Universal_MatchWin);
				GameInstance->EndRecordReplay();
				BattleState.CurrentWinSide = WIN_P1;
				return true;
			}
			if (BattleState.P2RoundsWon >= BattleState.TeamData[0].TeamCount && BattleState.P1RoundsWon < BattleState.
				P2RoundsWon)
			{
				GetMainPlayer(false)->JumpToStatePrimary(State_Universal_MatchWin);
				GameInstance->EndRecordReplay();
				BattleState.CurrentWinSide = WIN_P2;
				return true;
			}
			if (BattleState.P1RoundsWon >= BattleState.TeamData[1].TeamCount && BattleState.P2RoundsWon >= BattleState.
				TeamData[0].TeamCount)
			{
				GameInstance->EndRecordReplay();
				BattleState.CurrentWinSide = WIN_Draw;
				return true;
			}
		}
		return false;
	default:
		return false;
	}
}

void ANightSkyGameState::CollisionView() const
{
	if (bViewCollision)
	{
		for (int i = 0; i < BattleState.ActiveObjectCount; i++)
		{
			SortedObjects[i]->CollisionView();
		}
	}
}

int32 ANightSkyGameState::CreateChecksum()
{
	Checksum = 0;

	for (const auto Player : Players)
	{
		Checksum += Player->ActionTime ^ Player->ActionTime << 16;
		Checksum += Player->PosX ^ Player->PosX << 16;
		Checksum += Player->PosY ^ Player->PosY << 16;
		Checksum += Player->CurrentHealth ^ Player->CurrentHealth << 16;
	}

	Checksum += BattleState.Meter[0] ^ BattleState.Meter[0] << 16;
	Checksum += BattleState.Meter[1] ^ BattleState.Meter[1] << 16;

	for (const auto Gauge : BattleState.GaugeP1)
	{
		Checksum += Gauge ^ Gauge << 16;
	}
	for (const auto Gauge : BattleState.GaugeP2)
	{
		Checksum += Gauge ^ Gauge << 16;
	}

	return Checksum;
}

FGGPONetworkStats ANightSkyGameState::GetNetworkStats() const
{
	FGGPONetworkStats Stats{};
	if (AFighterMultiplayerRunner* Runner = Cast<AFighterMultiplayerRunner>(FighterRunner))
	{
		if (Runner->Players[0]->type == GGPO_PLAYERTYPE_REMOTE)
			GGPONet::ggpo_get_network_stats(Runner->ggpo, Runner->PlayerHandles[0], &Stats);
		else
			GGPONet::ggpo_get_network_stats(Runner->ggpo, Runner->PlayerHandles[1], &Stats);
		return Stats;
	}
	return Stats;
}

void ANightSkyGameState::ResetTraining()
{
	if (GameInstance->IsTraining)
	{
		BattleState.RoundCount = 0;
		RoundInit();
	}
	
	if (ANightSkyPlayerController* Controller = Cast<ANightSkyPlayerController>(
	UGameplayStatics::GetPlayerController(GetWorld(), 0)); Controller != nullptr)
	{
		Controller->Inputs &= ~INP_ResetTraining;
	}
	if (ANightSkyPlayerController* Controller = Cast<ANightSkyPlayerController>(
		UGameplayStatics::GetPlayerController(GetWorld(), 1)); Controller != nullptr)
	{
		Controller->Inputs &= ~INP_ResetTraining;
	}
}

void ANightSkyGameState::SetScreenBounds() const
{
	for (int i = 0; i < BattleState.ActiveObjectCount; i++)
	{
		if (SortedObjects[i] != nullptr)
		{
			if (SortedObjects[i]->MiscFlags & MISC_WallCollisionActive)
			{
				const auto ScreenData = &BattleState.ScreenData;

				if (const auto Player = Cast<APlayerObject>(SortedObjects[i]))
				{
					if (!(Player->PlayerFlags & PLF_IsOnScreen)) continue;
					Player->PlayerFlags |= PLF_TouchingWall;
					Player->WallTouchTimer++;
				}

				SortedObjects[i]->CalculatePushbox();

				if (SortedObjects[i]->PosX + 85000 >= ScreenData->ScreenBoundsRight * 1000)
				{
					SortedObjects[i]->PosX = ScreenData->ScreenBoundsRight * 1000 - 85000;
				}
				else if (SortedObjects[i]->PosX - 85000 <= ScreenData->ScreenBoundsLeft * 1000)
				{
					SortedObjects[i]->PosX = ScreenData->ScreenBoundsLeft * 1000 + 85000;
				}
				else
				{
					if (const auto Player = Cast<APlayerObject>(SortedObjects[i]))
					{
						Player->PlayerFlags &= ~PLF_TouchingWall;
						Player->WallTouchTimer = 0;
					}
				}

				if (SortedObjects[i]->PosY >= ScreenData->StageBoundsTop * 1000)
				{
					SortedObjects[i]->PosY = ScreenData->StageBoundsTop * 1000;
				}
			}
		}
	}
}

void ANightSkyGameState::StartSuperFreeze(int32 Duration, int32 SelfDuration, ABattleObject* CallingObject)
{
	BattleState.SuperFreezeDuration = Duration;
	BattleState.SuperFreezeSelfDuration = SelfDuration;
	BattleState.SuperFreezeCaller = CallingObject;
	BattleState.PauseTimer = true;
}

ABattleObject* ANightSkyGameState::AddBattleObject(
	const UState* InState,
	int PosX,
	int PosY,
	EObjDir Dir,
	int32 ObjectStateIndex,
	bool bIsCommonState,
	APlayerObject* Parent) const
{
	for (int i = 0; i < MaxBattleObjects; i++)
	{
		if (!Objects[i]->IsActive)
		{
			Objects[i]->ObjectState = DuplicateObject(InState, Objects[i]);
			Objects[i]->ObjectState->Parent = Objects[i];
			Objects[i]->IsActive = true;
			Objects[i]->Direction = Dir;
			Objects[i]->Player = Parent;
			Objects[i]->PosX = PosX;
			Objects[i]->PosY = PosY;
			Objects[i]->ObjectStateIndex = ObjectStateIndex;
			Objects[i]->bIsCommonState = bIsCommonState;
			Objects[i]->InitObject();
			return Objects[i];
		}
	}
	return nullptr;
}

void ANightSkyGameState::UpdateCamera()
{
	if (CameraActor != nullptr)
	{
		const auto ScreenData = &BattleState.ScreenData;

		BattleState.CameraPosition = BattleSceneTransform.GetRotation().RotateVector(
				FVector(ScreenData->FinalScreenX * 0.43, ScreenData->FinalScreenWidth * 0.43,
				        ScreenData->FinalScreenY * 0.43 - ScreenData->ScreenYZoom + 106)) + BattleSceneTransform.
			GetLocation();
		FRotator CameraRotation = BattleSceneTransform.GetRotation().Rotator();
		CameraRotation.Yaw -= 90;
		CameraRotation.Pitch += 2.5;
		CameraActor->SetActorLocation(BattleState.CameraPosition);
		CameraActor->SetActorRotation(CameraRotation);
		if (BattleState.CurrentSequenceTime == -1)
		{
			BattleState.OrthoBlendActive = 1;
			const FVector SequenceCameraLocation = BattleSceneTransform.GetRotation().RotateVector(
				FVector(0, 1080, 175)) + BattleSceneTransform.GetLocation();
			SequenceCameraActor->SetActorLocation(SequenceCameraLocation);
			if (const auto PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0); IsValid(
				PlayerController))
			{
				PlayerController->SetViewTargetWithBlend(CameraActor);
			}
		}
		else
		{
			if (BattleState.CurrentSequenceTime >= SequenceActor->GetSequencePlayer()->GetEndTime().Time)
			{
				StopLevelSequence();
				return;
			}
			const FMovieSceneSequencePlaybackParams Params = FMovieSceneSequencePlaybackParams(
				FFrameTime(BattleState.CurrentSequenceTime),
				EUpdatePositionMethod::Scrub);
			SequenceActor->GetSequencePlayer()->SetPlaybackPosition(Params);
			const FVector SequenceTargetVector = FVector(SequenceTarget->PosX / COORD_SCALE,
			                                             SequenceTarget->PosZ / COORD_SCALE,
			                                             SequenceTarget->PosY / COORD_SCALE);

			FVector NewCamLocation = SequenceCameraActor->GetActorLocation();
			NewCamLocation.Y = NewCamLocation.Y + SequenceTargetVector.Y;
			NewCamLocation.Z = NewCamLocation.Z + SequenceTargetVector.Z;

			if (SequenceTarget->Direction == DIR_Left)
			{
				NewCamLocation.X = -NewCamLocation.X + SequenceTargetVector.X;
				auto NewCamRotation = SequenceCameraActor->GetActorForwardVector();
				NewCamRotation.X *= -1;
				SequenceCameraActor->SetActorRotation(UKismetMathLibrary::MakeRotFromX(NewCamRotation));
			}
			else
			{
				NewCamLocation.X = NewCamLocation.X + SequenceTargetVector.X;
			}

			BattleState.OrthoBlendActive = FMath::Clamp(FVector::DotProduct(CameraActor->GetActorForwardVector(),
			                                                                SequenceCameraActor->
			                                                                GetActorForwardVector()), 0, 1)
											* FMath::Clamp(FVector::Dist(CameraActor->GetActorLocation(),
												SequenceCameraActor->GetActorLocation()) / 500, 0, 1);

			SequenceCameraActor->SetActorLocation(
				BattleSceneTransform.GetRotation().RotateVector(NewCamLocation) + BattleSceneTransform.GetLocation());

			const FRotator SequenceRotation = BattleSceneTransform.GetRotation().Rotator() + SequenceCameraActor->
				GetActorRotation();

			SequenceCameraActor->SetActorRotation(SequenceRotation);
		}
	}
	bIsPlayingSequence = BattleState.IsPlayingSequence;
}

void ANightSkyGameState::PlayLevelSequence(APlayerObject* Target, APlayerObject* Enemy, ULevelSequence* Sequence)
{
	if (SequenceActor != nullptr)
	{
		SequenceActor->GetSequencePlayer()->Stop();
		SequenceActor->SetSequence(Sequence);
		for (int i = 0; i < Sequence->GetMovieScene()->GetPossessableCount(); i++)
		{
			auto MovieSceneBinding = Sequence->GetMovieScene()->GetPossessable(i);
			if (!MovieSceneBinding.GetName().Equals("Target"))
			{
				continue;
			}

			FMovieSceneObjectBindingID BindingId = FMovieSceneObjectBindingID(MovieSceneBinding.GetGuid());
			SequenceActor->SetBinding(BindingId, TArray<AActor*>{Target});

			break;
		}
		for (int i = 0; i < Sequence->GetMovieScene()->GetPossessableCount(); i++)
		{
			auto MovieSceneBinding = Sequence->GetMovieScene()->GetPossessable(i);
			if (!MovieSceneBinding.GetName().Equals("Enemy"))
			{
				continue;
			}

			FMovieSceneObjectBindingID BindingId = FMovieSceneObjectBindingID(MovieSceneBinding.GetGuid());
			SequenceActor->SetBinding(BindingId, TArray<AActor*>{Enemy});

			break;
		}
		for (int i = 0; i < Sequence->GetMovieScene()->GetPossessableCount(); i++)
		{
			auto MovieSceneBinding = Sequence->GetMovieScene()->GetPossessable(i);
			if (!MovieSceneBinding.GetName().Equals("CameraActor"))
			{
				continue;
			}

			FMovieSceneObjectBindingID BindingId = FMovieSceneObjectBindingID(MovieSceneBinding.GetGuid());
			SequenceActor->SetBinding(BindingId, TArray<AActor*>{CameraActor});

			break;
		}
		for (int i = 0; i < Sequence->GetMovieScene()->GetPossessableCount(); i++)
		{
			auto MovieSceneBinding = Sequence->GetMovieScene()->GetPossessable(i);
			if (!MovieSceneBinding.GetName().Equals("SequenceCameraActor"))
			{
				continue;
			}

			FMovieSceneObjectBindingID BindingId = FMovieSceneObjectBindingID(MovieSceneBinding.GetGuid());
			SequenceActor->SetBinding(BindingId, TArray<AActor*>{SequenceCameraActor});

			break;
		}
		SequenceTarget = Target;
		SequenceEnemy = Enemy;
		BattleState.CurrentSequenceTime = 0;
		BattleState.IsPlayingSequence = true;
	}
}

void ANightSkyGameState::StopLevelSequence()
{
	SequenceActor->GetSequencePlayer()->Stop();
	BattleState.CurrentSequenceTime = -1;
	BattleState.IsPlayingSequence = false;
}

void ANightSkyGameState::CameraShake(const TSubclassOf<UCameraShakeBase>& Pattern, float Scale) const
{
	if (Pattern)
	{
		const auto PlayerCameraManager = UGameplayStatics::GetPlayerCameraManager(this, 0);
		PlayerCameraManager->StopAllCameraShakes();
		PlayerCameraManager->StartCameraShake(Pattern, Scale);
	}
}

void ANightSkyGameState::HUDInit() const
{
	if (BattleHudActor != nullptr)
	{
		if (BattleHudActor->TopWidget != nullptr)
		{
			BattleHudActor->TopWidget->P1Health.Init(0, BattleState.TeamData[0].TeamCount);
			BattleHudActor->TopWidget->P2Health.Init(0, BattleState.TeamData[1].TeamCount);
			BattleHudActor->TopWidget->P1RecoverableHealth.Init(0, BattleState.TeamData[0].TeamCount);
			BattleHudActor->TopWidget->P2RecoverableHealth.Init(0, BattleState.TeamData[1].TeamCount);
		}
	}
}

void ANightSkyGameState::UpdateHUD()
{
	if (BattleState.bHUDVisible)
	{
		BattleHudActor->TopWidget->SetVisibility(ESlateVisibility::Visible);
		BattleHudActor->BottomWidget->SetVisibility(ESlateVisibility::Visible);
	}
	else
	{
		BattleHudActor->TopWidget->SetVisibility(ESlateVisibility::Hidden);
		BattleHudActor->BottomWidget->SetVisibility(ESlateVisibility::Hidden);
	}

	if (BattleHudActor != nullptr)
	{
		if (BattleHudActor->TopWidget != nullptr)
		{
			for (int i = 0; i < BattleState.TeamData[0].TeamCount; i++)
			{
				BattleHudActor->TopWidget->P1Health[i] = static_cast<float>(GetTeam(true)[i]->CurrentHealth) /
					static_cast<float>(GetTeam(true)[i]->MaxHealth);
				BattleHudActor->TopWidget->P1RecoverableHealth[i] = static_cast<float>(GetTeam(true)[i]->CurrentHealth +
					GetTeam(true)[i]->RecoverableHealth) / static_cast<float>(GetTeam(true)[i]->MaxHealth);
			}
			for (int i = 0; i < BattleState.TeamData[1].TeamCount; i++)
			{
				BattleHudActor->TopWidget->P2Health[i] = static_cast<float>(GetTeam(false)[i]->CurrentHealth) /
					static_cast<float>(GetTeam(false)[i]->MaxHealth);
				BattleHudActor->TopWidget->P2RecoverableHealth[i] = static_cast<float>(GetTeam(false)[i]->CurrentHealth
					+ GetTeam(false)[i]->RecoverableHealth) / static_cast<float>(GetTeam(false)[i]->MaxHealth);
			}
			BattleHudActor->TopWidget->P1RoundsWon = BattleState.P1RoundsWon;
			BattleHudActor->TopWidget->P2RoundsWon = BattleState.P2RoundsWon;
			BattleHudActor->TopWidget->Timer = static_cast<float>(BattleState.RoundTimer / 60);
			BattleHudActor->TopWidget->P1ComboCounter = BattleState.MainPlayer[0]->ComboCounter;
			BattleHudActor->TopWidget->P2ComboCounter = BattleState.MainPlayer[1]->ComboCounter;
			BattleHudActor->TopWidget->Ping = NetworkStats.Ping;
			BattleHudActor->TopWidget->RollbackFrames = NetworkStats.RollbackFrames;

			if (BattleHudActor->TopWidget->P1Gauge.IsEmpty())
				BattleHudActor->TopWidget->P1Gauge.SetNum(
					BattleState.MaxGauge.Num());
			if (BattleHudActor->TopWidget->P2Gauge.IsEmpty())
				BattleHudActor->TopWidget->P2Gauge.SetNum(
					BattleState.MaxGauge.Num());

			for (int j = 0; j < BattleState.MaxGauge.Num(); j++)
			{
				BattleHudActor->TopWidget->P1Gauge[j] = static_cast<float>(BattleState.GaugeP1[j]) / BattleState.
					MaxGauge[j];
				BattleHudActor->TopWidget->P2Gauge[j] = static_cast<float>(BattleState.GaugeP2[j]) / BattleState.
					MaxGauge[j];
			}
		}
		if (BattleHudActor->BottomWidget != nullptr)
		{
			BattleHudActor->BottomWidget->P1Meter = static_cast<float>(BattleState.Meter[0]) / 10000;
			BattleHudActor->BottomWidget->P2Meter = static_cast<float>(BattleState.Meter[1]) / 10000;

			if (BattleHudActor->BottomWidget->P1Gauge.IsEmpty())
				BattleHudActor->BottomWidget->P1Gauge.SetNum(
					BattleState.MaxGauge.Num());
			if (BattleHudActor->BottomWidget->P2Gauge.IsEmpty())
				BattleHudActor->BottomWidget->P2Gauge.SetNum(
					BattleState.MaxGauge.Num());

			for (int j = 0; j < BattleState.MaxGauge.Num(); j++)
			{
				BattleHudActor->BottomWidget->P1Gauge[j] = static_cast<float>(BattleState.GaugeP1[j]) / BattleState.
					MaxGauge[j];
				BattleHudActor->BottomWidget->P2Gauge[j] = static_cast<float>(BattleState.GaugeP2[j]) / BattleState.
					MaxGauge[j];
			}
		}
		UpdateHUD_BP();
	}

	UpdateHUDAnimations_BP();

	BattleHudActor->TopWidget->PlayStandardAnimations();
	BattleHudActor->TopWidget->SetAnimationRollbackData();
	BattleHudActor->BottomWidget->PlayStandardAnimations();
	BattleHudActor->BottomWidget->SetAnimationRollbackData();

	for (auto& [Anim, Time, bPlaying] : BattleHudActor->TopWidget->WidgetAnimationRollback)
	{
		bPlaying = BattleHudActor->TopWidget->IsAnimationPlaying(Anim);
		Time = BattleHudActor->TopWidget->GetAnimationCurrentTime(Anim);
	}

	for (auto& [Anim, Time, bPlaying] : BattleHudActor->BottomWidget->WidgetAnimationRollback)
	{
		bPlaying = BattleHudActor->BottomWidget->IsAnimationPlaying(Anim);
		Time = BattleHudActor->BottomWidget->GetAnimationCurrentTime(Anim);
	}
}

void ANightSkyGameState::SetDrawPriorityFront(ABattleObject* InObject) const
{
	if (InObject->IsPlayer)
	{
		for (int i = 0; i < Players.Num(); i++)
		{
			if (SortedObjects[i] == InObject) continue;
			if (SortedObjects[i]->DrawPriority <= InObject->DrawPriority)
				SortedObjects[i]->DrawPriority++;
			SortedObjects[i]->DrawPriority = FMath::Min(SortedObjects[i]->DrawPriority, MaxDrawPriority);
		}
		InObject->DrawPriority = 0;
		return;
	}
	for (int i = Players.Num(); i < BattleState.ActiveObjectCount; i++)
	{
		if (SortedObjects[i] == InObject) continue;
		if (SortedObjects[i]->DrawPriority <= InObject->DrawPriority)
			SortedObjects[i]->DrawPriority++;
		SortedObjects[i]->DrawPriority = FMath::Min(SortedObjects[i]->DrawPriority, MaxDrawPriority);
	}
	InObject->DrawPriority = 0;
}

void ANightSkyGameState::SetDrawPriorityBack(ABattleObject* InObject) const
{
	if (InObject->IsPlayer)
	{
		for (int i = 0; i < Players.Num(); i++)
		{
			if (SortedObjects[i] == InObject) continue;
			if (SortedObjects[i]->DrawPriority > InObject->DrawPriority)
				SortedObjects[i]->DrawPriority--;
		}
		InObject->DrawPriority = Players.Num();
		return;
	}
	for (int i = Players.Num(); i < BattleState.ActiveObjectCount; i++)
	{
		if (SortedObjects[i] == InObject) continue;
		if (SortedObjects[i]->DrawPriority > InObject->DrawPriority)
			SortedObjects[i]->DrawPriority--;
		InObject->DrawPriority = Players.Num();
	}
}

APlayerObject* ANightSkyGameState::SwitchMainPlayer(APlayerObject* InPlayer, const int TeamIndex, const bool bForce,
                                                    const bool bEvenOnScreen)
{
	if (TeamIndex == 0) return nullptr;
	const bool IsP1 = InPlayer->PlayerIndex == 0;
	if (BattleState.BattleFormat != EBattleFormat::Tag && TeamIndex >= BattleState.TeamData[IsP1 == false].TeamCount)
		return nullptr;
	if (BattleState.TeamData[IsP1 == false].CooldownTimer[TeamIndex] > 0 && !bForce) return nullptr;

	const auto NewPlayer = GetTeam(IsP1)[TeamIndex];
	if (NewPlayer->CurrentHealth == 0) return nullptr;
	if (NewPlayer->PlayerFlags & PLF_IsOnScreen)
	{
		if (!bEvenOnScreen) return nullptr;
	}
	NewPlayer->TeamIndex = 0;
	InPlayer->TeamIndex = TeamIndex;
	BattleState.ScreenData.TargetObjects.Remove(InPlayer);
	BattleState.ScreenData.TargetObjects.Add(NewPlayer);
	NewPlayer->JumpToStatePrimary(State_Universal_TagIn);
	if (!(NewPlayer->PlayerFlags & PLF_IsOnScreen))
	{
		NewPlayer->PosX = InPlayer->PosX;
		NewPlayer->PosY = InPlayer->PosY;
		NewPlayer->Direction = InPlayer->Direction;
	}
	NewPlayer->SetOnScreen(true);
	NewPlayer->CalculatePushbox();
	NewPlayer->ComboCounter = InPlayer->ComboCounter;
	NewPlayer->ComboTimer = InPlayer->ComboTimer;
	NewPlayer->StoredInputBuffer = InPlayer->StoredInputBuffer;
	for (const auto EnemyPlayer : GetTeam(!IsP1))
	{
		EnemyPlayer->Enemy = NewPlayer;
	}
	BattleState.MainPlayer[!IsP1] = NewPlayer;
	SetDrawPriorityFront(NewPlayer);
	return NewPlayer;
}

APlayerObject* ANightSkyGameState::CallAssist(const bool IsP1, const int AssistIndex, const FGameplayTag AssistName)
{
	if (AssistIndex == 0) return nullptr;
	if (BattleState.BattleFormat != EBattleFormat::Tag && AssistIndex >= BattleState.TeamData[IsP1 == false].TeamCount)
		return nullptr;
	if (BattleState.TeamData[IsP1 == 0].CooldownTimer[AssistIndex] > 0) return nullptr;

	const auto NewPlayer = GetTeam(IsP1)[AssistIndex];
	if (NewPlayer->CurrentHealth == 0) return nullptr;
	if (NewPlayer->PlayerFlags & PLF_IsOnScreen) return nullptr;
	if (!NewPlayer->PrimaryStateMachine.StateNames.Contains(AssistName)) return nullptr;
	NewPlayer->SetOnScreen(true);
	NewPlayer->PosX = GetMainPlayer(IsP1)->PosX;
	NewPlayer->FaceOpponent();
	NewPlayer->JumpToStatePrimary(AssistName);
	SetDrawPriorityBack(NewPlayer);
	return NewPlayer;
}

void ANightSkyGameState::SetTeamCooldown(const bool IsP1, const int TeamIndex, const int Cooldown)
{
	BattleState.TeamData[IsP1 == 0].CooldownTimer[TeamIndex] = Cooldown;
}

bool ANightSkyGameState::CanTag(const APlayerObject* InPlayer, int TeamIndex) const
{
	if (InPlayer->PlayerFlags & PLF_RoundWinInputLock) return false;

	if (TeamIndex == 0) return false;
	const bool IsP1 = InPlayer->PlayerIndex == 0;
	if (BattleState.BattleFormat != EBattleFormat::Tag || TeamIndex >= BattleState.TeamData[IsP1 == false].TeamCount)
		return false;

	if (BattleState.TeamData[IsP1 == 0].CooldownTimer[TeamIndex] > 0) return false;

	const auto NewPlayer = GetTeam(IsP1)[TeamIndex];
	if (NewPlayer->CurrentHealth == 0) return false;
	if (NewPlayer->PlayerFlags & PLF_IsOnScreen) return false;

	return true;
}

int ANightSkyGameState::GetLocalInputs(int Index) const
{
	if (const ANightSkyPlayerController* Controller = Cast<ANightSkyPlayerController>(
		UGameplayStatics::GetPlayerController(GetWorld(), Index)); Controller != nullptr)
	{
		return Controller->Inputs;
	}
	return 0;
}

void ANightSkyGameState::SetOtherChecksum(uint32 RemoteChecksum, int32 InFrame)
{
	OtherChecksum = RemoteChecksum;
	OtherChecksumFrame = InFrame;
}

void ANightSkyGameState::PlayAnnouncerVoice(const FGameplayTag Name)
{
	if (!IsValid(GameInstance))
		return;
	if (GameInstance->AnnouncerData != nullptr)
	{
		for (FSoundStruct SoundStruct : GameInstance->AnnouncerData->SoundDatas)
		{
			if (SoundStruct.Name == Name)
			{
				PlayAnnouncerVoice(SoundStruct.SoundWave, SoundStruct.MaxDuration);
				break;
			}
		}
	}
}

TArray<APlayerObject*> ANightSkyGameState::GetTeam(bool IsP1) const
{
	if (IsP1)
	{
		TArray<APlayerObject*> PlayerObjects;
		for (int i = 0; i < BattleState.TeamData[0].TeamCount; i++)
		{
			PlayerObjects.Add(Players[i]);
			for (int j = 0; j < PlayerObjects.Num() - 1; j++)
			{
				if (PlayerObjects[i]->TeamIndex < PlayerObjects[j]->TeamIndex)
				{
					PlayerObjects.Swap(i, j);
				}
			}
		}
		return PlayerObjects;
	}
	TArray<APlayerObject*> PlayerObjects;
	for (int i = BattleState.TeamData[1].TeamCount; i < Players.Num(); i++)
	{
		PlayerObjects.Add(Players[i]);
		for (int j = 0; j < PlayerObjects.Num() - 1; j++)
		{
			if (PlayerObjects[i - BattleState.TeamData[0].TeamCount]->TeamIndex < PlayerObjects[j]->TeamIndex)
			{
				PlayerObjects.Swap(i - BattleState.TeamData[0].TeamCount, j);
			}
		}
	}
	return PlayerObjects;
}

APlayerObject* ANightSkyGameState::GetMainPlayer(bool IsP1) const
{
	if (IsP1) return BattleState.MainPlayer[0];
	return BattleState.MainPlayer[1];
}

void ANightSkyGameState::CallBattleExtension(FGameplayTag Name)
{
	if (BattleExtensionNames.Find(FGameplayTag(Name)) != INDEX_NONE)
	{
		BattleExtensions[BattleExtensionNames.Find(FGameplayTag(Name))]->Exec();
	}
}

int32 ANightSkyGameState::GetGauge(bool IsP1, int32 GaugeIndex) const
{
	if (GaugeIndex < BattleState.MaxGauge.Num())
	{
		if (IsP1) return BattleState.GaugeP1[GaugeIndex];
		return BattleState.GaugeP2[GaugeIndex];
	}

	return -1;
}

void ANightSkyGameState::SetGauge(bool IsP1, int32 GaugeIndex, int32 Value)
{
	if (GaugeIndex < BattleState.MaxGauge.Num())
	{
		if (IsP1) BattleState.GaugeP1[GaugeIndex] = Value;
		else BattleState.GaugeP2[GaugeIndex] = Value;
	}
}

void ANightSkyGameState::UseGauge(bool IsP1, int32 GaugeIndex, int32 Value)
{
	if (GaugeIndex < BattleState.MaxGauge.Num())
	{
		if (IsP1) BattleState.GaugeP1[GaugeIndex] -= Value;
		else BattleState.GaugeP2[GaugeIndex] -= Value;
	}
}

EScreenFlag ANightSkyGameState::GetScreenFlags() const
{
	return BattleState.ScreenData.Flags;
}

void ANightSkyGameState::SetScreenFlags(int32 InFlags)
{
	BattleState.ScreenData.Flags = (EScreenFlag)InFlags;
}

bool ANightSkyGameState::IsTagBattle() const
{
	return BattleState.BattleFormat == EBattleFormat::Tag;
}

int32 ANightSkyGameState::GetTeamCount(const bool bIsP1) const
{
	return BattleState.TeamData[bIsP1 == false].TeamCount;
}

bool ANightSkyGameState::GetPaused() const
{
	return bPauseGame;
}

void ANightSkyGameState::SetPaused(bool bPause)
{
	bPauseGame = bPause;
	if (GameInstance->FighterRunner == LocalPlay)
	{
		UGameplayStatics::SetGamePaused(this, bPause);
	}
}

void ANightSkyGameState::ScreenPosToWorldPos(const int32 X, const int32 Y, int32& OutX, int32& OutY) const
{
	const auto ScreenYSize = BattleState.ScreenData.FinalScreenWidth * 360 / 1280;

	OutX = BattleState.ScreenData.ScreenWorldCenterX * 1000 + BattleState.ScreenData.FinalScreenWidth * (X - 500);
	OutY = BattleState.ScreenData.ScreenWorldCenterY * 1000 + ScreenYSize * Y;
}

void ANightSkyGameState::BattleHudVisibility(bool Visible)
{
	BattleState.bHUDVisible = Visible;
}

void ANightSkyGameState::PlayCommonAudio(USoundBase* InSoundWave, float MaxDuration)
{
	for (int i = 0; i < CommonAudioChannelCount; i++)
	{
		if (BattleState.CommonAudioChannels[i].Finished)
		{
			BattleState.CommonAudioChannels[i].SoundWave = InSoundWave;
			BattleState.CommonAudioChannels[i].StartingFrame = BattleState.FrameNumber;
			BattleState.CommonAudioChannels[i].MaxDuration = MaxDuration;
			BattleState.CommonAudioChannels[i].Finished = false;
			if (!bIsResimulating)
			{
				AudioManager->CommonAudioPlayers[i]->SetSound(InSoundWave);
				AudioManager->CommonAudioPlayers[i]->Play();
			}
			return;
		}
	}
}

void ANightSkyGameState::PlayCharaAudio(USoundBase* InSoundWave, float MaxDuration)
{
	for (int i = 0; i < CharaAudioChannelCount; i++)
	{
		if (BattleState.CharaAudioChannels[i].Finished)
		{
			BattleState.CharaAudioChannels[i].SoundWave = InSoundWave;
			BattleState.CharaAudioChannels[i].StartingFrame = BattleState.FrameNumber;
			BattleState.CharaAudioChannels[i].MaxDuration = MaxDuration;
			BattleState.CharaAudioChannels[i].Finished = false;
			if (!bIsResimulating)
			{
				AudioManager->CharaAudioPlayers[i]->SetSound(InSoundWave);
				AudioManager->CharaAudioPlayers[i]->Play();
			}
			return;
		}
	}
}

void ANightSkyGameState::PlayVoiceLine(USoundBase* InSoundWave, float MaxDuration, int Player)
{
	BattleState.CharaVoiceChannels[Player].SoundWave = InSoundWave;
	BattleState.CharaVoiceChannels[Player].StartingFrame = BattleState.FrameNumber;
	BattleState.CharaVoiceChannels[Player].MaxDuration = MaxDuration;
	BattleState.CharaVoiceChannels[Player].Finished = false;
	if (!bIsResimulating)
	{
		AudioManager->CharaVoicePlayers[Player]->SetSound(InSoundWave);
		AudioManager->CharaVoicePlayers[Player]->Play();
	}
}

void ANightSkyGameState::PlayAnnouncerVoice(USoundBase* InSoundWave, float MaxDuration)
{
	BattleState.AnnouncerVoiceChannel.SoundWave = InSoundWave;
	BattleState.AnnouncerVoiceChannel.StartingFrame = BattleState.FrameNumber;
	BattleState.AnnouncerVoiceChannel.MaxDuration = MaxDuration;
	BattleState.AnnouncerVoiceChannel.Finished = false;
	if (!bIsResimulating)
	{
		AudioManager->AnnouncerVoicePlayer->SetSound(InSoundWave);
		AudioManager->AnnouncerVoicePlayer->Play();
	}
}

void ANightSkyGameState::PlayMusic(const FGameplayTag Name)
{
	if (!IsValid(GameInstance))
		return;
	if (GameInstance->MusicData != nullptr)
	{
		for (FSoundStruct SoundStruct : GameInstance->MusicData->SoundDatas)
		{
			if (SoundStruct.Name == Name)
			{
				PlayMusic(SoundStruct.SoundWave, SoundStruct.MaxDuration);
				break;
			}
		}
	}
}

void ANightSkyGameState::PlayMusic(USoundBase* InSoundWave, float MaxDuration)
{
	BattleState.MusicChannel.SoundWave = InSoundWave;
	BattleState.MusicChannel.StartingFrame = BattleState.FrameNumber;
	BattleState.MusicChannel.MaxDuration = MaxDuration;
	if (!bIsResimulating)
	{
		AudioManager->MusicPlayer->SetSound(InSoundWave);
		AudioManager->MusicPlayer->Play();
	}
}

void ANightSkyGameState::ManageAudio()
{
	for (int i = 0; i < CommonAudioChannelCount; i++)
	{
		const int CurrentAudioTime = BattleState.FrameNumber - BattleState.CommonAudioChannels[i].StartingFrame;
		if (!BattleState.CommonAudioChannels[i].Finished && static_cast<int>(BattleState.CommonAudioChannels[i].
			MaxDuration * 60) < CurrentAudioTime)
		{
			BattleState.CommonAudioChannels[i].Finished = true;
			BattleState.CommonAudioChannels[i].SoundWave = nullptr;
			if (bIsResimulating) continue;
			AudioManager->CommonAudioPlayers[i]->Stop();
			AudioManager->CommonAudioPlayers[i]->SetSound(nullptr);
		}
	}
	for (int i = 0; i < CharaAudioChannelCount; i++)
	{
		const int CurrentAudioTime = BattleState.FrameNumber - BattleState.CharaAudioChannels[i].StartingFrame;
		if (!BattleState.CharaAudioChannels[i].Finished && static_cast<int>(BattleState.CharaAudioChannels[i].
			MaxDuration * 60) < CurrentAudioTime)
		{
			BattleState.CharaAudioChannels[i].Finished = true;
			BattleState.CharaAudioChannels[i].SoundWave = nullptr;
			if (bIsResimulating) continue;
			AudioManager->CharaAudioPlayers[i]->Stop();
			AudioManager->CharaAudioPlayers[i]->SetSound(nullptr);
		}
	}
	for (int i = 0; i < CharaVoiceChannelCount; i++)
	{
		const int CurrentAudioTime = BattleState.FrameNumber - BattleState.CharaVoiceChannels[i].StartingFrame;
		if (!BattleState.CharaVoiceChannels[i].Finished && static_cast<int>(BattleState.CharaVoiceChannels[i].
			MaxDuration * 60) < CurrentAudioTime)
		{
			BattleState.CharaVoiceChannels[i].Finished = true;
			BattleState.CharaVoiceChannels[i].SoundWave = nullptr;
			if (bIsResimulating) continue;
			AudioManager->CharaVoicePlayers[i]->Stop();
			AudioManager->CharaVoicePlayers[i]->SetSound(nullptr);
		}
	}
	{
		const int CurrentAudioTime = BattleState.FrameNumber - BattleState.AnnouncerVoiceChannel.StartingFrame;
		if (!BattleState.AnnouncerVoiceChannel.Finished && static_cast<int>(BattleState.AnnouncerVoiceChannel.
			MaxDuration * 60) < CurrentAudioTime)
		{
			BattleState.AnnouncerVoiceChannel.Finished = true;
			BattleState.AnnouncerVoiceChannel.SoundWave = nullptr;
			if (!bIsResimulating)
			{
				AudioManager->AnnouncerVoicePlayer->Stop();
				AudioManager->AnnouncerVoicePlayer->SetSound(nullptr);
			}
		}
	}
	{
		const int CurrentAudioTime = BattleState.FrameNumber - BattleState.MusicChannel.StartingFrame;
		if (static_cast<int>(BattleState.MusicChannel.MaxDuration * 60) < CurrentAudioTime)
		{
			PlayMusic(BattleState.MusicChannel.SoundWave, BattleState.MusicChannel.MaxDuration);
		}
	}
}

void ANightSkyGameState::RollbackStartAudio(int32 InFrame)
{
	ManageAudio();

	for (int i = 0; i < CommonAudioChannelCount; i++)
	{
		if (BattleState.CommonAudioChannels[i].Finished) continue;
		if (BattleState.CommonAudioChannels[i].SoundWave == AudioManager->CommonAudioPlayers[i]->GetSound()) continue;

		AudioManager->CommonAudioPlayers[i]->Stop();
		AudioManager->CommonAudioPlayers[i]->SetSound(BattleState.CommonAudioChannels[i].SoundWave);
		const float CurrentAudioTime = static_cast<float>(InFrame - BattleState.CommonAudioChannels[i].StartingFrame) /
			60.f;
		if (BattleState.CommonAudioChannels[i].MaxDuration > CurrentAudioTime)
			AudioManager->CommonAudioPlayers[i]->Play(CurrentAudioTime);
	}
	for (int i = 0; i < CharaAudioChannelCount; i++)
	{
		if (BattleState.CharaAudioChannels[i].Finished) continue;
		if (BattleState.CharaAudioChannels[i].SoundWave == AudioManager->CharaAudioPlayers[i]->GetSound()) continue;

		AudioManager->CharaAudioPlayers[i]->Stop();
		AudioManager->CharaAudioPlayers[i]->SetSound(BattleState.CharaAudioChannels[i].SoundWave);
		const float CurrentAudioTime = static_cast<float>(InFrame - BattleState.CharaAudioChannels[i].StartingFrame) /
			60.f;
		if (BattleState.CharaAudioChannels[i].MaxDuration > CurrentAudioTime)
			AudioManager->CharaAudioPlayers[i]->Play(CurrentAudioTime);
	}
	for (int i = 0; i < CharaVoiceChannelCount; i++)
	{
		if (BattleState.CharaVoiceChannels[i].Finished) continue;
		if (BattleState.CharaVoiceChannels[i].SoundWave == AudioManager->CharaVoicePlayers[i]->GetSound()) continue;

		AudioManager->CharaVoicePlayers[i]->Stop();
		AudioManager->CharaVoicePlayers[i]->SetSound(BattleState.CharaVoiceChannels[i].SoundWave);
		const float CurrentAudioTime = static_cast<float>(InFrame - BattleState.CharaVoiceChannels[i].StartingFrame) /
			60.f;
		if (BattleState.CharaVoiceChannels[i].MaxDuration > CurrentAudioTime)
			AudioManager->CharaVoicePlayers[i]->Play(CurrentAudioTime);
	}
	if (!BattleState.AnnouncerVoiceChannel.Finished && BattleState.AnnouncerVoiceChannel.SoundWave != AudioManager->
		AnnouncerVoicePlayer->GetSound())
	{
		AudioManager->AnnouncerVoicePlayer->Stop();
		AudioManager->AnnouncerVoicePlayer->SetSound(BattleState.AnnouncerVoiceChannel.SoundWave);
		const float CurrentAudioTime = static_cast<float>(InFrame - BattleState.AnnouncerVoiceChannel.StartingFrame) /
			60.f;
		if (BattleState.AnnouncerVoiceChannel.MaxDuration > CurrentAudioTime)
			AudioManager->AnnouncerVoicePlayer->Play(CurrentAudioTime);
	}
	if (BattleState.MusicChannel.SoundWave != AudioManager->MusicPlayer->GetSound())
	{
		AudioManager->MusicPlayer->Stop();
		AudioManager->MusicPlayer->SetSound(BattleState.MusicChannel.SoundWave);
		const float CurrentAudioTime = static_cast<float>(InFrame - BattleState.MusicChannel.StartingFrame) / 60.f;
		if (BattleState.MusicChannel.MaxDuration > CurrentAudioTime)
			AudioManager->MusicPlayer->Play(CurrentAudioTime);
	}
}

void ANightSkyGameState::SaveGameState(FRollbackData& RollbackData, int32* InChecksum)
{
	RollbackData.BattleStateBuffer.AddUninitialized(SizeOfBattleState);
	FMemory::Memcpy(RollbackData.BattleStateBuffer.GetData(), &BattleState.BattleStateSync, SizeOfBattleState);
	RollbackData.BattleStateData = SaveForRollback();
	for (int i = 0; i < BattleExtensions.Num(); i++)
	{
		RollbackData.ExtensionData.Add(BattleExtensions[i]->SaveForRollback());
	}
	if (BattleExtensions.Num() == 0)
	{
		RollbackData.ExtensionData.Add(TArray<uint8>{1});
	}
	for (int i = 0; i < MaxBattleObjects; i++)
	{
		if (Objects[i]->IsActive)
		{
			RollbackData.ObjBuffer.AddDefaulted();
			RollbackData.ObjBuffer.Last().AddUninitialized(SizeOfBattleObject);
			Objects[i]->SaveForRollback(RollbackData.ObjBuffer[i].GetData());
			RollbackData.StateData.Add(Objects[i]->ObjectState->SaveForRollback());
			RollbackData.ObjActive.AddDefaulted();
			RollbackData.ObjActive[i] = true;
		}
		else
		{
			RollbackData.ObjBuffer.AddDefaulted();
			RollbackData.ObjActive.AddDefaulted();
			RollbackData.ObjActive[i] = false;
			RollbackData.StateData.Add(TArray<uint8>{1});
		}
	}
	for (int i = 0; i < Players.Num(); i++)
	{
		RollbackData.ObjBuffer.AddDefaulted();
		RollbackData.ObjBuffer.Last().AddUninitialized(SizeOfBattleObject);
		Players[i]->SaveForRollback(RollbackData.ObjBuffer[i + MaxBattleObjects].GetData());
		if (Players[i]->PlayerFlags & PLF_IsOnScreen)
		{
			RollbackData.StateData.Add(Players[i]->PrimaryStateMachine.CurrentState->SaveForRollback());
		}
		else
		{
			RollbackData.StateData.Add(TArray<uint8>{1});
		}
		RollbackData.CharBuffer.AddDefaulted();
		RollbackData.CharBuffer.Last().AddUninitialized(SizeOfPlayerObject);
		Players[i]->SaveForRollbackPlayer(RollbackData.CharBuffer[i].GetData());
		RollbackData.PlayerData.Add(Players[i]->SaveForRollbackBP());
	}

	RollbackData.WidgetAnimationData.Add(BattleHudActor->TopWidget->SaveForRollback());
	RollbackData.WidgetAnimationData.Add(BattleHudActor->BottomWidget->SaveForRollback());

	*InChecksum = CreateChecksum();
}

void ANightSkyGameState::LoadGameState(FRollbackData& RollbackData)
{
	const int CurrentFrame = BattleState.FrameNumber;
	FMemory::Memcpy(&BattleState.BattleStateSync, RollbackData.BattleStateBuffer.GetData(), SizeOfBattleState);
	LoadForRollback(RollbackData.BattleStateData);
	for (int i = 0; i < BattleExtensions.Num(); i++)
	{
		BattleExtensions[i]->LoadForRollback(RollbackData.ExtensionData[i]);
	}
	for (int i = 0; i < MaxBattleObjects; i++)
	{
		if (RollbackData.ObjActive[i])
		{
			Objects[i]->LoadForRollback(RollbackData.ObjBuffer[i].GetData());
			Objects[i]->ObjectState->LoadForRollback(RollbackData.StateData[i]);
		}
		else
		{
			if (Objects[i]->IsActive)
				Objects[i]->ResetObject();
		}
	}
	for (int i = 0; i < Players.Num(); i++)
	{
		Players[i]->LoadForRollback(RollbackData.ObjBuffer[i + MaxBattleObjects].GetData());
		if (Players[i]->PlayerFlags & PLF_IsOnScreen)
		{
			Players[i]->PrimaryStateMachine.CurrentState->LoadForRollback(
				RollbackData.StateData[i + MaxBattleObjects]);
		}
		Players[i]->LoadForRollbackPlayer(RollbackData.CharBuffer[i].GetData());
		Players[i]->LoadForRollbackBP(RollbackData.PlayerData[i]);
	}
	SortObjects();
	ParticleManager->RollbackParticles(CurrentFrame - BattleState.FrameNumber);

	BattleHudActor->TopWidget->LoadForRollback(RollbackData.WidgetAnimationData[0]);
	BattleHudActor->BottomWidget->LoadForRollback(RollbackData.WidgetAnimationData[1]);

	BattleHudActor->TopWidget->RollbackAnimations();
	BattleHudActor->BottomWidget->RollbackAnimations();

	if (!FighterRunner->IsA(AFighterSynctestRunner::StaticClass()))
		GameInstance->RollbackReplay(CurrentFrame - BattleState.FrameNumber);
}

TArray<uint8> ANightSkyGameState::SaveForRollback()
{
	TArray<uint8> SaveData;
	FObjectWriter Writer(SaveData);
	Writer.ArIsSaveGame = true;
	GetClass()->SerializeBin(Writer, this);
	return SaveData;
}

void ANightSkyGameState::LoadForRollback(const TArray<uint8>& InBytes)
{
	if (InBytes.Num() <= 1) return;
	FObjectReader Reader(InBytes);
	Reader.ArIsSaveGame = true;
	GetClass()->SerializeBin(Reader, this);
}

void ANightSkyGameState::EndMatch()
{
	EndMatch_BP();
	BattleState.BattlePhase = EBattlePhase::EndScreen;
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Actors/AudioManager.h"
#include "Objects/PlayerObject.h"
#include "GameFramework/GameStateBase.h"
#include "include/ggponet.h"
#include "Misc/RandomManager.h"
#include "NightSkyGameState.generated.h"

class UBattleExtensionData;
class UBattleExtension;
constexpr int32 MaxRollbackFrames = 1;
constexpr float OneFrame = 0.0166666666;

class ANightSkyBattleHudActor;

// Battle data

UENUM(BlueprintType)
enum class EBattleFormat : uint8
{
	Rounds,
	Tag,
	KOF,
};

enum EIntroSide
{
	INT_P1,
	INT_P2,
	INT_None,
};

UENUM(BlueprintType)
enum EWinSide 
{
	WIN_None,
	WIN_P1,
	WIN_P2,
	WIN_Draw,
};

UENUM()
enum class EBattlePhase
{
	Intro,
	Battle,
	RoundEnd,
	Fade,
	Outro,
	EndScreen,
};

USTRUCT()
struct FAudioChannel
{
	GENERATED_BODY()

	UPROPERTY()
	USoundBase* SoundWave;
	int StartingFrame;
	float MaxDuration = 1.0f;
	bool Finished = true;
};

USTRUCT()
struct FTeamData
{
	GENERATED_BODY()

	UPROPERTY(SaveGame)
	int TeamCount = 0;

	UPROPERTY(SaveGame)
	TArray<int32> CooldownTimer;
};

UENUM(Meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = "true"))
enum EScreenFlag 
{
	SCR_None,
	SCR_Lock = 1 << 0,
	SCR_LockXPos = 1 << 1,
	SCR_LockYPos = 1 << 2,
	SCR_LockWidth = 1 << 3,
	SCR_DisableScreenSides = 1 << 4,
};

ENUM_CLASS_FLAGS(EScreenFlag);

USTRUCT(BlueprintType)
struct FScreenData 
{
	GENERATED_BODY()

	TEnumAsByte<EScreenFlag> Flags;
	bool bTouchingWorldSide;
	
	UPROPERTY(EditAnywhere)
	int DefaultMaxWidth = 1689;
	UPROPERTY(EditAnywhere)
	int DefaultWidth = 1280;

	int MaxZoomOutWidth = 1689;
	int ZoomOutBeginX = 1280;
	int ZoomOutBeginY = 180;
	int ZoomOutBeginH = 360;
	
	UPROPERTY(SaveGame)
	TArray<ABattleObject*> TargetObjects{};
	
	int ObjTop = 0;
	int ObjBottom = 0;
	int HigherObjBottom = 0;
	int ObjLeft = 0;
	int ObjRight = 0;
	int ObjLength = 0;
	int ObjHeight = 0;
	int ObjDistanceY = 0;

	int ScreenWorldCenterX = 0;
	int ScreenWorldCenterY = 0;
	int ScreenWorldWidth = 1280;

	int TargetCenterX = 0;
	int TargetCenterY = 0;
	int TargetWidth = 1280;

	int CenterXVelocity = 0;
	int CenterYVelocity = 0;
	int WidthVelocity = 0;

	int FinalScreenX = 0;
	int FinalScreenY = 0;
	int FinalScreenWidth = 1280;

	float ScreenYZoom = 0;
	
	int TargetOffsetY = 350;
	int TargetOffsetLandYMax = 250;
	int TargetOffsetLandYAdd = 6;
	int TargetOffsetAirYMax = 180;
	int TargetOffsetAirYAdd = 3;
	int TargetOffsetAirYPos = 400;
	int TargetOffsetAirYDist = 570;

	int ScreenBoundsLeft = -640;
	int ScreenBoundsRight = 640;
	int ScreenBoundsTop = 0;

	UPROPERTY(EditAnywhere)
	int StageBoundsLeft = -3200;
	UPROPERTY(EditAnywhere)
	int StageBoundsRight = 3200;
	UPROPERTY(EditAnywhere)
	int StageBoundsTop = 5400;
};

USTRUCT(BlueprintType)
struct FBattleState
{
	GENERATED_BODY()

	char BattleStateSync;
	
	int32 FrameNumber = 0;
	int32 TimeUntilRoundStart = 0;

	UPROPERTY(EditAnywhere)
	int32 TagCooldown = 300;
	UPROPERTY(EditAnywhere)
	int32 AssistCooldown = 180;
	
	UPROPERTY(EditAnywhere)
	int32 RoundStartPos = 297500;

	UPROPERTY(EditAnywhere, SaveGame)
	FScreenData ScreenData;
	
	FVector CameraPosition = FVector();
	bool bHUDVisible = true;
	
	UPROPERTY(BlueprintReadOnly)
	int32 RoundTimer = 0;
	
	bool PauseTimer = false;
	bool PauseParticles = false;
	bool IsPlayingSequence = false;
	
	FRandomManager RandomManager;
	
	int32 Meter[2] {0, 0};
	int32 MaxMeter[2] {10000, 10000};

	int32 SuperFreezeDuration = 0;
	int32 SuperFreezeSelfDuration = 0;
	
	UPROPERTY()
	ABattleObject* SuperFreezeCaller = nullptr;
	UPROPERTY()
	APlayerObject* MainPlayer[2];
	
	int32 P1RoundsWon = 0;
	int32 P2RoundsWon = 0;
	UPROPERTY(BlueprintReadOnly)
	int32 RoundCount = 0;
	int32 FadeTimer;

	EIntroSide CurrentIntroSide = INT_None;
	UPROPERTY(BlueprintReadOnly)
	TEnumAsByte<EWinSide> CurrentWinSide = WIN_None;
	EBattlePhase BattlePhase = EBattlePhase::Intro;
	
	int32 ActiveObjectCount = 0;
	int32 CurrentSequenceTime = -1;
	
	FAudioChannel CommonAudioChannels[CommonAudioChannelCount];
	FAudioChannel CharaAudioChannels[CharaAudioChannelCount];
	FAudioChannel CharaVoiceChannels[CharaVoiceChannelCount];
	FAudioChannel AnnouncerVoiceChannel;
	FAudioChannel MusicChannel;
	
	UPROPERTY(BlueprintReadOnly)
	float OrthoBlendActive;

	char BattleStateSyncEnd;

	UPROPERTY(SaveGame)
	FTeamData TeamData[2];
	
	UPROPERTY(SaveGame)
	TArray<int32> GaugeP1;
	UPROPERTY(SaveGame)
	TArray<int32> GaugeP2;
	UPROPERTY(EditAnywhere, SaveGame)
	TArray<int32> MaxGauge;
	
	UPROPERTY(BlueprintReadOnly)
	EBattleFormat BattleFormat = EBattleFormat::Rounds;
	UPROPERTY(BlueprintReadOnly)
	int32 MaxRoundCount;
	UPROPERTY(BlueprintReadOnly)
	int32 MaxTimeUntilRoundStart;
	UPROPERTY(EditAnywhere)
	int32 MaxFadeTimer = 12;
};

constexpr size_t SizeOfBattleState = offsetof(FBattleState, BattleStateSyncEnd) - offsetof(
	FBattleState, BattleStateSync);

USTRUCT()
struct FRollbackData
{
	GENERATED_BODY()
	
	UPROPERTY()
	TArray<bool> ObjActive;
	TArray<TArray<uint8>> ObjBuffer;
	TArray<TArray<uint8>> CharBuffer;
	TArray<uint8> BattleStateBuffer;
	TArray<TArray<uint8>> PlayerData;
	TArray<uint8> BattleStateData;
	TArray<TArray<uint8>> StateData;
	TArray<TArray<uint8>> ExtensionData;
	TArray<TArray<uint8>> WidgetAnimationData;
	
	void Serialize(FArchive& Ar);
};

// Network

USTRUCT(BlueprintType)
struct FNetworkStats
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadOnly)
	int32 Ping;
	UPROPERTY(BlueprintReadOnly)
	int32 RollbackFrames;
};

// Main class

UCLASS()
class NIGHTSKYENGINE_API ANightSkyGameState : public AGameStateBase
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ANightSkyGameState();
	
	UPROPERTY(EditAnywhere, Category=Defaults)
	int MaxBattleObjects = 400;
	UPROPERTY(EditAnywhere, Category=Defaults)
	TSubclassOf<ABattleObject> BattleObjectClass = ABattleObject::StaticClass();
	UPROPERTY()
	TArray<ABattleObject*> Objects {};
	UPROPERTY()
	TArray<APlayerObject*> Players {};
	UPROPERTY(EditAnywhere, BlueprintReadOnly, SaveGame, Category=Battle)
	FBattleState BattleState {};
	
	UPROPERTY()
	TArray<ABattleObject*> SortedObjects {};
	
	UPROPERTY(BlueprintReadWrite)
	FTransform BattleSceneTransform;
	
	UPROPERTY()
	TArray<UBattleExtension*> BattleExtensions = {};
	TArray<FGameplayTag> BattleExtensionNames = {};

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	UBattleExtensionData* BattleExtensionData = {};

	UPROPERTY()
	class UNightSkyGameInstance* GameInstance = nullptr;

	UPROPERTY()
	class AParticleManager* ParticleManager = nullptr;
	UPROPERTY()
	AAudioManager* AudioManager = nullptr;

	UPROPERTY(BlueprintReadWrite)
	class ALevelSequenceActor* SequenceActor = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ACameraActor* CameraActor = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ACameraActor* SequenceCameraActor = nullptr;
	UPROPERTY(EditDefaultsOnly, Category=Defaults)
	TSubclassOf<ACameraActor> SequenceCameraActorClass;
	UPROPERTY(BlueprintReadOnly)
	APlayerObject* SequenceTarget = nullptr;
	UPROPERTY(BlueprintReadOnly)
	APlayerObject* SequenceEnemy = nullptr;
	UPROPERTY(BlueprintGetter=GetPaused, BlueprintSetter=SetPaused)
	bool bPauseGame = false;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Debug)
	bool bViewCollision = false;

	UPROPERTY(BlueprintReadOnly)
	bool bIsPlayingSequence = false;

	UPROPERTY()
	class AFighterLocalRunner* FighterRunner = nullptr;;
	UPROPERTY(BlueprintReadWrite)
	ANightSkyBattleHudActor* BattleHudActor = nullptr;;
	
	int32 LocalFrame = 0;
	int32 RemoteFrame = 0;

private:
	int32 LocalInputs[2] = {};
	int32 Checksum = 0;
	int32 OtherChecksum = 0;
	int32 OtherChecksumFrame = 0;
	int32 PrevOtherChecksumFrame = 0;
	FNetworkStats NetworkStats = FNetworkStats();
	bool bIsResimulating = false;
	
protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
	void Init();
	void PlayIntros();
	void UpdateLocalInput(); //updates local input
	void SortObjects();
	void HandlePushCollision() const; //for each active object, handle push collision
	void HandleHitCollision() const;
	void UpdateVisuals(bool bShouldResimulate) const;
	void HandleRoundWin();
	void NextRoundTransition(bool bIsP1);
	bool HandleMatchWin();
	void CollisionView() const;
	int32 CreateChecksum();
	FGGPONetworkStats GetNetworkStats() const;
	void ResetTraining();
	
public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	UFUNCTION(BlueprintCallable)
	void MatchInit();
	void RoundInit();
	
	void AssignEnemy();
	
	void UpdateGameState();
	void UpdateGameState(int32 Input1, int32 Input2, bool bShouldResimulate);

	void SetScreenCorners();
	void UpdateScreen();
	void SetScreenBounds() const; //forces wall collision
	void StartSuperFreeze(int32 Duration, int32 SelfDuration, ABattleObject* CallingObject);
	void ScreenPosToWorldPos(int32 X, int32 Y, int32& OutX, int32& OutY) const;
	ABattleObject* AddBattleObject(const UState* InState, int PosX, int PosY, EObjDir Dir, int32 ObjectStateIndex, bool bIsCommonState, APlayerObject* Parent) const;
	void SetDrawPriorityFront(ABattleObject* InObject) const;
	void SetDrawPriorityBack(ABattleObject* InObject) const;
	APlayerObject* SwitchMainPlayer(APlayerObject* InPlayer, int TeamIndex, bool bForce = false, bool bEvenOnScreen = false);
	APlayerObject* CallAssist(const bool IsP1, int AssistIndex, const FGameplayTag AssistName);
	void SetTeamCooldown(const bool IsP1, const int TeamIndex, const int Cooldown);
	bool CanTag(const APlayerObject* InPlayer, int TeamIndex) const;
	
	void SaveGameState(FRollbackData& RollbackData, int32* InChecksum); //saves game state
	void LoadGameState(FRollbackData& RollbackData); //loads game state
	
	TArray<uint8> SaveForRollback();
	void LoadForRollback(const TArray<uint8>& InBytes);
	void EndMatch();

	void UpdateCamera();
	void PlayLevelSequence(APlayerObject* Target, APlayerObject* Enemy, ULevelSequence* Sequence);
	void StopLevelSequence();
	void CameraShake(const TSubclassOf<UCameraShakeBase>& Pattern, float Scale) const;

	void HUDInit() const;
	void UpdateHUD();
	void BattleHudVisibility(bool Visible);
	
	void PlayCommonAudio(USoundBase* InSoundWave, float MaxDuration);
	void PlayCharaAudio(USoundBase* InSoundWave, float MaxDuration);
	void PlayVoiceLine(USoundBase* InSoundWave, float MaxDuration, int Player);
	void PlayAnnouncerVoice(USoundBase* InSoundWave, float MaxDuration);
	void PlayMusic(USoundBase* InSoundWave, float MaxDuration);
	void ManageAudio();
	void RollbackStartAudio(int32 InFrame);

	int GetLocalInputs(int Index) const; //get local inputs from player controller
	void SetOtherChecksum(uint32 RemoteChecksum, int32 InFrame);

	UFUNCTION(BlueprintCallable)
	void PlayAnnouncerVoice(const FGameplayTag Name);
	UFUNCTION(BlueprintCallable)
	void PlayMusic(const FGameplayTag Name);

	UFUNCTION(BlueprintCallable)
	TArray<APlayerObject*> GetTeam(bool IsP1) const;
	UFUNCTION(BlueprintCallable)
	APlayerObject* GetMainPlayer(bool IsP1) const;
	UFUNCTION(BlueprintCallable)
	void CallBattleExtension(FGameplayTag Name);
	UFUNCTION(BlueprintPure)
	int32 GetGauge(bool IsP1, int32 GaugeIndex) const;
	UFUNCTION(BlueprintCallable)
	void SetGauge(bool IsP1, int32 GaugeIndex, int32 Value);
	UFUNCTION(BlueprintCallable)
	void UseGauge(bool IsP1, int32 GaugeIndex, int32 Value);
	UFUNCTION(BlueprintPure)
	EScreenFlag GetScreenFlags() const;
	UFUNCTION(BlueprintCallable)
	void SetScreenFlags(UPARAM(meta = (Bitmask, BitmaskEnum = "/Script/NightSkyEngine.EScreenFlag")) int32 InFlags);
	UFUNCTION(BlueprintPure)
	bool IsTagBattle() const;
	UFUNCTION(BlueprintPure)
	int32 GetTeamCount(bool bIsP1) const;
	
	UFUNCTION(BlueprintPure)
	bool GetPaused() const;
	UFUNCTION(BlueprintCallable)
	void SetPaused(bool bPause);
	
	UFUNCTION(BlueprintImplementableEvent)
	void EndMatch_BP();
	UFUNCTION(BlueprintImplementableEvent)
	void UpdateHUD_BP();
	UFUNCTION(BlueprintImplementableEvent)
	void UpdateHUDAnimations_BP();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyPlayerController.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyPlayerController.h"

#include "EngineUtils.h"
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#include "InputMappingContext.h"
#include "NightSkyGameState.h"
#include "FighterRunners/FighterMultiplayerRunner.h"
#include "GameFramework/InputSettings.h"
#include "Kismet/GameplayStatics.h"
#include "NightSkyEngine/Battle/Misc/Bitflags.h"
#include "NightSkyEngine/Data/PrimaryCharaData.h"
#include "NightSkyEngine/Network/NetworkPawn.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "NightSkyEngine/Network/RpcConnectionManager.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyPlayerController)

// Sets default values
ANightSkyPlayerController::ANightSkyPlayerController()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	Inputs = 0;
	Frame = 0;
	NetworkPawn = nullptr;
	bRematch = false;
}

// Called when the game starts or when spawned
void ANightSkyPlayerController::BeginPlay()
{
	Super::BeginPlay();
}

// Called every frame
void ANightSkyPlayerController::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	NetworkPawn = Cast<ANetworkPawn>(GetPawn());
	
	if (NetworkPawn != nullptr)
	{
		const int PlayerIndex = Cast<UNightSkyGameInstance>(GetGameInstance())->PlayerIndex;
		TArray<ANetworkPawn*> NetworkPawns;
		for (TActorIterator<ANetworkPawn> It(GetWorld()); It; ++It)
		{
			NetworkPawns.Add(*It);
		}
		if (NetworkPawns.Num() > 1)
		{
			if (PlayerIndex == 0)
			{
				SendGgpo(NetworkPawns[1], true);
			}
			else
			{
				SendGgpo(NetworkPawns[0], false);
			}
		}
		if (NetworkPawn->bRematchAccepted && bRematch)
		{
			Inputs |= INP_Rematch;
		}
		else
		{
			Inputs = Inputs & ~INP_Rematch;			
		}
	}
}


void ANightSkyPlayerController::SetupInputComponent()
{
	if (GetLocalPlayer())
	{
		if (UEnhancedInputLocalPlayerSubsystem* InputSystem = GetLocalPlayer()->GetSubsystem<UEnhancedInputLocalPlayerSubsystem>())
		{
			if (!InputMapping.IsNull())
			{
				InputSystem->AddMappingContext(InputMapping.LoadSynchronous(), 0);
			}
		}
	}
	
	if (InputComponent == NULL)
	{
		InputComponent = NewObject<UEnhancedInputComponent>(this, UInputSettings::GetDefaultInputComponentClass(), TEXT("PC_InputComponent0"));
		InputComponent->RegisterComponent();
	}

	UEnhancedInputComponent* Input = Cast<UEnhancedInputComponent>(InputComponent);
	
	if (IsValid(InputActions.PressUp))
		Input->BindAction(InputActions.PressUp.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressUp);
	if (IsValid(InputActions.ReleaseUp))
		Input->BindAction(InputActions.ReleaseUp.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseUp);
	if (IsValid(InputActions.PressDown))
		Input->BindAction(InputActions.PressDown.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressDown);
	if (IsValid(InputActions.ReleaseDown))
		Input->BindAction(InputActions.ReleaseDown.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseDown);
	if (IsValid(InputActions.PressLeft))
		Input->BindAction(InputActions.PressLeft.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressLeft);
	if (IsValid(InputActions.ReleaseLeft))
		Input->BindAction(InputActions.ReleaseLeft.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseLeft);
	if (IsValid(InputActions.PressRight))
		Input->BindAction(InputActions.PressRight.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressRight);
	if (IsValid(InputActions.ReleaseRight))
		Input->BindAction(InputActions.ReleaseRight.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseRight);
	if (IsValid(InputActions.PressA))
		Input->BindAction(InputActions.PressA.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressA);
	if (IsValid(InputActions.ReleaseA))
		Input->BindAction(InputActions.ReleaseA.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseA);
	if (IsValid(InputActions.PressA))
		Input->BindAction(InputActions.PressB.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressB);
	if (IsValid(InputActions.ReleaseB))
		Input->BindAction(InputActions.ReleaseB.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseB);
	if (IsValid(InputActions.PressC))
		Input->BindAction(InputActions.PressC.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressC);
	if (IsValid(InputActions.ReleaseC))
		Input->BindAction(InputActions.ReleaseC.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseC);
	if (IsValid(InputActions.PressD))
		Input->BindAction(InputActions.PressD.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressD);
	if (IsValid(InputActions.ReleaseD))
		Input->BindAction(InputActions.ReleaseD.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseD);
	if (IsValid(InputActions.PressE))
		Input->BindAction(InputActions.PressE.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressE);
	if (IsValid(InputActions.ReleaseE))
		Input->BindAction(InputActions.ReleaseE.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseE);
	if (IsValid(InputActions.PressF))
		Input->BindAction(InputActions.PressF.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressF);
	if (IsValid(InputActions.ReleaseF))
		Input->BindAction(InputActions.ReleaseF.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseF);
	if (IsValid(InputActions.PressG))
		Input->BindAction(InputActions.PressG.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressG);
	if (IsValid(InputActions.ReleaseG))
		Input->BindAction(InputActions.ReleaseG.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseG);
	if (IsValid(InputActions.PressH))
		Input->BindAction(InputActions.PressH.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PressH);
	if (IsValid(InputActions.ReleaseH))
		Input->BindAction(InputActions.ReleaseH.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ReleaseH);
	if (IsValid(InputActions.PauseGame))
		Input->BindAction(InputActions.PauseGame.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::PauseGame);
	if (IsValid(InputActions.ResetTraining))
		Input->BindAction(InputActions.ResetTraining.Get(), ETriggerEvent::Triggered, this, &ANightSkyPlayerController::ResetTraining);
}

void ANightSkyPlayerController::PressUp()
{
	Inputs |= INP_Up;
}

void ANightSkyPlayerController::ReleaseUp()
{
	Inputs = Inputs & ~INP_Up;
}

void ANightSkyPlayerController::PressDown()
{
	Inputs |= INP_Down;
}

void ANightSkyPlayerController::ReleaseDown()
{
	Inputs = Inputs & ~INP_Down;
}

void ANightSkyPlayerController::PressLeft()
{
	Inputs |= INP_Left;
}

void ANightSkyPlayerController::ReleaseLeft()
{
	Inputs = Inputs & ~INP_Left;
}

void ANightSkyPlayerController::PressRight()
{
	Inputs |= INP_Right;
}

void ANightSkyPlayerController::ReleaseRight()
{
	Inputs = Inputs & ~INP_Right;
}

void ANightSkyPlayerController::PressA()
{
	Inputs |= INP_A;
}

void ANightSkyPlayerController::ReleaseA()
{
	Inputs = Inputs & ~INP_A;
}

void ANightSkyPlayerController::PressB()
{
	Inputs |= INP_B;
}

void ANightSkyPlayerController::ReleaseB()
{
	Inputs = Inputs & ~INP_B;
}

void ANightSkyPlayerController::PressC()
{
	Inputs |= INP_C;
}

void ANightSkyPlayerController::ReleaseC()
{
	Inputs = Inputs & ~INP_C;
}

void ANightSkyPlayerController::PressD()
{
	Inputs |= INP_D;
}

void ANightSkyPlayerController::ReleaseD()
{
	Inputs = Inputs & ~INP_D;
}

void ANightSkyPlayerController::PressE()
{
	Inputs |= INP_E;	
}

void ANightSkyPlayerController::ReleaseE()
{
	Inputs = Inputs & ~INP_E;
}

void ANightSkyPlayerController::PressF()
{
	Inputs |= INP_F;	
}

void ANightSkyPlayerController::ReleaseF()
{
	Inputs = Inputs & ~INP_F;
}

void ANightSkyPlayerController::PressG()
{
	Inputs |= INP_G;
}

void ANightSkyPlayerController::ReleaseG()
{
	Inputs = Inputs & ~INP_G;
}


void ANightSkyPlayerController::PressH()
{
	Inputs |= INP_H;
}

void ANightSkyPlayerController::ReleaseH()
{
	Inputs = Inputs & ~INP_H;
}

void ANightSkyPlayerController::PauseGame()
{
	const auto GameState = Cast<ANightSkyGameState>(GetWorld()->GetGameState());
	if (!GameState) return;
	
	if (!GameState->bPauseGame)
	{
		GameState->SetPaused(true);
		OpenPauseMenu();
	}
}

void ANightSkyPlayerController::ResetTraining()
{
	Inputs |= INP_ResetTraining;
}

void ANightSkyPlayerController::SendGgpo(ANetworkPawn* InNetworkPawn, bool Client) const
{
	if(InNetworkPawn->FighterMultiplayerRunner==nullptr)//TODO: CHECK IF MULTIPLAYERRUNNER IS SPAWNED BEFORE THIS, IF SO DO THIS IN BEGINPLAY
	{
		TArray<AActor*> FoundFighterGameStates;
		UGameplayStatics::GetAllActorsOfClass(GetWorld(), AFighterMultiplayerRunner::StaticClass(), FoundFighterGameStates);
		if(FoundFighterGameStates.Num()>0)
		{
			InNetworkPawn->FighterMultiplayerRunner = Cast<AFighterMultiplayerRunner>(FoundFighterGameStates[0]);
		}
	}

	if (InNetworkPawn->FighterMultiplayerRunner && InNetworkPawn->FighterMultiplayerRunner->connectionManager)
	{
		while(InNetworkPawn->FighterMultiplayerRunner->connectionManager->sendSchedule.Num()>0)
		{
			const auto SendVal = InNetworkPawn->FighterMultiplayerRunner->connectionManager->sendSchedule.GetTail();
			if(Client)
			{
				InNetworkPawn->SendGgpoToClient(SendVal->GetValue());
			}
			else
			{
				InNetworkPawn->SendGgpoToServer(SendVal->GetValue());
			}
			InNetworkPawn->FighterMultiplayerRunner->connectionManager->sendSchedule.Empty();
			//InNetworkPawn->FighterMultiplayerRunner->connectionManager->sendSchedule.RemoveNode(SendVal);
		}
	}
}

void ANightSkyPlayerController::SendBattleData()
{
	if (bSentCharaData) return;
	
	int PlayerIndex = Cast<UNightSkyGameInstance>(GetGameInstance())->PlayerIndex;
	TArray<ANetworkPawn*> NetworkPawns;
	for (TActorIterator<ANetworkPawn> It(GetWorld()); It; ++It)
	{
		NetworkPawns.Add(*It);
	}
	if (NetworkPawns.Num() > 1)
	{
		FNetworkMirror NetworkMirror{};
		UNightSkyGameInstance* GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
		if (PlayerIndex == 0)
		{
			if (NetworkPawns[1]->CharaDataReceived) return;
			for (const auto CharaData : GameInstance->BattleData.PlayerListP1)
			{
				NetworkMirror.PlayerList.Add(CharaData->GetPrimaryAssetId());
			}
			NetworkPawns[1]->ClientGetBattleData(GameInstance->BattleData, NetworkMirror);
			NetworkPawns[1]->CharaDataReceived = true;
			bSentCharaData = true;
		}
		else
		{
			for (const auto CharaData : GameInstance->BattleData.PlayerListP2)
			{
				NetworkMirror.PlayerList.Add(CharaData->GetPrimaryAssetId());
			}
			NetworkPawns[0]->ServerGetBattleData(GameInstance->BattleData, NetworkMirror);
			bSentCharaData = true;
		}
	}
}

void ANightSkyPlayerController::Rematch()
{
	bRematch = true;
	if (const UNightSkyGameInstance* GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance()); GameInstance->
		FighterRunner != Multiplayer)
	{
		Cast<ANightSkyGameState>(GetWorld()->GetGameState())->MatchInit();
		bRematch = false;
	}
	else
	{
		int PlayerIndex = Cast<UNightSkyGameInstance>(GetGameInstance())->PlayerIndex;
		TArray<ANetworkPawn*> NetworkPawns;
		for (TActorIterator<ANetworkPawn> It(GetWorld()); It; ++It)
		{
			NetworkPawns.Add(*It);
		}
		if (NetworkPawns.Num() > 1)
		{
			if (PlayerIndex != 0) NetworkPawns[0]->SendRematchToServer();
			else NetworkPawns[1]->bRematchAccepted = true;
		}
	}
}

void ANightSkyPlayerController::PostRematch()
{
	NetworkPawn->bRematchAccepted = false;
	bRematch = false;
	Inputs = Inputs & ~INP_Rematch;
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyPlayerController.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "NightSkyPlayerController.generated.h"

class UInputAction;
class UInputMappingContext;
class ANetworkPawn;

USTRUCT()
struct FBattleInputActions
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressUp;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseUp;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressDown;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseDown;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressLeft;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseLeft;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressRight;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseRight;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressA;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseA;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressB;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseB;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressC;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseC;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressD;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseD;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressE;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseE;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressF;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseF;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressG;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseG;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PressH;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ReleaseH;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> PauseGame;
	UPROPERTY(EditAnywhere)
	TObjectPtr<const UInputAction> ResetTraining;
};

UCLASS()
class NIGHTSKYENGINE_API ANightSkyPlayerController : public APlayerController
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ANightSkyPlayerController();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	virtual void SetupInputComponent() override;
	
	int Inputs;
	int Frame;
	bool bRematch;
	bool bRematchAccepted;
	bool bSentCharaData;

	UPROPERTY(EditAnywhere, Category="Input")
	TSoftObjectPtr<UInputMappingContext> InputMapping;
	UPROPERTY(EditAnywhere, Category="Input")
	FBattleInputActions InputActions;
	
	void PressUp();
	void ReleaseUp();
	void PressDown();
	void ReleaseDown();
	void PressLeft();
	void ReleaseLeft();
	void PressRight();
	void ReleaseRight();
	void PressA();
	void ReleaseA();
	void PressB();
	void ReleaseB();
	void PressC();
	void ReleaseC();
	void PressD();
	void ReleaseD();
	void PressE();
	void ReleaseE();
	void PressF();
	void ReleaseF();
	void PressG();
	void ReleaseG();
	void PressH();
	void ReleaseH();

	void PauseGame();
	void ResetTraining();
	
	void SendGgpo(ANetworkPawn* InNetworkPawn, bool Client) const;
	
	UFUNCTION(BlueprintCallable)
	void SendBattleData();
	UFUNCTION(BlueprintCallable)
	void Rematch();
	
	void PostRematch();

	UPROPERTY(BlueprintReadOnly)
	ANetworkPawn* NetworkPawn;

	UFUNCTION(BlueprintImplementableEvent)
	void OpenPauseMenu();

	UFUNCTION(BlueprintImplementableEvent)
	void ClosePauseMenu();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "BattleObject.h"
#include "NiagaraComponent.h"
#include "NiagaraFunctionLibrary.h"
#include "NightSkyEngine/Battle/Misc/NightSkyBlueprintFunctionLibrary.h"
#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "NightSkyEngine/Battle/Actors/ParticleManager.h"
#include "PlayerObject.h"
#include "NightSkyEngine/Battle/Actors/LinkActor.h"
#include "NightSkyEngine/Battle/Animation/NightSkyAnimMetaData.h"
#include "NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.h"
#include "NightSkyEngine/Battle/Misc/Bitflags.h"
#include "NightSkyEngine/Battle/Misc/Globals.h"
#include "NightSkyEngine/Battle/Script/Subroutine.h"
#include "NightSkyEngine/Data/CameraShakeData.h"
#include "NightSkyEngine/Data/ParticleData.h"
#include "NightSkyEngine/Battle/Misc/RandomManager.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(BattleObject)

// Sets default values
ABattleObject::ABattleObject()
{
	// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	RootComponent = CreateDefaultSubobject<USceneComponent>("RootComponent");

	bReplicates = false;
}

// Called when the game starts or when spawned
void ABattleObject::BeginPlay()
{
	Super::BeginPlay();
	if (IsPlayer)
	{
		Player = Cast<APlayerObject>(this);
	}
}

void ABattleObject::Move()
{
	if (IsPlayer)
	{
		if (Player->PlayerFlags & PLF_IsThrowLock)
			return;
		Player->SetHitValuesOverTime();
	}
	else
	{
		PositionLinkUpdate();
	}

	// Set previous pos values
	PrevPosX = PosX;
	PrevPosY = PosY;
	CalculateHoming();

	if (BlendOffset && BlendCelName != FGameplayTag::EmptyTag && MaxCelTime)
	{
		const int32 TmpOffsetX = (NextOffsetX - PrevOffsetX) * (MaxCelTime - TimeUntilNextCel) / MaxCelTime;
		const int32 TmpOffsetY = (NextOffsetY - PrevOffsetY) * (MaxCelTime - TimeUntilNextCel) / MaxCelTime;

		AddPosXWithDir(TmpOffsetX);
		PosY += TmpOffsetY;
	}

	// Root motion
	if (const auto BodyAnimUserData = GetAnimSequenceUserData("Body"))
	{
		if (!MaxCelTime) return;
		
		const auto FrameAnim = AnimFrame + (BlendAnimFrame - AnimFrame) * (MaxCelTime - TimeUntilNextCel) / MaxCelTime;
		const auto RootMotion = BodyAnimUserData->GetRootTranslationAtTime(FrameAnim);

		AddPosXWithDir(RootMotion.X - PrevRootMotionX);
		PosY += RootMotion.Y - PrevRootMotionY;
		PosZ += RootMotion.Z - PrevRootMotionZ;

		return;
	}
	ApplyRootMotion();

	SpeedX = SpeedX * SpeedXRatePerFrame / 100;
	SpeedY = SpeedY * SpeedYRatePerFrame / 100;
	SpeedZ = SpeedZ * SpeedZRatePerFrame / 100;
	SpeedX = SpeedX * SpeedXRate / 100;
	SpeedY = SpeedY * SpeedYRate / 100;
	SpeedZ = SpeedZ * SpeedZRate / 100;

	SpeedXRate = SpeedYRate = SpeedZRate = 100;

	if (MiscFlags & MISC_InertiaEnable) //only use inertia if enabled
	{
		if (PosY <= GroundHeight && MiscFlags & MISC_FloorCollisionActive) //only decrease inertia if grounded
		{
			Inertia = Inertia - Inertia / 10;
		}
		if (Inertia > -875 && Inertia < 875) //if inertia small enough, set to zero
		{
			Inertia = 0;
		}
		AddPosXWithDir(Inertia);
	}

	if (IsPlayer)
	{
		int32 ModifiedPushback;
		if (PosY > GroundHeight)
			ModifiedPushback = Player->Pushback * 84;
		else if (Player->Stance == ACT_Crouching)
			ModifiedPushback = Player->Pushback * 86;
		else
			ModifiedPushback = Player->Pushback * 88;

		Player->Pushback = ModifiedPushback / 100;

		if (PosY <= GroundHeight || !(Player->PlayerFlags & PLF_IsStunned))
			AddPosXWithDir(Player->Pushback);
	}

	AddPosXWithDir(SpeedX); //apply speed

	if (IsPlayer && Player != nullptr)
	{
		if (Player->AirDashTimer == 0 || (SpeedY > 0 && ActionTime < 5))
		// only set y speed if not airdashing/airdash startup not done
		{
			PosY += SpeedY;
			if (PosY > GroundHeight || !(MiscFlags & MISC_FloorCollisionActive))
				SpeedY -= Gravity;
		}
		else
		{
			SpeedY = 0;
		}
	}
	else
	{
		PosY += SpeedY;
		if (PosY > GroundHeight || !(MiscFlags & MISC_FloorCollisionActive))
			SpeedY -= Gravity;
	}

	if (PosY < GroundHeight && MiscFlags & MISC_FloorCollisionActive) //if on ground, force y values to zero
	{
		PosY = GroundHeight;
	}

	PosZ += SpeedZ;
}

void ABattleObject::PositionLinkUpdate()
{
	if (PositionLinkObj)
	{
		PrevPosX = PositionLinkObj->PrevPosX;
		PrevPosY = PositionLinkObj->PrevPosY;
		PosX = PositionLinkObj->PosX;
		PosY = PositionLinkObj->PosY;
	}
}

void ABattleObject::CalculateHoming()
{
	if (HomingParams.Target != OBJ_Null)
	{
		ABattleObject* Target = GetBattleObject(HomingParams.Target);

		if (Target != nullptr)
		{
			int32 TargetPosX = 0;
			int32 TargetPosY = 0;

			Target->PosTypeToPosition(HomingParams.Pos, TargetPosX, TargetPosY);

			const bool TargetFacingRight = Target->Direction == DIR_Right;
			int32 HomingOffsetX = -HomingParams.OffsetX;
			if (!TargetFacingRight)
				HomingOffsetX = HomingParams.OffsetX;

			if (HomingParams.Type == HOMING_DistanceAccel)
			{
				int32 TmpPosY = TargetPosY + HomingParams.OffsetY - PosY;
				int32 TmpPosX = TargetPosX + HomingOffsetX - PosX;
				if (Direction == DIR_Left) TmpPosX *= -1;
				SpeedXRatePerFrame = HomingParams.ParamB;
				SpeedYRatePerFrame = HomingParams.ParamB;
				SpeedX += HomingParams.ParamA * TmpPosX / 100;
				SpeedY += HomingParams.ParamA * TmpPosY / 100;
			}
			else if (HomingParams.Type == HOMING_FixAccel)
			{
				int32 TmpPosY = TargetPosY + HomingParams.OffsetY - PosY;
				int32 TmpPosX = TargetPosX + HomingOffsetX - PosX;
				if (Direction == DIR_Left) TmpPosX *= -1;
				int32 Angle = UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(TmpPosX, TmpPosY) / 100;
				SpeedXRate = HomingParams.ParamB;
				SpeedYRate = HomingParams.ParamB;
				int32 CosParamA = HomingParams.ParamA * UNightSkyBlueprintFunctionLibrary::Cos_x1000(Angle) / 1000;
				int32 SinParamA = HomingParams.ParamA * UNightSkyBlueprintFunctionLibrary::Sin_x1000(Angle) / 1000;
				SpeedX += CosParamA;
				SpeedY += SinParamA;
			}
			else if (HomingParams.Type == HOMING_ToSpeed)
			{
				int32 TmpPosY = TargetPosY + HomingParams.OffsetY - PosY;
				int32 TmpPosX = TargetPosX + HomingOffsetX - PosX;
				if (Direction == DIR_Left) TmpPosX *= -1;
				int32 Angle = UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(TmpPosX, TmpPosY) / 100;
				int32 CosParamA = HomingParams.ParamA * UNightSkyBlueprintFunctionLibrary::Cos_x1000(Angle) / 1000;
				int32 SinParamA = HomingParams.ParamA * UNightSkyBlueprintFunctionLibrary::Sin_x1000(Angle) / 1000;
				int32 TmpParamB = HomingParams.ParamB;
				int32 TmpSpeedX = SpeedX;
				if (TmpParamB <= 0)
				{
					if (TmpParamB >= 0)
					{
						CosParamA = TmpSpeedX;
					}
					else if (TmpSpeedX < CosParamA && -TmpSpeedX > CosParamA)
					{
						CosParamA = TmpParamB + TmpSpeedX;
					}
					while (TmpSpeedX - CosParamA <= TmpParamB || -TmpSpeedX + CosParamA >= TmpParamB)
					{
						SpeedX = -CosParamA;
						if (HomingParams.ParamB <= 0)
						{
							if (HomingParams.ParamB >= 0)
							{
								return;
							}
							if (SpeedY < SinParamA)
							{
								SinParamA = SpeedY + HomingParams.ParamB;
							}
							SpeedY = SinParamA;
							return;
						}
						if (SpeedY < SinParamA)
						{
							if (SinParamA - SpeedY > HomingParams.ParamB)
							{
								SinParamA = SpeedY + HomingParams.ParamB;
							}
						}
						if (SpeedY - SinParamA <= HomingParams.ParamB)
						{
							SpeedY = SinParamA;
							return;
						}
						SinParamA = SpeedY - HomingParams.ParamB;
						SpeedY = SinParamA;
						return;
					}
				}
				else
				{
					if (TmpSpeedX < CosParamA)
					{
						if (CosParamA - TmpSpeedX > TmpParamB)
						{
							CosParamA = TmpParamB + TmpSpeedX;
						}
						while (TmpSpeedX - CosParamA <= TmpParamB || -TmpSpeedX + CosParamA >= TmpParamB)
						{
							SpeedX = CosParamA;
							if (HomingParams.ParamB <= 0)
							{
								if (HomingParams.ParamB >= 0)
								{
									SinParamA = SpeedY;
								}
								if (SpeedY < SinParamA)
								{
									SinParamA = SpeedY + HomingParams.ParamB;
								}
								SpeedY = SinParamA;
								return;
							}
							if (SpeedY < SinParamA)
							{
								if (SinParamA - SpeedY > HomingParams.ParamB)
								{
									SinParamA = SpeedY + HomingParams.ParamB;
								}
							}
							if (SpeedY - SinParamA <= HomingParams.ParamB)
							{
								SpeedY = SinParamA;
								return;
							}
							SinParamA = SpeedY - HomingParams.ParamB;
							SpeedY = SinParamA;
							return;
						}
					}
					if (TmpSpeedX - CosParamA <= TmpParamB)
					{
						while (TmpSpeedX - CosParamA <= TmpParamB || -TmpSpeedX + CosParamA >= TmpParamB)
						{
							SpeedX = CosParamA;
							if (HomingParams.ParamB <= 0)
							{
								if (HomingParams.ParamB >= 0)
								{
									SinParamA = SpeedY;
								}
								if (SpeedY < SinParamA)
								{
									SinParamA = SpeedY + HomingParams.ParamB;
								}
								SpeedY = SinParamA;
								return;
							}
							if (SpeedY < SinParamA)
							{
								if (SinParamA - SpeedY > HomingParams.ParamB)
								{
									SinParamA = SpeedY + HomingParams.ParamB;
								}
							}
							if (SpeedY - SinParamA <= HomingParams.ParamB)
							{
								SpeedY = SinParamA;
								return;
							}
							SinParamA = SpeedY - HomingParams.ParamB;
							SpeedY = SinParamA;
							return;
						}
					}
				}
				while (TmpSpeedX - CosParamA <= TmpParamB || -TmpSpeedX + CosParamA >= TmpParamB)
				{
					SpeedX = CosParamA;
					if (HomingParams.ParamB <= 0)
					{
						if (HomingParams.ParamB >= 0)
						{
							SinParamA = SpeedY;
						}
						if (SpeedY < SinParamA)
						{
							SinParamA = SpeedY + HomingParams.ParamB;
						}
						SpeedY = SinParamA;
						return;
					}
					if (SpeedY < SinParamA)
					{
						if (SinParamA - SpeedY > HomingParams.ParamB)
						{
							SinParamA = SpeedY + HomingParams.ParamB;
						}
					}
					if (SpeedY - SinParamA <= HomingParams.ParamB)
					{
						SpeedY = SinParamA;
						return;
					}
					SinParamA = SpeedY - HomingParams.ParamB;
					SpeedY = SinParamA;
					return;
				}
			}
		}
	}
}

bool ABattleObject::SuperArmorSuccess(const ABattleObject* Attacker) const
{
	if (SuperArmorData.Type == ARM_None) return false;
	if (SuperArmorData.ArmorHits == 0) return false;

	if (SuperArmorData.bArmorMid && Attacker->HitCommon.BlockType == BLK_Mid) return true;
	if (SuperArmorData.bArmorOverhead && Attacker->HitCommon.BlockType == BLK_High) return true;
	if (SuperArmorData.bArmorLow && Attacker->HitCommon.BlockType == BLK_Low) return true;
	if (SuperArmorData.bArmorStrike && Attacker->AttackFlags & ATK_HitActive && !(Attacker->AttackFlags &
		ATK_AttackProjectileAttribute))
		return true;
	if (SuperArmorData.bArmorThrow && Attacker->IsPlayer && Attacker->Player->PlayerFlags & PLF_ThrowActive)
		return
			true;
	if (SuperArmorData.bArmorHead && Attacker->AttackFlags & ATK_HitActive && Attacker->AttackFlags &
		ATK_AttackHeadAttribute)
		return true;
	if (SuperArmorData.bArmorProjectile && Attacker->AttackFlags & ATK_HitActive && Attacker->AttackFlags &
		ATK_AttackProjectileAttribute)
		return true;

	return false;
}

// Called every frame
void ABattleObject::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
	if (!GameState)
	{
		ScreenSpaceDepthOffset = 0;
		OrthoBlendActive = 1;
	}
}

void ABattleObject::CalculatePushbox()
{
	if (Direction == DIR_Right)
	{
		R = PosX + (PushWidth / 2 + PushWidthExtend);
		L = PosX - PushWidth / 2;
	}
	else
	{
		R = PosX + PushWidth / 2;
		L = PosX - (PushWidth / 2 + PushWidthExtend);
	}
	T = PosY + PushHeight;
	B = PosY - PushHeightLow;
}

void ABattleObject::HandlePushCollision(ABattleObject* OtherObj)
{
	CalculatePushbox();
	OtherObj->CalculatePushbox();
	
	if (GameState->BattleState.SuperFreezeDuration && this != GameState->BattleState.SuperFreezeCaller) return;
	if (GameState->BattleState.SuperFreezeSelfDuration && this == GameState->BattleState.SuperFreezeCaller) return;

	if (MiscFlags & MISC_PushCollisionActive && OtherObj->MiscFlags & MISC_PushCollisionActive)
	{
		if (Hitstop <= 0 && ((!OtherObj->IsPlayer || OtherObj->Player->PlayerFlags & PLF_IsThrowLock) == 0 || (!IsPlayer
			|| Player->PlayerFlags & PLF_IsThrowLock) == 0))
		{
			if (T >= OtherObj->B && B <= OtherObj->T && R >= OtherObj->L && L <= OtherObj->R)
			{
				bool IsPushLeft;
				int32 CollisionDepth;

				GameState->SetScreenBounds();

				if (PosX == OtherObj->PosX)
				{
					if (PrevPosX == OtherObj->PrevPosX)
					{
						if (IsPlayer == OtherObj->IsPlayer)
						{
							if (Player->WallTouchTimer == OtherObj->Player->WallTouchTimer)
							{
								IsPushLeft = Player->PlayerIndex > 0;
							}
							else
							{
								IsPushLeft = Player->WallTouchTimer > OtherObj->Player->WallTouchTimer;
								if (PosX > 0)
								{
									IsPushLeft = Player->WallTouchTimer <= OtherObj->Player->WallTouchTimer;
								}
							}
						}
						else
						{
							IsPushLeft = IsPlayer > OtherObj->IsPlayer;
						}
					}
					else
					{
						IsPushLeft = PrevPosX < OtherObj->PrevPosX;
					}
				}
				else
				{
					IsPushLeft = PosX < OtherObj->PosX;
				}
				if (IsPushLeft)
				{
					CollisionDepth = OtherObj->L - R;
				}
				else
				{
					CollisionDepth = OtherObj->R - L;
				}

				if (IsPlayer && Player->PlayerFlags & PLF_TouchingWall 
					|| OtherObj->IsPlayer && OtherObj->Player->PlayerFlags & PLF_TouchingWall)
				{
					OtherObj->PosX -= CollisionDepth;
					PosX += CollisionDepth;
				}
				else
				{
					OtherObj->PosX -= CollisionDepth / 2;
					PosX += CollisionDepth / 2;
				}

				CalculatePushbox();
				OtherObj->CalculatePushbox();
			}
		}
	}
}

void ABattleObject::HandleHitCollision(ABattleObject* AttackedObj)
{
	if (AttackFlags & ATK_IsAttacking && AttackFlags & ATK_HitActive && AttackedObj->ObjectsToIgnoreHitsFrom.Find(this)
		== INDEX_NONE && !AttackedObj->Player->IsInvulnerable(this))
	{
		auto AttackedPlayer = Cast<APlayerObject>(AttackedObj);
		if (!AttackedPlayer) return;
		if (CheckBoxOverlap(AttackedObj, BOX_Hit, FGameplayTag::EmptyTag, BOX_Hurt, FGameplayTag::EmptyTag))
		{
			AttackedPlayer->AttackOwner = this;
			AttackedPlayer->ObjectsToIgnoreHitsFrom.AddUnique(this);
			AttackedPlayer->FaceOpponent();
			AttackedPlayer->HaltMomentum();
			AttackedPlayer->PlayerFlags |= PLF_IsStunned;
			AttackFlags |= ATK_HasHit;
			if (AttackFlags & ATK_SetPlayerHit) Player->AttackFlags |= ATK_HasHit;
			AttackTarget = AttackedPlayer;

			TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);
			if (AttackedPlayer->IsMainPlayer())
			{
				TriggerEvent(EVT_HitOrBlockMainPlayer, StateMachine_Primary);
			}

			AttackedPlayer->CallSubroutine(Subroutine_Cmn_HitCollision);
			if (AttackedPlayer->SubroutineReturnVal1) return;

			if (AttackedPlayer->IsCorrectBlock(HitCommon.BlockType)) //check blocking
			{
				CallSubroutine(Subroutine_Cmn_OnBlock);
				
				CreateCommonParticle(Particle_Guard, POS_Enemy,
				                     FVector(0, 100, 0),
				                     FRotator(HitCommon.HitAngle, 0, 0));
				TriggerEvent(EVT_Block, StateMachine_Primary);
				if (AttackedPlayer->IsMainPlayer())
				{
					TriggerEvent(EVT_BlockMainPlayer, StateMachine_Primary);
				}

				const int32 ChipDamage = NormalHit.Damage * HitCommon.ChipDamagePercent / 100;
				AttackedPlayer->CurrentHealth -= ChipDamage;

				const FHitData Data = InitHitDataByAttackLevel(false);
				AttackedPlayer->ReceivedHitCommon = HitCommon;
				AttackedPlayer->ReceivedHit = Data;

				if (AttackedPlayer->CurrentHealth <= 0)
				{
					EHitAction HACT;

					if (AttackedPlayer->PosY == AttackedPlayer->GroundHeight && !(AttackedPlayer->
						PlayerFlags & PLF_IsKnockedDown))
						HACT = NormalHit.GroundHitAction;
					else
						HACT = NormalHit.AirHitAction;

					AttackedPlayer->HandleHitAction(HACT);
				}
				else
				{
					AttackedPlayer->HandleBlockAction();
					AttackedPlayer->AirDashTimer = 0;
					if (AttackedPlayer->PlayerFlags & PLF_TouchingWall)
					{
						Pushback = AttackedPlayer->Pushback;
						AttackedPlayer->Pushback = 0;
					}
				}
				AttackedPlayer->AddMeter(
					NormalHit.Damage * AttackedPlayer->MeterPercentOnReceiveHitGuard / 100);
				Player->AddMeter(NormalHit.Damage * Player->MeterPercentOnHitGuard / 100);
			}
			else if (AttackedPlayer->SuperArmorSuccess(this))
			{
				TriggerEvent(EVT_Hit, StateMachine_Primary);
				if (AttackedPlayer->IsMainPlayer())
				{
					TriggerEvent(EVT_HitMainPlayer, StateMachine_Primary);
				}

				if (AttackedPlayer->SuperArmorData.ArmorHits > 0)
					AttackedPlayer->SuperArmorData.
					                ArmorHits--;
				switch (AttackedPlayer->SuperArmorData.Type)
				{
				case ARM_Guard:
					{
						if (AttackedPlayer->SuperArmorData.bArmorTakeChipDamage)
						{
							const int32 ChipDamage = NormalHit.Damage * HitCommon.ChipDamagePercent /
								100;
							AttackedPlayer->CurrentHealth -= ChipDamage;
							AttackedPlayer->AddMeter(
								NormalHit.Damage * AttackedPlayer->MeterPercentOnReceiveHitGuard / 100);
							Player->AddMeter(NormalHit.Damage * Player->MeterPercentOnHitGuard / 100);
						}
						if (AttackedPlayer->SuperArmorData.ArmorDamagePercent)
						{
							const int32 ArmorDamage = NormalHit.Damage * AttackedPlayer->SuperArmorData.
								ArmorDamagePercent / 100;
							AttackedPlayer->CurrentHealth -= ArmorDamage;
							AttackedPlayer->AddMeter(
								NormalHit.Damage * AttackedPlayer->MeterPercentOnReceiveHit *
								AttackedPlayer->
								SuperArmorData.ArmorDamagePercent / 10000);
							Player->AddMeter(
								NormalHit.Damage * Player->MeterPercentOnHit * AttackedPlayer->
								                                               SuperArmorData.ArmorDamagePercent /
								10000);
						}
						else
						{
							CreateCommonParticle(Particle_Guard, POS_Enemy,
							                     FVector(0, 100, 0),
							                     FRotator(HitCommon.HitAngle, 0, 0));
						}

						const FHitData Data = InitHitDataByAttackLevel(false);
						AttackedPlayer->ReceivedHitCommon = HitCommon;
						AttackedPlayer->ReceivedHit = Data;

						if (AttackedPlayer->CurrentHealth <= 0)
						{
							EHitAction HACT;

							if (AttackedPlayer->PosY == AttackedPlayer->GroundHeight && !(AttackedPlayer
								->PlayerFlags & PLF_IsKnockedDown))
								HACT = NormalHit.GroundHitAction;
							else
								HACT = NormalHit.AirHitAction;

							AttackedPlayer->HandleHitAction(HACT);
						}
						else
						{
							Hitstop = Data.Hitstop;
							AttackedPlayer->Hitstop = Data.Hitstop;
						}
					}
					break;
				case ARM_Dodge:
				default:
					break;
				}
			}
			else if ((AttackedPlayer->AttackFlags & ATK_IsAttacking) == 0)
			{
				AttackedPlayer->PlayerFlags &= ~PLF_ReceivedCounterHit;

				CallSubroutine(Subroutine_Cmn_OnHit);
				
				TriggerEvent(EVT_Hit, StateMachine_Primary);
				AttackedPlayer->TriggerEvent(EVT_ReceiveHit, StateMachine_Primary);
				if (AttackedPlayer->IsMainPlayer())
				{
					TriggerEvent(EVT_HitMainPlayer, StateMachine_Primary);
					AttackedPlayer->TriggerEvent(EVT_ReceiveHitMainPlayer, StateMachine_Primary);
				}

				if (IsPlayer && Player->PlayerFlags & PLF_HitgrabActive)
				{
					AttackedPlayer->JumpToStatePrimary(State_Universal_ThrowLock);
					AttackedPlayer->PlayerFlags |= PLF_IsThrowLock;
					AttackedPlayer->StunTime = 0x7FFFFFFF;
					AttackedPlayer->AttackOwner = Player;
					Player->ThrowExe();
					return;
				}

				const FHitData Data = InitHitDataByAttackLevel(false);
				CreateCommonParticle(HitCommon.HitVFX, POS_Col,
				                     FVector(0, 0, 0),
				                     FRotator(HitCommon.HitAngle, 0, 0));
				PlayCommonSound(HitCommon.HitSFX);
				AttackedPlayer->ReceivedHitCommon = HitCommon;
				AttackedPlayer->ReceivedHit = Data;
				EHitAction HACT;

				if (AttackedPlayer->PosY == AttackedPlayer->GroundHeight && !(AttackedPlayer->
					PlayerFlags & PLF_IsKnockedDown))
					HACT = NormalHit.GroundHitAction;
				else
					HACT = NormalHit.AirHitAction;

				AttackedPlayer->HandleHitAction(HACT);
				Hitstop = Data.Hitstop;
			}
			else
			{
				AttackedPlayer->PlayerFlags |= PLF_ReceivedCounterHit;
				
				CallSubroutine(Subroutine_Cmn_OnHit);
				CallSubroutine(Subroutine_Cmn_OnCounterHit);
				
				TriggerEvent(EVT_Hit, StateMachine_Primary);
				TriggerEvent(EVT_CounterHit, StateMachine_Primary);
				AttackedPlayer->TriggerEvent(EVT_ReceiveHit, StateMachine_Primary);
				if (AttackedPlayer->IsMainPlayer())
				{
					TriggerEvent(EVT_HitMainPlayer, StateMachine_Primary);
					TriggerEvent(EVT_CounterHitMainPlayer, StateMachine_Primary);
					AttackedPlayer->TriggerEvent(EVT_ReceiveHitMainPlayer, StateMachine_Primary);
				}
				
				AttackedPlayer->AddColor = FLinearColor(1, 0, 0.0, 1);
				AttackedPlayer->MulColor = FLinearColor(2.5, 0.1, 0.1, 1);
				AttackedPlayer->AddFadeSpeed = 0.1;
				AttackedPlayer->MulFadeSpeed = 0.1;

				if (IsPlayer && Player->PlayerFlags & PLF_HitgrabActive)
				{
					AttackedPlayer->JumpToStatePrimary(State_Universal_ThrowLock);
					AttackedPlayer->PlayerFlags |= PLF_IsThrowLock;
					AttackedPlayer->AttackOwner = Player;
					Player->ThrowExe();
					return;
				}

				const FHitData Data = InitHitDataByAttackLevel(false);
				const FHitData CounterData = InitHitDataByAttackLevel(true);
				CreateCommonParticle(HitCommon.HitVFX, POS_Col, FVector(0, 0, 0),
				                     FRotator(HitCommon.HitAngle, 0, 0));
				PlayCommonSound(HitCommon.HitSFX);
				AttackedPlayer->ReceivedHitCommon = HitCommon;
				AttackedPlayer->ReceivedHit = CounterData;
				EHitAction HACT;

				if (AttackedPlayer->PosY == AttackedPlayer->GroundHeight && !(AttackedPlayer->
					PlayerFlags & PLF_IsKnockedDown))
					HACT = CounterHit.GroundHitAction;
				else
					HACT = CounterHit.AirHitAction;

				AttackedPlayer->HandleHitAction(HACT);
				Hitstop = Data.Hitstop;
			}
		}
	}
}

FHitData ABattleObject::InitHitDataByAttackLevel(bool IsCounter)
{
	if (HitCommon.AttackLevel < 0)
		HitCommon.AttackLevel = 0;
	if (HitCommon.AttackLevel > 5)
		HitCommon.AttackLevel = 5;

	switch (HitCommon.AttackLevel)
	{
	case 0:
	default:
		if (HitCommon.BlockstopModifier == INT_MAX)
			HitCommon.BlockstopModifier = 0;
		if (HitCommon.Blockstun == INT_MAX)
			HitCommon.Blockstun = 9;
		if (HitCommon.GroundGuardPushbackX == INT_MAX)
			HitCommon.GroundGuardPushbackX = 15000;
		if (HitCommon.AirGuardPushbackX == INT_MAX)
			HitCommon.AirGuardPushbackX = 7500;
		if (HitCommon.AirGuardPushbackY == INT_MAX)
			HitCommon.AirGuardPushbackY = 15000;
		if (HitCommon.GuardGravity == INT_MAX)
			HitCommon.GuardGravity = 1900;
		if (NormalHit.Hitstop == INT_MAX)
			NormalHit.Hitstop = 11;
		if (NormalHit.Hitstun == INT_MAX)
			NormalHit.Hitstun = 10;
		if (NormalHit.Untech == INT_MAX)
			NormalHit.Untech = 10;
		if (NormalHit.Damage == INT_MAX)
			NormalHit.Damage = 300;
		if (NormalHit.GroundPushbackX == INT_MAX)
			NormalHit.GroundPushbackX = 20000;
		if (NormalHit.AirPushbackX == INT_MAX)
			NormalHit.AirPushbackX = 10500;
		if (NormalHit.AirPushbackY == INT_MAX)
			NormalHit.AirPushbackY = 21000;
		if (NormalHit.Gravity == INT_MAX)
			NormalHit.Gravity = 1900;
		if (CounterHit.Hitstop == INT_MAX)
			CounterHit.Hitstop = NormalHit.Hitstop;
		switch (HitCommon.VFXType)
		{
		case EHitVFXType::VFX_Strike:
		case EHitVFXType::VFX_Slash:
			HitCommon.HitVFX = Particle_Hit_S;
			break;
		case EHitVFXType::VFX_Special:
			HitCommon.HitVFX = Particle_Hit_SP;
			break;
		}
		switch (HitCommon.SFXType)
		{
		case EHitSFXType::SFX_Punch:
			HitCommon.HitSFX = Sound_Hit_Punch_S;
			break;
		case EHitSFXType::SFX_Kick:
			HitCommon.HitSFX = Sound_Hit_Kick_S;
			break;
		case EHitSFXType::SFX_Slash:
			HitCommon.HitSFX = Sound_Hit_Slash_S;
			break;
		}
		break;
	case 1:
		if (HitCommon.BlockstopModifier == INT_MAX)
			HitCommon.BlockstopModifier = 0;
		if (HitCommon.Blockstun == INT_MAX)
			HitCommon.Blockstun = 11;
		if (HitCommon.GroundGuardPushbackX == INT_MAX)
			HitCommon.GroundGuardPushbackX = 17500;
		if (HitCommon.AirGuardPushbackX == INT_MAX)
			HitCommon.AirGuardPushbackX = 7500;
		if (HitCommon.AirGuardPushbackY == INT_MAX)
			HitCommon.AirGuardPushbackY = 15025;
		if (HitCommon.GuardGravity == INT_MAX)
			HitCommon.GuardGravity = 1900;
		if (NormalHit.Hitstop == INT_MAX)
			NormalHit.Hitstop = 12;
		if (NormalHit.Hitstun == INT_MAX)
			NormalHit.Hitstun = 12;
		if (NormalHit.Untech == INT_MAX)
			NormalHit.Untech = 12;
		if (NormalHit.Damage == INT_MAX)
			NormalHit.Damage = 400;
		if (NormalHit.GroundPushbackX == INT_MAX)
			NormalHit.GroundPushbackX = 22500;
		if (NormalHit.AirPushbackX == INT_MAX)
			NormalHit.AirPushbackX = 10500;
		if (NormalHit.AirPushbackY == INT_MAX)
			NormalHit.AirPushbackY = 21500;
		if (NormalHit.Gravity == INT_MAX)
			NormalHit.Gravity = 1900;
		if (CounterHit.Hitstop == INT_MAX)
			CounterHit.Hitstop = NormalHit.Hitstop + 2;
		switch (HitCommon.VFXType)
		{
		case EHitVFXType::VFX_Strike:
		case EHitVFXType::VFX_Slash:
			HitCommon.HitVFX = Particle_Hit_S;
			break;
		case EHitVFXType::VFX_Special:
			HitCommon.HitVFX = Particle_Hit_SP;
			break;
		}
		switch (HitCommon.SFXType)
		{
		case EHitSFXType::SFX_Punch:
			HitCommon.HitSFX = Sound_Hit_Punch_S;
			break;
		case EHitSFXType::SFX_Kick:
			HitCommon.HitSFX = Sound_Hit_Kick_S;
			break;
		case EHitSFXType::SFX_Slash:
			HitCommon.HitSFX = Sound_Hit_Slash_S;
			break;
		}
		break;
	case 2:
		if (HitCommon.BlockstopModifier == INT_MAX)
			HitCommon.BlockstopModifier = 0;
		if (HitCommon.Blockstun == INT_MAX)
			HitCommon.Blockstun = 13;
		if (HitCommon.GroundGuardPushbackX == INT_MAX)
			HitCommon.GroundGuardPushbackX = 20000;
		if (HitCommon.AirGuardPushbackX == INT_MAX)
			HitCommon.AirGuardPushbackX = 7500;
		if (HitCommon.AirGuardPushbackY == INT_MAX)
			HitCommon.AirGuardPushbackY = 15050;
		if (HitCommon.GuardGravity == INT_MAX)
			HitCommon.GuardGravity = 1900;
		if (NormalHit.Hitstop == INT_MAX)
			NormalHit.Hitstop = 13;
		if (NormalHit.Hitstun == INT_MAX)
			NormalHit.Hitstun = 14;
		if (NormalHit.Untech == INT_MAX)
			NormalHit.Untech = 14;
		if (NormalHit.Damage == INT_MAX)
			NormalHit.Damage = 600;
		if (NormalHit.GroundPushbackX == INT_MAX)
			NormalHit.GroundPushbackX = 25000;
		if (NormalHit.AirPushbackX == INT_MAX)
			NormalHit.AirPushbackX = 10500;
		if (NormalHit.AirPushbackY == INT_MAX)
			NormalHit.AirPushbackY = 22000;
		if (NormalHit.Gravity == INT_MAX)
			NormalHit.Gravity = 1900;
		if (CounterHit.Hitstop == INT_MAX)
			CounterHit.Hitstop = NormalHit.Hitstop + 4;
		switch (HitCommon.VFXType)
		{
		case EHitVFXType::VFX_Strike:
		case EHitVFXType::VFX_Slash:
			HitCommon.HitVFX = Particle_Hit_M;
			break;
		case EHitVFXType::VFX_Special:
			HitCommon.HitVFX = Particle_Hit_SP;
			break;
		}
		switch (HitCommon.SFXType)
		{
		case EHitSFXType::SFX_Punch:
			HitCommon.HitSFX = Sound_Hit_Punch_M;
			break;
		case EHitSFXType::SFX_Kick:
			HitCommon.HitSFX = Sound_Hit_Kick_M;
			break;
		case EHitSFXType::SFX_Slash:
			HitCommon.HitSFX = Sound_Hit_Slash_M;
			break;
		}
		break;
	case 3:
		if (HitCommon.BlockstopModifier == INT_MAX)
			HitCommon.BlockstopModifier = 0;
		if (HitCommon.Blockstun == INT_MAX)
			HitCommon.Blockstun = 16;
		if (HitCommon.GroundGuardPushbackX == INT_MAX)
			HitCommon.GroundGuardPushbackX = 22500;
		if (HitCommon.AirGuardPushbackX == INT_MAX)
			HitCommon.AirGuardPushbackX = 7500;
		if (HitCommon.AirGuardPushbackY == INT_MAX)
			HitCommon.AirGuardPushbackY = 15075;
		if (HitCommon.GuardGravity == INT_MAX)
			HitCommon.GuardGravity = 1900;
		if (NormalHit.Hitstop == INT_MAX)
			NormalHit.Hitstop = 14;
		if (NormalHit.Hitstun == INT_MAX)
			NormalHit.Hitstun = 17;
		if (NormalHit.Untech == INT_MAX)
			NormalHit.Untech = 16;
		if (NormalHit.Damage == INT_MAX)
			NormalHit.Damage = 800;
		if (NormalHit.GroundPushbackX == INT_MAX)
			NormalHit.GroundPushbackX = 27500;
		if (NormalHit.AirPushbackX == INT_MAX)
			NormalHit.AirPushbackX = 10500;
		if (NormalHit.AirPushbackY == INT_MAX)
			NormalHit.AirPushbackY = 22500;
		if (NormalHit.Gravity == INT_MAX)
			NormalHit.Gravity = 1900;
		if (CounterHit.Hitstop == INT_MAX)
			CounterHit.Hitstop = NormalHit.Hitstop + 8;
		switch (HitCommon.VFXType)
		{
		case EHitVFXType::VFX_Strike:
		case EHitVFXType::VFX_Slash:
			HitCommon.HitVFX = Particle_Hit_M;
			break;
		case EHitVFXType::VFX_Special:
			HitCommon.HitVFX = Particle_Hit_SP;
			break;
		}
		switch (HitCommon.SFXType)
		{
		case EHitSFXType::SFX_Punch:
			HitCommon.HitSFX = Sound_Hit_Punch_M;
			break;
		case EHitSFXType::SFX_Kick:
			HitCommon.HitSFX = Sound_Hit_Kick_M;
			break;
		case EHitSFXType::SFX_Slash:
			HitCommon.HitSFX = Sound_Hit_Slash_M;
			break;
		}
		break;
	case 4:
		if (HitCommon.BlockstopModifier == INT_MAX)
			HitCommon.BlockstopModifier = 0;
		if (HitCommon.Blockstun == INT_MAX)
			HitCommon.Blockstun = 18;
		if (HitCommon.GroundGuardPushbackX == INT_MAX)
			HitCommon.GroundGuardPushbackX = 25000;
		if (HitCommon.AirGuardPushbackX == INT_MAX)
			HitCommon.AirGuardPushbackX = 7500;
		if (HitCommon.AirGuardPushbackY == INT_MAX)
			HitCommon.AirGuardPushbackY = 15100;
		if (HitCommon.GuardGravity == INT_MAX)
			HitCommon.GuardGravity = 1900;
		if (NormalHit.Hitstop == INT_MAX)
			NormalHit.Hitstop = 15;
		if (NormalHit.Hitstun == INT_MAX)
			NormalHit.Hitstun = 19;
		if (NormalHit.Untech == INT_MAX)
			NormalHit.Untech = 18;
		if (NormalHit.Damage == INT_MAX)
			NormalHit.Damage = 1000;
		if (NormalHit.GroundPushbackX == INT_MAX)
			NormalHit.GroundPushbackX = 30000;
		if (NormalHit.AirPushbackX == INT_MAX)
			NormalHit.AirPushbackX = 10500;
		if (NormalHit.AirPushbackY == INT_MAX)
			NormalHit.AirPushbackY = 23000;
		if (NormalHit.Gravity == INT_MAX)
			NormalHit.Gravity = 1900;
		if (CounterHit.Hitstop == INT_MAX)
			CounterHit.Hitstop = NormalHit.Hitstop + 12;
		switch (HitCommon.VFXType)
		{
		case EHitVFXType::VFX_Strike:
		case EHitVFXType::VFX_Slash:
			HitCommon.HitVFX = Particle_Hit_L;
			break;
		case EHitVFXType::VFX_Special:
			HitCommon.HitVFX = Particle_Hit_SP;
			break;
		}
		switch (HitCommon.SFXType)
		{
		case EHitSFXType::SFX_Punch:
			HitCommon.HitSFX = Sound_Hit_Punch_L;
			break;
		case EHitSFXType::SFX_Kick:
			HitCommon.HitSFX = Sound_Hit_Kick_L;
			break;
		case EHitSFXType::SFX_Slash:
			HitCommon.HitSFX = Sound_Hit_Slash_L;
			break;
		}
		break;
	case 5:
		if (HitCommon.BlockstopModifier == INT_MAX)
			HitCommon.BlockstopModifier = 0;
		if (HitCommon.Blockstun == INT_MAX)
			HitCommon.Blockstun = 20;
		if (HitCommon.GroundGuardPushbackX == INT_MAX)
			HitCommon.GroundGuardPushbackX = 30000;
		if (HitCommon.AirGuardPushbackX == INT_MAX)
			HitCommon.AirGuardPushbackX = 7500;
		if (HitCommon.AirGuardPushbackY == INT_MAX)
			HitCommon.AirGuardPushbackY = 15125;
		if (HitCommon.GuardGravity == INT_MAX)
			HitCommon.GuardGravity = 1900;
		if (NormalHit.Hitstop == INT_MAX)
			NormalHit.Hitstop = 18;
		if (NormalHit.Hitstun == INT_MAX)
			NormalHit.Hitstun = 22;
		if (NormalHit.Untech == INT_MAX)
			NormalHit.Untech = 21;
		if (NormalHit.Damage == INT_MAX)
			NormalHit.Damage = 1250;
		if (NormalHit.GroundPushbackX == INT_MAX)
			NormalHit.GroundPushbackX = 40000;
		if (NormalHit.AirPushbackX == INT_MAX)
			NormalHit.AirPushbackX = 10500;
		if (NormalHit.AirPushbackY == INT_MAX)
			NormalHit.AirPushbackY = 23500;
		if (NormalHit.Gravity == INT_MAX)
			NormalHit.Gravity = 1900;
		if (CounterHit.Hitstop == INT_MAX)
			CounterHit.Hitstop = NormalHit.Hitstop + 16;
		switch (HitCommon.VFXType)
		{
		case EHitVFXType::VFX_Strike:
		case EHitVFXType::VFX_Slash:
			HitCommon.HitVFX = Particle_Hit_L;
			break;
		case EHitVFXType::VFX_Special:
			HitCommon.HitVFX = Particle_Hit_SP;
			break;
		}
		switch (HitCommon.SFXType)
		{
		case EHitSFXType::SFX_Punch:
			HitCommon.HitSFX = Sound_Hit_Punch_L;
			break;
		case EHitSFXType::SFX_Kick:
			HitCommon.HitSFX = Sound_Hit_Kick_L;
			break;
		case EHitSFXType::SFX_Slash:
			HitCommon.HitSFX = Sound_Hit_Slash_L;
			break;
		}
		break;
	}

	if (NormalHit.EnemyHitstopModifier == INT_MAX)
		NormalHit.EnemyHitstopModifier = 0;
	if (NormalHit.RecoverableDamagePercent == INT_MAX)
		NormalHit.RecoverableDamagePercent = 40;
	if (NormalHit.MinimumDamagePercent == INT_MAX)
		NormalHit.MinimumDamagePercent = 0;
	if (NormalHit.InitialProration == INT_MAX)
		NormalHit.InitialProration = 100;
	if (NormalHit.ForcedProration == INT_MAX)
		NormalHit.ForcedProration = 90;

	if (CounterHit.EnemyHitstopModifier == INT_MAX)
		CounterHit.EnemyHitstopModifier = NormalHit.EnemyHitstopModifier;
	if (CounterHit.MinimumDamagePercent == INT_MAX)
		CounterHit.MinimumDamagePercent = NormalHit.MinimumDamagePercent;
	if (CounterHit.InitialProration == INT_MAX)
		CounterHit.InitialProration = NormalHit.InitialProration;
	if (CounterHit.ForcedProration == INT_MAX)
		CounterHit.ForcedProration = NormalHit.ForcedProration;

	if (CounterHit.Hitstun == INT_MAX)
		CounterHit.Hitstun = NormalHit.Hitstun;
	if (CounterHit.Untech == INT_MAX)
		CounterHit.Untech = NormalHit.Untech * 2;
	if (CounterHit.Damage == INT_MAX)
		CounterHit.Damage = NormalHit.Damage * 110 / 100;
	if (CounterHit.GroundPushbackX == INT_MAX)
		CounterHit.GroundPushbackX = NormalHit.GroundPushbackX;
	if (CounterHit.AirPushbackX == INT_MAX)
		CounterHit.AirPushbackX = NormalHit.AirPushbackX;
	if (CounterHit.AirPushbackY == INT_MAX)
		CounterHit.AirPushbackY = NormalHit.AirPushbackY;
	if (CounterHit.Gravity == INT_MAX)
		CounterHit.Gravity = NormalHit.Gravity;
	if (CounterHit.AirPushbackXOverTime.Value == INT_MAX)
		CounterHit.AirPushbackXOverTime.Value = NormalHit.AirPushbackXOverTime.Value;
	if (CounterHit.AirPushbackXOverTime.BeginFrame == INT_MAX)
		CounterHit.AirPushbackXOverTime.BeginFrame = NormalHit.AirPushbackXOverTime.BeginFrame;
	if (CounterHit.AirPushbackXOverTime.EndFrame == INT_MAX)
		CounterHit.AirPushbackXOverTime.EndFrame = NormalHit.AirPushbackXOverTime.EndFrame;
	if (CounterHit.AirPushbackYOverTime.Value == INT_MAX)
		CounterHit.AirPushbackYOverTime.Value = NormalHit.AirPushbackYOverTime.Value;
	if (CounterHit.AirPushbackYOverTime.BeginFrame == INT_MAX)
		CounterHit.AirPushbackYOverTime.BeginFrame = NormalHit.AirPushbackYOverTime.BeginFrame;
	if (CounterHit.AirPushbackYOverTime.EndFrame == INT_MAX)
		CounterHit.AirPushbackYOverTime.EndFrame = NormalHit.AirPushbackYOverTime.EndFrame;
	if (CounterHit.GravityOverTime.Value == INT_MAX)
		CounterHit.GravityOverTime.Value = NormalHit.GravityOverTime.Value;
	if (CounterHit.GravityOverTime.BeginFrame == INT_MAX)
		CounterHit.GravityOverTime.BeginFrame = NormalHit.GravityOverTime.BeginFrame;
	if (CounterHit.GravityOverTime.EndFrame == INT_MAX)
		CounterHit.GravityOverTime.EndFrame = NormalHit.GravityOverTime.EndFrame;
	if (CounterHit.BlowbackLevel == INT_MAX)
		CounterHit.BlowbackLevel = NormalHit.BlowbackLevel;
	if (CounterHit.FloatingCrumpleType == FLT_None)
		CounterHit.FloatingCrumpleType = NormalHit.FloatingCrumpleType;

	if (CounterHit.Position.Type == HPT_Non)
		CounterHit.Position.Type = NormalHit.Position.Type;
	if (CounterHit.Position.PosX == INT_MAX)
		CounterHit.Position.PosX = NormalHit.Position.PosX;
	if (CounterHit.Position.PosY == INT_MAX)
		CounterHit.Position.PosY = NormalHit.Position.PosY;

	if (CounterHit.GroundHitAction == HACT_GroundNormal)
		CounterHit.GroundHitAction = NormalHit.GroundHitAction;
	if (CounterHit.AirHitAction == HACT_AirNormal)
		CounterHit.AirHitAction = NormalHit.AirHitAction;
	if (CounterHit.CustomHitAction == FGameplayTag::EmptyTag)
		CounterHit.CustomHitAction = NormalHit.CustomHitAction;

	if (NormalHit.KnockdownTime == INT_MAX)
		NormalHit.KnockdownTime = 12;
	if (CounterHit.KnockdownTime == INT_MAX)
		CounterHit.KnockdownTime = NormalHit.KnockdownTime;

	if (NormalHit.HardKnockdown == INT_MAX)
		NormalHit.HardKnockdown = 0;
	if (CounterHit.HardKnockdown == INT_MAX)
		CounterHit.HardKnockdown = NormalHit.HardKnockdown;

	if (NormalHit.WallBounce.WallBounceStop == INT_MAX)
		NormalHit.WallBounce.WallBounceStop = 6;
	if (NormalHit.WallBounce.WallBounceXSpeed == INT_MAX)
		NormalHit.WallBounce.WallBounceXSpeed = NormalHit.AirPushbackX;
	if (NormalHit.WallBounce.WallBounceXRate == INT_MAX)
		NormalHit.WallBounce.WallBounceXRate = 33;
	if (NormalHit.WallBounce.WallBounceYSpeed == INT_MAX)
		NormalHit.WallBounce.WallBounceYSpeed = NormalHit.AirPushbackY;
	if (NormalHit.WallBounce.WallBounceYRate == INT_MAX)
		NormalHit.WallBounce.WallBounceYRate = 100;
	if (NormalHit.WallBounce.WallBounceGravity == INT_MAX)
		NormalHit.WallBounce.WallBounceGravity = NormalHit.Gravity;

	if (CounterHit.WallBounce.WallBounceStop == INT_MAX)
		CounterHit.WallBounce.WallBounceStop = NormalHit.WallBounce.WallBounceStop;
	if (CounterHit.WallBounce.WallBounceCount == -1)
		CounterHit.WallBounce.WallBounceCount = NormalHit.WallBounce.WallBounceCount;
	if (CounterHit.WallBounce.WallBounceXSpeed == INT_MAX)
		CounterHit.WallBounce.WallBounceXSpeed = NormalHit.WallBounce.WallBounceXSpeed;
	if (CounterHit.WallBounce.WallBounceXRate == INT_MAX)
		CounterHit.WallBounce.WallBounceXRate = NormalHit.WallBounce.WallBounceXRate;
	if (CounterHit.WallBounce.WallBounceYSpeed == INT_MAX)
		CounterHit.WallBounce.WallBounceYSpeed = NormalHit.WallBounce.WallBounceYSpeed;
	if (CounterHit.WallBounce.WallBounceYRate == INT_MAX)
		CounterHit.WallBounce.WallBounceYRate = NormalHit.WallBounce.WallBounceYRate;
	if (CounterHit.WallBounce.WallBounceGravity == INT_MAX)
		CounterHit.WallBounce.WallBounceGravity = NormalHit.WallBounce.WallBounceGravity;

	if (NormalHit.GroundBounce.GroundBounceStop == INT_MAX)
		NormalHit.GroundBounce.GroundBounceStop = 6;
	if (NormalHit.GroundBounce.GroundBounceXSpeed == INT_MAX)
		NormalHit.GroundBounce.GroundBounceXSpeed = NormalHit.AirPushbackX;
	if (NormalHit.GroundBounce.GroundBounceXRate == INT_MAX)
		NormalHit.GroundBounce.GroundBounceXRate = 100;
	if (NormalHit.GroundBounce.GroundBounceYSpeed == INT_MAX)
		NormalHit.GroundBounce.GroundBounceYSpeed = FMath::Abs(NormalHit.AirPushbackY);
	if (NormalHit.GroundBounce.GroundBounceYRate == INT_MAX)
		NormalHit.GroundBounce.GroundBounceYRate = 100;
	if (NormalHit.GroundBounce.GroundBounceGravity == INT_MAX)
		NormalHit.GroundBounce.GroundBounceGravity = NormalHit.Gravity;

	if (CounterHit.GroundBounce.GroundBounceStop == INT_MAX)
		CounterHit.GroundBounce.GroundBounceStop = NormalHit.GroundBounce.GroundBounceStop;
	if (CounterHit.GroundBounce.GroundBounceCount == -1)
		CounterHit.GroundBounce.GroundBounceCount = NormalHit.GroundBounce.GroundBounceCount;
	if (CounterHit.GroundBounce.GroundBounceXSpeed == INT_MAX)
		CounterHit.GroundBounce.GroundBounceXSpeed = NormalHit.GroundBounce.GroundBounceXSpeed;
	if (CounterHit.GroundBounce.GroundBounceXRate == INT_MAX)
		CounterHit.GroundBounce.GroundBounceXRate = NormalHit.GroundBounce.GroundBounceXRate;
	if (CounterHit.GroundBounce.GroundBounceYSpeed == INT_MAX)
		CounterHit.GroundBounce.GroundBounceYSpeed = NormalHit.GroundBounce.GroundBounceYSpeed;
	if (CounterHit.GroundBounce.GroundBounceYRate == INT_MAX)
		CounterHit.GroundBounce.GroundBounceYRate = NormalHit.GroundBounce.GroundBounceYRate;
	if (CounterHit.GroundBounce.GroundBounceGravity == INT_MAX)
		CounterHit.GroundBounce.GroundBounceGravity = NormalHit.GroundBounce.GroundBounceGravity;

	FHitData Data;
	if (!IsCounter)
		Data = NormalHit;
	else
		Data = CounterHit;

	return Data;
}

void ABattleObject::HandleClashCollision(ABattleObject* OtherObj)
{
	if (AttackFlags & ATK_IsAttacking && AttackFlags & ATK_HitActive && OtherObj->Player->PlayerIndex != Player->
		PlayerIndex
		&& OtherObj->AttackFlags & ATK_IsAttacking && OtherObj->AttackFlags & ATK_HitActive)
	{
		if (CheckBoxOverlap(OtherObj, BOX_Hit, FGameplayTag::EmptyTag, BOX_Hit, FGameplayTag::EmptyTag))
		{
			if (IsPlayer && OtherObj->IsPlayer)
			{
				Hitstop = 16;
				OtherObj->Hitstop = 16;
				AttackFlags &= ~ATK_HitActive;
				OtherObj->AttackFlags &= ~ATK_HitActive;
				Player->EnableAttacks();
				Player->EnableCancelIntoSelf(true);
				Player->EnableState(ENB_ForwardDash, StateMachine_Primary);
				OtherObj->Player->EnableAttacks();
				OtherObj->Player->EnableCancelIntoSelf(true);
				OtherObj->Player->EnableState(ENB_ForwardDash, StateMachine_Primary);
				TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);
				OtherObj->TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);
				CreateCommonParticle(Particle_Hit_Clash, POS_Col, FVector(0, 0, 0));
				PlayCommonSound(Sound_Hit_Clash);
			}
			else if (!IsPlayer && !OtherObj->IsPlayer)
			{
				OtherObj->Hitstop = 16;
				Hitstop = 16;
				AttackFlags &= ~ATK_HitActive;
				OtherObj->AttackFlags &= ~ATK_HitActive;
				TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);
				OtherObj->TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);
				CreateCommonParticle(Particle_Hit_Clash, POS_Col, FVector(0, 0, 0));
				PlayCommonSound(Sound_Hit_Clash);
			}
		}
	}
}

void ABattleObject::HandleFlip()
{
	if (!Player->Enemy) return;

	GameState->SetScreenBounds();

	FaceOpponent();
}

void ABattleObject::PosTypeToPosition(EPosType Type, int32& OutPosX, int32& OutPosY) const
{
	switch (Type)
	{
	case POS_Self:
		OutPosX = PosX;
		OutPosY = PosY;
		break;
	case POS_Player:
		OutPosX = Player->PosX;
		OutPosY = Player->PosY;
		break;
	case POS_Center:
		OutPosX = PosX;
		if (!IsPlayer)
		{
			OutPosY = PosY;
			break;
		}
		{
			int32 CenterPosY = PosY;
			switch (Player->Stance)
			{
			case ACT_Standing:
			case ACT_Jumping:
			default:
				CenterPosY += 200000;
				break;
			case ACT_Crouching:
				CenterPosY += 90000;
				break;
			}
			OutPosY = CenterPosY;
		}
		break;
	case POS_Ground:
		OutPosX = PosX;
		OutPosY = GroundHeight;
		break;
	case POS_Enemy:
		OutPosX = Player->Enemy->PosX;
		OutPosY = Player->Enemy->PosY;
		break;
	case POS_Col:
		OutPosX = ColPosX;
		OutPosY = ColPosY;
		break;
	default:
		break;
	}
}

void ABattleObject::ScreenPosToWorldPos(const int32 X, const int32 Y, int32& OutX, int32& OutY) const
{
	if (!GameState) return;
	
	GameState->ScreenPosToWorldPos(X, Y, OutX, OutY);
}

void ABattleObject::TriggerEvent(EEventType EventType, FGameplayTag StateMachineName)
{
	if (EventType == EVT_Update) UpdateTime++;
	if (const auto SubroutineName = EventHandlers[EventType].SubroutineName; SubroutineName != FGameplayTag::EmptyTag)
	{
		USubroutine* Subroutine = nullptr;

		if (const auto CommonIndex = Player->CommonSubroutineNames.Find(SubroutineName); CommonIndex != INDEX_NONE)
			Subroutine = Player->CommonSubroutines[CommonIndex];

		else if (const auto Index = Player->SubroutineNames.Find(SubroutineName); Index != INDEX_NONE)
			Subroutine = Player->Subroutines[Index];

		if (!Subroutine) return;

		UFunction* const Func = Subroutine->FindFunction(EventHandlers[EventType].FunctionName);
		if (IsValid(Func) && Func->ParmsSize == 0)
		{
			Subroutine->Parent = this;
			Subroutine->ProcessEvent(Func, nullptr);
		}
		return;
	}

	UState* State = ObjectState;
	if (IsPlayer)
		State = Player->GetStateMachine(StateMachineName).CurrentState;
	if (!IsValid(State))
		return;
	UFunction* const Func = State->FindFunction(EventHandlers[EventType].FunctionName);
	if (IsValid(Func) && Func->ParmsSize == 0)
	{
		State->ProcessEvent(Func, nullptr);
	}
}

void ABattleObject::UpdateCel()
{
	if (TimeUntilNextCel > 0)
		TimeUntilNextCel--;
	if (TimeUntilNextCel == 0)
		CelIndex++;
}

//for collision viewer

template <typename T>
constexpr auto min(T a, T b)
{
	return a < b ? a : b;
}

template <typename T>
constexpr auto max(T a, T b)
{
	return a > b ? a : b;
}

static void clip_line_y(
	const FVector2D& line_a, const FVector2D& line_b,
	float min_x, float max_x,
	float* min_y, float* max_y)
{
	const auto delta = line_b - line_a;

	if (abs(delta.X) > FLT_EPSILON)
	{
		const auto slope = delta.Y / delta.X;
		const auto intercept = line_a.Y - slope * line_a.X;
		*min_y = slope * min_x + intercept;
		*max_y = slope * max_x + intercept;
	}
	else
	{
		*min_y = line_a.Y;
		*max_y = line_b.Y;
	}

	if (*min_y > *max_y)
		std::swap(*min_y, *max_y);
}

bool line_box_intersection(
	const FVector2D& box_min, const FVector2D& box_max,
	const FVector2D& line_a, const FVector2D& line_b,
	float* entry_fraction, float* exit_fraction)
{
	// No intersection if line runs along the edge of the box
	if (line_a.X == line_b.X && (line_a.X == box_min.X || line_a.X == box_max.X))
		return false;

	if (line_a.Y == line_b.Y && (line_a.Y == box_min.Y || line_a.Y == box_max.Y))
		return false;

	// Clip X values to segment within box_min.X and box_max.X
	const auto min_x = max(min(line_a.X, line_b.X), box_min.X);
	const auto max_x = min(max(line_a.X, line_b.X), box_max.X);

	// Check if the line is in the bounds of the box on the X axis
	if (min_x > max_x)
		return false;

	// Clip Y values to segment within min_x and max_x
	float min_y, max_y;
	clip_line_y(line_a, line_b, min_x, max_x, &min_y, &max_y);

	// Clip Y values to segment within box_min.Y and box_max.Y
	min_y = max(min_y, (float)box_min.Y);
	max_y = min(max_y, (float)box_max.Y);

	// Check if the clipped line is in the bounds of the box on the Y axis
	if (min_y > max_y)
		return false;

	const FVector2D entry(
		line_a.X < line_b.X ? min_x : max_x,
		line_a.Y < line_b.Y ? min_y : max_y);

	const FVector2D exit(
		line_a.X > line_b.X ? min_x : max_x,
		line_a.Y > line_b.Y ? min_y : max_y);

	const auto length = (line_b - line_a).Size();
	*entry_fraction = (entry - line_a).Size() / length;
	*exit_fraction = (exit - line_a).Size() / length;

	return true;
}

void ABattleObject::CollisionView()
{
	TArray<TArray<FVector2D>> Corners;
	TArray<TArray<TArray<FVector2D>>> Lines;
	for (auto Box : Boxes)
	{
		TArray<FVector2D> CurrentCorners;
		if (Direction == DIR_Right)
		{
			CurrentCorners.Add(FVector2D(float(Box.PosX) / COORD_SCALE - float(Box.SizeX) / COORD_SCALE / 2,
			                             float(Box.PosY) / COORD_SCALE - float(Box.SizeY) / COORD_SCALE / 2).
				GetRotated((float)AnglePitch_x1000 / 1000));
			CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);
			CurrentCorners.Add(FVector2D(float(Box.PosX) / COORD_SCALE + float(Box.SizeX) / COORD_SCALE / 2,
			                             float(Box.PosY) / COORD_SCALE - float(Box.SizeY) / COORD_SCALE / 2).
				GetRotated((float)AnglePitch_x1000 / 1000));
			CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);
			CurrentCorners.Add(FVector2D(float(Box.PosX) / COORD_SCALE + float(Box.SizeX) / COORD_SCALE / 2,
			                             float(Box.PosY) / COORD_SCALE + float(Box.SizeY) / COORD_SCALE / 2).
				GetRotated((float)AnglePitch_x1000 / 1000));
			CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);
			CurrentCorners.Add(FVector2D(float(Box.PosX) / COORD_SCALE - float(Box.SizeX) / COORD_SCALE / 2,
			                             float(Box.PosY) / COORD_SCALE + float(Box.SizeY) / COORD_SCALE / 2).
				GetRotated((float)AnglePitch_x1000 / 1000));
			CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);
		}
		else
		{
			CurrentCorners.Add(FVector2D(float(-Box.PosX) / COORD_SCALE - float(Box.SizeX) / COORD_SCALE / 2,
			                             float(Box.PosY) / COORD_SCALE - float(Box.SizeY) / COORD_SCALE / 2).
				GetRotated(180 - (float)AnglePitch_x1000 / 1000 + 180));
			CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);
			CurrentCorners.Add(FVector2D(float(-Box.PosX) / COORD_SCALE + float(Box.SizeX) / COORD_SCALE / 2,
			                             float(Box.PosY) / COORD_SCALE - float(Box.SizeY) / COORD_SCALE / 2).
				GetRotated(180 - (float)AnglePitch_x1000 / 1000 + 180));
			CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);
			CurrentCorners.Add(FVector2D(float(-Box.PosX) / COORD_SCALE + float(Box.SizeX) / COORD_SCALE / 2,
			                             float(Box.PosY) / COORD_SCALE + float(Box.SizeY) / COORD_SCALE / 2).
				GetRotated(180 - (float)AnglePitch_x1000 / 1000 + 180));
			CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);
			CurrentCorners.Add(FVector2D(float(-Box.PosX) / COORD_SCALE - float(Box.SizeX) / COORD_SCALE / 2,
			                             float(Box.PosY) / COORD_SCALE + float(Box.SizeY) / COORD_SCALE / 2).
				GetRotated(180 - (float)AnglePitch_x1000 / 1000 + 180));
			CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);
		}
		Corners.Add(CurrentCorners);
		TArray<TArray<FVector2D>> CurrentLines;
		for (int j = 0; j < 4; j++)
		{
			CurrentLines.Add(TArray{CurrentCorners[j], CurrentCorners[(j + 1) % 4]});
		}
		Lines.Add(CurrentLines);
		FLinearColor color;
		if (Box.Type == BOX_Hit)
			color = FLinearColor(1.f, 0.f, 0.f, .25f);
		else if (AttackFlags & ATK_IsAttacking)
			color = FLinearColor(0.f, 1.f, 1.f, .25f);
		else
			color = FLinearColor(0.f, 1.f, 0.f, .25f);
		for (const auto& LineSet : Lines.Last())
		{
			auto start = LineSet[0];
			auto end = LineSet[1];
			DrawDebugLine(GetWorld(), FVector(start.X, 0, start.Y), FVector(end.X, 0, end.Y), color.ToFColor(false),
			              false, 1 / 60, 255, 2.f);
		}
	}
	TArray<FVector2D> CurrentCorners;
	CurrentCorners.Add(FVector2D(L / COORD_SCALE, B / COORD_SCALE));
	CurrentCorners.Add(FVector2D(R / COORD_SCALE, B / COORD_SCALE));
	CurrentCorners.Add(FVector2D(R / COORD_SCALE, T / COORD_SCALE));
	CurrentCorners.Add(FVector2D(L / COORD_SCALE, T / COORD_SCALE));
	TArray<TArray<FVector2D>> CurrentLines;
	for (int j = 0; j < 4; j++)
	{
		CurrentLines.Add(TArray{CurrentCorners[j], CurrentCorners[(j + 1) % 4]});
	}
	FLinearColor color = FLinearColor(1.f, 1.f, 0.f, .2f);

	for (const auto& LineSet : CurrentLines)
	{
		auto start = LineSet[0];
		auto end = LineSet[1];
		DrawDebugLine(GetWorld(), FVector(start.X, 0, start.Y), FVector(end.X, 0, end.Y), color.ToFColor(false), false,
		              1 / 60, 255, 2.f);
	}
}

void ABattleObject::SaveForRollback(unsigned char* Buffer) const
{
	FMemory::Memcpy(Buffer, &ObjSync, SizeOfBattleObject);
}

void ABattleObject::LoadForRollback(const unsigned char* Buffer)
{
	FMemory::Memcpy(&ObjSync, Buffer, SizeOfBattleObject);
	if (!IsPlayer)
	{
		const int StateIndex = Player->ObjectStateNames.Find(ObjectStateName);
		if (StateIndex != INDEX_NONE)
		{
			ObjectState = Player->ObjectStates[StateIndex];
			ObjectState->Parent = this;
		}
	}
}

void FBattleObjectLog::LogForSyncTestFile(std::ofstream& file)
{
	if (file)
	{
		file << "BattleObject:\n";
		file << "\tPosX: " << PosX << std::endl;
		file << "\tPosY: " << PosY << std::endl;
		file << "\tPosZ: " << PosZ << std::endl;
		file << "\tPrevPosX: " << PrevPosX << std::endl;
		file << "\tPrevPosY: " << PrevPosY << std::endl;
		file << "\tPrevPosZ: " << PrevPosZ << std::endl;
		file << "\tSpeedX: " << SpeedX << std::endl;
		file << "\tSpeedY: " << SpeedY << std::endl;
		file << "\tSpeedZ: " << SpeedZ << std::endl;
		file << "\tGravity: " << Gravity << std::endl;
		file << "\tInertia: " << Inertia << std::endl;
		file << "\tActionTime: " << ActionTime << std::endl;
		file << "\tPushHeight: " << PushHeight << std::endl;
		file << "\tPushHeightLow: " << PushHeightLow << std::endl;
		file << "\tPushWidth: " << PushWidth << std::endl;
		file << "\tStunTime: " << StunTime << std::endl;
		file << "\tStunTimeMax: " << StunTimeMax << std::endl;
		file << "\tHitstop: " << Hitstop << std::endl;
		file << "\tCelName: " << TCHAR_TO_ANSI(*CelName.ToString()) << std::endl;
		file << "\tAttackFlags: " << AttackFlags << std::endl;
		file << "\tDirection: " << Direction << std::endl;
		file << "\tMiscFlags: " << MiscFlags << std::endl;
		file << "\tCelIndex: " << CelIndex << std::endl;
		file << "\tTimeUntilNextCel: " << TimeUntilNextCel << std::endl;
		file << "\tAnimFrame: " << AnimFrame << std::endl;
	}
}

void ABattleObject::UpdateVisuals()
{
	if (IsValid(GameState))
	{
		if (GameState->BattleState.CurrentSequenceTime >= 0)
		{
			ScreenSpaceDepthOffset = 0;
			if (DrawPriorityLinkObj)
				ScreenSpaceDepthOffset = DrawPriorityLinkObj->ScreenSpaceDepthOffset;
			OrthoBlendActive = FMath::Lerp(OrthoBlendActive, 0, 0.2);
		}
		else
		{
			if (DrawPriorityLinkObj)
				ScreenSpaceDepthOffset = DrawPriorityLinkObj->ScreenSpaceDepthOffset;
			else
				ScreenSpaceDepthOffset = (MaxDrawPriority - DrawPriority) * 50;
			OrthoBlendActive = FMath::Lerp(OrthoBlendActive, 1, 0.2);
		}
	}
	else
	{
		ScreenSpaceDepthOffset = 0;
		OrthoBlendActive = 1;
	}

	AddColor = FMath::Lerp(AddColor, AddFadeColor, AddFadeSpeed);
	MulColor = FMath::Lerp(MulColor, MulFadeColor, MulFadeSpeed);
	Transparency = FMath::Lerp(Transparency, FadeTransparency, TransparencySpeed);
}

void ABattleObject::UpdateVisualsNoRollback()
{
	UpdateVisuals_BP();

	if (!bRender)
	{
		SetActorHiddenInGame(true);
		return;
	}
	
	if (IsPlayer)
	{
		if ((Player->PlayerFlags & PLF_IsOnScreen) == 0)
		{
			SetActorHiddenInGame(true);
			return;
		}
	}
	else
	{
		if (!IsActive)
		{
			SetActorHiddenInGame(true);
			return;
		}
	}
	SetActorHiddenInGame(false);
	if (LinkedParticle)
	{
		if (Direction == DIR_Left)
		{
			LinkedParticle->SetVariableFloat(FName("SpriteRotate"), AnglePitch_x1000 / 1000);
		}
		else
		{
			LinkedParticle->SetVariableFloat(FName("SpriteRotate"), -AnglePitch_x1000 / 1000);
		}
	}
	if (LinkedActor)
	{
		TArray<USkeletalMeshComponent*> SkeletalMeshComponents;
		GetComponents(USkeletalMeshComponent::StaticClass(), SkeletalMeshComponents);

		for (auto SkeletalMeshComponent : SkeletalMeshComponents)
		{
			if (!SkeletalMeshComponent->IsVisible()) continue;
			if (!SkeletalMeshComponent->IsVisible() || !IsValid(SkeletalMeshComponent->GetAnimInstance())) continue;
			SkeletalMeshComponent->GetAnimInstance()->UpdateAnimation(OneFrame, false); 
			SkeletalMeshComponent->TickAnimation(OneFrame, false); 
			SkeletalMeshComponent->TickPose(OneFrame, true);  
		}
	}
	
	FRotator FlipRotation = FRotator::ZeroRotator;
	if (Direction == DIR_Left)
	{
		if (Player->bMirrorWhenFlip && IsPlayer)
		{
			FlipRotation = FRotator(0, 180, 0);
			SetActorScale3D(FVector(1, 1, 1) * ObjectScale);
			if (!GameState) SetActorRotation(FlipRotation);
		}
		else
			SetActorScale3D(FVector(-1, 1, 1) * ObjectScale);
	}
	else
	{
		SetActorScale3D(FVector(1, 1, 1) * ObjectScale);
	}

	if (GameState)
	{
		if (SocketName == NAME_None) //only set visual location if not attached to socket
		{
			FRotator Rotation = FRotator(AnglePitch_x1000 / 1000, AngleYaw_x1000 / 1000, AngleRoll_x1000 / 1000);
			if (Direction == DIR_Left)
				Rotation.Pitch = 180 - Rotation.Pitch + 180;
			SetActorRotation(
				GameState->BattleSceneTransform.GetRotation() * (Rotation.Quaternion() * FlipRotation.
					Quaternion() * ObjectRotation.Quaternion()));
			FVector Location = FVector(static_cast<float>(PosX) / COORD_SCALE, static_cast<float>(PosZ) / COORD_SCALE,
									   static_cast<float>(PosY) / COORD_SCALE) + ObjectOffset;
			Location = GameState->BattleSceneTransform.GetRotation().RotateVector(Location) + GameState->
				BattleSceneTransform.GetLocation();
			SetActorLocation(Location);
		}
		else
		{
			FVector FinalSocketOffset = SocketOffset;
			if (Direction != DIR_Right)
				FinalSocketOffset.Y = -SocketOffset.Y;
			const auto Obj = GetBattleObject(SocketObj);
			TArray<USkeletalMeshComponent*> SocketSkeletalMeshComponents;
			Obj->GetComponents(USkeletalMeshComponent::StaticClass(), SocketSkeletalMeshComponents);
			for (const auto Component : SocketSkeletalMeshComponents)
			{
				if (!Component->DoesSocketExist(SocketName)) continue;
				FVector SocketLocation;
				FRotator SocketRotation;
				Component->GetSocketWorldLocationAndRotation(SocketName, SocketLocation, SocketRotation);
				SetActorLocation(FinalSocketOffset + SocketLocation);
				SetActorRotation(SocketRotation);
			}
		}
	}
	
	if (LinkedActor)
	{
		LinkedActor->SetActorScale3D(GetActorScale3D());
		LinkedActor->SetActorRotation(GetActorRotation());
		LinkedActor->SetActorLocation(GetActorLocation());
	}
	if (LinkedParticle)
	{
		LinkedParticle->SetVariableFloat(FName("ScreenSpaceDepthOffset"), ScreenSpaceDepthOffset);
		LinkedParticle->SetVariableFloat(FName("OrthoBlendActive"), OrthoBlendActive);
	}
	
	TInlineComponentArray<UPrimitiveComponent*> Components(this);
	GetComponents(Components);
	for (const auto Component : Components)
	{
		for (int64 i = 0; i < Component->GetNumMaterials(); i++)
		{
			if (const auto MIDynamic = Cast<UMaterialInstanceDynamic>(Component->GetMaterial(i)); IsValid(MIDynamic))
			{
				MIDynamic->SetScalarParameterValue(FName(TEXT("Transparency")), Transparency);
				MIDynamic->SetScalarParameterValue(FName(TEXT("ScreenSpaceDepthOffset")), ScreenSpaceDepthOffset);
				MIDynamic->SetScalarParameterValue(FName(TEXT("OrthoBlendActive")), OrthoBlendActive);
				MIDynamic->SetVectorParameterValue(FName(TEXT("AddColor")), AddColor);
				MIDynamic->SetVectorParameterValue(FName(TEXT("MulColor")), MulColor);
				MIDynamic->SetVectorParameterValue(FName(TEXT("DamageColor")), DamageColor);
				MIDynamic->SetVectorParameterValue(FName(TEXT("DamageColor2")), DamageColor2);
			}
		}
		if (const auto Mesh = Cast<USkeletalMeshComponent>(Component); IsValid(Mesh))
		{
			if (const auto MIDynamic = Cast<UMaterialInstanceDynamic>(Mesh->OverlayMaterial); IsValid(MIDynamic))
			{
				MIDynamic->SetScalarParameterValue(FName(TEXT("Transparency")), Transparency);
				MIDynamic->SetScalarParameterValue(FName(TEXT("ScreenSpaceDepthOffset")), ScreenSpaceDepthOffset);
				MIDynamic->SetScalarParameterValue(FName(TEXT("OrthoBlendActive")), OrthoBlendActive);
				MIDynamic->SetVectorParameterValue(FName(TEXT("DamageColor")), DamageColor);
				MIDynamic->SetVectorParameterValue(FName(TEXT("DamageColor2")), DamageColor2);
			}
		}
	}

	FrameBlendPosition = static_cast<float>(MaxCelTime - TimeUntilNextCel) / static_cast<float>(MaxCelTime);
	MarkComponentsRenderStateDirty();
}

void ABattleObject::FuncCall(const FName& FuncName) const
{
	UState* CurrentState = ObjectState;
	if (IsPlayer)
		CurrentState = Player->PrimaryStateMachine.CurrentState;

	UFunction* const Func = CurrentState->FindFunction(FuncName);
	if (IsValid(Func) && Func->ParmsSize == 0)
	{
		CurrentState->ProcessEvent(Func, nullptr);
	}
}

UNightSkyAnimSequenceUserData* ABattleObject::GetAnimSequenceUserData(const FName PartName) const
{
	TInlineComponentArray<UPrimitiveComponent*> Components;
	GetComponents(Components);
	for (int i = 0; i < Components.Num(); i++)
	{
		const auto Component = Components[i];
		if (Component->GetName() != PartName) continue;
		
		const auto AnimSequence = GetAnimSequenceForPart(*Component->GetName());
		if (!AnimSequence) return nullptr;

		if (!AnimSequence->FindMetaDataByClass(UNightSkyAnimMetaData::StaticClass())) return nullptr;
		return AnimSequence->GetAssetUserData<UNightSkyAnimSequenceUserData>();
	}

	return nullptr;
}

TArray<UNightSkyAnimSequenceUserData*> ABattleObject::GetAnimSequenceUserDatas() const
{
	TArray<UNightSkyAnimSequenceUserData*> UserDatas;
	
	TInlineComponentArray<UPrimitiveComponent*> Components;
	GetComponents(Components);
	for (int i = 0; i < Components.Num(); i++)
	{
		const auto Component = Components[i];
		const auto AnimSequence = GetAnimSequenceForPart(*Component->GetName());
		if (!AnimSequence) continue;

		auto UserData = AnimSequence->GetAssetUserData<UNightSkyAnimSequenceUserData>();
		if (!UserData) continue;

		UserDatas.Add(UserData);
	}

	return UserDatas;
}

void ABattleObject::GetBoxes()
{
	Boxes.Empty();
	if (Player->CommonCollisionData != nullptr)
	{
		for (int i = 0; i < Player->CommonCollisionData->CollisionFrames.Num(); i++)
		{
			if (Player->CommonCollisionData->CollisionFrames[i].CelName == CelName)
			{
				AnimStructs = Player->CommonCollisionData->CollisionFrames[i].Anim;
				AnimBlendIn = Player->CommonCollisionData->CollisionFrames[i].AnimBlendIn;
				AnimBlendOut = Player->CommonCollisionData->CollisionFrames[i].AnimBlendOut;
				AnimFrame = Player->CommonCollisionData->CollisionFrames[i].AnimFrame;
				if (BlendCelName == FGameplayTag::EmptyTag) BlendAnimFrame = AnimFrame;
				Boxes = Player->CommonCollisionData->CollisionFrames[i].Boxes;
			}
			if (Player->CommonCollisionData->CollisionFrames[i].CelName == BlendCelName)
			{
				BlendAnimFrame = Player->CommonCollisionData->CollisionFrames[i].AnimFrame;
				for (auto& Box : Player->CommonCollisionData->CollisionFrames[i].Boxes)
				{
					if (Box.Type != BOX_Offset) continue;

					NextOffsetX = Box.PosX;
					NextOffsetY = Box.PosY;
				}
			}
		}
	}
	if (Player->CollisionData != nullptr)
	{
		for (int i = 0; i < Player->CollisionData->CollisionFrames.Num(); i++)
		{
			if (Player->CollisionData->CollisionFrames[i].CelName == CelName)
			{
				AnimStructs = Player->CollisionData->CollisionFrames[i].Anim;
				AnimBlendIn = Player->CollisionData->CollisionFrames[i].AnimBlendIn;
				AnimBlendOut = Player->CollisionData->CollisionFrames[i].AnimBlendOut;
				AnimFrame = Player->CollisionData->CollisionFrames[i].AnimFrame;
				if (BlendCelName == FGameplayTag::EmptyTag) BlendAnimFrame = AnimFrame;
				Boxes = Player->CollisionData->CollisionFrames[i].Boxes;
			}
			if (Player->CollisionData->CollisionFrames[i].CelName == BlendCelName)
			{
				BlendAnimFrame = Player->CollisionData->CollisionFrames[i].AnimFrame;
				for (auto& Box : Player->CollisionData->CollisionFrames[i].Boxes)
				{
					if (Box.Type != BOX_Offset) continue;

					NextOffsetX = Box.PosX;
					NextOffsetY = Box.PosY;
				}
			}
		}
	}
}

void ABattleObject::InitObject()
{
	if (IsPlayer)
		return;
	if (IsValid(LinkedParticle))
	{
		LinkedParticle->Deactivate();
	}
	ObjectState->Parent = this;
	ObjectState->Init();
	FVector Location = FVector(static_cast<float>(PosX) / COORD_SCALE, static_cast<float>(PosZ) / COORD_SCALE,
	                           static_cast<float>(PosY) / COORD_SCALE);
	Location = GameState->BattleSceneTransform.GetRotation().RotateVector(Location) + GameState->BattleSceneTransform.
		GetLocation();
	SetActorLocation(Location);
	SetActorRotation(GameState->BattleSceneTransform.GetRotation());
	if (Direction == DIR_Left)
	{
		SetActorScale3D(FVector(-1, 1, 1));
	}
	else
	{
		SetActorScale3D(FVector(1, 1, 1));
	}
}

void ABattleObject::Update()
{
	CalculatePushbox();

	if (!IsPlayer)
	{
		PositionLinkUpdate();
		
		if (StopLinkObj)
			Hitstop = StopLinkObj->Hitstop;
	}

	if (Hitstop > 0) //break if hitstop active.
	{
		Hitstop--;
		return;
	}

	if (!IsPlayer && MiscFlags & MISC_DeactivateOnNextUpdate)
	{
		ResetObject();
		return;
	}

	if (IsPlayer)
		if (Player->PlayerFlags & PLF_IsThrowLock)
			return;

	if (Timer0 > 0)
	{
		--Timer0;
		if (Timer0 == 0) TriggerEvent(EVT_Timer0, StateMachine_Primary);
	}
	if (Timer1 > 0)
	{
		--Timer1;
		if (Timer1 == 0) TriggerEvent(EVT_Timer1, StateMachine_Primary);
	}

	if (MiscFlags & MISC_FlipEnable)
		HandleFlip();

	if (PosY == GroundHeight && PrevPosY != GroundHeight)
	{
		if (!IsPlayer)
		{
			TriggerEvent(EVT_Landing, StateMachine_Primary);
			SpeedX = 0;
		}
	}

	if (!IsPlayer)
	{
		if (ActionTime == 0)
		{
			ObjectState->Init();
		}

		ObjectState->CallExec();
		TriggerEvent(EVT_Update, StateMachine_Primary);
		
		if (LinkedActor)
			LinkedActor->Update();
		
		UpdateCel();
		
		Move();
		
		GameState->SetScreenBounds();
		ActionTime++;

		if (MiscFlags & MISC_DeactivateIfBeyondBounds)
		{
			if (PosX > GameState->BattleState.ScreenData.ScreenBoundsRight * 1000 + 85000
				|| PosX < GameState->BattleState.ScreenData.ScreenBoundsLeft * 1000 - 85000)
				DeactivateObject();
		}
	}
}

void ABattleObject::ResetObject()
{
	if (IsPlayer)
		return;

	if (IsValid(LinkedParticle))
	{
		LinkedParticle->SetVisibility(false);
		LinkedParticle->Deactivate();
		LinkedParticle = nullptr;
	}
	RemoveLinkActor();
	OrthoBlendActive = 1;
	
	IsActive = false;
	PosX = 0;
	PosY = 0;
	PosZ = 0;
	PrevPosX = 0;
	PrevPosY = 0;
	PrevPosZ = 0;
	PrevOffsetX = 0;
	PrevOffsetY = 0;
	NextOffsetX = 0;
	NextOffsetY = 0;
	PrevRootMotionX = 0;
	PrevRootMotionY = 0;
	PrevRootMotionZ = 0;
	AnglePitch_x1000 = 0;
	AngleYaw_x1000 = 0;
	AngleRoll_x1000 = 0;
	SpeedX = 0;
	SpeedY = 0;
	SpeedZ = 0;
	Gravity = 0;
	Inertia = 0;
	ActionTime = 0;
	PushHeight = 0;
	PushHeightLow = 0;
	PushWidth = 0;
	PushWidthExtend = 0;
	Hitstop = 0;
	L = 0;
	R = 0;
	T = 0;
	B = 0;
	HitCommon = FHitDataCommon();
	NormalHit = FHitData();
	CounterHit = FHitData();
	ReceivedHitCommon = FHitDataCommon();
	ReceivedHit = FHitData();
	AttackFlags = ATK_AttackProjectileAttribute;
	StunTime = 0;
	StunTimeMax = 0;
	Hitstop = 0;
	MiscFlags = 0;
	Direction = DIR_Right;
	SpeedXRate = 100;
	SpeedXRatePerFrame = 100;
	SpeedYRate = 100;
	SpeedYRatePerFrame = 100;
	SpeedZRate = 100;
	SpeedZRatePerFrame = 100;
	GroundHeight = 0;
	ActionReg1 = 0;
	ActionReg2 = 0;
	ActionReg3 = 0;
	ActionReg4 = 0;
	ActionReg5 = 0;
	ActionReg6 = 0;
	ActionReg7 = 0;
	ActionReg8 = 0;
	ObjectReg1 = 0;
	ObjectReg2 = 0;
	ObjectReg3 = 0;
	ObjectReg4 = 0;
	ObjectReg5 = 0;
	ObjectReg6 = 0;
	ObjectReg7 = 0;
	ObjectReg8 = 0;
	SubroutineReg1 = 0;
	SubroutineReg2 = 0;
	SubroutineReg3 = 0;
	SubroutineReg4 = 0;
	SubroutineReturnVal1 = 0;
	SubroutineReturnVal2 = 0;
	SubroutineReturnVal3 = 0;
	SubroutineReturnVal4 = 0;
	Timer0 = 0;
	Timer1 = 0;
	DrawPriority = 0;
	HomingParams = FHomingParams();
	SuperArmorData = FSuperArmorData();
	UpdateTime = 0;
	ObjectOffset = FVector::ZeroVector;
	ObjectRotation = FRotator::ZeroRotator;
	ObjectScale = FVector::OneVector;
	CelName = FGameplayTag();
	BlendCelName = FGameplayTag();
	AnimFrame = 0;
	BlendAnimFrame = 0;
	FrameBlendPosition = 0;
	CelIndex = 0;
	TimeUntilNextCel = 0;
	MaxCelTime = 0;
	for (auto& Handler : EventHandlers)
		Handler = FEventHandler();
	ColPosX = 0;
	ColPosY = 0;
	for (auto& Box : Boxes)
	{
		Box = FCollisionBox();
	}
	ObjectStateName = FGameplayTag();
	ObjectID = 0;
	Player = nullptr;
	AttackTarget = nullptr;
	StopLinkObj = nullptr;
	PositionLinkObj = nullptr;
	MaterialLinkObj = nullptr;
	SocketName = NAME_None;
	SocketObj = OBJ_Self;
	SocketOffset = FVector::ZeroVector;
	AddColor = FLinearColor(0, 0, 0, 1);
	MulColor = FLinearColor(1, 1, 1, 1);
	AddFadeColor = FLinearColor(0, 0, 0, 1);
	MulFadeColor = FLinearColor(1, 1, 1, 1);
	AddFadeSpeed = 0;
	MulFadeSpeed = 0;
	Transparency = 1;
	FadeTransparency = 1;
	TransparencySpeed = 0;
	DamageColor = FLinearColor(1, 1, 1, 1);
	DamageColor2 = FLinearColor(1, 1, 1, 1);
	bRender = true;
	ObjectsToIgnoreHitsFrom.Empty();
	for (const auto Object : GameState->SortedObjects)
	{
		Object->ObjectsToIgnoreHitsFrom.Remove(this);
	}
}

UAnimSequenceBase* ABattleObject::GetAnimSequenceForPart(const FName Part) const
{
	for (auto [PartName, AnimSequence, Flipbook] : AnimStructs)
	{
		if (PartName == Part) return AnimSequence;
	}

	return nullptr;
}

UPaperFlipbook* ABattleObject::GetFlipbookForPart(const FName Part) const
{
	for (auto [PartName, AnimSequence, Flipbook] : AnimStructs)
	{
		if (PartName == Part) return Flipbook;
	}

	return nullptr;
}

bool ABattleObject::IsStopped() const
{
	if (!GameState) return false;
	if (!IsPlayer && IsValid(StopLinkObj) && StopLinkObj->IsStopped()) return true;
	if (GameState->BattleState.SuperFreezeDuration && this != GameState->BattleState.SuperFreezeCaller && !(MiscFlags & MISC_IgnoreSuperFreeze)) return true;
	if (GameState->BattleState.SuperFreezeSelfDuration && this == GameState->BattleState.SuperFreezeCaller && !(MiscFlags & MISC_IgnoreSuperFreeze)) return true;
	return Hitstop > 0 || (IsPlayer && Player->PlayerFlags & PLF_IsThrowLock);
}

bool ABattleObject::IsTimerPaused() const
{
	if (!GameState) return false;
	return GameState->BattleState.PauseTimer;
}

void ABattleObject::CallSubroutine(FGameplayTag Name)
{
	SubroutineReturnVal1 = 0;
	SubroutineReturnVal2 = 0;
	SubroutineReturnVal3 = 0;
	SubroutineReturnVal4 = 0;

	if (Player->CommonSubroutineNames.Find(Name) != INDEX_NONE)
	{
		Player->CommonSubroutines[Player->CommonSubroutineNames.Find(Name)]->Parent = this;
		Player->CommonSubroutines[Player->CommonSubroutineNames.Find(Name)]->Exec();
		return;
	}

	if (Player->SubroutineNames.Find(Name) != INDEX_NONE)
	{
		Player->Subroutines[Player->SubroutineNames.Find(Name)]->Parent = this;
		Player->Subroutines[Player->SubroutineNames.Find(Name)]->Exec();
	}
}

void ABattleObject::CallSubroutineWithArgs(FGameplayTag Name, int32 Arg1, int32 Arg2, int32 Arg3, int32 Arg4)
{
	SubroutineReg1 = Arg1;
	SubroutineReg2 = Arg2;
	SubroutineReg3 = Arg3;
	SubroutineReg4 = Arg4;
	CallSubroutine(Name);
}

void ABattleObject::InitEventHandler(EEventType EventType, FName FuncName, int32 Value, FGameplayTag SubroutineName)
{
	switch (EventType)
	{
	case EVT_Timer0:
		Timer0 = Value;
		break;
	case EVT_Timer1:
		Timer1 = Value;
		break;
	case EVT_Update:
		UpdateTime = 0;
	default: break;
	}
	EventHandlers[EventType].FunctionName = FuncName;
	EventHandlers[EventType].SubroutineName = SubroutineName;
}

void ABattleObject::RemoveEventHandler(EEventType EventType)
{
	EventHandlers[EventType].FunctionName = NAME_None;
	EventHandlers[EventType].SubroutineName = FGameplayTag();
	if (EventType == EVT_Update)
		UpdateTime = 0;
}

FGameplayTag ABattleObject::GetCelName() const
{
	return CelName;
}

FGameplayTag ABattleObject::GetLabelName() const
{
	return LabelName;
}

void ABattleObject::SetCelName(FGameplayTag InName)
{
	CelName = InName;
	SetBlendCelName(FGameplayTag::EmptyTag);
	BlendAnimFrame = 0;

	GetBoxes();
	
	// Get position offset from boxes
	if (!GameState) return;
	for (auto Box : Boxes)
	{
		if (Box.Type == BOX_Offset)
		{
			PosY += Box.PosY - PrevOffsetY;
			AddPosXWithDir(Box.PosX - PrevOffsetX);

			PrevOffsetX = Box.PosX;
			PrevOffsetY = Box.PosY;
		}
	}
}

void ABattleObject::SetBlendCelName(FGameplayTag InName)
{
	BlendCelName = InName;
	FrameBlendPosition = 0;

	GetBoxes();
}

void ABattleObject::GotoLabel(FGameplayTag InName)
{
	if (!GameState && !CharaSelectGameState) return;
	LabelName = InName;
	GotoLabelActive = true;

	if (!Player) ObjectState->CallExec();
	else Player->PrimaryStateMachine.Update();
}

void ABattleObject::SetTimeUntilNextCel(int32 InTime)
{
	TimeUntilNextCel = InTime;
}

void ABattleObject::SetCelDuration(int32 InTime)
{
	TimeUntilNextCel = MaxCelTime = InTime;
}

void ABattleObject::AddPosXWithDir(int InPosX)
{
	if (Direction == DIR_Right)
	{
		PosX += InPosX;
	}
	else
	{
		PosX -= InPosX;
	}
}

void ABattleObject::ApplyRootMotion()
{
	PrevRootMotionX = 0;
	PrevRootMotionY = 0;
	PrevRootMotionZ = 0;
}

void ABattleObject::SetSpeedXRaw(int InSpeedX)
{
	if (Direction == DIR_Right)
	{
		SpeedX = InSpeedX;
	}
	else
	{
		SpeedX = -InSpeedX;
	}
}

void ABattleObject::AddSpeedXRaw(int InSpeedX)
{
	if (Direction == DIR_Right)
	{
		SpeedX += InSpeedX;
	}
	else
	{
		SpeedX -= InSpeedX;
	}
}

int32 ABattleObject::GetPosYCenter() const
{
	int32 CenterPosY = PosY;
	if (IsPlayer)
	{
		switch (Player->Stance)
		{
		case ACT_Standing:
		case ACT_Jumping:
		default:
			CenterPosY += 200000;
			break;
		case ACT_Crouching:
			CenterPosY += 90000;
			break;
		}
	}
	return CenterPosY;
}

void ABattleObject::SetPitch(int32 Pitch_x1000)
{
	AnglePitch_x1000 = NormalizeAngle(Pitch_x1000);
}

void ABattleObject::SetYaw(int32 Yaw_x1000)
{
	AngleYaw_x1000 = NormalizeAngle(Yaw_x1000);
}

void ABattleObject::SetRoll(int32 Roll_x1000)
{
	AngleRoll_x1000 = NormalizeAngle(Roll_x1000);
}

int32 ABattleObject::NormalizeAngle(int32 Angle_x1000)
{
	Angle_x1000 %= 360000;
	if (Angle_x1000 < 0) Angle_x1000 += 360000;
	return Angle_x1000;
}

int32 ABattleObject::CalculateSpeedAngle() const
{
	return UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(SpeedX, SpeedY);
}

int32 ABattleObject::CalculateDistanceBetweenPoints(EDistanceType Type, EObjType Obj1, EPosType Pos1, EObjType Obj2,
                                                    EPosType Pos2)
{
	const ABattleObject* Actor1 = GetBattleObject(Obj1);
	const ABattleObject* Actor2 = GetBattleObject(Obj2);
	if (IsValid(Actor1) && IsValid(Actor2))
	{
		int32 PosX1 = 0;
		int32 PosX2 = 0;
		int32 PosY1 = 0;
		int32 PosY2 = 0;

		Actor1->PosTypeToPosition(Pos1, PosX1, PosY1);
		Actor2->PosTypeToPosition(Pos2, PosX2, PosY2);

		int32 ObjDist;

		switch (Type)
		{
		case DIST_Distance:
			ObjDist = isqrt(
				static_cast<int64>(PosX2 - PosX1) * static_cast<int64>(PosX2 - PosX1) + static_cast<int64>(PosY2 -
					PosY1) * static_cast<int64>(PosY2 - PosY1));
			break;
		case DIST_DistanceX:
			ObjDist = abs(PosX2 - PosX1);
			break;
		case DIST_DistanceY:
			ObjDist = abs(PosY2 - PosY1);
			break;
		case DIST_FrontDistanceX:
			{
				int DirFlag = 1;
				if (Actor1->Direction == DIR_Left)
				{
					DirFlag = -1;
				}
				ObjDist = (PosX2 - PosX1) * DirFlag;
			}
			break;
		default:
			return 0;
		}
		return ObjDist;
	}
	return 0;
}

int32 ABattleObject::CalculateAngleBetweenPoints(EObjType Obj1, EPosType Pos1, EObjType Obj2, EPosType Pos2)
{
	const ABattleObject* Actor1 = GetBattleObject(Obj1);
	const ABattleObject* Actor2 = GetBattleObject(Obj2);
	if (IsValid(Actor1) && IsValid(Actor2))
	{
		int32 PosX1 = 0;
		int32 PosX2 = 0;
		int32 PosY1 = 0;
		int32 PosY2 = 0;

		Actor1->PosTypeToPosition(Pos1, PosX1, PosY1);
		Actor2->PosTypeToPosition(Pos2, PosX2, PosY2);

		const auto X = abs(PosX2 - PosX1);
		const auto Y = PosY2 - PosY1;

		return UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(X, Y);
	}
	return 0;
}

void ABattleObject::SetFacing(EObjDir NewDir)
{
	Direction = NewDir;
}

void ABattleObject::FlipObject()
{
	if (Direction == DIR_Right)
		Direction = DIR_Left;
	else
		Direction = DIR_Right;
}

void ABattleObject::FaceOpponent()
{
	const EObjDir CurrentDir = Direction;
	if (!Player->Enemy) return;

	if (GameState) GameState->SetScreenBounds();

	if (PosX + 30000 < Player->Enemy->PosX - 30000)
	{
		SetFacing(DIR_Right);
	}
	else if (PosX - 30000 > Player->Enemy->PosX + 30000)
	{
		SetFacing(DIR_Left);
	}
	if (CurrentDir != Direction)
	{
		SpeedX = -SpeedX;
		Inertia = -Inertia;
		if (IsPlayer)
		{
			Player->StoredInputBuffer.FlipInputsInBuffer();
			if (Player->Stance == ACT_Standing && Player->GetEnableFlags(StateMachine_Primary) & ENB_Standing)
				Player->JumpToStatePrimary(State_Universal_StandFlip);
			else if (Player->Stance == ACT_Crouching && Player->GetEnableFlags(StateMachine_Primary) & ENB_Crouching)
				Player->JumpToStatePrimary(State_Universal_CrouchFlip);
			else if (Player->Stance == ACT_Jumping && Player->GetEnableFlags(StateMachine_Primary) & ENB_Jumping)
				Player->JumpToStatePrimary(State_Universal_JumpFlip);
		}
	}
}

bool ABattleObject::CheckIsGrounded() const
{
	return PosY <= GroundHeight;
}

void ABattleObject::EnableHit(bool Enabled)
{
	if (Enabled)
	{
		AttackFlags |= ATK_HitActive;

		if (GameState)
		{
			for (const auto Object : GameState->SortedObjects)
			{
				Object->ObjectsToIgnoreHitsFrom.Remove(this);
			}
		}
	}
	else
	{
		AttackFlags &= ~ATK_HitActive;
	}

	if (!IsPlayer)
	{
		SetProjectileAttribute(true);
	}
}

void ABattleObject::SetAttacking(bool Attacking)
{
	if (Attacking)
	{
		AttackFlags |= ATK_IsAttacking;
	}
	else
	{
		AttackFlags &= ~ATK_IsAttacking;
	}
	AttackFlags &= ~ATK_HasHit;
	AttackFlags &= ~ATK_HitActive;
}

void ABattleObject::SetPlayerHit(bool Enable)
{
	if (!IsPlayer)
	{
		if (Enable)
		{
			AttackFlags |= ATK_SetPlayerHit;
		}
		else
		{
			AttackFlags &= ~ATK_SetPlayerHit;
		}
	}
}

void ABattleObject::SetProjectileAttribute(bool Attribute)
{
	if (Attribute)
		AttackFlags |= ATK_AttackProjectileAttribute;
	else
		AttackFlags &= ~ATK_AttackProjectileAttribute;
}

void ABattleObject::SetProrateOnce(bool Once)
{
	if (Once)
		AttackFlags |= ATK_ProrateOnce;
	else
		AttackFlags &= ~ATK_ProrateOnce;
}

void ABattleObject::SetIgnoreOTG(bool Ignore)
{
	if (Ignore)
		AttackFlags |= ATK_IgnoreOTG;
	else
		AttackFlags &= ~ATK_IgnoreOTG;
}

void ABattleObject::SetHitOTG(bool Enable)
{
	if (Enable)
		AttackFlags |= ATK_HitOTG;
	else
		AttackFlags &= ~ATK_HitOTG;

}

void ABattleObject::SetIgnorePushbackScaling(bool Ignore)
{
	if (Ignore)
		AttackFlags |= ATK_IgnorePushbackScaling;
	else
		AttackFlags &= ~ATK_IgnorePushbackScaling;
}

void ABattleObject::SetIgnoreHitstunScaling(bool Ignore)
{
	if (Ignore)
		AttackFlags |= ATK_IgnoreHitstunScaling;
	else
		AttackFlags &= ~ATK_IgnoreHitstunScaling;
}

void ABattleObject::DeactivateObject()
{
	if (IsPlayer) // Don't use on players
		return;
	// Remove from player cache
	for (int i = 0; i < 16; i++)
	{
		if (this == Player->StoredBattleObjects[i])
		{
			Player->StoredBattleObjects[i] = nullptr;
			break;
		}
	}

	// Wait until the next frame to complete
	MiscFlags |= MISC_DeactivateOnNextUpdate;
}

bool ABattleObject::CheckBoxOverlap(ABattleObject* OtherObj, const EBoxType SelfType, const FGameplayTag SelfCustomType,
                                    const EBoxType OtherType, const FGameplayTag OtherCustomType)
{
	auto RotatePoint = [](int32 (&Point)[2], int32 Angle)
	{
		const int OrigPoint[] = {Point[0], Point[1]};
		Point[0] = (int64)OrigPoint[0] * UNightSkyBlueprintFunctionLibrary::Cos_x1000(Angle / 100) / 1000 - (int64)
			OrigPoint[1] *
			UNightSkyBlueprintFunctionLibrary::Sin_x1000(Angle / 100) / 1000;
		Point[1] = (int64)OrigPoint[0] * UNightSkyBlueprintFunctionLibrary::Sin_x1000(Angle / 100) / 1000 + (int64)
			OrigPoint[1] *
			UNightSkyBlueprintFunctionLibrary::Cos_x1000(Angle / 100) / 1000;
	};

	// Lambda to automate getting the normal vectors for a box
	auto GetNormalAxes = [](const int32 (&Vertices)[4][2], int32 (&Normals)[4][2], bool bFacingRight)
	{
		// Loop over verts
		for (int i = 0; i < std::size(Vertices); i++)
		{
			// Get vertices
			const auto P1 = Vertices[i];
			const auto P2 = Vertices[i + 1 == std::size(Vertices) ? 0 : i + 1];
			// Get edge vector
			const int32 Edge[2] = {P1[0] - P2[0], P1[1] - P2[1]};
			// Get normal vector
			int32 Normal[2] = {Edge[1], -Edge[0]};
			if (bFacingRight)
			{
				Normal[0] = -Normal[0];
				Normal[1] = -Normal[1];
			}
			// Normalize vector
			auto Length = isqrt((int64)Normal[0] * Normal[0] + (int64)Normal[1] * Normal[1]);
			if (Length == 0)
				Length = 1;
			Normal[0] = (int64)Normal[0] * COORD_SCALE / Length;
			Normal[1] = (int64)Normal[1] * COORD_SCALE / Length;
			// Assign to passed in array
			Normals[i][0] = Normal[0];
			Normals[i][1] = Normal[1];
		}
	};

	// Lambda to project a box onto an axis.
	auto ProjectBoxOntoAxis = [](const int32 (&Vertices)[4][2], const int32 (&Normal)[2],
	                             int32 (&Proj)[2])
	{
		// Calculate minimum from dot product
		int32 Min = (int64)Vertices[0][0] * Normal[0] / COORD_SCALE + (int64)Vertices[0][1] * Normal[1] / COORD_SCALE;
		int32 Max = Min;

		for (int i = 0; i < std::size(Vertices); i++)
		{
			const int32 P = (int64)Vertices[i][0] * Normal[0] / COORD_SCALE + (int64)Vertices[i][1] * Normal[1] /
				COORD_SCALE;
			if (P < Min)
				Min = P;
			else if (P > Max)
				Max = P;
		}

		Proj[0] = Min;
		Proj[1] = Max;
	};

	// Lambda to check if projections overlap.
	auto IsOverlapping = [](const int32 (&Proj1)[2], const int32 (&Proj2)[2]) -> bool
	{
		return !(Proj1[1] < Proj2[0] || Proj2[1] < Proj1[0]);
	};

	// Calculate boxes for self
	for (auto& Box : Boxes)
	{
		if (Box.Type != SelfType)
			continue;
		if (Box.Type == BOX_Custom && Box.CustomType != SelfCustomType)
			continue;

		// Calculate vertices
		int32 P1[2] = {-Box.SizeX / 2, -Box.SizeY / 2};
		int32 P2[2] = {-Box.SizeX / 2, Box.SizeY / 2};
		int32 P3[2] = {Box.SizeX / 2, -Box.SizeY / 2};
		int32 P4[2] = {Box.SizeX / 2, Box.SizeY / 2};

		// Calculate rotated points
		auto Angle = Direction == DIR_Right ? AnglePitch_x1000 : 180000 - AnglePitch_x1000 + 180000;

		// Calculate box transform
		if (Direction == DIR_Right)
		{
			P1[0] += Box.PosX;
			P2[0] += Box.PosX;
			P3[0] += Box.PosX;
			P4[0] += Box.PosX;
		}
		else
		{
			P1[0] += -Box.PosX;
			P2[0] += -Box.PosX;
			P3[0] += -Box.PosX;
			P4[0] += -Box.PosX;
		}

		P1[1] += Box.PosY;
		P2[1] += Box.PosY;
		P3[1] += Box.PosY;
		P4[1] += Box.PosY;

		RotatePoint(P1, Angle);
		RotatePoint(P2, Angle);
		RotatePoint(P3, Angle);
		RotatePoint(P4, Angle);

		// Calculate scene transform
		P1[0] += PosX;
		P2[0] += PosX;
		P3[0] += PosX;
		P4[0] += PosX;

		P1[1] += PosY;
		P2[1] += PosY;
		P3[1] += PosY;
		P4[1] += PosY;

		int32 Vertices[4][2] = {
			{P1[0], P1[1]},
			{P2[0], P2[1]},
			{P3[0], P3[1]},
			{P4[0], P4[1]},
		};
		int32 Normals[4][2];
		GetNormalAxes(Vertices, Normals, Direction == DIR_Right);
		
		// Repeat for other object
		for (auto& OtherBox : OtherObj->Boxes)
		{
			if (OtherBox.Type != OtherType)
				continue;
			if (OtherBox.Type == BOX_Custom && OtherBox.CustomType != OtherCustomType)
				continue;

			int32 OtherP1[2] = {-OtherBox.SizeX / 2, -OtherBox.SizeY / 2};
			int32 OtherP2[2] = {-OtherBox.SizeX / 2, OtherBox.SizeY / 2};
			int32 OtherP3[2] = {OtherBox.SizeX / 2, -OtherBox.SizeY / 2};
			int32 OtherP4[2] = {OtherBox.SizeX / 2, OtherBox.SizeY / 2};

			auto OtherAngle = OtherObj->Direction == DIR_Right
				                  ? OtherObj->AnglePitch_x1000
				                  : 180000 - OtherObj->AnglePitch_x1000 + 180000;
			
			if (OtherObj->Direction == DIR_Right)
			{
				OtherP1[0] += OtherBox.PosX;
				OtherP2[0] += OtherBox.PosX;
				OtherP3[0] += OtherBox.PosX;
				OtherP4[0] += OtherBox.PosX;
			}
			else
			{
				OtherP1[0] += -OtherBox.PosX;
				OtherP2[0] += -OtherBox.PosX;
				OtherP3[0] += -OtherBox.PosX;
				OtherP4[0] += -OtherBox.PosX;
			}

			OtherP1[1] += OtherBox.PosY;
			OtherP2[1] += OtherBox.PosY;
			OtherP3[1] += OtherBox.PosY;
			OtherP4[1] += OtherBox.PosY;

			RotatePoint(OtherP1, OtherAngle);
			RotatePoint(OtherP2, OtherAngle);
			RotatePoint(OtherP3, OtherAngle);
			RotatePoint(OtherP4, OtherAngle);

			OtherP1[0] += OtherObj->PosX;
			OtherP2[0] += OtherObj->PosX;
			OtherP3[0] += OtherObj->PosX;
			OtherP4[0] += OtherObj->PosX;

			OtherP1[1] += OtherObj->PosY;
			OtherP2[1] += OtherObj->PosY;
			OtherP3[1] += OtherObj->PosY;
			OtherP4[1] += OtherObj->PosY;

			int32 OtherVertices[4][2] = {
				{OtherP1[0], OtherP1[1]},
				{OtherP2[0], OtherP2[1]},
				{OtherP3[0], OtherP3[1]},
				{OtherP4[0], OtherP4[1]},
			};
			int32 OtherNormals[4][2];
			GetNormalAxes(OtherVertices, OtherNormals, Direction == DIR_Right);
			
			int32 Overlap = INT_MAX;
			int32 Smallest[2];

			// Loop over the first set of normals
			for (int i = 0; i < std::size(Normals); i++)
			{
				int32 Axis[2] = {Normals[i][0], Normals[i][1]};
				// Project both shapes onto the axis
				int32 Proj1[2];
				ProjectBoxOntoAxis(Vertices, Axis, Proj1);
				int32 Proj2[2];
				ProjectBoxOntoAxis(OtherVertices, Axis, Proj2);
				// If the projections overlap...
				if (IsOverlapping(Proj1, Proj2))
				{
					int32 O = FMath::Abs(FMath::Min(Proj1[1], Proj2[1]) - FMath::Min(Proj1[0], Proj2[0]));
					if (O < Overlap)
					{
						Overlap = O;
						Smallest[0] = Axis[0];
						Smallest[1] = Axis[1];
					}
				}
				else
				{
					// Otherwise, the shapes don't overlap.
					goto END;
				}
			}

			// Loop over the second set of normals
			for (int i = 0; i < std::size(OtherNormals); i++)
			{
				int32 Axis[2] = {OtherNormals[i][0], OtherNormals[i][1]};
				// Project both shapes onto the axis
				int32 Proj1[2];
				ProjectBoxOntoAxis(Vertices, Axis, Proj1);
				int32 Proj2[2];
				ProjectBoxOntoAxis(OtherVertices, Axis, Proj2);
				// If the projections overlap...
				if (IsOverlapping(Proj1, Proj2))
				{
					int32 O = FMath::Abs(FMath::Min(Proj1[1], Proj2[1]) - FMath::Min(Proj1[0], Proj2[0]));
					if (O < Overlap)
					{
						Overlap = O;
						Smallest[0] = Axis[0];
						Smallest[1] = Axis[1];
					}
				}
				else
				{
					// Otherwise, the shapes don't overlap.
					goto END;
				}
			}
			
			ColPosX = (FMath::Max(P1[0], OtherP1[0]) + FMath::Min(P3[0], OtherP3[0])) / 2;
			ColPosY = (FMath::Max(P1[1], OtherP1[1]) + FMath::Min(P2[1], OtherP2[1])) / 2;

			return true;

		END:
			// Collision not detected, continue to next box.
			continue;
		}
	}

	return false;
}

void ABattleObject::GetBoxPosition(const EBoxType BoxType, const FGameplayTag CustomType, int& OutPosX,
                                   int& OutPosY) const
{
	for (auto& Box : Boxes)
	{
		if (Box.Type == BoxType)
		{
			if (Box.Type == BOX_Custom && Box.CustomType != CustomType) continue;

			OutPosX = Box.PosX;
			OutPosY = Box.PosY;

			return;
		}
	}
}

int32 ABattleObject::GetGauge(int32 GaugeIndex) const
{
	if (!GameState) return 0;
	return GameState->GetGauge(Player->PlayerIndex == 0, GaugeIndex);
}

void ABattleObject::SetGauge(int32 GaugeIndex, int32 Value)
{
	if (!GameState) return;
	GameState->SetGauge(Player->PlayerIndex == 0, GaugeIndex, Value);
}

void ABattleObject::UseGauge(int32 GaugeIndex, int32 Value)
{
	if (!GameState) return;
	GameState->UseGauge(Player->PlayerIndex == 0, GaugeIndex, Value);
}

void ABattleObject::EnableFlip(bool Enabled)
{
	if (Enabled)
	{
		MiscFlags |= MISC_FlipEnable;
	}
	else
	{
		MiscFlags = MiscFlags & ~MISC_FlipEnable;
	}
}

void ABattleObject::EnableInertia()
{
	MiscFlags |= MISC_InertiaEnable;
}

void ABattleObject::DisableInertia()
{
	MiscFlags = MiscFlags & ~MISC_InertiaEnable;
}

void ABattleObject::HaltMomentum()
{
	SpeedX = 0;
	SpeedY = 0;
	SpeedZ = 0;
	SpeedXRate = 100;
	SpeedYRate = 100;
	SpeedZRate = 100;
	Gravity = 0;
	Inertia = 0;
}

void ABattleObject::SetWallCollisionActive(bool Active)
{
	if (Active)
		MiscFlags |= MISC_WallCollisionActive;
	else
		MiscFlags &= ~MISC_WallCollisionActive;
}

void ABattleObject::SetFloorCollisionActive(bool Active)
{
	if (Active)
		MiscFlags |= MISC_FloorCollisionActive;
	else
		MiscFlags &= ~MISC_FloorCollisionActive;
}

void ABattleObject::SetPushCollisionActive(bool Active)
{
	if (Active)
		MiscFlags |= MISC_PushCollisionActive;
	else
		MiscFlags &= ~MISC_PushCollisionActive;
}

void ABattleObject::SetPushWidthExtend(int32 Extend)
{
	PushWidthExtend = Extend;
}

void ABattleObject::CreateCommonParticle(FGameplayTag Name, EPosType PosType, FVector Offset, FRotator Rotation)
{
	if (!GameState) return;
	if (Player->CommonParticleData != nullptr)
	{
		for (FParticleStruct ParticleStruct : Player->CommonParticleData->ParticleStructs)
		{
			if (ParticleStruct.Name == Name && ParticleStruct.ParticleSystem)
			{
				if (Direction == DIR_Left)
				{
					Rotation.Pitch = -Rotation.Pitch;
					Offset = FVector(-Offset.X, Offset.Y, Offset.Z);
				}
				Rotation += GameState->BattleSceneTransform.GetRotation().Rotator();
				int32 TmpPosX;
				int32 TmpPosY;
				PosTypeToPosition(PosType, TmpPosX, TmpPosY);
				FVector FinalLocation = Offset + FVector(TmpPosX / COORD_SCALE, 0, TmpPosY / COORD_SCALE);
				FinalLocation = GameState->BattleSceneTransform.GetRotation().RotateVector(FinalLocation) + GameState->
					BattleSceneTransform.GetLocation();
				UNiagaraComponent* NiagaraComponent = UNiagaraFunctionLibrary::SpawnSystemAtLocation(
					this, ParticleStruct.ParticleSystem, FinalLocation, Rotation, GetActorScale());
				GameState->ParticleManager->BattleParticles.Add(FBattleParticle(NiagaraComponent, nullptr));
				NiagaraComponent->SetAgeUpdateMode(ENiagaraAgeUpdateMode::DesiredAge);
				NiagaraComponent->SetDesiredAge(0);
				NiagaraComponent->SetVariableFloat(FName("SpriteRotate"), -Rotation.Pitch);
				if (Direction == DIR_Left)
				{
					NiagaraComponent->SetVariableVec2(FName("UVScale"), FVector2D(-1, 1));
					NiagaraComponent->SetVariableVec2(FName("PivotOffset"), FVector2D(0, 0.5));
				}
				NiagaraComponent->SetVariableFloat(FName("ScreenSpaceDepthOffset"), ScreenSpaceDepthOffset);
				NiagaraComponent->SetVariableFloat(FName("OrthoBlendActive"), OrthoBlendActive);
				NiagaraComponent->SetCustomDepthStencilValue(2);
				NiagaraComponent->SetBoundsScale(40000);
				break;
			}
		}
	}
}

void ABattleObject::CreateCharaParticle(FGameplayTag Name, EPosType PosType, FVector Offset, FRotator Rotation)
{
	if (!GameState) return;
	if (Player->CharaParticleData != nullptr)
	{
		for (FParticleStruct ParticleStruct : Player->CharaParticleData->ParticleStructs)
		{
			if (ParticleStruct.Name == Name && ParticleStruct.ParticleSystem)
			{
				if (Direction == DIR_Left)
				{
					Rotation.Pitch = -Rotation.Pitch;
					Offset = FVector(-Offset.X, Offset.Y, Offset.Z);
				}
				Rotation += GameState->BattleSceneTransform.GetRotation().Rotator();
				int32 TmpPosX;
				int32 TmpPosY;
				PosTypeToPosition(PosType, TmpPosX, TmpPosY);
				FVector FinalLocation = Offset + FVector(TmpPosX / COORD_SCALE, 0, TmpPosY / COORD_SCALE);
				FinalLocation = GameState->BattleSceneTransform.GetRotation().RotateVector(FinalLocation) + GameState->
					BattleSceneTransform.GetLocation();
				UNiagaraComponent* NiagaraComponent = UNiagaraFunctionLibrary::SpawnSystemAtLocation(
					this, ParticleStruct.ParticleSystem, FinalLocation, Rotation, GetActorScale());
				GameState->ParticleManager->BattleParticles.Add(FBattleParticle(NiagaraComponent, nullptr));
				NiagaraComponent->SetAgeUpdateMode(ENiagaraAgeUpdateMode::DesiredAge);
				NiagaraComponent->SetDesiredAge(0);
				NiagaraComponent->SetVariableFloat(FName("SpriteRotate"), -Rotation.Pitch);
				if (Direction == DIR_Left)
				{
					NiagaraComponent->SetVariableVec2(FName("UVScale"), FVector2D(-1, 1));
					NiagaraComponent->SetVariableVec2(FName("PivotOffset"), FVector2D(0, 0.5));
				}
				NiagaraComponent->SetVariableFloat(FName("ScreenSpaceDepthOffset"), ScreenSpaceDepthOffset);
				NiagaraComponent->SetVariableFloat(FName("OrthoBlendActive"), OrthoBlendActive);
				NiagaraComponent->SetCustomDepthStencilValue(2);
				NiagaraComponent->SetBoundsScale(40000);
				break;
			}
		}
	}
}

void ABattleObject::LinkCommonParticle(FGameplayTag Name)
{
	if (!GameState) return;
	if (IsPlayer)
		return;
	if (Player->CommonParticleData != nullptr)
	{
		for (FParticleStruct ParticleStruct : Player->CommonParticleData->ParticleStructs)
		{
			if (ParticleStruct.Name == Name && ParticleStruct.ParticleSystem)
			{
				if (IsValid(LinkedParticle))
					LinkedParticle->Deactivate();
				LinkedParticle = UNiagaraFunctionLibrary::SpawnSystemAttached(
					ParticleStruct.ParticleSystem, RootComponent, FName(), FVector(), FRotator(),
					EAttachLocation::SnapToTargetIncludingScale, true);
				LinkedParticle->SetAgeUpdateMode(ENiagaraAgeUpdateMode::DesiredAge);
				LinkedParticle->SetDesiredAge(0);
				GameState->ParticleManager->BattleParticles.Add(FBattleParticle(LinkedParticle, this));
				if (Direction == DIR_Left)
					LinkedParticle->SetVariableVec2(FName("UVScale"), FVector2D(-1, 1));
				LinkedParticle->SetBoundsScale(40000);
				LinkedParticle->SetCustomDepthStencilValue(2);
				break;
			}
		}
	}
}

void ABattleObject::LinkCharaParticle(FGameplayTag Name)
{
	if (!GameState) return;
	if (IsPlayer)
		return;
	if (Player->CharaParticleData != nullptr)
	{
		for (FParticleStruct ParticleStruct : Player->CharaParticleData->ParticleStructs)
		{
			if (ParticleStruct.Name == Name && ParticleStruct.ParticleSystem)
			{
				if (IsValid(LinkedParticle))
					LinkedParticle->Deactivate();
				LinkedParticle = UNiagaraFunctionLibrary::SpawnSystemAttached(
					ParticleStruct.ParticleSystem, RootComponent, FName(), FVector(), FRotator(),
					EAttachLocation::SnapToTargetIncludingScale, true);
				LinkedParticle->SetAgeUpdateMode(ENiagaraAgeUpdateMode::DesiredAge);
				LinkedParticle->SetDesiredAge(0);
				GameState->ParticleManager->BattleParticles.Add(FBattleParticle(LinkedParticle, this));
				if (Direction == DIR_Left)
					LinkedParticle->SetVariableVec2(FName("UVScale"), FVector2D(-1, 1));
				LinkedParticle->SetBoundsScale(40000);
				LinkedParticle->SetCustomDepthStencilValue(2);
				break;
			}
		}
	}
}

ALinkActor* ABattleObject::LinkActor(FGameplayTag Name)
{
	if (!GameState) return nullptr;
	if (IsPlayer)
		return nullptr;

	RemoveLinkActor();
	for (auto& Container : Player->StoredLinkActors)
	{
		if (Container.Name == Name && !Container.bIsActive)
		{
			Container.bIsActive = true;
			LinkedActor = Container.StoredActor;
			LinkedActor->SetActorHiddenInGame(false);
			LinkedActor->Init();

			return LinkedActor;
		}
	}
	return nullptr;
}

void ABattleObject::RemoveLinkActor()
{
	if (!LinkedActor) return;

	for (auto& Container : Player->StoredLinkActors)
	{
		if (Container.StoredActor == LinkedActor)
		{
			Container.bIsActive = false;
			LinkedActor->Exit();
			LinkedActor->SetActorHiddenInGame(true);
			LinkedActor = nullptr;
		}
	}
}

void ABattleObject::PlayCommonSound(FGameplayTag Name)
{
	if (!IsValid(GameState))
		return;
	if (Player->CommonSoundData != nullptr)
	{
		for (FSoundStruct SoundStruct : Player->CommonSoundData->SoundDatas)
		{
			if (SoundStruct.Name == Name)
			{
				GameState->PlayCommonAudio(SoundStruct.SoundWave, SoundStruct.MaxDuration);
				break;
			}
		}
	}
}

void ABattleObject::PlayCharaSound(FGameplayTag Name)
{
	if (!IsValid(GameState))
		return;
	if (Player->SoundData != nullptr)
	{
		for (FSoundStruct SoundStruct : Player->SoundData->SoundDatas)
		{
			if (SoundStruct.Name == Name)
			{
				GameState->PlayCharaAudio(SoundStruct.SoundWave, SoundStruct.MaxDuration);
				break;
			}
		}
	}
}

void ABattleObject::AttachToSocketOfObject(FName InSocketName, FVector Offset, EObjType ObjType)
{
	SocketName = InSocketName;
	SocketObj = ObjType;
	SocketOffset = Offset;
}

void ABattleObject::DetachFromSocket()
{
	SocketName = FName();
	SocketObj = OBJ_Self;
	SocketOffset = FVector::ZeroVector;
}

void ABattleObject::CameraShake(FGameplayTag PatternName, int32 Scale)
{
	if (!GameState) return;
	if (IsValid(Player->CameraShakeData))
	{
		for (auto [Name, CameraShake] : Player->CameraShakeData->CameraShakeStructs)
		{
			if (Name == PatternName)
				GameState->CameraShake(CameraShake, static_cast<float>(Scale) / 1000);
		}
	}
}

int32 ABattleObject::GenerateRandomNumber(int32 Min, int32 Max) const
{
	return GameState->BattleState.RandomManager.RandRange(Min, Max);
}

void ABattleObject::StartSuperFreeze(int Duration, int SelfDuration)
{
	if (!GameState) return;
	GameState->StartSuperFreeze(Duration, SelfDuration, this);
	if (Duration > 0) TriggerEvent(EVT_SuperFreeze, StateMachine_Primary);
}

void ABattleObject::IgnoreSuperFreeze(bool Ignore)
{
	if (Ignore)
		MiscFlags |= MISC_IgnoreSuperFreeze;
	else
		MiscFlags &= ~MISC_IgnoreSuperFreeze;
}

void ABattleObject::SetObjectID(int InObjectID)
{
	ObjectID = InObjectID;
}

ABattleObject* ABattleObject::GetBattleObject(EObjType Type)
{
	switch (Type)
	{
	case OBJ_Self:
		return this;
	case OBJ_MainPlayer:
		return GameState->GetMainPlayer(Player->PlayerIndex == 0);
	case OBJ_Enemy:
		return Player->Enemy;
	case OBJ_Parent:
		return Player;
	case OBJ_Child0:
		if (IsPlayer && Player->StoredBattleObjects[0])
			if (Player->StoredBattleObjects[0]->IsActive)
				return Player->StoredBattleObjects[0];
		return nullptr;
	case OBJ_Child1:
		if (IsPlayer && Player->StoredBattleObjects[1])
			if (Player->StoredBattleObjects[1]->IsActive)
				return Player->StoredBattleObjects[1];
		return nullptr;
	case OBJ_Child2:
		if (IsPlayer && Player->StoredBattleObjects[2])
			if (Player->StoredBattleObjects[2]->IsActive)
				return Player->StoredBattleObjects[2];
		return nullptr;
	case OBJ_Child3:
		if (IsPlayer && Player->StoredBattleObjects[3])
			if (Player->StoredBattleObjects[3]->IsActive)
				return Player->StoredBattleObjects[3];
		return nullptr;
	case OBJ_Child4:
		if (IsPlayer && Player->StoredBattleObjects[4])
			if (Player->StoredBattleObjects[4]->IsActive)
				return Player->StoredBattleObjects[4];
		return nullptr;
	case OBJ_Child5:
		if (IsPlayer && Player->StoredBattleObjects[5])
			if (Player->StoredBattleObjects[5]->IsActive)
				return Player->StoredBattleObjects[5];
		return nullptr;
	case OBJ_Child6:
		if (IsPlayer && Player->StoredBattleObjects[6])
			if (Player->StoredBattleObjects[6]->IsActive)
				return Player->StoredBattleObjects[6];
		return nullptr;
	case OBJ_Child7:
		if (IsPlayer && Player->StoredBattleObjects[7])
			if (Player->StoredBattleObjects[7]->IsActive)
				return Player->StoredBattleObjects[7];
		return nullptr;
	case OBJ_Child8:
		if (IsPlayer && Player->StoredBattleObjects[8])
			if (Player->StoredBattleObjects[8]->IsActive)
				return Player->StoredBattleObjects[8];
		return nullptr;
	case OBJ_Child9:
		if (IsPlayer && Player->StoredBattleObjects[9])
			if (Player->StoredBattleObjects[9]->IsActive)
				return Player->StoredBattleObjects[9];
		return nullptr;
	case OBJ_Child10:
		if (IsPlayer && Player->StoredBattleObjects[10])
			if (Player->StoredBattleObjects[10]->IsActive)
				return Player->StoredBattleObjects[10];
		return nullptr;
	case OBJ_Child11:
		if (IsPlayer && Player->StoredBattleObjects[11])
			if (Player->StoredBattleObjects[11]->IsActive)
				return Player->StoredBattleObjects[11];
		return nullptr;
	case OBJ_Child12:
		if (IsPlayer && Player->StoredBattleObjects[12])
			if (Player->StoredBattleObjects[12]->IsActive)
				return Player->StoredBattleObjects[12];
		return nullptr;
	case OBJ_Child13:
		if (IsPlayer && Player->StoredBattleObjects[13])
			if (Player->StoredBattleObjects[13]->IsActive)
				return Player->StoredBattleObjects[13];
		return nullptr;
	case OBJ_Child14:
		if (IsPlayer && Player->StoredBattleObjects[14])
			if (Player->StoredBattleObjects[14]->IsActive)
				return Player->StoredBattleObjects[14];
		return nullptr;
	case OBJ_Child15:
		if (IsPlayer && Player->StoredBattleObjects[15])
			if (Player->StoredBattleObjects[15]->IsActive)
				return Player->StoredBattleObjects[15];
		return nullptr;
	default:
		return nullptr;
	}
}

ABattleObject* ABattleObject::AddCommonBattleObject(FGameplayTag InStateName, int32 PosXOffset, int32 PosYOffset,
                                                    EPosType PosType)
{
	if (!GameState) return nullptr;
	const int StateIndex = Player->CommonObjectStateNames.Find(InStateName);
	if (StateIndex != INDEX_NONE)
	{
		int32 FinalPosX, FinalPosY;

		PosTypeToPosition(PosType, FinalPosX, FinalPosY);
		if (Direction == DIR_Left) PosXOffset *= -1;
		FinalPosX += PosXOffset;
		FinalPosY += PosYOffset;
		return GameState->AddBattleObject(Player->CommonObjectStates[StateIndex],
		                                  FinalPosX, FinalPosY, Direction, StateIndex, true, Player);
	}
	return nullptr;
}

ABattleObject* ABattleObject::AddBattleObject(FGameplayTag InStateName, int32 PosXOffset, int32 PosYOffset,
                                              EPosType PosType)
{
	if (!GameState) return nullptr;
	const int StateIndex = Player->ObjectStateNames.Find(InStateName);
	if (StateIndex != INDEX_NONE)
	{
		int32 FinalPosX, FinalPosY;

		PosTypeToPosition(PosType, FinalPosX, FinalPosY);
		if (Direction == DIR_Left) PosXOffset *= -1;
		FinalPosX += PosXOffset;
		FinalPosY += PosYOffset;
		return GameState->AddBattleObject(Player->ObjectStates[StateIndex],
		                                  FinalPosX, FinalPosY, Direction, StateIndex, false, Player);
	}
	return nullptr;
}

void ABattleObject::EnableDeactivateIfBeyondBounds(bool Enable)
{
	if (Enable)
	{
		MiscFlags |= MISC_DeactivateIfBeyondBounds;
	}
	else
	{
		MiscFlags &= ~MISC_DeactivateIfBeyondBounds;
	}
}

void ABattleObject::EnableDeactivateOnStateChange(bool Enable)
{
	if (Enable)
	{
		MiscFlags |= MISC_DeactivateOnStateChange;
	}
	else
	{
		MiscFlags &= ~MISC_DeactivateOnStateChange;
	}
}

void ABattleObject::EnableDeactivateOnReceiveHit(bool Enable)
{
	if (Enable)
	{
		MiscFlags |= MISC_DeactivateOnReceiveHit;
	}
	else
	{
		MiscFlags &= ~MISC_DeactivateOnReceiveHit;
	}
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include <fstream>

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "GameFramework/Pawn.h"
#include "NightSkyEngine/Battle/Misc/CollisionBox.h"
#include "NightSkyEngine/Data/CollisionData.h"
#include "BattleObject.generated.h"

class ALinkActor;
class UNightSkyAnimSequenceUserData;
class ANightSkyCharaSelectGameState;
class UPaperFlipbookComponent;
class UNiagaraComponent;
class ANightSkyGameState;
class UState;
class APlayerObject;

constexpr int32 MaxDrawPriority = 4;

// Event handler data.

/*
 * Event type. When a function is registered with an event handler, 
 * it will trigger at the event type specified.
 */

UENUM(BlueprintType)
enum EEventType
{
	EVT_Update UMETA(DisplayName="Update"),
	EVT_Exit UMETA(DisplayName="Exit"),
	EVT_Landing UMETA(DisplayName="Landing"),
	EVT_Hit UMETA(DisplayName="Hit"),
	EVT_Block UMETA(DisplayName="Block"),
	EVT_HitOrBlock UMETA(DisplayName="Hit or Block"),
	EVT_CounterHit UMETA(DisplayName="Counter Hit"),
	EVT_Kill UMETA(DisplayName="Kill"),
	EVT_ReceiveHit UMETA(DisplayName="Receive Hit"),
	EVT_SuperFreeze UMETA(DisplayName="Super Freeze"),
	EVT_SuperFreezeEnd UMETA(DisplayName="Super Freeze End"),
	EVT_Timer0 UMETA(DisplayName="Timer #0"),
	EVT_Timer1 UMETA(DisplayName="Timer #1"),
	EVT_HitMainPlayer UMETA(DisplayName="Hit (Main Player)"),
	EVT_BlockMainPlayer UMETA(DisplayName="Block (Main Player)"),
	EVT_HitOrBlockMainPlayer UMETA(DisplayName="Hit or Block (Main Player)"),
	EVT_CounterHitMainPlayer UMETA(DisplayName="Counter Hit (Main Player)"),
	EVT_KillMainPlayer UMETA(DisplayName="Kill (Main Player)"),
	EVT_ReceiveHitMainPlayer UMETA(DisplayName="Receive Hit (Main Player)"),
	EVT_NUM UMETA(Hidden)
};

USTRUCT()
struct FEventHandler
{
	GENERATED_BODY()

	FName FunctionName;
	FGameplayTag SubroutineName;
};

// Hit related data.

// How the opponent must block the attack.
UENUM()
enum EBlockType
{
	BLK_Mid UMETA(DisplayName="Mid"),
	BLK_High UMETA(DisplayName="High"),
	BLK_Low UMETA(DisplayName="Low"),
	BLK_None UMETA(DisplayName="Unblockable"),
};

// Hit sound effect type.
UENUM()
enum class EHitSFXType : uint8
{
	SFX_Punch UMETA(DisplayName="Punch"),
	SFX_Kick UMETA(DisplayName="Kick"),
	SFX_Slash UMETA(DisplayName="Slash"),
};

// Hit visual effect type.
UENUM()
enum class EHitVFXType : uint8
{
	VFX_Strike UMETA(DisplayName="Strike"),
	VFX_Slash UMETA(DisplayName="Slash"),
	VFX_Special UMETA(DisplayName="Special"),
};

/*
 * Common data for attacks.
 * These values will be used for blocking, normal hit, and counter hit.
 * Values that are set to INT_MAX will be replaced by a default value depending on attack level.
 */

USTRUCT(BlueprintType)
struct FHitDataCommon
{
	GENERATED_BODY()

	/*
	 * This controls default values for hit data.
	 * The minimum attack level is 0, and the maximum is 5.
	 */
	UPROPERTY(BlueprintReadWrite, meta=(ClampMin=0, ClampMax=5))
	int32 AttackLevel = 0;
	// How the opponent must block the attack.
	UPROPERTY(BlueprintReadWrite)
	TEnumAsByte<EBlockType> BlockType = BLK_Mid;
	// Hitstop modifier for self on block, relative to normal hit's hitstop.
	UPROPERTY(BlueprintReadWrite)
	int32 BlockstopModifier = INT_MAX;
	// Hitstop modifier for opponent on block, relative to normal hit's hitstop.
	UPROPERTY(BlueprintReadWrite)
	int32 EnemyBlockstopModifier = 0;
	// How long the opponent will be stunned while blocking.
	UPROPERTY(BlueprintReadWrite)
	int32 Blockstun = INT_MAX;
	// The percent of normal hit damage the opponent will take when blocking this attack.
	UPROPERTY(BlueprintReadWrite)
	int32 ChipDamagePercent = 0;
	/*
	 * Ground pushback for blocking.
	 * If the opponent is in the corner, this will instead apply to self,
	 * even if you are airborne.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 GroundGuardPushbackX = INT_MAX;
	// Air x pushback for blocking.
	UPROPERTY(BlueprintReadWrite)
	int32 AirGuardPushbackX = INT_MAX;
	// Air y pushback for blocking.
	UPROPERTY(BlueprintReadWrite)
	int32 AirGuardPushbackY = INT_MAX;
	// Gravity for blocking.
	UPROPERTY(BlueprintReadWrite)
	int32 GuardGravity = INT_MAX;
	UPROPERTY(BlueprintReadWrite)
	int32 ProximityBlockDistanceX = 240000;
	UPROPERTY(BlueprintReadWrite)
	int32 ProximityBlockDistanceY = 160000;
	// The angle at which hit effects will spawn.
	UPROPERTY(BlueprintReadWrite)
	int32 HitAngle = 0;
	// Sound effect type.
	UPROPERTY(BlueprintReadWrite)
	EHitSFXType SFXType = EHitSFXType::SFX_Punch;
	// Visual effect type.
	UPROPERTY(BlueprintReadWrite)
	EHitVFXType VFXType = EHitVFXType::VFX_Strike;
	UPROPERTY(BlueprintReadWrite)
	FGameplayTag GuardSFXOverride;
	UPROPERTY(BlueprintReadWrite)
	FGameplayTag GuardVFXOverride;
	UPROPERTY(BlueprintReadWrite)
	FGameplayTag HitSFXOverride;
	UPROPERTY(BlueprintReadWrite)
	FGameplayTag HitVFXOverride;
	UPROPERTY(BlueprintReadWrite)
	bool DeathCamOverride = false;

	// Guard sound effect name.
	FGameplayTag GuardSFX;
	// Guard visual effect name.
	FGameplayTag GuardVFX;
	// Hit sound effect name.
	FGameplayTag HitSFX;
	// Hit visual effect name.
	FGameplayTag HitVFX;
	
	// Hit color data.
	UPROPERTY(BlueprintReadWrite)
	FLinearColor DamageColor = FLinearColor(1.0, 1.0, 1.0);
	UPROPERTY(BlueprintReadWrite)
	FLinearColor DamageColor2 = FLinearColor(1.0, 1.0, 1.0);
};

/*
 * List of hit actions.
 * Depending on the hit action, animations and behavior will change.
 */

UENUM()
enum EHitAction
{
	HACT_None UMETA(DisplayName="None"),
	HACT_GroundNormal UMETA(DisplayName="Ground Normal"),
	HACT_AirNormal UMETA(DisplayName="Air Normal"),
	HACT_Stagger UMETA(DisplayName="Stagger"),
	HACT_Crumple UMETA(DisplayName="Crumple"),
	HACT_ForceCrouch UMETA(DisplayName="Force Crouch"),
	HACT_ForceStand UMETA(DisplayName="Force Stand"),
	HACT_AirFaceUp UMETA(DisplayName="Air Face Up"),
	HACT_AirVertical UMETA(DisplayName="Air Vertical"),
	HACT_AirFaceDown UMETA(DisplayName="Air Face Down"),
	HACT_Blowback UMETA(DisplayName="Blowback"),
	HACT_Tailspin UMETA(DisplayName="Tailspin"),
	HACT_GuardBreak UMETA(DisplayName="Guard Break"),
	HACT_GuardBreakStand UMETA(DisplayName="Guard Break Stand"),
	HACT_GuardBreakCrouch UMETA(DisplayName="Guard Break Crouch"),
	HACT_GuardBreakAir UMETA(DisplayName="Guard Break Air"),
	HACT_FloatingCrumple UMETA(DisplayName="Floating Crumple"),
	HACT_Custom UMETA(DisplayName="Custom"),
};

// Used with the Floating Crumple hit action.
UENUM(BlueprintType)
enum EFloatingCrumpleType
{
	FLT_None UMETA(DisplayName="None"),
	FLT_Body UMETA(DisplayName="Body"),
	FLT_Head UMETA(DisplayName="Head"),
};

// Determines how the opponent's position immediately after hit will be calculated.
UENUM(BlueprintType)
enum EHitPositionType
{
	HPT_Non UMETA(DisplayName="None"),
	HPT_Rel,
	HPT_Abs,
	HPT_Add UMETA(DisplayName="Add"),
	HPT_RelNextFrame,
	HPT_AbsNextFrame,
	HPT_AddNextFrame UMETA(DisplayName="Add Next Frame"),
};

/*
 * Data for wall bounce.
 * Values that are set to INT_MAX will be replaced by a default value.
 */
USTRUCT(BlueprintType)
struct FWallBounceData
{
	GENERATED_BODY()

	// How many times the opponent will wall bounce.
	UPROPERTY(BlueprintReadWrite)
	int32 WallBounceCount = -1;
	// If this value is not INT_MAX, it will override the current untech duration.
	UPROPERTY(BlueprintReadWrite)
	int32 WallBounceUntech = INT_MAX;
	// The hitstop upon wall bounce.
	UPROPERTY(BlueprintReadWrite)
	int32 WallBounceStop = INT_MAX;
	/*
	 * Wall bounce x speed.
	 * If this value is INT_MAX, it will be set to the current x speed.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 WallBounceXSpeed = INT_MAX;
	/*
	 * The percent of wall bounce x speed.
	 * If this value is INT_MAX, it will be set to 33%.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 WallBounceXRate = INT_MAX;
	/*
	 * Wall bounce y speed.
	 * If this value is INT_MAX, it will be set to the received y pushback.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 WallBounceYSpeed = INT_MAX;
	/*
     * The percent of wall bounce y speed.
     * If this value is INT_MAX, it will be set to 100%.
     */
	UPROPERTY(BlueprintReadWrite)
	int32 WallBounceYRate = INT_MAX;
	/*
	 * Wall bounce gravity.
	 * If this value is INT_MAX, it will be set to the received hit gravity.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 WallBounceGravity = INT_MAX;
	// Determines if wall bounce can happen anywhere, or only in stage corner.
	UPROPERTY(BlueprintReadWrite)
	bool WallBounceInCornerOnly = false;
};

/*
 * Data for ground bounce.
 * Values that are set to INT_MAX will be replaced by a default value.
 */
USTRUCT(BlueprintType)
struct FGroundBounceData
{
	GENERATED_BODY()

	// How many times the opponent will ground bounce.
	UPROPERTY(BlueprintReadWrite)
	int32 GroundBounceCount = -1;
	// If this value is not INT_MAX, it will override the current untech duration.
	UPROPERTY(BlueprintReadWrite)
	int32 GroundBounceUntech = INT_MAX;
	// The hitstop upon ground bounce.
	UPROPERTY(BlueprintReadWrite)
	int32 GroundBounceStop = INT_MAX;
	/*
	 * Ground bounce x speed.
	 * If this value is INT_MAX, it will be set to the received x pushback.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 GroundBounceXSpeed = INT_MAX;
	/*
	 * The percent of ground bounce x speed.
	 * If this value is INT_MAX, it will be set to 100%.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 GroundBounceXRate = INT_MAX;
	/*
	 * Ground bounce y speed.
	 * If this value is INT_MAX, it will be set to the current y speed.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 GroundBounceYSpeed = INT_MAX;
	/*
	 * The percent of ground bounce y speed.
	 * If this value is INT_MAX, it will be set to 100%.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 GroundBounceYRate = INT_MAX;
	/*
	 * Ground bounce gravity.
	 * If this value is INT_MAX, it will be set to the received hit gravity.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 GroundBounceGravity = INT_MAX;
};

/*
 * Value is added to the specified hit value every frame,
 * from BeginFrame to EndFrame.
 */
USTRUCT(BlueprintType)
struct FHitValueOverTime
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite)
	int32 Value = INT_MAX;
	UPROPERTY(BlueprintReadWrite)
	int32 BeginFrame = INT_MAX;
	UPROPERTY(BlueprintReadWrite)
	int32 EndFrame = INT_MAX;
};

// Determines the opponent's position after being hit.
USTRUCT(BlueprintType)
struct FHitPosition
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite)
	TEnumAsByte<EHitPositionType> Type;
	UPROPERTY(BlueprintReadWrite)
	int32 PosX = INT_MAX;
	UPROPERTY(BlueprintReadWrite)
	int32 PosY = INT_MAX;
};

/*
 * Hit data.
 * There is one for normal hit, and one for counter hit.
 * For normal hit, values that are set to INT_MAX will be replaced by a default value depending on attack level.
 * For counter hit, values that are set to INT_MAX will be replaced by the normal hit's value.
 */
USTRUCT(BlueprintType)
struct FHitData
{
	GENERATED_BODY()

	// Hitstop duration for attacker and defender.
	UPROPERTY(BlueprintReadWrite)
	int32 Hitstop = INT_MAX;
	// How long the opponent will be stunned if hit grounded.
	UPROPERTY(BlueprintReadWrite)
	int32 Hitstun = INT_MAX;
	// How long the opponent will be stunned if hit airborne.
	UPROPERTY(BlueprintReadWrite)
	int32 Untech = INT_MAX;
	// Hitstop modifier for the opponent on hit.
	UPROPERTY(BlueprintReadWrite)
	int32 EnemyHitstopModifier = INT_MAX;
	// How much damage the opponent will take.
	UPROPERTY(BlueprintReadWrite)
	int32 Damage = INT_MAX;
	// The percent of damage that can be recovered.
	UPROPERTY(BlueprintReadWrite)
	int32 RecoverableDamagePercent = INT_MAX;
	/*
	 * The minimum damage percent.
	 * Damage scaling cannot bring damage lower than this.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 MinimumDamagePercent = INT_MAX;
	/*
	 * Initial proration for hit.
	 * This is scaling that is applied only as the first hit of a combo.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 InitialProration = INT_MAX;
	/*
	 * Initial proration for hit.
	 * This is scaling that is applied every hit.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 ForcedProration = INT_MAX;
	/*
	 * Ground pushback for hit.
     * If the opponent is in the corner, this will instead apply to self,
	 * even if you are airborne.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 GroundPushbackX = INT_MAX;
	// Air x pushback for hit.
	UPROPERTY(BlueprintReadWrite)
	int32 AirPushbackX = INT_MAX;
	// Air y pushback for hit.
	UPROPERTY(BlueprintReadWrite)
	int32 AirPushbackY = INT_MAX;
	// Gravity for hit.
	UPROPERTY(BlueprintReadWrite)
	int32 Gravity = INT_MAX;
	/*
	 * The hit value over time for air pushback x.
	 * The value is a percentage.
	 */
	UPROPERTY(BlueprintReadWrite)
	FHitValueOverTime AirPushbackXOverTime;
	/*
	 * The hit value over time for air pushback y.
	 * The value is a percentage.
	 */
	UPROPERTY(BlueprintReadWrite)
	FHitValueOverTime AirPushbackYOverTime;
	/*
	 * The hit value over time for gravity.
	 * The value is added to current gravity.
	 */
	UPROPERTY(BlueprintReadWrite)
	FHitValueOverTime GravityOverTime;
	// Opponent position after hit.
	UPROPERTY(BlueprintReadWrite)
	FHitPosition Position;
	// Ground hit action.
	UPROPERTY(BlueprintReadWrite)
	TEnumAsByte<EHitAction> GroundHitAction = HACT_GroundNormal;
	// Air hit action.
	UPROPERTY(BlueprintReadWrite)
	TEnumAsByte<EHitAction> AirHitAction = HACT_AirNormal;
	// Custom hit action.
	UPROPERTY(BlueprintReadWrite)
	FGameplayTag CustomHitAction;
	// Blowback animation level. Used with the Blowback hit action.
	UPROPERTY(BlueprintReadWrite)
	int32 BlowbackLevel = INT_MAX;
	// Floating crumple type. Used with the Floating Crumple hit action.
	UPROPERTY(BlueprintReadWrite)
	TEnumAsByte<EFloatingCrumpleType> FloatingCrumpleType;
	// How long the opponent will be knocked down for before recovery. Defaults to 12 frames.
	UPROPERTY(BlueprintReadWrite)
	int32 KnockdownTime = INT_MAX;
	// Determines if the opponent can tech after being knocked down. Default is soft knockdown.
	UPROPERTY(BlueprintReadWrite)
	int32 HardKnockdown = INT_MAX;
	// Ground bounce data.
	UPROPERTY(BlueprintReadWrite)
	FGroundBounceData GroundBounce;
	// Wall bounce data.
	UPROPERTY(BlueprintReadWrite)
	FWallBounceData WallBounce;
};

/*
 * Miscellaneous data.
 */

// The character's facing direction.
UENUM()
enum EObjDir
{
	DIR_Right,
	DIR_Left,
};

// Used for distance calculations.
UENUM()
enum EDistanceType
{
	DIST_Distance,
	DIST_DistanceX,
	DIST_DistanceY,
	DIST_FrontDistanceX,
};

// Used for homing calculations.
UENUM(BlueprintType)
enum EHomingType
{
	HOMING_DistanceAccel,
	HOMING_FixAccel,
	HOMING_ToSpeed,
};

// Determines the position type to check.
UENUM(BlueprintType)
enum EPosType
{
	POS_Player,
	POS_Self,
	POS_Center,
	POS_Ground,
	POS_Enemy,
	POS_Col,
};

// Determines object type.
UENUM(BlueprintType)
enum EObjType
{
	OBJ_Self,
	OBJ_MainPlayer,
	OBJ_Enemy,
	OBJ_Parent,
	OBJ_Child0,
	OBJ_Child1,
	OBJ_Child2,
	OBJ_Child3,
	OBJ_Child4,
	OBJ_Child5,
	OBJ_Child6,
	OBJ_Child7,
	OBJ_Child8,
	OBJ_Child9,
	OBJ_Child10,
	OBJ_Child11,
	OBJ_Child12,
	OBJ_Child13,
	OBJ_Child14,
	OBJ_Child15,
	OBJ_Null,
};

USTRUCT(BlueprintType)
struct FHomingParams
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite)
	TEnumAsByte<EHomingType> Type;
	UPROPERTY(BlueprintReadWrite)
	TEnumAsByte<EObjType> Target = OBJ_Null;
	UPROPERTY(BlueprintReadWrite)
	TEnumAsByte<EPosType> Pos;
	UPROPERTY(BlueprintReadWrite)
	int32 OffsetX;
	UPROPERTY(BlueprintReadWrite)
	int32 OffsetY;
	UPROPERTY(BlueprintReadWrite)
	int32 ParamA;
	UPROPERTY(BlueprintReadWrite)
	int32 ParamB;
};

USTRUCT()
struct FLinkedActorContainer
{
	GENERATED_BODY()

	UPROPERTY()
	TObjectPtr<ALinkActor> StoredActor;
	FGameplayTag Name;
	int32 Index;
	UPROPERTY(SaveGame)
	bool bIsActive;
};

UENUM(BlueprintType)
enum ESuperArmorType
{
	ARM_None,
	ARM_Guard,
	ARM_Dodge,
};

USTRUCT(BlueprintType)
struct FSuperArmorData
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite)
	TEnumAsByte<ESuperArmorType> Type;
	UPROPERTY(BlueprintReadWrite)
	uint8 bArmorMid : 1;
	UPROPERTY(BlueprintReadWrite)
	uint8 bArmorOverhead : 1;
	UPROPERTY(BlueprintReadWrite)
	uint8 bArmorLow : 1;
	UPROPERTY(BlueprintReadWrite)
	uint8 bArmorStrike : 1;
	UPROPERTY(BlueprintReadWrite)
	uint8 bArmorThrow : 1;
	UPROPERTY(BlueprintReadWrite)
	uint8 bArmorHead : 1;
	UPROPERTY(BlueprintReadWrite)
	uint8 bArmorProjectile : 1;
	UPROPERTY(BlueprintReadWrite)
	uint8 bArmorTakeChipDamage : 1;
	UPROPERTY(BlueprintReadWrite)
	int32 ArmorDamagePercent;
	UPROPERTY(BlueprintReadWrite)
	int32 ArmorHits;
};

/**
 * This struct is only for sync logs.
 */
USTRUCT(BlueprintType)
struct FBattleObjectLog
{
	GENERATED_BODY()

public:
	virtual ~FBattleObjectLog() = default;

	//Starting from this until ObjSyncEnd, everything is saved/loaded for rollback.
	unsigned char ObjSync = 0;

	/*
	 * Movement and position values
	 */

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 PosX = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 PosY = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PosZ = 0;
	int32 PrevPosX = 0;
	int32 PrevPosY = 0;
	int32 PrevPosZ = 0;
	int32 PrevRootMotionX = 0;
	int32 PrevRootMotionY = 0;
	int32 PrevRootMotionZ = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 AnglePitch_x10 = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 AngleYaw_x10 = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 AngleRoll_x10 = 0;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	bool BlendOffset = false;
	int32 PrevOffsetX = 0;
	int32 PrevOffsetY = 0;
	int32 NextOffsetX = 0;
	int32 NextOffsetY = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 SpeedX = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 SpeedY = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedZ = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedXRate = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedXRatePerFrame = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedYRate = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedYRatePerFrame = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedZRate = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedZRatePerFrame = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 Gravity = 1900;
	// Inertia adds to the position every frame, but also decays every frame until it reaches zero.
	UPROPERTY(BlueprintReadWrite)
	int32 Inertia = 0;
	// The minimum Y position before considered grounded.
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 GroundHeight = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	TEnumAsByte<EObjDir> Direction = DIR_Right;
	// Ground hit pushback.
	int32 Pushback = 0;

	/*
	 * Attack data
	 */

	UPROPERTY(BlueprintReadWrite)
	FHitDataCommon HitCommon = {};
	UPROPERTY(BlueprintReadWrite)
	FHitData NormalHit = {};
	UPROPERTY(BlueprintReadWrite)
	FHitData CounterHit = {};
	uint32 AttackFlags = 0;

	/*
	 * Received attack data
	 */

	UPROPERTY(BlueprintReadOnly)
	FHitDataCommon ReceivedHitCommon = {};
	UPROPERTY(BlueprintReadOnly)
	FHitData ReceivedHit = {};
	uint32 StunTime = 0;
	uint32 StunTimeMax = 0;
	uint32 Hitstop = 0;

	/*
	 * Registers
	*/

	//This value stores the return value for functions.
	bool ReturnReg = false;

	//The following values are per-action registers. Shared between the player and its child objects.
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg4 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg5 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg6 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg7 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg8 = 0;

	//The following values are per-object registers.
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg4 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg5 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg6 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg7 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg8 = 0;

	/*
	 * Subroutine registers. These are set when calling a subroutine, and reset upon round end.
	 */
	UPROPERTY(BlueprintReadOnly)
	int32 SubroutineReg1 = 0;
	UPROPERTY(BlueprintReadOnly)
	int32 SubroutineReg2 = 0;
	UPROPERTY(BlueprintReadOnly)
	int32 SubroutineReg3 = 0;
	UPROPERTY(BlueprintReadOnly)
	int32 SubroutineReg4 = 0;

	/*
	 * Subroutine return values. Subroutines can optionally return values.
	 * These are reset upon the next called subroutine.
	*/
	UPROPERTY(BlueprintReadWrite)
	int32 SubroutineReturnVal1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SubroutineReturnVal2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SubroutineReturnVal3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SubroutineReturnVal4 = 0;

	/*
	 * Action data
	 */

	UPROPERTY(BlueprintReadOnly)
	int32 ActionTime = 0;
	/*
	 * The current cel name.
	 * Cels map to collision data.
	 * The collision frame also stores animation data.
	 */
	FGameplayTag CelName = {};
	/*
	 * The blend cel name.
	 * This is used to make traditional 3D animations.
	 */
	FGameplayTag BlendCelName = {};
	/*
	 * The name of the label that is currently being jumped to.
	 */
	FGameplayTag LabelName = {};

	UPROPERTY(BlueprintReadOnly)
	float AnimBlendIn{};
	UPROPERTY(BlueprintReadOnly)
	float AnimBlendOut{};
	// Are we jumping to a label right now?
	UPROPERTY(BlueprintReadWrite)
	bool GotoLabelActive = false;
	UPROPERTY(BlueprintReadWrite)
	int32 AnimFrame = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 BlendAnimFrame = 0;
	UPROPERTY(BlueprintReadWrite)
	float FrameBlendPosition = 0;
	// The index of the current cel in blueprint.
	UPROPERTY(BlueprintReadWrite)
	int32 CelIndex = 0;
	// How long until the next cel activates.
	UPROPERTY(BlueprintReadOnly)
	int32 TimeUntilNextCel = 0;
	// Max time of the cel.
	int32 MaxCelTime = 0;
	// Event handlers for every function.
	FEventHandler EventHandlers[EVT_NUM] = {};

	/*
	 * Action data for objects only.
	 */
	FGameplayTag ObjectStateName = {};
	uint32 ObjectID = 0;

protected:
	/*
	 * Collision data
	 */
	int32 PushHeight = 0;
	int32 PushHeightLow = 0;
	int32 PushWidth = 0;
	int32 PushWidthExtend = 0;

public:
	/*
	 * Push collision
	 */

	int32 L = 0;
	int32 R = 0;
	int32 T = 0;
	int32 B = 0;

	/*
	 * Socket data
	 */
	FName SocketName = {};
	EObjType SocketObj = OBJ_Self;
	FVector SocketOffset = FVector::ZeroVector;

	//material parameters
	UPROPERTY(BlueprintReadWrite)
	FLinearColor MulColor = FLinearColor(1, 1, 1, 1);
	UPROPERTY(BlueprintReadWrite)
	FLinearColor AddColor = FLinearColor(0, 0, 0, 1);
	UPROPERTY(BlueprintReadWrite)
	FLinearColor MulFadeColor = {};
	UPROPERTY(BlueprintReadWrite)
	FLinearColor AddFadeColor = {};
	UPROPERTY(BlueprintReadWrite)
	float MulFadeSpeed = 0;
	UPROPERTY(BlueprintReadWrite)
	float AddFadeSpeed = 0;
	UPROPERTY(BlueprintReadWrite)
	float Transparency = 1;
	UPROPERTY(BlueprintReadWrite)
	float FadeTransparency = 1;
	UPROPERTY(BlueprintReadWrite)
	float TransparencySpeed = 0;
	UPROPERTY(BlueprintReadWrite)
	FLinearColor DamageColor = FLinearColor(1, 1, 1, 1);
	UPROPERTY(BlueprintReadWrite)
	FLinearColor DamageColor2 = FLinearColor(1, 1, 1, 1);

	/*
	 * Miscellaneous data
	 */
	int32 ColPosX = 0;
	int32 ColPosY = 0;
	int32 MiscFlags = 0;
	int32 Timer0 = 0;
	int32 Timer1 = 0;
	bool IsPlayer = false;
	bool IsActive = false;
	UPROPERTY(BlueprintReadWrite)
	int32 DrawPriority = 0; // the higher the number, the farther in front the object will be drawn

	UPROPERTY(BlueprintReadWrite)
	bool bRender = true;

	UPROPERTY(BlueprintReadWrite)
	FHomingParams HomingParams = FHomingParams();
	UPROPERTY(BlueprintReadWrite)
	FSuperArmorData SuperArmorData = FSuperArmorData();

	UPROPERTY(BlueprintReadOnly)
	int32 UpdateTime = 0;

	/*
	 * Visual object transform
	 */
	UPROPERTY(BlueprintReadWrite)
	FVector ObjectOffset = FVector::ZeroVector;
	UPROPERTY(BlueprintReadWrite)
	FRotator ObjectRotation = FRotator::ZeroRotator;
	UPROPERTY(BlueprintReadWrite)
	FVector ObjectScale = FVector::One();

	/*
	 * Object pointers.
	 */

	// Pointer to player object. If this is not a player, it will point to the owning player.
	UPROPERTY(BlueprintReadOnly)
	APlayerObject* Player = nullptr;
	UPROPERTY(BlueprintReadOnly)
	ABattleObject* AttackOwner;
	UPROPERTY(BlueprintReadOnly)
	ABattleObject* AttackTarget = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ABattleObject* PositionLinkObj = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ABattleObject* DrawPriorityLinkObj = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ABattleObject* StopLinkObj = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ABattleObject* MaterialLinkObj = nullptr;

	int32 ObjectStateIndex = 0;
	bool bIsCommonState = false;

	// Anything past here isn't saved or loaded for rollback, unless it has the SaveGame tag.
	unsigned char ObjSyncEnd = 0;

	virtual void LogForSyncTestFile(std::ofstream& file);
};

/*
 * A battle object.
 * These are any objects that affect gameplay, or need values to change after being spawned.
 */
UCLASS()
class NIGHTSKYENGINE_API ABattleObject : public APawn
{
	GENERATED_BODY()

public:
	// Sets default values for this pawn's properties
	ABattleObject();

	//Starting from this until ObjSyncEnd, everything is saved/loaded for rollback.
	unsigned char ObjSync = 0;

	/*
	 * Movement and position values
	 */

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 PosX = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 PosY = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 PosZ = 0;
	int32 PrevPosX = 0;
	int32 PrevPosY = 0;
	int32 PrevPosZ = 0;
	int32 PrevRootMotionX = 0;
	int32 PrevRootMotionY = 0;
	int32 PrevRootMotionZ = 0;
	UPROPERTY(VisibleAnywhere)
	int32 AnglePitch_x1000 = 0;
	UPROPERTY(VisibleAnywhere)
	int32 AngleYaw_x1000 = 0;
	UPROPERTY(VisibleAnywhere)
	int32 AngleRoll_x1000 = 0;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	bool BlendOffset = false;
	int32 PrevOffsetX = 0;
	int32 PrevOffsetY = 0;
	int32 NextOffsetX = 0;
	int32 NextOffsetY = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 SpeedX = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 SpeedY = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedZ = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedXRate = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedXRatePerFrame = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedYRate = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedYRatePerFrame = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedZRate = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 SpeedZRatePerFrame = 100;
	UPROPERTY(BlueprintReadWrite)
	int32 Gravity = 1900;
	// Inertia adds to the position every frame, but also decays every frame until it reaches zero.
	UPROPERTY(BlueprintReadWrite)
	int32 Inertia = 0;
	// The minimum Y position before considered grounded.
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 GroundHeight = 0;
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	TEnumAsByte<EObjDir> Direction = DIR_Right;
	// Ground hit pushback.
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	int32 Pushback = 0;

	/*
	 * Attack data
	 */

	UPROPERTY(BlueprintReadWrite)
	FHitDataCommon HitCommon = {};
	UPROPERTY(BlueprintReadWrite)
	FHitData NormalHit = {};
	UPROPERTY(BlueprintReadWrite)
	FHitData CounterHit = {};
	uint32 AttackFlags = 0;

	/*
	 * Received attack data
	 */

	UPROPERTY(BlueprintReadOnly)
	FHitDataCommon ReceivedHitCommon = {};
	UPROPERTY(BlueprintReadOnly)
	FHitData ReceivedHit = {};
	int32 StunTime = 0;
	int32 StunTimeMax = 0;
	int32 Hitstop = 0;

	/*
	 * Registers
	*/
	
	//The following values are per-action registers. Shared between the player and its child objects.
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg4 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg5 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg6 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg7 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ActionReg8 = 0;

	//The following values are per-object registers.
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg4 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg5 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg6 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg7 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 ObjectReg8 = 0;

	/*
	 * Subroutine registers. These are set when calling a subroutine, and reset upon round end.
	 */
	UPROPERTY(BlueprintReadOnly)
	int32 SubroutineReg1 = 0;
	UPROPERTY(BlueprintReadOnly)
	int32 SubroutineReg2 = 0;
	UPROPERTY(BlueprintReadOnly)
	int32 SubroutineReg3 = 0;
	UPROPERTY(BlueprintReadOnly)
	int32 SubroutineReg4 = 0;

	/*
	 * Subroutine return values. Subroutines can optionally return values.
	 * These are reset upon the next called subroutine.
	*/
	UPROPERTY(BlueprintReadWrite)
	int32 SubroutineReturnVal1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SubroutineReturnVal2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SubroutineReturnVal3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 SubroutineReturnVal4 = 0;

	/*
	 * Action data
	 */

	UPROPERTY(BlueprintReadOnly)
	int32 ActionTime = 0;
	/*
	 * The current cel name.
	 * Cels map to collision data.
	 * The collision frame also stores animation data.
	 */
	FGameplayTag CelName = {};
	/*
	 * The blend cel name.
	 * This is used to make traditional 3D animations.
	 */
	FGameplayTag BlendCelName = {};
	/*
	 * The name of the label that is currently being jumped to.
	 */
	FGameplayTag LabelName = {};

	UPROPERTY(BlueprintReadOnly)
	float AnimBlendIn{};
	UPROPERTY(BlueprintReadOnly)
	float AnimBlendOut{};
	// Are we jumping to a label right now?
	UPROPERTY(BlueprintReadWrite)
	bool GotoLabelActive = false;
	UPROPERTY(BlueprintReadWrite)
	int32 AnimFrame = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 BlendAnimFrame = 0;
	UPROPERTY(BlueprintReadWrite)
	float FrameBlendPosition = 0;
	// The index of the current cel in blueprint.
	UPROPERTY(BlueprintReadWrite)
	int32 CelIndex = 0;
	// How long until the next cel activates.
	UPROPERTY(BlueprintReadOnly)
	int32 TimeUntilNextCel = 0;
	// Max time of the cel.
	int32 MaxCelTime = 0;
	// Event handlers for every function.
	FEventHandler EventHandlers[EVT_NUM] = {};

	/*
	 * Action data for objects only.
	 */
	FGameplayTag ObjectStateName = {};
	uint32 ObjectID = 0;

protected:
	/*
	 * Collision data
	 */
	int32 PushHeight = 0;
	int32 PushHeightLow = 0;
	int32 PushWidth = 0;
	int32 PushWidthExtend = 0;

public:
	/*
	 * Push collision
	 */

	int32 L = 0;
	int32 R = 0;
	int32 T = 0;
	int32 B = 0;

	/*
	 * Socket data
	 */
	FName SocketName = {};
	EObjType SocketObj = OBJ_Self;
	FVector SocketOffset = FVector::ZeroVector;

	//material parameters
	UPROPERTY(BlueprintReadWrite)
	FLinearColor MulColor = FLinearColor(1, 1, 1, 1);
	UPROPERTY(BlueprintReadWrite)
	FLinearColor AddColor = FLinearColor(0, 0, 0, 1);
	UPROPERTY(BlueprintReadWrite)
	FLinearColor MulFadeColor = {};
	UPROPERTY(BlueprintReadWrite)
	FLinearColor AddFadeColor = {};
	UPROPERTY(BlueprintReadWrite)
	float MulFadeSpeed = 0;
	UPROPERTY(BlueprintReadWrite)
	float AddFadeSpeed = 0;
	UPROPERTY(BlueprintReadWrite)
	float Transparency = 1;
	UPROPERTY(BlueprintReadWrite)
	float FadeTransparency = 1;
	UPROPERTY(BlueprintReadWrite)
	float TransparencySpeed = 0;
	UPROPERTY(BlueprintReadWrite)
	FLinearColor DamageColor = FLinearColor(1, 1, 1, 1);
	UPROPERTY(BlueprintReadWrite)
	FLinearColor DamageColor2 = FLinearColor(1, 1, 1, 1);

	/*
	 * Miscellaneous data
	 */
	int32 ColPosX = 0;
	int32 ColPosY = 0;
	int32 MiscFlags = 0;
	int32 Timer0 = 0;
	int32 Timer1 = 0;
	bool IsPlayer = false;
	bool IsActive = false;
	UPROPERTY(BlueprintReadWrite)
	int32 DrawPriority = 0; // the higher the number, the farther in front the object will be drawn

	UPROPERTY(BlueprintReadWrite)
	bool bRender = true;

	UPROPERTY(BlueprintReadWrite)
	FHomingParams HomingParams = FHomingParams();
	UPROPERTY(BlueprintReadWrite)
	FSuperArmorData SuperArmorData = FSuperArmorData();

	UPROPERTY(BlueprintReadOnly)
	int32 UpdateTime = 0;

	/*
	 * Visual object transform
	 */
	UPROPERTY(BlueprintReadWrite)
	FVector ObjectOffset = FVector::ZeroVector;
	UPROPERTY(BlueprintReadWrite)
	FRotator ObjectRotation = FRotator::ZeroRotator;
	UPROPERTY(BlueprintReadWrite)
	FVector ObjectScale = FVector::One();

	/*
	 * Object pointers.
	 */

	// Pointer to player object. If this is not a player, it will point to the owning player.
	UPROPERTY(BlueprintReadOnly)
	APlayerObject* Player = nullptr;
	UPROPERTY(BlueprintReadOnly)
	ABattleObject* AttackOwner;
	UPROPERTY(BlueprintReadOnly)
	ABattleObject* AttackTarget = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ABattleObject* PositionLinkObj = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ABattleObject* DrawPriorityLinkObj = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ABattleObject* StopLinkObj = nullptr;
	UPROPERTY(BlueprintReadWrite)
	ABattleObject* MaterialLinkObj = nullptr;

	int32 ObjectStateIndex = 0;
	bool bIsCommonState = false;

	// Anything past here isn't saved or loaded for rollback, unless it has the SaveGame tag.
	unsigned char ObjSyncEnd = 0;

	UPROPERTY(SaveGame)
	TArray<ABattleObject*> ObjectsToIgnoreHitsFrom;

	UPROPERTY(BlueprintReadOnly, SaveGame)
	TArray<FCollisionBox> Boxes;

	/*
	 * Link data (for object), not serialized
	 */

	UPROPERTY(SaveGame)
	TObjectPtr<ALinkActor> LinkedActor;
	UPROPERTY()
	TObjectPtr<UNiagaraComponent> LinkedParticle = nullptr;

	uint32 ObjNumber = 0;

	UPROPERTY(BlueprintReadWrite, SaveGame)
	float ScreenSpaceDepthOffset = 0;
	UPROPERTY(BlueprintReadWrite, SaveGame)
	float OrthoBlendActive = 0;

	UPROPERTY(SaveGame)
	TArray<FAnimStruct> AnimStructs;
	
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<ANightSkyGameState> GameState = nullptr;
	UPROPERTY()
	TObjectPtr<ANightSkyCharaSelectGameState> CharaSelectGameState = nullptr;

	UPROPERTY()
	TObjectPtr<UState> ObjectState = nullptr;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	// Moves object
	void Move();
	void CalculateHoming();
	bool SuperArmorSuccess(const ABattleObject* Attacker) const;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;
	void PositionLinkUpdate();
	//calculate pushbox
	void CalculatePushbox();
	//handles pushing objects
	void HandlePushCollision(ABattleObject* OtherObj);
	//handles hitting objects
	void HandleHitCollision(ABattleObject* AttackedObj);
	//initializes hit data by attack level
	FHitData InitHitDataByAttackLevel(bool IsCounter);
	//handles object clashes
	void HandleClashCollision(ABattleObject* OtherObj);
	//handles flip
	void HandleFlip();
	void TriggerEvent(EEventType EventType, FGameplayTag StateMachineName);
	void UpdateCel();
	
	UFUNCTION(BlueprintCallable)
	void CollisionView();

	void SaveForRollback(unsigned char* Buffer) const;
	void LoadForRollback(const unsigned char* Buffer);

protected:
	void FuncCall(const FName& FuncName) const;
	UNightSkyAnimSequenceUserData* GetAnimSequenceUserData(const FName PartName) const;
	TArray<UNightSkyAnimSequenceUserData*> GetAnimSequenceUserDatas() const;

public:
	// Cannot be called on player objects. Initializes the object for use.
	void InitObject();
	// update object
	virtual void Update();
	// update visuals
	virtual void UpdateVisuals();
	virtual void UpdateVisualsNoRollback();
	UFUNCTION(BlueprintImplementableEvent)
	void UpdateVisuals_BP();

	void GetBoxes();

	// resets object for next use
	void ResetObject();

	/*
	 * Blueprint callable functions.
	 */

	UFUNCTION(BlueprintPure)
	UAnimSequenceBase* GetAnimSequenceForPart(const FName Part) const;
	UFUNCTION(BlueprintPure)
	UPaperFlipbook* GetFlipbookForPart(const FName Part) const;
	UFUNCTION(BlueprintPure)
	bool IsStopped() const;
	UFUNCTION(BlueprintPure)
	bool IsTimerPaused() const;
	//calls subroutine
	UFUNCTION(BlueprintCallable)
	void CallSubroutine(FGameplayTag Name);
	//calls subroutine
	UFUNCTION(BlueprintCallable)
	void CallSubroutineWithArgs(FGameplayTag Name, int32 Arg1, int32 Arg2, int32 Arg3, int32 Arg4);
	//initializes event handler
	UFUNCTION(BlueprintCallable)
	void InitEventHandler(EEventType EventType, FName FuncName, int32 Value, FGameplayTag SubroutineName);
	//initializes event handler
	UFUNCTION(BlueprintCallable)
	void RemoveEventHandler(EEventType EventType);
	//gets cel name
	UFUNCTION(BlueprintPure)
	FGameplayTag GetCelName() const;
	//gets label name
	UFUNCTION(BlueprintPure)
	FGameplayTag GetLabelName() const;
	//sets cel name
	UFUNCTION(BlueprintCallable)
	void SetCelName(FGameplayTag InName);
	//sets cel name
	UFUNCTION(BlueprintCallable)
	void SetBlendCelName(FGameplayTag InName);
	//jumps to label
	UFUNCTION(BlueprintCallable)
	void GotoLabel(FGameplayTag InName);
	//sets time until next cel
	UFUNCTION(BlueprintCallable)
	void SetTimeUntilNextCel(int32 InTime);
	// sets cel duration
	UFUNCTION(BlueprintCallable)
	void SetCelDuration(int32 InTime);
	//adds x position
	UFUNCTION(BlueprintCallable)
	void AddPosXWithDir(int InPosX);
	// applies root motion
	UFUNCTION(BlueprintCallable)
	void ApplyRootMotion();
	//sets x speed
	UFUNCTION(BlueprintCallable)
	void SetSpeedXRaw(int InSpeedX);
	//adds x speed
	UFUNCTION(BlueprintCallable)
	void AddSpeedXRaw(int InSpeedX);
	//gets y center
	UFUNCTION(BlueprintPure)
	int32 GetPosYCenter() const;
	// Sets pitch.
	UFUNCTION(BlueprintCallable)
	void SetPitch(int32 Pitch_x1000);
	// Sets pitch.
	UFUNCTION(BlueprintCallable)
	void SetYaw(int32 Yaw_x1000);
	// Sets pitch.
	UFUNCTION(BlueprintCallable)
	void SetRoll(int32 Roll_x1000);
	// Normalizes angle to between 0 and 360 degrees.
	UFUNCTION(BlueprintPure)
	static int32 NormalizeAngle(int32 Angle_x1000);
	//calculates angle between points
	UFUNCTION(BlueprintPure)
	int32 CalculateSpeedAngle() const;
	//calculates distance between points
	UFUNCTION(BlueprintPure)
	int32 CalculateDistanceBetweenPoints(EDistanceType Type, EObjType Obj1, EPosType Pos1, EObjType Obj2,
	                                     EPosType Pos2);
	//calculates angle between points
	UFUNCTION(BlueprintPure)
	int32 CalculateAngleBetweenPoints(EObjType Obj1, EPosType Pos1, EObjType Obj2, EPosType Pos2);
	//gets position from pos type
	UFUNCTION(BlueprintPure)
	void PosTypeToPosition(EPosType Type, int32& OutPosX, int32& OutPosY) const;
	UFUNCTION(BlueprintPure)
	void ScreenPosToWorldPos(const int32 X, const int32 Y, int32& OutX, int32& OutY) const;
	//sets direction
	UFUNCTION(BlueprintCallable)
	void SetFacing(EObjDir NewDir);
	//flips character
	UFUNCTION(BlueprintCallable)
	void FlipObject();
	//forcibly face opponent
	UFUNCTION(BlueprintCallable)
	void FaceOpponent();
	//check if grounded
	UFUNCTION(BlueprintPure)
	bool CheckIsGrounded() const;
	//enables hit
	UFUNCTION(BlueprintCallable)
	void EnableHit(bool Enabled);
	//sets attacking. while this is true, you can be counter hit, but you can hit the opponent and chain cancel.
	UFUNCTION(BlueprintCallable)
	void SetAttacking(bool Attacking);
	UFUNCTION(BlueprintCallable)
	void SetPlayerHit(bool Enable);
	UFUNCTION(BlueprintCallable)
	void SetProjectileAttribute(bool Attribute);
	UFUNCTION(BlueprintCallable)
	void SetProrateOnce(bool Once);
	UFUNCTION(BlueprintCallable)
	void SetIgnoreOTG(bool Ignore);
	UFUNCTION(BlueprintCallable)
	void SetHitOTG(bool Enable);
	UFUNCTION(BlueprintCallable)
	void SetIgnorePushbackScaling(bool Ignore);
	UFUNCTION(BlueprintCallable)
	void SetIgnoreHitstunScaling(bool Ignore);
	//enables flip
	UFUNCTION(BlueprintCallable)
	void EnableFlip(bool Enabled);
	//enables inertia
	UFUNCTION(BlueprintCallable)
	void EnableInertia();
	//disables inertia
	UFUNCTION(BlueprintCallable)
	void DisableInertia();
	//halts momentum
	UFUNCTION(BlueprintCallable)
	void HaltMomentum();
	//should wall collision be used?
	UFUNCTION(BlueprintCallable)
	void SetWallCollisionActive(bool Active);
	//should floor collision be used?
	UFUNCTION(BlueprintCallable)
	void SetFloorCollisionActive(bool Active);
	//should push collision be used?
	UFUNCTION(BlueprintCallable)
	void SetPushCollisionActive(bool Active);
	//set push width extend
	UFUNCTION(BlueprintCallable)
	void SetPushWidthExtend(int32 Extend);
	//creates common particle
	UFUNCTION(BlueprintCallable)
	void CreateCommonParticle(FGameplayTag Name, EPosType PosType, FVector Offset = FVector::ZeroVector,
	                          FRotator Rotation = FRotator::ZeroRotator);
	//creates character particle
	UFUNCTION(BlueprintCallable)
	void CreateCharaParticle(FGameplayTag Name, EPosType PosType, FVector Offset = FVector::ZeroVector,
	                         FRotator Rotation = FRotator::ZeroRotator);
	//creates common particle and attaches it to the object. can only be used with non-player objects.
	UFUNCTION(BlueprintCallable)
	void LinkCommonParticle(FGameplayTag Name);
	//creates character particle and attaches it to the object. can only be used with non-player objects.
	UFUNCTION(BlueprintCallable)
	void LinkCharaParticle(FGameplayTag Name);
	//gets link actor and attaches it to the object. can only be used with non-player objects.
	UFUNCTION(BlueprintCallable)
	ALinkActor* LinkActor(FGameplayTag Name);
	UFUNCTION(BlueprintCallable)
	void RemoveLinkActor();
	//plays common sound
	UFUNCTION(BlueprintCallable)
	void PlayCommonSound(FGameplayTag Name);
	//plays chara sound
	UFUNCTION(BlueprintCallable)
	void PlayCharaSound(FGameplayTag Name);
	//attaches object to skeletal socket
	UFUNCTION(BlueprintCallable)
	void AttachToSocketOfObject(FName InSocketName, FVector Offset, EObjType ObjType);
	//detaches object from skeletal socket
	UFUNCTION(BlueprintCallable)
	void DetachFromSocket();
	UFUNCTION(BlueprintCallable)
	void CameraShake(FGameplayTag PatternName, int32 Scale);
	//generate random number
	UFUNCTION(BlueprintPure)
	int32 GenerateRandomNumber(int32 Min, int32 Max) const;
	// starts super freeze
	UFUNCTION(BlueprintCallable)
	void StartSuperFreeze(int Duration, int SelfDuration = 0);
	// ignore super freeze
	UFUNCTION(BlueprintCallable)
	void IgnoreSuperFreeze(bool Ignore);
	//sets object id
	UFUNCTION(BlueprintCallable)
	void SetObjectID(int InObjectID);
	//gets object by type
	UFUNCTION(BlueprintPure)
	ABattleObject* GetBattleObject(EObjType Type);
	//creates common object
	UFUNCTION(BlueprintCallable)
	ABattleObject* AddCommonBattleObject(FGameplayTag InStateName, int32 PosXOffset = 0, int32 PosYOffset = 0,
	                                     EPosType PosType = POS_Player);
	//creates object
	UFUNCTION(BlueprintCallable)
	ABattleObject* AddBattleObject(FGameplayTag InStateName, int32 PosXOffset = 0, int32 PosYOffset = 0,
	                               EPosType PosType = POS_Player);
	//if object goes beyond screen bounds, deactivate
	UFUNCTION(BlueprintCallable)
	void EnableDeactivateIfBeyondBounds(bool Enable);
	//if player changes state, deactivate
	UFUNCTION(BlueprintCallable)
	void EnableDeactivateOnStateChange(bool Enable);
	//if player receives hit, deactivate
	UFUNCTION(BlueprintCallable)
	void EnableDeactivateOnReceiveHit(bool Enable);
	// Cannot be called on player objects. Deactivates the object and returns it to the pool.
	UFUNCTION(BlueprintCallable)
	void DeactivateObject();
	UFUNCTION(BlueprintPure)
	bool CheckBoxOverlap(ABattleObject* OtherObj, const EBoxType SelfType, const FGameplayTag SelfCustomType,
	                     const EBoxType OtherType, const FGameplayTag OtherCustomType);
	UFUNCTION(BlueprintPure)
	void GetBoxPosition(const EBoxType BoxType, const FGameplayTag CustomType, int& OutPosX, int& OutPosY) const;
	UFUNCTION(BlueprintPure)
	int32 GetGauge(int32 GaugeIndex) const;
	UFUNCTION(BlueprintCallable)
	void SetGauge(int32 GaugeIndex, int32 Value);
	UFUNCTION(BlueprintCallable)
	void UseGauge(int32 GaugeIndex, int32 Value);

	// Handles custom collision. Activates before clash or hit collision.
	UFUNCTION(BlueprintImplementableEvent)
	void HandleCustomCollision_PreHit(ABattleObject* OtherObj);
	// Handles custom collision. Activates after clash and hit collision.
	UFUNCTION(BlueprintImplementableEvent)
	void HandleCustomCollision_PostHit(ABattleObject* OtherObj);
};

constexpr size_t SizeOfBattleObject = offsetof(ABattleObject, ObjSyncEnd) - offsetof(ABattleObject, ObjSync);

#if WITH_EDITOR
static_assert(offsetof(FBattleObjectLog, ObjSyncEnd) - offsetof(FBattleObjectLog, ObjSync) == SizeOfBattleObject,
              "FBattleObjectLog must contain all members from ABattleObject between ObjSync and ObjSyncEnd");
#endif

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/PlayerObject.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "PlayerObject.h"

#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "NightSkyEngine/Battle/Actors/LinkActor.h"
#include "NightSkyEngine/Battle/Script/Subroutine.h"
#include "NightSkyEngine/Data/LinkActorData.h"
#include "NightSkyEngine/Data/ParticleData.h"
#include "NightSkyEngine/Data/SubroutineData.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "Serialization/ObjectReader.h"
#include "Serialization/ObjectWriter.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(PlayerObject)

UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Blowback_1, "State.Label.Blowback.1", "Blowback Label 1");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Blowback_2, "State.Label.Blowback.2", "Blowback Label 2");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Blowback_3, "State.Label.Blowback.3", "Blowback Label 3");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Blowback_4, "State.Label.Blowback.4", "Blowback Label 4");

UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Block_PreGuard, "State.Label.Block.PreGuard", "Block Label Pre Guard");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Block_Level1, "State.Label.Block.Level1", "Block Label Level 1");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Block_Level2, "State.Label.Block.Level2", "Block Label Level 2");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Block_Level3, "State.Label.Block.Level3", "Block Label Level 3");

UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_IsCorrectBlock, "Subroutine.Cmn.IsCorrectBlock", "Common Is Correct Block");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_HitCollision, "Subroutine.Cmn.HitCollision", "Common Hit Collision");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnBlock, "Subroutine.Cmn.OnBlock", "Common On Block");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnHit, "Subroutine.Cmn.OnHit", "Common On Hit");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnCounterHit, "Subroutine.Cmn.OnCounterHit", "Common On Counter Hit");

void FPlayerObjectLog::LogForSyncTestFile(std::ofstream& file)
{
	FBattleObjectLog::LogForSyncTestFile(file);
	if (file)
	{
		file << "PlayerObject:\n";
		file << "\tCurrentAirJumpCount: " << CurrentAirJumpCount << std::endl;
		file << "\tCurrentAirDashCount: " << CurrentAirDashCount << std::endl;
		file << "\tAirDashTimer: " << AirDashTimer << std::endl;
		file << "\tAirDashTimerMax: " << AirDashTimerMax << std::endl;
		file << "\tCurrentHealth: " << CurrentHealth << std::endl;
		file << "\tCancelFlags: " << CancelFlags << std::endl;
		file << "\tPlayerFlags: " << PlayerFlags << std::endl;
		file << "\tInputs: " << StoredInputBuffer.InputBufferInternal[InputBufferSize - 1] << std::endl;
		file << "\tStance: " << Stance.GetValue() << std::endl;
	}
}

APlayerObject::APlayerObject()
{
	PrimaryStateMachine.Parent = this;
	MiscFlags = MISC_PushCollisionActive | MISC_WallCollisionActive | MISC_FloorCollisionActive;
	CancelFlags = CNC_EnableKaraCancel | CNC_ChainCancelEnabled | CNC_EnableReverseBeat;
	PlayerFlags = PLF_DefaultLandingAction;
	FWalkSpeed = 7800;
	BWalkSpeed = 4800;
	FDashInitSpeed = 13000;
	FDashAccel = 600;
	FDashFriction = 95;
	FDashMaxSpeed = 38500;
	BDashSpeed = 14000;
	BDashHeight = 5200;
	BDashGravity = 700;
	JumpHeight = 35000;
	FJumpSpeed = 7900;
	BJumpSpeed = 5200;
	JumpGravity = 1900;
	SuperJumpHeight = 43700;
	FSuperJumpSpeed = 7900;
	BSuperJumpSpeed = 5200;
	SuperJumpGravity = 1900;
	AirDashMinimumHeight = 105000;
	FAirDashSpeed = 30000;
	BAirDashSpeed = 24500;
	FAirDashTime = 20;
	BAirDashTime = 12;
	FAirDashNoAttackTime = 5;
	BAirDashNoAttackTime = 5;
	AirJumpCount = 1;
	AirDashCount = 1;
	Stance = ACT_Standing;
	StandPushWidth = 110000;
	StandPushHeight = 240000;
	CrouchPushWidth = 120000;
	CrouchPushHeight = 180000;
	AirPushWidth = 100000;
	AirPushHeight = 275000;
	AirPushHeightLow = -135000;
	IsPlayer = true;
	IsActive = true;
	MaxHealth = 10000;
	ForwardWalkMeterGain = 12;
	ForwardJumpMeterGain = 10;
	ForwardDashMeterGain = 25;
	ForwardAirDashMeterGain = 25;
	PushWidth = StandPushWidth;
	PushHeight = StandPushHeight;
	PushHeightLow = 0;
	AttackFlags = 0;
	for (bool& Visible : ComponentVisible)
		Visible = true;

	PrimaryStateMachine.bPrimary = true;
	PrimaryStateMachine.StateMachineName = StateMachine_Primary;
	std::fill_n(StoredInputBuffer.InputBufferInternal, InputBufferSize, INP_Neutral);
}

void APlayerObject::BeginPlay()
{
	Super::BeginPlay();

	if (CommonLinkActorData != nullptr)
	{
		for (FLinkActorStruct LinkedActorStruct : CommonLinkActorData->LinkedActorStructs)
		{
			for (int i = 0; i < LinkedActorStruct.MaxInstances; i++)
			{
				auto Actor = GetWorld()->SpawnActor<ALinkActor>(LinkedActorStruct.ActorClass);
				Actor->SetActorHiddenInGame(true);
				FLinkedActorContainer Container{Actor, LinkedActorStruct.Name, StoredLinkActors.Num(), false};
				StoredLinkActors.Add(Container);
			}
		}
	}

	if (LinkActorData != nullptr)
	{
		for (FLinkActorStruct LinkedActorStruct : LinkActorData->LinkedActorStructs)
		{
			for (int i = 0; i < LinkedActorStruct.MaxInstances; i++)
			{
				auto Actor = GetWorld()->SpawnActor<ALinkActor>(LinkedActorStruct.ActorClass);
				Actor->SetActorHiddenInGame(true);
				FLinkedActorContainer Container{Actor, LinkedActorStruct.Name, StoredLinkActors.Num(), false};
				StoredLinkActors.Add(Container);
			}
		}
	}

	InitPlayer();
}

void APlayerObject::HandleLanding()
{
	if (PosY <= GroundHeight && PrevPosY > GroundHeight) // trigger landing
	{
		PrevPosY = PosY;
		CurrentAirJumpCount = AirJumpCount;
		CurrentAirDashCount = AirDashCount;
		SpeedX = 0;
		if (PlayerFlags & PLF_DefaultLandingAction && PrimaryStateMachine.CurrentState->StateType !=
			EStateType::Hitstun)
		{
			JumpToStatePrimary(State_Universal_JumpLanding);
		}
		SetStance(ACT_Standing);
		TriggerEvent(EVT_Landing, StateMachine_Primary);
		CallSubroutine(Subroutine_Cmn_OnLanding);
		CallSubroutine(Subroutine_OnLanding);
		CreateCommonParticle(Particle_JumpSmoke_Land, POS_Player);
		if (PrimaryStateMachine.CurrentState->StateType != EStateType::Hitstun) PlayCommonSound(Sound_Land);
		BufferedStateName = FGameplayTag::EmptyTag;
	}
}

uint32 APlayerObject::FlipInput(uint32 Input)
{
	const unsigned int Bit1 = Input >> 2 & 1;
	const unsigned int Bit2 = Input >> 3 & 1;
	unsigned int x = Bit1 ^ Bit2;

	x = x << 2 | x << 3;

	return Input ^ x;
}

void APlayerObject::InitPlayer()
{
	Player = this;
	CurrentHealth = MaxHealth;
	EnableFlip(true);

	EmptyStateMachine();
	
	if (!CharaStateData) return;
	
	for (auto StateClass : CharaStateData->StateArray)
	{
		if (!IsValid(StateClass)) continue;
		auto State = NewObject<UState>(this, StateClass);
		AddState(State->Name, State, StateMachine_Primary);
	}
	for (auto SubStatePair : SubStateData)
	{
		for (auto StateClass : SubStatePair.Value->StateArray)
		{
			if (!IsValid(StateClass)) continue;
			auto State = NewObject<UState>(this, StateClass);
			AddState(State->Name, State, SubStatePair.Key);
		}
	}
	if (IsValid(CommonSubroutineData))
	{
		for (auto SubroutineClass : CommonSubroutineData->SubroutineArray)
		{
			if (!IsValid(SubroutineClass)) continue;
			auto Subroutine = NewObject<USubroutine>(this, SubroutineClass);
			AddSubroutine(Subroutine->Name, Subroutine, true);
		}
	}
	if (IsValid(CharaSubroutineData))
	{
		for (auto SubroutineClass : CharaSubroutineData->SubroutineArray)
		{
			if (!IsValid(SubroutineClass)) continue;
			auto Subroutine = NewObject<USubroutine>(this, SubroutineClass);
			AddSubroutine(Subroutine->Name, Subroutine, false);
		}
	}
	if (IsValid(CommonObjectStateData))
	{
		for (auto StateClass : CommonObjectStateData->StateArray)
		{
			if (!IsValid(StateClass)) continue;

			for (int i = 0; i < StateClass.GetDefaultObject()->MaxInstances; i++)
			{
				auto State = NewObject<UState>(this, StateClass);
				AddObjectState(State->Name, State, true);
			}
		}
	}
	if (IsValid(ObjectStateData))
	{
		for (auto StateClass : ObjectStateData->StateArray)
		{
			if (!IsValid(StateClass)) continue;

			for (int i = 0; i < StateClass.GetDefaultObject()->MaxInstances; i++)
			{
				auto State = NewObject<UState>(this, StateClass);
				AddObjectState(State->Name, State, false);
			}
		}
	}
}

void APlayerObject::HandleStateMachine(bool Buffer, FStateMachine& StateMachine)
{
	BufferedStateName = FGameplayTag::EmptyTag;
	for (int i = StateMachine.States.Num() - 1; i >= 0; i--)
	{
		if (CanEnterState(StateMachine.States[i], StateMachine.StateMachineName))
		{
			if (HandleAutoCombo(i, StateMachine)) return;
			if (HandleStateInputs(i, Buffer, StateMachine))
			{
				bIsAutoCombo = false;
				return;
			}
		}
		else
		{
			PlayerFlags &= ~PLF_DidKaraCancel;
		}
	}
}

bool APlayerObject::HandleAutoCombo(int32 StateIndex, FStateMachine& StateMachine)
{
	if (!FindAutoComboCancelOption(StateMachine.States[StateIndex]->Name, StateMachine)) return false;

	bool AutoComboSuccess = false;
	for (int i = 0; i < 8; i++)
	{
		const auto AutoComboCancel = AutoComboCancels[i];
		if (AutoComboCancel != StateIndex) continue;

		EInputFlags Button;
		switch (i)
		{
		case 0:
			Button = INP_A;
			break;
		case 1:
			Button = INP_A;
			break;
		case 2:
			Button = INP_A;
			break;
		case 3:
			Button = INP_A;
			break;
		case 4:
			Button = INP_A;
			break;
		case 5:
			Button = INP_A;
			break;
		case 6:
			Button = INP_A;
			break;
		case 7:
			Button = INP_A;
			break;
		default:
			Button = INP_A;
			break;
		}

		FInputCondition AutoComboCondition;
		AutoComboCondition.Sequence.Add(FInputBitmask(Button));
		AutoComboCondition.Sequence.Last().Lenience = 0;
		AutoComboCondition.Method = EInputMethod::Once;

		if (CheckInput(AutoComboCondition))
		{
			AutoComboSuccess = true;
			break;
		}
	}

	if (!AutoComboSuccess) return false;

	bIsAutoCombo = HandleStateTransition(StateIndex, true, StateMachine);
	return bIsAutoCombo;
}

bool APlayerObject::HandleStateInputs(int32 StateIndex, bool Buffer, FStateMachine& StateMachine)
{
	for (FInputConditionList& List : StateMachine.States[StateIndex]->InputConditionLists)
	{
		for (int v = 0; v < List.InputConditions.Num(); v++) //iterate over input conditions
		{
			//check input condition against input buffer, if not met break.
			if (!StoredInputBuffer.CheckInputCondition(List.InputConditions[v]))
			{
				break;
			}
			if (v == List.InputConditions.Num() - 1) //have all conditions been met?
			{
				return HandleStateTransition(StateIndex, Buffer, StateMachine);
			}
		}
		if (List.InputConditions.Num() == 0) //if no input conditions, set state
		{
			return HandleStateTransition(StateIndex, Buffer, StateMachine);
		}
	}
	return false;
}

bool APlayerObject::HandleStateTransition(int32 StateIndex, bool Buffer, FStateMachine& StateMachine)
{
	if (FindChainCancelOption(StateMachine.States[StateIndex]->Name, StateMachine)
		|| FindAutoComboCancelOption(StateMachine.States[StateIndex]->Name, StateMachine)
		|| FindWhiffCancelOption(StateMachine.States[StateIndex]->Name, StateMachine)
		|| CancelFlags & CNC_CancelIntoSelf) //if cancel option, allow resetting state
	{
		if (Buffer)
		{
			BufferedStateName = StateMachine.States[StateIndex]->Name;
			return true; //don't try to enter another state
		}
		if (StateMachine.ForceSetState(StateMachine.States[StateIndex]->Name)) //if state set successful...
		{
			GotoLabelActive = false;
			switch (StateMachine.States[StateIndex]->EntryStance)
			{
			case EEntryStance::Standing:
				Stance = ACT_Standing;
				break;
			case EEntryStance::Crouching:
				Stance = ACT_Crouching;
				break;
			case EEntryStance::Jumping:
				Stance = ACT_Jumping;
				break;
			default:
				break;
			}
			return true; //don't try to enter another state
		}
	}
	else
	{
		if (Buffer)
		{
			BufferedStateName = StateMachine.States[StateIndex]->Name;
			return true; //don't try to enter another state
		}
		if (StateMachine.SetState(StateMachine.States[StateIndex]->Name)) //if state set successful...
		{
			GotoLabelActive = false;
			switch (StateMachine.States[StateIndex]->EntryStance)
			{
			case EEntryStance::Standing:
				Stance = ACT_Standing;
				break;
			case EEntryStance::Crouching:
				Stance = ACT_Crouching;
				break;
			case EEntryStance::Jumping:
				Stance = ACT_Jumping;
				break;
			default:
				break;
			}
			return true; //don't try to enter another state
		}
	}
	return false; //state couldn't be entered
}

void APlayerObject::Update()
{
	if ((PlayerFlags & PLF_IsOnScreen) == 0)
	{
		return;
	}

	if (Inputs << 27 == 0) //if no direction, set neutral input
		Inputs |= INP_Neutral;
	else
		Inputs = Inputs & ~INP_Neutral; //remove neutral input if directional input

	if (Inputs >> 5 != StoredInputBuffer.InputBufferInternal[InputBufferSize - 1] >> 5)
	{
		IntroEndFlag = true;
		if (RoundWinTimer <= 0 || (bIsCpu && Enemy->IntroEndFlag))
		{
			RoundEndFlag = true;
		}
	}

	Super::Update();
	CallSubroutine(Subroutine_Cmn_OnUpdate);
	CallSubroutine(Subroutine_OnUpdate);

	if (GameState->GameInstance->IsTraining)
	{
		if ((PlayerFlags & PLF_IsStunned) == 0)
		{
			CurrentHealth = MaxHealth;
			RecoverableHealth = 0;
		}
		if ((AttackFlags & ATK_IsAttacking) == 0 && ComboTimer <= 0)
		{
			GameState->BattleState.Meter[PlayerIndex] = GameState->BattleState.MaxMeter[PlayerIndex];
			for (int i = 0; i < GameState->BattleState.MaxGauge.Num(); i++)
			{
				if (PlayerIndex == 0) GameState->BattleState.GaugeP1[i] = GameState->BattleState.MaxGauge[i];
				else GameState->BattleState.GaugeP2[i] = GameState->BattleState.MaxGauge[i];
			}
		}
		if (PlayerIndex == 1)
		{
			if (CheckIsStunned())
				Inputs = INP_A;
			else
				Inputs = INP_Neutral;
		}
	}

	if (GameState->BattleState.TimeUntilRoundStart > 0)
		Inputs = INP_Neutral;

	HandleFlipInput();
	
	if (ComboCounter > 0)
		ComboTimer++;

	if (PlayerFlags & PLF_IsThrowLock)
	{
		if (!bIsCpu) StoredInputBuffer.Update(Inputs, IsStopped());

		HandleStateMachine(true, PrimaryStateMachine); //handle state transitions
		PrimaryStateMachine.Update();

		for (auto& StateMachine : SubStateMachines)
		{
			HandleStateMachine(false, StateMachine);
			StateMachine.Update();
		}

		UpdateCel();

		if (ActionTime < ThrowTechTimer)
		{
			if (PrimaryStateMachine.GetStateIndex(State_Universal_Throw) != INDEX_NONE)
			{
				bool IsTech = true;
				if (!CanProximityThrow)
				{
					const auto ThrowState = PrimaryStateMachine.States[PrimaryStateMachine.GetStateIndex(
						State_Universal_Throw)];
					for (auto InputConditionList : ThrowState->InputConditionLists)
					{
						IsTech = true;
						for (auto InputCondition : InputConditionList.InputConditions)
						{
							if (!CheckInput(InputCondition))
							{
								IsTech = false;
								break;
							}
						}
						if (IsTech == true) break;
					}
				}
				else
				{
					FInputCondition Left;
					FInputBitmask BitmaskLeft;
					BitmaskLeft.InputFlag = INP_Left;
					BitmaskLeft.Lenience = 1;
					Left.Sequence.Add(BitmaskLeft);
					Left.Method = EInputMethod::Strict;
					FInputCondition Right;
					FInputBitmask BitmaskRight;
					BitmaskRight.InputFlag = INP_Right;
					BitmaskRight.Lenience = 1;
					Right.Sequence.Add(BitmaskRight);
					Right.Method = EInputMethod::Strict;
					if (!CheckInput(ProximityThrowInput) || (!CheckInput(Left) && !CheckInput(Right)))
					{
						IsTech = false;
					}
				}
				if (IsTech)
				{
					PlayerFlags &= ~PLF_IsThrowLock;
					FaceOpponent();
					if (Enemy->Stance != ACT_Jumping)
					{
						JumpToStatePrimary(State_Universal_GuardBreakStand);
						Enemy->JumpToStatePrimary(State_Universal_GuardBreakStand);
						InitEventHandler(EVT_Update, "ThrowTech", 0, FGameplayTag::EmptyTag);
						Enemy->InitEventHandler(EVT_Update, "ThrowTech", 0, FGameplayTag::EmptyTag);
					}
					else
					{
						JumpToStatePrimary(State_Universal_GuardBreakAir);
						Enemy->JumpToStatePrimary(State_Universal_GuardBreakAir);
						InitEventHandler(EVT_Update, "ThrowTechAir", 0, FGameplayTag::EmptyTag);
						Enemy->InitEventHandler(EVT_Update, "ThrowTechAir", 0, FGameplayTag::EmptyTag);
					}
					ColPosX = (PosX + Enemy->PosX) / 2;
					ColPosY = (PosY + Enemy->PosY) / 2 + 250000;
					CreateCommonParticle(Particle_ThrowTech, POS_Col);
					return;
				}
			}
		}
		ActionTime++;
		return;
	}

	if (CurrentHealth <= 0 && (PlayerFlags & PLF_IsDead) == 0)
	{
		HandleBufferedState(PrimaryStateMachine);
		for (auto& StateMachine : SubStateMachines)
		{
			HandleBufferedState(StateMachine);
		}

		PlayerFlags |= PLF_IsDead;
		RecoverableHealth = 0;
		if (Enemy->CurrentHealth > 0)
		{
			if (IsMainPlayer())
			{
				if (!(PlayerFlags & PLF_DeathCamOverride) && AttackOwner)
				{
					if (ReceivedHitCommon.AttackLevel < 2)
					{
						AddCommonBattleObject(State_BattleObject_KO_S);
					}
					else if (ReceivedHitCommon.AttackLevel < 4)
					{
						AddCommonBattleObject(State_BattleObject_KO_M);
					}
					else
					{
						AddCommonBattleObject(State_BattleObject_KO_L);
					}
					Hitstop = 1;
					AttackOwner->Hitstop = 1;
				}
			}
		}
		if (Enemy->CurrentHealth == 0 && (Enemy->PlayerFlags & PLF_IsDead) == 0 && AttackOwner)
		{
			AddCommonBattleObject(State_BattleObject_KO_Draw);
			Hitstop = 1;
			AttackOwner->Hitstop = 1;
		}
		else if (!IsMainPlayer())
		{
			PlayerFlags &= ~PLF_IsOnScreen;
		}
	}

	if (Hitstop > 0)
	{
		if (PlayerFlags & PLF_IsStunned)
		{
			HandleBufferedState(PrimaryStateMachine);

			for (auto& StateMachine : SubStateMachines)
			{
				HandleBufferedState(StateMachine);
			}
		}
		GetBoxes();
		if (!bIsCpu) StoredInputBuffer.Update(Inputs, IsStopped());
		HandleStateMachine(true, PrimaryStateMachine); //handle state transitions
		for (auto& StateMachine : SubStateMachines)
		{
			HandleStateMachine(false, StateMachine);
		}
		return;
	}

	//reset moves used in combo if not currently doing combo 
	if (PrimaryStateMachine.CurrentState->StateType != EStateType::NormalAttack
		&& PrimaryStateMachine.CurrentState->StateType != EStateType::SpecialAttack
		&& PrimaryStateMachine.CurrentState->StateType != EStateType::SuperAttack)
	{
		MovesUsedInCombo.Empty();
	}

	if (!(AttackFlags & ATK_IsAttacking)) //enable kara cancel when not attacking
		CancelFlags |= CNC_EnableKaraCancel;

	if (StrikeInvulnerableTimer > 0)
		StrikeInvulnerableTimer--;
	if (ThrowInvulnerableTimer > 0)
		ThrowInvulnerableTimer--;
	if (ThrowResistTimer > 0)
		ThrowResistTimer--;

	if (MeterCooldownTimer > 0)
		MeterCooldownTimer--;

	if (!bIsCpu)
	{
		if (IsMainPlayer() && ((PlayerFlags & PLF_RoundWinInputLock) == 0
			|| GameState->BattleState.BattleFormat == EBattleFormat::Tag))
		{
			StoredInputBuffer.Update(Inputs, IsStopped());
		}
		else StoredInputBuffer.Update(INP_Neutral, IsStopped());
	}

	if (AirDashTimer > 0)
	{
		AirDashTimer--;
	}
	if (AirDashTimer == 1)
	{
		CallSubroutine(Subroutine_Cmn_AnyCancel_Air);
		SpeedX /= 2;
	}

	if (AirDashNoAttackTime > 0)
		AirDashNoAttackTime--;
	if (AirDashNoAttackTime == 1)
		EnableAttacks();

	if (StunTime > 0)
		StunTime--;
	if (StunTime <= 0 && !(PlayerFlags & PLF_IsDead) && CheckIsStunned())
	{
		if (PrimaryStateMachine.CurrentState->StateType == EStateType::Blockstun)
		{
			if (Stance == ACT_Standing)
			{
				JumpToStatePrimary(State_Universal_StandBlockEnd);
			}
			else if (Stance == ACT_Crouching)
			{
				JumpToStatePrimary(State_Universal_CrouchBlockEnd);
			}
			else
			{
				JumpToStatePrimary(State_Universal_AirBlockEnd);
			}
		}
		else if (PosY == GroundHeight && PrevPosY == GroundHeight 
			&& GetCurrentStateName(StateMachine_Primary) != State_Universal_Crumple 
			&& GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceDownBounce
			&& GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceUpBounce
			&& GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceDownLoop 
			&& GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceUpLoop
			&& GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceDownWakeUp 
			&& GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceUpWakeUp
		&& !(PlayerFlags & PLF_IsKnockedDown))
		{
			if (Stance == ACT_Crouching)
			{
				JumpToStatePrimary(State_Universal_Crouch);
			}
			else
			{
				JumpToStatePrimary(State_Universal_Stand);
			}
		}
		else
		{
			if (((PlayerFlags & PLF_IsKnockedDown) == 0 || (PlayerFlags & PLF_IsHardKnockedDown) == 0) && (PlayerFlags &
				PLF_IsDead) == 0)
				EnableState(ENB_Tech, StateMachine_Primary);
		}
	}

	if (PlayerFlags & PLF_TouchingWall && Enemy->PrimaryStateMachine.CurrentState->StateType != EStateType::Hitstun &&
		Pushback != 0)
	{
		if (IsValid(AttackOwner))
			AttackOwner->Pushback = Pushback;
		Pushback = 0;
	}

	if (PrimaryStateMachine.CurrentState->StateType != EStateType::Hitstun)
	{
		PlayerFlags &= ~PLF_IsKnockedDown;
	}

	if (PrimaryStateMachine.CurrentState->StateType != EStateType::Hitstun
		&& PrimaryStateMachine.CurrentState->StateType != EStateType::Blockstun)
	{
		if (Enemy->PrimaryStateMachine.CurrentState->StateType != EStateType::Hitstun
			&& Enemy->PrimaryStateMachine.CurrentState->StateType != EStateType::Blockstun)
			Pushback = 0;
	}

	if ((GetCurrentStateName(StateMachine_Primary) == State_Universal_FaceDownLoop ||
			GetCurrentStateName(StateMachine_Primary) == State_Universal_FaceUpLoop)
		&& ActionTime >= ReceivedHit.KnockdownTime && (PlayerFlags & PLF_IsDead) == 0)
	{
		HandleEndCombo();
		if (PrimaryStateMachine.CurrentState->Name == State_Universal_FaceDownLoop)
			JumpToStatePrimary(State_Universal_FaceDownWakeUp);
		else if (PrimaryStateMachine.CurrentState->Name == State_Universal_FaceUpLoop)
			JumpToStatePrimary(State_Universal_FaceUpWakeUp);
		PlayerFlags &= ~PLF_IsKnockedDown;
		DisableState(ENB_Tech, StateMachine_Primary);
	}

	if (PlayerFlags & PLF_IsDead)
		DisableState(ENB_Tech, StateMachine_Primary);

	InstantBlockLockoutTimer--;

	HandleProximityBlock();

	if (Stance == ACT_Standing) //set pushbox values based on stance
	{
		PushWidth = StandPushWidth;
		PushHeight = StandPushHeight;
		PushHeightLow = 0;
	}
	else if (Stance == ACT_Crouching)
	{
		PushWidth = CrouchPushWidth;
		PushHeight = CrouchPushHeight;
		PushHeightLow = 0;
	}
	else if (Stance == ACT_Jumping)
	{
		PushWidth = AirPushWidth;
		PushHeight = AirPushHeight;
		PushHeightLow = AirPushHeightLow;
	}
	
	HandleLanding();
	Move();
	HandleLanding();

	Player->PrimaryStateMachine.Update();
	for (auto& StateMachine : SubStateMachines)
	{
		StateMachine.Update();
	}

	TriggerEvent(EVT_Update, StateMachine_Primary);
	UpdateCel();

	if (PrimaryStateMachine.CurrentState->StateType == EStateType::Hitstun)
	{
		if (GetCurrentStateName(StateMachine_Primary) == State_Universal_FaceDownBounce
			|| GetCurrentStateName(StateMachine_Primary) == State_Universal_FaceUpBounce)
		{
			if (ReceivedHit.GroundBounce.GroundBounceCount > 0) HandleGroundBounce();
		}
	}

	for (auto& Gauge : ExtraGauges)
	{
		Gauge.Value = FMath::Clamp(Gauge.Value, 0, Gauge.MaxValue);
	}

	if (PrimaryStateMachine.CurrentState->StateType == EStateType::Hitstun && ReceivedHit.WallBounce.WallBounceCount > 0
		&& PosY > GroundHeight)
		HandleWallBounce();

	if (PosY > GroundHeight) //set jumping if above ground
		Stance = ACT_Jumping;

	HandleStateMachine(true, PrimaryStateMachine);
	HandleBufferedState(PrimaryStateMachine);
	for (auto& StateMachine : SubStateMachines)
	{
		HandleStateMachine(false, StateMachine);
		HandleBufferedState(StateMachine);
	}
	
	GetBoxes();

	HandleThrowCollision();
	
	if (CurrentHealth > MaxHealth) CurrentHealth = MaxHealth;

	ActionTime++;
}

void APlayerObject::UpdateNotBattle()
{
	Player->PrimaryStateMachine.Update();

	UpdateCel();
	GetBoxes();

	UpdateVisuals();
	UpdateVisualsNoRollback();
}

void APlayerObject::EditorUpdate_Implementation()
{
	Player = this;

	GetBoxes();
	UpdateVisuals();
	UpdateVisualsNoRollback();
}

void APlayerObject::HandleHitAction(EHitAction HACT)
{
	int32 FinalHitstop = ReceivedHit.Hitstop + ReceivedHit.EnemyHitstopModifier;

	Hitstop = FinalHitstop;

	int32 Proration = ReceivedHit.ForcedProration;
	if (Enemy->ComboCounter == 0)
		Proration *= ReceivedHit.InitialProration;
	else
		Proration *= 100;
	if (Enemy->ComboCounter == 0)
		TotalProration = 10000;
	Proration = Proration * TotalProration / 10000;

	if ((AttackFlags & ATK_ProrateOnce) == 0 || (AttackFlags & ATK_ProrateOnce && Enemy->ComboCounter == 0))
		TotalProration = Proration;
	else
		Proration = TotalProration;

	Enemy->ComboCounter++;

	if (ReceivedHitCommon.DeathCamOverride)
		PlayerFlags |= PLF_DeathCamOverride;

	else
		PlayerFlags &= ~PLF_DeathCamOverride;

	if (PlayerFlags & PLF_IsKnockedDown)
	{
		if (PosY <= GroundHeight)
			PosY = GroundHeight + 1;

		if (!(AttackOwner->AttackFlags & ATK_IgnoreOTG))
			OTGCount++;
		PlayerFlags &= ~PLF_IsKnockedDown;
	}
	else if (PlayerFlags & PLF_IsDead && PosY <= GroundHeight)
	{
		PosY = GroundHeight + 1;
	}

	int FinalDamage;
	if (Enemy->ComboCounter == 1)
		FinalDamage = ReceivedHit.Damage;
	else
		FinalDamage = ReceivedHit.Damage * Proration * Enemy->ComboRate / 10000 / 100;

	if (FinalDamage < ReceivedHit.MinimumDamagePercent * ReceivedHit.Damage / 100)
		FinalDamage = ReceivedHit.Damage * ReceivedHit.MinimumDamagePercent / 100;

	if (MaxOTGCount >= 0 && OTGCount > MaxOTGCount && !(AttackOwner->AttackFlags & ATK_IgnoreOTG))
		FinalDamage = FinalDamage * OtgProration / 100;

	CurrentHealth -= FinalDamage;
	if (CurrentHealth > 0)
	{
		if (IsMainPlayer())
		{
			RecoverableHealth += FinalDamage * ReceivedHit.RecoverableDamagePercent / 100;
		}
		else
		{
			RecoverableHealth += FinalDamage;
		}
	}
	else
	{
		if (!(PlayerFlags & PLF_IsDead))
		{
			Enemy->TriggerEvent(EVT_Kill, StateMachine_Primary);
			if (IsMainPlayer())
			{
				Enemy->TriggerEvent(EVT_KillMainPlayer, StateMachine_Primary);
			}
			else
			{
				if (PlayerIndex == 0)
				{
					GameState->BattleState.P2RoundsWon++;
				}
				else
				{
					GameState->BattleState.P1RoundsWon++;
				}
			}
		}
	}

	if (GameState->GameInstance->IsTraining && CurrentHealth < 1)
		CurrentHealth = 1;

	AddMeter(FinalDamage * MeterPercentOnReceiveHit / 100);
	Enemy->AddMeter(FinalDamage * Enemy->MeterPercentOnHit / 100);

	EnableCancelIntoSelf(true);

	switch (ReceivedHit.Position.Type)
	{
	case HPT_Rel:
		{
			PosX = Enemy->PosX;
			PosY = Enemy->PosY;
			Direction = Enemy->Direction == DIR_Right ? DIR_Left : DIR_Right;
			if (PlayerFlags & PLF_TouchingWall)
			{
				Enemy->AddPosXWithDir(-ReceivedHit.Position.PosX);
			}
			else
			{
				AddPosXWithDir(-ReceivedHit.Position.PosX);
			}
			PosY += ReceivedHit.Position.PosY;
			if (PosY < GroundHeight)
				PosY = GroundHeight;
		}
		break;
	case HPT_Abs:
		{
			PosX = ReceivedHit.Position.PosX;
			PosY = ReceivedHit.Position.PosY;
		}
		break;
	case HPT_Add:
		{
			if (PlayerFlags & PLF_TouchingWall)
			{
				Enemy->AddPosXWithDir(-ReceivedHit.Position.PosX);
			}
			else
			{
				AddPosXWithDir(-ReceivedHit.Position.PosX);
			}
			PosY += ReceivedHit.Position.PosY;
			if (PosY < GroundHeight)
				PosY = GroundHeight;
		}
		break;
	default:
		break;
	}

	for (int i = GameState->Players.Num(); i < GameState->BattleState.ActiveObjectCount; i++)
	{
		if (GameState->SortedObjects[i]->Player == this && GameState->SortedObjects[i]->MiscFlags &
			MISC_DeactivateOnReceiveHit)
			GameState->SortedObjects[i]->DeactivateObject();
	}
	if (CurrentHealth <= 0)
	{
		CurrentHealth = 0;
		
		if (ReceivedHit.CustomHitAction != FGameplayTag::EmptyTag)
		{
			BufferedStateName = ReceivedHit.CustomHitAction;
		}
		else if (PosY <= GroundHeight && !(PlayerFlags & PLF_IsKnockedDown))
		{
			if (HACT == HACT_AirVertical)
				BufferedStateName = State_Universal_Launch_V;
			else if (HACT == HACT_AirFaceDown)
				BufferedStateName = State_Universal_Launch_F;
			else if (HACT == HACT_Blowback)
				BufferedStateName = State_Universal_Blowback;
			else if (HACT == HACT_Tailspin)
				BufferedStateName = State_Universal_Tailspin;
			else if (HACT == HACT_Custom)
			{
				BufferedStateName = ReceivedHit.CustomHitAction;
			}
			else if (!(PlayerFlags & PLF_IsDead))
			{
				BufferedStateName = State_Universal_Crumple;
			}
			else
			{
				BufferedStateName = State_Universal_Launch_B;
			}
		}
		else
		{
			if (PosY <= GroundHeight)
				PosY = GroundHeight + 1;
			if (HACT == HACT_AirFaceUp || HACT == HACT_AirNormal)
				BufferedStateName = State_Universal_Launch_B;
			else if (HACT == HACT_AirVertical)
				BufferedStateName = State_Universal_Launch_V;
			else if (HACT == HACT_AirFaceDown)
				BufferedStateName = State_Universal_Launch_F;
			else if (HACT == HACT_Blowback)
				BufferedStateName = State_Universal_Blowback;
			else if (HACT == HACT_Tailspin)
				BufferedStateName = State_Universal_Tailspin;
			else if (HACT == HACT_Custom)
				BufferedStateName = ReceivedHit.CustomHitAction;
			else
				BufferedStateName = State_Universal_Launch_B;
		}
		return;
	}
	if (bLimitCrumple && bCrumpled && HACT == HACT_Crumple)
	{
		HACT = HACT_AirNormal;
	}
	switch (HACT)
	{
	case HACT_GroundNormal:
		switch (Stance)
		{
		case ACT_Standing:
		default:
			if (ReceivedHitCommon.AttackLevel == 0)
				BufferedStateName = FGameplayTag(State_Universal_Hitstun_0);
			else if (ReceivedHitCommon.AttackLevel == 1)
				BufferedStateName = FGameplayTag(State_Universal_Hitstun_1);
			else if (ReceivedHitCommon.AttackLevel == 2)
				BufferedStateName = FGameplayTag(State_Universal_Hitstun_2);
			else if (ReceivedHitCommon.AttackLevel == 3)
				BufferedStateName = FGameplayTag(State_Universal_Hitstun_3);
			else if (ReceivedHitCommon.AttackLevel == 4)
				BufferedStateName = FGameplayTag(State_Universal_Hitstun_4);
			else if (ReceivedHitCommon.AttackLevel == 5)
				BufferedStateName = FGameplayTag(State_Universal_Hitstun_5);
			break;
		case ACT_Crouching:
			if (ReceivedHitCommon.AttackLevel == 0)
				BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_0);
			else if (ReceivedHitCommon.AttackLevel == 1)
				BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_1);
			else if (ReceivedHitCommon.AttackLevel == 2)
				BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_2);
			else if (ReceivedHitCommon.AttackLevel == 3)
				BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_3);
			else if (ReceivedHitCommon.AttackLevel == 4)
				BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_4);
			else if (ReceivedHitCommon.AttackLevel == 5)
				BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_5);
			StunTime += 1;
			StunTimeMax += 1;
		}
		break;
	case HACT_Crumple:
		BufferedStateName = FGameplayTag(State_Universal_Crumple);
		break;
	case HACT_ForceCrouch:
		Stance = ACT_Crouching;
		if (ReceivedHitCommon.AttackLevel == 0)
			BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_0);
		else if (ReceivedHitCommon.AttackLevel == 1)
			BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_1);
		else if (ReceivedHitCommon.AttackLevel == 2)
			BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_2);
		else if (ReceivedHitCommon.AttackLevel == 3)
			BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_3);
		else if (ReceivedHitCommon.AttackLevel == 4)
			BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_4);
		else if (ReceivedHitCommon.AttackLevel == 5)
			BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_5);
		StunTime += 1;
		StunTimeMax += 1;
		break;
	case HACT_ForceStand:
		Stance = ACT_Standing;
		if (ReceivedHitCommon.AttackLevel == 0)
			BufferedStateName = FGameplayTag(State_Universal_Hitstun_0);
		else if (ReceivedHitCommon.AttackLevel == 1)
			BufferedStateName = FGameplayTag(State_Universal_Hitstun_1);
		else if (ReceivedHitCommon.AttackLevel == 2)
			BufferedStateName = FGameplayTag(State_Universal_Hitstun_2);
		else if (ReceivedHitCommon.AttackLevel == 3)
			BufferedStateName = FGameplayTag(State_Universal_Hitstun_3);
		else if (ReceivedHitCommon.AttackLevel == 4)
			BufferedStateName = FGameplayTag(State_Universal_Hitstun_4);
		else if (ReceivedHitCommon.AttackLevel == 5)
			BufferedStateName = FGameplayTag(State_Universal_Hitstun_5);
		break;
	case HACT_GuardBreakCrouch:
		BufferedStateName = State_Universal_GuardBreakCrouch;
		break;
	case HACT_GuardBreakStand:
		BufferedStateName = State_Universal_GuardBreakStand;
		break;
	case HACT_AirNormal:
	case HACT_AirFaceUp:
		BufferedStateName = State_Universal_Launch_B;
		break;
	case HACT_AirVertical:
		BufferedStateName = State_Universal_Launch_V;
		break;
	case HACT_AirFaceDown:
		BufferedStateName = State_Universal_Launch_F;
		break;
	case HACT_Blowback:
		BufferedStateName = State_Universal_Blowback;
		break;
	case HACT_Tailspin:
		BufferedStateName = State_Universal_Tailspin;
		break;
	case HACT_FloatingCrumple:
		if (ReceivedHit.FloatingCrumpleType == FLT_Body)
			BufferedStateName = State_Universal_FloatingCrumpleBody;
		else
			BufferedStateName = State_Universal_FloatingCrumpleHead;
		break;
	case HACT_Custom:
		BufferedStateName = ReceivedHit.CustomHitAction;
	case HACT_None: break;
	default: ;
	}
	DisableAll(StateMachine_Primary);
}

void APlayerObject::SetHitValuesOverTime()
{
	if (PrimaryStateMachine.CurrentState->StateType == EStateType::Hitstun && PosY > GroundHeight
		&& GetCurrentStateName(StateMachine_Primary) != State_Universal_FloatingCrumpleBody && GetCurrentStateName(
			StateMachine_Primary) !=
		State_Universal_FloatingCrumpleHead)
	{
		const int32 CurrentStunTime = StunTimeMax - StunTime;
		if (ReceivedHit.AirPushbackXOverTime.BeginFrame <= CurrentStunTime
			&& ReceivedHit.AirPushbackXOverTime.EndFrame > CurrentStunTime)
		{
			SpeedX = SpeedX * ReceivedHit.AirPushbackXOverTime.Value / 100;
		}
		if (ReceivedHit.AirPushbackYOverTime.BeginFrame <= CurrentStunTime
			&& ReceivedHit.AirPushbackYOverTime.EndFrame > CurrentStunTime
			&& SpeedY > 0)
		{
			SpeedY = SpeedY * ReceivedHit.AirPushbackYOverTime.Value / 100;
		}
		if (ReceivedHit.GravityOverTime.BeginFrame <= CurrentStunTime
			&& ReceivedHit.GravityOverTime.EndFrame > CurrentStunTime)
		{
			Gravity += ReceivedHit.GravityOverTime.Value;
		}
	}
}

void APlayerObject::SetHitValues(bool bCustomAir)
{
	if (!GameState) return;
	if (!Enemy->CheckIsStunned() && Enemy == AttackOwner)
		GameState->SetDrawPriorityFront(Enemy);

	DamageColor = ReceivedHitCommon.DamageColor;
	DamageColor2 = ReceivedHitCommon.DamageColor2;
	
	int32 FinalHitPushbackX;
	int32 FinalAirHitPushbackX;
	int32 FinalAirHitPushbackY;
	int32 FinalGravity;

	if (!(AttackOwner->AttackFlags & ATK_IgnorePushbackScaling))
	{
		FinalHitPushbackX = ReceivedHit.GroundPushbackX + MovesUsedInCombo.Num() * 500;
		FinalAirHitPushbackX = ReceivedHit.AirPushbackX + MovesUsedInCombo.Num() * 150;
		FinalAirHitPushbackY = ReceivedHit.AirPushbackY - MovesUsedInCombo.Num() * 150;
		FinalGravity = ReceivedHit.Gravity + MovesUsedInCombo.Num() * 10;
	}
	else
	{
		FinalHitPushbackX = ReceivedHit.GroundPushbackX;
		FinalAirHitPushbackX = ReceivedHit.AirPushbackX;
		FinalAirHitPushbackY = ReceivedHit.AirPushbackY;
		FinalGravity = ReceivedHit.Gravity;
	}

	EHitAction HACT;

	if (PosY == GroundHeight && !(PlayerFlags & PLF_IsKnockedDown))
		HACT = ReceivedHit.GroundHitAction;
	else
		HACT = ReceivedHit.AirHitAction;

	Pushback = -FinalHitPushbackX;

	switch (ReceivedHit.Position.Type)
	{
	case HPT_RelNextFrame:
		{
			PosX = Enemy->PosX;
			PosY = Enemy->PosY;
			Direction = Enemy->Direction == DIR_Right ? DIR_Left : DIR_Right;
			if (PlayerFlags & PLF_TouchingWall)
			{
				Enemy->AddPosXWithDir(-ReceivedHit.Position.PosX);
			}
			else
			{
				AddPosXWithDir(-ReceivedHit.Position.PosX);
			}
			PosY += ReceivedHit.Position.PosY;
			if (PosY < GroundHeight)
				PosY = GroundHeight;
		}
		break;
	case HPT_AbsNextFrame:
		{
			PosX = ReceivedHit.Position.PosX;
			PosY = ReceivedHit.Position.PosY;
		}
		break;
	case HPT_AddNextFrame:
		{
			if (PlayerFlags & PLF_TouchingWall)
			{
				Enemy->AddPosXWithDir(-ReceivedHit.Position.PosX);
			}
			else
			{
				AddPosXWithDir(-ReceivedHit.Position.PosX);
			}
			PosY += ReceivedHit.Position.PosY;
			if (PosY < GroundHeight)
				PosY = GroundHeight;
		}
		break;
	default:
		break;
	}

	int32 FinalHitstun = ReceivedHit.Hitstun;
	int32 FinalUntech = ReceivedHit.Untech;
	if (!(AttackOwner->AttackFlags & ATK_IgnoreHitstunScaling))
	{
		if (Enemy->ComboTimer >= 14 * 60)
		{
			FinalHitstun = FinalHitstun * 50 / 100;
			FinalUntech = FinalUntech * 50 / 100;
		}
		else if (Enemy->ComboTimer >= 12 * 60)
		{
			FinalHitstun = FinalHitstun * 80 / 100;
			FinalUntech = FinalUntech * 70 / 100;
		}
		else if (Enemy->ComboTimer >= 10 * 60)
		{
			FinalHitstun = FinalHitstun * 90 / 100;
			FinalUntech = FinalUntech * 80 / 100;
		}
		else if (Enemy->ComboTimer >= 7 * 60)
		{
			FinalUntech = FinalUntech * 85 / 100;
		}
		else if (Enemy->ComboTimer >= 5 * 60)
		{
			FinalUntech = FinalUntech * 90 / 100;
		}
	}
	if (FinalHitstun < 1) FinalHitstun = 1;
	if (FinalUntech < 1) FinalUntech = 1;

	if (bLimitCrumple && bCrumpled && HACT == HACT_Crumple)
	{
		HACT = HACT_AirNormal;
	}
	switch (HACT)
	{
	case HACT_GroundNormal:
	case HACT_ForceCrouch:
	case HACT_ForceStand:
	default:
		StunTime = FinalHitstun;
		StunTimeMax = FinalHitstun;
		if (PlayerFlags & PLF_TouchingWall && FinalHitPushbackX != INT_MAX)
		{
			AttackOwner->Pushback = -FinalHitPushbackX;
			Pushback = 0;
		}
		break;
	case HACT_FloatingCrumple:
		if (CurrentHealth <= 0)
		{
			if (PosY <= GroundHeight)
				PosY = GroundHeight + 1;
			StunTime = FinalUntech;
			StunTimeMax = FinalUntech;
			SpeedX = -FinalAirHitPushbackX;
			SpeedY = FinalAirHitPushbackY;
			Gravity = FinalGravity;
			if (PlayerFlags & PLF_TouchingWall && FinalHitPushbackX != INT_MAX)
			{
				AttackOwner->Pushback = -FinalHitPushbackX;
				Pushback = 0;
			}
			break;
		}
		StunTime = FinalUntech;
		StunTimeMax = FinalUntech;
		if (PlayerFlags & PLF_TouchingWall && FinalHitPushbackX != INT_MAX)
		{
			AttackOwner->Pushback = -FinalHitPushbackX;
			Pushback = 0;
		}
		break;
	case HACT_AirNormal:
	case HACT_AirFaceUp:
	case HACT_AirVertical:
	case HACT_AirFaceDown:
	case HACT_Tailspin:
		if (PosY <= GroundHeight)
			PosY = GroundHeight + 1;
		StunTime = FinalUntech;
		StunTimeMax = FinalUntech;
		SpeedX = -FinalAirHitPushbackX;
		SpeedY = FinalAirHitPushbackY;
		Gravity = FinalGravity;
		if (PlayerFlags & PLF_TouchingWall && FinalHitPushbackX != INT_MAX)
		{
			AttackOwner->Pushback = -FinalHitPushbackX;
			Pushback = 0;
		}
		break;
	case HACT_Crumple:
		StunTime = FinalUntech;
		StunTimeMax = FinalUntech;
		if (PlayerFlags & PLF_TouchingWall && FinalHitPushbackX != INT_MAX)
		{
			AttackOwner->Pushback = -FinalHitPushbackX;
			Pushback = 0;
		}
		bCrumpled = true;
		break;
	case HACT_Blowback:
		switch (ReceivedHit.BlowbackLevel)
		{
		case 0:
		default:
			break;
		case 1:
			GotoLabel(State_Label_Blowback_1);
			break;
		case 2:
			GotoLabel(State_Label_Blowback_2);
			break;
		case 3:
			GotoLabel(State_Label_Blowback_3);
			break;
		case 4:
			GotoLabel(State_Label_Blowback_4);
			break;
		}
		if (PosY <= GroundHeight)
			PosY = GroundHeight + 1;
		StunTime = FinalUntech;
		StunTimeMax = FinalUntech;
		SpeedX = -FinalAirHitPushbackX;
		SpeedY = FinalAirHitPushbackY;
		Gravity = FinalGravity;
		if (PlayerFlags & PLF_TouchingWall && FinalHitPushbackX != INT_MAX)
		{
			AttackOwner->Pushback = -FinalHitPushbackX;
			Pushback = 0;
		}
	case HACT_Custom:
		if (bCustomAir)
		{
			if (PosY <= GroundHeight)
				PosY = GroundHeight + 1;
			StunTime = FinalUntech;
			StunTimeMax = FinalUntech;
			SpeedX = -FinalAirHitPushbackX;
			SpeedY = FinalAirHitPushbackY;
			Gravity = FinalGravity;
		}			
		else
		{
			StunTime = FinalHitstun;
			StunTimeMax = FinalHitstun;
		}
		if (PlayerFlags & PLF_TouchingWall && FinalHitPushbackX != INT_MAX)
		{
			AttackOwner->Pushback = -FinalHitPushbackX;
			Pushback = 0;
		}
		break;
	}
	AirDashTimer = 0;
	AirDashNoAttackTime = 0;

	if (ReceivedHit.HardKnockdown)
		PlayerFlags |= PLF_IsHardKnockedDown;
	else
		PlayerFlags &= ~PLF_IsHardKnockedDown;

	if (MaxOTGCount >= 0 && OTGCount > MaxOTGCount && !(AttackOwner->AttackFlags & ATK_IgnoreOTG))
	{
		SpeedX = -30000;
		SpeedY = 8000;
		Gravity = 3500;
		StunTime = 5;
		ReceivedHit.AirPushbackXOverTime = FHitValueOverTime();
		ReceivedHit.AirPushbackYOverTime = FHitValueOverTime();
		ReceivedHit.GravityOverTime = FHitValueOverTime();
		ReceivedHit.KnockdownTime = 0;
		PlayerFlags &= ~PLF_IsHardKnockedDown;
	}
}

void APlayerObject::SetGuardValues()
{
	if (StunTime <= 0) return;
	HaltMomentum();
	Pushback = -ReceivedHitCommon.GroundGuardPushbackX;
	if (PlayerFlags & PLF_TouchingWall)
	{
		AttackOwner->Pushback = -ReceivedHitCommon.GroundGuardPushbackX;
		Pushback = 0;
	}
	if (Stance == ACT_Jumping)
	{
		SpeedX = -ReceivedHitCommon.AirGuardPushbackX;
		SpeedY = ReceivedHitCommon.AirGuardPushbackY;
		Gravity = ReceivedHitCommon.GuardGravity;
	}
}

void APlayerObject::ForceEnableFarNormal(bool Enable)
{
	if (Enable)
	{
		PlayerFlags |= PLF_ForceEnableFarNormal;
	}
	else
	{
		PlayerFlags &= ~PLF_ForceEnableFarNormal;
	}
}

void APlayerObject::SetHeadAttribute(bool Attribute)
{
	if (Attribute)
		AttackFlags |= ATK_AttackHeadAttribute;
	else
		AttackFlags &= ~ATK_AttackHeadAttribute;
}

void APlayerObject::SetThrowActive(bool Active)
{
	if (Active)
	{
		PlayerFlags |= PLF_ThrowActive;
	}
	else
	{
		PlayerFlags &= ~PLF_ThrowActive;
	}
}

void APlayerObject::ThrowEnd()
{
	if (!Enemy) return;
	Enemy->PlayerFlags &= ~PLF_IsThrowLock;
}

void APlayerObject::SetThrowRange(int32 InThrowRange)
{
	ThrowRange = InThrowRange;
}

void APlayerObject::SetThrowExeState(FGameplayTag ExeState)
{
	ExeStateName = ExeState;
}

void APlayerObject::SetThrowPosition(int32 ThrowPosX, int32 ThrowPosY)
{
	if (!Enemy) return;
	if (!(Enemy->PlayerFlags & PLF_IsThrowLock)) return;
	
	if (Direction == DIR_Right)
		Enemy->PosX = R + ThrowPosX;
	else
		Enemy->PosX = L - ThrowPosX;
	Enemy->PosY = PosY + ThrowPosY;
}

void APlayerObject::SetDamageReactionCel(FGameplayTag Type)
{
	if (!Enemy) return;
	if (!(Enemy->PlayerFlags & PLF_IsThrowLock)) return;
	
	if (Enemy->DamageReactionCels.Contains(Type))
	{
		Enemy->SetCelName(Enemy->DamageReactionCels[Type]);
		Enemy->GetBoxes();
	}
}

void APlayerObject::SetHitgrabActive(bool Active)
{
	if (Active)
	{
		PlayerFlags |= PLF_HitgrabActive;
	}
	else
	{
		PlayerFlags &= ~PLF_HitgrabActive;
	}
}

void APlayerObject::PlayVoiceLine(FGameplayTag Name)
{
	if (!IsValid(GameState))
		return;
	if (VoiceData != nullptr)
	{
		for (FSoundStruct SoundStruct : VoiceData->SoundDatas)
		{
			if (SoundStruct.Name == Name)
			{
				GameState->PlayVoiceLine(SoundStruct.SoundWave, SoundStruct.MaxDuration, ObjNumber - 400);
				break;
			}
		}
	}
}

void APlayerObject::PlayCommonLevelSequence(FGameplayTag Name)
{
	if (!GameState) return;
	if (CommonSequenceData != nullptr)
	{
		for (FSequenceStruct SequenceStruct : CommonSequenceData->SequenceStructs)
		{
			if (SequenceStruct.Name == Name)
			{
				GameState->PlayLevelSequence(this, Enemy, SequenceStruct.Sequence);
			}
		}
	}
}

void APlayerObject::PlayLevelSequence(FGameplayTag Name)
{
	if (!GameState) return;
	if (SequenceData != nullptr)
	{
		for (FSequenceStruct SequenceStruct : SequenceData->SequenceStructs)
		{
			if (SequenceStruct.Name == Name)
			{
				GameState->PlayLevelSequence(this, Enemy, SequenceStruct.Sequence);
			}
		}
	}
}

void APlayerObject::StopLevelSequence()
{
	if (!GameState) return;
	GameState->StopLevelSequence();
}

void APlayerObject::BattleHudVisibility(bool Visible)
{
	if (!GameState) return;
	GameState->BattleHudVisibility(Visible);
}

void APlayerObject::EndRound() const
{
	if (!GameState) return;
	GameState->RoundInit();
}

void APlayerObject::EndMatch() const
{
	if (!GameState) return;
	GameState->EndMatch_BP();
}

void APlayerObject::PauseRoundTimer(bool Pause)
{
	if (!GameState) return;
	GameState->BattleState.PauseTimer = Pause;
}

void APlayerObject::AddBattleObjectToStorage(ABattleObject* InActor, int Index)
{
	if (Index < 16)
	{
		StoredBattleObjects[Index] = InActor;
	}
}

APlayerObject* APlayerObject::CallAssist(const int AssistIndex, const FGameplayTag AssistName)
{
	if (!GameState) return nullptr;
	return GameState->CallAssist(PlayerIndex == 0, AssistIndex, AssistName);
}

APlayerObject* APlayerObject::SwitchMainPlayer(int NewTeamIndex, bool bForce, bool bEvenOnScreen)
{
	if (!GameState) return nullptr;
	return GameState->SwitchMainPlayer(this, NewTeamIndex, bForce, bEvenOnScreen);
}

void APlayerObject::SetTeamCooldown(int NewTeamIndex, int Cooldown)
{
	if (!GameState) return;
	return GameState->SetTeamCooldown(PlayerIndex == 0, NewTeamIndex, Cooldown);
}

bool APlayerObject::IsMainPlayer() const
{
	if (!GameState) return true;
	return this == GameState->GetMainPlayer(PlayerIndex == 0);
}

bool APlayerObject::IsOnScreen() const
{
	return (PlayerFlags & PLF_IsOnScreen) == PLF_IsOnScreen;
}

void APlayerObject::SetOnScreen(bool OnScreen)
{
	if (OnScreen)
		PlayerFlags |= PLF_IsOnScreen;
	else
		PlayerFlags &= ~PLF_IsOnScreen;
}

void APlayerObject::ToggleComponentVisibility(FName ComponentName, bool Visible)
{
	TInlineComponentArray<UPrimitiveComponent*> Components;
	GetComponents(Components);
	for (int i = 0; i < Components.Num(); i++)
	{
		if (const auto Component = Components[i]; Component->GetName() == ComponentName)
		{
			ComponentVisible[i] = Visible;
		}
	}
}

bool APlayerObject::CanEnterState(UState* State, FGameplayTag StateMachineName)
{
	FStateMachine& StateMachine = GetStateMachine(StateMachineName);
	const FGameplayTag MoveChainName = State->ShareChainName != FGameplayTag::EmptyTag
		                                   ? State->ShareChainName
		                                   : State->Name;
	if (!CheckMovesUsedInChain(MoveChainName, StateMachine) ||
		!((CheckStateEnabled(State->StateType, State->CustomStateType, StateMachineName) && !State->IsFollowupState)
			|| FindChainCancelOption(State->Name, StateMachine)
			|| FindAutoComboCancelOption(State->Name, StateMachine)
			|| FindWhiffCancelOption(State->Name, StateMachine)
			|| (CheckKaraCancel(State->StateType, State->CustomStateType, StateMachine)
				&& !State->IsFollowupState
				&& StateMachine.GetStateIndex(State->Name) > StateMachine.GetStateIndex(GetStateEntryName()))
		)) //check if the state is enabled
	{
		return false;
	}
	if (CheckObjectPreventingState(State->ObjectID)) //check if an object is preventing state entry
	{
		return false;
	}
	//check current character state against entry stance condition
	if (!StateMachine.CheckStateStanceCondition(State->EntryStance, Stance))
	{
		return false;
	}
	if (State->StateConditions.Num() != 0) //only check state conditions if there are any
	{
		for (int j = 0; j < State->StateConditions.Num(); j++) //iterate over state conditions
		{
			if (!HandleStateCondition(State->StateConditions[j])) //check state condition
			{
				return false;
			}
		}
	}
	if (!State->CanEnterState()) //check bp state condition
	{
		return false;
	}

	return true;
}

void APlayerObject::SetStateForCPU(FGameplayTag StateName, FGameplayTag StateMachineName)
{
	HandleStateTransition(GetStateMachine(StateMachineName).GetStateIndex(StateName), false,
	                      GetStateMachine(StateMachineName));
}

bool APlayerObject::CheckEnemyInRange(int32 XBegin, int32 XEnd, int32 YBegin, int32 YEnd) const
{
	// force x range to current direction
	XBegin *= Direction == DIR_Right ? 1 : -1;
	XEnd *= Direction == DIR_Right ? 1 : -1;

	if (Direction == DIR_Right)
	{
		return XBegin + PosX <= Enemy->PosX && XEnd + PosX >= Enemy->PosX && YBegin + PosY <= Enemy->PosY
			&& YEnd + PosY >= Enemy->PosY;
	}
	return XEnd + PosX <= Enemy->PosX && XBegin + PosX >= Enemy->PosX && YBegin + PosY <= Enemy->PosY
		&& YEnd + PosY >= Enemy->PosY;
}

bool APlayerObject::IsEnemyAttackState() const
{
	return Enemy->PrimaryStateMachine.CurrentState->StateType >= EStateType::NormalAttack
		&& Enemy->PrimaryStateMachine.CurrentState->StateType <= EStateType::SuperAttack;
}

bool APlayerObject::IsEnemyThrow() const
{
	return Enemy->PlayerFlags & PLF_ThrowActive;
}

bool APlayerObject::IsEnemyBlocking() const
{
	return Enemy->GetCurrentStateName(StateMachine_Primary) == State_Universal_StandBlock || Enemy->GetCurrentStateName(
			StateMachine_Primary) ==
		State_Universal_CrouchBlock || Enemy->GetCurrentStateName(StateMachine_Primary) == State_Universal_AirBlock;
}

EBlockType APlayerObject::GetAttackBlockType() const
{
	return HitCommon.BlockType;
}

bool APlayerObject::IsCorrectBlock(EBlockType BlockType)
{
	CallSubroutine(Subroutine_Cmn_IsCorrectBlock);
	if (SubroutineReturnVal2) return SubroutineReturnVal1;
	
	if (BlockType != BLK_None && GetEnableFlags(StateMachine_Primary) & ENB_Block)
	{
		FInputCondition Left;
		FInputBitmask BitmaskLeft;
		BitmaskLeft.InputFlag = INP_Left;
		BitmaskLeft.Lenience = 10;
		Left.Sequence.Add(BitmaskLeft);
		FInputCondition Right;
		FInputBitmask BitmaskRight;
		BitmaskRight.InputFlag = INP_Right;
		Right.Sequence.Add(BitmaskRight);
		if ((CheckInput(Left) && !CheckInput(Right) && PosY > GroundHeight) || GetCurrentStateName(StateMachine_Primary)
			==
			State_Universal_AirBlock)
		{
			if (PrimaryStateMachine.StateNames.Contains(State_Universal_AirBlock))
			{
				Left.Method = EInputMethod::Once;
				if (CheckInput(Left) && InstantBlockLockoutTimer == 0)
				{
					AddMeter(800);
				}
				return true;
			}
		}
		FInputCondition Input1;
		FInputBitmask BitmaskDownLeft;
		BitmaskDownLeft.InputFlag = INP_DownLeft;
		BitmaskDownLeft.Lenience = 12;
		Input1.Sequence.Add(BitmaskDownLeft);
		Input1.Method = EInputMethod::Strict;
		if ((CheckInput(Input1) || GetCurrentStateName(StateMachine_Primary) == State_Universal_CrouchBlock) &&
			BlockType != BLK_High && !
			CheckInput(Right))
		{
			if (PrimaryStateMachine.StateNames.Contains(State_Universal_CrouchBlock))
			{
				Input1.Method = EInputMethod::OnceStrict;
				if (CheckInput(Input1) && InstantBlockLockoutTimer == 0)
				{
					AddMeter(800);
				}
				return true;
			}
		}
		FInputCondition Input4;
		Input4.Sequence.Add(BitmaskLeft);
		Input4.Method = EInputMethod::Strict;
		if ((CheckInput(Input4) || GetCurrentStateName(StateMachine_Primary) == State_Universal_StandBlock) && BlockType
			!= BLK_Low && !
			CheckInput(Right))
		{
			if (PrimaryStateMachine.StateNames.Contains(State_Universal_StandBlock))
			{
				Input4.Method = EInputMethod::OnceStrict;
				if (CheckInput(Input4) && InstantBlockLockoutTimer == 0)
				{
					AddMeter(800);
				}
				return true;
			}
		}
	}
	return false;
}

void APlayerObject::HandleBlockAction()
{
	AttackOwner->Hitstop = ReceivedHit.Hitstop;
	Hitstop = ReceivedHit.Hitstop + ReceivedHitCommon.EnemyBlockstopModifier;
	StunTime = ReceivedHitCommon.Blockstun;
	StunTimeMax = ReceivedHitCommon.Blockstun;

	FInputCondition Input1;
	FInputBitmask BitmaskDownLeft;
	BitmaskDownLeft.InputFlag = INP_DownLeft;
	Input1.Sequence.Add(BitmaskDownLeft);
	Input1.Method = EInputMethod::Strict;
	switch (ReceivedHitCommon.AttackLevel)
	{
	case 0:
	default:
		GotoLabel(State_Label_Block_Level1);
		break;
	case 1:
		GotoLabel(State_Label_Block_Level1);
		break;
	case 2:
		GotoLabel(State_Label_Block_Level2);
		break;
	case 3:
		GotoLabel(State_Label_Block_Level2);
		break;
	case 4:
		GotoLabel(State_Label_Block_Level3);
		break;
	case 5:
		GotoLabel(State_Label_Block_Level3);
		break;
	}
	if (Stance == ACT_Jumping || GetCurrentStateName(StateMachine_Primary) == State_Universal_AirBlock)
	{
		BufferedStateName = State_Universal_AirBlock;
	}
	else if (CheckInput(Input1) || GetCurrentStateName(StateMachine_Primary) == State_Universal_CrouchBlock)
	{
		PosY = 0;
		BufferedStateName = State_Universal_CrouchBlock;
	}
	else
	{
		PosY = 0;
		BufferedStateName = State_Universal_StandBlock;
	}
}

void APlayerObject::HandleProximityBlock()
{
	if (!(Enemy->AttackFlags & ATK_HitActive) || !IsCorrectBlock(Enemy->HitCommon.BlockType)
		|| (CalculateDistanceBetweenPoints(DIST_DistanceX, OBJ_Self, POS_Self, OBJ_Enemy, POS_Self) > Enemy->HitCommon.
			ProximityBlockDistanceX
			|| CalculateDistanceBetweenPoints(DIST_DistanceY, OBJ_Self, POS_Self, OBJ_Enemy, POS_Self) > Enemy->
			HitCommon.ProximityBlockDistanceY))
	{
		if (PrimaryStateMachine.CurrentState->StateType == EStateType::Blockstun && StunTime <= 0)
		{
			if (Stance == ACT_Standing)
			{
				JumpToStatePrimary(State_Universal_StandBlockEnd);
			}
			else if (Stance == ACT_Crouching)
			{
				JumpToStatePrimary(State_Universal_CrouchBlockEnd);
			}
			else
			{
				JumpToStatePrimary(State_Universal_AirBlockEnd);
			}
		}
		return;
	}
	if (!(GetEnableFlags(StateMachine_Primary) & ENB_ProximityBlock))
		return;

	FInputCondition Input1;
	FInputBitmask BitmaskDownLeft;
	BitmaskDownLeft.InputFlag = INP_DownLeft;
	Input1.Sequence.Add(BitmaskDownLeft);
	Input1.Method = EInputMethod::Strict;
	GotoLabel(State_Label_Block_PreGuard);
	if (PosY > GroundHeight)
	{
		JumpToStatePrimary(State_Universal_AirBlock, true);
		Stance = ACT_Jumping;
	}
	else if (CheckInput(Input1))
	{
		JumpToStatePrimary(State_Universal_CrouchBlock, true);
		Stance = ACT_Crouching;
	}
	else
	{
		JumpToStatePrimary(State_Universal_StandBlock, true);
		Stance = ACT_Standing;
	}
}

void APlayerObject::EmptyStateMachine()
{
	PrimaryStateMachine.States.Empty();
	PrimaryStateMachine.StateNames.Empty();
	PrimaryStateMachine.CurrentState = nullptr;
	for (auto& StateMachine : SubStateMachines)
	{
		StateMachine.States.Empty();
		StateMachine.StateNames.Empty();
		StateMachine.CurrentState = nullptr;
	}
	
	CommonSubroutineNames.Empty();
	CommonSubroutines.Empty();
	
	SubroutineNames.Empty();
	Subroutines.Empty();
	
	CommonObjectStates.Empty();
	CommonObjectStateNames.Empty();
	
	ObjectStates.Empty();
	ObjectStateNames.Empty();
}

void APlayerObject::HandleBufferedState()
{
	HandleBufferedState(PrimaryStateMachine);
}

void APlayerObject::HandleBufferedState(FStateMachine& StateMachine)
{
	if (BufferedStateName != FGameplayTag::EmptyTag)
	{
		if (StateMachine.ForceSetState(BufferedStateName))
		{
			BufferedStateName = FGameplayTag::EmptyTag;
			GotoLabelActive = false;
			switch (StateMachine.CurrentState->EntryStance)
			{
			case EEntryStance::Standing:
				Stance = ACT_Standing;
				break;
			case EEntryStance::Crouching:
				Stance = ACT_Crouching;
				break;
			case EEntryStance::Jumping:
				Stance = ACT_Jumping;
				break;
			default:
				break;
			}
		}
	}
}

bool APlayerObject::HandleStateCondition(EStateCondition StateCondition) const
{
	switch (StateCondition)
	{
	case EStateCondition::None:
		return true;
	case EStateCondition::AirJumpOk:
		if (CurrentAirJumpCount > 0)
			return true;
		break;
	case EStateCondition::AirJumpMinimumHeight:
		if (SpeedY <= 0 || PosY >= 122500)
			return true;
		break;
	case EStateCondition::AirDashOk:
		if (CurrentAirDashCount > 0)
			return true;
		break;
	case EStateCondition::AirDashMinimumHeight:
		if (PosY > AirDashMinimumHeight && SpeedY > 0)
			return true;
		if (PosY > 70000 && SpeedY <= 0)
			return true;
		break;
	case EStateCondition::IsAttacking:
		return AttackFlags & ATK_IsAttacking;
	case EStateCondition::HitstopCancel:
		return Hitstop > 0 && AttackFlags & ATK_IsAttacking;
	case EStateCondition::IsStunned:
		return CheckIsStunned();
	case EStateCondition::CloseNormal:
		if (abs(PosX - Enemy->PosX) < CloseNormalRange && (PlayerFlags & PLF_ForceEnableFarNormal) == 0)
			return true;
		break;
	case EStateCondition::FarNormal:
		if (abs(PosX - Enemy->PosX) > CloseNormalRange || PlayerFlags & PLF_ForceEnableFarNormal)
			return true;
		break;
	case EStateCondition::CanTag2nd:
		if (GameState->CanTag(this, 1))
			return true;
		break;
	case EStateCondition::CanTag3rd:
		if (GameState->CanTag(this, 2))
			return true;
		break;
	case EStateCondition::MeterNotZero:
		if (GameState->BattleState.Meter[PlayerIndex] > 0)
			return true;
		break;
	case EStateCondition::MeterQuarterBar:
		if (GameState->BattleState.Meter[PlayerIndex] >= 2500)
			return true;
		break;
	case EStateCondition::MeterHalfBar:
		if (GameState->BattleState.Meter[PlayerIndex] >= 5000)
			return true;
		break;
	case EStateCondition::MeterOneBar:
		if (GameState->BattleState.Meter[PlayerIndex] >= 10000)
			return true;
		break;
	case EStateCondition::MeterTwoBars:
		if (GameState->BattleState.Meter[PlayerIndex] >= 20000)
			return true;
		break;
	case EStateCondition::MeterThreeBars:
		if (GameState->BattleState.Meter[PlayerIndex] >= 30000)
			return true;
		break;
	case EStateCondition::MeterFourBars:
		if (GameState->BattleState.Meter[PlayerIndex] >= 40000)
			return true;
		break;
	case EStateCondition::MeterFiveBars:
		if (GameState->BattleState.Meter[PlayerIndex] >= 50000)
			return true;
		break;
	case EStateCondition::PlayerReg1True:
		return PlayerReg1 != 0;
	case EStateCondition::PlayerReg2True:
		return PlayerReg2 != 0;
	case EStateCondition::PlayerReg3True:
		return PlayerReg3 != 0;
	case EStateCondition::PlayerReg4True:
		return PlayerReg4 != 0;
	case EStateCondition::PlayerReg5True:
		return PlayerReg5 != 0;
	case EStateCondition::PlayerReg6True:
		return PlayerReg6 != 0;
	case EStateCondition::PlayerReg7True:
		return PlayerReg7 != 0;
	case EStateCondition::PlayerReg8True:
		return PlayerReg8 != 0;
	case EStateCondition::PlayerReg1False:
		return PlayerReg1 == 0;
	case EStateCondition::PlayerReg2False:
		return PlayerReg2 == 0;
	case EStateCondition::PlayerReg3False:
		return PlayerReg3 == 0;
	case EStateCondition::PlayerReg4False:
		return PlayerReg4 == 0;
	case EStateCondition::PlayerReg5False:
		return PlayerReg5 == 0;
	case EStateCondition::PlayerReg6False:
		return PlayerReg6 == 0;
	case EStateCondition::PlayerReg7False:
		return PlayerReg7 == 0;
	case EStateCondition::PlayerReg8False:
		return PlayerReg8 == 0;
	default:
		break;
	}
	return false;
}

bool APlayerObject::FindChainCancelOption(const FGameplayTag Name, FStateMachine& StateMachine)
{
	if (AttackFlags & ATK_HasHit && AttackFlags & ATK_IsAttacking && CancelFlags & CNC_ChainCancelEnabled)
	{
		if (CheckReverseBeat(Name, StateMachine))
			return true;
		for (int i = 0; i < ChainCancelOptions.Num(); i++)
		{
			if (ChainCancelOptions[i] == StateMachine.GetStateIndex(Name) && ChainCancelOptions[i] != INDEX_NONE)
			{
				return CheckMovesUsedInChain(Name, StateMachine);
			}
		}
	}
	return false;
}

bool APlayerObject::FindAutoComboCancelOption(const FGameplayTag Name, FStateMachine& StateMachine)
{
	if (AttackFlags & ATK_HasHit && CancelFlags & CNC_ChainCancelEnabled)
	{
		for (int i = 0; i < 8; i++)
		{
			if (AutoComboCancels[i] == StateMachine.GetStateIndex(Name) && AutoComboCancels[i] != INDEX_NONE)
			{
				return CheckMovesUsedInChain(Name, StateMachine);
			}
		}
	}
	return false;
}

bool APlayerObject::FindWhiffCancelOption(const FGameplayTag Name, FStateMachine& StateMachine)
{
	if (CancelFlags & CNC_WhiffCancelEnabled)
	{
		if (CheckReverseBeat(Name, StateMachine))
			return true;
		for (int i = 0; i < WhiffCancelOptions.Num(); i++)
		{
			if (WhiffCancelOptions[i] == StateMachine.GetStateIndex(Name) && WhiffCancelOptions[i] != INDEX_NONE)
			{
				return CheckMovesUsedInChain(Name, StateMachine);
			}
		}
	}
	return false;
}

bool APlayerObject::CheckReverseBeat(const FGameplayTag Name, FStateMachine& StateMachine)
{
	if (!CanReverseBeat || (CancelFlags & CNC_EnableReverseBeat) == 0)
		return false;
	
	const int32 Index = StateMachine.GetStateIndex(Name);
	if (!StateMachine.States[Index]->bEnableReverseBeat) return false;
	
	if (StateMachine.CurrentState->StateType == EStateType::NormalAttack
		&& Index != INDEX_NONE && StateMachine.States[Index]->StateType == EStateType::NormalAttack)
	{
		return CheckMovesUsedInChain(Name, StateMachine);
	}
	return false;
}

bool APlayerObject::CheckMovesUsedInChain(const FGameplayTag Name, FStateMachine& StateMachine)
{
	int32 Usages = 0;
	for (const int32 Index : MovesUsedInChain)
	{
		if (Index == StateMachine.GetStateIndex(Name) && Index != INDEX_NONE)
			Usages++;
	}
	if (CanReverseBeat && Usages)
	{
		auto LastMove = MovesUsedInChain.Last();
		if (LastMove != StateMachine.GetStateIndex(Name))
		{
			return false;
		}
	}
	
	auto State = StateMachine.States[StateMachine.GetStateIndex(Name)];
	
	if (Usages < State->MaxChain || State->MaxChain == -1)
	{
		return true;
	}
	return false;
}

void APlayerObject::ThrowExe()
{
	JumpToStatePrimary(ExeStateName);
	PlayerFlags &= ~PLF_ThrowActive;
}

void APlayerObject::HandleThrowCollision()
{
	if ((Enemy->InvulnFlags & INV_ThrowInvulnerable) == 0 && !Enemy->ThrowInvulnerableTimer
		&& !Enemy->ThrowResistTimer && !Enemy->CheckIsStunned()
		&& ((Enemy->PosY <= GroundHeight && PosY <= GroundHeight)
			|| (Enemy->PosY > GroundHeight && PosY > GroundHeight)))
	{
		FInputCondition Left;
		FInputBitmask BitmaskLeft;
		BitmaskLeft.InputFlag = INP_Left;
		BitmaskLeft.Lenience = 1;
		Left.Sequence.Add(BitmaskLeft);
		Left.Method = EInputMethod::Strict;

		if (CanProximityThrow)
		{
			if (ActionTime == 0 && PrimaryStateMachine.CurrentState->StateType == EStateType::NormalAttack)
			{
				FInputCondition Right;
				FInputBitmask BitmaskRight;
				BitmaskRight.InputFlag = INP_Right;
				BitmaskRight.Lenience = 1;
				Right.Sequence.Add(BitmaskRight);
				Right.Method = EInputMethod::Strict;

				if (CheckInput(ProximityThrowInput) && (CheckInput(Left) || CheckInput(Right)))
				{
					if (PosY <= GroundHeight)
						CallSubroutine(Subroutine_ThrowParam_Ground);
					else
						CallSubroutine(Subroutine_ThrowParam_Air);
				}
			}
			else
			{
				SetThrowActive(false);
			}
		}

		int ThrowPosX;
		if (Direction == DIR_Right)
			ThrowPosX = R + ThrowRange;
		else
			ThrowPosX = L - ThrowRange;
		if (AttackFlags & ATK_IsAttacking && PlayerFlags & PLF_ThrowActive
			&& ((PosX <= Enemy->PosX && ThrowPosX >= Enemy->L)
				|| (PosX > Enemy->PosX && ThrowPosX <= Enemy->R))
			&& T >= Enemy->B && B <= Enemy->T)
		{
			Enemy->JumpToStatePrimary(State_Universal_ThrowLock);
			Enemy->PlayerFlags |= PLF_IsThrowLock;
			Enemy->StunTime = 0x7FFFFFFF;
			Enemy->ThrowTechTimer = ThrowTechWindow;
			Enemy->AttackOwner = this;
			ThrowExe();
		}
	}
}

bool APlayerObject::CheckKaraCancel(EStateType InStateType, const FGameplayTag& CustomStateType, const FStateMachine& StateMachine)
{
	if ((CancelFlags & CNC_EnableKaraCancel) == 0 || PlayerFlags & PLF_DidKaraCancel)
	{
		return false;
	}

	if (ActionTime >= 3)
		return false;

	if (InStateType == StateMachine.CurrentState->StateType && CustomStateType == StateMachine.CurrentState->CustomStateType)
	{
		PlayerFlags |= PLF_DidKaraCancel;
		return true;
	}
	if (InStateType == EStateType::SpecialAttack && StateMachine.CurrentState->StateType >=
		EStateType::NormalAttack && StateMachine.CurrentState->StateType < EStateType::SpecialAttack)
	{
		PlayerFlags |= PLF_DidKaraCancel;
		return true;
	}
	if (InStateType == EStateType::SuperAttack && StateMachine.CurrentState->StateType >=
		EStateType::NormalAttack && StateMachine.CurrentState->StateType < EStateType::SuperAttack)
	{
		PlayerFlags |= PLF_DidKaraCancel;
		return true;
	}

	return false;
}

bool APlayerObject::CheckObjectPreventingState(int InObjectID) const
{
	if (InObjectID != 0)
	{
		for (int i = GameState->Players.Num(); i < GameState->BattleState.ActiveObjectCount; i++)
		{
			if (GameState->SortedObjects[i]->Player == this && GameState->SortedObjects[i]->ObjectID == InObjectID)
				return true;
		}
	}
	return false;
}

void APlayerObject::HandleWallBounce()
{
	if (ReceivedHit.WallBounce.WallBounceInCornerOnly)
	{
		if (PlayerFlags & PLF_TouchingWall && 
			GameState->BattleState.ScreenData.ScreenWorldCenterX + GameState->BattleState.ScreenData.ScreenWorldWidth / 2
			>= GameState->BattleState.ScreenData.StageBoundsRight ||
			GameState->BattleState.ScreenData.ScreenWorldCenterX - GameState->BattleState.ScreenData.ScreenWorldWidth / 2
			<= GameState->BattleState.ScreenData.StageBoundsLeft)
		{
			if (ReceivedHit.WallBounce.WallBounceCount > 0)
			{
				PlayCommonSound(Sound_Landing_Crash);
				CreateCommonParticle(Particle_WallBounce, POS_Self);
				ReceivedHit.GroundBounce.GroundBounceCount = 0;
				PlayerFlags &= ~PLF_TouchingWall;
				ReceivedHit.WallBounce.WallBounceCount--;
				ReceivedHit.GroundPushbackX = 0;
				ReceivedHit.AirPushbackX = -ReceivedHit.WallBounce.WallBounceXSpeed * ReceivedHit.WallBounce.WallBounceXRate / 100;
				ReceivedHit.AirPushbackY = ReceivedHit.WallBounce.WallBounceYSpeed * ReceivedHit.WallBounce.
					WallBounceYRate / 100;
				ReceivedHit.Gravity = ReceivedHit.WallBounce.WallBounceGravity;
				if (ReceivedHit.WallBounce.WallBounceUntech > 0)
					ReceivedHit.Untech = ReceivedHit.WallBounce.WallBounceUntech;
				else
					ReceivedHit.Untech = StunTime;
				StunTime = INT_MAX;
				ReceivedHit.Hitstop = ReceivedHit.WallBounce.WallBounceStop;
				ReceivedHit.GroundHitAction = HACT_AirFaceDown;
				ReceivedHit.AirHitAction = HACT_AirFaceDown;
				ReceivedHit.Position = FHitPosition();
				ReceivedHit.AirPushbackXOverTime = FHitValueOverTime();
				ReceivedHit.AirPushbackYOverTime = FHitValueOverTime();
				ReceivedHit.GravityOverTime = FHitValueOverTime();
				HaltMomentum();
				BufferedStateName = State_Universal_WallBounce;

				int32 FinalHitstop = ReceivedHit.Hitstop;

				Hitstop = FinalHitstop;
				HandleBufferedState(PrimaryStateMachine);
			}
		}
		return;
	}
	if (PlayerFlags & PLF_TouchingWall)
	{
		if (ReceivedHit.WallBounce.WallBounceCount > 0)
		{
			PlayCommonSound(Sound_Landing_Crash);
			CreateCommonParticle(Particle_WallBounce, POS_Self);
			ReceivedHit.GroundBounce.GroundBounceCount = 0;
			PlayerFlags &= ~PLF_TouchingWall;
			ReceivedHit.WallBounce.WallBounceCount--;
			ReceivedHit.GroundPushbackX = 0;
			ReceivedHit.AirPushbackX = -ReceivedHit.WallBounce.WallBounceXSpeed * ReceivedHit.WallBounce.WallBounceXRate / 100;
			ReceivedHit.AirPushbackY = ReceivedHit.WallBounce.WallBounceYSpeed * ReceivedHit.WallBounce.WallBounceYRate
				/ 100;
			ReceivedHit.Gravity = ReceivedHit.WallBounce.WallBounceGravity;
			if (ReceivedHit.WallBounce.WallBounceUntech > 0)
				ReceivedHit.Untech = ReceivedHit.WallBounce.WallBounceUntech;
			else
				ReceivedHit.Untech = StunTime;
			StunTime = INT_MAX;
			ReceivedHit.Hitstop = ReceivedHit.WallBounce.WallBounceStop;
			ReceivedHit.GroundHitAction = HACT_AirFaceDown;
			ReceivedHit.AirHitAction = HACT_AirFaceDown;
			ReceivedHit.Position = FHitPosition();
			ReceivedHit.AirPushbackXOverTime = FHitValueOverTime();
			ReceivedHit.AirPushbackYOverTime = FHitValueOverTime();
			ReceivedHit.GravityOverTime = FHitValueOverTime();
			HaltMomentum();
			BufferedStateName = State_Universal_WallBounce;

			int32 FinalHitstop = ReceivedHit.Hitstop;

			Hitstop = FinalHitstop;
			HandleBufferedState(PrimaryStateMachine);
		}
	}
}

void APlayerObject::HandleGroundBounce()
{
	CreateCommonParticle(Particle_JumpSmoke_Land, POS_Player);
	ReceivedHit.GroundBounce.GroundBounceCount--;
	ReceivedHit.GroundPushbackX = 0;
	if (SpeedX > 0)
		ReceivedHit.AirPushbackX = -ReceivedHit.GroundBounce.GroundBounceXSpeed * ReceivedHit.GroundBounce.
			GroundBounceXRate / 100;
	else
		ReceivedHit.AirPushbackX = ReceivedHit.GroundBounce.GroundBounceXSpeed * ReceivedHit.GroundBounce.
			GroundBounceXRate / 100;
	ReceivedHit.AirPushbackY = ReceivedHit.GroundBounce.GroundBounceYSpeed * ReceivedHit.GroundBounce.GroundBounceYRate / 100;
	ReceivedHit.Gravity = ReceivedHit.GroundBounce.GroundBounceGravity;
	if (ReceivedHit.GroundBounce.GroundBounceUntech > 0)
		ReceivedHit.Untech = ReceivedHit.GroundBounce.GroundBounceUntech;
	else
		ReceivedHit.Untech = StunTime;
	ReceivedHit.Hitstop = ReceivedHit.GroundBounce.GroundBounceStop;
	ReceivedHit.GroundHitAction = HACT_AirFaceUp;
	ReceivedHit.AirHitAction = HACT_AirFaceUp;
	ReceivedHit.Position = FHitPosition();
	ReceivedHit.AirPushbackXOverTime = FHitValueOverTime();
	ReceivedHit.AirPushbackYOverTime = FHitValueOverTime();
	ReceivedHit.GravityOverTime = FHitValueOverTime();
	EnableCancelIntoSelf(true);
	PosY = GroundHeight + 1;
	switch (ReceivedHit.AirHitAction)
	{
	case HACT_AirFaceUp:
	default:
		BufferedStateName = State_Universal_Launch_B;
		break;
	case HACT_AirVertical:
		BufferedStateName = State_Universal_Launch_V;
		break;
	case HACT_AirFaceDown:
		BufferedStateName = State_Universal_Launch_F;
		break;
	}

	Hitstop = ReceivedHit.GroundBounce.GroundBounceStop;
	PlayerFlags &= ~PLF_IsKnockedDown;
	HandleBufferedState(PrimaryStateMachine);
}

void APlayerObject::SetComponentVisibility() const
{
	TInlineComponentArray<UPrimitiveComponent*> Components;
	GetComponents(Components);
	for (int i = 0; i < Components.Num(); i++)
	{
		UPrimitiveComponent* Component = Components[i];
		Component->SetVisibility(ComponentVisible[i]);
	}
}

void APlayerObject::UpdateVisualsNoRollback()
{
	Super::UpdateVisualsNoRollback();

	for (const auto& LinkActor : StoredLinkActors)
	{
		if (!LinkActor.StoredActor) continue;
		LinkActor.StoredActor->SetActorHiddenInGame(!LinkActor.bIsActive);
	}
	SetComponentVisibility();
	
	TArray<USkeletalMeshComponent*> SkeletalMeshComponents;
	GetComponents(USkeletalMeshComponent::StaticClass(), SkeletalMeshComponents);

	for (auto SkeletalMeshComponent : SkeletalMeshComponents)
	{
		if (!SkeletalMeshComponent->IsVisible() || !IsValid(SkeletalMeshComponent->GetAnimInstance())) continue;
		SkeletalMeshComponent->GetAnimInstance()->UpdateAnimation(OneFrame, false); 
		SkeletalMeshComponent->TickAnimation(OneFrame, false); 
		SkeletalMeshComponent->TickPose(OneFrame, true);  
	}
}

void APlayerObject::AddState(FGameplayTag Name, UState* State, FGameplayTag StateMachineName)
{
	auto& StateMachine = GetStateMachine(StateMachineName);

	StateMachine.Parent = this;
	StateMachine.AddState(Name, State);
}

void APlayerObject::AddObjectState(FGameplayTag Name, UState* State, bool IsCommon)
{
	State->Parent = this;
	if (IsCommon)
	{
		CommonObjectStates.Add(State);
		CommonObjectStateNames.Add(Name);
	}
	else
	{
		ObjectStates.Add(State);
		ObjectStateNames.Add(Name);
	}
}

void APlayerObject::AddSubroutine(FGameplayTag Name, USubroutine* Subroutine, bool IsCommon)
{
	Subroutine->Parent = this;
	if (IsCommon)
	{
		CommonSubroutines.Add(Subroutine);
		CommonSubroutineNames.Add(Name);
	}
	else
	{
		Subroutines.Add(Subroutine);
		SubroutineNames.Add(Name);
	}
}

void APlayerObject::SetHealth(int Value)
{
	CurrentHealth = Value;
}

void APlayerObject::AddHealth(int Value)
{
	CurrentHealth += Value;
}

void APlayerObject::SetRecoverableHealth(int Value)
{
	RecoverableHealth = Value;
}

void APlayerObject::AddRecoverableHealth(int Value)
{
	RecoverableHealth += Value;
}

void APlayerObject::RecoverHealth(int Value)
{
	if (Value <= RecoverableHealth)
	{
		CurrentHealth += Value;
		RecoverableHealth -= Value;
	}
	else
	{
		CurrentHealth += RecoverableHealth;
		RecoverableHealth = 0;
	}
}

void APlayerObject::UseMeter(int Use)
{
	if (!GameState) return;
	GameState->BattleState.Meter[PlayerIndex] -= Use;
}

void APlayerObject::AddMeter(int Meter)
{
	if (!GameState) return;
	if (MeterCooldownTimer > 0)
		Meter /= 10;
	GameState->BattleState.Meter[PlayerIndex] += Meter;
}

void APlayerObject::SetMeterCooldownTimer(int Timer)
{
	MeterCooldownTimer = Timer;
}

void APlayerObject::SetStance(EActionStance InStance)
{
	Stance = InStance;
}

bool APlayerObject::JumpToStatePrimary(FGameplayTag NewName, bool IsLabel)
{
	return JumpToState(NewName, StateMachine_Primary, IsLabel);
}

bool APlayerObject::JumpToState(FGameplayTag NewName, FGameplayTag StateMachineName, bool IsLabel)
{
	if (!GameState && !CharaSelectGameState) return false;
	GotoLabelActive = IsLabel;
	FStateMachine& StateMachine = GetStateMachine(StateMachineName);
	if (StateMachine.ForceSetState(NewName) && StateMachine.CurrentState != nullptr)
	{
		switch (StateMachine.CurrentState->EntryStance)
		{
		case EEntryStance::Standing:
			Stance = ACT_Standing;
			break;
		case EEntryStance::Crouching:
			Stance = ACT_Crouching;
			break;
		case EEntryStance::Jumping:
			Stance = ACT_Jumping;
			break;
		default:
			break;
		}
		return true;
	}
	return false;
}


bool APlayerObject::JumpToStateByClassPrimary(TSubclassOf<UState> Class, bool IsLabel)
{
	return JumpToStateByClass(Class, StateMachine_Primary, IsLabel);
}

bool APlayerObject::JumpToStateByClass(TSubclassOf<UState> Class, FGameplayTag StateMachineName, bool IsLabel)
{
	if (!GameState && !CharaSelectGameState) return false;
	GotoLabelActive = IsLabel;
	FStateMachine& StateMachine = GetStateMachine(StateMachineName);
	if (StateMachine.ForceSetState(Class) && StateMachine.CurrentState != nullptr)
	{
		switch (StateMachine.CurrentState->EntryStance)
		{
		case EEntryStance::Standing:
			Stance = ACT_Standing;
			break;
		case EEntryStance::Crouching:
			Stance = ACT_Crouching;
			break;
		case EEntryStance::Jumping:
			Stance = ACT_Jumping;
			break;
		default:
			break;
		}
		return true;
	}
	return false;
}

FGameplayTag APlayerObject::GetCurrentStateName(FGameplayTag StateMachineName)
{
	if (!GetStateMachine(StateMachineName).CurrentState) return FGameplayTag::EmptyTag;
	return GetStateMachine(StateMachineName).CurrentState->Name;
}

FGameplayTag APlayerObject::GetLastStateName() const
{
	return LastStateName;
}

FGameplayTag APlayerObject::GetStateEntryName() const
{
	return StateEntryName;
}

FStateMachine& APlayerObject::GetStateMachine(FGameplayTag StateMachineName)
{
	for (auto& StateMachine : SubStateMachines)
	{
		if (StateMachineName == StateMachine.StateMachineName)
		{
			return StateMachine;
		}
	}
	if (StateMachineName != StateMachine_Primary && StateMachineName != FGameplayTag::EmptyTag)
	{
		UE_LOGFMT(LogCore, Error, "State machine `{Name}` was not found, returning primary.",
		          ("Name", StateMachineName.ToString()));
	}
	return PrimaryStateMachine;
}

bool APlayerObject::CheckStateEnabled(EStateType StateType, FGameplayTag CustomStateType, FGameplayTag StateMachineName)
{
	switch (StateType)
	{
	case EStateType::Standing:
		if (GetEnableFlags(StateMachineName) & ENB_Standing)
			return true;
		break;
	case EStateType::Crouching:
		if (GetEnableFlags(StateMachineName) & ENB_Crouching)
			return true;
		break;
	case EStateType::NeutralJump:
	case EStateType::ForwardJump:
	case EStateType::BackwardJump:
		if (GetEnableFlags(StateMachineName) & ENB_Jumping || (CancelFlags & CNC_JumpCancel && AttackFlags & ATK_HasHit
			&& AttackFlags &
			ATK_IsAttacking))
			return true;
		break;
	case EStateType::ForwardWalk:
		if (GetEnableFlags(StateMachineName) & ENB_ForwardWalk)
			return true;
		break;
	case EStateType::BackwardWalk:
		if (GetEnableFlags(StateMachineName) & ENB_BackWalk)
			return true;
		break;
	case EStateType::ForwardDash:
		if (GetEnableFlags(StateMachineName) & ENB_ForwardDash)
			return true;
		break;
	case EStateType::BackwardDash:
		if (GetEnableFlags(StateMachineName) & ENB_BackDash)
			return true;
		break;
	case EStateType::ForwardAirDash:
		if (GetEnableFlags(StateMachineName) & ENB_ForwardAirDash || (CancelFlags & CNC_FAirDashCancel && AttackFlags &
			ATK_HasHit &&
			AttackFlags & ATK_IsAttacking))
			return true;
		break;
	case EStateType::BackwardAirDash:
		if (GetEnableFlags(StateMachineName) & ENB_BackAirDash || (CancelFlags & CNC_BAirDashCancel && AttackFlags &
			ATK_HasHit &&
			AttackFlags & ATK_IsAttacking))
			return true;
		break;
	case EStateType::NormalAttack:
		if (GetEnableFlags(StateMachineName) & ENB_NormalAttack)
			return true;
		break;
	case EStateType::SpecialAttack:
		if (GetEnableFlags(StateMachineName) & ENB_SpecialAttack || (CancelFlags & CNC_SpecialCancel && AttackFlags &
			ATK_HasHit &&
			AttackFlags & ATK_IsAttacking))
			return true;
		break;
	case EStateType::SuperAttack:
		if (GetEnableFlags(StateMachineName) & ENB_SuperAttack || (CancelFlags & CNC_SuperCancel && AttackFlags &
			ATK_HasHit && AttackFlags &
			ATK_IsAttacking))
			return true;
		break;
	case EStateType::Tech:
		if (GetEnableFlags(StateMachineName) & ENB_Tech && CheckIsStunned())
			return true;
		break;
	case EStateType::Burst:
		if (GetEnableFlags(StateMachineName) & ENB_Burst && (Enemy->Player->PlayerFlags & PLF_LockOpponentBurst) == 0
			&& (PlayerFlags & PLF_IsDead) == 0)
			return true;
		break;
	case EStateType::Tag:
		if (GetEnableFlags(StateMachineName) & ENB_Tag)
			return true;
		break;
	case EStateType::Assist:
		if (GetEnableFlags(StateMachineName) & ENB_Assist)
			return true;
		break;
	case EStateType::Custom:
		if (GetStateMachine(StateMachineName).EnabledCustomStateTypes.Contains(CustomStateType))
			return true;
		break;
	default:
		break;
	}
	return false;
}

void APlayerObject::OnStateChange()
{
	if (!GameState) return;

	CallSubroutine(Subroutine_Cmn_OnStateChange);
	CallSubroutine(Subroutine_OnStateChange);

	// Deactivate all objects that need to be destroyed on state change.
	for (int i = GameState->Players.Num(); i < GameState->BattleState.ActiveObjectCount; i++)
	{
		if (GameState->SortedObjects[i]->Player == this && GameState->SortedObjects[i]->MiscFlags &
			MISC_DeactivateOnStateChange)
			GameState->SortedObjects[i]->DeactivateObject();
	}

	DisableAll(StateMachine_Primary);

	// Reset flags
	CancelFlags = CNC_ChainCancelEnabled | CNC_EnableReverseBeat;
	if (!(PlayerFlags & PLF_DidKaraCancel))
	{
		CancelFlags |= CNC_EnableKaraCancel;
	}
	else
	{
		PlayerFlags &= ~PLF_DidKaraCancel;
	}
	PlayerFlags &= ~PLF_ThrowActive;
	PlayerFlags &= ~PLF_HitgrabActive;
	PlayerFlags &= ~PLF_LockOpponentBurst;
	PlayerFlags &= ~PLF_ForceEnableFarNormal;
	PlayerFlags |= PLF_DefaultLandingAction;
	AttackFlags = 0;
	MiscFlags = 0;
	MiscFlags |= MISC_PushCollisionActive;
	MiscFlags |= MISC_WallCollisionActive;
	MiscFlags |= MISC_FloorCollisionActive;
	MiscFlags |= MISC_InertiaEnable;
	InvulnFlags = 0;
	GetStateMachine(StateMachine_Primary).EnableFlags = 0;

	// Reset offset, as the offset should be applied
	PrevOffsetX = 0;
	PrevOffsetY = 0;
	NextOffsetX = 0;
	NextOffsetY = 0;

	// Reset root motion params
	ApplyRootMotion();

	// Reset angle
	AnglePitch_x1000 = 0;
	AngleYaw_x1000 = 0;
	AngleRoll_x1000 = 0;
	
	PosZ = 0;

	// Reset speed modifiers
	Gravity = JumpGravity;
	SpeedXRate = 100;
	SpeedXRatePerFrame = 100;
	SpeedYRate = 100;
	SpeedYRatePerFrame = 100;

	// Reset action data
	ActionTime = 0;
	AnimFrame = 0;
	BlendAnimFrame = 0;
	CelIndex = 0;
	TimeUntilNextCel = 0;
	for (auto& Handler : EventHandlers)
		Handler = FEventHandler();

	// Reset action registers
	ActionReg1 = 0;
	ActionReg2 = 0;
	ActionReg3 = 0;
	ActionReg4 = 0;
	ActionReg5 = 0;
	ActionReg6 = 0;
	ActionReg7 = 0;
	ActionReg8 = 0;

	// Miscellaneous resets
	PushWidthExtend = 0;
	FlipInputs = false;
	for (int32& CancelOption : AutoComboCancels)
	{
		CancelOption = -1;
	}
	GetStateMachine(StateMachine_Primary).EnabledCustomStateTypes.Empty();
	for (auto& StateMachine : SubStateMachines)
	{
		StateMachine.EnabledCustomStateTypes.Empty();
	}
	ChainCancelOptions.Empty();
	WhiffCancelOptions.Empty();
	HitCommon = FHitDataCommon();
	NormalHit = FHitData();
	CounterHit = FHitData();
	CelName = FGameplayTag();
	BlendCelName = FGameplayTag();
	LastStateName = GetCurrentStateName(StateMachine_Primary);
	HomingParams = FHomingParams();
	SuperArmorData = FSuperArmorData();
	UpdateTime = 0;
	ObjectOffset = FVector::ZeroVector;
	ObjectRotation = FRotator::ZeroRotator;
	ObjectScale = FVector::OneVector;
	bRender = true;
	Transparency = 1;
	FadeTransparency = 1;
	TransparencySpeed = 0;
	DamageColor = FLinearColor(1, 1, 1, 1);
	DamageColor2 = FLinearColor(1, 1, 1, 1);
}

void APlayerObject::PostStateChange()
{
	CallSubroutine(Subroutine_Cmn_PostStateChange);
	CallSubroutine(Subroutine_PostStateChange);

	if (StunTime == 0 && PrimaryStateMachine.CurrentState->StateType != EStateType::Hitstun)
	{
		PlayerFlags &= ~PLF_IsStunned;
		DisableState(ENB_Tech, StateMachine_Primary);
	}
	
	if (!CheckIsStunned())
	{
		PlayerFlags &= ~PLF_ReceivedCounterHit;
	}
	AttackFlags &= ~ATK_HasHit;

	MovesUsedInCombo.Add(PrimaryStateMachine.GetStateIndex(GetCurrentStateName(StateMachine_Primary)));
	if (PrimaryStateMachine.CurrentState->StateType >= EStateType::NormalAttack
		&& PrimaryStateMachine.CurrentState->StateType <= EStateType::SuperAttack)
	{
		const FGameplayTag MoveChainName = PrimaryStateMachine.CurrentState->ShareChainName != FGameplayTag::EmptyTag
			                                   ? PrimaryStateMachine.CurrentState->ShareChainName
			                                   : PrimaryStateMachine.CurrentState->Name;
		MovesUsedInChain.Add(PrimaryStateMachine.GetStateIndex(MoveChainName));
	}
	else
	{
		MovesUsedInChain.Empty();
	}
	PrimaryStateMachine.CurrentState->ResetToCDO();
}

void APlayerObject::RoundInit(bool ResetHealth)
{
	OrthoBlendActive = 1;
	StoredInputBuffer = FInputBuffer();
	if (PlayerIndex == 0)
	{
		PosX = -GameState->BattleState.RoundStartPos;
	}
	else
	{
		PosX = GameState->BattleState.RoundStartPos;
	}
	PosY = 0;
	PosZ = 0;
	PrevPosX = 0;
	PrevPosY = 0;
	PrevPosZ = 0;
	SpeedX = 0;
	SpeedY = 0;
	SpeedZ = 0;
	Gravity = JumpGravity;
	Inertia = 0;
	Pushback = 0;
	ActionTime = 0;
	PushHeight = 0;
	PushHeightLow = 0;
	PushWidth = 0;
	PushWidthExtend = 0;
	Hitstop = 0;
	L = 0;
	R = 0;
	T = 0;
	B = 0;
	HitCommon = FHitDataCommon();
	NormalHit = FHitData();
	CounterHit = FHitData();
	ReceivedHitCommon = FHitDataCommon();
	ReceivedHit = FHitData();
	AttackFlags = 0;
	StunTime = 0;
	StunTimeMax = 0;
	Hitstop = 0;
	MiscFlags = 0;
	MiscFlags |= MISC_PushCollisionActive;
	MiscFlags |= MISC_WallCollisionActive;
	MiscFlags |= MISC_FloorCollisionActive;
	MiscFlags |= MISC_InertiaEnable;
	Direction = DIR_Right;
	SpeedXRate = 100;
	SpeedXRatePerFrame = 100;
	SpeedYRate = 100;
	SpeedYRatePerFrame = 100;
	SpeedZRate = 100;
	SpeedZRatePerFrame = 100;
	GroundHeight = 0;
	ActionReg1 = 0;
	ActionReg2 = 0;
	ActionReg3 = 0;
	ActionReg4 = 0;
	ActionReg5 = 0;
	ActionReg6 = 0;
	ActionReg7 = 0;
	ActionReg8 = 0;
	ObjectReg1 = 0;
	ObjectReg2 = 0;
	ObjectReg3 = 0;
	ObjectReg4 = 0;
	ObjectReg5 = 0;
	ObjectReg6 = 0;
	ObjectReg7 = 0;
	ObjectReg8 = 0;
	SubroutineReg1 = 0;
	SubroutineReg2 = 0;
	SubroutineReg3 = 0;
	SubroutineReg4 = 0;
	SubroutineReturnVal1 = 0;
	SubroutineReturnVal2 = 0;
	SubroutineReturnVal3 = 0;
	SubroutineReturnVal4 = 0;
	IsPlayer = true;
	AttackTarget = nullptr;
	AttackOwner = nullptr;
	StopLinkObj = nullptr;
	PositionLinkObj = nullptr;
	MaterialLinkObj = nullptr;
	Timer0 = 0;
	Timer1 = 0;
	HomingParams = FHomingParams();
	SuperArmorData = FSuperArmorData();
	UpdateTime = 0;
	ObjectOffset = FVector::ZeroVector;
	ObjectRotation = FRotator::ZeroRotator;
	ObjectScale = FVector::OneVector;
	CelName = FGameplayTag();
	BlendCelName = FGameplayTag();
	AnimFrame = 0;
	BlendAnimFrame = 0;
	FrameBlendPosition = 0;
	CelIndex = 0;
	TimeUntilNextCel = 0;
	for (auto& Handler : EventHandlers)
		Handler = FEventHandler();
	SocketName = FName();
	SocketObj = OBJ_Self;
	SocketOffset = FVector::ZeroVector;
	ObjectScale = FVector::OneVector;
	AddColor = FLinearColor(0, 0, 0, 1);
	MulColor = FLinearColor(1, 1, 1, 1);
	AddFadeColor = FLinearColor(0, 0, 0, 1);
	MulFadeColor = FLinearColor(1, 1, 1, 1);
	AddFadeSpeed = 0;
	MulFadeSpeed = 0;
	Transparency = 1;
	FadeTransparency = 1;
	TransparencySpeed = 0;
	DamageColor = FLinearColor(1, 1, 1, 1);
	DamageColor2 = FLinearColor(1, 1, 1, 1);
	bRender = true;
	ObjectsToIgnoreHitsFrom.Empty();
	for (auto& Box : Boxes)
	{
		Box = FCollisionBox();
	}
	PlayerReg1 = 0;
	PlayerReg2 = 0;
	PlayerReg3 = 0;
	PlayerReg4 = 0;
	PlayerReg5 = 0;
	PlayerReg6 = 0;
	PlayerReg7 = 0;
	PlayerReg8 = 0;
	CmnPlayerReg1 = 0;
	CmnPlayerReg2 = 0;
	CmnPlayerReg3 = 0;
	CmnPlayerReg4 = 0;
	CmnPlayerReg5 = 0;
	CmnPlayerReg6 = 0;
	CmnPlayerReg7 = 0;
	CmnPlayerReg8 = 0;
	IntroEndFlag = false;
	RoundEndFlag = false;
	SubroutineReg1 = 0;
	SubroutineReg2 = 0;
	SubroutineReg3 = 0;
	SubroutineReg4 = 0;
	Inputs = 0;
	FlipInputs = false;
	Stance = ACT_Standing;
	if (ResetHealth)
	{
		CurrentHealth = MaxHealth;
		RecoverableHealth = 0;
	}
	TotalProration = 10000;
	ComboCounter = 0;
	ComboTimer = 0;
	ThrowTechWindow = 6;
	InvulnFlags = 0;
	PlayerFlags &= ~PLF_IsDead;
	PlayerFlags &= ~PLF_ThrowActive;
	PlayerFlags &= ~PLF_HitgrabActive;
	PlayerFlags &= ~PLF_IsStunned;
	PlayerFlags &= ~PLF_IsThrowLock;
	PlayerFlags &= ~PLF_DeathCamOverride;
	PlayerFlags &= ~PLF_IsKnockedDown;
	PlayerFlags &= ~PLF_RoundWinInputLock;
	PlayerFlags &= ~PLF_LockOpponentBurst;
	PlayerFlags &= ~PLF_ForceEnableFarNormal;
	PlayerFlags |= PLF_DefaultLandingAction;
	StrikeInvulnerableTimer = 0;
	ThrowInvulnerableTimer = 0;
	ThrowResistTimer = 0;
	for (auto& Gauge : ExtraGauges)
		Gauge.Value = Gauge.InitialValue;
	AirDashTimer = 0;
	OTGCount = 0;
	RoundWinTimer = 120;
	for (auto& StoredObj : StoredBattleObjects)
		StoredObj = nullptr;
	CurrentAirJumpCount = AirJumpCount;
	CurrentAirDashCount = AirDashCount;
	AirDashTimerMax = 0;
	CancelFlags = 0;
	GetStateMachine(StateMachine_Primary).EnableFlags = 0;
	for (auto& StateMachine : SubStateMachines)
	{
		if (!StateMachine.States.IsEmpty())
			StateMachine.CurrentState = StateMachine.States[0];
		StateMachine.EnableFlags = 0;
	}
	AirDashNoAttackTime = 0;
	InstantBlockLockoutTimer = 0;
	MeterCooldownTimer = 0;
	for (auto& LinkActor : StoredLinkActors)
	{
		if (!LinkActor.StoredActor) continue;
		LinkActor.bIsActive = false;
		LinkActor.StoredActor->SetActorHiddenInGame(true);
	}
	for (int32& CancelOption : AutoComboCancels)
	{
		CancelOption = -1;
	}
	GetStateMachine(StateMachine_Primary).EnabledCustomStateTypes.Empty();
	for (auto& StateMachine : SubStateMachines)
	{
		StateMachine.EnabledCustomStateTypes.Empty();
	}
	ChainCancelOptions.Empty();
	WhiffCancelOptions.Empty();
	MovesUsedInCombo.Empty();
	LastStateName = FGameplayTag();
	ExeStateName = FGameplayTag();
	BufferedStateName = FGameplayTag();
	WallTouchTimer = 0;
	GameState->BattleState.MaxMeter[PlayerIndex] = MaxMeter;
	SetDefaultComponentVisibility();
	if (PlayerIndex == 1)
	{
		SetFacing(DIR_Left);
	}
	RoundInit_BP();

	CallSubroutine(Subroutine_Cmn_RoundInit);
	CallSubroutine(Subroutine_RoundInit);
}

void APlayerObject::HandleFlipInput()
{
	if ((Direction == DIR_Left && !FlipInputs) || (FlipInputs && Direction == DIR_Right))
		//flip inputs with direction
	{
		Inputs = FlipInput(Inputs);
	}
}

void APlayerObject::HandleEndCombo()
{
	if (!CheckIsStunned() && IsMainPlayer() && Enemy->ComboCounter)
	{
		Enemy->ComboCounter = 0;
		Enemy->ComboTimer = 0;
		Enemy->CallSubroutine(Subroutine_Cmn_OnComboEnd);
		Enemy->CallSubroutine(Subroutine_OnComboEnd);
		ReceivedHitCommon = FHitDataCommon();
		ReceivedHit = FHitData();
		TotalProration = 10000;
		OTGCount = 0;
		bCrumpled = false;
	}
}

void APlayerObject::SaveForRollbackPlayer(unsigned char* Buffer) const
{
	FMemory::Memcpy(Buffer, &PlayerSync, SizeOfPlayerObject);
}

TArray<uint8> APlayerObject::SaveForRollbackBP()
{
	TArray<uint8> SaveData;
	FObjectWriter Writer(SaveData);
	Writer.ArIsSaveGame = true;
	GetClass()->SerializeBin(Writer, this);
	return SaveData;
}

void APlayerObject::LoadForRollbackPlayer(const unsigned char* Buffer)
{
	FMemory::Memcpy(&PlayerSync, Buffer, SizeOfPlayerObject);
}

void APlayerObject::LoadForRollbackBP(TArray<uint8> InBytes)
{
	if (InBytes.Num() <= 1) return;
	FObjectReader Reader(InBytes);
	Reader.ArIsSaveGame = true;
	GetClass()->SerializeBin(Reader, this);
}

void APlayerObject::EnableState(int32 EnableType, FGameplayTag StateMachineName)
{
	GetStateMachine(StateMachineName).EnableFlags |= EnableType;
}

void APlayerObject::DisableState(int32 EnableType, FGameplayTag StateMachineName)
{
	GetStateMachine(StateMachineName).EnableFlags = GetStateMachine(StateMachineName).EnableFlags & ~EnableType;
}

int32 APlayerObject::GetEnableFlags(FGameplayTag StateMachineName)
{
	return GetStateMachine(StateMachineName).EnableFlags;
}

void APlayerObject::EnableCustomState(FGameplayTag CustomStateType, FGameplayTag StateMachineName)
{
	GetStateMachine(StateMachineName).EnabledCustomStateTypes.AddUnique(CustomStateType);
}

void APlayerObject::DisableCustomState(FGameplayTag CustomStateType, FGameplayTag StateMachineName)
{
	GetStateMachine(StateMachineName).EnabledCustomStateTypes.Remove(CustomStateType);
}

void APlayerObject::EnableAttacks()
{
	EnableState(ENB_NormalAttack, StateMachine_Primary);
	EnableState(ENB_SpecialAttack, StateMachine_Primary);
	EnableState(ENB_SuperAttack, StateMachine_Primary);
}

void APlayerObject::EnableCancelIntoSelf(bool Enable)
{
	if (Enable)
	{
		CancelFlags |= CNC_CancelIntoSelf;
	}
	else
	{
		CancelFlags &= ~CNC_CancelIntoSelf;
	}
}

void APlayerObject::EnableAll(FGameplayTag StateMachineName)
{
	EnableState(ENB_Standing, StateMachineName);
	EnableState(ENB_Crouching, StateMachineName);
	EnableState(ENB_Jumping, StateMachineName);
	EnableState(ENB_ForwardWalk, StateMachineName);
	EnableState(ENB_BackWalk, StateMachineName);
	EnableState(ENB_ForwardDash, StateMachineName);
	EnableState(ENB_BackDash, StateMachineName);
	EnableState(ENB_ForwardAirDash, StateMachineName);
	EnableState(ENB_BackAirDash, StateMachineName);
	EnableState(ENB_NormalAttack, StateMachineName);
	EnableState(ENB_SpecialAttack, StateMachineName);
	EnableState(ENB_SuperAttack, StateMachineName);
	EnableState(ENB_Block, StateMachineName);
	EnableState(ENB_ProximityBlock, StateMachineName);
	EnableState(ENB_Tech, StateMachineName);
	EnableState(ENB_Burst, StateMachineName);
	EnableState(ENB_Tag, StateMachineName);
	EnableState(ENB_Assist, StateMachineName);
}

void APlayerObject::DisableAll(FGameplayTag StateMachineName)
{
	DisableState(ENB_Standing, StateMachineName);
	DisableState(ENB_Crouching, StateMachineName);
	DisableState(ENB_Jumping, StateMachineName);
	DisableState(ENB_ForwardWalk, StateMachineName);
	DisableState(ENB_BackWalk, StateMachineName);
	DisableState(ENB_ForwardDash, StateMachineName);
	DisableState(ENB_BackDash, StateMachineName);
	DisableState(ENB_ForwardAirDash, StateMachineName);
	DisableState(ENB_BackAirDash, StateMachineName);
	DisableState(ENB_NormalAttack, StateMachineName);
	DisableState(ENB_SpecialAttack, StateMachineName);
	DisableState(ENB_SuperAttack, StateMachineName);
	DisableState(ENB_Block, StateMachineName);
	DisableState(ENB_ProximityBlock, StateMachineName);
	DisableState(ENB_Tech, StateMachineName);
	DisableState(ENB_Burst, StateMachineName);
	DisableState(ENB_Tag, StateMachineName);
	DisableState(ENB_Assist, StateMachineName);
}

bool APlayerObject::CheckInput(const FInputCondition& Input)
{
	return StoredInputBuffer.CheckInputCondition(Input);
}

bool APlayerObject::CheckIsAttacking() const
{
	return AttackFlags & ATK_IsAttacking;
}

bool APlayerObject::CheckHasHit() const
{
	return AttackFlags & ATK_HasHit;
}

bool APlayerObject::CheckIsStunned() const
{
	return PlayerFlags & PLF_IsStunned || PlayerFlags & PLF_IsThrowLock || PlayerFlags & PLF_IsDead
		|| PrimaryStateMachine.CurrentState->StateType == EStateType::Hitstun
		|| PrimaryStateMachine.CurrentState->StateType == EStateType::Blockstun;
}

void APlayerObject::AddAirJump(int32 NewAirJump)
{
	CurrentAirJumpCount += NewAirJump;
}

void APlayerObject::ResetAirJump()
{
	CurrentAirJumpCount = AirJumpCount;
}

void APlayerObject::AddAirDash(int32 NewAirDash)
{
	CurrentAirDashCount += NewAirDash;
}

void APlayerObject::ResetAirDash()
{
	CurrentAirDashCount = AirDashCount;
}

void APlayerObject::SetAirDashTimer(bool IsForward)
{
	if (IsForward)
		AirDashTimer = FAirDashTime + 1;
	else
		AirDashTimer = BAirDashTime + 1;
}

void APlayerObject::SetAirDashNoAttackTimer(bool IsForward)
{
	if (IsForward)
		AirDashNoAttackTime = FAirDashNoAttackTime + 1;
	else
		AirDashNoAttackTime = BAirDashNoAttackTime + 1;
}

void APlayerObject::AddChainCancelOption(FGameplayTag Option)
{
	ChainCancelOptions.AddUnique(PrimaryStateMachine.GetStateIndex(Option));
}

void APlayerObject::AddAutoComboCancel(FGameplayTag Option, EInputFlags Button)
{
	int32 Index;
	switch (Button)
	{
	case INP_A:
	default:
		Index = 0;
		break;
	case INP_B:
		Index = 1;
		break;
	case INP_C:
		Index = 2;
		break;
	case INP_D:
		Index = 3;
		break;
	case INP_E:
		Index = 4;
		break;
	case INP_F:
		Index = 5;
		break;
	case INP_G:
		Index = 6;
		break;
	case INP_H:
		Index = 7;
		break;
	}

	AutoComboCancels[Index] = PrimaryStateMachine.GetStateIndex(Option);
}

void APlayerObject::AddWhiffCancelOption(FGameplayTag Option)
{
	WhiffCancelOptions.AddUnique(PrimaryStateMachine.GetStateIndex(Option));
}

void APlayerObject::RemoveChainCancelOption(FGameplayTag Option)
{
	ChainCancelOptions.Remove(PrimaryStateMachine.GetStateIndex(Option));
}

void APlayerObject::RemoveAutoComboCancel(EInputFlags Button)
{
	int32 Index;
	switch (Button)
	{
	case INP_A:
		Index = 0;
		break;
	case INP_B:
		Index = 1;
		break;
	case INP_C:
		Index = 2;
		break;
	case INP_D:
		Index = 3;
		break;
	case INP_E:
		Index = 4;
		break;
	case INP_F:
		Index = 5;
		break;
	case INP_G:
		Index = 6;
		break;
	case INP_H:
		Index = 7;
		break;
	default: return;
	}

	AutoComboCancels[Index] = -1;
}

void APlayerObject::RemoveWhiffCancelOption(FGameplayTag Option)
{
	WhiffCancelOptions.Remove(PrimaryStateMachine.GetStateIndex(Option));
}

void APlayerObject::ClearMovesUsedInChain()
{
	MovesUsedInChain.Empty();
}

void APlayerObject::EnableChainCancel(bool Enable)
{
	if (Enable)
	{
		CancelFlags |= CNC_ChainCancelEnabled;
	}
	else
	{
		CancelFlags &= ~CNC_ChainCancelEnabled;
	}
}

void APlayerObject::EnableWhiffCancel(bool Enable)
{
	if (Enable)
	{
		CancelFlags |= CNC_WhiffCancelEnabled;
	}
	else
	{
		CancelFlags &= ~CNC_WhiffCancelEnabled;
	}
}

void APlayerObject::EnableReverseBeat(bool Enable)
{
	if (Enable)
	{
		CancelFlags |= CNC_EnableReverseBeat;
	}
	else
	{
		CancelFlags &= ~CNC_EnableReverseBeat;
	}
}

void APlayerObject::EnableJumpCancel(bool Enable)
{
	if (Enable)
	{
		CancelFlags |= CNC_JumpCancel;
	}
	else
	{
		CancelFlags &= ~CNC_JumpCancel;
	}
}

void APlayerObject::EnableSpecialCancel(bool Enable)
{
	if (Enable)
	{
		CancelFlags |= CNC_SpecialCancel;
		CancelFlags |= CNC_SuperCancel;
	}
	else
	{
		CancelFlags &= ~CNC_SpecialCancel;
		CancelFlags &= ~CNC_SuperCancel;
	}
}

void APlayerObject::EnableSuperCancel(bool Enable)
{
	if (Enable)
	{
		CancelFlags |= CNC_SuperCancel;
	}
	else
	{
		CancelFlags &= ~CNC_SuperCancel;
	}
}

void APlayerObject::EnableForwardAirdashCancel(bool Enable)
{
	if (Enable)
	{
		CancelFlags |= CNC_FAirDashCancel;
	}
	else
	{
		CancelFlags &= ~CNC_FAirDashCancel;
	}
}

void APlayerObject::SetDefaultLandingAction(bool Enable)
{
	if (Enable)
	{
		PlayerFlags |= PLF_DefaultLandingAction;
	}
	else
	{
		PlayerFlags &= ~PLF_DefaultLandingAction;
	}
}

void APlayerObject::SetKnockdownState()
{
	StunTime = 0;
	StunTimeMax = 0;
	PlayerFlags |= PLF_IsKnockedDown;
	if ((PlayerFlags & PLF_IsHardKnockedDown) == 0 && !(PlayerFlags & PLF_IsDead))
		EnableState(ENB_Tech, StateMachine_Primary);
}

bool APlayerObject::IsTouchingWall() const
{
	return PlayerFlags & PLF_TouchingWall;
}

bool APlayerObject::IsInvulnerable(const ABattleObject* Attacker) const
{
	if (IsInvulnerable_BP()) return true;
	
	if (PlayerFlags & PLF_IsThrowLock && Attacker != Enemy) return true;
	if (Enemy->PlayerFlags & PLF_IsThrowLock) return true;
	if (InvulnFlags & INV_StrikeInvulnerable || StrikeInvulnerableTimer) return true;
	if (Attacker->AttackFlags & ATK_AttackHeadAttribute && InvulnFlags & INV_HeadInvulnerable) return true;
	if (Attacker->AttackFlags & ATK_AttackProjectileAttribute && InvulnFlags & INV_ProjectileInvulnerable) return true;
	if ((Attacker->AttackFlags & ATK_HitOTG) == 0 && PlayerFlags & PLF_IsKnockedDown) return true;
	
	return false;
}

void APlayerObject::SetStrikeInvulnerable(bool Invulnerable)
{
	if (Invulnerable)
	{
		InvulnFlags |= INV_StrikeInvulnerable;
	}
	else
	{
		InvulnFlags &= ~INV_StrikeInvulnerable;
	}
}

void APlayerObject::SetThrowInvulnerable(bool Invulnerable)
{
	if (Invulnerable)
	{
		InvulnFlags |= INV_ThrowInvulnerable;
	}
	else
	{
		InvulnFlags &= ~INV_ThrowInvulnerable;
	}
}

void APlayerObject::SetHeadInvulnerable(bool Invulnerable)
{
	if (Invulnerable)
	{
		InvulnFlags |= INV_HeadInvulnerable;
	}
	else
	{
		InvulnFlags &= ~INV_HeadInvulnerable;
	}
}

void APlayerObject::SetProjectileInvulnerable(bool Invulnerable)
{
	if (Invulnerable)
	{
		InvulnFlags |= INV_ProjectileInvulnerable;
	}
	else
	{
		InvulnFlags &= ~INV_ProjectileInvulnerable;
	}
}

void APlayerObject::SetStrikeInvulnerableForTime(int32 Timer)
{
	StrikeInvulnerableTimer = Timer;
}

void APlayerObject::SetThrowInvulnerableForTime(int32 Timer)
{
	ThrowInvulnerableTimer = Timer;
}

void APlayerObject::SetThrowResistForTime(int32 Timer)
{
	ThrowResistTimer = Timer;
}

void APlayerObject::SetStunTime(int32 NewTime)
{
	StunTime = NewTime;
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/PlayerObject.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "BattleObject.h"
#include "NativeGameplayTags.h"
#include "NightSkyEngine/Battle/Misc/InputBuffer.h"
#include "NightSkyEngine/Battle/Script/State.h"
#include "NightSkyEngine/Battle/Script/StateMachine.h"
#include "NightSkyEngine/Data/CollisionData.h"
#include "NightSkyEngine/Data/SequenceData.h"
#include "NightSkyEngine/Data/SoundData.h"
#include "NightSkyEngine/Data/StateData.h"
#include "PlayerObject.generated.h"

class ULinkActorData;
class USubroutine;
class UCameraShakeData;
constexpr int32 MaxComponentCount = 64;

class USubroutineData;
class UStateData;
class UParticleData;
class UMaterialData;

UENUM(BlueprintType)
enum EActionStance
{
	ACT_Standing,
	ACT_Crouching,
	ACT_Jumping,
};

USTRUCT(BlueprintType)
struct FExtraGauge
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame)
	int32 Value;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame)
	int32 InitialValue;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame)
	int32 MaxValue;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame)
	int32 Sections;
};

UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Blowback_1);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Blowback_2);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Blowback_3);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Blowback_4);

UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Block_PreGuard);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Block_Level1);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Block_Level2);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Block_Level3);

UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_IsCorrectBlock);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_HitCollision);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnBlock);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnHit);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnCounterHit);

USTRUCT(BlueprintType)
struct FPlayerObjectLog : public FBattleObjectLog
{
	GENERATED_BODY()
	
	//Starting from this until PlayerSyncEnd, everything is saved/loaded for rollback.
	unsigned char PlayerSync;

	/*
	 * Default values
	 */

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FWalkSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BWalkSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FDashInitSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FDashAccel;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FDashMaxSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FDashFriction;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BDashSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BDashHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BDashGravity;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 JumpHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FJumpSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BJumpSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 JumpGravity;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 SuperJumpHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FSuperJumpSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BSuperJumpSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 SuperJumpGravity;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirDashMinimumHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FAirDashSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BAirDashSpeed;
	// Time until forward air dash properties stop applying.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FAirDashTime;
	// Time until backward air dash properties stop applying.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BAirDashTime;
	// Time until forward air dash can be cancelled.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FAirDashNoAttackTime;
	// Time until backward air dash can be cancelled.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BAirDashNoAttackTime;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirJumpCount;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirDashCount;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 StandPushWidth;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 StandPushHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 CrouchPushWidth;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 CrouchPushHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirPushWidth;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirPushHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirPushHeightLow;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 CloseNormalRange;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MaxHealth;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MaxMeter = 10000;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ComboRate = 60;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 OtgProration = 80;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ForwardWalkMeterGain;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ForwardJumpMeterGain;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ForwardDashMeterGain;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ForwardAirDashMeterGain;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MeterPercentOnHit = 72;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MeterPercentOnHitGuard = 18;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MeterPercentOnReceiveHitGuard = 10;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MeterPercentOnReceiveHit = 40;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	bool CanReverseBeat;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	bool CanProximityThrow;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	FInputCondition ProximityThrowInput;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ThrowTechWindow = 6;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ThrowResistAfterWakeUp = 5;

	/*
	 * Player registers. These are only touched by the engine to reset per round.
	 * Use these to keep track of values (timers, toggles, counters, etc) that are character-specific.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg4 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg5 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg6 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg7 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg8 = 0;

	/*
	 * Common player registers. These are only touched by the engine to reset per round.
	 * These are meant to be used by any character.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg4 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg5 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg6 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg7 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg8 = 0;

	UPROPERTY(BlueprintReadWrite)
	bool IntroEndFlag = false;
	UPROPERTY(BlueprintReadWrite)
	bool RoundEndFlag = false;

	/*
	 * Input data.
	 */
	uint32 Inputs;

	FInputBuffer StoredInputBuffer;

	/*
	 * Miscellaneous values.
	 */

	// If true, inputs will operate as if the character is facing the opposite direction.
	UPROPERTY(BlueprintReadWrite)
	bool FlipInputs;
	UPROPERTY(EditAnywhere, Category=Defaults)
	int32 MaxOTGCount;
	UPROPERTY(EditAnywhere, Category=Defaults)
	bool bLimitCrumple = true;

	UPROPERTY(BlueprintReadOnly)
	int32 PlayerIndex;
	UPROPERTY(BlueprintReadOnly)
	int32 TeamIndex;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	TEnumAsByte<EActionStance> Stance;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 CurrentHealth;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 RecoverableHealth;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 ComboCounter;
	
	int32 TotalProration = 10000;
	int32 ComboTimer;
	uint32 InvulnFlags = 0;
	uint32 PlayerFlags = 0;
	uint32 StrikeInvulnerableTimer = 0;
	uint32 ThrowInvulnerableTimer = 0;
	uint32 ThrowResistTimer = 0;
	uint32 AirDashTimer = 0;
	int32 OTGCount;
	bool bCrumpled;
	int32 RoundWinTimer = 120;
	int32 WallTouchTimer;

	/*
	 * Object pointers.
	 */

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	APlayerObject* Enemy;
	UPROPERTY()
	ABattleObject* StoredBattleObjects[16];

	bool ComponentVisible[MaxComponentCount];

	FGameplayTag StateEntryName;
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=Intro)
	FGameplayTag IntroName;

protected:
	/*
	 * Internal values.
	 */
	uint32 CurrentAirJumpCount = 0;
	uint32 CurrentAirDashCount = 0;
	uint32 AirDashTimerMax = 0;
	uint32 CancelFlags = 0;
	uint32 AirDashNoAttackTime = 0;
	uint32 InstantBlockLockoutTimer = 0;
	uint32 MeterCooldownTimer = 0;
	int32 ThrowRange = 0;
	int32 ThrowTechTimer = 0;

	//Auto combo cancels
	int32 AutoComboCancels[8] = {};

	UPROPERTY(BlueprintReadOnly)
	bool bIsAutoCombo = false;
	FGameplayTag LastStateName;
	FGameplayTag ExeStateName;
	FGameplayTag BufferedStateName;

public:
	// Anything past here isn't saved or loaded for rollback, unless it has the SaveGame tag.
	unsigned char PlayerSyncEnd;

	virtual void LogForSyncTestFile(std::ofstream& file) override;
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API APlayerObject : public ABattleObject
{
	GENERATED_BODY()

public:
	APlayerObject();

	//Starting from this until PlayerSyncEnd, everything is saved/loaded for rollback.
	unsigned char PlayerSync;

	/*
	 * Default values
	 */

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FWalkSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BWalkSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FDashInitSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FDashAccel;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FDashMaxSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FDashFriction;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BDashSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BDashHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BDashGravity;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 JumpHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FJumpSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BJumpSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 JumpGravity;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 SuperJumpHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FSuperJumpSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BSuperJumpSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 SuperJumpGravity;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirDashMinimumHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FAirDashSpeed;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BAirDashSpeed;
	// Time until forward air dash properties stop applying.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FAirDashTime;
	// Time until backward air dash properties stop applying.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BAirDashTime;
	// Time until forward air dash can be cancelled.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 FAirDashNoAttackTime;
	// Time until backward air dash can be cancelled.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 BAirDashNoAttackTime;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirJumpCount;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirDashCount;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 StandPushWidth;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 StandPushHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 CrouchPushWidth;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 CrouchPushHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirPushWidth;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirPushHeight;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 AirPushHeightLow;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 CloseNormalRange;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MaxHealth;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MaxMeter = 10000;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ComboRate = 60;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 OtgProration = 80;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ForwardWalkMeterGain;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ForwardJumpMeterGain;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ForwardDashMeterGain;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ForwardAirDashMeterGain;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MeterPercentOnHit = 72;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MeterPercentOnHitGuard = 18;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MeterPercentOnReceiveHitGuard = 10;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 MeterPercentOnReceiveHit = 40;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	bool CanReverseBeat;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	bool CanProximityThrow;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	FInputCondition ProximityThrowInput;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ThrowTechWindow = 6;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)
	int32 ThrowResistAfterWakeUp = 5;

	/*
	 * Player registers. These are only touched by the engine to reset per round.
	 * Use these to keep track of values (timers, toggles, counters, etc) that are character-specific.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg4 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg5 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg6 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg7 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 PlayerReg8 = 0;

	/*
	 * Common player registers. These are only touched by the engine to reset per round.
	 * These are meant to be used by any character.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg1 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg2 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg3 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg4 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg5 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg6 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg7 = 0;
	UPROPERTY(BlueprintReadWrite)
	int32 CmnPlayerReg8 = 0;

	UPROPERTY(BlueprintReadWrite)
	bool IntroEndFlag = false;
	UPROPERTY(BlueprintReadWrite)
	bool RoundEndFlag = false;

	/*
	 * Input data.
	 */
	uint32 Inputs;

	FInputBuffer StoredInputBuffer;

	/*
	 * Miscellaneous values.
	 */

	// If true, inputs will operate as if the character is facing the opposite direction.
	UPROPERTY(BlueprintReadWrite)
	bool FlipInputs;
	UPROPERTY(EditAnywhere, Category=Defaults)
	int32 MaxOTGCount;
	UPROPERTY(EditAnywhere, Category=Defaults)
	bool bLimitCrumple = true;

	UPROPERTY(BlueprintReadOnly)
	int32 PlayerIndex;
	UPROPERTY(BlueprintReadOnly)
	int32 TeamIndex;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	TEnumAsByte<EActionStance> Stance;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 CurrentHealth;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 RecoverableHealth;
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	int32 ComboCounter;
	
	int32 TotalProration = 10000;
	int32 ComboTimer;
	uint32 InvulnFlags = 0;
	uint32 PlayerFlags = 0;
	uint32 StrikeInvulnerableTimer = 0;
	uint32 ThrowInvulnerableTimer = 0;
	uint32 ThrowResistTimer = 0;
	uint32 AirDashTimer = 0;
	int32 OTGCount;
	bool bCrumpled;
	int32 RoundWinTimer = 120;
	int32 WallTouchTimer;

	/*
	 * Object pointers.
	 */

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	APlayerObject* Enemy;
	UPROPERTY()
	ABattleObject* StoredBattleObjects[16];

	bool ComponentVisible[MaxComponentCount];

	FGameplayTag StateEntryName;
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=Intro)
	FGameplayTag IntroName;

protected:
	/*
	 * Internal values.
	 */
	uint32 CurrentAirJumpCount = 0;
	uint32 CurrentAirDashCount = 0;
	uint32 AirDashTimerMax = 0;
	uint32 CancelFlags = 0;
	uint32 AirDashNoAttackTime = 0;
	uint32 InstantBlockLockoutTimer = 0;
	uint32 MeterCooldownTimer = 0;
	int32 ThrowRange = 0;
	int32 ThrowTechTimer = 0;

	//Auto combo cancels
	int32 AutoComboCancels[8] = {};

	UPROPERTY(BlueprintReadOnly)
	bool bIsAutoCombo = false;
	FGameplayTag LastStateName;
	FGameplayTag ExeStateName;
	FGameplayTag BufferedStateName;

public:
	// Anything past here isn't saved or loaded for rollback, unless it has the SaveGame tag.
	unsigned char PlayerSyncEnd;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
	bool bIsCpu = false;

	/*
	 * These properties are saved and loaded for rollback, as they have the SaveGame tag.
	 */
	
	UPROPERTY(SaveGame)
	FStateMachine PrimaryStateMachine;

	UPROPERTY(EditDefaultsOnly, SaveGame)
	TArray<FStateMachine> SubStateMachines;

	// All instances of actors needed for link actors.
	UPROPERTY(SaveGame)
	TArray<FLinkedActorContainer> StoredLinkActors;

	// Extra gauges.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame, Category=Defaults)
	TArray<FExtraGauge> ExtraGauges;

	//options to whiff cancel into
	UPROPERTY(SaveGame)
	TArray<int32> ChainCancelOptions;
	//options to chain cancel into
	UPROPERTY(SaveGame)
	TArray<int32> WhiffCancelOptions;
	//checks state indices for moves used in current combo
	UPROPERTY(SaveGame)
	TArray<int32> MovesUsedInCombo = {};
	//checks state indices for moves used in current combo
	UPROPERTY(SaveGame)
	TArray<int32> MovesUsedInChain = {};

	/*
	 * Defaults
	 */

	UPROPERTY(EditAnywhere, Category=Defaults)
	TMap<FGameplayTag, FGameplayTag> DamageReactionCels;
	UPROPERTY(EditAnywhere, Category=Defaults)
	bool bMirrorWhenFlip;

	/*
	 * States and subroutines
	*/

	UPROPERTY()
	TArray<USubroutine*> CommonSubroutines;
	TArray<FGameplayTag> CommonSubroutineNames;
	UPROPERTY()
	TArray<USubroutine*> Subroutines;
	TArray<FGameplayTag> SubroutineNames;

	UPROPERTY()
	TArray<UState*> CommonObjectStates;
	TArray<FGameplayTag> CommonObjectStateNames;
	UPROPERTY()
	TArray<UState*> ObjectStates;
	TArray<FGameplayTag> ObjectStateNames;

	/*
	 * Data assets
	 */

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	UCollisionData* CommonCollisionData;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	UCollisionData* CollisionData;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	USubroutineData* CommonSubroutineData;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	USubroutineData* CharaSubroutineData;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	UStateData* CommonObjectStateData;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	UStateData* ObjectStateData;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	UStateData* CharaStateData;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	TMap<FGameplayTag, UStateData*> SubStateData;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Assets)
	UMaterialData* MaterialData;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Assets)
	int32 ColorIndex = 1;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	int32 MaxColorIndex = 2;
	
	UPROPERTY(EditAnywhere, Category=Assets)
	ULinkActorData* CommonLinkActorData;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	ULinkActorData* LinkActorData;

	UPROPERTY(EditAnywhere, Category=Assets)
	UParticleData* CommonParticleData;
	UPROPERTY(EditAnywhere, Category=Assets)
	UParticleData* CharaParticleData;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	USequenceData* CommonSequenceData;
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)
	USequenceData* SequenceData;
	UPROPERTY(EditAnywhere, Category=Assets)
	UCameraShakeData* CameraShakeData;

	UPROPERTY(EditAnywhere, Category=Assets)
	USoundData* CommonSoundData;
	UPROPERTY(EditAnywhere, Category=Assets)
	USoundData* SoundData;
	UPROPERTY(EditAnywhere, Category=Assets)
	USoundData* VoiceData;

private:
	virtual void BeginPlay() override;

	void HandleLanding();
	//check state conditions
	bool HandleStateCondition(EStateCondition StateCondition) const;
	//check if chain cancel option exists
	bool FindChainCancelOption(const FGameplayTag Name, FStateMachine& StateMachine);
	//check if chain cancel option exists
	bool FindAutoComboCancelOption(const FGameplayTag Name, FStateMachine& StateMachine);
	//check if whiff cancel option exists
	bool FindWhiffCancelOption(const FGameplayTag Name, FStateMachine& StateMachine);
	//check reverse beat
	bool CheckReverseBeat(const FGameplayTag Name, FStateMachine& StateMachine);
	//checks moves used in combo
	bool CheckMovesUsedInChain(const FGameplayTag Name, FStateMachine& StateMachine);
	//handles throwing objects
	void HandleThrowCollision();
	//checks kara cancel
	bool CheckKaraCancel(EStateType InStateType, const FGameplayTag& CustomStateType, const FStateMachine& StateMachine);
	//checks if a child object with a corresponding object id exists. if so, do not enter state 
	bool CheckObjectPreventingState(int InObjectID) const;
	//handles wall bounce
	void HandleWallBounce();
	//handles ground bounce
	void HandleGroundBounce();
	void SetComponentVisibility() const;
	virtual void UpdateVisualsNoRollback() override;

public:
	//initialize player for match/round start
	void InitPlayer();
	//update object
	virtual void Update() override;
	// handle state machine
	void HandleStateMachine(bool Buffer, FStateMachine& StateMachine);
	// handle auto combos for state transition
	bool HandleAutoCombo(int32 StateIndex, FStateMachine& StateMachine);
	// handle input conditions for state transition
	bool HandleStateInputs(int32 StateIndex, bool Buffer, FStateMachine& StateMachine);
	// handle state transition
	bool HandleStateTransition(int32 StateIndex, bool Buffer, FStateMachine& StateMachine);
	//buffer state
	void HandleBufferedState();
	void HandleBufferedState(FStateMachine& StateMachine);
	//update object for non-battle modes (like character select)
	void UpdateNotBattle();
	//update object (editor only, compiled out otherwise)
	UFUNCTION(BlueprintNativeEvent)
	void EditorUpdate();
	//based on received hit action, choose state
	void HandleHitAction(EHitAction HACT);
	//upon successful throw, jump to state
	void ThrowExe();
	//set hit values over time
	void SetHitValuesOverTime();
	//check attack against block stance
	bool IsCorrectBlock(EBlockType BlockType);
	//jump to correct block state
	void HandleBlockAction();
	//handles proximity blocking
	void HandleProximityBlock();
	//called right before state changes
	void OnStateChange();
	//called right after state changes
	void PostStateChange();
	//resets object for next round
	void RoundInit(bool ResetHealth);
	void HandleFlipInput();
	void HandleEndCombo();
	
	static uint32 FlipInput(uint32 Input);
	
	
	void SaveForRollbackPlayer(unsigned char* Buffer) const;
	TArray<uint8> SaveForRollbackBP();
	void LoadForRollbackPlayer(const unsigned char* Buffer);
	void LoadForRollbackBP(TArray<uint8> InBytes);
	void EmptyStateMachine();

	// Only call when initializing the match.
	UFUNCTION(BlueprintImplementableEvent)
	void InitBP();
	// Only call when resetting player object for round.
	UFUNCTION(BlueprintImplementableEvent)
	void RoundInit_BP();

	/*
	 * Blueprint callable functions.
	 */
	//add state to state machine
	UFUNCTION(BlueprintCallable)
	void AddState(FGameplayTag Name, UState* State, FGameplayTag StateMachineName);
	//add object state
	UFUNCTION(BlueprintCallable)
	void AddObjectState(FGameplayTag Name, UState* State, bool IsCommon);
	//add subroutine to state machine
	UFUNCTION(BlueprintCallable)
	void AddSubroutine(FGameplayTag Name, USubroutine* Subroutine, bool IsCommon);
	UFUNCTION(BlueprintCallable)
	void SetHealth(int Value);
	UFUNCTION(BlueprintCallable)
	void AddHealth(int Value);
	UFUNCTION(BlueprintCallable)
	void SetRecoverableHealth(int Value);
	UFUNCTION(BlueprintCallable)
	void AddRecoverableHealth(int Value);
	UFUNCTION(BlueprintCallable)
	void RecoverHealth(int Value);
	//check if state can be entered
	UFUNCTION(BlueprintCallable)
	bool CanEnterState(UState* State, FGameplayTag StateMachineName);
	//use meter
	UFUNCTION(BlueprintCallable)
	void UseMeter(int Use);
	//add meter
	UFUNCTION(BlueprintCallable)
	void AddMeter(int Meter);
	//sets meter gain cooldown timer
	UFUNCTION(BlueprintCallable)
	void SetMeterCooldownTimer(int Timer);
	//set stance
	UFUNCTION(BlueprintCallable)
	void SetStance(EActionStance InStance);
	//force set state
	bool JumpToStatePrimary	(FGameplayTag NewName, bool IsLabel = false);
	//force set state
	UFUNCTION(BlueprintCallable, CallInEditor)
	bool JumpToState(FGameplayTag NewName, FGameplayTag StateMachineName, bool IsLabel = false);
	//force set state
	bool JumpToStateByClassPrimary(TSubclassOf<UState> Class, bool IsLabel = false);
	//force set state
	UFUNCTION(BlueprintCallable, CallInEditor)
	bool JumpToStateByClass(TSubclassOf<UState> Class, FGameplayTag StateMachineName, bool IsLabel = false);
	//gets current state name
	UFUNCTION(BlueprintPure)
	FGameplayTag GetCurrentStateName(FGameplayTag StateMachineName);
	//gets last state name
	UFUNCTION(BlueprintPure)
	FGameplayTag GetLastStateName() const;
	//gets state entry name
	UFUNCTION(BlueprintPure)
	FGameplayTag GetStateEntryName() const;
	// Get state machine by name.
	UFUNCTION(BlueprintPure)
	FStateMachine& GetStateMachine(FGameplayTag StateMachineName);
	// Get enable flags.
	UFUNCTION(BlueprintPure)
	int32 GetEnableFlags(FGameplayTag StateMachineName);
	// check if state can be entered
	UFUNCTION(BlueprintPure)
	bool CheckStateEnabled(EStateType StateType, FGameplayTag CustomStateType, FGameplayTag StateMachineName);
	//enable state type
	UFUNCTION(BlueprintCallable)
	void EnableState(UPARAM(meta = (Bitmask, BitmaskEnum = "/Script/NightSkyEngine.EEnableFlags"))
		int32 Bitmask, FGameplayTag StateMachineName);
	//disables state type
	UFUNCTION(BlueprintCallable)
	void DisableState(UPARAM(meta = (Bitmask, BitmaskEnum = "/Script/NightSkyEngine.EEnableFlags"))
		int32 Bitmask, FGameplayTag StateMachineName);
	//enable custom state type
	UFUNCTION(BlueprintCallable)
	void EnableCustomState(FGameplayTag CustomStateType, FGameplayTag StateMachineName);
	//disable custom state type
	UFUNCTION(BlueprintCallable)
	void DisableCustomState(FGameplayTag CustomStateType, FGameplayTag StateMachineName);
	//enable all attacks only
	UFUNCTION(BlueprintCallable)
	void EnableAttacks();
	//enable cancelling into same state
	UFUNCTION(BlueprintCallable)
	void EnableCancelIntoSelf(bool Enable);
	//enables all state types
	UFUNCTION(BlueprintCallable)
	void EnableAll(FGameplayTag StateMachineName);
	//disable all state types
	UFUNCTION(BlueprintCallable)
	void DisableAll(FGameplayTag StateMachineName);
	//checks input condition
	UFUNCTION(BlueprintPure)
	bool CheckInput(const FInputCondition& Input);
	//is attacking
	UFUNCTION(BlueprintPure)
	bool CheckIsAttacking() const;
	//has hit
	UFUNCTION(BlueprintPure)
	bool CheckHasHit() const;
	UFUNCTION(BlueprintPure)
	bool CheckIsStunned() const;
	//temporarily adds air jump
	UFUNCTION(BlueprintCallable)
	void AddAirJump(int32 NewAirJump);
	//reset air jump
	UFUNCTION(BlueprintCallable)
	void ResetAirJump();
	//temporarily adds air dash
	UFUNCTION(BlueprintCallable)
	void AddAirDash(int32 NewAirDash);
	//reset air jump
	UFUNCTION(BlueprintCallable)
	void ResetAirDash();
	//set air dash timer (set is forward for forward airdashes)
	UFUNCTION(BlueprintCallable)
	void SetAirDashTimer(bool IsForward);
	//set air dash timer (set is forward for forward airdashes)
	UFUNCTION(BlueprintCallable)
	void SetAirDashNoAttackTimer(bool IsForward);
	//add chain cancel option, use this in Init
	UFUNCTION(BlueprintCallable)
	void AddChainCancelOption(FGameplayTag Option);
	//add auto combo option, use this in Init
	UFUNCTION(BlueprintCallable)
	void AddAutoComboCancel(FGameplayTag Option, EInputFlags Button);
	//add whiff cancel option, use this in Init
	UFUNCTION(BlueprintCallable)
	void AddWhiffCancelOption(FGameplayTag Option);
	//remove chain cancel option
	UFUNCTION(BlueprintCallable)
	void RemoveChainCancelOption(FGameplayTag Option);
	//remove auto combo cancel
	UFUNCTION(BlueprintCallable)
	void RemoveAutoComboCancel(EInputFlags Button);
	//remove whiff cancel option
	UFUNCTION(BlueprintCallable)
	void RemoveWhiffCancelOption(FGameplayTag Option);
	UFUNCTION(BlueprintCallable)
	void ClearMovesUsedInChain();
	UFUNCTION(BlueprintCallable)
	void EnableChainCancel(bool Enable);
	//sets whiff cancel options enabled. off by default
	UFUNCTION(BlueprintCallable)
	void EnableWhiffCancel(bool Enable);
	//enables reverse beat
	UFUNCTION(BlueprintCallable)
	void EnableReverseBeat(bool Enable);
	//enables jump cnacel
	UFUNCTION(BlueprintCallable)
	void EnableJumpCancel(bool Enable);
	//sets special cancel enabled. off by default
	UFUNCTION(BlueprintCallable)
	void EnableSpecialCancel(bool Enable);
	//sets super cancel enabled. off by default
	UFUNCTION(BlueprintCallable)
	void EnableSuperCancel(bool Enable);
	//enables forward airdash cnacel
	UFUNCTION(BlueprintCallable)
	void EnableForwardAirdashCancel(bool Enable);
	//toggles default landing action. if true, landing will go to JumpLanding state. if false, define your own landing.
	UFUNCTION(BlueprintCallable)
	void SetDefaultLandingAction(bool Enable);
	UFUNCTION(BlueprintCallable)
	void SetKnockdownState();
	// check if touching wall
	UFUNCTION(BlueprintCallable)
	bool IsTouchingWall() const;
	//checks if invulnerable
	UFUNCTION(BlueprintPure)
	bool IsInvulnerable(const ABattleObject* Attacker) const;
	//sets strike invulnerable enabled
	UFUNCTION(BlueprintCallable)
	void SetStrikeInvulnerable(bool Invulnerable);
	//sets throw invulnerable enabled
	UFUNCTION(BlueprintCallable)
	void SetThrowInvulnerable(bool Invulnerable);
	UFUNCTION(BlueprintCallable)
	void SetHeadInvulnerable(bool Invulnerable);
	UFUNCTION(BlueprintCallable)
	void SetProjectileInvulnerable(bool Invulnerable);
	//sets strike invulnerable enabled for time
	UFUNCTION(BlueprintCallable)
	void SetStrikeInvulnerableForTime(int32 Timer);
	//sets throw invulnerable enabled for time
	UFUNCTION(BlueprintCallable)
	void SetThrowInvulnerableForTime(int32 Timer);
	//sets throw resist enabled for time
	UFUNCTION(BlueprintCallable)
	void SetThrowResistForTime(int32 Timer);
	//sets projectile invulnerable enabled
	//set stun time
	UFUNCTION(BlueprintCallable)
	void SetStunTime(int32 NewTime);
	//based on received hit data, set values
	UFUNCTION(BlueprintCallable)
	void SetHitValues(bool bCustomAir = false);
	//based on received guard data, set values
	UFUNCTION(BlueprintCallable)
	void SetGuardValues();
	//force enables far proximity normals
	UFUNCTION(BlueprintCallable)
	void ForceEnableFarNormal(bool Enable);
	UFUNCTION(BlueprintCallable)
	void SetHeadAttribute(bool Attribute);
	//initiate throw
	UFUNCTION(BlueprintCallable)
	void SetThrowActive(bool Active);
	//end throw
	UFUNCTION(BlueprintCallable)
	void ThrowEnd();
	//initiate throw range
	UFUNCTION(BlueprintCallable)
	void SetThrowRange(int32 InThrowRange);
	//sets throw execution state
	UFUNCTION(BlueprintCallable)
	void SetThrowExeState(FGameplayTag ExeState);
	//sets grip position for throw
	UFUNCTION(BlueprintCallable)
	void SetThrowPosition(int32 ThrowPosX, int32 ThrowPosY);
	//sets grip position for throw
	UFUNCTION(BlueprintCallable)
	void SetDamageReactionCel(FGameplayTag Type);
	// initiate hitgrab
	UFUNCTION(BlueprintCallable)
	void SetHitgrabActive(bool Active);
	//plays voice line
	UFUNCTION(BlueprintCallable)
	void PlayVoiceLine(FGameplayTag Name);
	//plays common level sequence
	UFUNCTION(BlueprintCallable)
	void PlayCommonLevelSequence(FGameplayTag Name);
	//plays character level sequence
	UFUNCTION(BlueprintCallable)
	void PlayLevelSequence(FGameplayTag Name);
	//stop level sequence
	UFUNCTION(BlueprintCallable)
	void StopLevelSequence();
	//toggles hud visibility
	UFUNCTION(BlueprintCallable)
	void BattleHudVisibility(bool Visible);
	//ends round
	UFUNCTION(BlueprintCallable)
	void EndRound() const;
	//match round
	UFUNCTION(BlueprintCallable)
	void EndMatch() const;
	//pauses round timer
	UFUNCTION(BlueprintCallable)
	void PauseRoundTimer(bool Pause);
	//stores battle actor in slot
	UFUNCTION(BlueprintCallable)
	void AddBattleObjectToStorage(ABattleObject* InActor, int Index);
	UFUNCTION(BlueprintCallable)
	APlayerObject* CallAssist(int AssistIndex, FGameplayTag AssistName);
	UFUNCTION(BlueprintCallable)
	APlayerObject* SwitchMainPlayer(int NewTeamIndex, bool bForce = false, bool bEvenOnScreen = false);
	UFUNCTION(BlueprintCallable)
	void SetTeamCooldown(int NewTeamIndex, int Cooldown);
	UFUNCTION(BlueprintPure)
	bool IsMainPlayer() const;
	UFUNCTION(BlueprintPure)
	bool IsOnScreen() const;
	UFUNCTION(BlueprintCallable)
	void SetOnScreen(bool OnScreen);
	UFUNCTION(BlueprintCallable)
	void ToggleComponentVisibility(FName ComponentName, bool Visible);
	UFUNCTION(BlueprintImplementableEvent, BlueprintCallable)
	void SetDefaultComponentVisibility();
	UFUNCTION(BlueprintImplementableEvent)
	bool IsInvulnerable_BP() const;
	
	// Intended for CPU opponents
	void SetStateForCPU(FGameplayTag StateName, FGameplayTag StateMachineName);
	bool CheckEnemyInRange(int32 XBegin, int32 XEnd, int32 YBegin, int32 YEnd) const;
	bool IsEnemyAttackState() const;
	bool IsEnemyThrow() const;
	bool IsEnemyBlocking() const;
	EBlockType GetAttackBlockType() const;
};

constexpr size_t SizeOfPlayerObject = offsetof(APlayerObject, PlayerSyncEnd) - offsetof(APlayerObject, PlayerSync);

#if WITH_EDITOR
static_assert(offsetof(FPlayerObjectLog, PlayerSyncEnd) - offsetof(FPlayerObjectLog, PlayerSync) == SizeOfPlayerObject, "FPlayerObjectLog must contain all members from ABattleObject between PlayerSync and PlayerSyncEnd");
#endif
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/BattleExtension.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "BattleExtension.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(BattleExtension)

void UBattleExtension::Exec_Implementation()
{
	//TODO implement Night Sky Script
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/BattleExtension.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "NightSkyEngine/Battle/Misc/SerializableObj.h"
#include "BattleExtension.generated.h"

/**
 * @brief A customizable extension to the battle ruleset.
 *
 * Allows modifying some general battle behavior.
 */
UCLASS(BlueprintType, Blueprintable)
class NIGHTSKYENGINE_API UBattleExtension : public USerializableObj
{
	GENERATED_BODY()

public:
	/**
     * The owning game state.
     */
	UPROPERTY(BlueprintReadOnly)
	ANightSkyGameState* Parent;
	
	/**
	 * The name of the subroutine.
	 * Used to call the subroutine.
	 */
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FGameplayTag Name;

	/**
	 * The primary function of the subroutine.
	 */
	UFUNCTION(BlueprintNativeEvent)
	void Exec();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/State.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "State.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(State)

void UState::Exec_Implementation()
{
}

void UState::CallExec()
{
	CelIndex = 0;
	Exec();
}

bool UState::CanEnterState_Implementation()
{
	return true;
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/State.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NightSkyEngine/Battle/Misc/Bitflags.h"
#include "GameplayTagContainer.h"
#include "NightSkyEngine/Battle/Misc/SerializableObj.h"
#include "NightSkyEngine/Battle/Objects/BattleObject.h"
#include "State.generated.h"

class APlayerObject;
class ABattleObject;

/**
 * What stance the character must be in to enter this state.
 * Upon entering the state, the character will take this stance.
 */
UENUM(BlueprintType)
enum class EEntryStance : uint8
{
	/**
	 * No stance requirement; any state can enter.
	 */
	None,
	/**
	 * Must be grounded, and forces standing.
	 */
	Standing,
	/**
	 * Must be grounded, and forces crouching.
	 */
	Crouching,
	/**
	 * Must be airborne, and forces jumping.
	 */
	Jumping,
};

/**
 * The type of state. 
 * State types can have the ability to enter them toggled on and off.
 */
UENUM(BlueprintType)
enum class EStateType : uint8
{
	Standing,
	Crouching,
	NeutralJump,
	ForwardJump,
	BackwardJump,
	ForwardWalk,
	BackwardWalk,
	ForwardDash,
	BackwardDash,
	ForwardAirDash,
	BackwardAirDash,
	NormalAttack,
	SpecialAttack,
	SuperAttack,
	Hitstun,
	Blockstun,
	Tech,
	Burst,
	Tag,
	Assist,
	Custom,
};

/**
 * A condition to enter the state.
 * 
 * @see APlayerObject::HandleStateCondition
 */
UENUM(BlueprintType)
enum class EStateCondition : uint8
{
	None,
	AirJumpOk,
	AirJumpMinimumHeight,
	AirDashOk,
	AirDashMinimumHeight,
	IsAttacking,
	HitstopCancel,
	IsStunned,
	CloseNormal,
	FarNormal,
	CanTag2nd,
	CanTag3rd,
	MeterNotZero,
	MeterQuarterBar,
	MeterHalfBar,
	MeterOneBar,
	MeterTwoBars,
	MeterThreeBars,
	MeterFourBars,
	MeterFiveBars,
	PlayerReg1True,
	PlayerReg2True,
	PlayerReg3True,
	PlayerReg4True,
	PlayerReg5True,
	PlayerReg6True,
	PlayerReg7True,
	PlayerReg8True,
	PlayerReg1False,
	PlayerReg2False,
	PlayerReg3False,
	PlayerReg4False,
	PlayerReg5False,
	PlayerReg6False,
	PlayerReg7False,
	PlayerReg8False,
};

/**
 * Determines the method of which the input will be read.
 */
UENUM()
enum class EInputMethod : uint8
{
	/*
	 * The button or direction may be held indefinitely.
	 * Diagonal directions are counted as both of the cardinal directions it represents.
	 */
	Normal,
	/*
	 * The button or direction may be held indefinitely.
	 * Diagonal directions are not counted as either of the cardinal directions it represents.
	 */
	Strict,
	/*
	 * The button or direction will only be counted on first press until release.
	  * Diagonal directions are counted as both of the cardinal directions it represents.
	 */
	Once,
	/*
	 * The button or direction will only be counted on first press until release.
	 * Diagonal directions are not counted as either of the cardinal directions it represents.
	 * This is a combination of the Once and Strict methods.
	 */
	OnceStrict,
	/*
	 * The button or direction will only be counted when first pressed, then released.
	  * Diagonal directions are counted as both of the cardinal directions it represents.
	 */
	PressAndRelease,
	/*
	 * The button or direction will only be counted when first pressed, then released.
	 * Diagonal directions are not counted as either of the cardinal directions it represents.
	 * This is a combination of the Once and Strict methods.
	 */
	PressAndReleaseStrict,
	/*
	 * The button or direction will only be counted at the moment of release.
	  * Diagonal directions are counted as both of the cardinal directions it represents.
	 */
	Negative,
	/*
	 * The button or direction will only be counted at the moment of release.
	 * Diagonal directions are not counted as either of the cardinal directions it represents.
	 * This is a combination of the Negative and Strict methods.
	 */
	NegativeStrict,
};

/**
 * A container struct for input bitmasks.
 */
USTRUCT(BlueprintType)
struct FInputBitmask
{
	GENERATED_BODY()

	FInputBitmask()
	{
		InputFlag = INP_None;
	};
	FInputBitmask(EInputFlags Input)
	{
		InputFlag = Input;
	};

	/**
	 * The input flag.
	 *
	 * @see EInputFlags
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (Bitmask, BitmaskEnum = "/Script/NightSkyEngine.EInputFlags"))
	int InputFlag;
	
	/**
	 * How much buffer time there is for the input.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 Lenience = 3;
	
	/**
	 * How long the input must be held for. Unless you're creating a charge/hold input, leave as zero.
	 * Does not work with the Negative or Negative Strict input methods.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 Hold = 0;
	
	/**
	 * Disallowed inputs. If any inputs in this array are detected, this input is invalidated.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<TEnumAsByte<EInputFlags>> DisallowedInputs;
};

/**
 * Contains an input condition.
 */
USTRUCT(BlueprintType)
struct FInputCondition
{
	GENERATED_BODY()

	/**
	 * A sequence of input bitmasks.
	 * Depending on lenience, the amount of time between inputs is increased or decreased.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<FInputBitmask> Sequence;
	/**
	 * Disallowed inputs. If any inputs in this array are detected, the entire condition is invalidated.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<TEnumAsByte<EInputFlags>> DisallowedInputs;
	/**
	 * This value determines how many imprecise inputs are allowed in this condition.
	 * An imprecise input is a diagonal input that matches the cardinal direction.
	 * For use with the Strict or Once Strict input methods.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int ImpreciseInputCount = 0;
	/**
	 * The input method used for this condition. 
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	EInputMethod Method = EInputMethod::Normal;
};

/**
 * A list of input conditions.
 * Every condition in this list must be met for the state to be entered.
 */
USTRUCT(BlueprintType)
struct FInputConditionList
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere)
	TArray<FInputCondition> InputConditions;
};

/**
 * A range used for CPU behavior.
 */
UENUM()
enum ERangeType
{
	RAN_Near,
	RAN_Mid,
	RAN_Far,
};

/**
 * Attack speed used for CPU behavior.
 */
UENUM()
enum EAttackSpeed
{
	ASPD_Fast,
	ASPD_Medium,
	ASPD_Slow,
};

/**
 * Data for the CPU to use when deciding which state to enter.
 */
USTRUCT()
struct FStateCPUData
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere)
	int32 AttackXBeginRange = 0;
	UPROPERTY(EditAnywhere)
	int32 AttackXEndRange = 300000;
	UPROPERTY(EditAnywhere)
	int32 AttackYBeginRange = 120000;
	UPROPERTY(EditAnywhere)
	int32 AttackYEndRange = 360000;
	UPROPERTY(EditAnywhere)
	bool bAttack;
	UPROPERTY(EditAnywhere)
	bool bCombo;
	UPROPERTY(EditAnywhere)
	bool bNoCombo;
	UPROPERTY(EditAnywhere)
	bool bBlockstring;
	UPROPERTY(EditAnywhere)
	bool bPunish;
	UPROPERTY(EditAnywhere)
	bool bAntiAir;
	UPROPERTY(EditAnywhere)
	bool bThrow;
	UPROPERTY(EditAnywhere)
	bool bProjectile;
	UPROPERTY(EditAnywhere)
	TEnumAsByte<ERangeType> PunishRange;
	UPROPERTY(EditAnywhere)
	TEnumAsByte<EBlockType> BlockType;
	UPROPERTY(EditAnywhere)
	TEnumAsByte<EAttackSpeed> AttackSpeed;
	UPROPERTY(EditAnywhere)
	bool bBigDamage;
	UPROPERTY(EditAnywhere)
	bool bUsesResource;
	UPROPERTY(EditAnywhere)
	bool bInvuln;
};

/**
 * @brief A character state that determines behavior.
 *
 * Provides functionality for the current character behavior, such as frame data, animations, and more.
 */
UCLASS(BlueprintType, Blueprintable)
class UState : public USerializableObj
{
	GENERATED_BODY()

public:
	/**
	 * The object that owns this state instance.
	 * For player states, this will always be the owning player.
	 * For object states, this value will change when a new object is activated and takes over this state.
	 */
	UPROPERTY(BlueprintReadOnly)
	ABattleObject* Parent;
	/**
	 * The current cel index.
	 * Used in Blueprint macros to determine which code to execute.
	 */
	UPROPERTY(BlueprintReadWrite)
	int32 CelIndex;
	/**
	 * The name of this state.
	 * For player states, this is used to jump to states directly.
	 * For object states, this is used to create an object by name.
	 */
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FGameplayTag Name;
	/**
	 * The state name to share a max chain with.
	 */
	UPROPERTY(EditAnywhere)
	FGameplayTag ShareChainName;
	/**
	 * The required stance to enter this state.
	 * Only used on player states.
	 */
	UPROPERTY(EditAnywhere)
	EEntryStance EntryStance;
	/**
	 * An array of input condition lists.
	 * Only the success of one input condition list is required to enter the state.
	 */
	UPROPERTY(EditAnywhere)
	TArray<FInputConditionList> InputConditionLists;
	/**
	 * The type of this state.
	 */
	UPROPERTY(EditAnywhere)
	EStateType StateType;
	/**
	 * The custom state type. Only used if the base state type is set to Custom.
	 */
	UPROPERTY(EditAnywhere)
	FGameplayTag CustomStateType;
	/**
	 * An array of state conditions.
	 * All state conditions must be successful to enter this state.
	 */
	UPROPERTY(EditAnywhere)
	TArray<EStateCondition> StateConditions;
	/**
	 * A value that determines if this state can be entered directly, or must be canceled into. 
	 */
	UPROPERTY(EditAnywhere)
	bool IsFollowupState;
	/**
	 * A value that's set to match with spawned objects.
	 * If an owned object with this ID is active, this state can't be entered.
	 * For use with states that you do not wish to enter while the projectile is active.
	 * Only used on player states.
	 */
	UPROPERTY(EditAnywhere)
	int32 ObjectID;
	/**
	 * The maximum number of times this state can be used in a chain.
	 * For use with moves used in a combo that you wish to prevent cancelling into multiple times in sequence. 
	 */
	UPROPERTY(EditAnywhere)
	int32 MaxChain = -1;
	/**
	 * The maximum number of times this state can be used in a reverse beat chain.
	 * For use with normal attacks that you don't want to use in reverse beat. 
	 */
	UPROPERTY(EditAnywhere)
	bool bEnableReverseBeat = true;
	/**
	 * Determines how many of this state will be spawned.
	 * Only used on object states. Player states will ignore this value and always spawn one instance.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	int32 MaxInstances = 1;
	/**
	 * Data for the CPU to determine when to enter the state.
	 */
	UPROPERTY(EditAnywhere)
	FStateCPUData CPUData;
	/**
	 * If a human player should be able to enter the state. Not used with object states.
	 */
	UPROPERTY(EditAnywhere)
	bool bHumanUsable = true;
	/**
	 * If a CPU player should be able to enter the state. Not used with object states.
	 */
	UPROPERTY(EditAnywhere)
	bool bCPUUsable = true;

	UFUNCTION(BlueprintImplementableEvent)
	void Init();
	
	/**
	 * Wrapper for Exec function that sets CelIndex to zero.
	 */
	virtual void CallExec();

	/**
	 * Called every frame to update the state.
	 */
	UFUNCTION(BlueprintNativeEvent)
	void Exec();
	
	/**
	 * Called to check if the state may be entered.
	 */
	UFUNCTION(BlueprintNativeEvent)
	bool CanEnterState();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/StateAlias.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "State.h"
#include "StateAlias.generated.h"

/**
 * An "alias" for an existing state. Allows giving different conditions for entering an existing state.
 */
UCLASS()
class NIGHTSKYENGINE_API UStateAlias : public UState
{
	GENERATED_BODY()

public:
	// Which state to enter from the alias
	UPROPERTY(EditAnywhere)
	FGameplayTag StateToEnter;
	
	// Dummy CallExec, we don't want it to execute code
	virtual void CallExec() override {}
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/StateMachine.cpp`:

```cpp
#include "StateMachine.h"

#include "StateAlias.h"
#include "SubroutineState.h"
#include "NightSkyEngine/Battle/Objects/PlayerObject.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(StateMachine)

UE_DEFINE_GAMEPLAY_TAG_COMMENT(StateMachine_Primary, "StateMachine.Primary", "Primary State Machine");

void FStateMachine::AddState(const FGameplayTag& Name, UState* Config)
{
	Config->Parent = Parent;
	States.Add(Config);
	StateNames.Add(Name);
	if (CurrentState == nullptr)
	{
		CurrentState = Config;
		CurrentState->Init();
		Update();
		Parent->UpdateCel();
	}
}

FGameplayTag FStateMachine::GetStateName(int Index)
{
	if (Index > 0 && Index < States.Num())
	{
		return States[Index]->Name;
	}
	return FGameplayTag::EmptyTag;
}

int FStateMachine::GetStateIndex(FGameplayTag Name) const
{
	return StateNames.Find(Name);
}

bool FStateMachine::SetState(const FGameplayTag Name, bool bIsAlias)
{
	if (StateNames.Find(Name) == INDEX_NONE)
	{
		return false;
	}

	if (IsCurrentState(Name))
	{
		CurrentState = States[StateNames.Find(Name)];
		return true;
	}

	const auto StateToEnter = States[StateNames.Find(Name)];
	if (const auto SubroutineState = Cast<USubroutineState>(StateToEnter))
	{
		Parent->CallSubroutine(SubroutineState->SubroutineName);
		return false;
	}
	if (!bIsAlias)
	{
		Parent->StateEntryName = StateToEnter->Name;
	}
	if (const auto Alias = Cast<UStateAlias>(StateToEnter))
	{
		return SetState(Alias->StateToEnter, true);
	}
	
	Parent->TriggerEvent(EVT_Exit, StateMachineName);
	if (bPrimary) Parent->OnStateChange();

	CurrentState = StateToEnter;
	if (bPrimary) Parent->PostStateChange();
	CurrentState->Init();
	Update();

	Parent->UpdateCel();

	return true;
}

bool FStateMachine::ForceSetState(const FGameplayTag Name, bool bIsAlias)
{
	if (StateNames.Find(Name) == INDEX_NONE)
	{
		return false;
	}
	
	const auto StateToEnter = States[StateNames.Find(Name)];
	if (const auto SubroutineState = Cast<USubroutineState>(StateToEnter))
	{
		Parent->CallSubroutine(SubroutineState->SubroutineName);
		return false;
	}
	if (!bIsAlias)
	{
		Parent->StateEntryName = StateToEnter->Name;
	}
	if (const auto Alias = Cast<UStateAlias>(StateToEnter))
	{
		return ForceSetState(Alias->StateToEnter, true);
	}

	Parent->TriggerEvent(EVT_Exit, StateMachineName);
	if (bPrimary) Parent->OnStateChange();

	CurrentState = StateToEnter;
	if (bPrimary) Parent->PostStateChange();
	CurrentState->Init();
	Update();

	Parent->UpdateCel();

	return true;
}

bool FStateMachine::ForceSetState(TSubclassOf<UState> Class, bool bIsAlias)
{
	for (auto State : States)
	{
		if (State->GetClass() == Class)
		{
			if (const auto SubroutineState = Cast<USubroutineState>(State))
			{
				Parent->CallSubroutine(SubroutineState->SubroutineName);
				return false;
			}
			if (!bIsAlias)
			{
				Parent->StateEntryName = State->Name;
			}
			if (const auto Alias = Cast<UStateAlias>(State))
			{
				return ForceSetState(Alias->StateToEnter, true);
			}

			Parent->TriggerEvent(EVT_Exit, StateMachineName);
			if (bPrimary) Parent->OnStateChange();

			CurrentState = State;
			if (bPrimary) Parent->PostStateChange();
			CurrentState->Init();
			Update();

			Parent->UpdateCel();

			return true;
		}
	}
	return false;
}

bool FStateMachine::ForceRollbackState(const FGameplayTag Name)
{
	if (StateNames.Find(Name) == INDEX_NONE)
	{
		return false;
	}
		
	CurrentState = States[StateNames.Find(Name)];

	return true;
}

bool FStateMachine::CheckStateStanceCondition(const EEntryStance StateStance, const int PlayerStance)
{
	if ((StateStance == EEntryStance::Standing && PlayerStance == ACT_Standing)
	|| (StateStance == EEntryStance::Standing && PlayerStance == ACT_Crouching)
	|| (StateStance == EEntryStance::Crouching && PlayerStance == ACT_Standing)
	|| (StateStance == EEntryStance::Crouching && PlayerStance == ACT_Crouching)
	|| (StateStance == EEntryStance::Jumping && PlayerStance == ACT_Jumping)
	|| StateStance == EEntryStance::None)
	{
		return true;
	}
	return false;
}

void FStateMachine::Update() const
{
	if (CurrentState != nullptr)
	{
		CurrentState->CallExec();
	}
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/StateMachine.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "NativeGameplayTags.h"
#include "State.h"
#include "StateMachine.generated.h"

class APlayerObject;

UE_DECLARE_GAMEPLAY_TAG_EXTERN(StateMachine_Primary);

/**
 * @brief The player object's state machine.
 *
 * Contains all player states and state names, as well as the currently active state.
 */
USTRUCT(BlueprintType)
struct NIGHTSKYENGINE_API FStateMachine
{
	GENERATED_BODY()
	
	UPROPERTY(SaveGame)
	bool bPrimary;
	/**
	 * The currently active state.
	 */
	UPROPERTY(EditDefaultsOnly, SaveGame)
	FGameplayTag StateMachineName;
	/**
	 * Flags of currently enabled states.
	 */
	UPROPERTY(SaveGame, meta=(Bitmask, BitmaskEnum = "/Script/NightSkyEngine.EEnableFlags"))
	int32 EnableFlags = 0;
	/**
	 * Currently enabled custom state types.
	 */
	UPROPERTY(SaveGame)
	TArray<FGameplayTag> EnabledCustomStateTypes;
	/**
	 * The currently active state.
	 */
	UPROPERTY(SaveGame)
	UState* CurrentState;
	/**
	 * An array of all player states.
	 */
	UPROPERTY()
	TArray<UState*> States;
	/**
	 * An array of all player state names.
	 * Used to lookup states.
	 */
	UPROPERTY()
	TArray<FGameplayTag> StateNames;
	/**
	 * The parent of this state machine.
	 */
	UPROPERTY()
	APlayerObject* Parent;

	/**
	 * Adds a state to the state machine.
	 * If no current state is set, the input state will be used as the current state.
	 * Only call at the beginning of a match!
	 */	
	void AddState(const FGameplayTag& Name, UState* Config);

	/**
	 * Checks a name against the current state name.
	 */	
	FORCEINLINE bool IsCurrentState(const FGameplayTag& Name) const
	{
		return CurrentState->Name == Name;
	}
	
	/**
	 * Gets the current state name.
	 */	
	FGameplayTag GetStateName(int Index);
	/**
	 * Gets the current state index.
	 */	
	int GetStateIndex(FGameplayTag Name) const;

	/**
	 * Sets the current state.
	 * If attempting to set the state to the same as the current state, nothing will happen.
	 * 
	 * @param Name The state to set as current.
	 * @param bIsAlias If the state is being set via an alias.
	 * @return If the state was successfully set, return true. Otherwise return false.
	 */
	bool SetState(const FGameplayTag Name, bool bIsAlias = false);
	/**
	 * Sets the current state.
	 * If the state to set is the same as the current state, the state will be reset.
	 * 
	 * @param Name The state to set as current.
	 * @param bIsAlias If the state is being set via an alias.
	 * @return If the state was successfully set, return true. Otherwise return false.
	 */
	bool ForceSetState(const FGameplayTag Name, bool bIsAlias = false);
	/**
	 * Sets the current state.
	 * If the state to set is the same as the current state, the state will be reset.
	 * 
	 * @param Class The state to set as current.
	 * @param bIsAlias If the state is being set via an alias.
	 * @return If the state was successfully set, return true. Otherwise return false.
	 */
	bool ForceSetState(TSubclassOf<UState> Class, bool bIsAlias = false);
	/**
	 * Sets the current state for rollback.
	 * Code called when entering a state normally will not be called.
	 * 
	 * @param Name The state to set as current.
	 * @return If the state was successfully set, return true. Otherwise return false.
	 */
	bool ForceRollbackState(const FGameplayTag Name);

	/**
	 * Checks if the state allows the player's current stance.
	 * 
	 * @param StateStance The state's required stance.
	 * @param PlayerStance The current player's stance.
	 * @return If the state stance allows the player's stance, return true. Otherwise return false.
	 */
	static bool CheckStateStanceCondition(const EEntryStance StateStance, const int PlayerStance);

	/**
	 * Calls the current state's exec function.
	 */
	void Update() const;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/Subroutine.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Subroutine.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(Subroutine)

void USubroutine::Exec_Implementation()
{
	ResetToCDO();
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/Subroutine.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "NightSkyEngine/Battle/Misc/SerializableObj.h"
#include "UObject/Object.h"
#include "Subroutine.generated.h"

class ABattleObject;

/**
 * @brief A subroutine callable from any player or object state.
 *
 * Allows encapsulating commonly used code that can be reused in states.
 */
UCLASS(BlueprintType, Blueprintable)
class USubroutine : public USerializableObj
{
	GENERATED_BODY()
public:
	/**
	 * The object that currently owns this subroutine instance.
	 * The last object to use this subroutine will be the owner.
	 */
	UPROPERTY(BlueprintReadOnly)
	ABattleObject* Parent;
	/**
	 * The name of the subroutine.
	 * Used to call the subroutine.
	 */
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FGameplayTag Name;

	/**
	 * The primary function of the subroutine.
	 */
	UFUNCTION(BlueprintNativeEvent)
	void Exec();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/SubroutineState.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "State.h"
#include "SubroutineState.generated.h"

/**
 * Attempting to enter the state will actually call a subroutine instead.
 */
UCLASS()
class NIGHTSKYENGINE_API USubroutineState : public UState
{
	GENERATED_BODY()

public:
	// Which subroutine to call from the state
	UPROPERTY(EditAnywhere)
	FGameplayTag SubroutineName;
	
	// Dummy CallExec, we don't want it to execute code
	virtual void CallExec() override {}
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/CharaSelect/NightSkyCharaSelectGameState.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyCharaSelectGameState.h"
#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "NightSkyEngine/Data/PrimaryCharaData.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyCharaSelectGameState)

// Sets default values
ANightSkyCharaSelectGameState::ANightSkyCharaSelectGameState()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	P1Positions.Add(FVector(-150, -100, 0));
	P1Positions.Add(FVector(-220, -50, 0));
	P1Positions.Add(FVector(-300, 0, 0));
	
	P2Positions.Add(FVector(150, -100, 0));
	P2Positions.Add(FVector(220, -50, 0));
	P2Positions.Add(FVector(300, 0, 0));
}

// Called when the game starts or when spawned
void ANightSkyCharaSelectGameState::BeginPlay()
{
	Super::BeginPlay();
	GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
}

// Called every frame
void ANightSkyCharaSelectGameState::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
	for (const auto Chara : P1Charas)
		Chara->UpdateNotBattle();
	for (const auto Chara : P2Charas)
	{
		Chara->UpdateNotBattle();
	}
}

void ANightSkyCharaSelectGameState::AddPlayerObject(UPrimaryCharaData* Player, bool IsP1)
{
	if (IsP1)
	{
		if (P1Charas.Num() >= GameInstance->BattleData.PlayerListP1.Num())
			return;
		P1Charas.Add(GetWorld()->SpawnActor<APlayerObject>(Player->PlayerClass));
		P1Charas.Last()->InitPlayer();
		P1Charas.Last()->CharaSelectGameState = this;
		P1Charas.Last()->SetDefaultComponentVisibility();
		P1Charas.Last()->PlayerFlags = PLF_IsOnScreen;
		P1Charas.Last()->SetActorLocation(P1Positions[P1Charas.Num() - 1]);
		GameInstance->BattleData.PlayerListP1[P1Charas.Num() - 1] = Player;
	}
	else
	{
		if (P2Charas.Num() >= GameInstance->BattleData.PlayerListP2.Num())
			return;
		P2Charas.Add(GetWorld()->SpawnActor<APlayerObject>(Player->PlayerClass));
		P2Charas.Last()->InitPlayer();
		P2Charas.Last()->CharaSelectGameState = this;
		P2Charas.Last()->SetDefaultComponentVisibility();
		P2Charas.Last()->PlayerFlags = PLF_IsOnScreen;
		P2Charas.Last()->SetActorLocation(P2Positions[P2Charas.Num() - 1]);
		P2Charas.Last()->Direction = DIR_Left;
		GameInstance->BattleData.PlayerListP2[P2Charas.Num() - 1] = Player;
	}
}

void ANightSkyCharaSelectGameState::AddColorIndex(int InColor, bool IsP1)
{
	if (IsP1)
	{
		if (P1Charas.Num() >= GameInstance->BattleData.PlayerListP1.Num())
			return;
		GameInstance->BattleData.ColorIndicesP1[P1Charas.Num() - 1] = InColor;
	}
	else
	{
		if (P2Charas.Num() >= GameInstance->BattleData.PlayerListP2.Num())
			return;
		GameInstance->BattleData.ColorIndicesP2[P2Charas.Num() - 1] = InColor;
	}
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/CharaSelect/NightSkyCharaSelectGameState.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameStateBase.h"
#include "NightSkyCharaSelectGameState.generated.h"

class UPrimaryCharaData;
class UNightSkyGameInstance;
class APlayerObject;

UCLASS()
class NIGHTSKYENGINE_API ANightSkyCharaSelectGameState : public AGameStateBase
{
	GENERATED_BODY()

private:
	UPROPERTY()
	TObjectPtr<UNightSkyGameInstance> GameInstance;
public:
	// Sets default values for this actor's properties
	ANightSkyCharaSelectGameState();

	UPROPERTY(BlueprintReadWrite)
	TArray<APlayerObject*> P1Charas;
	UPROPERTY(EditAnywhere)
	TArray<FVector> P1Positions;
	UPROPERTY(BlueprintReadWrite)
	TArray<APlayerObject*> P2Charas;
	UPROPERTY(EditAnywhere)
	TArray<FVector> P2Positions;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	UFUNCTION(BlueprintCallable)
	void AddPlayerObject(UPrimaryCharaData* Player, bool IsP1 = true);
	UFUNCTION(BlueprintCallable)
	void AddColorIndex(int InColor, bool IsP1 = true);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/BattleExtensionData.cpp`:

```cpp
#include "BattleExtensionData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(BattleExtensionData)

UE_DEFINE_GAMEPLAY_TAG_COMMENT(BattleExtension_MatchInit, "BattleExtension.MatchInit", "Battle Extension Match Init");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(BattleExtension_RoundInit, "BattleExtension.RoundInit", "Battle Extension Round Init");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(BattleExtension_Update, "BattleExtension.Update", "Battle Extension Update");

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/BattleExtensionData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "NightSkyEngine/Battle/Script/BattleExtension.h"
#include "BattleExtensionData.generated.h"

UE_DECLARE_GAMEPLAY_TAG_EXTERN(BattleExtension_MatchInit);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(BattleExtension_RoundInit);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(BattleExtension_Update);

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UBattleExtensionData : public UDataAsset
{
	GENERATED_BODY()
	
public:
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TArray<TSubclassOf<UBattleExtension>> ExtensionArray;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CameraShakeData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "GameplayTagContainer.h"
#include "CameraShakeData.generated.h"

USTRUCT(BlueprintType)
struct FCameraShakeStruct
{
	GENERATED_BODY()
	
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FGameplayTag Name;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	TSubclassOf<UCameraShakeBase> CameraShake;
};


/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UCameraShakeData : public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	TArray<FCameraShakeStruct> CameraShakeStructs;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CollisionData.cpp`:

```cpp
#include "CollisionData.h"

#include "Misc/DataValidation.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(CollisionData)

#define LOCTEXT_NAMESPACE "NightSkyEngine"

#if WITH_EDITOR

EDataValidationResult UCollisionData::IsDataValid(FDataValidationContext& Context) const
{
	EDataValidationResult Result = CombineDataValidationResults(Super::IsDataValid(Context), EDataValidationResult::Valid);
	if (Result == EDataValidationResult::Valid)
	{
		// Check for duplicates and empty names
		TSet<FGameplayTag> CelNames;
		for (const auto& CollisionFrame : CollisionFrames)
		{
			if (!CollisionFrame.CelName.IsValid())
			{
				Context.AddError(LOCTEXT("InvalidCelName", "Invalid Cel name found (not named)"));
				Result = EDataValidationResult::Invalid;
			}
			else
			{
				bool bIsDuplicate = false;
				CelNames.Add(CollisionFrame.CelName, &bIsDuplicate);
				if (bIsDuplicate)
				{
					Context.AddError(LOCTEXT("DuplicateCelName", "Duplicate Cel name found"));
					Result = EDataValidationResult::Invalid;
				}
			}
		}
	}
	return Result;
}

#endif // WITH_EDITOR

#undef LOCTEXT_NAMESPACE

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CollisionData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "GameplayTagContainer.h"
#include "PaperFlipbook.h"
#include "NightSkyEngine/Battle/Misc/CollisionBox.h"
#include "CollisionData.generated.h"

class APlayerObject;

DECLARE_MULTICAST_DELEGATE(FOnCollisionFramesChanged);

USTRUCT()
struct FAnimStruct
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere)
	FName PartName = "Body";
	UPROPERTY(EditAnywhere)
	UAnimSequenceBase* AnimSequence;
	UPROPERTY(EditAnywhere)
	UPaperFlipbook* Flipbook;
};

USTRUCT()
struct FCollisionStruct
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere)
	FGameplayTag CelName;
	UPROPERTY(EditAnywhere)
	TArray<FAnimStruct> Anim;
	UPROPERTY(EditAnywhere)
	int32 AnimFrame = 0;
	UPROPERTY(EditAnywhere)
	float AnimBlendIn = 0.25;
	UPROPERTY(EditAnywhere)
	float AnimBlendOut = 0.25;
	UPROPERTY(EditAnywhere)
	TArray<FCollisionBox> Boxes;
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UCollisionData : public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere)
	TArray<FCollisionStruct> CollisionFrames;

	FCollisionStruct GetByCelName(const FGameplayTag& CelName)
	{
		for (auto& CollisionFrame : CollisionFrames)
		{
			if (CollisionFrame.CelName == CelName) return CollisionFrame;
		}
		return FCollisionStruct();
	}

	int32 GetIndexByCelName(const FGameplayTag& CelName) const
	{
		for (int32 i = 0; i < CollisionFrames.Num(); ++i)
		{
			if (CollisionFrames[i].CelName == CelName) return i;
		}
		return INDEX_NONE;
	}

#if WITH_EDITORONLY_DATA
	// Transient selection state for editor - not saved with asset
	UPROPERTY(Transient)
	int32 EditorSelectedIndex = INDEX_NONE;
	
	/** TODO: Filter tags that can be selected based on character name */
	// UPROPERTY()
	// FGameplayTag SelectedCharacterTag = FGameplayTag::EmptyTag;
	
	/** TODO: Stored to automatically create the preview player object when opened */
	// UPROPERTY()
	// TSubclassOf<APlayerObject> SelectedPlayerObjectClass = nullptr;

	// Delegate broadcast when CollisionFrames array is modified
	FOnCollisionFramesChanged OnCollisionFramesChanged;

	void NotifyCollisionFramesChanged()
	{
		OnCollisionFramesChanged.Broadcast();
	}

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override
	{
		Super::PostEditChangeProperty(PropertyChangedEvent);
		for (auto& Collision : CollisionFrames)
		{
			for (auto& Box : Collision.Boxes)
			{
				Box.PostEditChangeProperty();
			}
		}
	}
#endif
	
#if WITH_EDITOR
	virtual EDataValidationResult IsDataValid(FDataValidationContext& Context) const override;
#endif
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/FlipbookData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Engine/DataAsset.h"
#include "PaperFlipbook.h"
#include "FlipbookData.generated.h"

USTRUCT(BlueprintType)
struct FFlipbookStruct
{
	GENERATED_BODY()
	
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FGameplayTag Name;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	UPaperFlipbook* Flipbook;
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UFlipbookData : public UDataAsset
{
	GENERATED_BODY()
	
public:
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	TArray<FFlipbookStruct> FlipbookStructs;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/LinkActorData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Engine/DataAsset.h"
#include "LinkActorData.generated.h"

USTRUCT(BlueprintType)
struct FLinkActorStruct
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere)
	FGameplayTag Name;
	UPROPERTY(EditAnywhere)
	TSubclassOf<ALinkActor> ActorClass;
	UPROPERTY(EditAnywhere)
	int32 MaxInstances = 1;
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API ULinkActorData : public UDataAsset
{
	GENERATED_BODY()
	
public:
	UPROPERTY(EditAnywhere)
	TArray<FLinkActorStruct> LinkedActorStructs;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/MaterialData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Engine/DataAsset.h"
#include "MaterialData.generated.h"

USTRUCT(BlueprintType)
struct FMaterialStruct
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FName Name;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	TArray<UMaterialInterface*> Material;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	UMaterialInterface* OverlayMaterial;
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UMaterialData : public UDataAsset
{
	GENERATED_BODY()

public:
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	TArray<FMaterialStruct> MaterialStructs;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/ParticleData.cpp`:

```cpp
#include "ParticleData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(ParticleData)

UE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_S, "Particle.Hit.S", "Hit (Small) Particle");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_M, "Particle.Hit.M", "Hit (Medium) Particle");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_L, "Particle.Hit.L", "Hit (Large) Particle");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_SP, "Particle.Hit.SP", "Hit (Special) Particle");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_Clash, "Particle.Hit.Clash", "Hit Clash Particle");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Guard, "Particle.Guard", "Guard Particle");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_ThrowTech, "Particle.ThrowTech", "Throw Tech Particle");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_JumpSmoke_Land, "Particle.JumpSmoke.Land", "Jump Smoke (Land) Particle");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_WallBounce, "Particle.WallBounce", "Wall Bounce Particle");

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/ParticleData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NativeGameplayTags.h"
#include "Engine/DataAsset.h"
#include "ParticleData.generated.h"

UE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_S);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_M);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_L);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_SP);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_Clash);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Guard);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_ThrowTech);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_JumpSmoke_Land);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_WallBounce);

USTRUCT(BlueprintType)
struct FParticleStruct
{
	GENERATED_BODY()
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FGameplayTag Name;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	class UNiagaraSystem* ParticleSystem;
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UParticleData : public UDataAsset
{
	GENERATED_BODY()
	
public:
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	TArray<FParticleStruct> ParticleStructs;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/PrimaryCharaData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "PrimaryCharaData.generated.h"

class APlayerObject;

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UPrimaryCharaData : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:
	virtual FPrimaryAssetId GetPrimaryAssetId() const override
	{
		return FPrimaryAssetId("PrimaryCharaData", GetFName());
	}

	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FName CharaName;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FText CharaFriendlyName;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FText CharaDescription;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	UTexture2D* CharaHUDIcon;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	UTexture2D* CharaSelectIcon;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	UTexture2D* CharaSplashIcon;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	TSubclassOf<APlayerObject> PlayerClass;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/PrimaryStageData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "PrimaryStageData.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UPrimaryStageData : public UPrimaryDataAsset
{
	GENERATED_BODY()

public:
	virtual FPrimaryAssetId GetPrimaryAssetId() const override
	{
		return FPrimaryAssetId("PrimaryStageData", GetFName());
	}

	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FName StageName;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FText StageFriendlyName;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FText StageDescription;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	UTexture2D* StageSelectIcon;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	UTexture2D* StageSplashIcon;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FString StageURL;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SequenceData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Engine/DataAsset.h"
#include "LevelSequence.h"
#include "SequenceData.generated.h"

USTRUCT(BlueprintType)
struct FSequenceStruct
{
	GENERATED_BODY()
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	FGameplayTag Name;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	ULevelSequence* Sequence;
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API USequenceData : public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	TArray<FSequenceStruct> SequenceStructs;
};
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SoundData.cpp`:

```cpp
#include "SoundData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(SoundData)

UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Punch_S, "Sound.Hit.Punch.S", "Punch Hit (Small) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Punch_M, "Sound.Hit.Punch.M", "Punch Hit (Medium) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Punch_L, "Sound.Hit.Punch.L", "Punch Hit (Large) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Punch_SP, "Sound.Hit.Punch.SP", "Punch Hit (Special) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Kick_S, "Sound.Hit.Kick.S", "Kick Hit (Small) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Kick_M, "Sound.Hit.Kick.M", "Kick Hit (Medium) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Kick_L, "Sound.Hit.Kick.L", "Kick Hit (Large) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Kick_SP, "Sound.Hit.Kick.SP", "Kick Hit (Special) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Slash_S, "Sound.Hit.Slash.S", "Slash Hit (Small) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Slash_M, "Sound.Hit.Slash.M", "Slash Hit (Medium) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Slash_L, "Sound.Hit.Slash.L", "Slash Hit (Large) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Slash_SP, "Sound.Hit.Slash.SP", "Slash Hit (Special) Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Clash, "Sound.Hit.Clash", "Hit Clash Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Land, "Sound.Land", "Landing Sound");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Landing_Crash, "Sound.Landing.Crash", "Landing Sound (Crash)");

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SoundData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NativeGameplayTags.h"
#include "Engine/DataAsset.h"
#include "SoundData.generated.h"

UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Punch_S);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Punch_M);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Punch_L);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Punch_SP);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Kick_S);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Kick_M);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Kick_L);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Kick_SP);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Slash_S);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Slash_M);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Slash_L);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Slash_SP);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Clash);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Guard);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Land);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Landing_Crash);

USTRUCT()
struct FSoundStruct
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere)
	FGameplayTag Name;
	UPROPERTY(EditAnywhere)
	USoundBase* SoundWave;
	UPROPERTY(EditAnywhere)
	float MaxDuration = 60;
	
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API USoundData : public UDataAsset
{
	GENERATED_BODY()
	
public:
	UPROPERTY(EditAnywhere)
	TArray<FSoundStruct> SoundDatas;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/StateData.cpp`:

```cpp
#include "StateData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(StateData)

UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Stand, "State.Universal.Stand", "Stand State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Crouch, "State.Universal.Crouch", "Crouch State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Jump_V, "State.Universal.Jump.V", "Vertical Jump State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_JumpLanding, "State.Universal.JumpLanding", "Jump Landing State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_StandFlip, "State.Universal.StandFlip", "Stand Flip State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchFlip, "State.Universal.CrouchFlip", "Crouch Flip State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_JumpFlip, "State.Universal.AirFlip", "Jump Flip State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_StandBlock, "State.Universal.Block.Stand", "Stand Block State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchBlock, "State.Universal.Block.Crouch", "Crouch Block State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_AirBlock, "State.Universal.Block.Air", "Jump Block State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_StandBlockEnd, "State.Universal.Block.Stand.End", "Stand Block (End) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchBlockEnd, "State.Universal.Block.Crouch.End", "Crouch Block (End) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_AirBlockEnd, "State.Universal.Block.Air.End", "Jump Block (End) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_GuardBreakStand, "State.Universal.GuardBreak.Stand", "Guard Break (Stand) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_GuardBreakCrouch, "State.Universal.GuardBreak.Crouch", "Guard Break (Crouch) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_GuardBreakAir, "State.Universal.GuardBreak.Air", "Guard Break (Jump) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_0, "State.Universal.Hitstun.0", "Hitstun (Level 0) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_1, "State.Universal.Hitstun.1", "Hitstun (Level 1) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_2, "State.Universal.Hitstun.2", "Hitstun (Level 2) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_3, "State.Universal.Hitstun.3", "Hitstun (Level 3) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_4, "State.Universal.Hitstun.4", "Hitstun (Level 4) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_5, "State.Universal.Hitstun.5", "Hitstun (Level 5) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_0, "State.Universal.Hitstun.Crouch.0", "Crouch Hitstun (Level 0) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_1, "State.Universal.Hitstun.Crouch.1", "Crouch Hitstun (Level 1) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_2, "State.Universal.Hitstun.Crouch.2", "Crouch Hitstun (Level 2) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_3, "State.Universal.Hitstun.Crouch.3", "Crouch Hitstun (Level 3) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_4, "State.Universal.Hitstun.Crouch.4", "Crouch Hitstun (Level 4) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_5, "State.Universal.Hitstun.Crouch.5", "Crouch Hitstun (Level 5) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Launch_B, "State.Universal.Launch.B", "Backward Launch State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Launch_V, "State.Universal.Launch.V", "Vertical Launch State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Launch_F, "State.Universal.Launch.F", "Forward Launch State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Blowback, "State.Universal.Blowback", "Blowback State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Tailspin, "State.Universal.Tailspin", "Tailspin State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Crumple, "State.Universal.Crumple", "Crumple State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FloatingCrumpleBody, "State.Universal.FloatingCrumple.Body", "Floating Crumple (Body) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FloatingCrumpleHead, "State.Universal.FloatingCrumple.Head", "Floating Crumple (Head) State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_WallBounce, "State.Universal.WallBounce", "Wall Bounce State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceDownBounce, "State.Universal.FaceDown.Bounce", "Face Down Bounce State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceUpBounce, "State.Universal.FaceUp.Bounce", "Face Up Bounce State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceDownLoop, "State.Universal.FaceDown.Loop", "Face Down Loop State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceUpLoop, "State.Universal.FaceUp.Loop", "Face Up Loop State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceDownWakeUp, "State.Universal.FaceDown.WakeUp", "Face Down Wake Up State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceUpWakeUp, "State.Universal.FaceUp.WakeUp", "Face Up Wake Up State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Throw, "State.Universal.Throw", "Throw State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_ThrowLock, "State.Universal.ThrowLock", "Throw Lock State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_TagIn, "State.Universal.TagIn", "Tag In State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_RoundWin, "State.Universal.RoundWin", "Round Win State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_RoundLose, "State.Universal.RoundLose", "Round Lose State");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_MatchWin, "State.Universal.MatchWin", "Match Win State");

UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_BattleObject_KO_S, "State.BattleObject.KO.S", "KO (Small) Battle Object");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_BattleObject_KO_M, "State.BattleObject.KO.M", "KO (Small) Battle Object");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_BattleObject_KO_L, "State.BattleObject.KO.L", "KO (Small) Battle Object");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(State_BattleObject_KO_Draw, "State.BattleObject.KO.Draw", "KO (Draw) Battle Object");


```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/StateData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NativeGameplayTags.h"
#include "Engine/DataAsset.h"
#include "NightSkyEngine/Battle/Script/State.h"
#include "StateData.generated.h"

UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Stand);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Crouch);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Jump_V);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_JumpLanding);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_StandFlip);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchFlip);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_JumpFlip);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_StandBlock);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchBlock);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_AirBlock);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_StandBlockEnd);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchBlockEnd);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_AirBlockEnd);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_GuardBreakStand);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_GuardBreakCrouch);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_GuardBreakAir);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_0);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_1);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_2);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_3);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_4);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_5);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_0);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_1);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_2);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_3);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_4);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_5);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Launch_B);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Launch_V);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Launch_F);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Blowback);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Tailspin);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Crumple);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FloatingCrumpleBody);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FloatingCrumpleHead);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_WallBounce);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceDownBounce);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceUpBounce);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceDownLoop);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceUpLoop);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceDownWakeUp);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceUpWakeUp);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Throw);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_ThrowLock);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_TagIn);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_RoundWin);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_RoundLose);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_MatchWin);

UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_BattleObject_KO_S);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_BattleObject_KO_M);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_BattleObject_KO_L);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(State_BattleObject_KO_Draw);

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UStateData : public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TArray<TSubclassOf<UState>> StateArray;

	UFUNCTION(BlueprintPure)
	const UState* GetByStateName(const FGameplayTag& StateName) const
	{
		for (const auto& StateClass : StateArray)
		{
			const auto State = GetDefault<UState>(StateClass);
			if (State->Name == StateName) return State;
		}
		return nullptr;
	}
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SubroutineData.cpp`:

```cpp
#include "SubroutineData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(SubroutineData)

UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_MatchInit, "Subroutine.Cmn.MatchInit", "Subroutine Common Match Init");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_MatchInit, "Subroutine.MatchInit", "Subroutine Match Init");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_RoundInit, "Subroutine.Cmn.RoundInit", "Subroutine Common Round Init");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_RoundInit, "Subroutine.RoundInit", "Subroutine Round Init");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnUpdate, "Subroutine.Cmn.OnUpdate", "Subroutine Common On Update");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_OnUpdate, "Subroutine.OnUpdate", "Subroutine On Update");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnStateChange, "Subroutine.Cmn.OnStateChange", "Subroutine Common On State Change");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_OnStateChange, "Subroutine.OnStateChange", "Subroutine On State Change");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_PostStateChange, "Subroutine.Cmn.PostStateChange", "Subroutine Common Post State Change");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_PostStateChange, "Subroutine.PostStateChange", "Subroutine Post State Change");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnComboEnd, "Subroutine.Cmn.OnComboEnd", "Subroutine Common On Combo End");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_OnComboEnd, "Subroutine.OnComboEnd", "Subroutine On Combo End");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_AnyCancel_Air, "Subroutine.Cmn.AnyCancel.Air", "Subroutine Common Any Cancel (Air)");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnLanding, "Subroutine.Cmn.OnLanding", "Subroutine Common On Landing");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_OnLanding, "Subroutine.OnLanding", "Subroutine On Landing");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_ThrowParam_Ground, "Subroutine.ThrowParam.Ground", "Subroutine Throw Param (Ground)");
UE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_ThrowParam_Air, "Subroutine.ThrowParam.Air", "Subroutine Throw Param (Air)");

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SubroutineData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NativeGameplayTags.h"
#include "Engine/DataAsset.h"
#include "NightSkyEngine/Battle/Script/Subroutine.h"
#include "SubroutineData.generated.h"

UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_MatchInit);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_MatchInit);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_RoundInit);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_RoundInit);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnUpdate);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_OnUpdate);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnStateChange);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_OnStateChange);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_PostStateChange);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_PostStateChange);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnComboEnd);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_OnComboEnd);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_AnyCancel_Air);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnLanding);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_OnLanding);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_ThrowParam_Ground);
UE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_ThrowParam_Air);


/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API USubroutineData : public UDataAsset
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	TArray<TSubclassOf<USubroutine>> SubroutineArray;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEEnhancedInputUserSettings.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NSEEnhancedInputUserSettings.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NSEEnhancedInputUserSettings)

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEEnhancedInputUserSettings.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UserSettings/EnhancedInputUserSettings.h"
#include "NSEEnhancedInputUserSettings.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UNSEEnhancedInputUserSettings : public UEnhancedInputUserSettings
{
	GENERATED_BODY()
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeyProfile.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NSEPlayerMappableKeyProfile.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NSEPlayerMappableKeyProfile)

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeyProfile.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UserSettings/EnhancedInputUserSettings.h"
#include "NSEPlayerMappableKeyProfile.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UNSEPlayerMappableKeyProfile : public UEnhancedPlayerMappableKeyProfile
{
	GENERATED_BODY()
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeySettings.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NSEPlayerMappableKeySettings.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NSEPlayerMappableKeySettings)

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeySettings.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "PlayerMappableKeySettings.h"
#include "NSEPlayerMappableKeySettings.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UNSEPlayerMappableKeySettings : public UPlayerMappableKeySettings
{
	GENERATED_BODY()
	
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyEditorSettings.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyEditorSettings.h"

UNightSkyEditorSettings::UNightSkyEditorSettings(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	CategoryName = "Plugins";
	SectionName = "Night Sky Engine";
}

UNightSkyEditorSettings* UNightSkyEditorSettings::Get()
{
	return GetMutableDefault<UNightSkyEditorSettings>();
}

const UNightSkyEditorSettings* UNightSkyEditorSettings::GetConst()
{
	return GetDefault<UNightSkyEditorSettings>();
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyEditorSettings.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DeveloperSettings.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "NightSkyEditorSettings.generated.h"

/**
 * 
 */
UCLASS(Config = EditorPerProjectUserSettings, DefaultConfig, meta = (DisplayName = "Night Sky Engine Editor Settings"), MinimalAPI)
class UNightSkyEditorSettings : public UDeveloperSettings
{
	GENERATED_BODY()
	
public:
	UNightSkyEditorSettings(const FObjectInitializer& ObjectInitializer);
	
	UPROPERTY(Config, EditAnywhere, Category = "Battle")
	FBattleData BattleData = FBattleData();
	
	static NIGHTSKYENGINE_API UNightSkyEditorSettings* Get();
	static NIGHTSKYENGINE_API const UNightSkyEditorSettings* GetConst();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyEngineGameModeBase.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.


#include "NightSkyEngineGameModeBase.h"
#include "OnlineSubsystem.h"
#include "OnlineSubsystemUtils.h"
#include "Kismet/GameplayStatics.h"
#include "NightSkyGameInstance.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyEngineGameModeBase)
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyEngineGameModeBase.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "NightSkyEngineGameModeBase.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API ANightSkyEngineGameModeBase : public AGameModeBase
{
	GENERATED_BODY()
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyGameInstance.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyGameInstance.h"

#include "NightSkyEditorSettings.h"
#include "NightSkySettingsInfo.h"
#include "ReplayInfo.h"
#include "Kismet/GameplayStatics.h"
#include "NightSkyEngine/Data/PrimaryStageData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyGameInstance)

void UNightSkyGameInstance::Init()
{
	Super::Init();

#if WITH_EDITOR
	if (auto& InBattleData = UNightSkyEditorSettings::GetConst()->BattleData; InBattleData.bIsValid) 
		BattleData = InBattleData;
#endif
	
	BattleData.bIsValid = true;	
	BattleData.Random = FRandomManager(FDateTime::Now().ToUnixTimestamp());

	SettingsInfo = Cast<UNightSkySettingsInfo>(UGameplayStatics::LoadGameFromSlot("SYSTEM", 0));
	if (!SettingsInfo)
	{
		SettingsInfo = Cast<UNightSkySettingsInfo>(UGameplayStatics::CreateSaveGameObject(UNightSkySettingsInfo::StaticClass()));
		UGameplayStatics::SaveGameToSlot(SettingsInfo, "SYSTEM", 0);
	}

	const FString AntiAliasingCommand = "r.AntiAliasingMethod " + FString::FromInt(SettingsInfo->AntiAliasingMethod);
	const FString GlobalIlluminationCommand = "r.DynamicGlobalIlluminationMethod " + FString::FromInt(SettingsInfo->GlobalIlluminationMethod);

	GetWorld()->Exec(GetWorld(), *AntiAliasingCommand);
	GetWorld()->Exec(GetWorld(), *GlobalIlluminationCommand);
}

void UNightSkyGameInstance::TravelToVSInfo() const
{
	this->GetWorld()->ServerTravel("VSInfo_PL", true);
}

void UNightSkyGameInstance::TravelToBattleMap() const
{
	this->GetWorld()->ServerTravel(BattleData.Stage->StageURL, true);
}

void UNightSkyGameInstance::LoadReplay()
{
	BattleData = CurrentReplay->BattleData;
}

void UNightSkyGameInstance::PlayReplayToGameState(int32 FrameNumber, int32& OutP1Input, int32& OutP2Input) const
{
	if (FrameNumber >= CurrentReplay->LengthInFrames)
	{
		UGameplayStatics::OpenLevel(this, FName(TEXT("MainMenu_PL")));
		return;
	}
	OutP1Input = CurrentReplay->InputsP1[FrameNumber];
	OutP2Input = CurrentReplay->InputsP2[FrameNumber];
}

void UNightSkyGameInstance::RecordReplay()
{
	CurrentReplay = Cast<UReplaySaveInfo>(UGameplayStatics::CreateSaveGameObject(UReplaySaveInfo::StaticClass()));
	CurrentReplay->BattleData = BattleData;
	CurrentReplay->Version = BattleVersion;
	CurrentReplay->bIsTraining = IsTraining;
}

void UNightSkyGameInstance::UpdateReplay(int32 InputsP1, int32 InputsP2) const
{
	if (!CurrentReplay) return;
	CurrentReplay->LengthInFrames++;
	CurrentReplay->InputsP1.Add(InputsP1);
	CurrentReplay->InputsP2.Add(InputsP2);
}

void UNightSkyGameInstance::RollbackReplay(int32 FramesToRollback) const
{
	for (int i = 0; i < FramesToRollback; i++)
	{
		CurrentReplay->LengthInFrames--;
		CurrentReplay->InputsP1.Pop();
		CurrentReplay->InputsP2.Pop();
	}
}

void UNightSkyGameInstance::EndRecordReplay() const
{
	if (IsReplay) return;
	FString ReplayName = "REPLAY";
	for (int i = 0; i < MaxReplays; i++)
	{
		ReplayName = "REPLAY";
		ReplayName.AppendInt(i);
		if (!UGameplayStatics::DoesSaveGameExist(ReplayName, 0))
		{
			break;
		}
	}
	UGameplayStatics::SaveGameToSlot(CurrentReplay, ReplayName, 0);
}

void UNightSkyGameInstance::PlayReplayFromBP(FString ReplayName)
{
	FighterRunner = Multiplayer;
	IsReplay = true;
	CurrentReplay = Cast<UReplaySaveInfo>(UGameplayStatics::LoadGameFromSlot(ReplayName, 0));
	IsTraining = CurrentReplay->bIsTraining;
	LoadReplay();
}

void UNightSkyGameInstance::FindReplays()
{
	ReplayList.Empty();
	for (int i = 0; i < MaxReplays; i++)
	{
		FString ReplayName = "REPLAY";
		ReplayName.AppendInt(i);
		if (!UGameplayStatics::DoesSaveGameExist(ReplayName, 0))
		{
			continue;
		}
		ReplayList.Add(Cast<UReplaySaveInfo>(UGameplayStatics::LoadGameFromSlot(ReplayName, 0)));
		ReplayList.Last()->ReplayIndex = i;
		if (ReplayList.Last()->Version != BattleVersion)
		{
			ReplayList.Pop();
			UGameplayStatics::DeleteGameInSlot(ReplayName, 0);
		}
	}
	BP_OnFindReplaysComplete(ReplayList);
}

void UNightSkyGameInstance::DeleteReplay(const FString& ReplayName)
{
	if (UGameplayStatics::DoesSaveGameExist(ReplayName, 0))
	{
		UGameplayStatics::DeleteGameInSlot(ReplayName, 0);
	}
	FindReplays();
}
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyGameInstance.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NightSkyEngine/Network/FighterRunners.h"
#include "GameplayTagContainer.h"
#include "NightSkyEngine/Battle/Misc/RandomManager.h"
#include "Engine/GameInstance.h"
#include "NightSkyGameInstance.generated.h"

class UPrimaryStageData;
class UPrimaryCharaData;
class UNightSkySettingsInfo;
class USoundData;
constexpr int32 MaxReplays = 999;

class APlayerObject;
class UReplaySaveInfo;
enum class EBattleFormat : uint8;

USTRUCT(BlueprintType)
struct FBattleData
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere)
	bool bIsValid = false;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	TArray<UPrimaryCharaData*> PlayerListP1;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	TArray<UPrimaryCharaData*> PlayerListP2;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	TArray<int32> ColorIndicesP1;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	TArray<int32> ColorIndicesP2;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	EBattleFormat BattleFormat;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 TimeUntilRoundStart = 180;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 RoundCount = 2;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 StartRoundTimer = 99;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	UPrimaryStageData* Stage;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FGameplayTag MusicName;
	UPROPERTY()
	FRandomManager Random;
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UNightSkyGameInstance : public UGameInstance
{
	GENERATED_BODY()

	UPROPERTY()
	UReplaySaveInfo* CurrentReplay;
	
	virtual void Init() override;

protected:
	UFUNCTION(BlueprintImplementableEvent, Category = "Replays")  
	void BP_OnFindReplaysComplete(const TArray<UReplaySaveInfo*> &AllReplays);
	
public:
	bool FinishedLoadingForNetworkBattle = false;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FString GameVersion;
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FString BattleVersion;
	
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<UNightSkySettingsInfo> SettingsInfo;

	UPROPERTY(EditAnywhere)
	TObjectPtr<USoundData> AnnouncerData;
	UPROPERTY(EditAnywhere)
	TObjectPtr<USoundData> MusicData;

	UPROPERTY()
	TArray<UReplaySaveInfo*> ReplayList;
	UPROPERTY(BlueprintReadWrite)
	int PlayerIndex;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FBattleData BattleData;
	
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	bool IsTraining = false;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	bool IsCPUBattle = false;
	UPROPERTY(BlueprintReadWrite)
	bool IsReplay = false;
	
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	TEnumAsByte<EFighterRunners> FighterRunner;	

	UFUNCTION(BlueprintCallable)
	void TravelToVSInfo() const;
	void TravelToBattleMap() const;

	void LoadReplay();
	void PlayReplayToGameState(int32 FrameNumber, int32& OutP1Input, int32& OutP2Input) const;
	
	void RecordReplay();
	void UpdateReplay(int32 InputsP1, int32 InputsP2) const;
	void RollbackReplay(int32 FramesToRollback) const;
	void EndRecordReplay() const;
	
	/** Start playback for a previously recorded Replay, from blueprint */   
	UFUNCTION(BlueprintCallable, Category = "Replays")   
	void PlayReplayFromBP(FString ReplayName);   
  
	/** Start looking for/finding replays on the hard drive */  
	UFUNCTION(BlueprintCallable, Category = "Replays")  
	void FindReplays(); 
  
	/** Delete a previously recorded replay */
	UFUNCTION(BlueprintCallable, Category = "Replays")
	void DeleteReplay(const FString &ReplayName);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySaveInfo.cpp`:

```cpp
#include "NightSkySaveInfo.h"
#include "GameFramework/Actor.h"
#include "Serialization/MemoryReader.h"
#include "Serialization/MemoryWriter.h"
#include "Engine/World.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkySaveInfo)

void UNightSkySaveInfo::ActorArraySaver(TArray<AActor*>& SaveActors)
{
	for (AActor* SaveActor : SaveActors)
	{
		ActorSaver(SaveActor);
	}
}

void UNightSkySaveInfo::ActorSaver(AActor* SaveActor)
{
	const int32 Index = ObjectRecords.Emplace();
	FObjectRecord& ObjectRecord = ObjectRecords[Index];

	ObjectRecord.Name = SaveActor->GetFName();
	ObjectRecord.Transform = SaveActor->GetTransform();
	ObjectRecord.Class = SaveActor->GetClass();
	ObjectRecord.bActor = true;

	SaveData(SaveActor, ObjectRecord.Data);

	this->TempObjects.Add(SaveActor);
	UE_LOG(LogTemp, Display, TEXT("Complete Save Actor %s"), *SaveActor->GetName())
}

void UNightSkySaveInfo::ActorPreloader(AActor* WorldActor, FObjectRecord& ActorRecord)
{
	FActorSpawnParameters SpawnParams;
	SpawnParams.Name = ActorRecord.Name;

	// TODO: change this to SpawnActorDeferred so you can de-serialize and apply data before it calls constructor\BeginPlay
	AActor* NewActor = WorldActor->GetWorld()->SpawnActor(ActorRecord.Class, &ActorRecord.Transform, SpawnParams);
	//AActor* NewActor = WorldActor->GetWorld()->SpawnActorDeferred
        
	// BUG? actor doesn't appear to load scale correctly using transform so I specifically apply the scale after loading
	NewActor->SetActorScale3D(ActorRecord.Transform.GetScale3D());

	// don't load now, load after all objects are preloaded
	//LoadData(LoadObject, ObjectRecord.Data);

	// add to temp array for lookup it another object using already loaded objects as outers (array gets cleared once all objects loaded)
	this->TempObjects.Add(NewActor);

	UE_LOG(LogTemp, Display, TEXT("Complete Load Actor %s"), *NewActor->GetPathName())
}

void UNightSkySaveInfo::UObjectArraySaver(TArray<UObject*>& SaveObjects)
{
	for (UObject* SaveObject : SaveObjects)
	{
		UObjectSaver(SaveObject);
	}
}

void UNightSkySaveInfo::UObjectSaver(UObject* SaveObject)
{
	if (SaveObject == nullptr)
	{
		UE_LOG(LogTemp, Error, TEXT("Invalid Save Object!"))
		return;
	}

	if (SaveObject->HasAnyFlags(EObjectFlags::RF_Transient))
	{
		UE_LOG(LogTemp, Warning, TEXT("Saving RF_Transient object"))
		return;
	}

	if (SaveObject->IsA(AActor::StaticClass()))
	{
		ActorSaver(Cast<AActor>(SaveObject));
		return;
	}

	const int32 Index = ObjectRecords.Emplace();
	FObjectRecord& ObjectRecord = ObjectRecords[Index];

	// Use custom IDs for save / retrieving outer pointers
	// * Negative IDs if outer is a permanent map object (i.e. not loaded from SaveGame)
	// * Negative IDs start from -2 because -1 is already assigned to INDEX_NONE, and 0+ is used for SaveGame loaded objects
	ObjectRecord.OuterID = TempObjects.Find(SaveObject->GetOuter());
	ObjectRecord.bActor = false;

	// if outer is a saved object then don't try to save the direct object pointer
	if (ObjectRecord.OuterID == INDEX_NONE)
	{
		ObjectRecord.OuterID = PersistentOuters.Find(SaveObject->GetOuter());
		if (ObjectRecord.OuterID != INDEX_NONE)
		{
			ObjectRecord.OuterID = -(ObjectRecord.OuterID + 2);
		}
		else
		{
			const int32 Index2 = PersistentOuters.Add(SaveObject->GetOuter());
			ObjectRecord.OuterID = -(Index2 + 2);
			UE_LOG(LogTemp, Display, TEXT("Save Outer %s"), *SaveObject->GetOuter()->GetPathName())

		}
	}

	ObjectRecord.Name = SaveObject->GetFName();
	ObjectRecord.Class = SaveObject->GetClass();

	SaveData(SaveObject, ObjectRecord.Data);

	this->TempObjects.Add(SaveObject);

	UE_LOG(LogTemp, Display, TEXT("Complete Save UObject %s"), *SaveObject->GetName())
}

void UNightSkySaveInfo::UObjectsPreloader(AActor* WorldActor)
{
	UObject* LoadOuter = nullptr;

	for (FObjectRecord& ObjectRecord : ObjectRecords)
	{
		if (ObjectRecord.bActor == false)
		{
			if (ObjectRecord.OuterID != INDEX_NONE)
			{
				if (TempObjects.IsValidIndex(ObjectRecord.OuterID) == true)
				{
					LoadOuter = TempObjects[ObjectRecord.OuterID];
					if (LoadOuter == nullptr)
					{
						UE_LOG(LogTemp, Error, TEXT("Unable to find Outer for object (invalid array object)"))
					}
				}
				else
				{
					const int32 NewIndex = FMath::Abs(ObjectRecord.OuterID) - 2;

					if (PersistentOuters.IsValidIndex(NewIndex)) 
					{
						LoadOuter = PersistentOuters[NewIndex];
					}
					else 
					{
						UE_LOG(LogTemp, Error, TEXT("Unable to find Outer for object (invalid ID)"))
					}   
				}
			}
			if (LoadOuter == nullptr)
			{
				UE_LOG(LogTemp, Error, TEXT("Unable to find Outer for object (no pointer)"))
				continue;
			}

			UObject* LoadObject = NewObject<UObject>(LoadOuter, ObjectRecord.Class, ObjectRecord.Name);
            
			if (LoadObject == nullptr) return;

			// don't load now, load after all objects are preloaded
			//LoadData(LoadObject, ObjectRecord.Data);

			// add to here to cycle through and keep a pointer temporarily to avoid garbage collection (not sure if required but to be safe)
			this->TempObjects.Add(LoadObject);

			UE_LOG(LogTemp, Display, TEXT("Complete Load UObject %s %d"), *LoadObject->GetPathName(), this->TempObjects.Num() - 1)
		}

		else
		{
			ActorPreloader(WorldActor, ObjectRecord);
		}
	}
}

void UNightSkySaveInfo::UObjectDataLoader()
{
	for (int32 a = 0 ; ObjectRecords.IsValidIndex(a) ; a++)
	{
		// Load now after all objects are preloaded
		LoadData(TempObjects[a], ObjectRecords[a].Data);
	}
}

void UNightSkySaveInfo::SaveData(UObject* Object, TArray<uint8>& InData)
{
	if (Object == nullptr) return;

	FMemoryWriter MemoryWriter = FMemoryWriter(Data, true);
	FNightSkySaveArchive MyArchive = FNightSkySaveArchive(MemoryWriter);

	Object->Serialize(MyArchive);
}

void UNightSkySaveInfo::LoadData(UObject* Object, TArray<uint8>& InData)
{
	if (Object == nullptr) return;

	FMemoryReader MemoryReader(Data, true);

	FNightSkySaveArchive Ar(MemoryReader);
	Object->Serialize(Ar);
}


```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySaveInfo.h`:

```h
#pragma once
#include "GameFramework/SaveGame.h"
#include "Serialization/ObjectAndNameAsStringProxyArchive.h"
#include "NightSkySaveInfo.generated.h"

struct FNightSkySaveArchive : FObjectAndNameAsStringProxyArchive
{
	FNightSkySaveArchive(FArchive& InInnerArchive)
		: FObjectAndNameAsStringProxyArchive(InInnerArchive, true)
	{
		ArIsSaveGame = true;
		ArNoDelta = true;
	}
};

USTRUCT(BlueprintType)
struct FObjectRecord
{
	GENERATED_BODY()

	// class that this object is
	UPROPERTY(BlueprintReadWrite)
	UClass* Class;

	// save the outer used for object so they get loaded back in the correct hierarchy
	UPROPERTY(BlueprintReadWrite)
	UObject* Outer;

	// save the outer used for object so they get loaded back in the correct hierarchy
	UPROPERTY(BlueprintReadWrite)
	int32 OuterID;

	// if the outer is an actor otherwise will be UObject
	UPROPERTY(BlueprintReadWrite)
	bool bActor;

	// this is for loading only, store a pointer for the loaded object here so you can loop for the records later to de-serialize all the data
	UPROPERTY(BlueprintReadWrite)
	UObject* Self;

	// Name of the object
	UPROPERTY(BlueprintReadWrite)
	FName Name;

	// serialized data for all UProperties that are 'SaveGame' enabled
	UPROPERTY(BlueprintReadWrite)
	TArray<uint8> Data;

	// Spawn location if it's an actor
	UPROPERTY(BlueprintReadWrite)
	FTransform Transform;

	FObjectRecord()
	{
		Class = nullptr;
		Outer = nullptr;
		Self = nullptr;
	}
};

UCLASS()
class UNightSkySaveInfo : public USaveGame
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<uint8> Data;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<FObjectRecord> ObjectRecords;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<UObject*> TempObjects;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<UObject*> PersistentOuters;

	// basically just a wrapper so you don't have to do a for loop in blueprints
	UFUNCTION(BlueprintCallable)
	void ActorArraySaver(UPARAM(ref)TArray<AActor*>& SaveActors);

	// Save individual Actors
	UFUNCTION(BlueprintCallable)
	void ActorSaver(AActor* SaveActor);

	// Create all saved actors without any data serialized yet
	UFUNCTION(BlueprintCallable)
	void ActorPreloader(AActor* WorldActor, FObjectRecord& ActorRecord);

	// basically just a wrapper so you don't have to do a for loop in blueprints
	UFUNCTION(BlueprintCallable)
	void UObjectArraySaver(UPARAM(ref) TArray<UObject*>& SaveObjects);

	// Save individual objects
	UFUNCTION(BlueprintCallable)
	void UObjectSaver(UObject* SaveObject);

	// create all saved objects without any data serialized yet
	UFUNCTION(BlueprintCallable)
	void UObjectsPreloader(AActor* WorldActor);

	// load all data after all objects exist so all pointers will load
	UFUNCTION(BlueprintCallable)
	void UObjectDataLoader();

	// serialize the data
	UFUNCTION(BlueprintCallable)
	void SaveData(UObject* Object, TArray<uint8>& InData);

	// de-serialize the data
	UFUNCTION(BlueprintCallable)
	void LoadData(UObject* Object, UPARAM(ref) TArray<uint8>& InData);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySettingsInfo.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NightSkySaveInfo.h"
#include "NightSkySettingsInfo.generated.h"

class UInputAction;

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UNightSkySettingsInfo : public UNightSkySaveInfo
{
	GENERATED_BODY()

public:
	UPROPERTY(BlueprintReadWrite)
	int32 AntiAliasingMethod;
	UPROPERTY(BlueprintReadWrite)
	int32 GlobalIlluminationMethod;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/ReplayInfo.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ReplayInfo.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(ReplayInfo)

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/ReplayInfo.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NightSkyGameInstance.h"
#include "NightSkySaveInfo.h"
#include "ReplayInfo.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UReplaySaveInfo : public UNightSkySaveInfo
{
	GENERATED_BODY()

public:
	UReplaySaveInfo()  
	{
		Timestamp = FDateTime::Now();
		BattleData = FBattleData();  
		Version = "";
		ReplayIndex = -1;
		LengthInFrames = 0;
	}
	
	UPROPERTY(BlueprintReadOnly)  
	FDateTime Timestamp;
	UPROPERTY(BlueprintReadOnly)  
	FBattleData BattleData;
	UPROPERTY(BlueprintReadOnly)  
	FString Version;
	UPROPERTY(BlueprintReadOnly)
	int32 ReplayIndex;
	UPROPERTY()
	int32 LengthInFrames;
	UPROPERTY()
	TArray<int32> InputsP1;
	UPROPERTY()
	TArray<int32> InputsP2;
	UPROPERTY()
	bool bIsTraining;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Network/FighterRunners.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "FighterRunners.generated.h"

/**
 * 
 */
UENUM(BlueprintType)
enum EFighterRunners {
	LocalPlay,
	Multiplayer,
	SyncTest
};
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NSESessionSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NSESessionSubsystem.h"

#include "OnlineSessionSettings.h"
#include "OnlineSubsystemUtils.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "Online/OnlineSessionNames.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NSESessionSubsystem)

FNSESessionInfo::FNSESessionInfo(const FOnlineSessionSearchResult& Result, const FString& Name, int32 OpenPrivate, int32 OpenPublic)
	: SessionSearchResult(Result), OwningUserName(Name), NumOpenPrivateConnections(OpenPrivate),
	  NumOpenPublicConnections(OpenPublic)
{
}

UNSESessionSubsystem::UNSESessionSubsystem() : CreateSessionCompleteDelegate(
	                                               FOnCreateSessionCompleteDelegate::CreateUObject(
		                                               this, &ThisClass::OnCreateSessionComplete)),
                                               UpdateSessionCompleteDelegate(
	                                               FOnUpdateSessionCompleteDelegate::CreateUObject(
		                                               this, &ThisClass::OnUpdateSessionComplete)),
                                               StartSessionCompleteDelegate(
	                                               FOnStartSessionCompleteDelegate::CreateUObject(
		                                               this, &ThisClass::OnStartSessionComplete)),
                                               DestroySessionCompleteDelegate(
	                                               FOnDestroySessionCompleteDelegate::CreateUObject(
		                                               this, &ThisClass::OnDestroySessionComplete)),
                                               FindSessionsCompleteDelegate(
	                                               FOnFindSessionsCompleteDelegate::CreateUObject(
		                                               this, &ThisClass::OnFindSessionsComplete)),
                                               JoinSessionCompleteDelegate(
	                                               FOnJoinSessionCompleteDelegate::CreateUObject(
		                                               this, &ThisClass::OnJoinSessionComplete)),
                                               SessionUserInviteAcceptedDelegate(
	                                               FOnSessionUserInviteAcceptedDelegate::CreateUObject(
		                                               this, &ThisClass::OnSessionInviteAccepted)
                                               )
{
	const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());
	if (!SessionInterface.IsValid()) return;

	SessionUserInviteAcceptedDelegateHandle = SessionInterface->AddOnSessionUserInviteAcceptedDelegate_Handle(SessionUserInviteAcceptedDelegate);
}

void UNSESessionSubsystem::Login()
{
	IOnlineSubsystem* Subsystem = Online::GetSubsystem(GetWorld());
	IOnlineIdentityPtr Identity = Subsystem->GetIdentityInterface(); // This is the generic OSS interface that will access the EOS OSS.
 
	// If you're logged in, don't try to login again.
	// This can happen if your player travels to a dedicated server or different maps as BeginPlay() will be called each time.
    
	FUniqueNetIdPtr NetId = Identity->GetUniquePlayerId(0);
 
	if (NetId != nullptr && Identity->GetLoginStatus(0) == ELoginStatus::LoggedIn)
	{
		return; 
	}
	
	LoginDelegateHandle = Identity->AddOnLoginCompleteDelegate_Handle(
		0,
		FOnLoginCompleteDelegate::CreateUObject(
			this,
			&ThisClass::OnLoginCompleted));
	
	FString AuthType; 
	FParse::Value(FCommandLine::Get(), TEXT("AUTH_TYPE="), AuthType);
 
	if (!AuthType.IsEmpty()) //If parameter is NOT empty we can autologin.
	{
		/* 
		In most situations you will want to automatically log a player in using the parameters passed via CLI.
		For example, using the exchange code for the Epic Games Store.
		*/
		UE_LOG(LogTemp, Log, TEXT("Logging into EOS...")); // Log to the UE logs that we are trying to log in. 
      
		if (!Identity->AutoLogin(0))
		{
			UE_LOG(LogTemp, Warning, TEXT("Failed to login... ")); // Log to the UE logs that we are trying to log in.
			// Clear our handle and reset the delegate.
			Identity->ClearOnLoginCompleteDelegate_Handle(0, LoginDelegateHandle);
			LoginDelegateHandle.Reset();			
		}
	}
	else
	{
		/* 
		Fallback if the CLI parameters are empty.Useful for PIE.
		The type here could be developer if using the DevAuthTool, ExchangeCode if the game is launched via the Epic Games Launcher, etc...
		*/
		FOnlineAccountCredentials Credentials("accountportal","", "SteamAppTicket");
 
		UE_LOG(LogTemp, Log, TEXT("Logging into EOS...")); // Log to the UE logs that we are trying to log in. 
        
		if (!Identity->Login(0, Credentials))
		{
			UE_LOG(LogTemp, Warning, TEXT("Failed to login... ")); // Log to the UE logs that we are trying to log in.
			// Clear our handle and reset the delegate. 
			Identity->ClearOnLoginCompleteDelegate_Handle(0, LoginDelegateHandle);
			LoginDelegateHandle.Reset();
		}        
	}
}

bool UNSESessionSubsystem::IsLoggedIn() const
{
	IOnlineSubsystem* Subsystem = Online::GetSubsystem(GetWorld());
	IOnlineIdentityPtr Identity = Subsystem->GetIdentityInterface(); // This is the generic OSS interface that will access the EOS OSS.
	
	FUniqueNetIdPtr NetId = Identity->GetUniquePlayerId(0);
 
	if (NetId != nullptr && Identity->GetLoginStatus(0) == ELoginStatus::LoggedIn)
	{
		return true; 
	}
	
	return false;
}

void UNSESessionSubsystem::CreateSession(int32 NumPublicConnections, bool bIsLANMatch)
{
	const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());
	if (!SessionInterface.IsValid())
	{
		OnCreateSessionCompleteDelegate.Broadcast(false);
		return;
	}

	LastSessionSettings = MakeShareable(new FOnlineSessionSettings());
	LastSessionSettings->NumPrivateConnections = 0;
	LastSessionSettings->NumPublicConnections = NumPublicConnections;
	LastSessionSettings->bAllowInvites = true;
	LastSessionSettings->bAllowJoinInProgress = true;
	LastSessionSettings->bAllowJoinViaPresence = true;
	LastSessionSettings->bAllowJoinViaPresenceFriendsOnly = false;
	LastSessionSettings->bIsDedicated = false;
	LastSessionSettings->bUsesPresence = true;
	LastSessionSettings->bUseLobbiesIfAvailable = true;
	LastSessionSettings->bIsLANMatch = bIsLANMatch;
	LastSessionSettings->bShouldAdvertise = true;

	LastSessionSettings->Set(SEARCH_LOBBIES, true, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);

	CreateSessionCompleteDelegateHandle = SessionInterface->AddOnCreateSessionCompleteDelegate_Handle(
		CreateSessionCompleteDelegate);

	if (!SessionInterface->CreateSession(0, NAME_GameSession, *LastSessionSettings))
	{
		SessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);

		OnCreateSessionCompleteDelegate.Broadcast(false);
	}
}

void UNSESessionSubsystem::UpdateSession()
{
	const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());
	if (!SessionInterface.IsValid())
	{
		OnUpdateSessionCompleteEvent.Broadcast(false);
		return;
	}

	const TSharedPtr<FOnlineSessionSettings> UpdatedSessionSettings = MakeShareable(
		new FOnlineSessionSettings(*LastSessionSettings));

	UpdateSessionCompleteDelegateHandle =
		SessionInterface->AddOnUpdateSessionCompleteDelegate_Handle(UpdateSessionCompleteDelegate);

	if (!SessionInterface->UpdateSession(NAME_GameSession, *UpdatedSessionSettings))
	{
		SessionInterface->ClearOnUpdateSessionCompleteDelegate_Handle(UpdateSessionCompleteDelegateHandle);

		OnUpdateSessionCompleteEvent.Broadcast(false);
	}
	else
	{
		LastSessionSettings = UpdatedSessionSettings;
	}
}

void UNSESessionSubsystem::StartSession()
{
	const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());
	if (!SessionInterface.IsValid())
	{
		OnStartSessionCompleteEvent.Broadcast(false);
		return;
	}

	StartSessionCompleteDelegateHandle =
		SessionInterface->AddOnStartSessionCompleteDelegate_Handle(StartSessionCompleteDelegate);

	if (!SessionInterface->StartSession(NAME_GameSession))
	{
		SessionInterface->ClearOnStartSessionCompleteDelegate_Handle(StartSessionCompleteDelegateHandle);

		OnStartSessionCompleteEvent.Broadcast(false);
	}
}

void UNSESessionSubsystem::DestroySession()
{
	const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());
	if (!SessionInterface.IsValid())
	{
		OnDestroySessionCompleteEvent.Broadcast(false);
		return;
	}

	DestroySessionCompleteDelegateHandle =
		SessionInterface->AddOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegate);

	if (!SessionInterface->DestroySession(NAME_GameSession))
	{
		SessionInterface->ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);

		OnDestroySessionCompleteEvent.Broadcast(false);
	}
}

void UNSESessionSubsystem::FindSessions(int32 MaxSearchResults, bool IsLANQuery)
{
	const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());
	if (!SessionInterface.IsValid())
	{
		OnFindSessionsCompleteEvent.Broadcast(TArray<FNSESessionInfo>(), false);
		return;
	}

	FindSessionsCompleteDelegateHandle =
		SessionInterface->AddOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegate);

	LastSessionSearch = MakeShareable(new FOnlineSessionSearch());
	LastSessionSearch->MaxSearchResults = MaxSearchResults;
	LastSessionSearch->bIsLanQuery = IsLANQuery;

	LastSessionSearch->QuerySettings.Set(SEARCH_LOBBIES, true, EOnlineComparisonOp::Equals);

	if (!SessionInterface->FindSessions(0, LastSessionSearch.ToSharedRef()))
	{
		SessionInterface->ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle);

		OnFindSessionsCompleteEvent.Broadcast(TArray<FNSESessionInfo>(), false);
	}
}

void UNSESessionSubsystem::JoinGameSession_BP(FNSESessionInfo Info)
{
	JoinGameSession(Info.SessionSearchResult);
}

void UNSESessionSubsystem::JoinGameSession(const FOnlineSessionSearchResult& SessionResult)
{
	const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());
	if (!SessionInterface.IsValid())
	{
		OnJoinGameSessionCompleteEvent.Broadcast(EOnJoinSessionCompleteResult::UnknownError);
		return;
	}

	JoinSessionCompleteDelegateHandle =
		SessionInterface->AddOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegate);

	auto ModResult = SessionResult;
	
	ModResult.Session.SessionSettings.bUsesPresence = true;
	ModResult.Session.SessionSettings.bUseLobbiesIfAvailable = true;
	if (!SessionInterface->JoinSession(0, NAME_GameSession, ModResult))
	{
		SessionInterface->ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle);

		OnJoinGameSessionCompleteEvent.Broadcast(EOnJoinSessionCompleteResult::UnknownError);
	}
}

void UNSESessionSubsystem::OnLoginCompleted(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId& UserId,
	const FString& Error)
{
	IOnlineSubsystem* Subsystem = Online::GetSubsystem(GetWorld());
	IOnlineIdentityPtr Identity = Subsystem->GetIdentityInterface();
	if (bWasSuccessful)
	{
		UE_LOG(LogTemp, Log, TEXT("Login callback completed!"));; 
	}
	else //Login failed
	{
		// TODO: set login failed message
		UE_LOGFMT(LogTemp, Error, "EOS login failed. Error: {0}", Error); //Print sign in failure in logs as an error
	}
 
	Identity->ClearOnLoginCompleteDelegate_Handle(LocalUserNum, LoginDelegateHandle);
	LoginDelegateHandle.Reset();
}

void UNSESessionSubsystem::OnCreateSessionComplete(FName SessionName, bool bSuccess)
{
	if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))
	{
		SessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);
	}

	OnCreateSessionCompleteDelegate.Broadcast(bSuccess);
}

void UNSESessionSubsystem::OnUpdateSessionComplete(FName SessionName, bool bSuccess)
{
	if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))
	{
		SessionInterface->ClearOnUpdateSessionCompleteDelegate_Handle(UpdateSessionCompleteDelegateHandle);
	}

	OnUpdateSessionCompleteEvent.Broadcast(bSuccess);
}

void UNSESessionSubsystem::OnStartSessionComplete(FName SessionName, bool bSuccess)
{
	if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))
	{
		SessionInterface->ClearOnStartSessionCompleteDelegate_Handle(StartSessionCompleteDelegateHandle);
	}

	OnStartSessionCompleteEvent.Broadcast(bSuccess);
}

void UNSESessionSubsystem::OnDestroySessionComplete(FName SessionName, bool bSuccess)
{
	if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))
	{
		SessionInterface->ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);
	}

	OnDestroySessionCompleteEvent.Broadcast(bSuccess);
}

void UNSESessionSubsystem::OnFindSessionsComplete(bool bSuccess)
{
	if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))
	{
		SessionInterface->ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle);
	}

	if (LastSessionSearch->SearchResults.Num() <= 0)
	{
		OnFindSessionsCompleteEvent.Broadcast(TArray<FNSESessionInfo>(), bSuccess);
		return;
	}

	TArray<FNSESessionInfo> Sessions{};
	for (auto SearchResult : LastSessionSearch->SearchResults)
	{
		Sessions.Add(FNSESessionInfo(
			SearchResult, SearchResult.Session.OwningUserName, SearchResult.Session.NumOpenPrivateConnections,
			SearchResult.Session.NumOpenPublicConnections
		));
	}

	OnFindSessionsCompleteEvent.Broadcast(Sessions, bSuccess);
}

void UNSESessionSubsystem::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result)
{
	if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))
	{
		SessionInterface->ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle);
	}

	OnJoinGameSessionCompleteEvent.Broadcast(Result);

	TryTravelToCurrentSession();
}

void UNSESessionSubsystem::OnSessionInviteAccepted(const bool bSuccess, const int32 ControllerId,
                                                   FUniqueNetIdPtr UserId,
                                                   const FOnlineSessionSearchResult& InviteResult)
{
	const auto GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
	if (!IsValid(GameInstance))
	{
		UE_LOG(LogTemp, Error, TEXT("OnSessionInviteAccepted: Invalid GameInstance"));
		return;
	}
	if (GameInstance->BattleData.PlayerListP2.IsEmpty()) return;
	
	JoinGameSession(InviteResult);
}

bool UNSESessionSubsystem::TryTravelToCurrentSession()
{
	const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());
	if (!SessionInterface.IsValid())
	{
		return false;
	}

	FString ConnectString;
	if (!SessionInterface->GetResolvedConnectString(NAME_GameSession, ConnectString))
	{
		return false;
	}

	APlayerController* PlayerController = GetWorld()->GetFirstPlayerController();
	PlayerController->ClientTravel(ConnectString, TRAVEL_Absolute);
	return true;
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NSESessionSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "OnlineSessionSettings.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "Interfaces/OnlineSessionInterface.h"
#include "NSESessionSubsystem.generated.h"

USTRUCT(BlueprintType)
struct FNSESessionInfo
{
	GENERATED_BODY()

	FNSESessionInfo() = default;
	FNSESessionInfo(const FOnlineSessionSearchResult& Result, const FString& Name, int32 OpenPrivate, int32 OpenPublic);

	/** Session */
	FOnlineSessionSearchResult SessionSearchResult{};
	/** Owner name of the session */
	UPROPERTY(BlueprintReadOnly)
	FString OwningUserName;
	/** The number of private connections that are available (read only) */
	UPROPERTY(BlueprintReadOnly)
	int32 NumOpenPrivateConnections;
	/** The number of publicly available connections that are available (read only) */
	UPROPERTY(BlueprintReadOnly)
	int32 NumOpenPublicConnections;
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FNSEOnCreateSessionComplete, bool, bSuccess);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FNSEOnUpdateSessionComplete, bool, bSuccess);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FNSEOnStartSessionComplete, bool, bSuccess);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FNSEOnDestroySessionComplete, bool, bSuccess);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FNSEOnFindSessionsComplete, const TArray<FNSESessionInfo>&, SessionResults, bool, bSuccess);
DECLARE_MULTICAST_DELEGATE_OneParam(FNSEOnJoinSessionComplete, EOnJoinSessionCompleteResult::Type Result);

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UNSESessionSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()

public:
	UNSESessionSubsystem();

	UFUNCTION(BlueprintCallable)
	void Login();
	FDelegateHandle LoginDelegateHandle;
	
	UFUNCTION(BlueprintPure)
	bool IsLoggedIn() const;

	UFUNCTION(BlueprintCallable)
	void CreateSession(int32 NumPublicConnections, bool bIsLANMatch);
	FNSEOnCreateSessionComplete OnCreateSessionCompleteDelegate;
	
	UFUNCTION(BlueprintCallable)
	void UpdateSession();
	FNSEOnUpdateSessionComplete OnUpdateSessionCompleteEvent;
	
	UFUNCTION(BlueprintCallable)
	void StartSession();
	FNSEOnStartSessionComplete OnStartSessionCompleteEvent;
	
	UFUNCTION(BlueprintCallable)
	void DestroySession();
	FNSEOnDestroySessionComplete OnDestroySessionCompleteEvent;
	
	UFUNCTION(BlueprintCallable)
	void FindSessions(int32 MaxSearchResults, bool IsLANQuery);
	UPROPERTY(BlueprintAssignable)
	FNSEOnFindSessionsComplete OnFindSessionsCompleteEvent;

	UFUNCTION(BlueprintCallable)
	void JoinGameSession_BP(FNSESessionInfo Info);
	
	void JoinGameSession(const FOnlineSessionSearchResult& SessionResult);
	FNSEOnJoinSessionComplete OnJoinGameSessionCompleteEvent;

protected:
	void OnLoginCompleted(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId& UserId, const FString& Error);
	void OnCreateSessionComplete(FName SessionName, bool bSuccess);
	void OnUpdateSessionComplete(FName SessionName, bool bSuccess);
	void OnStartSessionComplete(FName SessionName, bool bSuccess);
	void OnDestroySessionComplete(FName SessionName, bool bSuccess);
	void OnFindSessionsComplete(bool bSuccess);
	void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result);
	void OnSessionInviteAccepted(const bool bSuccess, const int32 ControllerId, FUniqueNetIdPtr UserId, const FOnlineSessionSearchResult& InviteResult);
	bool TryTravelToCurrentSession();

private:
	FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;
	FDelegateHandle CreateSessionCompleteDelegateHandle;;
	
	FOnUpdateSessionCompleteDelegate UpdateSessionCompleteDelegate;
	FDelegateHandle UpdateSessionCompleteDelegateHandle;
	
	FOnStartSessionCompleteDelegate StartSessionCompleteDelegate;
	FDelegateHandle StartSessionCompleteDelegateHandle;

	FOnDestroySessionCompleteDelegate DestroySessionCompleteDelegate;
	FDelegateHandle DestroySessionCompleteDelegateHandle;

	FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate;
	FDelegateHandle FindSessionsCompleteDelegateHandle;
	TSharedPtr<FOnlineSessionSearch> LastSessionSearch;

	FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;
	FDelegateHandle JoinSessionCompleteDelegateHandle;

	FOnSessionUserInviteAcceptedDelegate SessionUserInviteAcceptedDelegate;
	FDelegateHandle SessionUserInviteAcceptedDelegateHandle;

	TSharedPtr<FOnlineSessionSettings> LastSessionSettings;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NetworkPawn.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NetworkPawn.h"

#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "RpcConnectionManager.h"
#include "Engine/AssetManager.h"
#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "Net/UnrealNetwork.h"
#include "NightSkyEngine/Battle/NightSkyPlayerController.h"
#include "NightSkyEngine/Battle/FighterRunners/FighterMultiplayerRunner.h"
#include "NightSkyEngine/Data/PrimaryCharaData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NetworkPawn)

// Sets default values
ANetworkPawn::ANetworkPawn()
{
	// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	bReplicates = true;
}

// Called when the game starts or when spawned
void ANetworkPawn::BeginPlay()
{
	Super::BeginPlay();
}

void ANetworkPawn::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ANetworkPawn, CharaDataReceived)
	DOREPLIFETIME(ANetworkPawn, bRematchAccepted)
}

void ANetworkPawn::ServerGetCharaData(TArray<FPrimaryAssetId> Assets)
{
	auto NetworkPawn = Cast<ANightSkyPlayerController>(GetWorld()->GetFirstPlayerController())->NetworkPawn;
	if (NetworkPawn->CharaDataReceived) return;
	
	UNightSkyGameInstance* GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());

	GameInstance->BattleData.PlayerListP2.Empty();
	for (const auto CharaData : Assets)
	{
		GameInstance->BattleData.PlayerListP2.Add(Cast<UPrimaryCharaData>(UAssetManager::Get().GetPrimaryAssetObject(CharaData)));
	}

	NetworkPawn->CharaDataReceived = true;
}

void ANetworkPawn::ClientGetCharaData(TArray<FPrimaryAssetId> Assets)
{
	if (CharaDataReceived) return;
	
	UNightSkyGameInstance* GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());

	GameInstance->BattleData.PlayerListP1.Empty();
	for (const auto CharaData : Assets)
	{
		GameInstance->BattleData.PlayerListP1.Add(Cast<UPrimaryCharaData>(UAssetManager::Get().GetPrimaryAssetObject(CharaData)));
	}
}

void ANetworkPawn::SendRematchToServer_Implementation()
{
	Cast<ANightSkyPlayerController>(GetWorld()->GetFirstPlayerController())->NetworkPawn->bRematchAccepted = true;
}

void ANetworkPawn::ServerGetFinishedLoading_Implementation(bool Finished)
{
	const UNightSkyGameInstance* GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
	if (Finished == true && Finished == GameInstance->FinishedLoadingForNetworkBattle)
		GameInstance->TravelToBattleMap();
}

void ANetworkPawn::SendGgpoToClient_Implementation(const TArray<int8> &GgpoMessage)
{
	 if(FighterMultiplayerRunner)
	 	FighterMultiplayerRunner->connectionManager->receiveSchedule.AddTail(GgpoMessage);
}

void ANetworkPawn::SendGgpoToServer_Implementation(const TArray<int8> &GgpoMessage)
{
	 if(FighterMultiplayerRunner)
	 	FighterMultiplayerRunner->connectionManager->receiveSchedule.AddTail(GgpoMessage);
}

void ANetworkPawn::ClientGetBattleData_Implementation(FBattleData InBattleData, FNetworkMirror Mirror)
{
	UNightSkyGameInstance* GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
	UAssetManager::Get().LoadPrimaryAssets(Mirror.PlayerList, TArray<FName>(), FStreamableDelegate::CreateUObject(this, &ANetworkPawn::ClientGetCharaData, Mirror.PlayerList));
	GameInstance->BattleData.ColorIndicesP1 = InBattleData.ColorIndicesP1;
	GameInstance->BattleData.BattleFormat = InBattleData.BattleFormat;
	GameInstance->BattleData.RoundCount = InBattleData.RoundCount;
	GameInstance->BattleData.StartRoundTimer = InBattleData.StartRoundTimer;
	GameInstance->BattleData.Random = InBattleData.Random;
	GameInstance->BattleData.Stage = InBattleData.Stage;
	GameInstance->BattleData.MusicName = InBattleData.MusicName;
}

void ANetworkPawn::ServerGetBattleData_Implementation(FBattleData InBattleData, FNetworkMirror Mirror)
{
	UNightSkyGameInstance* GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
	UAssetManager::Get().LoadPrimaryAssets(Mirror.PlayerList, TArray<FName>(), FStreamableDelegate::CreateUObject(this, &ANetworkPawn::ServerGetCharaData, Mirror.PlayerList));
	GameInstance->BattleData.ColorIndicesP2 = InBattleData.ColorIndicesP2;
}

void ANetworkPawn::ServerChecksumCheck_Implementation(uint32 Checksum, int32 InFrame)
{
	if (ANightSkyGameState* GameState = Cast<ANightSkyGameState>(GetWorld()->GetGameState()))
	{
		if (GameState != nullptr)
		{
			GameState->SetOtherChecksum(Checksum, InFrame);
		}
	}
}

void ANetworkPawn::ClientChecksumCheck_Implementation(uint32 Checksum, int32 InFrame)
{
	if (ANightSkyGameState* GameState = Cast<ANightSkyGameState>(GetWorld()->GetGameState()))
	{
		if (GameState != nullptr)
		{
			GameState->SetOtherChecksum(Checksum, InFrame);
		}
	}
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NetworkPawn.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Pawn.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "NetworkPawn.generated.h"

class APlayerObject;

USTRUCT()
struct FNetworkMirror
{
	GENERATED_BODY()

	UPROPERTY()
	TArray<FPrimaryAssetId> PlayerList;
	UPROPERTY()
	FPrimaryAssetId Stage;
};

UCLASS()
class NIGHTSKYENGINE_API ANetworkPawn : public APawn
{
	GENERATED_BODY()

public:
	// Sets default values for this pawn's properties
	ANetworkPawn();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	
	UPROPERTY(BlueprintReadOnly, Replicated)
	bool CharaDataReceived = false;
	UPROPERTY(BlueprintReadOnly, Replicated)
	bool bRematchAccepted = false;
	
	UFUNCTION( Server, Reliable )
	void ServerChecksumCheck(uint32 Checksum, int32 InFrame);
	UFUNCTION( Client, Reliable )
	void ClientChecksumCheck(uint32 Checksum, int32 InFrame);
	UFUNCTION( Server, Reliable )
	void ServerGetBattleData(FBattleData InBattleData, FNetworkMirror Mirror);
	UFUNCTION( Client, Reliable )
	void ClientGetBattleData(FBattleData InBattleData, FNetworkMirror Mirror);
	UFUNCTION( Server, Reliable )
	void ServerGetFinishedLoading(bool Finished);

	void ServerGetCharaData(TArray<FPrimaryAssetId> Assets);
	void ClientGetCharaData(TArray<FPrimaryAssetId> Assets);

	UPROPERTY()
	class AFighterMultiplayerRunner* FighterMultiplayerRunner = nullptr;
	
	UFUNCTION( Server, Reliable )
	void SendGgpoToServer(const TArray<int8> &GgpoMessage);
	UFUNCTION( Client, Reliable )
	void SendGgpoToClient(const TArray<int8> &GgpoMessage);
	
	UFUNCTION( Server, Reliable )
	void SendRematchToServer();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Network/RpcConnectionManager.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RpcConnectionManager.h"


RpcConnectionManager::RpcConnectionManager()
{
	playerIndex = 0;
}

RpcConnectionManager::~RpcConnectionManager()
{
}

int RpcConnectionManager::SendTo(const char* buffer, int len, int flags, int connection_id)
{
	const TArray scheduledMessage((int8*)buffer,len);
	sendSchedule.AddTail(scheduledMessage);

	return 0;
}

int RpcConnectionManager::RecvFrom(char* buffer, int len, int flags, int* connection_id)
{
	if (receiveSchedule.Num() == 0)
		return -1;
	auto msg = receiveSchedule.GetTail();
	
	auto msgVal = msg->GetValue();
	auto rec = (char*)msgVal.GetData();
	auto leng = msgVal.Num(); // int* to char* size
	if (leng == 0)
		return -1;
	memcpy(buffer, rec, leng);
	receiveSchedule.Empty();
	*connection_id = playerIndex;
	return leng;
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/Network/RpcConnectionManager.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "include/connection_manager.h"

/**
 * 
 */
class NIGHTSKYENGINE_API RpcConnectionManager: public ConnectionManager
{
public:
	RpcConnectionManager();
	virtual ~RpcConnectionManager() override;
	
	virtual int SendTo(const char* buffer, int len, int flags, int connection_id);
	virtual int RecvFrom(char* buffer, int len, int flags, int* connection_id);
	
	int playerIndex;
	TDoubleLinkedList<TArray<int8>> sendSchedule;
	TDoubleLinkedList<TArray<int8>> receiveSchedule;
};


```

`Plugins/NightSkyEngine/Source/NightSkyEngine/NightSkyEngine.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class NightSkyEngine : ModuleRules
{
	public NightSkyEngine(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new[]
		{
			"Core",
			"CoreUObject", 
			"Engine",
			"InputCore",
			"OnlineSubsystem",
			"OnlineSubsystemUtils",
			"MovieScene",
			"LevelSequence",
			"EnhancedInput",
			"UMG",
			"Niagara",
			"Paper2D",
		});
		
		PrivateDependencyModuleNames.AddRange(new[]
		{
			"AIModule",
			"GGPOUE4",
			"Json",
			"CommonUI",
			"CommonInput",
			"GameplayTags",
			"CinematicCamera",
			"StateTreeModule", 
			"DeveloperSettings",
		});

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
		
		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/NightSkyEngine.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "NightSkyEngine.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_MODULE(FDefaultModuleImpl, NightSkyEngine);

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/NightSkyEngine.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"


```

`Plugins/NightSkyEngine/Source/NightSkyEngine/UI/ExtendedCommonActivatableWidget.cpp`:

```cpp
#include "ExtendedCommonActivatableWidget.h"

#include "Editor/WidgetCompilerLog.h"
#include "Input/CommonUIInputTypes.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(ExtendedCommonActivatableWidget)

#define LOCTEXT_NAMESPACE "NightSkyEngine"

UExtendedCommonActivatableWidget::UExtendedCommonActivatableWidget(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

TOptional<FUIInputConfig> UExtendedCommonActivatableWidget::GetDesiredInputConfig() const
{
	const auto Result = Super::GetDesiredInputConfig();
	
	if (Result.IsSet())
	{
		return Result;
	}
	
	switch (DefaultInputConfig)
	{
	case ENightSkyWidgetInputMode::GameAndMenu:
		return FUIInputConfig(ECommonInputMode::All, GameMouseCaptureMode);
	case ENightSkyWidgetInputMode::Game:
		return FUIInputConfig(ECommonInputMode::Game, GameMouseCaptureMode);
	case ENightSkyWidgetInputMode::Menu:
		return FUIInputConfig(ECommonInputMode::Menu, EMouseCaptureMode::NoCapture);
	case ENightSkyWidgetInputMode::Default:
	default:
		return TOptional<FUIInputConfig>();
	}
}

void UExtendedCommonActivatableWidget::NativeDestruct()
{
	for (FUIActionBindingHandle Handle : BindingHandles)
	{
		if (Handle.IsValid())
		{
			Handle.Unregister();
		}
	}
	BindingHandles.Empty();

	Super::NativeDestruct();
}

void UExtendedCommonActivatableWidget::RegisterBinding(FDataTableRowHandle InputAction, const FInputActionExecutedDelegate& Callback, FInputActionBindingHandle& BindingHandle)
{
	FBindUIActionArgs BindArgs(InputAction, FSimpleDelegate::CreateLambda([InputAction, Callback]()
	{
		Callback.ExecuteIfBound(InputAction.RowName);
	}));
	BindArgs.bDisplayInActionBar = true;
	
	BindingHandle.Handle = RegisterUIActionBinding(BindArgs);
	BindingHandles.Add(BindingHandle.Handle);
}

void UExtendedCommonActivatableWidget::UnregisterBinding(FInputActionBindingHandle BindingHandle)
{
	if (BindingHandle.Handle.IsValid())
	{
		BindingHandle.Handle.Unregister();
		BindingHandles.Remove(BindingHandle.Handle);
	}
}

void UExtendedCommonActivatableWidget::UnregisterAllBindings()
{
	for (FUIActionBindingHandle Handle : BindingHandles)
	{
		Handle.Unregister();
	}
	BindingHandles.Empty();
}

#if WITH_EDITOR

void UExtendedCommonActivatableWidget::ValidateCompiledWidgetTree(const UWidgetTree& BlueprintWidgetTree, IWidgetCompilerLog& CompileLog) const
{
	Super::ValidateCompiledWidgetTree(BlueprintWidgetTree, CompileLog);

	if (!GetClass()->IsFunctionImplementedInScript(GET_FUNCTION_NAME_CHECKED(UExtendedCommonActivatableWidget, BP_GetDesiredFocusTarget)))
	{
		if (GetParentNativeClass(GetClass()) == UExtendedCommonActivatableWidget::StaticClass())
		{
			CompileLog.Warning(LOCTEXT("ValidateGetDesiredFocusTarget_Warning", "GetDesiredFocusTarget wasn't implemented, you're going to have trouble using gamepads on this screen."));
		}
		else
		{
			// We can't guarantee it isn't implemented in a native subclass of this one.
			// Native subclasses should override ValidateCompiledWidgetTree, skipping this and invoking the base UUserWidget version
			CompileLog.Note(LOCTEXT("ValidateGetDesiredFocusTarget_Note", "GetDesiredFocusTarget wasn't implemented in Blueprint, you will have issues with gamepads if a native subclass did not implement it."));
		}
	}
}

#endif

#undef LOCTEXT_NAMESPACE
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/UI/ExtendedCommonActivatableWidget.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "CommonActivatableWidget.h"
#include "ExtendedCommonActivatableWidget.generated.h"

DECLARE_DYNAMIC_DELEGATE_OneParam(FInputActionExecutedDelegate, FName, ActionName);

UENUM(BlueprintType)
enum class ENightSkyWidgetInputMode : uint8
{
	Default,
	GameAndMenu,
	Game,
	Menu
};

USTRUCT(BlueprintType)
struct FInputActionBindingHandle
{
	GENERATED_BODY()
	
public:
	FUIActionBindingHandle Handle;
};

/**
 * Extends UCommonActivatableWidget with Blueprint-visible functions for registering additional input action bindings.
 */
UCLASS(Abstract, Blueprintable, meta = (DisableNativeTick))
class UExtendedCommonActivatableWidget : public UCommonActivatableWidget
{
	GENERATED_BODY()

public:
	UExtendedCommonActivatableWidget(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
	
	//~UCommonActivatableWidget interface
	virtual TOptional<FUIInputConfig> GetDesiredInputConfig() const override;
	//~End of UCommonActivatableWidget interface
	
#if WITH_EDITOR
	virtual void ValidateCompiledWidgetTree(const UWidgetTree& BlueprintWidgetTree, IWidgetCompilerLog& CompileLog) const override;
#endif

protected:
	virtual void NativeDestruct() override;

	UFUNCTION(BlueprintCallable, Category = ExtendedActivatableWidget)
	void RegisterBinding(FDataTableRowHandle InputAction, const FInputActionExecutedDelegate& Callback, FInputActionBindingHandle& BindingHandle);

	UFUNCTION(BlueprintCallable, Category = ExtendedActivatableWidget)
	void UnregisterBinding(FInputActionBindingHandle BindingHandle);

	UFUNCTION(BlueprintCallable, Category = ExtendedActivatableWidget)
	void UnregisterAllBindings();
	
	/** The desired input mode to use while this UI is activated, for example do you want key presses to still reach the game/player controller? */
	UPROPERTY(EditDefaultsOnly, Category = Input)
	ENightSkyWidgetInputMode DefaultInputConfig = ENightSkyWidgetInputMode::Default;
	
	/** The desired mouse behavior when the game gets input. */
	UPROPERTY(EditDefaultsOnly, Category = Input)
	EMouseCaptureMode GameMouseCaptureMode = EMouseCaptureMode::CapturePermanently;

private:
	TArray<FUIActionBindingHandle> BindingHandles;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleHudActor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyBattleHudActor.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyBattleHudActor)

// Sets default values
ANightSkyBattleHudActor::ANightSkyBattleHudActor()
{
	PrimaryActorTick.bCanEverTick = true;
}
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleHudActor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "NightSkyBattleHudActor.generated.h"

class UNightSkyBattleWidget;

UCLASS()
class NIGHTSKYENGINE_API ANightSkyBattleHudActor : public AActor
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ANightSkyBattleHudActor();

	UPROPERTY(BlueprintReadWrite)
	UNightSkyBattleWidget* TopWidget;
	UPROPERTY(BlueprintReadWrite)
	UNightSkyBattleWidget* BottomWidget;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleWidget.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyBattleWidget.h"

#include "Serialization/ObjectReader.h"
#include "Serialization/ObjectWriter.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyBattleWidget)

void UNightSkyBattleWidget::PlayStandardAnimations()
{
	PlayHealthAnim();
	PlayRecoverableHealthAnim();
	PlayTimerAnim();
	PlayMeterAnim();
	PlayGaugeAnim();
	PlayComboCounterAnim();
}

void UNightSkyBattleWidget::SetAnimationRollbackData()
{
	for (auto& [Anim, Time, bPlaying] : WidgetAnimationRollback)
	{
		if (IsAnimationPlaying(Anim))
		{
			bPlaying = true;
			Time = GetAnimationCurrentTime(Anim);
		}
	}
}

void UNightSkyBattleWidget::RollbackAnimations()
{
	for (const auto& [Anim, Time, bPlaying] : WidgetAnimationRollback)
	{
		if (bPlaying)
			PlayAnimation(Anim, Time);
		else
			SetAnimationCurrentTime(Anim, Time);
	}
}

TArray<uint8> UNightSkyBattleWidget::SaveForRollback()
{
	TArray<uint8> SaveData;
	FObjectWriter Writer(SaveData);
	Writer.ArIsSaveGame = true;
	GetClass()->SerializeBin(Writer, this);
	return SaveData;
}

void UNightSkyBattleWidget::LoadForRollback(const TArray<uint8>& InBytes)
{
	if (InBytes.Num() <= 1) return;
	FObjectReader Reader(InBytes);
	Reader.ArIsSaveGame = true;
	GetClass()->SerializeBin(Reader, this);
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleWidget.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "NightSkyBattleWidget.generated.h"

USTRUCT(BlueprintType)
struct FRollbackAnimation
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite)
	UWidgetAnimation* Anim;
	
	UPROPERTY(BlueprintReadWrite, SaveGame)
	float Time;

	UPROPERTY(BlueprintReadWrite, SaveGame)
	bool bPlaying;
};

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API UNightSkyBattleWidget : public UUserWidget
{
	GENERATED_BODY()
	
public:
	UPROPERTY(BlueprintReadOnly)
	TArray<float> P1Health;
	UPROPERTY(BlueprintReadOnly)
	TArray<float> P2Health;
	UPROPERTY(BlueprintReadOnly)
	TArray<float> P1RecoverableHealth;
	UPROPERTY(BlueprintReadOnly)
	TArray<float> P2RecoverableHealth;
	UPROPERTY(BlueprintReadOnly)
	float Timer;
	UPROPERTY(BlueprintReadOnly)
	float P1Meter;
	UPROPERTY(BlueprintReadOnly)
	float P2Meter;
	UPROPERTY(BlueprintReadOnly)
	TArray<float> P1Gauge;
	UPROPERTY(BlueprintReadOnly)
	TArray<float> P2Gauge;
	UPROPERTY(BlueprintReadOnly)
	int P1RoundsWon;
	UPROPERTY(BlueprintReadOnly)
	int P2RoundsWon;
	UPROPERTY(BlueprintReadOnly)
	int P1ComboCounter;
	UPROPERTY(BlueprintReadOnly)
	int P2ComboCounter;
	UPROPERTY(BlueprintReadOnly)
	int Ping;
	UPROPERTY(BlueprintReadOnly)
	int RollbackFrames;

	UPROPERTY(BlueprintReadWrite, SaveGame)
	TArray<FRollbackAnimation> WidgetAnimationRollback;

	UFUNCTION(BlueprintImplementableEvent)
	void RegisterAnimationsForRollback();

	UFUNCTION(BlueprintImplementableEvent)
	void PlayFadeAnim();
	
	UFUNCTION(BlueprintImplementableEvent)
	void PlayFadeOutAnim();

	UFUNCTION(BlueprintImplementableEvent)
	void PlayHealthAnim();

	UFUNCTION(BlueprintImplementableEvent)
	void PlayRecoverableHealthAnim();
	
	UFUNCTION(BlueprintImplementableEvent)
	void PlayTimerAnim();

	UFUNCTION(BlueprintImplementableEvent)
	void PlayMeterAnim();

	UFUNCTION(BlueprintImplementableEvent)
	void PlayGaugeAnim();
	
	UFUNCTION(BlueprintImplementableEvent)
	void PlayRoundInitAnim();

	UFUNCTION(BlueprintImplementableEvent)
	void PlayRoundWinAnim(bool bIsP1);

	UFUNCTION(BlueprintImplementableEvent)
	void PlayMatchWinAnim(bool bIsP1);

	UFUNCTION(BlueprintImplementableEvent)
	void PlayComboCounterAnim();

	void PlayStandardAnimations();
	void SetAnimationRollbackData();
	void RollbackAnimations();

	TArray<uint8> SaveForRollback();
	void LoadForRollback(const TArray<uint8>& InBytes);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/VSInfo/NightSkyVSInfoGameState.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyVSInfoGameState.h"

#include "NightSkyEngine/Network/NetworkPawn.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "Kismet/GameplayStatics.h"
#include "NightSkyEngine/Battle/Objects/PlayerObject.h"
#include "NightSkyEngine/Data/PrimaryCharaData.h"
#include "NightSkyEngine/Data/PrimaryStageData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyVSInfoGameState)

ANightSkyVSInfoGameState::ANightSkyVSInfoGameState()
{
	PrimaryActorTick.bCanEverTick = true;

	VSInfoTime = 0;
	MapLoaded = false;
	LoadedCharaPackageCount = 0;
	TotalCharaPackageCount = 0;
}

void ANightSkyVSInfoGameState::BeginPlay()
{
	Super::BeginPlay();

	GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
	LoadPackageAsync(GameInstance->BattleData.Stage->StageURL,
		FLoadPackageAsyncDelegate::CreateUObject(this,
			&ANightSkyVSInfoGameState::OnMapPackageLoaded),
		0, PKG_ContainsMap);
	for (const auto PrimaryCharaData : GameInstance->BattleData.PlayerListP1)
	{
		if (PrimaryCharaData == nullptr) continue;
		++TotalCharaPackageCount;
		LoadPackageAsync(PrimaryCharaData->PlayerClass->GetPathName(),
			FLoadPackageAsyncDelegate::CreateUObject(this,
				&ANightSkyVSInfoGameState::OnCharaPackageLoaded));
	}
	for (const auto PrimaryCharaData : GameInstance->BattleData.PlayerListP2)
	{
		if (PrimaryCharaData == nullptr) continue;
		++TotalCharaPackageCount;
		LoadPackageAsync(PrimaryCharaData->PlayerClass->GetPathName(),
			FLoadPackageAsyncDelegate::CreateUObject(this,
				&ANightSkyVSInfoGameState::OnCharaPackageLoaded));
	}
}

void ANightSkyVSInfoGameState::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	VSInfoTime += DeltaSeconds;
	if (VSInfoTime >= MaxVSInfoTime && MapLoaded && LoadedCharaPackageCount == TotalCharaPackageCount)
	{
		if (GameInstance->FighterRunner != Multiplayer || GameInstance->IsReplay)
			GameInstance->TravelToBattleMap();
		else
		{
			GameInstance->FinishedLoadingForNetworkBattle = true;
			if (GetWorld()->GetNetMode() == NM_Client)
			{
				const auto NetworkPawn = Cast<ANetworkPawn>(UGameplayStatics::GetPlayerController(GetWorld(), 0)->GetPawn());
				if (IsValid(NetworkPawn))
				{
					NetworkPawn->ServerGetFinishedLoading(true);
				}
			}
		}
	}
}

void ANightSkyVSInfoGameState::OnMapPackageLoaded(const FName& PackageName, UPackage* LoadedPackage,
	EAsyncLoadingResult::Type Result)
{
	MapLoaded = true;
	Packages.Add(LoadedPackage);
}

void ANightSkyVSInfoGameState::OnCharaPackageLoaded(const FName& PackageName, UPackage* LoadedPackage,
	EAsyncLoadingResult::Type Result)
{
	++LoadedCharaPackageCount;
	Packages.Add(LoadedPackage);
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/VSInfo/NightSkyVSInfoGameState.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameStateBase.h"
#include "NightSkyVSInfoGameState.generated.h"

class UNightSkyGameInstance;
/**
 * 
 */
UCLASS()
class NIGHTSKYENGINE_API ANightSkyVSInfoGameState : public AGameStateBase
{
	GENERATED_BODY()

	double VSInfoTime;
	bool MapLoaded;
	int32 LoadedCharaPackageCount;
	int32 TotalCharaPackageCount;

	UPROPERTY()
	TArray<TObjectPtr<UPackage>> Packages;
	UPROPERTY()
	TObjectPtr<UNightSkyGameInstance> GameInstance;

public:
	ANightSkyVSInfoGameState();
	
	UPROPERTY(EditAnywhere)
	double MaxVSInfoTime = 6;
	
	virtual void BeginPlay() override;
	virtual void Tick(float DeltaSeconds) override;
	
	void OnMapPackageLoaded(const FName& PackageName, UPackage* LoadedPackage, EAsyncLoadingResult::Type Result);
	void OnCharaPackageLoaded(const FName& PackageName, UPackage* LoadedPackage, EAsyncLoadingResult::Type Result);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTGameState.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyWTGameState.h"

#include "Camera/CameraActor.h"
#include "NightSkyEngine/Battle/Actors/ParticleManager.h"
#include "NightSkyEngine/Battle/FighterRunners/FighterLocalRunner.h"
#include "NightSkyEngine/Miscellaneous/NightSkyGameInstance.h"
#include "CineCameraActor.h"
#include "Camera/CameraComponent.h"
#include "LevelSequenceActor.h"
#include "NightSkyEngine/Data/BattleExtensionData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyWTGameState)

// Sets default values
ANightSkyWTGameState::ANightSkyWTGameState()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	BattleSceneTransform = FTransform();
	bIsBattling = false;
	bIsMatchEnd = false;
}

// Called when the game starts or when spawned
void ANightSkyWTGameState::BeginPlay()
{
	AActor::BeginPlay();

	FActorSpawnParameters SpawnParameters;
	ParticleManager = GetWorld()->SpawnActor<AParticleManager>();
	AudioManager = GetWorld()->SpawnActor<AAudioManager>();
	GameInstance = Cast<UNightSkyGameInstance>(GetGameInstance());
	CameraActor = GetWorld()->SpawnActor<ACameraActor>(ACameraActor::StaticClass());
	CameraActor->GetCameraComponent()->SetFieldOfView(54);
	SequenceCameraActor = GetWorld()->SpawnActor<ACineCameraActor>(ACineCameraActor::StaticClass());
	SequenceActor = GetWorld()->SpawnActor<ALevelSequenceActor>(ALevelSequenceActor::StaticClass());
}

void ANightSkyWTGameState::Init(APlayerObject* P1, APlayerObject* P2)
{
	bIsBattling = true;

	if (IsValid(BattleExtensionData))
	{
		for (auto Extension : BattleExtensionData->ExtensionArray)
		{
			BattleExtensions.Add(NewObject<UBattleExtension>(this, Extension));
			BattleExtensions.Last()->Parent = this;
			BattleExtensionNames.Add(BattleExtensions.Last()->Name);
		}
	}

	{
		Players.Add(P1);
		P1->SetActorTransform(BattleSceneTransform);
		P1->PlayerFlags |= PLF_IsOnScreen;
		SortedObjects.Add(P1);
		P1->InitPlayer();
		P1->GameState = this;
	}
	{
		Players.Add(P2);
		P2->SetActorTransform(BattleSceneTransform);
		P2->PlayerFlags |= PLF_IsOnScreen;
		SortedObjects.Add(P2);
		P2->InitPlayer();
		P2->GameState = this;
	}

	for (int i = 0; i < MaxBattleObjects; i++)
	{
		Objects.Add(GetWorld()->SpawnActor<ABattleObject>(ABattleObject::StaticClass(), BattleSceneTransform));
		Objects[i]->GameState = this;
		SortedObjects.Add(Objects.Last());
	}
	
	const FVector NewCameraLocation = BattleSceneTransform.GetRotation().RotateVector(FVector(0, 1080, 175)) + BattleSceneTransform.GetLocation();
	FRotator CameraRotation = BattleSceneTransform.GetRotation().Rotator();
	CameraRotation.Yaw -= 90;
	
	CameraActor->SetActorLocation(NewCameraLocation);
	CameraActor->SetActorRotation(CameraRotation);
	SequenceCameraActor->SetActorLocation(NewCameraLocation);

	MatchInit();
	HUDInit();
}

// Called every frame
void ANightSkyWTGameState::Tick(float DeltaTime)
{
	AActor::Tick(DeltaTime);
	
	if (bIsBattling && IsValid(FighterRunner))
		FighterRunner->Update(DeltaTime);

	if (bIsMatchEnd)
	{
		bIsBattling = false;
		bIsMatchEnd = false;
		Objects.Empty();
		Players.Empty();
		SortedObjects.Empty();
		OnBattleEndDelegate.Broadcast();
	}
}
```

`Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTGameState.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NightSkyEngine/Battle/NightSkyGameState.h"
#include "NightSkyWTGameState.generated.h"

UDELEGATE()
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnBattleEndDelegate);

UCLASS()
class NIGHTSKYENGINE_API ANightSkyWTGameState : public ANightSkyGameState
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ANightSkyWTGameState();

	UPROPERTY(BlueprintReadWrite)
	bool bIsMatchEnd;
	
	UPROPERTY(BlueprintReadOnly)
	bool bIsBattling;

	UPROPERTY()
	FOnBattleEndDelegate OnBattleEndDelegate;
	
protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	
public:
	void Init(APlayerObject* P1, APlayerObject* P2);
	
	// Called every frame
	virtual void Tick(float DeltaTime) override;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTPlayerController.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyWTPlayerController.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyWTPlayerController)

// Sets default values
ANightSkyWTPlayerController::ANightSkyWTPlayerController()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}

// Called when the game starts or when spawned
void ANightSkyWTPlayerController::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void ANightSkyWTPlayerController::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}


```

`Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTPlayerController.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "NightSkyEngine/Battle/NightSkyPlayerController.h"
#include "NightSkyWTPlayerController.generated.h"

UCLASS()
class NIGHTSKYENGINE_API ANightSkyWTPlayerController : public ANightSkyPlayerController
{
	GENERATED_BODY()

public:
	// Sets default values for this actor's properties
	ANightSkyWTPlayerController();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/WT/WTCharacter.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "WTCharacter.h"

#include "NightSkyWTGameState.h"
#include "NightSkyEngine/Battle/Objects/PlayerObject.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(WTCharacter)

// Sets default values
AWTCharacter::AWTCharacter()
{
	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}

// Called when the game starts or when spawned
void AWTCharacter::BeginPlay()
{
	Super::BeginPlay();

	GameState = Cast<ANightSkyWTGameState>(GetWorld()->GetGameState());
	if (GameState)
		GameState->OnBattleEndDelegate.AddUniqueDynamic(this, &AWTCharacter::EndBattle);

	BattlePlayer = GetWorld()->SpawnActor<APlayerObject>(BattlePlayerClass);
	BattlePlayer->SetActorHiddenInGame(true);

	if (!IsPlayerControlled())
	{
		BattlePlayer->SpawnDefaultController();
		BattlePlayer->bIsCpu = true;
	}
}

// Called every frame
void AWTCharacter::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

// Called to bind functionality to input
void AWTCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);
}

void AWTCharacter::StartBattle(AWTCharacter* Opponent)
{
	// Hide WT character and show battle player.
	SetActorHiddenInGame(true);
	BattlePlayer->SetActorHiddenInGame(false);
	Opponent->SetActorHiddenInGame(true);
	Opponent->BattlePlayer->SetActorHiddenInGame(false);

	GameState->Init(BattlePlayer, Opponent->BattlePlayer);
}

void AWTCharacter::EndBattle()
{
	SetActorHiddenInGame(false);
	BattlePlayer->SetActorHiddenInGame(true);
	EndBattle_BP();
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngine/WT/WTCharacter.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "WTCharacter.generated.h"

class ANightSkyWTGameState;
class APlayerObject;

UCLASS()
class NIGHTSKYENGINE_API AWTCharacter : public ACharacter
{
	GENERATED_BODY()

public:
	// Sets default values for this character's properties
	AWTCharacter();

	UPROPERTY(BlueprintReadOnly)
	ANightSkyWTGameState* GameState;
	
	UPROPERTY(EditAnywhere)
	TSubclassOf<APlayerObject> BattlePlayerClass;
	
	UPROPERTY(BlueprintReadOnly)
	APlayerObject* BattlePlayer;
	
protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	UFUNCTION(BlueprintCallable)
	void StartBattle(AWTCharacter* Opponent);

	UFUNCTION()
	void EndBattle();

	UFUNCTION(BlueprintImplementableEvent)
	void EndBattle_BP();
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngineEditor/NightSkyEngineEditor.Build.cs`:

```cs
using UnrealBuildTool;

public class NightSkyEngineEditor : ModuleRules
{
    public NightSkyEngineEditor(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;
        
        PrivateIncludePaths.AddRange(
            new string[] {
                "NightSkyEngineEditor/Public",
                "NightSkyEngine"
            }
        );

        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                "Core"
            }
        );

        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
                "CoreUObject",
                "Engine",
                "Slate",
                "SlateCore",
                "NightSkyEngine",
                "GameplayTags",
            }
        );
    }
}
```

`Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Private/NightSkyEditorBlueprintLibrary.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "NightSkyEditorBlueprintLibrary.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyEditorBlueprintLibrary)

FGameplayTag UNightSkyEditorBlueprintLibrary::GetGameplayTagFromName(FName Name)
{
	return FGameplayTag::RequestGameplayTag(Name);
}

```

`Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Private/NightSkyEngineEditor.cpp`:

```cpp
#include "NightSkyEngineEditor.h"

#define LOCTEXT_NAMESPACE "FNightSkyEngineEditorModule"

void FNightSkyEngineEditorModule::StartupModule()
{
    
}

void FNightSkyEngineEditorModule::ShutdownModule()
{
    
}

#undef LOCTEXT_NAMESPACE
    
IMPLEMENT_MODULE(FNightSkyEngineEditorModule, NightSkyEngineEditor)
```

`Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Public/NightSkyEditorBlueprintLibrary.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "NightSkyEditorBlueprintLibrary.generated.h"

/**
 * 
 */
UCLASS()
class NIGHTSKYENGINEEDITOR_API UNightSkyEditorBlueprintLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintCallable, Category = "Gameplay Tags")
	static FGameplayTag GetGameplayTagFromName(FName Name);
};

```

`Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Public/NightSkyEngineEditor.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FNightSkyEngineEditorModule : public IModuleInterface
{
public:
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
};

```

`README.md`:

```md
# NightSkyEngine

Night Sky Engine is a free and open source fighting game framework made in Unreal Engine 5. It is designed to be powerful yet easy to learn, and can be used to make 2D and 2.5D fighting games.

It requires Unreal Engine 5.7. 

This branch is intended to target higher-end machines, such as consoles and high-end PCs. If you're looking for lower fidelity visuals, please use the `lowend` branch.

Documentation link: https://wistfulhopes.github.io/NightSkyEngine/

Discord link: https://discord.gg/mJTU9PV7jH

The following additional plugins are used:

- GGPOUE4, originally by @BwdYeti, then forked by @erebuswolf, and finally modified for use in Night Sky Engine.

Collision editor co-developed by [@MostExcellent](https://github.com/MostExcellent).

All sound effects are from [this site](http://osabisi.sakura.ne.jp/m2/).

```

`Source/NightSkyEngine.Target.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class NightSkyEngineTarget : TargetRules
{
	public NightSkyEngineTarget( TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.Latest;
		IncludeOrderVersion = EngineIncludeOrderVersion.Latest;
		ExtraModuleNames.Add("NightSkyEngineDemo");
	}
}
```

`Source/NightSkyEngineDemo/NightSkyEngineDemo.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class NightSkyEngineDemo : ModuleRules
{
	public NightSkyEngineDemo(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new[]
		{
			"Core",
			"CoreUObject",
			"Engine",
			"InputCore",
			"NightSkyEngine",
		});

		DynamicallyLoadedModuleNames.Add("OnlineSubsystemSteam");

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
		
		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}

```

`Source/NightSkyEngineDemo/NightSkyEngineDemo.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "NightSkyEngineDemo.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, NightSkyEngineDemo, "NightSkyEngineDemo" );

```

`Source/NightSkyEngineDemo/NightSkyEngineDemo.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"


```

`Source/NightSkyEngineEditor.Target.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class NightSkyEngineEditorTarget : TargetRules
{
	public NightSkyEngineEditorTarget( TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.Latest;
		IncludeOrderVersion = EngineIncludeOrderVersion.Latest;
		ExtraModuleNames.Add("NightSkyEngineDemo");
	}
}
```

`docs/docs/basics/basics.md`:

```md
Basics
=========

Now that you have the bare-minimum rundown of Night Sky Engine, it's time to learn the basics in more detail.

- [Project Structure](structure.md): How your project's folders should be structured.
- [Collision Data and Cels: Tying Frame Data, Animations, and Hitboxes Together](collision-data.md): Details on the Collision Data asset, and how it relates to frame data, animations, and hitboxes.

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [State Data Asset](../getting-started/state-data.md) | [Project Structure](structure.md) |
```

`docs/docs/basics/collision-data.md`:

```md
Collision Data and Cels: Tying Frame Data, Animations, and Hitboxes Together
===================

In Night Sky Engine, the concept of a Cel is what ties a character's frame data, animations, and hitboxes together. As such, it's the most vital data for a character. I briefly touched upon it in [Getting Your Bearings](../getting-started/bearings.md) from the Quick Start Guide, but here, I'll explain in more detail how Cels work and how to make new Cels.

## Frame Data
A Cel can be thought of as a sort of "keyframe". They're named as such to invoke the idea of an animation cel. When combined with a State Blueprint, the Cel determines how long the character's current hitboxes and pose lasts for.

The reason such a system is used, and not something like a frame data timeline (such as using Unreal Engine's Anim Notifies), is that it makes adjusting the animation to match the frame data incredibly easy. For example, if you have a punch animatoin, and put a Cel at frame 0 (punch start) and another cel at frame 10 (punch fully extended), but then decide that the punch should actually have 4 frames of startup instead, you don't have to edit the animation, reimport it, modify the Cels, and the State. Instead, you can just set the *duration* of the `Set Cel and Blend Cel` node in your State blueprint to 4.![An example Set Cel and Blend Cel setup.](cel-example.png)

## Animation
This section assumes that you have an Anim Sequence in Unreal Engine for your character. If not, [here's a link to official documentation for animation importing.](https://dev.epicgames.com/documentation/en-us/unreal-engine/importing-animations-using-fbx-in-unreal-engine)

In the Collision Data asset of your character, each Cel has associated animation data.![Example Animation Data for a Cel.](anim-data-example.png)

This screenshot has quite a bit going on, so let's break it down:

- Anim: An array of animations for your Player Object. It's structured in an Array format to allow different animations on different Components.
    - Part Name: This is the name of the component that will be assigned the animation. For example, if you have a Skeletal Mesh Component named "Body", it will use the given animation.
    - Anim Sequence: For Skeletal Mesh Components, this is the animation that will be used for the given part.
    - Flipbook: For Paper Flipbook Components, this is the flipbook that will be used for the given part.
- Anim Frame: The frame of animation that will be used for this Cel. This depends on your animation's frame rate.
- Anim Blend In: For Skeletal Mesh Components, this controls the "blend in" time. This is used for when the animation asset is different from the currently playing asset.
- Anim Blend Out: For Skeletal Mesh Components, this controls the "blend out" time. This is used for when the animation asset of the next Cel is different from this Cel's.

## Hitboxes
Finally, every Cel can have an arbitrary number of boxes. The Collision Data editor comes with a built-in preview for the boxes, relative to the animating character.
![An example preview of hitboxes for a Cel.](collision-preview.png)

To set the character to preview collision for, use the dropdown below the `Cel Browser` and select the blueprint for your character.
![How to set the character to preview collision for.](bp-select-collision.png)

Every Collision Box comes with some properties. Here's what they all do:

- Type: There are five types of boxes.
    - Pushbox. This is currently unused, as push collision is handled elsewhere. However, this is planned to be an option as a separate push collision system.
    - Hurtbox.
    - Hitbox.
    - Offset. This can be used as a "root motion" system for sprites.
    - Custom. This box type can be used in conjunction with the `Custom Type` property for custom logic.
- Custom Type: For boxes with the Custom type, this specifies what kind of custom box it is. You can set any tag you want, but it should preferably use the naming convention `Collision.<Type>`.
- X Position: The box X axis position relative to the character's origin in Night Sky units, divided by 1000. The position is used as the box center.Updating this will update the `X Position (Unreal)` property, and vice versa.
- Y Position: The box Y axis position relative to the character's origin in Night Sky units, divided by 1000. The position is used as the box center. Updating this will update the `Y Position (Unreal)` property, and vice versa.
- X Size: The box width in Night Sky units, divided by 1000. Updating this will update the `X Size (Unreal)` property, and vice versa.
- Y Size: The box height in Night Sky units, divided by 1000. Updating this will update the `Y Size (Unreal)` property, and vice versa.
- X Position (Unreal): The box X axis position relative to the character's origin in centimeters. The position is used as the box center. Updating this will update the regular `X Position` property, and vice versa.
- Y Position (Unreal): The box Y axis position relative to the character's origin in centimeters. The position is used as the box center. Updating this will update the regular `Y Position` property, and vice versa.
- X Size: The box width in centimeters. Updating this will update the regular `X Size` property, and vice versa.
- Y Size: The box height in centimeters. Updating this will update the regular `Y Size` property, and vice versa.

![A look at all of the Box properties.](box.png)

| Previous          |
|:------------------|
| [Project Structure](structure.md) |
```

`docs/docs/basics/structure.md`:

```md
Project Structure
===================

Night Sky Engine's project structure may feel overwhelming at first glance. This page is designed to break down what each folder's intended use is.

# Root folder
The intended filesystem for projects is to leave core implementation details in `Content/NightSkyEngine`, and put game-specific files in `Content/<Project Name>`.

## Blueprints
As one would expect, this folder contains all of the Blueprints for the given folder. Additionally, gameplay-related data assets tend to reside in this folder. Note that Widget Blueprints should be stored elsewhere.

### Battle
Universal battle elements, such as `BP_NightSkyGameState` and `BP_NightSkyPlayerController`, reside in this folder.

### Characters
Character-related elements, such as states and pawns, reside in this folder. A subfolder should be created for each character.

### CharaSelect
Character select-related elements, such as `BP_NightSkyCharaSelectGameState`, reside in this folder.

### Menu
Universal menu elements, such as `BP_MenuPlayerController`, reside in this folder.

### Transition
Used for network seamless loading.

### VSInfo
Used for the versus screen during battle loading.

### WT
Used for WT mode-related elements. Depending on your project needs, this folder may be deleted.

## CharacterAssets
Visual and audio assets for characters reside in this folder. Make a new subfolder for each character.

### Chara/Animations
For 3D characters, the character's animations should reside in this folder.

### Chara/Audio
A character's audio should reside in this folder. There should be an SE folder for sound effects, and a Voice folder for voice lines.

### Chara/Flipbooks
For 2D characters, the character's flipbooks should reside in this folder.

### Chara/Materials
The character's materials, material instances, and textures should reside in this folder.

There should be a Base folder for common parts, and a ColorXX folder for each color, where XX is the color ID.

### Chara/Meshes
For 3D characters, the character's meshes should reside in this folder.

### Chara/Sprites
For 2D characters, the character's sprites should reside in this folder.

### Chara/Particles
The character's particle effects should reside in this folder.

### Chara/Textures
For 2D characters, the character's textures should reside in this folder.

## Maps
All levels should reside in this folder.

## Shared
Common assets, such as master materials, inputs, and others should reside in this folder.

## UI
All UI elements, such as widget blueprints, should reside in this folder.

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [Basics](basics.md) | [Collision Data and Cels: Tying Frame Data, Animations, and Hitboxes Together](collision-data.md) |
```

`docs/docs/getting-started/about.md`:

```md
About Night Sky Engine
===================

## What is Night Sky Engine written in?
Night Sky Engine uses high-level visual scripting powered by Unreal Engine's Blueprint system, giving those with less programming experience the ability to create their own characters. If this scripting isn't enough for your needs, the native C++ backend can be edited freely to extend functionality.

## What are some key features of Night Sky Engine?
Using the Blueprint system and exposed native functions, Night Sky Engine allows for very in-depth control of character states. States are quite robust, allowing the creator to control frame data, set animations, create timers, move objects, and more.

Night Sky Engine also allows for both 2D sprite-based characters using Paper2D and 3D skeletal characters. As an added bonus, there's support for both traditionally animated 3D characters and the Arc System Works style of animated 3D characters.

One of the most important features included is rollback netcode using GGPO. Stable netplay across the world is possible thanks to this.

## Should I download now, or wait for later?

After over 3 years of development, Night Sky Engine is finally ready for use! Feel free to download it right now and start making the fighting game of your dreams.

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [Home](../index.md) | [Licenses](licenses.md) |
```

`docs/docs/getting-started/bearings.md`:

```md
Getting Your Bearings
===================

Night Sky Engine is very powerful, but it may take some getting used to in order to unlock the full power of the framework. This page will explain some basic concepts of the framework. More detailed information will be brought up as the guide continues.

## Night Sky Game State
The Night Sky Game State is a class that extends Unreal's Game State Base. Everything related to battle code can be traced back to the code written in this class, such as all objects, the battle camera, and cinematics.

When using Blueprint scripting, you most likely won't touch the code of this class. However, you can set fields like the round format (such as first to one round), the round start position, screen and stage boundaries, and more.

## Battle and Player Objects
If the Night Sky Game State is the foundation of the battle scene, then a Battle Object is the main building block of the battle scene. Every actor that can influence the battle directly is either a Battle Object or inherits from a Battle Object. It stores all sorts of data, from position and speed to frame data and hit values. Regular Battle Objects tend to be used as projectiles or other non-player entities that should be updated.

On the other hand, Player Objects are a specialized version of Battle Objects intended for use with player characters. In other words, you directly control Player Objects. These contain even more data, such as health, meter, a state machine, and more.

## The State Machine
Player Objects have access to a primary state machines. This state machine contains states the Player Object has access to, and methods for changing state. You will most likely never need to modify the state machine itself, as the transition logic lies in the Player Object itself. The state machine's purpose is to keep track of the current state and contain all other states.

There's also an advanced, experimental feature for additional state machines. These states run in tandem with the primary state machine, and can be used to run background code independent of the main states. For more experimental games, this is useful for blending logic of multiple states together.

## States
In Night Sky Engine, a state is a Blueprint that contains logic for how a Battle Object should behave. They can informally be divided between object states and player states.

An object state is attached to a created Battle Object to set properties (such as an attached particle or values for hit) and frame data, or to run code. Object states are one-and-done; once the state is over, the Battle Object is removed.

A player state is attached to a Player Object's state machine for much the same reason as an object state. Unlike an object state, a player state will transition into another state upon ending, either via the Exit State macro (which will return the Player Object to a neutral state) or via the Jump to State function (which will forcibly enter a new state). Additionally, conditions can be set for entering the state, such as an input sequence or a variable.

## Cels
Frame data and anything else that should only update at a specific point of a state is handled by the Cel system. Cels are a two-part system: one part being the `Cel Gate`, and the other part being in the Player Object's Collision Data.

By using a `Cel Gate` macro in a state, you can create a "keyframe" of sorts for your state code. Code connected to the On Enter line will execute immediately upon a Cel's activation, and code connected to the On Update line will execute otherwise. The Duration parameter of the macro sets how long a Cel lasts. Once a Cel's duration elapses, the Next Cel line will activate, thereby creating a frame data system. All `Cel Gates` should be connected via the Next Cel line.

For the Collision Data part, Cels can be connected to animation frames and collision data via the Set Cel Name function. By setting the current Battle Object's Cel name to the corresponding entry in the Collision Data, the Battle Object's animation and collision data will be updated.

Under normal circumstances, there is no need to directly interact with a `Cel Gate`. Instead, it is recommended to use the `Set Cel` macro, or the `Set Cel and Blend Cel` macro for interpolated animations.

As an example, say we have a Set Cel macro for the first 8 frames of a player's standing state. The Cel Name is set to `Manny.Stand.00`. In the Collision Data, `Manny.Stand.00` is connected to the first frame of the standing animation and collision data. Upon entering the standing state, the player will immediately set its Cel name, then wait 8 frames. Upon its duration elapsing, the next Cel hooked up to Skip will activate, and so on.

When scripting in Blueprints, Cels will be the main way you interact with a state.

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [Installing Night Sky Engine](installing.md) | [What Is A State? Part 1](state-p1.md) |
```

`docs/docs/getting-started/create-state.md`:

```md
Your First State
===================

Let's put what you've learned into practice, and create a new state.

First, navigate to your character's folder in the Content Drawer. An example path would be `Content/NightSkyEngine/Blueprints/Characters/Manny/States`. Right-click in an empty spot of the Content Drawer, and create a new Blueprint. 

Generally, you do not want to inherit directly from the State class. Instead, I have prepared a plethora of state templates in `Content/NightSkyEngine/Blueprints/Characters/Common/States`. In this example, we'll create a normal attack, so let's inherit from `ST_CommonNormalAttack`.

The standard naming convention for states is `ST_{Character}{StateName}`. We'll be creating a new standing light, so let's go with `ST_MannyNmlAtk5A`. If you don't understand the state name, [there is a page on Infil's Fighting Game Glossary about numpad notation.](https://glossary.infil.net/?t=Numpad%20Notation#:~:text=A%20way%20to%20describe%20joystick,d%20call%20it%20%222MK%22.)

First, you should define default values for your State. On the rightmost panel, you will see the Details tab. For now, here's the basics you need to understand about the State defaults:

- The name of your State is used to directly reference the State (for example, in Cancels or Jump to States).
- The Entry Stance determines what character stance (standing, crouching, jumping) the state may be entered from. If it is set to None, any state will work.
- Input Condition Lists handles input conditions. If one Condition List's requirements is met, the state may be entered. 

Start by setting the State name to a fitting Gameplay Tag (such as `State.Attack.Normal.5A`), and the entry stance to Standing. For the Input Condition Lists, add one entry, then open the dropdowns. You will notice a new array, called Input Conditions. These are the actual conditions that the list contains. All of these conditions must be met in order for the list to be considered successful.

For now, add a new entry into the Condition's Sequence, and set the Input Flag to A (for light). Then, set the Method of the condition to Once. This means that it will only register the input on first press.

Now that the default values have been set up, you should move on to the actual code. However, you'll notice that your new State currently has no code. Let's add some!

On the leftmost panel, there should be a section labeled Functions. If you hover over it, you'll see a dropdown called "Override". First, override the Init function. It will create an Init function, which calls the parent function from `ST_CommonNormalAttack`.

Under Init, you will handle all state values that need to be set when netering the state. In this case, we'll be setting the attack data, such as strength and damage. 

To interact with the State's owning object, you will need to Get the Parent. Right-click on an empty spot in the Function Graph, and type "Get Parent". Find the bottommost entry and click it. This will create a node in the Function Graph which gives you access to the owning object.

In this case, we want to call a Subroutine that initializes the default attack values. Drag on the blue circle at the rightmost edge of the Parent node, release the mouse, and type "Call Subroutine". Click on the entry, and a new node will appear. This node will call a Subroutine that is stored within the Common Subroutine Data. Under Name, find the gameplay tag for `Subroutine.Cmn.AttackLevel.1`, which will set default attack values. Then, connect the leftmost white arrow to the "Parent: Init" node's rightmost white arrow.

Now, we'll go back to the "Override" menu, and override the Exec function. This will create a new Event in the Event Graph. You may notice the lack of a "Parent: Exec" node in this override. Unless you are sure that you do not want the parent State's default functionality, it is best to create this node yourself. Right-click on the "Event Exec" node, and click "Add Call to Parent Function". Then, wire in the "Parent: Exec" node to "Event Exec".

There are a lot of nodes that should be plugged into Exec, so I won't explain everything step-by-step. Instead, replicate the following image's node setup: ![The node setup.](state-example.png)

I will explain what each macro or function call does, however:

- Set Cel and Blend Cel sets the Cel and Blend Cel names. The Cel system was previously explained, but Blend Cels are used to have animation interpolation between two frames. In other words, rather than just jumping from pose to pose, the character will smoothly transition based on your animation.
- Enable Hit must be called when you wish to hit the opponent, and Enabled must be set to True to allow hitting the opponent.
- Set Attacking changes the attacking state of the object. When attacking, the object is allowed to hit or Chain Cancel, but may be counter hit in return. Meanwhile, when not attacking, the object may not hit the opponent or Chain Cancel, but is no longer vulnerable to counter hits.
- Exit State will exit the current state and enter the default state for the current stance (standing, crouching, or jumping).

Congrats, you have created your first State! Now, to see it in action, open the character's State Data. In this case, it is located at `Content/NightSkyEngine/Blueprints/Characters/Manny/DA_MannyStates`. Open the asset, and add a new entry to the State Array. Set the value to `ST_MannyNmlAtk5A`. Now, you can open Play in Editor and test out your new state.

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [What Is A State? Part 2](state-p1.md) | [State Data Asset](state-data.md) |
```

`docs/docs/getting-started/installing.md`:

```md
Installing Night Sky Engine
===================

There are two methods to installing Night Sky Engine: downloading the official release, or building from development source. For those who don't need to touch C++ code, or just want a quick and easy setup, I recommend grabbing the official release. However, if you want to mess around with the engine, or just want the latest changes, you will need to build from source.

!!! warning

    The official release only has support for Windows on x64. While other platforms do work, they are not bunudled with the official release. You will need to build from source for Mac, Linux, or Windows on ARM.

# Download Official Release
Starting from version 1.0.1, there are multiple versions of the official release that can be installed: the full project, the low-end project, and the plugin.

- The full project comes with a ton of example assets to get started with. It is designed for high-end machines, such as more powerful PCs or console.
- The low-end project comes with the same assets, but is much lighter on the graphics end. It is designed for low-end machines, such as mobile.
- The plugin is all of the code required to use Night Sky Engine, but without any of the assets.

## Full Project
To download the latest full project release, simply download `NightSkyEngine.rar` from [this link.](https://github.com/WistfulHopes/NightSkyEngine/releases/latest). Then, extract `NightSkyEngine.rar` using your tool of choice.

Then, you will need to install Unreal Engine 5.7. Details can be found [here](https://www.unrealengine.com/en-US/download). After installing Unreal Engine, you may run it, then open `NightSkyEngine/NightSkyEngine.uproject` from within the editor.

## Low-End Project
To download the latest low-end project release, simply download `NSELowEnd.rar` from [this link.](https://github.com/WistfulHopes/NightSkyEngine/releases/latest). Then, extract `NSELowEnd.rar` using your tool of choice.

Then, you will need to install Unreal Engine 5.7. Details can be found [here](https://www.unrealengine.com/en-US/download). After installing Unreal Engine, you may run it, then open `NightSkyEngine/NightSkyEngine.uproject` from within the editor.

## Plugin
To download the latest plugin release, simply download `NSEPlugin.rar` from [this link.](https://github.com/WistfulHopes/NightSkyEngine/releases/latest). Then, extract `NSEPlugin.rar` using your tool of choice.

Then, you will need to install Unreal Engine 5.7. Details can be found [here](https://www.unrealengine.com/en-US/download). After installing Unreal Engine, you may run it, then create a new project. Finally, put the contents of `NSEPlugin.rar` in `<Project Folder>\Plugins`, so that the `NightSkyEngine` folder sits within the `Plugins` folder.

# Build From Source
Building from source takes more steps than just downloading the release. You'll need to know how to use Git and Visual Studio (or your IDE of choice).

## Clone the Engine
To get Night Sky Engine, use a Git client (such as the [official client](https://git-scm.com/) or [Github Desktop](https://desktop.github.com/)) and clone the Night Sky Engine repository at https://github.com/WistfulHopes/NightSkyEngine.git. If using the command line, type in the following:

```git clone https://github.com/WistfulHopes/NightSkyEngine.git```

## Compile the engine
To compile the Night Sky Engine, you will need Unreal Engine 5.7 and Visual Studio. The version of Visual Studio must be 2022. For detailed instructions on installing Visual Studio for use with Unreal Engine, [click here](https://docs.unrealengine.com/5.7/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine/).

After Visual Studio is set up, you will need to generate Visual Studio project files for Night Sky Engine. To do so, right-click on NightSkyEngine.uproject, and click on "Generate Visual Studio project files".

There will be a new file in the folder, `NightSkyEngine.sln`. Open it, and once Visual Studio has loaded, press Ctrl+Shift+B to compile the engine.

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [Quick Start](quick-start.md) | [Getting Your Bearings](bearings.md) |
```

`docs/docs/getting-started/licenses.md`:

```md
Licenses
===================

Listed below are the libraries used in Night Sky Engine.

## GGPOUE

Night Sky Engine uses a fork of GGPOUE, a version of GGPO, for networking.

You can find the original [here](https://github.com/BwdYeti/GGPOUE).

```
The MIT License

Copyright (c) 2009-2019 GroundStorm Studios, LLC. (http://ggpo.net)
Copyright (c) 2020 BwdYeti

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
```

## THE MATCH-MAKERS Sound Effects Pack (Osabisi)

A sound effect library made by Osabisi.

You can find the originals [here](https://osabisi.sakura.ne.jp/m2/material3.html).

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [About](about.md) | [Quick Start](quick-start.md) |
```

`docs/docs/getting-started/quick-start.md`:

```md
Quick Start
=========

Don't know where to start with Night Sky Engine? Take a look at the below guides:

- [Installing Night Sky Engine](installing.md): A written tutorial on how to download and install Night Sky Engine.
- [Getting Your Bearings](bearings.md): After installing the framework, check this out to understand the basics.
- [What Is A State? Part 1](state-p1.md): Take a look here to learn more about a State in-depth.
- [What Is A State? Part 2](state-p2.md): Continuing from the last part, this part will cover how State logic is defined.
- [Your First State](create-state.md): It's time to learn how to make your first State.

This section is in progress. More pages will be added.

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [About](about.md) | [Installing Night Sky Engine](installing.md) |
```

`docs/docs/getting-started/state-data.md`:

```md
State Data Asset
===================

Even though you just learned how to make a state, you didn't learn much about what goes into making one. The following few pages will go a little bit more into what you're doing, and how to make something that's truly your own. First, we'll start with the `State Data Asset`.

## Organization
As you have just learned, states are individual Blueprint assets, meaning they're self-contained and don't directly link to your character. This is where the `State Data Asset` comes in: It contains a collection of states.

Every character uses three `State Data Assets`: `Common Object State Data`, `Object State Data`, and `Chara State Data`. `Chara State Data` is used to hold your character's states. In other words, any action performed by the character itself - such as standing, walking, or attacking - should be held here. Meanwhile, Object State Data is used to contain states that will be applied to Battle Objects. For example, projectiles, visual effects that you want to spawn and get a reference to later, or anything else that needs to be in the game world but *isn't* your character belongs here.

The difference between `Common Object State Data` and `Object State Data` is that `Common` refers to something that all characters in the game need, whereas regular `Object State Data` is character-specific. You are allowed to set a different `State Data Asset` with its own states to `Common Object State Data` if, for whatever reason, you wish to override the behavior of a common state.

## Priority
For `Chara State Data`, there's more than just containing states the character can use. It's also a hierarchy of priorities. As an example, if you had a punch and a fireball that both require pressing the button A, but the fireball also has a quarter circle, how would you guarantee that the fireball is what happens *instead* of the punch? With the `Chara State Data`, if the punch comes **before** the fireball in the list, the fireball is considered higher priority. **Remember this: the closer to the bottom of the list, the higher priority the state.**

There are even more advanced ways to manipulate the `State Data Asset`, but those are for another day. For the basics, this is all you need to know on this topic.

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [Your First State](create-state.md) | [Basics](../basics/basics.md) |
```

`docs/docs/getting-started/state-p1.md`:

```md
What Is A State? Part 1
===================

In Night Sky Engine, all characters have their logic built using States and Subroutines. For now, we'll focus on States.

If you're familiar with a finite state machine, the concept here is similar. A character's state machine can be in one state at a time, and there are rules for transitioning between states. However, unlike a traditional finite state machine, the Night Sky State Machine allows for more broad categorization of states, in addition to fine-tuned control over transitions.

States have two types of main conditions: Input and State Conditions. Input Conditions are based on the controller input: in other words, anything from holding a direction to doing a quarter circle forward and a button together, and even more. Meanwhile, a State Condition is a pre-determined condition for entering the state. Several examples of State Conditions are having enough meter, a Player Register being true or false, and so on.

Every state can be grouped into a "State Type", such as Standing, Jumping, Normal Attack, etc. You can broadly toggle on and off transitioning into other states. For example, by toggling on the Jumping State Type, any Jumping States can be entered when its Input and State Conditions are met. Additionally, custom State Types may be created in Blueprints.

Finally, if you need even more control over entering a state, you can override the `Can Enter State` function of a state to set custom conditions.

If you need a more specific way to transition between different states, there are two ways to handle this: Cancels and Jump to State.

A Cancel is a way to "cancel" the current state's execution and move to another state, but only when the other state's Input and State Conditions are met. There are several types of cancels, such as Jump Cancels, Special Cancels, Chain Cancels, and Whiff Cancels. For the most control, Chain and Whiff Cancels can be used.

A Chain Cancel allows transitioning to another state upon the opponent receiving or blocking an attack. Chain Cancels are on by default on all normal attacks. Meanwhile, a Whiff Cancel allows transitioning to another state at any time. However, Whiff Cancels must be enabled on a per-state basis. The state to transition to is specified by name.

Finally, a Jump to State allows bypassing all Input and State Conditions to enter another state. This is useful when a state has an automatic followup, such as landing recovery or a cinematic that only activates on hit.

The Exit State macro is a simplification of Jump to State used to return to a neutral state immediately. This is used when a state's logic has ended (like when an attack's recovery is over).

| Previous          |                              Next |
|:------------------|----------------------------------:|
| [Getting Your Bearings](bearings.md) | [What Is A State? Part 2](state-p2.md) |
```

`docs/docs/getting-started/state-p2.md`:

```md
What Is A State? Part 2
===================

Now that you broadly know what a state is, I'll cover how state logic is defined.

States are defined in Unreal Engine's Blueprint system. If you haven't worked with Blueprints before, take a look at the official Unreal Engine documentation. All states must inherit from the C++ class called `State` at some point in its chain. This means that you cannot make a Blueprint that inherits from another UObject, or an Actor, and use it as a state.

There are two native-declared functions in States: Init and Exec. Init is called upon entering a state, and handles setup. For example, in a character's Stand State, you'd set Speed to zero, enable all State Types, and enable character flipping sides. Meanwhile, Exec is called every frame the game updates, and handles the majority of state logic. For example, you would want to put Cels only in Exec, meaning frame data is locked into the Exec function.

Another important system in States is the Event Handler system. There are several types of Events, such as Update, Exit, Landing, etc. Each Event has its own triggers, such as every frame for Update, exiting the state for Exit, touching the ground for Landing, etc. Event Handlers trigger a Blueprint Function by name when the corresponding Event fires.

Event Handlers must be initialized before they can be used. Once initialized, they will remain until the State is exited, or if removed by type. Only one Event Handler of a type may be active at once; if another Event Handler of the same type is initialized, it will overwrite the old one.

!!! warning

    If an Event Handler attempts to call a Blueprint Function that doesn't exist in the current State, nothing will happen! Make sure not to misspell the function name.

For large States, reading an Event Graph can become unwieldy. As a result, there are two main ways to clean up your Blueprint Code: Functions and Macros. I recommend using Macros to group Cels, and Functions to group non-Cel code that needs to be used often.

In the next part, I'll cover creating your first state.


| Previous          |                              Next |
|:------------------|----------------------------------:|
| [What Is A State? Part 1](state-p2.md) | [Your First State](create-state.md) |
```

`docs/docs/index.md`:

```md
Home
===================

Welcome to the official documentation for [Night Sky Engine](https://github.com/WistfulHopes/NightSkyEngine). Night Sky Engine is a free and open source fighting game framework made in Unreal Engine 5. It is designed to be powerful yet easy to learn, and can be used to make 2D and 2.5D fighting games.

- Want to learn more about what Night Sky Engine is? [Check out the About page](getting-started/about.md).
- Interested in getting started with Night Sky Engine? [Head to the Quick Start Guide to get started](getting-started/quick-start.md).

If you have any questions, or need help, [join the Discord server](https://discord.gg/mJTU9PV7jH).

| Next |
|----------------------------------:|
| [About](getting-started/about.md) |
```

`docs/mkdocs.yml`:

```yml
site_name: Night Sky Engine
site_url: https://wistfulhopes.github.io/NightSkyEngine/
theme:
  name: material
  font:
    text: Merriweather Sans
    code: Red Hat Mono
  palette:
    # Dark Mode
    - scheme: slate
      toggle:
        icon: material/weather-sunny
        name: Dark mode
      primary: indigo
      accent: deep purple

    # Light Mode
    - scheme: default
      toggle:
        icon: material/weather-night
        name: Light mode
      primary: blue
      accent: deep orange
plugins:
  - search
  - awesome-nav
  - mkdoxy:
      projects:
        NightSkyEngine: # name of project must be alphanumeric + numbers (without spaces)
          src-dirs: ../Plugins/NightSkyEngine/Source/NightSkyEngine # path to source code (support multiple paths separated by space) => INPUT
          full-doc: True # if you want to generate full documentation
          doxy-cfg: # standard doxygen configuration (key: value)
            FILE_PATTERNS: "*.cpp *.h*" # specify file patterns to filter out
            RECURSIVE: True # recursive search in source directories
        NightSkyEngineEditor: # name of project must be alphanumeric + numbers (without spaces)
          src-dirs: ../Plugins/NightSkyEngine/Source/NightSkyEngineEditor # path to source code (support multiple paths separated by space) => INPUT
          full-doc: True # if you want to generate full documentation
          doxy-cfg: # standard doxygen configuration (key: value)
            FILE_PATTERNS: "*.cpp *.h*" # specify file patterns to filter out
            RECURSIVE: True # recursive search in source directories
        CollisionEditor: # name of project must be alphanumeric + numbers (without spaces)
          src-dirs: ../Plugins/NightSkyEngine/Source/CollisionEditor # path to source code (support multiple paths separated by space) => INPUT
          full-doc: True # if you want to generate full documentation
          doxy-cfg: # standard doxygen configuration (key: value)
            FILE_PATTERNS: "*.cpp *.h*" # specify file patterns to filter out
            RECURSIVE: True # recursive search in source directories
        GGPOUE4: # name of project must be alphanumeric + numbers (without spaces)
          src-dirs: ../Plugins/NightSkyEngine/Source/GGPOUE4 # path to source code (support multiple paths separated by space) => INPUT
          full-doc: True # if you want to generate full documentation
          doxy-cfg: # standard doxygen configuration (key: value)
            FILE_PATTERNS: "*.cpp *.h*" # specify file patterns to filter out
            RECURSIVE: True # recursive search in source directories
markdown_extensions:
  - admonition
  - pymdownx.details
  - pymdownx.superfences

```