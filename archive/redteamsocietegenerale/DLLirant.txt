Project Path: arc_redteamsocietegenerale_DLLirant_557w8wom

Source Tree:

```txt
arc_redteamsocietegenerale_DLLirant_557w8wom
├── App.config
├── App.xaml
├── App.xaml.cs
├── Classes
│   ├── CodeGenerator.cs
│   ├── DLLHijackingsHelper.cs
│   ├── ExecuteCommandHelper.cs
│   ├── FileOperations.cs
│   ├── KernelEventsParser.cs
│   └── PEAnalyzer.cs
├── DLLirant.csproj
├── DLLirant.sln
├── FodyWeavers.xml
├── LICENSE
├── MainWindow.xaml
├── MainWindow.xaml.cs
├── Properties
│   ├── AssemblyInfo.cs
│   ├── Resources.Designer.cs
│   ├── Resources.resx
│   ├── Settings.Designer.cs
│   └── Settings.settings
├── README.md
├── ViewModel
│   └── DataContextViewModel.cs
├── app.manifest
├── background.png
├── dllirant.ico
├── live.gif
├── packages.config
├── screenshot.png
├── screenshot2.png
├── screenshot3.png
└── screenshot4.png

```

`App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.2" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="ControlzEx" publicKeyToken="69f1c32f803d307e" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.1" newVersion="4.1.1.1" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Diagnostics.Tracing" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.0" newVersion="4.1.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Reflection" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.0" newVersion="4.1.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.InteropServices" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.0.0" newVersion="4.1.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.1.0" newVersion="4.0.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Net.Http" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.1.3" newVersion="4.1.1.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.IO.Compression" publicKeyToken="b77a5c561934e089" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.2.0" newVersion="4.1.2.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Security.Cryptography.Pkcs" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="PeNet.Asn1" publicKeyToken="1e2e3568f0050bf5" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-2.0.1.0" newVersion="2.0.1.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>
```

`App.xaml`:

```xaml
<Application x:Class="DLLirant.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:DLLirant"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <!-- MahApps.Metro resource dictionaries. Make sure that all file names are Case Sensitive! -->
                <ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml" />
                <ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml" />
                <!-- Theme setting -->
                <ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Themes/Dark.Green.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>

```

`App.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

namespace DLLirant
{
    /// <summary>
    /// Logique d'interaction pour App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}

```

`Classes/CodeGenerator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Management;

namespace DLLirant.Classes
{
    internal class CodeGenerator
    {
        public enum TypeDLLHijacking
        {
            DLLSearchOrderHijacking,
            OrdinalBased
        }

        public static string GenerateDLL(string dllmain, List<string> functions = null, TypeDLLHijacking typeDLLHijacking = TypeDLLHijacking.DLLSearchOrderHijacking)
        {
            string CppCode = string.Empty;
            switch (typeDLLHijacking)
            {
                case TypeDLLHijacking.DLLSearchOrderHijacking:
                    CppCode =
                        "#include <windows.h>\r\n" +
                        "#include <stdio.h>\r\n\r\n" +

                        "#pragma comment (lib, \"User32.lib\")\r\n\r\n" +
                        "int Main() {\r\n" +
                            "\tFILE* fptr;\r\n" +
                            "\tfopen_s(&fptr, \"C:\\\\DLLirant\\\\output.txt\", \"w\");\r\n" +
                            "\tfprintf(fptr, \"%s\", \"It works !\");\r\n" +
                            "\tfclose(fptr);\r\n" +
                            "\treturn 1;\r\n" +
                        "}\r\n\r\n" +
                        "BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)\r\n" +
                        "{\r\n" +
                            "\tswitch (ul_reason_for_call) {\r\n" +
                                "\t\tcase DLL_PROCESS_ATTACH:\r\n" +
                                    "\t\t\t" + dllmain + "\r\n" +
                                    "\t\t\tbreak;\r\n" +
                                "\t\tcase DLL_THREAD_ATTACH:\r\n" +
                                "\t\tcase DLL_THREAD_DETACH:\r\n" +
                                "\t\tcase DLL_PROCESS_DETACH:\r\n" +
                                    "\t\t\tbreak;\r\n" +
                            "\t}\r\n" +
                            "\treturn TRUE;\r\n" +
                            "}\r\n\r\n";
                    break;
                case TypeDLLHijacking.OrdinalBased:
                    CppCode =
                       "#include <windows.h>\r\n" +
                       "#include <string>\r\n" +

                       "#pragma comment (lib, \"User32.lib\")\r\n\r\n" +
                       "int Main(int nb) {\r\n" +
                           "\tstd::wstring message = std::to_wstring(nb);\r\n" +
                           "\tMessageBoxW(0, message.data(), L\"DLL Hijack\", 0);\r\n" +
                       "\treturn 1;\r\n" +
                       "}\r\n\r\n" +
                       "BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)\r\n" +
                       "{\r\n" +
                           "\tswitch (ul_reason_for_call) {\r\n" +
                               "\t\tcase DLL_PROCESS_ATTACH:\r\n" +
                                   "\t\t\t" + dllmain + "\r\n" +
                                   "\t\t\tbreak;\r\n" +
                               "\t\tcase DLL_THREAD_ATTACH:\r\n" +
                               "\t\tcase DLL_THREAD_DETACH:\r\n" +
                               "\t\tcase DLL_PROCESS_DETACH:\r\n" +
                                   "\t\t\tbreak;\r\n" +
                           "\t}\r\n" +
                           "\treturn TRUE;\r\n" +
                           "}\r\n\r\n";
                    break;
                default:
                    break;
            }

            if (functions != null) { CppCode += string.Join("\n", functions.ToArray()); };

            using (StreamWriter writer = new StreamWriter("output/dllmain.cpp"))
            {
                writer.WriteLine(CppCode);
            }

            return CppCode;
        }
    }
}

```

`Classes/DLLHijackingsHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection.Emit;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace DLLirant.Classes
{
    internal class DLLHijackingsHelper
    {
        public ExecuteCommandHelper ExecuteCommandHelper = new ExecuteCommandHelper();

        private SynchronizationContext uiContext;
        private DataContextViewModel data;
        private PEAnalyzer peAnalyzer;

        public async Task FindSearchOrderHijackings(SynchronizationContext uiContext, DataContextViewModel data, PEAnalyzer peAnalyzer)
        {
            this.uiContext = uiContext;
            this.data = data;
            this.peAnalyzer = peAnalyzer;

            // Get Modules.
            List<string> modules = peAnalyzer.GetModules(data.ExcludesDLLs.ToList());
            foreach (string module in modules)
            {
                if (!ExecuteCommandHelper.IsStarted) break;

                // Display PE informations, create directories and import files from the import/ directory to the output/ dir.
                DisplayPEFileInformations();
                FileOperations.RecreateDirectories(new List<string> { "output/", "C:\\DLLirant\\" });
                FileOperations.CopyFilesDirToDir("import/", "output/", new List<string> { module });

                await Task.Run(() =>
                {
                    // Testing DllMain().
                    TestingDllMain(module);

                    // Testing imported functions one by one.
                    TestingImportedFunctions(module);
                });
            }

        }

        private void DisplayPEFileInformations()
        {
            uiContext.Send(x => data.LogsGrid1.Clear(), null);
            uiContext.Send(x => data.LogsGrid1.Add($"Process Name: {Path.GetFileName(peAnalyzer.SelectedBinaryPath)}"), null);
            foreach (string info in peAnalyzer.GetPEInformations())
            {
                uiContext.Send(x => data.LogsGrid1.Add(info), null);
            }
            uiContext.Send(x => data.LogsGrid1.Add("==========================================================="), null);
        }

        private void TestingDllMain(string module)
        {
            uiContext.Send(x => data.LogsGrid1.Add("Testing DllMain..."), null);

            string cppCode = CodeGenerator.GenerateDLL("CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Main, NULL, NULL, NULL);");
            
            ExecuteCommandHelper.ExecuteCommand("cmd.exe", "/C clang++.exe dllmain.cpp -o DLLirantDLL.dll -shared");

            FileOperations.CopyFileToDir(peAnalyzer.SelectedBinaryPath, "output/");
            FileOperations.RenameFile("output/DLLirantDLL.dll", $"output/{module}");

            ExecuteCommandHelper.ExecuteCommand(Path.GetFileName(peAnalyzer.SelectedBinaryPath));

            SaveDllHijackingIfFound(module, cppCode);
        }

        private void TestingImportedFunctions(string module)
        {
            List<string> importedFunctions = peAnalyzer.GetImportedFunctions(module);
            List<string> functionsToTest = new List<string>();
            foreach (string importedFunc in importedFunctions)
            {
                if (!ExecuteCommandHelper.IsStarted) break;

                // Display PE informations, create directories and import files from the import/ directory to the output/ dir.
                DisplayPEFileInformations();
                FileOperations.RecreateDirectories(new List<string> { "output/", "C:\\DLLirant\\" });
                FileOperations.CopyFilesDirToDir("import/", "output/", new List<string> { module });

                uiContext.Send(x => data.LogsGrid1.Add($"Testing {module}..."), null);
                functionsToTest.Add($"extern \"C\" __declspec(dllexport) void {importedFunc}() {{ Main(); }}");
                foreach (string function in functionsToTest)
                {
                    uiContext.Send(x => data.LogsGrid1.Add(function), null);
                }
                uiContext.Send(x => data.LogsGrid1.Add("=========================="), null);

                string cppCode = CodeGenerator.GenerateDLL(string.Empty, functionsToTest);

                ExecuteCommandHelper.ExecuteCommand("cmd.exe", "/C clang++.exe dllmain.cpp -o DLLirantDLL.dll -shared");

                FileOperations.CopyFileToDir(peAnalyzer.SelectedBinaryPath, "output/");
                FileOperations.RenameFile("output/DLLirantDLL.dll", $"output/{module}");

                ExecuteCommandHelper.ExecuteCommand(Path.GetFileName(peAnalyzer.SelectedBinaryPath));

                SaveDllHijackingIfFound(module, cppCode);
            }
        }

        private void SaveDllHijackingIfFound(string moduleName, string cppCode)
        {
            if (!File.Exists("C:\\DLLirant\\output.txt"))
                return;
            
            uiContext.Send(x => data.LogsGrid1.Add($"[+] DLL Search Order Hijacking found in the binary {Path.GetFileName(peAnalyzer.SelectedBinaryPath)} with the DLL {moduleName} !"), null);
            FileOperations.CreateDirectory("dll-hijacks");
            string fileName = $"{Path.GetFileName(peAnalyzer.SelectedBinaryPath)}-{moduleName}.cpp";
            using (StreamWriter sw = File.CreateText($"dll-hijacks\\{fileName}"))
            {
                sw.WriteLine($"// MD5 Binary: {peAnalyzer.GetMD5()}");
                sw.WriteLine($"// SHA1 Binary: {peAnalyzer.GetSHA1()}");
                sw.WriteLine($"// SHA256 Binary: {peAnalyzer.GetSHA256()}");
                sw.WriteLine(cppCode);
            }
            Thread.Sleep(2000);
        }
    }
}

```

`Classes/ExecuteCommandHelper.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Management;

namespace DLLirant.Classes
{
    internal class ExecuteCommandHelper
    {
        public Process process = new Process();

        public bool IsStarted = false;

        public void ExecuteCommand(string path, string arguments = null, int maxRetries = 3)
        {
            ProcessStartInfo startInfo = new ProcessStartInfo
            {
                WindowStyle = ProcessWindowStyle.Hidden,
                FileName = path,
                WorkingDirectory = $"{Directory.GetCurrentDirectory()}\\output"
            };

            if (arguments != null)
                startInfo.Arguments = arguments;

            process.StartInfo = startInfo;
            process.Start();
            try
            {
                while (!process.HasExited && IsStarted)
                {
                    process.WaitForExit(3000);
                    maxRetries--;
                    if (maxRetries <= 0)
                    {
                        KillProcessAndChildrens(process.Id);
                    }
                }
            }
            catch (InvalidOperationException)
            {
                process = new Process();
            }
        }

        public void Stop()
        {
            IsStarted = false;
        }

        public void KillProcessAndChildrens(int pid)
        {
            ManagementObjectSearcher processSearcher = new ManagementObjectSearcher
              ("Select * From Win32_Process Where ParentProcessID=" + pid);
            ManagementObjectCollection processCollection = processSearcher.Get();

            // We must kill child processes first!
            if (processCollection != null)
                foreach (ManagementObject mo in processCollection)
                {
                    KillProcessAndChildrens(Convert.ToInt32(mo["ProcessID"]));
                }

            // Then kill parents.
            try
            {
                Process proc = Process.GetProcessById(pid);
                if (!proc.HasExited) proc.Kill();
            }
            catch (System.ComponentModel.Win32Exception)
            {
                // Access Denied.
            }
            catch (ArgumentException)
            {
                // Process already exited.
            }
            catch (InvalidOperationException)
            {
                process = new Process();
            }
        }
    }
}

```

`Classes/FileOperations.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;

namespace DLLirant.Classes
{
    internal class FileOperations
    {
        public static void CreateDirectory(string path)
        {
            if (!Directory.Exists(path))
                Directory.CreateDirectory(path);
        }

        public static void DeleteDirectory(string path)
        {
            if (Directory.Exists(path))
                try
                {
                    Directory.Delete(path, true);
                }
                catch (UnauthorizedAccessException) { }
                catch (IOException)
                {
                    // The output directory is used by another process in specific cases, so we just ignore it
                }
        }

        public static void CopyFileToDir(string file, string outputDir)
        {
            if (!File.Exists($"{outputDir}/{Path.GetFileName(file)}"))
                File.Copy(file, $"{outputDir}/{Path.GetFileName(file)}");
        }

        public static void RenameFile(string path, string newpath)
        {
            if (File.Exists(path) && !File.Exists(newpath))
                File.Move(path, newpath);
        }

        public static void CopyFilesDirToDir(string sourceDir, string targetDir, List<string> ignoreList = null)
        {
            if (Directory.Exists(sourceDir))
            {
                foreach (string ignoreFile in ignoreList)
                {
                    foreach (string file in Directory.GetFiles(sourceDir))
                    {
                        if (Path.GetFileName(file) != ignoreFile)
                        {
                            File.Copy(file, Path.Combine(targetDir, Path.GetFileName(file)));
                        }
                    }
                }
            }
        }

        public static void RecreateDirectories(List<string> directories)
        {
            foreach (string dir in directories)
            {
                DeleteDirectory(dir);
                CreateDirectory(dir);
            }
        }
    }
}

```

`Classes/KernelEventsParser.cs`:

```cs
using Microsoft.Diagnostics.Tracing.Parsers;
using Microsoft.Diagnostics.Tracing.Parsers.Kernel;
using Microsoft.Diagnostics.Tracing.Session;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace DLLirant.Classes
{
    internal class KernelEventsParser
    {
        public bool IsStarted = false;

        TraceEventSession kernelSession;

        public async void StartNameNotFoundTracing(SynchronizationContext uiContext, DataContextViewModel data, string processName = null)
        {
            IsStarted = true;

            await Task.Run(() =>
            {
                uiContext.Send(x => data.LogsGrid2.Clear(), null);

                if (processName != null)
                    processName = processName.Replace(".exe", string.Empty);

                List<string> namesNotFoundPaths = new List<string>();

                using (kernelSession = new TraceEventSession(KernelTraceEventParser.KernelSessionName))
                {
                    kernelSession.EnableKernelProvider(KernelTraceEventParser.Keywords.All);
                    kernelSession.Source.Kernel.FileIOCreate += ((FileIOCreateTraceData obj) =>
                    {
                        if (processName != null && processName.Length > 0)
                        {
                            if (obj.ProcessName == processName)
                            {
                                if (!namesNotFoundPaths.Contains(obj.FileName) && !obj.FileName.ToLower().StartsWith(Environment.SystemDirectory.ToLower()) && obj.FileName.ToLower().EndsWith(".dll"))
                                {
                                    if (!File.Exists(obj.FileName) || !Directory.Exists(Path.GetDirectoryName(obj.FileName)))
                                    {
                                        namesNotFoundPaths.Add(obj.FileName);
                                        uiContext.Send(x => data.LogsGrid2.Add(obj.FileName), null);
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (!namesNotFoundPaths.Contains(obj.FileName) && !obj.FileName.ToLower().StartsWith(Environment.SystemDirectory.ToLower()) && obj.FileName.ToLower().EndsWith(".dll"))
                            {
                                if (!File.Exists(obj.FileName) || !Directory.Exists(Path.GetDirectoryName(obj.FileName)))
                                {
                                    namesNotFoundPaths.Add(obj.FileName);
                                    uiContext.Send(x => data.LogsGrid2.Add(obj.FileName), null);
                                }
                            }
                        }
                    });

                    kernelSession.Source.Process();
                };
            });
        }

        public void StopNameNotFoundTracing()
        {
            IsStarted = false;
            kernelSession.Stop();
        }
    }
}

```

`Classes/PEAnalyzer.cs`:

```cs
using PeNet;
using System.Collections.Generic;

namespace DLLirant.Classes
{
    internal class PEAnalyzer
    {
        public string SelectedBinaryPath;

        private readonly PeFile peFile;

        public PEAnalyzer(string path)
        {
            SelectedBinaryPath = path;
            peFile = new PeFile(SelectedBinaryPath);
        }

        public List<string> GetPEInformations()
        {
            List<string> peInformations = new List<string>();

            if (peFile.HasValidSignature)
            {
                peInformations.Add("Is signature valid: Yes");
            }
            else
            {
                peInformations.Add("Is signature valid: No");
            }

            if (peFile.Is64Bit)
            {
                peInformations.Add("Architecture: x64");
            }
            else if (peFile.Is32Bit)
            {
                peInformations.Add("Architecture: x86");
            }
            else
            {
                peInformations.Add("Architecture: Unknown");
            }

            peInformations.Add($"MD5: {peFile.Md5}");
            peInformations.Add($"SHA1: {peFile.Sha1}");
            peInformations.Add($"SHA256: {peFile.Sha256}");
            return peInformations;
        }

        public string CheckIfSigned()
        {
            if (peFile.IsSigned)
            {
                return "Is signed: Yes";
            }
            else
            {
                return "Is signed: No";
            }
        }

        public List<string> GetModules(List<string> excludesList)
        {
            List<string> modules = new List<string>();
            foreach (PeNet.Header.Pe.ImportFunction func in peFile.ImportedFunctions)
            {
                bool isExcluded = false;
                foreach (string exclude in excludesList)
                {
                    if (func.DLL.ToLower().Contains(exclude.ToLower()))
                    {
                        isExcluded = true;
                        break;
                    }
                }
                if (!modules.Contains(func.DLL) && !isExcluded)
                {
                    modules.Add(func.DLL);
                }
            }
            return modules;
        }

        public List<string> GetImportedFunctions(string moduleName)
        {
            List<string> importedFunctions = new List<string>();
            foreach (PeNet.Header.Pe.ImportFunction func in peFile.ImportedFunctions)
            {
                if (func.DLL == moduleName && func.Name != null && !func.Name.StartsWith("?"))
                {
                    importedFunctions.Add(func.Name);
                }
            }
            return importedFunctions;
        }

        public string GetMD5()
        {
            return peFile.Md5;
        }

        public string GetSHA1()
        {
            return peFile.Sha1;
        }

        public string GetSHA256()
        {
            return peFile.Sha256;
        }
    }
}

```

`DLLirant.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.0.6\build\Microsoft.Diagnostics.Tracing.TraceEvent.props" Condition="Exists('packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.0.6\build\Microsoft.Diagnostics.Tracing.TraceEvent.props')" />
  <Import Project="packages\Costura.Fody.5.7.0\build\Costura.Fody.props" Condition="Exists('packages\Costura.Fody.5.7.0\build\Costura.Fody.props')" />
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{B715E1C2-05E2-475A-81BA-6C60A6ED55A3}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>DLLirant</RootNamespace>
    <AssemblyName>DLLirant</AssemblyName>
    <TargetFrameworkVersion>v4.6.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationManifest>app.manifest</ApplicationManifest>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>dllirant.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="ControlzEx, Version=5.0.0.0, Culture=neutral, PublicKeyToken=69f1c32f803d307e, processorArchitecture=MSIL">
      <HintPath>packages\ControlzEx.5.0.2\lib\net462\ControlzEx.dll</HintPath>
    </Reference>
    <Reference Include="Costura, Version=5.7.0.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>packages\Costura.Fody.5.7.0\lib\netstandard1.0\Costura.dll</HintPath>
    </Reference>
    <Reference Include="Dia2Lib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.0.6\lib\net462\Dia2Lib.dll</HintPath>
      <EmbedInteropTypes>True</EmbedInteropTypes>
    </Reference>
    <Reference Include="MahApps.Metro, Version=2.0.0.0, Culture=neutral, PublicKeyToken=51482d6f650b2b3f, processorArchitecture=MSIL">
      <HintPath>packages\MahApps.Metro.2.4.9\lib\net46\MahApps.Metro.dll</HintPath>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>packages\MahApps.Metro.IconPacks.Unicons.4.11.0\lib\net46\MahApps.Metro.IconPacks.Core.dll</HintPath>
    </Reference>
    <Reference Include="MahApps.Metro.IconPacks.Unicons, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0c0d510f9915137a, processorArchitecture=MSIL">
      <HintPath>packages\MahApps.Metro.IconPacks.Unicons.4.11.0\lib\net46\MahApps.Metro.IconPacks.Unicons.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Diagnostics.FastSerialization, Version=3.0.6.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.0.6\lib\net462\Microsoft.Diagnostics.FastSerialization.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Diagnostics.Tracing.TraceEvent, Version=3.0.6.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.0.6\lib\net462\Microsoft.Diagnostics.Tracing.TraceEvent.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Win32.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Win32.Primitives.4.3.0\lib\net46\Microsoft.Win32.Primitives.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Xaml.Behaviors, Version=1.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Xaml.Behaviors.Wpf.1.1.39\lib\net45\Microsoft.Xaml.Behaviors.dll</HintPath>
    </Reference>
    <Reference Include="OSExtensions, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.0.6\lib\net462\OSExtensions.dll</HintPath>
    </Reference>
    <Reference Include="PeNet, Version=2.9.9.0, Culture=neutral, PublicKeyToken=6cf2bfba59bcfb3f, processorArchitecture=MSIL">
      <HintPath>packages\PeNet.2.9.9\lib\netstandard2.0\PeNet.dll</HintPath>
    </Reference>
    <Reference Include="PeNet.Asn1, Version=2.0.1.0, Culture=neutral, PublicKeyToken=1e2e3568f0050bf5, processorArchitecture=MSIL">
      <HintPath>packages\PeNet.Asn1.2.0.1\lib\net461\PeNet.Asn1.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.AppContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.AppContext.4.3.0\lib\net46\System.AppContext.dll</HintPath>
    </Reference>
    <Reference Include="System.Buffers, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Buffers.4.5.1\lib\net461\System.Buffers.dll</HintPath>
    </Reference>
    <Reference Include="System.ComponentModel.Composition" />
    <Reference Include="System.ComponentModel.DataAnnotations" />
    <Reference Include="System.Configuration" />
    <Reference Include="System.Console, Version=4.0.1.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Console.4.3.1\lib\net46\System.Console.dll</HintPath>
    </Reference>
    <Reference Include="System.Data" />
    <Reference Include="System.Diagnostics.DiagnosticSource, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Diagnostics.DiagnosticSource.7.0.0\lib\net462\System.Diagnostics.DiagnosticSource.dll</HintPath>
    </Reference>
    <Reference Include="System.Diagnostics.Tracing, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Diagnostics.Tracing.4.3.0\lib\net462\System.Diagnostics.Tracing.dll</HintPath>
    </Reference>
    <Reference Include="System.Globalization.Calendars, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Globalization.Calendars.4.3.0\lib\net46\System.Globalization.Calendars.dll</HintPath>
    </Reference>
    <Reference Include="System.IO, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.4.3.0\lib\net462\System.IO.dll</HintPath>
    </Reference>
    <Reference Include="System.IO.Compression, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.Compression.4.3.0\lib\net46\System.IO.Compression.dll</HintPath>
    </Reference>
    <Reference Include="System.IO.Compression.FileSystem" />
    <Reference Include="System.IO.Compression.ZipFile, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.Compression.ZipFile.4.3.0\lib\net46\System.IO.Compression.ZipFile.dll</HintPath>
    </Reference>
    <Reference Include="System.IO.FileSystem, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.FileSystem.4.3.0\lib\net46\System.IO.FileSystem.dll</HintPath>
    </Reference>
    <Reference Include="System.IO.FileSystem.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.FileSystem.Primitives.4.3.0\lib\net46\System.IO.FileSystem.Primitives.dll</HintPath>
    </Reference>
    <Reference Include="System.Management" />
    <Reference Include="System.Memory, Version=4.0.1.2, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Memory.4.5.5\lib\net461\System.Memory.dll</HintPath>
    </Reference>
    <Reference Include="System.Net.Http, Version=4.1.1.3, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Net.Http.4.3.4\lib\net46\System.Net.Http.dll</HintPath>
    </Reference>
    <Reference Include="System.Net.Sockets, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Net.Sockets.4.3.0\lib\net46\System.Net.Sockets.dll</HintPath>
    </Reference>
    <Reference Include="System.Numerics" />
    <Reference Include="System.Numerics.Vectors, Version=4.1.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Numerics.Vectors.4.5.0\lib\net46\System.Numerics.Vectors.dll</HintPath>
    </Reference>
    <Reference Include="System.Reflection, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Reflection.4.3.0\lib\net462\System.Reflection.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime, Version=4.1.1.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.4.3.1\lib\net462\System.Runtime.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime.CompilerServices.Unsafe, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.CompilerServices.Unsafe.6.0.0\lib\net461\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime.Extensions, Version=4.1.1.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.Extensions.4.3.1\lib\net462\System.Runtime.Extensions.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime.InteropServices, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.InteropServices.4.3.0\lib\net462\System.Runtime.InteropServices.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime.InteropServices.RuntimeInformation, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.InteropServices.RuntimeInformation.4.3.0\lib\net45\System.Runtime.InteropServices.RuntimeInformation.dll</HintPath>
    </Reference>
    <Reference Include="System.Security" />
    <Reference Include="System.Security.Cryptography.Algorithms, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Algorithms.4.3.1\lib\net461\System.Security.Cryptography.Algorithms.dll</HintPath>
    </Reference>
    <Reference Include="System.Security.Cryptography.Encoding, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Encoding.4.3.0\lib\net46\System.Security.Cryptography.Encoding.dll</HintPath>
    </Reference>
    <Reference Include="System.Security.Cryptography.Pkcs, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Pkcs.7.0.0\lib\net462\System.Security.Cryptography.Pkcs.dll</HintPath>
    </Reference>
    <Reference Include="System.Security.Cryptography.Primitives, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Primitives.4.3.0\lib\net46\System.Security.Cryptography.Primitives.dll</HintPath>
    </Reference>
    <Reference Include="System.Security.Cryptography.X509Certificates, Version=4.1.1.2, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.X509Certificates.4.3.2\lib\net461\System.Security.Cryptography.X509Certificates.dll</HintPath>
    </Reference>
    <Reference Include="System.Web" />
    <Reference Include="System.Web.Extensions" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="System.Xml.ReaderWriter, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Xml.ReaderWriter.4.3.1\lib\net46\System.Xml.ReaderWriter.dll</HintPath>
    </Reference>
    <Reference Include="TraceReloggerLib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.0.6\lib\net462\TraceReloggerLib.dll</HintPath>
      <EmbedInteropTypes>True</EmbedInteropTypes>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="Classes\CodeGenerator.cs" />
    <Compile Include="Classes\DLLHijackingsHelper.cs" />
    <Compile Include="Classes\ExecuteCommandHelper.cs" />
    <Compile Include="Classes\FileOperations.cs" />
    <Compile Include="Classes\KernelEventsParser.cs" />
    <Compile Include="Classes\PEAnalyzer.cs" />
    <Compile Include="ViewModel\DataContextViewModel.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="app.manifest" />
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="FodyWeavers.xml" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="dllirant.ico" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="background.png" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>Ce projet fait référence à des packages NuGet qui sont manquants sur cet ordinateur. Utilisez l'option de restauration des packages NuGet pour les télécharger. Pour plus d'informations, consultez http://go.microsoft.com/fwlink/?LinkID=322105. Le fichier manquant est : {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('packages\Costura.Fody.5.7.0\build\Costura.Fody.props')" Text="$([System.String]::Format('$(ErrorText)', 'packages\Costura.Fody.5.7.0\build\Costura.Fody.props'))" />
    <Error Condition="!Exists('packages\Costura.Fody.5.7.0\build\Costura.Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', 'packages\Costura.Fody.5.7.0\build\Costura.Fody.targets'))" />
    <Error Condition="!Exists('packages\Fody.6.6.4\build\Fody.targets')" Text="$([System.String]::Format('$(ErrorText)', 'packages\Fody.6.6.4\build\Fody.targets'))" />
    <Error Condition="!Exists('packages\NETStandard.Library.2.0.3\build\netstandard2.0\NETStandard.Library.targets')" Text="$([System.String]::Format('$(ErrorText)', 'packages\NETStandard.Library.2.0.3\build\netstandard2.0\NETStandard.Library.targets'))" />
    <Error Condition="!Exists('packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.0.6\build\Microsoft.Diagnostics.Tracing.TraceEvent.props')" Text="$([System.String]::Format('$(ErrorText)', 'packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.0.6\build\Microsoft.Diagnostics.Tracing.TraceEvent.props'))" />
  </Target>
  <Import Project="packages\Costura.Fody.5.7.0\build\Costura.Fody.targets" Condition="Exists('packages\Costura.Fody.5.7.0\build\Costura.Fody.targets')" />
  <Import Project="packages\Fody.6.6.4\build\Fody.targets" Condition="Exists('packages\Fody.6.6.4\build\Fody.targets')" />
  <Import Project="packages\NETStandard.Library.2.0.3\build\netstandard2.0\NETStandard.Library.targets" Condition="Exists('packages\NETStandard.Library.2.0.3\build\netstandard2.0\NETStandard.Library.targets')" />
</Project>
```

`DLLirant.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33110.190
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DLLirant", "DLLirant.csproj", "{B715E1C2-05E2-475A-81BA-6C60A6ED55A3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B715E1C2-05E2-475A-81BA-6C60A6ED55A3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B715E1C2-05E2-475A-81BA-6C60A6ED55A3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B715E1C2-05E2-475A-81BA-6C60A6ED55A3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B715E1C2-05E2-475A-81BA-6C60A6ED55A3}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E9980F37-BD8F-4061-B8E7-D87ED4B77013}
	EndGlobalSection
EndGlobal

```

`FodyWeavers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
	<Costura />
</Weavers>
```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Société Générale

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`MainWindow.xaml`:

```xaml
<mah:MetroWindow x:Class="DLLirant.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:mah="clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro"
        xmlns:iconPacks="http://metro.mahapps.com/winfx/xaml/iconpacks"
        xmlns:local="clr-namespace:DLLirant"
        mc:Ignorable="d"
        Title="DLLirant.NET" Height="664" Width="1176" WindowStartupLocation="CenterScreen" Loaded="MetroWindow_Loaded">
    <Window.DataContext>
        <local:DataContextViewModel />
    </Window.DataContext>
    <Window.Resources>
        <Style x:Key="TabItemText" TargetType="{x:Type TextBlock}">
            <Style.Triggers>
                <DataTrigger Binding="{Binding IsSelected, RelativeSource={RelativeSource AncestorType=TabItem}}" Value="True">
                    <Setter Property="Foreground" Value="DarkGreen"/>
                    <Setter Property="FontWeight" Value="Bold" />
                    <Setter Property="FontFamily" Value="Segoe Script" />
                </DataTrigger>
                <DataTrigger Binding="{Binding IsSelected, RelativeSource={RelativeSource AncestorType=TabItem}}" Value="False">
                    <Setter Property="Foreground" Value="White"/>
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="FontFamily" Value="Segoe UI" />
                </DataTrigger>
            </Style.Triggers>
        </Style>
    </Window.Resources>
    <mah:MetroWindow.LeftWindowCommands>
        <mah:WindowCommands>
            <Button Click="ButtonOpenGitHub_Click" ToolTip="Open up the GitHub site">
                <iconPacks:PackIconUnicons Width="22" Height="22" Kind="Github" />
            </Button>
        </mah:WindowCommands>
    </mah:MetroWindow.LeftWindowCommands>
    <Grid Background="Black">
        <Image Source="background.png" Stretch="Fill" Height="{Binding ActualHeight, ElementName=ItemsContainer}" VerticalAlignment="Top" />
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="1.5*" />
                <ColumnDefinition />
            </Grid.ColumnDefinitions>
            <TabControl Grid.Column="0" x:Name="MainTabControl" Background="Transparent" SelectionChanged="MainTabControl_SelectionChanged">
                <TabItem>
                    <TabItem.Header>
                        <TextBlock Style="{StaticResource TabItemText}" Text="DLL SEARCH ORDER HIJACKINGS" FontSize="14" />
                    </TabItem.Header>
                    <Grid Background="Transparent">
                        <ListBox Grid.Column="0" ItemsSource="{Binding LogsGrid1}" HorizontalContentAlignment="Stretch" Background="Transparent" Foreground="White">
                            <ListBox.Resources>
                                <Style TargetType="{x:Type ListBoxItem}">
                                    <Setter Property="Background" Value="Transparent" />
                                </Style>
                            </ListBox.Resources>
                        </ListBox>
                    </Grid>
                </TabItem>
                <TabItem>
                    <TabItem.Header>
                        <TextBlock Style="{StaticResource TabItemText}" Text="NAME NOT FOUND" FontSize="14" />
                    </TabItem.Header>
                    <Grid Background="Transparent">
                        <Grid.RowDefinitions>
                            <RowDefinition />
                            <RowDefinition Height="0.06*" />
                        </Grid.RowDefinitions>
                        <ListBox x:Name="ListBoxLogsGrid2" Grid.Row="0" ItemsSource="{Binding LogsGrid2}" HorizontalContentAlignment="Stretch" Background="Transparent" Foreground="White">
                            <ListBox.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Open Directory" PreviewMouseDown="MenuItemOpenDirectory_PreviewMouseDown"></MenuItem>
                                </ContextMenu>
                            </ListBox.ContextMenu>
                            <ListBox.Resources>
                                <Style TargetType="{x:Type ListBoxItem}">
                                    <Setter Property="Background" Value="Transparent" />
                                </Style>
                            </ListBox.Resources>
                        </ListBox>
                    </Grid>
                </TabItem>
                <TabItem>
                    <TabItem.Header>
                        <TextBlock Style="{StaticResource TabItemText}" Text="DLL PROXYING" FontSize="14" />
                    </TabItem.Header>
                    <Grid Background="Transparent">
                        <Grid>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition />
                                <ColumnDefinition />
                            </Grid.ColumnDefinitions>
                            <Grid Grid.Column="0">
                                <StackPanel>
                                    <TextBlock Margin="5, 20, 5, 0" HorizontalAlignment="Center" Text="Generate a classic proxy DLL:" Foreground="White" FontWeight="Bold" FontStyle="Italic" FontFamily="Consolas" />
                                    <TextBlock Margin="10" Text="Select the targeted DLL:" Foreground="White" FontFamily="Consolas" TextAlignment="Center" />
                                    <Button Margin="5" Width="100" Content="Browse" Click="SelectedTargetedDLL_Button_Click" />
                                    <TextBlock Margin="10" Text="Targeted DLL:" Foreground="White" FontFamily="Consolas" TextAlignment="Center" />
                                    <TextBlock x:Name="TargetedDLL" Margin="10" Text="None" Foreground="White" FontFamily="Consolas" TextAlignment="Center" TextWrapping="Wrap" />
                                    <TextBlock Margin="10" Text="Path to use in the Proxy DLL (by default it will be 'proxy' but you can use full path like 'C:\\Windows\\System32\\foobar.dll'):" Foreground="White" FontFamily="Consolas" TextAlignment="Center" TextWrapping="Wrap" />
                                    <TextBox x:Name="TextBoxPathProxyDLL" Margin="5" ToolTip="Write the path of the proxy DLL" Width="200" />
                                    <Button x:Name="ButtonGenerateClassicDLL" Margin="5" Width="200" Content="Generate" Click="GenerateClassicDLL_Button_Click" IsEnabled="False" />
                                </StackPanel>
                            </Grid>
                            <Grid Grid.Column="1">
                                <StackPanel>
                                    <TextBlock Margin="5, 20, 5, 0" HorizontalAlignment="Center" Text="Generate an Ordinal based proxy DLL:" Foreground="White" FontWeight="Bold" FontStyle="Italic" FontFamily="Consolas" />
                                    <TextBlock Margin="10" Text="Name of the DLL to generate:" Foreground="White" FontFamily="Consolas" TextAlignment="Center" />
                                    <TextBox x:Name="TextBoxOrdinalDLLName" Margin="5" ToolTip="Write the name of the DLL that you want to generate" Width="200" />
                                    <TextBlock Margin="10" Text="Number of Ordinal to export:" Foreground="White" FontFamily="Consolas" TextAlignment="Center" />
                                    <DockPanel Margin="10" VerticalAlignment="Center" Width="300">
                                        <TextBox Text="{Binding ElementName=sliderValue, Path=Value, UpdateSourceTrigger=PropertyChanged}" DockPanel.Dock="Right" TextAlignment="Right" Width="45" Margin="10,0,0,0" />
                                        <Slider Maximum="10000" TickFrequency="1" IsSnapToTickEnabled="True" Name="sliderValue" />
                                    </DockPanel>
                                    <Button Margin="5" Width="200" Content="Generate" Click="GenerateOrdinalBasedDLL_Button_Click" />
                                </StackPanel>
                            </Grid>
                        </Grid>
                    </Grid>
                </TabItem>
            </TabControl>
            <Grid x:Name="GridDLLSearchOrderHijackingMenu" Grid.Column="1">
                <Grid.RowDefinitions>
                    <RowDefinition Height="0.07*" />
                    <RowDefinition />
                    <RowDefinition Height="0.1*" />
                </Grid.RowDefinitions>
                <StackPanel Grid.Row="0" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,5,0,5">
                    <TextBox x:Name="TextBoxBinaryNameToTest" mah:TextBoxHelper.Watermark="SELECT THE BINARY TO TEST ..." Width="380" Background="Transparent" BorderThickness="1" TextAlignment="Right" PreviewMouseDown="TextBoxBinaryNameToTest_PreviewMouseDown" />
                    <Button x:Name="ButtonStartFindingDLLSearchOrderHijackings" Background="Transparent" Click="ButtonStartFindingDLLSearchOrderHijackings_Click" Margin="5,0,5,0" BorderThickness="0">
                        <Button.ContentTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <iconPacks:PackIconUnicons Width="18" Height="18" VerticalAlignment="Center" Kind="Play" />
                                    <TextBlock Margin="5,0,0,0" VerticalAlignment="Center" Text="Start" />
                                </StackPanel>
                            </DataTemplate>
                        </Button.ContentTemplate>
                    </Button>
                </StackPanel>
                <ListBox x:Name="ListBoxExcludes" Grid.Row="1" ItemsSource="{Binding ExcludesDLLs}" HorizontalContentAlignment="Right" Background="Transparent" Foreground="White">
                    <ListBox.ContextMenu>
                        <ContextMenu>
                            <MenuItem Header="Delete" PreviewMouseDown="MenuItemDeleteExcludeDLL_PreviewMouseDown"></MenuItem>
                        </ContextMenu>
                    </ListBox.ContextMenu>
                    <ListBox.Resources>
                        <Style TargetType="{x:Type ListBoxItem}">
                            <Setter Property="Background" Value="Transparent" />
                        </Style>
                    </ListBox.Resources>
                </ListBox>
                <StackPanel Grid.Row="2" Margin="0,5,0,5" VerticalAlignment="Bottom">
                    <TextBlock Text="Add a DLL in the exclusion list:" Foreground="White" TextAlignment="Center" FontFamily="Consolas" />
                    <Grid Margin="0,5,0,0">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="2*" />
                            <ColumnDefinition />
                        </Grid.ColumnDefinitions>
                        <TextBox x:Name="TextBoxExcludeAdd" Grid.Column="0" Margin="5,0,5,0" Background="Transparent" />
                        <Button Grid.Column="1" Content="ADD" Foreground="White" Margin="5,0,5,0" Background="Transparent" Click="ButtonAddExclude_Click" />
                    </Grid>
                </StackPanel>
            </Grid>
            <Grid x:Name="GridNameNotFoundMenu" Grid.Column="1">
                <Grid.RowDefinitions>
                    <RowDefinition Height="0.065*" />
                    <RowDefinition />
                </Grid.RowDefinitions>
                <StackPanel Grid.Row="0" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,5,0,5">
                    <TextBox x:Name="TextBoxProcessNameToMonitor" mah:TextBoxHelper.Watermark="ENTER THE PROCESS NAME TO MONITOR OR LET BLANK FOR ALL ..." Width="380" Background="Transparent" BorderThickness="1" TextAlignment="Right" />
                    <Button x:Name="ButtonStartMonitoringNameNotFound" Background="Transparent" Click="ButtonStartMonitoringNameNotFound_Click" Margin="5,0,5,0" BorderThickness="0">
                        <Button.ContentTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <iconPacks:PackIconUnicons Width="18" Height="18" VerticalAlignment="Center" Kind="Play" />
                                    <TextBlock Margin="5,0,0,0" VerticalAlignment="Center" Text="Start" />
                                </StackPanel>
                            </DataTemplate>
                        </Button.ContentTemplate>
                    </Button>
                </StackPanel>
            </Grid>
        </Grid>
    </Grid>
</mah:MetroWindow>

```

`MainWindow.xaml.cs`:

```cs
using DLLirant.Classes;
using MahApps.Metro.Controls;
using Microsoft.Win32;
using PeNet;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

namespace DLLirant
{
    public partial class MainWindow : MetroWindow
    {
        readonly SynchronizationContext uiContext = SynchronizationContext.Current;
        readonly DataContextViewModel data = new DataContextViewModel();
        readonly KernelEventsParser kernelEventsParser = new KernelEventsParser();
        readonly DLLHijackingsHelper dllHijackingsHelper = new DLLHijackingsHelper();

        private PEAnalyzer peAnalyzer;

        string SelectedDLL;

        public MainWindow()
        {
            InitializeComponent();
            DataContext = data;
        }

        private void MetroWindow_Loaded(object sender, RoutedEventArgs e)
        {
            uiContext.Send(x => data.LogsGrid1.Clear(), null);
            uiContext.Send(x => data.LogsGrid2.Clear(), null);
            GridNameNotFoundMenu.Visibility = Visibility.Collapsed;
            ButtonStartFindingDLLSearchOrderHijackings.IsEnabled = false;
        }

        private void ButtonOpenGitHub_Click(object sender, RoutedEventArgs e)
        {
            Process.Start("https://github.com/redteamsocietegenerale/DLLirant");
        }

        private void TextBoxBinaryNameToTest_PreviewMouseDown(object sender, MouseButtonEventArgs e)
        {
            TextBox textBox = (TextBox)sender;
            OpenFileDialog openFileDialog = new OpenFileDialog
            {
                Filter = "Exe Files (.exe)|*.exe",
                Multiselect = false
            };

            if (openFileDialog.ShowDialog() == true)
            {
                textBox.Text = Path.GetFileName(openFileDialog.FileName);
                if (openFileDialog.FileName.EndsWith(".exe"))
                {
                    ButtonStartFindingDLLSearchOrderHijackings.IsEnabled = true;
                    peAnalyzer = new PEAnalyzer(openFileDialog.FileName);
                }
            }
        }

        private async void ButtonStartFindingDLLSearchOrderHijackings_Click(object sender, RoutedEventArgs e)
        {
            Button button = (Button)sender;
            TextBlock buttonTextBlock = button.FindChild<TextBlock>();

            if (!dllHijackingsHelper.ExecuteCommandHelper.IsStarted)
            {
                buttonTextBlock.Text = "Stop";
                dllHijackingsHelper.ExecuteCommandHelper.IsStarted = true;
                await dllHijackingsHelper.FindSearchOrderHijackings(uiContext, data, peAnalyzer);
            } else
            {
                dllHijackingsHelper.ExecuteCommandHelper.Stop();
                buttonTextBlock.Text = "Start";
            }
        }

        private void ButtonStartMonitoringNameNotFound_Click(object sender, RoutedEventArgs e)
        {
            Button button = (Button)sender;
            TextBlock buttonTextBlock = button.FindChild<TextBlock>();

            if (!kernelEventsParser.IsStarted)
            {
                TextBoxProcessNameToMonitor.IsEnabled = false;
                buttonTextBlock.Text = "Stop";
                kernelEventsParser.StartNameNotFoundTracing(uiContext, data, TextBoxProcessNameToMonitor.Text);
            } else
            {
                TextBoxProcessNameToMonitor.IsEnabled = true;
                buttonTextBlock.Text = "Start";
                kernelEventsParser.StopNameNotFoundTracing();
            }
        }

        private void MainTabControl_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            TabControl tabControl = sender as TabControl;
            switch (tabControl.SelectedIndex)
            {
                case 0:
                    GridDLLSearchOrderHijackingMenu.Visibility = Visibility.Visible;
                    GridNameNotFoundMenu.Visibility = Visibility.Collapsed;
                    break;
                case 1:
                    GridNameNotFoundMenu.Visibility = Visibility.Visible;
                    GridDLLSearchOrderHijackingMenu.Visibility = Visibility.Collapsed;
                    break;
                case 2:
                    GridNameNotFoundMenu.Visibility = Visibility.Collapsed;
                    GridDLLSearchOrderHijackingMenu.Visibility = Visibility.Collapsed;
                    break;
                default:
                    break;
            }
        }

        private void MenuItemOpenDirectory_PreviewMouseDown(object sender, MouseButtonEventArgs e)
        {
            try
            {
                Process.Start(Path.GetDirectoryName(ListBoxLogsGrid2.SelectedValue.ToString()));
            } catch (System.ComponentModel.Win32Exception) { MessageBox.Show("The specified directory does not exists"); }
        }

        private void ButtonAddExclude_Click(object sender, RoutedEventArgs e)
        {
            if (TextBoxExcludeAdd.Text.Length > 0 && !data.ExcludesDLLs.Contains(TextBoxExcludeAdd.Text.ToLower()))
            {
                string text = TextBoxExcludeAdd.Text.ToLower().Replace(" ", string.Empty);
                data.ExcludesDLLs.Add(text);
            }
        }

        private void MenuItemDeleteExcludeDLL_PreviewMouseDown(object sender, MouseButtonEventArgs e)
        {
            if (ListBoxExcludes.SelectedValue != null)
            {
                data.ExcludesDLLs.Remove(ListBoxExcludes.SelectedValue.ToString());
            }
        }

        private void SelectedTargetedDLL_Button_Click(object sender, RoutedEventArgs e)
        {
            OpenFileDialog openFileDialog = new OpenFileDialog
            {
                Filter = "DLL files (*.dll)|*.dll",
                Multiselect = false
            };

            if (openFileDialog.ShowDialog() == true)
            {
                SelectedDLL = openFileDialog.FileName;
                if (SelectedDLL.EndsWith(".dll"))
                {
                    ButtonGenerateClassicDLL.IsEnabled = true;
                    TargetedDLL.Text = SelectedDLL;
                }
            }
        }

        private async void GenerateClassicDLL_Button_Click(object sender, RoutedEventArgs e)
        {
            Button button = (Button)sender;
            button.Content = "Generating...";
            button.IsEnabled = false;

            PeFile peFile = new PeFile(SelectedDLL);

            FileOperations.RecreateDirectories(new List<string> { "output/" });

            List<string> exportedFunctions = new List<string>();
            string proxyPath = "proxy";
            if (TextBoxPathProxyDLL.Text.Length > 0)
            {
                proxyPath = TextBoxPathProxyDLL.Text.Replace(".dll", string.Empty);
            }
            foreach (PeNet.Header.Pe.ExportFunction func in peFile.ExportedFunctions)
            {
                exportedFunctions.Add($"#pragma comment(linker,\"/export:{func.Name}={proxyPath}.{func.Name},@{func.Ordinal}\")");
            }
            await Task.Run(() => {
                CodeGenerator.GenerateDLL("Main();", exportedFunctions);

                ExecuteCommandHelper executeCommandHelper = new ExecuteCommandHelper();
                executeCommandHelper.ExecuteCommand("cmd.exe", "/C clang++.exe dllmain.cpp -o DLLirantDLL.dll -shared");
            });

            if (proxyPath.StartsWith("C:"))
            {
                FileOperations.RenameFile("output/DLLirantDLL.dll", $"output/{Path.GetFileName(SelectedDLL)}");
            }
            else
            {
                FileOperations.CopyFileToDir(SelectedDLL, "output/");
                FileOperations.RenameFile($"output/{Path.GetFileName(SelectedDLL)}", $"output/{proxyPath}.dll");
                FileOperations.RenameFile("output/DLLirantDLL.dll", $"output/{Path.GetFileName(SelectedDLL)}");
            }

            button.Content = "Success!";
            await Task.Run(() => { Thread.Sleep(2000); });
            button.Content = "Generate";
            button.IsEnabled = true;
        }

        private async void GenerateOrdinalBasedDLL_Button_Click(object sender, RoutedEventArgs e)
        {
            Button button = (Button)sender;
            button.Content = "Generating...";
            button.IsEnabled = false;

            FileOperations.RecreateDirectories(new List<string> { "output/" });

            List<string> exportedFunctions = new List<string>();
            for (int i = 0; i < sliderValue.Value; i++)
            {
                exportedFunctions.Add($"extern \"C\" __declspec(dllexport) void DLLIrant{i}() {{ Main({i}); }};");
            }

            await Task.Run(() => {
                CodeGenerator.GenerateDLL(string.Empty, exportedFunctions, CodeGenerator.TypeDLLHijacking.OrdinalBased);

                ExecuteCommandHelper executeCommandHelper = new ExecuteCommandHelper();
                executeCommandHelper.ExecuteCommand("cmd.exe", "/C clang++.exe dllmain.cpp -o DLLirantDLL.dll -shared");
            });

            string dllName = TextBoxOrdinalDLLName.Text;
            if (dllName.Length > 0)
            {
                if (!dllName.EndsWith(".dll"))
                {
                    dllName = $"{dllName}.dll";
                }
                FileOperations.RenameFile("output/DLLirantDLL.dll", $"output/{dllName}");
            }
            button.Content = "Success!";
            await Task.Run(() => { Thread.Sleep(2000); });
            button.Content = "Generate";
            button.IsEnabled = true;
        }
    }
}

```

`Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// Les informations générales relatives à un assembly dépendent de
// l'ensemble d'attributs suivant. Pour modifier les informations
// associées à un assembly.
[assembly: AssemblyTitle("DLLirant")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("DLLirant")]
[assembly: AssemblyCopyright("Copyright ©  2022")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// L'affectation de la valeur false à ComVisible rend les types invisibles dans cet assembly
// aux composants COM. Si vous devez accéder à un type dans cet assembly à partir de
// COM, affectez la valeur True à l'attribut ComVisible sur ce type.
[assembly: ComVisible(false)]

//Pour commencer à générer des applications localisables, définissez
//<UICulture>CultureUtiliséePourCoder</UICulture> dans votre fichier .csproj
//dans <PropertyGroup>.  Par exemple, si vous utilisez le français
//dans vos fichiers sources, définissez <UICulture> à fr-FR. Puis, supprimez les marques de commentaire de
//l'attribut NeutralResourceLanguage ci-dessous. Mettez à jour "fr-FR" dans
//la ligne ci-après pour qu'elle corresponde au paramètre UICulture du fichier projet.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //où se trouvent les dictionnaires de ressources spécifiques à un thème
                                     //(utilisé si une ressource est introuvable dans la page,
                                     // ou dictionnaires de ressources de l'application)
    ResourceDictionaryLocation.SourceAssembly //où se trouve le dictionnaire de ressources générique
                                              //(utilisé si une ressource est introuvable dans la page,
                                              // dans l'application ou dans l'un des dictionnaires de ressources spécifiques à un thème)
)]


// Les informations de version pour un assembly se composent des quatre valeurs suivantes :
//
//      Version principale
//      Version secondaire
//      Numéro de build
//      Révision
//
// Vous pouvez spécifier toutes les valeurs ou indiquer les numéros de build et de révision par défaut
// en utilisant '*', comme indiqué ci-dessous :
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.42000
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DLLirant.Properties
{


    /// <summary>
    ///   Une classe de ressource fortement typée destinée, entre autres, à la consultation des chaînes localisées.
    /// </summary>
    // Cette classe a été générée automatiquement par la classe StronglyTypedResourceBuilder
    // à l'aide d'un outil, tel que ResGen ou Visual Studio.
    // Pour ajouter ou supprimer un membre, modifiez votre fichier .ResX, puis réexécutez ResGen
    // avec l'option /str ou régénérez votre projet VS.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Retourne l'instance ResourceManager mise en cache utilisée par cette classe.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DLLirant.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Remplace la propriété CurrentUICulture du thread actuel pour toutes
        ///   les recherches de ressources à l'aide de cette classe de ressource fortement typée.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}

```

`Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DLLirant.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}

```

`Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>
```

`README.md`:

```md
# DLLirant

DLLirant is a tool to automatize the DLL Hijacking and DLL Proxying researches on a specified binary.

![alt text](https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot.png)
![alt text](https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot2.png)
![alt text](https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot3.png)

* Final PoC output when a DLL Hijacking is found:

![alt text](https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/screenshot4.png)

## Old Live Demo (similar to the new version)

![alt text](https://raw.githubusercontent.com/redteamsocietegenerale/DLLirant/main/live.gif)

## How to install

* Install LLVM for Windows x64 (LLVM-version-win64.exe): https://github.com/llvm/llvm-project/releases
* Do not forget to check the "Add LLVM to the system PATH for current user" during the installation.

## How to use

Select the desired PE file, if it is an .exe, the application will currently search for DLL Search Order Hijacking, if you select a DLL, the application will offer you to proxy it.

Regarding the second option, you must specify a path for the proxy DLL, this path can be specified in two ways:

* With a name, this will generate the proxy DLL and rename it with the name of the selected DLL, and the application will copy the selected (original) DLL and rename it with the name you selected.

* With a path, this option will generate a single file, the proxy DLL that will call the functions exported from the DLL specified in the text box.

You can also create an `import` directory and place the missing DLL files that your application need if necessary (the DLL files will be copied automatically in the `output` directory with the targeted binary).

**Important**

Concerning the error messages of your targeted application, I tried to avoid the error messages, but you can't really because the messagebox is generated by the System via csrss.exe, not via the targeted application, so you can try to kill the threads, the child windows, use SetErrorMode etc... it will not work.

## How it works

The script will create an output directory in the same directory of DLLirant, copy the targeted binary to the output directory.

Via the PeNet library, the script will extract the dll names required by the binary, and test each imports functions available one by one by compilate a custom DLL with the required exported functions.

If a function required by the binary is executed, the custom DLL will create a `C:\DLLirant\output.txt` to be sure that a DLL Hijacking is possible.

The PoCs of the DLL Hijackings will be also created in the DLLirant/dll-hijacks directory.

## Technical posts (in French)

* https://sh0ckfr.com/pages/martine-a-la-recherche-de-la-dll-hijacking-perdue/
* https://sh0ckfr.com/pages/martin-et-le-dll-proxying-de-cristal/

```

`ViewModel/DataContextViewModel.cs`:

```cs
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace DLLirant
{
    internal class DataContextViewModel : INotifyPropertyChanged
    {
        public DataContextViewModel()
        {
            logsgrid1 = new ObservableCollection<string>
            {
                "grid1 test1",
                "grid1 test2",
                "grid1 test3",
                "grid1 test4",
                "grid1 test5",
                "grid1 test6"
            };

            logsgrid2 = new ObservableCollection<string>
            {
                "grid2 test1",
                "grid2 test2",
                "grid2 test3",
                "grid2 test4",
                "grid2 test5",
                "grid2 test6"
            };

            excludesDlls = new ObservableCollection<string>
            {
                "api-ms",
                "ext-ms",
                "ntdll",
                "kernel32",
                "user32",
                "shell32",
                "comctl32",
                "imm32",
                "gdi32",
                "msvcr",
                "ws2_32",
                "ole32",
                "ninput",
                "setupapi",
                "mscoree",
                "msvcp_win",
                "oleaut32",
                "advapi32",
                "crypt32"
            };
        }

        private ObservableCollection<string> logsgrid1;
        public ObservableCollection<string> LogsGrid1
        {
            get { return logsgrid1; }
            set
            {
                logsgrid1 = value;
                OnPropertyChanged();
            }
        }

        private ObservableCollection<string> logsgrid2;
        public ObservableCollection<string> LogsGrid2
        {
            get { return logsgrid2; }
            set
            {
                logsgrid2 = value;
                OnPropertyChanged();
            }
        }

        private ObservableCollection<string> excludesDlls;
        public ObservableCollection<string> ExcludesDLLs
        {
            get { return excludesDlls; }
            set
            {
                excludesDlls = value;
                OnPropertyChanged();
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

```

`app.manifest`:

```manifest
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
	<assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
	<trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
		<security>
			<requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
				<requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
			</requestedPrivileges>
		</security>
	</trustInfo>
</assembly>

```

`packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="ControlzEx" version="5.0.2" targetFramework="net462" />
  <package id="Costura.Fody" version="5.7.0" targetFramework="net462" developmentDependency="true" />
  <package id="Fody" version="6.6.4" targetFramework="net462" developmentDependency="true" />
  <package id="MahApps.Metro" version="2.4.9" targetFramework="net462" />
  <package id="MahApps.Metro.IconPacks.Unicons" version="4.11.0" targetFramework="net462" />
  <package id="Microsoft.Diagnostics.Tracing.TraceEvent" version="3.0.6" targetFramework="net462" />
  <package id="Microsoft.NETCore.Platforms" version="7.0.0" targetFramework="net462" />
  <package id="Microsoft.Win32.Primitives" version="4.3.0" targetFramework="net462" />
  <package id="Microsoft.Xaml.Behaviors.Wpf" version="1.1.39" targetFramework="net462" />
  <package id="NETStandard.Library" version="2.0.3" targetFramework="net462" />
  <package id="PeNet" version="2.9.9" targetFramework="net462" />
  <package id="PeNet.Asn1" version="2.0.1" targetFramework="net462" />
  <package id="System.AppContext" version="4.3.0" targetFramework="net462" />
  <package id="System.Buffers" version="4.5.1" targetFramework="net462" />
  <package id="System.Collections" version="4.3.0" targetFramework="net462" />
  <package id="System.Collections.Concurrent" version="4.3.0" targetFramework="net462" />
  <package id="System.Console" version="4.3.1" targetFramework="net462" />
  <package id="System.Diagnostics.Debug" version="4.3.0" targetFramework="net462" />
  <package id="System.Diagnostics.DiagnosticSource" version="7.0.0" targetFramework="net462" />
  <package id="System.Diagnostics.Tools" version="4.3.0" targetFramework="net462" />
  <package id="System.Diagnostics.Tracing" version="4.3.0" targetFramework="net462" />
  <package id="System.Globalization" version="4.3.0" targetFramework="net462" />
  <package id="System.Globalization.Calendars" version="4.3.0" targetFramework="net462" />
  <package id="System.IO" version="4.3.0" targetFramework="net462" />
  <package id="System.IO.Compression" version="4.3.0" targetFramework="net462" />
  <package id="System.IO.Compression.ZipFile" version="4.3.0" targetFramework="net462" />
  <package id="System.IO.FileSystem" version="4.3.0" targetFramework="net462" />
  <package id="System.IO.FileSystem.Primitives" version="4.3.0" targetFramework="net462" />
  <package id="System.Linq" version="4.3.0" targetFramework="net462" />
  <package id="System.Linq.Expressions" version="4.3.0" targetFramework="net462" />
  <package id="System.Memory" version="4.5.5" targetFramework="net462" />
  <package id="System.Net.Http" version="4.3.4" targetFramework="net462" />
  <package id="System.Net.Primitives" version="4.3.1" targetFramework="net462" />
  <package id="System.Net.Sockets" version="4.3.0" targetFramework="net462" />
  <package id="System.Numerics.Vectors" version="4.5.0" targetFramework="net462" />
  <package id="System.ObjectModel" version="4.3.0" targetFramework="net462" />
  <package id="System.Reflection" version="4.3.0" targetFramework="net462" />
  <package id="System.Reflection.Extensions" version="4.3.0" targetFramework="net462" />
  <package id="System.Reflection.Primitives" version="4.3.0" targetFramework="net462" />
  <package id="System.Resources.ResourceManager" version="4.3.0" targetFramework="net462" />
  <package id="System.Runtime" version="4.3.1" targetFramework="net462" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.0.0" targetFramework="net462" />
  <package id="System.Runtime.Extensions" version="4.3.1" targetFramework="net462" />
  <package id="System.Runtime.Handles" version="4.3.0" targetFramework="net462" />
  <package id="System.Runtime.InteropServices" version="4.3.0" targetFramework="net462" />
  <package id="System.Runtime.InteropServices.RuntimeInformation" version="4.3.0" targetFramework="net462" />
  <package id="System.Runtime.Numerics" version="4.3.0" targetFramework="net462" />
  <package id="System.Security.Cryptography.Algorithms" version="4.3.1" targetFramework="net462" />
  <package id="System.Security.Cryptography.Encoding" version="4.3.0" targetFramework="net462" />
  <package id="System.Security.Cryptography.Pkcs" version="7.0.0" targetFramework="net462" />
  <package id="System.Security.Cryptography.Primitives" version="4.3.0" targetFramework="net462" />
  <package id="System.Security.Cryptography.X509Certificates" version="4.3.2" targetFramework="net462" />
  <package id="System.Text.Encoding" version="4.3.0" targetFramework="net462" />
  <package id="System.Text.Encoding.Extensions" version="4.3.0" targetFramework="net462" />
  <package id="System.Text.RegularExpressions" version="4.3.1" targetFramework="net462" />
  <package id="System.Threading" version="4.3.0" targetFramework="net462" />
  <package id="System.Threading.Tasks" version="4.3.0" targetFramework="net462" />
  <package id="System.Threading.Timer" version="4.3.0" targetFramework="net462" />
  <package id="System.Xml.ReaderWriter" version="4.3.1" targetFramework="net462" />
  <package id="System.Xml.XDocument" version="4.3.0" targetFramework="net462" />
</packages>
```