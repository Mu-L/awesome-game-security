Project Path: arc_australeo_libipt-rs_5h1x4crp

Source Tree:

```txt
arc_australeo_libipt-rs_5h1x4crp
├── Cargo.toml
├── LICENSE
├── README.md
└── src
    ├── ffi
    │   ├── filesystem.rs
    │   └── mod.rs
    ├── ipt
    │   ├── ipt_buffers.rs
    │   ├── ipt_controller.rs
    │   ├── ipt_options.rs
    │   └── mod.rs
    └── lib.rs

```

`Cargo.toml`:

```toml
[package]
name = "libipt-rs"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
paste = "1.0.12"

[dependencies.windows]
version = "0.48"
features = [
    "Win32_Foundation",
    "Win32_System_IO",
    "Win32_Security",
    "Win32_Storage_FileSystem",
    "Win32_System_Diagnostics_Debug",
    "Win32_System_Threading",
    "Win32_System_Kernel",
    "Win32_System_ProcessStatus",
    "Win32_System_LibraryLoader",
    "Win32_System_Memory",
]
```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Leo Adrien

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# libipt-rs
Rust implementation of a simple user-mode library for interacting with Window's inbuilt Intel Processor Trace driver.

This was initially started as a Rust port of Alex Ionescu's WinIPT (https://github.com/ionescu007/winipt), however as that project has not been updated in some time I found that it was no longer compatible with the latest Windows IPT driver. libipt-rs therefore relies on some of my own reverse engineering as well. Alex's code is probably much better documented however, and I recommend looking at it if you are interested in the driver itself.

Note this library only allows you to interact (start/stop/get) with the IPT driver. It does not contain any functionality for parsing IPT traces for coverage information.

This code is for research purposes only and I have no plans to support or add to it.

```

`src/ffi/filesystem.rs`:

```rs
use windows::Win32::Foundation::{HANDLE, BOOL, CloseHandle, GetLastError};
use windows::Win32::System::IO::DeviceIoControl;
use windows::Win32::Storage::FileSystem::{CreateFileA, FILE_SHARE_MODE,
    FILE_CREATION_DISPOSITION, FILE_FLAGS_AND_ATTRIBUTES};
use windows::core::PCSTR;
use std::ffi::CString;
use std::os::raw::c_void;

type Result<T> = std::result::Result<T, &'static str>;

/// Wrapper for Win32 `CloseHandle`
pub fn close_handle(handle: HANDLE) {
    unsafe {
        CloseHandle(handle);
    }
}

/// Wrapper for Win32 `CreateFileA` with default parameters:
/// - GENERIC_READ
/// - FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING
pub unsafe fn create_file_read(file_path: &str) -> Result<HANDLE> {
    // this is bad and I feel bad
    let path = PCSTR::from_raw(
        CString::new(file_path)
        .unwrap()
        .into_raw() as *const u8);

    let template: HANDLE = HANDLE::default();
    let result = CreateFileA(
        path,
        0x80000000, // GENERIC_READ
        FILE_SHARE_MODE(0x1), // FILE_SHARE_READ
        None,
        FILE_CREATION_DISPOSITION(0x3), // OPEN_EXISTING
        // FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING
        FILE_FLAGS_AND_ATTRIBUTES(0x80 | 0x08000000 | 0x20000000),
        template,
    );

    match result {
        Ok(handle) => Ok(handle),
        Err(_) => Err("CreateFileA failed!"),
    }
}

/// Wrapper for Win32 `DeviceIoControl`
pub unsafe fn device_io_control(
    device_handle: HANDLE, 
    control_code: u32, 
    in_buffer: &mut [u8],
    out_buffer: &mut [u8]) -> Result<()> {
    let mut bytes_returned = 0;

    let result = DeviceIoControl(
        device_handle,
        control_code,
        Some(in_buffer.as_mut_ptr() as *const c_void),
        in_buffer.len() as u32,
        Some(out_buffer.as_mut_ptr() as *mut c_void),
        out_buffer.len() as u32,
        Some(&mut bytes_returned),
        None,
    );

    match result {
        BOOL(0) => {
            println!("Error: {:#?}", GetLastError());
            Err("DeviceIoControl failed!")
        },
        _ => Ok(()),
    }
}
```

`src/ffi/mod.rs`:

```rs
pub (crate) mod filesystem;
```

`src/ipt/ipt_buffers.rs`:

```rs
use crate::ipt::ipt_options::IptOptions;

/// Enumeration types for IPT input packets
#[allow(missing_docs)]
#[derive(Copy, Clone, Debug)]
pub enum IptInputType {
    IptGetTraceVersion = 0,
    IptGetProcessTraceSize = 1,
    IptGetProcessTrace = 2,
    IptStartCoreTracing = 3,
    IptRegisterExtendedImageForTracing = 4,
    IptStartProcessTrace = 5,
    IptStopProcessTrace = 6,
    IptPauseThreadTrace = 7,
    IptResumeThreadTrace = 8,
    IptQueryProcessTrace = 9,
    IptQueryCoreTrace = 10,
    IptStopTraceOnEachCore = 12,
    IptConfigureThreadAddressFilterRange = 13,
    IptQueryThreadAddressFilterRange = 14,
    IptQueryThreadTraceStopRangeEntered = 15,
}

/// Map enum to u32 for use in C-style structs
impl Into<u32> for IptInputType {
    fn into(self) -> u32 {
        match self {
            IptInputType::IptGetTraceVersion => 0,
            IptInputType::IptGetProcessTraceSize => 1,
            IptInputType::IptGetProcessTrace => 2,
            IptInputType::IptStartCoreTracing => 3,
            IptInputType::IptRegisterExtendedImageForTracing => 4,
            IptInputType::IptStartProcessTrace => 5,
            IptInputType::IptStopProcessTrace => 6,
            IptInputType::IptPauseThreadTrace => 7,
            IptInputType::IptResumeThreadTrace => 8,
            IptInputType::IptQueryProcessTrace => 9,
            IptInputType::IptQueryCoreTrace => 10,
            IptInputType::IptStopTraceOnEachCore => 12,
            IptInputType::IptConfigureThreadAddressFilterRange => 13,
            IptInputType::IptQueryThreadAddressFilterRange => 14,
            IptInputType::IptQueryThreadTraceStopRangeEntered => 15,
        }
    }
}

/// Size of header present in all IPT input messages. Data after this
/// will be type specific.
/// [0x0 - 0x8]  Version
/// [0x8 - 0xc]  MessageType
/// [0xc - 0x10] Padding
/// [0x10 - ...] Message specific data
const HEADER_SIZE: usize = 0x10;

/// Size of largest possible IPT message including header
const MAX_INPUT_SIZE: usize = 0x30;

/// Wrapper to allow manipulating input fields while keeping the inner type
/// as a contiguous array for FFI purposes.
pub struct InputBuffer {
    cursor: usize,
    inner: [u8; MAX_INPUT_SIZE],
}

impl Default for InputBuffer {
    fn default() -> Self {
        Self {
            // start the data cursor at the end of the header
            cursor: HEADER_SIZE,
            inner: [0u8; 0x30],
        }
    }
}

impl InputBuffer {
    /// Helper to set message version and type
    fn fill_header(&mut self, t: u32) {
        let version: u64 = 1;
        self.inner[0..8].clone_from_slice(&version.to_le_bytes());
        self.inner[8..12].copy_from_slice(&t.to_le_bytes());
    }

    /// Helper to fill in data section with given bytes
    fn fill_data(&mut self, data: &[u8]) {
        assert!((data.len() > HEADER_SIZE - self.cursor),
            "Attemped to write more than 0x30 bytes to an IPT message!");

        self.inner[self.cursor..self.cursor + data.len()].clone_from_slice(data);
        self.cursor += data.len();
    }

    /// Create a `Query Version` message
    pub fn query_version() -> Self {
        let mut input = InputBuffer::default();

        input.fill_header(IptInputType::IptGetTraceVersion.into());

        input
    }

    /// Create a `Set Thread Filter Range` message
    /// This will configure the address ranges which should be traced for a given thread.
    /// NOTE: Index must be <= 3
    pub fn set_thread_filter_range(
        thread_handle: u64,
        index: u32,
        start_address: u64,
        end_address: u64
        ) -> Self {
            assert!(index <= 3, "Attempted to configure thread index outside allowable range!");

            let mut input = InputBuffer::default();
            let filter_config = 1u32; // configure IP filtering

            input.fill_header(IptInputType::IptConfigureThreadAddressFilterRange.into());
            input.fill_data(&thread_handle.to_le_bytes());
            input.fill_data(&filter_config.to_le_bytes());
            input.fill_data(&index.to_le_bytes());
            input.fill_data(&start_address.to_le_bytes());
            input.fill_data(&end_address.to_le_bytes());

            input
        }

    /// Create a `Start Process Trace` message
    pub fn start_process_trace(process_handle: u64, options: IptOptions) -> Self {
        let mut input = InputBuffer::default();

        input.fill_header(IptInputType::IptStartProcessTrace.into());
        input.fill_data(&process_handle.to_le_bytes());
        input.fill_data(&options.to_le_bytes());

        input
    }

    /// Create a `Stop Process Trace` message
    pub fn stop_process_trace(process_handle: u64) -> Self {
        let mut input = InputBuffer::default();

        input.fill_header(IptInputType::IptStopProcessTrace.into());
        input.fill_data(&process_handle.to_le_bytes());

        input
    }

    /// Create a `Get Process Trace Size` message
    pub fn get_process_trace_size(process_handle: usize) -> Self {
        let mut input = InputBuffer::default();
        let trace_version = 1u64;

        input.fill_header(IptInputType::IptGetProcessTraceSize.into());
        input.fill_data(&trace_version.to_le_bytes());
        let handle64 = process_handle as u64;
        input.fill_data(&handle64.to_le_bytes());

        input
    }

    /// Create a `Get Process Trace Data` message
    pub fn get_process_trace_data(process_handle: usize) -> Self {
        let mut input = InputBuffer::default();
        let trace_version = 1u64;

        input.fill_header(IptInputType::IptGetProcessTrace.into());
        input.fill_data(&trace_version.to_le_bytes());
        let handle64 = process_handle as u64;
        input.fill_data(&handle64.to_le_bytes());

        input
    }

    /// Helper to get inner buffer as a mutable slice. Used for passing the entire message
    /// to an FFI function.
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.inner
    }
}

/// Wrapper to allow parsing output buffer obtained via FFI
pub struct OutputBuffer {
    inner: [u8; 0x18],
}

impl Default for OutputBuffer {
    fn default() -> Self {
        Self {
            inner: [0u8; 0x18],
        }
    }
}

impl OutputBuffer {
    /// Get version from response
    pub fn get_version(&self) -> u64 {
        let (int_bytes, _) = 
            self.inner.split_at(std::mem::size_of::<u64>());
        u64::from_le_bytes(int_bytes.try_into().unwrap())
    }

    /// Get trace size from response
    pub fn get_trace_size(&self) -> u64 {
        // split off the version
        let (_, remainder) = 
            self.inner.split_at(std::mem::size_of::<u64>());

        let (size, _) =
            remainder.split_at(std::mem::size_of::<u64>());

        u64::from_le_bytes(size.try_into().unwrap())
    }

    /// Get inner buffer as slice
    pub fn as_slice(&self) -> &[u8] {
        &self.inner
    }

    /// Get inner buffer as mutable slice
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.inner
    }
}

/// Wrapper around a reference to a byte array representing the header that the `ipt.sys`
/// driver prepends to every trace data buffer returned via IOCTL.
pub struct IptDataHeader<'a> {
    inner: &'a [u8],
}

pub const IPT_DATA_HEADER_LEN: usize = 8;

impl<'a> IptDataHeader<'a> {
    pub fn new(buffer: &'a [u8]) -> Self {
        Self { inner: buffer }
    }

    /// Validate that the `is_valid` field is not 0
    pub fn is_valid(&self) -> bool {
        let valid = u16::from_le_bytes(
            self.inner[2..4]
            .try_into()
            .unwrap());

        valid > 0
    }

    /// Parse out the size of the trace buffer
    pub fn get_trace_data_size(&self) -> usize {
        u32::from_le_bytes(
            self.inner[4..8]
            .try_into()
            .unwrap()) as usize
    }
}


/// Wrapper around a byte array which represents the header that the `ipt.sys`
/// driver places in front of each sub-packet containing actual Intel Process Trace
/// data. There may be multiple `IptTraceHeader` packets inside one `IptDataHeader`
/// packet, each containing some trace information.
pub struct IptTraceHeader<'a> {
    inner: &'a [u8],
}

pub const IPT_TRACE_HEADER_LEN: usize = 28;

impl<'a> IptTraceHeader<'a> {
    pub fn new(buffer: &'a [u8]) -> Self {
        Self { inner: buffer }
    }

    /// Parse out the thread id
    pub fn get_thread_id64(&self) -> u64 {
        u64::from_le_bytes(
            self.inner[0..8]
            .try_into()
            .unwrap())
    }

    /// Get the offset to the trace in the ringbuffer
    pub fn get_ringbuffer_offset(&self) -> usize {
        u32::from_le_bytes(
            self.inner[20..24]
            .try_into()
            .unwrap()) as usize
    }

    /// Get the size of the trace
    pub fn get_trace_size(&self) -> usize {
        u32::from_le_bytes(
            self.inner[24..28]
            .try_into()
            .unwrap()) as usize
    }
}
```

`src/ipt/ipt_controller.rs`:

```rs
use crate::ipt::ipt_buffers::{OutputBuffer, InputBuffer, IPT_DATA_HEADER_LEN, IptDataHeader, IPT_TRACE_HEADER_LEN};
use crate::ipt::ipt_options::IptOptions;
use crate::ffi::filesystem::{close_handle, create_file_read, device_io_control};
use windows::Win32::Foundation::HANDLE;

use super::ipt_buffers::IptTraceHeader;

type Result<T> = std::result::Result<T, &'static str>;

/// IOCTL for control messages
pub const IPT_IOCTL_REQUEST: u32 = 0x220004;
/// IOTCL for `read trace` messages
pub const IPT_IOCTL_READ_TRACE: u32 = 0x220006;
/// Path for IPT device
pub const IPT_DEVICE_PATH: &'static str = "\\??\\IPT";

fn print_ipt_service_message() {
    println!(
    "################################################
     # Failed to obtain a handle to the IPT device! #
     # This may mean the IPT service is not running.#
     # Run the following from an administrative cmd #
     # prompt to enable it:                         #
     #      `sc start ipt`                          #
     ################################################
    ")
}

/// Controller object for interacting with the IPT driver
pub struct IptController {
    /// Handle to the IPT device
    device_handle: HANDLE,
    /// Options for IPT tracing
    options: IptOptions,
    /// Maximum size of the trace buffer
    trace_buffer_max: usize,
    /// Buffer for storing trace data
    trace_buffer: Vec<u8>,
}

/// Close the device handle on drop
impl Drop for IptController {
    fn drop(&mut self) {
        if self.device_handle != HANDLE(0) {
            let temp = self.device_handle;
            self.device_handle = HANDLE(0);
            close_handle(temp);
        }
    }
}

impl IptController {
    /// Create a new controller object, can fail if obtaining a handle to the windows 
    /// IPT device fails.
    pub fn create_controller(options: IptOptions) -> Result<Self> {
        let device_handle;

        // SAFETY: Opening the device handle requires an FFI call
        unsafe {
            match create_file_read(IPT_DEVICE_PATH) {
                Ok(handle) => device_handle = handle,
                Err(e) => {
                    print_ipt_service_message();
                    return Err(e);
                },
            }
    
            Ok(
                Self {
                    device_handle,
                    options,
                    trace_buffer_max: options.get_size_in_bytes(),
                    trace_buffer: Vec::<u8>::with_capacity(options.get_size_in_bytes() + 8),
                }
            )
        }
    }

    /// Get the IPT protocol version in use by the windows driver
    pub fn get_ipt_version(&self) -> Result<u64> {
        let mut in_buffer = InputBuffer::query_version();
        let mut out_buffer = OutputBuffer::default();

        unsafe {
            let _ = device_io_control(
                self.device_handle,
                IPT_IOCTL_REQUEST,
                &mut in_buffer.as_mut_slice(),
                &mut out_buffer.as_mut_slice()
            )?;
        }

        Ok(out_buffer.get_version())
    }

    /// Set the range of instruction pointer addresses to be trace.
    /// Up to four pairs of start/end addresses can be provided.
    pub fn set_ip_filter_range(
        &mut self, 
        thread_handle: usize,
        index: u32,
        start_address: u64,
        end_address: u64,
    ) -> Result<()> {
        if index > 3 {
            return Err("Index is outside of range 0-3!");
        }

        let mut in_buffer = InputBuffer::set_thread_filter_range(
            thread_handle as u64,
            index,
            start_address,
            end_address
        );
        let mut out_buffer = OutputBuffer::default();

        unsafe {
            let _ = device_io_control(
                self.device_handle,
                IPT_IOCTL_REQUEST,
                &mut in_buffer.as_mut_slice(),
                &mut out_buffer.as_mut_slice()
            )?;
        }

        Ok(())
    }

    /// Start IPT tracing on a target process
    pub fn start_tracing_on_process(&mut self, process_handle: u64) -> Result<()> {
        let mut in_buffer = InputBuffer::start_process_trace(
            process_handle, self.options);
        let mut out_buffer = OutputBuffer::default();

        unsafe {
            let _ = device_io_control(
                self.device_handle,
                IPT_IOCTL_REQUEST,
                &mut in_buffer.as_mut_slice(),
                &mut out_buffer.as_mut_slice()
            )?;
        }

        Ok(())
    }

    /// Stop IPT tracing on a target process
    pub fn stop_tracing_on_process(&mut self, process_handle: u64) -> Result<()> {
        let mut in_buffer = InputBuffer::stop_process_trace(process_handle);
        let mut out_buffer = OutputBuffer::default();

        unsafe {
            let _ = device_io_control(
                self.device_handle,
                IPT_IOCTL_REQUEST,
                &mut in_buffer.as_mut_slice(),
                &mut out_buffer.as_mut_slice()
            )?;
        }

        println!("Stopped tracing on process {:#x}", process_handle);

        Ok(())
    }

    /// Get the trace data for a target thread
    pub fn get_trace_data_for_process(
        &mut self, 
        process_handle: usize, 
        thread_id: u32
    ) -> Result<&[u8]> {
        // setup to get trace size
        let mut in_size_buffer = InputBuffer::get_process_trace_size(process_handle);
        let mut out_buffer = OutputBuffer::default();

        unsafe {
            let _ = device_io_control(
                self.device_handle,
                IPT_IOCTL_REQUEST,
                &mut in_size_buffer.as_mut_slice(),
                &mut out_buffer.as_mut_slice()
            )?;
        }

        let trace_size = out_buffer.get_trace_size() as usize;

        println!("Got trace size of {:#x} for process {:#x}", trace_size, process_handle);

        // setup to get ipt trace data
        let mut in_trace_buffer = InputBuffer::get_process_trace_data(process_handle);
        let mut ipt_trace_data = vec![0u8; trace_size];
        unsafe {
            let _ = device_io_control(
                self.device_handle,
                IPT_IOCTL_READ_TRACE,
                &mut in_trace_buffer.as_mut_slice(),
                &mut ipt_trace_data.as_mut_slice()
            )?;
        }

        println!("Got trace data for process {:#x}", process_handle);

        // parse trace data will read the IPT headers to find the actual size
        // of the trace packets
        self.parse_ipt_header(&ipt_trace_data, thread_id)?;

        // tag end of trace
        self.trace_buffer.push(0x55);
        Ok(&self.trace_buffer[..])
    }

    /// for debugging
    pub fn get_handle(&self) -> HANDLE {
        self.device_handle
    }

    /// Extract Intel PT data from Window ipt.sys metadata
    fn parse_ipt_header(
        &mut self, 
        header: &[u8], 
        thread_id: u32
    ) -> Result<()> {
        assert!(header.len() >= IPT_DATA_HEADER_LEN);

        // get the header for the overall packet
        let data_header = IptDataHeader::new(&header[0..8]);
        if data_header.is_valid() == false {
            return Err("Trace is invalid!");
        }

        // get the size of the remaining data
        let trace_buffer_size = data_header.get_trace_data_size();
        println!("IptDataHeader size: {:#x}", data_header.get_trace_data_size());

        let mut trace_header;
        let mut cursor = IPT_DATA_HEADER_LEN;

        while cursor <= (trace_buffer_size - IPT_TRACE_HEADER_LEN) {
            // get the header for the next trace
            trace_header = IptTraceHeader::new(
                &header[cursor..]);

            cursor += IPT_TRACE_HEADER_LEN;
            let data_offset = cursor;
            cursor += trace_header.get_trace_size();
            println!("IptTraceHeader size: {:#x}", trace_header.get_trace_size());

            println!("Got thread id {:#x}, target: {:#x}", trace_header.get_thread_id64(), thread_id);
            if trace_header.get_thread_id64() == thread_id as u64 {
                // extract the trace data and add it to the buffer
                self.extract_ipt_trace_data(
                    &trace_header, 
                    &header[data_offset..cursor]
                )?;
            }

            cursor += trace_header.get_trace_size();
        }

        Ok(())
    }

    fn extract_ipt_trace_data(
        &mut self, 
        header: &IptTraceHeader, 
        trace: &[u8]
    ) -> Result<()> {
        // trace has not overflowed
        if header.get_ringbuffer_offset() > self.trace_buffer.len() {
            self.append_trace_data(trace);
            Ok(())
        } else {
            Err("Trace overflowed!")
        }
    }

    fn append_trace_data(
        &mut self,
        data: &[u8]
    ) {
        // if there is space remaining, push the trace data onto the buffer
        if self.trace_buffer.len() + data.len() < self.trace_buffer_max {
            self.trace_buffer.extend_from_slice(data);
        } else {
            let remaining = self.trace_buffer_max - self.trace_buffer.len();
            // only take what we can fit
            self.trace_buffer.extend_from_slice(&data[..remaining]);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn get_version() {
        let opt = IptOptions::default();
        let controller = IptController::create_controller(opt).unwrap();
        let version = controller.get_ipt_version().unwrap();
        println!("VERSION: {:x}", version);
        assert_eq!(1, version);
    }
}

```

`src/ipt/ipt_options.rs`:

```rs
#![allow(non_upper_case_globals)]
/// Code for handling the Ipt Options bitfield structure, including getters/setters for
/// each option. 
/// 
/// Above attribute is to allow a find/replace macro to generate the these methods automatically 
/// while using lowercase method names, and the constants themselves are private anyway.
use std::{fmt, arch::asm};
use paste::paste;

/// u64 bitfield representing the user configurable features of the IPT.SYS driver
#[derive(Clone, Copy)]
pub struct IptOptions {
    inner: u64,
}

/// Pretty print all options with hex values
impl fmt::Debug for IptOptions {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("IptOptions")
        .field("Raw value", &format_args!("{:#x}", &self.inner))
        .field("OptionVersion", &format_args!("{:#x}", &self.get_version()))
        .field("TimingSettings", &format_args!("{:#x}", &self.get_timing()))
        .field("MtcFrequency ", &format_args!("{:#x}", &self.get_mtc()))
        .field("CycThreshold ", &format_args!("{:#x}", &self.get_cyc()))
        .field("TopaPagesPow2", &format_args!("{:#x}", &self.get_topa()))
        .field("MatchSettings", &format_args!("{:#x}", &self.get_matchs()))
        .field("Inherit", &format_args!("{:#x}", &self.get_inherit()))
        .field("ModeSettings ", &format_args!("{:#x}", &self.get_mode()))
        .finish()
    }
}

/// Always starts with version set to `1`
impl Default for IptOptions {
    fn default() -> Self {
        Self {
            inner: 1,
        }
    }
}

/// Macro to generate setters for the various option fields
macro_rules! set_option {
    ($option:ident) => {
    paste! {
            pub fn [<set_ $option>](&mut self, value: u64) -> () {
                // shift the new value up to the bit position it occupies in IptOptions
                let new_value: u64 = value << [<$option _SHIFT>];
                // capture the current value of the overall IptOptions
                let old_options = self.inner;
                // mask the current bits for the specified value to 0 the OR in the new value
                self.inner = (old_options & ![<$option _MASK>]) | new_value;
            }
        }
    }
}

/// Macro to generate getters for the various option fields
macro_rules! get_option {
    ($option:ident) => {
    paste! {
            pub fn [<get_ $option>](&self) -> u64 {
                // mask off the option's bits then shift them down to LSB
                return (self.inner & [<$option _MASK>]) >> [<$option _SHIFT>]
            }
        }
    }
}

/// Constants which allow for masking and shifting to LSB the option fields,
/// used with the above macros to generate methods
const version_MASK: u64 = 0xf;
const version_SHIFT: u64 = 0;

const timing_MASK: u64 = 0xf0;
const timing_SHIFT: u64 = 4;

const mtc_MASK: u64 = 0xf00;
const mtc_SHIFT: u64 = 8;

const cyc_MASK: u64 = 0xf000;
const cyc_SHIFT: u64 = 12;

const topa_MASK: u64 = 0xf_0000;
const topa_SHIFT: u64 = 16;

const matchs_MASK: u64 = 0x70_0000;
const matchs_SHIFT: u64 = 20;

const inherit_MASK: u64 = 0x80_0000;
const inherit_SHIFT: u64 = 23;

const mode_MASK: u64 = 0xF00_0000;
const mode_SHIFT: u64 = 24;

impl IptOptions {
    /// Get options field as a byte array
    pub fn to_le_bytes(&self) -> [u8; 8] {
        self.inner.to_le_bytes()
    }

    /// Create a new IptOptions with desired trace size. Performs checks on the size and will silently
    /// modify them to be within min/max allowed bounds. Can use `get_size_in_bytes`to check if
    /// modification has occurred.
    pub fn new(buffer_size: usize) -> Self {
        let mut options = IptOptions::default();
        let size;

        // Sanity check for the allowable sizes
        if buffer_size < 0x1000 {
            size = 0x1000;
        } else if buffer_size > 0x800_0000 {
            size = 0x800_0000;
        } else {
            size = buffer_size;
        }

        let mut size_bit_index;
        unsafe {
            // SAFETY: size cannot be zero 
            size_bit_index = bit_scan_reverse(size as u64);
        }

        // The minimum size is 0x1000 or b1_0000_0000_0000 (12th bit index) so we shift
        // the "size index" back by 12 to get the `TOPA` offset used by the IPT driver.
        size_bit_index -= 12;
        
        options.set_topa(size_bit_index);

        options
    }

    /// Get the configured trace size in number of bytes
    pub fn get_size_in_bytes(&self) -> usize {
        let topa = self.get_topa() as usize;
        
        // Add the `TOPA` offset back to the value to get the real bit index
        let bit_index: usize = topa + 12;

        // Shift by the index to get the trace size value in bytes
        return 1 << bit_index;
    }

    set_option!(version);
    get_option!(version);

    set_option!(timing);
    get_option!(timing);

    set_option!(mtc);
    get_option!(mtc);

    set_option!(cyc);
    get_option!(cyc);

    set_option!(topa);
    get_option!(topa);
    
    set_option!(matchs);
    get_option!(matchs);

    set_option!(inherit);
    get_option!(inherit);

    set_option!(mode);
    get_option!(mode);
}

/// Helper ASM function, we know the arch will always be x86 ;)
/// 
/// SAFETY: `src` should be checked by the caller to ensure it is > 0, 
/// and note this will clear the ZF.
/// 
/// See also: https://www.felixcloutier.com/x86/bsr
#[inline]
unsafe fn bit_scan_reverse(src: u64) -> u64 {
    let mut s = src;
    asm!(
        "bsr {s}, {s}",
        s = inout(reg) s,
    );

    s
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn version() {
        let mut opt = IptOptions::default();
        opt.set_version(0xf);
        assert_eq!(0xf, opt.get_version());
    }

    #[test]
    fn timing() {
        let mut opt = IptOptions::default();
        opt.set_timing(0xf);
        assert_eq!(0xf, opt.get_timing());
    }

    #[test]
    fn mtc() {
        let mut opt = IptOptions::default();
        opt.set_mtc(0xf);
        assert_eq!(0xf, opt.get_mtc());
    }

    #[test]
    fn cyc() {
        let mut opt = IptOptions::default();
        opt.set_cyc(0xf);
        assert_eq!(0xf, opt.get_cyc());
    }

    #[test]
    fn topa() {
        let mut opt = IptOptions::default();
        opt.set_topa(0xf);
        assert_eq!(0xf, opt.get_topa());
    }

    #[test]
    fn matchs() {
        let mut opt = IptOptions::default();
        opt.set_matchs(0xf);
        assert_eq!(0x7, opt.get_matchs());
    }

    #[test]
    fn inherit() {
        let mut opt = IptOptions::default();
        opt.set_inherit(0xf);
        assert_eq!(1, opt.get_inherit());
    }

    #[test]
    fn mode() {
        let mut opt = IptOptions::default();
        opt.set_mode(0xf);
        assert_eq!(0xf, opt.get_mode());
    }

    #[test]
    fn debug() {
        let mut opt = IptOptions::default();
        opt.set_version(0x1);
        opt.set_timing(0x1);
        opt.set_mtc(0x1);
        opt.set_cyc(0x1);
        opt.set_topa(0x1);
        opt.set_matchs(0x1);
        opt.set_inherit(0x1);
        opt.set_mode(0x1);
        // pretty print to check that none of the values have overflowed
        println!("{:#?}", opt);
    }

    #[test]
    fn bsr() {
        unsafe {
            let bits = 0x10u64;
            let msb = bit_scan_reverse(bits);
            assert_eq!(4, msb);
        }
    }

    #[test]
    fn topa_to_size() {
        let opt = IptOptions::new(0x1000);
        let size = opt.get_size_in_bytes();
        assert_eq!(size, 0x1000);
    }

}
```

`src/ipt/mod.rs`:

```rs
pub mod ipt_buffers;
pub mod ipt_controller;
pub mod ipt_options;
```

`src/lib.rs`:

```rs
pub mod ipt;
pub mod ffi;
```