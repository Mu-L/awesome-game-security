Project Path: arc_sapdragon_syscalls-cpp_1flb1fle

Source Tree:

```txt
arc_sapdragon_syscalls-cpp_1flb1fle
├── CMakeLists.txt
├── LICENSE
├── docs
│   └── images
│       └── protection_demo.gif
├── examples
│   ├── CMakeLists.txt
│   ├── basic-usage.cpp
│   └── custom-generator.cpp
├── include
│   └── syscalls-cpp
│       ├── crt.hpp
│       ├── hash.hpp
│       ├── native_api.hpp
│       ├── platform.hpp
│       ├── shared.hpp
│       └── syscall.hpp
├── readme.md
└── tests
    ├── CMakeLists.txt
    ├── test_crt.cpp
    ├── test_hash.cpp
    └── test_integration.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15)
project(syscalls-cpp VERSION 1.2.0 LANGUAGES CXX)

option(SYSCALL_CPP_BUILD_EXAMPLES "Build example executables" ${PROJECT_IS_TOP_LEVEL})
option(SYSCALL_CPP_BUILD_TESTS "Build tests" ${PROJECT_IS_TOP_LEVEL})

include(GNUInstallDirs)

add_library(${PROJECT_NAME} INTERFACE)
add_library(sapdragon::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
target_compile_features(${PROJECT_NAME} INTERFACE cxx_std_20)

target_include_directories(${PROJECT_NAME} INTERFACE
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
)

if (SYSCALL_CPP_BUILD_EXAMPLES)
    add_subdirectory(examples)
endif ()

if (SYSCALL_CPP_BUILD_TESTS)
    include(CTest)
    add_subdirectory(tests)
endif ()

install(
        DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/include/
        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
        FILES_MATCHING PATTERN "*.hpp"
)

install(
        TARGETS ${PROJECT_NAME}
        EXPORT ${PROJECT_NAME}-targets
)

install(
        EXPORT ${PROJECT_NAME}-targets
        FILE ${PROJECT_NAME}-config.cmake
        NAMESPACE sapdragon::
        DESTINATION share/${PROJECT_NAME}
)
```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Ivan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`examples/CMakeLists.txt`:

```txt
project(syscall_examples)

add_executable(basic_usage basic-usage.cpp)
target_link_libraries(basic_usage PRIVATE syscalls-cpp)
set_target_properties(basic_usage PROPERTIES CXX_STANDARD 20)

add_executable(custom_generator custom-generator.cpp)
target_link_libraries(custom_generator PRIVATE syscalls-cpp)
set_target_properties(custom_generator PROPERTIES CXX_STANDARD 20)
```

`examples/basic-usage.cpp`:

```cpp
#include <iostream>
#include <syscalls-cpp/syscall.hpp>
int main() 
{
    syscall::Manager<syscall::policies::allocator::section, syscall::policies::generator::direct> syscallManager;
    if (!syscallManager.initialize())
    {
        std::cerr << "initialization failed!\n";
        return 1;
    }

    PVOID pBaseAddress = nullptr;
    SIZE_T uSize = 0x1000;

    std::ignore = syscallManager.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        0, &uSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    if (pBaseAddress)
        std::cout << "allocation successful at 0x" << pBaseAddress << std::endl;

    return 0;
}
```

`examples/custom-generator.cpp`:

```cpp
#pragma warning(disable : 4146) // neg for unsigned

#include <syscalls-cpp/syscall.hpp>

#include <iostream>
#include <cstdint>
#include <array>
#include <vector>
#include <random>
#include <functional>
#include <chrono>
#include <initializer_list>
#include <cstring> 

class CBufferWriter 
{
public:
    CBufferWriter(uint8_t* buffer, size_t size) : m_pStart(buffer), m_pCurrent(buffer), m_pEnd(buffer + size) 
    {

    }

    template<typename T>
    void write(T value) 
    {
        if (m_pCurrent + sizeof(T) <= m_pEnd)
        {
            *reinterpret_cast<T*>(m_pCurrent) = value;
            m_pCurrent += sizeof(T);
        }
    }

    void writeBytes(std::initializer_list<uint8_t> listBytes) {
        if (m_pCurrent + listBytes.size() <= m_pEnd) 
        {
            memcpy(m_pCurrent, listBytes.begin(), listBytes.size());
            m_pCurrent += listBytes.size();
        }
    }

    size_t getCurrentSize() const {
        return m_pCurrent - m_pStart;
    }

    void fillRest(uint8_t uValue) 
    {
        if (m_pCurrent < m_pEnd) {
            memset(m_pCurrent, uValue, m_pEnd - m_pCurrent);
        }
    }

private:
    uint8_t* m_pStart;
    uint8_t* m_pCurrent;
    const uint8_t* m_pEnd;
};


struct EncryptedShellGenerator
{
    static constexpr bool bRequiresGadget = false;
    static constexpr size_t kMaxStubSize = 128;

private:
    enum class EOperationType { ADD, SUB, XOR, NOT, NEG, ROL, ROR };

    struct ObfuscationLayer_t
    {
        EOperationType m_eType;
        uint32_t m_uKey;
    };

    inline static std::mt19937 randEngine{ static_cast<unsigned int>(std::chrono::high_resolution_clock::now().time_since_epoch().count()) };

public:
    static void generate(uint8_t* pBuffer, uint32_t uSyscallNumber, void* /*pGadgetAddress*/)
    {
        CBufferWriter writer(pBuffer, kMaxStubSize);

        std::uniform_int_distribution<> operationDist(0, 6);
        std::uniform_int_distribution<uint32_t> keyDist(1, 0xFFFFFFFF);
        std::uniform_int_distribution<> layersDist(4, 8);

        const int iAmountOfLayers = layersDist(randEngine);
        std::vector<ObfuscationLayer_t> vecLayers;
        vecLayers.reserve(iAmountOfLayers);

        for (int i = 0; i < iAmountOfLayers; ++i)
        {
            EOperationType operationType = static_cast<EOperationType>(operationDist(randEngine));
            uint32_t uKey = 0;

            if (operationType == EOperationType::ROL || operationType == EOperationType::ROR)
                uKey = keyDist(randEngine) % 31 + 1;
            else if (operationType != EOperationType::NOT && operationType != EOperationType::NEG)
            {
                uKey = keyDist(randEngine);

                if (uKey == 0)
                    uKey = 1;
            }

            vecLayers.push_back({ operationType, uKey });
        }
        uint32_t uEncryptedValue = uSyscallNumber;
        for (auto it = vecLayers.rbegin(); it != vecLayers.rend(); ++it)
        {
            const auto& layer = *it;
            switch (layer.m_eType)
            {
                case EOperationType::ADD: uEncryptedValue -= layer.m_uKey; break;
                case EOperationType::SUB: uEncryptedValue += layer.m_uKey; break;
                case EOperationType::XOR: uEncryptedValue ^= layer.m_uKey; break;
                case EOperationType::NOT: uEncryptedValue = ~uEncryptedValue; break;
                case EOperationType::NEG: uEncryptedValue = -uEncryptedValue; break;
                case EOperationType::ROL: uEncryptedValue = (uEncryptedValue >> layer.m_uKey) | (uEncryptedValue << (32 - layer.m_uKey)); break; // ROR
                case EOperationType::ROR: uEncryptedValue = (uEncryptedValue << layer.m_uKey) | (uEncryptedValue >> (32 - layer.m_uKey)); break; // ROL
            }
        }

        writer.writeBytes({ 0x51, 0x41, 0x5A });     // push rcx; pop r10

        writer.write<uint8_t>(0xB8);                // mov eax, ...
        writer.write<uint32_t>(uEncryptedValue);    // ... encryptedValue

        emitJunk(writer);

        for (const auto& layer : vecLayers)
        {
            switch (layer.m_eType) {
            case EOperationType::ADD:
                writer.write<uint8_t>(0x05);    // add eax, key
                writer.write<uint32_t>(layer.m_uKey);
                break;
            case EOperationType::SUB:
                writer.write<uint8_t>(0x2D);    // sub eax, key
                writer.write<uint32_t>(layer.m_uKey);
                break;
            case EOperationType::XOR:
                writer.write<uint8_t>(0x35);    // xor eax, key
                writer.write<uint32_t>(layer.m_uKey);
                break;
            case EOperationType::NOT:
                writer.writeBytes({ 0xF7, 0xD0 }); // not eax
                break;
            case EOperationType::NEG:
                writer.writeBytes({ 0xF7, 0xD8 }); // neg eax
                break;
            case EOperationType::ROL:
                writer.writeBytes({ 0xC1, 0xC0 }); // rol eax, key
                writer.write<uint8_t>(static_cast<uint8_t>(layer.m_uKey));
                break;
            case EOperationType::ROR:
                writer.writeBytes({ 0xC1, 0xC8 }); // ror eax, key
                writer.write<uint8_t>(static_cast<uint8_t>(layer.m_uKey));
                break;
            }

            emitJunk(writer);
        }

        writer.writeBytes({ 0x0F, 0x05 });                  // syscall
        writer.writeBytes({ 0x48, 0x83, 0xC4, 0x08 });     // add rsp 8
        writer.writeBytes({ 0xFF, 0x64, 0x24, 0xF8 });     // jmp qword ptr [rsp-8]

        writer.fillRest(0xCC); // int3
    }

    static constexpr size_t getStubSize() { return kMaxStubSize; }
private:
    static void emitJunk(CBufferWriter& writer)
    {
        std::uniform_int_distribution<> junkDist(0, 5);
        int iJunkType = junkDist(randEngine);

        const uint8_t uREXW = 0x48;
        const std::array<uint8_t, 6> arrPushOpcodes = { 0x50, 0x51, 0x52, 0x53, 0x56, 0x57 };
        const std::array<uint8_t, 6> arrPopOpcodes = { 0x58, 0x59, 0x5A, 0x5B, 0x5E, 0x5F };

        const std::array<uint8_t, 6> arrIncDecNegModRM = { 0xC0, 0xC1, 0xC2, 0xC3, 0xC6, 0xC7 };
        const std::array<uint8_t, 6> arrLeaModRM = { 0x40, 0x49, 0x52, 0x5B, 0x76, 0x7F };
        std::uniform_int_distribution<> regDist(0, arrPushOpcodes.size() - 1);
        int iRegIdx = regDist(randEngine);

        switch (iJunkType)
        {
            case 0:
                // nop
                writer.write<uint8_t>(0x90);
                break;

            case 1:
                // push rXX; pop rXX
                writer.write<uint8_t>(arrPushOpcodes[iRegIdx]);
                writer.write<uint8_t>(arrPopOpcodes[iRegIdx]);
                break;

            case 2:
                // pushfq
                writer.write<uint8_t>(0x9C);
                // inc rXX
                writer.writeBytes({ uREXW, 0xFF, arrIncDecNegModRM[iRegIdx] });
                // dec rXX
                writer.writeBytes({ uREXW, 0xFF, (uint8_t)(arrIncDecNegModRM[iRegIdx] + 0x08) });
                // popfq
                writer.write<uint8_t>(0x9D);
                break;

            case 3:
                // lea rXX, [rXX + 0x00]
                writer.writeBytes({ uREXW, 0x8D, arrLeaModRM[iRegIdx], 0x00 });
                break;

            case 4:
            {
                // pushfq
                writer.write<uint8_t>(0x9C);

                std::uniform_int_distribution<uint32_t> valDist;
                uint32_t uRandomVal = valDist(randEngine);

                // xor rXX, imm32
                writer.writeBytes({ uREXW, 0x81, (uint8_t)(0xF0 + iRegIdx) });
                writer.write<uint32_t>(uRandomVal);

                // xor rXX, imm32 
                writer.writeBytes({ uREXW, 0x81, (uint8_t)(0xF0 + iRegIdx) });
                writer.write<uint32_t>(uRandomVal);

                // popfq
                writer.write<uint8_t>(0x9D);
            }
            break;

            case 5:
                break;
        }
    }
};

int main() 
{
    syscall::Manager < syscall::policies::allocator::section, EncryptedShellGenerator> syscallManager;
    if (!syscallManager.initialize()) 
    {
        std::cerr << "failed to initialize syscall manager" << std::endl;
        return 1;
    }

    std::cout << "syscall manager initialized successfully" << std::endl;

    NTSTATUS status;
    PVOID pBaseAddress = nullptr;
    SIZE_T uSize = 0x1000;

    status = syscallManager.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        0,
        &uSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    if(pBaseAddress)
        std::cout << "memory allocated: " << pBaseAddress;
    else
        std::cout << "failed to allocate, status:" << status;

    return 0;
}
```

`include/syscalls-cpp/crt.hpp`:

```hpp
#ifndef SYSCALL_CRT_HPP
#define SYSCALL_CRT_HPP

#include <algorithm>
#include <cstdint>
#include <cwchar>
#include <string>
#include <iterator>

namespace syscall::crt
{
    template<typename T, size_t N>
    [[nodiscard]] constexpr size_t getCountOf(T(&arr)[N]) noexcept
    {
        return std::size(arr);
    }

    namespace string
    {
        [[nodiscard]] constexpr char toLower(char c) noexcept
        {
            return (c >= 'A' && c <= 'Z') ? (c + ('a' - 'A')) : c;
        }

        [[nodiscard]] constexpr wchar_t toLower(wchar_t c) noexcept
        {
            return (c >= L'A' && c <= L'Z') ? (c + (L'a' - L'A')) : c;
        }

        [[nodiscard]] constexpr size_t getLength(const char* szStr) noexcept
        {
            return std::char_traits<char>::length(szStr);
        }

        [[nodiscard]] constexpr size_t getLength(const wchar_t* wzStr) noexcept
        {
            return std::char_traits<wchar_t>::length(wzStr);
        }

        [[nodiscard]] constexpr int compareIgnoreCase(const wchar_t* szFirst, const wchar_t* szSecond) noexcept
        {
            wchar_t c1, c2;
            do {
                c1 = toLower(*szFirst++);
                c2 = toLower(*szSecond++);

                if (c1 == L'\0') 
                    return c1 - c2;
            } while (c1 == c2);

            return c1 - c2;
        }

        inline void concat(wchar_t* pDest, size_t uSizeInElements, const wchar_t* pSource) noexcept
        {
            if (!pDest || !uSizeInElements)
                return;

            const size_t uDestLength = getLength(pDest);
            if (uDestLength >= uSizeInElements - 1)
                return;


            const size_t uSourceLength = getLength(pSource);
            const size_t uRemainingSpace = uSizeInElements - uDestLength - 1;
            const size_t uCount = (uSourceLength < uRemainingSpace) ? uSourceLength : uRemainingSpace;

            std::copy_n(pSource, uCount, pDest + uDestLength);
            pDest[uDestLength + uCount] = L'\0';
        }

        inline void mbToWcs(wchar_t* pDest, size_t uSizeInElements, const char* pSource) noexcept
        {
            if (!pDest || !uSizeInElements)
                return;

            const size_t uSourceLength = getLength(pSource);
            const size_t uCount = (uSourceLength < uSizeInElements) ? uSourceLength : (uSizeInElements - 1);
            for (size_t i = 0; i < uCount; ++i)
                pDest[i] = static_cast<wchar_t>(static_cast<unsigned char>(pSource[i]));

            pDest[uCount] = L'\0';
        }
    }
}

#endif

```

`include/syscalls-cpp/hash.hpp`:

```hpp
#ifndef HASHING_HPP
#define HASHING_HPP

#include <cstdint>
#include <string>
#include <string_view>
#include <bit>

namespace syscall::hashing
{
    using Hash_t = uint64_t;

    constexpr Hash_t getCompileTimeSeed()
    {
        Hash_t seed = 0;
        const char* szCurrentTime = __TIME__;
        const char* szCurrentDate = __DATE__;

        for (int i = 0; szCurrentTime[i] != '\0'; ++i) 
            seed = std::rotr(seed, 3) + szCurrentTime[i];

        for (int i = 0; szCurrentDate[i] != '\0'; ++i) 
            seed = std::rotr(seed, 5) + szCurrentDate[i];

        return seed;
    }

    constexpr Hash_t currentSeed = getCompileTimeSeed();
    constexpr Hash_t polyKey1 = 0xAF6F01BD5B2D7583ULL ^ currentSeed;
    constexpr Hash_t polyKey2 = 0xB4F281729182741DULL ^ std::rotr(currentSeed, 7);

    consteval Hash_t calculateHash(const char* szData)
    {
        Hash_t hash = polyKey1;
        while (*szData)
        {
            hash ^= static_cast<Hash_t>(*szData++);
            hash += std::rotr(hash, 11) + polyKey2;
        }
        return hash;
    }

    consteval Hash_t calculateHash(const char* szData, size_t uLength)
    {
        Hash_t hash = polyKey1;
        for (size_t i = 0; i < uLength && szData[i]; ++i)
        {
            hash ^= static_cast<Hash_t>(szData[i]);
            hash += std::rotr(hash, 11) + polyKey2;
        }
        return hash;
    }


    inline Hash_t calculateHashRuntime(const char* szData)
    {
        Hash_t hash = polyKey1;
        while (*szData)
        {
            hash ^= static_cast<Hash_t>(*szData++);
            hash += std::rotr(hash, 11) + polyKey2;
        }
        return hash;
    }

    inline Hash_t calculateHashRuntime(const char* szData, size_t uLength)
    {
        Hash_t hash = polyKey1;
        for (size_t i = 0; i < uLength && szData[i]; ++i)
        {
            hash ^= static_cast<Hash_t>(szData[i]);
            hash += std::rotr(hash, 11) + polyKey2;
        }
        return hash;
    }

    inline Hash_t calculateHashRuntime(std::string_view sv)
    {
        Hash_t hash = polyKey1;
        for (char c : sv)
        {
            hash ^= static_cast<Hash_t>(c);
            hash += std::rotr(hash, 11) + polyKey2;
        }
        return hash;
    }
}

#ifdef SYSCALLS_NO_HASH
#define SYSCALL_ID(str) (str)
#define SYSCALL_ID_RT(str) (str)
#else
#define SYSCALL_ID(str) (syscall::hashing::calculateHash(str))
#define SYSCALL_ID_RT(str) (syscall::hashing::calculateHashRuntime(str))

#endif

#endif
```

`include/syscalls-cpp/native_api.hpp`:

```hpp
#ifndef NATIVE_API_HPP
#define NATIVE_API_HPP

#include "shared.hpp"
#include "crt.hpp"
#include "hash.hpp"
#include <cstdint>
#include <cwchar>

namespace syscall::native
{
    // @todo / sapdragon: we need refactoring here.
    inline void* getExportAddress(HMODULE hModuleBase, const char* szExportName);
    inline void* getExportAddress(HMODULE hModuleBase, hashing::Hash_t uExportHash);

    namespace detail
    {
        inline hashing::Hash_t appendDllExtensionToHash(hashing::Hash_t uHash)
        {
            uHash ^= static_cast<hashing::Hash_t>('.');
            uHash += std::rotr(uHash, 11) + hashing::polyKey2;
            uHash ^= static_cast<hashing::Hash_t>('d');
            uHash += std::rotr(uHash, 11) + hashing::polyKey2;
            uHash ^= static_cast<hashing::Hash_t>('l');
            uHash += std::rotr(uHash, 11) + hashing::polyKey2;
            uHash ^= static_cast<hashing::Hash_t>('l');
            uHash += std::rotr(uHash, 11) + hashing::polyKey2;
            
            return uHash;
        }

        struct ForwarderInfo_t
        {
            char  m_szDllName[256];
            char* m_pszFuncName;
        };


        inline bool parseForwarderString(const uint8_t* pBase, uint32_t uFunctionRva, ForwarderInfo_t& outInfo)
        {
            const char* szSrc     = reinterpret_cast<const char*>(pBase + uFunctionRva);
            char*       szDest    = outInfo.m_szDllName;
            const char* szDestEnd = szDest + sizeof(outInfo.m_szDllName) - 1;
            char*       pszDot    = nullptr;

            while (szDest < szDestEnd && (*szDest = *szSrc++))
            {
                if (*szDest == '.')
                    pszDot = szDest;

                szDest++;
            }

            *szDest = '\0';

            if (!pszDot || pszDot == outInfo.m_szDllName)
                return false;

            *pszDot = '\0';
            
            outInfo.m_pszFuncName = pszDot + 1;

            return true;
        }
    }

    inline PPEB getCurrentPEB()
    {
#if SYSCALL_PLATFORM_WINDOWS_64
        return (PEB*)(__readgsqword(0x60));
#elif SYSCALL_PLATFORM_WINDOWS_32
        return (PEB*)(__readfsdword(0x30));
#endif
    }

    inline hashing::Hash_t calculateHashRuntimeCi(const wchar_t* wzData)
    {
        if (!wzData)
            return 0;

        hashing::Hash_t hash = hashing::polyKey1;
        wchar_t wcCurrent = 0;

        while ((wcCurrent = *wzData++))
        {
            char cAnsiChar = static_cast<char>(crt::string::toLower(wcCurrent));
            hash ^= static_cast<hashing::Hash_t>(cAnsiChar);
            hash += std::rotr(hash, 11) + hashing::polyKey2;
        }
        return hash;
    }

    inline hashing::Hash_t calculateHashRuntimeCi(const char* szData)
    {
        if (!szData)
            return 0;

        hashing::Hash_t hash = hashing::polyKey1;
        char cCurrent = 0;

        while ((cCurrent = *szData++))
        {
            char cLower = crt::string::toLower(cCurrent);
            hash ^= static_cast<hashing::Hash_t>(cLower);
            hash += std::rotr(hash, 11) + hashing::polyKey2;
        }
        return hash;
    }

    inline HMODULE getModuleBase(const wchar_t* wzModuleName)
    {
        if (!wzModuleName)
            return nullptr;

        auto pPeb = getCurrentPEB();
        if (!pPeb || !pPeb->Ldr)
            return nullptr;

        auto pLdrData = pPeb->Ldr;
        auto pListHead = &pLdrData->InMemoryOrderModuleList;
        auto pCurrentEntry = pListHead->Flink;

        while (pCurrentEntry != pListHead)
        {
            auto pEntry = CONTAINING_RECORD(pCurrentEntry, native::LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
            if (pEntry->BaseDllName.Buffer && crt::string::compareIgnoreCase(pEntry->BaseDllName.Buffer, wzModuleName) == 0)
                return reinterpret_cast<HMODULE>(pEntry->DllBase);

            pCurrentEntry = pCurrentEntry->Flink;
        }
        return nullptr;
    }

    inline HMODULE getModuleBase(hashing::Hash_t uModuleHash)
    {
        auto pPeb = getCurrentPEB();
        if (!pPeb || !pPeb->Ldr)
            return nullptr;

        auto pLdrData = pPeb->Ldr;
        auto pListHead = &pLdrData->InMemoryOrderModuleList;
        auto pCurrentEntry = pListHead->Flink;

        while (pCurrentEntry != pListHead)
        {
            auto pEntry = CONTAINING_RECORD(pCurrentEntry, native::LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
            if (pEntry->BaseDllName.Buffer && calculateHashRuntimeCi(pEntry->BaseDllName.Buffer) == uModuleHash)
                return reinterpret_cast<HMODULE>(pEntry->DllBase);

            pCurrentEntry = pCurrentEntry->Flink;
        }
        return nullptr;
    }

    inline void* getExportAddress(HMODULE hModuleBase, const char* szExportName)
    {
        if (!hModuleBase || !szExportName)
            return nullptr;

        auto pBase = reinterpret_cast<uint8_t*>(hModuleBase);
        auto pDosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(pBase);
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
            return nullptr;

        auto pNtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(pBase + pDosHeader->e_lfanew);
        if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE)
            return nullptr;

        auto uExportDirRva = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (!uExportDirRva) return nullptr;

        auto pExportDir = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(pBase + uExportDirRva);
        auto pNamesRVA = reinterpret_cast<uint32_t*>(pBase + pExportDir->AddressOfNames);
        auto pOrdinalsRVA = reinterpret_cast<uint16_t*>(pBase + pExportDir->AddressOfNameOrdinals);
        auto pFunctionsRVA = reinterpret_cast<uint32_t*>(pBase + pExportDir->AddressOfFunctions);

        for (uint32_t i = 0; i < pExportDir->NumberOfNames; ++i)
        {
            auto szCurrentProcName = reinterpret_cast<const char*>(pBase + pNamesRVA[i]);

            if (std::string_view{szCurrentProcName} != std::string_view{szExportName})
                continue;

            const uint16_t usOrdinal = pOrdinalsRVA[i];
            const uint32_t uFunctionRva = pFunctionsRVA[usOrdinal];
            auto uExportSectionStart = uExportDirRva;
            auto uExportSectionEnd = uExportSectionStart + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

            if (uFunctionRva < uExportSectionStart || uFunctionRva >= uExportSectionEnd)
                return pBase + uFunctionRva;

            detail::ForwarderInfo_t forwarderInfo;
            if (!detail::parseForwarderString(pBase, uFunctionRva, forwarderInfo))
                return nullptr;

            hashing::Hash_t uForwarderDllHash = calculateHashRuntimeCi(forwarderInfo.m_szDllName);
            if (!uForwarderDllHash) 
                return nullptr;

            uForwarderDllHash = detail::appendDllExtensionToHash(uForwarderDllHash);

            HMODULE hForwarderModuleBase = getModuleBase(uForwarderDllHash);
            if (!hForwarderModuleBase) 
                return nullptr;

            hashing::Hash_t uForwarderFuncHash = hashing::calculateHashRuntime(forwarderInfo.m_pszFuncName);
            return getExportAddress(hForwarderModuleBase, uForwarderFuncHash);
        }
        return nullptr;
    }

    inline void* getExportAddress(HMODULE hModuleBase, hashing::Hash_t uExportHash)
    {
        if (!hModuleBase)
            return nullptr;

        auto pBase = reinterpret_cast<uint8_t*>(hModuleBase);
        auto pDosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(pBase);
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
            return nullptr;

        auto pNtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(pBase + pDosHeader->e_lfanew);
        if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE)
            return nullptr;

        auto uExportDirRva = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (!uExportDirRva)
            return nullptr;

        auto pExportDir = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(pBase + uExportDirRva);
        auto pNamesRVA = reinterpret_cast<uint32_t*>(pBase + pExportDir->AddressOfNames);
        auto pOrdinalsRVA = reinterpret_cast<uint16_t*>(pBase + pExportDir->AddressOfNameOrdinals);
        auto pFunctionsRVA = reinterpret_cast<uint32_t*>(pBase + pExportDir->AddressOfFunctions);

        for (uint32_t i = 0; i < pExportDir->NumberOfNames; ++i)
        {
            const char* szCurrentProcName = reinterpret_cast<const char*>(pBase + pNamesRVA[i]);

            if (hashing::calculateHashRuntime(szCurrentProcName) != uExportHash)
                continue;

            uint16_t usOrdinal = pOrdinalsRVA[i];
            uint32_t uFunctionRva = pFunctionsRVA[usOrdinal];
            auto uExportSectionStart = uExportDirRva;
            auto uExportSectionEnd = uExportSectionStart + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

            if (uFunctionRva < uExportSectionStart || uFunctionRva >= uExportSectionEnd)
                return pBase + uFunctionRva;

            detail::ForwarderInfo_t forwarderInfo;
            if (!detail::parseForwarderString(pBase, uFunctionRva, forwarderInfo))
                return nullptr;

            hashing::Hash_t uForwarderDllHash = calculateHashRuntimeCi(forwarderInfo.m_szDllName);
            if (!uForwarderDllHash) 
                return nullptr;

            uForwarderDllHash = detail::appendDllExtensionToHash(uForwarderDllHash);

            const HMODULE hForwarderModuleBase = getModuleBase(uForwarderDllHash);
            if (!hForwarderModuleBase) 
                return nullptr;
                
            return getExportAddress(hForwarderModuleBase, forwarderInfo.m_pszFuncName);
        }
        return nullptr;
    }

    SYSCALL_FORCE_INLINE uint64_t rdtscp()
    {
        unsigned int uProcessorId;
#if SYSCALL_COMPILER_MSVC
        return __rdtscp(&uProcessorId);
#elif SYSCALL_COMPILER_GCC || SYSCALL_COMPILER_CLANG
        return __builtin_ia32_rdtscp(&uProcessorId);
#else
#error "Compiler not supported for RDTSCP intrinsic"
#endif
    }
}

#endif
```

`include/syscalls-cpp/platform.hpp`:

```hpp
#ifndef _SYSCALL_PLATFORM_HPP_
#define _SYSCALL_PLATFORM_HPP_

#if defined(_WIN64)
#define SYSCALL_PLATFORM_WINDOWS 1
#define SYSCALL_PLATFORM_WINDOWS_64 1
#define SYSCALL_PLATFORM_WINDOWS_32 0
#elif defined(_WIN32)
#define SYSCALL_PLATFORM_WINDOWS 1
#define SYSCALL_PLATFORM_WINDOWS_64 0
#define SYSCALL_PLATFORM_WINDOWS_32 1
#else
#define SYSCALL_PLATFORM_WINDOWS 0
#endif

#if defined(__linux__)
#define SYSCALL_PLATFORM_LINUX 1
#else
#define SYSCALL_PLATFORM_LINUX 0
#endif

#if defined(_MSC_VER)
#define SYSCALL_COMPILER_MSVC 1
#else
#define SYSCALL_COMPILER_MSVC 0
#endif

#if defined(__clang__)
#define SYSCALL_COMPILER_CLANG 1
#else
#define SYSCALL_COMPILER_CLANG 0
#endif

#if defined(__GNUC__) && !SYSCALL_COMPILER_CLANG
#define SYSCALL_COMPILER_GCC 1
#else
#define SYSCALL_COMPILER_GCC 0
#endif

#if SYSCALL_PLATFORM_WINDOWS_64
#define SYSCALL_API __stdcall
#else
#define SYSCALL_API __cdecl
#endif

#if SYSCALL_COMPILER_MSVC
#define SYSCALL_FORCE_INLINE __forceinline
#elif SYSCALL_COMPILER_GCC || SYSCALL_COMPILER_CLANG
#define SYSCALL_FORCE_INLINE inline __attribute__((always_inline))
#else
#define SYSCALL_FORCE_INLINE inline
#endif

namespace syscall::platform
{
    constexpr bool isWindows = (SYSCALL_PLATFORM_WINDOWS == 1);
    constexpr bool isWindows64 = (SYSCALL_PLATFORM_WINDOWS_64 == 1);
    constexpr bool isWindows32 = (SYSCALL_PLATFORM_WINDOWS_32 == 1);
    constexpr bool isLinux = (SYSCALL_PLATFORM_LINUX == 1);

    constexpr bool isMSVC = (SYSCALL_COMPILER_MSVC == 1);
    constexpr bool IsClang = (SYSCALL_COMPILER_CLANG == 1);
    constexpr bool IsGCC = (SYSCALL_COMPILER_GCC == 1);

    static_assert(isWindows, "Unsupported OS");
    static_assert(isMSVC || IsClang || IsGCC, "Unsupported compiler");
}

#endif
```

`include/syscalls-cpp/shared.hpp`:

```hpp
#ifndef _SYSCALL_SHARED_HPP_
#define _SYSCALL_SHARED_HPP_

#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <Windows.h>
#include <winternl.h>

#include "platform.hpp"

namespace syscall::native
{

    [[nodiscard]] constexpr bool isSuccess(NTSTATUS status) noexcept
    {
        return status >= 0;
    }

    
    [[nodiscard]] constexpr HANDLE getCurrentProcess() noexcept
    {
        return reinterpret_cast<HANDLE>(-1);
    }

    enum class ESectionInherit : DWORD 
    {
        VIEW_SHARE = 1,
        VIEW_UNMAP = 2
    };

    enum class ESectionAllocAttributes : ULONG 
    {
        SECTION_COMMIT = SEC_COMMIT,
        SECTION_IMAGE = SEC_IMAGE,
        SECTION_IMAGE_NO_EXECUTE = SEC_IMAGE_NO_EXECUTE,
        SECTION_LARGE_PAGES = SEC_LARGE_PAGES,
        SECTION_NO_CHANGE = 0x00400000, 
        SECTION_RESERVE = SEC_RESERVE,
    };

    struct LDR_DATA_TABLE_ENTRY
    {
        LIST_ENTRY InLoadOrderLinks;
        LIST_ENTRY InMemoryOrderLinks;
        LIST_ENTRY InInitializationOrderLinks;
        PVOID DllBase;
        PVOID EntryPoint;
        ULONG SizeOfImage;
        UNICODE_STRING FullDllName;
        UNICODE_STRING BaseDllName;
        ULONG Flags;
        USHORT LoadCount;
        USHORT TlsIndex;
        union {
            LIST_ENTRY HashLinks;
            struct {
                PVOID SectionPointer;
                ULONG CheckSum;
            };
        };
        union {
            ULONG TimeDateStamp;
            PVOID LoadedImports;
        };
        _ACTIVATION_CONTEXT* EntryPointActivationContext;
        PVOID PatchInformation;
        LIST_ENTRY ForwarderLinks;
        LIST_ENTRY ServiceTagLinks;
        LIST_ENTRY StaticLinks;
        PVOID ContextInformation;
        ULONG_PTR OriginalBase;
        LARGE_INTEGER LoadTime;
    };

    using NtCreateSection_t = NTSTATUS(NTAPI*)(
        PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes,
        PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle
        );

    using NtMapViewOfSection_t = NTSTATUS(NTAPI*)(
        HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress,
        ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset,
        PSIZE_T ViewSize, ESectionInherit InheritDisposition, ULONG AllocationType, ULONG Win32Protect
        );

    using NtUnmapViewOfSection_t = NTSTATUS(NTAPI*)(HANDLE ProcessHandle, PVOID BaseAddress);

    using NtAllocateVirtualMemory_t = NTSTATUS(NTAPI*)(
        HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits,
        PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect
        );

    using NtProtectVirtualMemory_t = NTSTATUS(NTAPI*)(
        HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize,
        ULONG NewProtect, PULONG OldProtect
        );

    using NtFreeVirtualMemory_t = NTSTATUS(NTAPI*)(
        HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG FreeType
        );

    using NtClose_t = NTSTATUS(NTAPI*)(HANDLE Handle);
    using RtlCreateHeap_t = PVOID(NTAPI*)(ULONG Flags, PVOID HeapBase, SIZE_T ReserveSize, SIZE_T CommitSize, PVOID Lock, PVOID Parameters);
    using RtlAllocateHeap_t = PVOID(NTAPI*)(PVOID HeapHandle, ULONG Flags, SIZE_T Size);
    using RtlDestroyHeap_t = PVOID(NTAPI*)(PVOID HeapHandle);

    constexpr NTSTATUS STATUS_SUCCESS = 0x00000000L;
    constexpr NTSTATUS STATUS_UNSUCCESSFUL = 0xC0000001L;
    constexpr NTSTATUS STATUS_PROCEDURE_NOT_FOUND = 0xC000007A;

} // syscall::native

#endif
```

`include/syscalls-cpp/syscall.hpp`:

```hpp
#ifndef SYSCALL_HPP
#define SYSCALL_HPP

#include <cstdint>
#include <string>
#include <vector>
#include <unordered_map>
#include <optional>
#include <fstream>
#include <mutex>
#include <cstring>
#include <utility>
#include <concepts> 
#include <array>
#include <random>
#include <algorithm>
#include <ranges>
#include <span>

#include "shared.hpp"
#include "hash.hpp"
#include "native_api.hpp"


namespace syscall
{

    struct ModuleInfo_t
    {
        uint8_t* m_pModuleBase = nullptr;
        IMAGE_NT_HEADERS* m_pNtHeaders = nullptr;
        IMAGE_EXPORT_DIRECTORY* m_pExportDir = nullptr;
    };

#ifdef SYSCALLS_NO_HASH
    using SyscallKey_t = std::string;
#else
    using SyscallKey_t = hashing::Hash_t;
#endif

    struct SyscallEntry_t
    {
        SyscallKey_t m_key;
        uint32_t m_uSyscallNumber;
        uint32_t m_uOffset;
    };


    inline thread_local struct ExceptionContext_t
    {
        bool m_bShouldHandle = false;
        const void* m_pExpectedExceptionAddress = nullptr;
        void* m_pSyscallGadget = nullptr;
        uint32_t m_uSyscallNumber = 0;
    } pExceptionContext;

    class CExceptionContextGuard
    {
    public:
        CExceptionContextGuard(const void* pExpectedAddress, void* pSyscallGadget, uint32_t uSyscallNumber)
        {
            pExceptionContext.m_bShouldHandle = true;
            pExceptionContext.m_pExpectedExceptionAddress = pExpectedAddress;
            pExceptionContext.m_pSyscallGadget = pSyscallGadget;
            pExceptionContext.m_uSyscallNumber = uSyscallNumber;
        }

        ~CExceptionContextGuard()
        {
            pExceptionContext.m_bShouldHandle = false;
        }

        CExceptionContextGuard(const CExceptionContextGuard&) = delete;
        CExceptionContextGuard& operator=(const CExceptionContextGuard&) = delete;
    };

    static LONG NTAPI VectoredExceptionHandler(PEXCEPTION_POINTERS pExceptionInfo)
    {
        if (!pExceptionContext.m_bShouldHandle)
            return EXCEPTION_CONTINUE_SEARCH;

        if (pExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ILLEGAL_INSTRUCTION &&
            pExceptionInfo->ExceptionRecord->ExceptionAddress == pExceptionContext.m_pExpectedExceptionAddress)
        {
            pExceptionContext.m_bShouldHandle = false;
#if SYSCALL_PLATFORM_WINDOWS_64
            pExceptionInfo->ContextRecord->R10 = pExceptionInfo->ContextRecord->Rcx;
            pExceptionInfo->ContextRecord->Rax = pExceptionContext.m_uSyscallNumber;
            pExceptionInfo->ContextRecord->Rip = reinterpret_cast<uintptr_t>(pExceptionContext.m_pSyscallGadget);
#else
            uintptr_t uReturnAddressAfterSyscall = reinterpret_cast<uintptr_t>(pExceptionInfo->ExceptionRecord->ExceptionAddress) + 2;

            pExceptionInfo->ContextRecord->Edx = pExceptionInfo->ContextRecord->Esp;

            pExceptionInfo->ContextRecord->Esp -= sizeof(uintptr_t);

            *reinterpret_cast<uintptr_t*>(pExceptionInfo->ContextRecord->Esp) = uReturnAddressAfterSyscall;

            pExceptionInfo->ContextRecord->Eip = reinterpret_cast<uintptr_t>(pExceptionContext.m_pSyscallGadget);
            pExceptionInfo->ContextRecord->Eax = pExceptionContext.m_uSyscallNumber;

#endif


            return EXCEPTION_CONTINUE_EXECUTION;
        }

        return EXCEPTION_CONTINUE_SEARCH;
    }

    namespace policies
    {
        namespace allocator
        {
            struct section
            {
                static bool allocate(size_t uRegionSize, const std::span<const uint8_t> vecBuffer, void*& pOutRegion, HANDLE& /*unused*/)
                {
                    HMODULE hNtDll = native::getModuleBase(hashing::calculateHash("ntdll.dll"));

                    auto fNtCreateSection = reinterpret_cast<native::NtCreateSection_t>(native::getExportAddress(hNtDll, SYSCALL_ID("NtCreateSection")));
                    auto fNtMapView = reinterpret_cast<native::NtMapViewOfSection_t>(native::getExportAddress(hNtDll, SYSCALL_ID("NtMapViewOfSection")));
                    auto fNtUnmapView = reinterpret_cast<native::NtUnmapViewOfSection_t>(native::getExportAddress(hNtDll, SYSCALL_ID("NtUnmapViewOfSection")));
                    auto fNtClose = reinterpret_cast<native::NtClose_t>(native::getExportAddress(hNtDll, SYSCALL_ID("NtClose")));
                    if (!fNtCreateSection || !fNtMapView || !fNtUnmapView || !fNtClose)
                        return false;

                    HANDLE hSectionHandle = nullptr;
                    LARGE_INTEGER sectionSize;
                    sectionSize.QuadPart = uRegionSize;

                    using enum native::ESectionInherit;
                    using enum native::ESectionAllocAttributes;

                    NTSTATUS status = fNtCreateSection(&hSectionHandle, SECTION_ALL_ACCESS, nullptr, &sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT | static_cast<ULONG>(SECTION_NO_CHANGE), nullptr);
                    if (!NT_SUCCESS(status))
                        return false;

                    void* pTempView = nullptr;
                    SIZE_T uViewSize = uRegionSize;
                    status = fNtMapView(hSectionHandle, native::getCurrentProcess(), &pTempView, 0, 0, nullptr, &uViewSize, VIEW_SHARE, 0, PAGE_READWRITE);
                    if (!NT_SUCCESS(status))
                    {
                        fNtClose(hSectionHandle);
                        return false;
                    }

                    std::copy_n(vecBuffer.data(), uRegionSize, static_cast<uint8_t*>(pTempView));
                    fNtUnmapView(native::getCurrentProcess(), pTempView);
                    uViewSize = uRegionSize;
                    status = fNtMapView(hSectionHandle, native::getCurrentProcess(), &pOutRegion, 0, 0, nullptr, &uViewSize, native::ESectionInherit::VIEW_SHARE, 0, PAGE_EXECUTE_READ);
                    fNtClose(hSectionHandle);
                    return NT_SUCCESS(status) && pOutRegion;
                }
                static void release(void* pRegion, HANDLE /*hHeapHandle*/)
                {
                    HMODULE hNtDll = native::getModuleBase(hashing::calculateHash("ntdll.dll"));
                    if (pRegion)
                    {
                        auto fNtUnmapView = reinterpret_cast<native::NtUnmapViewOfSection_t>(native::getExportAddress(hNtDll, SYSCALL_ID("NtUnmapViewOfSection")));
                        if (fNtUnmapView)
                            fNtUnmapView(native::getCurrentProcess(), pRegion);
                    }
                }
            };

            struct heap
            {
                static bool allocate(size_t uRegionSize, const std::span<const uint8_t> vecBuffer, void*& pOutRegion, HANDLE& hOutHeapHandle)
                {
                    HMODULE hNtdll = native::getModuleBase(hashing::calculateHash("ntdll.dll"));
                    if (!hNtdll)
                        return false;

                    auto fRtlCreateHeap = reinterpret_cast<native::RtlCreateHeap_t>(native::getExportAddress(hNtdll, SYSCALL_ID("RtlCreateHeap")));
                    auto fRtlAllocateHeap = reinterpret_cast<native::RtlAllocateHeap_t>(native::getExportAddress(hNtdll, SYSCALL_ID("RtlAllocateHeap")));
                    if (!fRtlCreateHeap || !fRtlAllocateHeap)
                        return false;

                    hOutHeapHandle = fRtlCreateHeap(HEAP_CREATE_ENABLE_EXECUTE | HEAP_GROWABLE, nullptr, 0, 0, nullptr, nullptr);
                    if (!hOutHeapHandle)
                        return false;

                    pOutRegion = fRtlAllocateHeap(hOutHeapHandle, 0, uRegionSize);
                    if (!pOutRegion)
                    {
                        release(nullptr, hOutHeapHandle);
                        hOutHeapHandle = nullptr;
                        return false;
                    }

                    std::copy_n(vecBuffer.data(), uRegionSize, static_cast<uint8_t*>(pOutRegion));
                    return true;
                }

                static void release(void* /*region*/, HANDLE hHeapHandle)
                {
                    if (hHeapHandle)
                    {
                        HMODULE hNtdll = native::getModuleBase(hashing::calculateHash("ntdll.dll"));
                        if (!hNtdll)
                            return;

                        auto fRtlDestroyHeap = reinterpret_cast<native::RtlDestroyHeap_t>(native::getExportAddress(hNtdll, SYSCALL_ID("RtlDestroyHeap")));
                        if (fRtlDestroyHeap)
                            fRtlDestroyHeap(hHeapHandle);
                    }
                }
            };

            struct memory
            {
                static bool allocate(size_t uRegionSize, const std::span<const uint8_t> vecBuffer, void*& pOutRegion, HANDLE& /*unused*/)
                {
                    HMODULE hNtDll = native::getModuleBase(hashing::calculateHash("ntdll.dll"));

                    auto fNtAllocate = reinterpret_cast<native::NtAllocateVirtualMemory_t>(native::getExportAddress(hNtDll, SYSCALL_ID("NtAllocateVirtualMemory")));
                    auto fNtProtect = reinterpret_cast<native::NtProtectVirtualMemory_t>(native::getExportAddress(hNtDll, SYSCALL_ID("NtProtectVirtualMemory")));
                    if (!fNtAllocate || !fNtProtect)
                        return false;

                    pOutRegion = nullptr;
                    SIZE_T uSize = uRegionSize;
                    NTSTATUS status = fNtAllocate(native::getCurrentProcess(), &pOutRegion, 0, &uSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

                    if (!NT_SUCCESS(status) || !pOutRegion)
                        return false;

                    std::copy_n(vecBuffer.data(), uRegionSize, static_cast<uint8_t*>(pOutRegion));
                    ULONG oldProtection = 0;
                    uSize = uRegionSize;
                    status = fNtProtect(native::getCurrentProcess(), &pOutRegion, &uSize, PAGE_EXECUTE_READ, &oldProtection);

                    if (!NT_SUCCESS(status))
                    {
                        uSize = 0;
                        fNtAllocate(native::getCurrentProcess(), &pOutRegion, 0, &uSize, MEM_RELEASE, 0);
                        pOutRegion = nullptr;
                        return false;
                    }

                    return true;
                }

                static void release(void* pRegion, HANDLE /*heapHandle*/)
                {
                    HMODULE hNtDll = native::getModuleBase(hashing::calculateHash("ntdll.dll"));

                    if (pRegion)
                    {
                        auto fNtFree = reinterpret_cast<native::NtFreeVirtualMemory_t>(native::getExportAddress(hNtDll, SYSCALL_ID("NtFreeVirtualMemory")));
                        if (fNtFree)
                        {
                            SIZE_T uSize = 0;
                            fNtFree(native::getCurrentProcess(), &pRegion, &uSize, MEM_RELEASE);
                        }
                    }
                }
            };
        } // allocator
        namespace generator
        {
#if SYSCALL_PLATFORM_WINDOWS_64
            // @note / SapDragon: supports only on x64 now
            struct gadget
            {
                static constexpr bool bRequiresGadget = true;
                static constexpr size_t getStubSize() { return 32; }
                static void generate(uint8_t* pBuffer, uint32_t uSyscallNumber, void* pGadgetAddress)
                {
                    // @note / SapDragon: mov r10, rcx
                    pBuffer[0] = 0x49;
                    pBuffer[1] = 0x89;
                    pBuffer[2] = 0xCA;

                    // @note / SapDragon: mov eax, syscallNumber
                    pBuffer[3] = 0xB8;
                    *reinterpret_cast<uint32_t*>(&pBuffer[4]) = uSyscallNumber;

                    // @note / SapDragon: mov r11, gadgetAddress
                    pBuffer[8] = 0x49;
                    pBuffer[9] = 0xBB;
                    *reinterpret_cast<uint64_t*>(&pBuffer[10]) = reinterpret_cast<uint64_t>(pGadgetAddress);

                    // @note / SapDragon: push r11
                    pBuffer[18] = 0x41;
                    pBuffer[19] = 0x53;

                    // @note / SapDragon: ret
                    pBuffer[20] = 0xC3;
                }
            };

#endif

            struct exception
            {
                static constexpr bool bRequiresGadget = true;
                static constexpr size_t getStubSize() { return 8; }
                static void generate(uint8_t* pBuffer, uint32_t /*uSyscallNumber*/, void* /*pGadgetAddress*/)
                {
                    pBuffer[0] = 0x0F;
                    pBuffer[1] = 0x0B;
                    pBuffer[2] = 0xC3;
                    std::fill_n(pBuffer + 3, getStubSize() - 3, 0x90);
                }
            };

            struct direct
            {
                static constexpr bool bRequiresGadget = false;

#if SYSCALL_PLATFORM_WINDOWS_64
                inline static constinit std::array<uint8_t, 18> arrShellcode =
                {
                    0x51,                               // push rcx
                    0x41, 0x5A,                         // pop r10
                    0xB8, 0x00, 0x00, 0x00, 0x00,       // mov eax, 0x00000000 (syscall number placeholder)
                    0x0F, 0x05,                         // syscall
                    0x48, 0x83, 0xC4, 0x08,             // add rsp, 8
                    0xFF, 0x64, 0x24, 0xF8              // jmp qword ptr [rsp-8]
                };
#elif SYSCALL_PLATFORM_WINDOWS_32
                inline static constinit std::array<uint8_t, 15> arrShellcode =
                {
                    0xB8, 0x00, 0x00, 0x00, 0x00,       // mov eax, 0x00000000 (syscall number placeholder)
                    0x89, 0xE2,                         // mov edx, esp
                    0x64, 0xFF, 0x15, 0xC0, 0x00, 0x00, 0x00, // call dword ptr fs:[0xC0]
                    0xC3                                // ret
                };
#endif
                static void generate(uint8_t* pBuffer, uint32_t uSyscallNumber, void* /*pGadgetAddress*/)
                {
                    std::copy_n(arrShellcode.data(), arrShellcode.size(), pBuffer);
                    if constexpr (platform::isWindows64)
                        *reinterpret_cast<uint32_t*>(pBuffer + 4) = uSyscallNumber;
                    else
                        *reinterpret_cast<uint32_t*>(pBuffer + 1) = uSyscallNumber;
                }
                static constexpr size_t getStubSize() { return arrShellcode.size(); }
            };

        }
        namespace parser
        {
            struct directory
            {
                static std::vector<SyscallEntry_t> parse(const ModuleInfo_t& module)
                {
                    std::vector<SyscallEntry_t> vecFoundSyscalls;
                    // @note / sapdragon: exception parser on x64
                    if constexpr (platform::isWindows64)
                    {
                        auto uExceptionDirRva = module.m_pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
                        if (!uExceptionDirRva)
                            return vecFoundSyscalls;

                        auto pRuntimeFunctions = reinterpret_cast<PIMAGE_RUNTIME_FUNCTION_ENTRY>(module.m_pModuleBase + uExceptionDirRva);
                        auto uExceptionDirSize = module.m_pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
                        auto uFunctionCount = uExceptionDirSize / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY);

                        auto pFunctionsRVA = reinterpret_cast<uint32_t*>(module.m_pModuleBase + module.m_pExportDir->AddressOfFunctions);
                        auto pNamesRVA = reinterpret_cast<uint32_t*>(module.m_pModuleBase + module.m_pExportDir->AddressOfNames);
                        auto pOrdinalsRva = reinterpret_cast<uint16_t*>(module.m_pModuleBase + module.m_pExportDir->AddressOfNameOrdinals);

                        std::unordered_map<uint32_t, const char*> mapRvaToName;
                        for (uint32_t i = 0; i < module.m_pExportDir->NumberOfNames; ++i)
                        {
                            const char* szName = reinterpret_cast<const char*>(module.m_pModuleBase + pNamesRVA[i]);
                            uint16_t uOrdinal = pOrdinalsRva[i];
                            uint32_t uFunctionRva = pFunctionsRVA[uOrdinal];
                            mapRvaToName[uFunctionRva] = szName;
                        }

                        uint32_t uSyscallNumber = 0;
                        for (DWORD i = 0; i < uFunctionCount; ++i)
                        {
                            auto pFunction = &pRuntimeFunctions[i];
                            if (pFunction->BeginAddress == 0)
                                break;

                            auto it = mapRvaToName.find(pFunction->BeginAddress);
                            if (it != mapRvaToName.end())
                            {
                                const char* szName = it->second;

                                if (hashing::calculateHashRuntime(szName, 2) == hashing::calculateHash("Zw"))
                                {
                                    char szNtName[128];
                                    std::copy_n(szName, sizeof(szNtName)-1, szNtName);
                                    szNtName[0] = 'N';
                                    szNtName[1] = 't';

                                    const SyscallKey_t key = SYSCALL_ID_RT(szNtName);

                                    vecFoundSyscalls.push_back(SyscallEntry_t{ key, uSyscallNumber, 0 });
                                    uSyscallNumber++;
                                }
                            }
                        }
                    }
                    // @note / sapdragon: sorting zw exports
                    else
                    {
                        auto pFunctionsRVA = reinterpret_cast<uint32_t*>(module.m_pModuleBase + module.m_pExportDir->AddressOfFunctions);
                        auto pNamesRVA = reinterpret_cast<uint32_t*>(module.m_pModuleBase + module.m_pExportDir->AddressOfNames);
                        auto pOrdinalsRva = reinterpret_cast<uint16_t*>(module.m_pModuleBase + module.m_pExportDir->AddressOfNameOrdinals);

                        std::vector<std::pair<uintptr_t, const char*>> vecZwFunctions;
                        for (uint32_t i = 0; i < module.m_pExportDir->NumberOfNames; ++i)
                        {
                            const char* szName = reinterpret_cast<const char*>(module.m_pModuleBase + pNamesRVA[i]);

                            if (szName[0] == 'Z' && szName[1] == 'w')
                            {
                                uint16_t uOrdinal = pOrdinalsRva[i];
                                uint32_t uFunctionRva = pFunctionsRVA[uOrdinal];

                                auto pExportSectionStart = module.m_pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                                auto pExportSectionEnd = pExportSectionStart + module.m_pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                                if (uFunctionRva >= pExportSectionStart && uFunctionRva < pExportSectionEnd)
                                    continue;

                                uintptr_t uFunctionAddress = reinterpret_cast<uintptr_t>(module.m_pModuleBase + uFunctionRva);
                                vecZwFunctions.push_back({ uFunctionAddress, szName });
                            }
                        }

                        if (vecZwFunctions.empty())
                            return vecFoundSyscalls;

                        std::sort(vecZwFunctions.begin(), vecZwFunctions.end(),
                            [](const auto& a, const auto& b) {
                                return a.first < b.first;
                            });

                        uint32_t uSyscallNumber = 0;
                        for (const auto& [_, szName] : vecZwFunctions) 
                        {
                            char szNtName[128];
                            std::copy_n(szName, sizeof(szNtName)-1, szNtName);
                            szNtName[0] = 'N';
                            szNtName[1] = 't';

                            const SyscallKey_t key = SYSCALL_ID_RT(szNtName);
                            vecFoundSyscalls.push_back(SyscallEntry_t{ key, uSyscallNumber, 0 });
                            uSyscallNumber++;
                        }
                    }

                    return vecFoundSyscalls;
                }
            };

            struct signature
            {
                static std::vector<SyscallEntry_t> parse(const ModuleInfo_t& module)
                {
                    std::vector<SyscallEntry_t> vecFoundSyscalls;

                    auto pFunctionsRVA = reinterpret_cast<uint32_t*>(module.m_pModuleBase + module.m_pExportDir->AddressOfFunctions);
                    auto pNamesRVA = reinterpret_cast<uint32_t*>(module.m_pModuleBase + module.m_pExportDir->AddressOfNames);
                    auto pOrdinalsRva = reinterpret_cast<uint16_t*>(module.m_pModuleBase + module.m_pExportDir->AddressOfNameOrdinals);

                    for (uint32_t i = 0; i < module.m_pExportDir->NumberOfNames; i++)
                    {
                        const char* szName = reinterpret_cast<const char*>(module.m_pModuleBase + pNamesRVA[i]);

                        if (hashing::calculateHashRuntime(szName, 2) != hashing::calculateHash("Nt"))
                            continue;

                        uint16_t uOrdinal = pOrdinalsRva[i];
                        uint32_t uFunctionRva = pFunctionsRVA[uOrdinal];

                        auto pExportSectionStart = module.m_pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                        auto pExportSectionEnd = pExportSectionStart + module.m_pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                        if (uFunctionRva >= pExportSectionStart && uFunctionRva < pExportSectionEnd)
                            continue;

                        uint8_t* pFunctionStart = module.m_pModuleBase + uFunctionRva;
                        uint32_t uSyscallNumber = 0;
                        bool bSyscallFound = false;

                        if constexpr (platform::isWindows64)
                        {
                            if (*reinterpret_cast<uint32_t*>(pFunctionStart) == 0xB8D18B4C)
                            {
                                uSyscallNumber = *reinterpret_cast<uint32_t*>(pFunctionStart + 4);
                                bSyscallFound = true;
                            }
                        }

                        if constexpr (platform::isWindows32)
                        {
                            if (*pFunctionStart == 0xB8)
                            {
                                uSyscallNumber = *reinterpret_cast<uint32_t*>(pFunctionStart + 1);
                                bSyscallFound = true;
                            }
                        }
                        // @note / SapDragon: checks hooks on x64
                        if constexpr (platform::isWindows64)
                        {
                            if (isFunctionHooked(pFunctionStart) && !bSyscallFound)
                            {
                                // @note / SapDragon: stable only on x64

                                // @note / SapDragon: search up
                                for (int j = 1; j < 20; ++j)
                                {
                                    uint8_t* pNeighborFunc = pFunctionStart - (j * 0x20);
                                    if (reinterpret_cast<uintptr_t>(pNeighborFunc) < reinterpret_cast<uintptr_t>(module.m_pModuleBase)) break;
                                    if (*reinterpret_cast<uint32_t*>(pNeighborFunc) == 0xB8D18B4C)
                                    {
                                        uint32_t uNeighborSyscall = *reinterpret_cast<uint32_t*>(pNeighborFunc + 4);
                                        uSyscallNumber = uNeighborSyscall + j;
                                        bSyscallFound = true;
                                        break;
                                    }
                                }

                                // @note / SapDragon: search down
                                if (!bSyscallFound)
                                {
                                    for (int j = 1; j < 20; ++j)
                                    {
                                        uint8_t* pNeighborFunc = pFunctionStart + (j * 0x20);
                                        if (reinterpret_cast<uintptr_t>(pNeighborFunc) > (reinterpret_cast<uintptr_t>(module.m_pModuleBase) + module.m_pNtHeaders->OptionalHeader.SizeOfImage)) break;
                                        if (*reinterpret_cast<uint32_t*>(pNeighborFunc) == 0xB8D18B4C)
                                        {
                                            uint32_t uNeighborSyscall = *reinterpret_cast<uint32_t*>(pNeighborFunc + 4);
                                            uSyscallNumber = uNeighborSyscall - j;
                                            bSyscallFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        if (bSyscallFound)
                        {
                            const SyscallKey_t key = SYSCALL_ID_RT(szName);
                            vecFoundSyscalls.push_back(SyscallEntry_t{
                                        key,
                                        uSyscallNumber,
                                        0
                                });
                        }
                    }
                    return vecFoundSyscalls;
                }
            private:
                static bool isFunctionHooked(const uint8_t* pFunctionStart)
                {
                    const uint8_t* pCurrent = pFunctionStart;

                    while (*pCurrent == 0x90)
                        pCurrent++;

                    switch (pCurrent[0])
                    {
                        // @note / SapDragon: JMP rel32
                    case 0xE9:
                        // @note / SapDragon: JMP rel8
                    case 0xEB:
                        // @note / SapDragon: push imm32
                    case 0x68:
                        return true;

                        // @note / SapDragon: jmp [mem] / jmp [rip + offset]
                    case 0xFF:
                        if (pCurrent[1] == 0x25)
                            return true;
                        break;

                        // @note / SapDragon: int3...
                    case 0xCC:
                        return true;

                        // @note / SapDragon: ud2
                    case 0x0F:
                        if (pCurrent[1] == 0x0B)
                            return true;
                        break;

                        // @note / SapDragon: int 0x3
                    case 0xCD:
                        if (pCurrent[1] == 0x03)
                            return true;
                        break;

                    default:
                        break;
                    }

                    return false;
                }
            };
        } // parsing
    } // policies


    template<typename T>
    concept IsIAllocationPolicy = requires(size_t uSize, const std::span<const uint8_t>vecBuffer, void*& pRegion, HANDLE & hObject)
    {
        { T::allocate(uSize, vecBuffer, pRegion, hObject) } -> std::convertible_to<bool>;
        { T::release(pRegion, hObject) } -> std::same_as<void>;
    };

    template<typename T>
    concept IsStubGenerationPolicy = requires(uint8_t * pBuffer, uint32_t uSyscallNumber, void* pGadget)
    {
        { T::bRequiresGadget } -> std::same_as<const bool&>;
        { T::getStubSize() } -> std::convertible_to<size_t>;
        { T::generate(pBuffer, uSyscallNumber, pGadget) } -> std::same_as<void>;
    };

    template<typename T>
    concept IsSyscallParsingPolicy = requires(const ModuleInfo_t & module)
    {
        { T::parse(module) } -> std::convertible_to<std::vector<SyscallEntry_t>>;
    };

    template<IsSyscallParsingPolicy... IParsers>
    struct ParserChain_t
    {
        static_assert(sizeof...(IParsers) > 0, "Parsedchain_t cannot be empty.");
    };

    template<
        typename IAllocationPolicy,
        typename IStubGenerationPolicy,
        typename IFirstParser,
        typename ... IFallbackParsers
    >
    class ManagerImpl
    {
    private:
        static_assert(IsIAllocationPolicy<IAllocationPolicy>,
            "[Syscall] The provided allocation policy is not valid. "
            "A valid allocation policy must provide two static functions: "
            "1. 'static bool allocate(size_t, const std::span<const uint8_t>, void*&, HANDLE&);' "
            "2. 'static void release(void*, HANDLE);'"
            );

        static_assert(IsStubGenerationPolicy<IStubGenerationPolicy>,
            "[Syscall] The provided stub generation policy is not valid. "
            "A valid stub generation policy must provide: "
            "1. A 'static constexpr bool bRequiresGadget' member. "
            "2. A 'static constexpr size_t getStubSize()' function. "
            "3. A 'static void generate(uint8_t*, uint32_t, void*)' function."
            );

        static_assert(IsSyscallParsingPolicy<IFirstParser> && (IsSyscallParsingPolicy<IFallbackParsers> && ...),
            "[Syscall] One or more provided syscall parsing policies are not valid. "
            "A valid parsing policy must provide a static function: "
            "1. 'static std::vector<SyscallEntry_t> parse(const ModuleInfo_t&);'"
            );

        std::mutex m_mutex;
        std::vector<SyscallEntry_t> m_vecParsedSyscalls;
        void* m_pSyscallRegion = nullptr;
        std::vector<void*> m_vecSyscallGadgets;
        size_t m_uRegionSize = 0;
        bool m_bInitialized = false;
        HANDLE m_hObjectHandle = nullptr;
        void* m_pVehHandle = nullptr;
    public:
        ManagerImpl() = default;
        ~ManagerImpl()
        {
            if constexpr (platform::isWindows64)
                if (m_pVehHandle)
                    RemoveVectoredExceptionHandler(m_pVehHandle);

            IAllocationPolicy::release(m_pSyscallRegion, m_hObjectHandle);
        }

        ManagerImpl(const ManagerImpl&) = delete;
        ManagerImpl& operator=(const ManagerImpl&) = delete;
        ManagerImpl(ManagerImpl&& other) noexcept
        {
            std::lock_guard<std::mutex> lock(other.m_mutex);
            m_vecParsedSyscalls = std::move(other.m_vecParsedSyscalls);
            m_pSyscallRegion = other.m_pSyscallRegion;
            m_vecSyscallGadgets = std::move(other.m_vecSyscallGadgets);
            m_uRegionSize = other.m_uRegionSize;
            m_bInitialized = other.m_bInitialized;
            m_hObjectHandle = other.m_hObjectHandle;
            other.m_pSyscallRegion = nullptr;
            other.m_hObjectHandle = nullptr;
        }

        ManagerImpl& operator=(ManagerImpl&& other) noexcept
        {
            if (this != &other)
            {
                std::scoped_lock lock(m_mutex, other.m_mutex);
                IAllocationPolicy::release(m_pSyscallRegion, m_hObjectHandle);
                m_vecParsedSyscalls = std::move(other.m_vecParsedSyscalls);
                m_pSyscallRegion = other.m_pSyscallRegion;
                m_vecSyscallGadgets = std::move(other.m_vecSyscallGadgets);
                m_uRegionSize = other.m_uRegionSize;
                m_bInitialized = other.m_bInitialized;
                m_hObjectHandle = other.m_hObjectHandle;
                other.m_pSyscallRegion = nullptr;
                other.m_hObjectHandle = nullptr;
            }

            return *this;
        }

        [[nodiscard]] bool initialize(const std::vector<SyscallKey_t>& vecModuleKeys = { SYSCALL_ID("ntdll.dll") })
        {
            if (m_bInitialized)
                return true;

            std::lock_guard<std::mutex> lock(m_mutex);

            if (m_bInitialized)
                return true;
#if SYSCALL_PLATFORM_WINDOWS_64
            if constexpr (IStubGenerationPolicy::bRequiresGadget)
                if (!findSyscallGadgets())
                    return false;
#endif

            m_vecParsedSyscalls.clear();
            for (const auto& moduleKey : vecModuleKeys)
            {
                ModuleInfo_t moduleInfo;
                if (!getModuleInfo(moduleKey, moduleInfo))
                    continue;

                std::vector<SyscallEntry_t> moduleSyscalls = tryParseSyscalls<IFirstParser, IFallbackParsers...>(moduleInfo);

                m_vecParsedSyscalls.insert(m_vecParsedSyscalls.end(), moduleSyscalls.begin(), moduleSyscalls.end());
            }

            if (m_vecParsedSyscalls.empty())
                return false;

            if (m_vecParsedSyscalls.size() > 1)
                for (size_t i = m_vecParsedSyscalls.size() - 1; i > 0; --i)
                    std::swap(m_vecParsedSyscalls[i], m_vecParsedSyscalls[native::rdtscp() % (i + 1)]);

            for (size_t i = 0; i < m_vecParsedSyscalls.size(); ++i)
                m_vecParsedSyscalls[i].m_uOffset = static_cast<uint32_t>(i * IStubGenerationPolicy::getStubSize());


            std::ranges::sort(m_vecParsedSyscalls, std::less{}, &SyscallEntry_t::m_key);

            m_bInitialized = createSyscalls();
            if (m_bInitialized)
            {
                if constexpr (std::is_same_v<IStubGenerationPolicy, policies::generator::exception>)
                {
                    m_pVehHandle = AddVectoredExceptionHandler(1, VectoredExceptionHandler);
                    if (!m_pVehHandle)
                    {
                        IAllocationPolicy::release(m_pSyscallRegion, m_hObjectHandle);
                        m_pSyscallRegion = nullptr;
                        m_bInitialized = false;
                    }
                }
            }

            return m_bInitialized;
        }
        template<typename Ret = uintptr_t, typename... Args>
        [[nodiscard]] SYSCALL_FORCE_INLINE Ret invoke(const SyscallKey_t& syscallId, Args... args)
        {
            if (!m_bInitialized)
            {
                if (!initialize())
                {
                    if constexpr (std::is_same_v<Ret, NTSTATUS>)
                        return native::STATUS_UNSUCCESSFUL;

                    return Ret{};
                }
            }
            auto it = std::ranges::lower_bound(m_vecParsedSyscalls, syscallId, std::less{}, &SyscallEntry_t::m_key);

            if (it == m_vecParsedSyscalls.end() || it->m_key != syscallId)
            {
                if constexpr (std::is_same_v<Ret, NTSTATUS>)
                    return native::STATUS_PROCEDURE_NOT_FOUND;

                return Ret{};
            }

            using Function_t = Ret(SYSCALL_API*)(Args...);

            uint8_t* pStubAddress = reinterpret_cast<uint8_t*>(m_pSyscallRegion) + it->m_uOffset;
            if constexpr (std::is_same_v<IStubGenerationPolicy, policies::generator::exception>)
            {
#if SYSCALL_PLATFORM_WINDOWS_64
                const size_t uGadgetCount = m_vecSyscallGadgets.size();

                if (!uGadgetCount)
                {
                    if constexpr (std::is_same_v<Ret, NTSTATUS>)
                        return native::STATUS_UNSUCCESSFUL;
                    return Ret{};
                }

                const size_t uRandomIndex = native::rdtscp() % uGadgetCount;
                void* pRandomGadget = m_vecSyscallGadgets[uRandomIndex];
#else
                void* pRandomGadget = (void*)__readfsdword(0xC0);
#endif

                CExceptionContextGuard contextGuard(pStubAddress, pRandomGadget, it->m_uSyscallNumber);
                return reinterpret_cast<Function_t>(pStubAddress)(std::forward<Args>(args)...);
            }

            return reinterpret_cast<Function_t>(pStubAddress)(std::forward<Args>(args)...);
        }
    private:
        template<IsSyscallParsingPolicy CurrentParser, IsSyscallParsingPolicy... OtherParsers>
        std::vector<SyscallEntry_t> tryParseSyscalls(const ModuleInfo_t& moduleInfo)
        {
            auto vecSyscalls = CurrentParser::parse(moduleInfo);

            if (!vecSyscalls.empty())
                return vecSyscalls;

            if constexpr (sizeof...(OtherParsers) > 0)
                return tryParseSyscalls<OtherParsers...>(moduleInfo);

            return vecSyscalls;
        }


        bool createSyscalls()
        {
            if (m_vecParsedSyscalls.empty())
                return false;
#if SYSCALL_PLATFORM_WINDOWS_64
            if constexpr (IStubGenerationPolicy::bRequiresGadget)
                if (m_vecSyscallGadgets.empty())
                    return false;
#endif

            m_uRegionSize = m_vecParsedSyscalls.size() * IStubGenerationPolicy::getStubSize();
            std::vector<uint8_t> vecTempBuffer(m_uRegionSize);

            const size_t uGadgetsCount = m_vecSyscallGadgets.size();

            for (const SyscallEntry_t& entry : m_vecParsedSyscalls)
            {
                uint8_t* pStubLocation = vecTempBuffer.data() + entry.m_uOffset;
                void* pGadgetForStub = nullptr;
#if SYSCALL_PLATFORM_WINDOWS_64
                if constexpr (IStubGenerationPolicy::bRequiresGadget)
                {
                    const size_t uRandomIndex = native::rdtscp() % uGadgetsCount;
                    pGadgetForStub = m_vecSyscallGadgets[uRandomIndex];
                }
#endif

                IStubGenerationPolicy::generate(pStubLocation, entry.m_uSyscallNumber, pGadgetForStub);
            }

            return IAllocationPolicy::allocate(m_uRegionSize, vecTempBuffer, m_pSyscallRegion, m_hObjectHandle);
        }

        bool getModuleInfo(SyscallKey_t moduleKey, ModuleInfo_t& info)
        {
            HMODULE hModule = native::getModuleBase(moduleKey);
            if (!hModule)
                return false;

            info.m_pModuleBase = reinterpret_cast<uint8_t*>(hModule);

            auto pDosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(info.m_pModuleBase);
            if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
                return false;

            info.m_pNtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(info.m_pModuleBase + pDosHeader->e_lfanew);
            if (info.m_pNtHeaders->Signature != IMAGE_NT_SIGNATURE)
                return false;

            auto uExportRva = info.m_pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
            if (!uExportRva)
                return false;

            info.m_pExportDir = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(info.m_pModuleBase + uExportRva);

            return true;
        }

#if SYSCALL_PLATFORM_WINDOWS_64
        bool findSyscallGadgets()
        {
            ModuleInfo_t ntdll;
            if (!getModuleInfo(SYSCALL_ID("ntdll.dll"), ntdll))
                return false;

            IMAGE_SECTION_HEADER* pSections = IMAGE_FIRST_SECTION(ntdll.m_pNtHeaders);
            uint8_t* pTextSection = nullptr;
            uint32_t uTextSectionSize = 0;
            for (int i = 0; i < ntdll.m_pNtHeaders->FileHeader.NumberOfSections; ++i)
            {
                if (hashing::calculateHashRuntime(reinterpret_cast<const char*>(pSections[i].Name)) == hashing::calculateHash(".text"))
                {
                    pTextSection = ntdll.m_pModuleBase + pSections[i].VirtualAddress;
                    uTextSectionSize = pSections[i].Misc.VirtualSize;
                    break;
                }
            }

            if (!pTextSection || !uTextSectionSize)
                return false;

            m_vecSyscallGadgets.clear();
            for (DWORD i = 0; i < uTextSectionSize - 2; ++i)
                if (pTextSection[i] == 0x0F && pTextSection[i + 1] == 0x05 && pTextSection[i + 2] == 0xC3)
                    m_vecSyscallGadgets.push_back(&pTextSection[i]);

            return !m_vecSyscallGadgets.empty();
        }
#endif

    };

    using DefaultParserChain = syscall::ParserChain_t<
        syscall::policies::parser::directory,
        syscall::policies::parser::signature
    >;

    // @note / sapdragon: fucking templates, is that a legal cpp hack? unpack overloads...
    template<typename AllocPolicy, typename StubPolicy, typename... ParserArgs>
    class Manager : public Manager<AllocPolicy, StubPolicy, DefaultParserChain>
    {
    };

    template< typename AllocPolicy, typename StubPolicy, IsSyscallParsingPolicy... ParsersInChain >
    class Manager<AllocPolicy, StubPolicy, ParserChain_t<ParsersInChain...>>
        : public ManagerImpl<AllocPolicy, StubPolicy, ParsersInChain...>
    {
    };

    template< typename AllocPolicy, typename StubPolicy, typename FirstParser, typename... FallbackParsers>
    class Manager<AllocPolicy, StubPolicy, FirstParser, FallbackParsers...>
        : public ManagerImpl<AllocPolicy, StubPolicy, FirstParser, FallbackParsers...>
    {
    };
}
#if SYSCALL_PLATFORM_WINDOWS_64
using SyscallSectionGadget = syscall::Manager<syscall::policies::allocator::section, syscall::policies::generator::gadget>;
using SyscallHeapGadget = syscall::Manager<syscall::policies::allocator::heap, syscall::policies::generator::gadget>;
#endif
using SyscallSectionDirect = syscall::Manager<syscall::policies::allocator::section, syscall::policies::generator::direct>;

#endif  
```

`readme.md`:

```md
# syscalls-cpp

syscalls-cpp is a C++20 policy-based framework for crafting undetectable/protected syscalls (x86 / x64). It leverages a policy-based design to let you mix and match different strategies for memory allocation and stub generation at compile-time, giving you full control over your operational security tradeoffs.

The core principle is **modularity**. You are not given a black box; you are given building blocks.

**The library automatically resolves system call numbers by directly parsing ntdll.dll's metadata. This method is resilient to user-mode hooks by leveraging the PE's structure—the exception directory on x64 and sorted export addresses on x86—and can find adjacent syscalls if a target is patched.**

[![SEC_NO_CHANGE](https://raw.githubusercontent.com/sapdragon/syscalls-cpp/refs/heads/main/docs/images/protection_demo.gif)](https://raw.githubusercontent.com/sapdragon/syscalls-cpp/refs/heads/main/docs/images/protection_demo.gif)

*Allocation demonstration: an attempt to patch a system call located in a section with the `SEC_NO_CHANGE` flag fails.

## The Building Blocks: Provided Policies

You can combine any allocation policy with any stub generation policy.

#### Allocation Policies (`IsAllocationPolicy`)

| Policy             | Method                                                |
| ------------------ | ----------------------------------------------------- | 
| `allocator::section` | `NtCreateSection` with `SEC_NO_CHANGE` flag           | 
| `allocator::heap`    | `HeapCreate` with `HEAP_CREATE_ENABLE_EXECUTE`        |
| `allocator::memory`    | `NtAllocateVirtualMemory` (`RW` -> `RX`)       |

    

#### Stub Generation Policies (`IsStubGenerationPolicy`)

| Policy                | Method                                              |
| --------------------- | ----------------------------------------------------|
| `generator::direct` | Uses a classic, self-contained `syscall` instruction|
| `generator::gadget` only | (Only x64) Jumps to a `syscall; ret` gadget found in `ntdll.dll|
| `generator::exception` | Triggers a breakpoint (`ud2`) to perform the syscall via a custom Vectored Exception Handler (VEH). |

#### Parsing Policies (`IsSyscallParsingPolicy`)
| Policy | Method |
| :--- | :--- |
| `parser::directory` | On x64, maps the exception directory (.pdata) to the export table to determine the order of syscalls. On x86, it sorts exported Zw* functions by their memory addresses to calculate their numbers. |
| `parser::signature` | Scans function prologues for the `mov r10, rcx; mov eax, syscall_id` signature with hooks detection. |


## Installation

The recommended way to install and manage the library is through the C++ package manager [vcpkg](https://vcpkg.io/).

```sh
vcpkg install syscalls-cpp
```

This command will download, build, and install `syscalls-cpp`, making it easily accessible for your projects with automatic MSBuild and CMake integration.

### Conan

You can also use [Conan](https://conan.io/). Add the following to your `conanfile.txt`:

```ini
[requires]
syscalls-cpp/1.2.0
```

For manual setup, you can clone this repository and add the `include` directory to your project's include paths.

## Example: Crafting Your Strategy

The power is in the combination. Here is how you build and use a syscall manager.

### Standard Usage
```cpp
#include <iostream>
#include "syscall.hpp"

int main() {
    SyscallSectionDirect syscallManager;
    // you can add your own modules for parsing syscalls, by default only ntdll is parsed
    if (!syscallManager.initialize(/* SYSCALL_ID("ntdll.dll"),  SYSCALL_ID("win32u.dll")*/))
    {
        std::cerr << "initialization failed!\n";
        return 1;
    }

    PVOID pBaseAddress = nullptr;
    SIZE_T uSize = 0x1000;

    syscallManager.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        NtCurrentProcess(),
        &pBaseAddress,
        0, &uSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    if (pBaseAddress)
        std::cout << "allocation successful at 0x" << pBaseAddress << std::endl;

    return 0;
}
```

### Advanced Usage

For more control, you can specify your own policy or build a custom allocators / generators / parsers

```cpp
#include "syscall.hpp"

using UniqueSecretOwnPolicyManager = syscall::Manager<
        syscall::policies::allocator::heap, // heap allocator
        syscall::policies::generator::direct, // direct!!
        DefaultParserChain  // default exception/sort directory + improved halo gates as a fallback is used
>;

// or, let's build a custom parser chain using the ParserChain_t helper
// imagine you wrote a MyCustomParser policy
/*
using MyParserChain = syscall::ParserChain_t<
    MyCustomParser,
    syscall::policies::SignatureScanningParser
>;

using SuperCustomManager = syscall::Manager<
    syscall::policies::HeapAllocator,
    syscall::policies::GadgetStubGenerator,
    MyParserChain // own custom chain!!!
>;
*/
```

> [!WARNING]
> ### `NULL` vs. `nullptr` on x64
> **Always use `nullptr` instead of `NULL`** when invoking syscalls on x64 platforms.
>
> The `NULL` macro is often defined as an integer `0` (a 32-bit `int`). Passing it to a syscall expecting a 64-bit pointer can corrupt the stack, as the compiler may treat it as an integer and fail to properly extend it. This leads to argument misalignment and unpredictable crashes.
>
> `nullptr` is type-safe and guarantees the correct 64-bit null pointer representation, preventing this subtle but critical bug.

## Extensibility

The true power of the framework is its extensibility. You can easily write your own policies. Simply create a class that satisfies the required `concept` (`IsAllocationPolicy`, `IsStubGenerationPolicy`, or `IsSyscallParsingPolicy`), and it will be seamlessly compatible with the `Manager`.

## Configuration

For easier debugging, you can disable the compile-time hashing mechanism by defining the `SYSCALLS_NO_HASH` macro. This will cause the manager to use `std::string` for syscall names instead of integer hashes.

-   **MSVC:** `/DSYSCALLS_NO_HASH`
-   **GCC/Clang:** `-DSYSCALLS_NO_HASH`

## Requirements

-   A C++20 compatible compiler (MSVC, Clang, GCC).
-   Windows targets (x86/x64)

## LICENSE
MIT
```

`tests/CMakeLists.txt`:

```txt
include(FetchContent)

FetchContent_Declare(
        googletest
        GIT_REPOSITORY https://github.com/google/googletest.git
        GIT_TAG v1.15.2
)

set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

add_executable(test_hash test_hash.cpp)
target_link_libraries(test_hash PRIVATE syscalls-cpp GTest::gtest_main)
target_compile_features(test_hash PRIVATE cxx_std_20)
add_test(NAME test_hash COMMAND $<TARGET_FILE:test_hash>)

add_executable(test_crt test_crt.cpp)
target_link_libraries(test_crt PRIVATE syscalls-cpp GTest::gtest_main)
target_compile_features(test_crt PRIVATE cxx_std_20)
add_test(NAME test_crt COMMAND $<TARGET_FILE:test_crt>)

add_executable(test_integration test_integration.cpp)
target_link_libraries(test_integration PRIVATE syscalls-cpp GTest::gtest_main)
target_compile_features(test_integration PRIVATE cxx_std_20)
add_test(NAME test_integration COMMAND $<TARGET_FILE:test_integration>)

```

`tests/test_crt.cpp`:

```cpp
#include <gtest/gtest.h>
#include <syscalls-cpp/crt.hpp>
#include <cstring>

using namespace syscall::crt;

TEST(CrtTest, GetCountOfReturnsCorrectSize)
{
    int arrInt[10];
    EXPECT_EQ(getCountOf(arrInt), 10);

    char arrChar[256];
    EXPECT_EQ(getCountOf(arrChar), 256);
}

TEST(CrtTest, ConcatBasic)
{
    wchar_t wzDest[32] = L"Hello";
    string::concat(wzDest, 32, L" World");
    EXPECT_STREQ(wzDest, L"Hello World");
}

TEST(CrtTest, ConcatEmptySource)
{
    wchar_t wzDest[32] = L"Hello";
    string::concat(wzDest, 32, L"");
    EXPECT_STREQ(wzDest, L"Hello");
}

TEST(CrtTest, ConcatEmptyDest)
{
    wchar_t wzDest[32] = L"";
    string::concat(wzDest, 32, L"World");
    EXPECT_STREQ(wzDest, L"World");
}

TEST(CrtTest, ConcatTruncatesWhenFull)
{
    wchar_t wzDest[10] = L"Hello";
    string::concat(wzDest, 10, L"WorldWorldWorld");
    EXPECT_LT(string::getLength(wzDest), 10u);
}

TEST(CrtTest, ConcatNullDest)
{
    string::concat(nullptr, 32, L"test");
}

TEST(CrtTest, ConcatZeroSize)
{
    wchar_t wzDest[32] = L"Hello";
    string::concat(wzDest, 0, L" World");
    EXPECT_STREQ(wzDest, L"Hello");
}

TEST(CrtTest, MbToWcsBasic)
{
    wchar_t wzDest[32];
    string::mbToWcs(wzDest, 32, "hello");
    EXPECT_STREQ(wzDest, L"hello");
}

TEST(CrtTest, MbToWcsEmpty)
{
    wchar_t wzDest[32] = L"garbage";
    string::mbToWcs(wzDest, 32, "");
    EXPECT_STREQ(wzDest, L"");
}

TEST(CrtTest, MbToWcsTruncates)
{
    wchar_t wzDest[5];
    string::mbToWcs(wzDest, 5, "hello world");
    EXPECT_EQ(string::getLength(wzDest), 4u);
    EXPECT_EQ(wzDest[4], L'\0');
}

TEST(CrtTest, MbToWcsNullDest)
{
    string::mbToWcs(nullptr, 32, "test");
}

TEST(CrtTest, MbToWcsZeroSize)
{
    wchar_t wzDest[32] = L"garbage";
    string::mbToWcs(wzDest, 0, "test");
    EXPECT_STREQ(wzDest, L"garbage");
}

TEST(CrtTest, GetLengthIsConstexpr)
{
    constexpr size_t uLen = string::getLength("compile time");
    static_assert(uLen == 12);
    EXPECT_EQ(uLen, 12u);
}

TEST(CrtTest, ToLowerIsConstexpr)
{
    constexpr char cLower = string::toLower('X');
    static_assert(cLower == 'x');
    EXPECT_EQ(cLower, 'x');
}

TEST(CrtTest, GetCountOfIsConstexpr)
{
    constexpr int arrTest[42] = {};
    constexpr size_t uCount = getCountOf(arrTest);
    static_assert(uCount == 42);
    EXPECT_EQ(uCount, 42u);
}

TEST(CrtTest, CompareIgnoreCaseEqual)
{
    EXPECT_EQ(string::compareIgnoreCase(L"ntdll.dll", L"NTDLL.DLL"), 0);
    EXPECT_EQ(string::compareIgnoreCase(L"Kernel32.dll", L"kernel32.dll"), 0);
    EXPECT_EQ(string::compareIgnoreCase(L"", L""), 0);
}

TEST(CrtTest, CompareIgnoreCaseDifferent)
{
    EXPECT_NE(string::compareIgnoreCase(L"ntdll.dll", L"kernel32.dll"), 0);
    EXPECT_NE(string::compareIgnoreCase(L"abc", L"abd"), 0);
}

TEST(CrtTest, CompareIgnoreCaseOrdering)
{
    EXPECT_LT(string::compareIgnoreCase(L"abc", L"abd"), 0);
    EXPECT_GT(string::compareIgnoreCase(L"abd", L"abc"), 0);
    EXPECT_LT(string::compareIgnoreCase(L"ABC", L"ABD"), 0);
}

TEST(CrtTest, CompareIgnoreCaseLengthDifference)
{
    EXPECT_LT(string::compareIgnoreCase(L"abc", L"abcd"), 0);
    EXPECT_GT(string::compareIgnoreCase(L"abcd", L"abc"), 0);
}

TEST(CrtTest, CompareIgnoreCaseIsConstexpr)
{
    constexpr int nResult = string::compareIgnoreCase(L"Test", L"TEST");
    static_assert(nResult == 0);
    EXPECT_EQ(nResult, 0);
}

TEST(CrtTest, ToLowerWcharIsConstexpr)
{
    constexpr wchar_t wcLower = string::toLower(L'X');
    static_assert(wcLower == L'x');
    EXPECT_EQ(wcLower, L'x');
}
```

`tests/test_hash.cpp`:

```cpp
#include <gtest/gtest.h>
#include <syscalls-cpp/hash.hpp>

using namespace syscall::hashing;

TEST(HashTest, CompileTimeHashNotZero)
{
    constexpr auto uHash = calculateHash("NtAllocateVirtualMemory");
    static_assert(uHash != 0);
    EXPECT_NE(uHash, 0);
}

TEST(HashTest, DifferentStringsDifferentHashes)
{
    constexpr auto uHash1 = calculateHash("NtAllocateVirtualMemory");
    constexpr auto uHash2 = calculateHash("NtFreeVirtualMemory");
    static_assert(uHash1 != uHash2);
    EXPECT_NE(uHash1, uHash2);
}

TEST(HashTest, SameStringSameHash)
{
    constexpr auto uHash1 = calculateHash("ntdll.dll");
    constexpr auto uHash2 = calculateHash("ntdll.dll");
    static_assert(uHash1 == uHash2);
    EXPECT_EQ(uHash1, uHash2);
}

TEST(HashTest, RuntimeMatchesCompileTime)
{
    constexpr auto uCompileTimeHash = calculateHash("NtClose");
    auto uRuntimeHash = calculateHashRuntime("NtClose");
    EXPECT_EQ(uCompileTimeHash, uRuntimeHash);
}

TEST(HashTest, PartialHashWithLength)
{
    constexpr auto uFullHash = calculateHash("Nt");
    constexpr auto uPartialHash = calculateHash("NtAllocateVirtualMemory", 2);
    static_assert(uFullHash == uPartialHash);
    EXPECT_EQ(uFullHash, uPartialHash);
}

TEST(HashTest, RuntimePartialHashWithLength)
{
    auto uFullHash = calculateHashRuntime("Zw");
    auto uPartialHash = calculateHashRuntime("ZwAllocateVirtualMemory", 2);
    EXPECT_EQ(uFullHash, uPartialHash);
}

TEST(HashTest, StringViewWorks)
{
    std::string_view svName = "NtQuerySystemInformation";
    auto uSvHash = calculateHashRuntime(svName);
    auto uPtrHash = calculateHashRuntime("NtQuerySystemInformation");
    EXPECT_EQ(uSvHash, uPtrHash);
}

TEST(HashTest, StringViewPartial)
{
    std::string_view svName = "NtClose";
    std::string_view svPartial = svName.substr(0, 2);
    auto uPartialHash = calculateHashRuntime(svPartial);
    auto uExpectedHash = calculateHashRuntime("Nt");
    EXPECT_EQ(uPartialHash, uExpectedHash);
}

TEST(HashTest, EmptyString)
{
    auto uHash = calculateHashRuntime("");
    EXPECT_EQ(uHash, polyKey1);
}

TEST(HashTest, SeedIsConsistent)
{
    EXPECT_EQ(currentSeed, getCompileTimeSeed());
}

TEST(HashTest, CommonNtFunctionsUnique)
{
    constexpr auto uHash1 = calculateHash("NtClose");
    constexpr auto uHash2 = calculateHash("NtOpenProcess");
    constexpr auto uHash3 = calculateHash("NtReadFile");
    constexpr auto uHash4 = calculateHash("NtWriteFile");
    constexpr auto uHash5 = calculateHash("NtCreateFile");

    EXPECT_NE(uHash1, uHash2);
    EXPECT_NE(uHash1, uHash3);
    EXPECT_NE(uHash1, uHash4);
    EXPECT_NE(uHash1, uHash5);
    EXPECT_NE(uHash2, uHash3);
    EXPECT_NE(uHash2, uHash4);
    EXPECT_NE(uHash2, uHash5);
    EXPECT_NE(uHash3, uHash4);
    EXPECT_NE(uHash3, uHash5);
    EXPECT_NE(uHash4, uHash5);
}

TEST(HashTest, DllNamesUnique)
{
    constexpr auto uHash1 = calculateHash("ntdll.dll");
    constexpr auto uHash2 = calculateHash("kernel32.dll");
    constexpr auto uHash3 = calculateHash("user32.dll");

    EXPECT_NE(uHash1, uHash2);
    EXPECT_NE(uHash1, uHash3);
    EXPECT_NE(uHash2, uHash3);
}

```

`tests/test_integration.cpp`:

```cpp
#include <gtest/gtest.h>
#include <syscalls-cpp/syscall.hpp>

class SyscallManagerTest : public ::testing::Test {};

TEST_F(SyscallManagerTest, InitializesWithSectionDirect)
{
    syscall::Manager<
        syscall::policies::allocator::section,
        syscall::policies::generator::direct
    > manager;

    EXPECT_TRUE(manager.initialize());
}

TEST_F(SyscallManagerTest, InitializesWithHeapDirect)
{
    syscall::Manager<
        syscall::policies::allocator::heap,
        syscall::policies::generator::direct
    > manager;

    EXPECT_TRUE(manager.initialize());
}

TEST_F(SyscallManagerTest, InitializesWithMemoryDirect)
{
    syscall::Manager<
        syscall::policies::allocator::memory,
        syscall::policies::generator::direct
    > manager;

    EXPECT_TRUE(manager.initialize());
}

#if SYSCALL_PLATFORM_WINDOWS_64
TEST_F(SyscallManagerTest, InitializesWithGadgetX64)
{
    syscall::Manager<
        syscall::policies::allocator::section,
        syscall::policies::generator::gadget
    > manager;

    EXPECT_TRUE(manager.initialize());
}

TEST_F(SyscallManagerTest, InitializesWithExceptionX64)
{
    syscall::Manager<
        syscall::policies::allocator::section,
        syscall::policies::generator::exception
    > manager;

    EXPECT_TRUE(manager.initialize());
}
#endif

TEST_F(SyscallManagerTest, DoubleInitSucceeds)
{
    SyscallSectionDirect manager;
    EXPECT_TRUE(manager.initialize());
    EXPECT_TRUE(manager.initialize());
}

TEST_F(SyscallManagerTest, MoveConstructorWorks)
{
    SyscallSectionDirect manager1;
    ASSERT_TRUE(manager1.initialize());

    SyscallSectionDirect manager2 = std::move(manager1);

    PVOID pBaseAddress = nullptr;
    SIZE_T uRegionSize = 0x1000;

    NTSTATUS status = manager2.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        0,
        &uRegionSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    EXPECT_TRUE(NT_SUCCESS(status));

    if (pBaseAddress)
    {
        uRegionSize = 0;
        manager2.invoke<NTSTATUS>(
            SYSCALL_ID("NtFreeVirtualMemory"),
            syscall::native::getCurrentProcess(),
            &pBaseAddress,
            &uRegionSize,
            MEM_RELEASE
        );
    }
}

class SyscallInvokeTest : public ::testing::Test
{
protected:
    SyscallSectionDirect manager;

    void SetUp() override
    {
        ASSERT_TRUE(manager.initialize());
    }
};

TEST_F(SyscallInvokeTest, NtAllocateVirtualMemory)
{
    PVOID pBaseAddress = nullptr;
    SIZE_T uRegionSize = 0x1000;

    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        0,
        &uRegionSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    EXPECT_TRUE(NT_SUCCESS(status));
    EXPECT_NE(pBaseAddress, nullptr);
    EXPECT_GE(uRegionSize, 0x1000u);

    if (pBaseAddress)
    {
        uRegionSize = 0;
        manager.invoke<NTSTATUS>(
            SYSCALL_ID("NtFreeVirtualMemory"),
            syscall::native::getCurrentProcess(),
            &pBaseAddress,
            &uRegionSize,
            MEM_RELEASE
        );
    }
}

TEST_F(SyscallInvokeTest, NtQuerySystemInformation)
{
    ULONG uReturnLength = 0;
    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtQuerySystemInformation"),
        0,
        nullptr,
        0,
        &uReturnLength
    );

    EXPECT_EQ(status, static_cast<NTSTATUS>(0xC0000004));
    EXPECT_GT(uReturnLength, 0u);
}

TEST_F(SyscallInvokeTest, InvalidSyscallReturnsNotFound)
{
    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtThisFunctionDoesNotExist123456")
    );

    EXPECT_EQ(status, syscall::native::STATUS_PROCEDURE_NOT_FOUND);
}

TEST_F(SyscallInvokeTest, NtCloseInvalidHandle)
{
    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtClose"),
        reinterpret_cast<HANDLE>(0xDEADBEEF)
    );

    EXPECT_EQ(status, static_cast<NTSTATUS>(0xC0000008));
}

class NativeApiTest : public ::testing::Test {};

TEST_F(NativeApiTest, GetModuleBaseNtdll)
{
    HMODULE hNtdll = syscall::native::getModuleBase(
        syscall::hashing::calculateHash("ntdll.dll")
    );
    EXPECT_NE(hNtdll, nullptr);
}

TEST_F(NativeApiTest, GetModuleBaseKernel32)
{
    HMODULE hKernel32 = syscall::native::getModuleBase(
        syscall::hashing::calculateHash("kernel32.dll")
    );
    EXPECT_NE(hKernel32, nullptr);
}

TEST_F(NativeApiTest, GetModuleBaseWideString)
{
    HMODULE hNtdll = syscall::native::getModuleBase(L"ntdll.dll");
    EXPECT_NE(hNtdll, nullptr);
}

TEST_F(NativeApiTest, GetModuleBaseInvalidReturnsNull)
{
    HMODULE hInvalid = syscall::native::getModuleBase(
        syscall::hashing::calculateHash("this_dll_does_not_exist.dll")
    );
    EXPECT_EQ(hInvalid, nullptr);
}

TEST_F(NativeApiTest, GetExportAddressNtClose)
{
    HMODULE hNtdll = syscall::native::getModuleBase(
        syscall::hashing::calculateHash("ntdll.dll")
    );
    ASSERT_NE(hNtdll, nullptr);

    void* pNtClose = syscall::native::getExportAddress(hNtdll, SYSCALL_ID("NtClose"));
    EXPECT_NE(pNtClose, nullptr);
}

TEST_F(NativeApiTest, GetExportAddressWithStringName)
{
    HMODULE hNtdll = syscall::native::getModuleBase(
        syscall::hashing::calculateHash("ntdll.dll")
    );
    ASSERT_NE(hNtdll, nullptr);

    void* pNtClose = syscall::native::getExportAddress(hNtdll, "NtClose");
    EXPECT_NE(pNtClose, nullptr);
}

TEST_F(NativeApiTest, GetExportAddressInvalidReturnsNull)
{
    HMODULE hNtdll = syscall::native::getModuleBase(
        syscall::hashing::calculateHash("ntdll.dll")
    );
    ASSERT_NE(hNtdll, nullptr);

    void* pInvalid = syscall::native::getExportAddress(
        hNtdll,
        SYSCALL_ID("ThisExportDoesNotExist123")
    );
    EXPECT_EQ(pInvalid, nullptr);
}

TEST_F(NativeApiTest, GetCurrentPEBNotNull)
{
    auto pPeb = syscall::native::getCurrentPEB();
    EXPECT_NE(pPeb, nullptr);
}

TEST_F(NativeApiTest, RdtscpReturnsValue)
{
    uint64_t uValue1 = syscall::native::rdtscp();
    uint64_t uValue2 = syscall::native::rdtscp();

    EXPECT_NE(uValue1, uValue2);
    EXPECT_NE(uValue1, 0u);
}

TEST(ManagerOwnershipTest, MoveAssignmentWorks)
{
    SyscallSectionDirect manager1;
    ASSERT_TRUE(manager1.initialize());

    SyscallSectionDirect manager2;
    manager2 = std::move(manager1);

    PVOID pAddress = nullptr;
    SIZE_T uRegionSize = 0x1000;

    NTSTATUS status = manager2.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pAddress,
        0,
        &uRegionSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    EXPECT_TRUE(NT_SUCCESS(status));

    if (pAddress)
    {
        uRegionSize = 0;
        manager2.invoke<NTSTATUS>(
            SYSCALL_ID("NtFreeVirtualMemory"),
            syscall::native::getCurrentProcess(),
            &pAddress,
            &uRegionSize,
            MEM_RELEASE
        );
    }
}

class NativeApiExtendedTest : public ::testing::Test {};

TEST_F(NativeApiExtendedTest, CalculateHashRuntimeCiBasic)
{
    auto uHash1 = syscall::native::calculateHashRuntimeCi(L"ntdll.dll");
    auto uHash2 = syscall::native::calculateHashRuntimeCi(L"NTDLL.DLL");
    auto uHash3 = syscall::native::calculateHashRuntimeCi(L"NtDlL.DlL");

    EXPECT_EQ(uHash1, uHash2);
    EXPECT_EQ(uHash1, uHash3);
    EXPECT_NE(uHash1, 0u);
}

TEST_F(NativeApiExtendedTest, CalculateHashRuntimeCiDifferentStrings)
{
    auto uHash1 = syscall::native::calculateHashRuntimeCi(L"ntdll.dll");
    auto uHash2 = syscall::native::calculateHashRuntimeCi(L"kernel32.dll");

    EXPECT_NE(uHash1, uHash2);
}

TEST_F(NativeApiExtendedTest, CalculateHashRuntimeCiWcharNull)
{
    auto uHash = syscall::native::calculateHashRuntimeCi(static_cast<const wchar_t*>(nullptr));
    EXPECT_EQ(uHash, 0u);
}

TEST_F(NativeApiExtendedTest, CalculateHashRuntimeCiEmpty)
{
    auto uHash = syscall::native::calculateHashRuntimeCi(L"");
    EXPECT_EQ(uHash, syscall::hashing::polyKey1);
}

TEST_F(NativeApiExtendedTest, CalculateHashRuntimeCiCharBasic)
{
    auto uHash1 = syscall::native::calculateHashRuntimeCi("ntdll");
    auto uHash2 = syscall::native::calculateHashRuntimeCi("NTDLL");
    auto uHash3 = syscall::native::calculateHashRuntimeCi("NtDlL");

    EXPECT_EQ(uHash1, uHash2);
    EXPECT_EQ(uHash1, uHash3);
    EXPECT_NE(uHash1, 0u);
}

TEST_F(NativeApiExtendedTest, CalculateHashRuntimeCiCharNull)
{
    auto uHash = syscall::native::calculateHashRuntimeCi(static_cast<const char*>(nullptr));
    EXPECT_EQ(uHash, 0u);
}

TEST_F(NativeApiExtendedTest, CalculateHashRuntimeCiCharMatchesWchar)
{
    auto uHashChar = syscall::native::calculateHashRuntimeCi("kernel32");
    auto uHashWchar = syscall::native::calculateHashRuntimeCi(L"kernel32");

    EXPECT_EQ(uHashChar, uHashWchar);
}

TEST_F(NativeApiExtendedTest, GetModuleBaseNullWideString)
{
    HMODULE hModule = syscall::native::getModuleBase(static_cast<const wchar_t*>(nullptr));
    EXPECT_EQ(hModule, nullptr);
}

TEST_F(NativeApiExtendedTest, GetModuleBaseCaseInsensitive)
{
    HMODULE hNtdll1 = syscall::native::getModuleBase(L"ntdll.dll");
    HMODULE hNtdll2 = syscall::native::getModuleBase(L"NTDLL.DLL");
    HMODULE hNtdll3 = syscall::native::getModuleBase(L"NtDlL.DlL");

    EXPECT_NE(hNtdll1, nullptr);
    EXPECT_EQ(hNtdll1, hNtdll2);
    EXPECT_EQ(hNtdll1, hNtdll3);
}

TEST_F(NativeApiExtendedTest, GetExportAddressNullModule)
{
    void* pAddr = syscall::native::getExportAddress(nullptr, "NtClose");
    EXPECT_EQ(pAddr, nullptr);
}

TEST_F(NativeApiExtendedTest, GetExportAddressNullName)
{
    HMODULE hNtdll = syscall::native::getModuleBase(L"ntdll.dll");
    ASSERT_NE(hNtdll, nullptr);

    void* pAddr = syscall::native::getExportAddress(hNtdll, static_cast<const char*>(nullptr));
    EXPECT_EQ(pAddr, nullptr);
}

TEST_F(NativeApiExtendedTest, GetExportAddressHashNullModule)
{
    void* pAddr = syscall::native::getExportAddress(nullptr, SYSCALL_ID("NtClose"));
    EXPECT_EQ(pAddr, nullptr);
}

TEST_F(NativeApiExtendedTest, GetExportAddressMultipleFunctions)
{
    HMODULE hNtdll = syscall::native::getModuleBase(L"ntdll.dll");
    ASSERT_NE(hNtdll, nullptr);

    void* pNtClose = syscall::native::getExportAddress(hNtdll, "NtClose");
    void* pNtOpenProcess = syscall::native::getExportAddress(hNtdll, "NtOpenProcess");
    void* pNtReadFile = syscall::native::getExportAddress(hNtdll, "NtReadFile");

    EXPECT_NE(pNtClose, nullptr);
    EXPECT_NE(pNtOpenProcess, nullptr);
    EXPECT_NE(pNtReadFile, nullptr);
    EXPECT_NE(pNtClose, pNtOpenProcess);
    EXPECT_NE(pNtClose, pNtReadFile);
}

TEST_F(NativeApiExtendedTest, GetExportAddressForwardedFunction)
{
    HMODULE hKernel32 = syscall::native::getModuleBase(L"kernel32.dll");
    ASSERT_NE(hKernel32, nullptr);

    void* pHeapAlloc = syscall::native::getExportAddress(hKernel32, "HeapAlloc");
    EXPECT_NE(pHeapAlloc, nullptr);
}

TEST_F(NativeApiExtendedTest, GetExportAddressZwFunctions)
{
    HMODULE hNtdll = syscall::native::getModuleBase(L"ntdll.dll");
    ASSERT_NE(hNtdll, nullptr);

    void* pZwClose = syscall::native::getExportAddress(hNtdll, "ZwClose");
    void* pNtClose = syscall::native::getExportAddress(hNtdll, "NtClose");

    EXPECT_NE(pZwClose, nullptr);
    EXPECT_NE(pNtClose, nullptr);
}

TEST_F(NativeApiExtendedTest, GetCurrentPEBFields)
{
    auto pPeb = syscall::native::getCurrentPEB();
    ASSERT_NE(pPeb, nullptr);

    EXPECT_NE(pPeb->Ldr, nullptr);
    EXPECT_NE(pPeb->ProcessParameters, nullptr);
}

TEST_F(NativeApiExtendedTest, RdtscpIncreasing)
{
    uint64_t uValues[10];
    for (int i = 0; i < 10; ++i)
        uValues[i] = syscall::native::rdtscp();

    for (int i = 1; i < 10; ++i)
        EXPECT_GT(uValues[i], uValues[i - 1]);
}

TEST_F(NativeApiExtendedTest, IsSuccessFunction)
{
    EXPECT_TRUE(syscall::native::isSuccess(0));
    EXPECT_TRUE(syscall::native::isSuccess(0x00000001));
    EXPECT_FALSE(syscall::native::isSuccess(static_cast<NTSTATUS>(0xC0000001)));
    EXPECT_FALSE(syscall::native::isSuccess(static_cast<NTSTATUS>(0x80000001)));
}

TEST_F(NativeApiExtendedTest, GetCurrentProcessHandle)
{
    HANDLE hProcess = syscall::native::getCurrentProcess();
    EXPECT_EQ(hProcess, reinterpret_cast<HANDLE>(-1));
}

class SyscallPolicyTest : public ::testing::Test {};

TEST_F(SyscallPolicyTest, SignatureParserDirect)
{
    syscall::Manager<
        syscall::policies::allocator::section,
        syscall::policies::generator::direct,
        syscall::policies::parser::signature
    > manager;

    EXPECT_TRUE(manager.initialize());

    PVOID pBaseAddress = nullptr;
    SIZE_T uRegionSize = 0x1000;

    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        0,
        &uRegionSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    EXPECT_TRUE(NT_SUCCESS(status));

    if (pBaseAddress)
    {
        uRegionSize = 0;
        manager.invoke<NTSTATUS>(
            SYSCALL_ID("NtFreeVirtualMemory"),
            syscall::native::getCurrentProcess(),
            &pBaseAddress,
            &uRegionSize,
            MEM_RELEASE
        );
    }
}

TEST_F(SyscallPolicyTest, DirectoryParserDirect)
{
    syscall::Manager<
        syscall::policies::allocator::section,
        syscall::policies::generator::direct,
        syscall::policies::parser::directory
    > manager;

    EXPECT_TRUE(manager.initialize());

    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtClose"),
        reinterpret_cast<HANDLE>(0xDEADBEEF)
    );

    EXPECT_EQ(status, static_cast<NTSTATUS>(0xC0000008));
}

TEST_F(SyscallPolicyTest, HeapAllocatorWithSignatureParser)
{
    syscall::Manager<
        syscall::policies::allocator::heap,
        syscall::policies::generator::direct,
        syscall::policies::parser::signature
    > manager;

    EXPECT_TRUE(manager.initialize());

    ULONG uReturnLength = 0;
    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtQuerySystemInformation"),
        0,
        nullptr,
        0,
        &uReturnLength
    );

    EXPECT_EQ(status, static_cast<NTSTATUS>(0xC0000004));
}

TEST_F(SyscallPolicyTest, MemoryAllocatorWithSignatureParser)
{
    syscall::Manager<
        syscall::policies::allocator::memory,
        syscall::policies::generator::direct,
        syscall::policies::parser::signature
    > manager;

    EXPECT_TRUE(manager.initialize());

    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtClose"),
        reinterpret_cast<HANDLE>(0xDEADBEEF)
    );

    EXPECT_EQ(status, static_cast<NTSTATUS>(0xC0000008));
}

#if SYSCALL_PLATFORM_WINDOWS_64
TEST_F(SyscallPolicyTest, GadgetGeneratorWithSignatureParser)
{
    syscall::Manager<
        syscall::policies::allocator::section,
        syscall::policies::generator::gadget,
        syscall::policies::parser::signature
    > manager;

    EXPECT_TRUE(manager.initialize());

    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtClose"),
        reinterpret_cast<HANDLE>(0xDEADBEEF)
    );

    EXPECT_EQ(status, static_cast<NTSTATUS>(0xC0000008));
}

TEST_F(SyscallPolicyTest, ExceptionGeneratorWithSignatureParser)
{
    syscall::Manager<
        syscall::policies::allocator::section,
        syscall::policies::generator::exception,
        syscall::policies::parser::signature
    > manager;

    EXPECT_TRUE(manager.initialize());

    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtClose"),
        reinterpret_cast<HANDLE>(0xDEADBEEF)
    );

    EXPECT_EQ(status, static_cast<NTSTATUS>(0xC0000008));
}
#endif

TEST_F(SyscallPolicyTest, InvokeWithoutInitialize)
{
    SyscallSectionDirect manager;

    PVOID pBaseAddress = nullptr;
    SIZE_T uRegionSize = 0x1000;

    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        0,
        &uRegionSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    EXPECT_TRUE(NT_SUCCESS(status));
    EXPECT_NE(pBaseAddress, nullptr);

    if (pBaseAddress)
    {
        uRegionSize = 0;
        manager.invoke<NTSTATUS>(
            SYSCALL_ID("NtFreeVirtualMemory"),
            syscall::native::getCurrentProcess(),
            &pBaseAddress,
            &uRegionSize,
            MEM_RELEASE
        );
    }
}

TEST_F(SyscallPolicyTest, MultipleSyscallsSequentially)
{
    SyscallSectionDirect manager;
    ASSERT_TRUE(manager.initialize());

    for (int i = 0; i < 100; ++i)
    {
        PVOID pBaseAddress = nullptr;
        SIZE_T uRegionSize = 0x1000;

        NTSTATUS status = manager.invoke<NTSTATUS>(
            SYSCALL_ID("NtAllocateVirtualMemory"),
            syscall::native::getCurrentProcess(),
            &pBaseAddress,
            0,
            &uRegionSize,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE
        );

        EXPECT_TRUE(NT_SUCCESS(status));

        if (pBaseAddress)
        {
            uRegionSize = 0;
            manager.invoke<NTSTATUS>(
                SYSCALL_ID("NtFreeVirtualMemory"),
                syscall::native::getCurrentProcess(),
                &pBaseAddress,
                &uRegionSize,
                MEM_RELEASE
            );
        }
    }
}

TEST_F(SyscallPolicyTest, NtProtectVirtualMemory)
{
    SyscallSectionDirect manager;
    ASSERT_TRUE(manager.initialize());

    PVOID pBaseAddress = nullptr;
    SIZE_T uRegionSize = 0x1000;

    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        0,
        &uRegionSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    ASSERT_TRUE(NT_SUCCESS(status));
    ASSERT_NE(pBaseAddress, nullptr);

    ULONG uOldProtect = 0;
    SIZE_T uProtectSize = 0x1000;
    PVOID pProtectAddress = pBaseAddress;

    status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtProtectVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pProtectAddress,
        &uProtectSize,
        PAGE_EXECUTE_READ,
        &uOldProtect
    );

    EXPECT_TRUE(NT_SUCCESS(status));
    EXPECT_EQ(uOldProtect, PAGE_READWRITE);

    uRegionSize = 0;
    manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtFreeVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        &uRegionSize,
        MEM_RELEASE
    );
}

TEST_F(SyscallPolicyTest, NtQueryVirtualMemory)
{
    SyscallSectionDirect manager;
    ASSERT_TRUE(manager.initialize());

    PVOID pBaseAddress = nullptr;
    SIZE_T uRegionSize = 0x1000;

    NTSTATUS status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtAllocateVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        0,
        &uRegionSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    ASSERT_TRUE(NT_SUCCESS(status));

    MEMORY_BASIC_INFORMATION memInfo{};
    SIZE_T uReturnLength = 0;

    status = manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtQueryVirtualMemory"),
        syscall::native::getCurrentProcess(),
        pBaseAddress,
        0,
        &memInfo,
        sizeof(memInfo),
        &uReturnLength
    );

    EXPECT_TRUE(NT_SUCCESS(status));
    EXPECT_EQ(memInfo.BaseAddress, pBaseAddress);
    EXPECT_EQ(memInfo.Protect, PAGE_READWRITE);
    EXPECT_EQ(memInfo.State, MEM_COMMIT);

    uRegionSize = 0;
    manager.invoke<NTSTATUS>(
        SYSCALL_ID("NtFreeVirtualMemory"),
        syscall::native::getCurrentProcess(),
        &pBaseAddress,
        &uRegionSize,
        MEM_RELEASE
    );
}


```