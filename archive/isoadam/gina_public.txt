Project Path: arc_isoadam_gina_public_obajs6eb

Source Tree:

```txt
arc_isoadam_gina_public_obajs6eb
├── gina.sln
├── src
│   ├── control
│   │   ├── control.vcxproj
│   │   ├── control.vcxproj.filters
│   │   ├── control.vcxproj.user
│   │   ├── gina
│   │   │   ├── driver.cpp
│   │   │   └── driver.h
│   │   ├── main.cpp
│   │   ├── nt
│   │   │   └── handle.h
│   │   └── nt.h
│   └── driver
│       ├── dispatch.cpp
│       ├── dispatch.h
│       ├── driver.cpp
│       ├── driver.h
│       ├── driver.vcxproj
│       ├── driver.vcxproj.filters
│       ├── driver.vcxproj.user
│       ├── gina.h
│       ├── nt
│       │   ├── memory.h
│       │   ├── portable_executable.h
│       │   ├── reference.cpp
│       │   └── reference.h
│       ├── nt.cpp
│       ├── nt.h
│       └── utilities.h
└── vendor
    └── processhacker

```

`gina.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.329
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "driver", "src\driver\driver.vcxproj", "{E1834C23-0688-4E7F-A005-F0D25044665A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "control", "src\control\control.vcxproj", "{1B6CC9DC-D4BC-41A6-BE7B-EB21E6B0AB38}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{F44BC3BC-B926-4906-A2F6-ECCD53A74005}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		README.md = README.md
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E1834C23-0688-4E7F-A005-F0D25044665A}.Debug|x64.ActiveCfg = Debug|x64
		{E1834C23-0688-4E7F-A005-F0D25044665A}.Debug|x64.Build.0 = Debug|x64
		{E1834C23-0688-4E7F-A005-F0D25044665A}.Debug|x64.Deploy.0 = Debug|x64
		{E1834C23-0688-4E7F-A005-F0D25044665A}.Release|x64.ActiveCfg = Release|x64
		{E1834C23-0688-4E7F-A005-F0D25044665A}.Release|x64.Build.0 = Release|x64
		{E1834C23-0688-4E7F-A005-F0D25044665A}.Release|x64.Deploy.0 = Release|x64
		{1B6CC9DC-D4BC-41A6-BE7B-EB21E6B0AB38}.Debug|x64.ActiveCfg = Debug|x64
		{1B6CC9DC-D4BC-41A6-BE7B-EB21E6B0AB38}.Debug|x64.Build.0 = Debug|x64
		{1B6CC9DC-D4BC-41A6-BE7B-EB21E6B0AB38}.Release|x64.ActiveCfg = Release|x64
		{1B6CC9DC-D4BC-41A6-BE7B-EB21E6B0AB38}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2D750847-F7F7-488A-BCE0-EBB0FF1904F5}
	EndGlobalSection
EndGlobal

```

`src/control/control.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="gina\driver.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="gina\driver.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{1B6CC9DC-D4BC-41A6-BE7B-EB21E6B0AB38}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>control</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)bin\obj\$(PlatformShortName)\$(Configuration)\$(ProjectName)\</IntDir>
    <IncludePath>$(SolutionDir)vendor\processhacker\phnt\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)bin\obj\$(PlatformShortName)\$(Configuration)\$(ProjectName)\</IntDir>
    <IncludePath>$(SolutionDir)vendor\processhacker\phnt\include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <ObjectFileName>$(IntDir)%(RelativeDir)%(Filename)%(Extension).obj</ObjectFileName>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <ObjectFileName>$(IntDir)%(RelativeDir)%(Filename)%(Extension).obj</ObjectFileName>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`src/control/control.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="gina\driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="nt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt\handle.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="gina\driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>

```

`src/control/control.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`src/control/gina/driver.cpp`:

```cpp
#include "driver.h"

using namespace gina;

bool driver::open()
{
  UNICODE_STRING object_name;
  OBJECT_ATTRIBUTES object_attributes;
  IO_STATUS_BLOCK io_status_block;

  RtlInitUnicodeString(&object_name, const_cast<wchar_t*>(device_path));
  InitializeObjectAttributes(&object_attributes, &object_name, OBJ_CASE_INSENSITIVE, NULL, NULL);

  HANDLE handle;
  if (NT_SUCCESS(NtOpenFile(&handle, FILE_GENERIC_READ | FILE_GENERIC_WRITE, &object_attributes, &io_status_block, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE)))
  {
    driver::handle = nt::handle(handle);
    return true;
  }

  return false;
}

void driver::close()
{
  handle.reset();
}

bool driver::opened()
{
  return handle != nullptr && handle.get() != INVALID_HANDLE_VALUE;
}

bool driver::is_present()
{
  return ioctl_present();
}

std::uintptr_t driver::get_image_base(unsigned long process_id)
{
  ioctl_image_base_parameters parameters = {};
  parameters.process_id = process_id;

  ioctl_image_base(parameters);

  return parameters.image_base;
}

std::uintptr_t driver::get_peb_address(unsigned long process_id)
{
  ioctl_peb_parameters parameters = {};
  parameters.process_id = process_id;

  ioctl_peb(parameters);

  return parameters.peb;
}

bool driver::read(unsigned long process_id, std::uintptr_t address, void* buffer, std::size_t size)
{
	ioctl_copy_memory_parameters parameters = {};
  parameters.process_id = process_id;
  parameters.buffer = reinterpret_cast<std::uintptr_t>(buffer);
  parameters.address = address;
  parameters.size = size;
  parameters.write = false;

  return ioctl_copy_memory(parameters);
}

bool driver::write(unsigned long process_id, std::uintptr_t address, void* buffer, std::size_t size)
{
	ioctl_copy_memory_parameters parameters = {};
  parameters.process_id = process_id;
  parameters.buffer = reinterpret_cast<std::uintptr_t>(buffer);
  parameters.address = address;
  parameters.size = size;
  parameters.write = true;

  return ioctl_copy_memory(parameters);
}

std::uintptr_t driver::allocate(unsigned long process_id, std::uintptr_t base_address, std::size_t size, unsigned long type, unsigned long protect)
{
  ioctl_allocate_memory_parameters parameters = {};
  parameters.process_id = process_id;
  parameters.base_address = base_address;
  parameters.size = size;
  parameters.type = type;
  parameters.protect = protect;

  if (ioctl_allocate_memory(parameters))
  {
    return parameters.base_address;
  }

  return 0;
}

bool driver::free(unsigned long process_id, std::uintptr_t base_address, std::size_t size, unsigned long type)
{
  ioctl_free_memory_parameters parameters = {};
  parameters.process_id = process_id;
  parameters.base_address = base_address;
  parameters.size = size;
  parameters.type = type;

  return ioctl_free_memory(parameters);
}

bool driver::remove_nx(unsigned long process_id, std::uintptr_t base_address, std::size_t size)
{
  ioctl_remove_nx_parameters parameters = {};
  parameters.process_id = process_id;
  parameters.base_address = base_address;
  parameters.size = size;

  return ioctl_remove_nx(parameters);
}

bool driver::ioctl_present()
{
  return DeviceIoControl(handle.get(), ioctl_code_present, NULL, 0, NULL, 0, NULL, NULL);
}

bool driver::ioctl_unload()
{
  return DeviceIoControl(handle.get(), ioctl_code_unload, NULL, 0, NULL, 0, NULL, NULL);
}

bool driver::ioctl_clear_unloaded(ioctl_code_clear_unloaded_parameters& parameters)
{
  return DeviceIoControl(handle.get(), ioctl_code_clear_unloaded, &parameters, sizeof(parameters), NULL, 0, NULL, NULL);
}

bool driver::ioctl_image_base(ioctl_image_base_parameters& parameters)
{
  return DeviceIoControl(handle.get(), ioctl_code_image_base, &parameters, sizeof(parameters), &parameters, sizeof(parameters), NULL, NULL);
}

bool driver::ioctl_peb(ioctl_peb_parameters& parameters)
{
  return DeviceIoControl(handle.get(), ioctl_code_peb, &parameters, sizeof(parameters), &parameters, sizeof(parameters), NULL, NULL);
}

bool driver::ioctl_copy_memory(ioctl_copy_memory_parameters& parameters)
{
  return DeviceIoControl(handle.get(), ioctl_code_copy_memory, &parameters, sizeof(parameters), NULL, 0, NULL, NULL);
}

bool driver::ioctl_allocate_memory(ioctl_allocate_memory_parameters& parameters)
{
  return DeviceIoControl(handle.get(), ioctl_code_allocate_memory, &parameters, sizeof(parameters), &parameters, sizeof(parameters), NULL, NULL);
}

bool driver::ioctl_free_memory(ioctl_free_memory_parameters& parameters)
{
  return DeviceIoControl(handle.get(), ioctl_code_free_memory, &parameters, sizeof(parameters), &parameters, sizeof(parameters), NULL, NULL);
}

bool driver::ioctl_remove_nx(ioctl_remove_nx_parameters& parameters)
{
  return DeviceIoControl(handle.get(), ioctl_code_remove_nx, &parameters, sizeof(parameters), &parameters, sizeof(parameters), NULL, NULL);
}

```

`src/control/gina/driver.h`:

```h
#pragma once

#include "../nt.h"
#include "../../driver/gina.h"
#include <string>

namespace gina
{
  namespace driver
  {
    constexpr const auto device_path = L"\\Device\\Null";

    static nt::handle handle = {};

    bool open();
    void close();
    bool opened();

    bool is_present();
    std::uintptr_t get_image_base(unsigned long process_id);
    std::uintptr_t get_peb_address(unsigned long process_id);
    bool read(unsigned long process_id, std::uintptr_t address, void* buffer, std::size_t size);
    bool write(unsigned long process_id, std::uintptr_t address, void* buffer, std::size_t size);
    std::uintptr_t allocate(unsigned long process_id, std::uintptr_t base_address, std::size_t size, unsigned long type, unsigned long protect);
    bool free(unsigned long process_id, std::uintptr_t base_address, std::size_t size, unsigned long type);
    bool remove_nx(unsigned long process_id, std::uintptr_t base_address, std::size_t size);

    template <typename T>
    T read(unsigned long process_id, std::uintptr_t address)
    {
      T buffer;
      if (read(process_id, address, &buffer, sizeof(T)))
      {
        return buffer;
      }

      return {};
    }

    template <typename T>
    void write(unsigned long process_id, std::uintptr_t address, const T& buffer)
    {
      write(process_id, address, &buffer, sizeof(T));
    }

    inline bool ioctl_present();
    inline bool ioctl_unload();
    inline bool ioctl_clear_unloaded(ioctl_code_clear_unloaded_parameters& parameters);
    inline bool ioctl_image_base(ioctl_image_base_parameters& parameters);
    inline bool ioctl_peb(ioctl_peb_parameters& paramaters);
    inline bool ioctl_copy_memory(ioctl_copy_memory_parameters& parameters);
    inline bool ioctl_allocate_memory(ioctl_allocate_memory_parameters& parameters);
    inline bool ioctl_free_memory(ioctl_free_memory_parameters& parameters);
    inline bool ioctl_remove_nx(ioctl_remove_nx_parameters& parameters);
  }
}

```

`src/control/main.cpp`:

```cpp
#include "gina/driver.h"

int main(int argc, char* argv[])
{
  if (!gina::driver::open())
  {
    throw std::runtime_error("failed to open handle to device");
  }

  if (!gina::driver::is_present())
  {
    throw std::runtime_error("failed to communicate with patched device");
  }

  return 0;
}

```

`src/control/nt.h`:

```h
#pragma once

#define PHNT_VERSION PHNT_THRESHOLD

#include <phnt_windows.h>
#include <phnt.h>

#pragma comment(lib, "ntdll.lib")

#include "nt/handle.h"

```

`src/control/nt/handle.h`:

```h
#pragma once

#include "../nt.h"
#include <memory>
#include <type_traits>

namespace nt
{
  template <typename T, void(*closer)(T*)>
  struct handle_deleter
  {
    void operator()(T* handle)
    {
      closer(handle);
    }
  };

  template <typename T, void(*closer)(T*)>
  using generic_handle = std::unique_ptr<T, handle_deleter<T, closer>>;

  using handle = generic_handle<std::remove_pointer<HANDLE>::type, reinterpret_cast<void(*)(HANDLE)>(CloseHandle)>;
  using sc_handle = generic_handle<std::remove_pointer<SC_HANDLE>::type, reinterpret_cast<void(*)(SC_HANDLE)>(CloseServiceHandle)>;
}

```

`src/driver/dispatch.cpp`:

```cpp
#include "dispatch.h"

NTSTATUS dispatch_image_base(gina::ioctl_image_base_parameters* parameters)
{
  auto process = nt::reference_process(parameters->process_id);
  if (process == nullptr)
  {
    return STATUS_NOT_FOUND;
  }

  parameters->image_base = reinterpret_cast<std::uintptr_t>(PsGetProcessSectionBaseAddress(process.get()));

  return STATUS_SUCCESS;
}

NTSTATUS dispatch_peb(gina::ioctl_peb_parameters* parameters)
{
  auto process = nt::reference_process(parameters->process_id);
  if (process == nullptr)
  {
    return STATUS_NOT_FOUND;
  }

  parameters->peb = reinterpret_cast<std::uintptr_t>(PsGetProcessPeb(process.get()));

  return STATUS_SUCCESS;
}

NTSTATUS dispatch_copy_memory(gina::ioctl_copy_memory_parameters* parameters)
{
  auto process = nt::reference_process(parameters->process_id);
  if (process == nullptr)
  {
    return STATUS_NOT_FOUND;
  }

  const auto buffer = reinterpret_cast<void*>(parameters->buffer);
  const auto address = reinterpret_cast<void*>(parameters->address);

  // beware: no size check on buffers occurs
  if (!MmIsAddressValid(buffer))
  {
    return STATUS_ACCESS_VIOLATION;
  }

  KAPC_STATE kapc_state;
  KeStackAttachProcess(process.get(), &kapc_state);

  if (!MmIsAddressValid(address))
  {
    KeUnstackDetachProcess(&kapc_state);
    return STATUS_ACCESS_VIOLATION;
  }

  KeUnstackDetachProcess(&kapc_state);

  std::size_t bytes_copied;
  if (parameters->write)
  {
    return MmCopyVirtualMemory(IoGetCurrentProcess(), buffer, process.get(), address, parameters->size, KernelMode, &bytes_copied);
  }
  else
  {
    return MmCopyVirtualMemory(process.get(), address, IoGetCurrentProcess(), buffer, parameters->size, KernelMode, &bytes_copied);
  }
}

NTSTATUS dispatch_allocate_memory(gina::ioctl_allocate_memory_parameters* parameters)
{
  auto process = nt::reference_process(parameters->process_id);
  if (process == nullptr)
  {
    return STATUS_NOT_FOUND;
  }

  KAPC_STATE kapc_state;
  KeStackAttachProcess(process.get(), &kapc_state);

  const auto status = ZwAllocateVirtualMemory(NtCurrentProcess(), reinterpret_cast<void**>(&parameters->base_address), 0, &parameters->size, parameters->type, parameters->protect);

  KeUnstackDetachProcess(&kapc_state);

  return status;
}

NTSTATUS dispatch_free_memory(gina::ioctl_free_memory_parameters* parameters)
{
  auto process = nt::reference_process(parameters->process_id);
  if (process == nullptr)
  {
    return STATUS_NOT_FOUND;
  }

  KAPC_STATE kapc_state;
  KeStackAttachProcess(process.get(), &kapc_state);

  const auto status = NtFreeVirtualMemory(NtCurrentProcess(), reinterpret_cast<void**>(&parameters->base_address), &parameters->size, parameters->type);

  KeUnstackDetachProcess(&kapc_state);

  return status;
}

NTSTATUS dispatch_remove_nx(gina::ioctl_remove_nx_parameters* parameters)
{
  auto process = nt::reference_process(parameters->process_id);
  if (process == nullptr)
  {
    return STATUS_NOT_FOUND;
  }

  if (MiGetPteAddress == nullptr)
  {
    return STATUS_UNSUCCESSFUL;
  }

  for (std::uintptr_t page = parameters->base_address; page < parameters->base_address + parameters->size; page += PAGE_SIZE)
  {
    if (auto pte = MiGetPteAddress(reinterpret_cast<void*>(page)); pte != nullptr)
    {
      if (pte->Hardware.Valid)
      {
        pte->Hardware.NoExecute = 0;
      }
    }
    else
    {
      return STATUS_ACCESS_VIOLATION;
    }
  }

  return STATUS_SUCCESS;
}

```

`src/driver/dispatch.h`:

```h
#pragma once

#include "nt.h"
#include "gina.h"

NTSTATUS dispatch_image_base(gina::ioctl_image_base_parameters* parameters);
NTSTATUS dispatch_peb(gina::ioctl_peb_parameters* parameters);
NTSTATUS dispatch_copy_memory(gina::ioctl_copy_memory_parameters* parameters);
NTSTATUS dispatch_allocate_memory(gina::ioctl_allocate_memory_parameters* parameters);
NTSTATUS dispatch_free_memory(gina::ioctl_free_memory_parameters* parameters);
NTSTATUS dispatch_remove_nx(gina::ioctl_remove_nx_parameters* parameters);

```

`src/driver/driver.cpp`:

```cpp
#include "driver.h"

#include "nt.h"
#include "gina.h"
#include "utilities.h"
#include "dispatch.h"
#include <algorithm>

#ifdef max
#undef max
#endif

DRIVER_DISPATCH* null_original_irp_device_control = {};

// mov rax, 0i64
// jmp rax
const unsigned char jmp_buffer[] = { 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0 };

NTSTATUS DriverEntry(DRIVER_OBJECT* driver_object, UNICODE_STRING* registry_path)
{
  UNREFERENCED_PARAMETER(registry_path);

  driver_object->DriverUnload = unload;

  return initialise();
}

NTSTATUS initialise()
{
  MiGetPteAddress = utilities::find_pattern<decltype(MiGetPteAddress)>(nt::kernel_base_address(), nt::kernel_base_size(), "\x48\xC1\xE9\x09\x48\xB8\xF8\xFF\xFF\xFF\x7F\x00\x00\x00\x48\x23\xC8\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\x48\x03\xC1\xC3", "xxxxxxxxxxxxxxxxxxx????????xxxx");
  if (MiGetPteAddress == nullptr)
  {
    return STATUS_UNSUCCESSFUL;
  }

  auto null_driver_object = nt::reference_driver(L"\\Driver\\Null");
  if (null_driver_object == nullptr)
  {
    return STATUS_UNSUCCESSFUL;
  }

  PIMAGE_SECTION_HEADER null_discardable_section_header = {};

  const auto null_nt_headers = RtlImageNtHeader(null_driver_object->DriverStart);
  const auto first_section = IMAGE_FIRST_SECTION(null_nt_headers);

  for (PIMAGE_SECTION_HEADER section = first_section; section < first_section + null_nt_headers->FileHeader.NumberOfSections; section++)
  {
    // assume INIT section is RWX - implement assert
    if (section->Characteristics & 0x02000000 && section->Misc.VirtualSize > 0 && section->Misc.VirtualSize <= PAGE_SIZE) // IMAGE_SCN_MEM_DISCARDABLE
    {
      null_discardable_section_header = section;
      break;
    }
  }

  if (null_discardable_section_header == nullptr)
  {
    return STATUS_UNSUCCESSFUL;
  }

  const auto discardable_section = reinterpret_cast<void*>(reinterpret_cast<std::uintptr_t>(null_driver_object->DriverStart) + null_discardable_section_header->VirtualAddress);
  auto discardable_section_pte = MiGetPteAddress(discardable_section);

  const auto discardable_allocated_buffer = ExAllocatePool(NonPagedPool, ROUND_TO_PAGES(null_discardable_section_header->Misc.VirtualSize)); // not currently handling more than 1 page anyhow
  auto discardable_allocated_buffer_pte = MiGetPteAddress(discardable_allocated_buffer);

  if (discardable_section_pte == nullptr || discardable_allocated_buffer_pte == nullptr)
  {
    return STATUS_UNSUCCESSFUL;
  }

  // copy pte
  *discardable_section_pte = *discardable_allocated_buffer_pte;

  // create hook
  memcpy(discardable_section, jmp_buffer, sizeof(jmp_buffer));
  *reinterpret_cast<void**>(&reinterpret_cast<unsigned char*>(discardable_section)[2]) = &device_control;

  // replace dispatch function
  null_original_irp_device_control = null_driver_object->MajorFunction[IRP_MJ_DEVICE_CONTROL];
  null_driver_object->MajorFunction[IRP_MJ_DEVICE_CONTROL] = reinterpret_cast<DRIVER_DISPATCH*>(discardable_section);

  return STATUS_SUCCESS;
}

void unload(DRIVER_OBJECT* driver_object)
{
  if (driver_object != nullptr && null_original_irp_device_control != nullptr)
  {
    if (auto null_driver_object = nt::reference_driver(L"\\Driver\\Null"); null_driver_object.get() != nullptr)
    {
      null_driver_object->MajorFunction[IRP_MJ_DEVICE_CONTROL] = null_original_irp_device_control;
    }
  }
}

NTSTATUS device_control(DEVICE_OBJECT* device_object, IRP* irp)
{
  const auto io_stack_location = IoGetCurrentIrpStackLocation(irp);
  auto& buffer = irp->AssociatedIrp.SystemBuffer;
  auto& status = irp->IoStatus.Status;

  if (io_stack_location->MajorFunction == IRP_MJ_DEVICE_CONTROL)
  {
    const auto io_control_code = io_stack_location->Parameters.DeviceIoControl.IoControlCode;
    const auto buffer_length = std::max(io_stack_location->Parameters.DeviceIoControl.InputBufferLength, io_stack_location->Parameters.DeviceIoControl.OutputBufferLength);

    switch (io_control_code)
    {
    case gina::ioctl_code_present:
      status = STATUS_SUCCESS;

      break;

    case gina::ioctl_code_unload:
      // unhook
      // set success/complete irp
      // jmp to asm to modify registers/stack to call ExFreePool but return to parent

      status = STATUS_UNSUCCESSFUL;

      break;

    case gina::ioctl_code_clear_unloaded:
      status = STATUS_UNSUCCESSFUL;

      break;

    case gina::ioctl_code_image_base:
      if (buffer_length >= sizeof(gina::ioctl_image_base_parameters))
      {
        status = dispatch_image_base(static_cast<gina::ioctl_image_base_parameters*>(buffer));
        irp->IoStatus.Information = sizeof(gina::ioctl_image_base_parameters);
      }
      else
      {
        status = STATUS_INFO_LENGTH_MISMATCH;
      }

      break;

    case gina::ioctl_code_peb:
      if (buffer_length >= sizeof(gina::ioctl_peb_parameters))
      {
        status = dispatch_peb(static_cast<gina::ioctl_peb_parameters*>(buffer));
        irp->IoStatus.Information = sizeof(gina::ioctl_peb_parameters);
      }
      else
      {
        status = STATUS_INFO_LENGTH_MISMATCH;
      }

      break;

    case gina::ioctl_code_copy_memory:
      if (buffer_length >= sizeof(gina::ioctl_copy_memory_parameters))
      {
        status = dispatch_copy_memory(static_cast<gina::ioctl_copy_memory_parameters*>(buffer));
        irp->IoStatus.Information = sizeof(gina::ioctl_copy_memory_parameters);
      }
      else
      {
        status = STATUS_INFO_LENGTH_MISMATCH;
      }

      break;

    case gina::ioctl_code_allocate_memory:
      if (buffer_length >= sizeof(gina::ioctl_allocate_memory_parameters))
      {
        status = dispatch_allocate_memory(static_cast<gina::ioctl_allocate_memory_parameters*>(buffer));
        irp->IoStatus.Information = sizeof(gina::ioctl_allocate_memory_parameters);
      }
      else
      {
        status = STATUS_INFO_LENGTH_MISMATCH;
      }

      break;

    case gina::ioctl_code_free_memory:
      if (buffer_length >= sizeof(gina::ioctl_free_memory_parameters))
      {
        status = dispatch_free_memory(static_cast<gina::ioctl_free_memory_parameters*>(buffer));
        irp->IoStatus.Information = sizeof(gina::ioctl_free_memory_parameters);
      }
      else
      {
        status = STATUS_INFO_LENGTH_MISMATCH;
      }

      break;

    case gina::ioctl_code_remove_nx:
      if (buffer_length >= sizeof(gina::ioctl_remove_nx_parameters))
      {
        status = dispatch_remove_nx(static_cast<gina::ioctl_remove_nx_parameters*>(buffer));
        irp->IoStatus.Information = sizeof(gina::ioctl_remove_nx_parameters);
      }
      else
      {
        status = STATUS_INFO_LENGTH_MISMATCH;
      }

      break;

    default:
      return null_original_irp_device_control(device_object, irp);
    }
  }
  else
  {
    status = STATUS_UNSUCCESSFUL;
  }

  IoCompleteRequest(irp, IO_NO_INCREMENT);

  return status;
}

```

`src/driver/driver.h`:

```h
#pragma once

#include "nt.h"

extern "C" NTSTATUS DriverEntry(DRIVER_OBJECT* driver_object, UNICODE_STRING* registry_path);
extern "C" NTSTATUS initialise();
void unload(DRIVER_OBJECT* driver_object);
NTSTATUS device_control(DEVICE_OBJECT* device_object, IRP* irp);

```

`src/driver/driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E1834C23-0688-4E7F-A005-F0D25044665A}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>driver</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)bin\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)bin\obj\$(PlatformShortName)\$(Configuration)\$(ProjectName)\</IntDir>
    <IncludePath>$(SolutionDir)vendor\processhacker\phnt\include;$(VC_IncludePath);$(IncludePath)</IncludePath>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)bin\$(PlatformShortName)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)bin\obj\$(PlatformShortName)\$(Configuration)\$(ProjectName)\</IntDir>
    <IncludePath>$(SolutionDir)vendor\processhacker\phnt\include;$(VC_IncludePath);$(IncludePath)</IncludePath>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ObjectFileName>$(IntDir)%(RelativeDir)%(Filename)%(Extension).obj</ObjectFileName>
      <DisableSpecificWarnings>4201;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <EntryPointSymbol>FxDriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <ObjectFileName>$(IntDir)%(RelativeDir)%(Filename)%(Extension).obj</ObjectFileName>
      <DisableSpecificWarnings>4201;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <EntryPointSymbol>initialise</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dispatch.cpp" />
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="nt.cpp" />
    <ClCompile Include="nt\reference.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dispatch.h" />
    <ClInclude Include="driver.h" />
    <ClInclude Include="gina.h" />
    <ClInclude Include="nt.h" />
    <ClInclude Include="nt\memory.h" />
    <ClInclude Include="nt\portable_executable.h" />
    <ClInclude Include="nt\reference.h" />
    <ClInclude Include="utilities.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/driver/driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dispatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="nt.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="nt\reference.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="nt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="gina.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dispatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utilities.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt\reference.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt\portable_executable.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt\memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/driver/driver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <SignMode>Off</SignMode>
    <RemoveDriver>True</RemoveDriver>
    <InstallMode>None</InstallMode>
    <HardwareIdString />
    <CommandLine />
    <ScriptPath>C:\Program Files (x86)\Windows Kits\10\Testing\Tests\Utilities\DefaultDriverPackageInstallationTask.dll</ScriptPath>
    <DbgengRemoteMachineName>vm</DbgengRemoteMachineName>
    <DbgengKernelMachineName>vm</DbgengKernelMachineName>
    <DeployFiles />
    <ScriptName>Microsoft.DriverKit.DefaultDriverPackageInstallationClass.PerformDefaultDriverPackageInstallation</ScriptName>
    <ScriptDeviceQuery />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
    <RemoveDriver>False</RemoveDriver>
    <InstallMode>InstallAndVerify</InstallMode>
    <HardwareIdString />
    <CommandLine />
    <ScriptPath>C:\Program Files (x86)\Windows Kits\10\Testing\Tests\Utilities\DefaultDriverPackageInstallationTask.dll</ScriptPath>
    <DbgengRemoteMachineName>vm</DbgengRemoteMachineName>
    <DbgengKernelMachineName>vm</DbgengKernelMachineName>
    <DeployFiles />
    <ScriptName>Microsoft.DriverKit.DefaultDriverPackageInstallationClass.PerformDefaultDriverPackageInstallation</ScriptName>
    <ScriptDeviceQuery />
  </PropertyGroup>
</Project>
```

`src/driver/gina.h`:

```h
#pragma once

#include <cstddef>
#include <cstdint>

namespace gina
{
  constexpr unsigned long gina_ioctl_code(int function)
  {
    return CTL_CODE(FILE_DEVICE_UNKNOWN, function, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
  }

  constexpr auto ioctl_code_present = gina_ioctl_code(0x800);
  constexpr auto ioctl_code_unload = gina_ioctl_code(0x801);
  constexpr auto ioctl_code_clear_unloaded = gina_ioctl_code(0x802);
  constexpr auto ioctl_code_image_base = gina_ioctl_code(0x803);
  constexpr auto ioctl_code_peb = gina_ioctl_code(0x804);
  constexpr auto ioctl_code_copy_memory = gina_ioctl_code(0x805);
  constexpr auto ioctl_code_allocate_memory = gina_ioctl_code(0x806);
  constexpr auto ioctl_code_free_memory = gina_ioctl_code(0x807);
  constexpr auto ioctl_code_remove_nx = gina_ioctl_code(0x808);

  struct ioctl_code_clear_unloaded_parameters
  {

  };

  struct ioctl_image_base_parameters
  {
    unsigned long process_id;
    std::uintptr_t image_base;
  };

  struct ioctl_peb_parameters
  {
    unsigned long process_id;
    std::uintptr_t peb;
  };

  struct ioctl_copy_memory_parameters
  {
    unsigned long process_id;
    std::uintptr_t buffer;
    std::uintptr_t address;
    std::size_t size;
    bool write;
  };

  struct ioctl_allocate_memory_parameters
  {
    unsigned long process_id;
    std::uintptr_t base_address;
    std::size_t size;
    unsigned long type;
    unsigned long protect;
  };

  struct ioctl_free_memory_parameters
  {
    unsigned long process_id;
    std::uintptr_t base_address;
    std::size_t size;
    unsigned long type;
  };

  struct ioctl_remove_nx_parameters
  {
    unsigned long process_id;
    std::uintptr_t base_address;
    std::size_t size;
  };
}

```

`src/driver/nt.cpp`:

```cpp
#include "nt.h"

#include <intrin.h>

void* nt::kernel_base_address()
{
  return *reinterpret_cast<void**>(reinterpret_cast<std::uintptr_t>(PsLoadedModuleList) + 0x30);
}

std::size_t nt::kernel_base_size()
{
  return *reinterpret_cast<std::size_t*>(reinterpret_cast<std::uintptr_t>(PsLoadedModuleList) + 0x40);
}

std::uintptr_t nt::get_process_cr3(PEPROCESS process)
{
  KAPC_STATE kapc_state;
  KeStackAttachProcess(process, &kapc_state);

  const auto cr3 = __readcr3();

  KeUnstackDetachProcess(&kapc_state);

  return cr3;
}

// unexported
PMMPTE(NTAPI *MiGetPteAddress)(PVOID VirtualAddress) = nullptr;

```

`src/driver/nt.h`:

```h
#pragma once

#define PHNT_MODE PHNT_MODE_KERNEL
#define PHNT_VERSION PHNT_THRESHOLD

#include <ntifs.h>
#include <phnt.h>

#include <cstddef>
#include <cstdint>

#include "nt/memory.h"
#include "nt/portable_executable.h"
#include "nt/reference.h"

namespace nt
{
  void* kernel_base_address();
  std::size_t kernel_base_size();

  std::uintptr_t get_process_cr3(PEPROCESS process);

  template <typename T = void*>
  auto get_system_routine(const wchar_t* routine_name) -> T
  {
    UNICODE_STRING routine_unicode_name;
    RtlInitUnicodeString(&routine_unicode_name, routine_name);

    return reinterpret_cast<T>(MmGetSystemRoutineAddress(&routine_unicode_name));
  }
}

// undocumented imports
extern "C" __declspec(dllimport) POBJECT_TYPE* IoDriverObjectType;
extern "C" __declspec(dllimport) PLIST_ENTRY PsLoadedModuleList;

extern "C" __declspec(dllimport) NTSTATUS NTAPI MmCopyVirtualMemory(PEPROCESS FromProcess, PVOID FromAddress, PEPROCESS ToProcess, PVOID ToAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T NumberOfBytesCopied);
extern "C" __declspec(dllimport) NTSTATUS NTAPI ObReferenceObjectByName(PUNICODE_STRING ObjectName, ULONG Attributes, PACCESS_STATE AccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID ParseContext OPTIONAL, PVOID* Object);
extern "C" __declspec(dllimport) PVOID NTAPI PsGetProcessSectionBaseAddress(PEPROCESS Process);
extern "C" __declspec(dllimport) PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(PVOID Base);
extern "C" __declspec(dllimport) PPEB NTAPI PsGetProcessPeb(PEPROCESS Process);

// unexported
extern PMMPTE(NTAPI *MiGetPteAddress)(PVOID VirtualAddress);

```

`src/driver/nt/memory.h`:

```h
#pragma once

#include "../nt.h"

typedef struct _MMPTE_HARDWARE
{
  ULONGLONG Valid : 1;
  ULONGLONG Writable : 1;
  ULONGLONG Owner : 1;
  ULONGLONG WriteThrough : 1;
  ULONGLONG CacheDisable : 1;
  ULONGLONG Accessed : 1;
  ULONGLONG Dirty : 1;
  ULONGLONG LargePage : 1;
  ULONGLONG Global : 1;
  ULONGLONG CopyOnWrite : 1;
  ULONGLONG Prototype : 1;
  ULONGLONG Write : 1;
  ULONGLONG PageFrameNumber : 40;
  ULONGLONG Reserved : 11;
  ULONGLONG NoExecute : 1;
} MMPTE_HARDWARE, *PMMPTE_HARDWARE;

typedef union _MMPTE
{
  ULONG_PTR Long;
  MMPTE_HARDWARE Hardware;
} MMPTE, *PMMPTE;

```

`src/driver/nt/portable_executable.h`:

```h
#pragma once

#include "../nt.h"

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

typedef struct _IMAGE_FILE_HEADER
{
  USHORT Machine;
  USHORT NumberOfSections;
  ULONG TimeDateStamp;
  ULONG PointerToSymbolTable;
  ULONG NumberOfSymbols;
  USHORT SizeOfOptionalHeader;
  USHORT Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY
{
  ULONG VirtualAddress;
  ULONG Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_SECTION_HEADER
{
  UCHAR  Name[8];
  union
  {
    ULONG PhysicalAddress;
    ULONG VirtualSize;
  } Misc;
  ULONG VirtualAddress;
  ULONG SizeOfRawData;
  ULONG PointerToRawData;
  ULONG PointerToRelocations;
  ULONG PointerToLinenumbers;
  USHORT NumberOfRelocations;
  USHORT NumberOfLinenumbers;
  ULONG Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64
{
  USHORT Magic;
  UCHAR MajorLinkerVersion;
  UCHAR MinorLinkerVersion;
  ULONG SizeOfCode;
  ULONG SizeOfInitializedData;
  ULONG SizeOfUninitializedData;
  ULONG AddressOfEntryPoint;
  ULONG BaseOfCode;
  ULONGLONG ImageBase;
  ULONG SectionAlignment;
  ULONG FileAlignment;
  USHORT MajorOperatingSystemVersion;
  USHORT MinorOperatingSystemVersion;
  USHORT MajorImageVersion;
  USHORT MinorImageVersion;
  USHORT MajorSubsystemVersion;
  USHORT MinorSubsystemVersion;
  ULONG Win32VersionValue;
  ULONG SizeOfImage;
  ULONG SizeOfHeaders;
  ULONG CheckSum;
  USHORT Subsystem;
  USHORT DllCharacteristics;
  ULONGLONG SizeOfStackReserve;
  ULONGLONG SizeOfStackCommit;
  ULONGLONG SizeOfHeapReserve;
  ULONGLONG SizeOfHeapCommit;
  ULONG LoaderFlags;
  ULONG NumberOfRvaAndSizes;
  struct _IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64
{
  ULONG Signature;
  struct _IMAGE_FILE_HEADER FileHeader;
  struct _IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

//
typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(ntheader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))

```

`src/driver/nt/reference.cpp`:

```cpp
#include "reference.h"

nt::driver_reference nt::reference_driver(const wchar_t* object_path, unsigned long attributes, KPROCESSOR_MODE access_mode)
{
  UNICODE_STRING object_path_unicide;
  RtlInitUnicodeString(&object_path_unicide, object_path);

  DRIVER_OBJECT* object;
  if (NT_SUCCESS(ObReferenceObjectByName(&object_path_unicide, attributes, NULL, NULL, *IoDriverObjectType, access_mode, NULL, reinterpret_cast<void**>(&object))))
  {
    return nt::driver_reference(object);
  }

  return {};
}

nt::process_reference nt::reference_process(unsigned long process_id)
{
  PEPROCESS process;
  if (NT_SUCCESS(PsLookupProcessByProcessId(reinterpret_cast<HANDLE>(process_id), &process)))
  {
    return nt::process_reference(process);
  }

  return {};
}

```

`src/driver/nt/reference.h`:

```h
#pragma once

#include "../nt.h"

#include <memory>

namespace nt
{
  template <typename T, void(*dereference)(T*)>
  struct object_reference_deleter
  {
    void operator()(T* object)
    {
      dereference(object);
    }
  };

  template <typename T, auto dereference = reinterpret_cast<void(*)(T*)>(ObfDereferenceObject)>
  using object_reference = std::unique_ptr<T, object_reference_deleter<T, dereference>>;

  using driver_reference = object_reference<DRIVER_OBJECT>;
  using process_reference = object_reference<std::remove_pointer<PEPROCESS>::type>;

  driver_reference reference_driver(const wchar_t* object_path, unsigned long attributes = 0, KPROCESSOR_MODE access_mode = KernelMode);
  process_reference reference_process(unsigned long process_id);
}

```

`src/driver/utilities.h`:

```h
#pragma once

#include "nt.h"

#include <cstddef>
#include <cstdint>

namespace utilities
{
  template <typename T = void*>
  T find_pattern(void* start, std::size_t length, const char* pattern, const char* mask)
  {
    const auto data = static_cast<const char*>(start);
    const auto pattern_length = strlen(mask);

    for (std::size_t i = 0; i <= length - pattern_length; i++)
    {
      bool accumulative_found = true;

      for (std::size_t j = 0; j < pattern_length; j++)
      {
        if (!MmIsAddressValid(reinterpret_cast<void*>(reinterpret_cast<std::intptr_t>(data) + i + j)))
        {
          accumulative_found = false;
          break;
        }

        if (data[i + j] != pattern[j] && mask[j] != '?')
        {
          accumulative_found = false;
          break;
        }
      }

      if (accumulative_found)
      {
        return reinterpret_cast<T>(reinterpret_cast<std::intptr_t>(data) + i);
      }
    }

    return nullptr;
  }
}

```