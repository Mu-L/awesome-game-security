Project Path: arc_Oliver-1-1_UEFI-Graphic_y1tn4toe

Source Tree:

```txt
arc_Oliver-1-1_UEFI-Graphic_y1tn4toe
├── README.md
└── VisualUefi-master
    ├── UEFI-Graphics
    │   ├── UEFI-Graphics
    │   │   ├── General.cpp
    │   │   ├── General.hpp
    │   │   ├── Graphics
    │   │   │   ├── Color.hpp
    │   │   │   ├── Drawable.cpp
    │   │   │   ├── Drawable.hpp
    │   │   │   ├── Graphics.cpp
    │   │   │   ├── Graphics.hpp
    │   │   │   ├── Screen.cpp
    │   │   │   ├── Screen.hpp
    │   │   │   ├── Shapes
    │   │   │   │   ├── Circle.cpp
    │   │   │   │   ├── Circle.hpp
    │   │   │   │   ├── Rectangle.cpp
    │   │   │   │   ├── Rectangle.hpp
    │   │   │   │   ├── Text.cpp
    │   │   │   │   └── Text.hpp
    │   │   │   ├── Transformable.cpp
    │   │   │   └── Transformable.hpp
    │   │   ├── Main.cpp
    │   │   ├── Misc.cpp
    │   │   ├── Network
    │   │   │   ├── Tcp.cpp
    │   │   │   ├── Tcp.hpp
    │   │   │   ├── Udp.cpp
    │   │   │   └── Udp.hpp
    │   │   ├── UEFI-Graphics.filters
    │   │   ├── UEFI-Graphics.user
    │   │   ├── UEFI-Graphics.vcxproj
    │   │   ├── UEFI-Graphics.vcxproj.filters
    │   │   ├── UEFI-Graphics.vcxproj.user
    │   │   └── Utils
    │   │       ├── File.cpp
    │   │       ├── File.hpp
    │   │       ├── Mouse.cpp
    │   │       └── Mouse.hpp
    │   ├── UEFI-Graphics.sln
    │   ├── samples.default.props
    │   └── samples.props
    └── VisualUefi files removed. cuz space.txt

```

`README.md`:

```md
# UEFI-Graphic - Simpel usage of graphic in UEFI.
UEFI-Graphic brings graphics to UEFI in a simple way and it is written in C++. 
Visual-efi is used for development environment

The project will support:
1. Basic shapes                // Done
2. Basic text                  // Done
3. Basic mouse support         // Done
4. Basic file management// Done
5. Basic transform of shapes   // Done.
6. Basic internet connectivity // Not started

Might want to add rotation to transform. The issue is i can't seem to get float support to work.
## Usage

 It has a very simple usage and abstracts all the protocol and buffer searching that is essential for UEFI.
 This shows a very simple use case
```
CAPI EFI_STATUS EFIAPI UefiMain(IN EFI_HANDLE ImageHandle,IN EFI_SYSTEM_TABLE* SystemTable){
  constexpr EFI_STATUS efi_status = EFI_SUCCESS;
    
  Text t(50, 50, 2, Color::WHITE, (CHAR8*)"UEFI is fun but a pain in the ass.", (CHAR16*) L"font.fnt");
  Text t1(175, 100, 1, Color::WHITE, (CHAR8*)"LMAO what is this. Zepta.....", (CHAR16*)L"font.fnt");

  Circle c(500, 500, 50, Color::RED);
  Rectangle r(350, 500, 50, 50, Color::GREEN);

  Screen s(800, 600);
 
  s.ClearBackground(Color::BLUE);
  s.Render(t);
  s.Render(c);
  s.Render(r);
  s.Render(t1);

  return efi_status
}
```

## Images

This picture shows the result of the above code. It all looks like it came from the 90s but it mostly has to do with the font.

![](https://i.imgur.com/KFhdh41.png)

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UEFI-Graphics", "UEFI-Graphics\UEFI-Graphics.vcxproj", "{7C6C4292-DEA3-4FF8-8D68-79BDCCF67A8A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7C6C4292-DEA3-4FF8-8D68-79BDCCF67A8A}.Release|x64.ActiveCfg = Release|x64
		{7C6C4292-DEA3-4FF8-8D68-79BDCCF67A8A}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A04A1491-658E-4A30-996F-49278518F2E4}
	EndGlobalSection
EndGlobal

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/General.cpp`:

```cpp
#pragma once
#include <Uefi.h>

extern "C" const UINT8 _gDriverUnloadImageCount = 1;
extern "C" const UINT32 _gUefiDriverRevision = 0x200;
extern "C" const UINT32 _gDxeRevision = 0x200;

//Add in vshack.h aswell
extern "C" CHAR8* gEfiCallerBaseName = (CHAR8*)"Zepta";

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/General.hpp`:

```hpp
#pragma once

#define CAPI extern "C"
//#define printf(text) Print((const CHAR16*)text);


#include <IndustryStandard/SmBios.h>
#include <IndustryStandard/Usb.h>
#include <Protocol/SimplePointer.h>

CAPI{
    #include <Uefi.h>
    #include <Library/UefiLib.h>
    #include <Library/DebugLib.h>
    #include <Library/MemoryAllocationLib.h>
    #include <Library/BaseMemoryLib.h>   
    #include <Library/UefiBootServicesTableLib.h>
    #include <Library/UefiRuntimeServicesTableLib.h>
    #include <Library/DebugLib.h>
    #include <Library/SynchronizationLib.h>
    #include <Library/ShellLib.h>
    #include <Guid/SmBios.h>
	#include <Library/UefiUsbLib.h>
}
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Color.hpp`:

```hpp
#pragma once
extern "C" {
#include <Uefi.h>
#include <Protocol/GraphicsOutput.h>

}
class Color{
public:
	Color(CHAR8 r, CHAR8 g, CHAR8 b, CHAR8 a) {
		col_.Red = r;
		col_.Green = g;
		col_.Blue = b;
		col_.Reserved = a; // I dont know what this does
	}

	static enum Types {
		BLACK,
		WHITE,
		BLUE,
		RED,
		GREEN
	};

	Color(Types color) { // Its not RBGA, its BGR Reserved
		if (color == BLACK) {
			EFI_GRAPHICS_OUTPUT_BLT_PIXEL c = {0,0,0,0};
			col_ = c;
		}
		if (color == WHITE) {
			EFI_GRAPHICS_OUTPUT_BLT_PIXEL c = { 255,255,255,0 };
			col_ = c;
		}
		if (color == BLUE) {
			EFI_GRAPHICS_OUTPUT_BLT_PIXEL c = { 255,0,0,0 };
			col_ = c;
		}
		if (color == RED) {
			EFI_GRAPHICS_OUTPUT_BLT_PIXEL c = { 0,0,255,0 };
			col_ = c;
		}
		if (color == GREEN) {
			EFI_GRAPHICS_OUTPUT_BLT_PIXEL c = { 0,255,0,0 };
			col_ = c;
		}
	}

	EFI_GRAPHICS_OUTPUT_BLT_PIXEL Get() { return col_; }
private:
	EFI_GRAPHICS_OUTPUT_BLT_PIXEL col_;

};
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Drawable.cpp`:

```cpp
#include "Drawable.hpp"

bool Drawable::GetVisible() const{
	return this->visible_;
}

VOID Drawable::SetVisible(bool visible){
	this->visible_ = visible;
}

Color Drawable::GetColor() const{
	return this->color_;
}

VOID Drawable::SetColor(Color color){
	this->color_ = color;
}

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Drawable.hpp`:

```hpp
#pragma once
#include "Graphics.hpp"

class Drawable{
public:
	virtual VOID Draw(Graphics& g) {};
	bool GetVisible() const;
	VOID SetVisible(bool visible);

	VOID SetColor(Color color);
	Color GetColor() const;
protected:
	~Drawable() = default;
	bool visible_ = true;
	Color color_ = Color::BLACK;

private:
};
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Graphics.cpp`:

```cpp
#include "Graphics.hpp"

VOID Graphics::Render() const {
	const auto status = gop_->Blt(gop_, blt_buffer_, ::EfiBltBufferToVideo, 0, 0, 0, 0, screen_x_size_, screen_y_size_, 0);
}

VOID Graphics::DrawRectangle(INTN x, INTN y, UINTN width, UINTN height, Color color) const {
	for (int i = 0; i < width; i++) {
		for (int j = 0; j < height; j++) {
			DrawPixel(x+i, y+j, color);
		}
	}

}

Graphics::Graphics(UINTN screen_x_size, UINTN screen_y_size) : oldx_(screen_x_size / 2), oldy_(screen_y_size / 2), screen_x_size_(screen_x_size), screen_y_size_(screen_y_size) {
	const EFI_STATUS st = gBS->LocateProtocol(&gEfiGraphicsOutputProtocolGuid, NULL, reinterpret_cast<void**>(&gop_));
	if (EFI_ERROR(st)) {
		#ifdef DEBUG
			Print((CHAR16*)L"Could not find protocol graph.\n");
		#endif

		return;
	}
	gop_->SetMode(gop_, GetProperGraphicsMode(screen_x_size, screen_y_size)); // Get the right mode for the right res. Its like settings on different resolutions.
	blt_buffer_ = new EFI_GRAPHICS_OUTPUT_BLT_PIXEL[screen_x_size * screen_y_size];
}

VOID Graphics::DrawPixel(INTN x, INTN y, Color color) const{
	if (x > screen_x_size_ || x < 0) {
		#ifdef DEBUG
			Print((CHAR16*)L"Too large writing buffer in DrawRectangle. X\n");
		#endif
		return;
	}
	if (y > screen_y_size_ || y < 0) {
		#ifdef DEBUG
			Print((CHAR16*)L"Too large writing buffer in DrawRectangle. Y\n");
		#endif

		return;
	}
	blt_buffer_[screen_x_size_ * y + x] = EFI_GRAPHICS_OUTPUT_BLT_PIXEL{ color.Get().Blue, color.Get().Green, color.Get().Red, color.Get().Reserved };
}

bool Graphics::IsProperGraphicsMode(const EFI_GRAPHICS_OUTPUT_MODE_INFORMATION* mode_info, const UINTN horizontal_resolution, const UINTN vertical_resolution) {
	return	mode_info->HorizontalResolution == horizontal_resolution && mode_info->PixelFormat == PixelBlueGreenRedReserved8BitPerColor &&
		mode_info->VerticalResolution == vertical_resolution;
}

UINT32 Graphics::GetProperGraphicsMode(const UINTN horizontal_resolution, const UINTN vertical_resolution) const {
	for (UINT32 i = 0; i < gop_->Mode->MaxMode; i++) {
		EFI_GRAPHICS_OUTPUT_MODE_INFORMATION* mode_info;
		UINTN size_of_mode_info;

		const auto status = gop_->QueryMode(gop_, i, (UINTN*)&size_of_mode_info, &mode_info);

		if (IsProperGraphicsMode(mode_info, horizontal_resolution, vertical_resolution)) {
			return i;
		}
	}

	#ifdef DEBUG
		Print((CHAR16*)L"Could not find graph mode.\n");
	#endif

	return 0;
}
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Graphics.hpp`:

```hpp
#pragma once
#include "Color.hpp"
#include "../General.hpp"

extern "C" {
	#include <Uefi.h>
	#include <Protocol/GraphicsOutput.h>
}

class Graphics {
public:
	Graphics(UINTN screen_x_size, UINTN screen_y_size);
	~Graphics() {
		delete blt_buffer_;
	}

	VOID DrawRectangle(INTN x, INTN y, UINTN width, UINTN height, Color color) const;
	VOID DrawPixel(INTN x, INTN y, Color color) const;
	VOID Render() const;

private:
	EFI_GRAPHICS_OUTPUT_BLT_PIXEL mou_[8][8];
	int oldx_, oldy_;
	EFI_GRAPHICS_OUTPUT_PROTOCOL* gop_{};
	EFI_GRAPHICS_OUTPUT_BLT_PIXEL* blt_buffer_;

	UINTN screen_x_size_, screen_y_size_;
	UINT32 GetProperGraphicsMode(const UINTN horizontal_resolution, const UINTN vertical_resolution) const;
	static bool IsProperGraphicsMode(const EFI_GRAPHICS_OUTPUT_MODE_INFORMATION* mode_info, const UINTN horizontal_resolution, const UINTN vertical_resolution);
};


```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Screen.cpp`:

```cpp
#include "Screen.hpp"

Screen::Screen(UINTN size_x, UINTN size_y) : size_x_(size_x), size_y_(size_y) {
	RemoveWatchDog();
	g_ = new Graphics(size_x, size_y);
}

VOID Screen::Render(Drawable& object) const
{
	if (object.GetVisible()) {
		object.Draw(*g_);
		g_->Render();
	}
}

VOID Screen::ClearBackground(Color color) const{
	return g_->DrawRectangle(0, 0, size_x_, size_y_, color);
}

VOID Screen::RemoveWatchDog(){
	gBS->SetWatchdogTimer(0, 0, 0, nullptr); // Default the value is 5 * 60 = 5 min. If we 0 it, its ignored.
}

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Screen.hpp`:

```hpp
#pragma once
#include "Graphics.hpp"
#include "Drawable.hpp"
class Screen{
public:
	Screen(UINTN size_x, UINTN size_y);
	VOID Render(Drawable& object) const;
	VOID ClearBackground(Color color) const;
private:
	VOID RemoveWatchDog();
	Graphics* g_;
	UINTN size_x_, size_y_;
};
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Shapes/Circle.cpp`:

```cpp
#include "Circle.hpp"

Circle::Circle(INTN x, INTN y, UINTN radius, Color color) {
	SetPosX(x);
	SetPosY(y);
	SetColor(color);
	SetRadius(radius);
}

VOID Circle::Draw(Graphics& g){ // Circle equation.
	for (UINTN x = pos_x_ - radius_; x <= pos_x_ + radius_; x++) {
		for (UINTN y = pos_y_ - radius_; y <= pos_y_ + radius_; y++) {
			if ((x - pos_x_) * (x - pos_x_) + (y - pos_y_) * (y - pos_y_) <= radius_ * radius_) {
				g.DrawPixel(x, y, color_);
			}
		}
	}
}

VOID Circle::SetSizeX(UINTN radius){
	SetRadius(radius);
}

VOID Circle::SetSizeY(UINTN radius){
	SetRadius(radius);
}

VOID Circle::SetRadius(UINTN radius){
	this->radius_ = radius;
	this->size_x_ = radius;
	this->size_y_ = radius;
}

UINTN Circle::GetRadius() const
{
	return radius_;
}

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Shapes/Circle.hpp`:

```hpp
#pragma once
#include "../Graphics.hpp"
#include "../Drawable.hpp"
#include "../Transformable.hpp"
class Circle : public Drawable, public Transformable{
public:
	Circle(INTN x, INTN y, UINTN radius, Color color);
	VOID Draw(Graphics& g) override;
	VOID SetSizeX(UINTN radius) override;
	VOID SetSizeY(UINTN radius) override;

	VOID SetRadius(UINTN radius);
	UINTN GetRadius() const;

private:
	UINTN radius_;
};
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Shapes/Rectangle.cpp`:

```cpp
#include "Rectangle.hpp"

Rectangle::Rectangle(INTN x, INTN y, UINTN size_x, UINTN size_y, Color color) {
	SetPosX(x);
	SetPosY(y);
	SetSizeX(size_x);
	SetSizeY(size_y);
	SetColor(color);
}
VOID Rectangle::Draw(Graphics& g){
	g.DrawRectangle(pos_x_, pos_y_, size_x_, size_y_, color_);

}

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Shapes/Rectangle.hpp`:

```hpp
#pragma once
#include "../Graphics.hpp"
#include "../Drawable.hpp"
#include "../Transformable.hpp"
class Rectangle : public Drawable, public Transformable{
public:
	Rectangle(INTN x, INTN y, UINTN size_x, UINTN size_y, Color color);
	VOID Draw(Graphics& g) override;

private:
};
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Shapes/Text.cpp`:

```cpp
#include "Text.hpp"
#include "../../Utils/File.hpp"

Text::Text(INTN x, INTN y, UINTN scale, Color color, CHAR8* text, CHAR16* font_name) {
	SetPosX(x);
	SetPosY(y);
	SetColor(color);
	font_name_ = font_name;
	text_ = text;
	scale_ = scale;

	File f(font_name);
	UINTN size;
	const auto data = f.ReadWide(&size);
	font_data_ = reinterpret_cast<unsigned char*>(data);

	if(size == 0){
		return;
	}
	height_ = font_data_[3];
	text_size_ = size;
}
VOID Text::Draw(Graphics& g){
	INTN x = pos_x_;
	INTN y = pos_y_;

	for(int i = 0; text_[i] != '\0'; i++) {
		if(text_[i+1] == '\n' && text_[i] == '\r') {
			x = pos_x_;
			y += height_ * scale_; 
		}
		else if(text_[i] == '\n'){
			x = pos_x_;
			y += height_ * scale_;
		}
		else if(text_[i] == '\r'){
			x = pos_x_;
		}
		else{
			const unsigned char width = DrawGlyph(g, text_[i], x, y, color_, scale_);
			x += width * scale_;
		}
		
	}
}

unsigned char Text::DrawGlyph(const Graphics& g, const char ch, UINTN x_pos, UINTN y_pos, const Color color, const UINTN scale) const{
	const unsigned char width = GetGlyphWidth(ch);
	const unsigned char* glyph = GetGlyphDataPtr(ch);

	for (int y = 0; y < height_; y++){
		for (int x = 0; x < width; x++){
			const int font_alpha = 1 - glyph[width * y + x] / 255; // Normalize the alpha
			if (font_alpha == 1) {
				g.DrawRectangle(x_pos + x * scale, y_pos + y * scale, scale, scale, Color::WHITE);
			}
		}
	}
	return width;
}

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Shapes/Text.hpp`:

```hpp
#pragma once
#include "../Graphics.hpp"
#include "../Drawable.hpp"
#include "../Transformable.hpp"
class Text : public Drawable, public Transformable{
public:
	Text(INTN x, INTN y, UINTN scale, Color color, CHAR8* text, CHAR16* font_name);
	VOID Draw(Graphics& g) override;

private:
	CHAR8* text_;
	CHAR16* font_name_;
	
	UINTN height_;
	UINTN text_size_;
	unsigned char* font_data_;

	unsigned char DrawGlyph(const Graphics& g, const char ch, UINTN x_pos, UINTN y_pos, const Color color, const UINTN scale) const;

	unsigned char GetGlyphWidth(const char ch) const{
		return font_data_[4 + 1024 * (ch - ' ')];
	}

	const unsigned char* GetGlyphDataPtr(const char ch) const{
		return &font_data_[4 + 1024 * (ch - ' ') + 1];
	}
};
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Transformable.cpp`:

```cpp
#include "Transformable.hpp"

UINTN Transformable::GetSizeX() const{
	return size_x_;
}

UINTN Transformable::GetSizeY() const{
	return size_y_;
}

INTN Transformable::GetPosX() const{
	return pos_x_;
}

INTN Transformable::GetPosY() const{
	return pos_y_;
}

VOID Transformable::SetPosX(INTN x){
	pos_x_ = x;
}

VOID Transformable::SetPosY(INTN y){
	pos_y_ = y;
}

VOID Transformable::SetSizeX(UINTN x){
	size_x_ = x;
}

VOID Transformable::SetSizeY(UINTN y){
	size_y_ = y;
}

VOID Transformable::Move(INTN x, INTN y){
	pos_x_ += x;
	pos_y_ += y;
}


```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Graphics/Transformable.hpp`:

```hpp
#pragma once
#include "Graphics.hpp"

class Transformable{
public:
	UINTN GetSizeX() const;
	UINTN GetSizeY() const;
	INTN GetPosX() const;
	INTN GetPosY() const;

	VOID SetPosX(INTN x);
	VOID SetPosY(INTN y);
	virtual VOID SetSizeX(UINTN x);
	virtual VOID SetSizeY(UINTN y);

	VOID Move(INTN x, INTN y);
	//virtual VOID Rotate(double angle);

protected:
	UINTN size_x_ = 0, size_y_ = 0;
	INTN pos_x_ = 0, pos_y_ = 0;
	UINTN scale_ = 1;

private:

	
};
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Main.cpp`:

```cpp
#include <Uefi.h>
#include "General.hpp"
#include "Graphics/Screen.hpp"
#include "Graphics/Shapes/Rectangle.hpp"
#include "Utils/File.hpp"
#include "Graphics/Shapes/Circle.hpp"
#include "Graphics/Shapes/Text.hpp"
#include "Graphics/Graphics.hpp"
#include "Utils/Mouse.hpp"
//AsciiPrint() could be used whole proj.

#define DEBUG

CAPI EFI_STATUS EFIAPI UefiUnload (IN EFI_HANDLE ImageHandle) { return 0; }

CAPI EFI_STATUS EFIAPI UefiMain(IN EFI_HANDLE ImageHandle,IN EFI_SYSTEM_TABLE* SystemTable){
	constexpr EFI_STATUS efi_status = EFI_SUCCESS;

    Text t(50, 50, 2, Color::BLACK, (CHAR8*)"UEFI is fun but a pain in the ass.", (CHAR16*) L"font.fnt");
    Text t1(175, 100, 1, Color::BLACK, (CHAR8*)"LMAO what is this. Zepta.....", (CHAR16*)L"font.fnt");

    Circle c(500, 500, 50, Color::RED);
    Rectangle r(400, 300, 5, 5, Color::GREEN);

    Screen s(800, 600);

    Mouse m(800, 600);

    File f((CHAR16*)L"Download.txt");
    f.Write((CHAR8*)"Hello1", 7); // 1 byte for end line char \0

	//s.ClearBackground(Color::BLACK);
	//s.Render(t);
	//s.Render(c);
	//s.Render(r);
	//s.Render(t1);
    for (int i = 0; i < 999999; i++) {
        s.Render(c);
        s.Render(t);
        s.Render(t1);
        s.Render(r);
        gBS->Stall(10000);
        //gST->ConOut->ClearScreen(gST->ConOut);

    }
    
    return efi_status;
}


```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Misc.cpp`:

```cpp
extern "C" {
#include <Uefi.h>
#include <Library/MemoryAllocationLib.h>
}
// Remove exceptipon in settings for no compile error

void* operator new(const unsigned long long size){
	return AllocateZeroPool(size);
}

void* operator new[](const unsigned long long size){
	return AllocateZeroPool(size);
}

void operator delete(void* buf){
	FreePool(buf);
}

void operator delete[](void* buf){
	FreePool(buf);
}

void operator delete(void* buf, const unsigned long long){
	FreePool(buf);
}

void operator delete[](void* buf, const unsigned long long){
	FreePool(buf);
}
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Network/Tcp.cpp`:

```cpp
#include "Tcp.hpp"

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Network/Tcp.hpp`:

```hpp
#pragma once
class Tcp
{
};


```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Network/Udp.cpp`:

```cpp
#include "Udp.hpp"

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Network/Udp.hpp`:

```hpp
#pragma once

//https://stackoverflow.com/questions/67045742/send-tcp-or-udp-packets-from-efi-application
//I know like 0 networking stuff
class Udp
{
};


```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/UEFI-Graphics.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Graphics\Graphics.cpp">
      <Filter>Graphics</Filter>
    </ClCompile>
    <ClCompile Include="General.c" />
    <ClCompile Include="Misc.cpp" />
    <ClCompile Include="Graphics\Drawable.cpp">
      <Filter>Graphics</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Screen.cpp">
      <Filter>Graphics</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Shapes\Mouse.cpp">
      <Filter>Graphics\Shapes</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Shapes\Rectangle.cpp">
      <Filter>Graphics\Shapes</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Transformable.cpp">
      <Filter>Graphics</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Shapes\Circle.cpp">
      <Filter>Graphics\Shapes</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Graphics">
      <UniqueIdentifier>{fc07d3fa-e3ef-4579-a851-9e77eb0403a9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Graphics\Shapes">
      <UniqueIdentifier>{af639081-6d5d-4e62-964c-2cd4cb5db048}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Graphics\Graphics.hpp">
      <Filter>Graphics</Filter>
    </ClInclude>
    <ClInclude Include="General.h" />
    <ClInclude Include="Graphics\Drawable.hpp">
      <Filter>Graphics</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Screen.hpp">
      <Filter>Graphics</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Shapes\Mouse.hpp">
      <Filter>Graphics\Shapes</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Shapes\Rectangle.hpp">
      <Filter>Graphics\Shapes</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Transformable.hpp">
      <Filter>Graphics</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Shapes\Circle.hpp">
      <Filter>Graphics\Shapes</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Color.hpp">
      <Filter>Graphics\Shapes</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/UEFI-Graphics.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/UEFI-Graphics.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7C6C4292-DEA3-4FF8-8D68-79BDCCF67A8A}</ProjectGuid>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>UEFI-Graphics</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <Import Project="$(SolutionDir)\samples.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(SolutionDir)\samples.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ItemDefinitionGroup>
    <Link>
      <AdditionalDependencies>UefiApplicationEntryPoint.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>EFI Application</SubSystem>
    </Link>
    <ClCompile>
      <TreatWarningAsError Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</TreatWarningAsError>
      <ExceptionHandling Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExceptionHandling>
      <WarningLevel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">TurnOffAllWarnings</WarningLevel>
      <LanguageStandard Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <FloatingPointModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Fast</FloatingPointModel>
      <FloatingPointExceptions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</FloatingPointExceptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Graphics\Drawable.cpp" />
    <ClCompile Include="Graphics\Graphics.cpp" />
    <ClCompile Include="Graphics\Screen.cpp" />
    <ClCompile Include="Graphics\Shapes\Circle.cpp" />
    <ClCompile Include="Graphics\Shapes\Rectangle.cpp" />
    <ClCompile Include="Graphics\Shapes\Text.cpp" />
    <ClCompile Include="Graphics\Transformable.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="General.cpp" />
    <ClCompile Include="Misc.cpp" />
    <ClCompile Include="Network\Tcp.cpp" />
    <ClCompile Include="Network\Udp.cpp" />
    <ClCompile Include="Utils\File.cpp" />
    <ClCompile Include="Utils\Mouse.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="General.hpp" />
    <ClInclude Include="Graphics\Color.hpp" />
    <ClInclude Include="Graphics\Drawable.hpp" />
    <ClInclude Include="Graphics\Graphics.hpp" />
    <ClInclude Include="Graphics\Screen.hpp" />
    <ClInclude Include="Graphics\Shapes\Circle.hpp" />
    <ClInclude Include="Graphics\Shapes\Rectangle.hpp" />
    <ClInclude Include="Graphics\Shapes\Text.hpp" />
    <ClInclude Include="Graphics\Transformable.hpp" />
    <ClInclude Include="Network\Tcp.hpp" />
    <ClInclude Include="Network\Udp.hpp" />
    <ClInclude Include="Utils\File.hpp" />
    <ClInclude Include="Utils\Mouse.hpp" />
  </ItemGroup>
</Project>
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/UEFI-Graphics.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="General.cpp" />
    <ClCompile Include="Misc.cpp" />
    <ClCompile Include="Graphics\Shapes\Circle.cpp">
      <Filter>Graphics\Shapes</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Drawable.cpp">
      <Filter>Graphics</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Graphics.cpp">
      <Filter>Graphics</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Shapes\Rectangle.cpp">
      <Filter>Graphics\Shapes</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Transformable.cpp">
      <Filter>Graphics</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Screen.cpp">
      <Filter>Graphics</Filter>
    </ClCompile>
    <ClCompile Include="Utils\File.cpp">
      <Filter>Utils</Filter>
    </ClCompile>
    <ClCompile Include="Graphics\Shapes\Text.cpp">
      <Filter>Graphics\Shapes</Filter>
    </ClCompile>
    <ClCompile Include="Network\Tcp.cpp">
      <Filter>Network</Filter>
    </ClCompile>
    <ClCompile Include="Utils\Mouse.cpp">
      <Filter>Utils</Filter>
    </ClCompile>
    <ClCompile Include="Network\Udp.cpp">
      <Filter>Network</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="General.hpp" />
    <ClInclude Include="Graphics\Shapes\Circle.hpp">
      <Filter>Graphics\Shapes</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Drawable.hpp">
      <Filter>Graphics</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Graphics.hpp">
      <Filter>Graphics</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Shapes\Rectangle.hpp">
      <Filter>Graphics\Shapes</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Color.hpp">
      <Filter>Graphics</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Transformable.hpp">
      <Filter>Graphics</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Screen.hpp">
      <Filter>Graphics</Filter>
    </ClInclude>
    <ClInclude Include="Utils\File.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Graphics\Shapes\Text.hpp">
      <Filter>Graphics\Shapes</Filter>
    </ClInclude>
    <ClInclude Include="Network\Tcp.hpp">
      <Filter>Network</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Mouse.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Network\Udp.hpp">
      <Filter>Network</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Graphics">
      <UniqueIdentifier>{26da5818-4c04-48f7-ba06-fbe60625e02b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Graphics\Shapes">
      <UniqueIdentifier>{95e7aefc-8590-427e-9ca4-e9e9993f6891}</UniqueIdentifier>
    </Filter>
    <Filter Include="Utils">
      <UniqueIdentifier>{0901b3b1-ff96-407d-b0f6-0ade2ba0cbc8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Network">
      <UniqueIdentifier>{94640072-b309-4e1c-80cc-2f8059e3d411}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/UEFI-Graphics.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommandArguments>-name "VisualUEFI Debugger" -drive file=OVMF_CODE-need-smm.fd,if=pflash,format=raw,unit=0,readonly=on -drive file=OVMF_VARS-need-smm.fd,if=pflash,format=raw,unit=1 -drive file=fat:rw:..\UEFI-Graphics\$(Platform)\$(Configuration)\,media=disk,if=virtio,format=raw -drive file=UefiShell.iso,format=raw -m 512 -machine q35,smm=on -nodefaults -vga std -global driver=cfi.pflash01,property=secure,value=on -global ICH9-LPC.disable_s3=1</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Utils/File.cpp`:

```cpp
#include "File.hpp"

File::File(const CHAR16* path){
	path_ = path;

}

VOID* File::ReadData(UINTN* size){
	EFI_GUID guid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
	EFI_HANDLE* handles = nullptr;
	UINTN count = 0;
	VOID* buffer;

	//Get buffer with handles.
	if (EFI_ERROR(gBS->LocateHandleBuffer(ByProtocol, &guid, NULL, &count, &handles)))
		return nullptr;

	EFI_FILE_PROTOCOL* file = nullptr, *root = nullptr;

	//Loop through all handles and check if we are able to open path
	for (UINTN i = 0; i < count; i++) {
		EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs = nullptr;
		if (EFI_ERROR(gBS->HandleProtocol(handles[i], &guid, reinterpret_cast<void**>(&fs))))
			continue;

		if (EFI_ERROR(fs->OpenVolume(fs, &root)))
			continue;

		if (!EFI_ERROR(root->Open(root, &file, const_cast<CHAR16*>(path_), EFI_FILE_MODE_READ, EFI_FILE_READ_ONLY | EFI_FILE_HIDDEN | EFI_FILE_SYSTEM)))
			break;
	}

	if (file == nullptr)
		return nullptr;

	//Get Size of file.

	UINTN info_size = 0;
	if (file->GetInfo(file, &info_id_, &info_size, NULL) != EFI_BUFFER_TOO_SMALL)
		return nullptr;
	if (info_size == 0)
		return nullptr;

	//Get info
	const auto info = static_cast<EFI_FILE_INFO*>(AllocatePool(info_size));
	if(EFI_ERROR(file->GetInfo(file, &info_id_, (UINTN*)&info_size, info)))
		return nullptr;

	
	UINTN file_size = info->FileSize;
	for (UINTN i = info_size; i--;)
		reinterpret_cast<unsigned char*>(info)[i] = 0;

	FreePool(info);

	//Allocate memory to store the data.
	gBS->AllocatePool(EfiBootServicesData, file_size, &buffer);
	
	if (EFI_ERROR(file->Read(file, &file_size, buffer))) {
		root->Close(file);
		root->Close(root);
		FreePool(buffer);
		return nullptr;
	}

	root->Close(file);
	root->Close(root);
	*size = file_size;

	return buffer;

}

CHAR8* File::Read(UINTN* size){
	const auto wide_string_data = ReadWide(size);
	auto sting_data = new CHAR8[*size]; // Most likely memory leak here

	for(int i = 0; i < *size / 2; i++){
		sting_data[i] = static_cast<char>(wide_string_data[i]);
	}

	return sting_data;
}

CHAR8* File::Read(){
	UINTN size = 0;
	return Read(&size);
}

CHAR16* File::ReadWide(UINTN* size){
	VOID* data = ReadData(size);

	const auto wide_string_data = static_cast<CHAR16*>(data);

	return wide_string_data;
}

CHAR16* File::ReadWide(){
	UINTN size = 0;
	return ReadWide(&size);
}

VOID File::Write(CHAR8* data, UINTN size){
	auto wide_data = new CHAR16[size];

	for(int i = 0; i < size; i++){
		wide_data[i] = data[i];
	}

	WriteWide(wide_data, size * 2);

	delete[] wide_data;
}

VOID File::WriteWide(CHAR16* data, UINTN size){
	WriteData((VOID*)data, size);
}

VOID File::WriteData(VOID* data, UINTN size){
	EFI_GUID guid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
	EFI_HANDLE* handles = nullptr;
	UINTN count = 0;
	VOID* buffer;

	//Get buffer with handles.
	if (EFI_ERROR(gBS->LocateHandleBuffer(ByProtocol, &guid, NULL, &count, &handles)))
		return;

	EFI_FILE_PROTOCOL* file = nullptr, * root = nullptr;

	//Loop through all handles and check if we are able to open path
	for (UINTN i = 0; i < count; i++) {
		EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs = nullptr;
		if (EFI_ERROR(gBS->HandleProtocol(handles[i], &guid, reinterpret_cast<void**>(&fs))))
			continue;

		if (EFI_ERROR(fs->OpenVolume(fs, &root)))
			continue;

		if (!EFI_ERROR(root->Open(root, &file, const_cast<CHAR16*>(path_), EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, EFI_FILE_HIDDEN | EFI_FILE_SYSTEM)))
			break;
	}

	if (file == nullptr)
		return;

	if(EFI_ERROR(file->Write(file, &size, data))){
		Print((CHAR16*)L"Failed to write\n");
	}
	
	root->Close(file);
	root->Close(root);

}


```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Utils/File.hpp`:

```hpp
#pragma once
#include "../General.hpp"

//Does not automatically create the file if it does not exist!
class File{
public:
	File(const CHAR16* path);
	~File() = default;

	CHAR8* Read(UINTN* size);
	CHAR8* Read();
	CHAR16* ReadWide(UINTN* size);
	CHAR16* ReadWide();
	VOID Write(CHAR8* data, UINTN size);
	VOID WriteWide(CHAR16* data, UINTN size);

private:
	VOID* ReadData(UINTN* size);
	VOID WriteData(VOID* data, UINTN size); //This works half of the time. Do not use
	const CHAR16* path_;
	EFI_GUID info_id_ = EFI_FILE_INFO_ID;

};
```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Utils/Mouse.cpp`:

```cpp
#include "Mouse.hpp"

Mouse::Mouse(UINTN screen_width, UINTN screen_height){

	//Initiate the two buttons to false since we can't predict that buttons are pressed.
	l_button_ = false;
	r_button_ = false;

	screen_width_ = screen_width;
	screen_height_ = screen_height;

	//Initiate the mouse cursor position to middle of the screen.
	real_pos_.x = screen_width / 2;
	real_pos_.y = screen_height / 2;

	//Enable cursor. I do not know if this is needed.
	gST->ConOut->EnableCursor(gST->ConOut, true);

	//Locate the mouse protocol so we can receive the struct
	EFI_STATUS status = gBS->LocateProtocol(&g_efi_simple_pointer_protocol_guid_, NULL, (VOID**)&mouse_);

	//If left button or right button = false then it is not supported
	if(EFI_ERROR(status) || !(mouse_->Mode->LeftButton && mouse_->Mode->RightButton)){
		#ifdef DEBUG
			Print((CHAR16*)L"Not supported mouse config!\n");
		#endif
		return;
	}
	#ifdef DEBUG
	Print((CHAR16*)L"Not 1 mouse config!\n");
	#endif
	//Ignore Z since this project is 2D
	const UINT64 res_x = mouse_->Mode->ResolutionX;
	const UINT64 res_y = mouse_->Mode->ResolutionY;

	//if(!(res_x && res_y)){
	//	return;
	//}
}

bool Mouse::GetLButton() const{
	return l_button_;
}

bool Mouse::GetRButton() const{
	return r_button_;
}

Mouse::Point Mouse::GetPosition(){
	EFI_EVENT events;
	UINTN index;
	EFI_STATUS status = gBS->WaitForEvent(2, &events, &index);

	//if(EFI_ERROR(status)){
	//	return real_pos_;
	//}

	if (index == 0) {
		status = mouse_->GetState(mouse_, &state_);

		// Get delta from mouse
		Point pos = {state_.RelativeMovementX, state_.RelativeMovementY};

		// Get the state of the mouse buttons
		l_button_ = state_.LeftButton;
		r_button_ = state_.RightButton;

		//Clamp to screen width
		//if ((real_pos_.x + (pos.x / screen_width_)) / 4 >= screen_width_ || (real_pos_.x + (pos.x / screen_width_)) / 4 <= 0) {
		//	#ifdef DEBUG
		//		Print((CHAR16*)L"Mouse pos out of screen X\n");
		//	#endif

		//	return real_pos_;
		//}
		//////Clamp to screen height
		//if ((real_pos_.y + (pos.y / screen_height_)) / 4 >= screen_height_ || (real_pos_.y + (pos.y / screen_height_)) / 4 <= 0) {
		//	#ifdef DEBUG
		//		Print((CHAR16*)L"Mouse pos out of screen Y\n");
		//	#endif

		//	return real_pos_;
		//}

		//Update the actual cursor position from the mouse delta received.
		//4 to decrease the speed for testing
		real_pos_.x += (pos.x / (INT32)screen_width_) / (INT32)4;
		real_pos_.y += (pos.y / (INT32)screen_height_) / (INT32)4;
	}

	return real_pos_;
}

```

`VisualUefi-master/UEFI-Graphics/UEFI-Graphics/Utils/Mouse.hpp`:

```hpp
#pragma once
#include "../General.hpp"

class Mouse{
public:
	Mouse(UINTN screen_width, UINTN screen_height);
	~Mouse() = default;

	static struct Point{
		INT32 x;
		INT32 y;
	};
	
	bool GetLButton() const;
	bool GetRButton() const;
	Point GetPosition();

private:
	UINTN screen_width_;
	UINTN screen_height_;

	bool l_button_;
	bool r_button_;

	Point real_pos_;

	EFI_SIMPLE_POINTER_PROTOCOL* mouse_ = nullptr;
	EFI_SIMPLE_POINTER_STATE     state_;

	EFI_GUID g_efi_simple_pointer_protocol_guid_ = { 0x31878C87, 0xB75,0x11D5,
	{ 0x9A, 0x4F,0x0, 0x90, 0x27, 0x3F,0xC1, 0x4D } };


};


```

`VisualUefi-master/UEFI-Graphics/samples.default.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <EDK_PATH>$(SolutionDir)..\edk2</EDK_PATH>
  </PropertyGroup>
  <PropertyGroup>
    <IncludePath>$(EDK_PATH)\MdePkg\Include;$(EDK_PATH)\MdePkg\Include\X64;$(EDK_PATH)\ShellPkg\Include;$(EDK_PATH)\CryptoPkg\Include</IncludePath>
    <LibraryPath>$(SolutionDir)..\EDK-II\$(Platform)\$(Configuration)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <ItemGroup>
    <BuildMacro Include="EDK_PATH">
      <Value>$(EDK_PATH)</Value>
      <EnvironmentVariable>true</EnvironmentVariable>
    </BuildMacro>
  </ItemGroup>
</Project>

```

`VisualUefi-master/UEFI-Graphics/samples.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup>
    <GenerateManifest />
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <TargetExt>.efi</TargetExt>
  </PropertyGroup>
  <PropertyGroup>
    <LocalDebuggerCommand>..\debugger\qemu.exe</LocalDebuggerCommand>
    <LocalDebuggerCommandArguments>-name "VisualUEFI Debugger" -drive file=OVMF_CODE-need-smm.fd,if=pflash,format=raw,unit=0,readonly=on -drive file=OVMF_VARS-need-smm.fd,if=pflash,format=raw,unit=1 -drive file=fat:rw:..\samples\$(Platform)\$(Configuration)\,media=disk,if=virtio,format=raw -drive file=UefiShell.iso,format=raw -m 512 -machine q35,smm=on -nodefaults -vga std -global driver=cfi.pflash01,property=secure,value=on -global ICH9-LPC.disable_s3=1</LocalDebuggerCommandArguments>
    <LocalDebuggerWorkingDirectory>..\..\debugger</LocalDebuggerWorkingDirectory>
    <LocalDebuggerDebuggerType>Script</LocalDebuggerDebuggerType>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <WarningLevel>Level4</WarningLevel>
      <TreatWarningAsError>true</TreatWarningAsError>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <OmitFramePointers>true</OmitFramePointers>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ForcedIncludeFiles>$(SolutionDir)..\EDK-II\BaseLib\vshacks.h</ForcedIncludeFiles>
      <CallingConvention />
      <TreatWChar_tAsBuiltInType />
      <StringPooling>true</StringPooling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ForceConformanceInForLoopScope />
      <AdditionalOptions>/Gs32768 %(AdditionalOptions)</AdditionalOptions>
      <ErrorReporting />
      <FloatingPointModel />
    </ClCompile>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib</AdditionalDependencies>
      <GenerateDebugInformation>DebugFastLink</GenerateDebugInformation>
      <SubSystem>EFI Boot Service Driver</SubSystem>
      <Driver>Driver</Driver>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding />
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>0</BaseAddress>
      <SectionAlignment>32</SectionAlignment>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <RandomizedBaseAddress />
      <DataExecutionPrevention />
      <ManifestFile />
      <AllowIsolation />
      <EnableUAC />
      <UACExecutionLevel />
      <UACUIAccess />
      <TypeLibraryResourceID />
      <AdditionalOptions>/OPT:ICF=10 /IGNORE:4001 /IGNORE:4254 /IGNORE:4281 %(AdditionalOptions)</AdditionalOptions>
      <MergeSections>.rdata=.data</MergeSections>
      <SpecifySectionAttributes>.xdata,D</SpecifySectionAttributes>
      <LinkErrorReporting />
      <ProfileGuidedDatabase />
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
</Project>

```