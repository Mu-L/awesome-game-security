Project Path: arc_bitdefender_river_0pwwuauk

Source Tree:

```txt
arc_bitdefender_river_0pwwuauk
├── BinLoader
│   ├── Abstract.Importer.h
│   ├── Abstract.Loader.h
│   ├── Abstract.Mapper.h
│   ├── BinLoader.vcxproj
│   ├── CMakeLists.txt
│   ├── Common.cpp
│   ├── Common.h
│   ├── ELF.Loader.cpp
│   ├── ELF.Loader.h
│   ├── Extern.Mapper.cpp
│   ├── Extern.Mapper.h
│   ├── Extern.Native.Importer.cpp
│   ├── Extern.Native.Importer.h
│   ├── Inproc.Mapper.cpp
│   ├── Inproc.Mapper.h
│   ├── Inproc.Native.Importer.cpp
│   ├── Inproc.Native.Importer.h
│   ├── LoaderAPI.cpp
│   ├── LoaderAPI.h
│   ├── Main.cpp
│   ├── Makefile
│   ├── Mem.Mapper.cpp
│   ├── Mem.Mapper.h
│   ├── PE.Loader.cpp
│   ├── PE.Loader.h
│   ├── Shm.Mapper.cpp
│   ├── Shm.Mapper.h
│   ├── Types.h
│   ├── Unified.Loader.cpp
│   ├── __ELF.Loader.cpp
│   ├── libbinloader
│   └── tmp
│       ├── Tester.cpp
│       └── tester
├── CMakeLists.txt
├── CommonCrossPlatform
│   ├── BasicTypes.h
│   ├── CMakeLists.txt
│   ├── Common.h
│   ├── CommonSpecifiers.h
│   └── LibraryLayout.h
├── DisableSSE
│   ├── CMakeLists.txt
│   ├── DisableSSE.S
│   ├── DisableSSEHelper.c
│   └── Makefile
├── Execution
│   ├── CMakeLists.txt
│   ├── CommonExecutionController.cpp
│   ├── CommonExecutionController.h
│   ├── CommonExecutionController2.cpp
│   ├── Debugger.cpp
│   ├── Debugger.h
│   ├── DualAllocator.Linux.cpp
│   ├── DualAllocator.Windows.cpp
│   ├── DualAllocator.h
│   ├── Execution.h
│   ├── Execution.vcxproj
│   ├── ExternExecutionController.Linux.cpp
│   ├── ExternExecutionController.Windows.cpp
│   ├── ExternExecutionController.h
│   ├── InprocessExecutionController.cpp
│   ├── InprocessExecutionController.h
│   ├── InternalExecutionControllerExt.cpp
│   ├── LargeStack.cpp
│   ├── LargeStack.h
│   ├── Main.cpp
│   ├── Makefile
│   ├── RiverStructs.h
│   ├── TokenRingInit.Linux.cpp
│   ├── TokenRingInit.Linux.h
│   ├── TokenRingInit.Windows.cpp
│   └── TokenRingInit.Windows.h
├── ExecutionWrapper
│   ├── AssemblyInfo.cpp
│   ├── ExecutionWrapper.cpp
│   ├── ExecutionWrapper.h
│   ├── ExecutionWrapper.vcxproj
│   ├── Stdafx.cpp
│   ├── Stdafx.h
│   ├── app.ico
│   ├── app.rc
│   └── resource.h
├── LICENSE
├── LargeStack
│   ├── LargeStack.cpp
│   ├── LargeStack.h
│   ├── LargeStack.vcxproj
│   └── Main.cpp
├── Makefile
├── SymbolicEnvironment
│   ├── CMakeLists.txt
│   ├── Environment.cpp
│   ├── Environment.h
│   ├── LargeStack.cpp
│   ├── LargeStack.h
│   ├── Makefile
│   ├── OverlappedRegisters.cpp
│   ├── OverlappedRegisters.h
│   ├── RevSymbolicEnvironment.cpp
│   ├── RevSymbolicEnvironment.h
│   ├── SymbolicEnvironment.cpp
│   ├── SymbolicEnvironment.h
│   └── SymbolicEnvironment.vcxproj
├── VirtualMemory
│   ├── CMakeLists.txt
│   ├── Makefile
│   ├── MemoryLayout.Linux.cpp
│   ├── MemoryLayout.Windows.cpp
│   ├── MemoryLayout.h
│   ├── VirtualMem.cpp
│   ├── VirtualMem.h
│   └── VirtualMemory.vcxproj
├── benchmarking-payload
│   ├── CMakeLists.txt
│   ├── freetype-payload
│   │   ├── CMakeLists.txt
│   │   ├── Makefile
│   │   ├── Payload.cpp
│   │   └── config_freetype.sh
│   ├── gumbo-payload
│   │   ├── CMakeLists.txt
│   │   ├── Makefile
│   │   ├── Payload.cpp
│   │   └── config_gumbo.sh
│   ├── http-parser-payload
│   │   ├── CMakeLists.txt
│   │   ├── Makefile
│   │   ├── ParserPayload.vcxproj
│   │   ├── Payload.cpp
│   │   ├── http-parser.version
│   │   ├── http_parser.c
│   │   └── http_parser.h
│   ├── jsmn-payload
│   │   ├── CMakeLists.txt
│   │   ├── Makefile
│   │   ├── Payload.cpp
│   │   └── config_jsmn.sh
│   ├── libjpeg-turbo-payload
│   │   ├── CMakeLists.txt
│   │   ├── Makefile
│   │   ├── Payload.cpp
│   │   └── config_libjpeg-turbo.sh
│   ├── libpng-payload
│   │   ├── CMakeLists.txt
│   │   ├── Makefile
│   │   ├── Payload.cpp
│   │   └── config_libpng.sh
│   ├── libxml2-payload
│   │   ├── CMakeLists.txt
│   │   ├── Makefile
│   │   ├── Payload.cpp
│   │   └── config_libxml2.sh
│   ├── simple-accumulator-payload
│   │   ├── CMakeLists.txt
│   │   ├── Payload.cpp
│   │   └── simple-accumulator.c
│   └── simple-address-payload
│       ├── CMakeLists.txt
│       ├── Payload.cpp
│       └── simple-address.c
├── build-all.sh
├── docs
│   ├── abi
│   │   ├── Makefile
│   │   ├── abi.tex
│   │   ├── code
│   │   │   ├── BranchHandler.h
│   │   │   └── SysHandler.h
│   │   ├── img
│   │   │   └── river-transition-handling.png
│   │   └── macros.tex
│   ├── cheatsheet
│   │   ├── Makefile
│   │   ├── cheatsheet.tex
│   │   └── code
│   │       ├── RiverAddress.h
│   │       ├── RiverInstruction.h
│   │       └── RiverOperand.h
│   ├── metafiles
│   │   └── base.mk
│   └── offline.sanitizer
│       ├── Makefile
│       ├── biblio.bib
│       ├── header-standard.bib
│       └── main.tex
├── evaluators.sln
├── execution.external.test
│   ├── Main.cpp
│   └── execution.external.test.vcxproj
├── execution.inprocess.test
│   ├── Main.cpp
│   ├── Makefile
│   ├── Payload.cpp
│   └── execution.inprocess.test.vcxproj
├── fibonacci
│   └── fib.cpp
├── ipclib
│   ├── CMakeLists.txt
│   ├── Makefile
│   ├── RingBuffer.h
│   ├── common.h
│   ├── ipclib.cpp
│   ├── ipclib.h
│   └── ipclib.vcxproj
├── libproc
│   ├── libproc.cpp
│   └── os-linux.h
├── loader
│   ├── CMakeLists.txt
│   ├── Loader.Linux.Stub.S
│   ├── Loader.Linux.cpp
│   ├── Loader.Windows.cpp
│   ├── Loader.h
│   ├── Main.cpp
│   ├── Makefile
│   ├── libloader.idb
│   └── loader.vcxproj
├── loader.setup
│   ├── Loader.Setup.h
│   ├── Setup.Windows.cpp
│   └── loader.setup.vcxproj
├── loader.test
│   ├── Loader
│   │   ├── Abstract.Mapper.h
│   │   ├── Extern.Mapper.cpp
│   │   ├── Extern.Mapper.h
│   │   ├── Inproc.Mapper.cpp
│   │   ├── Inproc.Mapper.h
│   │   ├── Mem.Mapper.cpp
│   │   ├── Mem.Mapper.h
│   │   ├── PE.ldr.cpp
│   │   ├── PE.ldr.h
│   │   └── Types.h
│   ├── Main.cpp
│   └── loader.test.vcxproj
├── lzo
├── makeSDK.bat
├── makeSDK.sh
├── nodeaddon
│   ├── binding.gyp
│   ├── executionwrapper.cpp
│   └── index.js
├── notracer
│   ├── Loader
│   │   ├── Abstract.Mapper.h
│   │   ├── Inproc.Mapper.cpp
│   │   ├── Inproc.Mapper.h
│   │   ├── PE.ldr.cpp
│   │   ├── PE.ldr.h
│   │   └── Types.h
│   ├── MapPE.cpp
│   ├── extern.cpp
│   ├── extern.h
│   ├── main.cpp
│   └── notracer.vcxproj
├── release.conf
├── revmaster
│   ├── DualAllocator.cpp
│   ├── DualAllocator.h
│   ├── Loader
│   │   ├── Abstract.Mapper.h
│   │   ├── Extern.Mapper.cpp
│   │   ├── Extern.Mapper.h
│   │   ├── Inproc.Mapper.cpp
│   │   ├── Inproc.Mapper.h
│   │   ├── Mem.Mapper.cpp
│   │   ├── Mem.Mapper.h
│   │   ├── PE.ldr.cpp
│   │   ├── PE.ldr.h
│   │   └── Types.h
│   ├── Main.cpp
│   └── revmaster.vcxproj
├── revtracer
│   ├── AddressContainer.cpp
│   ├── AddressContainer.h
│   ├── CMakeLists.txt
│   ├── CodeGen.h
│   ├── DebugPrintFlags.h
│   ├── GenericX86Assembler.cpp
│   ├── GenericX86Assembler.h
│   ├── Loader
│   │   ├── Abstract.Mapper.h
│   │   ├── Inproc.Mapper.cpp
│   │   ├── Inproc.Mapper.h
│   │   ├── PE.ldr.cpp
│   │   ├── PE.ldr.h
│   │   └── Types.h
│   ├── Makefile
│   ├── NativeX86Assembler.cpp
│   ├── NativeX86Assembler.h
│   ├── PreTrackingX86Assembler.cpp
│   ├── PreTrackingX86Assembler.h
│   ├── RelocableCodeBuffer.cpp
│   ├── RelocableCodeBuffer.h
│   ├── RepInstrumentation.S
│   ├── RiverAddress.cpp
│   ├── RiverAddress.h
│   ├── RiverMetaTranslator.cpp
│   ├── RiverMetaTranslator.h
│   ├── RiverPrintTable.cpp
│   ├── RiverRepAssembler.cpp
│   ├── RiverRepAssembler.h
│   ├── RiverRepTranslator.cpp
│   ├── RiverRepTranslator.h
│   ├── RiverReverseTranslator.cpp
│   ├── RiverReverseTranslator.h
│   ├── RiverSaveTranslator.cpp
│   ├── RiverSaveTranslator.h
│   ├── RiverTrackingX86Assembler.cpp
│   ├── RiverTrackingX86Assembler.h
│   ├── RiverX86Assembler.cpp
│   ├── RiverX86Assembler.h
│   ├── RiverX86Disassembler.cpp
│   ├── RiverX86Disassembler.h
│   ├── RiverX86DisassemblerTable.cpp
│   ├── Runtime.h
│   ├── SymbopReverseTranslator.cpp
│   ├── SymbopReverseTranslator.h
│   ├── SymbopSaveTranslator.cpp
│   ├── SymbopSaveTranslator.h
│   ├── SymbopTranslator.cpp
│   ├── SymbopTranslator.h
│   ├── Tracking.cpp
│   ├── Tracking.h
│   ├── TrackingX86Assembler.cpp
│   ├── TrackingX86Assembler.h
│   ├── TranslatorUtil.cpp
│   ├── TranslatorUtil.h
│   ├── VBoxSnapshotDll.h
│   ├── X86Assembler.cpp
│   ├── X86Assembler.h
│   ├── X86AssemblerFuncs.cpp
│   ├── X86AssemblerFuncs.h
│   ├── api.cpp
│   ├── callgates.cpp
│   ├── callgates.h
│   ├── cb.cpp
│   ├── cb.h
│   ├── codegen.cpp
│   ├── common.h
│   ├── crc32.cpp
│   ├── crc32.h
│   ├── crtStub.cpp
│   ├── environment.h
│   ├── execenv.cpp
│   ├── execenv.h
│   ├── extern.cpp
│   ├── main.cpp
│   ├── mm.cpp
│   ├── mm.h
│   ├── modrm32.cpp
│   ├── modrm32.h
│   ├── revtracer.cpp
│   ├── revtracer.h
│   ├── revtracer.stub.S
│   ├── revtracer.vcxproj
│   ├── river.h
│   ├── riverinternl.h
│   ├── sync.cpp
│   └── sync.h
├── revtracer-wrapper
│   ├── CMakeLists.txt
│   ├── Main.cpp
│   ├── Makefile
│   ├── RevtracerWrapper.cpp
│   ├── RevtracerWrapper.h
│   ├── ShmTokenRingLin.cpp
│   ├── ShmTokenRingLin.h
│   ├── ShmTokenRingWin.cpp
│   ├── TokenRing.Linux.h
│   ├── TokenRing.Windows.h
│   ├── TokenRing.h
│   ├── UnifiedTokenRing.cpp
│   ├── Wrapper.Global.h
│   ├── Wrapper.Linux.cpp
│   ├── Wrapper.Windows.cpp
│   ├── revtracer-wrapper.vcxproj
│   └── setup-libs.sh
├── revtracerexe
│   ├── Extern.cpp
│   ├── Extern.h
│   ├── Loader
│   │   ├── Abstract.Mapper.h
│   │   ├── Inproc.Mapper.cpp
│   │   ├── Inproc.Mapper.h
│   │   ├── PE.ldr.cpp
│   │   ├── PE.ldr.h
│   │   └── Types.h
│   ├── Main.cpp
│   ├── MapPE.cpp
│   └── revtracerexe.vcxproj
├── tracer
│   ├── Loader
│   │   ├── Abstract.Mapper.h
│   │   ├── Inproc.Mapper.cpp
│   │   ├── Inproc.Mapper.h
│   │   ├── PE.ldr.cpp
│   │   ├── PE.ldr.h
│   │   └── Types.h
│   ├── MapPE.cpp
│   ├── callgates.c
│   ├── callgates.h
│   ├── cb.c
│   ├── cb.h
│   ├── codegen.c
│   ├── codetbl.c
│   ├── codetbl.h
│   ├── common.h
│   ├── crc32.c
│   ├── crc32.h
│   ├── environment.h
│   ├── execenv.c
│   ├── execenv.h
│   ├── extern.c
│   ├── extern.h
│   ├── main.c
│   ├── mm.c
│   ├── mm.h
│   ├── modrm32.c
│   ├── modrm32.h
│   ├── nld2msg.h
│   ├── src.c
│   ├── sync.c
│   ├── sync.h
│   └── tracer.vcxproj
├── tracer.simple
│   ├── Main.cpp
│   ├── Makefile
│   ├── ezOptionParser.h
│   └── tracer.simple.vcxproj
└── wrapper.setup
    ├── CMakeLists.txt
    ├── Makefile
    ├── Setup.Linux.cpp
    ├── Setup.Windows.cpp
    ├── Wrapper.Setup.h
    └── wrapper.setup.vcxproj

```

`BinLoader/Abstract.Importer.h`:

```h
#ifndef _ABSTRACT_IMPORTER_H_
#define _ABSTRACT_IMPORTER_H_

#include "Types.h"

namespace ldr {
#define IMPORT_NOT_FOUND 0xFFFFFFFF

	class AbstractImporter {
	public:
		virtual DWORD FindImport(const char *moduleName, const char *funcName) = 0;
		virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal) = 0;
		virtual DWORD FindImport(const char *moduleName, const char *funcName, const char *version) = 0;
	};
};

#endif


```

`BinLoader/Abstract.Loader.h`:

```h
#ifndef _ABSTRACT_LDR_H_
#define _ABSTRACT_LDR_H_

#include "Abstract.Mapper.h"
#include "Abstract.Importer.h"

#include <functional>

namespace ldr {
	class AbstractBinary {
	public:
		virtual bool IsValid() const = 0;
		virtual bool Map(AbstractMapper &mapr, AbstractImporter &impr, DWORD &baseAddr, bool callConstructors) = 0;
		virtual bool GetExport(const char *funcName, DWORD &funcRVA) const = 0;
		virtual DWORD GetRequiredSize() const = 0;

		virtual void ForAllExports(std::function<void(const char * /*funcName*/, const DWORD /*ordinal*/, const char * /*version*/, const DWORD /*rva*/, const unsigned char * /*body*/)> verb) const = 0;
	};

	AbstractBinary *LoadBinary(const char *module);
	AbstractBinary *LoadBinary(const wchar_t *module);
}; //namespace ldr

#endif


```

`BinLoader/Abstract.Mapper.h`:

```h
#ifndef _ABSTRACT_MAPPER_H_
#define _ABSTRACT_MAPPER_H_

#include "Types.h"

namespace ldr {
#define PAGE_PROTECTION_READ			0x4
#define PAGE_PROTECTION_WRITE			0x2
#define PAGE_PROTECTION_EXECUTE			0x1

	class AbstractMapper {
	public:
		virtual void *CreateSection(void *lpAddress, SIZE_T dwSize, DWORD flProtect) = 0;
		virtual bool ChangeProtect(void *lpAddress, SIZE_T dwSize, DWORD flProtect) = 0;
		virtual bool WriteBytes(void *lpAddress, void *lpBuffer, SIZE_T nSize) = 0;

		/*virtual DWORD FindImport(const char *moduleName, const char *funcName) = 0;
		virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal) = 0;*/
	};
};

#endif


```

`BinLoader/BinLoader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D7D32923-BF55-4907-9A83-DA7676298CD8}</ProjectGuid>
    <RootNamespace>BinLoader</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;EXTERN_EXECUTION_ONLY;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>Debug</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;EXTERN_EXECUTION_ONLY;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Abstract.Importer.h" />
    <ClInclude Include="Abstract.Loader.h" />
    <ClInclude Include="Abstract.Mapper.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="ELF.Loader.h" />
    <ClInclude Include="Extern.Mapper.h" />
    <ClInclude Include="Inproc.Mapper.h" />
    <ClInclude Include="Inproc.Native.Importer.h" />
    <ClInclude Include="LoaderAPI.h" />
    <ClInclude Include="Mem.Mapper.h" />
    <ClInclude Include="PE.Loader.h" />
    <ClInclude Include="Shm.Mapper.h" />
    <ClInclude Include="Types.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Common.cpp" />
    <ClCompile Include="ELF.Loader.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Extern.Mapper.cpp" />
    <ClCompile Include="Inproc.Mapper.cpp" />
    <ClCompile Include="Inproc.Native.Importer.cpp" />
    <ClCompile Include="LoaderAPI.cpp" />
    <ClCompile Include="Main.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Mem.Mapper.cpp" />
    <ClCompile Include="PE.Loader.cpp" />
    <ClCompile Include="Shm.Mapper.cpp" />
    <ClCompile Include="Unified.Loader.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BinLoader/CMakeLists.txt`:

```txt
## BinLoader CMakeLists.txt

set(LIBRARY_NAME binloader)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -m32 -std=c++11")

add_library(${LIBRARY_NAME} STATIC
	Common.cpp
	ELF.Loader.cpp
	PE.Loader.cpp
	Unified.Loader.cpp
	LoaderAPI.cpp
	Inproc.Mapper.cpp
	Shm.Mapper.cpp
	Inproc.Native.Importer.cpp
	)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)


```

`BinLoader/Common.cpp`:

```cpp
#include "Common.h"

#ifdef __linux__
#include <stdlib.h>
#include <wchar.h>
#include <string.h>
#include <iconv.h>
#include <dlfcn.h>

int wchar_to_utf8(const wchar_t *wchar, char *utf8, ssize_t dst_len) {
	int len =  wcslen(wchar);
	if (dst_len < len)
		return -1;
	memset(utf8, 0, len + 1);


	char *iconv_in =  (char *)wchar;
	char *iconv_out = (char *)utf8;

	size_t iconv_in_bytes = (len + 1) * sizeof(wchar_t);
	size_t iconv_out_bytes = dst_len;

	iconv_t cd = iconv_open("UTF-8", "WCHAR_T");
	if ((iconv_t)-1 == cd)
		return -1;

	size_t ret = iconv(cd, &iconv_in, &iconv_in_bytes,
		&iconv_out, &iconv_out_bytes);
	if ((size_t)-1 == ret)
		return -1;

	return 0;
}

int utf8_to_wchar(wchar_t *wchar, const char *utf8, ssize_t dst_len) {
	int len = strlen(utf8);
	if (dst_len < len)
		return -1;
	wmemset(wchar, L'\0', len + 1);


	char *iconv_in = (char *)utf8;
	char *iconv_out = (char *)wchar;

	size_t iconv_in_bytes = (len + 1) * sizeof(wchar_t);
	size_t iconv_out_bytes = dst_len;

	iconv_t cd = iconv_open("WCHAR_T", "UTF-8");
	if ((iconv_t)-1 == cd)
		return -1;

	size_t ret = iconv(cd, &iconv_in, &iconv_in_bytes,
		&iconv_out, &iconv_out_bytes);
	if ((size_t)-1 == ret)
		return -1;

	return 0;
}

void *w_dlopen(const wchar_t *filename, int flags) {
	char path_utf8[wcslen(filename) + 1];
	if (wchar_to_utf8((filename), path_utf8, wcslen(filename) + 1) < 0)
		return nullptr;
	return dlopen(path_utf8, flags);
}

FILE *w_fopen(const wchar_t *path, const wchar_t *mode) {
	char path_utf8[wcslen(path) + 1];
	char  mode_utf8[wcslen(mode) + 1];

	if (wchar_to_utf8((path), path_utf8, wcslen(path) + 1) < 0)
		return nullptr;
	if (wchar_to_utf8((mode), mode_utf8, wcslen(mode) + 1) < 0)
		return nullptr;

	return fopen(path_utf8, mode_utf8);
}

#include <stdlib.h> //getenv
#include <dirent.h>

bool find_module(const char *moduleName, char *dirname, char *path) {

	DIR *d;
	struct dirent *dir;
	d = opendir(dirname);
	if (d)
	{
		while ((dir = readdir(d)) != NULL)
		{
			if (!strcmp(moduleName, dir->d_name)) {
				strcpy(path, dirname);
				path[strlen(path)] = '/';
				strcat(path, moduleName);

				closedir(d);
				return true;
			}
		}
		closedir(d);
	}

	return false;
}


bool find_in_env(const char *moduleName, char *path) {
	const char* env = getenv("LD_LIBRARY_PATH");
	if (!env) {
		printf("[Binloader] Export LD_LIBRARY_PATH accordingly to find %s\n", moduleName);
		return false;
	}

	// iterate thourgh it
	const char *it = env;
	const char *start = it;
	while (1) {
		if ((*it == ':') || (*it == '\0')) {
			//process from start to it - 1
			ssize_t len = it - 1 - start + 1;
			if (!len)
				continue;
			char dirname[MAX_PATH_NAME];
			memset(dirname, 0, MAX_PATH_NAME);
			strncpy(dirname, start, len);
			if (find_module(moduleName, dirname, path)) {
				return true;
			}
			if (!*it)
				break;
			start = it + 1;
		}
		it++;
	}

	return false;

}

bool find_in_env(const wchar_t *moduleName, wchar_t *path) {
	char utf8ModuleName[MAX_PATH_NAME];
	char utf8Path[MAX_PATH_NAME];

	wchar_to_utf8(moduleName, utf8ModuleName, MAX_PATH_NAME);
	memset(utf8Path, 0, MAX_PATH_NAME);
	find_in_env(utf8ModuleName, utf8Path);
	utf8_to_wchar(path, utf8Path, MAX_PATH_NAME);
}
#elif defined(_WIN32)
#include <string.h>
#include <stdio.h>
bool find_in_env(const char *moduleName, char *path) {
	strcpy_s(path, strlen(moduleName) + 1, moduleName);
	return true;
}

bool find_in_env(const wchar_t *moduleName, wchar_t *path) {
	wcscpy_s(path, wcslen(moduleName) + 1, moduleName);
	return true;
}
#endif

void solve_path(const char *moduleName, char *path) {
	memset(path, 0, MAX_PATH_NAME);
	FILE *fModule = nullptr;
	if (0 != FOPEN(fModule, moduleName, "rb")) {
		find_in_env(moduleName, path);
	} else {
		strcpy(path, moduleName);
		fclose(fModule);
	}
}

void solve_path(const wchar_t *moduleName, wchar_t *path) {
	memset(path, 0, MAX_PATH_NAME);
	FILE *fModule = nullptr;
	if (0 != W_FOPEN(fModule, moduleName, L"rb")) {
		find_in_env(moduleName, path);
	} else {
		wcscpy(path, moduleName);
		fclose(fModule);
	}
}

```

`BinLoader/Common.h`:

```h
#ifndef _COMMON_EXECUTION_LOADER_H
#define _COMMON_EXECUTION_LOADER_H

#ifdef _MSC_VER
#define DEBUG_BREAK __asm \
{ __asm int 3 }
#else
#define DEBUG_BREAK asm volatile("int $0x3")
#endif

#ifdef __linux__
#include <stdio.h>
#define MAX_PATH_NAME 4096
int wchar_to_utf8(const wchar_t *src, char *dst, ssize_t dst_len);
void *w_dlopen(const wchar_t *filename, int flags);
FILE *w_fopen(const wchar_t *path, const wchar_t *mode);

#define FOPEN(res, path, mode) ( res = fopen((path), (mode)), res == nullptr)
#define W_FOPEN(res, path, mode) ({ res = w_fopen((path), (mode)); nullptr == res; })

#else
#define MAX_PATH_NAME 260
#define FOPEN(res, path, mode) fopen_s(&(res), (path), (mode))
#define W_FOPEN(res, path, mode) _wfopen_s(&(res), (path), (mode))
#endif

void solve_path(const char *moduleName, char *path);
void solve_path(const wchar_t *moduleName, wchar_t *path);
#endif

```

`BinLoader/ELF.Loader.cpp`:

```cpp
#include "Common.h"
#include "ELF.Loader.h"

#include <string.h>
#include <algorithm>

#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#else
#define dbg_log(fmt,...) {printf(fmt, ##__VA_ARGS__); fflush(stdout);}
#endif

#define SHT_NULL	 0
#define SHT_PROGBITS 1
#define SHT_SYMTAB	 2
#define SHT_STRTAB	 3
#define SHT_RELA	 4
#define SHT_HASH	 5
#define SHT_DYNAMIC	 6
#define SHT_NOTE	 7
#define SHT_NOBITS	 8
#define SHT_REL		 9
#define SHT_SHLIB	 10
#define SHT_DYNSYM	 11
#define SHT_GNU_HASH 0x6FFFFFF6
#define SHT_VERNEED	 0x6FFFFFFE
#define SHT_VERDEF	 0x6FFFFFFD
#define SHT_VERSYM	 0x6FFFFFFF
#define SHT_LOPROC   0x70000000
#define SHT_HIPROC   0x7fffffff
#define SHT_LOUSER   0x80000000
#define SHT_HIUSER   0xffffffff

#define SHF_WRITE		0x1
#define SHF_ALLOC		0x2
#define SHF_EXECINSTR	0x4
#define SHF_MASKPROC	0xf0000000

namespace ldr {
	ELFSection::ELFSection() {
		data = nullptr;
		versions = nullptr;
	}

	bool ELFSection::Load(FILE *fModule) {
		if (SHT_NOBITS == header.sh_type) {
			return true;
		}

		data = new unsigned char[header.sh_size];

		fseek(fModule, header.sh_offset, SEEK_SET);
		if (header.sh_size != fread(data, 1, header.sh_size, fModule)) {
			dbg_log("read error, in section %s\n", (char *)header.sh_name);
			return false;
		}

		return true;
	}

	void ELFSection::Unload() {
		delete data;
	}

#define ELF_MAGIC 0x464C457F

#define ELFCLASSNONE		0
#define ELFCLASS32			1
#define ELFCLASS64			2

#define ELFDATANONE			0
#define ELFDATA2LSB			1
#define ELFDATA2MSB			2

#define ET_NONE				0
#define ET_REL				1
#define ET_EXEC				2
#define ET_DYN				3
#define ET_CORE				4
#define ET_LOPROC			0xff00
#define ET_HIPROC			0xffff

#define EM_NONE				0
#define EM_M32				1
#define EM_SPARC			2
#define EM_386				3
#define EM_68K				4
#define EM_88K				5
#define EM_860				7
#define EM_MIPS				8 

#define EV_NONE				0
#define EV_CURRENT			1

#define PT_NULL				0
#define PT_LOAD				1
#define PT_DYNAMIC			2
#define PT_INTERP			3
#define PT_NOTE				4
#define PT_SHLIB			5
#define PT_PHDR				6
#define PT_GNU_EH_FRAME		0x6474E550
#define PT_GNU_STACK		0x6474E551
#define PT_GNU_RELRO		0x6474E552
#define PT_LOPROC			0x70000000
#define PT_HIPROC			0x7fffffff

#define PF_R            0x4
#define PF_W            0x2
#define PF_X            0x1

#define ELF32RSYM(i) ((i)>>8)
#define ELF32RTYPE(i) ((unsigned char)(i))
#define ELF32RINFO(s,t) (((s)<<8)+(unsigned char)(t)

#define R_386_NONE			0 
#define R_386_32			1
#define R_386_PC32			2
#define R_386_GOT32			3
#define R_386_PLT32			4
#define R_386_COPY			5
#define R_386_GLOB_DAT		6
#define R_386_JMP_SLOT		7
#define R_386_RELATIVE		8
#define R_386_GOTOFF		9
#define R_386_GOTPC			10

#define DT_NULL				0   
#define DT_NEEDED			1   
#define DT_PLTRELSZ			2   
#define DT_PLTGOT			3   
#define DT_HASH				4   
#define DT_STRTAB			5   
#define DT_SYMTAB			6   
#define DT_RELA				7   
#define DT_RELASZ			8   
#define DT_RELAENT			9   
#define DT_STRSZ			10   
#define DT_SYMENT			11   
#define DT_INIT				12   
#define DT_INIT_ARRAY		25 /* Array with addresses Offf init fct */
#define DT_INIT_ARRAYSZ		27 /* Size in bytestes of DT_INIT_ARRAY */
#define DT_FINI				13   
#define DT_SONAME			14   
#define DT_RPATH			15   
#define DT_SYMBOLIC			16
#define DT_REL				17 
#define DT_RELSZ			18
#define DT_RELENT			19
#define DT_PLTREL			20
#define DT_DEBUG			21
#define DT_TEXTREL			22
#define DT_JMPREL			23
#define DT_LOPROC			0x70000000
#define DT_HIPROC			0x7fffffff

#define STB_LOCAL			0
#define STB_GLOBAL			1
#define STB_WEAK			2
#define STB_LOPROC			13
#define STB_HIPROC			15

#define SHN_UNDEF 0
#define SHN_LORESERVE 0xff00
#define SHN_LOPROC 0xff00
#define SHN_HIPROC 0xff1f
#define SHN_ABS 0xfff1
#define SHN_COMMON 0xfff2
#define SHN_HIRESERVE 0xffff

#define VER_DEF_NONE		0
#define VER_DEF_CURRENT		1
#define VER_DEF_NUM			2

#define VER_FLG_BASE		1
#define VER_FLG_WEAK		2


#define ELF32STBIND(i) ((i)>>4)
#define ELF32STTYPE(i) ((i)&0xf

	struct ELF32Rel{
		DWORD r_offset;
		DWORD r_info;
	};

	struct ELF32Rela {
		DWORD r_offset;
		DWORD r_info;
		LONG r_addend;
	};

	struct ELF32Sym {
		DWORD st_name;
		DWORD st_value;
		DWORD st_size;
		unsigned char st_info;
		unsigned char st_other;
		WORD st_shndx;
	};

	struct ELF32Dyn {
		LONG d_tag;
		DWORD d_un;
	};

	struct ELF32VerNeed {
		WORD vn_version;
		WORD vn_cnt;
		DWORD vn_file;
		DWORD vn_aux;
		DWORD vn_next;
	};

	struct ELF32VerNeedAux {
		DWORD vna_hash;
		WORD vna_flags;
		WORD vna_other;
		DWORD vna_name;
		DWORD vna_next;
	};

	struct ELF32VerDef {
		WORD vd_version;
		WORD vd_flags;
		WORD vd_ndx;
		WORD vd_cnt;
		DWORD vd_hash;
		DWORD vd_aux;
		DWORD vd_next;
	};

	struct ELF32VerDefAux {
		DWORD vda_name;
		DWORD vda_next;
	};


	void *FloatingELF32::RVA(DWORD rva) const {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if ((i->header.sh_addr <= rva) && (i->header.sh_addr + i->header.sh_size > rva) &&
					(i->header.sh_type != SHT_NOBITS)) {
				return &i->data[rva - i->header.sh_addr];
			}
		}
		return nullptr;
	}

	bool FloatingELF32::CanLoad(FILE *fMod) {
		ElfIdent ident;

		fseek(fMod, 0, SEEK_SET);

		if (1 != fread(&ident, sizeof(ident), 1, fMod)) {
			return false;
		}

		if (ELF_MAGIC != ident.e_magic) {
			return false;
		}

		if ((ELFCLASS32 != ident.e_class) || (ELFDATA2LSB != ident.e_data)) {
			return false;
		}

		// the file seems to be a falid ELF32 module
		return true;
	}

	bool FloatingELF32::LoadELF(FILE *fModule) {
		if (NULL == fModule) {
			dbg_log("File open error!\n");
			return false;
		}

		if (1 != fread(&ident, sizeof(ident), 1, fModule)) {
			dbg_log("Read error\n");
			return false;
		}

		if (ELF_MAGIC != ident.e_magic) {
			dbg_log("ident.e_magic not valid %08x != %08lx\n", ELF_MAGIC, ident.e_magic);
			return false;
		}

		if ((ELFCLASS32 != ident.e_class) || (ELFDATA2LSB != ident.e_data)) {
			dbg_log("ident.e_class or ident.e_data not supported\n");
			return false;
		}

		if (1 != fread(&header, sizeof(header), 1, fModule)) {
			dbg_log("Read error\n");
			return false;
		}

		if (EM_386 != header.e_machine) {
			dbg_log("header.e_machine not supported\n");
			return false;
		}

		//dbg_log("Base: %08lx\n", header.)

		moduleBase = 0xFFFFF000;
		pHeaders.resize(header.e_phnum);
		fseek(fModule, header.e_phoff, SEEK_SET);
		dbg_log("Type     Offset   V.Addr   P.Addr   F.Size   M.Size   Flags    Align\n");
		for (int i = 0; i < header.e_phnum; ++i) {
			if (1 != fread(&pHeaders[i].header, sizeof(pHeaders[i].header), 1, fModule)) {
				dbg_log("read error\n");
				return false;
			}

			DWORD tBA = 0xFFFFF000;
			switch (pHeaders[i].header.p_type) {
				case PT_LOAD:
					tBA = pHeaders[i].header.p_vaddr & ~(pHeaders[i].header.p_align - 1);
					break;
			};
			if (tBA < moduleBase) {
				moduleBase = tBA;
			}
		

			dbg_log("%08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
				pHeaders[i].header.p_type,
				pHeaders[i].header.p_offset,
				pHeaders[i].header.p_vaddr,
				pHeaders[i].header.p_paddr,
				pHeaders[i].header.p_filesz,
				pHeaders[i].header.p_memsz,
				pHeaders[i].header.p_flags,
				pHeaders[i].header.p_align
			);

		}

		sections.resize(header.e_shnum);
		fseek(fModule, header.e_shoff, SEEK_SET);
		for (int i = 0; i < header.e_shnum; ++i) {
			if (1 != fread(&sections[i].header, sizeof(sections[i].header), 1, fModule)) {
				dbg_log("read error\n");
				return false;
			}

			if (SHT_STRTAB == sections[i].header.sh_type) {
				names = &sections[i];
			}
		}

		for (int i = 0; i < header.e_shnum; ++i) {
			if (!sections[i].Load(fModule)) {
				return false;
			}

			switch (sections[i].header.sh_type) {
				case SHT_DYNAMIC :
					dbg_log("Dynamic section\n");
					ParseDynamic(sections[i]);
					break;
				case SHT_VERSYM :
					dbg_log("Versym section\n");
					sections[sections[i].header.sh_link].versions = &sections[i];
					break;
				case SHT_VERNEED :
					dbg_log("Verneed section\n");
					gnu_versions_r = &sections[i];
					ParseVerNeed(sections[i]);
					break;
				case SHT_VERDEF:
					dbg_log("Verdef section\n");
					gnu_versions_d = &sections[i];
					ParseVerDef(sections[i]);
					break;
				default:
					dbg_log("Section type %08lx - not recognized\n", sections[i].header.sh_type);
			}
		}

		/*dbg_log("\nName                     Type     Flags    Addr     Offset   Size     Link     Info     AddrAlgn EntSize\n");
		for (int i = 0; i < header.e_shnum; ++i) {
			dbg_log("%24s %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
				&sections[header.e_shstrndx].data[sections[i].header.sh_name],
				sections[i].header.sh_type,
				sections[i].header.sh_flags,
				sections[i].header.sh_addr,
				sections[i].header.sh_offset,
				sections[i].header.sh_size,
				sections[i].header.sh_link,
				sections[i].header.sh_info,
				sections[i].header.sh_addralign,
				sections[i].header.sh_entsize
			);
		}*/

		return true;
	}

	FloatingELF32::FloatingELF32(const char *moduleName) :start(0), init_array(0)
	{
		// TODO fix this fclose double free
		FILE *fModule = nullptr;
		
		if (0 != FOPEN(fModule, moduleName, "rb")) {
			isValid = false;
			return;
		}

		isValid = LoadELF(fModule);
		fclose(fModule);
	}

	FloatingELF32::FloatingELF32(const wchar_t *moduleName) :start(0), init_array(0)
	{
		FILE *fModule = nullptr;
		
		if (0 != W_FOPEN(fModule, moduleName, L"rb")) {
			isValid = false;
			return;
		}

		isValid = LoadELF(fModule);
		fclose(fModule);
	}

	FloatingELF32::~FloatingELF32() {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			i->Unload();
		}
	}

	DWORD FloatingELF32::GetEntryPoint() const {
		if (!isValid)
			return 0;
		return header.e_entry;
	}

	DWORD FloatingELF32::Import(AbstractImporter &impr, const char *name) {
		DWORD ret;
		const char *at = strchr(name, '@');

		if (at && at[1] == '@') {
			// retrieve version
			char funcname[100];
			strncpy(funcname, name, at - name);
			funcname[at - name] = '\0';

			if  (nullptr != gnu_versions_r) {
				for (auto v = gnu_versions_r->snVers.begin(); v != gnu_versions_r->snVers.end(); ++v) {
					if (!strcmp(v->version.c_str(), at + 2)) {
						return impr.FindImport(v->module.c_str(), funcname, at + 2);
					}
				}
			}

		}
		for (auto l = libraries.begin(); l != libraries.end(); ++l) {
			ret = impr.FindImport(l->c_str(), name);

			if (IMPORT_NOT_FOUND != ret) {
				return ret;
			}
		}

		return 0;
	}

	bool FloatingELF32::FixImports(AbstractImporter &impr, DWORD offset) {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if ((SHT_DYNSYM == i->header.sh_type) || (SHT_SYMTAB == i->header.sh_type)) {
				ELF32Sym *symb = (ELF32Sym *)i->data;
				DWORD count = i->header.sh_size / sizeof(*symb);
				for (DWORD j = 0; j < count; ++j) {
					if ((STB_GLOBAL == ELF32STBIND(symb[j].st_info)) && (SHN_UNDEF == symb[j].st_shndx)) {
						dbg_log(
							"%s",
							(char *)&sections[i->header.sh_link].data[symb[j].st_name]
						);

						if (nullptr != i->versions && nullptr != gnu_versions_r) {
							ELFSymbolVersionNeeded *vers = gnu_versions_r->idxSnVers[((WORD *)i->versions->data)[j]];
							if (nullptr != vers) {
								dbg_log(
									"##%s",
									vers->version.c_str()
								);

								symb[j].st_value = impr.FindImport(vers->module.c_str(), (char *)&sections[i->header.sh_link].data[symb[j].st_name], vers->version.c_str());
							} else {
								symb[j].st_value = Import(impr, (char *)&sections[i->header.sh_link].data[symb[j].st_name]);
							}
						} else {
							symb[j].st_value = Import(impr, (char *)&sections[i->header.sh_link].data[symb[j].st_name]);
						}
						//symb[j].st_value -= offset;
						//hack because s.st_value is normally the offset of a symbol in ITS library
						dbg_log("\n");
					}
				}
			}
		}
		
		return false;
	}

	bool FloatingELF32::PrintSymbols() const {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if ((SHT_DYNSYM == i->header.sh_type) || (SHT_SYMTAB == i->header.sh_type)) {
				ELF32Sym *symb = (ELF32Sym *)i->data;
				DWORD count = i->header.sh_size / sizeof(*symb);
				for (DWORD j = 0; j < count; ++j) {
					if ((STB_GLOBAL == ELF32STBIND(symb[j].st_info)) && (SHN_UNDEF == symb[j].st_shndx)) {
						dbg_log(
							"%s",
							(char *)&sections[i->header.sh_link].data[symb[j].st_name]
						);

						if (nullptr != i->versions && nullptr != gnu_versions_r) {
							ELFSymbolVersionNeeded *vers = gnu_versions_r->idxSnVers[((WORD *)i->versions->data)[j]];

							if (nullptr != vers) {
								dbg_log(
									"@@%s",
									vers->version.c_str()
								);
							}
						}
						dbg_log("\n");
					}
				}
			}
		}

		return true;
	}

	bool FloatingELF32::GetExport(const char *funcName, DWORD &funcRVA) const {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if (SHT_DYNSYM == i->header.sh_type) {
				ELF32Sym *symb = (ELF32Sym *)i->data;
				DWORD count = i->header.sh_size / sizeof(*symb);
				for (DWORD j = 0; j < count; ++j) {
					if ((STB_GLOBAL == ELF32STBIND(symb[j].st_info)) &&
							(SHN_UNDEF != symb[j].st_shndx)) {
						if (!strcmp(funcName, (char *)&sections[i->header.sh_link].data[symb[j].st_name])) {
							//we found it
							funcRVA = symb[j].st_value;
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	bool FloatingELF32::RelocateSection(void *r, DWORD count, const ELFSection &symb, const ELFSection &names, DWORD offset) {
		ELF32Rel *rels = (ELF32Rel *)r;
			for (DWORD i = 0; i < count; ++i) {
			dbg_log("Off: 0x%08lx, Sym: 0x%06lx, Typ: 0x%02x ", rels[i].r_offset, ELF32RSYM(rels[i].r_info), ELF32RTYPE(rels[i].r_info));
			DWORD *addr = (DWORD *)RVA(rels[i].r_offset);
			DWORD oldAddr;
			WORD sectionIndex;
			ELF32Sym *s;

			switch (ELF32RTYPE(rels[i].r_info)) {
				case R_386_NONE :
					dbg_log("$ none");
					break;
				case R_386_32 :
					s = &((ELF32Sym *)symb.data)[ELF32RSYM(rels[i].r_info)];
					sectionIndex = s->st_shndx;
					oldAddr = *addr;
					*addr += s->st_value;
					if (sectionIndex != SHN_UNDEF)
						*addr += offset; //hack because the imports have absolute addrs and static calls have relative addrs
					dbg_log("$ %s st %lx off %lx res_addr %lx oldaddr %lx", (char *)&names.data[s->st_name], s->st_value, offset, *addr, oldAddr);
					//set *addr
					break;
				case R_386_PC32:
					s = &((ELF32Sym *)symb.data)[ELF32RSYM(rels[i].r_info)];
					sectionIndex = s->st_shndx;
					oldAddr = *addr;
					*addr += s->st_value - rels[i].r_offset;
					if (sectionIndex == SHN_UNDEF)
						*addr -= offset; //hack because we get the imports as absolute values and the static relocs have relative values X(X((X
					dbg_log("$ %s %lx %lx %lx %lx oldaddr %lx", (char *)&names.data[s->st_name], s->st_value, offset, rels[i].r_offset, *addr, oldAddr);
					//set *addr
					break;
				case R_386_RELATIVE :
					oldAddr = *addr;
					*addr += offset;
					dbg_log("$ 0x%08lx => 0x%08lx", oldAddr, *addr);
					break;
				case R_386_GLOB_DAT :
					// TODO : Probably bug source
					s = &((ELF32Sym *)symb.data)[ELF32RSYM(rels[i].r_info)];
					oldAddr = *addr;
					*addr = s->st_value;
					dbg_log("$ 0x%08lx => 0x%08lx; %s", oldAddr, *addr, (char *)&names.data[s->st_name]);
					//set *addr
					break;
				case R_386_JMP_SLOT :
					// TODO : Probably bug source
					s = &((ELF32Sym *)symb.data)[ELF32RSYM(rels[i].r_info)];
					oldAddr = *addr;
					*addr = s->st_value;
					dbg_log("$ 0x%08lx => 0x%08lx; %s", oldAddr, *addr, (char *)&names.data[s->st_name]);
					//set *addr
					break;
			};

			dbg_log("\n");
		}
		return true;
	}

	bool FloatingELF32::Relocate(DWORD newBase) {
		DWORD offset = newBase - moduleBase;

		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if (SHT_REL == i->header.sh_type) {
				if (i->header.sh_addr == rd[REL_INDEX].address) {
					DWORD symbols = i->header.sh_link;
					DWORD symNames = sections[symbols].header.sh_link;
					RelocateSection((ELF32Rel *)rd[REL_INDEX].rValue,
							rd[REL_INDEX].size / relEnt,
							sections[symbols], sections[symNames], offset);
				}

				if (i->header.sh_addr == rd[PLTREL_INDEX].address) {
					DWORD symbols = i->header.sh_link;
					DWORD symNames = sections[symbols].header.sh_link;
					RelocateSection((ELF32Rel *)rd[PLTREL_INDEX].rValue,
							rd[PLTREL_INDEX].size / relEnt,
							sections[symbols], sections[symNames], offset);
				}
			}
		}

		// Do the same for rela sections

		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if (SHF_ALLOC & i->header.sh_flags) {
				i->header.sh_addr += offset;
			}
		}

		for (auto i = pHeaders.begin(); i != pHeaders.end(); ++i) {
			if (PT_LOAD == i->header.p_type) {
				i->header.p_vaddr += offset;
			}
		}

		moduleBase += offset;
		return true;
	}

	void FloatingELF32::MapSections(AbstractMapper &mapr, DWORD startSeg, DWORD stopSeg) {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if (SHF_ALLOC & i->header.sh_flags) {
				DWORD cpStart = i->header.sh_addr;
				if (cpStart < startSeg) {
					cpStart = startSeg;
				}

				DWORD cpStop = i->header.sh_addr + i->header.sh_size;
				if (cpStop > stopSeg) {
					cpStop = stopSeg;
				}

				if (cpStart < cpStop) { // we need to do some copying
					if (SHT_NOBITS == i->header.sh_type) {
						unsigned char *buff = new unsigned char[cpStop - cpStart];
						memset(buff, 0, cpStop - cpStart);
						mapr.WriteBytes((void *)(cpStart), buff, cpStop - cpStart);
						delete buff;
					}
					else {
						mapr.WriteBytes((void *)(cpStart), &i->data[cpStart - i->header.sh_addr], cpStop - cpStart);
					}
					dbg_log("%s[%lu:%lu] ", &sections[header.e_shstrndx].data[i->header.sh_name], cpStart - i->header.sh_addr, cpStop - i->header.sh_addr);
				}
			}
		}

		dbg_log("\n");
	}

	void FloatingELF32::ForAllExports(std::function<void(const char *, const DWORD, const char *, const DWORD, const unsigned char *)> verb) const {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if (SHT_DYNSYM == i->header.sh_type) {
				ELF32Sym *symb = (ELF32Sym *)i->data;
				DWORD count = i->header.sh_size / sizeof(*symb);
				for (DWORD j = 0; j < count; ++j) {
					if ((STB_GLOBAL == ELF32STBIND(symb[j].st_info)) && (SHN_UNDEF != symb[j].st_shndx)) {
						if (nullptr != i->versions && nullptr != gnu_versions_d) {
							ELFSymbolVersionDefined *vers = gnu_versions_d->idxSdVers[((WORD *)i->versions->data)[j]];

							if (0 != symb[j].st_value) {
								if (nullptr != vers) {
									verb(
											(const char *)&sections[i->header.sh_link].data[symb[j].st_name],
											0,
											vers->version.c_str(),
											symb[j].st_value,
											(const unsigned char *)RVA(symb[j].st_value)
										);
								}
								else {
									verb(
											(const char *)&sections[i->header.sh_link].data[symb[j].st_name],
											0,
											"",
											symb[j].st_value,
											(const unsigned char *)RVA(symb[j].st_value)
										);
								}
							}
						}
					}
				}
			}
		}
	}



	bool FloatingELF32::ParseVerNeed(ELFSection &s) {
		DWORD maxVer = 0;
		s.snVers.clear();
		for (unsigned char *ptr = s.data; ptr < s.data + s.header.sh_size; ) {
			ELF32VerNeed *vn = (ELF32VerNeed *)ptr;
			ptr += sizeof(*vn);

			dbg_log("%s with %d entries\n", &sections[s.header.sh_link].data[vn->vn_file], vn->vn_cnt);

			for (DWORD j = 0; j < vn->vn_cnt; ++j) {
				ELF32VerNeedAux *va = (ELF32VerNeedAux *)ptr;
				ptr += sizeof(*va);

				dbg_log("\t %s -> %d\n", &sections[s.header.sh_link].data[va->vna_name], va->vna_other);
				if (maxVer < va->vna_other) {
					maxVer = va->vna_other;
				}
				s.snVers.push_back(ELFSymbolVersionNeeded(va->vna_other, (char *)&sections[s.header.sh_link].data[va->vna_name], (char *)&sections[s.header.sh_link].data[vn->vn_file]));
			}
		}

		s.idxSnVers.resize(maxVer + 1);
		for (DWORD i = 0; i <= maxVer; ++i) {
			s.idxSnVers[i] = nullptr;
		}

		for (auto i = s.snVers.begin(); i != s.snVers.end(); ++i) {
			s.idxSnVers[i->index] = &(*i);
		}
		return true;
	}

	bool FloatingELF32::ParseVerDef(ELFSection &s) {
		DWORD maxVer = 0;
		s.snVers.clear();
		for (unsigned char *ptr = s.data; ptr < s.data + s.header.sh_size; ) {
			ELF32VerDef *vd = (ELF32VerDef *)ptr;
			ptr += sizeof(*vd);

			dbg_log("%d with %d entries [%s %s]\n", 
				vd->vd_ndx, 
				vd->vd_cnt,
				(vd->vd_flags & VER_FLG_BASE) ? "VER_FLG_BASE" : "",
				(vd->vd_flags & VER_FLG_WEAK) ? "VER_FLG_WEAK" : ""
			);

			if (maxVer < vd->vd_ndx) {
				maxVer = vd->vd_ndx;
			}

			for (DWORD j = 0; j < vd->vd_cnt; ++j) {
				ELF32VerDefAux *va = (ELF32VerDefAux *)ptr;
				ptr += sizeof(*va);

				// I think that VER_FLG_BASE marks an unversioned symbol
				if (0 == (vd->vd_flags & VER_FLG_BASE)) {
					if (0 == j) {
						dbg_log("\t %s\n", &sections[s.header.sh_link].data[va->vda_name]);
						s.sdVers.push_back(ELFSymbolVersionDefined(vd->vd_ndx, (char *)&sections[s.header.sh_link].data[va->vda_name]));
					}
				}
 			}
 		}

		s.idxSdVers.resize(maxVer + 1);
 		for (DWORD i = 0; i <= maxVer; ++i) {
			s.idxSdVers[i] = nullptr;
 		}


		for (auto i = s.sdVers.begin(); i != s.sdVers.end(); ++i) {
			s.idxSdVers[i->index] = &(*i);
 		}
 		return true;
 	}


	bool FloatingELF32::ParseDynamic(const ELFSection &s) {
		ELF32Dyn *dyns = (ELF32Dyn *)s.data;
		DWORD cnt = s.header.sh_size / sizeof(dyns[0]);

		for (DWORD j = 0; j < cnt; ++j) {
			DWORD value = dyns[j].d_un;
			DWORD *rValue = nullptr;
			switch (dyns[j].d_tag) {
				case DT_INIT :
					start = dyns[j].d_un;
					break;
				case DT_INIT_ARRAY:
					init_array = dyns[j].d_un;
					break;
				case DT_INIT_ARRAYSZ:
					init_array_sz = dyns[j].d_un;
					break;
				case DT_PLTGOT :
				case DT_HASH :
				case DT_STRTAB :
				case DT_SYMTAB :
				case DT_RELA :
				case DT_FINI :
				case DT_REL :
				case DT_DEBUG :
				case DT_JMPREL :
					rValue = (DWORD *)RVA(value);
			}

			switch (dyns[j].d_tag) {
				case DT_NEEDED :
					dbg_log("Need library %s\n", &sections[s.header.sh_link].data[value]);
					libraries.push_back((char *)&sections[s.header.sh_link].data[value]);
					break;
				case DT_REL :
					rd[REL_INDEX].rValue = rValue;
					rd[REL_INDEX].address = value;
					break;
				case DT_RELA :
					rela = rValue;
					break;
				case DT_RELSZ :
					rd[REL_INDEX].size = value;
					break;
				case DT_RELASZ :
					relaSz = value;
					break;
				case DT_RELENT :
					relEnt = value;
					break;
				case DT_RELAENT :
					relaEnt = value;
					break;
				case DT_JMPREL:
					rd[PLTREL_INDEX].rValue = rValue;
					rd[PLTREL_INDEX].address = value;
					break;
				case DT_PLTRELSZ:
					rd[PLTREL_INDEX].size = value;
					break;
				case DT_SONAME :
					dbg_log("So name %s\n", &sections[s.header.sh_link].data[value]);
					break;
			}
		}
		
		return true;
	}

	bool FloatingELF32::Map(AbstractMapper &mapr, AbstractImporter &impr, DWORD &baseAddr, bool callConstructors) {
		DWORD oNA = 0;

		for (auto i = pHeaders.begin(); i != pHeaders.end(); ++i) {
			DWORD tNA = 0;
			switch (i->header.p_type) {
				case PT_LOAD :
					tNA = (i->header.p_vaddr + i->header.p_memsz + i->header.p_align - 1) & ~(i->header.p_align - 1);
					break;
			}

			if (tNA > oNA) {
				oNA = tNA;
			}
		}

		dbg_log("Base: 0x%08lx; Size: 0x%08lx\n", moduleBase, oNA - moduleBase);

		baseAddr = (DWORD)mapr.CreateSection((void *)(baseAddr), oNA - moduleBase, PAGE_PROTECTION_READ | PAGE_PROTECTION_WRITE);
		if (0 == baseAddr) {
			return false;
		}

		FixImports(impr, baseAddr);

		Relocate(baseAddr);

		static const DWORD prot[] = {
			0, 1, 2, 3, 4, 5, 6, 7
		};

		for (auto i = pHeaders.begin(); i != pHeaders.end(); ++i) {
			DWORD startSegment, stopSegment;
			bool loaded = false;
			switch (i->header.p_type) {
				case PT_LOAD:
					startSegment = i->header.p_vaddr & ~(i->header.p_align - 1);
					stopSegment = (i->header.p_vaddr + i->header.p_memsz + i->header.p_align - 1) & ~(i->header.p_align - 1);
					MapSections(mapr, startSegment, stopSegment);
					loaded = true;
					break;
			}

			if (loaded) {
				void *address = (void*)(i->header.p_vaddr & ~(i->header.p_align - 1));
				mapr.ChangeProtect(address, stopSegment - startSegment, prot[i->header.p_flags]);
			}
		}

		typedef void (*start_handler) (void);
		typedef void (*init_handler) (void);

		if (!callConstructors)
			return true;

		if (start)
			((start_handler) (baseAddr + start)) ();

		// init array
		if (init_array) {
			unsigned int j, jm;
			jm = init_array_sz / 4;

			for (j = 0; j < jm; ++j) {
				(((init_handler*) (baseAddr + init_array))[j]) ();
			}
		}

		return true;
	}

	DWORD FloatingELF32::GetRequiredSize() const {
		DWORD maxAddr = 0x0;
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if (i->header.sh_addr == 0)
				continue;

			unsigned int alignment = std::max((DWORD)0x1000, i->header.sh_addralign);
			DWORD maxSec = ((i->header.sh_addr + i->header.sh_size) +
					(alignment - 1)) & (~(alignment - 1));
			if (maxSec > maxAddr)
				maxAddr = maxSec;
		}
		return maxAddr;
	}

}; //namespace ldr

```

`BinLoader/ELF.Loader.h`:

```h
#ifndef _ELF_LDR_H_
#define _ELF_LDR_H_

#include "Types.h"
#include "Abstract.Mapper.h"
#include "Abstract.Loader.h"

#include <stdio.h>

#include <vector>
#include <string>

namespace ldr {
	struct ElfIdent {
		DWORD e_magic; /* 0x00 */
		BYTE e_class;  /* 0x04 */
		BYTE e_data;   /* 0x05 */
		BYTE e_version;/* 0x06 */
		BYTE e_pad[9]; /* 0x07 */
	};

	struct Elf32Header {
		WORD e_type;
		WORD e_machine;
		DWORD e_version;
		DWORD e_entry;
		DWORD e_phoff;
		DWORD e_shoff;
		DWORD e_flags;
		WORD e_ehsize;
		WORD e_phentsize;
		WORD e_phnum;
		WORD e_shentsize;
		WORD e_shnum;
		WORD e_shstrndx;
	};

#define SHN_UNDEF			0
#define SHN_LORESERVE		0xff00
#define SHN_LOPROC			0xff00
#define SHN_HIPROC			0xff1f
#define SHN_ABS				0xfff1
#define SHN_COMMON			0xfff2
#define SHN_HIRESERVE		0xffff

#define SHT_NULL			0
#define SHT_PROGBITS		1
#define SHT_SYMTAB			2
#define SHT_STRTAB			3
#define SHT_RELA			4
#define SHT_HASH			5
#define SHT_DYNAMIC			6
#define SHT_NOTE			7
#define SHT_NOBITS			8
#define SHT_REL				9
#define SHT_SHLIB			10
#define SHT_DYNSYM			11
#define SHT_LOPROC			0x70000000
#define SHT_HIPROC			0x7fffffff
#define SHT_LOUSER			0x80000000
#define SHT_HIUSER			0xffffffff


	struct Elf32Shdr {
		DWORD sh_name;
		DWORD sh_type;
		DWORD sh_flags;
		DWORD sh_addr;
		DWORD sh_offset;
		DWORD sh_size;
		DWORD sh_link;
		DWORD sh_info;
		DWORD sh_addralign;
		DWORD sh_entsize;
	};


	class ELFSymbolVersionNeeded {
	public:
		DWORD index;
		std::string version;
		std::string module;

		ELFSymbolVersionNeeded(DWORD idx, std::string v, std::string m) :
			index(idx), version(v), module(m) {}
	};

	class ELFSymbolVersionDefined {
	public :
		WORD index;
		std::string version;

		ELFSymbolVersionDefined(WORD idx, std::string v) :
			index(idx), version(v)
		{}
	};


	class ELFSection {
	public:
		Elf32Shdr header;
		unsigned char *data;

		ELFSection *versions;
		std::vector<ELFSymbolVersionNeeded> snVers;
		std::vector<ELFSymbolVersionNeeded *> idxSnVers;

		std::vector<ELFSymbolVersionDefined> sdVers;
		std::vector<ELFSymbolVersionDefined *> idxSdVers;

		ELFSection();
		bool Load(FILE *fModule);
		void Unload();
	};

	struct Elf32Phdr {
		DWORD p_type;
		DWORD p_offset;
		DWORD p_vaddr;
		DWORD p_paddr;
		DWORD p_filesz;
		DWORD p_memsz;
		DWORD p_flags;
		DWORD p_align;
	};

	class ELFProgramHeader {
	public:
		Elf32Phdr header;

	};

	struct RelocData {
		void *rValue;
		DWORD address;
		DWORD size;
	};

#define REL_INDEX 0
#define PLTREL_INDEX 1

	class FloatingELF32 : public AbstractBinary {
	private:
		ElfIdent ident;
		Elf32Header header;

		std::vector<ELFProgramHeader> pHeaders;
		std::vector<ELFSection> sections;
		std::vector<std::string> libraries;
		DWORD moduleBase, start, init_array;
		RelocData rd[2];
		void *rela;
		DWORD relaSz, relEnt, relaEnt, init_array_sz;

		ELFSection *names;
		ELFSection *gnu_versions_r;
		ELFSection *gnu_versions_d;

		bool isValid;

		void *RVA(DWORD rva) const;

		bool LoadELF(FILE *fModule);

		bool PrintSymbols() const;

		bool RelocateSection(void *r, DWORD count, const ELFSection &symb, const ELFSection &names, DWORD offset);

		bool ParseVerNeed(ELFSection &s);
		bool ParseVerDef(ELFSection &s);
		bool ParseDynamic(const ELFSection &section);

		bool Relocate(DWORD newBase);
		void MapSections(AbstractMapper &mapr, DWORD startSeg, DWORD stopSeg);

		DWORD Import(AbstractImporter &impr, const char * name);
		bool FixImports(AbstractImporter &impr, DWORD offset);
	public:
		static bool CanLoad(FILE *fMod);

		FloatingELF32(const char *moduleName);
		FloatingELF32(const wchar_t *moduleName);
		~FloatingELF32();

		DWORD GetEntryPoint() const;
		DWORD GetRequiredSize() const;

		virtual bool Map(AbstractMapper &mapr, AbstractImporter &impr, DWORD &baseAddr, bool callConstructors = false);
		virtual bool GetExport(const char *funcName, DWORD &funcRVA) const;


		virtual void ForAllExports(std::function<void(const char *, const DWORD, const char *, const DWORD, const unsigned char *)> verb) const;

		virtual bool IsValid() const {
			return isValid;
		}
	};
}; //namespace ldr

#endif


```

`BinLoader/Extern.Mapper.cpp`:

```cpp
#include "Extern.Mapper.h"

#include <psapi.h>

namespace ldr {
#ifdef _WIN32

	// virtual memory functions
	static const DWORD PageProtections[8] = {
		PAGE_NOACCESS,				// 0 ---
		PAGE_EXECUTE,				// 1 --X
		PAGE_READWRITE,				// 2 -W- (specified as RW)
		PAGE_EXECUTE_READWRITE,		// 3 -WX (specified as RWX)
		PAGE_READONLY,				// 4 R--
		PAGE_EXECUTE_READ,			// 5 R-X
		PAGE_READWRITE,				// 6 RW-
		PAGE_EXECUTE_READWRITE		// 7 RWX
	};
//#define VIRTUAL_ALLOC(addr, size, protect, fd, offset) VirtualAlloc((addr), (size), MEM_RESERVE | MEM_COMMIT, (protect))
//#define VIRTUAL_PROTECT(addr, size, newProtect, oldProtect) (TRUE == VirtualProtect((addr), (size), (newProtect), &(oldProtect)))

#elif defined(__linux__)
	static const DWORD PageProtections[8] = {
		PROT_NONE,							// 0 ---
		PROT_EXEC,							// 1 --X
		PROT_WRITE,							// 2 -W-
		PROT_EXEC | PROT_WRITE,				// 3 -WX
		PROT_READ,							// 4 R--
		PROT_EXEC | PROT_READ,				// 5 R-X
		PROT_WRITE | PROT_READ,				// 6 RW-
		PROT_EXEC | PROT_WRITE | PROT_READ,	// 7 RWX
	};
	// virtual memory functions
//#define VIRTUAL_ALLOC(addr, size, protect, fd, offset) ({ int flags = ((fd) < 0) ? MAP_SHARED | MAP_ANONYMOUS : MAP_SHARED; \
//		addr = mmap(addr, (size), (protect), flags, (fd), (offset)); addr; })
//#define VIRTUAL_PROTECT(addr, size, newProtect, oldProtect) (0 == mprotect((addr), (size), (newProtect)))

#endif

	bool SameFile(const char *s1, int l1, const char *s2, int l2) {
		/*int cLen = l1;
		if (l2 < cLen) cLen = l2;

		int o1 = l1 - cLen, o2 = l2 - cLen;

		for (int i = 0; i < cLen; ++i) {
			if (toupper(s1[o1 + i]) != toupper(s2[o2 + i])) {
				return false;
			}
		}

		if ((o1 > 0) && (s1[o1 - 1] != '\\')) {
			return false;
		}

		if ((o2 > 0) && (s2[o2 - 1] != '\\')) {
			return false;
		}

		return true;*/

		if (l1 != l2) {
			return false;
		}

		for (int i = 0; i < l1; ++i) {
			if (toupper(s1[i]) == toupper(s2[i])) {
				return false;
			}
		}

		return true;
	}

	HMODULE ExternMapper::RemoteFindModule(const char *module) {
		HMODULE hMods[1024];
		DWORD cbNeeded;

		int mLen = strlen(module);

		if (EnumProcessModules(hProc, hMods, sizeof(hMods), &cbNeeded)) {
			for (unsigned int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {
				char szModName[MAX_PATH];
				if (GetModuleFileNameExA(hProc, hMods[i], szModName, sizeof(szModName))) {
					int rLen = strlen(szModName);

					if (SameFile(module, mLen, szModName, rLen)) {
						return hMods[i];
					}
				}
			}
		}

		return NULL;
	}

	ExternMapper::ExternMapper(unsigned int pid) {
		hProc = OpenProcess(
			PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
			FALSE,
			pid
		);

		ownProcess = true;
	}

	ExternMapper::ExternMapper(HANDLE process) {
		hProc = process;
		ownProcess = false;
	}

	ExternMapper::~ExternMapper() {
		if (ownProcess) {
			CloseHandle(hProc);
		}
	}

	void *ExternMapper::CreateSection(void *lpAddress, SIZE_T dwSize, DWORD flProtect) {
		return VirtualAllocEx(hProc, lpAddress, dwSize, MEM_RESERVE | MEM_COMMIT, PageProtections[flProtect]);
	}

	bool ExternMapper::ChangeProtect(void *lpAddress, SIZE_T dwSize, DWORD flProtect) {
		DWORD oldProtect;
		return TRUE == VirtualProtectEx(hProc, lpAddress, dwSize, PageProtections[flProtect], &oldProtect);
	}

	bool ExternMapper::WriteBytes(void *lpAddress, void *lpBuffer, SIZE_T nSize) {
		return TRUE == WriteProcessMemory(hProc, lpAddress, lpBuffer, nSize, NULL);
	}

	/* This is very sloppy! */
	/* Should work for ntdll. No WOW64 support. No export forwarding. */
	DWORD ExternMapper::FindImport(const char *moduleName, const char *funcName) {
		HMODULE rMod = RemoteFindModule(moduleName);
		HMODULE lMod = GetModuleHandleA(moduleName);

		if ((NULL == rMod) || (NULL == lMod)) {
			return 0xFFFFFFFF;
		}

		void *pFunc = GetProcAddress(lMod, funcName);
		return (DWORD)pFunc - (DWORD)lMod + (DWORD)rMod;
	}

	DWORD ExternMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
		HMODULE lMod = GetModuleHandleA(moduleName);
		char modName[MAX_PATH];

		GetModuleFileNameA(lMod, modName, sizeof(modName));
		HMODULE rMod = RemoteFindModule(modName);


		if ((NULL == rMod) || (NULL == lMod)) {
			return 0xFFFFFFFF;
		}

		void *pFunc = GetProcAddress(lMod, (LPCSTR)funcOrdinal);
		return (DWORD)pFunc - (DWORD)lMod + (DWORD)rMod;
	}

	DWORD ExternMapper::FindImport(const char *moduleName, const char *funcName, const char* version) {
		return FindImport(moduleName, funcName);
	}

};
```

`BinLoader/Extern.Mapper.h`:

```h
#ifndef _EXTERN_MAPPER_H_
#define _EXTERN_MAPPER_H_
#ifdef _WIN32

#include <Windows.h>

#include "Abstract.Mapper.h"
#include "Abstract.Importer.h"

namespace ldr {
	class ExternMapper : public AbstractMapper, public AbstractImporter {
	private:
		HANDLE hProc;
		bool ownProcess;

		HMODULE RemoteFindModule(const char *module);
	public:
		ExternMapper(unsigned int pid);
		ExternMapper(HANDLE process);
		virtual ~ExternMapper();

		virtual void *CreateSection(void *lpAddress, SIZE_T dwSize, DWORD flProtect);
		virtual bool ChangeProtect(void *lpAddress, SIZE_T dwSize, DWORD flProtect);
		virtual bool WriteBytes(void *lpAddress, void *lpBuffer, SIZE_T nSize);

		virtual DWORD FindImport(const char *moduleName, const char *funcName);
		virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
		virtual DWORD FindImport(const char *moduleName, const char *funcName, const char* version);
	};
};
#endif
#endif

```

`BinLoader/Inproc.Mapper.cpp`:

```cpp
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__)
#include <stdlib.h>
#include <sys/mman.h>
#include <string.h>
#include <dlfcn.h>
#endif

#include "Inproc.Mapper.h"

namespace ldr {
#ifdef _WIN32

// virtual memory functions
	static const DWORD PageProtections[8] = {
		PAGE_NOACCESS,				// 0 ---
		PAGE_EXECUTE,				// 1 --X
		PAGE_READWRITE,				// 2 -W- (specified as RW)
		PAGE_EXECUTE_READWRITE,		// 3 -WX (specified as RWX)
		PAGE_READONLY,				// 4 R--
		PAGE_EXECUTE_READ,			// 5 R-X
		PAGE_READWRITE,				// 6 RW-
		PAGE_EXECUTE_READWRITE		// 7 RWX
	};
#define VIRTUAL_ALLOC(addr, size, protect, fd, offset) VirtualAlloc((addr), (size), MEM_RESERVE | MEM_COMMIT, (protect))
#define VIRTUAL_PROTECT(addr, size, newProtect, oldProtect) (TRUE == VirtualProtect((addr), (size), (newProtect), &(oldProtect)))

#elif defined(__linux__)
	static const DWORD PageProtections[8] = {
		PROT_NONE,							// 0 ---
		PROT_EXEC,							// 1 --X
		PROT_WRITE,							// 2 -W-
		PROT_EXEC | PROT_WRITE,				// 3 -WX
		PROT_READ,							// 4 R--
		PROT_EXEC | PROT_READ,				// 5 R-X
		PROT_WRITE | PROT_READ,				// 6 RW-
		PROT_EXEC | PROT_WRITE | PROT_READ,	// 7 RWX
	};
// virtual memory functions
#define VIRTUAL_ALLOC(addr, size, protect, fd, offset) ({ int flags = ((fd) < 0) ? MAP_SHARED | MAP_ANONYMOUS : MAP_SHARED; \
		addr = mmap(addr, (size), (protect), flags, (fd), (offset)); addr; })
#define VIRTUAL_PROTECT(addr, size, newProtect, oldProtect) (0 == mprotect((addr), (size), (newProtect)))

#endif

	InprocMapper::InprocMapper(int shmFd, size_t offset) {
		this->shmFd = shmFd;
		this->offset = offset;
	}

	void *InprocMapper::CreateSection(void *lpAddress, SIZE_T dwSize, DWORD flProtect) {
		return VIRTUAL_ALLOC(lpAddress, dwSize, PageProtections[flProtect], shmFd, offset);
	}

	bool InprocMapper::ChangeProtect(void *lpAddress, SIZE_T dwSize, DWORD flProtect) {
		DWORD oldProtect;
		return VIRTUAL_PROTECT(lpAddress, dwSize, PageProtections[flProtect], oldProtect);
	}

	bool InprocMapper::WriteBytes(void *lpAddress, void *lpBuffer, SIZE_T nSize) {
		memcpy(lpAddress, lpBuffer, nSize);
		return true;
	}
};

```

`BinLoader/Inproc.Mapper.h`:

```h
#ifndef _INPROC_MAPPER_H_
#define _INPROC_MAPPER_H_

#include <stdlib.h> //size_t
#include "Abstract.Mapper.h"

namespace ldr {
	class InprocMapper : public AbstractMapper {
	private:
		int shmFd;
		size_t offset;

	public:
		InprocMapper(int shmFd = -1, size_t offset = 0);
		virtual void *CreateSection(void *lpAddress, SIZE_T dwSize, DWORD flProtect);
		virtual bool ChangeProtect(void *lpAddress, SIZE_T dwSize, DWORD flProtect);
		virtual bool WriteBytes(void *lpAddress, void *lpBuffer, SIZE_T nSize);
	};
};

#endif

```

`BinLoader/Inproc.Native.Importer.cpp`:

```cpp
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__)
#include <stdlib.h>
#include <sys/mman.h>
#include <string.h>
#include <dlfcn.h>
#endif

#include "Inproc.Native.Importer.h"
#include "Abstract.Loader.h"

namespace ldr {
#ifdef _WIN32
#define MODULE_PTR HMODULE
#define GET_MODULE_HANDLE(name) GetModuleHandleA((name))
#define GET_PROC_ADDRESS_BY_NAME(module, name) GetProcAddress((module), (name))
#define GET_PROC_ADDRESS_BY_ORDINAL(module, name) GetProcAddress((module), (LPCSTR)(name))
	// versioned imports not present on Windows
#define GET_PROC_ADDRESS_BY_NAME_VERSION(module, name, version) IMPORT_NOT_FOUND
#define GET_IMPORT(module, rva) ((0 == rva) ? (IMPORT_NOT_FOUND) : ((DWORD)module) + (rva))
#elif defined(__linux__)
#define MODULE_PTR void *
#define GET_MODULE_HANDLE(name) dlopen((name), RTLD_LAZY)
#define GET_PROC_ADDRESS_BY_NAME(module, name) dlsym((module), (name))
	// function ordinals not present on Linux
#define GET_PROC_ADDRESS_BY_ORDINAL(module, name) IMPORT_NOT_FOUND
#define GET_PROC_ADDRESS_BY_NAME_VERSION(module, name, version) dlvsym((module), (name), (version))
#define GET_IMPORT(module, rva) ((0 == rva) ? (IMPORT_NOT_FOUND) : (*(DWORD *)module) + (rva))
	//TODO
#endif

	InprocNativeImporter::CachedModule *InprocNativeImporter::AddModule(const char *name)	{
		int sz = modules.size();
		modules.resize(sz + 1);

		modules[sz].moduleName = name;
		return &modules[sz];
	}

	InprocNativeImporter::CachedModule *InprocNativeImporter::FindModule(const char *moduleName) {
		for (auto it = modules.begin(); it != modules.end(); ++it) {
			if (it->moduleName == moduleName) {
				return &(*it);
			}
		}
		return nullptr;
	}

	InprocNativeImporter::CachedModule *InprocNativeImporter::GetModule(const char *name) {
		CachedModule *mod = FindModule(name);

		if (nullptr == mod) {
			AbstractBinary *bin = LoadBinary(name); 
			
			if (nullptr == bin) {
				printf("[BinLoader] Could not load module %s\n", name);
				return nullptr;
			}
			mod = AddModule(name);
			bin->ForAllExports([mod](const char *funcName, const DWORD ordinal, const char *version, const DWORD rva, const unsigned char *body) {
				mod->AddImport(funcName, ordinal, version, rva);
			});

			delete bin;
		}

		return mod;
	}

	void InprocNativeImporter::CachedModule::AddImport(const char *funcName, const unsigned int ordinal, const char *version, DWORD rva) {
		int sz = entries.size();

		entries.resize(sz + 1);
		entries[sz].funcName = funcName;
		entries[sz].ordinal = ordinal;
		entries[sz].version = version;
		entries[sz].rva = rva;
	}



	DWORD InprocNativeImporter::CachedModule::FindCachedImport(const char *funcName) {
		for (auto it = entries.begin(); it != entries.end(); ++it) {
			if (it->funcName == funcName) {
				return it->rva;
			}
		}
		return 0;
	}

	DWORD InprocNativeImporter::CachedModule::FindCachedImport(const unsigned int funcOrdinal) {
		for (auto it = entries.begin(); it != entries.end(); ++it) {
			if (it->ordinal == funcOrdinal) {
				return it->rva;
			}
		}
		return 0;
	}

	DWORD InprocNativeImporter::CachedModule::FindCachedImport(const char *funcName, const char *version) {
		for (auto it = entries.begin(); it != entries.end(); ++it) {
			if ((it->funcName == funcName) && (it->version == version)) {
				return it->rva;
			}
		}
		return 0;
	}

	DWORD InprocNativeImporter::FindImport(const char *moduleName, const char *funcName) {
		MODULE_PTR hModule = GET_MODULE_HANDLE(moduleName);

		if (NULL == hModule) {
			return IMPORT_NOT_FOUND;
		}

		DWORD ret = (DWORD)GET_PROC_ADDRESS_BY_NAME(hModule, funcName);

		if (0 == ret) {
			CachedModule *mod = GetModule(moduleName);
			ret = GET_IMPORT(hModule, mod->FindCachedImport(funcName));
		}

		return ret;
	}

	DWORD InprocNativeImporter::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
		MODULE_PTR hModule = GET_MODULE_HANDLE(moduleName);

		if (NULL == hModule) {
			return IMPORT_NOT_FOUND;
		}
		DWORD ret = (DWORD)GET_PROC_ADDRESS_BY_ORDINAL(hModule, funcOrdinal);
		if (0 == ret) {
			CachedModule *mod = GetModule(moduleName);
			ret = GET_IMPORT(hModule, mod->FindCachedImport(funcOrdinal));
		}

		return ret;
	}

	DWORD InprocNativeImporter::FindImport(const char *moduleName, const char *funcName, const char *version) {
		MODULE_PTR hModule = GET_MODULE_HANDLE(moduleName);

		if (NULL == hModule) {
			return IMPORT_NOT_FOUND;
		}
		DWORD ret = (DWORD)GET_PROC_ADDRESS_BY_NAME_VERSION(hModule, funcName, version);
		if (0 == ret) {
			CachedModule *mod = GetModule(moduleName);
			ret = GET_IMPORT(hModule, mod->FindCachedImport(funcName, version));
		}

		return ret;
	}

};

```

`BinLoader/Inproc.Native.Importer.h`:

```h
#ifndef _INPROC_NATIVE_IMPORTER_H_
#define _INPROC_NATIVE_IMPORTER_H_

#include "Abstract.Importer.h"
#include <vector>
#include <string>

namespace ldr {
	class InprocNativeImporter : public AbstractImporter {

	private:
		struct CachedEntry {
			std::string funcName;
			unsigned int ordinal;
			std::string version;
			DWORD rva;
		};

		struct CachedModule {
			std::string moduleName;
			std::vector<CachedEntry> entries;

			void AddImport(const char *funcName, const unsigned int ordinal, const char *version, DWORD rva);

			DWORD FindCachedImport(const char *funcName);
			DWORD FindCachedImport(const unsigned int funcOrdinal);
			DWORD FindCachedImport(const char *funcName, const char *version);
		};
		std::vector<CachedModule> modules;


		CachedModule *AddModule(const char *name);
		CachedModule *FindModule(const char *moduleName);

		CachedModule *GetModule(const char *name);

	public:
		virtual DWORD FindImport(const char *moduleName, const char *funcName);
		virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);

		virtual DWORD FindImport(const char *moduleName, const char *funcName, const char *version);
	};
};

#endif

```

`BinLoader/LoaderAPI.cpp`:

```cpp
#include "Abstract.Importer.h"
#include "Shm.Mapper.h"
#include "Inproc.Mapper.h"
#include "Mem.Mapper.h"
#include "Inproc.Native.Importer.h"
#include "Extern.Mapper.h"
#include "ELF.Loader.h"
#include <stdio.h>

#include "LoaderAPI.h"
#include "Common.h"
// keep in mind that this funcion does NOT return the module base
void ManualLoadLibrary(const wchar_t *libName, ldr::AbstractBinary *&module, BASE_PTR &baseAddr) {
	CreateModule(libName, module);

	if (!module)
		return;

	MapModule(module, baseAddr, false, -1, 0);
}

void CreateModule(const wchar_t *libname, ldr::AbstractBinary *&module) {
	ldr::AbstractBinary *fExec = ldr::LoadBinary(libname);

	if (fExec && !fExec->IsValid()) {
		delete fExec;
		return;
	}

	module = fExec;
}

void CreateModule(const char *libname, ldr::AbstractBinary *&module) {
	ldr::AbstractBinary *fExec = ldr::LoadBinary(libname);

	if (fExec && !fExec->IsValid()) {
		delete fExec;
		return;
	}

	module = fExec;
}

void MapModule(ldr::AbstractBinary *&module, BASE_PTR &baseAddr, bool callConstructors, int shmFd, unsigned long offset) {
	ldr::ShmMapper mpr(shmFd, offset);
	ldr::InprocNativeImporter imp;

	if (!module->Map(mpr, imp, (ldr::DWORD &)baseAddr, callConstructors)) {
		delete module;
		return;
	}
}

#ifdef _WIN32
void MapModule(ldr::AbstractBinary *&module, BASE_PTR &baseAddr) {
	ldr::InprocMapper mpr;
	ldr::InprocNativeImporter imp;

	if (!module->Map(mpr, imp, (ldr::DWORD &)baseAddr, false)) {
		delete module;
		return;
	}
}

void MapModule2(ldr::AbstractBinary *&module, BASE_PTR &baseAddr) {
	ldr::MemMapper mpr;
	ldr::InprocNativeImporter imp;

	if (!module->Map(mpr, imp, (ldr::DWORD &)baseAddr, false)) {
		delete module;
		return;
	}
}

void MapModuleExtern(ldr::AbstractBinary *&module, BASE_PTR &baseAddr, void *hProcess) {
	ldr::ExternMapper mLoader(hProcess);
	module->Map(mLoader, mLoader, (ldr::DWORD &)baseAddr, false);
}
#endif

void *ManualGetProcAddress(ldr::AbstractBinary *module, BASE_PTR base, const char *funcName) {

	DWORD rva;
	if (!module->GetExport(funcName, rva)) {
		return nullptr;
	}
	return (void *)(base + rva);
}

DWORD GetEntryPoint(const char *elfName) {
	ldr::AbstractBinary *fExec = ldr::LoadBinary(elfName);
	if (ldr::FloatingELF32* fElf = dynamic_cast<ldr::FloatingELF32*>(fExec)) {
		unsigned long entryPoint = fElf->GetEntryPoint();
		delete fExec;
		return entryPoint;
	}

	delete fExec;
	return 0;
}


```

`BinLoader/LoaderAPI.h`:

```h
#ifndef _LOADER_API
#define _LOADER_API

#if defined(__linux__)
#include <string>
#include "Abstract.Loader.h"
typedef unsigned long DWORD;
typedef ldr::AbstractBinary *MODULE_PTR;
typedef DWORD BASE_PTR;
struct mappedObject {
	MODULE_PTR module;
	BASE_PTR base;
	DWORD size;
};

#define LOAD_LIBRARYW(libName, module, base) ManualLoadLibrary((libName), (module), (base))
#define GET_PROC_ADDRESS(module, base, name) ManualGetProcAddress((module), (base), (name))
#define UNLOAD_MODULE(module) delete (module)

#elif defined(_WIN32)

#include <Windows.h>
typedef HMODULE BASE_PTR;
typedef void *MODULE_PTR;

#define LOAD_LIBRARYW(libName, module, base) do { base = LoadLibraryW((libName)); module = nullptr; } while (false);
#define GET_PROC_ADDRESS(module, base, name) GetProcAddress((base), (name))
#define UNLOAD_MODULE(module)
#endif


#include "Abstract.Loader.h"

struct MappedObject {
	ldr::AbstractBinary *module;
	BASE_PTR base;
	DWORD size;
};

void ManualLoadLibrary(const wchar_t *libName, ldr::AbstractBinary *&module, BASE_PTR &baseAddr);
void *ManualGetProcAddress(ldr::AbstractBinary *module, BASE_PTR base, const char *funcName);
DWORD GetEntryPoint(const char *elfName);
void CreateModule(const wchar_t *libname, ldr::AbstractBinary *&module);
void CreateModule(const char *libname, ldr::AbstractBinary *&module);
void MapModule(ldr::AbstractBinary *&module, BASE_PTR &baseAddr);
void MapModule2(ldr::AbstractBinary *&module, BASE_PTR &baseAddr);
void MapModule(ldr::AbstractBinary *&module, BASE_PTR &baseAddr, bool callConstructors, int shmFd, unsigned long offset);
void MapModuleExtern(ldr::AbstractBinary *&module, BASE_PTR &baseAddr, void *hProcess);

template <typename T> bool LoadExportedName(ldr::AbstractBinary *&module, BASE_PTR &base, const char *name, T *&ptr) {
	//ptr = (T *)GET_PROC_ADDRESS(module, base, name);
	//return ptr != NULL;
	ldr::DWORD rva;

	if (module->GetExport(name, rva)) {
		ptr = (T*)(rva + (DWORD)base);
		return true;
	}

	ptr = nullptr;
	return false;
}


#endif

```

`BinLoader/Main.cpp`:

```cpp
#include <stdio.h>
#include <assert.h>
#include "Abstract.Loader.h"
#include "Abstract.Importer.h"
#include "Inproc.Mapper.h"
#include "Inproc.Native.Importer.h"
#include "LoaderAPI.h"

typedef void* (*handler)(unsigned long);
typedef int (*_printf)(const char *format, ...);
_printf myPrintf;

int main() {
	//ldr::AbstractBinary *fElf = ldr::LoadBinary("tested");
	//if (!fElf)
	//	return -1;

	//if (fElf->IsValid()) {
	//	printf("All				is good!\n\n");
	//}

	ldr::DWORD entry = GetEntryPoint("tested");
	printf("Got entry point %lx\n", entry);

	//void *func = (void*)imp.FindImport("librevtracerwrapper.so", "CallAllocateMemoryHandler");

	//void *addr = ((handler)func) (1024);
	//printf("Allocated %d bytes @address %p\n", 1024, addr);

	//delete fElf;
	MODULE_PTR lModule = nullptr;
	BASE_PTR lBase = 0;
	CreateModule("libc.so", lModule);
	assert(lModule != nullptr);
	MapModule(lModule, lBase);
	assert(lBase != 0);
	LoadExportedName(lModule, lBase, "printf", myPrintf);
	assert(myPrintf != nullptr);
	myPrintf("My printf function is working\n");
	fflush(stdout);

	//CreateModule("libpthread.so", lModule);
	//assert(lModule != nullptr);
	//lBase = 0;
	//MapModule(lModule, lBase);
	//assert(lBase != 0);
	return 0;
}


```

`BinLoader/Makefile`:

```
test_bin := test_bin
lib_binloader := libbinloader.a
CC := gcc
CXX := g++
LOADER_FILES := ELF.Loader.cpp PE.Loader.cpp Unified.Loader.cpp LoaderAPI.cpp
MAPPER_FILES := Inproc.Mapper.cpp Shm.Mapper.cpp
IMPORTER_FILES := Inproc.Native.Importer.cpp
CPP_FILES := Common.cpp $(LOADER_FILES) $(MAPPER_FILES) $(IMPORTER_FILES)
OBJ_FILES := $(addprefix ,$(CPP_FILES:.cpp=.o))
CXX_FLAGS += -g -m32 -std=c++11
prefix := /usr/local

all: $(lib_binloader)

test_bin: $(lib_binloader) Main.o
	$(CXX) -L. $(CXX_FLAGS) -o main Main.o -lbinloader -ldl

install: $(lib_binloader)
	install -m 0755 $(lib_binloader) -t $(prefix)/lib -D

$(lib_binloader): $(OBJ_FILES)
	$(AR) rcs $@ $^

%.o: %.cpp
	   $(CXX) $(CXX_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(lib_binloader) $(OBJ_FILES) *.o main

```

`BinLoader/Mem.Mapper.cpp`:

```cpp
#include <Windows.h>
#include "Mem.Mapper.h"

namespace ldr {
	void *MemMapper::CreateSection(void *lpAddress, SIZE_T dwSize, DWORD flProtect) {
		return lpAddress;
	}

	bool MemMapper::ChangeProtect(void *lpAddress, SIZE_T dwSize, DWORD flProtect) {
		return true;
	}

	bool MemMapper::WriteBytes(void *lpAddress, void *lpBuffer, SIZE_T nSize) {
		memcpy(lpAddress, lpBuffer, nSize);
		return true;
	}
};
```

`BinLoader/Mem.Mapper.h`:

```h
#ifndef _MEM_MAPPER_H_
#define _MEM_MAPPER_H_

#include "Abstract.Mapper.h"

namespace ldr {
	class MemMapper : public AbstractMapper {
	public:
		virtual void *CreateSection(void *lpAddress, SIZE_T dwSize, DWORD flProtect);
		virtual bool ChangeProtect(void *lpAddress, SIZE_T dwSize, DWORD flProtect);
		virtual bool WriteBytes(void *lpAddress, void *lpBuffer, SIZE_T nSize);
	};
}

#endif
```

`BinLoader/PE.Loader.cpp`:

```cpp
#include <stdio.h>
#include <string.h>

#include <vector>

#include "Common.h"
using namespace std;

//#include "..\extern.h"

#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#endif

#include "PE.Loader.h"

//#include "common/debug-log.h"
//#define dbg_log DbgPrint

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5
#define IMAGE_REL_BASED_RESERVED              6
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9
#define IMAGE_REL_BASED_DIR64                 10

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     

#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     

#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define PAGE_REVERT_TO_FILE_MAP     0x80000000 

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

namespace ldr {

	const USHORT DOS_MAGIC = 0x5A4D;
	const DWORD PE_MAGIC = 0x00004550;
	const WORD OPT32_MAGIC = 0x010B;
	const WORD OPT64_MAGIC = 0x020B;

	const WORD IMAGE_FILE_MACHINE_I386 = 0x14C;
	const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;

	typedef struct _IMAGE_BASE_RELOCATION {
		DWORD   VirtualAddress;
		DWORD   SizeOfBlock;
		//  WORD    TypeOffset[1];
	} IMAGE_BASE_RELOCATION;

	typedef struct _IMAGE_IMPORT_DESCRIPTOR {
		DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
		DWORD   TimeDateStamp;                  // 0 if not bound,
												// -1 if bound, and real date\time stamp
												//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
												// O.W. date/time stamp of DLL bound to (Old BIND)

		DWORD   ForwarderChain;                 // -1 if no forwarders
		DWORD   Name;
		DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
	} IMAGE_IMPORT_DESCRIPTOR;

	typedef struct _IMAGE_EXPORT_DIRECTORY {
		DWORD Characteristics;
		DWORD TimeDateStamp;
		WORD MajorVersion;
		WORD MinorVersion;
		DWORD Name;
		DWORD Base;
		DWORD NumberOfFunctions;
		DWORD NumberOfNames;
		DWORD AddressOfFunctions; // RVA from base of image
		DWORD AddressOfNames; // RVA from base of image
		DWORD AddressOfNameOrdinals; // RVA from base of image
	} IMAGE_EXPORT_DIRECTORY;

	void *FloatingPE::RVA(DWORD rva) const {
		for (int i = 0; i < peHdr.NumberOfSections; ++i) {
			if (rva >= sections[i].header.VirtualAddress) {
				DWORD dwOffset = rva - sections[i].header.VirtualAddress;
				if (dwOffset < sections[i].header.VirtualSize) {
					return sections[i].data + dwOffset;
				}
			}
		}
		return (void *)0;
	}

	bool FloatingPE::Relocate(DWORD newAddr) {
		long long offset = 0;
		IMAGE_BASE_RELOCATION *reloc;
		IMAGE_BASE_RELOCATION *term;

		switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			offset = newAddr - optHdr.w32.ImageBase;
			optHdr.w32.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			offset = newAddr - optHdr.w64.ImageBase;
			optHdr.w64.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
		}

		while (reloc < term) {
			//dbg_log("Relocation Block %08x %08x", reloc->VirtualAddress, reloc->SizeOfBlock);
			WORD *wloc = (WORD *)reloc + 4;
			int wlocCount = (reloc->SizeOfBlock - sizeof(*reloc)) / sizeof(*wloc);

			for (int i = 0; i < wlocCount; ++i) {
				//dbg_log("%x %x;\t", wloc[i] >> 12, wloc[i] & 0x0FFF);
				WORD type = wloc[i] >> 12;
				WORD off = wloc[i] & 0x0FFF;

				if ((i % 3) == 0) {
					//dbg_log("\n");
				}

				switch (type) {
				case IMAGE_REL_BASED_ABSOLUTE:
					break;
				case IMAGE_REL_BASED_HIGHLOW:
					*((DWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					//dbg_log("%08x -> %08x\t", reloc->VirtualAddress + off, *((DWORD *)RVA(reloc->VirtualAddress + off)));
					break;
				case IMAGE_REL_BASED_DIR64:
					*((QWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					break;
				default:
					//__asm int 3;
					DEBUG_BREAK;
				}
			}
			//dbg_log("\n");
			reloc = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + reloc->SizeOfBlock);
		}


		return true;
	}

	bool FloatingPE::GetExport(const char *funcName, DWORD &funcRVA) const {
		DWORD exportRVA = 0;

		switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			exportRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			exportRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
		};

		if (0 == exportRVA) {
			return false;
		}

		IMAGE_EXPORT_DIRECTORY *exprt = (IMAGE_EXPORT_DIRECTORY *)RVA(exportRVA);

		dbg_log("Number of functions: %d\n", exprt->NumberOfFunctions);
		dbg_log("Number of names: %d\n", exprt->NumberOfNames);

		DWORD *names = (DWORD *)RVA(exprt->AddressOfNames);
		int found = -1;
		for (DWORD i = 0; i < exprt->NumberOfNames; ++i) {
			char *name = (char *)RVA(names[i]);
			if (0 == strcmp(name, funcName)) {
				found = i;
				break;
			}
		}

		if (-1 == found) {
			return false;
		}

		WORD *ordinals = (WORD *)RVA(exprt->AddressOfNameOrdinals);
		WORD ordinal = ordinals[found] - (WORD)exprt->Base + 1;

		DWORD *exportTable = (DWORD *)RVA(exprt->AddressOfFunctions);
		funcRVA = exportTable[ordinal];

		return true;
	}

	void FloatingPE::ForAllExports(std::function<void(const char *, const DWORD, const char *, const DWORD, const unsigned char *)> verb) const {
		DWORD exportRVA = 0;

		switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			exportRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			exportRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return;
		};

		if (0 == exportRVA) {
			return;
		}

		IMAGE_EXPORT_DIRECTORY *exprt = (IMAGE_EXPORT_DIRECTORY *)RVA(exportRVA);

		dbg_log("Number of functions: %d\n", exprt->NumberOfFunctions);
		dbg_log("Number of names: %d\n", exprt->NumberOfNames);

		DWORD *names = (DWORD *)RVA(exprt->AddressOfNames);
		WORD *ordinals = (WORD *)RVA(exprt->AddressOfNameOrdinals);
		DWORD *exportTable = (DWORD *)RVA(exprt->AddressOfFunctions);

		for (DWORD i = 0; i < exprt->NumberOfNames; ++i) {
			verb(
				(char *)RVA(names[i]),
				ordinals[i] + (WORD)exprt->Base,
				"",
				exportTable[ordinals[i]],
				(const unsigned char *)RVA(exportTable[ordinals[i]])
			);
		}
	}

	DWORD FloatingPE::GetRequiredSize() const {
		DWORD maxAddr = 0;
		for (DWORD i = 0; i < sections.size(); ++i) {
			if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
				continue;
			}

			DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFFF) & (~0xFFFF);
			if (maxSec > maxAddr) {
				maxAddr = maxSec;
			}
		}

		return maxAddr;
	}

	DWORD FloatingPE::GetSectionCount() const {
		return sections.size();
	}

	const PESection *FloatingPE::GetSection(DWORD dwIdx) const {
		return &sections[dwIdx];
	}


	bool FloatingPE::FixImports(AbstractImporter &impr) {
		DWORD importRVA = 0;


		switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			importRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			importRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
		};

		if (0 == importRVA) {
			return true;
		}

		IMAGE_IMPORT_DESCRIPTOR *import = (IMAGE_IMPORT_DESCRIPTOR *)RVA(importRVA);
		if (NULL == import) {
			return false;
		}

		while (import->OriginalFirstThunk != 0) {
			char *name = (char *)RVA(import->Name);
			dbg_log("Directory for: %s\n", name);
			dbg_log("OFT: %08x, FT: %08x\n", import->OriginalFirstThunk, import->FirstThunk);
			DWORD *funcs = (DWORD *)RVA(import->OriginalFirstThunk);
			DWORD *iat = (DWORD *)RVA(import->FirstThunk);
			while (*funcs != 0) {
				if (0x80000000 & *funcs) {
					dbg_log("Import by ordinal %d\n", *funcs & 0x7FFF);
					*iat = impr.FindImport(name, *funcs & 0x7FFF);
				}
				else {
					char *funcName = (char *)RVA(*funcs + 2);
					dbg_log("Import by name %s\n", funcName);
					*iat = impr.FindImport(name, funcName);
				}

				funcs += 1;
				iat += 1;
			}

			import += 1;
		}

		return true;
	}

	bool ldr::FloatingPE::CanLoad(FILE * fMod) {
		ImageDosHeader dosHdr;

		fseek(fMod, 0, SEEK_SET);

		if (1 != fread(&dosHdr, sizeof(dosHdr), 1, fMod)) {
			return false;
		}

		if (dosHdr.e_magic != DOS_MAGIC) {
			return false;
		}

		// the file seems to be a PE
		return true;
	}

	bool FloatingPE::LoadPE(FILE *fModule) {
		if (NULL == fModule) {
			dbg_log("File open error!\n");
			return false;
		}

		if (1 != fread(&dosHdr, sizeof(dosHdr), 1, fModule)) {
			dbg_log("Read error\n");
			return false;
		}

		if (dosHdr.e_magic != DOS_MAGIC) {
			dbg_log("dosHdr.e_magic not valid\n");
			return false;
		}

		fseek(fModule, dosHdr.e_lfanew, SEEK_SET);


		if (1 != fread(&peHdr, sizeof(peHdr), 1, fModule)) {
			dbg_log("Read error\n");
			return false;
		}

		if (PE_MAGIC != peHdr.PeSignature) {
			dbg_log("peHdr.PeSignature not valid\n");
			return false;
		}

		//dbg_log("Machine: %d\n", peHdr.Machine);
		//dbg_log("NumberOfSections: %d\n", peHdr.NumberOfSections);
		//dbg_log("SizeOfOptionalHeader: %d\n", peHdr.SizeOfOptionalHeader);
		//dbg_log("Characteristics: %d\n", peHdr.Characteristics);

		DWORD optSize = 0;
		switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w32);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w64);
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
		}

		if (peHdr.SizeOfOptionalHeader != optSize) {
			dbg_log("Unsupported optional header\n");
			return false;
		}

		if (1 != fread(&optHdr, optSize, 1, fModule)) {
			dbg_log("Read error\n");
			return false;
		}


		switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			if (OPT32_MAGIC != optHdr.c.Magic) {
				dbg_log("opt32Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %08x\n", optHdr.w32.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w32.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w32.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w32.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w32.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w32.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w32.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w32.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w32.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
			);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			if (OPT64_MAGIC != optHdr.c.Magic) {
				dbg_log("opt64Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %016x\n", optHdr.w64.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w64.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w64.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w64.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w64.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w64.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w64.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w64.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w64.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
			); break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
		}



		sections.resize(peHdr.NumberOfSections);

		dbg_log("Name\t V.Size\t V.Addr\t R.Size\t R.Addr\t Characteristics\n");
		for (int i = 0; i < peHdr.NumberOfSections; ++i) {
			if (1 != fread(&sections[i].header, sizeof(sections[i].header), 1, fModule)) {
				dbg_log("read error\n");
				return false;
			}

			dbg_log("%.8s\t %08x %08x %08x %08x %08x\n",
				sections[i].header.Name,
				sections[i].header.VirtualSize,
				sections[i].header.VirtualAddress,
				sections[i].header.SizeOfRawData,
				sections[i].header.PointerToRawData,
				sections[i].header.Characteristics);
		}

		for (int i = 0; i < peHdr.NumberOfSections; ++i) {
			if (!sections[i].Load(fModule)) {
				return false;
			}
		}

		return true;
	}

	FloatingPE::FloatingPE(const wchar_t *moduleName) {
		FILE *fModule = nullptr; // = _wfopen_s(moduleName, L"rb");

		if (0 != W_FOPEN(fModule, moduleName, L"rb")) {
			isValid = false;
			return;
		}

		isValid = LoadPE(fModule);
		fclose(fModule);
	}

	FloatingPE::FloatingPE(const char *moduleName) {
		FILE *fModule = nullptr; // = fopen(moduleName, "rb");

		if (0 != FOPEN(fModule, moduleName, "rb")) {
			isValid = false;
			return;
		}

		isValid = LoadPE(fModule);
		fclose(fModule);
	}


	FloatingPE::~FloatingPE() {
		//TODO: regular cleanup
		for (int i = 0; i < peHdr.NumberOfSections; ++i) {
			sections[i].Unload();
		}
	}

	bool FloatingPE::Map(AbstractMapper &mapr, AbstractImporter &impr, DWORD &baseAddr, bool callConstructors) {


		FixImports(impr);


		DWORD maxAddr = 0;
		for (DWORD i = 0; i < sections.size(); ++i) {
			if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
				continue;
			}

			DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFF) & (~0xFFF);
			if (maxSec > maxAddr) {
				maxAddr = maxSec;
			}
		}


		baseAddr = (DWORD)mapr.CreateSection((void *)(baseAddr), maxAddr, PAGE_PROTECTION_READ | PAGE_PROTECTION_WRITE);
		if (0 == baseAddr) {
			return false;
		}


		Relocate(baseAddr);

		//#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
		//#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
		//#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
		static const DWORD pVec[] = {
			0,
			PAGE_PROTECTION_EXECUTE,
			                          PAGE_PROTECTION_READ,
			PAGE_PROTECTION_EXECUTE | PAGE_PROTECTION_READ,
			                                                 PAGE_PROTECTION_WRITE,
			PAGE_PROTECTION_EXECUTE |                        PAGE_PROTECTION_WRITE,
			                          PAGE_PROTECTION_READ | PAGE_PROTECTION_WRITE,
			PAGE_PROTECTION_EXECUTE | PAGE_PROTECTION_READ | PAGE_PROTECTION_WRITE
		};

		for (unsigned int i = 0; i < sections.size(); ++i) {
			if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
				continue;
			}

			if (sections[i].header.SizeOfRawData) {
				if (!mapr.WriteBytes((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].data, sections[i].header.SizeOfRawData)) {
					return false;
				}
			}

			DWORD protect = pVec[sections[i].header.Characteristics >> 29]; // get the three most significant bytes
			if (!mapr.ChangeProtect((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].header.VirtualSize, protect)) {
				return false;
			}

		}

		return true;
	}

	bool PESection::Load(FILE *fModule) {
		data = new unsigned char[header.SizeOfRawData];

		fseek(fModule, header.PointerToRawData, SEEK_SET);
		if (header.SizeOfRawData != fread(data, 1, header.SizeOfRawData, fModule)) {
			dbg_log("read error, in section %s\n", header.Name);
			return false;
		}

		return true;
	}

	void PESection::Unload() {
		if (data) {
			delete[] data;
		}
	}

};

#ifdef DONOTPRINT
#undef dbg_log
#endif

















```

`BinLoader/PE.Loader.h`:

```h
#ifndef _PE_LDR_H_
#define _PE_LDR_H_

#include <vector>

#include "Types.h"
#include "Abstract.Mapper.h"
#include "Abstract.Loader.h"

namespace ldr {
	struct ImageSectionHeader {
		BYTE    Name[8];
		DWORD   VirtualSize;
		DWORD   VirtualAddress;
		DWORD   SizeOfRawData;
		DWORD   PointerToRawData;
		DWORD   PointerToRelocations;
		DWORD   PointerToLinenumbers;
		WORD    NumberOfRelocations;
		WORD    NumberOfLinenumbers;
		DWORD   Characteristics;
	};

	struct ImageDosHeader {  // DOS .EXE header
		USHORT e_magic;         // Magic number
		USHORT e_cblp;          // Bytes on last page of file
		USHORT e_cp;            // Pages in file
		USHORT e_crlc;          // Relocations
		USHORT e_cparhdr;       // Size of header in paragraphs
		USHORT e_minalloc;      // Minimum extra paragraphs needed
		USHORT e_maxalloc;      // Maximum extra paragraphs needed
		USHORT e_ss;            // Initial (relative) SS value
		USHORT e_sp;            // Initial SP value
		USHORT e_csum;          // Checksum
		USHORT e_ip;            // Initial IP value
		USHORT e_cs;            // Initial (relative) CS value
		USHORT e_lfarlc;        // File address of relocation table
		USHORT e_ovno;          // Overlay number
		USHORT e_res[4];        // Reserved words
		USHORT e_oemid;         // OEM identifier (for e_oeminfo)
		USHORT e_oeminfo;       // OEM information; e_oemid specific
		USHORT e_res2[10];      // Reserved words
		LONG   e_lfanew;        // File address of new exe header
	};

	struct ImagePeHeader {
		DWORD   PeSignature;
		WORD    Machine;
		WORD    NumberOfSections;
		DWORD   TimeDateStamp;
		DWORD   PointerToSymbolTable;
		DWORD   NumberOfSymbols;
		WORD    SizeOfOptionalHeader;
		WORD    Characteristics;
	};

	struct ImageDataDirectory {
		DWORD   VirtualAddress;
		DWORD   Size;
	};

#pragma pack (push, 1)
	struct ImageOptionalHeader {
		struct {
			WORD    Magic;
			BYTE    MajorLinkerVersion;
			BYTE    MinorLinkerVersion;
			DWORD   SizeOfCode;
			DWORD   SizeOfInitializedData;
			DWORD   SizeOfUninitializedData;
			DWORD   AddressOfEntryPoint;
			DWORD   BaseOfCode;
		} c;

		union {
			struct {
				DWORD   BaseOfData;
				DWORD   ImageBase;
				DWORD   SectionAlignment;
				DWORD   FileAlignment;
				WORD    MajorOperatingSystemVersion;
				WORD    MinorOperatingSystemVersion;
				WORD    MajorImageVersion;
				WORD    MinorImageVersion;
				WORD    MajorSubsystemVersion;
				WORD    MinorSubsystemVersion;
				DWORD   Win32VersionValue;
				DWORD   SizeOfImage;
				DWORD   SizeOfHeaders;
				DWORD   CheckSum;
				WORD    Subsystem;
				WORD    DllCharacteristics;
				DWORD   SizeOfStackReserve;
				DWORD   SizeOfStackCommit;
				DWORD   SizeOfHeapReserve;
				DWORD   SizeOfHeapCommit;
				DWORD   LoaderFlags;
				DWORD   NumberOfRvaAndSizes;
				ImageDataDirectory DataDirectory[16];
			} w32;

			struct {
				QWORD   ImageBase;
				DWORD   SectionAlignment;
				DWORD   FileAlignment;
				WORD    MajorOperatingSystemVersion;
				WORD    MinorOperatingSystemVersion;
				WORD    MajorImageVersion;
				WORD    MinorImageVersion;
				WORD    MajorSubsystemVersion;
				WORD    MinorSubsystemVersion;
				DWORD   Win32VersionValue;
				DWORD   SizeOfImage;
				DWORD   SizeOfHeaders;
				DWORD   CheckSum;
				WORD    Subsystem;
				WORD    DllCharacteristics;
				QWORD   SizeOfStackReserve;
				QWORD   SizeOfStackCommit;
				QWORD   SizeOfHeapReserve;
				QWORD   SizeOfHeapCommit;
				DWORD   LoaderFlags;
				DWORD   NumberOfRvaAndSizes;
				ImageDataDirectory DataDirectory[16];
			} w64;
		};
	};
#pragma pack (pop)

	class PESection {
	public:
		ImageSectionHeader header;
		unsigned char *data;

		bool Load(FILE *fModule);
		void Unload();
	};

	//typedef void (*ExportVerb)(const char *funcName, const DWORD ord, const DWORD rva, const unsigned char *body);

	class FloatingPE : public AbstractBinary {
	private:
		bool isValid;

		ImageDosHeader dosHdr;
		ImagePeHeader peHdr;
		ImageOptionalHeader optHdr;

		std::vector<PESection> sections;

		void *RVA(DWORD rva) const;
		bool LoadPE(FILE *fModule);

	public:
		static bool CanLoad(FILE *fMod);

		FloatingPE(const char *moduleName);
		FloatingPE(const wchar_t *moduleName);
		~FloatingPE();

		bool Relocate(DWORD newAddr);
		bool FixImports(AbstractImporter &impr);

		bool GetExport(const char *funcName, DWORD &funcRVA) const;
		void ForAllExports(std::function<void(const char *, const DWORD, const char*, const DWORD, const unsigned char *)> verb) const;
		DWORD GetRequiredSize() const;
		DWORD GetSectionCount() const;
		const PESection *GetSection(DWORD dwIdx) const;

		virtual bool Map(AbstractMapper &mapr, AbstractImporter &impr, DWORD &baseAddr, bool callConstructors = false);

		virtual bool IsValid() const {
			return isValid;
		}
	};
}; //namespace ldr

#endif

```

`BinLoader/Shm.Mapper.cpp`:

```cpp
#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__)
#include <stdlib.h>
#include <sys/mman.h>
#include <string.h>
#include <dlfcn.h>
#endif

#include "Shm.Mapper.h"

// WARNING: DO NOT USE ON WINDOWS, YET!

namespace ldr {
#ifdef _WIN32

	// virtual memory functions
	static const DWORD PageProtections[8] = {
		PAGE_NOACCESS,				// 0 ---
		PAGE_EXECUTE,				// 1 --X
		PAGE_READWRITE,				// 2 -W- (specified as RW)
		PAGE_EXECUTE_READWRITE,		// 3 -WX (specified as RWX)
		PAGE_READONLY,				// 4 R--
		PAGE_EXECUTE_READ,			// 5 R-X
		PAGE_READWRITE,				// 6 RW-
		PAGE_EXECUTE_READWRITE		// 7 RWX
	};
#define VIRTUAL_ALLOC(addr, size, protect, fd, offset) VirtualAlloc((addr), (size), MEM_RESERVE | MEM_COMMIT, (protect))
#define VIRTUAL_PROTECT(addr, size, newProtect, oldProtect) (TRUE == VirtualProtect((addr), (size), (newProtect), &(oldProtect)))

#elif defined(__linux__)
	static const DWORD PageProtections[8] = {
		PROT_NONE,							// 0 ---
		PROT_EXEC,							// 1 --X
		PROT_WRITE,							// 2 -W-
		PROT_EXEC | PROT_WRITE,				// 3 -WX
		PROT_READ,							// 4 R--
		PROT_EXEC | PROT_READ,				// 5 R-X
		PROT_WRITE | PROT_READ,				// 6 RW-
		PROT_EXEC | PROT_WRITE | PROT_READ,	// 7 RWX
	};
	// virtual memory functions
#define VIRTUAL_ALLOC(addr, size, protect, fd, offset) ({ int flags = ((fd) < 0) ? MAP_SHARED | MAP_ANONYMOUS : MAP_SHARED; \
		addr = mmap(addr, (size), (protect), flags, (fd), (offset)); addr; })
#define VIRTUAL_PROTECT(addr, size, newProtect, oldProtect) (0 == mprotect((addr), (size), (newProtect)))

#endif

	ShmMapper::ShmMapper(int shmFd, SIZE_T offset) {
		this->shmFd = shmFd;
		this->offset = offset;
	}

	void *ShmMapper::CreateSection(void *lpAddress, SIZE_T dwSize, DWORD flProtect) {
		return VIRTUAL_ALLOC(lpAddress, dwSize, PageProtections[flProtect], shmFd, offset);
	}

	bool ShmMapper::ChangeProtect(void *lpAddress, SIZE_T dwSize, DWORD flProtect) {
		DWORD oldProtect;
		return VIRTUAL_PROTECT(lpAddress, dwSize, PageProtections[flProtect], oldProtect);
	}

	bool ShmMapper::WriteBytes(void *lpAddress, void *lpBuffer, SIZE_T nSize) {
		memcpy(lpAddress, lpBuffer, nSize);
		return true;
	}
};

```

`BinLoader/Shm.Mapper.h`:

```h
#ifndef _SHM_MAPPER_H_
#define _SHM_MAPPER_H_

//#include <stdlib.h> //size_t
#include "Abstract.Mapper.h"

namespace ldr {
	class ShmMapper : public AbstractMapper {
	private:
		int shmFd;
		SIZE_T offset;

	public:
		ShmMapper(int shmFd = -1, SIZE_T offset = 0);
		virtual void *CreateSection(void *lpAddress, SIZE_T dwSize, DWORD flProtect);
		virtual bool ChangeProtect(void *lpAddress, SIZE_T dwSize, DWORD flProtect);
		virtual bool WriteBytes(void *lpAddress, void *lpBuffer, SIZE_T nSize);
	};
};

#endif

```

`BinLoader/Types.h`:

```h
#ifndef _TYPES_H_
#define _TYPES_H_

namespace ldr {
	typedef unsigned short USHORT;
	typedef long LONG;

	typedef unsigned char BYTE;
	typedef unsigned short WORD;
	typedef unsigned long DWORD;
	typedef unsigned long long QWORD;

	// TODO: Make arch aware size_t
	typedef unsigned long SIZE_T;
}; // namespace ldr

#endif

```

`BinLoader/Unified.Loader.cpp`:

```cpp
#include "Abstract.Loader.h"

#include "Common.h"

#include "ELF.Loader.h"
#include "PE.Loader.h"

namespace ldr {

	template <typename NT> AbstractBinary *LoadBinary(NT fileName, FILE *file) {
		if (FloatingPE::CanLoad(file)) {
			return new FloatingPE(fileName);
		}

		if (FloatingELF32::CanLoad(file)) {
			return new FloatingELF32(fileName);
		}

		return nullptr;
	}

	AbstractBinary *LoadBinary(const char *module) {
		FILE *fMod;
		char path[MAX_PATH_NAME];
		solve_path(module, path);

		if (FOPEN(fMod, path, "rt"))
			return nullptr;

		AbstractBinary *bin = LoadBinary<const char *>(path, fMod);

		fclose(fMod);

		return bin;
	}


	AbstractBinary *LoadBinary(const wchar_t * module) {
		FILE *fMod;
		wchar_t path[MAX_PATH_NAME];
		solve_path(module, path);

		if (W_FOPEN(fMod, path, L"rt"))
			return nullptr;
		AbstractBinary *bin = LoadBinary<const wchar_t *>(path, fMod);

		fclose(fMod);

		return bin;
	}
}

```

`BinLoader/__ELF.Loader.cpp`:

```cpp
#include "Common.h"
#include "ELF.Loader.h"

#include <string.h>

//#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#else
#define dbg_log(fmt,...) printf(fmt, ##__VA_ARGS__)
#endif

#define SHT_NULL	 0
#define SHT_PROGBITS 1
#define SHT_SYMTAB	 2
#define SHT_STRTAB	 3
#define SHT_RELA	 4
#define SHT_HASH	 5
#define SHT_DYNAMIC	 6
#define SHT_NOTE	 7
#define SHT_NOBITS	 8
#define SHT_REL		 9
#define SHT_SHLIB	 10
#define SHT_DYNSYM	 11
#define SHT_GNU_HASH 0x6FFFFFF6
#define SHT_VERNEED	 0x6FFFFFFE
#define SHT_VERSYM	 0x6FFFFFFF
#define SHT_LOPROC   0x70000000
#define SHT_HIPROC   0x7fffffff
#define SHT_LOUSER   0x80000000
#define SHT_HIUSER   0xffffffff

#define SHF_WRITE		0x1
#define SHF_ALLOC		0x2
#define SHF_EXECINSTR	0x4
#define SHF_MASKPROC	0xf0000000

namespace ldr {
	ELFSection::ELFSection() {
		data = nullptr;
		versions = verneed = nullptr;
	}

	bool ELFSection::Load(FILE *fModule) {
		if (SHT_NOBITS == header.sh_type) {
			return true;
		}

		data = new unsigned char[header.sh_size];

		fseek(fModule, header.sh_offset, SEEK_SET);
		if (header.sh_size != fread(data, 1, header.sh_size, fModule)) {
			dbg_log("read error, in section %s\n", (char *)header.sh_name);
			return false;
		}

		return true;
	}

	void ELFSection::Unload() {
		delete data;
	}

#define ELF_MAGIC 0x464C457F

#define ELFCLASSNONE		0
#define ELFCLASS32			1
#define ELFCLASS64			2

#define ELFDATANONE			0
#define ELFDATA2LSB			1
#define ELFDATA2MSB			2

#define ET_NONE				0
#define ET_REL				1
#define ET_EXEC				2
#define ET_DYN				3
#define ET_CORE				4
#define ET_LOPROC			0xff00
#define ET_HIPROC			0xffff

#define EM_NONE				0
#define EM_M32				1
#define EM_SPARC			2
#define EM_386				3
#define EM_68K				4
#define EM_88K				5
#define EM_860				7
#define EM_MIPS				8 

#define EV_NONE				0
#define EV_CURRENT			1

#define PT_NULL				0
#define PT_LOAD				1
#define PT_DYNAMIC			2
#define PT_INTERP			3
#define PT_NOTE				4
#define PT_SHLIB			5
#define PT_PHDR				6
#define PT_GNU_EH_FRAME		0x6474E550
#define PT_GNU_STACK		0x6474E551
#define PT_GNU_RELRO		0x6474E552
#define PT_LOPROC			0x70000000
#define PT_HIPROC			0x7fffffff

#define PF_R            0x4
#define PF_W            0x2
#define PF_X            0x1

#define ELF32RSYM(i) ((i)>>8)
#define ELF32RTYPE(i) ((unsigned char)(i))
#define ELF32RINFO(s,t) (((s)<<8)+(unsigned char)(t)

#define R_386_NONE			0 
#define R_386_32			1
#define R_386_PC32			2
#define R_386_GOT32			3
#define R_386_PLT32			4
#define R_386_COPY			5
#define R_386_GLOB_DAT		6
#define R_386_JMP_SLOT		7
#define R_386_RELATIVE		8
#define R_386_GOTOFF		9
#define R_386_GOTPC			10

#define DT_NULL				0   
#define DT_NEEDED			1   
#define DT_PLTRELSZ			2   
#define DT_PLTGOT			3   
#define DT_HASH				4   
#define DT_STRTAB			5   
#define DT_SYMTAB			6   
#define DT_RELA				7   
#define DT_RELASZ			8   
#define DT_RELAENT			9   
#define DT_STRSZ			10   
#define DT_SYMENT			11   
#define DT_INIT				12   
#define DT_FINI				13   
#define DT_SONAME			14   
#define DT_RPATH			15   
#define DT_SYMBOLIC			16
#define DT_REL				17 
#define DT_RELSZ			18
#define DT_RELENT			19
#define DT_PLTREL			20
#define DT_DEBUG			21
#define DT_TEXTREL			22
#define DT_JMPREL			23
#define DT_LOPROC			0x70000000
#define DT_HIPROC			0x7fffffff

#define STB_LOCAL			0
#define STB_GLOBAL			1
#define STB_WEAK			2
#define STB_LOPROC			13
#define STB_HIPROC			15

#define SHN_UNDEF 0
#define SHN_LORESERVE 0xff00
#define SHN_LOPROC 0xff00
#define SHN_HIPROC 0xff1f
#define SHN_ABS 0xfff1
#define SHN_COMMON 0xfff2
#define SHN_HIRESERVE 0xffff

#define ELF32STBIND(i) ((i)>>4)
#define ELF32STTYPE(i) ((i)&0xf

	struct Elf32Rel{
		DWORD r_offset;
		DWORD r_info;
	};

	struct Elf32Rela {
		DWORD r_offset;
		DWORD r_info;
		LONG r_addend;
	};

	struct Elf32Sym {
		DWORD st_name;
		DWORD st_value;
		DWORD st_size;
		unsigned char st_info;
		unsigned char st_other;
		WORD st_shndx;
	};

	struct Elf32Dyn {
		LONG d_tag;
		DWORD d_un;
	};

	struct ELF32VerNeed {
		WORD vn_version;
		WORD vn_cnt;
		DWORD vn_file;
		DWORD vn_aux;
		DWORD vn_next;
	};

	struct Elf32VerAux {
		DWORD vna_hash;
		WORD vna_flags;
		WORD vna_other;
		DWORD vna_name;
		DWORD vna_next;
	};

	void *FloatingELF32::RVA(DWORD rva) const {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if ((i->header.sh_addr <= rva) && (i->header.sh_addr + i->header.sh_size > rva)) {
				return &i->data[rva - i->header.sh_addr];
			}
		}
		return nullptr;
	}

	bool FloatingELF32::CanLoad(FILE *fMod) {
		ElfIdent ident;

		fseek(fMod, 0, SEEK_SET);

		if (1 != fread(&ident, sizeof(ident), 1, fMod)) {
			return false;
		}

		if (ELF_MAGIC != ident.e_magic) {
			return false;
		}

		if ((ELFCLASS32 != ident.e_class) || (ELFDATA2LSB != ident.e_data)) {
			return false;
		}

		// the file seems to be a falid ELF32 module
		return true;
	}

	bool FloatingELF32::LoadELF(FILE *fModule) {
		if (NULL == fModule) {
			dbg_log("File open error!\n");
			return false;
		}

		if (1 != fread(&ident, sizeof(ident), 1, fModule)) {
			dbg_log("Read error\n");
			return false;
		}

		if (ELF_MAGIC != ident.e_magic) {
			dbg_log("ident.e_magic not valid %08x != %08x\n", ELF_MAGIC, ident.e_magic);
			return false;
		}

		if ((ELFCLASS32 != ident.e_class) || (ELFDATA2LSB != ident.e_data)) {
			dbg_log("ident.e_class or ident.e_data not supported\n");
			return false;
		}

		if (1 != fread(&header, sizeof(header), 1, fModule)) {
			dbg_log("Read error\n");
			return false;
		}

		if (EM_386 != header.e_machine) {
			dbg_log("header.e_machine not supported\n");
			return false;
		}

		//dbg_log("Base: %08x\n", header.)

		moduleBase = 0xFFFFF000;
		pHeaders.resize(header.e_phnum);
		fseek(fModule, header.e_phoff, SEEK_SET);
		dbg_log("Type     Offset   V.Addr   P.Addr   F.Size   M.Size   Flags    Align\n");
		for (int i = 0; i < header.e_phnum; ++i) {
			if (1 != fread(&pHeaders[i].header, sizeof(pHeaders[i].header), 1, fModule)) {
				dbg_log("read error\n");
				return false;
			}

			DWORD tBA = 0xFFFFF000;
			switch (pHeaders[i].header.p_type) {
				case PT_LOAD:
					tBA = pHeaders[i].header.p_vaddr & ~(pHeaders[i].header.p_align - 1);
					break;
			};
			if (tBA < moduleBase) {
				moduleBase = tBA;
			}
		

			dbg_log("%08x %08x %08x %08x %08x %08x %08x %08x\n",
				pHeaders[i].header.p_type,
				pHeaders[i].header.p_offset,
				pHeaders[i].header.p_vaddr,
				pHeaders[i].header.p_paddr,
				pHeaders[i].header.p_filesz,
				pHeaders[i].header.p_memsz,
				pHeaders[i].header.p_flags,
				pHeaders[i].header.p_align
			);
		}

		sections.resize(header.e_shnum);
		fseek(fModule, header.e_shoff, SEEK_SET);
		for (int i = 0; i < header.e_shnum; ++i) {
			if (1 != fread(&sections[i].header, sizeof(sections[i].header), 1, fModule)) {
				dbg_log("read error\n");
				return false;
			}

			if (SHT_STRTAB == sections[i].header.sh_type) {
				names = &sections[i];
			}
		}

		dbg_log("Here!\n");
		for (int i = 0; i < header.e_shnum; ++i) {
			if (!sections[i].Load(fModule)) {
				return false;
			}

			switch (sections[i].header.sh_type) {
				case SHT_DYNAMIC :
					dbg_log("Dynamic section\n");
					ParseDynamic(sections[i]);
					break;
				case SHT_VERSYM :
					dbg_log("Versym section\n");
					sections[sections[i].header.sh_link].versions = &sections[i];
					break;
				case SHT_VERNEED :
					dbg_log("Verneed section\n");
					sections[sections[i].header.sh_info].verneed = &sections[i];
					ParseVerNeed(sections[i]);
					break;
			}
		}

		dbg_log("\nName                     Type     Flags    Addr     Offset   Size     Link     Info     AddrAlgn EntSize\n");
		for (int i = 0; i < header.e_shnum; ++i) {
			dbg_log("%24s %08x %08x %08x %08x %08x %08x %08x %08x %08x\n",
				&sections[header.e_shstrndx].data[sections[i].header.sh_name],
				sections[i].header.sh_type,
				sections[i].header.sh_flags,
				sections[i].header.sh_addr,
				sections[i].header.sh_offset,
				sections[i].header.sh_size,
				sections[i].header.sh_link,
				sections[i].header.sh_info,
				sections[i].header.sh_addralign,
				sections[i].header.sh_entsize
			);
		}

		return true;
	}

	FloatingELF32::FloatingELF32(const char *moduleName) {
		FILE *fModule = nullptr;
		
		if (0 != FOPEN(fModule, moduleName, "rb")) {
			isValid = false;
			return;
		}

		isValid = LoadELF(fModule);
		fclose(fModule);
	}

	FloatingELF32::FloatingELF32(const wchar_t *moduleName) {
		FILE *fModule = nullptr;
		
		if (0 != W_FOPEN(fModule, moduleName, L"rb")) {
			isValid = false;
			return;
		}

		isValid = LoadELF(fModule);
		fclose(fModule);
	}

	FloatingELF32::~FloatingELF32() {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			i->Unload();
		}
	}

	DWORD FloatingELF32::Import(AbstractImporter &impr, const char *name) {
		DWORD ret;
		for (auto l = libraries.begin(); l != libraries.end(); ++l) {
			ret = impr.FindImport(l->c_str(), name);

			if (IMPORT_NOT_FOUND != ret) {
				return ret;
			}
		}

		return 0;
	}

	bool FloatingELF32::FixImports(AbstractImporter &impr) {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if ((SHT_DYNSYM == i->header.sh_type) || (SHT_SYMTAB == i->header.sh_type)) {
				Elf32Sym *symb = (Elf32Sym *)i->data;
				DWORD count = i->header.sh_size / sizeof(*symb);
				for (DWORD j = 0; j < count; ++j) {
					if ((STB_GLOBAL == ELF32STBIND(symb[j].st_info)) && (SHN_UNDEF == symb[j].st_shndx)) {
						dbg_log(
							"%s",
							(char *)&sections[i->header.sh_link].data[symb[j].st_name]
						);

						if (nullptr != i->versions) {
							ELFSymbolVersioning *vers = i->verneed->idxSVers[((WORD *)i->versions->data)[j]];
							if (nullptr != vers) {
								dbg_log(
									"@@%s",
									vers->version.c_str()
								);

								symb->st_value = impr.FindImport(vers->module.c_str(), (char *)&sections[i->header.sh_link].data[symb[j].st_name], vers->version.c_str());
							} else {
								symb->st_value = Import(impr, (char *)&sections[i->header.sh_link].data[symb[j].st_name]);
							}
						} else {
							symb->st_value = Import(impr, (char *)&sections[i->header.sh_link].data[symb[j].st_name]);
						}
						dbg_log("\n");
					}
				}
			}
		}
		
		return false;
	}

	bool FloatingELF32::PrintSymbols() const {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if ((SHT_DYNSYM == i->header.sh_type) || (SHT_SYMTAB == i->header.sh_type)) {
				Elf32Sym *symb = (Elf32Sym *)i->data;
				DWORD count = i->header.sh_size / sizeof(*symb);
				for (DWORD j = 0; j < count; ++j) {
					if ((STB_GLOBAL == ELF32STBIND(symb[j].st_info)) && (SHN_UNDEF == symb[j].st_shndx)) {
						dbg_log(
							"%s",
							(char *)&sections[i->header.sh_link].data[symb[j].st_name]
						);

						if (nullptr != i->versions) {
							ELFSymbolVersioning *vers = i->verneed->idxSVers[((WORD *)i->versions->data)[j]];
							if (nullptr != vers) {
								dbg_log(
									"@@%s",
									vers->version.c_str()
								);
							}
						}
						dbg_log("\n");
					}
				}
			}
		}

		return true;
	}

	bool FloatingELF32::RelocateSection(void *r, DWORD count, const ELFSection &symb, const ELFSection &names, DWORD offset) {
		Elf32Rel *rels = (Elf32Rel *)r;
			for (DWORD i = 0; i < count; ++i) {
			dbg_log("Off: 0x%08x, Sym: 0x%06x, Typ: 0x%02x ", rels[i].r_offset, ELF32RSYM(rels[i].r_info), ELF32RTYPE(rels[i].r_info));
			DWORD *addr = (DWORD *)RVA(rels[i].r_offset);
			DWORD oldAddr;
			Elf32Sym *s;

			switch (ELF32RTYPE(rels[i].r_info)) {
				case R_386_NONE :
					dbg_log("$ none");
					break;
				case R_386_32 :
					s = &((Elf32Sym *)symb.data)[ELF32RSYM(rels[i].r_info)];
					oldAddr = *addr;
					*addr = offset + s->st_value;
					dbg_log("$ 0x%08x => 0x%08x; %s", oldAddr, *addr, (char *)&names.data[s->st_name]);
					//set *addr
					break;
				case R_386_PC32:
					s = &((Elf32Sym *)symb.data)[ELF32RSYM(rels[i].r_info)];
					oldAddr = *addr;
					dbg_log("$ %s", (char *)&names.data[s->st_name]);
					//set *addr
					break;
				case R_386_RELATIVE :
					oldAddr = *addr;
					*addr += offset;
					dbg_log("$ 0x%08x => 0x%08x", oldAddr, *addr);
					break;
				case R_386_GLOB_DAT :
					s = &((Elf32Sym *)symb.data)[ELF32RSYM(rels[i].r_info)];
					oldAddr = *addr;
					*addr = s->st_value;
					dbg_log("$ 0x%08x => 0x%08x; %s", oldAddr, *addr, (char *)&names.data[s->st_name]);
					//set *addr
					break;
			};

			dbg_log("\n");
		}
		return true;
	}

	bool FloatingELF32::Relocate(DWORD newBase) {
		DWORD offset = newBase - moduleBase;

		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if (SHT_REL == i->header.sh_type) {
				if (rel) {
					DWORD symbols = i->header.sh_link;
					DWORD symNames = sections[symbols].header.sh_link;
					RelocateSection((Elf32Rel *)rel, relSz / relEnt, sections[symbols], sections[symNames], offset);
				}
			}
		}

		// Do the same for rela sections

		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if (SHF_ALLOC & i->header.sh_flags) {
				i->header.sh_addr += offset;
			}
		}

		for (auto i = pHeaders.begin(); i != pHeaders.end(); ++i) {
			if (PT_LOAD == i->header.p_type) {
				i->header.p_vaddr += offset;
			}
		}

		moduleBase += offset;
		return true;
	}

	void FloatingELF32::MapSections(AbstractMapper &mapr, DWORD startSeg, DWORD stopSeg) {
		for (auto i = sections.begin(); i != sections.end(); ++i) {
			if (SHF_ALLOC & i->header.sh_flags) {
				DWORD cpStart = i->header.sh_addr;
				if (cpStart < startSeg) {
					cpStart = startSeg;
				}

				DWORD cpStop = i->header.sh_addr + i->header.sh_size;
				if (cpStop > stopSeg) {
					cpStop = stopSeg;
				}

				if (cpStart < cpStop) { // we need to do some copying
					if (SHT_NOBITS == i->header.sh_type) {
						unsigned char *buff = new unsigned char[cpStop - cpStart];
						memset(buff, 0, cpStop - cpStart);
						mapr.WriteBytes((void *)(cpStart), buff, cpStop - cpStart);
						delete buff;
					}
					else {
						mapr.WriteBytes((void *)(cpStart), &i->data[cpStart - i->header.sh_addr], cpStop - cpStart);
					}
					dbg_log("%s[%d:%d] ", &sections[header.e_shstrndx].data[i->header.sh_name], cpStart - i->header.sh_addr, cpStop - i->header.sh_addr);
				}
			}
		}

		dbg_log("\n");
	}

	bool FloatingELF32::ParseVerNeed(ELFSection &s) {
		DWORD maxVer = 0;
		s.sVers.clear();
		for (unsigned char *ptr = s.data; ptr < s.data + s.header.sh_size; ) {
			ELF32VerNeed *vn = (ELF32VerNeed *)ptr;
			ptr += sizeof(*vn);

			dbg_log("%s with %d entries\n", &sections[s.header.sh_link].data[vn->vn_file], vn->vn_cnt);

			for (DWORD j = 0; j < vn->vn_cnt; ++j) {
				Elf32VerAux *va = (Elf32VerAux *)ptr;
				ptr += sizeof(*va);

				dbg_log("\t %s -> %d\n", &sections[s.header.sh_link].data[va->vna_name], va->vna_other);
				if (maxVer < va->vna_other) {
					maxVer = va->vna_other;
				}
				s.sVers.push_back(ELFSymbolVersioning(va->vna_other, (char *)&sections[s.header.sh_link].data[va->vna_name], (char *)&sections[s.header.sh_link].data[vn->vn_file]));
			}
		}

		s.idxSVers.resize(maxVer + 1);
		for (DWORD i = 0; i <= maxVer; ++i) {
			s.idxSVers[i] = nullptr;
		}

		for (auto i = s.sVers.begin(); i != s.sVers.end(); ++i) {
			s.idxSVers[i->index] = &(*i);
		}
		return true;
	}

	bool FloatingELF32::ParseDynamic(const ELFSection &s) {
		Elf32Dyn *dyns = (Elf32Dyn *)s.data;
		DWORD cnt = s.header.sh_size / sizeof(dyns[0]);

		for (DWORD j = 0; j < cnt; ++j) {
			DWORD value = dyns[j].d_un;
			DWORD *rValue = nullptr;
			switch (dyns[j].d_tag) {
				case DT_PLTGOT :
				case DT_HASH :
				case DT_STRTAB :
				case DT_SYMTAB :
				case DT_RELA :
				case DT_INIT :
				case DT_FINI :
				case DT_REL :
				case DT_DEBUG :
				case DT_JMPREL :
					rValue = (DWORD *)RVA(value);
			}

			switch (dyns[j].d_tag) {
				case DT_NEEDED :
					dbg_log("Need library %s\n", &sections[s.header.sh_link].data[value]);
					libraries.push_back((char *)&sections[s.header.sh_link].data[value]);
					break;
				case DT_REL :
					rel = rValue;
					break;
				case DT_RELA :
					rela = rValue;
					break;
				case DT_RELSZ :
					relSz = value;
					break;
				case DT_RELASZ :
					relaSz = value;
					break;
				case DT_RELENT :
					relEnt = value;
					break;
				case DT_RELAENT :
					relaEnt = value;
					break;
				case DT_SONAME :
					dbg_log("So name %s\n", &sections[s.header.sh_link].data[value]);
					break;
			}
		}
		
		return true;
	}

	bool FloatingELF32::Map(AbstractMapper &mapr, AbstractImporter &impr, DWORD &baseAddr) {
		DWORD oNA = 0;

		for (auto i = pHeaders.begin(); i != pHeaders.end(); ++i) {
			DWORD tNA = 0;
			switch (i->header.p_type) {
				case PT_LOAD :
					tNA = (i->header.p_vaddr + i->header.p_memsz + i->header.p_align - 1) & ~(i->header.p_align - 1);
					break;
			}

			if (tNA > oNA) {
				oNA = tNA;
			}
		}

		dbg_log("Base: 0x%08x; Size: 0x%08x\n", moduleBase, oNA - moduleBase);

		FixImports(impr);

		baseAddr = (DWORD)mapr.CreateSection((void *)(baseAddr), oNA - moduleBase, PAGE_PROTECTION_READ | PAGE_PROTECTION_WRITE);
		if (0 == baseAddr) {
			return false;
		}

		Relocate(baseAddr);

		static const DWORD prot[] = {
			0, 1, 2, 3, 4, 5, 6, 7
		};

		for (auto i = pHeaders.begin(); i != pHeaders.end(); ++i) {
			DWORD startSegment, stopSegment;
			bool loaded = false;
			switch (i->header.p_type) {
				case PT_LOAD:
					startSegment = i->header.p_vaddr & ~(i->header.p_align - 1);
					stopSegment = (i->header.p_vaddr + i->header.p_memsz + i->header.p_align - 1) & ~(i->header.p_align - 1);
					MapSections(mapr, startSegment, stopSegment);
					loaded = true;
					break;
			}

			if (loaded) {
				mapr.ChangeProtect((void *)(i->header.p_vaddr), stopSegment - startSegment, prot[i->header.p_flags]);
			}
		}
		return false;
	}

}; //namespace ldr
```

`BinLoader/tmp/Tester.cpp`:

```cpp
/*
 * Tester.cpp
 *
 *  Created on: Jan 3, 2012
 *      Author: sorin
 */

#include <stdio.h>
#include <iostream>
#include <dlfcn.h>
#include <string.h>
#include "CLoad.h"
#include <elf.h>

#define MAX_STRING      80

using namespace std;

void custom_invoke( char *lib, char *method, float argument ){
	MyLib* result = myLibLoad(lib);
	float (*func)(float);

	func = (float (*)(float))getFunctPointer(result, method);
	dout << "found it at " << (long)func << endl;
	printf("  %f\n", (*func)(argument) );

}

void invoke_method( char *lib, char *method, float argument )
{
  void *dl_handle;
  float (*func)(float);
  char *error;

  /* Open the shared object*/
  dl_handle = dlopen( lib, RTLD_LAZY );
  if (!dl_handle) {
    printf( "!!! %s\n", dlerror() );
    return;
  }

  /* Resolve the symbol (method) from the object*/
  func = (float (*)(float))dlsym( dl_handle, method );
  error = dlerror();
  if (error != NULL) {
    printf( "!!! %s\n", error );
    return;
  }

  /* Call the resolved method and print the result*/
  printf("  %f\n", (*func)(argument) );

  /* Close the object*/
  dlclose( dl_handle );

  return;
}

int main( int argc, char *argv[] )
{
  char line[MAX_STRING+1];
  char lib[MAX_STRING+1];
  char method[MAX_STRING+1];
  float argument;
  int custom;

  while (1) {

    printf("> ");

    line[0]=0;
    fgets( line, MAX_STRING, stdin);

    if (!strncmp(line, "bye", 3)) break;

    sscanf( line, "%s %s %f %d", lib, method, &argument, &custom);

    if (!custom)
    	invoke_method( lib, method, argument );
    else
    	custom_invoke( lib, method, argument );
  }

}



```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.8)
set(CMAKE_SYSTEM_NAME Linux)
project(RIVER C CXX ASM)

set(CMAKE_ASM_CREATE_SHARED_LIBRARY ${CMAKE_C_CREATE_SHARED_LIBRARY})
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_INSTALL_PREFIX}/bin)

set(CMAKE_POSITION_INDEPENDENT_CODE false)

if(NOT CMAKE_BUILD_TYPE)
	set(CMAKE_BUILD_TYPE Release)
endif()

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O0")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS}")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS}")

# build targets
add_subdirectory(CommonCrossPlatform)
add_subdirectory(BinLoader)
add_subdirectory(VirtualMemory)
add_subdirectory(wrapper.setup)
add_subdirectory(revtracer-wrapper)
add_subdirectory(revtracer)
add_subdirectory(ipclib)
add_subdirectory(Execution)
add_subdirectory(loader)
add_subdirectory(SymbolicEnvironment)
add_subdirectory(benchmarking-payload)

```

`CommonCrossPlatform/BasicTypes.h`:

```h
#ifndef _BASIC_TYPES_H_
#define _BASIC_TYPES_H_

/** Use this header in binaries that have no dependencies */

namespace nodep {
	/* Define NULL pointer value */
#ifndef NULL
	#ifdef __cplusplus
		#define NULL    0
	#else  /* __cplusplus */
		#define NULL    ((void *)0)
	#endif  /* __cplusplus */
#endif  /* NULL */

#if !defined(_W64)
	#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86) || defined(_ARM_) || defined(_M_ARM)) && _MSC_VER >= 1300
		#define _W64 __w64
	#else
		#define _W64
	#endif
#endif


#if defined(_WIN64)
	typedef __int64 INT_PTR, *PINT_PTR;
	typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

	typedef __int64 LONG_PTR, *PLONG_PTR;
	typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

#define __int3264   __int64

#else
	typedef _W64 int INT_PTR, *PINT_PTR;
	typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

	typedef _W64 long LONG_PTR, *PLONG_PTR;
	typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

#define __int3264   __int32

#endif

	typedef unsigned long ULONG;
	typedef ULONG *PULONG;
	typedef unsigned short USHORT;
	typedef USHORT *PUSHORT;
	typedef unsigned char UCHAR;
	typedef UCHAR *PUCHAR;
	
	typedef long LONG;
	typedef long long LONGLONG;

	typedef unsigned long long QWORD;
	typedef unsigned long DWORD;
	typedef unsigned short WORD;
	typedef unsigned char BYTE;

	/* Windows-like types */
	typedef int BOOL;
	typedef void *HANDLE;
	typedef void *LPVOID;

	typedef ULONG_PTR SIZE_T, *PSIZE_T;

	typedef wchar_t WCHAR;
	typedef WCHAR *PWSTR;

	typedef BYTE  BOOLEAN;
	
	typedef union _LARGE_INTEGER {
		struct {
			DWORD LowPart;
			LONG  HighPart;
		};
		struct {
			DWORD LowPart;
			LONG  HighPart;
		} u;
		LONGLONG QuadPart;
	} LARGE_INTEGER, *PLARGE_INTEGER;

#ifndef FALSE
#define FALSE               0
#endif

#ifndef TRUE
#define TRUE                1
#endif

};

#endif

```

`CommonCrossPlatform/CMakeLists.txt`:

```txt
install(FILES BasicTypes.h Common.h CommonSpecifiers.h
  DESTINATION ${CMAKE_INSTALL_PREFIX}/include/CommonCrossPlatform)

```

`CommonCrossPlatform/Common.h`:

```h
#ifndef _COMMON_UTIL_H
#define _COMMON_UTIL_H

#ifdef _MSC_VER
#define DEBUG_BREAK __asm \
{ __asm int 3 }
#else
#define DEBUG_BREAK asm volatile("int $0x3")
#endif

#ifdef __linux__
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/types.h>
typedef int FILE_T;
typedef pid_t PROCESS_HANDLE;
typedef int MAPPING_HANDLE;
typedef wchar_t WCHAR;
typedef unsigned long ULONG;
typedef void* HANDLE;
typedef int BOOL;

typedef unsigned short USHORT;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;
typedef int64_t LONGLONG;
typedef unsigned long long QWORD;
typedef unsigned int UINT_PTR;
typedef void* LPVOID;
typedef const void* LPCVOID;

typedef union _LARGE_INTEGER {
  struct {
    DWORD LowPart;
    LONG  HighPart;
  };
  struct {
    DWORD LowPart;
    LONG  HighPart;
  } u;
  LONGLONG QuadPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

#define MAX_PAYLOAD_BUF (64 << 10)

#define MAX_PATH 260
#define SEEK_BEGIN_FILE SEEK_SET
#define SEEK_END_FILE SEEK_END
#define TRUE 1
#define FALSE 0

#define VSNPRINTF_S(buf, size, count, format, args) vsnprintf(buf, size, format, args)
#define OPEN_FILE_W(filename) open((filename), O_WRONLY | O_CREAT, 0644)
#define OPEN_FILE_RW(filename) open((filename), O_RDWR | O_CREAT, 0644)
#define FAIL_OPEN_FILE(fd) (0 > (fd))
#define WRITE_FILE(fd, buf, size, written, ret) do { written = write((fd), (buf), (size)); ret = (written >= 0); } while (false)
#define READ_FILE(fd, buf, size, b_read, ret) do { b_read = read((fd), (buf), (size)); ret = (b_read >= 0); } while (false)
#define CLOSE_FILE(fd) close((fd))
#define LSEEK(fd, off, flag) lseek((fd), (off.QuadPart), (flag))
#define FOPEN(res, path, mode) ({ res = fopen((path), (mode)); })
#define SPRINTF(buffer, format, ...) sprintf((buffer), (format), ##__VA_ARGS__)

#define MAP_FILE_RWX(file, size)                                   \
  ({ int fd = open((file), O_RDWR | O_CREAT | O_TRUNC, 0644);                                \
   void *ret = mmap(0, (size), PROT_READ | PROT_WRITE | PROT_EXEC, \
       MAP_SHARED, fd, 0);                                         \
   ret;                                                            \
   })

#include <pthread.h>
typedef pthread_t THREAD_T;
struct event_t {
  pthread_cond_t cond;
  pthread_mutex_t mutex;
  int exited;
};

//TODO clean this. Lots of components require changes
typedef struct event_t EVENT_T;
#define CREATE_VALUE_EVENT(event, value) \
  ({ pthread_cond_init(&((event).cond), nullptr); \
   pthread_mutex_init(&(event).mutex, nullptr); \
   (event).exited = (value); \
   })

#define CREATE_EVENT(event) CREATE_VALUE_EVENT((event), false)

#define SIGNAL_EVENT(event) \
  ({ pthread_mutex_lock(&(event).mutex); \
   (event).exited = !(event).exited; \
   pthread_cond_signal(&(event).cond); \
   pthread_mutex_unlock(&(event).mutex); \
   })

#define WAIT_FOR_SINGLE_OBJECT(event) \
  ({ pthread_mutex_lock(&(event).mutex); \
   int ret = 0; \
   while (!(event).exited) { \
   ret = pthread_cond_wait(&(event).cond, &(event).mutex); \
   } \
   (event).exited = !(event).exited; \
   pthread_mutex_unlock(&(event).mutex); \
   ret == 0; \
   })

#define CREATE_THREAD(tid, func, params, ret) do { ret = pthread_create((&tid), nullptr, (func), (params)); ret = (0 == ret); } while(false)
#define JOIN_THREAD(tid, ret) do { ret = pthread_join(tid, nullptr); ret = (0 == ret); } while (false)

#include <unistd.h>
#define GET_CURRENT_PROC() getpid()

// manual dynamic loading
#include <dlfcn.h>
#include <link.h>
typedef void* LIB_T;
#define GET_LIB_HANDLER(libname) dlopen((libname), RTLD_LAZY)
#define GET_LIB_BASE(lib) ((struct link_map *)(lib))->l_addr
#define CLOSE_LIB(libhandler) dlclose((libhandler))
#define LOAD_PROC(libhandler, szProc) dlsym((libhandler), (szProc))

typedef struct timespec TIME_T;
typedef double TIME_FREQ_T;
typedef double TIME_RES_T;
#define START_COUNTER(starttime, freq) { clock_gettime(CLOCK_REALTIME, &(starttime)); }
#define GET_COUNTER(starttime, endtime, freq, res) { clock_gettime(CLOCK_REALTIME, &(endtime)); \
	res = ((endtime).tv_sec - (starttime).tv_sec) + ((endtime).tv_nsec - (starttime).tv_nsec) / freq; }
#define GET_COUNTER_AGGREGATE(starttime, endtime, freq, res) { clock_gettime(CLOCK_REALTIME, &(endtime)); \
	res += ((endtime).tv_sec - (starttime).tv_sec) + ((endtime).tv_nsec - (starttime).tv_nsec) / freq; }
#define GET_AGGREGATE_RESULT(total, freq, result) { result = total; }
#define GET_FREQ(freq) { (freq) = 1E9; }


#else
#include <Windows.h>
typedef HANDLE FILE_T;
typedef HANDLE THREAD_T;
typedef HANDLE EVENT_T;
typedef HANDLE PROCESS_HANDLE;
typedef HANDLE MAPPING_HANDLE;

#define CREATE_VALUE_EVENT(handle, value) do { handle = CreateEvent(nullptr, false, (value), nullptr); } while (false)
#define CREATE_EVENT(handle) CREATE_VALUE_EVENT((handle), false)
#define SIGNAL_EVENT(handle) SetEvent((handle))
#define WAIT_FOR_SINGLE_OBJECT(handle) (WAIT_OBJECT_0 == WaitForSingleObject((handle), INFINITE))

#define CREATE_THREAD(tid, func, params, ret) do { tid = CreateThread(nullptr, 0, (func), (params), 0, nullptr); ret = (tid != nullptr); } while (false)
#define JOIN_THREAD(tid, ret) do { ret = WaitForSingleObject(tid, INFINITE); ret = (WAIT_FAILED != ret); } while (false)

#define SEEK_BEGIN_FILE FILE_BEGIN
#define SEEK_END_FILE FILE_END

#define VSNPRINTF_S(buf, size, count, format, args) vsnprintf_s(buf, size, count, format, args)
#define OPEN_FILE_W(filename) CreateFileA((filename), GENERIC_WRITE, FILE_SHARE_READ, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr)
#define OPEN_FILE_RW(filename) CreateFileA((filename), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr)
#define FAIL_OPEN_FILE(fd) (INVALID_HANDLE_VALUE == (fd))
#define WRITE_FILE(fd, buf, size, written, ret) do { ret = WriteFile((fd), (buf), (size), &(written), nullptr); } while (false)
#define READ_FILE(fd, buf, size, read, ret) do { ret = ReadFile((fd), (buf), (size), &(read), nullptr); } while (false)
#define CLOSE_FILE(fd) CloseHandle(fd)
#define LSEEK(fd, off, flag) SetFilePointerEx((fd), (off), &(off), (flag))
#define FOPEN(res, path, mode) fopen_s(&(res), (path), (mode))
#define SPRINTF(buffer, format, ...) sprintf_s((buffer), (format), ##__VA_ARGS__)

#define MAP_FILE_RWX(file, size) CreateFileMappingA(INVALID_HANDLE_VALUE, nullptr, PAGE_EXECUTE_READWRITE, 0, (size), (file))

#define GET_CURRENT_PROC() GetCurrentProcess()

// manual dynamic loading
typedef HMODULE LIB_T;
#define GET_LIB_HANDLER(libname) GetModuleHandleW((libname))
#define GET_LIB_BASE(lib) (DWORD)(lib)
#define CLOSE_LIB
#define LOAD_PROC(libhandler, szProc) GetProcAddress((libhandler), (szProc))

typedef LARGE_INTEGER TIME_T;
typedef LARGE_INTEGER TIME_FREQ_T;
typedef double TIME_RES_T;
#define START_COUNTER(starttime, freq) { QueryPerformanceCounter(&(starttime)); }
#define GET_COUNTER_AGGREGATE(starttime, endtime, freq, total) { QueryPerformanceCounter(&(endtime)); \
	total += (endtime).QuadPart - (starttime).QuadPart; }
#define GET_COUNTER(starttime, endtime, freq, total) { QueryPerformanceCounter(&(endtime)); \
	total = 1000.0 * ((endtime).QuadPart - (starttime).QuadPart) / freq.QuadPart; }
#define GET_AGGREGATE_RESULT(total, freq, result) { \
	result = 1000.0 * (total) / (freq).QuadPart; }
#define GET_FREQ(freq) { QueryPerformanceFrequency(&(freq)); }

#endif

#endif

```

`CommonCrossPlatform/CommonSpecifiers.h`:

```h
#ifndef _COMMON_SPECIFIERS_H_
#define _COMMON_SPECIFIERS_H_

#if defined _WIN32 || defined __CYGWIN__
	#ifdef _IMPORT_THIS_API_
		#ifdef _MSC_VER
			#define DLL_PUBLIC __declspec(dllimport)
		#else
			#define DLL_PUBLIC __attribute__ ((dllimport))
		#endif
	#elif defined _EXPORT_THIS_API_
		#ifdef _MSC_VER
			#define DLL_PUBLIC __declspec(dllexport)
		#else
			#define DLL_PUBLIC __attribute__ ((dllexport))
		#endif
	#else
		#ifdef _MSC_VER
			#define DLL_PUBLIC
		#else
			#define DLL_PUBLIC
		#endif
	#endif

	#ifdef _MSC_VER
		#define NAKED  __declspec(naked)
	#else
		#define NAKED
	#endif

	#define DLL_LOCAL
#else
	#if __GNUC__ >= 4
		#define DLL_PUBLIC __attribute__ ((visibility ("default")))
		#define DLL_LOCAL  __attribute__ ((visibility ("hidden")))
	    #define NAKED  __attribute__ ((naked))
	#else
		#define DLL_PUBLIC
		#define DLL_LOCAL
	#endif
#endif

#endif

```

`CommonCrossPlatform/LibraryLayout.h`:

```h
#ifndef _LIBRARY_LAYOUT_H_
#define _LIBRARY_LAYOUT_H_

namespace ext {
	union LibraryLayout {
		struct LinuxLayout {
			unsigned int libcBase;
			unsigned int librtBase;
			unsigned int libpthreadBase;
		} linLib;
		struct WindowsLayout {
			unsigned int ntdllBase;
		} winLib;
	};
};


#endif

```

`DisableSSE/CMakeLists.txt`:

```txt
## disablesse CMakeLists.txt

set(LIBRARY_NAME "disablesse")
set(CMAKE_C_FLAGS "-m32 -mno-mmx -mno-sse -march=i386")
set(CMAKE_ASM_FLAGS "${CMAKE_C_FLAGS}")

add_library(${LIBRARY_NAME} SHARED
	DisableSSE.S
	DisableSSEHelper.c
	)

set_target_properties(${LIBRARY_NAME}
	PROPERTIES
	DEFINE_SYMBOL ""
	)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`DisableSSE/DisableSSE.S`:

```S
#ifdef	__ASSEMBLER__

# define GET_PC_THUNK(reg) __x86.get_pc_thunk.reg

/* ELF uses byte-counts for .align, most others use log2 of count of bytes.  */
#define ALIGNARG(log2) 1<<log2
#define ASM_SIZE_DIRECTIVE(name) .size name,.-name;
#define JUMPTARGET(sym)	sym
# define C_LABEL(name)	name##:
# define C_SYMBOL_NAME(name) name

# define cfi_startproc			.cfi_startproc
# define cfi_endproc			.cfi_endproc
# define cfi_adjust_cfa_offset(off)	.cfi_adjust_cfa_offset off
# define cfi_def_cfa_register(reg)	.cfi_def_cfa_register reg
# define cfi_def_cfa(reg, off)		.cfi_def_cfa reg, off


#ifdef	PROF
/* The mcount code relies on a normal frame pointer being on the stack
   to locate our caller, so push one just for its benefit.  */
#define CALL_MCOUNT \
  pushl %ebp; cfi_adjust_cfa_offset (4); movl %esp, %ebp; \
  cfi_def_cfa_register (ebp); call JUMPTARGET(mcount); \
  popl %ebp; cfi_def_cfa (esp, 4);
#else
#define CALL_MCOUNT		/* Do nothing.  */
#endif

#define	ENTRY(name)							      \
  .globl C_SYMBOL_NAME(name);						      \
  .type C_SYMBOL_NAME(name),@function;					      \
  .align ALIGNARG(4);							      \
  C_LABEL(name)								      \
  cfi_startproc;							      \
  CALL_MCOUNT

#undef	END
#define END(name)							      \
  cfi_endproc;								      \
  ASM_SIZE_DIRECTIVE(name)


# define SETUP_PIC_REG(reg) \
  .ifndef GET_PC_THUNK(reg);						      \
  .section .gnu.linkonce.t.GET_PC_THUNK(reg),"ax",@progbits;		      \
  .globl GET_PC_THUNK(reg);						      \
  .hidden GET_PC_THUNK(reg);						      \
  .p2align 4;								      \
  .type GET_PC_THUNK(reg),@function;					      \
GET_PC_THUNK(reg):							      \
  movl (%esp), %e##reg;							      \
  ret;									      \
  .size GET_PC_THUNK(reg), . - GET_PC_THUNK(reg);			      \
  .previous;								      \
  .endif;								      \
  call GET_PC_THUNK(reg)

# define LOAD_PIC_REG(reg) \
  SETUP_PIC_REG(reg); addl $_GLOBAL_OFFSET_TABLE_, %e##reg

# define LOAD_GOT_AND_RTLD_GLOBAL_RO \
  LOAD_PIC_REG(dx); \
  mov _rtld_global_ro@GOT(%edx), %ecx


.globl patch__rtld_global_ro
.text
ENTRY(patch__rtld_global_ro_stub)
	.type patch__rtld_global_ro_stub, @gnu_indirect_function
	call patch__rtld_global_ro
	ret
END(patch__rtld_global_ro_stub)


.globl get_rtld_global_ro_addr
.section .text
get_rtld_global_ro_addr:
LOAD_GOT_AND_RTLD_GLOBAL_RO
movl %ecx, %eax
ret
#endif

```

`DisableSSE/DisableSSEHelper.c`:

```c
#include <sys/mman.h>

#define DEBUG_BREAK asm volatile("int $0x3")
#define bit_arch_Slow_BSF (1 << 2)

extern unsigned int get_rtld_global_ro_addr(void);

void patch__rtld_global_ro() {

	void *_rtld_global_ro =  (void*)get_rtld_global_ro_addr();
	off_t sse_flag = 0x64;
	off_t slow_bsf = 0x94;
	int ret = mprotect(_rtld_global_ro - 0xd00, 0x1000, PROT_READ | PROT_WRITE);

	void *_rtld_global_ro_sse = _rtld_global_ro + sse_flag;

	*((unsigned int*)_rtld_global_ro_sse) &= 0xfffffdff;
	*((unsigned int*)_rtld_global_ro_sse + 1) &= 0xfbffffff;
	*((unsigned int*)(_rtld_global_ro + slow_bsf)) &= ~bit_arch_Slow_BSF;
	mprotect((void *)_rtld_global_ro - 0xd00, 0x1000, PROT_READ);
}

__attribute__((constructor)) void somain(void) {
	patch__rtld_global_ro();
}

```

`DisableSSE/Makefile`:

```
disable_sse_so := libdisablesse.so
CC := gcc
CXX := g++
NO_SSE := -mno-mmx -mno-sse -march=i386
CC_FLAGS += -m32 $(NO_SSE) $(CC_FLAGS_CROSS)
prefix := /usr/local

ASM_FILES := DisableSSE.S
C_FILES := DisableSSEHelper.c
OBJ_FILES :=  DisableSSE.o  DisableSSEHelper.o

all: $(disable_sse_so)

install: $(disable_sse_so)
	install -m 0755 $(disable_sse_so) -t $(prefix)/lib -D

$(disable_sse_so): $(OBJ_FILES)
	$(CC) $(CC_FLAGS) -shared -o $@ $^

DisableSSEHelper.o: DisableSSEHelper.c
	$(CC) $(CC_FLAGS) -c -o $@ $<

DisableSSE.o: DisableSSE.S
	$(CC) $(CC_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(disable_sse_so) $(OBJ_FILES)

```

`Execution/CMakeLists.txt`:

```txt
## Execution CMakeLists.txt

set(LIBRARY_NAME execution)
set(FLAGS_CROSS "-D__cdecl=\"\" -D__stdcall=\"\"")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32 -std=c++11 -D_EXECUTION_EXPORTS \
	-DBLOCK_CACHE_READ_ONLY ${FLAGS_CROSS}")

include_directories(../BinLoader)
add_library(${LIBRARY_NAME} SHARED
	Debugger.cpp
	ExternExecutionController.Linux.cpp
	DualAllocator.Linux.cpp
	TokenRingInit.Linux.cpp
	LargeStack.cpp
	CommonExecutionController2.cpp
	InprocessExecutionController.cpp
	CommonExecutionController.cpp
	Main.cpp
	../revtracer/sync.cpp
	../revtracer/crc32.cpp
	../revtracer/cb.cpp
	../libproc/libproc.cpp
	)

target_link_libraries(${LIBRARY_NAME}
	binloader
	wrappersetup
	virtualmemory
	rt
	dl)

set_target_properties(${LIBRARY_NAME} PROPERTIES PUBLIC_HEADER "Execution.h")
install(TARGETS ${LIBRARY_NAME}
  LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX}/lib
  PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Execution
  )

```

`Execution/CommonExecutionController.cpp`:

```cpp
#include "CommonExecutionController.h"
#include "../revtracer/DebugPrintFlags.h"
#include "../CommonCrossPlatform/Common.h"
#include <iostream>

#ifdef __linux__
#include <stdarg.h>
#include <stdio.h>
#include "../libproc/os-linux.h"

#include <sys/time.h>
#include <sys/resource.h>

#include <libgen.h> //basename
#include <asm/ldt.h>
#else
#include <Windows.h>
#include <Psapi.h>
#include <tlhelp32.h>
#include <Winternl.h>
#endif

#ifdef _WIN32
void InitSegment(HANDLE hThread, DWORD dwSeg, DWORD &offset) {
	LDT_ENTRY entry;
	DWORD base, limit;

	if (FALSE == GetThreadSelectorEntry(hThread, dwSeg, &entry)) {
		base = 0xFFFFFFFF;
		limit = 0;
	}
	else {
		base = entry.BaseLow | (entry.HighWord.Bytes.BaseMid << 16) | (entry.HighWord.Bytes.BaseHi << 24);
		limit = entry.LimitLow | (entry.HighWord.Bits.LimitHi << 16);
	}

	if (entry.HighWord.Bits.Granularity) {
		limit = (limit << 12) | 0x0FFF;
	}

	offset = base;
}


void InitSegments(void *hThread, nodep::DWORD *segments) {
	for (DWORD i = 0; i < 0x100; ++i) {
		InitSegment((HANDLE)hThread, i, segments[i]);
	}
}
#elif defined(__linux__)
#define __NR_get_thread_area 244
void InitSegments(void *hThread, nodep::DWORD *segments) {
	struct user_desc* table_entry_ptr = nullptr;

	table_entry_ptr = (struct user_desc*)malloc(sizeof(struct user_desc));

	// segments max size if 0xff, so index max is 0x1f
	for (int index = 0; index < 0x1f; ++index) {
		table_entry_ptr->entry_number = index;
		int ret = syscall( __NR_get_thread_area,
				table_entry_ptr);
		// if entry number is not available
		unsigned value = 0x0;
		if (ret == -1 && errno != EINVAL) {
			printf("Error found when get_thread_area. errno %d\n", errno);
			DEBUG_BREAK;
		} else if (ret == 0) {
			value = table_entry_ptr->base_addr;
		}

		for (int j = 0; j < 8; ++j) {
			nodep::WORD segmentvalue = (index << 3) | j;
			// bit #2 specifies LDT(set) or GDT(unset)
			if (j & 0x4) {
				segments[segmentvalue] = 0xffffffff;
			} else {
				segments[segmentvalue] = value;
			}
		}
	}
	free(table_entry_ptr);
}
#endif


class DefaultObserver : public ExecutionObserver {
public :
	unsigned int ExecutionBegin(void *ctx, void *address) {
		return EXECUTION_ADVANCE;
	}

	unsigned int ExecutionControl(void *ctx, void *address) {
		return EXECUTION_ADVANCE;
	}

	unsigned int ExecutionEnd(void *ctx) {
		return EXECUTION_TERMINATE;
	}

	unsigned int TranslationError(void *ctx, void *address) {
		return EXECUTION_TERMINATE;
	}

	void TerminationNotification(void *ctx) { }
} defaultObserver;


const rev::RevtracerVersion CommonExecutionController::supportedVersion = {
	0,
	1,
	1
};

CommonExecutionController::CommonExecutionController() {
	execState = NEW;

	path = L"";
	cmdLine = L"";
	entryPoint = nullptr;
	featureFlags = EXECUTION_FEATURE_REVERSIBLE | EXECUTION_FEATURE_TRACKING;

	context = NULL;

	observer = &defaultObserver;

	virtualSize = commitedSize = 0;
	updated = false;

	trackCb = nullptr;
	markCb = nullptr;
	symbCb = nullptr;
}

int CommonExecutionController::GetState() const {
	return (int)execState;
}

bool CommonExecutionController::SetPath(const wstring &p) {
	if (execState == RUNNING) {
		return false;
	}

	std::wcout << "[CommonExecutionController] Setting tracee path to [" << p.c_str() << "]\n";
	path = p;
	execState = INITIALIZED;
	return true;
}

bool CommonExecutionController::SetCmdLine(const wstring &c) {
	if (execState == RUNNING) {
		return false;
	}

	cmdLine = c;
	return true;
}

bool CommonExecutionController::SetEntryPoint(void *ep) {
	if (execState == RUNNING) {
		return false;
	}

	entryPoint = ep;
	return true;
}

bool CommonExecutionController::SetExecutionFeatures(unsigned int feat) {
	featureFlags = feat;
	return true;
}

void CommonExecutionController::SetExecutionObserver(ExecutionObserver * obs) {
	observer = obs;
}

void CommonExecutionController::SetTrackingObserver(rev::TrackCallbackFunc track, rev::MarkCallbackFunc mark) {
	trackCb = track;
	markCb = mark;
}

void CommonExecutionController::SetSymbolicHandler(rev::SymbolicHandlerFunc symb) {
	symbCb = symb;
}

unsigned int CommonExecutionController::ExecutionBegin(void *address, void *cbCtx) {
	execState = SUSPENDED_AT_START;
	return observer->ExecutionBegin(cbCtx, address);
}

unsigned int CommonExecutionController::ExecutionControl(void *address, void *cbCtx) {
	return observer->ExecutionControl(cbCtx, address);
}

unsigned int CommonExecutionController::ExecutionEnd(void *cbCtx) {
	execState = SUSPENDED_AT_TERMINATION;
	return observer->ExecutionEnd(cbCtx);
}

unsigned int CommonExecutionController::TranslationError(void *address, void *cbCtx) {
	return observer->TranslationError(cbCtx, address);
}

struct _VM_COUNTERS_ {
	ULONG PeakVirtualSize;
	ULONG VirtualSize; // << VM use 
	ULONG PageFaultCount;
	ULONG PeakWorkingSetSize;
	ULONG WorkingSetSize;
	ULONG QuotaPeakPagedPoolUsage;
	ULONG QuotaPagedPoolUsage;
	ULONG QuotaPeakNonPagedPoolUsage;
	ULONG QuotaNonPagedPoolUsage;
	ULONG PagefileUsage; // << Commited use
	ULONG PeakPagefileUsage;
};

#ifdef __linux__

long get_prss() {
	struct rusage rusage;
	getrusage( RUSAGE_SELF, &rusage );

	return (size_t)(rusage.ru_maxrss * 1024L);
}

char *TrimModulePath(char *modulePath) {
	return basename(modulePath);
}

void CommonExecutionController::PrintModules() {
	for (auto it = mod.begin(); it != mod.end(); ++it) {
		printf("## %s base: 0x%08X size: 0x%08X\n", it->Name, it->ModuleBase,
				it->Size);
	}
}

bool CommonExecutionController::UpdateLayout() {
	if (updated) {
		return true;
	}

	if ((virtualSize == get_prss()) && (commitedSize == get_rss())) {
		return true;
	}

	virtualSize = get_prss();
	commitedSize = get_rss();

	sec.clear();
	mod.clear();

	struct map_iterator mi;
	struct map_prot mp;
	unsigned long hi;
	unsigned long segbase, mapoff;


	if (maps_init (&mi, getpid()) < 0) {
		updated = false;
		return false;
	}


	while (maps_next (&mi, &segbase, &hi, &mapoff, &mp)) {
		VirtualMemorySection vms;
		vms.BaseAddress = segbase;
		vms.Protection = mp.prot;
		vms.RegionSize = hi - segbase;
		sec.push_back(vms);

		ssize_t pathLen = strlen(mi.path);
		char *moduleName = TrimModulePath(mi.path);

		if ((0 == mod.size()) ||
				(0 != strcmp(moduleName, mod[mod.size() - 1].Name))) {
			ModuleInfo minfo;

			if (0 == pathLen) {
				//handle anonymous mapping
				minfo.anonymous = true;
			} else {
				minfo.anonymous = false;
				memset(minfo.Name, 0, MAX_PATH);
				strncpy(minfo.Name, moduleName, pathLen);
			}

			minfo.ModuleBase = segbase;
			minfo.Size = hi - segbase;
			mod.push_back(minfo);
		} else {
			ModuleInfo &mi = mod[mod.size() - 1];
			mi.Size += hi - segbase;
		}

	}

	updated = true;
	return true;
}
#else
bool CommonExecutionController::UpdateLayout() {
	if (updated) {
		return true;
	}

	ULONG retLen;
	_VM_COUNTERS_ ctrs;

	THREAD_T hProcess = GetProcessHandle();

	NtQueryInformationProcess(
		hProcess,
		(PROCESSINFOCLASS)3,
		&ctrs,
		sizeof(ctrs),
		&retLen
	);

	if ((ctrs.VirtualSize == virtualSize) && (ctrs.PagefileUsage == commitedSize)) {
		return true;
	}

	virtualSize = ctrs.VirtualSize;
	commitedSize = ctrs.PagefileUsage;

	sec.clear();
	mod.clear();

	char mf[MAX_PATH];

	for (DWORD dwAddr = 0; dwAddr < 0x7FFF0000;) {
		MEMORY_BASIC_INFORMATION32 mbi;

		if (0 == VirtualQueryEx(hProcess, (LPCVOID)dwAddr, (PMEMORY_BASIC_INFORMATION)&mbi, sizeof(mbi))) {
			return false;
		}

		VirtualMemorySection vms;
		vms.BaseAddress = dwAddr;
		vms.Protection = mbi.Protect;
		vms.RegionSize = mbi.RegionSize;
		vms.State = mbi.State;
		vms.Type = mbi.Type;
		sec.push_back(vms);

		DWORD dwSz = GetMappedFileName(hProcess, (LPVOID)dwAddr, mf, (sizeof(mf) / sizeof(mf[0])) - 1);
		if (0 != dwSz) {
			char *module = mf;
			for (DWORD i = 1; i < dwSz; ++i) {
				if (mf[i - 1] == '\\') {
					module = &mf[i];
				}
			}

			for (char *t = module; *t != '\0'; ++t) {
				*t = tolower(*t);
			}

			if ((0 == mod.size()) || (0 != strcmp(module, mod[mod.size() - 1].Name))) {
				ModuleInfo mi;
				strcpy_s(mi.Name, module);
				mi.ModuleBase = dwAddr;
				mi.Size = mbi.RegionSize;

				mod.push_back(mi);
			}
			else {
				ModuleInfo &mi = mod[mod.size() - 1];

				mi.Size = dwAddr - mi.ModuleBase + mbi.RegionSize;
			}
		}


		dwAddr = mbi.BaseAddress + mbi.RegionSize;
	}

	updated = true;
	return true;
}
#endif

bool CommonExecutionController::GetProcessVirtualMemory(VirtualMemorySection *&sections, int &sectionCount) {
	if (!UpdateLayout()) {
		return false;
	}

	sectionCount = sec.size();
	sections = &sec[0];

	return true;
}

bool CommonExecutionController::GetModules(ModuleInfo *&modules, int &moduleCount) {
	if (!UpdateLayout()) {
		return false;
	}

	moduleCount = mod.size();
	modules = &mod[0];
	return true;
}

int GeneratePrefix(char *buff, int size, ...) {
	va_list va;

	va_start(va, size);
	int sz = VSNPRINTF_S(
		buff,
		size,
		size - 1,
		"[%3s|%5s|%3s|%c] ",
		va
	);
	va_end(va);

	return sz;
}

FILE_T hDbg = OPEN_FILE_W("execution.log");

void vDebugPrintf(const DWORD printMask, const char *fmt, va_list args) {
	DWORD dwWr;
	char tmpBuff[512];

	char pfxBuff[] = "[___|_____|___|_]      ";
	static char lastChar = '\n';

	const char messageTypes[][4] = {
		"___",
		"ERR",
		"INF",
		"DBG"
	};

	const char executionStages[][6] = {
		"_____",
		"BRHND",
		"DIASM",
		"TRANS",
		"REASM",
		"RUNTM",
		"INSPT",
		"CNTNR"
	};

	const char codeTypes[][4] = {
		"___",
		"NAT",
		"RIV",
		"TRK",
		"SYM"
	};

	const char codeDirections[] = {
		'_', 'F', 'B'
	};

	if ('\n' == lastChar) {

		int sz = GeneratePrefix(
			pfxBuff,
			sizeof(pfxBuff),
			messageTypes[(printMask & PRINT_MESSAGE_MASK) >> PRINT_MESSAGE_SHIFT],
			executionStages[(printMask & PRINT_EXECUTION_MASK) >> PRINT_EXECUTION_SHIFT],
			codeTypes[(printMask & PRINT_CODE_TYPE_MASK) >> PRINT_CODE_TYPE_SHIFT],
			codeDirections[(printMask & PRINT_CODE_DIRECTION_MASK) >> PRINT_CODE_DIRECTION_SHIFT]
		);
		//debugLog.Write(pfxBuff, sz);

		BOOL ret;
		WRITE_FILE(hDbg, pfxBuff, sz, dwWr, ret);
	}

	int sz = VSNPRINTF_S(tmpBuff, sizeof(tmpBuff) - 1, sizeof(tmpBuff) - 1, fmt, args);
	
	if (sz) {
		//debugLog.Write(tmpBuff, sz);

		BOOL ret;
		WRITE_FILE(hDbg, tmpBuff, sz, dwWr, ret);
		lastChar = tmpBuff[sz - 1];
	}
}

void DebugPrintf(const unsigned int printMask, const char *fmt, ...) {
	va_list va;
	va_start(va, fmt);
	vDebugPrintf(printMask, fmt, va);
	va_end(va);
}

void CommonExecutionController::DebugPrintf(const unsigned long printMask, const char * fmt, ...) {
	va_list va;
	va_start(va, fmt);
	vDebugPrintf(printMask, fmt, va);
	va_end(va);
}


void CommonExecutionController::GetFirstEsp(void *ctx, nodep::DWORD &esp) {
	gfe(ctx, esp);
}

void CommonExecutionController::GetCurrentRegisters(void *ctx, rev::ExecutionRegs *regs) {
	gcr(ctx, regs);
}

void *CommonExecutionController::GetMemoryInfo(void *ctx, void *ptr) {
	return gmi(ctx, ptr);
}

bool CommonExecutionController::GetLastBasicBlockInfo(void *ctx, rev::BasicBlockInfo *bbInfo) {
	return glbbi(ctx, bbInfo);
}

void CommonExecutionController::MarkMemoryValue(void *ctx, rev::ADDR_TYPE addr, nodep::DWORD value) {
	mmv(ctx, addr, value);
}

```

`Execution/CommonExecutionController.h`:

```h
#ifndef _COMMON_EXECUTION_CONTROLLER_H
#define _COMMON_EXECUTION_CONTROLLER_H

#include "../CommonCrossPlatform/Common.h"
#include "Execution.h"
#include <vector>

using namespace std;

void DebugPrintf(const unsigned int printMask, const char *fmt, ...);
nodep::DWORD BranchHandlerFunc(void *context, void *userContext, rev::ADDR_TYPE nextInstruction);
nodep::DWORD ErrorHandlerFunc(void *context, void *userContext, rev::RevtracerError *rerror);
void InitSegments(void *hThread, nodep::DWORD *segments);

typedef void (*GetFirstEspFunc)(void *ctx, nodep::DWORD &esp);
typedef void(*GetCurrentRegistersFunc)(void *ctx, rev::ExecutionRegs *regs);
typedef void *(*GetMemoryInfoFunc)(void *ctx, void *ptr);
typedef void (*SetSymbolicExecutorFunc)(rev::SymbolicExecutorConstructor);
typedef bool(*GetLastBasicBlockInfoFunc)(void *ctx, rev::BasicBlockInfo *);

typedef void (*MarkMemoryValueFunc)(void *ctx, rev::ADDR_TYPE addr, nodep::DWORD value);

class CommonExecutionController : public ExecutionController {
private :
	bool UpdateLayout();
	void PrintModules();

	vector<VirtualMemorySection> sec;
	vector<ModuleInfo> mod;
	uint32_t virtualSize, commitedSize;

protected:

	enum {
		NEW = EXECUTION_NEW,
		INITIALIZED = EXECUTION_INITIALIZED,
		SUSPENDED_AT_START = EXECUTION_SUSPENDED_AT_START,
		RUNNING = EXECUTION_RUNNING,
		SUSPENDED = EXECUTION_SUSPENDED,
		SUSPENDED_AT_TERMINATION = EXECUTION_SUSPENDED_AT_TERMINATION,
		TERMINATED = EXECUTION_TERMINATED,
		ERR = EXECUTION_ERR
	} execState;

	CommonExecutionController();

	wstring path;
	wstring cmdLine;
	void *entryPoint;

	uint32_t featureFlags;

	void *context;
	bool updated;

	ExecutionObserver *observer;

	GetFirstEspFunc gfe;
	GetCurrentRegistersFunc gcr;
	GetMemoryInfoFunc gmi;
	MarkMemoryValueFunc mmv;
	GetLastBasicBlockInfoFunc glbbi;

	rev::TrackCallbackFunc trackCb;
	rev::MarkCallbackFunc markCb;
	rev::SymbolicHandlerFunc symbCb;

	static const rev::RevtracerVersion supportedVersion;
public :
	virtual int GetState() const;

	virtual bool SetPath(const wstring &p);
	virtual bool SetCmdLine(const wstring &c);
	virtual bool SetEntryPoint(void *ep);
	virtual bool SetExecutionFeatures(unsigned int feat);

	virtual void SetExecutionObserver(ExecutionObserver *obs);
	virtual void SetTrackingObserver(rev::TrackCallbackFunc track, rev::MarkCallbackFunc mark);
	virtual void SetSymbolicHandler(rev::SymbolicHandlerFunc symb);

	virtual unsigned int ExecutionBegin(void *address, void *cbCtx);
	virtual unsigned int ExecutionControl(void *address, void *cbCtx);
	virtual unsigned int ExecutionEnd(void *cbCtx);
	virtual unsigned int TranslationError(void *address, void *cbCtx);

	virtual void GetFirstEsp(void *ctx, nodep::DWORD &esp);
	virtual void GetCurrentRegisters(void *ctx, rev::ExecutionRegs *registers);
	virtual void *GetMemoryInfo(void *ctx, void *ptr);
	virtual bool GetLastBasicBlockInfo(void *ctx, rev::BasicBlockInfo *bbInfo);

	virtual void DebugPrintf(const unsigned long printMask, const char *fmt, ...);

	virtual bool GetProcessVirtualMemory(VirtualMemorySection *&sections, int &sectionCount);
	virtual bool GetModules(ModuleInfo *&modules, int &moduleCount);
	virtual void MarkMemoryValue(void *ctx, rev::ADDR_TYPE addr, nodep::DWORD value);
};

#endif // !_COMMON_EXECUTION_CONTROLLER_H

```

`Execution/CommonExecutionController2.cpp`:

```cpp
#include "../revtracer/common.h"
#include "../revtracer/revtracer.h"
#include "../revtracer/execenv.h"
#include "../revtracer/DebugPrintFlags.h"

#include "Execution.h"

#define PRINT_RUNTIME_TRACKING	PRINT_INFO | PRINT_RUNTIME | PRINT_TRACKING
#define PRINT_BRANCHING_ERROR	PRINT_ERROR | PRINT_BRANCH_HANDLER
#define PRINT_BRANCHING_DEBUG	PRINT_DEBUG | PRINT_BRANCH_HANDLER
#define PRINT_BRANCHING_INFO	PRINT_INFO | PRINT_BRANCH_HANDLER

static nodep::DWORD TopFromExecutionBuffer(ExecutionEnvironment *pEnv) {
	return *((nodep::DWORD *)pEnv->runtimeContext.execBuff);
}

static bool ExecutionBufferEmpty(ExecutionEnvironment *pEnv) {
	return (nodep::DWORD)pEnv->executionBase == pEnv->runtimeContext.execBuff;
}

typedef void(*SymbolicPayloadFunc)(nodep::DWORD trackBuffer);

nodep::DWORD BranchHandlerFunc(void *context, void *userContext, rev::ADDR_TYPE nextInstruction) {
	ExecutionEnvironment *pEnv = (ExecutionEnvironment *)context;
	ExecutionController *exec = (ExecutionController *)userContext;
	rev::ADDR_TYPE termCode = exec->GetTerminationCode();

	exec->DebugPrintf(PRINT_BRANCHING_INFO, "[BranchHandler] next instr %p\n", nextInstruction);

	if (pEnv->generationFlags & TRACER_FEATURE_TRACKING) {
		if (pEnv->bForward) {
			nodep::DWORD dwLastBlock = pEnv->lastFwBlock; //TopFromExecutionBuffer(pEnv);
			RiverBasicBlock *pLast = pEnv->blockCache.FindBlock(dwLastBlock);
			if (NULL != pLast) {
				((SymbolicPayloadFunc)pLast->pTrackCode)(pEnv->runtimeContext.trackBase - 4);
			}
		}
	}

	if (TRACER_FEATURE_TRACKING & pEnv->generationFlags) {
		LIB_TRACKING_PRINT(PRINT_RUNTIME_TRACKING, "Tainted registers :\n");
		LIB_TRACKING_PRINT(PRINT_RUNTIME_TRACKING, "EAX: 0x%08x  ECX: 0x%08x  EDX: 0x%08x  EBX: 0x%08x\n", pEnv->runtimeContext.taintedRegisters[0], pEnv->runtimeContext.taintedRegisters[1], pEnv->runtimeContext.taintedRegisters[2], pEnv->runtimeContext.taintedRegisters[3]);
		LIB_TRACKING_PRINT(PRINT_RUNTIME_TRACKING, "ESP: 0x%08x  EBP: 0x%08x  ESI: 0x%08x  EDI: 0x%08x\n", pEnv->runtimeContext.taintedRegisters[4], pEnv->runtimeContext.taintedRegisters[5], pEnv->runtimeContext.taintedRegisters[6], pEnv->runtimeContext.taintedRegisters[7]);
		LIB_TRACKING_PRINT(PRINT_RUNTIME_TRACKING, "CF: 0x%08x  PF: 0x%08x  AF: 0x%08x  ZF: 0x%08x  SF: 0x%08x  OF: 0x%08x  DF: 0x%08x\n",
			pEnv->runtimeContext.taintedFlags[0],
			pEnv->runtimeContext.taintedFlags[1],
			pEnv->runtimeContext.taintedFlags[2],
			pEnv->runtimeContext.taintedFlags[3],
			pEnv->runtimeContext.taintedFlags[4],
			pEnv->runtimeContext.taintedFlags[5],
			pEnv->runtimeContext.taintedFlags[6]
		);
	}

	nodep::DWORD dwDirection = EXECUTION_ADVANCE;
	if ((nextInstruction == termCode) || (nextInstruction == (rev::ADDR_TYPE)pEnv->exitAddr)) {
		// TODO: verify parameters
		dwDirection = exec->ExecutionEnd(pEnv);
	}
	else if (ExecutionBufferEmpty(pEnv)) {
		dwDirection = exec->ExecutionBegin(nextInstruction, pEnv);
	}
	else {
		dwDirection = exec->ExecutionControl(nextInstruction, pEnv);
	}

	// for now: we only accept resets at execution end
	if ((EXECUTION_RESTART == dwDirection) && (nextInstruction != (rev::ADDR_TYPE)pEnv->exitAddr)) {
		dwDirection = EXECUTION_TERMINATE;
	}

	if ((EXECUTION_BACKTRACK == dwDirection) && (0 == (pEnv->generationFlags & TRACER_FEATURE_REVERSIBLE))) {
		dwDirection = EXECUTION_ADVANCE;
	}


	if (pEnv->generationFlags & TRACER_FEATURE_TRACKING) {
		if (EXECUTION_BACKTRACK == dwDirection) {
			// go backwards
			nodep::DWORD addr = TopFromExecutionBuffer(pEnv);
			RiverBasicBlock *pCB = pEnv->blockCache.FindBlock(addr);
			if (pCB) {
				exec->DebugPrintf(PRINT_BRANCHING_INFO, "Block found\n");
				((SymbolicPayloadFunc)pCB->pRevTrackCode)(pEnv->runtimeContext.trackBase - 4);
			}
			else {
				exec->DebugPrintf(PRINT_BRANCHING_ERROR, "No reverse block found!");
				DEBUG_BREAK;
			}
		}
	}

	exec->DebugPrintf(PRINT_BRANCHING_INFO, "[Parent] BH direction %s\n", dwDirection == EXECUTION_ADVANCE ? "advance" : "other");
	return dwDirection;
}

nodep::DWORD ErrorHandlerFunc(void *context, void *userContext, rev::RevtracerError *rerror) {
	ExecutionEnvironment *pEnv = (ExecutionEnvironment *)context;
	ExecutionController *exec = (ExecutionController *)userContext;

	if (rerror->errorCode == RERROR_UNK_INSTRUCTION) {
		exec->DebugPrintf(PRINT_ERROR, "Disassembling unknown instruction %02x %02x at address %08x\n",
				rerror->prefix, rerror->opcode, rerror->instructionAddress);

		switch(rerror->translatorId) {
			case RIVER_META_TRANSLATOR_ID:
				exec->DebugPrintf(PRINT_ERROR, "Translation step: MetaTrasnlator\n");
				break;
			case RIVER_DISASSEMBLER_ID:
				exec->DebugPrintf(PRINT_ERROR, "Translation step: Disassembler\n");
				break;
			default:
				exec->DebugPrintf(PRINT_ERROR, "Translation step: unknown\n");

		}
	}

	auto direction = exec->TranslationError((void*)rerror->instructionAddress, pEnv);

	return direction;
}

void SyscallControlFunc(void *context, void *userContext) {
	// *_this = (InprocessExecutionController *)context;
}

```

`Execution/Debugger.cpp`:

```cpp
#ifdef  __linux__

#include "Debugger.h"

#include <sys/wait.h>
#include <sys/user.h>
#include <string.h>

namespace dbg {

#if defined(__i386)
#define REGISTER_IP EIP
#define TRAP_LEN    1
#define TRAP_INST   0xCC
#define TRAP_MASK   0xFFFFFF00
#endif

	const int long_size = sizeof(long);
	void Debugger::GetData(long addr, unsigned char *str, int len)
	{   unsigned char *laddr;
		int i, j;
		union u {
			long val;
			char chars[long_size];
		}data;
		i = 0;
		j = len / long_size;
		laddr = str;
		while(i < j) {
			data.val = ptrace(PTRACE_PEEKDATA, Tracee,
					addr + i * 4, nullptr);
			memcpy(laddr, data.chars, long_size);
			++i;
			laddr += long_size;
		}
		j = len % long_size;
		if(j != 0) {
			data.val = ptrace(PTRACE_PEEKDATA, Tracee,
					addr + i * 4, nullptr);
			memcpy(laddr, data.chars, j);
		}
		str[len] = '\0';
	}

	void Debugger::PutData(long addr, unsigned char *str, int len)
	{   unsigned char *laddr;
		int i, j;
		union u {
			long val;
			char chars[long_size];
		}data;
		i = 0;
		j = len / long_size;
		laddr = str;
		while(i < j) {
			memcpy(data.chars, laddr, long_size);
			ptrace(PTRACE_POKEDATA, Tracee,
					addr + i * 4, data.val);
			++i;
			laddr += long_size;
		}
		j = len % long_size;
		if(j != 0) {
			memcpy(data.chars, laddr, j);
			ptrace(PTRACE_POKEDATA, Tracee,
					addr + i * 4, data.val);
		}
	}

	void Debugger::SetEip(unsigned long address) {
		struct user_regs_struct regs;
		ptrace(PTRACE_GETREGS, Tracee, 0, &regs);
		regs.eip = address;
		ptrace (PTRACE_SETREGS, Tracee, 0, &regs);
	}

	void Debugger::PrintEip() {
		struct user_regs_struct regs;
		ptrace(PTRACE_GETREGS, Tracee, 0, &regs);
		printf("[Debugger] Tracee process %d stopped at eip %lx\n", Tracee, regs.eip);
	}

	void Debugger::PrintRegs() {
		struct user_regs_struct regs;
		ptrace(PTRACE_GETREGS, Tracee, 0, &regs);
		printf("[Debugger] EAX: %08lx  EDX: %08lx  ECX: %08lx  EBX: %08lx\n", regs.eax, regs.edx, regs.ecx, regs.ebx);
		printf("[Debugger] ESP: %08lx  EBP: %08lx  ESI: %08lx  EDI: %08lx\n", regs.esp, regs.ebp, regs.esi, regs.edi);
	}

	int Debugger::CheckEip(unsigned eip) {
		struct user_regs_struct regs;
		ptrace(PTRACE_GETREGS, Tracee, 0, &regs);
		printf("[Debugger] Tracee process %d testing eip %08lx with limit %08x\n", Tracee, regs.eip, eip);
		return eip == regs.eip;
	}

	Debugger::Debugger() {
		Tracee = -1;
	}

	void Debugger::Attach(pid_t pid) {
		if (Tracee != -1) {
			printf("[Debugger] Already tracing %d\n", Tracee);
			return;
		}

		Tracee = pid;
		int status;

		waitpid(pid, &status, 0);

		struct user_regs_struct regs;
		ptrace(PTRACE_GETREGS, pid, 0, &regs);
		printf("[Debugger] Attached to pid %d, ip %08lx\n", pid, regs.eip);
	}

	unsigned long Debugger::InsertBreakpoint(unsigned long address) {
		printf("[Debugger] Inserting breakpoint at address %lx\n", address);

		long orig = ptrace(PTRACE_PEEKTEXT, Tracee, address);
		ptrace(PTRACE_POKETEXT, Tracee, address, (orig & TRAP_MASK) | TRAP_INST);
		BreakpointCode.insert(std::make_pair(address, orig));
		return address;
	}

	void Debugger::DeleteBreakpoint(unsigned long address) {
		printf("[Debugger] Deleting breakpoint at address %lx\n", address);
		if (BreakpointCode.find(address) == BreakpointCode.end()) {
			printf("[Debugger] Breakpoint not found at address %lx\n", address);
			return;
		}
		ptrace(PTRACE_POKETEXT, Tracee, address, BreakpointCode[address]);
		SetEip(address);
	}

	int Debugger::Run(enum __ptrace_request request) {
		int status, last_sig = 0, event;

		while (1) {
			ptrace(request, Tracee, 0, last_sig);
			waitpid(Tracee, &status, WCONTINUED);

			if (WIFEXITED(status)) {
				printf("[Debugger] Pid %d exited\n", Tracee);
				return 0;
			}

			if (WIFSTOPPED(status)) {
				last_sig = WSTOPSIG(status);
				if (last_sig == SIGTRAP) {
					event = (status >> 16) & 0xffff;
					printf("[Debugger] Tracee received SIGTRAP\n");
					PrintEip();
					return (event == PTRACE_EVENT_EXIT) ? 0 : 1;
				} else if (last_sig == SIGUSR1) {
					printf("[Debugger] Child received SIGUSR1, continuing ...\n");
					fflush(stdout);
				} else {
					printf("[Debugger] Tracee received signal %d\n", last_sig);
					PrintEip();
					PrintRegs();
					if (last_sig == 11) {
						return -1;
					}
				}
			}
		}
		return 0;
	}


	unsigned long Debugger::GetAndResolveModuleAddress(unsigned long symbolAddress) {
		unsigned char sym_addr[5] = {0, 0, 0, 0, 0};
		//printf("[Parent] Trying to read data from child %08lx\n", symbolAddress);
		GetData(symbolAddress, sym_addr, 4);

		unsigned long result;
		for (int i = 0; i < 4; ++i) {
			((char*)&result)[i] = sym_addr[i];
		}
		return result;
	}

} //namespace dbg

#endif

```

`Execution/Debugger.h`:

```h
#ifdef  __linux__

#ifndef __DEBUGGER__
#define __DEBUGGER__

#include <map>
#include <unistd.h>
#include <sys/ptrace.h>

namespace dbg {
class Debugger {
	public:
		Debugger();
		void Attach(pid_t pid);
		void Detach();
		unsigned long InsertBreakpoint(unsigned long address);
		void DeleteBreakpoint(unsigned long address);
		int Run(enum __ptrace_request request);
		void SetEip(unsigned long address);
		void PrintEip();
		void PrintRegs();
		int CheckEip(unsigned eip);
		void GetData(long addr, unsigned char *str, int len);
		void PutData(long addr, unsigned char *str, int len);
		unsigned long GetAndResolveModuleAddress(unsigned long symbolAddress);

	private:
		pid_t Tracee;
		std::map<unsigned long, long> BreakpointCode;

};
} //namespace dbg
#endif

#endif
```

`Execution/DualAllocator.Linux.cpp`:

```cpp
#ifdef  __linux__

#include "DualAllocator.h"
#include <stdio.h>
#include <errno.h>
#include <algorithm>
#include "../libproc/os-linux.h"

#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#else
#define dbg_log(fmt,...) printf(fmt, ##__VA_ARGS__)
#endif

DualAllocator::DualAllocator(DWORD size, PROCESS_HANDLE remoteProcess, const char *shmName, DWORD granularity, DWORD initialOffset) {
	dwSize = size;
	dwUsed = initialOffset;
	dwGran = 0x1000;

	hProcess[0] = GET_CURRENT_PROC();
	hProcess[1] = remoteProcess;

	hMapping = shm_open("/thug_life", O_CREAT | O_RDWR, 0644);
	if (hMapping == -1) {
		printf("[DualAllocator] Could not init shared memory chunk. Exiting. %d\n", errno);
	}
}

DualAllocator::~DualAllocator() {
	for (auto it = mappedViews.begin(); it < mappedViews.end(); ++it) {
		munmap(it->first, it->second);
	}

	shm_unlink("/thug_life");
}

HANDLE DualAllocator::CloneTo(PROCESS_HANDLE process) {
	// TODO do we need this ?
	return nullptr;
}

void DualAllocator::SetBaseAddress(DWORD baseAddress) {
	//TODO move this in constructor
	this->baseAddress = baseAddress;
}

DWORD DualAllocator::AllocateFixed(DWORD address, DWORD size) {
	printf("[DualAllocator] AllocateFixed(%08lx, %08lx)\n", address, dwUsed);
	void* addr = mmap((void*)address, size,
				PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, hMapping, dwUsed);
	if (addr == (void *)(-1)) {
		printf("[DualAllocator] mmap failed with error code %d for address %p. Used: %08lx\n", errno, addr, dwUsed);
		return (DWORD)addr;
	}

	// TODO check if there is enough free space in parent! Should be!
	dwUsed += size;
	dwUsed += dwGran - 1;
	dwUsed &= ~(dwGran - 1);

	return (DWORD)addr;
}

void GetMemoryLayout(std::vector<struct map_region> &mrs, pid_t pid) {
	struct map_iterator mi;
	if (maps_init(&mi, pid) < 0) {
		dbg_log("[DualAllocator] Cannot retrieve /proc/%d/maps\n", pid);
		return;
	}

	struct map_prot mp;
	unsigned long low, high, offset;

	dbg_log("[DualAllocator] /proc/%d/maps\n", pid);
	while (maps_next(&mi, &low, &high, &offset, &mp)) {
		dbg_log("[DualAllocator] path : %s base addr : %08lx high %08lx\n", mi.path, low, high);
		struct map_region mr;
		ssize_t len = mrs.size();
		if (len > 1) {
			// add free region before current region
			mr.address = mrs[len - 1].address + mrs[len-1].size;
			mr.size = low - mr.address;
		} else {
			mr.address = 0x0;
			mr.size = low;
		}
		if (mr.size > 0x00) {
			mr.state = FREE;
			mrs.push_back(mr);
			dbg_log("[DualAllocator] Added FREE %08x %08x\n", mr.address, mr.size);
		}

		// add current allocated region
		mr.address = low;
		mr.size = high - low;
		mr.state = ALLOCATED;
		mrs.push_back(mr);
		dbg_log("[DualAllocator] Added ALLOCATED %08x %08x\n", mr.address, mr.size);


	}
	maps_close(&mi);
}

bool VirtualQuery(std::vector<struct map_region> &mrs, uint32_t address,
		struct map_region &mr) {

	for (auto it = mrs.begin(); it != mrs.end(); ++it) {
		if (address < it->address)
			continue;
		if (address >= it->address + it->size)
			continue;
		mr = *it;
		return true;
	}

	//shouldn't reach this point
	printf("[DualAllocator] Could not find memory region for address %08x\n",
			address);
	return false;
}


void *DualAllocator::Allocate(DWORD size, DWORD &offset) {
	printf("[DualAllocator] Looking for a 0x%08lx block\n", size);

	// alignment
	size = (size + 0xFFF) & ~0xFFF;

	offset = 0xFFFFFFFF;
	if (dwUsed == dwSize) {
		printf("[DualAllocator] There is not enough size left. Used %08lx \
				out of %08lx\n", dwUsed, dwSize);
		return NULL;
	}

	offset = dwUsed;
	// now look for a suitable address;

	DWORD dwOffset = baseAddress; // dwGran;
	DWORD dwCandidate = 0, dwCandidateSize = 0xFFFFFFFF;

	std::vector<struct map_region> MemoryLayout[2];

	for (int i = 0; i < 2; i++) {
		GetMemoryLayout(MemoryLayout[i], hProcess[i]);
	}

	while (dwOffset < 0xF7000000) {
		struct map_region mr;
		DWORD regionSize = 0xFFFFFFFF;
		bool regionFree = true;

		for (int i = 0; i < 2; ++i) {
			VirtualQuery(MemoryLayout[i], dwOffset,  mr);

			DWORD dwSize = mr.size - (dwOffset - mr.address); // or allocationbase
			if (regionSize > dwSize) {
				regionSize = dwSize;
			}

			//printf("        Proc %d offset: 0x%08x, size 0x%08x\n", i, dwOffset, dwSize);

			regionFree &= (FREE == mr.state);
		}

		if (regionFree & (regionSize >= size) & (regionSize < dwCandidateSize)) {
			printf("    Candidate found @0x%08lx size 0x%08lx\n", dwOffset, regionSize);
			dwCandidate = dwOffset;
			dwCandidateSize = regionSize;

			if (regionSize == size) {
				break;
			}
		}

		dwOffset += regionSize;
		dwOffset += dwGran - 1;
		dwOffset &= ~(dwGran - 1);
	}

	if (0 == dwCandidate) {
		printf("[DualAllocator] Could not find candidate for size %08lx\n", size);
		return NULL;
	}

	printf("[DualAllocator] Trying to allocate %08lx at address %08lx\n",
			size, dwCandidate);
	void *ptr = (void *)AllocateFixed(dwCandidate, size);
	printf("[DualAllocator] Allocated addr @%p of size %08lx\n", ptr, size);

	if (dwCandidate != (DWORD)ptr) {
		DEBUG_BREAK;
	}

	mappedViews.push_back(std::pair<FileView, DWORD>(ptr, size));
	return ptr;
}

void DualAllocator::Free(void *ptr) {
	for (auto it = mappedViews.begin(); it != mappedViews.end(); ++it) {
		if (it->first == ptr) {
			munmap(ptr, it->second);
			mappedViews.erase(it);
			return;
		}
	}
}

#endif //  __linux__

```

`Execution/DualAllocator.Windows.cpp`:

```cpp
#include "DualAllocator.h"

DualAllocator::DualAllocator(DWORD size, HANDLE remoteProcess, const char *shmName, DWORD granularity, DWORD initialOffset) {
	hMapping = MAP_FILE_RWX(shmName, size);

	dwSize = size;
	dwUsed = initialOffset;
	dwGran = granularity;

	hProcess[0] = GetCurrentProcess();
	hProcess[1] = remoteProcess;
}

DualAllocator::~DualAllocator() {
	for (auto it = mappedViews.begin(); it < mappedViews.end(); ++it) {
		UnmapViewOfFile(it->first);
	}

	CloseHandle(hMapping);
}

HANDLE DualAllocator::CloneTo(HANDLE process) {
	HANDLE ret;
	if (TRUE == DuplicateHandle(
		GetCurrentProcess(),
		hMapping,
		process,
		&ret,
		0,
		FALSE,
		DUPLICATE_SAME_ACCESS
	)) {
		return ret;
	}
	return INVALID_HANDLE_VALUE;
}

#include <stdio.h>
void *DualAllocator::Allocate(DWORD size, DWORD &offset) {
	printf("Looking for a 0x%08x block\n", size);

	size = (size + 0xFFF) & ~0xFFF;

	offset = 0xFFFFFFFF;
	if (dwUsed == dwSize) {
		return NULL;
	}
	offset = dwUsed;
	dwUsed += size;
	dwUsed += dwGran - 1;
	dwUsed &= ~(dwGran - 1);

	// now look for a suitable address;

	DWORD dwOffset = 0x01000000; // dwGran;
	DWORD dwCandidate = 0, dwCandidateSize = 0xFFFFFFFF;

	while (dwOffset < 0x2FFF0000) {
		MEMORY_BASIC_INFORMATION32 mbi;
		DWORD regionSize = 0xFFFFFFFF;
		bool regionFree = true;

		for (int i = 0; i < 2; ++i) {
			if (0 == VirtualQueryEx(hProcess[i], (LPCVOID)dwOffset, (PMEMORY_BASIC_INFORMATION)&mbi, sizeof(mbi))) {
				return NULL;
			}

			DWORD dwSize = mbi.RegionSize - (dwOffset - mbi.BaseAddress); // or allocationbase
			if (regionSize > dwSize) {
				regionSize = dwSize;
			}

			//printf("        Proc %d offset: 0x%08x, size 0x%08x\n", i, dwOffset, dwSize);

			regionFree &= (MEM_FREE == mbi.State);
		}

		if (regionFree & (regionSize >= size) & (regionSize < dwCandidateSize)) {
			printf("    Candidate found @0x%08x size 0x%08x\n", dwOffset, regionSize);
			dwCandidate = dwOffset;
			dwCandidateSize = regionSize;

			if (regionSize == size) {
				break;
			}
		}

		dwOffset += regionSize;
		dwOffset += dwGran - 1;
		dwOffset &= ~(dwGran - 1);
	}

	if (0 == dwCandidate) {
		return NULL;
	}

	void *ptr = MapViewOfFileEx(
		hMapping,
		FILE_MAP_ALL_ACCESS | FILE_MAP_EXECUTE,
		0,
		offset,
		size,
		(void *)dwCandidate
		);

	if (dwCandidate != (DWORD)ptr) {
		DEBUG_BREAK;
	}

	mappedViews.push_back(std::pair<FileView, DWORD>(ptr, size));
	return ptr;
}

void DualAllocator::Free(void *ptr) {
	UnmapViewOfFile(ptr);
}

```

`Execution/DualAllocator.h`:

```h
#ifndef _DUAL_ALLOCATOR_H_
#define _DUAL_ALLOCATOR_H_

#include "../CommonCrossPlatform/Common.h"
#include <vector>

typedef void *FileView;

class DualAllocator {
private:
	MAPPING_HANDLE hMapping;
	DWORD dwSize;
	DWORD dwUsed;
	DWORD dwGran;
	DWORD baseAddress;

	std::vector<std::pair<FileView, DWORD> > mappedViews;
	PROCESS_HANDLE hProcess[2];
public:
	DualAllocator(DWORD size, PROCESS_HANDLE remoteProcess,	const char *shmName, DWORD granularity, DWORD initialOffset);
	~DualAllocator();

	HANDLE CloneTo(PROCESS_HANDLE process);

	void SetBaseAddress(DWORD baseAddress);
	void *Allocate(DWORD size, DWORD &offset);
	DWORD AllocateFixed(DWORD size, DWORD address);
	void Free(void *ptr);
};


#endif

```

`Execution/Execution.h`:

```h
#ifndef _EXECUTION_H
#define _EXECUTION_H

#include <string>
#include <cstdint>

#include "../revtracer/revtracer.h"

#if defined _WIN32 || defined __CYGWIN__
	#ifdef _EXECUTION_EXPORTS
		#ifdef __GNUC__
			#define DLL_EXECUTION_PUBLIC __attribute__ ((dllexport))
		#else
			#define DLL_EXECUTION_PUBLIC __declspec(dllexport)
		#endif
	#else
		#ifdef __GNUC__
			#define DLL_EXECUTION_PUBLIC __attribute__ ((dllimport))
		#else
			#define DLL_EXECUTION_PUBLIC __declspec(dllimport)
		#endif
	#endif
	#define DLL_LOCAL
#else
	#if __GNUC__ >= 4
		#define DLL_EXECUTION_PUBLIC __attribute__ ((visibility ("default")))
		#define DLL_LOCAL  __attribute__ ((visibility ("hidden")))
	#else
		#define DLL_EXECUTION_PUBLIC
		#define DLL_LOCAL
	#endif
#endif

#ifdef __linux__
typedef pthread_t THREAD_T;
typedef void* ADDR_TYPE;
#else
typedef void *THREAD_T;
typedef void *ADDR_TYPE;
#endif

#define EXECUTION_INPROCESS						0x00000000
#define EXECUTION_EXTERNAL						0x00000001

#define EXECUTION_FEATURE_REVERSIBLE			0x00000001
#define EXECUTION_FEATURE_TRACKING				0x00000002
#define EXECUTION_FEATURE_ADVANCED_TRACKING		0x00000004 // never use this flag --- use _SYMBOLIC instead
#define EXECUTION_FEATURE_SYMBOLIC				EXECUTION_FEATURE_TRACKING | EXECUTION_FEATURE_ADVANCED_TRACKING

#define EXECUTION_ADVANCE					0x00000000
#define EXECUTION_BACKTRACK					0x00000001
#define EXECUTION_TERMINATE					0x00000002
#define EXECUTION_RESTART					0x00000003

#define EXECUTION_NEW							0x00
#define EXECUTION_INITIALIZED					0x01
#define EXECUTION_SUSPENDED_AT_START			0x02
#define EXECUTION_RUNNING						0x03
#define EXECUTION_SUSPENDED						0x04
#define EXECUTION_SUSPENDED_AT_TERMINATION		0x05
#define EXECUTION_TERMINATED					0x06
#define EXECUTION_ERR							0xFF

using namespace std;

#define EXEC_MEM_COMMIT					0x01000
#define EXEC_MEM_FREE					0x10000
#define EXEC_MEM_RESERVE				0x02000

#define EXEC_MEM_IMAGE					0x1000000
#define EXEC_MEM_MAPPED					0x0040000
#define EXEC_MEM_PRIVATE				0x0020000

#define EXEC_PAGE_NOACCESS				0x01
#define EXEC_PAGE_EXECUTE				0x10
#define EXEC_PAGE_READONLY				0x02
#define EXEC_PAGE_READWRITE				0x04
#define EXEC_PAGE_GUARD					0x100
#define EXEC_PAGE_NOCACHE				0x200
#define EXEC_PAGE_WRITECOMBINE			0x400

struct VirtualMemorySection {
	uint32_t BaseAddress;
	uint32_t RegionSize;
	uint32_t State; // free, reserved, commited
	uint32_t Protection; // read, write, execute
	uint32_t Type; // image, mapped, private
};

#define MAX_PATH 260

struct ModuleInfo {
	char Name[MAX_PATH];
	uint32_t ModuleBase;
	uint32_t Size;
#ifdef __linux__
	bool anonymous;
#endif
};

/*struct Registers {
	uint32_t edi;
	uint32_t esi;
	uint32_t ebp;
	uint32_t esp;

	uint32_t ebx;
	uint32_t edx;
	uint32_t ecx;
	uint32_t eax;
	uint32_t eflags;
};*/

class ExecutionObserver {
public :
	virtual unsigned int ExecutionBegin(void *ctx, void *address) = 0;
	virtual unsigned int ExecutionControl(void *ctx, void *address) = 0;
	virtual unsigned int ExecutionEnd(void *ctx) = 0;
	virtual unsigned int TranslationError(void *ctx, void *address) = 0;

	virtual void TerminationNotification(void *ctx) = 0;
};

typedef rev::ADDR_TYPE(*RevWrapperInitCallback)(void);

class ExecutionController {
public:
	virtual int GetState() const = 0;
	virtual bool SetPath(const wstring &) = 0;
	virtual bool SetCmdLine(const wstring &) = 0;
	virtual bool SetEntryPoint(void *ep) = 0;
	virtual bool SetExecutionFeatures(unsigned int feat) = 0;

	virtual bool Execute() = 0;
	// wait for the whole thing to terminate
	virtual bool WaitForTermination() = 0;

	virtual THREAD_T GetProcessHandle() = 0;
	virtual rev::ADDR_TYPE GetTerminationCode() = 0;

	virtual bool GetProcessVirtualMemory(VirtualMemorySection *&sections, int &sectionCount) = 0;
	virtual bool GetModules(ModuleInfo *&modules, int &moduleCount) = 0;
	virtual bool ReadProcessMemory(unsigned int base, unsigned int size, unsigned char *buff) = 0;
	virtual bool WriteProcessMemory(unsigned int base, unsigned int size, unsigned char *buff) = 0;

	virtual void SetExecutionObserver(ExecutionObserver *obs) = 0;
	virtual void SetTrackingObserver(rev::TrackCallbackFunc track, rev::MarkCallbackFunc mark) = 0;
	virtual void SetSymbolicHandler(rev::SymbolicHandlerFunc symb) = 0;

	virtual unsigned int ExecutionBegin(void *address, void *cbCtx) = 0;
	virtual unsigned int ExecutionControl(void *address, void *cbCtx) = 0;
	virtual unsigned int ExecutionEnd(void *cbCtx) = 0;
	virtual unsigned int TranslationError(void *address, void *cbCtx) = 0;

	virtual void DebugPrintf(const unsigned long printMask, const char *fmt, ...) = 0;

	// in-execution api
	virtual void GetFirstEsp(void *ctx, nodep::DWORD &esp) = 0;
	virtual void GetCurrentRegisters(void *ctx, rev::ExecutionRegs *registers) = 0;
	virtual void *GetMemoryInfo(void *ctx, void *ptr) = 0;
	virtual bool GetLastBasicBlockInfo(void *ctx, rev::BasicBlockInfo *bbInfo) = 0;
	virtual void MarkMemoryValue(void *ctx, rev::ADDR_TYPE addr, nodep::DWORD value) = 0;

};


DLL_EXECUTION_PUBLIC extern ExecutionController *NewExecutionController(uint32_t type);
DLL_EXECUTION_PUBLIC extern void DeleteExecutionController(ExecutionController *);

#endif

```

`Execution/Execution.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{668C607E-2E3B-435D-9390-56BDB152C363}</ProjectGuid>
    <RootNamespace>Execution</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_WINDOWS;_EXECUTION_EXPORTS;BLOCK_CACHE_READ_ONLY;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;BinLoader.lib;VirtualMemory.lib;loader.setup.lib;wrapper.setup.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <Profile>true</Profile>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetDir)$(TargetFileName) $(SolutionDir)jsdemo\
copy $(TargetDir)$(ProjectName).pdb $(SolutionDir)jsdemo\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <IgnoreStandardIncludePath>true</IgnoreStandardIncludePath>
      <UndefineAllPreprocessorDefinitions>true</UndefineAllPreprocessorDefinitions>
      <PreprocessorDefinitions>_WINDOWS;_EXECUTION_EXPORTS;BLOCK_CACHE_READ_ONLY;INPROCESS_EXECUTION_ONLY%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>ntdll.lib;BinLoader.lib;VirtualMemory.lib;loader.setup.lib;wrapper.setup.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetDir)$(TargetFileName) $(SolutionDir)jsdemo\
copy $(TargetDir)$(ProjectName).pdb $(SolutionDir)jsdemo\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\revtracer\cb.cpp" />
    <ClCompile Include="..\revtracer\crc32.cpp" />
    <ClCompile Include="..\revtracer\sync.cpp" />
    <ClCompile Include="CommonExecutionController.cpp" />
    <ClCompile Include="Debugger.cpp" />
    <ClCompile Include="DualAllocator.Linux.cpp" />
    <ClCompile Include="DualAllocator.Windows.cpp" />
    <ClCompile Include="ExternExecutionController.Linux.cpp" />
    <ClCompile Include="ExternExecutionController.Windows.cpp" />
    <ClCompile Include="InprocessExecutionController.cpp" />
    <ClCompile Include="CommonExecutionController2.cpp" />
    <ClCompile Include="LargeStack.cpp" />
    <ClCompile Include="Loader\Extern.Mapper.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Loader\Inproc.Mapper.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Loader\Mem.Mapper.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Loader\PE.ldr.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="TokenRingInit.Linux.cpp" />
    <ClCompile Include="TokenRingInit.Windows.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CommonExecutionController.h" />
    <ClInclude Include="DualAllocator.h" />
    <ClInclude Include="Execution.h" />
    <ClInclude Include="InprocessExecutionController.h" />
    <ClInclude Include="LargeStack.h" />
    <ClInclude Include="RiverStructs.h" />
    <ClInclude Include="ExternExecutionController.h">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="Loader\Abstract.Mapper.h" />
    <ClInclude Include="Loader\Extern.Mapper.h">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="Loader\Inproc.Mapper.h">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="Loader\Mem.Mapper.h">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="Loader\PE.ldr.h">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="Loader\Types.h" />
    <ClInclude Include="TokenRingInit.Linux.h" />
    <ClInclude Include="TokenRingInit.Windows.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Makefile" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Execution/ExternExecutionController.Linux.cpp`:

```cpp
#ifdef __linux__
#include "ExternExecutionController.h"

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <string.h>
#include <iostream>
#include "../libproc/os-linux.h"
#include "Debugger.h"
#include "DualAllocator.h"

#include "TokenRingInit.Linux.h"
#include "../wrapper.setup/Wrapper.Setup.h"

#include "../VirtualMemory/VirtualMem.h"

// TODO seach for this lib in LD_LIBRARY_PATH
//#define LOADER_PATH "/home/alex/river/tracer.simple/inst/lib/libloader.so"
#define LOADER_PATH "/home/teodor/wrk/tools/river.sdk/lin/lib/libloader.so"

static int ChildRunning = 1;
//static void *hMapMemoryAddress = nullptr;

dbg::Debugger debugger;

unsigned long ExternExecutionController::ControlThread() {
	bool bRunning = true;
	DWORD exitCode;

	//HANDLE hDbg = 0;
	FILE_T hOffs = 0;

	printf("[ControlThread] Started controlthread!\n");

	do {

		hDbg = OPEN_FILE_W("debug.log");

		if (FAIL_OPEN_FILE(hDbg)) {
			//TerminateProcess(hProcess, 0);
			break;
		}

		hOffs = OPEN_FILE_W("bbs1.txt");

		if (FAIL_OPEN_FILE(hOffs)) {
			break;
		}


		while (bRunning) {
			do {
				if (!ChildRunning) {
					break;
				}

			} while (!wrapper.pExports->tokenRing->Wait(CONTROL_PROCESS_TOKENID, false));
			updated = false;

			while (!ipc.pExports->debugLog->IsEmpty()) {
				int read;
				DWORD written;
				ipc.pExports->debugLog->Read(debugBuffer, sizeof(debugBuffer)-1, read);
				
				BOOL ret;
				WRITE_FILE(hDbg, debugBuffer, read, written, ret);
			}

			if (!ChildRunning) {
				break;
			}

			switch (ipc.pExports->ipcData->type) {
			case REPLY_MEMORY_ALLOC:
			case REPLY_MEMORY_FREE:
			case REPLY_TAKE_SNAPSHOT:
			case REPLY_RESTORE_SNAPSHOT:
			case REPLY_INITIALIZE_CONTEXT:
			case REPLY_CLEANUP_CONTEXT:
			case REPLY_SYSCALL_CONTROL:
			case REPLY_BRANCH_HANDLER:
				DEBUG_BREAK;
				break;

			case REQUEST_DUMMY:
				ipc.pExports->ipcData->type = REPLY_DUMMY;
				break;

			case REQUEST_MEMORY_ALLOC: {
				DWORD offset;
				ipc.pExports->ipcData->type = REPLY_MEMORY_ALLOC;
				ipc.pExports->ipcData->data.asMemoryAllocReply.pointer = shmAlloc->Allocate(ipc.pExports->ipcData->data.asMemoryAllocRequest, offset);
				ipc.pExports->ipcData->data.asMemoryAllocReply.offset = offset;
				break;
			}

			case REQUEST_BRANCH_HANDLER: {
				void *context = ipc.pExports->ipcData->data.asBranchHandlerRequest.executionEnv;
				ipc::ADDR_TYPE next = ipc.pExports->ipcData->data.asBranchHandlerRequest.nextInstruction;
				ipc.pExports->ipcData->type = REPLY_BRANCH_HANDLER;
				execState = SUSPENDED;
				if (EXECUTION_TERMINATE == (ipc.pExports->ipcData->data.asBranchHandlerReply = BranchHandlerFunc(context, this, next))) {
					bRunning = false;
				}
				break;
			}

			case REQUEST_SYSCALL_CONTROL:
				ipc.pExports->ipcData->type = REPLY_SYSCALL_CONTROL;
				break;

			default:
				printf("[Parent] Received message with number %lu\n", ipc.pExports->ipcData->type);
				DEBUG_BREAK;
				break;
			}

			wrapper.pExports->tokenRing->Release(CONTROL_PROCESS_TOKENID);
		}


	} while (false);

	CLOSE_FILE(hDbg);

	execState = TERMINATED;

	observer->TerminationNotification(context); // this needs to be the last thing called!
	return 0;
}

void *ControlThreadFunc(void *ptr) {
	ExternExecutionController *ctr = (ExternExecutionController *)ptr;
	ctr->ControlThread();
	return nullptr;
}

ExternExecutionController::ExternExecutionController() {
	shmAlloc = nullptr;
}

bool ExternExecutionController::SetEntryPoint() {
	return false;
}

THREAD_T ExternExecutionController::GetProcessHandle() {
	// N/A for the linux version
	return -1;
}

rev::ADDR_TYPE ExternExecutionController::GetTerminationCode() {
	return wrapper.pExports->getTerminationCode();
}

unsigned long GetLibcAddress(pid_t pid) {
	struct map_iterator mi;
	struct map_prot mp;
	unsigned long hi;
	unsigned long segbase, mapoff;


	if (maps_init(&mi, pid) < 0) {
		printf("Cannot find maps for pid %d\n", pid);
		return 0;
	}

	while (maps_next(&mi, &segbase, &hi, &mapoff, &mp)) {
		const char *p = strrchr(mi.path, '/');
		p = (nullptr == p) ? mi.path : (p + 1);

		printf("[Parent] found lib %s\n", p);
		if (0 == strncmp("libc", p, 4)) {
			printf("[Parent] Found child mapping for libc %p\n", (void*)segbase);
			maps_close(&mi);
			return segbase;
		}

	}
	maps_close(&mi);
	return 0;
}

#define MAX_FUNC_LIST 32
struct libc_ifunc_impl
{
	/* The name of function to be tested.  */
	const char *name;
	/* The address of function to be tested.  */
	void(*fn) (void);
	/* True if this implementation is usable on this machine.  */
	bool usable;
};

typedef size_t(*__libc_ifunc_impl_list_handle)(const char *name,
	struct libc_ifunc_impl *array,
	size_t max);
static __libc_ifunc_impl_list_handle my__libc_ifunc_impl_list;


bool ExternExecutionController::PatchProcess() {
	LIB_T libcHandler;
	struct libc_ifunc_impl func_list[MAX_FUNC_LIST];

	std::vector<std::string> func_names = {
		"bcopy", "bzero", "memchr", "memcmp", "__memmove_chk",
		"memmove", "memrchr", "__memset_chk", "memset",
		"rawmemchr", "stpncpy", "stpcpy", "strcasecmp",
		"strcasecmp_l", "strcat", "strchr", "strcmp",
		"strcpy", "strcspn", "strncasecmp", "strncasecmp_l",
		"strncat", "strncpy", "strnlen", "strpbrk", "strrchr",
		"strspn", "wcschr", "wcscmp", "wcscpy", "wcslen", "wcsrchr",
		"wmemcmp", "__memcpy_chk", "memcpy", "__mempcpy_chk",
		"mempcpy", "strlen", "strncmp"
	};

	libcHandler = GET_LIB_HANDLER("libc.so.6");
	if (nullptr == libcHandler) {
		DEBUG_BREAK;
		return false;
	}

	unsigned long remoteLibc = GetLibcAddress(pid);
	unsigned long libDelta = remoteLibc - *(unsigned long *)libcHandler;

	printf("[Parent] libc parent %08lx; child %08lx; delta %08lx\n", *(unsigned long *)libcHandler, remoteLibc, libDelta);

	my__libc_ifunc_impl_list = (__libc_ifunc_impl_list_handle)dlsym(
		libcHandler, "__libc_ifunc_impl_list");
	if (nullptr == my__libc_ifunc_impl_list) {
		DEBUG_BREAK;
		return false;
	}

	for (auto it = func_names.begin(); it != func_names.end(); ++it) {
		ADDR_TYPE detourAddr = nullptr;
		memset(func_list, 0,
			MAX_FUNC_LIST * sizeof(struct libc_ifunc_impl));
		(my__libc_ifunc_impl_list)(it->c_str(), func_list, MAX_FUNC_LIST);
		for (int i = 0; i < MAX_FUNC_LIST; ++i) {
			if (!func_list[i].name || !func_list[i].fn)
				break;
			char *ia32 = strstr((char*)func_list[i].name, "ia32");
			if (nullptr != ia32 && (strlen(ia32) == strlen("ia32"))) {
				detourAddr = (ADDR_TYPE)func_list[i].fn;
				break;
			}
		}

		if (nullptr == detourAddr) {
			DEBUG_BREAK;
			return false;
		}
		for (int i = 0; i < MAX_FUNC_LIST; ++i) {
			if (!func_list[i].name || !func_list[i].fn)
				break;
			if ((ADDR_TYPE)func_list[i].fn != detourAddr) {
				revtracer.pConfig->hooks[revtracer.pConfig->hookCount].originalAddr = (ADDR_TYPE)((unsigned long)func_list[i].fn + libDelta);
				revtracer.pConfig->hooks[revtracer.pConfig->hookCount].detourAddr = (ADDR_TYPE)((unsigned long)detourAddr + libDelta);
				revtracer.pConfig->hookCount++;
			}
		}

	}
	return true;
}



bool ExternExecutionController::WaitForTermination() {
	int ret;
	JOIN_THREAD(hControlThread, ret);
	return ret;
}

unsigned int ExternExecutionController::ExecutionBegin(void *address, void *cbCtx) {
	if (!PatchProcess()) {
		execState = ERR;
		return EXECUTION_TERMINATE;
	}
	else {
		execState = SUSPENDED_AT_START;
		return observer->ExecutionBegin(cbCtx, address);
	}
}


// reads the child process memory
bool ExternExecutionController::ReadProcessMemory(unsigned int base, unsigned int size, unsigned char *buff) {
	return true;
}

bool ExternExecutionController::WriteProcessMemory(unsigned int base, unsigned int size, unsigned char *buff) {
	return true;
}

void ExternExecutionController::ConvertWideStringPath(char *result, size_t len) {
	memset(result, 0, len);
	const wchar_t *pathStream = path.c_str();
	std::wcstombs(result, pathStream, len);
	std::cout << "[EXTERN EXECUTION] Tracee path is [" << result << "]\n";
}

void DebugPrintVMMap(pid_t pid) {
	struct map_iterator mi;
	struct map_prot mp;
	unsigned long hi;
	unsigned long segbase, mapoff;


	printf("[%d] debug vmmap ........................................\n", pid);
	if (maps_init (&mi, pid) < 0) {
		printf("Cannot find maps for pid %d\n", pid);
		return;
	}

	while (maps_next (&mi, &segbase, &hi, &mapoff, &mp)) {
		printf("path : %s base addr : %08lx high %08lx\n", mi.path, segbase, hi);
	}

	maps_close(&mi);
}

unsigned long GetLoaderAddress(pid_t pid) {
	struct map_iterator mi;
	struct map_prot mp;
	unsigned long hi;
	unsigned long segbase, mapoff;


	if (maps_init (&mi, pid) < 0) {
		printf("Cannot find maps for pid %d\n", pid);
		return 0;
	}

	while (maps_next (&mi, &segbase, &hi, &mapoff, &mp)) {
		if (nullptr != strstr(mi.path, LOADER_PATH)) {
			printf("[Parent] Found child mapping for ld_preload %p\n", (void*)segbase);
			maps_close(&mi);
			return segbase;
		}

	}
	maps_close(&mi);
	return 0;
}

bool ExternExecutionController::InitLibraryLayout() {
	libraryLayout = (ext::LibraryLayout *)vmem::GetFreeRegion(pid, getpid(), sizeof(*libraryLayout), 0x10000);
	printf("[Parent] libraryLayout will be @ %p <%ld,%d>\n", libraryLayout, pid, getpid());
	printf("[Parent] mmap(%p, %08x)\n", libraryLayout, (sizeof(*libraryLayout) + 0xFFF) & ~0xFFF);
	if (MAP_FAILED == mmap(libraryLayout, (sizeof(*libraryLayout) + 0xFFF) & ~0xFFF, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0)) {
		printf("[Parent] Couldn't map loaderImports.libraries; errno %d\n", errno);
		return false;
	}
	//void *ret1 = VirtualAllocEx(hProcess, libraryLayout, sizeof(*libraryLayout), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	//void *ret2 = VirtualAlloc(libraryLayout, sizeof(*libraryLayout), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	return true;
}

bool ExternExecutionController::InitializeWrapper() {
	if (!LoadExportedName(wrapper.module, wrapper.base, "wrapperImports", wrapper.pImports) ||
		!LoadExportedName(wrapper.module, wrapper.base, "wrapperExports", wrapper.pExports)
		) {
		return false;
	}

	wrapper.pImports->libraries = libraryLayout;
	InitWrapperOffsets(libraryLayout, wrapper.pImports);

	if (!revwrapper::InitTokenRing(wrapper.pExports->tokenRing, 2)) {
		printf("[Parent] Token ring initialization failure. Errno %d\n", errno);
		return false;
	}
	return true;
}

bool ExternExecutionController::InitializeIpcLib() {
	if (!LoadExportedName(ipc.module, ipc.base, "ipcImports", ipc.pImports) ||
		!LoadExportedName(ipc.module, ipc.base, "ipcExports", ipc.pExports)
	) {
		return false;
	}

	ipc.pImports->mapMemory = loader.vExports.mapMemory;
	ipc.pImports->vsnprintf_sFunc = wrapper.pExports->formattedPrint;
	ipc.pImports->ipcToken = wrapper.pExports->tokenRing;

	return true;
}

bool ExternExecutionController::InitializeRevtracer() {
	if (!LoadExportedName(revtracer.module, revtracer.base, "revtracerConfig", revtracer.pConfig) ||
		!LoadExportedName(revtracer.module, revtracer.base, "revtracerImports", revtracer.pImports) ||
		!LoadExportedName(revtracer.module, revtracer.base, "revtracerExports", revtracer.pExports)
		) {
		return false;
	}

	revtracer.pImports->lowLevel.ntTerminateProcess = (rev::ADDR_TYPE)wrapper.pExports->terminateProcess;
	revtracer.pImports->lowLevel.vsnprintf_s = (rev::ADDR_TYPE)wrapper.pExports->formattedPrint;
	revtracer.pImports->lowLevel.ntWriteFile = (rev::ADDR_TYPE)nullptr;
#ifdef DUMP_BLOCKS
	revtracer.pImports->lowLevel.ntWriteFile = GET_PROC_ADDRESS(wrapper.module, wrapper.base, "CallWriteFile");
#endif

	revtracer.pImports->dbgPrintFunc = (rev::DbgPrintFunc)ipc.pExports->debugPrint;

	/* Memory management function */
	revtracer.pImports->memoryAllocFunc = ipc.pExports->memoryAlloc;
	revtracer.pImports->memoryFreeFunc = ipc.pExports->memoryFree;

	/* VM Snapshot control */
	revtracer.pImports->takeSnapshot = ipc.pExports->takeSnapshot;
	revtracer.pImports->restoreSnapshot = ipc.pExports->restoreSnapshot;

	/* Execution callbacks */
	revtracer.pImports->initializeContext = ipc.pExports->initializeContext;
	revtracer.pImports->cleanupContext = ipc.pExports->cleanupContext;
	revtracer.pImports->branchHandler = ipc.pExports->branchHandler;
	revtracer.pImports->syscallControl = ipc.pExports->syscallControl;

	/* IpcLib initialization */
	revtracer.pImports->ipcLibInitialize;

	//tmpRevApi.lowLevel.ntAllocateVirtualMemory = GET_PROC_ADDRESS(wrapper.module, wrapper.base, "CallAllocateMemoryHandler");
	//tmpRevApi.lowLevel.ntFreeVirtualMemory = GET_PROC_ADDRESS(wrapper.module, wrapper.base, "CallFreeMemoryHandler");

	if (nullptr != trackCb) {
		revtracer.pImports->trackCallback = trackCb;
	}

	if (nullptr != markCb) {
		revtracer.pImports->markCallback = markCb;
	}

	if (nullptr != symbCb) {
		revtracer.pImports->symbolicHandler = symbCb;
	}

	gfe = revtracer.pExports->getFirstEsp;
	gcr = revtracer.pExports->getCurrentRegisters;
	gmi = revtracer.pExports->getMemoryInfo;
	mmv = revtracer.pExports->markMemoryValue;
	glbbi = revtracer.pExports->getLastBasicBlockInfo;

	revtracer.pConfig->context = nullptr;
	/*for (unsigned i = 0; i < 0x100; i++) {
		loader.pImports->segmentOffsets[i] = 
			debugger.GetAndResolveModuleAddress((DWORD)loader.pImports->segments + i * 4);
	}*/

	revtracer.pConfig->hookCount = 0;
	revtracer.pConfig->featureFlags = featureFlags;
	//revtracer.pConfig->sCons = symbolicConstructor;

#ifdef DUMP_BLOCKS
	revtracer.pConfig->dumpBlocks = TRUE;

	hBlocksFd = OPEN_FILE_RW("blocks.bin");
#else
	revtracer.pConfig->dumpBlocks = FALSE;
	revtracer.pConfig->hBlocks = nullptr;
#endif

	return true;
	
}

bool ExternExecutionController::Execute() {

	pid_t child;
	int ret, status;
	struct user_regs_struct regs;

	char arg[MAX_PATH];
	DWORD entryPoint;

	ConvertWideStringPath(arg, MAX_PATH);
	//entryPoint = GetEntryPoint(arg);

	void *shmAddress = nullptr;
	const char* ld_library_path = getenv("LD_LIBRARY_PATH");
	printf("[Parent] Retrieved path %s\n", ld_library_path);
	child = fork();
	if(child == 0) {
		ptrace(PTRACE_TRACEME, 0, nullptr, nullptr);

		char *const args[] = {arg, nullptr};
		char env[MAX_PATH] = "LD_PRELOAD=";
		strcat(env, LOADER_PATH);
		char env_path[MAX_PATH] = "LD_LIBRARY_PATH=";
		strcat(env_path, ld_library_path);
		char *const envs[] = {env, env_path, nullptr};
		int ret = execve(arg, args, envs);

		if (ret == -1) {
			printf("Cannot start child process %s. Execve failed!\n", arg);
		}
	}

	else {
		pid = child;
		debugger.Attach(child);
		ret = debugger.Run(PTRACE_CONT);
		debugger.PrintEip();
		debugger.PrintRegs();

		InitLibraryLayout();
		printf(
			"[Parent] Library layout @ %p\n",
			libraryLayout
		);

		loader.base = GetLoaderAddress(child);
		CreateModule(LOADER_PATH, loader.module);

		if (!loader.module) {
			printf(
				"[Extern Execution] Please set LD_LIBRARY_PATH correctly. Modules not found\n"
				"\tlibloader.so = %p @ %08lx\n",
				loader.module, loader.base
			);
			DEBUG_BREAK;
		}
		printf("[Parent] loader found at address %08lx\n", loader.base);
		

		LoadExportedName(loader.module, loader.base, "loaderConfig", loader.pConfig);
		LoadExportedName(loader.module, loader.base, "loaderImports", loader.pImports);
		LoadExportedName(loader.module, loader.base, "loaderExports", loader.pExports);
		debugger.GetData((DWORD)loader.pExports, (unsigned char *)&loader.vExports, sizeof(loader.vExports));
		printf(
			"[Loader] Layout:\n"
			"\tpConfig = %p\n"
			"\tpImports = %p\n"
			"\tpExports = %p\n"
			"\tpExports->mapMemory = %p\n",
			loader.pConfig,
			loader.pImports,
			loader.pExports,
			loader.vExports.mapMemory
		);


		debugger.PutData((DWORD)&loader.pImports->libraries, (unsigned char *)&libraryLayout, sizeof(libraryLayout));


		// is this safe to be removed?
		/*debugger.InsertBreakpoint(entryPoint);
		ret = debugger.Run(PTRACE_CONT);
		debugger.PrintEip();
		if (ret == -1)
			return false;
		debugger.DeleteBreakpoint(entryPoint);*/

		//DebugPrintVMMap(child);

		CreateModule(L"libipc.so", ipc.module);
		CreateModule(L"librevtracerwrapper.so", wrapper.module);
		CreateModule(L"revtracer.dll", revtracer.module);

		if (!ipc.module || !wrapper.module || !revtracer.module) {
			printf(
				"[Extern Execution] Please set LD_LIBRARY_PATH correctly. Modules not found\n"
				"\tlibipc.so = %p\n"
				"\tlibrevtracerwrapper.so = %p\n"
				"\trevtracer.dll = %p\n",
				ipc.module,
				wrapper.module,
				revtracer.module
			);
			DEBUG_BREAK;
		}

		DWORD dwIpcLibSize = (ipc.module->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
		//DWORD dwLibPthreadSize = (hPthreadModule->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
		DWORD dwRevWrapperSize = (wrapper.module->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
		DWORD dwRevTracerSize = (revtracer.module->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
		DWORD dwTotalSize = dwIpcLibSize + /*dwLibPthreadSize +*/ dwRevWrapperSize + dwRevTracerSize;

		// TODO dirty hack - sharedMemoryAddress offset in struct
		shmAddress = (void*)debugger.GetAndResolveModuleAddress((DWORD)&(loader.pConfig->shmBase));
		printf("[Parent] Received shared mem address %08lx, while reading %p\n", (DWORD)shmAddress, &(loader.pConfig->shmBase));

		// initialize dual allocator with child pid
		shmAlloc = new DualAllocator(1 << 30, child, "thug_life", 0, 0);
		shmAlloc->SetBaseAddress((DWORD)shmAddress);
		shmAddress = (void*)shmAlloc->AllocateFixed((DWORD)shmAddress, dwTotalSize);

		if (shmAddress == (void *)-1) {
			printf("[Parent] Could not find enough space to map libraries. Exiting.");
			return -1;
		}

		printf("[Parent] Mapped shared memory at address %08lx\n", (DWORD)shmAddress);

		//TODO dirty hack - base members offsets in struct
		wrapper.base = debugger.GetAndResolveModuleAddress((DWORD)&loader.pConfig->osData.linux.mos[0].base);
			//(DWORD)(loader.pConfig->osData.linux.mos + 2) + 4);
		ipc.base = debugger.GetAndResolveModuleAddress((DWORD)&loader.pConfig->osData.linux.mos[1].base);
			//(DWORD)loader.pConfig->osData.linux.mos + 4);
		revtracer.base = debugger.GetAndResolveModuleAddress((DWORD)&loader.pConfig->osData.linux.mos[2].base);
			//(DWORD)(loader.pConfig->osData.linux.mos + 3) + 4);

		printf("[Parent] Found libraries mapping in shared memory revwrapper@%lx ipclib@%lx revtracer@%lx mapMemory %08lx\n",
			wrapper.base, ipc.base, revtracer.base, (DWORD)loader.pExports->mapMemory);


		if (!InitializeWrapper()) {
			DEBUG_BREAK;
		}
		InitializeIpcLib();
		//DebugPrintVMMap(child);
		InitializeRevtracer();

		//DebugPrintVMMap(getpid());
		// Setup token ring pids
		//wrapper.pExports->tokenRing->Init(0);
		revwrapper::InitTokenRing(wrapper.pExports->tokenRing, 2);
		
		printf("[Parent] Passing execution control to revtracerPerform %08lx\n", (unsigned long)revtracer.pExports->revtracerPerform);
		// ipcToken object exists and called init and use.
		//debugger.SetEip((unsigned long)revtracer.pExports->revtracerPerform);
		
		debugger.PutData((DWORD)&loader.pConfig->entryPoint, (unsigned char *)&revtracer.pExports->revtracerPerform, sizeof(unsigned long));
		
		debugger.GetData((DWORD)&loader.pConfig->osData.linux.retAddr, (unsigned char *)&entryPoint, sizeof(entryPoint));
		printf("[Parent] First address to be translated is %08lx\n", (DWORD)entryPoint);

		revtracer.pConfig->entryPoint = (void*)entryPoint;
		printf("[Parent] Entrypoint setup for revtracer to %08lx\n", (DWORD)revtracer.pConfig->entryPoint);

		CREATE_THREAD(hControlThread, ControlThreadFunc, this, ret);
		execState = RUNNING;

		ChildRunning = debugger.Run(PTRACE_CONT);
		debugger.PrintEip();
		debugger.PrintRegs();

		int read;
		DWORD written;
		ipc.pExports->debugLog->Read(debugBuffer, sizeof(debugBuffer) - 1, read);

		BOOL _ret;
		WRITE_FILE(hDbg, debugBuffer, read, written, _ret);

		/*DEBUG_BREAK;

		while (-1 != debugger.Run(PTRACE_SINGLESTEP)) {
			//debugger.PrintEip();
			debugger.PrintRegs();
		}
		debugger.PrintEip();
		debugger.PrintRegs();*/

		printf("[Parent] Remember: revwrapper@%lx ipclib@%lx revtracer@%lx mapMemory %08lx\n",
			wrapper.base, ipc.base, revtracer.base, (DWORD)loader.pExports->mapMemory);

		ipc.pExports->debugLog->Read(debugBuffer, sizeof(debugBuffer)-1, read);

		WRITE_FILE(hDbg, debugBuffer, read, written, _ret);

		if (ChildRunning != 0) {
			printf("[Execution] Child %d tracing failed\n.", child);
			DEBUG_BREAK;
		}

		printf("[Execution] Child %d exited normally.\n", child);

		return ret == TRUE;
	}

}
#endif

```

`Execution/ExternExecutionController.Windows.cpp`:

```cpp
#include "ExternExecutionController.h"

#include "../BinLoader/LoaderAPI.h"
#include "../BinLoader/Extern.Mapper.h"

#include "TokenRingInit.Windows.h"

#include "RiverStructs.h"

#include "../wrapper.setup/Wrapper.Setup.h"
#include "../loader.setup/Loader.Setup.h"

#include "../VirtualMemory/VirtualMem.h"

//#define DUMP_BLOCKS

#include <Psapi.h>
#include <io.h>
#include <fcntl.h>

typedef long NTSTATUS;
typedef bool(*GetHandlerCallback)(void *);

//NtYieldExecutionFunc ntdllYieldExecution;

/*namespace ipc {
	void NtDllNtYieldExecution() {
		::ntdllYieldExecution();
	}
};*/

ExternExecutionController::ExternExecutionController() {
	shmAlloc = NULL;
}

bool ExternExecutionController::SetEntryPoint() {
	return false;
}

bool ExternExecutionController::InitializeAllocator() {
	SYSTEM_INFO si;
	memset(&si, 0, sizeof(si));

	GetSystemInfo(&si);

	shmAlloc = new DualAllocator(1 << 30, hProcess, "Local\\MumuMem", si.dwAllocationGranularity, 0);
	return NULL != shmAlloc;
}

bool ExternExecutionController::InitLibraryLayout() {
	libraryLayout = (ext::LibraryLayout *)vmem::GetFreeRegion(hProcess, GetCurrentProcess(), sizeof(*libraryLayout), 0x10000);

	void *ret1 = VirtualAllocEx(hProcess, libraryLayout, sizeof(*libraryLayout), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	void *ret2 = VirtualAlloc(libraryLayout, sizeof(*libraryLayout), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	return true;
}

bool ExternExecutionController::MapLoader() {
	CreateModule(L"loader.dll", loader.module);
	DWORD dwWritten;
	bool bRet = false;
	do {

		if (!loader.module->IsValid()) {
			DEBUG_BREAK;
			break;
		}

		loader.base = (BASE_PTR)vmem::GetFreeRegion(hProcess, loader.module->GetRequiredSize(), 0x10000);
		MapModuleExtern(loader.module, loader.base, hProcess);

		FlushInstructionCache(hProcess, (LPVOID)loader.base, loader.module->GetRequiredSize());

		if (!InitLibraryLayout()) {
			DEBUG_BREAK;
			break;
		}


		ldr::LoaderImports ldrAPI;
		InitLoaderOffsets(libraryLayout, &ldrAPI);
		ldrAPI.libraries = libraryLayout;

		if (!LoadExportedName(loader.module, loader.base, "loaderConfig", loader.pConfig) ||
			!LoadExportedName(loader.module, loader.base, "loaderImports", loader.pImports) ||
			!LoadExportedName(loader.module, loader.base, "loaderExports", loader.pExports)
		) {
			DEBUG_BREAK;
			break;
		}

		if (FALSE == ::WriteProcessMemory(hProcess, libraryLayout, (LPCVOID)libraryLayout, sizeof(*libraryLayout), &dwWritten)) {
			DEBUG_BREAK;
			break;
		}

		if (FALSE == ::WriteProcessMemory(hProcess, loader.pImports, &ldrAPI, sizeof(ldrAPI), &dwWritten)) {
			DEBUG_BREAK;
			break;
		}

		if (FALSE == ::ReadProcessMemory(hProcess, loader.pExports, &loader.vExports, sizeof(loader.vExports), &dwWritten)) {
			DEBUG_BREAK;
			break;
		}

		memset(&loader.vConfig, 0, sizeof(loader.vConfig));
		loader.vConfig.sharedMemory = shmAlloc->CloneTo(hProcess);

		bRet = true;
	} while (false);
	delete loader.module;
	loader.module = nullptr;
	return bRet;
}

DWORD CharacteristicsToDesiredAccess(DWORD c) {
	DWORD r = 0;

	r |= (c & IMAGE_SCN_MEM_READ) ? FILE_MAP_READ : 0;
	r |= (c & IMAGE_SCN_MEM_WRITE) ? FILE_MAP_WRITE : 0;
	r |= (c & IMAGE_SCN_MEM_EXECUTE) ? FILE_MAP_EXECUTE : 0;
	return r;
}

bool ExternExecutionController::InitializeWrapper() {
	if (!LoadExportedName(wrapper.module, wrapper.base, "wrapperImports", wrapper.pImports) ||
		!LoadExportedName(wrapper.module, wrapper.base, "wrapperExports", wrapper.pExports)
	) {
		return false;
	}

	InitWrapperOffsets(libraryLayout, wrapper.pImports);


	unsigned int pids[2] = {
		GetCurrentProcessId(),
		pid
	};

	revwrapper::InitTokenRing(wrapper.pExports->tokenRing, 2, pids);
	return true;
}

bool ExternExecutionController::InitializeIpcLib() {
	if (!LoadExportedName(ipc.module, ipc.base, "ipcImports", ipc.pImports) ||
		!LoadExportedName(ipc.module, ipc.base, "ipcExports", ipc.pExports) ||
		!LoadExportedName(ipc.module, ipc.base, "IsProcessorFeaturePresent", ipc.pIPFPFunc)
	) {
		return false;
	}

	ipc.pImports->mapMemory = loader.vExports.mapMemory;
	ipc.pImports->vsnprintf_sFunc = wrapper.pExports->formattedPrint;
	ipc.pImports->ipcToken = wrapper.pExports->tokenRing;
	
	return true;
}

bool ExternExecutionController::InitializeRevtracer() {
	if (!LoadExportedName(revtracer.module, revtracer.base, "revtracerConfig", revtracer.pConfig) ||
		!LoadExportedName(revtracer.module, revtracer.base, "revtracerImports", revtracer.pImports) ||
		!LoadExportedName(revtracer.module, revtracer.base, "revtracerExports", revtracer.pExports)
		) {
		return false;
	}

	revtracer.pImports->lowLevel.ntTerminateProcess = (rev::ADDR_TYPE)wrapper.pExports->terminateProcess;
	revtracer.pImports->lowLevel.vsnprintf_s = (rev::ADDR_TYPE)wrapper.pExports->formattedPrint;
	revtracer.pImports->lowLevel.ntWriteFile = (rev::ADDR_TYPE)nullptr;
#ifdef DUMP_BLOCKS
	revtracer.pImports->lowLevel.ntWriteFile = GET_PROC_ADDRESS(wrapper.module, wrapper.base, "CallWriteFile");
#endif

	revtracer.pImports->dbgPrintFunc = (rev::DbgPrintFunc)ipc.pExports->debugPrint;

	/* Memory management function */
	revtracer.pImports->memoryAllocFunc = ipc.pExports->memoryAlloc;
	revtracer.pImports->memoryFreeFunc = ipc.pExports->memoryFree;

	/* VM Snapshot control */
	revtracer.pImports->takeSnapshot = ipc.pExports->takeSnapshot;
	revtracer.pImports->restoreSnapshot = ipc.pExports->restoreSnapshot;

	/* Execution callbacks */
	revtracer.pImports->initializeContext = ipc.pExports->initializeContext;
	revtracer.pImports->cleanupContext = ipc.pExports->cleanupContext;
	revtracer.pImports->branchHandler = ipc.pExports->branchHandler;
	revtracer.pImports->syscallControl = ipc.pExports->syscallControl;

	/* IpcLib initialization */
	revtracer.pImports->ipcLibInitialize;

	//tmpRevApi.lowLevel.ntAllocateVirtualMemory = GET_PROC_ADDRESS(wrapper.module, wrapper.base, "CallAllocateMemoryHandler");
	//tmpRevApi.lowLevel.ntFreeVirtualMemory = GET_PROC_ADDRESS(wrapper.module, wrapper.base, "CallFreeMemoryHandler");

	if (nullptr != trackCb) {
		revtracer.pImports->trackCallback = trackCb;
	}

	if (nullptr != markCb) {
		revtracer.pImports->markCallback = markCb;
	}

	if (nullptr != symbCb) {
		revtracer.pImports->symbolicHandler = symbCb;
	}

	gfe = revtracer.pExports->getFirstEsp;
	gcr = revtracer.pExports->getCurrentRegisters;
	gmi = revtracer.pExports->getMemoryInfo;
	mmv = revtracer.pExports->markMemoryValue;
	glbbi = revtracer.pExports->getLastBasicBlockInfo;

	revtracer.pConfig->context = nullptr;
	InitSegments(hMainThread, revtracer.pConfig->segmentOffsets);
	revtracer.pConfig->hookCount = 0;
	revtracer.pConfig->featureFlags = featureFlags;
	//revtracer.pConfig->sCons = symbolicConstructor;

#ifdef DUMP_BLOCKS
	revCfg->dumpBlocks = TRUE;

	HANDLE hBlocks = CreateFile(
		"blocks.bin",
		GENERIC_WRITE,
		FILE_SHARE_READ,
		NULL,
		CREATE_ALWAYS,
		0,
		NULL
	);

	if (FALSE == DuplicateHandle(
		GetCurrentProcess(),
		hBlocks,
		hProcess,
		&revCfg->hBlocks,
		0,
		FALSE,
		DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS
	)) {
		CloseHandle(hBlocks);
		return false;
	}
#else
	revtracer.pConfig->dumpBlocks = FALSE;
	revtracer.pConfig->hBlocks = INVALID_HANDLE_VALUE;
#endif

	return true;
}

bool ExternExecutionController::MapTracer() {
	CreateModule(L"revtracer-wrapper.dll", wrapper.module);
	CreateModule(L"ipclib.dll", ipc.module);
	CreateModule(L"revtracer.dll", revtracer.module);
	bool bRet = false;
	do {
		DWORD dwWrapperSize = (wrapper.module->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
		DWORD dwIpcLibSize = (ipc.module->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
		DWORD dwRevTracerSize = (revtracer.module->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
		DWORD dwTotalSize = dwWrapperSize + dwIpcLibSize + dwRevTracerSize;

		DWORD dwOffset;

		// Bases are module bases int the child/parent process address space
		DWORD libs = (DWORD)shmAlloc->Allocate(dwTotalSize, dwOffset);
		wrapper.base = (BASE_PTR)libs;
		ipc.base = (BASE_PTR)(libs + dwWrapperSize);
		revtracer.base = (BASE_PTR)(libs + dwWrapperSize + dwIpcLibSize);

		// Offsets are displacements relative to the shared memory
		DWORD wrapperOffset = dwOffset;
		DWORD ipcLibOffset = wrapperOffset + dwWrapperSize;
		DWORD revTracerOffset = ipcLibOffset + dwIpcLibSize;

		//TODO fix this map
		MapModule2(wrapper.module, wrapper.base);
		MapModule2(ipc.module, ipc.base);
		MapModule2(revtracer.module, revtracer.base);

		printf(
			"wrapper@0x%08x\nipclib@0x%08x\nrevtracer@0x%08x\n", 
			(DWORD)wrapper.base, 
			(DWORD)ipc.base,
			(DWORD)revtracer.base
		);
		FlushInstructionCache(hProcess, (BYTE*)libs, dwTotalSize);


		DWORD sCount = 0;
		//TODO implement GetSectionCount for Elf loader
		DWORD dwWrapperSections = dynamic_cast<ldr::FloatingPE*>(wrapper.module)->GetSectionCount();
		for (DWORD i = 0; i < dwWrapperSections; ++i) {
			const ldr::PESection *sec = dynamic_cast<ldr::FloatingPE*>(wrapper.module)->GetSection(i);

			if (sec->header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
				continue;
			}

			loader.vConfig.osData.windows.sections[sCount].mappingAddress = (ldr::ADDR_TYPE)((BYTE *)wrapper.base + sec->header.VirtualAddress);
			loader.vConfig.osData.windows.sections[sCount].mappingSize = (sec->header.VirtualSize + 0xFFFF) & ~0xFFFF;
			loader.vConfig.osData.windows.sections[sCount].sectionOffset = wrapperOffset + sec->header.VirtualAddress;
			loader.vConfig.osData.windows.sections[sCount].desiredAccess = CharacteristicsToDesiredAccess(sec->header.Characteristics);
			sCount++;
		}

		DWORD dwIpcLibSections = dynamic_cast<ldr::FloatingPE*>(ipc.module)->GetSectionCount();
		for (DWORD i = 0; i < dwIpcLibSections; ++i) {
			const ldr::PESection *sec = dynamic_cast<ldr::FloatingPE*>(ipc.module)->GetSection(i);

			if (sec->header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
				continue;
			}

			loader.vConfig.osData.windows.sections[sCount].mappingAddress = (ldr::ADDR_TYPE)((BYTE *)ipc.base + sec->header.VirtualAddress);
			loader.vConfig.osData.windows.sections[sCount].mappingSize = (sec->header.VirtualSize + 0xFFFF) & ~0xFFFF;
			loader.vConfig.osData.windows.sections[sCount].sectionOffset = ipcLibOffset + sec->header.VirtualAddress;
			loader.vConfig.osData.windows.sections[sCount].desiredAccess = CharacteristicsToDesiredAccess(sec->header.Characteristics);
			sCount++;
		}

		DWORD dwRevTracerSections = dynamic_cast<ldr::FloatingPE*>(revtracer.module)->GetSectionCount();
		for (DWORD i = 0; i < dwRevTracerSections; ++i) {
			const ldr::PESection *sec = dynamic_cast<ldr::FloatingPE*>(revtracer.module)->GetSection(i);

			if (sec->header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
				continue;
			}

			loader.vConfig.osData.windows.sections[sCount].mappingAddress = (ldr::ADDR_TYPE)((BYTE *)revtracer.base + sec->header.VirtualAddress);
			loader.vConfig.osData.windows.sections[sCount].mappingSize = (sec->header.VirtualSize + 0xFFFF) & ~0xFFFF;
			loader.vConfig.osData.windows.sections[sCount].sectionOffset = revTracerOffset + sec->header.VirtualAddress;
			loader.vConfig.osData.windows.sections[sCount].desiredAccess = CharacteristicsToDesiredAccess(sec->header.Characteristics);
			sCount++;
		}
		loader.vConfig.osData.windows.sectionCount = sCount;
		loader.vConfig.shmBase = (ldr::ADDR_TYPE)libs;

		// Reserve this memory chunk to prevent the windows loader on using it before our loader can do its job
		if (NULL == VirtualAllocEx(
			hProcess,
			(BYTE*)libs,
			dwTotalSize,
			MEM_RESERVE,
			PAGE_READONLY
		)) {
			break;
		}

		if (!InitializeWrapper()) {
			break;
		}

		if (!InitializeIpcLib()) {
			break;
		}
		
		if (!InitializeRevtracer()) {
			break;
		}

		loader.vConfig.entryPoint = revtracer.pExports->revtracerPerform;

		bRet = true;
	} while (false);

	delete wrapper.module;
	wrapper.module = nullptr;
	delete ipc.module;
	ipc.module = nullptr;
	delete revtracer.module;
	revtracer.module = nullptr;
	return bRet;
}

bool ExternExecutionController::WriteLoaderConfig() {
	DWORD dwWritten;
	if (FALSE == ::WriteProcessMemory(hProcess, loader.pConfig, &loader.vConfig, sizeof(loader.vConfig), &dwWritten)) {
		return false;
	}

	return true;
}

bool ExternExecutionController::SwitchEntryPoint() {
	CONTEXT ctx;
	memset(&ctx, 0, sizeof(ctx));
	ctx.ContextFlags = CONTEXT_ALL;
	if (FALSE == GetThreadContext(hMainThread, &ctx)) {
		return false;
	}

	revtracer.pConfig->entryPoint = (rev::ADDR_TYPE)ctx.Eip;

	ctx.Eip = (DWORD)loader.vExports.perform;
	if (FALSE == SetThreadContext(hMainThread, &ctx)) {
		return false;
	}

	return true;
}

BYTE *RemoteGetModuleHandle(HANDLE hProcess, const wchar_t *module) {
	BYTE *pOffset = (BYTE *)0x10000;
	while ((BYTE *)0x7FFE0000 >= pOffset) {
		MEMORY_BASIC_INFORMATION mbi;
		wchar_t moduleName[MAX_PATH];

		VirtualQueryEx(hProcess, pOffset, (PMEMORY_BASIC_INFORMATION)&mbi, sizeof(mbi));

		if ((MEM_COMMIT == mbi.State) && (SEC_IMAGE == mbi.Type) && (PAGE_READONLY == mbi.Protect)) {
			if (0 != GetMappedFileNameW(
				hProcess,
				pOffset,
				moduleName,
				sizeof(moduleName)-1
			)) {
				wchar_t *mName = moduleName;
				for (int t = wcslen(moduleName) - 1; t >= 0; --t) {
					if (L'\\' == moduleName[t]) {
						mName = &moduleName[t + 1];
						break;
					}
				}

				if (0 == _wcsicmp(mName, module)) {
					return pOffset;
				}
			}
		}

		pOffset += mbi.RegionSize;
	}

	return NULL;
}

bool ExternExecutionController::PatchProcess() {
	// hook IsProcessorFeaturePresent
	HMODULE hKernel32 = GetModuleHandle("kernel32.dll");
	BYTE *ipfpFunc = (BYTE *)GetProcAddress(hKernel32, "IsProcessorFeaturePresent");
	BYTE *remoteKernel = RemoteGetModuleHandle(hProcess, L"kernel32.dll");

	if (NULL == remoteKernel) {
		return false;
	}

	revtracer.pConfig->hooks[revtracer.pConfig->hookCount].originalAddr = &remoteKernel[ipfpFunc - (BYTE *)hKernel32];
	revtracer.pConfig->hooks[revtracer.pConfig->hookCount].detourAddr = ipc.pIPFPFunc;
	revtracer.pConfig->hookCount++;


	const wchar_t *pth = path.c_str();

	for (int t = path.length() - 1; t > 0; --t) {
		if (L'\\' == pth[t]) {
			pth = &pth[t + 1];
			break;
		}
	}

	BYTE *mAddr = RemoteGetModuleHandle(hProcess, pth);

	unsigned short tmp = '  ';
	DWORD dwWr, oldPr;

	if (FALSE == VirtualProtectEx(hProcess, mAddr, sizeof(tmp), PAGE_READWRITE, &oldPr)) {
		return false;
	}

	if (FALSE == ::WriteProcessMemory(hProcess, mAddr, &tmp, sizeof(tmp), &dwWr)) {
		return false;
	}

	revtracer.pConfig->mainModule = mAddr;

	/*if (FALSE == VirtualProtectEx(hProcess, mAddr, sizeof(tmp), oldPr, &oldPr)) {
		return false;
	}*/
	return true;
}

DWORD WINAPI ControlThreadFunc(void *ptr) {
	ExternExecutionController *ctr = (ExternExecutionController *)ptr;
	return ctr->ControlThread();
}

THREAD_T ExternExecutionController::GetProcessHandle() {
	return hProcess;
}

rev::ADDR_TYPE ExternExecutionController::GetTerminationCode() {
	return wrapper.pExports->getTerminationCode();
}

bool ExternExecutionController::Execute() {
	STARTUPINFOW startupInfo;
	PROCESS_INFORMATION processInfo;

	memset(&startupInfo, 0, sizeof(startupInfo));
	startupInfo.cb = sizeof(startupInfo);
	
	memset(&processInfo, 0, sizeof(processInfo));

	if ((execState != INITIALIZED) && (execState != TERMINATED) && (execState != ERR)) {
		DEBUG_BREAK;
		return false;
	}

	BOOL bRet = CreateProcessW(
		path.c_str(),
		L"", //cmdLine.c_str(),
		NULL,
		NULL,
		FALSE,
		CREATE_SUSPENDED | CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&startupInfo,
		&processInfo
	);

	if (FALSE == bRet) {
		execState = ERR;
		DEBUG_BREAK;
		return false;
	}

	pid = processInfo.dwProcessId;
	hProcess = processInfo.hProcess;
	hMainThread = processInfo.hThread;

	if (!InitializeAllocator()) {
		execState = ERR;
		DEBUG_BREAK;
		return false;
	}

	if (!MapLoader()) {
		execState = ERR;
		DEBUG_BREAK;
		return false;
	}

	if (!MapTracer()) {
		execState = ERR;
		DEBUG_BREAK;
		return false;
	}

	if (!WriteLoaderConfig()) {
		execState = ERR;
		DEBUG_BREAK;
		return false;
	}

	if (!SwitchEntryPoint()) {
		execState = ERR;
		DEBUG_BREAK;
		return false;
	}

	hControlThread = CreateThread(
		NULL,
		0,
		ControlThreadFunc,
		this,
		0,
		NULL
	);

	execState = RUNNING;
	ResumeThread(hMainThread);
	return true;
}

bool ExternExecutionController::WaitForTermination() {
	WaitForSingleObject(hControlThread, INFINITE);

	return true;
}

//DWORD BranchHandler(void *context, rev::ADDR_TYPE a, void *controller);

DWORD ExternExecutionController::ControlThread() {
	bool bRunning = true;
	DWORD exitCode;

	//HANDLE hDbg = 0;
	FILE_T hOffs = 0;

	do {

		hDbg = OPEN_FILE_W("debug.log");

		if (FAIL_OPEN_FILE(hDbg)) {
			//TerminateProcess(hProcess, 0);
			break;
		}

		hOffs = OPEN_FILE_W("bbs1.txt");

		if (FAIL_OPEN_FILE(hOffs)) {
			break;
		}

		int cFile = _open_osfhandle((intptr_t)hOffs, _O_TEXT);
		FILE *fOffs = _fdopen(cFile, "wt");


		while (bRunning) {
			do {
				GetExitCodeProcess(hProcess, &exitCode);

				if (STILL_ACTIVE != exitCode) {
					break;
				}

			} while (!wrapper.pExports->tokenRing->Wait(CONTROL_PROCESS_TOKENID, false));
			updated = false;

			while (!ipc.pExports->debugLog->IsEmpty()) {
				int read;
				DWORD written;
				ipc.pExports->debugLog->Read(debugBuffer, sizeof(debugBuffer)-1, read);

				BOOL ret;
				WRITE_FILE(hDbg, debugBuffer, read, written, ret);
			}

			if (STILL_ACTIVE != exitCode) {
				break;
			}

			switch (ipc.pExports->ipcData->type) {
			case REPLY_MEMORY_ALLOC:
			case REPLY_MEMORY_FREE:
			case REPLY_TAKE_SNAPSHOT:
			case REPLY_RESTORE_SNAPSHOT:
			case REPLY_INITIALIZE_CONTEXT:
			case REPLY_CLEANUP_CONTEXT:
			case REPLY_SYSCALL_CONTROL:
			case REPLY_BRANCH_HANDLER:
				DEBUG_BREAK;
				break;

			case REQUEST_DUMMY:
				ipc.pExports->ipcData->type = REPLY_DUMMY;
				break; 
			
			case REQUEST_MEMORY_ALLOC: {
				DWORD offset;
				ipc.pExports->ipcData->type = REPLY_MEMORY_ALLOC;
				ipc.pExports->ipcData->data.asMemoryAllocReply.pointer = shmAlloc->Allocate(ipc.pExports->ipcData->data.asMemoryAllocRequest, offset);
				ipc.pExports->ipcData->data.asMemoryAllocReply.offset = offset;
				break;
			}

			case REQUEST_BRANCH_HANDLER: {
				void *context = ipc.pExports->ipcData->data.asBranchHandlerRequest.executionEnv;
				ipc::ADDR_TYPE next = ipc.pExports->ipcData->data.asBranchHandlerRequest.nextInstruction;
				ipc.pExports->ipcData->type = REPLY_BRANCH_HANDLER;
				execState = SUSPENDED;
				if (EXECUTION_TERMINATE == (ipc.pExports->ipcData->data.asBranchHandlerReply = BranchHandlerFunc(context, this, next))) {
					bRunning = false;
				}
				break;
			}

			case REQUEST_SYSCALL_CONTROL:
				ipc.pExports->ipcData->type = REPLY_SYSCALL_CONTROL;
				break;

			default:
				DEBUG_BREAK;
				break;
			}

			wrapper.pExports->tokenRing->Release(CONTROL_PROCESS_TOKENID);
		}


		fclose(fOffs);
	} while (false);

	CloseHandle(hDbg);
	hDbg = INVALID_HANDLE_VALUE;
	//CloseHandle(hOffs);
	//hOffs = INVALID_HANDLE_VALUE;

	WaitForSingleObject(hProcess, INFINITE);

	CloseHandle(hMainThread);
	CloseHandle(hProcess);

	execState = TERMINATED;
	delete shmAlloc;

	observer->TerminationNotification(context); // this needs to be the last thing called!
	return 0;
}

/*_declspec(dllimport) extern "C" NTSTATUS WINAPI NtQueryInformationProcess(
	_In_      HANDLE             ProcessHandle,
	_In_      MYPROCESSINFOCLASS ProcessInformationClass,
	_Out_     PVOID              ProcessInformation,
	_In_      ULONG              ProcessInformationLength,
	_Out_opt_ PULONG             ReturnLength
);*/


bool ExternExecutionController::ReadProcessMemory(unsigned int base, unsigned int size, unsigned char *buff) {
	DWORD dwRd;
	return TRUE == ::ReadProcessMemory(hProcess, (LPCVOID)base, buff, size, &dwRd);
}

bool ExternExecutionController::WriteProcessMemory(unsigned int base, unsigned int size, unsigned char *buff) {
	DWORD dwWr;
	return TRUE == ::WriteProcessMemory(hProcess, (LPVOID)base, buff, size, &dwWr);
}

unsigned int ExternExecutionController::ExecutionBegin(void *address, void *cbCtx) {
	if (!PatchProcess()) {
		execState = ERR;
		return EXECUTION_TERMINATE;
	}
	else {
		execState = SUSPENDED_AT_START;
		return observer->ExecutionBegin(cbCtx, address);
	}
}

/*void ExternExecutionController::GetCurrentRegisters(Registers &registers) {
	RemoteRuntime *ree = (RemoteRuntime *)revCfg->pRuntime;

	memcpy(&registers, (Registers *)ree->registers, sizeof(registers));
	registers.esp = ree->virtualStack;
}*/

```

`Execution/ExternExecutionController.h`:

```h
#ifndef _EXTERN_EXECUTION_CONTROLLER_H
#define _EXTERN_EXECUTION_CONTROLLER_H

#include "CommonExecutionController.h"

#include "../BinLoader/Abstract.Loader.h"
#include "../BinLoader/LoaderAPI.h"
#include "../BinLoader/PE.Loader.h"
#include "DualAllocator.h"

#include "../loader/Loader.h"
#include "../revtracer-wrapper/RevtracerWrapper.h"
#include "../ipclib/ipclib.h"
#include "../revtracer/revtracer.h"


#include "../CommonCrossPlatform/Common.h"
#include "../CommonCrossPlatform/LibraryLayout.h"

#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__)
#endif

class ExternExecutionController : public CommonExecutionController {
private:
	HANDLE hProcess /* child process */, hMainThread;
	THREAD_T hControlThread;
	FILE_T hDbg;
	DWORD pid, currentPid;

	DualAllocator* shmAlloc;

	ext::LibraryLayout *libraryLayout;

	struct {
		ldr::AbstractBinary *module;
		BASE_PTR base;
		ldr::LoaderConfig vConfig;
		ldr::LoaderConfig *pConfig;
		ldr::LoaderImports *pImports;
		ldr::LoaderExports vExports; 
		ldr::LoaderExports *pExports;
	} loader;

	struct {
		ldr::AbstractBinary *module;
		BASE_PTR base;
		revwrapper::WrapperImports *pImports;
		revwrapper::WrapperExports *pExports;
	} wrapper;

	struct {
		ldr::AbstractBinary *module;
		BASE_PTR base;
		ipc::IpcImports *pImports;
		ipc::IpcExports *pExports;

		BYTE *pIPFPFunc;
	} ipc;
	
	struct {
		ldr::AbstractBinary *module;
		BASE_PTR base;
		rev::RevtracerConfig *pConfig;
		rev::RevtracerImports *pImports;
		rev::RevtracerExports *pExports;
	} revtracer;

	char debugBuffer[4096];

	FILE_T hBlocksFd;

	bool InitializeAllocator();
	bool InitLibraryLayout();
	bool MapLoader();
	bool MapWrapper();
	bool MapTracer();
	bool WriteLoaderConfig();

	bool InitializeWrapper();
	bool InitializeIpcLib();
	bool InitializeRevtracer();

	bool SwitchEntryPoint();
	bool PatchProcess();

	void ConvertWideStringPath(char *result, size_t len);
	void MapSharedLibraries(unsigned long baseAddress);
public:
	ExternExecutionController();

	virtual bool SetEntryPoint();

	virtual bool Execute();
	virtual bool WaitForTermination();

	DWORD ControlThread();

	virtual THREAD_T GetProcessHandle();
	virtual rev::ADDR_TYPE GetTerminationCode();

	virtual bool ReadProcessMemory(unsigned int base, unsigned int size, unsigned char *buff);
	virtual bool WriteProcessMemory(unsigned int base, unsigned int size, unsigned char *buff);

	virtual unsigned int ExecutionBegin(void *address, void *cbCtx);
};


#endif

```

`Execution/InprocessExecutionController.cpp`:

```cpp
#include "InprocessExecutionController.h"
#include "RiverStructs.h"
#include "../CommonCrossPlatform/Common.h"
#include "../revtracer-wrapper/RevtracerWrapper.h"
#include "../BinLoader/LoaderAPI.h"
#include "../wrapper.setup/Wrapper.Setup.h"

#ifdef __linux__
#include <string.h>
#endif

#ifdef __linux__
#define MAX_FUNC_LIST 32
struct libc_ifunc_impl
{
	/* The name of function to be tested.  */
	const char *name;
	/* The address of function to be tested.  */
	void (*fn) (void);
	/* True if this implementation is usable on this machine.  */
	bool usable;
};

typedef size_t (*__libc_ifunc_impl_list_handle)(const char *name,
                       struct libc_ifunc_impl *array,
                       size_t max);
static __libc_ifunc_impl_list_handle my__libc_ifunc_impl_list;
#endif

#ifdef __linux__
#define CREATE_THREAD(tid, func, params, ret) do { ret = pthread_create((&tid), nullptr, (func), (params)); ret = (0 == ret); } while(false)
#define JOIN_THREAD(tid, ret) do { ret = pthread_join(tid, nullptr); ret = (0 == ret); } while (false)

#else
#define CREATE_THREAD(tid, func, params, ret) do { tid = CreateThread(nullptr, 0, (func), (params), 0, nullptr); ret = (tid != nullptr); } while (false)
#define JOIN_THREAD(tid, ret) do { ret = WaitForSingleObject(tid, INFINITE); ret = (WAIT_FAILED != ret); } while (false)
#endif

typedef ADDR_TYPE(*GetHandlerCallback)(void);

bool InprocessExecutionController::SetPath(const wstring &) {
	return false;
}

bool InprocessExecutionController::SetCmdLine(const wstring &c) {
	return false;
}

bool InprocessExecutionController::PatchProcess() {
#ifdef __linux__
	LIB_T libcHandler;
	struct libc_ifunc_impl func_list[MAX_FUNC_LIST];

	std::vector<std::string> func_names = {
		"bcopy", "bzero", "memchr", "memcmp", "__memmove_chk",
		"memmove", "memrchr", "__memset_chk", "memset",
		"rawmemchr", "stpncpy", "stpcpy", "strcasecmp",
		"strcasecmp_l", "strcat", "strchr", "strcmp",
		"strcpy", "strcspn", "strncasecmp", "strncasecmp_l",
		"strncat", "strncpy", "strnlen", "strpbrk", "strrchr",
		"strspn", "wcschr", "wcscmp", "wcscpy", "wcslen", "wcsrchr",
		"wmemcmp", "__memcpy_chk", "memcpy", "__mempcpy_chk",
		"mempcpy", "strlen", "strncmp"
	};

	libcHandler = GET_LIB_HANDLER("libc.so");
	if (nullptr == libcHandler) {
		DEBUG_BREAK;
		return false;
	}

	my__libc_ifunc_impl_list = (__libc_ifunc_impl_list_handle)dlsym(
			libcHandler, "__libc_ifunc_impl_list");
	if (nullptr == my__libc_ifunc_impl_list) {
		DEBUG_BREAK;
		return false;
	}

	for (auto it = func_names.begin(); it != func_names.end(); ++it) {
		ADDR_TYPE detourAddr = nullptr;
		memset(func_list, 0,
				MAX_FUNC_LIST * sizeof(struct libc_ifunc_impl));
		(my__libc_ifunc_impl_list)(it->c_str(), func_list, MAX_FUNC_LIST);
		for (int i = 0; i < MAX_FUNC_LIST; ++i) {
			if (!func_list[i].name || !func_list[i].fn)
				break;
			char *ia32 = strstr((char*)func_list[i].name, "ia32");
			if (nullptr != ia32 && (strlen(ia32) == strlen("ia32"))) {
				detourAddr = (ADDR_TYPE)func_list[i].fn;
				break;
			}
		}

		if (nullptr == detourAddr) {
			DEBUG_BREAK;
			return false;
		}
		for (int i = 0; i < MAX_FUNC_LIST; ++i) {
			if (!func_list[i].name || !func_list[i].fn)
				break;
			if ((ADDR_TYPE)func_list[i].fn != detourAddr) {
				revtracer.pConfig->hooks[revtracer.pConfig->hookCount].originalAddr = (ADDR_TYPE)func_list[i].fn;
				revtracer.pConfig->hooks[revtracer.pConfig->hookCount].detourAddr = detourAddr;
				revtracer.pConfig->hookCount++;
			}
		}

	}
#endif
	return true;
}


THREAD_T InprocessExecutionController::GetProcessHandle() {
	return GET_CURRENT_PROC();
}

rev::ADDR_TYPE InprocessExecutionController::GetTerminationCode() {
	return wrapper.pExports->getTerminationCode();
}

bool InprocessExecutionController::ReadProcessMemory(unsigned int base, unsigned int size, unsigned char * buff) {
	memcpy(buff, (LPCVOID)base, size);
	return true;
}

bool InprocessExecutionController::WriteProcessMemory(unsigned int base, unsigned int size, unsigned char * buff) {
	memcpy((LPVOID)base, buff, size);
	return true;
}

#ifdef __linux__
void *ThreadProc(void *p) {
	InprocessExecutionController *_this = (InprocessExecutionController *)p;
	_this->ControlThread();
  return nullptr;
}
#else
DWORD __stdcall ThreadProc(LPVOID p) {
	InprocessExecutionController *_this = (InprocessExecutionController *)p;
	return _this->ControlThread();
}
#endif

//unsigned int BranchHandler(void *context, void *userContext, void *nextInstruction);
void SyscallControlFunc(void *context, void *userContext);

typedef void(*InitializeFunc)();
typedef void(*ExecuteFunc)(int argc, char *argv[]);

InitializeFunc revtracerInitialize = nullptr;
ExecuteFunc revtraceExecute = nullptr;

bool InprocessExecutionController::Execute() {
#ifdef _WIN32
	wchar_t revWrapperPath[] = L"revtracer-wrapper.dll";
#else
	wchar_t revWrapperPath[] = L"librevtracerwrapper.so";
#endif

	LOAD_LIBRARYW(L"revtracer.dll", revtracer.module, revtracer.base);
	LOAD_LIBRARYW(revWrapperPath, wrapper.module, wrapper.base);

	if (((0 == revtracer.module) && (0 == revtracer.base)) ||
        ((0 == wrapper.module) && (0 == wrapper.base))) {
		DEBUG_BREAK;
		return false;
	}

	revtracer.pConfig = (rev::RevtracerConfig *)GET_PROC_ADDRESS(revtracer.module, revtracer.base, "revtracerConfig");
	revtracer.pImports = (rev::RevtracerImports *)GET_PROC_ADDRESS(revtracer.module, revtracer.base, "revtracerImports");
	revtracer.pExports = (rev::RevtracerExports *)GET_PROC_ADDRESS(revtracer.module, revtracer.base, "revtracerExports");
	
	if ((nullptr == revtracer.pConfig) || (nullptr == revtracer.pImports) || (nullptr == revtracer.pExports)) {
		DEBUG_BREAK;
		return false;
	}

	revtracer.pImports->dbgPrintFunc = ::DebugPrintf;

	revtracer.pImports->branchHandler = BranchHandlerFunc;
	revtracer.pImports->errorHandler = ErrorHandlerFunc;
	revtracer.pImports->syscallControl = SyscallControlFunc;

	if (nullptr != trackCb) {
		revtracer.pImports->trackCallback = trackCb;
	}

	if (nullptr != markCb) {
		revtracer.pImports->markCallback = markCb;
	}

	if (nullptr != symbCb) {
		revtracer.pImports->symbolicHandler = symbCb;
	}

	wrapper.pImports = (revwrapper::WrapperImports *)GET_PROC_ADDRESS(wrapper.module, wrapper.base, "wrapperImports");
	wrapper.pExports = (revwrapper::WrapperExports *)GET_PROC_ADDRESS(wrapper.module, wrapper.base, "wrapperExports");

	wrapper.pImports->libraries = &libLayout;
	if (!InitWrapperOffsets(&libLayout, wrapper.pImports)) {
		DEBUG_BREAK;
		return false;
	}

	if (!wrapper.pExports->initRevtracerWrapper(nullptr)) {
		DEBUG_BREAK;
		return false;
	}

	revtracer.pImports->memoryAllocFunc = wrapper.pExports->allocateMemory;
	revtracer.pImports->memoryFreeFunc = wrapper.pExports->freeMemory;
	revtracer.pImports->lowLevel.ntTerminateProcess = (rev::ADDR_TYPE)wrapper.pExports->terminateProcess;
	revtracer.pImports->lowLevel.vsnprintf_s = (rev::ADDR_TYPE)wrapper.pExports->formattedPrint;
	gfe = revtracer.pExports->getFirstEsp;
	gcr = revtracer.pExports->getCurrentRegisters;
	gmi = revtracer.pExports->getMemoryInfo;
	mmv = revtracer.pExports->markMemoryValue;
	glbbi = revtracer.pExports->getLastBasicBlockInfo;

	if ((nullptr == gfe) || (nullptr == gcr) || (nullptr == gmi) || (nullptr == mmv) || (nullptr == glbbi)) {
		DEBUG_BREAK;
		return false;
	}

	revtracer.pConfig->entryPoint = entryPoint;
	revtracer.pConfig->featureFlags = featureFlags;
	revtracer.pConfig->context = this;
	revtracer.pConfig->hookCount = 0;
	
	revtracerInitialize = (InitializeFunc)GET_PROC_ADDRESS(revtracer.module, revtracer.base, "Initialize");
	revtraceExecute = (ExecuteFunc)GET_PROC_ADDRESS(revtracer.module, revtracer.base, "Execute");

	PatchProcess();

	int ret;
	CREATE_THREAD(hThread, ThreadProc, this, ret);

#ifdef _WIN32
	InitSegments(hThread, revtracer.pConfig->segmentOffsets);
#elif defined(__linux__)
	InitSegments(nullptr, revtracer.pConfig->segmentOffsets);
#endif

	return TRUE == ret;
}


DWORD InprocessExecutionController::ControlThread() {
	revtracerInitialize();
	revtraceExecute(0, nullptr);

	execState = TERMINATED;
	observer->TerminationNotification(context);
	return 0;
}

bool InprocessExecutionController::WaitForTermination() {
	int ret;
	JOIN_THREAD(hThread, ret);
	return TRUE == ret;
}


```

`Execution/InprocessExecutionController.h`:

```h
#ifndef _INPROCESS_EXECUTION_CONTROLLER_H_
#define _INPROCESS_EXECUTION_CONTROLLER_H_

#include "CommonExecutionController.h"
/*#ifdef _WIN32
#include <Windows.h>
#endif*/

#include "../revtracer-wrapper/RevtracerWrapper.h"
#include "../revtracer/revtracer.h"
#include "../CommonCrossPlatform/Common.h"
#include "../BinLoader/LoaderAPI.h"

class InprocessExecutionController : public CommonExecutionController {
private :
	THREAD_T hThread;

	ext::LibraryLayout libLayout, **expLayout;
	
	struct {
		MODULE_PTR module;
		BASE_PTR base;
		revwrapper::WrapperImports *pImports;
		revwrapper::WrapperExports *pExports;
	} wrapper;

	struct {
		MODULE_PTR module;
		BASE_PTR base;
		rev::RevtracerConfig *pConfig;
		rev::RevtracerImports *pImports;
		rev::RevtracerExports *pExports;
	} revtracer;
public :
	virtual bool SetPath(const wstring &p);
	virtual bool SetCmdLine(const wstring &c);

	bool PatchProcess();

	virtual THREAD_T GetProcessHandle();
	virtual rev::ADDR_TYPE GetTerminationCode();

	/*virtual bool GetProcessVirtualMemory(VirtualMemorySection *&sections, int &sectionCount);
	virtual bool GetModules(ModuleInfo *&modules, int &moduleCount);*/
	virtual bool ReadProcessMemory(unsigned int base, unsigned int size, unsigned char *buff);
	virtual bool WriteProcessMemory(unsigned int base, unsigned int size, unsigned char *buff);

	DWORD ControlThread();

	virtual bool Execute();
	virtual bool WaitForTermination();
};

#endif

```

`Execution/InternalExecutionControllerExt.cpp`:

```cpp
#include "InternalExecutionController.h"




```

`Execution/LargeStack.cpp`:

```cpp

//layout

// [Y][C][B][A][X]
// A, B, C large regions
// X, Y, small overflow detection regions
// Layout: Divide the available buffer into 8 chunks
//         Y|C|C|B|B|A|A|X



// in order to keep things consistent
// When Top in Y:
// 		Move contents of Y in A
//		Move top in A
// When Top in X:
//		Move top in C

// When Top in A:
// 		B must be clear
//      C must be prev -> clone C to X
// When Top in B:
// 		A must be prev
// 		C must be clear
// When Top in C:
//      A must be clear
//      B must be prev

#include "LargeStack.h"
#ifdef __linux__
#include <string.h>
#endif

#define LOG_MIN_CHUNK_SIZE 12
#define MIN_CHUNK_SIZE (1 << LOG_MIN_CHUNK_SIZE)
#define CHUNK_COUNT    0x8
#define MIN_STACK_SIZE (CHUNK_COUNT << LOG_MIN_CHUNK_SIZE)

namespace rev {

	LargeStack::LargeStack(DWORD *base, DWORD size, DWORD *top, char *fName) {
		if (size & (MIN_STACK_SIZE - 1)) {
			DEBUG_BREAK;
		}

		stackBase = base;
		stackSize = size;
		stackTop = top;

		chunkSize = stackSize / CHUNK_COUNT;

		*stackTop = (DWORD)stackBase + 7 * chunkSize;
		currentRegion = CurrentRegion();

		offsets[0] = 2;
		offsets[1] = 1;
		offsets[2] = 0;

		hVirtualStack = OPEN_FILE_RW(fName);

		if (FAIL_OPEN_FILE(hVirtualStack)) {
			DEBUG_BREAK;
		}
	}

	LargeStack::~LargeStack() {
		CLOSE_FILE(hVirtualStack);
	}

	DWORD LargeStack::CurrentRegion() const {
		DWORD ttop = *stackTop - (DWORD)stackBase - 4;

		ttop /= chunkSize;

		return (ttop + 1) >> 1;
	}

	bool LargeStack::VirtualPush(DWORD *buffer) {
		::DWORD dwWr;
		
		BOOL ret;
		WRITE_FILE(hVirtualStack, buffer, chunkSize << 1, dwWr, ret);
		return TRUE == ret;
	}

	bool LargeStack::VirtualPop(DWORD *buffer) {
		LARGE_INTEGER liPos;
		::DWORD dwRd;

		liPos.QuadPart = ~(LONGLONG)(chunkSize << 1) + 1;

		LSEEK(hVirtualStack, liPos, SEEK_END_FILE);

		BOOL ret;
		READ_FILE(hVirtualStack, buffer, chunkSize << 1, dwRd, ret);

#ifdef __linux__
    ftruncate(hVirtualStack, liPos.QuadPart);
#else
		SetFilePointerEx(hVirtualStack, liPos, &liPos, FILE_BEGIN);
		SetEndOfFile(hVirtualStack);
#endif

		return true;
	}

	void LargeStack::Update() {
		DWORD newRegion = CurrentRegion();
		DWORD copySize;

		if (newRegion != currentRegion) {
			DWORD *clearBuffer = NULL, *loadBuffer = NULL;

			switch (newRegion) {
				case 0: // move to 3
					copySize = (DWORD)stackBase + (chunkSize << 1) - *stackTop;
					memcpy((void *)(*stackTop + 6 * chunkSize), (void *)*stackTop, copySize);
					*stackTop += 6 * chunkSize;
					newRegion = 3;
					break;
				case 4:
					*stackTop -= 6 * chunkSize;
					newRegion = 1;
					break;
			}

			switch (newRegion) {
				case 1:
					if (2 == currentRegion) {
						clearBuffer = (DWORD *)((DWORD)stackBase + 5 * chunkSize);
					} else { // 3
						loadBuffer = (DWORD *)((DWORD)stackBase + 3 * chunkSize);
					}
					break						;
				case 2:
					if (3 == currentRegion) {
						clearBuffer = (DWORD *)((DWORD)stackBase + 1 * chunkSize);
					} else { // 1
						loadBuffer = (DWORD *)((DWORD)stackBase + 5 * chunkSize);
					}
					break;
				case 3:
					if (1 == currentRegion) {
						clearBuffer = (DWORD *)((DWORD)stackBase + 3 * chunkSize);
					} else { // 2
						loadBuffer = (DWORD *)((DWORD)stackBase + 1 * chunkSize);
					}
					break;
			}

			if (NULL != clearBuffer) {
				VirtualPush(clearBuffer);
				//optionally
				memset(clearBuffer, 0, chunkSize << 1);
			}

			if (NULL != loadBuffer) {
				VirtualPop(loadBuffer);
			}

			currentRegion = newRegion;
		}
	}

};

```

`Execution/LargeStack.h`:

```h
#ifndef _LARGE_STACK_H_
#define _LARGE_STACK_H_

#ifdef _WIN32
#include <Windows.h>
#endif

#include "../CommonCrossPlatform/Common.h"

namespace rev {
	typedef unsigned int DWORD;

	class LargeStack {
	private:
		DWORD *stackTop;
		DWORD *stackBase;
		DWORD stackSize;
		DWORD chunkSize;
		DWORD currentRegion;

		DWORD offsets[3];

		FILE_T hVirtualStack;

		DWORD CurrentRegion() const;

		bool VirtualPush(DWORD *buffer);
		bool VirtualPop(DWORD *buffer);
	public:
		LargeStack(DWORD *base, DWORD size, DWORD *top, char *fName);
		~LargeStack();

		void Update();
	};
};

#endif // !_LARGE_STACK_H_

```

`Execution/Main.cpp`:

```cpp
#ifndef DISABLE_EXTERN_EXECUTION
#include "ExternExecutionController.h"
#endif

#ifndef DISABLE_EXTERN_EXECUTION
#include "ExternExecutionController.h"
#endif

#ifndef DISABLE_INPROCESS_EXECUTION
#include "InprocessExecutionController.h"
#endif

DLL_EXECUTION_PUBLIC ExecutionController *NewExecutionController(uint32_t type) {
	switch (type) {
#ifndef DISABLE_EXTERN_EXECUTION
		case EXECUTION_EXTERNAL:
			return new ExternExecutionController();
#endif
#ifndef DISABLE_INPROCESS_EXECUTION
		case EXECUTION_INPROCESS:
			return new InprocessExecutionController();
#endif
		default:
			return nullptr;
	};
}

DLL_EXECUTION_PUBLIC void DeleteExecutionController(ExecutionController *ptr) {
	delete ptr;
}


#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(_In_ HINSTANCE hinstDLL, _In_ DWORD fdwReason, _In_ LPVOID lpvReserved) {
	return TRUE;
}
#endif

```

`Execution/Makefile`:

```
lib_execution := libexecution.so
CC := gcc
CXX := g++

EXTERNAL_FILES := ../revtracer/sync.cpp ../revtracer/crc32.cpp ../revtracer/cb.cpp ../libproc/libproc.cpp

INCLUDE_PATHS := -I../BinLoader

INPROCESS_EXECUTION_CPP := LargeStack.cpp CommonExecutionController2.cpp InprocessExecutionController.cpp CommonExecutionController.cpp Main.cpp
EXTERN_EXECUTION_CPP := Debugger.cpp ExternExecutionController.Linux.cpp DualAllocator.Linux.cpp TokenRingInit.Linux.cpp

CPP_FILES := $(EXTERN_EXECUTION_CPP) $(INPROCESS_EXECUTION_CPP) $(EXTERNAL_FILES)

OBJ_FILES := $(addprefix ,$(CPP_FILES:.cpp=.o))
LIB_BINLOADER_PATH := ../BinLoader/libbinloader.a
LIB_WRAPPER_SETUP_PATH := ../wrapper.setup/libwrappersetup.a
LIB_VIRTUALMEMORY_PATH := ../VirtualMemory/libvirtualmemory.a
LD_FLAGS := -lrt

CC_FLAGS_CROSS = -D__cdecl="" -D__stdcall=""
CC_FLAGS += -g -m32 -std=c++11 -D_EXECUTION_EXPORTS \
						-DBLOCK_CACHE_READ_ONLY  \
						$(INCLUDE_PATHS) $(CC_FLAGS_CROSS)

prefix := /usr/local

all: $(lib_execution)

install: $(lib_execution)
	install -m 0755 $(lib_execution) -t $(prefix)/lib -D

$(lib_execution): $(OBJ_FILES)
	$(CXX) $(CC_FLAGS)  -shared -o $@ $^ $(LIB_BINLOADER_PATH) $(LIB_WRAPPER_SETUP_PATH) $(LIB_VIRTUALMEMORY_PATH) $(LD_FLAGS)

%.o: %.cpp
	   $(CXX) $(CC_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(lib_execution) $(OBJ_FILES)

```

`Execution/RiverStructs.h`:

```h
#ifndef _RIVER_STRUCTS_H
#define _RIVER_STRUCTS_H

#include "../CommonCrossPlatform/Common.h"

struct RemoteRuntime {
	UINT_PTR virtualStack;				// + 0x00 - mandatory first member (used in vm-rm transitions)
	UINT_PTR returnRegister;			// + 0x04 - ax/eax/rax value
	UINT_PTR jumpBuff;					// + 0x08
	UINT_PTR execBuff;					// + 0x0C
	UINT_PTR trackBuff;					// + 0x10
	UINT_PTR trackBase;					// + 0x14
	UINT_PTR taintedAddresses;			// + 0x18
	UINT_PTR registers;					// + 0x1C

	DWORD taintedFlags[8];			// + 0x20
	DWORD taintedRegisters[8];		// + 0x40
};

//struct RiverExecutionEnvironment {
//	RiverRuntime runtimeContext;
//
//	UINT_PTR saveLog;
//
//	unsigned int /*heapSize,*/ historySize /*, logHashSize*/, outBufferSize;
//
//	unsigned char *pStack; // = NULL;
//
//	RiverHeap heap;
//
//	//_tbm_mutex cbLock; //  = 0;
//	//struct _cb_info **hashTable; // = 0
//	RiverBasicBlockCache blockCache;
//
//	UINT_PTR lastFwBlock;
//	//UINT_PTR *history;
//	//unsigned long posHist, totHist; // = 0;
//
//	UINT_PTR *executionBuffer;
//
//	//unsigned char *saveBuffer;
//
//	unsigned int bForward;
//
//	RiverCodeGen codeGen;
//
//	DWORD exitAddr;
//
//	bool bValid;
//	void *userContext;
//};

#endif

```

`Execution/TokenRingInit.Linux.cpp`:

```cpp
#ifdef __linux__


#include "TokenRingInit.Linux.h"

//#include <semaphore.h>
#include <link.h>
#include <string.h>
#include <stdio.h>

#include "../CommonCrossPlatform/Common.h"
#include "../revtracer-wrapper/TokenRing.Linux.h"

namespace revwrapper {
	typedef int (*semInitFunc)(sem_t *sem, int pshared, unsigned int value);

	int FindLibPthread(struct dl_phdr_info *info, size_t size, void *data) {
		LIB_T *dest = (LIB_T *)data;
		//printf("[Child] module name=\"%s\" @ %08x\n", info->dlpi_name, info->dlpi_addr);
		
		const char *p = strrchr(info->dlpi_name, '/');
		p = (nullptr == p) ? info->dlpi_name : (p + 1);

		if (0 == strncmp("libpthread.so", p, 13)) {
			printf("Found libpthread @ %08x\n", info->dlpi_addr);
			*dest = GET_LIB_HANDLER(info->dlpi_name);
			return 0;
		}

		return 0;
	}


	bool InitTokenRing(TokenRing *_this, long uCount) {
		LIB_T libPthread;
		dl_iterate_phdr(FindLibPthread, &libPthread);
		semInitFunc _sem_init = (semInitFunc)dlvsym(libPthread, "sem_init", "GLIBC_2.1");
		
		TokenRingOsData *_data = (TokenRingOsData *)_this->osData;

		_data->userCount = uCount;

		for (int i = 0; i < uCount; ++i) {
			if (-1 == _sem_init(&_data->semaphores[i], 1, 0)) {
				return false;
			}
		}

		return true;
	}

}; // namespace ipc

#endif

```

`Execution/TokenRingInit.Linux.h`:

```h
#ifndef _TOKEN_RING_INIT_WINDOWS_H_
#define _TOKEN_RING_INIT_WINDOWS_H_

#ifdef __linux__

#include "../revtracer-wrapper/TokenRing.h"

namespace revwrapper {
	bool InitTokenRing(TokenRing *_this, long userCount);
};
#endif

#endif


```

`Execution/TokenRingInit.Windows.cpp`:

```cpp
#if defined _WIN32 || defined __CYGWIN__

#include "TokenRingInit.Windows.h"

#include <Windows.h>

#include "../revtracer-wrapper/TokenRing.Windows.h"

namespace revwrapper {
	bool InitTokenRing(TokenRing *_this, long uCount, unsigned int *pids) {
		//_this->trw = WaitTokenRingWin;
		//_this->trr = ReleaseTokenRingWin;

		TokenRingOsData *_data = (TokenRingOsData *)_this->osData;

		_data->userCount = uCount;

		HANDLE processes[MAX_USER_COUNT];
		for (int i = 0; i < uCount; ++i) {
			processes[i] = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pids[i]);
		}

		for (int i = 0; i < uCount; ++i) {
			HANDLE hEvt = CreateEvent(nullptr, FALSE, FALSE, nullptr); // (token == i) ? TRUE : FALSE, nullptr);

			DuplicateHandle(
				GetCurrentProcess(),
				hEvt,
				processes[i],
				&_data->waitSem[i],
				0,
				FALSE,
				DUPLICATE_SAME_ACCESS
			);

			DuplicateHandle(
				GetCurrentProcess(),
				hEvt,
				processes[(0 == i) ? (uCount - 1) : (i - 1)],
				&_data->postSem[i],
				0,
				FALSE,
				DUPLICATE_SAME_ACCESS
			);

			CloseHandle(hEvt);
		}

		for (int i = 0; i < uCount; ++i) {
			CloseHandle(processes[i]);
		}

		return true;
	}

}; // namespace ipc

#endif
```

`Execution/TokenRingInit.Windows.h`:

```h
#ifndef _TOKEN_RING_INIT_WINDOWS_H_
#define _TOKEN_RING_INIT_WINDOWS_H_

#if defined _WIN32 || defined __CYGWIN__

#include "../revtracer-wrapper/TokenRing.h"

namespace revwrapper {
	bool InitTokenRing(TokenRing *_this, long userCount, unsigned int *pids);
};

#endif

#endif


```

`ExecutionWrapper/AssemblyInfo.cpp`:

```cpp
#include "stdafx.h"

using namespace System;
using namespace System::Reflection;
using namespace System::Runtime::CompilerServices;
using namespace System::Runtime::InteropServices;
using namespace System::Security::Permissions;

//
// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitleAttribute(L"ExecutionWrapper")];
[assembly:AssemblyDescriptionAttribute(L"")];
[assembly:AssemblyConfigurationAttribute(L"")];
[assembly:AssemblyCompanyAttribute(L"")];
[assembly:AssemblyProductAttribute(L"ExecutionWrapper")];
[assembly:AssemblyCopyrightAttribute(L"Copyright (c)  2015")];
[assembly:AssemblyTrademarkAttribute(L"")];
[assembly:AssemblyCultureAttribute(L"")];

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the value or you can default the Revision and Build Numbers
// by using the '*' as shown below:

[assembly:AssemblyVersionAttribute("1.0.*")];

[assembly:ComVisible(false)];

[assembly:CLSCompliantAttribute(true)];
```

`ExecutionWrapper/ExecutionWrapper.cpp`:

```cpp
// This is the main DLL file.

using namespace System::ComponentModel;
using namespace System::Threading;
//using namespace System::Windows::


#include "stdafx.h"

#include "ExecutionWrapper.h"

void MarshalString(String^ s, wstring& os) {
	using namespace Runtime::InteropServices;
	const wchar_t* chars = (const wchar_t*)(Marshal::StringToHGlobalUni(s)).ToPointer();
	os = chars;
	Marshal::FreeHGlobal(IntPtr((void*)chars));
}

delegate void TermFuncDelegate();
delegate ExecutionWrapper::ExecutionControl ExecBeginDelegate(unsigned int addr);
delegate ExecutionWrapper::ExecutionControl ExecControlDelegate(unsigned int addr);
delegate ExecutionWrapper::ExecutionControl ExecEndDelegate();

ExecutionWrapper::Execution::Execution() : controlEvent(false) {
	impl = NewExecutionController();

	TermFuncDelegate ^termDel = gcnew TermFuncDelegate(this, &ExecutionWrapper::Execution::TerminateNotifyWrapper);
	ExecBeginDelegate ^execBeginDel = gcnew ExecBeginDelegate(this, &ExecutionWrapper::Execution::ExecutionBeginWrapper);
	ExecControlDelegate ^execControlDel = gcnew ExecControlDelegate(this, &ExecutionWrapper::Execution::ExecutionControlWrapper);
	ExecEndDelegate ^execEndDel = gcnew ExecEndDelegate(this, &ExecutionWrapper::Execution::ExecutionEndWrapper);


	termDelHnd = GCHandle::Alloc(termDel);
	execBeginDelHnd = GCHandle::Alloc(execBeginDel);
	execControlDelHnd = GCHandle::Alloc(execControlDel);
	execEndDelHnd = GCHandle::Alloc(execEndDel);

	impl->SetTerminationNotification(
		static_cast<TerminationNotifyFunc>(
			Marshal::GetFunctionPointerForDelegate(termDel).ToPointer()
		)
	);

	impl->SetExecutionBeginNotification(
		static_cast<ExecutionBeginFunc>(
			Marshal::GetFunctionPointerForDelegate(execBeginDel).ToPointer()
		)
	);

	impl->SetExecutionControlNotification(
		static_cast<ExecutionControlFunc>(
			Marshal::GetFunctionPointerForDelegate(execControlDel).ToPointer()
		)
	);

	impl->SetExecutionEndNotification(
		static_cast<ExecutionEndFunc>(
			Marshal::GetFunctionPointerForDelegate(execEndDel).ToPointer()
		)
	);
}

ExecutionWrapper::Execution::~Execution() {
	DeleteExecutionController(impl);
	impl = NULL;

	termDelHnd.Free();
	execBeginDelHnd.Free();
	execControlDelHnd.Free();
	execEndDelHnd.Free();
}

ExecutionWrapper::ExecutionState ExecutionWrapper::Execution::GetState() {
	return (ExecutionWrapper::ExecutionState)impl->GetState();
}

bool ExecutionWrapper::Execution::SetPath(String^ path) {
	wstring wPath;

	MarshalString(path, wPath);
	return impl->SetPath(wPath);
}

bool ExecutionWrapper::Execution::SetCmdLine(String^ cmdLine) {
	wstring wCmdLine;

	MarshalString(cmdLine, wCmdLine);
	return impl->SetCmdLine(wCmdLine);
}

bool ExecutionWrapper::Execution::Execute() {
	return impl->Execute();
}

bool ExecutionWrapper::Execution::Terminate() {
	return impl->Terminate();
}

bool ExecutionWrapper::Execution::GetProcessVirtualMemory(ObservableCollection<VirtualMemorySection> ^list) {
	::VirtualMemorySection *vms;
	int cnt;

	list->Clear();
	if (!impl->GetProcessVirtualMemory(vms, cnt)) {
		return false;
	}

	for (int i = 0; i < cnt; ++i) {
		VirtualMemorySection t;

		t._BaseAddress = vms[i].BaseAddress;
		t._Protection = vms[i].Protection;
		t._RegionSize = vms[i].RegionSize;
		t._State = vms[i].State;
		t._Type = vms[i].Type;

		list->Add(t);
	}
	return true;
}

bool ExecutionWrapper::Execution::ReadProcessMemory(unsigned int address, unsigned int size, unsigned char *data) {
	bool ret = impl->ReadProcessMemory(address, size, data);
	return ret;
}

void ExecutionWrapper::Execution::Control(ExecutionWrapper::ExecutionControl ctrl) {
	lastControlMessage = ctrl;
	controlEvent.Set();
}

void ExecutionWrapper::Execution::TerminateNotifyWrapper() {
	//RaiseEventOnUIThread(onTerminate, gcnew array<Object ^>(0));
	onTerminate->Invoke();
}

ExecutionWrapper::ExecutionControl ExecutionWrapper::Execution::ExecutionBeginWrapper(unsigned int address) {
	onExecutionBegin->Invoke(address);

	controlEvent.WaitOne();
	return lastControlMessage;
}

ExecutionWrapper::ExecutionControl ExecutionWrapper::Execution::ExecutionControlWrapper(unsigned int address) {
	onExecutionControl->Invoke(address);

	controlEvent.WaitOne();
	return lastControlMessage;
}

ExecutionWrapper::ExecutionControl ExecutionWrapper::Execution::ExecutionEndWrapper() {
	onExecutionEnd->Invoke();

	controlEvent.WaitOne();
	return lastControlMessage;
}


```

`ExecutionWrapper/ExecutionWrapper.h`:

```h
// ExecutionWrapper.h

#pragma once

using namespace System;
//using namespace System::Collections::Generic;
using namespace System::Collections::ObjectModel;
using namespace System::Runtime::InteropServices;
using namespace System::Threading;

#include "../Execution/Execution.h"
#include "../revtracer/revtracer.h"

namespace ExecutionWrapper {

	public enum class ExecutionState
	{
		NEW = EXECUTION_NEW,
		INITIALIZED = EXECUTION_INITIALIZED,
		SUSPENDED_AT_START = EXECUTION_SUSPENDED_AT_START,
		RUNNING = EXECUTION_RUNNING,
		SUSPENDED = EXECUTION_SUSPENDED,
		SUSPENDED_AT_TERMINATION = EXECUTION_SUSPENDED_AT_TERMINATION,
		TERMINATED = EXECUTION_TERMINATED,
		ERR = EXECUTION_ERR
	};

	public enum class ExecutionControl
	{
		ADVANCE = EXECUTION_ADVANCE,
		BACKTRACK = EXECUTION_BACKTRACK,
		TERMINATE = EXECUTION_TERMINATE
	};

	public value struct VirtualMemorySection {
		uint32_t _BaseAddress;
		uint32_t _RegionSize;
		uint32_t _State; // free, reserved, commited
		uint32_t _Protection; // read, write, execute
		uint32_t _Type; // image, mapped, private

		property uint32_t BaseAddress {
			uint32_t get() { return _BaseAddress; }
		};

		property uint32_t RegionSize {
			uint32_t get() { return _RegionSize; }
		};

		property uint32_t State {
			uint32_t get() { return _State; }
		};

		property uint32_t Protection {
			uint32_t get() { return _Protection; }
		};

		property uint32_t Type {
			uint32_t get() { return _Type; }
		};
	};

	public ref class Execution
	{
	private :
		ExecutionController *impl;

		GCHandle termDelHnd, execBeginDelHnd, execControlDelHnd, execEndDelHnd;

		void TerminateNotifyWrapper();
		ExecutionControl ExecutionBeginWrapper(unsigned int address);
		ExecutionControl ExecutionControlWrapper(unsigned int address);
		ExecutionControl ExecutionEndWrapper();

		ExecutionControl lastControlMessage;
		AutoResetEvent controlEvent;
	public:

		Execution();
		~Execution();

		ExecutionState GetState();

		bool SetPath(String^ path);
		bool SetCmdLine(String^ cmdLine);
		bool Execute();
		bool Terminate();

		void Control(ExecutionControl control);

		bool GetProcessVirtualMemory(ObservableCollection<VirtualMemorySection> ^list);
		bool ReadProcessMemory(unsigned int address, unsigned int size, unsigned char data[]);

		delegate void OnTerminateDelegate();
		delegate void OnExecutionBeginDelegate(unsigned int address);
		delegate void OnExecutionControlDelegate(unsigned int address);
		delegate void OnExecutionEndDelegate();

		OnTerminateDelegate ^onTerminate;
		OnExecutionBeginDelegate ^onExecutionBegin;
		OnExecutionControlDelegate ^onExecutionControl;
		OnExecutionEndDelegate ^onExecutionEnd;
	};
}

```

`ExecutionWrapper/ExecutionWrapper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{738D1D30-447B-434D-A323-E9D4E299AEC1}</ProjectGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <Keyword>ManagedCProj</Keyword>
    <RootNamespace>ExecutionWrapper</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CLRSupport>true</CLRSupport>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CLRSupport>true</CLRSupport>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetDir)$(TargetFileName) $(SolutionDir)Demo\bin\$(ConfigurationName)\
copy $(TargetDir)$(ProjectName).pdb $(SolutionDir)Demo\bin\$(ConfigurationName)\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies />
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetDir)$(TargetFileName) $(SolutionDir)Demo\bin\$(ConfigurationName)\
copy $(TargetDir)$(ProjectName).pdb $(SolutionDir)Demo\bin\$(ConfigurationName)\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ExecutionWrapper.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AssemblyInfo.cpp" />
    <ClCompile Include="ExecutionWrapper.cpp" />
    <ClCompile Include="Stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="app.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="app.ico" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Execution\Execution.vcxproj">
      <Project>{668c607e-2e3b-435d-9390-56bdb152c363}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ExecutionWrapper/Stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// ExecutionWrapper.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

```

`ExecutionWrapper/Stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once



```

`ExecutionWrapper/app.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//
// Icon placed first or with lowest ID value becomes application icon
LANGUAGE 9, 1
1           ICON         "app.ico"

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE  
BEGIN
    "resource.h\0"
    "\0"
END

2 TEXTINCLUDE  
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE  
BEGIN
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`ExecutionWrapper/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by app.rc

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 Bitdefender

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`LargeStack/LargeStack.cpp`:

```cpp

//layout

// [Y][C][B][A][X]
// A, B, C large regions
// X, Y, small overflow detection regions
// Layout: Divide the available buffer into 8 chunks
//         Y|C|C|B|B|A|A|X



// in order to keep things consistent
// When Top in Y:
// 		Move contents of Y in A
//		Move top in A
// When Top in X:
//		Move top in C

// When Top in A:
// 		B must be clear
//      C must be prev -> clone C to X
// When Top in B:
// 		A must be prev
// 		C must be clear
// When Top in C:
//      A must be clear
//      B must be prev

#include "LargeStack.h"

#define LOG_MIN_CHUNK_SIZE 12
#define MIN_CHUNK_SIZE (1 << LOG_MIN_CHUNK_SIZE)
#define CHUNK_COUNT    0x8
#define MIN_STACK_SIZE (CHUNK_COUNT << LOG_MIN_CHUNK_SIZE)

namespace rev {

	LargeStack::LargeStack(DWORD *base, DWORD size, DWORD *top, char *fName) {
		if (size & (MIN_STACK_SIZE - 1)) {
			__asm int 3;
		}

		stackBase = base;
		stackSize = size;
		stackTop = top;

		chunkSize = stackSize / CHUNK_COUNT;

		*stackTop = (DWORD)stackBase + 7 * chunkSize;
		currentRegion = CurrentRegion();

		offsets[0] = 2;
		offsets[1] = 1;
		offsets[2] = 0;

		hVirtualStack = CreateFileA(
			fName,
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);

		if (INVALID_HANDLE_VALUE == hVirtualStack) {
			__asm int 3;
		}
	}

	LargeStack::~LargeStack() {
		CloseHandle(hVirtualStack);
	}

	DWORD LargeStack::CurrentRegion() const {
		DWORD ttop = *stackTop - (DWORD)stackBase - 4;

		ttop /= chunkSize;

		return (ttop + 1) >> 1;
	}

	bool LargeStack::VirtualPush(DWORD *buffer) {
		::DWORD dwWr;
		
		return TRUE == WriteFile(hVirtualStack, buffer, chunkSize << 1, &dwWr, NULL);
	}

	bool LargeStack::VirtualPop(DWORD *buffer) {
		LARGE_INTEGER liPos;
		::DWORD dwRd;

		liPos.QuadPart = ~(LONGLONG)(chunkSize << 1) + 1;

		SetFilePointerEx(hVirtualStack, liPos, &liPos, FILE_END);

		ReadFile(hVirtualStack, buffer, chunkSize << 1, &dwRd, NULL);

		SetFilePointerEx(hVirtualStack, liPos, &liPos, FILE_BEGIN);

		SetEndOfFile(hVirtualStack);

		return true;
	}

	void LargeStack::Update() {
		DWORD newRegion = CurrentRegion();
		DWORD copySize;

		if (newRegion != currentRegion) {
			DWORD *clearBuffer = NULL, *loadBuffer = NULL;

			switch (newRegion) {
				case 0: // move to 3
					copySize = (DWORD)stackBase + (chunkSize << 1) - *stackTop;
					memcpy((void *)(*stackTop + 6 * chunkSize), (void *)*stackTop, copySize);
					*stackTop += 6 * chunkSize;
					newRegion = 3;
					break;
				case 4:
					*stackTop -= 6 * chunkSize;
					newRegion = 1;
					break;
			}

			switch (newRegion) {
				case 1:
					if (2 == currentRegion) {
						clearBuffer = (DWORD *)((DWORD)stackBase + 5 * chunkSize);
					} else { // 3
						loadBuffer = (DWORD *)((DWORD)stackBase + 3 * chunkSize);
					}
					break						;
				case 2:
					if (3 == currentRegion) {
						clearBuffer = (DWORD *)((DWORD)stackBase + 1 * chunkSize);
					} else { // 1
						loadBuffer = (DWORD *)((DWORD)stackBase + 5 * chunkSize);
					}
					break;
				case 3:
					if (1 == currentRegion) {
						clearBuffer = (DWORD *)((DWORD)stackBase + 3 * chunkSize);
					} else { // 2
						loadBuffer = (DWORD *)((DWORD)stackBase + 1 * chunkSize);
					}
					break;
			}

			if (NULL != clearBuffer) {
				VirtualPush(clearBuffer);
				//optionally
				memset(clearBuffer, 0, chunkSize << 1);
			}

			if (NULL != loadBuffer) {
				VirtualPop(loadBuffer);
			}

			currentRegion = newRegion;
		}
	}

};
```

`LargeStack/LargeStack.h`:

```h
#ifndef _LARGE_STACK_H_
#define _LARGE_STACK_H_

#include <Windows.h>

namespace rev {
	typedef unsigned int DWORD;

	class LargeStack {
	private:
		DWORD *stackTop;
		DWORD *stackBase;
		DWORD stackSize;
		DWORD chunkSize;
		DWORD currentRegion;

		DWORD offsets[3];

		HANDLE hVirtualStack;

		DWORD CurrentRegion() const;

		bool VirtualPush(DWORD *buffer);
		bool VirtualPop(DWORD *buffer);
	public:
		LargeStack(DWORD *base, DWORD size, DWORD *top, char *fName);
		~LargeStack();

		void Update();
	};
};

#endif // !_LARGE_STACK_H_

```

`LargeStack/LargeStack.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C2337D23-250D-4204-83B3-8381B64B729A}</ProjectGuid>
    <RootNamespace>LargeStack</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="LargeStack.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="LargeStack.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`LargeStack/Main.cpp`:

```cpp
#include <stdio.h>

#include "LargeStack.h"

using namespace rev;

rev::DWORD stack[0x10000];
rev::DWORD top;

int main() {
	LargeStack ls(stack, sizeof(stack), &top, "stack.bin");

	unsigned int val = 0;
	for (int i = 0; i < 0x1000000; ++i) {
		for (int j = 0; j < 13; ++j) {

			//push equivalent
			top -= 4; 
			*((rev::DWORD *)top) = val;
			
			val++;
		}

		ls.Update();

		for (int j = 0; j < 12; ++j) {
			val--;

			rev::DWORD v = *((rev::DWORD *)top);
			top += 4;

			if (v != val) __asm int 3;
		}

		ls.Update();
	}

	return 0;
}
```

`Makefile`:

```
DIRS := BinLoader VirtualMemory wrapper.setup revtracer-wrapper \
	revtracer ipclib  DisableSSE  Execution loader http-parser-payload \
	SymbolicEnvironment SymbolicDemo
prefix := /usr/local

all:
	for d in $(DIRS); do $(MAKE) clean -C $$d && $(MAKE) -C $$d; done

clean:
	for d in $(DIRS); do $(MAKE) clean -C $$d; done

install:
	for d in $(DIRS); do $(MAKE) clean -C $$d && \
		$(MAKE) -C $$d && \
		$(MAKE) install prefix=$(prefix) -C $$d; done



```

`SymbolicEnvironment/CMakeLists.txt`:

```txt
## SymbolicEnvironment CMakeLists.txt

set(LIBRARY_NAME symbolicenvironment)
set(FLAGS_CROSS "-D__cdecl=\"\" -D__stdcall=\"\"")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -m32 -std=c++11 \
	-D_BUILDING_ENVIRONMENT_DLL -D_NO_TRACK_CALLBACKS_ ${FLAGS_CROSS}")

add_library(${LIBRARY_NAME} SHARED
	Environment.cpp
	LargeStack.cpp
	OverlappedRegisters.cpp
	RevSymbolicEnvironment.cpp
	SymbolicEnvironment.cpp
	../revtracer/Tracking.cpp
	../revtracer/AddressContainer.cpp
	)

set_target_properties(${LIBRARY_NAME} PROPERTIES
  PUBLIC_HEADER "Environment.h;LargeStack.h;SymbolicEnvironment.h"
  )

install(TARGETS ${LIBRARY_NAME}
  LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX}/lib
  PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_PREFIX}/include/SymbolicEnvironment
  )

```

`SymbolicEnvironment/Environment.cpp`:

```cpp
#include "Environment.h"

#include "RevSymbolicEnvironment.h"
#include "OverlappedRegisters.h"

DLL_ENVIRONMENT_PUBLIC sym::SymbolicEnvironment *NewX86RevtracerEnvironment(void *revEnv, void *ctl) {
	return new RevSymbolicEnvironment(revEnv, (ExecutionController *)ctl);
}

DLL_ENVIRONMENT_PUBLIC sym::SymbolicEnvironment *NewX86RegistersEnvironment(sym::SymbolicEnvironment *parent) {
	sym::ScopedSymbolicEnvironment *ret = new OverlappedRegistersEnvironment();
	ret->SetSubEnvironment(parent);

	return ret;
}
```

`SymbolicEnvironment/Environment.h`:

```h
#ifndef _ENVIRONMENT_H_
#define _ENVIRONMENT_H_

#if defined _WIN32 || defined __CYGWIN__
	#ifdef _BUILDING_ENVIRONMENT_DLL
		#ifdef __GNUC__
			#define DLL_ENVIRONMENT_PUBLIC __attribute__ ((dllexport))
		#else
			#define DLL_ENVIRONMENT_PUBLIC __declspec(dllexport)
		#endif
	#else
		#ifdef __GNUC__
			#define DLL_ENVIRONMENT_PUBLIC __attribute__ ((dllimport))
		#else
			#define DLL_ENVIRONMENT_PUBLIC __declspec(dllimport)
		#endif
	#endif
	#define DLL_LOCAL
#else
	#if __GNUC__ >= 4
		#define DLL_ENVIRONMENT_PUBLIC __attribute__ ((visibility ("default")))
		#define DLL_LOCAL  __attribute__ ((visibility ("hidden")))
	#else
		#define DLL_ENVIRONMENT_PUBLIC
		#define DLL_LOCAL
	#endif
#endif

#include "SymbolicEnvironment.h"

/** Get a symbolic environment that can be used directly with the revtracer.
 * Features:
 *     - Lazy CPU flag evaluation
 *     - Only 32-bit CPU registers support
 *     - Constructs symbolic expressions on the fly for unaligned memory accesses
 */
DLL_ENVIRONMENT_PUBLIC sym::SymbolicEnvironment *NewX86RevtracerEnvironment(void *revEnv, void *ctl);

/** Get a symbolic environment that lazily constructs x86 register expressions 
 * Features:
 *     - Delegates flag evaluation to the underlying environment
 *     - Lazy evalauation of register symbolic values
 *     - Delegates memory evaluation to underlying environment
 */
DLL_ENVIRONMENT_PUBLIC sym::SymbolicEnvironment *NewX86RegistersEnvironment(sym::SymbolicEnvironment *parent);


#endif


```

`SymbolicEnvironment/LargeStack.cpp`:

```cpp

//layout

// [Y][C][B][A][X]
// A, B, C large regions
// X, Y, small overflow detection regions
// Layout: Divide the available buffer into 8 chunks
//         Y|C|C|B|B|A|A|X



// in order to keep things consistent
// When Top in Y:
// 		Move contents of Y in A
//		Move top in A
// When Top in X:
//		Move top in C

// When Top in A:
// 		B must be clear
//      C must be prev -> clone C to X
// When Top in B:
// 		A must be prev
// 		C must be clear
// When Top in C:
//      A must be clear
//      B must be prev

#include "LargeStack.h"
#ifdef __linux__
#include <string.h>
#endif

#define LOG_MIN_CHUNK_SIZE 12
#define MIN_CHUNK_SIZE (1 << LOG_MIN_CHUNK_SIZE)
#define CHUNK_COUNT    0x8
#define MIN_STACK_SIZE (CHUNK_COUNT << LOG_MIN_CHUNK_SIZE)

namespace stk {

	LargeStack::LargeStack(DWORD *base, DWORD size, DWORD *top, const char *fName) {
		if (size & (MIN_STACK_SIZE - 1)) {
			DEBUG_BREAK;
		}

		stackBase = base;
		stackSize = size;
		stackTop = top;

		chunkSize = stackSize / CHUNK_COUNT;

		*stackTop = (DWORD)stackBase + 7 * chunkSize;
		currentRegion = CurrentRegion();

		offsets[0] = 2;
		offsets[1] = 1;
		offsets[2] = 0;

		hVirtualStack = OPEN_FILE_RW(fName);

		if (FAIL_OPEN_FILE(hVirtualStack)) {
			DEBUG_BREAK;
		}
	}

	LargeStack::~LargeStack() {
		CLOSE_FILE(hVirtualStack);
	}

	DWORD LargeStack::CurrentRegion() const {
		DWORD ttop = *stackTop - (DWORD)stackBase - 4;

		ttop /= chunkSize;

		return (ttop + 1) >> 1;
	}

	bool LargeStack::VirtualPush(DWORD *buffer) {
		::DWORD dwWr;
		
		BOOL ret;
		WRITE_FILE(hVirtualStack, buffer, chunkSize << 1, dwWr, ret);
		return TRUE == ret;
	}

	bool LargeStack::VirtualPop(DWORD *buffer) {
		LARGE_INTEGER liPos;
		::DWORD dwRd;

		liPos.QuadPart = ~(LONGLONG)(chunkSize << 1) + 1;

		LSEEK(hVirtualStack, liPos, SEEK_END_FILE);

		BOOL ret;
		READ_FILE(hVirtualStack, buffer, chunkSize << 1, dwRd, ret);

#ifdef __linux__
    ftruncate(hVirtualStack, liPos.QuadPart);
#else
		SetFilePointerEx(hVirtualStack, liPos, &liPos, FILE_BEGIN);
		SetEndOfFile(hVirtualStack);
#endif

		return true;
	}

	void LargeStack::Update() {
		DWORD newRegion = CurrentRegion();
		DWORD copySize;

		if (newRegion != currentRegion) {
			DWORD *clearBuffer = NULL, *loadBuffer = NULL;

			switch (newRegion) {
				case 0: // move to 3
					copySize = (DWORD)stackBase + (chunkSize << 1) - *stackTop;
					memcpy((void *)(*stackTop + 6 * chunkSize), (void *)*stackTop, copySize);
					*stackTop += 6 * chunkSize;
					newRegion = 3;
					break;
				case 4:
					*stackTop -= 6 * chunkSize;
					newRegion = 1;
					break;
			}

			switch (newRegion) {
				case 1:
					if (2 == currentRegion) {
						clearBuffer = (DWORD *)((DWORD)stackBase + 5 * chunkSize);
					} else { // 3
						loadBuffer = (DWORD *)((DWORD)stackBase + 3 * chunkSize);
					}
					break						;
				case 2:
					if (3 == currentRegion) {
						clearBuffer = (DWORD *)((DWORD)stackBase + 1 * chunkSize);
					} else { // 1
						loadBuffer = (DWORD *)((DWORD)stackBase + 5 * chunkSize);
					}
					break;
				case 3:
					if (1 == currentRegion) {
						clearBuffer = (DWORD *)((DWORD)stackBase + 3 * chunkSize);
					} else { // 2
						loadBuffer = (DWORD *)((DWORD)stackBase + 1 * chunkSize);
					}
					break;
			}

			if (NULL != clearBuffer) {
				VirtualPush(clearBuffer);
				//optionally
				memset(clearBuffer, 0, chunkSize << 1);
			}

			if (NULL != loadBuffer) {
				VirtualPop(loadBuffer);
			}

			currentRegion = newRegion;
		}
	}

	void LargeStack::Push(DWORD value) {
		*stackTop -= 4;
		*stackTop = value;
	}

	DWORD LargeStack::Pop() {
		DWORD ret = *stackTop;
		*stackTop += 4;
		return ret;
	}
};

```

`SymbolicEnvironment/LargeStack.h`:

```h
#ifndef _LARGE_STACK_H_
#define _LARGE_STACK_H_

#ifdef _WIN32
#include <Windows.h>
#endif

#include "../CommonCrossPlatform/Common.h"

namespace stk {
	typedef unsigned int DWORD;

	class LargeStack {
	private:
		DWORD *stackTop;
		DWORD *stackBase;
		DWORD stackSize;
		DWORD chunkSize;
		DWORD currentRegion;

		DWORD offsets[3];

		FILE_T hVirtualStack;

		DWORD CurrentRegion() const;

		bool VirtualPush(DWORD *buffer);
		bool VirtualPop(DWORD *buffer);
	public:
		LargeStack(DWORD *base, DWORD size, DWORD *top, const char *fName);
		~LargeStack();

		void Push(DWORD value);
		DWORD Pop();

		void Update();
	};
};

#endif // !_LARGE_STACK_H_

```

`SymbolicEnvironment/Makefile`:

```
lib_symbolicenvironment := libsymbolicenvironment.so
CC := gcc
CXX := g++
EXTERNAL_FILES := ../revtracer/Tracking.cpp ../revtracer/AddressContainer.cpp
CPP_FILES := Environment.cpp LargeStack.cpp OverlappedRegisters.cpp RevSymbolicEnvironment.cpp SymbolicEnvironment.cpp $(EXTERNAL_FILES)
OBJ_FILES := $(addprefix ,$(CPP_FILES:.cpp=.o))
CC_FLAGS += -g -m32 -march=i386 -std=c++11 -D_BUILDING_ENVIRONMENT_DLL -D_NO_TRACK_CALLBACKS_
prefix := /usr/local

all: $(lib_symbolicenvironment)

install: $(lib_symbolicenvironment)
	install -m 0755 $(lib_symbolicenvironment) -t $(prefix)/lib -D

$(lib_symbolicenvironment): $(OBJ_FILES)
	$(CXX) $(CC_FLAGS) -shared -o $@ $^

%.o: %.cpp
	   $(CXX) $(CC_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(lib_symbolicenvironment) $(OBJ_FILES)

```

`SymbolicEnvironment/OverlappedRegisters.cpp`:

```cpp
#include "OverlappedRegisters.h"

// offsets from the lsb
const nodep::DWORD OverlappedRegistersEnvironment::OverlappedRegister::rOff[5] = { 0, 0, 16, 0, 8 };
const nodep::DWORD OverlappedRegistersEnvironment::OverlappedRegister::rSize[5] = { 32, 16, 16, 8, 8 };
const nodep::DWORD OverlappedRegistersEnvironment::OverlappedRegister::rParent[5] = { 0xFF, 0, 0, 1, 1 };
const nodep::DWORD OverlappedRegistersEnvironment::OverlappedRegister::rLChild[5] = { 1, 3, 0xFF, 0xFF, 0xFF };
const nodep::DWORD OverlappedRegistersEnvironment::OverlappedRegister::rMChild[5] = { 2, 4, 0xFF, 0xFF, 0xFF };
const nodep::DWORD OverlappedRegistersEnvironment::OverlappedRegister::rSeed[4] = { 0, 1, 3, 4 };


/*
 *			[eax]
 *			  |
 *        [ax]  [?]
 *          |
 *      [al] [ah]
 */

nodep::DWORD OverlappedRegistersEnvironment::OverlappedRegister::needConcat = 0xdeadbeef;
nodep::DWORD OverlappedRegistersEnvironment::OverlappedRegister::needExtract = 0xdeadbeef;

static nodep::BYTE _GetFundamentalRegister(nodep::BYTE reg) {
	if (reg < 0x20) {
		return reg & 0x07;
	}
	return reg;
}

OverlappedRegistersEnvironment::OverlappedRegister::OverlappedRegister() {
	for (int i = 0; i < 5; ++i) {
		subRegs[i] = nullptr;
	}
}

void OverlappedRegistersEnvironment::OverlappedRegister::MarkNeedExtract(nodep::DWORD node, bool doRefCount) {
	nodep::DWORD c = rLChild[node];
	if (c != 0xFF) {
		if ((doRefCount) && (nullptr != subRegs[c]) && (&needExtract != subRegs[c]) && (&needConcat != subRegs[c])) {
			parent->decRefFunc(subRegs[c]);
		}
		subRegs[c] = &needExtract;
		MarkNeedExtract(c, doRefCount);
	}

	c = rMChild[node];
	if (c != 0xFF) {
		if ((doRefCount) && (nullptr != subRegs[c]) && (&needExtract != subRegs[c]) && (&needConcat != subRegs[c])) {
			parent->decRefFunc(subRegs[c]);
		}
		subRegs[c] = &needExtract;
		MarkNeedExtract(c, doRefCount);
	}
}

void OverlappedRegistersEnvironment::OverlappedRegister::MarkUnset(nodep::DWORD node, bool doRefCount) {
	nodep::DWORD c = rLChild[node];
	if (c != 0xFF) {
		if ((doRefCount) && (nullptr != subRegs[c]) && (&needExtract != subRegs[c]) && (&needConcat != subRegs[c])) {
			parent->decRefFunc(subRegs[c]);
		}
		
		subRegs[c] = nullptr;
		MarkUnset(c, doRefCount);
	}

	c = rMChild[node];
	if (c != 0xFF) {
		if ((doRefCount) && (nullptr != subRegs[c]) && (&needExtract != subRegs[c]) && (&needConcat != subRegs[c])) {
			parent->decRefFunc(subRegs[c]);
		}
		
		subRegs[c] = nullptr;
		MarkUnset(c, doRefCount);
	}
}

void *OverlappedRegistersEnvironment::OverlappedRegister::Get(nodep::DWORD node, nodep::DWORD concreteValue) {
	if (subRegs[node] == &needExtract) {
		nodep::DWORD c;
		c = node;
		while ((c != 0xFF) && (subRegs[c] == &needExtract)) {
			c = rParent[c];
		}

		if (c == 0xFF) {
			DEBUG_BREAK;
		}

		return parent->exec->ExtractBits(
			subRegs[c],
			rOff[node],
			rSize[node]
		);
	}
	else if (subRegs[node] == &needConcat) {
		nodep::DWORD msz = rSize[rMChild[node]];

		nodep::DWORD msk = (1 << msz) - 1;
		nodep::DWORD mVal = (concreteValue >> msz) & msk;
		nodep::DWORD lVal = concreteValue & msk;

		void *ms = Get(rMChild[node], mVal);
		if (nullptr == ms) {
			ms = parent->exec->MakeConst(
				mVal,
				msz
			);
		}

		void *ls = Get(rLChild[node], lVal);
		if (nullptr == ls) {
			ls = parent->exec->MakeConst(
				lVal,
				msz
			);
		}

		return parent->exec->ConcatBits(ms, ls);
	}
	else {
		return subRegs[node];
	}
}

void OverlappedRegistersEnvironment::OverlappedRegister::SetParent(OverlappedRegistersEnvironment *p) {
	parent = p;
}

void *OverlappedRegistersEnvironment::OverlappedRegister::Get(RiverRegister &reg, nodep::DWORD &concreteValue) {
	nodep::BYTE idx = (reg.name >> 3);

	if (idx > 3) {
		DEBUG_BREAK; // do not handle special registers yet
	}

	nodep::DWORD seed = rSeed[idx];
	void *ret = Get(seed, concreteValue);

	concreteValue >>= rOff[idx];
	concreteValue &= ((1 << (rSize[idx] - 1)) << 1) - 1;

	return ret;
}

// recursive function that should mark node parent for needConcat
//
void OverlappedRegistersEnvironment::OverlappedRegister::MarkNeedConcat(nodep::DWORD node, bool doRefCount) {
	// is symbolic or needExtract
	if ((nullptr != subRegs[node]) && (&needConcat != subRegs[node])) {
		// if it has child and child needs extract
		if ((0xFF != rLChild[node]) && (&needExtract == subRegs[rLChild[node]])) {
			void *symbolicValue = subRegs[node];
			// cannot be needConcat
			// xX lowest 16bit reg matches this requirement
			if (&needExtract == symbolicValue) {
				symbolicValue = parent->exec->ExtractBits(subRegs[rParent[node]],
						rOff[node],
						rSize[node]);
				subRegs[node] = symbolicValue;
			}
			subRegs[rLChild[node]] = parent->exec->ExtractBits(
				subRegs[node],
				rOff[rLChild[node]],
				rSize[rLChild[node]]
			);

			if (doRefCount) {
				parent->addRefFunc(subRegs[rLChild[node]]);
			}
		}

		if ((0xFF != rMChild[node]) && (&needExtract == subRegs[rMChild[node]])) {
			void *symbolicValue = subRegs[node];
			// cannot be needConcat
			// xX lowest 16bit reg matches this requirement
			if (&needExtract == symbolicValue) {
				symbolicValue = parent->exec->ExtractBits(subRegs[rParent[node]],
						rOff[node],
						rSize[node]);
				subRegs[node] = symbolicValue;
			}
			subRegs[rMChild[node]] = parent->exec->ExtractBits(
				subRegs[node],
				rOff[rMChild[node]],
				rSize[rMChild[node]]
			);

			if (doRefCount) {
				parent->addRefFunc(subRegs[rMChild[node]]);
			}
		}

		if (doRefCount) {
			parent->decRefFunc(subRegs[node]);
		}
	}

	// Possible bug
	if (0xFF != rParent[node]) {
		MarkNeedConcat(rParent[node], doRefCount);
	}
	subRegs[node] = &needConcat;
}

void OverlappedRegistersEnvironment::OverlappedRegister::Set(RiverRegister &reg, void *value, bool doRefCount) {
	nodep::BYTE idx = (reg.name >> 3);

	if (idx > 3) {
		DEBUG_BREAK; // do not handle special registers yet
	}

	nodep::DWORD seed = rSeed[idx];

	// set the current register
	if (doRefCount) {
		if ((nullptr != subRegs[seed]) && (&needExtract != subRegs[seed]) && (&needConcat != subRegs[seed])) {
			parent->decRefFunc(subRegs[seed]);
		}
		if (parent->addRefFunc == nullptr)
			DEBUG_BREAK;
		parent->addRefFunc(value);
	}
	subRegs[seed] = value;

	// mark parents as needing concat
	/*for (rev::DWORD c = rParent[seed]; c != 0xFF; c = rParent[c]) {
		if ((doRefCount) && (nullptr != subRegs[c]) && (&needExtract != subRegs[c]) && (&needConcat != subRegs[c])) {
			parent->decRefFunc(subRegs[c]);
		}
		subRegs[c] = &needConcat;
	}*/
	if (0xFF != rParent[seed]) {
		MarkNeedConcat(rParent[seed], doRefCount);
	}

	// mark children as needing extract
	MarkNeedExtract(seed, doRefCount);
}

bool OverlappedRegistersEnvironment::OverlappedRegister::Unset(RiverRegister &reg, bool doRefCount) {
	nodep::BYTE idx = (reg.name >> 3);

	if (idx > 3) {
		DEBUG_BREAK; // do not handle special registers yet
	}

	nodep::DWORD seed = rSeed[idx];
	// set the current register
	subRegs[seed] = nullptr;

	// unset parents if both children are unset
	for (nodep::DWORD c = rParent[seed]; c != 0xFF; c = rParent[c]) {
		if ((nullptr == subRegs[rMChild[c]]) && (nullptr == subRegs[rLChild[c]])) {
			subRegs[c] = nullptr;
		}
		else {
			// if parent is marked needConcat, all needExtract children must be resolved
			MarkNeedConcat(c, doRefCount);
		}
	}

	// unset children as well
	MarkUnset(seed, doRefCount);

	return (subRegs[0] == nullptr);
}

void OverlappedRegistersEnvironment::OverlappedRegister::SaveState(stk::LargeStack &stack) {
	for (int i = 0; i < 5; ++i) {
		stack.Push((DWORD)subRegs[i]);
	}
}

void OverlappedRegistersEnvironment::OverlappedRegister::LoadState(stk::LargeStack &stack) {
	for (int i = 4; i >= 0; ++i) {
		subRegs[i] = (void *)stack.Pop();
	}
}

bool OverlappedRegistersEnvironment::_SetCurrentInstruction(RiverInstruction *instruction, void *opBuffer) {
	current = instruction;
	return true;
}

void OverlappedRegistersEnvironment::_SetReferenceCounting(AddRefFunc addRef, DecRefFunc decRef) {
	addRefFunc = addRef;
	decRefFunc = decRef;
}

void OverlappedRegistersEnvironment::_PushState(stk::LargeStack &stack) {
	for (int i = 0; i < 8; ++i) {
		subRegisters[i].SaveState(stack);
	}
}

void OverlappedRegistersEnvironment::_PopState(stk::LargeStack &stack) {
	for (int i = 7; i >= 0; --i) {
		subRegisters[i].LoadState(stack);
	}
}

OverlappedRegistersEnvironment::OverlappedRegistersEnvironment() {
	for (int i = 7; i >= 0; --i) {
		subRegisters[i].SetParent(this);
	}
}

bool OverlappedRegistersEnvironment::GetAddressBase(struct OperandInfo &opInfo) {
	bool ret = subEnv->GetAddressBase(opInfo);
	if ((RIVER_OPTYPE(current->opTypes[opInfo.opIdx]) != RIVER_OPTYPE_MEM) ||
			(0 == current->operands[opInfo.opIdx].asAddress->type)) {
		return ret;
	}

	if (0 == (current->operands[opInfo.opIdx].asAddress->type & RIVER_ADDR_BASE)) {
		return ret;
	}

	if (opInfo.fields & OP_HAS_SYMBOLIC) {
		opInfo.symbolic = ((OverlappedRegister *)opInfo.symbolic)->Get(
				current->operands[opInfo.opIdx].asAddress->base, opInfo.concreteBefore);
		opInfo.fields &= ~OP_HAS_SYMBOLIC;
		opInfo.fields |= (opInfo.symbolic != nullptr) ? OP_HAS_SYMBOLIC : 0;
	}

	return true;
}


bool OverlappedRegistersEnvironment::GetAddressScaleAndIndex(struct OperandInfo &opInfo, nodep::BYTE &scale) {
	bool ret = subEnv->GetAddressScaleAndIndex(opInfo, scale);
	if ((RIVER_OPTYPE(current->opTypes[opInfo.opIdx]) != RIVER_OPTYPE_MEM) ||
			(0 == current->operands[opInfo.opIdx].asAddress->type)) {
		return ret;
	}

	if (0 == (current->operands[opInfo.opIdx].asAddress->type & RIVER_ADDR_INDEX)) {
		return ret;
	}

	if (opInfo.fields & OP_HAS_SYMBOLIC) {
		opInfo.symbolic = ((OverlappedRegister *)opInfo.symbolic)->Get(
				current->operands[opInfo.opIdx].asAddress->index, opInfo.concreteBefore);
		opInfo.fields &= ~OP_HAS_SYMBOLIC;
		opInfo.fields |= (opInfo.symbolic != nullptr) ? OP_HAS_SYMBOLIC : 0;
	}
	return true;
}

// displacement cannot have symbolic values, it is stored in x86 code
bool OverlappedRegistersEnvironment::GetAddressDisplacement(const nodep::BYTE opIdx, struct AddressDisplacement &addressDisplacement) {
	return subEnv->GetAddressDisplacement(opIdx, addressDisplacement);
}

bool OverlappedRegistersEnvironment::GetOperand(struct OperandInfo &opInfo) {
	//return subEnv->GetOperand(opIdx, isTracked, concreteValue, symbolicValue);

	opInfo.symbolic = nullptr; 
	switch (RIVER_OPTYPE(current->opTypes[opInfo.opIdx])) {
		case RIVER_OPTYPE_REG :
			if (!subEnv->GetOperand(opInfo)) {
				return false;
			}

			if (opInfo.fields & OP_HAS_SYMBOLIC) {
				opInfo.symbolic = ((OverlappedRegister *)opInfo.symbolic)->Get(
						current->operands[opInfo.opIdx].asRegister, opInfo.concreteBefore);
				opInfo.fields &= ~OP_HAS_SYMBOLIC;
				opInfo.fields |= (opInfo.symbolic != nullptr) ? OP_HAS_SYMBOLIC : 0;
			}
			return true;

		case RIVER_OPTYPE_MEM :
			if (0 == current->operands[opInfo.opIdx].asAddress->type) {
				if (!subEnv->GetOperand(opInfo)) {
					return false;
				}

				if (opInfo.fields & OP_HAS_SYMBOLIC) {
					opInfo.symbolic = ((OverlappedRegister *)opInfo.symbolic)->Get(
							current->operands[opInfo.opIdx].asAddress->base, opInfo.concreteBefore);
					opInfo.fields &= ~OP_HAS_SYMBOLIC;
					opInfo.fields |= (opInfo.symbolic != nullptr) ? OP_HAS_SYMBOLIC : 0;
				}

				return true;
			}

			// no break/return on purpose
		default :
			return subEnv->GetOperand(opInfo);
	};
}

bool OverlappedRegistersEnvironment::SetOperand(nodep::BYTE opIdx, void *symbolicValue, bool doRefCount) {

	OverlappedRegister *reg;

	switch (RIVER_OPTYPE(current->opTypes[opIdx])) {
		case RIVER_OPTYPE_REG :
			reg = &subRegisters[_GetFundamentalRegister(current->operands[opIdx].asRegister.name)];
			reg->Set(current->operands[opIdx].asRegister, symbolicValue, doRefCount);

			return subEnv->SetOperand(opIdx, reg, false);

		case RIVER_OPTYPE_MEM :
			if (0 == current->operands[opIdx].asAddress->type) {
				reg = &subRegisters[_GetFundamentalRegister(current->operands[opIdx].asAddress->base.name)];
				reg->Set(current->operands[opIdx].asAddress->base, symbolicValue, doRefCount);

				return subEnv->SetOperand(opIdx, reg, false);
			}

			// no break/return on purpose
		default :
			return subEnv->SetOperand(opIdx, symbolicValue, doRefCount);
	}
}

bool OverlappedRegistersEnvironment::UnsetOperand(nodep::BYTE opIdx, bool doRefCount) {
	OverlappedRegister *reg;

	switch (RIVER_OPTYPE(current->opTypes[opIdx])) {
	case RIVER_OPTYPE_REG:
		reg = &subRegisters[_GetFundamentalRegister(current->operands[opIdx].asRegister.name)];
		if (reg->Unset(current->operands[opIdx].asRegister, doRefCount)) {
			return subEnv->UnsetOperand(opIdx, false);
		}
		return true;

	case RIVER_OPTYPE_MEM:
		if (0 == current->operands[opIdx].asAddress->type) {
			reg = &subRegisters[_GetFundamentalRegister(current->operands[opIdx].asAddress->base.name)];
			if (reg->Unset(current->operands[opIdx].asAddress->base, doRefCount)) {
				return subEnv->UnsetOperand(opIdx, false);
			}
			return true;
		}

		// no break on purpose
	default :
		return subEnv->UnsetOperand(opIdx, doRefCount);
	}
}



```

`SymbolicEnvironment/OverlappedRegisters.h`:

```h
#ifndef _OVERLAPPED_REGISTERS_H_
#define _OVERLAPPED_REGISTERS_H_

#include "LargeStack.h"
#include "SymbolicEnvironment.h"

#include "../revtracer/river.h"

class OverlappedRegistersEnvironment : public sym::ScopedSymbolicEnvironment {
private :
	class OverlappedRegister {
	private:
		void *subRegs[5];
		static const nodep::DWORD rOff[5], rSize[5], rParent[5], rMChild[5], rLChild[5];
		static const nodep::DWORD rSeed[4];
		static nodep::DWORD needConcat, needExtract;
		OverlappedRegistersEnvironment *parent;

		// marks children as need extraction
		void MarkNeedExtract(nodep::DWORD node, bool doRefCount);
		void MarkNeedConcat(nodep::DWORD node, bool doRefCount);
		void MarkUnset(nodep::DWORD node, bool doRefCount);

		void *Get(nodep::DWORD node, nodep::DWORD concreteValue);
	public:
		OverlappedRegister();

		void SetParent(OverlappedRegistersEnvironment *p);

		void *Get(RiverRegister &reg, nodep::DWORD &concreteValue);
		void Set(RiverRegister &reg, void *value, bool doRefCount);
		bool Unset(RiverRegister &reg, bool doRefCount);

		void SaveState(stk::LargeStack &stack);
		void LoadState(stk::LargeStack &stack);
	} subRegisters[8];

	RiverInstruction *current;
	AddRefFunc addRefFunc;
	DecRefFunc decRefFunc;

protected :
	virtual bool _SetCurrentInstruction(RiverInstruction *instruction, void *opBuffer);

	virtual void _SetReferenceCounting(AddRefFunc addRef, DecRefFunc decRef);

	virtual void _PushState(stk::LargeStack &stack);
	virtual void _PopState(stk::LargeStack &stack);

public :
	OverlappedRegistersEnvironment();

	virtual bool GetOperand(struct OperandInfo &opInfo);
	virtual bool GetAddressBase(struct OperandInfo &opInfo);
	virtual bool GetAddressScaleAndIndex(struct OperandInfo &opInfo, nodep::BYTE &scale);
	virtual bool GetAddressDisplacement(const nodep::BYTE opIdx, struct AddressDisplacement &addressDisplacement);
	virtual bool SetOperand(nodep::BYTE opIdx, void *symbolicValue, bool doRefCount);
	virtual bool UnsetOperand(nodep::BYTE opIdx, bool doRefCount);
};

#endif

```

`SymbolicEnvironment/RevSymbolicEnvironment.cpp`:

```cpp
#include "RevSymbolicEnvironment.h"

#include "../revtracer/execenv.h"
#include "../revtracer/Tracking.h"
#include "../Execution/Execution.h"

static nodep::BYTE _GetFundamentalRegister(nodep::BYTE reg) {
	if (reg < 0x20) {
		return reg & 0x07;
	}
	return reg;
}

void NoAddRef(void *) {}
void NoDecRef(void *) {}

nodep::DWORD TrackAddrWrapper(void *pEnv, nodep::DWORD dwAddr, nodep::DWORD segSel) {
	nodep::DWORD ret = TrackAddr(pEnv, dwAddr, segSel);
	fprintf(stderr, "<info> TrackAddr 0x%08lx => 0x%08lx\n", dwAddr, ret);
	return ret;
}

nodep::DWORD MarkAddrWrapper(void *pEnv, nodep::DWORD dwAddr, nodep::DWORD value, nodep::DWORD segSel) {
	fprintf(stderr, "<info> MarkAddr 0x%08lx <= %lu\n", dwAddr, value);
	return MarkAddr(pEnv, dwAddr, value, segSel);
}

RevSymbolicEnvironment::RevSymbolicEnvironment(void *revEnv, ExecutionController *ctl) {
	ctrl = ctl;
	pEnv = revEnv;

	addRefFunc = NoAddRef;
	decRefFunc = NoDecRef;
}

void RevSymbolicEnvironment::GetOperandLayout(const RiverInstruction &rIn) {
	unsigned int trackIndex = 0;

	for (unsigned int i = 0; i < 4; ++i) {
		addressOffsets[i] = 0xFFFFFFFF;
		inValueOffsets[i] = 0xFFFFFFFF;
		outValueOffsets[i] = 0xFFFFFFFF;
		baseOffsets[i] = 0xFFFFFFFF;
		indexOffsets[i] = 0xFFFFFFFF;
	}

	inFlagOffset = outFlagOffset = 0xFFFFFFFF;

	for (int i = 3; i >= 0; --i) {
		// if memory operand and it is constructed from non-zero addr components
		if ((RIVER_OPTYPE(rIn.opTypes[i]) == RIVER_OPTYPE_MEM) && (0 != rIn.operands[i].asAddress->type)) {
			addressOffsets[i] = trackIndex;
			// for segmented addresses both segment and address are tracked
			trackIndex += rIn.operands[i].asAddress->HasSegment() ? 2 : 1;

			// increase trackIndex if base exists
			if (rIn.operands[i].asAddress->type & RIVER_ADDR_BASE) {
				baseOffsets[i] = trackIndex;
				trackIndex++;
			}

			// increase trackIndex if index exists
			if (rIn.operands[i].asAddress->type & RIVER_ADDR_INDEX) {
				indexOffsets[i] = trackIndex;
				trackIndex++;
			}

			/*if (0 == (rIn.specifiers & RIVER_SPEC_IGNORES_MEMORY)) {
				valueOffsets[i] = trackIndex + 1; // look at the layout one more time
				trackIndex += 2;
			}*/
		}
	}

	//if ((0 == (RIVER_SPEC_IGNORES_FLG & rIn.specifiers)) || (rIn.modFlags)) {
	if (rIn.testFlags | rIn.modFlags) {
		inFlagOffset = trackIndex;
		trackIndex++;
	}

	for (int i = 3; i >= 0; --i) {
		if (0 == (RIVER_SPEC_IGNORES_OP(i) & rIn.specifiers)) {
			switch (RIVER_OPTYPE(rIn.opTypes[i])) {
			case RIVER_OPTYPE_NONE:
			case RIVER_OPTYPE_IMM:
				break;
			case RIVER_OPTYPE_MEM:
				if (0 == (rIn.specifiers & RIVER_SPEC_IGNORES_MEMORY)) {
					if (0 == rIn.operands[i].asAddress->type) {
						inValueOffsets[i] = trackIndex;
						trackIndex++;
					} else {
						inValueOffsets[i] = trackIndex + 1;
						trackIndex += 2;
					}
				}
			case RIVER_OPTYPE_REG:
				inValueOffsets[i] = trackIndex;
				trackIndex++;
				break;
			default:
				DEBUG_BREAK;
			}
		}
	}


	if (rIn.modFlags) {
		outFlagOffset = trackIndex;
		trackIndex++;
	}

	for (int i = 3; i >= 0; --i) {
		if (RIVER_SPEC_MODIFIES_OP(i) & rIn.specifiers) {
			switch (RIVER_OPTYPE(rIn.opTypes[i])) {
			case RIVER_OPTYPE_NONE:
			case RIVER_OPTYPE_IMM:
				break;
			case RIVER_OPTYPE_MEM:
				if (0 == (rIn.specifiers & RIVER_SPEC_IGNORES_MEMORY)) {
					if (0 == rIn.operands[i].asAddress->type) {
						inValueOffsets[i] = trackIndex;
						trackIndex++;
					}
					else {
						inValueOffsets[i] = trackIndex + 1;
						trackIndex += 2;
					}
				}
			case RIVER_OPTYPE_REG:
				inValueOffsets[i] = trackIndex;
				trackIndex++;
				break;
			default:
				DEBUG_BREAK;
			}
		}
	}
}

template <nodep::BYTE offset, nodep::BYTE size> void *RevSymbolicEnvironment::GetSubexpression(nodep::DWORD address) {
	void *symExpr = (void *)TrackAddrWrapper(pEnv, address, 0);
	if (symExpr == nullptr) {
		return nullptr;
	}

	return exec->ExtractBits(symExpr, offset << 3, size << 3);
}

template <> void *RevSymbolicEnvironment::GetSubexpression<0, 4>(nodep::DWORD address) {
	void *symExpr = (void *)TrackAddrWrapper(pEnv, address, 0);

	if (nullptr != symExpr) {
		addRefFunc(symExpr);
	}

	return symExpr;
}

void *RevSymbolicEnvironment::GetSubexpressionInvalid(nodep::DWORD address) {
	DEBUG_BREAK;
}

RevSymbolicEnvironment::GetSubExpFunc RevSymbolicEnvironment::subExpsGet[4][5] = {
	{ nullptr, &RevSymbolicEnvironment::GetSubexpression<0, 1>, &RevSymbolicEnvironment::GetSubexpression<0, 2>,  &RevSymbolicEnvironment::GetSubexpression<0, 3>,  &RevSymbolicEnvironment::GetSubexpression<0, 4>  }, 
	{ nullptr, &RevSymbolicEnvironment::GetSubexpression<1, 1>, &RevSymbolicEnvironment::GetSubexpression<1, 2>,  &RevSymbolicEnvironment::GetSubexpression<1, 3>,  &RevSymbolicEnvironment::GetSubexpressionInvalid },
	{ nullptr, &RevSymbolicEnvironment::GetSubexpression<2, 1>, &RevSymbolicEnvironment::GetSubexpression<2, 2>,  &RevSymbolicEnvironment::GetSubexpressionInvalid, &RevSymbolicEnvironment::GetSubexpressionInvalid },
	{ nullptr, &RevSymbolicEnvironment::GetSubexpression<3, 1>, &RevSymbolicEnvironment::GetSubexpressionInvalid, &RevSymbolicEnvironment::GetSubexpressionInvalid, &RevSymbolicEnvironment::GetSubexpressionInvalid },
};

void *RevSymbolicEnvironment::GetExpression(nodep::DWORD address, nodep::DWORD size) {
	static const nodep::DWORD sizes[3] = { 4, 2, 1 };
	nodep::DWORD sz = sizes[RIVER_OPSIZE(size)];
	
	void *ret = nullptr;

	while (sz) {
		nodep::DWORD fa = address & (~0x03), fo = address & 0x03;
		nodep::DWORD copy = 4 - fo;

		if (sz < copy) {
			copy = sz;
		}

		void *tmp = (this->*subExpsGet[fo][copy])(address);

		if (nullptr == ret) {
			ret = tmp;
		} else {
			void *newret = exec->ConcatBits(ret, tmp);
			decRefFunc(ret);
			ret = newret;
		}

		address += copy;
		sz -= copy;
	}

	return ret;
}

//set expr from offset to offset + size
template<nodep::BYTE offset, nodep::BYTE size> void RevSymbolicEnvironment::SetSubexpression(void *expr, nodep::DWORD address, void *value) {
	/* z3: | |x| | |
	 *      3 2 1 0
	 * dw: | | |x| |
	 *	    0 1 2 3
	 */
	nodep::DWORD operandSzL = (4 - offset - size) << 3;
	nodep::DWORD operandSzR = offset << 3;
	nodep::DWORD operandSzM = size << 3;

	void *retRight = exec->ExtractBits(value, 0, operandSzR);

	if (expr == nullptr) {
		expr = exec->MakeConst(((nodep::DWORD)value >> operandSzL) & ((1 << operandSzM) - 1),
				operandSzM);
	}
	void *retMidRight = exec->ConcatBits(expr, retRight);
	decRefFunc(retRight);

	void *retLeft = exec->ExtractBits(value, operandSzM + operandSzR, operandSzL);
	void *ret = exec->ConcatBits(retLeft, retMidRight);
	decRefFunc(retMidRight);
	decRefFunc(retLeft);

	nodep::DWORD r = MarkAddrWrapper(pEnv, address, (nodep::DWORD)ret, 0);
	if (0 != r) {
		decRefFunc((void *)r);
	}
}

/*set expr on right-most bytes*/
template<nodep::BYTE size> void RevSymbolicEnvironment::SetSubexpressionOffM(void *expr, nodep::DWORD address, void *value) {
	/* z3: |x| | | |
	 *      3 2 1 0
	 * dw: | | | |x|
	 *	    0 1 2 3
	 */
	nodep::DWORD operandSzL = size << 3;
	nodep::DWORD operandSzR = (4 - size) << 3;
	void *retRight = exec->ExtractBits(value, 0, operandSzR);

	if (expr == nullptr) {
		expr = exec->MakeConst(((nodep::DWORD)value) >> operandSzR,
				operandSzL);
	}

	void *ret = exec->ConcatBits(expr, retRight);

	decRefFunc(retRight);
	//addRefFunc(ret2);
	nodep::DWORD r = MarkAddrWrapper(pEnv, address, (nodep::DWORD)ret, 0);
	if (0 != r) {
		decRefFunc((void *)r);
	}
}

/* `size` = size in bytes of `expr`
 * `expr` = SE that marks letf-most `size` bytes
 *
 * why dword and address have different layout:
 * we intend to mark left-most size bytes with SE `expr`
 */
template<nodep::BYTE size> void RevSymbolicEnvironment::SetSubexpressionOff0(void *expr, nodep::DWORD address, void *value) {
    /* z3: | | | |x|
	 *      3 2 1 0
	 * dw: |x| | | |
	 *	    0 1 2 3
	 */
	unsigned operandSzL = (4 - size) << 3;
	unsigned operandSzR = size << 3;
	// extract bytes from zero to operandSzR. consider the `dword` layout
	void *retLeft = exec->ExtractBits(value, operandSzR, operandSzL);

	if (expr == nullptr) {
		// dw processing x86
		// WARN: valid expr should not have value `0`
		expr = exec->MakeConst(((nodep::DWORD)value) & ((1 << operandSzR) - 1),
				operandSzR);
	}

	//considering `dword` layout, we concatenate SE `expr` with
	//the remaining of `value`
	void *ret = exec->ConcatBits(retLeft, expr);

	decRefFunc(retLeft);

	nodep::DWORD r = MarkAddr(pEnv, address, (nodep::DWORD)ret, 0);
	if (0 != r) {
		decRefFunc((void *)r);
	}
}

/* `expr` corresponds to memory at `address`, all 4 bytes from offset 0*/
template <> void RevSymbolicEnvironment::SetSubexpression<0, 4>(void *expr, nodep::DWORD address, void *value) {
	if (nullptr != expr) {
		addRefFunc(expr);
	}
	nodep::DWORD r = MarkAddr(pEnv, address, (nodep::DWORD)expr, 0);
	if (0 != r) {
		decRefFunc((void *)r);
	}
}

void RevSymbolicEnvironment::SetSubexpressionInvalid(void *expr, nodep::DWORD address, void *value) {
	DEBUG_BREAK;
}

RevSymbolicEnvironment::SetSubExpFunc RevSymbolicEnvironment::subExpsSet[4][5] = {
	{ nullptr, &RevSymbolicEnvironment::SetSubexpressionOff0<1>, &RevSymbolicEnvironment::SetSubexpressionOff0<2>, &RevSymbolicEnvironment::SetSubexpressionOff0<3>, &RevSymbolicEnvironment::SetSubexpression<0, 4>  },
	{ nullptr, &RevSymbolicEnvironment::SetSubexpression<1, 1>,  &RevSymbolicEnvironment::SetSubexpression<1, 2>,  &RevSymbolicEnvironment::SetSubexpressionOffM<3>,  &RevSymbolicEnvironment::SetSubexpressionInvalid },
	{ nullptr, &RevSymbolicEnvironment::SetSubexpression<2, 1>,  &RevSymbolicEnvironment::SetSubexpressionOffM<2>,  &RevSymbolicEnvironment::SetSubexpressionInvalid, &RevSymbolicEnvironment::SetSubexpressionInvalid },
	{ nullptr, &RevSymbolicEnvironment::SetSubexpressionOffM<1>, &RevSymbolicEnvironment::SetSubexpressionInvalid, &RevSymbolicEnvironment::SetSubexpressionInvalid, &RevSymbolicEnvironment::SetSubexpressionInvalid }
};

/*this will set symbolic expression `expr` at address depending
 * on the addressing type and size
 * valid approaches are:
 * * 4 bytes on 4 bytes
 * * `size` bytes written from 0 offset
 * * `size` bytes written to MAX offset
 * * `size` bytes written from `offset`
 */
void RevSymbolicEnvironment::SetExpression(void *exp, nodep::DWORD address, nodep::DWORD size, nodep::DWORD *values) {
	static const nodep::DWORD sizes[3] = { 4, 2, 1 };
	nodep::DWORD sz = sizes[RIVER_OPSIZE(size)];
	nodep::DWORD osz = sz;
	nodep::DWORD ptr = 0;

	while (sz) {
		nodep::DWORD fa = address & (~0x03), fo = address & 0x03;
		nodep::DWORD copy = 4 - fo;

		if (sz < copy) {
			copy = sz;
		}

		void *ext = (osz == copy) ? exp : exec->ExtractBits(exp, (sz - copy) << 3, copy << 3);

		void *val = (void *)TrackAddr(pEnv, fa, 0);
		if (((0 != fo) || (4 != sz)) && (nullptr == val)) {
			val = exec->MakeConst(values[ptr], 32);
		}


		(this->*subExpsSet[fo][copy])(ext, address, val);

		if (ext != exp) {
			decRefFunc(ext);
		}
		ptr++;

		address += copy;
		sz -= copy;
	}
}

void RevSymbolicEnvironment::SetReferenceCounting(AddRefFunc addRef, DecRefFunc decRef) {
	addRefFunc = addRef;
	decRefFunc = decRef;
}

bool RevSymbolicEnvironment::SetCurrentInstruction(RiverInstruction *rIn, void *context) {
	opBase = (nodep::DWORD *)context;
	current = rIn;

	GetOperandLayout(*current);
	return true;
}

void RevSymbolicEnvironment::PushState(stk::LargeStack &stack) { }
void RevSymbolicEnvironment::PopState(stk::LargeStack &stack) { }

bool RevSymbolicEnvironment::GetAddressBase(struct OperandInfo &opInfo) {
	if ((RIVER_OPTYPE(current->opTypes[opInfo.opIdx]) != RIVER_OPTYPE_MEM) ||
			(0 == current->operands[opInfo.opIdx].asAddress->type)) {
		return false;
	}

	if (0 == (current->operands[opInfo.opIdx].asAddress->type & RIVER_ADDR_BASE)) {
		return false;
	}

	opInfo.symbolic = (void *)((ExecutionEnvironment *)pEnv)->runtimeContext.taintedRegisters[_GetFundamentalRegister(
		current->operands[opInfo.opIdx].asAddress->base.name)];
	opInfo.fields = (opInfo.symbolic != NULL) ? OP_HAS_SYMBOLIC : 0;
	if (opInfo.fields) {
		fprintf(stderr, "GetAddressBase [%d] => symb [0x%08lX]\n", opInfo.opIdx, (DWORD)opInfo.symbolic);
	}
	opInfo.concreteBefore = opBase[-((int)baseOffsets[opInfo.opIdx])];
	opInfo.fields |= OP_HAS_CONCRETE_BEFORE;
	return true;
}

bool RevSymbolicEnvironment::GetAddressScaleAndIndex(struct OperandInfo &opInfo, nodep::BYTE &scale) {
	if ((RIVER_OPTYPE(current->opTypes[opInfo.opIdx]) != RIVER_OPTYPE_MEM) ||
			(0 == current->operands[opInfo.opIdx].asAddress->type)) {
		return false;
	}

	if (0 == (current->operands[opInfo.opIdx].asAddress->type & RIVER_ADDR_INDEX)) {
		return false;
	}

	scale = current->operands[opInfo.opIdx].asAddress->GetScale();
	opInfo.symbolic = (void *)((ExecutionEnvironment *)pEnv)->runtimeContext.taintedRegisters[_GetFundamentalRegister(
		current->operands[opInfo.opIdx].asAddress->index.name)];
	opInfo.fields = (opInfo.symbolic != NULL) ? OP_HAS_SYMBOLIC : 0;
	if (opInfo.fields) {
		fprintf(stderr, "GetAddressScaleAndIndex [%d] => symb [0x%08lX]\n", opInfo.opIdx, (DWORD)opInfo.symbolic);
	}
	opInfo.concreteBefore = opBase[-((int)indexOffsets[opInfo.opIdx])];
	opInfo.fields |= OP_HAS_CONCRETE_BEFORE;
	return true;
}

bool RevSymbolicEnvironment::GetAddressDisplacement(const nodep::BYTE opIdx, struct AddressDisplacement &addressDisplacement) {
	if ((RIVER_OPTYPE(current->opTypes[opIdx]) != RIVER_OPTYPE_MEM) ||
			(0 == current->operands[opIdx].asAddress->type)) {
		return false;
	}

	if (current->operands[opIdx].asAddress->type & RIVER_ADDR_DISP8) {
		addressDisplacement.type = RIVER_ADDR_DISP8;
		addressDisplacement.disp = (nodep::DWORD)current->operands[opIdx].asAddress->disp.d8;
	} else if (current->operands[opIdx].asAddress->type & RIVER_ADDR_DISP) {
		addressDisplacement.type = RIVER_ADDR_DISP;
		addressDisplacement.disp = current->operands[opIdx].asAddress->disp.d32;
	} else {
		return false;
	}

	return true;
}

bool RevSymbolicEnvironment::GetOperand(struct OperandInfo &opInfo) {
	void *symExpr;

	if (RIVER_SPEC_IGNORES_OP(opInfo.opIdx) & current->specifiers) {
		return false;
	}

	switch (RIVER_OPTYPE(current->opTypes[opInfo.opIdx])) {
	case RIVER_OPTYPE_NONE:
		return false;

	case RIVER_OPTYPE_IMM:
		opInfo.fields = OP_HAS_CONCRETE_BEFORE | OP_HAS_CONCRETE_AFTER;
		switch (RIVER_OPSIZE(current->opTypes[opInfo.opIdx])) {
		case RIVER_OPSIZE_32:
			opInfo.concreteBefore = opInfo.concreteAfter = current->operands[opInfo.opIdx].asImm32;
			break;
		case RIVER_OPSIZE_16:
			opInfo.concreteBefore = opInfo.concreteAfter = current->operands[opInfo.opIdx].asImm16;
			break;
		case RIVER_OPSIZE_8:
			opInfo.concreteBefore = opInfo.concreteAfter = current->operands[opInfo.opIdx].asImm8;
			break;
		}
		return true;

	case RIVER_OPTYPE_REG:
		symExpr = (void *)((ExecutionEnvironment *)pEnv)->runtimeContext.taintedRegisters[_GetFundamentalRegister(
				current->operands[opInfo.opIdx].asRegister.name)];

		opInfo.fields = 0;

		if (symExpr) {
			opInfo.symbolic = symExpr;
			opInfo.fields |= OP_HAS_SYMBOLIC;
		}
		
		if (0xFFFFFFFF != inValueOffsets[opInfo.opIdx]) {
			opInfo.concreteBefore = opBase[-((int)inValueOffsets[opInfo.opIdx])];
			opInfo.fields |= OP_HAS_CONCRETE_BEFORE;
		}

		if (0xFFFFFFFF != outValueOffsets[opInfo.opIdx]) {
			opInfo.concreteAfter = opBase[-((int)outValueOffsets[opInfo.opIdx])];
			opInfo.fields |= OP_HAS_CONCRETE_AFTER;
		}

		//printf("[%d] <= getOperand reg 0x%lX\n", opInfo.opIdx, (DWORD)opInfo.symbolic);
		return true;

	case RIVER_OPTYPE_MEM:
		// how do we handle dereferenced symbolic values?

		if (0 == current->operands[opInfo.opIdx].asAddress->type) {
			symExpr = (void *)((ExecutionEnvironment *)pEnv)->runtimeContext.taintedRegisters[_GetFundamentalRegister(
				current->operands[opInfo.opIdx].asAddress->base.name)];

			opInfo.fields = 0;

			if (symExpr) {
				opInfo.symbolic = symExpr;
				opInfo.fields |= OP_HAS_SYMBOLIC;
			}

			if (0xFFFFFFFF != inValueOffsets[opInfo.opIdx]) {
				opInfo.concreteBefore = opBase[-((int)inValueOffsets[opInfo.opIdx])];
				opInfo.fields |= OP_HAS_CONCRETE_BEFORE;
			}

			if (0xFFFFFFFF != outValueOffsets[opInfo.opIdx]) {
				opInfo.concreteAfter = opBase[-((int)outValueOffsets[opInfo.opIdx])];
				opInfo.fields |= OP_HAS_CONCRETE_AFTER;
			}
			//printf("[%d] <= getOperand mem reg 0x%lX\n", opInfo.opIdx, (DWORD)opInfo.symbolic);
			return true;
		}

		if (RIVER_SPEC_IGNORES_MEMORY & current->specifiers) {
			return false; // for now!
		}

		//symExpr = get from opBase[opOffset[opInfo.opIdx]]

		if (opBase[-((int)addressOffsets[opInfo.opIdx])] < 0x1000) {
			DEBUG_BREAK;
		}

		symExpr = GetExpression(opBase[-((int)addressOffsets[opInfo.opIdx])],
				RIVER_OPSIZE(current->opTypes[opInfo.opIdx])); //(void *)TrackAddrWrapper(pEnv, opBase[-(addressOffsets[opInfo.opIdx])], 0);
		opInfo.fields = 0;

		if (symExpr) {
			opInfo.symbolic = symExpr;
			opInfo.fields |= OP_HAS_SYMBOLIC;
		}

		if (0xFFFFFFFF != inValueOffsets[opInfo.opIdx]) {
			opInfo.concreteBefore = opBase[-((int)inValueOffsets[opInfo.opIdx])];
			opInfo.fields |= OP_HAS_CONCRETE_BEFORE;
		}

		if (0xFFFFFFFF != outValueOffsets[opInfo.opIdx]) {
			opInfo.concreteAfter = opBase[-((int)outValueOffsets[opInfo.opIdx])];
			opInfo.fields |= OP_HAS_CONCRETE_AFTER;
		}
		return true;
	}

	return false;
}

unsigned int BinLog2(unsigned int v) {
	register unsigned int r; // result of log2(v) will go here
	register unsigned int shift;

	r = (v > 0xFFFF) << 4; v >>= r;
	shift = (v > 0xFF) << 3; v >>= shift; r |= shift;
	shift = (v > 0x0F) << 2; v >>= shift; r |= shift;
	shift = (v > 0x03) << 1; v >>= shift; r |= shift;
	r |= (v >> 1);

	return r;
}

unsigned int flagShifts[] = {
	0, //RIVER_SPEC_FLAG_CF
	2, //RIVER_SPEC_FLAG_PF
	4, //RIVER_SPEC_FLAG_AF
	6, //RIVER_SPEC_FLAG_ZF
	7, //RIVER_SPEC_FLAG_SF
	11, //RIVER_SPEC_FLAG_OF
	10 //RIVER_SPEC_FLAG_DF
};

bool RevSymbolicEnvironment::GetFlgValue(struct FlagInfo &flagInfo) {
	if (0 == (flagInfo.opIdx & current->testFlags)) {
		return false;
	}

	unsigned int flgIdx = BinLog2(flagInfo.opIdx);
	//void *expr = pEnv->runtimeContext.taintedFlags[flgIdx];

	nodep::DWORD val = ((ExecutionEnvironment *)pEnv)->runtimeContext.taintedFlags[flgIdx];

	flagInfo.fields = 0;

	if (0 != val) {
		flagInfo.symbolic = (void *)val;
		flagInfo.fields |= OP_HAS_SYMBOLIC;
	}

	if (0xFFFFFFFF != inFlagOffset) {
		flagInfo.concreteBefore = (opBase[inFlagOffset] >> flagShifts[flgIdx]) & 1;
		flagInfo.fields |= OP_HAS_CONCRETE_BEFORE;
	}

	if (0xFFFFFFFF != outFlagOffset) {
		flagInfo.concreteAfter = (opBase[outFlagOffset] >> flagShifts[flgIdx]) & 1;
		flagInfo.fields |= OP_HAS_CONCRETE_AFTER;
	}

	return true;
}

bool RevSymbolicEnvironment::SetOperand(nodep::BYTE opIdx, void *symbolicValue, bool doRefCount) {
	nodep::DWORD tmp;
	switch (RIVER_OPTYPE(current->opTypes[opIdx])) {
	case RIVER_OPTYPE_NONE:
	case RIVER_OPTYPE_IMM:
		return false;

	case RIVER_OPTYPE_REG:
		tmp = ((ExecutionEnvironment *)pEnv)->runtimeContext.taintedRegisters[_GetFundamentalRegister(current->operands[opIdx].asRegister.name)];
		if (doRefCount && (0 != tmp)) {
			decRefFunc((void *)tmp);
		}
		((ExecutionEnvironment *)pEnv)->runtimeContext.taintedRegisters[_GetFundamentalRegister(current->operands[opIdx].asRegister.name)] = (nodep::DWORD)symbolicValue;
		if (doRefCount && (nullptr != symbolicValue)) {
			addRefFunc(symbolicValue);
		}
		//printf("[%d] SetOperand Reg <= 0x%08lX TR: %08lX Freg: %d reg: %d\n", opIdx, (DWORD)symbolicValue,
		//		&((ExecutionEnvironment *)pEnv)->runtimeContext.taintedRegisters[_GetFundamentalRegister(current->operands[opIdx].asRegister.name)],
		//		current->operands[opIdx].asRegister.name);
		return true;

	case RIVER_OPTYPE_MEM:
		if (0 == current->operands[opIdx].asAddress->type) {
			tmp = ((ExecutionEnvironment *)pEnv)->runtimeContext.taintedRegisters[_GetFundamentalRegister(current->operands[opIdx].asAddress->base.name)];
			if (doRefCount && (0 != tmp)) {
				decRefFunc((void *)tmp);
			}
			((ExecutionEnvironment *)pEnv)->runtimeContext.taintedRegisters[_GetFundamentalRegister(current->operands[opIdx].asAddress->base.name)] = (nodep::DWORD)symbolicValue;
			if (doRefCount && (nullptr != symbolicValue)) {
				addRefFunc(symbolicValue);
			}
			//printf("[%d] SetOperand Mem Reg <= 0x%08lX\n", opIdx, (DWORD)symbolicValue);
		}
		else {
			//MarkAddrWrapper(pEnv, opBase[-(addressOffsets[opIdx])], (rev::DWORD)symbolicValue, 0);
			SetExpression(symbolicValue, opBase[-((int)addressOffsets[opIdx])], RIVER_OPSIZE(current->opTypes[opIdx]), &opBase[-((int)outValueOffsets[opIdx])]);
			//printf("[%d] SetOperand Mem <= 0x%08lX\n", opIdx, (DWORD)symbolicValue);
		}
		return true;

	}

	return false;
}

bool RevSymbolicEnvironment::UnsetOperand(nodep::BYTE opIdx, bool doRefCount) {
	return SetOperand(opIdx, nullptr, doRefCount);
}

void RevSymbolicEnvironment::SetFlgValue(nodep::BYTE flg, void *symbolicValue, bool doRefCount) {
	unsigned int flgIdx = BinLog2(flg);

	nodep::DWORD tmp = ((ExecutionEnvironment *)pEnv)->runtimeContext.taintedFlags[flgIdx];
	if (doRefCount && (0 != tmp)) {
		decRefFunc((void *)tmp);
	}
	((ExecutionEnvironment *)pEnv)->runtimeContext.taintedFlags[flgIdx] = (nodep::DWORD)symbolicValue;
	if (doRefCount && (nullptr != symbolicValue)) {
		addRefFunc(symbolicValue);
	}
}

void RevSymbolicEnvironment::UnsetFlgValue(nodep::BYTE flg, bool doRefCount) {
	SetFlgValue(flg, nullptr, doRefCount);
}

void RevSymbolicEnvironment::SetSymbolicVariable(const char *name, rev::ADDR_TYPE addr, nodep::DWORD size) {
	nodep::DWORD buff[2];
	ctrl->ReadProcessMemory((unsigned int)addr & ~0x03, 8, (unsigned char *)buff);

	nodep::DWORD oSize = 0;

	switch (size) {
	case 4:
		oSize = RIVER_OPSIZE_32;
		break;
	case 2:
		oSize = RIVER_OPSIZE_16;
		break;
	case 1 : 
		oSize = RIVER_OPSIZE_8;
		break;
	default :
		DEBUG_BREAK;
	}

	SetExpression(
		exec->CreateVariable(name, size),
		(nodep::DWORD)addr,
		oSize,
		buff
	);
}

```

`SymbolicEnvironment/RevSymbolicEnvironment.h`:

```h
#ifndef _REV_SYMBOLIC_ENVIRONMENT_H_
#define _REV_SYMBOLIC_ENVIRONMENT_H_

#include "SymbolicEnvironment.h"

class ExecutionController;

class RevSymbolicEnvironment : public sym::SymbolicEnvironment {
private :
	RiverInstruction *current;
	ExecutionController *ctrl;
	nodep::DWORD *opBase;
	
	nodep::DWORD addressOffsets[4];
	nodep::DWORD baseOffsets[4];
	nodep::DWORD indexOffsets[4];
	nodep::DWORD inValueOffsets[4];
	nodep::DWORD outValueOffsets[4];
	nodep::DWORD inFlagOffset;
	nodep::DWORD outFlagOffset;

	AddRefFunc addRefFunc;
	DecRefFunc decRefFunc;

	void *pEnv;

	void GetOperandLayout(const RiverInstruction &rIn);

	typedef void *(RevSymbolicEnvironment::*GetSubExpFunc)(nodep::DWORD address);
	template <nodep::BYTE offset, nodep::BYTE size> void *GetSubexpression(nodep::DWORD address);
	void *GetSubexpressionInvalid(nodep::DWORD address);
	static GetSubExpFunc subExpsGet[4][5];

	typedef void (RevSymbolicEnvironment::*SetSubExpFunc)(void *expr, nodep::DWORD address, void *value);
	template <nodep::BYTE offset, nodep::BYTE size> void SetSubexpression(void *expr, nodep::DWORD address, void *value);
	template <nodep::BYTE size> void SetSubexpressionOff0(void *expr, nodep::DWORD address, void *value);
	template <nodep::BYTE size> void SetSubexpressionOffM(void *expr, nodep::DWORD address, void *value);
	void SetSubexpressionInvalid(void *expr, nodep::DWORD address, void *value);
	static SetSubExpFunc subExpsSet[4][5];

	void *GetExpression(nodep::DWORD address, nodep::DWORD size);
	void SetExpression(void *exp, nodep::DWORD address, nodep::DWORD size, nodep::DWORD *values);


public :
	RevSymbolicEnvironment(void *revEnv, ExecutionController *ctl);

	virtual void SetReferenceCounting(AddRefFunc addRef, DecRefFunc decRef);
	virtual bool SetCurrentInstruction(RiverInstruction *instruction, void *opBuffer);

	virtual void PushState(stk::LargeStack &stack);
	virtual void PopState(stk::LargeStack &stack);

	virtual bool GetOperand(struct OperandInfo &opInfo);
	virtual bool GetAddressBase(struct OperandInfo &opInfo);
	virtual bool GetAddressScaleAndIndex(struct OperandInfo &opInfo, nodep::BYTE &scale);
	virtual bool GetAddressDisplacement(const nodep::BYTE opIdx, struct AddressDisplacement &addressDisplacement);

	virtual bool GetFlgValue(struct FlagInfo &flagInfo);
	virtual bool SetOperand(nodep::BYTE opIdx, void *symbolicValue, bool doRefCount);
	virtual bool UnsetOperand(nodep::BYTE opIdx, bool doRefCount);
	virtual void SetFlgValue(nodep::BYTE flg, void *symbolicValue, bool doRefCount);
	virtual void UnsetFlgValue(nodep::BYTE flg, bool doRefCount);

	virtual void SetSymbolicVariable(const char *name, rev::ADDR_TYPE addr, nodep::DWORD size);
};

#endif



```

`SymbolicEnvironment/SymbolicEnvironment.cpp`:

```cpp
#include "SymbolicEnvironment.h"

#include "LargeStack.h"

namespace sym {
	inline bool SymbolicEnvironment::SetExecutor(SymbolicExecutor *e) {
		exec = e;
		return true;
	}

	void sym::ScopedSymbolicEnvironment::_SetReferenceCounting(AddRefFunc addRef, DecRefFunc decRef) {
	}

	bool ScopedSymbolicEnvironment::_SetCurrentInstruction(RiverInstruction *instruction, void *opBuffer) {
		return true;
	}

	ScopedSymbolicEnvironment::ScopedSymbolicEnvironment() {
		subEnv = nullptr;
	}

	inline bool ScopedSymbolicEnvironment::SetExecutor(SymbolicExecutor *e) {
		exec = e;
		return subEnv->SetExecutor(e);
	}

	void ScopedSymbolicEnvironment::PushState(stk::LargeStack &stack) {
		subEnv->PushState(stack);
		_PushState(stack);
	}

	void ScopedSymbolicEnvironment::PopState(stk::LargeStack &stack) {
		_PopState(stack);
		subEnv->PopState(stack);
	}

	void ScopedSymbolicEnvironment::SetSymbolicVariable(const char * name, rev::ADDR_TYPE addr, nodep::DWORD size) {
		subEnv->SetSymbolicVariable(name, addr, size);
	}

	bool ScopedSymbolicEnvironment::SetSubEnvironment(SymbolicEnvironment *env) {
		subEnv = env;
		return true;
	}

	void ScopedSymbolicEnvironment::SetReferenceCounting(AddRefFunc addRef, DecRefFunc decRef) {
		_SetReferenceCounting(addRef, decRef);
		subEnv->SetReferenceCounting(addRef, decRef);
	}

	bool ScopedSymbolicEnvironment::SetCurrentInstruction(RiverInstruction *instruction, void *opBuffer) {
		if (!subEnv->SetCurrentInstruction(instruction, opBuffer)) {
			return false;
		}

		return _SetCurrentInstruction(instruction, opBuffer);
	}

	bool ScopedSymbolicEnvironment::GetOperand(struct OperandInfo &opInfo) {
		return subEnv->GetOperand(opInfo);
	}

	bool ScopedSymbolicEnvironment::GetAddressBase(struct OperandInfo &opInfo) {
		return subEnv->GetAddressBase(opInfo);
	}

	bool ScopedSymbolicEnvironment::GetAddressScaleAndIndex(struct OperandInfo &opInfo, nodep::BYTE &scale) {
		return subEnv->GetAddressScaleAndIndex(opInfo, scale);
	}

	bool ScopedSymbolicEnvironment::GetAddressDisplacement(const nodep::BYTE opIdx, struct AddressDisplacement &addressDisplacement) {
		return subEnv->GetAddressDisplacement(opIdx, addressDisplacement);
	}

	bool ScopedSymbolicEnvironment::GetFlgValue(struct FlagInfo &flagInfo) {
		return subEnv->GetFlgValue(flagInfo);
	}

	bool ScopedSymbolicEnvironment::SetOperand(nodep::BYTE opIdx, void *symbolicValue, bool doRefCount) {
		return subEnv->SetOperand(opIdx, symbolicValue, doRefCount);
	}

	bool ScopedSymbolicEnvironment::UnsetOperand(nodep::BYTE opIdx, bool doRefCount) {
		return subEnv->UnsetOperand(opIdx, doRefCount);
	}

	void ScopedSymbolicEnvironment::SetFlgValue(nodep::BYTE flg, void *symbolicValue, bool doRefCount) {
		return subEnv->SetFlgValue(flg, symbolicValue, doRefCount);
	}

	void ScopedSymbolicEnvironment::UnsetFlgValue(nodep::BYTE flg, bool doRefCount) {
		return subEnv->UnsetFlgValue(flg, doRefCount);
	}

	void SymbolicExecutor::SetModuleData(int mCount, ModuleInfo *mInfo) {
		this->mCount = mCount;
		this->mInfo = mInfo;
	}
};

```

`SymbolicEnvironment/SymbolicEnvironment.h`:

```h
#ifndef _SYMBOLIC_ENVIRONMENT_H_
#define _SYMBOLIC_ENVIRONMENT_H_

#include "../revtracer/river.h"
#include "../Execution/Execution.h"
#include "LargeStack.h"

#define OP_HAS_SYMBOLIC				1
#define OP_HAS_CONCRETE_BEFORE		2
#define OP_HAS_CONCRETE_AFTER		4

struct OperandInfo {
	nodep::BYTE opIdx;
	nodep::BYTE fields;
	nodep::DWORD concreteBefore;
	nodep::DWORD concreteAfter;
	void *symbolic;
};

struct FlagInfo {
	nodep::BYTE opIdx;
	nodep::BYTE fields;
	nodep::BYTE concreteBefore;
	nodep::BYTE concreteAfter;
	void *symbolic;
};

struct AddressDisplacement {
	nodep::BYTE type;
	nodep::DWORD disp;
};

namespace sym {

	class SymbolicExecutor;

	class SymbolicEnvironment {
	protected :
		SymbolicExecutor *exec;
	public :
		/**
		Function typed for monitoring variable reference counting
		*/
		typedef void(*AddRefFunc)(void *);
		typedef void(*DecRefFunc)(void *);

		virtual void SetReferenceCounting(AddRefFunc addRef, DecRefFunc decRef) = 0;

		/**
		*	The set current instruction gets called by the symbolic handler.
		*	This function parses instruction operands and makes them available for the SymbolicExecutor
		*	Params:
		*		instruction - input, the instruction about to be executed
		*		obBuffer - input, buffer storing concrete operand values
		*/
		virtual bool SetCurrentInstruction(RiverInstruction *instruction, void *opBuffer) = 0;

		virtual bool SetExecutor(SymbolicExecutor *e);

		virtual void PushState(stk::LargeStack &stack) = 0;
		virtual void PopState(stk::LargeStack &stack) = 0;

		virtual void SetSymbolicVariable(const char *name, rev::ADDR_TYPE addr, nodep::DWORD size) = 0;

		/**
		*	The GetOperand function returns an operand by index.
		*	Params:
		*		opInfo - struct containing operand info
		*  Result:
		*		true - if the operand can be interogated
		*		false - if the operand can't be interogated, (if the operand type is RIVER_OPERAND_NONE, or if
		*				the RIVER_SPEC_IGNORES_OP(opIdx) flag is specified).
		*/
		virtual bool GetOperand(struct OperandInfo &opInfo) = 0;

		/**
		*	The GetAddressBase function returns the base of an address operand by index.
		*	Params:
		*		opInfo - struct containing operand info
		*  Result:
		*		true - if the operand can be interogated
		*		false - if the operand can't be interogated, (all excepting RIVER_OPTYPE_MEM)
		*/
		virtual bool GetAddressBase(struct OperandInfo &opInfo) = 0;

		/**
		*	The GetAddressScaleAndIndex function returns the scale and index of an address operand by index.
		*	Params:
		*		opInfo - struct containing operand info
		*       scale - output, returns the operands scale.
		*  Result:
		*		true - if the operand can be interogated
		*		false - if the operand can't be interogated, (all excepting RIVER_OPTYPE_MEM)
		*/
		virtual bool GetAddressScaleAndIndex(struct OperandInfo &opInfo, nodep::BYTE &scale) = 0;

		/**
		*	The GetAddressDisplacement function returns the displacement value and type
		*	Params:
		*	    opIdx - operand id
		*		addressDisplacement - struct that is populated with actual info from `current`
		*  Result:
		*		true - if operand can be interogated
		*		false - if the operand can't be interogated, (all excepting RIVER_OPTYPE_MEM)
		*/
		virtual bool GetAddressDisplacement(const nodep::BYTE opIdx, struct AddressDisplacement &addressDisplacement) = 0;

		/**
		*	The GetFlgValue function returns a flag by flag value.
		*	Params:
		*		flagInfo - struct containing flag info
		*  Result:
		*		true - if the flag can be interogated
		*		false - if the flag can't be interogated, (if the flag is not in the modFlags bitmask).
		*/
		virtual bool GetFlgValue(struct FlagInfo &flagInfo) = 0;

		/**
		*  The SetOperand function binds a symbolic expression to an operand.
		*  Params:
		*		opIdx - input, specifies the operand index.
		*		symbolicValue - input, symbolic expression to bind.
		*  Result:
		*		true - if the expression was bound successfully
		*		false - otherwise
		*/
		virtual bool SetOperand(nodep::BYTE opIdx, void *symbolicValue, bool doRefCount = true) = 0;

		/**
		*  The UnsetOperand unbinds the symbolic expression from the specified operand.
		*  Params:
		*		opIdx - input, specifies the operand index.
		*/
		virtual bool UnsetOperand(nodep::BYTE opIdx, bool doRefCount = true) = 0;

		/**
		*  The SetFlgValue function binds a symbolic expression to flag.
		*  Params:
		*		flg - input, one of the RIVER_SPEC_FLAG_?F constants.
		*		symbolicValue - input, symbolic expression to bind.
		*  Result:
		*		true - if the expression was bound successfully
		*		false - otherwise
		*/
		virtual void SetFlgValue(nodep::BYTE flg, void *symbolicValue, bool doRefCount = true) = 0;

		/**
		*  The UnsetFlgValue unbinds the symbolic expression from the specified operand.
		*  Params:
		*		flg - input, one of the RIVER_SPEC_FLAG_?F constants.
		*/
		virtual void UnsetFlgValue(nodep::BYTE flg, bool doRefCount = true) = 0;
	};

	class ScopedSymbolicEnvironment : public SymbolicEnvironment {
	protected :
		SymbolicEnvironment *subEnv;

		virtual void _SetReferenceCounting(AddRefFunc addRef, DecRefFunc decRef);
		virtual bool _SetCurrentInstruction(RiverInstruction *instruction, void *opBuffer);
		
		virtual void _PushState(stk::LargeStack &stack) = 0;
		virtual void _PopState(stk::LargeStack &stack) = 0;
	public :
		ScopedSymbolicEnvironment();

		virtual bool SetExecutor(SymbolicExecutor *e);

		virtual void PushState(stk::LargeStack &stack);
		virtual void PopState(stk::LargeStack &stack);

		virtual void SetSymbolicVariable(const char *name, rev::ADDR_TYPE addr, nodep::DWORD size);

		virtual bool SetSubEnvironment(SymbolicEnvironment *env);

		virtual void SetReferenceCounting(AddRefFunc addRef, DecRefFunc decRef);
		virtual bool SetCurrentInstruction(RiverInstruction *instruction, void *opBuffer);

		virtual bool GetOperand(struct OperandInfo &opInfo);
		virtual bool GetAddressBase(struct OperandInfo &opInfo);
		virtual bool GetAddressScaleAndIndex(struct OperandInfo &opInfo, nodep::BYTE &scale);
		virtual bool GetAddressDisplacement(const nodep::BYTE opIdx, struct AddressDisplacement &addressDisplacement);
		virtual bool GetFlgValue(struct FlagInfo &flagInfo);
		virtual bool SetOperand(nodep::BYTE opIdx, void *symbolicValue, bool doRefCount);
		virtual bool UnsetOperand(nodep::BYTE opIdx, bool doRefCount);
		virtual void SetFlgValue(nodep::BYTE flg, void *symbolicValue, bool doRefCount);
		virtual void UnsetFlgValue(nodep::BYTE flg, bool doRefCount);
	};

	/** Executor class. Inherit this class to provide bindings to a SMT solver. */
	class SymbolicExecutor {
	public:
		int mCount;
		ModuleInfo *mInfo;
		SymbolicEnvironment *env;
	public:

		SymbolicExecutor(SymbolicEnvironment *e)
			: mCount(0), mInfo(nullptr), env(e)
		{}

		// Create a new symbolic variable
		// size - variable size in bytes
		virtual void *CreateVariable(const char *name, nodep::DWORD size) = 0;

		// Make a new constant
		virtual void *MakeConst(nodep::DWORD value, nodep::DWORD bits) = 0;

		// Extract bits from an expression
		virtual void *ExtractBits(void *expr, nodep::DWORD lsb, nodep::DWORD size) = 0;

		virtual void *ConcatBits(void *expr1, void *expr2) = 0;

		// Access the symbolic environment through env->* methods
		// The environment might be subject to change as more features are added
		virtual void Execute(RiverInstruction *instruction) = 0;
		void SetModuleData(int mCount, ModuleInfo *mInfo);
	};

}; // namespace sym

#endif

```

`SymbolicEnvironment/SymbolicEnvironment.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{56939285-B2AF-42A9-ADEB-E21411F84C55}</ProjectGuid>
    <RootNamespace>SymbolicEnvironment</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_BUILDING_ENVIRONMENT_DLL;_NO_TRACK_CALLBACKS_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>revtracer.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_BUILDING_ENVIRONMENT_DLL;_NO_TRACK_CALLBACKS_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\revtracer\Tracking.h" />
    <ClInclude Include="Environment.h" />
    <ClInclude Include="LargeStack.h" />
    <ClInclude Include="OverlappedRegisters.h" />
    <ClInclude Include="RevSymbolicEnvironment.h" />
    <ClInclude Include="SymbolicEnvironment.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\revtracer\AddressContainer.cpp" />
    <ClCompile Include="..\revtracer\Tracking.cpp" />
    <ClCompile Include="Environment.cpp" />
    <ClCompile Include="LargeStack.cpp" />
    <ClCompile Include="OverlappedRegisters.cpp" />
    <ClCompile Include="RevSymbolicEnvironment.cpp" />
    <ClCompile Include="SymbolicEnvironment.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`VirtualMemory/CMakeLists.txt`:

```txt
## VirtualMemory CMakeLists.txt

set(LIBRARY_NAME virtualmemory)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -m32 -std=c++11")

add_library(${LIBRARY_NAME} STATIC
	VirtualMem.cpp
	MemoryLayout.Linux.cpp
	../libproc/libproc.cpp
	)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`VirtualMemory/Makefile`:

```
lib_virtualmemory := libvirtualmemory.a
CC := gcc
CXX := g++

EXTERNAL_FILES := ../libproc/libproc.cpp
CPP_FILES := VirtualMem.cpp MemoryLayout.Linux.cpp $(EXTERNAL_FILES)

OBJ_FILES := $(addprefix ,$(CPP_FILES:.cpp=.o))
CXX_FLAGS += -g -m32 -std=c++11
prefix := /usr/local

all: $(lib_virtualmemory)

test_bin: $(lib_virtualmemory) Main.o
	$(CXX) -L. $(CXX_FLAGS) -o main Main.o -lbinloader -ldl

install: $(lib_virtualmemory)
	install -m 0755 $(lib_virtualmemory) -t $(prefix)/lib -D

$(lib_virtualmemory): $(OBJ_FILES)
	$(AR) rcs $@ $^

%.o: %.cpp
	   $(CXX) $(CXX_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(lib_virtualmemory) $(OBJ_FILES) *.o main

```

`VirtualMemory/MemoryLayout.Linux.cpp`:

```cpp
#if __linux__

#include "../libproc/os-linux.h"

#include "MemoryLayout.h"

#include <vector>

#include <stdio.h>

namespace vmem {
	class LinMemoryLayout : public MemoryLayout {
	private:
		process_t pid;
		std::vector<MemoryRegionInfo> regions;
	public :
		LinMemoryLayout(process_t p) {
			pid = p;
		}

		virtual bool Snapshot() {
			MemoryRegionInfo mTmp;
			struct map_iterator mi;
			if (maps_init(&mi, pid) < 0) {
				//dbg_log("[DualAllocator] Cannot retrieve /proc/%d/maps\n", pid);
				return false;
			}

			struct map_prot mp;
			unsigned long low, high, offset;

			//dbg_log("[DualAllocator] /proc/%d/maps\n", pid);
			while (maps_next(&mi, &low, &high, &offset, &mp)) {
				//dbg_log("[DualAllocator] path : %s base addr : %08lx high %08lx\n", mi.path, low, high);
				ssize_t len = regions.size();
				if (len > 1) {
					// add free region before current region
					mTmp.allocationBase = (void *)((unsigned char *)regions[len - 1].allocationBase + regions[len - 1].size);
					mTmp.size = low - (unsigned long)mTmp.allocationBase;

				} else {
					mTmp.allocationBase = (void *)0x0;
					mTmp.size = low;
				}

				if (mTmp.size > 0x00) {
					//mr.state = FREE;
					//mrs.push_back(mr);

					mTmp.baseAddress = mTmp.allocationBase;
					mTmp.state = MEMORY_REGION_FREE;
					mTmp.protection = 0;
					mTmp.moduleName = nullptr; // unsuported

					regions.push_back(mTmp);
					//dbg_log("[DualAllocator] Added FREE %08x %08x\n", mr.address, mr.size);
				}

				// add current allocated region
				mTmp.baseAddress = (void *)low;
				mTmp.allocationBase = (void *)low;
				mTmp.size = high - low;
				mTmp.state = MEMORY_REGION_COMMITED;
				mTmp.protection = 0; // unsupported
				mTmp.moduleName = nullptr; //unsupported

				regions.push_back(mTmp);
				//dbg_log("[DualAllocator] Added ALLOCATED %08x %08x\n", mr.address, mr.size);


			}
			maps_close(&mi);
		}

		virtual bool Query(void *addr, MemoryRegionInfo &out) {
			for (auto it = regions.begin(); it != regions.end(); ++it) {
				if (addr < it->allocationBase)
					continue;
				if (addr >= (unsigned char *)it->allocationBase + it->size)
					continue;

				out.baseAddress = addr;
				out.allocationBase = it->allocationBase;
				out.size = it->size - ((unsigned long)addr - (unsigned long)it->allocationBase);
				out.state = it->state;
				out.protection = it->protection;
				out.moduleName = it->moduleName;
				return true;
			}

			//shouldn't reach this point
			//printf("[DualAllocator] Could not find memory region for address %08x\n", address);
			return false;
		}

		virtual bool Debug() {
			for (auto it = regions.begin(); it != regions.end(); ++it) {
				printf("%p %08x %x %x\n",
					it->allocationBase,
					it->size,
					it->state,
					it->protection
				);
			}
		}

		virtual bool Release() {
			regions.clear();
			return true;
		}
	};


	MemoryLayout *CreateMemoryLayout(process_t process) {
		return new LinMemoryLayout(process);
	}
};


#endif
```

`VirtualMemory/MemoryLayout.Windows.cpp`:

```cpp
#if defined _WIN32 || defined __CYGWIN__


#include <Windows.h>
#include <Psapi.h>

#include "MemoryLayout.h"

namespace vmem {

	class WinMemoryLayout : public MemoryLayout {
	private :
		process_t process;
		char moduleName[MAX_PATH];

		static unsigned int MemoryState(DWORD state) {
			switch (state) {
				case MEM_COMMIT :
					return MEMORY_REGION_COMMITED;
				case MEM_RESERVE :
					return MEMORY_REGION_RESERVED;
				case MEM_FREE :
					return MEMORY_REGION_FREE;
				default :
					return MEMORY_REGION_UNKNOWN;
			}
		}

		static unsigned int MemoryProtect(DWORD protect) {
			switch (protect) {
				case PAGE_EXECUTE :
					return MEMORY_REGION_EXECUTE;
				case PAGE_EXECUTE_READ :
					return MEMORY_REGION_EXECUTE | MEMORY_REGION_READ;
				case PAGE_EXECUTE_READWRITE :
					return MEMORY_REGION_EXECUTE | MEMORY_REGION_READ | MEMORY_REGION_WRITE;
				case PAGE_NOACCESS :
					return 0;
				case PAGE_READONLY :
					return MEMORY_REGION_READ;
				case PAGE_READWRITE :
					return MEMORY_REGION_READ | MEMORY_REGION_WRITE;
				default :
					return 0;
			}
		}
	public :
		WinMemoryLayout(process_t p) {
			process = p;
		}

		virtual bool Snapshot() {
			return true;
		}

		virtual bool Query(void *addr, MemoryRegionInfo &out) {
			MEMORY_BASIC_INFORMATION32 mbi;

			if (0 == VirtualQueryEx(process, addr, (PMEMORY_BASIC_INFORMATION)&mbi, sizeof(mbi))) {
				return false;
			}

			out.baseAddress = (void *)mbi.BaseAddress;
			out.allocationBase = (void *)mbi.AllocationBase;
			out.size = mbi.RegionSize;
			out.state = MemoryState(mbi.State);
			out.protection = MemoryProtect(mbi.Protect);
			out.moduleName = moduleName;

			moduleName[0] = '\0';
			if (MEM_IMAGE == mbi.Type) {
				GetModuleFileNameExA(
					process,
					(HMODULE)addr,
					moduleName,
					sizeof(moduleName)
				);
			}
			return true;
		}

		virtual bool Debug() {
			return true;
		}

		virtual bool Release() {
			return true;
		}
	};


	MemoryLayout *CreateMemoryLayout(process_t process) {
		return new WinMemoryLayout(process);
	}
};


#endif
```

`VirtualMemory/MemoryLayout.h`:

```h
#ifndef _MEMORY_LAYOUT_H_

#include "VirtualMem.h"

namespace vmem {

#define MEMORY_REGION_FREE			0x00
#define MEMORY_REGION_RESERVED		0x01
#define MEMORY_REGION_COMMITED		0x02
#define MEMORY_REGION_UNKNOWN		0xFF

#define MEMORY_REGION_READ			0x4
#define MEMORY_REGION_WRITE			0x2
#define MEMORY_REGION_EXECUTE		0x1

	struct MemoryRegionInfo {
		void *baseAddress;
		void *allocationBase;

		unsigned int size;

		// free, reserved, protected
		unsigned int state;

		// read, write, execute
		unsigned int protection;

		char *moduleName;
	};

	class MemoryLayout {
	public:
		virtual bool Snapshot() = 0;
		virtual bool Query(void *addr, MemoryRegionInfo &out) = 0;
		virtual bool Release() = 0;

		virtual bool Debug() = 0;
	};

	MemoryLayout *CreateMemoryLayout(process_t process);

};

#endif // !_MEMORY_LAYOUT_H_
```

`VirtualMemory/VirtualMem.cpp`:

```cpp
#include "VirtualMem.h"

#include "MemoryLayout.h"

namespace vmem {
	nodep::BYTE *GetFreeRegion(process_t hProcess, nodep::DWORD size, nodep::DWORD granularity) {
		size = (size + 0xFFF) & ~0xFFF;

		nodep::DWORD dwOffset = 0x01000000;
		nodep::DWORD dwCandidate = 0, dwCandidateSize = 0xFFFFFFFF;

		MemoryLayout *layout = CreateMemoryLayout(hProcess);
		if (!layout->Snapshot()) {
			return nullptr;
		}

		while (dwOffset < 0x2FFF0000) {
			MemoryRegionInfo mri;
			nodep::DWORD regionSize = 0xFFFFFFFF;
			bool regionFree = true;

			if (!layout->Query((void *)dwOffset, mri)) {
				layout->Release();
				delete layout;
				return nullptr;
			}

			nodep::DWORD dwSize = mri.size - (dwOffset - (nodep::DWORD)mri.baseAddress); // or allocationbase
			if (regionSize > dwSize) {
				regionSize = dwSize;
			}

			regionFree &= (MEMORY_REGION_FREE == mri.state);

			if (regionFree & (regionSize >= size) & (regionSize < dwCandidateSize)) {
				dwCandidate = dwOffset;
				dwCandidateSize = regionSize;

				if (regionSize == size) {
					break;
				}
			}

			dwOffset += regionSize;
			dwOffset += granularity - 1;
			dwOffset &= ~(granularity - 1);
		}


		layout->Release();
		delete layout;

		if (0 == dwCandidate) {
			return nullptr;
		}

		return (nodep::BYTE *)dwCandidate;
	}


	nodep::BYTE *GetFreeRegion(process_t hProcess1, process_t hProcess2, nodep::DWORD size, nodep::DWORD granularity) {

		size = (size + 0xFFF) & ~0xFFF;
		// now look for a suitable address;

		nodep::DWORD dwOffset = 0x01000000; // dwGran;
		nodep::DWORD dwCandidate = 0, dwCandidateSize = 0xFFFFFFFF;

		//HANDLE hProcess[2] = { hProcess1, hProcess2 };
		MemoryLayout *layout[2];
		layout[0] = CreateMemoryLayout(hProcess1);
		layout[1] = CreateMemoryLayout(hProcess2);

		for (int i = 0; i < 2; ++i) {
			layout[i]->Snapshot();
			//layout[i]->Debug();
		}

		while (dwOffset < 0x2FFF0000) {
			MemoryRegionInfo mri;
			nodep::DWORD regionSize = 0xFFFFFFFF;
			bool regionFree = true;

			for (int i = 0; i < 2; ++i) {
				if (!layout[i]->Query((void *)dwOffset, mri)) {
					for (int i = 0; i < 2; ++i) {
						layout[i]->Release();
						delete layout[i];
					}
					return nullptr;
				}

				nodep::DWORD dwSize = mri.size - (dwOffset - (nodep::DWORD)mri.baseAddress); // or allocationbase
				if (regionSize > dwSize) {
					regionSize = dwSize;
				}

				//printf("        Proc %d offset: 0x%08x, size 0x%08x\n", i, dwOffset, dwSize);

				regionFree &= (MEMORY_REGION_FREE == mri.state);
			}

			if (regionFree & (regionSize >= size) & (regionSize < dwCandidateSize)) {
				dwCandidate = dwOffset;
				dwCandidateSize = regionSize;

				if (regionSize == size) {
					break;
				}
			}

			dwOffset += regionSize;
			dwOffset += granularity - 1;
			dwOffset &= ~(granularity - 1);
		}

		for (int i = 0; i < 2; ++i) {
			layout[i]->Release();
			delete layout[i];
		}

		if (0 == dwCandidate) {
			return nullptr;
		}

		return (nodep::BYTE *)dwCandidate;
	}
};
```

`VirtualMemory/VirtualMem.h`:

```h
#ifndef _VIRTUAL_MEM_H_
#define _VIRTUAL_MEM_H_

#include "../CommonCrossPlatform/BasicTypes.h"

namespace vmem {
	// the process_t aliases depending on the os
	// Linux: pid - used by libproc
	// Windows: HANDLE (to an opened process) - used by kernel32!VirtualQuery

#ifdef __linux__
	typedef int process_t;
#elif defined _WIN32 || defined __CYGWIN__
	#include <Windows.h>
	typedef HANDLE process_t;
#endif

	nodep::BYTE *GetFreeRegion(process_t hProcess, nodep::DWORD size, nodep::DWORD granularity);
	nodep::BYTE *GetFreeRegion(process_t hProcess1, process_t hProcess2, nodep::DWORD size, nodep::DWORD granularity);

};


#endif

```

`VirtualMemory/VirtualMemory.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{39020D47-08BE-4F17-911D-E346D2E9418F}</ProjectGuid>
    <RootNamespace>VirtualMemory</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Lib>
      <AdditionalDependencies>psapi.lib</AdditionalDependencies>
    </Lib>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Lib>
      <AdditionalDependencies>psapi.lib</AdditionalDependencies>
    </Lib>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="MemoryLayout.h" />
    <ClInclude Include="VirtualMem.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="MemoryLayout.Linux.cpp" />
    <ClCompile Include="MemoryLayout.Windows.cpp" />
    <ClCompile Include="VirtualMem.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`benchmarking-payload/CMakeLists.txt`:

```txt
include_directories(${CMAKE_SOURCE_DIR})

add_subdirectory(jsmn-payload)
add_subdirectory(gumbo-payload)
#add_subdirectory(libxml2-payload)
#add_subdirectory(libpng-payload)
#add_subdirectory(freetype-payload)
#add_subdirectory(http-parser-payload)
#add_subdirectory(libjpeg-turbo-payload)
#add_subdirectory(simple-address-payload)
#add_subdirectory(simple-accumulator-payload)

```

`benchmarking-payload/freetype-payload/CMakeLists.txt`:

```txt
set(LIBRARY_NAME freetype-payload)
set(CMAKE_C_FLAGS "-m32 -g")
set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=c++11 -D_PAYLOAD_EXPORTS")

add_library(${LIBRARY_NAME} SHARED
	Payload.cpp
)

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/freetype-src/include
	${CMAKE_CURRENT_SOURCE_DIR}/freetype-src
	$ENV{RIVER_SDK_DIR}/include
)

target_link_libraries(${LIBRARY_NAME}
	${CMAKE_CURRENT_SOURCE_DIR}/freetype-src/objs/.libs/libfreetype.a
	archive
	png16
)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`benchmarking-payload/freetype-payload/Makefile`:

```
mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
makefile_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

freetype := libfreetype.so
CC := gcc
CXX := g++
INCLUDE_PATHS = "-I$(makefile_dir)/freetype-src/include -I$(makefile_dir)/freetype-src/"
OBJ_FILES := Payload.o $(makefile_dir)/freetype-src/objs/.libs/libfreetype.a
CXX_FLAGS += -m32 -std=c++11 -D_PAYLOAD_EXPORTS
prefix := /usr/local

all: $(freetype)

install: $(freetype)
	install -m 0755 $(freetype) -t $(prefix)/lib -D

$(freetype): $(OBJ_FILES)
	$(CXX) -m32 -shared $(OBJ_FILES) -o $@ -lz -larchive -lpng12

Payload.o: Payload.cpp
	   $(CXX) $(CXX_FLAGS) $(INCLUDE_PATHS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(freetype) Payload.o

```

`benchmarking-payload/freetype-payload/Payload.cpp`:

```cpp
#include "CommonCrossPlatform/Common.h"
#include "CommonCrossPlatform/CommonSpecifiers.h"


#include <assert.h>
#include <stdint.h>

#include <ft2build.h>

#include FT_FREETYPE_H
#include FT_GLYPH_H
#include FT_CACHE_H
#include FT_CACHE_CHARMAP_H
#include FT_CACHE_IMAGE_H
#include FT_CACHE_SMALL_BITMAPS_H
#include FT_SYNTHESIS_H
#include FT_ADVANCES_H
#include FT_OUTLINE_H
#include FT_BBOX_H
#include FT_MODULE_H
#include FT_CFF_DRIVER_H
#include FT_TRUETYPE_DRIVER_H


  static FT_Library  library;
  static int         InitResult = FT_Init_FreeType( &library );



  void test_simple(unsigned char *data) {

	  size_t size = MAX_PAYLOAD_BUF;
	  assert( !InitResult );

	  if ( size < 1 )
		  return;

	  FT_Face         face;
	  FT_Int32        load_flags  = FT_LOAD_DEFAULT;
	  FT_Render_Mode  render_mode = FT_RENDER_MODE_NORMAL;

	  if ( !FT_New_Memory_Face( library, data, size, 0, &face ) )
	  {
		  unsigned int  first_index = 0;

		  for ( unsigned i = first_index;
				  i < (unsigned int)face->num_glyphs;
				  i++ )
		  {
			  if ( FT_Load_Glyph( face, i, load_flags ) )
				  continue;

			  // Rendering is the most expensive and the least interesting part.
			  //
			  // if ( FT_Render_Glyph( face->glyph, render_mode) )
			  //   continue;
			  // FT_GlyphSlot_Embolden( face->glyph );

#if 0
			  FT_Glyph  glyph;

			  if ( !FT_Get_Glyph( face->glyph, &glyph ) )
				  FT_Done_Glyph( glyph );

			  FT_Outline*  outline = &face->glyph->outline;
			  FT_Matrix    rot30   = { 0xDDB4, -0x8000, 0x8000, 0xDDB4 };

			  FT_Outline_Transform( outline, &rot30 );

			  FT_BBox  bbox;

			  FT_Outline_Get_BBox( outline, &bbox );
#endif
		  }

		  FT_Done_Face( face );
	  }

	  return;
  }



extern "C" {
	DLL_PUBLIC unsigned char payloadBuffer[MAX_PAYLOAD_BUF];
	DLL_PUBLIC int Payload() {
		test_simple(payloadBuffer);
		return 0;
	}
};

#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(
		_In_ HINSTANCE hinstDLL,
		_In_ DWORD     fdwReason,
		_In_ LPVOID    lpvReserved
		) {
	return TRUE;
}
#endif

```

`benchmarking-payload/freetype-payload/config_freetype.sh`:

```sh
#! /bin/bash

# Init source code
SRC_DIR="$(pwd)/freetype-src"

DEFAULT_CFLAGS="-m32"
DEFAULT_LDFLAGS="-m32"
CC=gcc

init_target() {
	if ! [ -d $SRC_DIR ]; then
		wget http://download.savannah.gnu.org/releases/freetype/freetype-2.8.tar.gz
		tar xvf freetype-2.8.tar.gz
		mv freetype-2.8 $SRC_DIR
		cd $SRC_DIR
		./autogen.sh
		cd -
	fi
}


# Build http-parser with the given `name` and flags.
build_target() {
	cd $SRC_DIR
	CC="$CC" CFLAGS="$DEFAULT_CFLAGS" LDFLAGS="$DEFAULT_LDFLAGS" \
	   	LD="ld -m elf_i386" ./configure
	make
	make library
	cd -
}

init_target
build_target

```

`benchmarking-payload/gumbo-payload/CMakeLists.txt`:

```txt
set(LIBRARY_NAME gumbo-payload)
set(CMAKE_C_FLAGS "-m32 -g")
set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=c++11 -D_PAYLOAD_EXPORTS")

add_library(${LIBRARY_NAME} SHARED
	Payload.cpp
)

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/gumbo-src/src
	$ENV{RIVER_SDK_DIR}/include
)

target_link_libraries(${LIBRARY_NAME}
	${CMAKE_CURRENT_SOURCE_DIR}/gumbo-src/.libs/libgumbo.a
)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`benchmarking-payload/gumbo-payload/Makefile`:

```
mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
makefile_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

lib_gumbo := libgumbo.so
CC := gcc
CXX := g++
INCLUDE_PATHS = -I$(makefile_dir)/gumbo-src/src
OBJ_FILES := Payload.o $(makefile_dir)/gumbo-src/.libs/libgumbo.a
CXX_FLAGS += -m32 -D_PAYLOAD_EXPORTS
prefix := /usr/local

all: $(lib_gumbo)

install: $(lib_gumbo)
	install -m 0755 $(lib_gumbo) -t $(prefix)/lib -D

$(lib_gumbo): $(OBJ_FILES)
	$(CXX) -m32 -shared $(OBJ_FILES) -o $@

Payload.o: Payload.cpp
	   $(CXX) $(CXX_FLAGS) $(INCLUDE_PATHS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(lib_gumbo) Payload.o

```

`benchmarking-payload/gumbo-payload/Payload.cpp`:

```cpp
#include "CommonCrossPlatform/Common.h"
#include "CommonCrossPlatform/CommonSpecifiers.h"

#include "gumbo.h"
#include <stdint.h>

void test_simple(const unsigned char *buf) {
	GumboOutput* output = gumbo_parse_with_options(
			&kGumboDefaultOptions, (const char *)buf, MAX_PAYLOAD_BUF);
	gumbo_destroy_output(&kGumboDefaultOptions, output);
}

extern "C" {
	DLL_PUBLIC unsigned char payloadBuffer[MAX_PAYLOAD_BUF];
	DLL_PUBLIC int Payload() {
		test_simple(payloadBuffer);
		return 0;
	}
};

#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(
		_In_ HINSTANCE hinstDLL,
		_In_ DWORD     fdwReason,
		_In_ LPVOID    lpvReserved
		) {
	return TRUE;
}
#endif

```

`benchmarking-payload/gumbo-payload/config_gumbo.sh`:

```sh
#! /bin/bash

# Init source code
SRC_DIR="$(pwd)/gumbo-src"

DEFAULT_CFLAGS="-m32"
DEFAULT_LDFLAGS="-m32"
CC=gcc
CXX=g++

init_target() {
	if ! [ -d $SRC_DIR ]; then
		git clone https://github.com/google/gumbo-parser.git $SRC_DIR
		cd $SRC_DIR
		./autogen.sh
		cd -
	fi
}


# Build http-parser with the given `name` and flags.
build_target() {
	cd $SRC_DIR
	CC="$CC" CXX="$CXX" CXXFLAGS="$DEFAULT_CFLAGS" CFLAGS="$DEFAULT_CFLAGS" \
		LDFLAGS="$DEFAULT_LDFLAGS"  ./configure

	make
	cd -
}

init_target
build_target

```

`benchmarking-payload/http-parser-payload/CMakeLists.txt`:

```txt
## http-parser CMakeLists.txt
# https://software.intel.com/en-us/articles/performance-tools-for-software-developers-bsymbolic-can-cause-dangerous-side-effects

set(LIBRARY_NAME "http-parser")

set(CMAKE_C_FLAGS "-m32 -g -O2")
set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -nostdlib -std=c++11 -D_PAYLOAD_EXPORTS")

include_directories($ENV{RIVER_SDK_DIR}/include)

add_library(${LIBRARY_NAME} SHARED
	http_parser.c
	Payload.cpp
	)

set_target_properties(${LIBRARY_NAME} PROPERTIES LINK_FLAGS
	"${LINK_FLAGS} \
	-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/http-parser.version")

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`benchmarking-payload/http-parser-payload/Makefile`:

```
# https://software.intel.com/en-us/articles/performance-tools-for-software-developers-bsymbolic-can-cause-dangerous-side-effects

lib_http_parser := libhttp-parser.so
CC := gcc
CXX := g++
OBJ_FILES := http_parser.o Payload.o
DEFAULT_CFLAGS := -m32 -O2 -g
CC_FLAGS += $(DEFAULT_CFLAGS)
CXX_FLAGS += $(DEFAULT_CFLAGS) -nostdlib -std=c++11 -D_PAYLOAD_EXPORTS
prefix := /usr/local

all: $(lib_http_parser)

install: $(lib_http_parser)
	install -m 0755 $(lib_http_parser) -t $(prefix)/lib -D

$(lib_http_parser): $(OBJ_FILES)
	$(CXX) $(CC_FLAGS) -Wl,--version-script=http-parser.version  -shared -o $@ $^

Payload.o: Payload.cpp
	   $(CXX) $(CXX_FLAGS) -c $<

http_parser.o: http_parser.c
	   $(CC) $(CC_FLAGS) -c $<

.PHONY: clean
clean:
	$(RM) $(lib_http_parser) $(OBJ_FILES)

```

`benchmarking-payload/http-parser-payload/ParserPayload.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}</ProjectGuid>
    <RootNamespace>ParserPayload</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PreprocessorDefinitions>_PAYLOAD_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>_PAYLOAD_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="http_parser.c" />
    <ClCompile Include="Payload.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="http_parser.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`benchmarking-payload/http-parser-payload/Payload.cpp`:

```cpp
#include "http_parser.h"
#include "CommonCrossPlatform/CommonSpecifiers.h"
#include "CommonCrossPlatform/Common.h"
#include <assert.h>

#define NDEBUG

static http_parser *parser = nullptr;

static int currently_parsing_eof;

#define MAX_HEADERS 13
#define MAX_ELEMENT_SIZE 2048
#define MAX_CHUNKS 16

#define TRUE 1
#define FALSE 0

struct message {
	const char *name; // for debugging purposes
	const char *raw;
	enum http_parser_type type;
	enum http_method method;
	int status_code;
	char response_status[MAX_ELEMENT_SIZE];
	char request_path[MAX_ELEMENT_SIZE];
	char request_url[MAX_ELEMENT_SIZE];
	char fragment[MAX_ELEMENT_SIZE];
	char query_string[MAX_ELEMENT_SIZE];
	char body[MAX_ELEMENT_SIZE];
	size_t body_size;
	const char *host;
	const char *userinfo;
	uint16_t port;
	int num_headers;
	enum { NONE = 0, FIELD, VALUE } last_header_element;
	char headers[MAX_HEADERS][2][MAX_ELEMENT_SIZE];
	int should_keep_alive;

	int num_chunks;
	int num_chunks_complete;
	int chunk_lengths[MAX_CHUNKS];

	const char *upgrade; // upgraded body

	unsigned short http_major;
	unsigned short http_minor;

	int message_begin_cb_called;
	int headers_complete_cb_called;
	int message_complete_cb_called;
	int message_complete_on_eof;
	int body_is_final;
};

static struct message messages[16];
static int num_messages;
static http_parser_settings *current_pause_parser;

#ifdef _WIN32
#define my_memset memset
#define my_memcpy memcpy
#define my_strlen strlen
#define my_strnlen strnlen
#endif
/*
void my_memset(void *buffer, unsigned int value, unsigned int size) {
	for (unsigned int i = 0; i < size; ++i) {
		((char *)buffer)[i] = value;
	}
}

void my_memcpy(void *dest, const void *src, unsigned int size) {
	for (unsigned int i = 0; i < size; ++i) {
		((char *)dest)[i] = ((char *)src)[i];
	}
}

int my_strlen(const char *str) {
	const char *c = str;
	while (*c) c++;

	return c - str;
}

int my_strnlen(const char *str, int n) {
	for (int i = 0; i < n; ++i) {
		if ('\0' == str[i]) {
			return i;
		}
	}
	return n;
}*/

#ifdef __linux__
typedef void *(*my_memset_t) (void *s, int c, size_t n);
typedef void *(*my_memcpy_t) (void *dest, const void *src, size_t n);
typedef size_t (*my_strlen_t) (const char *s);
typedef size_t (*my_strnlen_t) (const char *s, size_t maxlen);
typedef void* (*my_malloc_t) (size_t size);
typedef void (*my_free_t) (void *ptr);
typedef void (*my_abort_t) (void);

my_memset_t my_memset;
my_memcpy_t my_memcpy;
my_strlen_t my_strlen;
my_strnlen_t my_strnlen;
my_malloc_t my_malloc;
my_free_t my_free;
my_abort_t my_abort;
#endif

void parser_init(enum http_parser_type type) {
	num_messages = 0;

	parser = (http_parser *)my_malloc(sizeof(*parser));
	my_memset(parser, 0, sizeof(struct http_parser));
	http_parser_init(parser, type);

	my_memset(&messages, 0, sizeof(messages));
}

void parser_free() {
	assert(parser);
	my_free(parser);
	parser = nullptr;
}

size_t strlncat(char *dst, size_t len, const char *src, size_t n) {
	size_t slen;
	size_t dlen;
	size_t rlen;
	size_t ncpy;

	slen = my_strnlen(src, n);
	dlen = my_strnlen(dst, len);

	if (dlen < len) {
		rlen = len - dlen;
		ncpy = slen < rlen ? slen : (rlen - 1);
		my_memcpy(dst + dlen, src, ncpy);
		dst[dlen + ncpy] = '\0';
	}

	assert(len > slen + dlen);
	return slen + dlen;
}

size_t strlcat(char *dst, const char *src, size_t len) {
	return strlncat(dst, len, src, (size_t)-1);
}

size_t strlncpy(char *dst, size_t len, const char *src, size_t n) {
	size_t slen;
	size_t ncpy;

	slen = my_strnlen(src, n);

	if (len > 0) {
		ncpy = slen < len ? slen : (len - 1);
		my_memcpy(dst, src, ncpy);
		dst[ncpy] = '\0';
	}

	assert(len > slen);
	return slen;
}

size_t strlcpy(char *dst, const char *src, size_t len) {
	return strlncpy(dst, len, src, (size_t)-1);
}


int message_begin_cb(http_parser *p) {
	assert(p == parser);
	messages[num_messages].message_begin_cb_called = TRUE;
	return 0;
}

int request_url_cb(http_parser *p, const char *buf, size_t len) {
	assert(p == parser);
	strlncat(messages[num_messages].request_url,
		sizeof(messages[num_messages].request_url),
		buf,
		len);
	return 0;
}

int response_status_cb(http_parser *p, const char *buf, size_t len)
{
	assert(p == parser);
	strlncat(messages[num_messages].response_status,
		sizeof(messages[num_messages].response_status),
		buf,
		len);
	return 0;
}

int
header_field_cb(http_parser *p, const char *buf, size_t len)
{
	assert(p == parser);
	struct message *m = &messages[num_messages];

	if (m->num_headers < MAX_HEADERS - 1) {
		return -1;
	}

	if (m->last_header_element != m->FIELD)
		m->num_headers++;

	strlncat(m->headers[m->num_headers - 1][0],
		sizeof(m->headers[m->num_headers - 1][0]),
		buf,
		len);

	m->last_header_element = m->FIELD;

	return 0;
}

int header_value_cb(http_parser *p, const char *buf, size_t len) {
	assert(p == parser);
	struct message *m = &messages[num_messages];

	strlncat(m->headers[m->num_headers - 1][1],
		sizeof(m->headers[m->num_headers - 1][1]),
		buf,
		len);

	m->last_header_element = m->VALUE;

	return 0;
}

void check_body_is_final(const http_parser *p) {
	if (messages[num_messages].body_is_final) {
		/*fprintf(stderr, "\n\n *** Error http_body_is_final() should return 1 "
			"on last on_body callback call "
			"but it doesn't! ***\n\n");*/
		assert(0);
		my_abort();
	}
	messages[num_messages].body_is_final = http_body_is_final(p);
}


int headers_complete_cb(http_parser *p) {
	assert(p == parser);
	messages[num_messages].method = (http_method)parser->method;
	messages[num_messages].status_code = parser->status_code;
	messages[num_messages].http_major = parser->http_major;
	messages[num_messages].http_minor = parser->http_minor;
	messages[num_messages].headers_complete_cb_called = TRUE;
	messages[num_messages].should_keep_alive = http_should_keep_alive(parser);
	return 0;
}

int body_cb(http_parser *p, const char *buf, size_t len) {
	assert(p == parser);
	strlncat(messages[num_messages].body,
		sizeof(messages[num_messages].body),
		buf,
		len);
	messages[num_messages].body_size += len;
	check_body_is_final(p);
	// printf("body_cb: '%s'\n", requests[num_messages].body);
	return 0;
}

int message_complete_cb(http_parser *p) {
	assert(p == parser);
	if (messages[num_messages].should_keep_alive != http_should_keep_alive(parser))
	{
		/*fprintf(stderr, "\n\n *** Error http_should_keep_alive() should have same "
			"value in both on_message_complete and on_headers_complete "
			"but it doesn't! ***\n\n");*/
		assert(0);
		my_abort();
	}

	if (messages[num_messages].body_size &&
		http_body_is_final(p) &&
		!messages[num_messages].body_is_final)
	{
		/*fprintf(stderr, "\n\n *** Error http_body_is_final() should return 1 "
			"on last on_body callback call "
			"but it doesn't! ***\n\n");*/
		assert(0);
		my_abort();
	}

	messages[num_messages].message_complete_cb_called = TRUE;

	messages[num_messages].message_complete_on_eof = currently_parsing_eof;

	if (num_messages < (sizeof(messages) / sizeof(messages[0]) - 1)) {
		num_messages++;
	} else {
		my_memset(messages + num_messages, 0, sizeof(messages[0]));
	}
	return 0;
}

int chunk_header_cb(http_parser *p) {
	assert(p == parser);
	int chunk_idx = messages[num_messages].num_chunks;
	messages[num_messages].num_chunks++;
	if (chunk_idx < MAX_CHUNKS) {
		messages[num_messages].chunk_lengths[chunk_idx] = p->content_length;
	}

	return 0;
}

int chunk_complete_cb(http_parser *p) {
	assert(p == parser);

	/* Here we want to verify that each chunk_header_cb is matched by a
	* chunk_complete_cb, so not only should the total number of calls to
	* both callbacks be the same, but they also should be interleaved
	* properly */
	assert(messages[num_messages].num_chunks ==
		messages[num_messages].num_chunks_complete + 1);

	messages[num_messages].num_chunks_complete++;
	return 0;
}

static http_parser_settings settings = { 
	message_begin_cb,
	request_url_cb,
	response_status_cb,
	header_field_cb,
	header_value_cb,
	headers_complete_cb,
	body_cb,
	message_complete_cb,
	chunk_header_cb,
	chunk_complete_cb
};

size_t parse (const char *buf, const size_t len) {
	size_t nparsed;
	currently_parsing_eof = (len == 0);
	nparsed = http_parser_execute(parser, &settings, buf, len);
	return nparsed;
}

void test_simple(const unsigned char *buf) {
	parser_init(HTTP_REQUEST);

	enum http_errno err;

	parse((const char *)buf, MAX_PAYLOAD_BUF);
	err = HTTP_PARSER_ERRNO(parser);

	parser_free();
	num_messages = 0;
}

extern "C" {
	DLL_PUBLIC unsigned char payloadBuffer[MAX_PAYLOAD_BUF];
	DLL_PUBLIC int Payload() {
		test_simple(payloadBuffer);
		return 0;
	}
};

#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(
	_In_ HINSTANCE hinstDLL,
	_In_ DWORD     fdwReason,
	_In_ LPVOID    lpvReserved
) {
	return TRUE;
}
#else
#include <dlfcn.h>
__attribute__((constructor)) void somain(void) {
	void * libhandler = dlopen(("libc.so"), RTLD_LAZY);
	my_strlen = (my_strlen_t) dlsym(libhandler, "strlen");
	my_strnlen = (my_strnlen_t) dlsym(libhandler, "strnlen");
	my_memset = (my_memset_t) dlsym(libhandler, "memset");
	my_memcpy = (my_memcpy_t) dlsym(libhandler, "memcpy");
	my_malloc = (my_malloc_t) dlsym(libhandler, "malloc");
	my_free = (my_free_t) dlsym(libhandler, "free");
	my_abort = (my_abort_t) dlsym(libhandler, "abort");
}
#endif

```

`benchmarking-payload/http-parser-payload/http-parser.version`:

```version
LIBHTTPPARSER_1.0 {
  local:
    http_parser_version;
	http_parser_init;
	http_parser_settings_init;
	http_parser_execute;
	http_should_keep_alive;
	http_method_str;
	http_errno_description;
	http_parser_url_init;
	http_parser_parse_url;
	http_parser_pause;
	http_body_is_final;
};

```

`benchmarking-payload/http-parser-payload/http_parser.c`:

```c
/* Based on src/http/ngx_http_parse.c from NGINX copyright Igor Sysoev
 *
 * Additional changes are licensed under the same terms as NGINX and
 * copyright Joyent, Inc. and other Node contributors. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
#include "http_parser.h"
#include <assert.h>
#include <stddef.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#ifndef ULLONG_MAX
# define ULLONG_MAX ((uint64_t) -1) /* 2^64-1 */
#endif

#ifndef MIN
# define MIN(a,b) ((a) < (b) ? (a) : (b))
#endif

#ifndef ARRAY_SIZE
# define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
#endif

#ifndef BIT_AT
# define BIT_AT(a, i)                                                \
  (!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                  \
   (1 << ((unsigned int) (i) & 7))))
#endif

#ifndef ELEM_AT
# define ELEM_AT(a, i, v) ((unsigned int) (i) < ARRAY_SIZE(a) ? (a)[(i)] : (v))
#endif

#define SET_ERRNO(e)                                                 \
do {                                                                 \
  parser->http_errno = (e);                                          \
} while(0)

#define CURRENT_STATE() p_state
#define UPDATE_STATE(V) p_state = (enum state) (V);
#define RETURN(V)                                                    \
do {                                                                 \
  parser->state = CURRENT_STATE();                                   \
  return (V);                                                        \
} while (0);
#define REEXECUTE()                                                  \
  goto reexecute;                                                    \


#ifdef __GNUC__
# define LIKELY(X) __builtin_expect(!!(X), 1)
# define UNLIKELY(X) __builtin_expect(!!(X), 0)
#else
# define LIKELY(X) (X)
# define UNLIKELY(X) (X)
#endif


/* Run the notify callback FOR, returning ER if it fails */
#define CALLBACK_NOTIFY_(FOR, ER)                                    \
do {                                                                 \
  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \
                                                                     \
  if (LIKELY(settings->on_##FOR)) {                                  \
    parser->state = CURRENT_STATE();                                 \
    if (UNLIKELY(0 != settings->on_##FOR(parser))) {                 \
      SET_ERRNO(HPE_CB_##FOR);                                       \
    }                                                                \
    UPDATE_STATE(parser->state);                                     \
                                                                     \
    /* We either errored above or got paused; get out */             \
    if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {             \
      return (ER);                                                   \
    }                                                                \
  }                                                                  \
} while (0)

/* Run the notify callback FOR and consume the current byte */
#define CALLBACK_NOTIFY(FOR)            CALLBACK_NOTIFY_(FOR, p - data + 1)

/* Run the notify callback FOR and don't consume the current byte */
#define CALLBACK_NOTIFY_NOADVANCE(FOR)  CALLBACK_NOTIFY_(FOR, p - data)

/* Run data callback FOR with LEN bytes, returning ER if it fails */
#define CALLBACK_DATA_(FOR, LEN, ER)                                 \
do {                                                                 \
  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \
                                                                     \
  if (FOR##_mark) {                                                  \
    if (LIKELY(settings->on_##FOR)) {                                \
      parser->state = CURRENT_STATE();                               \
      if (UNLIKELY(0 !=                                              \
                   settings->on_##FOR(parser, FOR##_mark, (LEN)))) { \
        SET_ERRNO(HPE_CB_##FOR);                                     \
      }                                                              \
      UPDATE_STATE(parser->state);                                   \
                                                                     \
      /* We either errored above or got paused; get out */           \
      if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {           \
        return (ER);                                                 \
      }                                                              \
    }                                                                \
    FOR##_mark = NULL;                                               \
  }                                                                  \
} while (0)

/* Run the data callback FOR and consume the current byte */
#define CALLBACK_DATA(FOR)                                           \
    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data + 1)

/* Run the data callback FOR and don't consume the current byte */
#define CALLBACK_DATA_NOADVANCE(FOR)                                 \
    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data)

/* Set the mark FOR; non-destructive if mark is already set */
#define MARK(FOR)                                                    \
do {                                                                 \
  if (!FOR##_mark) {                                                 \
    FOR##_mark = p;                                                  \
  }                                                                  \
} while (0)

/* Don't allow the total size of the HTTP headers (including the status
 * line) to exceed HTTP_MAX_HEADER_SIZE.  This check is here to protect
 * embedders against denial-of-service attacks where the attacker feeds
 * us a never-ending header that the embedder keeps buffering.
 *
 * This check is arguably the responsibility of embedders but we're doing
 * it on the embedder's behalf because most won't bother and this way we
 * make the web a little safer.  HTTP_MAX_HEADER_SIZE is still far bigger
 * than any reasonable request or response so this should never affect
 * day-to-day operation.
 */
#define COUNT_HEADER_SIZE(V)                                         \
do {                                                                 \
  parser->nread += (V);                                              \
  if (UNLIKELY(parser->nread > (HTTP_MAX_HEADER_SIZE))) {            \
    SET_ERRNO(HPE_HEADER_OVERFLOW);                                  \
    goto error;                                                      \
  }                                                                  \
} while (0)


#define PROXY_CONNECTION "proxy-connection"
#define CONNECTION "connection"
#define CONTENT_LENGTH "content-length"
#define TRANSFER_ENCODING "transfer-encoding"
#define UPGRADE "upgrade"
#define CHUNKED "chunked"
#define KEEP_ALIVE "keep-alive"
#define CLOSE "close"


static const char *method_strings[] =
  {
#define XX(num, name, string) #string,
  HTTP_METHOD_MAP(XX)
#undef XX
  };


/* Tokens as defined by rfc 2616. Also lowercases them.
 *        token       = 1*<any CHAR except CTLs or separators>
 *     separators     = "(" | ")" | "<" | ">" | "@"
 *                    | "," | ";" | ":" | "\" | <">
 *                    | "/" | "[" | "]" | "?" | "="
 *                    | "{" | "}" | SP | HT
 */
static const char tokens[256] = {
/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */
        0,       0,       0,       0,       0,       0,       0,       0,
/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */
        0,       0,       0,       0,       0,       0,       0,       0,
/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */
        0,       0,       0,       0,       0,       0,       0,       0,
/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */
        0,       0,       0,       0,       0,       0,       0,       0,
/*  32 sp    33  !    34  "    35  #    36  $    37  %    38  &    39  '  */
        0,      '!',      0,      '#',     '$',     '%',     '&',    '\'',
/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */
        0,       0,      '*',     '+',      0,      '-',     '.',      0,
/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */
       '0',     '1',     '2',     '3',     '4',     '5',     '6',     '7',
/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */
       '8',     '9',      0,       0,       0,       0,       0,       0,
/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */
        0,      'a',     'b',     'c',     'd',     'e',     'f',     'g',
/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */
       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',
/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */
       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',
/*  88  X    89  Y    90  Z    91  [    92  \    93  ]    94  ^    95  _  */
       'x',     'y',     'z',      0,       0,       0,      '^',     '_',
/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */
       '`',     'a',     'b',     'c',     'd',     'e',     'f',     'g',
/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */
       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',
/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */
       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',
/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */
       'x',     'y',     'z',      0,      '|',      0,      '~',       0 };


static const int8_t unhex[256] =
  {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1
  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
  };


#if HTTP_PARSER_STRICT
# define T(v) 0
#else
# define T(v) v
#endif


static const uint8_t normal_url_char[32] = {
/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */
        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */
        0    | T(2)   |   0    |   0    | T(16)  |   0    |   0    |   0,
/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */
        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */
        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
/*  32 sp    33  !    34  "    35  #    36  $    37  %    38  &    39  '  */
        0    |   2    |   4    |   0    |   16   |   32   |   64   |  128,
/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0,
/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  88  X    89  Y    90  Z    91  [    92  \    93  ]    94  ^    95  _  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */
        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0, };

#undef T

enum state
  { s_dead = 1 /* important that this is > 0 */

  , s_start_req_or_res
  , s_res_or_resp_H
  , s_start_res
  , s_res_H
  , s_res_HT
  , s_res_HTT
  , s_res_HTTP
  , s_res_first_http_major
  , s_res_http_major
  , s_res_first_http_minor
  , s_res_http_minor
  , s_res_first_status_code
  , s_res_status_code
  , s_res_status_start
  , s_res_status
  , s_res_line_almost_done

  , s_start_req

  , s_req_method
  , s_req_spaces_before_url
  , s_req_schema
  , s_req_schema_slash
  , s_req_schema_slash_slash
  , s_req_server_start
  , s_req_server
  , s_req_server_with_at
  , s_req_path
  , s_req_query_string_start
  , s_req_query_string
  , s_req_fragment_start
  , s_req_fragment
  , s_req_http_start
  , s_req_http_H
  , s_req_http_HT
  , s_req_http_HTT
  , s_req_http_HTTP
  , s_req_first_http_major
  , s_req_http_major
  , s_req_first_http_minor
  , s_req_http_minor
  , s_req_line_almost_done

  , s_header_field_start
  , s_header_field
  , s_header_value_discard_ws
  , s_header_value_discard_ws_almost_done
  , s_header_value_discard_lws
  , s_header_value_start
  , s_header_value
  , s_header_value_lws

  , s_header_almost_done

  , s_chunk_size_start
  , s_chunk_size
  , s_chunk_parameters
  , s_chunk_size_almost_done

  , s_headers_almost_done
  , s_headers_done

  /* Important: 's_headers_done' must be the last 'header' state. All
   * states beyond this must be 'body' states. It is used for overflow
   * checking. See the PARSING_HEADER() macro.
   */

  , s_chunk_data
  , s_chunk_data_almost_done
  , s_chunk_data_done

  , s_body_identity
  , s_body_identity_eof

  , s_message_done
  };


#define PARSING_HEADER(state) (state <= s_headers_done)


enum header_states
  { h_general = 0
  , h_C
  , h_CO
  , h_CON

  , h_matching_connection
  , h_matching_proxy_connection
  , h_matching_content_length
  , h_matching_transfer_encoding
  , h_matching_upgrade

  , h_connection
  , h_content_length
  , h_transfer_encoding
  , h_upgrade

  , h_matching_transfer_encoding_chunked
  , h_matching_connection_token_start
  , h_matching_connection_keep_alive
  , h_matching_connection_close
  , h_matching_connection_upgrade
  , h_matching_connection_token

  , h_transfer_encoding_chunked
  , h_connection_keep_alive
  , h_connection_close
  , h_connection_upgrade
  };

enum http_host_state
  {
    s_http_host_dead = 1
  , s_http_userinfo_start
  , s_http_userinfo
  , s_http_host_start
  , s_http_host_v6_start
  , s_http_host
  , s_http_host_v6
  , s_http_host_v6_end
  , s_http_host_v6_zone_start
  , s_http_host_v6_zone
  , s_http_host_port_start
  , s_http_host_port
};

/* Macros for character classes; depends on strict-mode  */
#define CR                  '\r'
#define LF                  '\n'
#define LOWER(c)            (unsigned char)(c | 0x20)
#define IS_ALPHA(c)         (LOWER(c) >= 'a' && LOWER(c) <= 'z')
#define IS_NUM(c)           ((c) >= '0' && (c) <= '9')
#define IS_ALPHANUM(c)      (IS_ALPHA(c) || IS_NUM(c))
#define IS_HEX(c)           (IS_NUM(c) || (LOWER(c) >= 'a' && LOWER(c) <= 'f'))
#define IS_MARK(c)          ((c) == '-' || (c) == '_' || (c) == '.' || \
  (c) == '!' || (c) == '~' || (c) == '*' || (c) == '\'' || (c) == '(' || \
  (c) == ')')
#define IS_USERINFO_CHAR(c) (IS_ALPHANUM(c) || IS_MARK(c) || (c) == '%' || \
  (c) == ';' || (c) == ':' || (c) == '&' || (c) == '=' || (c) == '+' || \
  (c) == '$' || (c) == ',')

#define STRICT_TOKEN(c)     (tokens[(unsigned char)c])

#if HTTP_PARSER_STRICT
#define TOKEN(c)            (tokens[(unsigned char)c])
#define IS_URL_CHAR(c)      (BIT_AT(normal_url_char, (unsigned char)c))
#define IS_HOST_CHAR(c)     (IS_ALPHANUM(c) || (c) == '.' || (c) == '-')
#else
#define TOKEN(c)            ((c == ' ') ? ' ' : tokens[(unsigned char)c])
#define IS_URL_CHAR(c)                                                         \
  (BIT_AT(normal_url_char, (unsigned char)c) || ((c) & 0x80))
#define IS_HOST_CHAR(c)                                                        \
  (IS_ALPHANUM(c) || (c) == '.' || (c) == '-' || (c) == '_')
#endif

/**
 * Verify that a char is a valid visible (printable) US-ASCII
 * character or %x80-FF
 **/
#define IS_HEADER_CHAR(ch)                                                     \
  (ch == CR || ch == LF || ch == 9 || ((unsigned char)ch > 31 && ch != 127))

#define start_state (parser->type == HTTP_REQUEST ? s_start_req : s_start_res)


#if HTTP_PARSER_STRICT
# define STRICT_CHECK(cond)                                          \
do {                                                                 \
  if (cond) {                                                        \
    SET_ERRNO(HPE_STRICT);                                           \
    goto error;                                                      \
  }                                                                  \
} while (0)
# define NEW_MESSAGE() (http_should_keep_alive(parser) ? start_state : s_dead)
#else
# define STRICT_CHECK(cond)
# define NEW_MESSAGE() start_state
#endif


/* Map errno values to strings for human-readable output */
#define HTTP_STRERROR_GEN(n, s) { "HPE_" #n, s },
static struct {
  const char *name;
  const char *description;
} http_strerror_tab[] = {
  HTTP_ERRNO_MAP(HTTP_STRERROR_GEN)
};
#undef HTTP_STRERROR_GEN

int http_message_needs_eof(const http_parser *parser);

/* Our URL parser.
 *
 * This is designed to be shared by http_parser_execute() for URL validation,
 * hence it has a state transition + byte-for-byte interface. In addition, it
 * is meant to be embedded in http_parser_parse_url(), which does the dirty
 * work of turning state transitions URL components for its API.
 *
 * This function should only be invoked with non-space characters. It is
 * assumed that the caller cares about (and can detect) the transition between
 * URL and non-URL states by looking for these.
 */
static enum state
parse_url_char(enum state s, const char ch)
{
  if (ch == ' ' || ch == '\r' || ch == '\n') {
    return s_dead;
  }

#if HTTP_PARSER_STRICT
  if (ch == '\t' || ch == '\f') {
    return s_dead;
  }
#endif

  switch (s) {
    case s_req_spaces_before_url:
      /* Proxied requests are followed by scheme of an absolute URI (alpha).
       * All methods except CONNECT are followed by '/' or '*'.
       */

      if (ch == '/' || ch == '*') {
        return s_req_path;
      }

      if (IS_ALPHA(ch)) {
        return s_req_schema;
      }

      break;

    case s_req_schema:
      if (IS_ALPHA(ch)) {
        return s;
      }

      if (ch == ':') {
        return s_req_schema_slash;
      }

      break;

    case s_req_schema_slash:
      if (ch == '/') {
        return s_req_schema_slash_slash;
      }

      break;

    case s_req_schema_slash_slash:
      if (ch == '/') {
        return s_req_server_start;
      }

      break;

    case s_req_server_with_at:
      if (ch == '@') {
        return s_dead;
      }

    /* FALLTHROUGH */
    case s_req_server_start:
    case s_req_server:
      if (ch == '/') {
        return s_req_path;
      }

      if (ch == '?') {
        return s_req_query_string_start;
      }

      if (ch == '@') {
        return s_req_server_with_at;
      }

      if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
        return s_req_server;
      }

      break;

    case s_req_path:
      if (IS_URL_CHAR(ch)) {
        return s;
      }

      switch (ch) {
        case '?':
          return s_req_query_string_start;

        case '#':
          return s_req_fragment_start;
      }

      break;

    case s_req_query_string_start:
    case s_req_query_string:
      if (IS_URL_CHAR(ch)) {
        return s_req_query_string;
      }

      switch (ch) {
        case '?':
          /* allow extra '?' in query string */
          return s_req_query_string;

        case '#':
          return s_req_fragment_start;
      }

      break;

    case s_req_fragment_start:
      if (IS_URL_CHAR(ch)) {
        return s_req_fragment;
      }

      switch (ch) {
        case '?':
          return s_req_fragment;

        case '#':
          return s;
      }

      break;

    case s_req_fragment:
      if (IS_URL_CHAR(ch)) {
        return s;
      }

      switch (ch) {
        case '?':
        case '#':
          return s;
      }

      break;

    default:
      break;
  }

  /* We should never fall out of the switch above unless there's an error */
  return s_dead;
}

size_t http_parser_execute (http_parser *parser,
                            const http_parser_settings *settings,
                            const char *data,
                            size_t len)
{
  char c, ch;
  int8_t unhex_val;
  const char *p = data;
  const char *header_field_mark = 0;
  const char *header_value_mark = 0;
  const char *url_mark = 0;
  const char *body_mark = 0;
  const char *status_mark = 0;
  enum state p_state = (enum state) parser->state;
  const unsigned int lenient = parser->lenient_http_headers;

  /* We're in an error state. Don't bother doing anything. */
  if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
    return 0;
  }

  if (len == 0) {
    switch (CURRENT_STATE()) {
      case s_body_identity_eof:
        /* Use of CALLBACK_NOTIFY() here would erroneously return 1 byte read if
         * we got paused.
         */
        CALLBACK_NOTIFY_NOADVANCE(message_complete);
        return 0;

      case s_dead:
      case s_start_req_or_res:
      case s_start_res:
      case s_start_req:
        return 0;

      default:
        SET_ERRNO(HPE_INVALID_EOF_STATE);
        return 1;
    }
  }


  if (CURRENT_STATE() == s_header_field)
    header_field_mark = data;
  if (CURRENT_STATE() == s_header_value)
    header_value_mark = data;
  switch (CURRENT_STATE()) {
  case s_req_path:
  case s_req_schema:
  case s_req_schema_slash:
  case s_req_schema_slash_slash:
  case s_req_server_start:
  case s_req_server:
  case s_req_server_with_at:
  case s_req_query_string_start:
  case s_req_query_string:
  case s_req_fragment_start:
  case s_req_fragment:
    url_mark = data;
    break;
  case s_res_status:
    status_mark = data;
    break;
  default:
    break;
  }

  for (p=data; p != data + len; p++) {
    ch = *p;

    if (PARSING_HEADER(CURRENT_STATE()))
      COUNT_HEADER_SIZE(1);

reexecute:
    switch (CURRENT_STATE()) {

      case s_dead:
        /* this state is used after a 'Connection: close' message
         * the parser will error out if it reads another message
         */
        if (LIKELY(ch == CR || ch == LF))
          break;

        SET_ERRNO(HPE_CLOSED_CONNECTION);
        goto error;

      case s_start_req_or_res:
      {
        if (ch == CR || ch == LF)
          break;
        parser->flags = 0;
        parser->content_length = ULLONG_MAX;

        if (ch == 'H') {
          UPDATE_STATE(s_res_or_resp_H);

          CALLBACK_NOTIFY(message_begin);
        } else {
          parser->type = HTTP_REQUEST;
          UPDATE_STATE(s_start_req);
          REEXECUTE();
        }

        break;
      }

      case s_res_or_resp_H:
        if (ch == 'T') {
          parser->type = HTTP_RESPONSE;
          UPDATE_STATE(s_res_HT);
        } else {
          if (UNLIKELY(ch != 'E')) {
            SET_ERRNO(HPE_INVALID_CONSTANT);
            goto error;
          }

          parser->type = HTTP_REQUEST;
          parser->method = HTTP_HEAD;
          parser->index = 2;
          UPDATE_STATE(s_req_method);
        }
        break;

      case s_start_res:
      {
        parser->flags = 0;
        parser->content_length = ULLONG_MAX;

        switch (ch) {
          case 'H':
            UPDATE_STATE(s_res_H);
            break;

          case CR:
          case LF:
            break;

          default:
            SET_ERRNO(HPE_INVALID_CONSTANT);
            goto error;
        }

        CALLBACK_NOTIFY(message_begin);
        break;
      }

      case s_res_H:
        STRICT_CHECK(ch != 'T');
        UPDATE_STATE(s_res_HT);
        break;

      case s_res_HT:
        STRICT_CHECK(ch != 'T');
        UPDATE_STATE(s_res_HTT);
        break;

      case s_res_HTT:
        STRICT_CHECK(ch != 'P');
        UPDATE_STATE(s_res_HTTP);
        break;

      case s_res_HTTP:
        STRICT_CHECK(ch != '/');
        UPDATE_STATE(s_res_first_http_major);
        break;

      case s_res_first_http_major:
        if (UNLIKELY(ch < '0' || ch > '9')) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_major = ch - '0';
        UPDATE_STATE(s_res_http_major);
        break;

      /* major HTTP version or dot */
      case s_res_http_major:
      {
        if (ch == '.') {
          UPDATE_STATE(s_res_first_http_minor);
          break;
        }

        if (!IS_NUM(ch)) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_major *= 10;
        parser->http_major += ch - '0';

        if (UNLIKELY(parser->http_major > 999)) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        break;
      }

      /* first digit of minor HTTP version */
      case s_res_first_http_minor:
        if (UNLIKELY(!IS_NUM(ch))) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_minor = ch - '0';
        UPDATE_STATE(s_res_http_minor);
        break;

      /* minor HTTP version or end of request line */
      case s_res_http_minor:
      {
        if (ch == ' ') {
          UPDATE_STATE(s_res_first_status_code);
          break;
        }

        if (UNLIKELY(!IS_NUM(ch))) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_minor *= 10;
        parser->http_minor += ch - '0';

        if (UNLIKELY(parser->http_minor > 999)) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        break;
      }

      case s_res_first_status_code:
      {
        if (!IS_NUM(ch)) {
          if (ch == ' ') {
            break;
          }

          SET_ERRNO(HPE_INVALID_STATUS);
          goto error;
        }
        parser->status_code = ch - '0';
        UPDATE_STATE(s_res_status_code);
        break;
      }

      case s_res_status_code:
      {
        if (!IS_NUM(ch)) {
          switch (ch) {
            case ' ':
              UPDATE_STATE(s_res_status_start);
              break;
            case CR:
              UPDATE_STATE(s_res_line_almost_done);
              break;
            case LF:
              UPDATE_STATE(s_header_field_start);
              break;
            default:
              SET_ERRNO(HPE_INVALID_STATUS);
              goto error;
          }
          break;
        }

        parser->status_code *= 10;
        parser->status_code += ch - '0';

        if (UNLIKELY(parser->status_code > 999)) {
          SET_ERRNO(HPE_INVALID_STATUS);
          goto error;
        }

        break;
      }

      case s_res_status_start:
      {
        if (ch == CR) {
          UPDATE_STATE(s_res_line_almost_done);
          break;
        }

        if (ch == LF) {
          UPDATE_STATE(s_header_field_start);
          break;
        }

        MARK(status);
        UPDATE_STATE(s_res_status);
        parser->index = 0;
        break;
      }

      case s_res_status:
        if (ch == CR) {
          UPDATE_STATE(s_res_line_almost_done);
          CALLBACK_DATA(status);
          break;
        }

        if (ch == LF) {
          UPDATE_STATE(s_header_field_start);
          CALLBACK_DATA(status);
          break;
        }

        break;

      case s_res_line_almost_done:
        STRICT_CHECK(ch != LF);
        UPDATE_STATE(s_header_field_start);
        break;

      case s_start_req:
      {
        if (ch == CR || ch == LF)
          break;
        parser->flags = 0;
        parser->content_length = ULLONG_MAX;

        if (UNLIKELY(!IS_ALPHA(ch))) {
          SET_ERRNO(HPE_INVALID_METHOD);
          goto error;
        }

        parser->method = (enum http_method) 0;
        parser->index = 1;
        switch (ch) {
          case 'A': parser->method = HTTP_ACL; break;
          case 'B': parser->method = HTTP_BIND; break;
          case 'C': parser->method = HTTP_CONNECT; /* or COPY, CHECKOUT */ break;
          case 'D': parser->method = HTTP_DELETE; break;
          case 'G': parser->method = HTTP_GET; break;
          case 'H': parser->method = HTTP_HEAD; break;
          case 'L': parser->method = HTTP_LOCK; /* or LINK */ break;
          case 'M': parser->method = HTTP_MKCOL; /* or MOVE, MKACTIVITY, MERGE, M-SEARCH, MKCALENDAR */ break;
          case 'N': parser->method = HTTP_NOTIFY; break;
          case 'O': parser->method = HTTP_OPTIONS; break;
          case 'P': parser->method = HTTP_POST;
            /* or PROPFIND|PROPPATCH|PUT|PATCH|PURGE */
            break;
          case 'R': parser->method = HTTP_REPORT; /* or REBIND */ break;
          case 'S': parser->method = HTTP_SUBSCRIBE; /* or SEARCH */ break;
          case 'T': parser->method = HTTP_TRACE; break;
          case 'U': parser->method = HTTP_UNLOCK; /* or UNSUBSCRIBE, UNBIND, UNLINK */ break;
          default:
            SET_ERRNO(HPE_INVALID_METHOD);
            goto error;
        }
        UPDATE_STATE(s_req_method);

        CALLBACK_NOTIFY(message_begin);

        break;
      }

      case s_req_method:
      {
        const char *matcher;
        if (UNLIKELY(ch == '\0')) {
          SET_ERRNO(HPE_INVALID_METHOD);
          goto error;
        }

        matcher = method_strings[parser->method];
        if (ch == ' ' && matcher[parser->index] == '\0') {
          UPDATE_STATE(s_req_spaces_before_url);
        } else if (ch == matcher[parser->index]) {
          ; /* nada */
        } else if (IS_ALPHA(ch)) {

          switch (parser->method << 16 | parser->index << 8 | ch) {
#define XX(meth, pos, ch, new_meth) \
            case (HTTP_##meth << 16 | pos << 8 | ch): \
              parser->method = HTTP_##new_meth; break;

            XX(POST,      1, 'U', PUT)
            XX(POST,      1, 'A', PATCH)
            XX(CONNECT,   1, 'H', CHECKOUT)
            XX(CONNECT,   2, 'P', COPY)
            XX(MKCOL,     1, 'O', MOVE)
            XX(MKCOL,     1, 'E', MERGE)
            XX(MKCOL,     2, 'A', MKACTIVITY)
            XX(MKCOL,     3, 'A', MKCALENDAR)
            XX(SUBSCRIBE, 1, 'E', SEARCH)
            XX(REPORT,    2, 'B', REBIND)
            XX(POST,      1, 'R', PROPFIND)
            XX(PROPFIND,  4, 'P', PROPPATCH)
            XX(PUT,       2, 'R', PURGE)
            XX(LOCK,      1, 'I', LINK)
            XX(UNLOCK,    2, 'S', UNSUBSCRIBE)
            XX(UNLOCK,    2, 'B', UNBIND)
            XX(UNLOCK,    3, 'I', UNLINK)
#undef XX

            default:
              SET_ERRNO(HPE_INVALID_METHOD);
              goto error;
          }
        } else if (ch == '-' &&
                   parser->index == 1 &&
                   parser->method == HTTP_MKCOL) {
          parser->method = HTTP_MSEARCH;
        } else {
          SET_ERRNO(HPE_INVALID_METHOD);
          goto error;
        }

        ++parser->index;
        break;
      }

      case s_req_spaces_before_url:
      {
        if (ch == ' ') break;

        MARK(url);
        if (parser->method == HTTP_CONNECT) {
          UPDATE_STATE(s_req_server_start);
        }

        UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));
        if (UNLIKELY(CURRENT_STATE() == s_dead)) {
          SET_ERRNO(HPE_INVALID_URL);
          goto error;
        }

        break;
      }

      case s_req_schema:
      case s_req_schema_slash:
      case s_req_schema_slash_slash:
      case s_req_server_start:
      {
        switch (ch) {
          /* No whitespace allowed here */
          case ' ':
          case CR:
          case LF:
            SET_ERRNO(HPE_INVALID_URL);
            goto error;
          default:
            UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));
            if (UNLIKELY(CURRENT_STATE() == s_dead)) {
              SET_ERRNO(HPE_INVALID_URL);
              goto error;
            }
        }

        break;
      }

      case s_req_server:
      case s_req_server_with_at:
      case s_req_path:
      case s_req_query_string_start:
      case s_req_query_string:
      case s_req_fragment_start:
      case s_req_fragment:
      {
        switch (ch) {
          case ' ':
            UPDATE_STATE(s_req_http_start);
            CALLBACK_DATA(url);
            break;
          case CR:
          case LF:
            parser->http_major = 0;
            parser->http_minor = 9;
            UPDATE_STATE((ch == CR) ?
              s_req_line_almost_done :
              s_header_field_start);
            CALLBACK_DATA(url);
            break;
          default:
            UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));
            if (UNLIKELY(CURRENT_STATE() == s_dead)) {
              SET_ERRNO(HPE_INVALID_URL);
              goto error;
            }
        }
        break;
      }

      case s_req_http_start:
        switch (ch) {
          case 'H':
            UPDATE_STATE(s_req_http_H);
            break;
          case ' ':
            break;
          default:
            SET_ERRNO(HPE_INVALID_CONSTANT);
            goto error;
        }
        break;

      case s_req_http_H:
        STRICT_CHECK(ch != 'T');
        UPDATE_STATE(s_req_http_HT);
        break;

      case s_req_http_HT:
        STRICT_CHECK(ch != 'T');
        UPDATE_STATE(s_req_http_HTT);
        break;

      case s_req_http_HTT:
        STRICT_CHECK(ch != 'P');
        UPDATE_STATE(s_req_http_HTTP);
        break;

      case s_req_http_HTTP:
        STRICT_CHECK(ch != '/');
        UPDATE_STATE(s_req_first_http_major);
        break;

      /* first digit of major HTTP version */
      case s_req_first_http_major:
        if (UNLIKELY(ch < '1' || ch > '9')) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_major = ch - '0';
        UPDATE_STATE(s_req_http_major);
        break;

      /* major HTTP version or dot */
      case s_req_http_major:
      {
        if (ch == '.') {
          UPDATE_STATE(s_req_first_http_minor);
          break;
        }

        if (UNLIKELY(!IS_NUM(ch))) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_major *= 10;
        parser->http_major += ch - '0';

        if (UNLIKELY(parser->http_major > 999)) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        break;
      }

      /* first digit of minor HTTP version */
      case s_req_first_http_minor:
        if (UNLIKELY(!IS_NUM(ch))) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_minor = ch - '0';
        UPDATE_STATE(s_req_http_minor);
        break;

      /* minor HTTP version or end of request line */
      case s_req_http_minor:
      {
        if (ch == CR) {
          UPDATE_STATE(s_req_line_almost_done);
          break;
        }

        if (ch == LF) {
          UPDATE_STATE(s_header_field_start);
          break;
        }

        /* XXX allow spaces after digit? */

        if (UNLIKELY(!IS_NUM(ch))) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        parser->http_minor *= 10;
        parser->http_minor += ch - '0';

        if (UNLIKELY(parser->http_minor > 999)) {
          SET_ERRNO(HPE_INVALID_VERSION);
          goto error;
        }

        break;
      }

      /* end of request line */
      case s_req_line_almost_done:
      {
        if (UNLIKELY(ch != LF)) {
          SET_ERRNO(HPE_LF_EXPECTED);
          goto error;
        }

        UPDATE_STATE(s_header_field_start);
        break;
      }

      case s_header_field_start:
      {
        if (ch == CR) {
          UPDATE_STATE(s_headers_almost_done);
          break;
        }

        if (ch == LF) {
          /* they might be just sending \n instead of \r\n so this would be
           * the second \n to denote the end of headers*/
          UPDATE_STATE(s_headers_almost_done);
          REEXECUTE();
        }

        c = TOKEN(ch);

        if (UNLIKELY(!c)) {
          SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
          goto error;
        }

        MARK(header_field);

        parser->index = 0;
        UPDATE_STATE(s_header_field);

        switch (c) {
          case 'c':
            parser->header_state = h_C;
            break;

          case 'p':
            parser->header_state = h_matching_proxy_connection;
            break;

          case 't':
            parser->header_state = h_matching_transfer_encoding;
            break;

          case 'u':
            parser->header_state = h_matching_upgrade;
            break;

          default:
            parser->header_state = h_general;
            break;
        }
        break;
      }

      case s_header_field:
      {
        const char* start = p;
        for (; p != data + len; p++) {
          ch = *p;
          c = TOKEN(ch);

          if (!c)
            break;

          switch (parser->header_state) {
            case h_general:
              break;

            case h_C:
              parser->index++;
              parser->header_state = (c == 'o' ? h_CO : h_general);
              break;

            case h_CO:
              parser->index++;
              parser->header_state = (c == 'n' ? h_CON : h_general);
              break;

            case h_CON:
              parser->index++;
              switch (c) {
                case 'n':
                  parser->header_state = h_matching_connection;
                  break;
                case 't':
                  parser->header_state = h_matching_content_length;
                  break;
                default:
                  parser->header_state = h_general;
                  break;
              }
              break;

            /* connection */

            case h_matching_connection:
              parser->index++;
              if (parser->index > sizeof(CONNECTION)-1
                  || c != CONNECTION[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(CONNECTION)-2) {
                parser->header_state = h_connection;
              }
              break;

            /* proxy-connection */

            case h_matching_proxy_connection:
              parser->index++;
              if (parser->index > sizeof(PROXY_CONNECTION)-1
                  || c != PROXY_CONNECTION[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(PROXY_CONNECTION)-2) {
                parser->header_state = h_connection;
              }
              break;

            /* content-length */

            case h_matching_content_length:
              parser->index++;
              if (parser->index > sizeof(CONTENT_LENGTH)-1
                  || c != CONTENT_LENGTH[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(CONTENT_LENGTH)-2) {
                parser->header_state = h_content_length;
              }
              break;

            /* transfer-encoding */

            case h_matching_transfer_encoding:
              parser->index++;
              if (parser->index > sizeof(TRANSFER_ENCODING)-1
                  || c != TRANSFER_ENCODING[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(TRANSFER_ENCODING)-2) {
                parser->header_state = h_transfer_encoding;
              }
              break;

            /* upgrade */

            case h_matching_upgrade:
              parser->index++;
              if (parser->index > sizeof(UPGRADE)-1
                  || c != UPGRADE[parser->index]) {
                parser->header_state = h_general;
              } else if (parser->index == sizeof(UPGRADE)-2) {
                parser->header_state = h_upgrade;
              }
              break;

            case h_connection:
            case h_content_length:
            case h_transfer_encoding:
            case h_upgrade:
              if (ch != ' ') parser->header_state = h_general;
              break;

            default:
              assert(0 && "Unknown header_state");
              break;
          }
        }

        COUNT_HEADER_SIZE(p - start);

        if (p == data + len) {
          --p;
          break;
        }

        if (ch == ':') {
          UPDATE_STATE(s_header_value_discard_ws);
          CALLBACK_DATA(header_field);
          break;
        }

        SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
        goto error;
      }

      case s_header_value_discard_ws:
        if (ch == ' ' || ch == '\t') break;

        if (ch == CR) {
          UPDATE_STATE(s_header_value_discard_ws_almost_done);
          break;
        }

        if (ch == LF) {
          UPDATE_STATE(s_header_value_discard_lws);
          break;
        }

        /* FALLTHROUGH */

      case s_header_value_start:
      {
        MARK(header_value);

        UPDATE_STATE(s_header_value);
        parser->index = 0;

        c = LOWER(ch);

        switch (parser->header_state) {
          case h_upgrade:
            parser->flags |= F_UPGRADE;
            parser->header_state = h_general;
            break;

          case h_transfer_encoding:
            /* looking for 'Transfer-Encoding: chunked' */
            if ('c' == c) {
              parser->header_state = h_matching_transfer_encoding_chunked;
            } else {
              parser->header_state = h_general;
            }
            break;

          case h_content_length:
            if (UNLIKELY(!IS_NUM(ch))) {
              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
              goto error;
            }

            if (parser->flags & F_CONTENTLENGTH) {
              SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);
              goto error;
            }

            parser->flags |= F_CONTENTLENGTH;
            parser->content_length = ch - '0';
            break;

          case h_connection:
            /* looking for 'Connection: keep-alive' */
            if (c == 'k') {
              parser->header_state = h_matching_connection_keep_alive;
            /* looking for 'Connection: close' */
            } else if (c == 'c') {
              parser->header_state = h_matching_connection_close;
            } else if (c == 'u') {
              parser->header_state = h_matching_connection_upgrade;
            } else {
              parser->header_state = h_matching_connection_token;
            }
            break;

          /* Multi-value `Connection` header */
          case h_matching_connection_token_start:
            break;

          default:
            parser->header_state = h_general;
            break;
        }
        break;
      }

      case s_header_value:
      {
        const char* start = p;
        enum header_states h_state = (enum header_states) parser->header_state;
        for (; p != data + len; p++) {
          ch = *p;
          if (ch == CR) {
            UPDATE_STATE(s_header_almost_done);
            parser->header_state = h_state;
            CALLBACK_DATA(header_value);
            break;
          }

          if (ch == LF) {
            UPDATE_STATE(s_header_almost_done);
            COUNT_HEADER_SIZE(p - start);
            parser->header_state = h_state;
            CALLBACK_DATA_NOADVANCE(header_value);
            REEXECUTE();
          }

          if (!lenient && !IS_HEADER_CHAR(ch)) {
            SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
            goto error;
          }

          c = LOWER(ch);

          switch (h_state) {
            case h_general:
            {
              const char* p_cr;
              const char* p_lf;
              size_t limit = data + len - p;

              limit = MIN(limit, HTTP_MAX_HEADER_SIZE);

              p_cr = (const char*) memchr(p, CR, limit);
              p_lf = (const char*) memchr(p, LF, limit);
              if (p_cr != NULL) {
                if (p_lf != NULL && p_cr >= p_lf)
                  p = p_lf;
                else
                  p = p_cr;
              } else if (UNLIKELY(p_lf != NULL)) {
                p = p_lf;
              } else {
                p = data + len;
              }
              --p;

              break;
            }

            case h_connection:
            case h_transfer_encoding:
              assert(0 && "Shouldn't get here.");
              break;

            case h_content_length:
            {
              uint64_t t;

              if (ch == ' ') break;

              if (UNLIKELY(!IS_NUM(ch))) {
                SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
                parser->header_state = h_state;
                goto error;
              }

              t = parser->content_length;
              t *= 10;
              t += ch - '0';

              /* Overflow? Test against a conservative limit for simplicity. */
              if (UNLIKELY((ULLONG_MAX - 10) / 10 < parser->content_length)) {
                SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
                parser->header_state = h_state;
                goto error;
              }

              parser->content_length = t;
              break;
            }

            /* Transfer-Encoding: chunked */
            case h_matching_transfer_encoding_chunked:
              parser->index++;
              if (parser->index > sizeof(CHUNKED)-1
                  || c != CHUNKED[parser->index]) {
                h_state = h_general;
              } else if (parser->index == sizeof(CHUNKED)-2) {
                h_state = h_transfer_encoding_chunked;
              }
              break;

            case h_matching_connection_token_start:
              /* looking for 'Connection: keep-alive' */
              if (c == 'k') {
                h_state = h_matching_connection_keep_alive;
              /* looking for 'Connection: close' */
              } else if (c == 'c') {
                h_state = h_matching_connection_close;
              } else if (c == 'u') {
                h_state = h_matching_connection_upgrade;
              } else if (STRICT_TOKEN(c)) {
                h_state = h_matching_connection_token;
              } else if (c == ' ' || c == '\t') {
                /* Skip lws */
              } else {
                h_state = h_general;
              }
              break;

            /* looking for 'Connection: keep-alive' */
            case h_matching_connection_keep_alive:
              parser->index++;
              if (parser->index > sizeof(KEEP_ALIVE)-1
                  || c != KEEP_ALIVE[parser->index]) {
                h_state = h_matching_connection_token;
              } else if (parser->index == sizeof(KEEP_ALIVE)-2) {
                h_state = h_connection_keep_alive;
              }
              break;

            /* looking for 'Connection: close' */
            case h_matching_connection_close:
              parser->index++;
              if (parser->index > sizeof(CLOSE)-1 || c != CLOSE[parser->index]) {
                h_state = h_matching_connection_token;
              } else if (parser->index == sizeof(CLOSE)-2) {
                h_state = h_connection_close;
              }
              break;

            /* looking for 'Connection: upgrade' */
            case h_matching_connection_upgrade:
              parser->index++;
              if (parser->index > sizeof(UPGRADE) - 1 ||
                  c != UPGRADE[parser->index]) {
                h_state = h_matching_connection_token;
              } else if (parser->index == sizeof(UPGRADE)-2) {
                h_state = h_connection_upgrade;
              }
              break;

            case h_matching_connection_token:
              if (ch == ',') {
                h_state = h_matching_connection_token_start;
                parser->index = 0;
              }
              break;

            case h_transfer_encoding_chunked:
              if (ch != ' ') h_state = h_general;
              break;

            case h_connection_keep_alive:
            case h_connection_close:
            case h_connection_upgrade:
              if (ch == ',') {
                if (h_state == h_connection_keep_alive) {
                  parser->flags |= F_CONNECTION_KEEP_ALIVE;
                } else if (h_state == h_connection_close) {
                  parser->flags |= F_CONNECTION_CLOSE;
                } else if (h_state == h_connection_upgrade) {
                  parser->flags |= F_CONNECTION_UPGRADE;
                }
                h_state = h_matching_connection_token_start;
                parser->index = 0;
              } else if (ch != ' ') {
                h_state = h_matching_connection_token;
              }
              break;

            default:
              UPDATE_STATE(s_header_value);
              h_state = h_general;
              break;
          }
        }
        parser->header_state = h_state;

        COUNT_HEADER_SIZE(p - start);

        if (p == data + len)
          --p;
        break;
      }

      case s_header_almost_done:
      {
        if (UNLIKELY(ch != LF)) {
          SET_ERRNO(HPE_LF_EXPECTED);
          goto error;
        }

        UPDATE_STATE(s_header_value_lws);
        break;
      }

      case s_header_value_lws:
      {
        if (ch == ' ' || ch == '\t') {
          UPDATE_STATE(s_header_value_start);
          REEXECUTE();
        }

        /* finished the header */
        switch (parser->header_state) {
          case h_connection_keep_alive:
            parser->flags |= F_CONNECTION_KEEP_ALIVE;
            break;
          case h_connection_close:
            parser->flags |= F_CONNECTION_CLOSE;
            break;
          case h_transfer_encoding_chunked:
            parser->flags |= F_CHUNKED;
            break;
          case h_connection_upgrade:
            parser->flags |= F_CONNECTION_UPGRADE;
            break;
          default:
            break;
        }

        UPDATE_STATE(s_header_field_start);
        REEXECUTE();
      }

      case s_header_value_discard_ws_almost_done:
      {
        STRICT_CHECK(ch != LF);
        UPDATE_STATE(s_header_value_discard_lws);
        break;
      }

      case s_header_value_discard_lws:
      {
        if (ch == ' ' || ch == '\t') {
          UPDATE_STATE(s_header_value_discard_ws);
          break;
        } else {
          switch (parser->header_state) {
            case h_connection_keep_alive:
              parser->flags |= F_CONNECTION_KEEP_ALIVE;
              break;
            case h_connection_close:
              parser->flags |= F_CONNECTION_CLOSE;
              break;
            case h_connection_upgrade:
              parser->flags |= F_CONNECTION_UPGRADE;
              break;
            case h_transfer_encoding_chunked:
              parser->flags |= F_CHUNKED;
              break;
            default:
              break;
          }

          /* header value was empty */
          MARK(header_value);
          UPDATE_STATE(s_header_field_start);
          CALLBACK_DATA_NOADVANCE(header_value);
          REEXECUTE();
        }
      }

      case s_headers_almost_done:
      {
        STRICT_CHECK(ch != LF);

        if (parser->flags & F_TRAILING) {
          /* End of a chunked request */
          UPDATE_STATE(s_message_done);
          CALLBACK_NOTIFY_NOADVANCE(chunk_complete);
          REEXECUTE();
        }

        /* Cannot use chunked encoding and a content-length header together
           per the HTTP specification. */
        if ((parser->flags & F_CHUNKED) &&
            (parser->flags & F_CONTENTLENGTH)) {
          SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);
          goto error;
        }

        UPDATE_STATE(s_headers_done);

        /* Set this here so that on_headers_complete() callbacks can see it */
        parser->upgrade =
          ((parser->flags & (F_UPGRADE | F_CONNECTION_UPGRADE)) ==
           (F_UPGRADE | F_CONNECTION_UPGRADE) ||
           parser->method == HTTP_CONNECT);

        /* Here we call the headers_complete callback. This is somewhat
         * different than other callbacks because if the user returns 1, we
         * will interpret that as saying that this message has no body. This
         * is needed for the annoying case of recieving a response to a HEAD
         * request.
         *
         * We'd like to use CALLBACK_NOTIFY_NOADVANCE() here but we cannot, so
         * we have to simulate it by handling a change in errno below.
         */
        if (settings->on_headers_complete) {
          switch (settings->on_headers_complete(parser)) {
            case 0:
              break;

            case 2:
              parser->upgrade = 1;

            case 1:
              parser->flags |= F_SKIPBODY;
              break;

            default:
              SET_ERRNO(HPE_CB_headers_complete);
              RETURN(p - data); /* Error */
          }
        }

        if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
          RETURN(p - data);
        }

        REEXECUTE();
      }

      case s_headers_done:
      {
        int hasBody;
        STRICT_CHECK(ch != LF);

        parser->nread = 0;

        hasBody = parser->flags & F_CHUNKED ||
          (parser->content_length > 0 && parser->content_length != ULLONG_MAX);
        if (parser->upgrade && (parser->method == HTTP_CONNECT ||
                                (parser->flags & F_SKIPBODY) || !hasBody)) {
          /* Exit, the rest of the message is in a different protocol. */
          UPDATE_STATE(NEW_MESSAGE());
          CALLBACK_NOTIFY(message_complete);
          RETURN((p - data) + 1);
        }

        if (parser->flags & F_SKIPBODY) {
          UPDATE_STATE(NEW_MESSAGE());
          CALLBACK_NOTIFY(message_complete);
        } else if (parser->flags & F_CHUNKED) {
          /* chunked encoding - ignore Content-Length header */
          UPDATE_STATE(s_chunk_size_start);
        } else {
          if (parser->content_length == 0) {
            /* Content-Length header given but zero: Content-Length: 0\r\n */
            UPDATE_STATE(NEW_MESSAGE());
            CALLBACK_NOTIFY(message_complete);
          } else if (parser->content_length != ULLONG_MAX) {
            /* Content-Length header given and non-zero */
            UPDATE_STATE(s_body_identity);
          } else {
            if (!http_message_needs_eof(parser)) {
              /* Assume content-length 0 - read the next */
              UPDATE_STATE(NEW_MESSAGE());
              CALLBACK_NOTIFY(message_complete);
            } else {
              /* Read body until EOF */
              UPDATE_STATE(s_body_identity_eof);
            }
          }
        }

        break;
      }

      case s_body_identity:
      {
        uint64_t to_read = MIN(parser->content_length,
                               (uint64_t) ((data + len) - p));

        assert(parser->content_length != 0
            && parser->content_length != ULLONG_MAX);

        /* The difference between advancing content_length and p is because
         * the latter will automaticaly advance on the next loop iteration.
         * Further, if content_length ends up at 0, we want to see the last
         * byte again for our message complete callback.
         */
        MARK(body);
        parser->content_length -= to_read;
        p += to_read - 1;

        if (parser->content_length == 0) {
          UPDATE_STATE(s_message_done);

          /* Mimic CALLBACK_DATA_NOADVANCE() but with one extra byte.
           *
           * The alternative to doing this is to wait for the next byte to
           * trigger the data callback, just as in every other case. The
           * problem with this is that this makes it difficult for the test
           * harness to distinguish between complete-on-EOF and
           * complete-on-length. It's not clear that this distinction is
           * important for applications, but let's keep it for now.
           */
          CALLBACK_DATA_(body, p - body_mark + 1, p - data);
          REEXECUTE();
        }

        break;
      }

      /* read until EOF */
      case s_body_identity_eof:
        MARK(body);
        p = data + len - 1;

        break;

      case s_message_done:
        UPDATE_STATE(NEW_MESSAGE());
        CALLBACK_NOTIFY(message_complete);
        if (parser->upgrade) {
          /* Exit, the rest of the message is in a different protocol. */
          RETURN((p - data) + 1);
        }
        break;

      case s_chunk_size_start:
      {
        assert(parser->nread == 1);
        assert(parser->flags & F_CHUNKED);

        unhex_val = unhex[(unsigned char)ch];
        if (UNLIKELY(unhex_val == -1)) {
          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);
          goto error;
        }

        parser->content_length = unhex_val;
        UPDATE_STATE(s_chunk_size);
        break;
      }

      case s_chunk_size:
      {
        uint64_t t;

        assert(parser->flags & F_CHUNKED);

        if (ch == CR) {
          UPDATE_STATE(s_chunk_size_almost_done);
          break;
        }

        unhex_val = unhex[(unsigned char)ch];

        if (unhex_val == -1) {
          if (ch == ';' || ch == ' ') {
            UPDATE_STATE(s_chunk_parameters);
            break;
          }

          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);
          goto error;
        }

        t = parser->content_length;
        t *= 16;
        t += unhex_val;

        /* Overflow? Test against a conservative limit for simplicity. */
        if (UNLIKELY((ULLONG_MAX - 16) / 16 < parser->content_length)) {
          SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
          goto error;
        }

        parser->content_length = t;
        break;
      }

      case s_chunk_parameters:
      {
        assert(parser->flags & F_CHUNKED);
        /* just ignore this shit. TODO check for overflow */
        if (ch == CR) {
          UPDATE_STATE(s_chunk_size_almost_done);
          break;
        }
        break;
      }

      case s_chunk_size_almost_done:
      {
        assert(parser->flags & F_CHUNKED);
        STRICT_CHECK(ch != LF);

        parser->nread = 0;

        if (parser->content_length == 0) {
          parser->flags |= F_TRAILING;
          UPDATE_STATE(s_header_field_start);
        } else {
          UPDATE_STATE(s_chunk_data);
        }
        CALLBACK_NOTIFY(chunk_header);
        break;
      }

      case s_chunk_data:
      {
        uint64_t to_read = MIN(parser->content_length,
                               (uint64_t) ((data + len) - p));

        assert(parser->flags & F_CHUNKED);
        assert(parser->content_length != 0
            && parser->content_length != ULLONG_MAX);

        /* See the explanation in s_body_identity for why the content
         * length and data pointers are managed this way.
         */
        MARK(body);
        parser->content_length -= to_read;
        p += to_read - 1;

        if (parser->content_length == 0) {
          UPDATE_STATE(s_chunk_data_almost_done);
        }

        break;
      }

      case s_chunk_data_almost_done:
        assert(parser->flags & F_CHUNKED);
        assert(parser->content_length == 0);
        STRICT_CHECK(ch != CR);
        UPDATE_STATE(s_chunk_data_done);
        CALLBACK_DATA(body);
        break;

      case s_chunk_data_done:
        assert(parser->flags & F_CHUNKED);
        STRICT_CHECK(ch != LF);
        parser->nread = 0;
        UPDATE_STATE(s_chunk_size_start);
        CALLBACK_NOTIFY(chunk_complete);
        break;

      default:
        assert(0 && "unhandled state");
        SET_ERRNO(HPE_INVALID_INTERNAL_STATE);
        goto error;
    }
  }

  /* Run callbacks for any marks that we have leftover after we ran our of
   * bytes. There should be at most one of these set, so it's OK to invoke
   * them in series (unset marks will not result in callbacks).
   *
   * We use the NOADVANCE() variety of callbacks here because 'p' has already
   * overflowed 'data' and this allows us to correct for the off-by-one that
   * we'd otherwise have (since CALLBACK_DATA() is meant to be run with a 'p'
   * value that's in-bounds).
   */

  assert(((header_field_mark ? 1 : 0) +
          (header_value_mark ? 1 : 0) +
          (url_mark ? 1 : 0)  +
          (body_mark ? 1 : 0) +
          (status_mark ? 1 : 0)) <= 1);

  CALLBACK_DATA_NOADVANCE(header_field);
  CALLBACK_DATA_NOADVANCE(header_value);
  CALLBACK_DATA_NOADVANCE(url);
  CALLBACK_DATA_NOADVANCE(body);
  CALLBACK_DATA_NOADVANCE(status);

  RETURN(len);

error:
  if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {
    SET_ERRNO(HPE_UNKNOWN);
  }

  RETURN(p - data);
}


/* Does the parser need to see an EOF to find the end of the message? */
int
http_message_needs_eof (const http_parser *parser)
{
  if (parser->type == HTTP_REQUEST) {
    return 0;
  }

  /* See RFC 2616 section 4.4 */
  if (parser->status_code / 100 == 1 || /* 1xx e.g. Continue */
      parser->status_code == 204 ||     /* No Content */
      parser->status_code == 304 ||     /* Not Modified */
      parser->flags & F_SKIPBODY) {     /* response to a HEAD request */
    return 0;
  }

  if ((parser->flags & F_CHUNKED) || parser->content_length != ULLONG_MAX) {
    return 0;
  }

  return 1;
}


int
http_should_keep_alive (const http_parser *parser)
{
  if (parser->http_major > 0 && parser->http_minor > 0) {
    /* HTTP/1.1 */
    if (parser->flags & F_CONNECTION_CLOSE) {
      return 0;
    }
  } else {
    /* HTTP/1.0 or earlier */
    if (!(parser->flags & F_CONNECTION_KEEP_ALIVE)) {
      return 0;
    }
  }

  return !http_message_needs_eof(parser);
}


const char *
http_method_str (enum http_method m)
{
  return ELEM_AT(method_strings, m, "<unknown>");
}


void
http_parser_init (http_parser *parser, enum http_parser_type t)
{
  void *data = parser->data; /* preserve application data */
  memset(parser, 0, sizeof(*parser));
  parser->data = data;
  parser->type = t;
  parser->state = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));
  parser->http_errno = HPE_OK;
}

void
http_parser_settings_init(http_parser_settings *settings)
{
  memset(settings, 0, sizeof(*settings));
}

const char *
http_errno_name(enum http_errno err) {
  assert(((size_t) err) < ARRAY_SIZE(http_strerror_tab));
  return http_strerror_tab[err].name;
}

const char *
http_errno_description(enum http_errno err) {
  assert(((size_t) err) < ARRAY_SIZE(http_strerror_tab));
  return http_strerror_tab[err].description;
}

static enum http_host_state
http_parse_host_char(enum http_host_state s, const char ch) {
  switch(s) {
    case s_http_userinfo:
    case s_http_userinfo_start:
      if (ch == '@') {
        return s_http_host_start;
      }

      if (IS_USERINFO_CHAR(ch)) {
        return s_http_userinfo;
      }
      break;

    case s_http_host_start:
      if (ch == '[') {
        return s_http_host_v6_start;
      }

      if (IS_HOST_CHAR(ch)) {
        return s_http_host;
      }

      break;

    case s_http_host:
      if (IS_HOST_CHAR(ch)) {
        return s_http_host;
      }

    /* FALLTHROUGH */
    case s_http_host_v6_end:
      if (ch == ':') {
        return s_http_host_port_start;
      }

      break;

    case s_http_host_v6:
      if (ch == ']') {
        return s_http_host_v6_end;
      }

    /* FALLTHROUGH */
    case s_http_host_v6_start:
      if (IS_HEX(ch) || ch == ':' || ch == '.') {
        return s_http_host_v6;
      }

      if (s == s_http_host_v6 && ch == '%') {
        return s_http_host_v6_zone_start;
      }
      break;

    case s_http_host_v6_zone:
      if (ch == ']') {
        return s_http_host_v6_end;
      }

    /* FALLTHROUGH */
    case s_http_host_v6_zone_start:
      /* RFC 6874 Zone ID consists of 1*( unreserved / pct-encoded) */
      if (IS_ALPHANUM(ch) || ch == '%' || ch == '.' || ch == '-' || ch == '_' ||
          ch == '~') {
        return s_http_host_v6_zone;
      }
      break;

    case s_http_host_port:
    case s_http_host_port_start:
      if (IS_NUM(ch)) {
        return s_http_host_port;
      }

      break;

    default:
      break;
  }
  return s_http_host_dead;
}

static int
http_parse_host(const char * buf, struct http_parser_url *u, int found_at) {
  enum http_host_state s;

  const char *p;
  size_t buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;

  assert(u->field_set & (1 << UF_HOST));

  u->field_data[UF_HOST].len = 0;

  s = found_at ? s_http_userinfo_start : s_http_host_start;

  for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
    enum http_host_state new_s = http_parse_host_char(s, *p);

    if (new_s == s_http_host_dead) {
      return 1;
    }

    switch(new_s) {
      case s_http_host:
        if (s != s_http_host) {
          u->field_data[UF_HOST].off = p - buf;
        }
        u->field_data[UF_HOST].len++;
        break;

      case s_http_host_v6:
        if (s != s_http_host_v6) {
          u->field_data[UF_HOST].off = p - buf;
        }
        u->field_data[UF_HOST].len++;
        break;

      case s_http_host_v6_zone_start:
      case s_http_host_v6_zone:
        u->field_data[UF_HOST].len++;
        break;

      case s_http_host_port:
        if (s != s_http_host_port) {
          u->field_data[UF_PORT].off = p - buf;
          u->field_data[UF_PORT].len = 0;
          u->field_set |= (1 << UF_PORT);
        }
        u->field_data[UF_PORT].len++;
        break;

      case s_http_userinfo:
        if (s != s_http_userinfo) {
          u->field_data[UF_USERINFO].off = p - buf ;
          u->field_data[UF_USERINFO].len = 0;
          u->field_set |= (1 << UF_USERINFO);
        }
        u->field_data[UF_USERINFO].len++;
        break;

      default:
        break;
    }
    s = new_s;
  }

  /* Make sure we don't end somewhere unexpected */
  switch (s) {
    case s_http_host_start:
    case s_http_host_v6_start:
    case s_http_host_v6:
    case s_http_host_v6_zone_start:
    case s_http_host_v6_zone:
    case s_http_host_port_start:
    case s_http_userinfo:
    case s_http_userinfo_start:
      return 1;
    default:
      break;
  }

  return 0;
}

void
http_parser_url_init(struct http_parser_url *u) {
  memset(u, 0, sizeof(*u));
}

int
http_parser_parse_url(const char *buf, size_t buflen, int is_connect,
                      struct http_parser_url *u)
{
  enum state s;
  const char *p;
  enum http_parser_url_fields uf, old_uf;
  int found_at = 0;

  u->port = u->field_set = 0;
  s = is_connect ? s_req_server_start : s_req_spaces_before_url;
  old_uf = UF_MAX;

  for (p = buf; p < buf + buflen; p++) {
    s = parse_url_char(s, *p);

    /* Figure out the next field that we're operating on */
    switch (s) {
      case s_dead:
        return 1;

      /* Skip delimeters */
      case s_req_schema_slash:
      case s_req_schema_slash_slash:
      case s_req_server_start:
      case s_req_query_string_start:
      case s_req_fragment_start:
        continue;

      case s_req_schema:
        uf = UF_SCHEMA;
        break;

      case s_req_server_with_at:
        found_at = 1;

      /* FALLTROUGH */
      case s_req_server:
        uf = UF_HOST;
        break;

      case s_req_path:
        uf = UF_PATH;
        break;

      case s_req_query_string:
        uf = UF_QUERY;
        break;

      case s_req_fragment:
        uf = UF_FRAGMENT;
        break;

      default:
        assert(!"Unexpected state");
        return 1;
    }

    /* Nothing's changed; soldier on */
    if (uf == old_uf) {
      u->field_data[uf].len++;
      continue;
    }

    u->field_data[uf].off = p - buf;
    u->field_data[uf].len = 1;

    u->field_set |= (1 << uf);
    old_uf = uf;
  }

  /* host must be present if there is a schema */
  /* parsing http:///toto will fail */
  if ((u->field_set & (1 << UF_SCHEMA)) &&
      (u->field_set & (1 << UF_HOST)) == 0) {
    return 1;
  }

  if (u->field_set & (1 << UF_HOST)) {
    if (http_parse_host(buf, u, found_at) != 0) {
      return 1;
    }
  }

  /* CONNECT requests can only contain "hostname:port" */
  if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {
    return 1;
  }

  if (u->field_set & (1 << UF_PORT)) {
    /* Don't bother with endp; we've already validated the string */
    unsigned long v = strtoul(buf + u->field_data[UF_PORT].off, NULL, 10);

    /* Ports have a max value of 2^16 */
    if (v > 0xffff) {
      return 1;
    }

    u->port = (uint16_t) v;
  }

  return 0;
}

void
http_parser_pause(http_parser *parser, int paused) {
  /* Users should only be pausing/unpausing a parser that is not in an error
   * state. In non-debug builds, there's not much that we can do about this
   * other than ignore it.
   */
  if (HTTP_PARSER_ERRNO(parser) == HPE_OK ||
      HTTP_PARSER_ERRNO(parser) == HPE_PAUSED) {
    SET_ERRNO((paused) ? HPE_PAUSED : HPE_OK);
  } else {
    assert(0 && "Attempting to pause parser in error state");
  }
}

int
http_body_is_final(const struct http_parser *parser) {
    return parser->state == s_message_done;
}

unsigned long
http_parser_version(void) {
  return HTTP_PARSER_VERSION_MAJOR * 0x10000 |
         HTTP_PARSER_VERSION_MINOR * 0x00100 |
         HTTP_PARSER_VERSION_PATCH * 0x00001;
}

```

`benchmarking-payload/http-parser-payload/http_parser.h`:

```h
/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
#ifndef http_parser_h
#define http_parser_h
#ifdef __cplusplus
extern "C" {
#endif

/* Also update SONAME in the Makefile whenever you change these. */
#define HTTP_PARSER_VERSION_MAJOR 2
#define HTTP_PARSER_VERSION_MINOR 7
#define HTTP_PARSER_VERSION_PATCH 1

#include <sys/types.h>
#if defined(_WIN32) && !defined(__MINGW32__) && \
  (!defined(_MSC_VER) || _MSC_VER<1600) && !defined(__WINE__)
#include <BaseTsd.h>
#include <stddef.h>
typedef __int8 int8_t;
typedef unsigned __int8 uint8_t;
typedef __int16 int16_t;
typedef unsigned __int16 uint16_t;
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Compile with -DHTTP_PARSER_STRICT=0 to make less checks, but run
 * faster
 */
#ifndef HTTP_PARSER_STRICT
# define HTTP_PARSER_STRICT 1
#endif

/* Maximium header size allowed. If the macro is not defined
 * before including this header then the default is used. To
 * change the maximum header size, define the macro in the build
 * environment (e.g. -DHTTP_MAX_HEADER_SIZE=<value>). To remove
 * the effective limit on the size of the header, define the macro
 * to a very large number (e.g. -DHTTP_MAX_HEADER_SIZE=0x7fffffff)
 */
#ifndef HTTP_MAX_HEADER_SIZE
# define HTTP_MAX_HEADER_SIZE (80*1024)
#endif

typedef struct http_parser http_parser;
typedef struct http_parser_settings http_parser_settings;


/* Callbacks should return non-zero to indicate an error. The parser will
 * then halt execution.
 *
 * The one exception is on_headers_complete. In a HTTP_RESPONSE parser
 * returning '1' from on_headers_complete will tell the parser that it
 * should not expect a body. This is used when receiving a response to a
 * HEAD request which may contain 'Content-Length' or 'Transfer-Encoding:
 * chunked' headers that indicate the presence of a body.
 *
 * Returning `2` from on_headers_complete will tell parser that it should not
 * expect neither a body nor any futher responses on this connection. This is
 * useful for handling responses to a CONNECT request which may not contain
 * `Upgrade` or `Connection: upgrade` headers.
 *
 * http_data_cb does not return data chunks. It will be called arbitrarily
 * many times for each string. E.G. you might get 10 callbacks for "on_url"
 * each providing just a few characters more data.
 */
typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);
typedef int (*http_cb) (http_parser*);


/* Request Methods */
#define HTTP_METHOD_MAP(XX)         \
  XX(0,  DELETE,      DELETE)       \
  XX(1,  GET,         GET)          \
  XX(2,  HEAD,        HEAD)         \
  XX(3,  POST,        POST)         \
  XX(4,  PUT,         PUT)          \
  /* pathological */                \
  XX(5,  CONNECT,     CONNECT)      \
  XX(6,  OPTIONS,     OPTIONS)      \
  XX(7,  TRACE,       TRACE)        \
  /* WebDAV */                      \
  XX(8,  COPY,        COPY)         \
  XX(9,  LOCK,        LOCK)         \
  XX(10, MKCOL,       MKCOL)        \
  XX(11, MOVE,        MOVE)         \
  XX(12, PROPFIND,    PROPFIND)     \
  XX(13, PROPPATCH,   PROPPATCH)    \
  XX(14, SEARCH,      SEARCH)       \
  XX(15, UNLOCK,      UNLOCK)       \
  XX(16, BIND,        BIND)         \
  XX(17, REBIND,      REBIND)       \
  XX(18, UNBIND,      UNBIND)       \
  XX(19, ACL,         ACL)          \
  /* subversion */                  \
  XX(20, REPORT,      REPORT)       \
  XX(21, MKACTIVITY,  MKACTIVITY)   \
  XX(22, CHECKOUT,    CHECKOUT)     \
  XX(23, MERGE,       MERGE)        \
  /* upnp */                        \
  XX(24, MSEARCH,     M-SEARCH)     \
  XX(25, NOTIFY,      NOTIFY)       \
  XX(26, SUBSCRIBE,   SUBSCRIBE)    \
  XX(27, UNSUBSCRIBE, UNSUBSCRIBE)  \
  /* RFC-5789 */                    \
  XX(28, PATCH,       PATCH)        \
  XX(29, PURGE,       PURGE)        \
  /* CalDAV */                      \
  XX(30, MKCALENDAR,  MKCALENDAR)   \
  /* RFC-2068, section 19.6.1.2 */  \
  XX(31, LINK,        LINK)         \
  XX(32, UNLINK,      UNLINK)       \

enum http_method
  {
#define XX(num, name, string) HTTP_##name = num,
  HTTP_METHOD_MAP(XX)
#undef XX
  };


enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };


/* Flag values for http_parser.flags field */
enum flags
  { F_CHUNKED               = 1 << 0
  , F_CONNECTION_KEEP_ALIVE = 1 << 1
  , F_CONNECTION_CLOSE      = 1 << 2
  , F_CONNECTION_UPGRADE    = 1 << 3
  , F_TRAILING              = 1 << 4
  , F_UPGRADE               = 1 << 5
  , F_SKIPBODY              = 1 << 6
  , F_CONTENTLENGTH         = 1 << 7
  };


/* Map for errno-related constants
 *
 * The provided argument should be a macro that takes 2 arguments.
 */
#define HTTP_ERRNO_MAP(XX)                                           \
  /* No error */                                                     \
  XX(OK, "success")                                                  \
                                                                     \
  /* Callback-related errors */                                      \
  XX(CB_message_begin, "the on_message_begin callback failed")       \
  XX(CB_url, "the on_url callback failed")                           \
  XX(CB_header_field, "the on_header_field callback failed")         \
  XX(CB_header_value, "the on_header_value callback failed")         \
  XX(CB_headers_complete, "the on_headers_complete callback failed") \
  XX(CB_body, "the on_body callback failed")                         \
  XX(CB_message_complete, "the on_message_complete callback failed") \
  XX(CB_status, "the on_status callback failed")                     \
  XX(CB_chunk_header, "the on_chunk_header callback failed")         \
  XX(CB_chunk_complete, "the on_chunk_complete callback failed")     \
                                                                     \
  /* Parsing-related errors */                                       \
  XX(INVALID_EOF_STATE, "stream ended at an unexpected time")        \
  XX(HEADER_OVERFLOW,                                                \
     "too many header bytes seen; overflow detected")                \
  XX(CLOSED_CONNECTION,                                              \
     "data received after completed connection: close message")      \
  XX(INVALID_VERSION, "invalid HTTP version")                        \
  XX(INVALID_STATUS, "invalid HTTP status code")                     \
  XX(INVALID_METHOD, "invalid HTTP method")                          \
  XX(INVALID_URL, "invalid URL")                                     \
  XX(INVALID_HOST, "invalid host")                                   \
  XX(INVALID_PORT, "invalid port")                                   \
  XX(INVALID_PATH, "invalid path")                                   \
  XX(INVALID_QUERY_STRING, "invalid query string")                   \
  XX(INVALID_FRAGMENT, "invalid fragment")                           \
  XX(LF_EXPECTED, "LF character expected")                           \
  XX(INVALID_HEADER_TOKEN, "invalid character in header")            \
  XX(INVALID_CONTENT_LENGTH,                                         \
     "invalid character in content-length header")                   \
  XX(UNEXPECTED_CONTENT_LENGTH,                                      \
     "unexpected content-length header")                             \
  XX(INVALID_CHUNK_SIZE,                                             \
     "invalid character in chunk size header")                       \
  XX(INVALID_CONSTANT, "invalid constant string")                    \
  XX(INVALID_INTERNAL_STATE, "encountered unexpected internal state")\
  XX(STRICT, "strict mode assertion failed")                         \
  XX(PAUSED, "parser is paused")                                     \
  XX(UNKNOWN, "an unknown error occurred")


/* Define HPE_* values for each errno value above */
#define HTTP_ERRNO_GEN(n, s) HPE_##n,
enum http_errno {
  HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)
};
#undef HTTP_ERRNO_GEN


/* Get an http_errno value from an http_parser */
#define HTTP_PARSER_ERRNO(p)            ((enum http_errno) (p)->http_errno)


struct http_parser {
  /** PRIVATE **/
  unsigned int type : 2;         /* enum http_parser_type */
  unsigned int flags : 8;        /* F_* values from 'flags' enum; semi-public */
  unsigned int state : 7;        /* enum state from http_parser.c */
  unsigned int header_state : 7; /* enum header_state from http_parser.c */
  unsigned int index : 7;        /* index into current matcher */
  unsigned int lenient_http_headers : 1;

  uint32_t nread;          /* # bytes read in various scenarios */
  uint64_t content_length; /* # bytes in body (0 if no Content-Length header) */

  /** READ-ONLY **/
  unsigned short http_major;
  unsigned short http_minor;
  unsigned int status_code : 16; /* responses only */
  unsigned int method : 8;       /* requests only */
  unsigned int http_errno : 7;

  /* 1 = Upgrade header was present and the parser has exited because of that.
   * 0 = No upgrade header present.
   * Should be checked when http_parser_execute() returns in addition to
   * error checking.
   */
  unsigned int upgrade : 1;

  /** PUBLIC **/
  void *data; /* A pointer to get hook to the "connection" or "socket" object */
};


struct http_parser_settings {
  http_cb      on_message_begin;
  http_data_cb on_url;
  http_data_cb on_status;
  http_data_cb on_header_field;
  http_data_cb on_header_value;
  http_cb      on_headers_complete;
  http_data_cb on_body;
  http_cb      on_message_complete;
  /* When on_chunk_header is called, the current chunk length is stored
   * in parser->content_length.
   */
  http_cb      on_chunk_header;
  http_cb      on_chunk_complete;
};


enum http_parser_url_fields
  { UF_SCHEMA           = 0
  , UF_HOST             = 1
  , UF_PORT             = 2
  , UF_PATH             = 3
  , UF_QUERY            = 4
  , UF_FRAGMENT         = 5
  , UF_USERINFO         = 6
  , UF_MAX              = 7
  };


/* Result structure for http_parser_parse_url().
 *
 * Callers should index into field_data[] with UF_* values iff field_set
 * has the relevant (1 << UF_*) bit set. As a courtesy to clients (and
 * because we probably have padding left over), we convert any port to
 * a uint16_t.
 */
struct http_parser_url {
  uint16_t field_set;           /* Bitmask of (1 << UF_*) values */
  uint16_t port;                /* Converted UF_PORT string */

  struct {
    uint16_t off;               /* Offset into buffer in which field starts */
    uint16_t len;               /* Length of run in buffer */
  } field_data[UF_MAX];
};


/* Returns the library version. Bits 16-23 contain the major version number,
 * bits 8-15 the minor version number and bits 0-7 the patch level.
 * Usage example:
 *
 *   unsigned long version = http_parser_version();
 *   unsigned major = (version >> 16) & 255;
 *   unsigned minor = (version >> 8) & 255;
 *   unsigned patch = version & 255;
 *   printf("http_parser v%u.%u.%u\n", major, minor, patch);
 */
unsigned long http_parser_version(void);

void http_parser_init(http_parser *parser, enum http_parser_type type);


/* Initialize http_parser_settings members to 0
 */
void http_parser_settings_init(http_parser_settings *settings);


/* Executes the parser. Returns number of parsed bytes. Sets
 * `parser->http_errno` on error. */
size_t http_parser_execute(http_parser *parser,
                           const http_parser_settings *settings,
                           const char *data,
                           size_t len);


/* If http_should_keep_alive() in the on_headers_complete or
 * on_message_complete callback returns 0, then this should be
 * the last message on the connection.
 * If you are the server, respond with the "Connection: close" header.
 * If you are the client, close the connection.
 */
int http_should_keep_alive(const http_parser *parser);

/* Returns a string version of the HTTP method. */
const char *http_method_str(enum http_method m);

/* Return a string name of the given error */
const char *http_errno_name(enum http_errno err);

/* Return a string description of the given error */
const char *http_errno_description(enum http_errno err);

/* Initialize all http_parser_url members to 0 */
void http_parser_url_init(struct http_parser_url *u);

/* Parse a URL; return nonzero on failure */
int http_parser_parse_url(const char *buf, size_t buflen,
                          int is_connect,
                          struct http_parser_url *u);

/* Pause or un-pause the parser; a nonzero value pauses */
void http_parser_pause(http_parser *parser, int paused);

/* Checks if this is the final chunk of the body. */
int http_body_is_final(const http_parser *parser);

#ifdef __cplusplus
}
#endif
#endif

```

`benchmarking-payload/jsmn-payload/CMakeLists.txt`:

```txt
set(CMAKE_VERBOSE_MAKEFILE on)
set(LIBRARY_NAME jsmn-parser)
set(CMAKE_C_FLAGS "-m32 -g")
set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=c++11 -D_PAYLOAD_EXPORTS")

add_library(${LIBRARY_NAME} SHARED
	Payload.cpp
)

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/libjsmn-src
	$ENV{RIVER_SDK_DIR}/include
	)

target_link_libraries(${LIBRARY_NAME}
	${CMAKE_CURRENT_SOURCE_DIR}/libjsmn-src/libjsmn.a
)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`benchmarking-payload/jsmn-payload/Makefile`:

```
mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
makefile_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

libjsmn := libjsmn.so
CC := gcc
CXX := g++
OBJ_FILES :=  Payload.o $(makefile_dir)/libjsmn-src/libjsmn.a
INCLUDE_PATH := -I$(makefile_dir)/libjsmn-src
CXX_FLAGS += -m32 -std=c++11 -D_PAYLOAD_EXPORTS
prefix := /usr/local

all: $(libjsmn)

install: $(libjsmn)
	install -m 0755 $(libjsmn) -t $(prefix)/lib -D

$(libjsmn): $(OBJ_FILES)
	$(CXX) -m32 -shared $(OBJ_FILES) -o $@

Payload.o: Payload.cpp
	$(CXX) $(CXX_FLAGS) $(INCLUDE_PATH) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) -r $(libjsmn) Payload.o

```

`benchmarking-payload/jsmn-payload/Payload.cpp`:

```cpp
#include "CommonCrossPlatform/Common.h"
#include "CommonCrossPlatform/CommonSpecifiers.h"

#include "jsmn.h"


#define TOKEN_SIZE 256

static jsmn_parser parser;
static jsmntok_t tokens[TOKEN_SIZE];

void test_simple(const unsigned char *buf) {
	jsmn_init(&parser);
	// js - pointer to JSON string
	// tokens - an array of tokens available
	jsmn_parse(&parser, (const char *)buf, MAX_PAYLOAD_BUF, tokens, TOKEN_SIZE);
}

extern "C" {
	DLL_PUBLIC unsigned char payloadBuffer[MAX_PAYLOAD_BUF];
	DLL_PUBLIC int Payload() {
		test_simple(payloadBuffer);
		return 0;
	}
};

#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(
		_In_ HINSTANCE hinstDLL,
		_In_ DWORD     fdwReason,
		_In_ LPVOID    lpvReserved
		) {
	return TRUE;
}
#endif

```

`benchmarking-payload/jsmn-payload/config_jsmn.sh`:

```sh
#! /bin/bash

# Init http-parser source code
SRC_DIR="$(pwd)/libjsmn-src"

DEFAULT_CFLAGS="-m32"
DEFAULT_LDFLAGS="-m32"
CC=gcc
CXX=g++

# Build http-parser with the given `name` and flags.
build_target() {

	if ! [ -d $SRC_DIR ]; then
		git clone https://github.com/zserge/jsmn.git $SRC_DIR
	fi

	cd $SRC_DIR
	make clean
	CC="$CC" CXX="$CXX" CXXFLAGS="$DEFAULT_CFLAGS" \
		CFLAGS="$DEFAULT_CFLAGS" LDFLAGS="$DEFAULT_LDFLAGS" \
		make all

	cd -
}

build_target

```

`benchmarking-payload/libjpeg-turbo-payload/CMakeLists.txt`:

```txt
set(LIBRARY_NAME jpeg-turbo-payload)
set(CMAKE_C_FLAGS "-m32 -g")
set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=c++11 -D_PAYLOAD_EXPORTS")

add_library(${LIBRARY_NAME} SHARED
	Payload.cpp
)

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/libjpeg-turbo-src
	$ENV{RIVER_SDK_DIR}/include
	)

target_link_libraries(${LIBRARY_NAME}
	${CMAKE_CURRENT_SOURCE_DIR}/libjpeg-turbo-src/.libs/libturbojpeg.a
)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`benchmarking-payload/libjpeg-turbo-payload/Makefile`:

```
mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
makefile_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

libjpeg_turbo := libjpeg_turbo.so
CC := gcc
CXX := g++
INCLUDE_PATHS = -I$(makefile_dir)/libjpeg-turbo-src
OBJ_FILES := Payload.o $(makefile_dir)/libjpeg-turbo-src/.libs/libturbojpeg.a
CXX_FLAGS += -m32 -std=c++11 -D_PAYLOAD_EXPORTS
prefix := /usr/local

all: $(libjpeg_turbo)

install: $(libjpeg_turbo)
	install -m 0755 $(libjpeg_turbo) -t $(prefix)/lib -D

$(libjpeg_turbo): $(OBJ_FILES)
	$(CXX) -m32 -shared $(OBJ_FILES) -o $@

Payload.o: Payload.cpp
	   $(CXX) $(CXX_FLAGS) $(INCLUDE_PATHS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(libjpeg_turbo) Payload.o

```

`benchmarking-payload/libjpeg-turbo-payload/Payload.cpp`:

```cpp
#include "CommonCrossPlatform/Common.h"
#include "CommonCrossPlatform/CommonSpecifiers.h"

#include <turbojpeg.h>
#include <stdint.h>
#include <stdlib.h>

#include <memory>

void test_simple(const unsigned char *data) {
	tjhandle jpegDecompressor = tjInitDecompress();

	int width, height, subsamp, colorspace;
	int res = tjDecompressHeader3(
        jpegDecompressor, data, MAX_PAYLOAD_BUF,
		&width, &height, &subsamp, &colorspace);

    // Bail out if decompressing the headers failed, the width or height is 0,
    // or the image is too large (avoids slowing down too much). Cast to size_t to
    // avoid overflows on the multiplication
    if (res != 0 || width == 0 || height == 0 || ((size_t)width * height > (1024 * 1024))) {
        tjDestroy(jpegDecompressor);
        return;
    }

    std::unique_ptr<unsigned char[]> buf(new unsigned char[width * height * 3]);
    tjDecompress2(
        jpegDecompressor, data, MAX_PAYLOAD_BUF,
		buf.get(), width, 0, height, TJPF_RGB, 0);

    tjDestroy(jpegDecompressor);
}

extern "C" {
	DLL_PUBLIC unsigned char payloadBuffer[MAX_PAYLOAD_BUF];
	DLL_PUBLIC int Payload() {
		test_simple(payloadBuffer);
		return 0;
	}
};

#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(
		_In_ HINSTANCE hinstDLL,
		_In_ DWORD     fdwReason,
		_In_ LPVOID    lpvReserved
		) {
	return TRUE;
}
#endif

```

`benchmarking-payload/libjpeg-turbo-payload/config_libjpeg-turbo.sh`:

```sh
#! /bin/bash

# Init source code
SRC_DIR="$(pwd)/libjpeg-turbo-src"

DEFAULT_CFLAGS="-m32"
DEFAULT_LDFLAGS="-m32"
CC=gcc
CXX=g++

init_target() {
	if ! [ -d $SRC_DIR ]; then
		wget https://github.com/libjpeg-turbo/libjpeg-turbo/archive/1.5.1.tar.gz
		tar xvf 1.5.1.tar.gz
		mv libjpeg-turbo-1.5.1 $SRC_DIR
		cd $SRC_DIR
		autoreconf -fiv
		cd -
	fi
}

LIBTURBOJPEG_FLAGS="--host i686-pc-linux-gnu"
LIBTURBOJPEG_CFLAGS="-O3 -m32"
LIBTURBOJPEG_LDFLAGS="-m32"

build_target() {
	cd $SRC_DIR
	CC="$CC" CFLAGS="$DEFAULT_CFLAGS $LIBTURBOJPEG_CFLAGS" \
	LDFLAGS="$DEFAULT_LDFLAGS $LIBTURBOJPEG_LDFLAGS" \
	$SRC_DIR/configure $LIBTURBOJPEG_FLAGS

	make
	cd -
}

init_target
build_target

```

`benchmarking-payload/libpng-payload/CMakeLists.txt`:

```txt
set(LIBRARY_NAME png-payload)
set(CMAKE_C_FLAGS "-m32 -g")
set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=c++11 -nostdlib -D_PAYLOAD_EXPORTS")

add_library(${LIBRARY_NAME} SHARED
	Payload.cpp
)

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/libpng-src
	$ENV{RIVER_SDK_DIR}/include
	)

target_link_libraries(${LIBRARY_NAME}
	${CMAKE_CURRENT_SOURCE_DIR}/libpng-src/.libs/libpng16.a
	z
)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`benchmarking-payload/libpng-payload/Makefile`:

```
mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
makefile_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

libpng := libpng.so
CC := gcc
CXX := g++
INCLUDE_PATHS = -I$(makefile_dir)/libpng-src
OBJ_FILES := Payload.o $(makefile_dir)/libpng-src/.libs/libpng16.a
CXX_FLAGS += -m32 -std=c++11 -D_PAYLOAD_EXPORTS
prefix := /usr/local

all: $(libpng)

install: $(libpng)
	install -m 0755 $(libpng) -t $(prefix)/lib -D

$(libpng): $(OBJ_FILES)
	$(CXX) -m32 -shared $(OBJ_FILES) -o $@ -lz

Payload.o: Payload.cpp
	   $(CXX) $(CXX_FLAGS) $(INCLUDE_PATHS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(libpng) Payload.o

```

`benchmarking-payload/libpng-payload/Payload.cpp`:

```cpp
#include "CommonCrossPlatform/Common.h"
#include "CommonCrossPlatform/CommonSpecifiers.h"
#include <stddef.h>
#include <stdint.h>
#include <string.h>


#define PNG_INTERNAL
#include "png.h"

struct BufState {
  const uint8_t* data;
  size_t bytes_left;
};

struct PngObjectHandler {
  png_infop info_ptr = nullptr;
  png_structp png_ptr = nullptr;
  png_voidp row_ptr = nullptr;
  BufState* buf_state = nullptr;

  ~PngObjectHandler() {
    if (row_ptr && png_ptr) {
      png_free(png_ptr, row_ptr);
    }
    if (png_ptr && info_ptr) {
      png_destroy_read_struct(&png_ptr, &info_ptr, nullptr);
    }
    delete buf_state;
  }
};

void user_read_data(png_structp png_ptr, png_bytep data, png_size_t length) {
  BufState* buf_state = static_cast<BufState*>(png_get_io_ptr(png_ptr));
  if (length > buf_state->bytes_left) {
    png_error(png_ptr, "read error");
  }
  memcpy(data, buf_state->data, length);
  buf_state->bytes_left -= length;
  buf_state->data += length;
}

static const int kPngHeaderSize = 8;

// Entry point for LibFuzzer.
// Roughly follows the libpng book example:
// http://www.libpng.org/pub/png/book/chapter13.html

void test_simple(const unsigned char *data) {
  unsigned int size = MAX_PAYLOAD_BUF;
  if (size < kPngHeaderSize) {
    return;
  }

  if (png_sig_cmp(data, 0, kPngHeaderSize)) {
    // not a PNG.
    return;
  }

  PngObjectHandler png_handler;
  png_handler.png_ptr = png_create_read_struct
    (PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr);
  if (!png_handler.png_ptr) {
    return;
  }

  png_set_user_limits(png_handler.png_ptr, 2048, 2048);

  png_set_crc_action(png_handler.png_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);

  png_handler.info_ptr = png_create_info_struct(png_handler.png_ptr);
  if (!png_handler.info_ptr) {
    return;
  }

  // Setting up reading from buffer.
  png_handler.buf_state = new BufState();
  png_handler.buf_state->data = data + kPngHeaderSize;
  png_handler.buf_state->bytes_left = size - kPngHeaderSize;
  png_set_read_fn(png_handler.png_ptr, png_handler.buf_state, user_read_data);
  png_set_sig_bytes(png_handler.png_ptr, kPngHeaderSize);

  // libpng error handling.
  if (setjmp(png_jmpbuf(png_handler.png_ptr))) {
    return;
  }

  // Reading.
  png_read_info(png_handler.png_ptr, png_handler.info_ptr);
  png_handler.row_ptr = png_malloc(
      png_handler.png_ptr, png_get_rowbytes(png_handler.png_ptr,
                                               png_handler.info_ptr));

  // reset error handler to put png_deleter into scope.
  if (setjmp(png_jmpbuf(png_handler.png_ptr))) {
    return;
  }

  png_uint_32 width, height;
  int bit_depth, color_type, interlace_type, compression_type;
  int filter_type;

  if (!png_get_IHDR(png_handler.png_ptr, png_handler.info_ptr, &width,
                    &height, &bit_depth, &color_type, &interlace_type,
                    &compression_type, &filter_type)) {
    return;
  }

  // This is going to be too slow.
  if (width && height > 100000000 / width)
    return;

  if (width > 2048 || height > 2048)
    return;

  int passes = png_set_interlace_handling(png_handler.png_ptr);
  png_start_read_image(png_handler.png_ptr);

  for (int pass = 0; pass < passes; ++pass) {
    for (png_uint_32 y = 0; y < height; ++y) {
      png_read_row(png_handler.png_ptr,
                   static_cast<png_bytep>(png_handler.row_ptr), NULL);
    }
  }

  return;
}

extern "C" {
	DLL_PUBLIC unsigned char payloadBuffer[MAX_PAYLOAD_BUF];
	DLL_PUBLIC int Payload() {
		test_simple(payloadBuffer);
		return 0;
	}
};

#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(
		_In_ HINSTANCE hinstDLL,
		_In_ DWORD     fdwReason,
		_In_ LPVOID    lpvReserved
		) {
	return TRUE;
}
#endif

```

`benchmarking-payload/libpng-payload/config_libpng.sh`:

```sh
#! /bin/bash

# Init source code
SRC_DIR="$(pwd)/libpng-src"

DEFAULT_CFLAGS="-m32 -fno-stack-protector"
DEFAULT_LDFLAGS="-m32"
CC=gcc
CXX=g++

init_target() {
	if ! [ -d $SRC_DIR ]; then
		wget https://github.com/glennrp/libpng/archive/v1.6.33.tar.gz
		tar xvf v1.6.33.tar.gz
		mv libpng-1.6.33 $SRC_DIR
		cd $SRC_DIR
		autoreconf -fiv
		cd -
	fi
}


# Build http-parser with the given `name` and flags.
build_target() {
	cd $SRC_DIR
	make clean
	CC="$CC" CFLAGS="$DEFAULT_CFLAGS" LDFLAGS="$DEFAULT_LDFLAGS" \
	LD="ld -m elf_i386"  ./configure --enable-werror=no \
	--enable-hardware-optimizations=no --enable-shared=no \
	--enable-unversioned-links=no

	make libpng16.la
	cd -
}

init_target
build_target

```

`benchmarking-payload/libxml2-payload/CMakeLists.txt`:

```txt
set(LIBRARY_NAME xml2-payload)
set(CMAKE_C_FLAGS "-m32 -g")
set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=c++11 -D_PAYLOAD_EXPORTS")

add_library(${LIBRARY_NAME} SHARED
	Payload.cpp
)

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/build/include
	${CMAKE_CURRENT_SOURCE_DIR}/libxml2-src/include
	$ENV{RIVER_SDK_DIR}/include
	)

target_link_libraries(${LIBRARY_NAME}
	${CMAKE_CURRENT_SOURCE_DIR}/build/.libs/libxml2.a
)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`benchmarking-payload/libxml2-payload/Makefile`:

```
mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
makefile_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

libxml := libxml.so
CC := gcc
CXX := g++
LIBPATHS := -L$(makefile_dir) -L$(makefile_dir)/build/.libs/
OBJ_FILES :=  Payload.o
INCLUDE_PATH := -I$(makefile_dir)/build/include -I$(makefile_dir)/libxml2-src/include
NO_SSE := -mno-mmx -mno-sse -march=i386
CXX_FLAGS += -m32 -std=c++11 $(NO_SSE) -D_PAYLOAD_EXPORTS
prefix := /usr/local

all: $(libxml)

install: $(libxml)
	install -m 0755 $(libxml) -t $(prefix)/lib -D

$(libxml): $(OBJ_FILES)
	$(CXX) -m32 -shared $(LIBPATHS) $(OBJ_FILES) -lxml2 -o $@

Payload.o: Payload.cpp
	$(CXX) $(CXX_FLAGS) $(INCLUDE_PATH) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) -r $(libxml) Payload.o #build/

```

`benchmarking-payload/libxml2-payload/Payload.cpp`:

```cpp
#include "CommonCrossPlatform/Common.h"
#include "CommonCrossPlatform/CommonSpecifiers.h"

#include "libxml/parser.h"
#include "libxml/tree.h"

static void nopErrorHandlerFunction(void *ctx, const char *msg, ...) {}
static xmlGenericErrorFunc nopErrorHandler = nopErrorHandlerFunction;

void test_simple(const unsigned char *buf) {
	initGenericErrorDefaultFunc(&nopErrorHandler);

	if (auto doc = xmlReadMemory(reinterpret_cast<const char *>(buf), MAX_PAYLOAD_BUF, "noname.xml", NULL,
				XML_PARSE_NOERROR | XML_PARSE_NOWARNING | XML_PARSE_NONET)) {
		xmlFreeDoc(doc);
	}
}

extern "C" {
	DLL_PUBLIC unsigned char payloadBuffer[MAX_PAYLOAD_BUF];
	DLL_PUBLIC int Payload() {
		test_simple(payloadBuffer);
		return 0;
	}
};

#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(
		_In_ HINSTANCE hinstDLL,
		_In_ DWORD     fdwReason,
		_In_ LPVOID    lpvReserved
		) {
	return TRUE;
}
#endif

```

`benchmarking-payload/libxml2-payload/config_libxml2.sh`:

```sh
#! /bin/bash

ARGS="--enable-option-checking --disable-shared --disable-ipv6 --without-c14n --without-catalog
--without-debug --without-docbook --without-ftp --without-http --without-legacy
--without-output --without-pattern --without-push --without-python
--without-reader --without-readline --without-regexps --without-sax1 --without-schemas
--without-schematron --without-threads --without-valid --without-writer --without-xinclude
--without-xpath --without-xptr --with-zlib=no --with-lzma=no"

NO_SSE="-mno-mmx -mno-sse -march=i386"

init_target() {
	if ! [ -d libxml2-src ]; then
		git clone git://git.gnome.org/libxml2 libxml2-src
		(
		cd libxml2-src
		autoreconf -fiv
		)
	fi
}

build_target() {

	mkdir -p build
	cd build
	CC="$CC" CXX="$CXX" CFLAGS="-m32 $NO_SSE" LDFLAGS="-m32" \
		../libxml2-src/configure $ARGS
	make -j $N_CORES libxml2.la include/libxml/xmlversion.h
	cd ..
}

init_target
build_target

```

`benchmarking-payload/simple-accumulator-payload/CMakeLists.txt`:

```txt
set(LIBRARY_NAME "simple-accumulator")

set(CMAKE_C_FLAGS "-m32 -g")
set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -D_PAYLOAD_EXPORTS")

include_directories($ENV{RIVER_SDK_DIR}/include)

add_library(${LIBRARY_NAME} SHARED
	simple-accumulator.c
	Payload.cpp
	)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`benchmarking-payload/simple-accumulator-payload/Payload.cpp`:

```cpp
#include "CommonCrossPlatform/CommonSpecifiers.h"
#include "CommonCrossPlatform/Common.h"

extern "C" void test_simple(const unsigned char *buf);

extern "C" {
	DLL_PUBLIC unsigned char payloadBuffer[MAX_PAYLOAD_BUF];
	DLL_PUBLIC int Payload() {
		test_simple(payloadBuffer);
		return 0;
	}
};

#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(
		_In_ HINSTANCE hinstDLL,
		_In_ DWORD     fdwReason,
		_In_ LPVOID    lpvReserved
		) {
	return TRUE;
}
#else
__attribute__((constructor)) void somain(void) {
}
#endif

```

`benchmarking-payload/simple-accumulator-payload/simple-accumulator.c`:

```c
#include <stdio.h>

#define MAX_PAYLOAD_BUF 128

void print_payload(const unsigned char *buf) {
	for (unsigned i = 0; i < MAX_PAYLOAD_BUF; ++i) {
		printf("%02X", buf[i]);
	}
	printf("\n");
}

void test_simple(const unsigned char *buf) {
	const unsigned alpha_len = 'z' - 'A';
	unsigned char magic = 0;
	for (unsigned i = 0; i < alpha_len; ++i) {
		magic = magic | ('A' + i);
	}

	if (magic == buf[0]) {
		print_payload(buf);
	}
}

```

`benchmarking-payload/simple-address-payload/CMakeLists.txt`:

```txt
set(LIBRARY_NAME "simple-address")

set(CMAKE_C_FLAGS "-m32 -g")
set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -D_PAYLOAD_EXPORTS")

include_directories($ENV{RIVER_SDK_DIR}/include)

add_library(${LIBRARY_NAME} SHARED
	simple-address.c
	Payload.cpp
	)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`benchmarking-payload/simple-address-payload/Payload.cpp`:

```cpp
#include "CommonCrossPlatform/CommonSpecifiers.h"
#include "CommonCrossPlatform/Common.h"

extern "C" void test_simple(const unsigned char *buf);

extern "C" {
	DLL_PUBLIC unsigned char payloadBuffer[MAX_PAYLOAD_BUF];
	DLL_PUBLIC int Payload() {
		test_simple(payloadBuffer);
		return 0;
	}
};

#ifdef _WIN32
#include <Windows.h>
BOOL WINAPI DllMain(
		_In_ HINSTANCE hinstDLL,
		_In_ DWORD     fdwReason,
		_In_ LPVOID    lpvReserved
		) {
	return TRUE;
}
#else
__attribute__((constructor)) void somain(void) {
}
#endif

```

`benchmarking-payload/simple-address-payload/simple-address.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include "CommonCrossPlatform/Common.h"

// data layout
//		size | ... | payload | payload ... | payload
// payload layout
//		data | size

void my_warn(void) {
	exit(0);
}

void test_simple(const unsigned char *buf) {
	unsigned size = 0;
	const unsigned char *payload_cursor = NULL;

	size = ((unsigned *)buf)[0];
	payload_cursor = buf + size;

	payload_cursor -= 4;

	unsigned payload_size = ((unsigned *)payload_cursor)[0];
	//payload_cursor -= payload_size;

	__asm("mov 4(%%ebp), %%ebx;"
			"mov %0, %%eax;"
			"test %%eax, %%eax;"
			"jz my_warn;"
			: : "r" (payload_cursor) : "%eax", "%ebx"
		 );
}

```

`build-all.sh`:

```sh
#!/usr/bin/env bash

[ $# != 2 ] && { echo "Usage: ./build-all.sh <prefix> <prefix_payload> "; exit 1; }
DIRS="revtracer-wrapper revtracer BinLoader  Execution http-parser-payload libxml-payload"

for d in $DIRS; do
	make clean -C $d
	prefix="$1"
	if [ "$d" == "http-parser-payload" ] || [ "$d" == "libxml-payload" ]; then
		prefix="$2"
	fi
	make install prefix="$prefix" -C $d
done

```

`docs/abi/Makefile`:

```
BASENAME = abi

include ../metafiles/base.mk

```

`docs/abi/abi.tex`:

```tex
\documentclass[12pt]{report}


\input{macros}

\begin{document}

\author{Edited by\\
  Teodor Stoenescu\thanks{tstoenescu@bitdefender.com},
  Alexandra Sandulescu\thanks{asandulescu@bitdefender.com}}

\title{River Application Binary Interface\\
Version \version}
\maketitle
\tableofcontents
%%\listoftables
%%\listoffigures

\section*{Revision History}

\begin{description}
	\item[1.0][09.02.2018] Document rep prefix instrumentation \autoref{sec:rep-family-abi}.
\item[0.3][28.01.2016] Added \autoref{sec:reassembly} detailing instruction reassembly.
\item[0.2][26.01.2016] Added chapter detailing the binary translation - \autoref{chapter:binary-translation-process}.
Added several new meta instructions - \autoref{sec:tracking-translator}.
Added the track instruction family.
Substituted chapter numbers with cross references.
\item[0.1][09.09.2015] Renamed symbop instruction set to track and pretrack.
Covers the pretrack instruction set.
Added individual flag tracking.
Added a brief description of the current API.
\item[0.0][20.07.2015] Initial release. Covers general instruction layout as well as the river instruction set.
\end{description}

\chapter{River internal instruction representation}
Since this documentation is subject to change please consult the river.h header file for an updated version.\\
Instructions are represented in the river intermediate representation as fixed length structures as defined below. This comes in handy since most translators work on arrays of instructions.

\lstinputlisting[language=C]{../cheatsheet/code/RiverInstruction.h}

Modifiers are described in \autoref{sec:modifiers}, specifiers in \autoref{sec:specifiers}, family in \autoref{sec:instrfamilies}. OpTypes are documented in \autoref{sec:operands-and-operand-types} along with operands.

\section{Modifiers}
\label{sec:modifiers}
Instruction modifiers are optional instruction features introduced by x86 instruction prefixes.\\
\begin{table}[H]
	\begin{tabular}{| p{6cm} | p{10cm} |}
		\hline
		\textbf{Modifier name} & \textbf{Modifier meaning}\\ \hline
		\texttt{RIVER\_MODIFIER\_NOSEG} & Default modifier, used as a placeholder when no other modifiers are specified.\\ \hline
		\texttt{RIVER\_MODIFIER\_ESSEG} & \multirow{6}{*}{The instruction has been prefixed with a segment selector.} \\
		\texttt{RIVER\_MODIFIER\_CSSEG} &\\
		\texttt{RIVER\_MODIFIER\_SSSEG} &\\
		\texttt{RIVER\_MODIFIER\_DSSEG} &\\
		\texttt{RIVER\_MODIFIER\_FSSEG} &\\
		\texttt{RIVER\_MODIFIER\_GSSEG} &\\ \hline
		\texttt{RIVER\_MODIFIER\_EXT} & The instruction has a two byte opcode. (0x0F is the first byte)\\ \hline
		\texttt{RIVER\_MODIFIER\_O8} & (No corresponding prefix) The instruction operates on 8 bit operands.\\ \hline
		\texttt{RIVER\_MODIFIER\_O16} & The instruction operates on 16 bit operands.\\ \hline
		\texttt{RIVER\_MODIFIER\_A16} & The instruction uses 16 bit addressing mode.\\ \hline
		\texttt{RIVER\_MODIFIER\_LOCK} & The instruction has a LOCK prefix.\\ \hline
		\texttt{RIVER\_MODIFIER\_REP} & \multirow{3}{*}{The instruction has a REP/REPZ/REPNZ prefix.}\\
		\texttt{RIVER\_MODIFIER\_REPZ} &\\
		\texttt{RIVER\_MODIFIER\_REPNZ} &\\ \hline
	\end{tabular}
	\caption{River Modifiers}
	\label{table:river-modifiers}
\end{table}

\section{Specifiers}
\label{sec:specifiers}
Instruction specifiers are decorations introduced by the disassembler in order to aid data flow analysis.\\
\begin{table}[H]
\begin{tabular}{| p{6.3cm} | p{10cm} |}
		\hline
		\textbf{Specifier name} & \textbf{Specifier meaning}\\ \hline
		\texttt{RIVER\_SPEC\_MODIFIES\_OP(x}) & \multirow{5}{10cm}{The current instruction modifies the specified operand. NOTE: Keep in mind that \texttt{RIVER_SPEC_MODIFIES_OP1} actually corresponds to \texttt{RIVER_SPEC_MODIFIES_OP(0)}.}\\
		\texttt{RIVER\_SPEC\_MODIFIES\_OP1} &\\
		\texttt{RIVER\_SPEC\_MODIFIES\_OP2} &\\
		\texttt{RIVER\_SPEC\_MODIFIES\_OP3} &\\
		\texttt{RIVER\_SPEC\_MODIFIES\_OP4} &\\ \hline
		\texttt{RIVER\_SPEC\_MODIFIES\_FLG} & The instruction modifies at least one CPU flag. (This specifier might be deprecated in the future and replaced with individual per-flag versions)\\ \hline
		\texttt{RIVER\_SPEC\_IGNORES\_OP(idx)} & \multirow{6}{10cm}{Used in combination with \texttt{RIVER\_SPEC\_MODIFIES\_OP(x)}, specifies that the current operand is only used as an output operand. NOTE: Keep in mind that \texttt{RIVER\_SPEC\_IGNORES\_OP1} actually corresponds to \texttt{RIVER\_SPEC\_IGNORES\_OP(0)}.} \\
		\texttt{RIVER\_SPEC\_IGNORES\_OP1} &\\
		\texttt{RIVER\_SPEC\_IGNORES\_OP2} &\\
		\texttt{RIVER\_SPEC\_IGNORES\_OP3} &\\
		\texttt{RIVER\_SPEC\_IGNORES\_OP4} &\\
		& \\\hline
		\texttt{RIVER\_SPEC\_IGNORES\_FLG} & The instruction ignores all CPU flags. (To be deprecated soon).\\ \hline
	\end{tabular}
	\caption{River Specifiers}
	\label{table:river-specifiers}
\end{table}

\section{Instruction families}
\label{sec:instrfamilies}
Instruction families are the core of the river design. \autoref{chapter:instruction-families-abi} gives a more detailed analysis of the available families.\\
\begin{table}[H]
	\begin{tabular}{| p{6cm} | p{10cm} |}
		\hline
		\textbf{Family name} & \textbf{Family meaning}\\ \hline
		\texttt{RIVER_FAMILY_NATIVE} & Native instructions produced by the x86 disassembler.\\ \hline
		\texttt{RIVER_FAMILY_RIVER} & Instruction family that enables reversible code.\\ \hline
		\texttt{RIVER_FAMILY_PRETRACK} & Instruction family that handles symbolic variable tracking. These instructions are inserted directly into the original instruction stream.\\ \hline
		\texttt{RIVER_FAMILY_TRACK} & Instruction family that handles symbolic variable tracking. These instructions are inserted in a separate instruction stream.\\ \hline
		\texttt{RIVER_FAMILY_PREMETA} & Instruction produced by the disassembler that further specify the following native instruction.\\ \hline
		\texttt{RIVER_FAMILY_POSTMETA} & Instruction produced by the disassembler that further specify the previous native instruction.\\ \hline
		\texttt{RIVER_FAMILY_RIVER_TRACK} & Instruction family that handles symbolic variable tracking during reverse execution.\\ \hline
		\texttt{RIVER_FAMILY_REP} & Instuctions that handle \texttt{rep} prefix instrumentation.\\ \hline
	\end{tabular}
	\caption{Instruction Families}
	\label{table:instruction-families}
\end{table}
Furthermore some instruction families may be further decorated with the following flags.\\
\begin{table}[H]
	\begin{tabular}{| p{8cm} | p{8cm} |}
		\hline
		\textbf{Family name} & \textbf{Family meaning}\\ \hline
		\texttt{RIVER_FAMILY_FLAG_IGNORE} & The current instruction has been marked for lazy deletion.\\ \hline
		\texttt{RIVER_FAMILY_FLAG_METAPROCESSED} & The current instruction has been completely split up in metaoperations.\\ \hline
		\texttt{RIVER_FAMILY_FLAG_ORIG_xSP} & The current instruction needs access to the native stack pointer.\\ \hline
	\end{tabular}
	\caption{Instruction families characteristics}
\end{table}

\section{Operands and operand types}
\label{sec:operands-and-operand-types}
\texttt{opTypes} field encodes the operand type while \texttt{operands} field encodes the actual operand. \texttt{opTypes} field base values are shown in \autoref{table:river-operand-types}.\\
\begin{table}[H]
	\begin{tabular}{| p{6cm} | p{10cm} |}
		\hline
		\textbf{Operand type} & \textbf{Meaning}\\ \hline
		\texttt{RIVER_OPTYPE_NONE} & This type specifies that the current operand is not used.\\ \hline
		\texttt{RIVER_OPTYPE_IMM} & The current operand is an immediate value.\\ \hline
		\texttt{RIVER_OPTYPE_REG} & The current operand is a CPU register.\\ \hline
		\texttt{RIVER_OPTYPE_MEM} & The current operand is an address.\\ \hline
	\end{tabular}
	\caption{River operand types}
	\label{table:river-operand-types}
\end{table}
Furthermore the basic operand types can be combined with size specifiers shown in \autoref{table:river-operand-size}.\\
\begin{table}[H]
	\begin{tabular}{| p{6cm} | p{10cm} |}
		\hline
		\textbf{Operand size} & \textbf{Meaning}\\ \hline
		\texttt{RIVER_OPSIZE_32} & 32-bit operand. (This is the default value)\\ \hline
		\texttt{RIVER_OPSIZE_16} & 16-bit operand.\\ \hline
		\texttt{RIVER_OPSIZE_8} & 8-bit operand.\\ \hline
	\end{tabular}
	\caption{River operand size}
	\label{table:river-operand-size}
\end{table}
Last but not least the operand type can have the \texttt{RIVER_OPFLAG_IMPLICIT} flag set in order to distinguish between explicit operands and operands implicitly added by the disassembler.\\
\newline
The \texttt{RiverOperand} union encapsulates all possible operand configurations and is described in the following chapters.\\

\subsection{Immediate operands}
\label{ssec:immediate-operands}
Depending on the operand size immediate values are stored in \texttt{RiverOperand::asImm8}, \texttt{RiverOperand::asImm16} or \texttt{RiverOperand::asImm32} members.\\
\subsection{Register operands}
\label{ssec:register-operands}
Register operands are stored in \texttt{RiverOperand::asRegister} member. This is a 32-bit field where the least significant eight bits encode the register name, while the remaining bits are used for register versioning (in order to achieve SSA at a basic block level). Register name encoding is divided between general purpose and other registers.\\
\newline
The general purpose registers can be specified by combining the register name with the register size as described in \autoref{table:river-registers}.\\
\begin{table}[H]
	\begin{tabular}{| p{3.6cm} | p{3.2cm} | p{1cm} | p{1cm} | p{1cm} | p{1cm} | p{1cm} | p{1cm} | p{1cm} |}
		\hline
		& \texttt{RIVER_REG_xAX}  & \texttt{*_xCX}  & \texttt{*_xDX}  & \texttt{*_xBX}  & \texttt{*_xSP}  & \texttt{*_xBP}  & \texttt{*_xSI}  & \texttt{*_xDI}\\ \hline
		\texttt{RIVER_REG_SZ32}  & \texttt{EAX}  & \texttt{ECX}  & \texttt{EDX}  & \texttt{EBX}  & \texttt{ESP}  & \texttt{EBP}  & \texttt{ESI}  & \texttt{EDI}\\ \hline
		\texttt{RIVER_REG_SZ16}  & \texttt{AX}  & \texttt{CX}  & \texttt{DX}  & \texttt{BX}  & \texttt{SP}  & \texttt{BP}  & \texttt{SI}  & \texttt{DI}\\ \hline
		\texttt{RIVER_REG_SZ8_L}  & \texttt{AL}  & \texttt{CL}  & \texttt{DL}  & \texttt{BL}  & \texttt{-}  & \texttt{-}  & \texttt{-}  & \texttt{-}\\ \hline
		\texttt{RIVER_REG_SZ8_H}  & \texttt{AH}  & \texttt{CH}  & \texttt{DH}  & \texttt{BH}  & \texttt{-}  & \texttt{-}  & \texttt{-}  & \texttt{-}\\ \hline
	\end{tabular}
	\caption{River Registers}
	\label{table:river-registers}
\end{table}
Other registers have individual register notations. See \autoref{table:extra-registers}.\\
\begin{table}[H]
	\begin{tabular}{| p{5cm} | p{5cm} | p{5cm} |}
		\hline
		\textbf{Segment registers} & \textbf{Control registers} & \textbf{Debug registers} \\ \hline
		\texttt{RIVER_REG_ES} \texttt{RIVER_REG_CS} \texttt{RIVER_REG_SS} \texttt{RIVER_REG_DS} \texttt{RIVER_REG_FS} \texttt{RIVER_REG_GS} &
		\texttt{RIVER_REG_CR0} \texttt{RIVER_REG_CR2} \texttt{RIVER_REG_CR3} \texttt{RIVER_REG_CR4} &
		\texttt{RIVER_REG_DR0} \texttt{RIVER_REG_DR1} \texttt{RIVER_REG_DR2} \texttt{RIVER_REG_DR3} \texttt{RIVER_REG_DR4} \texttt{RIVER_REG_DR5} \texttt{RIVER_REG_DR6} \texttt{RIVER_REG_DR7}\\ \hline
	\end{tabular}
	\caption{Extra registers}
	\label{table:extra-registers}
\end{table}

\subsection{Address operands}
\label{ssec:address-operands}
Address operands are stored as a pointer to a structure containing fields shown in \autoref{table:address-operand-fields}.\\
\begin{table}[H]
	\begin{tabular}{| p{6cm} | p{10cm} |}
		\hline
		\textbf{RiverAddress field name} & \textbf{Meaning}\\ \hline
		\texttt{type} & Encodes valid address fields as described below.\\ \hline
		\texttt{base} & Encodes the base register. Valid only if type has the \texttt{RIVER_ADDR_BASE} flag set.\\ \hline
		\texttt{index} & Encodes the index register. Valid only if type has the \texttt{RIVER_ADDR_INDEX} flag set.\\ \hline
		\texttt{disp.d8} & Encodes a 8-bit displacement. Valid only if type has the \texttt{RIVER_ADDR_DISP8} flag set.\\ \hline
		\texttt{disp.d32} & Encodes a 32-bit displacement. Valid only if type has the \texttt{RIVER_ADDR_DISP} flag set. (Mutually exclusive with disp.d8)\\ \hline
		\texttt{scaleAndSegment} & Encodes the address scale and segment in a single byte. Use the provided getters and setters for convenient access. The scale is only valid if type has the \texttt{RIVER_ADDR_SCALE} flag set.\\ \hline
	\end{tabular}
	\caption{Address operand structure fields}
	\label{table:address-operand-fields}
\end{table}
As a short reminder the x86 addressing works by evaluating the following expression:\\
\[address = base + scale * index + displacement\]
Where:
\begin{itemize}
	\item any of the aforementioned components are optional
	\item the scale can have values of 1,2,4 and 8
	\item the displacement can be 8 or 32 bits
\end{itemize}

\section{Unused registers}
\label{sec:unused-register}
\texttt{RiverInstruction} contains the \texttt{unusedRegisters} member. The disassembler marks all the general purpose registers unaffected by the current instruction. This comes in handy while reassembling.\\
\newline
For instance, non-native instructions make use of a modified stack pointer register (\texttt{ESP}). When these instructions need access to the original \texttt{ESP} (\texttt{RIVER_FAMILY_ORIG_xSP} is set) some form of register reallocation needs to be performed. The assembler makes use of one of the unused registers to hold the original \texttt{ESP} value.\\

\chapter{Instruction families ABI}
\label{chapter:instruction-families-abi}
\section{Native family ABI}
\label{sec:native-family-abi}
Detailing the x86 instruction set is beyond the scope of this document. Check out \footnote{Intel 64 and IA-32 Architectures Software Developer Manual \url{https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf}} for an in depth explanation.\\
\newline
Furthermore, \footnote{X86 Opcode and Instruction Reference \url{http://ref.x86asm.net/coder32.html}} has a really good overview of the whole instruction set.\\

\section{River family ABI}
\label{sec:river-family-abi}
The river instruction family handles code reversibility by saving values that are about to be destroyed in an execution log. Reversing code execution simply translates to restoring the initial values. River instructions available are presented in \autoref{table:river-instructions}.\\
\begin{table}[H]
	\begin{tabular}{| l | l | l |}
		\hline
		\textbf{Instruction mnemonic} & \textbf{Opcode} & \textbf{Meaning} \\ \hline
		\texttt{riverpushf}  & \texttt{0x9C}  & Save the EFLAGS register.\\ \hline
		\texttt{riverpopf}  & \texttt{0x9D}  & Restore the EFLAGS register.\\ \hline
		\texttt{riverpush reg}  & \texttt{0x50 + r}  & Save a general purpose register.\\ \hline
		\texttt{riverpop reg}  & \texttt{0x58 + r}  & Restore a general purpose register.\\ \hline
		\texttt{riverpush mem}  & \texttt{0xFF /6}  & Save a memory location.\\ \hline
		\texttt{riverpop mem}  & \texttt{0x8F}  & Restore a memory location.\\ \hline
	\end{tabular}
	\caption{River Instructions}
	\label{table:river-instructions}
\end{table}
While reassembling, river instructions are converted into their native counterparts.\\
\newline
River instruction set needs a separate \texttt{ESP} register. Transitioning to and from a river instruction is achieved using a single \texttt{xchg} instruction. \autoref{table:river-family-abi-example} presents two examples. The second example also shows how the register renaming works.\\
\begin{table}[H]
	\centering
	\begin{tabular}{| l | l |}
		\hline
		\textbf{Original code} & \textbf{Reassembled code}\\ \hline
		\multirow{3}{*}{\texttt{riverpush [eax+4*ecx]}} & \texttt{xchg esp, [espSave]}\\
		& \texttt{push [eax+4*ecx]}\\
		& \texttt{xchg esp, [espSave]}\\ \hline
		\multirow{5}{*}{\texttt{riverpush esp}} & \texttt{xchg esp, [espSave]}\\
		& \texttt{xchg eax, esp}\\
		& \texttt{push eax}\\
		& \texttt{xchg eax, esp}\\
		& \texttt{xchg esp, [espSave]}\\ \hline
	\end{tabular}
	\caption{River family ABI - examples}
	\label{table:river-family-abi-example}
\end{table}


\section{Meta family ABI (both pre- and postmeta)}
\label{sec:meta-family-abi}
Meta instructions are generated by the disassembler in order to add further detail to the native instruction family. There are two instructions available in the meta instruction family.\\
\begin{table}[H]
	\begin{tabular}{| l | l | l |}
		\hline
		\textbf{Instruction mnemonic} & \textbf{Opcode}  & \textbf{Meaning}\\ \hline
		\texttt{metaadd reg, imm8}	  & \texttt{0x83 /0} & Add an immediate value to a register. No flags are altered.\\ \hline
		\texttt{metasub reg, imm8} 	  & \texttt{0x83 /5} & Subtract an immediate value to a register. No flags are altered.\\ \hline
		\texttt{metamov reg, mem}	  & \texttt{0x8B}	 & Move memory to register (32 bit).\\ \hline
		\texttt{metamov mem, reg}	  & \texttt{0x89}    & Move register to memory (32 bit).\\ \hline
		\texttt{metamov mem, imm32}	  & \texttt{0xC7}    & Move immediate value to memory.\\ \hline
		\texttt{metamov mem1, mem2}	  & \texttt{0xA5}    & Copy 4 bytes from mem2 to mem1.\\ \hline
	\end{tabular}
	\caption{Meta Instructions}
\end{table}

\section{Pretrack family ABI}
\label{sec:pretrack-family-abi}
Pretrack instructions handle the saving of immediate values in order to correctly track symbolic expressions. Similar to the river instructions, pretrack instructions require a separate shadow stack.\\
\begin{table}[H]
	\begin{tabular}{| l | l | l |}
		\hline
		\textbf{Instruction mnemonic} & \textbf{Opcode}   & \textbf{Meaning}\\ \hline
		\texttt{pretrackpushf}        & \texttt{0x9C}     & Save a copy of the flags register.\\ \hline
		\texttt{pretrackpush reg}     & \texttt{0x50 + r} & Save the value of the register.\\ \hline
		\texttt{pretracklea mem}      & \texttt{0x8D}     & Save the address specified as the first operand.\\ \hline
		\texttt{pretrackpush mem}     & \texttt{0xFF /6}  & Save the content at the specified address.\\ \hline
	\end{tabular}
	\caption{Pretrack instructions}
\end{table}
While reassembling pretrack instructions are converted into their native counterparts. Transitioning to the pretrack family requires an extra \texttt{xchg} instruction.\\
\newline
Specifically, \texttt{pretracklea} instruction requires an additional register. The assembler picks an unused register dynamically. \autoref{table:pretrack-family-abi-example} presents an example of said behavior.\\
\begin{table}[H]
	\centering
	\begin{tabular}{| l | l |}
		\hline
		\textbf{Original code} & \textbf{Reassembled code}\\ \hline
		\multirow{6}{*}{\texttt{pretracklea [eax+4*ecx]}} & \texttt{xchg esp, [espSave]}\\
		& \texttt{mov [tmp], edx}\\
		& \texttt{lea edx, [eax+4*ecx]}\\
		& \texttt{push edx}\\
		& \texttt{mov edx, [tmp]}\\
		& \texttt{xchg esp, [espSave]}\\ \hline
	\end{tabular}
	\caption{Pretrack family ABI - example}
	\label{table:pretrack-family-abi-example}
\end{table}

\section{Track family ABI}
\label{sec:track-family-abi}
Track instructions generate a separate code block responsibile for tracking marked variables. \autoref{table:track-instructions} shows valid instructions in the track family.\\
\begin{table}[H]
	\begin{tabular}{| l | l | p{10cm} |}
		\hline
		\textbf{Instruction mnemonic} &	\textbf{Opcode} & \textbf{Meaning}\\ \hline
		\texttt{trackinit}		  & \texttt{0xB8}     & Initialize the tracking register. Corresponds to \texttt{mov edi, 0}.\\ \hline
		\texttt{trackclean imm8}  & \texttt{0xC3}     & Marks the end of tracking for the current instruction. Corresponds to \texttt{retn}.\\ \hline
		\texttt{trackflags imm8}  & \texttt{0x8D}     & Select which flags are used as input. Corresponds to \texttt{pushf}.\\ \hline
		\texttt{markflags imm8}   & \texttt{0x9D}     & Selects which flags are used as output. Corresponds to \texttt{popf}.\\ \hline
		\texttt{trackreg reg}     & \texttt{0x50 + r} & Selects which registers are used as input. Corresponds to \texttt{push reg}.\\ \hline
		\texttt{markreg reg}      & \texttt{0x58 + r} & Selects which registers are used as output. Corresponds to \texttt{pop reg}.\\ \hline
		\texttt{trackaddress mem} & \texttt{0x8D}     & Selects addresses that are used as input. Corresponds to \texttt{lea mem}.\\ \hline
		\texttt{trackmem mem}     & \texttt{0xFF /6}  & Selects memory location as tracking input. Corresponds to \texttt{push mem}.\\ \hline
		\texttt{markmem mem}      & \texttt{0x8F}     & Selects memory location as tracking output. Corresponds to \texttt{pop mem}.\\ \hline
	\end{tabular}
	\caption{Track instructions}
	\label{table:track-instructions}
\end{table}

\section{Rep family ABI}
\label{sec:rep-family-abi}
Rep instructions wrap the original instruction prefixed by rep/repz/repnz. \autoref{table:rep-instructions} shows how rep instrumentation works.\\
\begin{table}[H]
	\begin{tabular}{| l | l | l |}
		\hline
		\textbf{Instruction mnemonic}     & \textbf{Opcode}                & \textbf{Native equivalent}\\ \hline
		\multirow{7}{*}{\texttt{repinit}} & \multirow{4}{*}{\texttt{0xF2}} & \tab \texttt{jmp wrapin}\\
										  &								   & \texttt{init:}\\
										  &								   & \tab \texttt{jmp codein}\\
										  &								   & \texttt{loop:}\\
										  &								   & \tab \texttt{loop init}\\
										  &								   & \tab \texttt{jmp codeout}\\
										  &								   & \texttt{codein:}\\ \hline
		\multirow{9}{*}{\texttt{repfini}} & \multirow{5}{*}{\texttt{0xF3}} & \tab \texttt{jmp loop}\\
										  &								   & \texttt{codeout:}\\
										  &								   & \tab \texttt{jmp wrapout}\\
										  &								   & \texttt{farloop:}\\
										  &								   & \tab \texttt{jmp init}\\
										  &								   & \texttt{wrapin:}\\
										  &								   & \tab \texttt{lea ecx, [ecx + 1]}\\
										  &								   & \tab \texttt{loop farloop}\\
										  &								   & \texttt{wrapout:}\\ \hline
	\end{tabular}
	\caption{Rep prefix instrumentation}
	\label{table:rep-instructions}
\end{table}

\textbf{codein} label marks the actual instructions that are prefixed by \texttt{rep}. The original code contains only one instruction, but it may be translated into more instructions, depending on the tracking type. The instrumentation performs a \texttt{farloop} instruction that also ensures that null ecx register value doesn't result in an internal crash.\\
A \texttt{farloop} is a loop that jumps to the actual code that is executed because \texttt{loop} instruction operand size is signed 8-bit, while \texttt{jmp} operand can be as large as signed 32-bit.\\
The extra \texttt{loop} verifies if ecx value is zero. Consult x86 documetation\footnote{Rep/Repz/Repnz\url{https://c9x.me/x86/html/file_module_x86_id_279.html}} \footnote{Loop/Loopz/Loopnz\url{https://c9x.me/x86/html/file_module_x86_id_161.html}} for further details.

\chapter{Binary translation process}
\label{chapter:binary-translation-process}
\textit{Note: This chapter is subject to some changes in future versions.}\\
The goal of this chapter is to detail the inner workings of the translation process. Throughout the entire chapter basic block in \autoref{table:basic-block-example} is used as an example.\\
\begin{table}[H]
	\centering
	\begin{tabular}{| l |}
		\hline
		\textbf{Original code}\\ \hline
		\texttt{mov edi, edi}\\
		\texttt{push ebp}\\
		\texttt{mov ebp, esp}\\
		\texttt{cmp dword ptr[0x77b40150], 0x01}\\
		\texttt{jnz 0x000571d6}\\ \hline
	\end{tabular}
	\label{table:basic-block-example}
	\caption{Basic Block Example}
\end{table}

\section{Disassembly and decoration}
\label{sec:disassembly-and-decoration}
Besides the conversion to x86 assembly, the river disassembler augments the code with the following properties:
\begin{itemize}
	\item \textbf{Implicit operands} - some instructions implicitly modify registers and memory locations. These are added to the instruction as implicit operands.
	\item \textbf{Register versioning} - in order to simplify data flow analysis, the disassembler versions every register.
	\item \textbf{Meta operations} - since the x86 instruction set is not orthogonal, some instructions may be split into several sub-operations. (See \autoref{sec:meta-family-abi})
	\item \textbf{Absolute jump addresses} - relative jump operations are augmented with an additional operand containing the original instruction address. This makes it easier to compute the jump destination.
\end{itemize}

\autoref{table:disassembler-output} shows the disassembler output for the input block. The implicit operands are marked \textcolor{orange}{orange}, register version are \textcolor{blue}{blue}, meta operations are \textit{italic}, and the inserted jump operand is \textcolor{green}{green}.\\
\begin{table}[H]
	\centering
	\begin{tabular}{| l |}
		\hline
		\textbf{Disassembled code}\\ \hline
		\texttt{mov edi\blue{\$1}, edi\blue{\$0}}\\
		\texttt{\textit{premetamov dword ptr {[}esp\blue{\$0}+0xfc{]}, ebp\blue{\$0}}}\\
		\texttt{\textit{premetasub esp\blue{\$1}, 4}}\\
		\texttt{push ebp\blue{\$0},}
		\texttt{\orange{\{esp}\blue{\$1}\orange{\}},}
		\texttt{\orange{\{dword ptr {[}esp}\blue{\$0 }\orange{+ 0xfc{]}\}}}\\
		\texttt{mov ebp\blue{\$1}, esp\blue{\$1}}\\
		\texttt{cmp dword ptr[0x77b40150], 0x01}\\
		\texttt{jnz 0x000571d6, \textcolor{green}{0x77a79831}}\\ \hline
	\end{tabular}
	\caption{Disassembler output}
	\label{table:disassembler-output}
\end{table}
\section{River translator}
\label{sec:river-translator}
The river translator inserts the river instruction family in the translated code (see \autoref{sec:river-family-abi}). The river translator generates a second basic block for reversing the effects of the first block. The newly inserted instructions are \textbf{bold}. The river translator operates only on native instructions. As a general rule, every operand that is about to be overwritten has a corresponding riverpush instruction.\\
\begin{table}[H]
	\begin{tabular}{| l | l |}
		\hline
		\textbf{Forward block}							& \textbf{Backward block}\\ \hline
		\texttt{\textbf{riverpush edi\$0}}						 & \texttt{riverpopf}\\
		\texttt{mov edi\$1, edi\$0}								 & \texttt{riverpop ebp\$0}\\
		\texttt{premetamov dword ptr [esp\$0+0xfc], ...}		 & \texttt{espriverpop esp\$0}\\
		\texttt{premetasub esp\$1, 4}							 & \texttt{espriverpop dword ptr [esp\$0 + 0xfc]}\\
		\texttt{\textbf{espriverpush dword ptr [esp\$0 + 0xfc]}} & \texttt{riverpop edi\$0}\\
		\texttt{\textbf{espriverpush esp\$0}}					 & \texttt{jmp 0x77a7981f}\\
		\texttt{push ebp\$0, \{esp\$1\}, \{dword ptr [esp ...}   & \\
		\texttt{\textbf{riverpush ebp\$0}}						 & \\
		\texttt{mov ebp\$1, esp\$1}								 & \\
		\texttt{\textbf{riverpushf}}							 & \\
		\texttt{cmp dword ptr[0x77b40150], 0x01}				 & \\
		\texttt{jnz 0x000571d6, 0x77a79831}						 & \\ \hline
	\end{tabular}
	\caption{River Translation}
\end{table}
\section{Tracking translator}
\label{sec:tracking-translator}
Similar to the river translator, the tracking translator inserts some instructions (from the pretrack family) in the original basic block and generates a separate block for tracking purposes.\\
\newline
The tracking translator operates both on native and meta instructions. Below are the rules for generating pretrack instructions.\\
\begin{itemize}
	\item If the analyzed instruction uses any processor flags a \texttt{pretrackpushf} instruction is generated. The purpose of this instruction is to save the necessary flag values.
	\item For any register operand that is used as an input a \texttt{pretrackpush reg} instruction is generated. The purpose of this instruction is to save the register value.
	\item For any memory operand a \texttt{pretracklea mem} instruction is generated.
	\item Furthermore for any memory operand that is used as input a \texttt{pretrackpush mem} instruction is generated.
\end{itemize}

The main role of the pretrack instructions is to store a copy of every operand in a separate buffer. These are later used in the tracking block. The track instructions will be generated on a per instruction basis. Following rules are followed for generation.\\
\begin{itemize}
	\item Each analyzed instruction generates a tracking instruction group preceded by a \texttt{trackinit}/\texttt{trackmov edi, 0} instruction and succeeded by a \texttt{trackclean}/\texttt{trackretn imm8} instruction.
	\item Each tracking block is split in two parts, the first part consists of track* instructions in order to determine whether the original instruction has tracked operands. The latter part consists of mark* instructions in order to mark the output operands.
\end{itemize}

\begin{table}[H]
	\begin{tabular}{| p{9.7cm} | l |}
		\hline
		\textbf{Forward block}									& \textbf{Tracking block}\\ \hline
		\texttt{riverpush edi\$0}							    & \texttt{trackmov edi, 0}\\
		\texttt{\textbf{pretrackpush edi\$0}}				    & \texttt{trackpush edi}\\
		\texttt{mov edi\$1, edi\$0}							    & \texttt{trackpop edi}\\
		\texttt{\textbf{esppretracklea [esp\$0+0xfc]}}		    & \texttt{trackretn 0x01}\\
		\texttt{\textbf{pretrackpush ebp\$0}}				    &\\
		\texttt{premetamov dword ptr [esp\$0+0xfc], }...	    & \texttt{trackmov edi, 0}\\
		\texttt{\textbf{esppretrackpush esp\$1}}			    & \texttt{esptracklea [esp+0xfc]}\\
		\texttt{premetasub esp\$1, 4}						    & \texttt{trackpush ebp}\\
		\texttt{espriverpush dword ptr [esp\$0+0xfc]}		    & \texttt{esptrackpop [esp+0xfc], 0x00}\\
		\texttt{espriverpush esp\$0}							& \texttt{trackretn 0x02}\\
		\texttt{push ebp\$0, \{esp\$1\}, \{dword ptr [esp} ...  &\\
		\texttt{riverpush ebp\$0}							    & \texttt{trackmov edi, 0}\\
		\texttt{\textbf{esppretrackpush esp\$1}}				& \texttt{esptrackpush esp}\\
		\texttt{mov ebp\$1, esp\$1}							    & \texttt{esptrackpop esp}\\
		\texttt{riverpushf}									    & \texttt{trackretn 0x01}\\
		\texttt{\textbf{pretrackpushf}}						    &\\
		\texttt{\textbf{pretracklea [0x77b40150]}}			    & \texttt{trackmov edi, 0}\\
		\texttt{\textbf{pretrackpush [0x77b40150], 0x02}}	    & \texttt{esptrackpush esp}\\
		\texttt{cmp dword ptr[0x77b40150], 0x01}				& \texttt{trackpop ebp}\\
		\texttt{\textbf{pretrackpushf}}						    & \texttt{trackretn 0x01}\\
		\texttt{jnz 0x000571d6, 0x77a79831}					    &\\
															    & \texttt{trackmov edi, 0}\\
															    & \texttt{trackpushf 0x00}\\
															    & \texttt{tracklea [0x77b40150]}\\
															    & \texttt{trackpush [0x77b40150], 0x01}\\
															    & \texttt{trackpopf 0x3f}\\
															    & \texttt{trackretn 0x03}\\
															    &\\
															    & \texttt{trackmov edi, 0}\\
															    & \texttt{trackpushf 0x08}\\
															    & \texttt{trackretn 0x01}\\ \hline
	\end{tabular}
	\caption{Tracking translation}
\end{table}

\section{Reassembly}
\label{sec:reassembly}
The last translation stage handles reassembly back to x86 binary. The assembler handles the transitions between instruction families, and all particularities that come with each instruction family.\\

\subsection{Transition handling}
\autoref{img:river-transition-handling} details transitions between families. The track family is not present because it cannot be combined with other families.\\
\begin{figure}[h]
	\includegraphics[width=\textwidth]{river-transition-handling}
	\label{img:river-transition-handling}
	\caption{River transition handling}
\end{figure}

\subsection{Assembling native instructions}
\label{ssec:assembling-native-instructions}
Most native instructions are assembled back to their original representations. The sole exceptions are branch instructions (jumps, conditional jumps, calls, returns, syscalls). Details will follow in future versions of this document.\\

\subsection{Assembling river instructions}
All river instructions are assembled directly to their binary counterpart.\\

\subsection{Assembling pretrack instructions}
Some pretrack instructions do not have a direct binary correspondent. See \autoref{table:assembling-pretrack-instructions}.\\
\begin{table}[h]
	\centering
	\begin{tabular}{| l | l |}
		\hline
		\textbf{Instruction mnemonic}			  & \textbf{Native equivalent}\\ \hline
		\texttt{pretrackpushf}					  &	\texttt{pushf}\\ \hline
		\texttt{pretrackpush reg}			      & \texttt{push reg}\\ \hline
		\multirow{4}{*}{\texttt{pretracklea mem}} & \texttt{mov [tmp], <unused_reg>}\\
												  & \texttt{lea <unused_reg>, mem}\\
												  & \texttt{push <unused_reg>}\\
												  & \texttt{mov <unused_reg>, [tmp]}\\ \hline
		\texttt{pretrackpush mem}				  & \texttt{push mem}\\ \hline
	\end{tabular}
	\caption{Pretrack transition table}
	\label{table:assembling-pretrack-instructions}
\end{table}

\chapter{Execution API}
\label{chapter:execution-api}
\textit{Note: The documentation in \autoref{chapter:execution-api} is subject to a lot of changes.}\\
While evaluating binary code the user regains control of the execution after each basic block. The user must implement the following callback in order to steer the program execution:
\lstinputlisting[language=C]{./code/BranchHandler.h}
\begin{table}[H]
	\begin{tabular}{| p{6cm} | p{10cm} |}
		\hline
		\textbf{Parameter name}		   & \textbf{Meaning}\\ \hline
		\multirow{2}{*}{\texttt{pEnv}} & An object encapsulating the entire execution environment. The user may store generic data under the \texttt{pEnv->userContext} field.\\
									   & For allocating space for the userContext the user needs to call the \texttt{AllocUserContext} function.\\ \hline
		\texttt{address}			   & The address of the next instruction that will be executed (in case the execution goes forward).\\ \hline
	\end{tabular}
	\caption{Branch Handler Parameters}
	\label{table:branch-handler-parameters}
\end{table}
BranchHandler needs to return one of the two values in \autoref{table:branch-handler-return}.\\
\begin{table}[H]
	\begin{tabular}{| p{6cm} | p{10cm} |}
		\hline
		\textbf{Return value}      & \textbf{Meaning}\\ \hline
		\texttt{EVALUATE_FORWARD}  & Execution goes forward. The callback will be called after the next basic block is executed.\\ \hline
		\texttt{EVALUATE_BACKWARD} & All changes made by the last executed basic block are rolled back. The callback gets called after the rollback.\\ \hline
	\end{tabular}
	\label{table:branch-handler-return}
	\caption{Branch Handler Return Values}
\end{table}
If a basic block ends with a syscall the following callback is called:
\lstinputlisting[language=C]{./code/SysHandler.h}
This allows the user to globally save the machine state.\\
\begin{table}[H]
	\begin{tabular}{| p{6cm} | p{10cm} |}
		\hline
		\textbf{Parameter name} & \textbf{Meaning}\\ \hline
		\texttt{pEnv}			& An object encapsulating the entire execution environment. The user may store generic data under the \texttt{pEnv->userContext} field.\\ \hline
	\end{tabular}
	\caption{SysHandler Parameters}
	\label{table:syshandler-parameters}
\end{table}

\appendix

\end{document}

```

`docs/abi/code/BranchHandler.h`:

```h
DWORD __stdcall BranchHandler(struct _exec_env *pEnv, DWORD address);

```

`docs/abi/code/SysHandler.h`:

```h
void __stdcall SysHandler(struct _exec_env *pEnv);

```

`docs/abi/macros.tex`:

```tex
% All macros

%  First find out if we're running pdftex
\usepackage{ifpdf}

\ifpdf
\pdfcompresslevel 5
\fi

% Times is nicer with pdf
\usepackage{times}
% American style
\usepackage[american]{babel}

\usepackage[T1]{fontenc}

% To make typesetting easier
\usepackage{xspace}

% Generate an index
\usepackage{makeidx}
\makeindex

% Some convenient macros:
%  Add text to index and print it also
\newcommand{\textindex}[1]{#1\index{#1}\xspace}
% Add text to index and print it also with \code{}
\newcommand{\codeindex}[1]{\code{#1}\index{#1@\texttt{#1}}\xspace}
% A version without xspace - I had some strange problems with commas
% afterwards.
\newcommand{\codeindexwo}[1]{\texttt{#1}\index{#1@\texttt{#1}}}

% Control placement of floats
%\usepackage{here}
\usepackage{float}

% Version number of document - increment occasionally ;-)
\newcommand{\version}{1.0}

% Print a footer everywhere with current date
% prelim2e needs \thistime
\newcount\hours
\newcount\minutes
\def\SetTime{\hours=\time
        \global\divide\hours by 60
        \minutes=\hours
        \multiply\minutes by 60
        \advance\minutes by-\time
        \global\multiply\minutes by-1 }
\SetTime
\def\thistime{\number\hours:\ifnum\minutes<10 0\fi\number\minutes}
\usepackage[time]{prelim2e}
\renewcommand{\PrelimWords}{RIVER ABI \version}

% Some commands:
\newcommand{\editornote}[1]{\footnote{#1}}

%Typesetting of registers
\newcommand{\reg}[1]{{\texttt{\%#1}}\xspace}
\newcommand{\RAX}{\reg{rax}}
\newcommand{\RBX}{\reg{rbx}}
\newcommand{\RCX}{\reg{rcx}}
\newcommand{\RDX}{\reg{rdx}}
\newcommand{\RSI}{\reg{rsi}}
\newcommand{\RDI}{\reg{rdi}}
\newcommand{\RBP}{\reg{rbp}}
\newcommand{\RSP}{\reg{rsp}}
\newcommand{\RIP}{\reg{rip}}

%Typesetting of opcodes
\newcommand{\op}[1]{\texttt{#1}}

%Typesetting common names
\newcommand{\MMX}{\emph{MMX}\xspace}
\newcommand{\xARCH}{AMD64\xspace}
\newcommand{\threednow}{3DNow!\xspace}

% Typesetting paths and files
\newcommand{\path}[1]{\texttt{#1}\xspace}

% Typesetting program code
\newcommand{\code}[1]{\texttt{#1}\xspace}

% Long Hrule
\newcommand{\Hrule}{\noindent\rule{\linewidth}{0.3mm}}

\usepackage{xcolor}
% Use Hyperref for PDF support - this should be last
\ifpdf
\usepackage[pdftex,colorlinks,linkcolor={blue!50!black}]{hyperref}
\usepackage{changebar}
\else
\usepackage[dvips,colorlinks,linkcolor={blue!50!black}]{hyperref}
\usepackage{changebar}
\fi

% Make `_' an ordinary character.
\catcode`_=12

% The Intel386 psABI document.
\newcommand{\intelabi}{Intel386 ABI\xspace}

\newcommand{\byte}{byte\xspace}
\newcommand{\twobyte}{twobyte\xspace}
\newcommand{\fourbyte}{fourbyte\xspace}
\newcommand{\eightbyte}{eightbyte\xspace}
\newcommand{\eightbytes}{eightbytes\xspace}
\newcommand{\sixteenbyte}{sixteenbyte\xspace}

\newcommand*{\cbnew}{\marginpar{\textsf{New}}}

\newcommand{\myfontsize}{\fontsize{9}{10}\selectfont}

\usepackage{listings}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt}
\usepackage{multirow, multicol}
\usepackage{graphicx}
\graphicspath{{img/}}
\newcommand{\blue}{\textcolor{blue}}
\newcommand{\orange}{\textcolor{orange}}
\newcommand\tab[1][1cm]{\hspace*{#1}}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "abi"
%%% End:

```

`docs/cheatsheet/Makefile`:

```
BASENAME = cheatsheet

include ../metafiles/base.mk

```

`docs/cheatsheet/cheatsheet.tex`:

```tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% writeLaTeX Example: A quick guide to LaTeX
%
% Source: Dave Richeson (divisbyzero.com), Dickinson College
% 
% A one-size-fits-all LaTeX cheat sheet. Kept to two pages, so it 
% can be printed (double-sided) on one piece of paper
% 
% Feel free to distribute this example, but please keep the referral
% to divisbyzero.com
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% How to use writeLaTeX: 
%
% You edit the source code here on the left, and the preview on the
% right shows you the result within a few seconds.
%
% Bookmark this page and share the URL with your co-authors. They can
% edit at the same time!
%
% You can upload figures, bibliographies, custom classes and
% styles using the files menu.
%
% If you're new to LaTeX, the wikibook is a great place to start:
% http://en.wikibooks.org/wiki/LaTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[10pt,landscape]{article}
\usepackage{amssymb,amsmath,amsthm,amsfonts}
\usepackage{multicol,multirow}
\usepackage{calc}
\usepackage{ifthen}
\usepackage[landscape]{geometry}
\usepackage[colorlinks=true,citecolor=blue,linkcolor=blue]{hyperref}
\usepackage{listings}
\usepackage{balance}


\ifthenelse{\lengthtest { \paperwidth = 11in}}
    { \geometry{top=.5in,left=.5in,right=.5in,bottom=.5in} }
	{\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
		{\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
		{\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
	}
\pagestyle{empty}
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\newcommand{\river}{RIVER}
\newcommand{\rr}{\raggedright}
\newcommand{\tn}{\tabularnewline}
\makeatother
\setcounter{secnumdepth}{0}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}
% -----------------------------------------------------------------------

\title{Quick Guide to LaTeX}

\begin{document}

\raggedright
\footnotesize

\begin{center}
	\Large{\textbf{{\river} Cheat Sheet}} \\
\end{center}
\begin{multicols*}{3}
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

\section{What is \river?}
	{\river} spelled backwards stands for \textbf{REV}ersible \textbf{I}ntermediate \textbf{R}epresentation. {\river} is a fixed length extended x86 instruction set. It is designed to be translated to and from x86. {\river} instrumentation helps tracing binaries (no need for program source code) and provides analysis information about each basic block that was executed by target program. Provided details are: module name, instruction pointer offset, execution cost, jump type, jump instruction and number of instructions.

\section{Constant Definitions}

	\subsection{{\river} Modifiers}

	\begin{tabular}{ p{6cm} p{1.3cm} }
		RIVER\_MODIFIER\_NOSEG & 0x00000000\\
		RIVER\_MODIFIER\_ESSEG & 0x00000001\\
		RIVER\_MODIFIER\_CSSEG & 0x00000002\\
		RIVER\_MODIFIER\_SSSEG & 0x00000003\\
		RIVER\_MODIFIER\_DSSEG & 0x00000004\\
		RIVER\_MODIFIER\_FSSEG & 0x00000005\\
		RIVER\_MODIFIER\_GSSEG & 0x00000006\\
							   \\
		RIVER\_MODIFIER\_EXT &	0x00000008\\
		RIVER\_MODIFIER\_O8 & 0x00000010\\
		RIVER\_MODIFIER\_O16 & 0x00000020\\
		RIVER\_MODIFIER\_A16 & 0x00000040\\
		RIVER\_MODIFIER\_LOCK & 0x00000080\\
		RIVER\_MODIFIER\_REP & 0x00000100\\
		RIVER\_MODIFIER\_REPZ & 0x00000200\\
		RIVER\_MODIFIER\_REPNZ & 0x00000400\\
	\end{tabular}

	\subsection{{\river} Family}
	\begin{tabular}{ p{6cm} p{1.3cm} }
		RIVER\_FAMILY\_NATIVE & 0x00000000\\
		RIVER\_FAMILY\_RIVER & 0x00000001\\
		RIVER\_FAMILY\_TRACK & 0x00000002\\
		RIVER\_FAMILY\_PRETRACK & 0x00000003\\
		RIVER\_FAMILY\_PREMETA & 0x00000004\\
		RIVER\_FAMILY\_POSTMETA & 0x00000005\\
		RIVER\_FAMILY\_RIVER\_TRACK & 0x00000006\\

		RIVER\_FAMILY\_FLAG\_METAPROCESSED & 0x00000020\\
		RIVER\_FAMILY\_FLAG\_ORIG\_xSP & 0x00000040\\
		RIVER\_FAMILY\_FLAG\_IGNORE & 0x00000080\\
	\end{tabular}

	\subsection{{\river} Branch Instruction}
	\begin{tabular}{ p{6cm} p{1.3cm} }
		RIVER\_BRANCH\_INSTR\_RET & 0x00001000\\
		RIVER\_BRANCH\_INSTR\_JMP & 0x00002000\\
		RIVER\_BRANCH\_INSTR\_JXX & 0x00004000\\
		RIVER\_BRANCH\_INSTR\_CALL & 0x00008000\\
		RIVER\_BRANCH\_INSTR\_SYSCALL & 0x00010000\\
	\end{tabular}

	\subsection{{\river} Branch Type}
	\begin{tabular}{p{6cm} p{1.3cm} }
		RIVER\_BRANCH\_TYPE\_IMM & 0x00020000\\
		RIVER\_BRANCH\_TYPE\_REG & 0x00040000\\
		RIVER\_BRANCH\_TYPE\_MEM & 0x00080000\\
	\end{tabular}

	\subsection{{\river} Virtual Registers}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_REG\_xAX & 0x00\\
		RIVER\_REG\_xCX & 0x01\\
		RIVER\_REG\_xDX & 0x02\\
		RIVER\_REG\_xBX & 0x03\\
		RIVER\_REG\_xSP & 0x04\\
		RIVER\_REG\_xBP & 0x05\\
		RIVER\_REG\_xSI & 0x06\\
		RIVER\_REG\_xDI & 0x07\\
	\end{tabular}

	\subsection{{\river} Virtual Registers Size}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_REG\_SZ32 & 0x00\\
		RIVER\_REG\_SZ16 & 0x08\\
		RIVER\_REG\_SZ8\_L & 0x10\\
		RIVER\_REG\_SZ8\_H & 0x18\\
	\end{tabular}

	\subsection{{\river} Segment Registers}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_REG\_ES & 0x20\\
		RIVER\_REG\_SEGMENT & 0x20\\
		RIVER\_REG\_CS & 0x21\\
		RIVER\_REG\_SS & 0x22\\
		RIVER\_REG\_DS & 0x23\\
		RIVER\_REG\_FS & 0x24\\
		RIVER\_REG\_GS & 0x25\\
	\end{tabular}

	\subsection{{\river} Control Registers}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_REG\_CONTROL & 0x30\\
		RIVER\_REG\_CR0 & 0x30\\
		RIVER\_REG\_CR2 & 0x32\\
		RIVER\_REG\_CR3 & 0x33\\
		RIVER\_REG\_CR4 & 0x34\\
	\end{tabular}

	\subsection{{\river} Debug Registers}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_REG\_DEBUG & 0x40\\
		RIVER\_REG\_DR0 & 0x40\\
		RIVER\_REG\_DR1 & 0x41\\
		RIVER\_REG\_DR2 & 0x42\\
		RIVER\_REG\_DR3 & 0x43\\
		RIVER\_REG\_DR4 & 0x44\\
		RIVER\_REG\_DR5 & 0x45\\
		RIVER\_REG\_DR6 & 0x46\\
		RIVER\_REG\_DR7 & 0x47\\
	\end{tabular}

	\subsection{{\river} Other Registers}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_REG\_NONE & 0x20\\
	\end{tabular}

	\subsection{RiverAddress components}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_ADDR\_DISP8 & 0x01\\
		RIVER\_ADDR\_DISP & 0x02\\
		RIVER\_ADDR\_SCALE & 0x04\\
		RIVER\_ADDR\_BASE & 0x08\\
		RIVER\_ADDR\_INDEX & 0x10\\
		RIVER\_ADDR\_DIRTY & 0x80\\
	\end{tabular}

	\subsection{{\river} Operand Types}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_OPTYPE\_NONE & 0x00\\
		RIVER\_OPTYPE\_IMM & 0x04\\
		RIVER\_OPTYPE\_REG & 0x08\\
		RIVER\_OPTYPE\_MEM & 0x0C\\
		RIVER\_OPTYPE\_ALL & 0x10\\
	\end{tabular}

	\subsection{{\river} Operand Size}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_OPSIZE\_32 & 0x00\\
		RIVER\_OPSIZE\_16 & 0x01\\
		RIVER\_OPSIZE\_8 & 0x02\\
	\end{tabular}

	\subsection{{\river} Operation Specifiers}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_SPEC\_MODIFIES\_OP1 & 0x0001\\
		RIVER\_SPEC\_MODIFIES\_OP2 & 0x0002\\
		RIVER\_SPEC\_MODIFIES\_OP3 & 0x0004\\
		RIVER\_SPEC\_MODIFIES\_OP4 & 0x0008\\
		\\
		RIVER\_SPEC\_MODIFIES\_FLG & 0x0010\\
		\\
		RIVER\_SPEC\_MODIFIES\_xSP & 0x0020\\
		\\
		RIVER\_SPEC\_MODIFIES\_CUSTOM & 0x0040\\
		\\
		RIVER\_SPEC\_IGNORES\_MEMORY & 0x0080\\
		\\
		RIVER\_SPEC\_IGNORES\_OP1 & 0x0100\\
		RIVER\_SPEC\_IGNORES\_OP2 & 0x0200\\
		RIVER\_SPEC\_IGNORES\_OP3 & 0x0400\\
		RIVER\_SPEC\_IGNORES\_OP4 & 0x0800\\
		\\
		RIVER\_SPEC\_IGNORES\_FLG & 0x1000\\
	\end{tabular}

	\subsection{{\river} Operation Flags}
	\begin{tabular}{p{6cm} p{1.3cm}}
		RIVER\_SPEC\_IDX\_CF & 0x00\\
		RIVER\_SPEC\_IDX\_PF & 0x01\\
		RIVER\_SPEC\_IDX\_AF & 0x02\\
		RIVER\_SPEC\_IDX\_ZF & 0x03\\
		RIVER\_SPEC\_IDX\_SF & 0x04\\
		RIVER\_SPEC\_IDX\_OF & 0x05\\
		RIVER\_SPEC\_IDX\_DF & 0x06\\
	\end{tabular}

	\newpage
	\section{Structure Definitions}
	\subsection{struct RiverAddress}
	\lstinputlisting[language=C]{code/RiverAddress.h}

	\subsection{struct RiverOperand}
	\lstinputlisting[language=C]{code/RiverOperand.h}

	\columnbreak
	\subsection{struct RiverInstruction}
	\lstinputlisting[language=C]{code/RiverInstruction.h}

\end{multicols*}

\end{document}

```

`docs/cheatsheet/code/RiverAddress.h`:

```h
struct RiverAddress {
	nodep::BYTE type;
	nodep::BYTE scaleAndSegment;
	nodep::BYTE modRM;
	nodep::BYTE sib;
	union RiverRegister base;
	union RiverRegister index;
	union {
		nodep::BYTE d8;
		nodep::DWORD d32;
	} disp;

	inline nodep::BYTE GetScale() const {
		return 1 << (scaleAndSegment & 0x3);
	}

	inline nodep::BYTE GetScaleBits() const {
		return scaleAndSegment & 0x03;
	}

	inline nodep::BYTE HasSegment() const {
		return scaleAndSegment & 0xFC;
	}

	inline nodep::BYTE GetSegment() const {
		return scaleAndSegment >> 2;
	}
	...
};

```

`docs/cheatsheet/code/RiverInstruction.h`:

```h
struct RiverInstruction {
	nodep::WORD modifiers;
	nodep::WORD specifiers;

	nodep::BYTE family;
	nodep::BYTE unusedRegisters;
	nodep::BYTE opCode;
	nodep::BYTE subOpCode;

	nodep::BYTE disassFlags, modFlags, testFlags;

	nodep::BYTE opTypes[4];
	union RiverOperand operands[4];

	nodep::DWORD instructionAddress;
};

```

`docs/cheatsheet/code/RiverOperand.h`:

```h
union RiverOperand {
	nodep::BYTE asImm8;
	nodep::WORD asImm16;
	nodep::DWORD asImm32;
	RiverRegister asRegister;
	RiverAddress *asAddress;
};

```

`docs/metafiles/base.mk`:

```mk
# folders required throughout rules
STY_DIR = ../sty
FORMAT_DIR = ../metafiles/format
OUT_DIR = texfiles
CODE_DIR = code
IMG_DIR = img

PDFLATEX = pdflatex


#
# PDF output files
# * cheatsheet
# * abi
#
# BASENAME is defined in top-level Makefile including this file.
#
TARGET = $(addsuffix .pdf, $(BASENAME))

.PHONY: main all clean
.PHONY: target

# If running `make' with no arguments, only generate slides.
main: target

all: target

# Phony targets depend on PDF output files.
target: $(TARGET)

TARGET_TEX = $(addsuffix .tex, $(BASENAME))

$(TARGET): $(TARGET_TEX)
	# Rebuild source files, if any.
	-test -d $(CODE_DIR) && make -C $(CODE_DIR)
	# Rebuild image files, if any.
	-test -d $(IMG_DIR) && make -C $(IMG_DIR)
	# Create out directory.
	-test -d $(OUT_DIR) || mkdir $(OUT_DIR)
	# Run twice, so TOC is also updated.
	TEXINPUTS=$(STY_DIR)//: $(PDFLATEX) -output-directory $(OUT_DIR) -jobname $(basename $@) $<
	TEXINPUTS=$(STY_DIR)//: $(PDFLATEX) -output-directory $(OUT_DIR) -jobname $(basename $@) $<
	ln -f $(OUT_DIR)/$@ .


clean:
	-test -d $(OUT_DIR) && rm -fr $(OUT_DIR)
	-rm -f $(TARGET)
	-test -d $(CODE_DIR) && make -C $(CODE_DIR) clean

```

`docs/offline.sanitizer/Makefile`:

```
TEX=pdflatex
BIBTEX=bibtex

ALL=main
SOURCES := $(wildcard *.bib *.sty *.cls *.tex media/* media/*/*.pdf)

# Sources are copied to the .build folder to manage LaTeX's flurry of
# intermediate files.
PROCESSED_SOURCES := $(patsubst %,.build/%,${SOURCES})
PROCESSED_SOURCES := $(sort ${PROCESSED_SOURCES})

all: ${ALL}.pdf

${ALL}.pdf: ${PROCESSED_SOURCES}
	rm -f "$@"
	cd .build && \
	  ${TEX} ${ALL} && \
	  ${BIBTEX} ${ALL} && \
	  ${TEX} ${ALL} && \
	  ${TEX} ${ALL}
	cp -a .build/${ALL}.pdf "$@"

.build/%: %
	mkdir -p $$(dirname "$@") && cp -a "$^" "$@"

.PHONY: clean
clean:
	rm -rf .build/ ${ALL}.pdf

```

`docs/offline.sanitizer/biblio.bib`:

```bib
%
%%
%%
%% Usage:
%%
%% \bibliography{../../common/header-short,../../common/biblio}
%% or
%% \bibliography{../../common/header-standard,../../common/biblio}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@article{Wagner2015,
	author = {Wagner, Jonas and Kuznetsov, Volodymyr and Candea, George and Kinder, Johannes},
	doi = {10.1109/SP.2015.58},
	isbn = {978-1-4673-6949-7},
	issn = {1081-6011},
	journal = {Oakland},
	title = {{High System-Code Security with Low Overhead}},
	year = {2015}
}

@misc{afl,
  title={{American Fuzzy Lop}},
  author={Michał Zalewski},
  howpublished = {\url{http://lcamtuf.coredump.cx/afl/}},
}

@misc{libfuzzer,
  title={{LibFuzzer}---A Library for Coverage-Guided Fuzz Testing},
  howpublished = {\url{http://llvm.org/docs/LibFuzzer.html}},
}

```

`docs/offline.sanitizer/header-standard.bib`:

```bib
%
% Please keep this file ordered alphabetically by abbreviation
%

@string{ACSAC="Annual Computer Security Applications Conf."}
@string{AISEC=" {W}orkshop on {A}rtificial {I}ntelligence and {S}ecurity"}
@string{AISEC-2010="3rd" # AISEC}
@string{AMS="Intl. Workshop on Active Middleware Services"}
@string{APAQS="Asia-Pacific Conf. on Quality Software"}
@string{ASE="Intl. Conf. on Automated Software Engineering"}
@string{ASE-J="Automated Software Engineering Journal"}
@string{ASE-2007="22nd " # ASE}
@string{APSYS="Asia-Pacific Workshop on Systems"}
@string{ASPLOS="Intl. Conf. on Architectural Support for Programming Languages and Operating Systems"}
@string{ASPLOS-2008="13th " # ASPLOS}
@string{ASPLOS-2004="11th " # ASPLOS}

@string{CACM="Communications of the {ACM}"}
@string{CASCON="CASCON"}
@string{CASE="ASE"}
@string{CAV="Intl. Conf. on Computer Aided Verification"}
@string{CAV-EC2="CAV Workshop on Exploiting Concurrency Efficiently and Correctly"}
@string{CCC="Intl. Conf. on Compiler Construction"}
@string{CCS="Conf. on Computer and Communication Security"}
@string{CCS-2006="13th " # CCS}
@string{CCS-2008="15th " # CCS}
@string{CGO="Intl. Symp. on Code Generation and Optimization"}
@string{CGO-2004="2nd" # CGO}
@string{COMPSAC="Computer Software \& Applications Conference"}
@string{COMPUTER="IEEE Computer"}
@string{CSF="Computer Security Foundations Symp."}
@string{CSUR="{ACM} Computing Surveys"}

@string{DAC="Design Automation Conference"}
@string{DSN="Intl. Conf. on Dependable Systems and Networks"}

@string{ECOOP="European Conf. on Object-Oriented Programming"}
@string{ECOOP-1993="7th " # ECOOP}
@string{ECOOP-1997="11th " # ECOOP}
@string{EDCC="European Dependable Computing Conference"}
@string{EMSOFT= " Intl. Conf. on Embedded Software"}
@string{EMSOFT-2005 = "5th" # EMSOFT}
@string{EMSOFT-2006 = "6th" # EMSOFT}
@string{EMSOFT-2007 = "7th" # EMSOFT}
@string{ESOP = "European Symp. on Programming"}
@string{EUROSYS="ACM EuroSys European Conf. on Computer Systems"}
@string{EUROSIGOPS="{ACM SIGOPS} European Workshop"}

@string{FAST="USENIX Conf. on File and Storage Technologies"}
@string{FMCAD=" Intl. Conf. on Formal Methods in Computer-Aided Design"}
@string{FMCAD-2010="10th" # FMCAD}
@string{FMSD="Formal Methods in System Design"}
@string{FSE="Symp. on the Foundations of Software Eng."}
@string{FTCS="Intl. Symp. on Fault-Tolerant Computing"}

@string{HOTDEP  = "{W}orkshop on {H}ot {T}opics in {D}ependable {S}ystems"}
@string{HOTDEP-2008  = "4th " # HOTDEP}
@string{HOTDEP-2009  = "5th " # HOTDEP}
@string{HOTDEP-2010  = "6th " # HOTDEP}
@string{HOTPAR = "USENIX Workshop on Hot Topics in Parallelism"}
@string{HOTOS  = "{W}orkshop on {H}ot {T}opics in {O}perating {S}ystems"}
@string{HOTOS-2001 = "8th " # HOTOS}
@string{HOTOS-2003 = "9th " # HOTOS}
@string{HOTOS-2005 = "10th " # HOTOS}
@string{HOTOS-2007 = "11th " # HOTOS}
@string{HPCA = "International Symposium on High-Performance Computer Architecture"}

@string{ICAC="Intl. Conf. on Autonomic Computing"}
@string{ICDCS="Intl. Conf. on Distributed Computing Systems"}

@string{ICFP = "ACM SIGPLAN International Conference on Functional Programming"}
@string{ICISS="Intl. Conf. on Information Systems Security"}
@string{ICRS="Intl. Conf. on Reliable Software"}
@string{ICSE="Intl. Conf. on Software Engineering"}
@string{ICSE-2007="30th" # ICSE}
@string{ICSE-2008="30th" # ICSE}
@string{ICSE-2011="33th" # ICSE}
@string{ICST="Intl. Conf. on Software Testing Verification and Validation"}
@string{ICTSS="Intl. Conf. on {T}esting {S}oftware and {S}ystems"}
@string{IEEE-LCS="IEEE-LCS"}
@string{IISWC="IEEE Intl. Symp. on Workload Characterization"}
@string{IJES="Intl. Journal of Embedded Systems"}
@string{IJPP="Intl. Journal on Parallel Programming"}
@string{IJUFKS="Intl. Journal on Uncertainty, Fuzziness and Knowledge-based Systems"}
@string{IPDPS="Intl. Parallel and Distributed Processing Symp."}
@string{ISCA=" Intl. Symp. on Computer Architecture"}
@string{ISCA-1993="20th" # ISCA}
@string{ISCA-2003="30th" # ISCA}
@string{ISCA-2007="34th" # ISCA}
@string{ISCA-2008="35th" # ISCA}
@string{ISCA-2009="36th" # ISCA}
@string{ISMM="Intl. Symp. on Memory Management"}
@string{ISO= "International Organization for Standardization"}
@string{ISOLA="ISoLA"}
@string{ISPASS="IEEE Intl. Symp. on Performance Analysis of Systems and Software"}
@string{ISSRE="Intl. Symp. on Software Reliability Engineering"}
@string{ISSTA="Intl. Symp. on Software Testing and Analysis"}
@string{ITOCS="{IEEE} Transactions on Computers"}
@string{ITSE="IEEE Transactions on Software Engineering"}

@string{JACE="J. ACE"}

@string{LADIS = "{W}orkshop on {L}arge {S}cale {D}istributed {S}ystems and {M}iddleware"}
@string{LOPLAS="ACM Letters on Programming Languages and Systems"}
@string{LNCS="Lecture Notes In Computer Science"}
@string{LPAR= "Intl. Conf. on Logic for Programming Artificial Intelligence and Reasoning"}

@string{MICRO="IEEE/ACM International Symposium on Microarchitecture"}
@string{MIDDLEWARE=" Intl. Middleware Conf."}

@string{NDSS="Network and Distributed System Security Symp."}
@string{NSDI=" Symp. on Networked Systems Design and Implem."}

@string{OLS="Linux Symposium"}
@string{OOPSLA= " Conf. on Object-Oriented Programming, Systems, Languages, and Applications"}
@string{OOPSLA-1999="14th" # OOPSLA}
@string{OOPSLA-2002="17th" # OOPSLA}
@string{OSDI=" Symp. on Operating Sys. Design and Implem."}
@string{OSDI-1996="2nd" # OSDI}
@string{OSDI-2000="4th" # OSDI}
@string{OSDI-2002="5th" # OSDI}
@string{OSDI-2004="6th" # OSDI}
@string{OSDI-2006="7th" # OSDI}
@string{OSDI-2008="8th" # OSDI}
@string{OSR="ACM SIGOPS Operating Systems Review"}

@string{PASTE="Workshop on Program Analysis for Software Tools and Engineering"}
@string{PDMC="Intl. Workshop on Parallel and Distributed Methods in Verification"}
@string{PEPM="SIGPLAN Symp. on Partial Evaluation and Semantics-Based Program Manipulation"}
@string{PLDI=" Intl. Conf. on Programming Language Design and Implementation"}
@string{PLDI-1998="20th" # PLDI}
@string{PLDI-2005="27th" # PLDI}
@string{PLDI-2008="30th" # PLDI}
@string{PLDI-2009="31th" # PLDI}
@string{PODS=" Symp. on Principles of Database Systems"}
@string{POPL =" Symp. on Principles of Programming Languages"}
@string{PPoPP = "Symp. on Principles and Practice of Parallel Computing"}
@string{PVLDB=" Proc. of the VLDB Endowment"}

@string{QRS="Int. Conf. Software Quality, Reliability and Security"}
@string{QSIC=" Intl. Conf. on Quality Software "}
@string{QSIC-2010="10th" # QSIC}


@string{RV="Intl. Conf. on Runtime Verification"}
@string{RVW="Intl. Workshop on Runtime Verification"}
@string{RACES="{ACM} Workshop on Relaxing Synchronization for Multicore and Manycore Scalability"}

@string{SAT="Intl. Conf. on Theory and Applications of Satisfiability Testing"}
@string{SAW="{S}tatic {A}nalysis {W}orkshop"}
@string{SEN="ACM SIGSOFT Software Engineering Notes"}
@string{SIGCOMM = "ACM {SIGCOMM} {C}onf."}
@string{SIGMETRICS="ACM SIGMETRICS Conf."}
@string{SIGMOD=" ACM SIGMOD Conf."}
@string{SIGPLAN-Notices="SIGPLAN Notices"}
@string{SOCC=" Symp. on Cloud Computing"}
@string{SOSP=" Symp. on Operating Systems Principles"}
@string{SOSP-1971="3rd" # SOSP}
@string{SOSP-1993="14th" # SOSP}
@string{SOSP-1997="16th" # SOSP}
@string{SOSP-2002="18th" # SOSP}
@string{SOSP-2003="19th" # SOSP}
@string{SOSP-2005="20th" # SOSP}
@string{SOSP-2007="21st" # SOSP}
@string{SOUPS=" Symp. on Usable Privacy and Security"}
@string{SPIN="Intl. {SPIN} Workshop"}
@string{SPSM="Workshop on Security and Privacy in Smartphones and Mobile Devices"}
@string{SRDS="Symp. on Reliability in Distributed Software and Database Systems"}
@string{SSP="IEEE Symp. on Security and Privacy"}
@string{SSV="Intl. Workshop on Systems Software Verification"}
@string{SSV-2010="5th" # SSV}
@string{STVR=" Intl. Journal on Software Testing, Verification and Reliability"}

@string{TACAS="Intl. Conf. on Tools and Algorithms for the Construction and Analysis of Systems"}
@string{TAP="Tests and Proofs"}
@string{TPHOLs="Theorem Proving in Higher Order Logics"}
@string{TOCS="{ACM} Transactions on Computer Systems"}
@string{TOPLAS="{ACM} Transactions on Programming Languages and Systems"}
@string{TOMACS="{ACM} Transactions on Modeling and Computer Simulation"}
@string{TSE = "IEEE Transactions on Software Engineering"}

@string{USEC=" Workshop on Usable Security"}
@string{USENIX=" {USENIX} Annual Technical Conf."}
@string{USENIX-2004="29th" # USENIX}
@string{USENIX-2005="30th" # USENIX}
@string{USENIX-2007="32nd" # USENIX}
@string{USENIX-2008="33rd" # USENIX}
@string{USENIXSUMMER=" {USENIX} Summer Technical Conf."}
@string{USENIX-LISA=" {USENIX} Large Installation System Administration Conf."}
@string{USENIX-NT=" {USENIX} Windows NT Symposium"}
@string{USENIX-SEC=" {USENIX} Security Symp."}
@string{USITS=" {USENIX} Symp. on Internet Technologies and Systems"}

@string{VEE=" Intl. Conf. on Virtual Execution Environments"}
@string{VEE-2008="4th" # VEE}
@string{VLDB=" Intl. Conf. on Very Large Databases"}
@string{VLDBJ=" Intl. Journal on Very Large Databases"}
@string{VSTTE="Verified Software: Theories, Tools, Experiments"}

@string{WBIA="Workshop on Binary Instrumentation and Applications"}
@string{WCRE="Working Conf. on Reverse Engineering"}
@string{WIAPP="Workshop on Internat Applications"}
@string{WODET="Workshop on Determinism and Correctness in Parallel Programming"}
@string{WOSAS="1st Workshop on Operating System and Architectural Support for the On Demand IT InfraStructure"}
@string{WOSN="Workshop on Online Social Networks"}
@string{WOOT="Workshop on Offensive Technologies"}

@string{WRIPE="Intl. Workshop on Rigorous Protocol Engineering"}

```

`docs/offline.sanitizer/main.tex`:

```tex
\documentclass[format=acmsmall]{acmart}

\usepackage[utf8]{inputenc}

\usepackage{xspace} % Auto-insert of space after macros

% To eliminate the hyperref space after the paragraph symbol
\def\Snospace~{\S{}}
\renewcommand*{\sectionautorefname}{\Snospace}
\renewcommand*{\subsectionautorefname}{\Snospace}
\renewcommand*{\subsubsectionautorefname}{\Snospace}

% Nicer tables
\usepackage{booktabs}
\usepackage{tabularx}

% Other packages needed for the content
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}

\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage{nicefrac}
\usepackage{multirow}
\usepackage{siunitx}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning}

% Some useful symbols
\newcommand{\cmark}{\ding{51}\xspace}
\newcommand{\xmark}{\ding{55}\xspace}

% Relative fontsize
\usepackage{relsize}
% Abbreviations and acronyms
\newcommand{\allcaps}[1]{\texorpdfstring{\textsmaller[.5]{#1}}{#1}\xspace}
\newcommand{\code}[1]{\texttt{\small{#1}}}
\newcommand{\approximately}{\ensuremath{\stackrel{\sim}{}}}

\newcommand{\FIXME}[1]{\textcolor{Red}{#1}}
%\renewcommand{\FIXME}[1]{#1}

% Slowdown due to coverage instrumentation and coverage+ASan, on average over
% our benchmarks.
% \newcommand{\coverageSlowdown}{1.6\ensuremath{\times}\xspace}
% \newcommand{\coverageAsanSlowdown}{2.8\ensuremath{\times}\xspace}

% Fraction of CPU cycles spent in instrumentation code
% \newcommand{\instrumentationCycles}{54\%\xspace}
% Simply the inverse of \instrumentationCycles. This is not equal to the
% average slowdown, because the average of inverses is not the inverse of
% averages... Confusing.
% \newcommand{\fuzzingSlowdown}{2.2\ensuremath{\times}\xspace}

% Maximal speedup for bug finding
% \newcommand{\fussSpeedup}{3.2\ensuremath{\times}\xspace}
% \newcommand{\removedOverhead}{88\%\xspace}

% Global listings config
\lstset{ %
  basicstyle=\small,
  language=C,
  numberstyle=\scriptsize\color{gray},
  numbers=left,
  xleftmargin=18pt,
}

\hyphenation{analy-sis}

\newcommand{\mytitle}{Rosanne: River Offline Sanitizers}
\newcommand{\tool}{\textbf{Rosanne}}
\newcommand{\river}{\allcaps{RIVER}}

\hypersetup{
  pdfauthor={Teodor Stoenescu, Alexandra Sandulescu},
  pdftitle={\mytitle},
  pdfsubject={Computer Science},
  pdfkeywords={Runtime Tracing, Instrumentation, Dynamic Binary Instrumentation, Program Analysis, Static Analysis},
}

% Metadata Information
% \acmJournal{TOSEM}

\author{Teodor Stoenescu}
\affiliation{%
  \institution{Bitdefender}
  \city{Bucharest}
  \country{Romania}}
\email{tstoenescu@bitdefender.com}
\author{Alexandra Sandulescu}
\affiliation{%
  \institution{Bitdefender}
  \city{Bucharest}
  \country{Romania}}
\email{asandulescu@bitdefender.com}

\title{\mytitle}
\keywords{Runtime Tracing, Instrumentation, Dynamic Binary Instrumentation, Program Analysis, Static Analysis}


\begin{document}

\begin{abstract}

\end{abstract}

\maketitle
\renewcommand{\shortauthors}{T. Stoenescu, A. Sandulescu}

\section{Motivation}
\subsection{Symbolic operations}\label{subsec:symbolic-operations}

\section{Why runtime instrumentation works .. slow}

\section{\river Offline Traces}\label{offline-traces}
\river obtains runtime traces from executing target programs. It instruments each target program basic block \
depending on the required type of trace. The available tracing options are: \textit{raw traces}, \textit{tainted index traces}, \
\textit{Z3 traces}. \\

\textbf{Raw traces} show an ordered list of basic blocks executed at runtime during target program tracing. Data corresponding \
to each basic block shows the library/module container of current basic block, the offset inside the module where the basic block \
resides, the cost for executing it. Traces show jump type information (immediate value, memory or register) and jump instruction information \
(return, jump, conditional jump, call or syscall). The stack pointer value is logged for each basic block. Also, the number of instructions \
per basic block and data defining the next options in execution. Next options could be no location, one location or two different locations. \
If the jump type depends on a value in memory or register, then the successor(s) cannot be known. Otherwise, if the current jump is not \
dependent on any condition, one single successor is available. If the jump depends on any boolean condition, there are two potential \
successors of current basic block. \\
An example of how raw traces look is found in \autoref{raw-trace}. \\

\begin{table}
	\caption{Raw traces example - text format}
	\label{raw-trace}
	\scalebox{0.65}{
		\begin{tabular}{| l| l| l| l| l| l| l| l| l| l| l |}
			\hline
			\textbf{Module name} & \textbf{Offset} & \textbf{Cost} & \textbf{Jmp type} & \textbf{Jmp instr} & \textbf{Esp} & \textbf{Nr instr} & \textbf{Taken} & \textbf{Offset} & \textbf{Not taken} & \textbf{Offset} \\
			libsimple-address.so & 0x000005DF        &       5       &          0         &         3					&  0xF5BBF25C    &           5             &  libsimple-address.so	 & 0x000005DB       &              ???			   & 0x00000000 \\
			libsimple-address.so & 0x000005DB		   & 2			   & 0					&						0   &  0xF5BBF260    &		   2			 &            ???			 & 0x00000000		   &			  ???		   & 0x00000000 \\
			libsimple-address.so & 0x000005EB		   & 6			   & 0					& 3							&  0xF5BBF24C    & 6						 & libsimple-address.so  & 0x00000450		   & ???					   & 0x00000000 \\
			libsimple-address.so & 0x00000450		   & 1			   & 1					& 1							&  0xF5BBF24C	   & 1						 & ???					 & 0x00000000		   & ???					   & 0x00000000 \\
			libsimple-address.so & 0x00000456		   & 2			   & 0					& 1							&  0xF5BBF248	   & 2						 & libsimple-address.so  & 0x00000430		   & ???					   & 0x00000000 \\
			libsimple-address.so & 0x00000430		   & 2			   & 1					& 1							&  0xF5BBF244     & 2						 & ???					 & 0x00000000		   & ???					   & 0x00000000 \\
			ld-2.26.so		     & 0x000154C0		   & 6			   & 0					& 3							&  0xF5BBF234	   & 6						 & ld-2.26.so			 & 0x0000F130		   & ???					   & 0x00000000 \\
			ld-2.26.so		     & 0x0000F130		   & 6			   & 0					& 3							&  0xF5BBF220	   & 6						 & ld-2.26.so			 & 0x0001B57D		   & ???					   & 0x00000000 \\
			ld-2.26.so		     & 0x0001B57D		   & 2			   & 0					& 0							&  0xF5BBF224	   & 2						 & ???					 & 0x00000000		   & ???					   & 0x00000000 \\
			ld-2.26.so		     & 0x0000F13B		   & 22			   & 0					& 2							&  0xF5BBF1F8	   & 22						 & ld-2.26.so			 & 0x0000F2BF		   & ld-2.26.so				   & 0x0000F181 \\
			ld-2.26.so		     & 0x0000F181		   & 3			   & 0					& 2							&  0xF5BBF1F8	   & 3						 & ld-2.26.so			 & 0x0000F260		   & ld-2.26.so				   & 0x0000F18D \\ \hline
		\end{tabular}
		}
		\scalebox{0.7}{
		\begin{tabular}{@{}>{$}l<{$}l@{}}
			Module name & module / library name of code container \\
			Offset & offset in module where code resides \\
			Cost & basic block cost of execution computed using a custom heuristic \\
			Jmp type & final basic block instruction jump type (immediate / memory /register) \\
			Jmp instuction & final basic block instruction type (call / return / syscall / jmp /jcc) \\
			Esp & stack pointer value after basic block execution \\
			Nr instr & number of instructions of current basic block \\
			Taken and offset & module and offset of branch that satisfies the jump condition \\
			Not taken and offset & module and offset of branch that does not satisfy the jump condition \\
		\end{tabular}
		}
\end{table}

\textbf{Tainted index traces} are represented by raw traces enhanced with tainted index information. Tainted index is a mechanism that implements \
data flow analysis. Input data is marked with a positive number starting with \textit{1}. During target program execution, taint is transferred \
when a certain type of operation occurs. {\tool} distinguishes between four types of operations that propagate taint: \textit{extraction}, \
\textit{concatenation}, \textit{constant generation} and \textit{generic execution}. \\

\textbf{Extract propagation} formula is shown in \autoref{extract-formula}. It defines the operation of cutting a part from tainted data. \
Data flow propagation constructs the new cut as tainted, thus a new index is created for this type of operation. \\

\begin{figure}
	\caption{Tainted index extract}
	\label{extract-formula}
	\[ I[k] <= I[index][offset:size] \]
	\scalebox{0.7}{
		\begin{tabular}{@{}>{$}l<{$}l@{}}
			I[k] & tainted index\\
			I[index] & source tainted index \\
			offset & cut offset inside I[index] \\
			size & cut size in bits \\
		\end{tabular}
	  }
\end{figure}

\textbf{Concat propagation} formula is shown in \autoref{concat-formula}. It refers to concatenating tainted data to untracked data. The \
result is considered tainted and thus a new index is generated. \\

\begin{figure}
	\caption{Tainted index concat}
	\label{concat-formula}
	\[ I[k] <= I[p] ++ I[q] \]
	\scalebox{0.7}{
		\begin{tabular}{@{}>{$}l<{$}l@{}}
			I[k] & tainted index\\
			I[p] & left concatenation operator \\
			I[1] & right concatenation operator \\
		\end{tabular}
	  }
\end{figure}

\textbf{Constant generation} representation in \autoref{const-gen-formula} shows how a new tainted index is generated for tracking a \
bare constant that is needed in the data flow analysis. \\

\begin{figure}
	\caption{Tainted index constant}
	\label{const-gen-formula}
	\[ I[k] <= const <const value> \]
	\scalebox{0.7}{
		\begin{tabular}{@{}>{$}l<{$}l@{}}
			I[k] & tainted index\\
			const value & constant value that becomes tracked\\
		\end{tabular}
	  }
\end{figure}


\begin{figure}
	\caption{Tainted index generic execution}
	\label{generic-execution}
	\[ I[k] <= <flagname>:I[q] | I[p] \]
	\scalebox{0.7}{
		\begin{tabular}{@{}>{$}l<{$}l@{}}
			I[k] & tainted index\\
			<flagname>:I[q] & operator flag and its associated tainted index\\
			I[p] & operator tainted index\\
		\end{tabular}
	  }
\end{figure}

\textbf{Generic execution} in the context of tainted index is represented in \autoref{generic-execution}. There are instructions that propagate taint along \
program execution. The taint is associated with instruction source operands or flags (or both) and broadcast taint to destination operands or flags (or both). \
\autoref{generic-execution} shows that a new tainted index \textit{I[k]} is generated by current instruction to transmit taint from source operands \
associated with tainted index \textit{I[p]} and tainted flag \textit{<flagname>} associated with tainted index \textit{I[q]}. \\

\textbf{Z3 traces} represent raw traces augmented with Z3 information. Symbolic execution is performed during target execution, thus allowing \
the collection of z3 representation of symbolic data. Two types of operations that involve symbolic data are of interest for the offline \
sanitizers. First operation refers to \textit{symbolic addresses} that are used for input or output of data (read or write to symbolic address). The second \
operation is associated to \textit{symbolic jump condition} where a certain jump operation (of any kind) depends on a symbolic condition. \
The motivation behind these two scenarios is elaborated in \autoref{subsec:symbolic-operations}. \\

\begin{figure}
	\caption{Symbolic address representation in Z3 traces}
	\label{symbolic-address}
	[composed address] <= [base address] + scale x [index address] + displacement
	\scalebox{0.7}{
		\begin{tabular}{@{}>{$}l<{$}l@{}}
			<composed address> & address of symbolic object corresponding to targeted symbolic address\\
		  <base address> & address of symbolic object corresponding to targeted address base\\
			scale & constant representing the scaling factor from address construction\\
			<index address> & address of symbolic object corresponding to targeted address index\\
			displacement & constant representing the displacement from address construction\\
		\end{tabular}
	  }
\end{figure}

\begin{figure}
	\caption{X86 Addressing}
	\label{x86addressing}
	effective address = base + scale factor x index + displacement
	\scalebox{0.7}{
		\begin{tabular}{@{}>{$}l<{$}l@{}}
		  effective address & virtual address \\ 
		  base & the start address usually stored in a general-purpose register \\
		  scale factor & value of 2, 4 or 8 that is multiplied by the index operand \\
		  index & the offset usually stored in a general-purpose register \\
		  displacement & 8-, 16- or 32-bit value \\
		\end{tabular}
	  }
\end{figure}

\textbf{Symbolic address} representation is shown in \autoref{symbolic-address}. Construction of addresses in x86 architecture is explained in \autoref{x86addressing}. \
If the target program runs an instruction that adresses memory using a symbolic address, it means that the pointer value can be controlled using input data \
manipulation. Along with the aforementioned information about the address composition, Z3 traces also store the Z3 AST (abstract syntax tree) representing \
the symbolic object that defines the \textit{composed address}. \\

\begin{figure}
	\caption{Jump condition representation in Z3 traces}
	\label{jump-condition}
	jcc <address> <= <flagname>[<symbolic address>]
	\scalebox{0.7}{
		\begin{tabular}{@{}>{$}l<{$}l@{}}
		  <address> & jump destination \\
		  <flagname> & ZF CF DF OF PF SF AF eflags\\
		  <symbolic address> & address of symbolic object associated with <flagname>\\
		\end{tabular}
	  }
\end{figure}

\textbf{Symbolic jump condition} is exposed in \autoref{jump-condition}. If the condition has a symbolic object associated, then the jump direction can be \
controlled by user input, thus leading to a major vulnerability that allows an attacker to control program flow. Z3 AST object associated with the symbolic flag \
is also stored inside Z3 traces. \\

The authors mark an important note about symbolic flags. \textit{Symbolic flags} represent the result of comparing concrete data with symbolic data. This mechanism \
is introduced for simplifying Z3 representation and usability of resources. All Z3 objects are represented by pure Z3 structures, eradicating the need for custom \
\river specifications. All registers and memory locations are involved in Z3 tracing if the need arises. \\

\section{Offline sanitization}


{\tool} introduces the concept of offline sanitization, a novel approach of reporting crashes outside program execution. We introduce this approach for being \
used in two different scenarios where instrumentation runtime costs exceeds the target code execution with a scaling factor larger than 5.0X \cite{Wagner2015}. \
The following discussion regards \textit{offline sanitization} use cases where lower sanitization execution costs increase the overall benefits of the bearer system. \
First and most important use case is fuzzing - in any of its flavors: white-box, grey-box and black-box - followed by secure code execution in production assisted by \
component behavior sanitizers - address sanitizer, memory sanitizer, undefined behavior sanitizer, thread sanitizer. \\

Fuzzing is a technique for testing binary files or source code by feeding random input to target program. In practice, fuzzing procedure performance is augmented \
by input mutation heuristics, target execution feedback and crash / error reporting tools. In most implementations \cite{afl} \cite{libfuzzer}, the latter is \
represented by instrumentation code that consists in a condition which decides whether the program crashes or not and reports the fault along with execution context \
(memory, registers, backtrace, statistics, etc.).

\begin{figure}
  \caption{Asan instrumentation atom}
  \label{asan-atom}
\begin{lstlisting}
  shadow_address = MemToShadow(address);
  if (ShadowIsPoisoned(shadow_address)) {
    ReportError(address, kAccessSize, kIsWrite);
  }
\end{lstlisting}
\scalebox{0.7}{
		\begin{tabular}{@{}>{$}l<{$}l@{}}
		  shadow_address & address in shadow memory where poisoning metadata resides \\
		  MemToShadow() & function that translates between virtual memory address and shadow memory address \\
		  address & virtual memory address that is verified \\
		  ShadowIsPoisoned() & check if address is addressable\\
		  ReportError() & report execution context and exit\\
		\end{tabular}
	  }
\end{figure}

Runtime instrumentation for crash reporting is implemented in a separate project, Address Sanitizer, outside any fuzzing implementation. The discussion follows \
Address Sanitizer implementation since other versions %% TODO how other fuzzers implement address sanitization \
have similar implementations. \autoref{asan-atom} shows the layout of asan atoms. Asan instrumentation instructions that compute shadow address and verify whether \
the associated memory location is addressable or not, is executed each time the target instruction pointer reaches instrumented basic blocks. The exposed situation \
allows the idea of removing asan instrumentation execution overhead. {\tool} runs code instrumented with a custom implementation of coverage sanitizer and obtains \
execution traces. The layout of these traces is discussed in \autoref{offline-traces}. \\ 

\subsection{Address Sanitization}

\begin{figure}
\caption{User controlled pointer vulnerability}
\label{vuln-symbolic-address}
\begin{lstlisting}
  char buf[128];
  int size, offset = 0;
  while(1) {
    scanf("%d", &size);
    if (!size) break;
    read(STDIN_FILENO, buf + offset, size);
    offset += size;
  }
\end{lstlisting}
\end{figure}

{\tool} uses {\river} offline traces to detect potential security vulnerabilities in program execution. The vulnerabilty class addressed by {\tool} refers to \
reading/writing from/to memory location pointed by user controlled address. This includes writing to execution stack, situation which often leads to control of \
return address. We introduce the concept of \textit{symbolic address}, a pointer that is indirectly controlled by user input. Consider the example in \
\autoref{vuln-symbolic-address}. \\

Considering that \textit{size} is controlled by user, we call it symbolic or tainted. The operation \textit{buf + offset} results in a symbolic address because \
one of the source operators, \textit{offset}, is symbolic. The taint propagation went from initial input data, \textit{size}, to \textit{offset} by the \
addition operation. The final taint target is \textit{buf + offset} by addressing a memory location controlled by used data. In this particular care, the user \
can perform illegal writes to memory locations outside the designated stack buffer. \\

More complex situations that allow return address overwrite, thus allowing execution flow control by user. {\tool} analyzes all addresses that are computed \
using source operands depending on user input. These addresses are called symbolic addresses. Each raw trace entry which logs basic block metadata shows the stack \
pointer value corresponding to the execution of last instruction. Further discussion relates to how {\tool} uses stack pointer values to detect whether user input \
can be manipulated in such way that it rewrites the return address corresponding to current stack frame. \\

\begin{figure}
  \caption{Stack layout}
  \label{stack-frame}
  \begin{tabular}{| l |}
  \hline
  return address \\ \hline
  old ebp \\ \hline
  local variables \\
  ... \\ \hline
  return address \\ \hline
  old ebp \\ \hline
  local variables \\
  ... \\ \hline
  \end{tabular}
\end{figure}

Each entry from raw trace represents data about static and runtime context of last traslated and executed basic block. Following the basic blocks that \
end in \textit{call} and \textit{return} instructions, each stack frame can be restored. \autoref{stack-frame} shows the layout of a stack. \\

Using a stack data stucture, {\tool} records the stack pointer value corresponding to each basic block ended in a call instruction. After executing the call, \
the stack pointer represents the stack address of last element pushed on the stack, in this particular case being the old value of instruction pointer or \
address of the instruction following the call. \\

\begin{figure}
  \caption{Offline Address Sanitizer}
  \label{offline-asan}
  \[ ( assert \quad (not \quad (eq \quad [symbolic\-address] \quad [stack\-pointer]))) \]
  \begin{tabular}{@{}>{$}l<{$}l@{}}
    symbolic\-address & symbolic expression corresponding to virtual address\\
    stack\-pointer & stack address where return address is stored\\
  \end{tabular}
\end{figure}

{\tool} can assert that the symbolic address value cannot evaluate to illegal values. One illegal value that should not be written using user input is the \
address of return address obtained using the mechanism discussed above. The assertion performend by {\tool} custom offline address sanitizer is represented in \
\autoref{offline-asan}. \\

The argument extends to an example of how {\tool} works on the particular case where addresses are not allowed to point to return address location on \
execution stack. \\

%%TODO enhanced taint analysis %%
%===========================================================================

% Acknowledgements hidden in the anonymized version
%
%\section{Acknowledgements}\label{acknowledgements}
%
%Thanks to LibFuzzer developers and the people on llvm-dev.
%\newpage

\bibliographystyle{IEEEtran}
\citestyle{acmnumeric}
\bibliography{header-standard,biblio}

\end{document}

% vim: set number wrap linebreak textwidth=0 sw=2:

```

`evaluators.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25123.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "revtracer", "revtracer\revtracer.vcxproj", "{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "loader", "loader\loader.vcxproj", "{A04D7B87-303A-422A-8E6B-63DC92B11663}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "loader.test", "loader.test\loader.test.vcxproj", "{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}"
	ProjectSection(ProjectDependencies) = postProject
		{A04D7B87-303A-422A-8E6B-63DC92B11663} = {A04D7B87-303A-422A-8E6B-63DC92B11663}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ipclib", "ipclib\ipclib.vcxproj", "{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tracers", "tracers", "{930B15E3-8D4C-4018-96FA-4970465FC571}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "wrapper", "wrapper", "{073AF0B8-E01F-4C39-9EF0-41E55EACDEA9}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "interface", "interface", "{CBA07A98-2DF0-454F-BE31-64BEE468F2A1}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Execution", "Execution\Execution.vcxproj", "{668C607E-2E3B-435D-9390-56BDB152C363}"
	ProjectSection(ProjectDependencies) = postProject
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6} = {F4898816-F6BE-4EE3-87F2-CE011A8302E6}
		{D7D32923-BF55-4907-9A83-DA7676298CD8} = {D7D32923-BF55-4907-9A83-DA7676298CD8}
		{39020D47-08BE-4F17-911D-E346D2E9418F} = {39020D47-08BE-4F17-911D-E346D2E9418F}
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706} = {3E5A9A80-186E-4D0A-9279-E2D7EFB66706}
		{A04D7B87-303A-422A-8E6B-63DC92B11663} = {A04D7B87-303A-422A-8E6B-63DC92B11663}
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3} = {F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}
		{117888DC-1743-427D-9A65-D32029F42038} = {117888DC-1743-427D-9A65-D32029F42038}
		{3F22D7DF-8353-409A-8A65-3E1987E439C8} = {3F22D7DF-8353-409A-8A65-3E1987E439C8}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tracer.test", "tracer.test\tracer.test.vcxproj", "{BC87AB86-7BAC-459C-8D27-3646241C1D9C}"
	ProjectSection(ProjectDependencies) = postProject
		{668C607E-2E3B-435D-9390-56BDB152C363} = {668C607E-2E3B-435D-9390-56BDB152C363}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "_subobjects", "_subobjects", "{C5303C5C-335C-41A1-8B57-C5AC2142989B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LargeStack", "LargeStack\LargeStack.vcxproj", "{C2337D23-250D-4204-83B3-8381B64B729A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "execution.external.test", "execution.external.test\execution.external.test.vcxproj", "{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}"
	ProjectSection(ProjectDependencies) = postProject
		{668C607E-2E3B-435D-9390-56BDB152C363} = {668C607E-2E3B-435D-9390-56BDB152C363}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "execution.inprocess.test", "execution.inprocess.test\execution.inprocess.test.vcxproj", "{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}"
	ProjectSection(ProjectDependencies) = postProject
		{668C607E-2E3B-435D-9390-56BDB152C363} = {668C607E-2E3B-435D-9390-56BDB152C363}
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6} = {ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "revtracer-wrapper", "revtracer-wrapper\revtracer-wrapper.vcxproj", "{3F22D7DF-8353-409A-8A65-3E1987E439C8}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SymbolicEnvironment", "SymbolicEnvironment\SymbolicEnvironment.vcxproj", "{56939285-B2AF-42A9-ADEB-E21411F84C55}"
	ProjectSection(ProjectDependencies) = postProject
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3} = {F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ParserPayload", "ParserPayload\ParserPayload.vcxproj", "{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BinLoader", "BinLoader\BinLoader.vcxproj", "{D7D32923-BF55-4907-9A83-DA7676298CD8}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wrapper.setup", "wrapper.setup\wrapper.setup.vcxproj", "{F4898816-F6BE-4EE3-87F2-CE011A8302E6}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "ipclib", "ipclib", "{1E408A64-AFEE-47AD-833D-9D26F9179A84}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "extern-execution", "extern-execution", "{0566C2C2-A272-4EBC-B939-18EF0266F540}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "loader", "loader", "{55280D52-43A3-4199-8A35-9B3C185DAFAC}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "loader.setup", "loader.setup\loader.setup.vcxproj", "{117888DC-1743-427D-9A65-D32029F42038}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualMemory", "VirtualMemory\VirtualMemory.vcxproj", "{39020D47-08BE-4F17-911D-E346D2E9418F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|Mixed Platforms = Debug|Mixed Platforms
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|Mixed Platforms = Release|Mixed Platforms
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Debug|Win32.ActiveCfg = Debug|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Debug|Win32.Build.0 = Debug|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Debug|x64.ActiveCfg = Debug|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Release|Any CPU.ActiveCfg = Release|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Release|Mixed Platforms.Build.0 = Release|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Release|Win32.ActiveCfg = Release|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Release|Win32.Build.0 = Release|Win32
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}.Release|x64.ActiveCfg = Release|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Debug|Win32.ActiveCfg = Debug|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Debug|Win32.Build.0 = Debug|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Debug|x64.ActiveCfg = Debug|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Release|Any CPU.ActiveCfg = Release|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Release|Mixed Platforms.Build.0 = Release|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Release|Win32.ActiveCfg = Release|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Release|Win32.Build.0 = Release|Win32
		{A04D7B87-303A-422A-8E6B-63DC92B11663}.Release|x64.ActiveCfg = Release|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Debug|Win32.ActiveCfg = Debug|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Debug|Win32.Build.0 = Debug|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Debug|x64.ActiveCfg = Debug|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Release|Any CPU.ActiveCfg = Release|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Release|Mixed Platforms.Build.0 = Release|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Release|Win32.ActiveCfg = Release|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Release|Win32.Build.0 = Release|Win32
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}.Release|x64.ActiveCfg = Release|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Debug|Win32.ActiveCfg = Debug|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Debug|Win32.Build.0 = Debug|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Debug|x64.ActiveCfg = Debug|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Release|Any CPU.ActiveCfg = Release|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Release|Mixed Platforms.Build.0 = Release|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Release|Win32.ActiveCfg = Release|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Release|Win32.Build.0 = Release|Win32
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}.Release|x64.ActiveCfg = Release|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Debug|Win32.ActiveCfg = Debug|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Debug|Win32.Build.0 = Debug|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Debug|x64.ActiveCfg = Debug|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Release|Any CPU.ActiveCfg = Release|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Release|Mixed Platforms.Build.0 = Release|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Release|Win32.ActiveCfg = Release|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Release|Win32.Build.0 = Release|Win32
		{668C607E-2E3B-435D-9390-56BDB152C363}.Release|x64.ActiveCfg = Release|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Debug|Win32.ActiveCfg = Debug|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Debug|Win32.Build.0 = Debug|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Debug|x64.ActiveCfg = Debug|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Release|Any CPU.ActiveCfg = Release|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Release|Mixed Platforms.Build.0 = Release|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Release|Win32.ActiveCfg = Release|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Release|Win32.Build.0 = Release|Win32
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C}.Release|x64.ActiveCfg = Release|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Debug|Win32.ActiveCfg = Debug|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Debug|Win32.Build.0 = Debug|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Debug|x64.ActiveCfg = Debug|x64
		{C2337D23-250D-4204-83B3-8381B64B729A}.Debug|x64.Build.0 = Debug|x64
		{C2337D23-250D-4204-83B3-8381B64B729A}.Release|Any CPU.ActiveCfg = Release|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Release|Mixed Platforms.Build.0 = Release|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Release|Win32.ActiveCfg = Release|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Release|Win32.Build.0 = Release|Win32
		{C2337D23-250D-4204-83B3-8381B64B729A}.Release|x64.ActiveCfg = Release|x64
		{C2337D23-250D-4204-83B3-8381B64B729A}.Release|x64.Build.0 = Release|x64
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Debug|Win32.ActiveCfg = Debug|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Debug|Win32.Build.0 = Debug|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Debug|x64.ActiveCfg = Debug|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Release|Any CPU.ActiveCfg = Release|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Release|Mixed Platforms.Build.0 = Release|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Release|Win32.ActiveCfg = Release|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Release|Win32.Build.0 = Release|Win32
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}.Release|x64.ActiveCfg = Release|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Debug|Win32.ActiveCfg = Debug|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Debug|Win32.Build.0 = Debug|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Debug|x64.ActiveCfg = Debug|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Release|Any CPU.ActiveCfg = Release|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Release|Mixed Platforms.Build.0 = Release|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Release|Win32.ActiveCfg = Release|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Release|Win32.Build.0 = Release|Win32
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}.Release|x64.ActiveCfg = Release|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Debug|Win32.ActiveCfg = Debug|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Debug|Win32.Build.0 = Debug|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Debug|x64.ActiveCfg = Debug|x64
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Debug|x64.Build.0 = Debug|x64
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Release|Any CPU.ActiveCfg = Release|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Release|Mixed Platforms.Build.0 = Release|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Release|Win32.ActiveCfg = Release|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Release|Win32.Build.0 = Release|Win32
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Release|x64.ActiveCfg = Release|x64
		{3F22D7DF-8353-409A-8A65-3E1987E439C8}.Release|x64.Build.0 = Release|x64
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Debug|Win32.ActiveCfg = Debug|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Debug|Win32.Build.0 = Debug|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Debug|x64.ActiveCfg = Debug|x64
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Debug|x64.Build.0 = Debug|x64
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Release|Any CPU.ActiveCfg = Release|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Release|Mixed Platforms.Build.0 = Release|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Release|Win32.ActiveCfg = Release|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Release|Win32.Build.0 = Release|Win32
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Release|x64.ActiveCfg = Release|x64
		{56939285-B2AF-42A9-ADEB-E21411F84C55}.Release|x64.Build.0 = Release|x64
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Debug|Win32.ActiveCfg = Debug|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Debug|Win32.Build.0 = Debug|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Debug|x64.ActiveCfg = Debug|x64
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Debug|x64.Build.0 = Debug|x64
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Release|Any CPU.ActiveCfg = Release|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Release|Mixed Platforms.Build.0 = Release|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Release|Win32.ActiveCfg = Release|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Release|Win32.Build.0 = Release|Win32
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Release|x64.ActiveCfg = Release|x64
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6}.Release|x64.Build.0 = Release|x64
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Debug|Win32.ActiveCfg = Debug|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Debug|Win32.Build.0 = Debug|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Debug|x64.ActiveCfg = Debug|x64
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Debug|x64.Build.0 = Debug|x64
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Release|Any CPU.ActiveCfg = Release|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Release|Mixed Platforms.Build.0 = Release|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Release|Win32.ActiveCfg = Release|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Release|Win32.Build.0 = Release|Win32
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Release|x64.ActiveCfg = Release|x64
		{D7D32923-BF55-4907-9A83-DA7676298CD8}.Release|x64.Build.0 = Release|x64
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Debug|Win32.ActiveCfg = Debug|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Debug|Win32.Build.0 = Debug|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Debug|x64.ActiveCfg = Debug|x64
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Debug|x64.Build.0 = Debug|x64
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Release|Any CPU.ActiveCfg = Release|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Release|Mixed Platforms.Build.0 = Release|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Release|Win32.ActiveCfg = Release|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Release|Win32.Build.0 = Release|Win32
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Release|x64.ActiveCfg = Release|x64
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6}.Release|x64.Build.0 = Release|x64
		{117888DC-1743-427D-9A65-D32029F42038}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Debug|Win32.ActiveCfg = Debug|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Debug|Win32.Build.0 = Debug|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Debug|x64.ActiveCfg = Debug|x64
		{117888DC-1743-427D-9A65-D32029F42038}.Debug|x64.Build.0 = Debug|x64
		{117888DC-1743-427D-9A65-D32029F42038}.Release|Any CPU.ActiveCfg = Release|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Release|Mixed Platforms.Build.0 = Release|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Release|Win32.ActiveCfg = Release|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Release|Win32.Build.0 = Release|Win32
		{117888DC-1743-427D-9A65-D32029F42038}.Release|x64.ActiveCfg = Release|x64
		{117888DC-1743-427D-9A65-D32029F42038}.Release|x64.Build.0 = Release|x64
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Debug|Win32.ActiveCfg = Debug|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Debug|Win32.Build.0 = Debug|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Debug|x64.ActiveCfg = Debug|x64
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Debug|x64.Build.0 = Debug|x64
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Release|Any CPU.ActiveCfg = Release|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Release|Mixed Platforms.Build.0 = Release|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Release|Win32.ActiveCfg = Release|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Release|Win32.Build.0 = Release|Win32
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Release|x64.ActiveCfg = Release|x64
		{39020D47-08BE-4F17-911D-E346D2E9418F}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3} = {930B15E3-8D4C-4018-96FA-4970465FC571}
		{A04D7B87-303A-422A-8E6B-63DC92B11663} = {55280D52-43A3-4199-8A35-9B3C185DAFAC}
		{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3} = {55280D52-43A3-4199-8A35-9B3C185DAFAC}
		{3E5A9A80-186E-4D0A-9279-E2D7EFB66706} = {1E408A64-AFEE-47AD-833D-9D26F9179A84}
		{073AF0B8-E01F-4C39-9EF0-41E55EACDEA9} = {0566C2C2-A272-4EBC-B939-18EF0266F540}
		{668C607E-2E3B-435D-9390-56BDB152C363} = {CBA07A98-2DF0-454F-BE31-64BEE468F2A1}
		{BC87AB86-7BAC-459C-8D27-3646241C1D9C} = {CBA07A98-2DF0-454F-BE31-64BEE468F2A1}
		{C2337D23-250D-4204-83B3-8381B64B729A} = {C5303C5C-335C-41A1-8B57-C5AC2142989B}
		{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2} = {CBA07A98-2DF0-454F-BE31-64BEE468F2A1}
		{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C} = {CBA07A98-2DF0-454F-BE31-64BEE468F2A1}
		{3F22D7DF-8353-409A-8A65-3E1987E439C8} = {073AF0B8-E01F-4C39-9EF0-41E55EACDEA9}
		{ADD1CFC1-2FAE-4591-902B-EDA0B98B64D6} = {C5303C5C-335C-41A1-8B57-C5AC2142989B}
		{D7D32923-BF55-4907-9A83-DA7676298CD8} = {C5303C5C-335C-41A1-8B57-C5AC2142989B}
		{F4898816-F6BE-4EE3-87F2-CE011A8302E6} = {073AF0B8-E01F-4C39-9EF0-41E55EACDEA9}
		{1E408A64-AFEE-47AD-833D-9D26F9179A84} = {0566C2C2-A272-4EBC-B939-18EF0266F540}
		{55280D52-43A3-4199-8A35-9B3C185DAFAC} = {0566C2C2-A272-4EBC-B939-18EF0266F540}
		{117888DC-1743-427D-9A65-D32029F42038} = {55280D52-43A3-4199-8A35-9B3C185DAFAC}
		{39020D47-08BE-4F17-911D-E346D2E9418F} = {C5303C5C-335C-41A1-8B57-C5AC2142989B}
	EndGlobalSection
EndGlobal

```

`execution.external.test/Main.cpp`:

```cpp
#include "../Execution/Execution.h"

#include <Windows.h>

ExecutionController *ctrl = NULL;
HANDLE hEvent;

class CustomObserver : public ExecutionObserver {
public :
	FILE *fBlocks;

	virtual void TerminationNotification(void *ctx) {
		printf("Process Terminated\n");
		SetEvent(hEvent);
	}

	virtual unsigned int ExecutionBegin(void *ctx, void *address) {
		printf("Process starting\n");
		return EXECUTION_ADVANCE;
	}

	virtual unsigned int ExecutionControl(void *ctx, void *address) {
		//static bool b = true;
		rev::ExecutionRegs rgs;

		/*if (0xE39A == (address & 0xFFFF)) {
		__asm int 3;
		}*/

		/*if (b) {*/
		ctrl->GetCurrentRegisters(ctx, &rgs);

		const char module[] = "";
		fprintf(fBlocks, "%-15s+%08X EAX:%08x ECX:%08x EDX:%08x EBX:%08x ESP:%08x EBP:%08x ESI:%08x EDI:%08x\n",
			module,
			(DWORD)address,
			rgs.eax,
			rgs.ecx,
			rgs.edx,
			rgs.ebx,
			rgs.esp,
			rgs.ebp,
			rgs.esi,
			rgs.edi
		);
		/*}*/

		return EXECUTION_ADVANCE;
	}

	virtual unsigned int ExecutionEnd(void *ctx) {
		return EXECUTION_TERMINATE;
	}

	virtual unsigned int TranslationError(void *ctx, void *address) {
		printf("Translation error @%08p\n", address);
		return EXECUTION_TERMINATE;
	}

} observer;

int main() {

	fopen_s(&observer.fBlocks, "e.t.txt", "wt");

	ctrl = NewExecutionController(EXECUTION_EXTERNAL);
	ctrl->SetPath(L"D:\\wrk\\evaluators\\lzo\\a.exe");
	
	ctrl->SetExecutionFeatures(0 /*EXECUTION_FEATURE_REVERSIBLE | EXECUTION_FEATURE_TRACKING*/);

	ctrl->SetExecutionObserver(&observer);
	//ctrl->SetExecutionControlNotification(ExecControl);
	//ctrl->SetTerminationNotification(Term);

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	ctrl->Execute();

	WaitForSingleObject(hEvent, INFINITE);

	DeleteExecutionController(ctrl);
	ctrl = NULL;

	fclose(observer.fBlocks);
	system("pause");

	return 0;
}
```

`execution.external.test/execution.external.test.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{DDD88C03-CD71-44D9-A245-8FBDFE4E38D2}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>executiontest</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>execution.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`execution.inprocess.test/Main.cpp`:

```cpp
#include "../Execution/Execution.h"
#include "../CommonCrossPlatform/Common.h"

#ifdef _WIN32
#include <Windows.h>
#elif defined(__linux__)
#include "../libproc/os-linux.h"
#endif


ExecutionController *ctrl = NULL;
EVENT_T hEvent;

class CustomObserver : public ExecutionObserver {
public :
	FILE *fBlocks;
	ModuleInfo *mInfo;
	int mCount;

	virtual void TerminationNotification(void *ctx) {
		printf("Process Terminated\n");
		SIGNAL_EVENT(hEvent);
	}

	virtual unsigned int ExecutionBegin(void *ctx, void *address) {
		printf("Process starting\n");
		ctrl->GetModules(mInfo, mCount);
		return EXECUTION_ADVANCE;
	}

	virtual unsigned int ExecutionControl(void *ctx, void *address) {
		rev::BasicBlockInfo bbInfo;
		ctrl->GetLastBasicBlockInfo(ctx, &bbInfo);

		const char unkmod[MAX_PATH] = "???";
		unsigned int offset = (DWORD)bbInfo.address;
		int foundModule = -1;

		for (int i = 0; i < mCount; ++i) {
			if ((mInfo[i].ModuleBase <= (DWORD)bbInfo.address) && ((DWORD)bbInfo.address < mInfo[i].ModuleBase + mInfo[i].Size)) {
				offset -= mInfo[i].ModuleBase;
				foundModule = i;
				break;
			}
		}


		const char module[] = "";
		fprintf(fBlocks, "%-15s + %08lX (%4ld)\n",
			(-1 == foundModule) ? unkmod : mInfo[foundModule].Name,
			(DWORD)offset,
			bbInfo.cost
		);
		return EXECUTION_ADVANCE;
	}

	virtual unsigned int ExecutionEnd(void *ctx) {
		fflush(fBlocks);
		return EXECUTION_TERMINATE;
	}

	virtual unsigned int TranslationError(void *ctx, void *address) {
		printf("Translation error @%08p\n", address);
		return EXECUTION_TERMINATE;
	}

} observer;

#define MAX_BUFF 4096
#ifdef _WIN32
#define IMPORT __declspec(dllimport)
#else
#define IMPORT extern
#endif

extern "C" {
	IMPORT char payloadBuffer[];
	IMPORT int Payload();
};
#ifdef __linux__
extern "C"  void patch__rtld_global_ro();
#endif

int main(int argc, char **argv) {
#ifdef __linux__
	patch__rtld_global_ro();
#endif
	char *buff = payloadBuffer;
	unsigned int bSize = MAX_BUFF;
	do {
		fgets(buff, bSize, stdin);
		while (*buff) {
			buff++;
			bSize--;
		}
	} while (!feof(stdin));
	//Payload();

#ifdef _WIN32
	/* dirty hack: patch _isa_available on the loaded dll */
	HMODULE hPayload = GetModuleHandle(L"ParserPayload.dll");
	*(DWORD *)((BYTE *)hPayload + 0x00117288) = 0x00000001;
	*(DWORD *)((BYTE *)hPayload + 0x001796E0) = 0x00000000;
#endif


	FOPEN(observer.fBlocks, "e.t.txt", "wt");

	ctrl = NewExecutionController(EXECUTION_INPROCESS);
	ctrl->SetEntryPoint((void*)Payload);
	
	ctrl->SetExecutionFeatures(0);

	ctrl->SetExecutionObserver(&observer);

	CREATE_EVENT(hEvent);

	ctrl->Execute();

	WAIT_FOR_SINGLE_OBJECT(hEvent);

	DeleteExecutionController(ctrl);
	ctrl = NULL;

	fclose(observer.fBlocks);
	system("pause");

	return 0;
}

```

`execution.inprocess.test/Makefile`:

```
mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
makefile_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

inprocess_test := inprocess_test
CC := gcc
CXX := g++
CPP_FILES := Main.cpp
OBJ_FILES := Main.o
LD_PATHS:= -L$(makefile_dir)/../DisableSSE -L$(makefile_dir)/../Execution \
	-L$(makefile_dir)/../ParserPayload -L$(makefile_dir)

LD_FLAGS:= -lexecution -lpthread -ldl -lhttp-parser -ldisablesse
CC_FLAGS_CROSS = -D__cdecl="" -D__stdcall=""
NO_SSE := -mno-mmx -mno-sse -march=i386
CXX_FLAGS += -m32 $(NO_SSE) -std=c++11 $(CC_FLAGS_CROSS)
CC_FLAGS += -m32 $(NO_SSE) $(CC_FLAGS_CROSS)
prefix := /usr/local

all: $(inprocess_test)

install: $(inprocess_test)
	install -m 0755 $(inprocess_test) -t $(prefix)/bin -D

$(inprocess_test): $(OBJ_FILES)
	$(CXX) $(LD_PATHS) $(CXX_FLAGS) -o $@ $(OBJ_FILES) $(LD_FLAGS)

Main.o: Main.cpp
	$(CXX) $(CXX_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(inprocess_test) $(OBJ_FILES_SO) $(OBJ_FILES)

```

`execution.inprocess.test/Payload.cpp`:

```cpp
#include "http_parser.h"

#include <malloc.h>
#include <assert.h>
//#include <string.h>
//#include <stdio.h>
#include <stdlib.h>

static http_parser parser_buff, *parser = &parser_buff;

static int currently_parsing_eof;

#define MAX_HEADERS 13
#define MAX_ELEMENT_SIZE 2048
#define MAX_CHUNKS 16

#define TRUE 1
#define FALSE 0

struct message {
	const char *name; // for debugging purposes
	const char *raw;
	enum http_parser_type type;
	enum http_method method;
	int status_code;
	char response_status[MAX_ELEMENT_SIZE];
	char request_path[MAX_ELEMENT_SIZE];
	char request_url[MAX_ELEMENT_SIZE];
	char fragment[MAX_ELEMENT_SIZE];
	char query_string[MAX_ELEMENT_SIZE];
	char body[MAX_ELEMENT_SIZE];
	size_t body_size;
	const char *host;
	const char *userinfo;
	uint16_t port;
	int num_headers;
	enum { NONE = 0, FIELD, VALUE } last_header_element;
	char headers[MAX_HEADERS][2][MAX_ELEMENT_SIZE];
	int should_keep_alive;

	int num_chunks;
	int num_chunks_complete;
	int chunk_lengths[MAX_CHUNKS];

	const char *upgrade; // upgraded body

	unsigned short http_major;
	unsigned short http_minor;

	int message_begin_cb_called;
	int headers_complete_cb_called;
	int message_complete_cb_called;
	int message_complete_on_eof;
	int body_is_final;
};

static struct message messages[5];
static int num_messages;
static http_parser_settings *current_pause_parser;

void my_memset(void *buffer, unsigned int value, unsigned int size) {
	for (unsigned int i = 0; i < size; ++i) {
		((char *)buffer)[i] = value;
	}
}

void my_memcpy(void *dest, const void *src, unsigned int size) {
	for (unsigned int i = 0; i < size; ++i) {
		((char *)dest)[i] = ((char *)src)[i];
	}
}

int my_strlen(const char *str) {
	const char *c = str;
	while (*c) c++;

	return c - str;
}

int my_strnlen(const char *str, int n) {
	for (int i = 0; i < n; ++i) {
		if ('\0' == str[i]) {
			return i;
		}
	}
	return n;
}

void parser_init(enum http_parser_type type) {
	num_messages = 0;

	http_parser_init(parser, type);

	my_memset(&messages, 0, sizeof(messages));
}

void parser_free() {
	assert(parser);
	free(parser);
	parser = NULL;
}

size_t strlncat(char *dst, size_t len, const char *src, size_t n) {
	size_t slen;
	size_t dlen;
	size_t rlen;
	size_t ncpy;

	slen = my_strnlen(src, n);
	dlen = my_strnlen(dst, len);

	if (dlen < len) {
		rlen = len - dlen;
		ncpy = slen < rlen ? slen : (rlen - 1);
		my_memcpy(dst + dlen, src, ncpy);
		dst[dlen + ncpy] = '\0';
	}

	assert(len > slen + dlen);
	return slen + dlen;
}

size_t strlcat(char *dst, const char *src, size_t len) {
	return strlncat(dst, len, src, (size_t)-1);
}

size_t strlncpy(char *dst, size_t len, const char *src, size_t n) {
	size_t slen;
	size_t ncpy;

	slen = my_strnlen(src, n);

	if (len > 0) {
		ncpy = slen < len ? slen : (len - 1);
		my_memcpy(dst, src, ncpy);
		dst[ncpy] = '\0';
	}

	assert(len > slen);
	return slen;
}

size_t strlcpy(char *dst, const char *src, size_t len) {
	return strlncpy(dst, len, src, (size_t)-1);
}


int message_begin_cb(http_parser *p) {
	assert(p == parser);
	messages[num_messages].message_begin_cb_called = TRUE;
	return 0;
}

int request_url_cb(http_parser *p, const char *buf, size_t len) {
	assert(p == parser);
	strlncat(messages[num_messages].request_url,
		sizeof(messages[num_messages].request_url),
		buf,
		len);
	return 0;
}

int response_status_cb(http_parser *p, const char *buf, size_t len)
{
	assert(p == parser);
	strlncat(messages[num_messages].response_status,
		sizeof(messages[num_messages].response_status),
		buf,
		len);
	return 0;
}

int
header_field_cb(http_parser *p, const char *buf, size_t len)
{
	assert(p == parser);
	struct message *m = &messages[num_messages];

	if (m->last_header_element != m->FIELD)
		m->num_headers++;

	strlncat(m->headers[m->num_headers - 1][0],
		sizeof(m->headers[m->num_headers - 1][0]),
		buf,
		len);

	m->last_header_element = m->FIELD;

	return 0;
}

int header_value_cb(http_parser *p, const char *buf, size_t len) {
	assert(p == parser);
	struct message *m = &messages[num_messages];

	strlncat(m->headers[m->num_headers - 1][1],
		sizeof(m->headers[m->num_headers - 1][1]),
		buf,
		len);

	m->last_header_element = m->VALUE;

	return 0;
}

void check_body_is_final(const http_parser *p) {
	if (messages[num_messages].body_is_final) {
		/*fprintf(stderr, "\n\n *** Error http_body_is_final() should return 1 "
			"on last on_body callback call "
			"but it doesn't! ***\n\n");*/
		assert(0);
		abort();
	}
	messages[num_messages].body_is_final = http_body_is_final(p);
}


int headers_complete_cb(http_parser *p) {
	assert(p == parser);
	messages[num_messages].method = (http_method)parser->method;
	messages[num_messages].status_code = parser->status_code;
	messages[num_messages].http_major = parser->http_major;
	messages[num_messages].http_minor = parser->http_minor;
	messages[num_messages].headers_complete_cb_called = TRUE;
	messages[num_messages].should_keep_alive = http_should_keep_alive(parser);
	return 0;
}

int body_cb(http_parser *p, const char *buf, size_t len) {
	assert(p == parser);
	strlncat(messages[num_messages].body,
		sizeof(messages[num_messages].body),
		buf,
		len);
	messages[num_messages].body_size += len;
	check_body_is_final(p);
	// printf("body_cb: '%s'\n", requests[num_messages].body);
	return 0;
}

int message_complete_cb(http_parser *p) {
	assert(p == parser);
	if (messages[num_messages].should_keep_alive != http_should_keep_alive(parser))
	{
		/*fprintf(stderr, "\n\n *** Error http_should_keep_alive() should have same "
			"value in both on_message_complete and on_headers_complete "
			"but it doesn't! ***\n\n");*/
		assert(0);
		abort();
	}

	if (messages[num_messages].body_size &&
		http_body_is_final(p) &&
		!messages[num_messages].body_is_final)
	{
		/*fprintf(stderr, "\n\n *** Error http_body_is_final() should return 1 "
			"on last on_body callback call "
			"but it doesn't! ***\n\n");*/
		assert(0);
		abort();
	}

	messages[num_messages].message_complete_cb_called = TRUE;

	messages[num_messages].message_complete_on_eof = currently_parsing_eof;

	num_messages++;
	return 0;
}

int chunk_header_cb(http_parser *p) {
	assert(p == parser);
	int chunk_idx = messages[num_messages].num_chunks;
	messages[num_messages].num_chunks++;
	if (chunk_idx < MAX_CHUNKS) {
		messages[num_messages].chunk_lengths[chunk_idx] = p->content_length;
	}

	return 0;
}

int chunk_complete_cb(http_parser *p) {
	assert(p == parser);

	/* Here we want to verify that each chunk_header_cb is matched by a
	* chunk_complete_cb, so not only should the total number of calls to
	* both callbacks be the same, but they also should be interleaved
	* properly */
	assert(messages[num_messages].num_chunks ==
		messages[num_messages].num_chunks_complete + 1);

	messages[num_messages].num_chunks_complete++;
	return 0;
}

static http_parser_settings settings = { 
	message_begin_cb,
	request_url_cb,
	response_status_cb,
	header_field_cb,
	header_value_cb,
	headers_complete_cb,
	body_cb,
	message_complete_cb,
	chunk_header_cb,
	chunk_complete_cb
};

size_t parse(const char *buf, size_t len) {
	size_t nparsed;
	currently_parsing_eof = (len == 0);
	nparsed = http_parser_execute(parser, &settings, buf, len);
	return nparsed;
}

void test_simple(const char *buf) {
	parser_init(HTTP_REQUEST);

	enum http_errno err;

	parse(buf, my_strlen(buf));
	err = HTTP_PARSER_ERRNO(parser);
	parse(NULL, 0);

	parser_free();
}

char payload_buffer[4096];
int Payload() {
	test_simple(payload_buffer);
	return 0;
}
```

`execution.inprocess.test/execution.inprocess.test.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F79ED47A-7A0D-49BC-B4D7-68BD24D5858C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>executiontest</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>execution.lib;ParserPayload.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>execution.lib;ParserPayload.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`fibonacci/fib.cpp`:

```cpp
#include <stdio.h>

unsigned int fibo0 = 1, fibo1 = 1;

int main() {
	unsigned int fib0 = fibo0, fib1 = fibo1;
	for (int i = 0; i < 1000 - 2; ++i) {
		unsigned int t = fib0 + fib1;
		fib0 = fib1;
		fib1 = t;
	}

	printf("%u\n", fib1);
}


```

`ipclib/CMakeLists.txt`:

```txt
## ipclib CMakeLists.txt

set(LIBRARY_NAME ipc)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32 -std=c++11")

add_library(${LIBRARY_NAME} SHARED
	ipclib.cpp
	)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`ipclib/Makefile`:

```
ipc_lib := libipc.so
CC := gcc
CXX := g++
CPP_FILES := ipclib.cpp
OBJ_FILES := ipclib.o

CXX_FLAGS += -m32 -std=c++11
prefix := /usr/local

all: $(ipc_lib)

install: $(ipc_lib)
	install -m 0755 $(ipc_lib) -t $(prefix)/lib -D

$(ipc_lib): $(OBJ_FILES)
	$(CXX) $(CXX_FLAGS) -shared -o $@ $(OBJ_FILES)

%.o: %.cpp
	$(CXX) $(CXX_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) -r $(ipc_lib) $(OBJ_FILES)


```

`ipclib/RingBuffer.h`:

```h
#ifndef _RING_BUFFER_H_
#define _RING_BUFFER_H_

namespace ipc {
	template <int SZ> class RingBuffer {
	private:
		char buffer[SZ];
		volatile int head, tail;

	public:
		void Init() {
			head = tail = 0;
			buffer[0] = 0;
		}

		bool IsEmpty() const {
			return head == tail;
		}

		bool IsFull() const {
			int nextTail = (tail + 1) % SZ;
			return nextTail == head;
		}

		void Read(char *buf, int size, int &read) {
			int vH = head;
			if (vH < tail) {
				vH += SZ;
			}

			read = vH - tail;
			if (size < read) {
				read = size;
			}

			int dwLast = (tail + read) % SZ;

			for (int p = 0; tail != dwLast; ++p) {
				buf[p] = buffer[tail];
				tail++;
				if (tail >= SZ) {
					tail -= SZ;
				}
			}
		}

		void Write(char *buf, int size) {
			int vT = tail;

			if (vT <= head) {
				vT += SZ;
			}

			int write = vT - head - 1;

			if (size > write) {
				tail = (head + write + 1) % SZ;
			}
			else if (size < write) {
				write = size;
			}

			int dwLast = (head + write) % SZ;

			for (int p = 0; head != dwLast; ++p) {
				buffer[head] = buf[p];
				head++;
				if (head >= SZ) {
					head -= SZ;
				}
			}
			buffer[dwLast] = '\0';
		}
	};
};

#endif
```

`ipclib/common.h`:

```h
#ifndef _COMMON_IPC_H
#define _COMMON_IPC_H

#ifdef _MSC_VER
#define DEBUG_BREAK __asm \
{ __asm int 3 }
#else
#define DEBUG_BREAK asm volatile("int $0x3")
typedef unsigned int size_t;
#endif

#if defined _WIN32 || defined __CYGWIN__
	#ifdef _BUILDING_IPC_DLL
		#ifdef __GNUC__
			#define DLL_IPC_PUBLIC __attribute__ ((dllexport))
		#else
			#define DLL_IPC_PUBLIC __declspec(dllexport)
		#endif
	#else
		#ifdef __GNUC__
			#define DLL_IPC_PUBLIC __attribute__ ((dllimport))
		#else
			#define DLL_IPC_PUBLIC __declspec(dllimport)
		#endif
	#endif
	#define DLL_IPC_LOCAL
#else
	#if __GNUC__ >= 4
		#define DLL_IPC_PUBLIC __attribute__ ((visibility ("default")))
		#define DLL_IPC_LOCAL  __attribute__ ((visibility ("hidden")))
	#else
		#define DLL_IPC_PUBLIC
		#define DLL_IPC_LOCAL
	#endif
#endif


typedef void *ADDR_TYPE;

namespace ipc {
	typedef int (*InitSemaphoreHandler)(void *, int, int);
	typedef int (*WaitSemaphoreFunc)(void *, bool);
	typedef int (*PostSemaphoreFunc)(void *);
	typedef int (*DestroySemaphoreHandler)(void *);
	typedef int (*GetvalueSemaphoreHandler)(void *, int*);

	/*struct IpcAPI {
		ADDR_TYPE ntYieldExecution;
		ADDR_TYPE initSemaphore;
		ADDR_TYPE waitSemaphore;
		ADDR_TYPE postSemaphore;
		ADDR_TYPE destroySemaphore;
		ADDR_TYPE getvalueSemaphore;
		ADDR_TYPE vsnprintf_s;

		ADDR_TYPE ldrMapMemory;
	};*/
} //namespace ipc

#endif

```

`ipclib/ipclib.cpp`:

```cpp
#include "ipclib.h"

#include "../revtracer/DebugPrintFlags.h"
#include "common.h"

namespace ipc {
	typedef char *va_list;
#define _ADDRESSOF(v)   ( (unsigned int *)&v )
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )


	RingBuffer<(1 << 20)> debugLog;


	//AbstractTokenRing *ipcToken = &__ipcToken;
	DLL_IPC_PUBLIC IpcData ipcData;

	int GeneratePrefix(char *buff, int size, ...) {
		va_list va;

		va_start(va, size);
		int sz = ((_vsnprintf_sFunc)ipcImports.vsnprintf_sFunc)(
			buff, 
			size - 1, 
			"[%3s|%5s|%3s|%c] ",
			va
		);
		va_end(va);

		return sz;
	}

	char tmpBuff[512];

	char pfxBuff[] = "[___|_____|___|_]      ";
	static char lastChar = '\n';

	const char messageTypes[][4] = {
		"___",
		"ERR",
		"INF",
		"DBG"
	};

	const char executionStages[][6] = {
		"_____",
		"BRHND",
		"DIASM",
		"TRANS",
		"REASM",
		"RUNTM",
		"INSPT",
		"CNTNR"
	};

	const char codeTypes[][4] = {
		"___",
		"NAT",
		"RIV",
		"TRK",
		"SYM"
	};

	const char codeDirections[] = {
		'_', 'F', 'B'
	};

	void DebugPrint(DWORD printMask, const char *fmt, ...) {
		va_list va;


		if ('\n' == lastChar) {
			int sz = GeneratePrefix(
				pfxBuff,
				sizeof(pfxBuff),
				messageTypes[(printMask & PRINT_MESSAGE_MASK) >> PRINT_MESSAGE_SHIFT],
				executionStages[(printMask & PRINT_EXECUTION_MASK) >> PRINT_EXECUTION_SHIFT],
				codeTypes[(printMask & PRINT_CODE_TYPE_MASK) >> PRINT_CODE_TYPE_SHIFT],
				codeDirections[(printMask & PRINT_CODE_DIRECTION_MASK) >> PRINT_CODE_DIRECTION_SHIFT]
			);
			debugLog.Write(pfxBuff, sz);
		}

		va_start(va, fmt);
		int sz = ((_vsnprintf_sFunc)ipcImports.vsnprintf_sFunc)(tmpBuff, sizeof(tmpBuff)-1, fmt, va);
		va_end(va);

		if (sz) {
			debugLog.Write(tmpBuff, sz);
			lastChar = tmpBuff[sz - 1];
		}
	}


#define SECTION_MAP_WRITE            0x0002
#define SECTION_MAP_READ             0x0004
#define SECTION_MAP_EXECUTE          0x0020

#define FILE_MAP_WRITE      SECTION_MAP_WRITE
#define FILE_MAP_READ       SECTION_MAP_READ
#define FILE_MAP_EXECUTE	SECTION_MAP_EXECUTE

	void *MemoryAlloc(DWORD dwSize) {
		ipcData.type = REQUEST_MEMORY_ALLOC;
		ipcData.data.asMemoryAllocRequest = dwSize;
		ipcImports.ipcToken->Release(DEBUGGED_PROCESS_TOKENID);

		// remote execution here

		ipcImports.ipcToken->Wait(DEBUGGED_PROCESS_TOKENID);
		if (ipcData.type != REPLY_MEMORY_ALLOC) {
			DEBUG_BREAK;
		}

		void *ptr = (ipcImports.mapMemory)(
			FILE_MAP_READ | FILE_MAP_WRITE | FILE_MAP_EXECUTE,
			ipcData.data.asMemoryAllocReply.offset,
			dwSize,
			ipcData.data.asMemoryAllocReply.pointer
		);

		if (ptr != ipcData.data.asMemoryAllocReply.pointer) {
			DEBUG_BREAK;
			return NULL;
		}

		return ptr;
	}

	void MemoryFree(void *ptr) {
		ipcData.type = REQUEST_MEMORY_FREE;
		ipcData.data.asMemoryFreeRequest = ptr;
		ipcImports.ipcToken->Release(DEBUGGED_PROCESS_TOKENID);
		// remote execution here

		ipcImports.ipcToken->Wait(DEBUGGED_PROCESS_TOKENID);
		if (ipcData.type != REPLY_MEMORY_FREE) {
			DEBUG_BREAK;
		}
	}

	QWORD TakeSnapshot() {
		ipcData.type = REQUEST_TAKE_SNAPSHOT;
		ipcImports.ipcToken->Release(DEBUGGED_PROCESS_TOKENID);
		// remote execution here
		
		ipcImports.ipcToken->Wait(DEBUGGED_PROCESS_TOKENID);
		if (ipcData.type != REPLY_TAKE_SNAPSHOT) {
			DEBUG_BREAK;
		}

		return ipcData.data.asTakeSnapshotReply;
	}

	QWORD RestoreSnapshot() {
		ipcData.type = REQUEST_RESTORE_SNAPSHOT;
		ipcImports.ipcToken->Release(DEBUGGED_PROCESS_TOKENID);
		// remote execution here

		ipcImports.ipcToken->Wait(DEBUGGED_PROCESS_TOKENID);
		if (ipcData.type != REPLY_RESTORE_SNAPSHOT) {
			DEBUG_BREAK;
		}

		return ipcData.data.asRestoreSnapshotReply;
	}

	void InitializeContext(void *context) {
		ipcData.type = REQUEST_INITIALIZE_CONTEXT;
		ipcData.data.asInitializeContextRequest = context;
		ipcImports.ipcToken->Release(DEBUGGED_PROCESS_TOKENID);
		// remote execution here

		ipcImports.ipcToken->Wait(DEBUGGED_PROCESS_TOKENID);
		if (ipcData.type != REPLY_INITIALIZE_CONTEXT) {
			DEBUG_BREAK;
		}
	}

	void CleanupContext(void *context) {
		ipcData.type = REQUEST_CLEANUP_CONTEXT;
		ipcData.data.asCleanupContextRequest = context;
		ipcImports.ipcToken->Release(DEBUGGED_PROCESS_TOKENID);
		// remote execution here

		ipcImports.ipcToken->Wait(DEBUGGED_PROCESS_TOKENID);
		if (ipcData.type != REPLY_CLEANUP_CONTEXT) {
			DEBUG_BREAK;
		}
	}

	DWORD BranchHandler(void *context, void *userContext, ADDR_TYPE nextInstruction) {
		ipcData.type = REQUEST_BRANCH_HANDLER;
		ipcData.data.asBranchHandlerRequest.executionEnv = context;
		ipcData.data.asBranchHandlerRequest.userContext = userContext;
		ipcData.data.asBranchHandlerRequest.nextInstruction = nextInstruction;
		ipcImports.ipcToken->Release(DEBUGGED_PROCESS_TOKENID);

		ipcImports.ipcToken->Wait(DEBUGGED_PROCESS_TOKENID);
		if (ipcData.type != REPLY_BRANCH_HANDLER) {
			DEBUG_BREAK;
		}

		return ipcData.data.asBranchHandlerReply;
	}

	void SyscallControl(void *context, void *userContext) {
		ipcData.type = REQUEST_SYSCALL_CONTROL;
		ipcData.data.asSyscallControlRequest.context = context;
		ipcData.data.asSyscallControlRequest.userContext = userContext;
		ipcImports.ipcToken->Release(DEBUGGED_PROCESS_TOKENID);
		// remote execution here

		ipcImports.ipcToken->Wait(DEBUGGED_PROCESS_TOKENID);
		if (ipcData.type != REPLY_SYSCALL_CONTROL) {
			DEBUG_BREAK;
		}
	}

	void DummyFunc() {
		ipcData.type = REQUEST_DUMMY;
		ipcImports.ipcToken->Release(DEBUGGED_PROCESS_TOKENID);
		// remote execution here

		ipcImports.ipcToken->Wait(DEBUGGED_PROCESS_TOKENID);
		if (ipcData.type != REPLY_DUMMY) {
			DEBUG_BREAK;
		}
	}


	void Initialize() {
		debugLog.Init();
		//TODO handle Windows case accordingly
		//ipcToken.Use(DEBUGGED_PROCESS_TOKENID);
	}

	DLL_IPC_PUBLIC IpcExports ipcExports = {
		DebugPrint,
		MemoryAlloc,
		MemoryFree,

		TakeSnapshot,
		RestoreSnapshot,

		InitializeContext,
		CleanupContext,

		BranchHandler,
		SyscallControl,
		
		Initialize,

		&debugLog,
		&ipcData
	};

	DLL_IPC_PUBLIC IpcImports ipcImports;

#define FALSE 0
#define TRUE 1

#define PF_FLOATING_POINT_PRECISION_ERRATA   0   
#define PF_FLOATING_POINT_EMULATED           1   
#define PF_COMPARE_EXCHANGE_DOUBLE           2   
#define PF_MMX_INSTRUCTIONS_AVAILABLE        3   
#define PF_PPC_MOVEMEM_64BIT_OK              4   
#define PF_ALPHA_BYTE_INSTRUCTIONS           5   
#define PF_XMMI_INSTRUCTIONS_AVAILABLE       6   
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE      7   
#define PF_RDTSC_INSTRUCTION_AVAILABLE       8   
#define PF_PAE_ENABLED                       9   
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE    10   
#define PF_SSE_DAZ_MODE_AVAILABLE           11   
#define PF_NX_ENABLED                       12   
#define PF_SSE3_INSTRUCTIONS_AVAILABLE      13   
#define PF_COMPARE_EXCHANGE128              14   
#define PF_COMPARE64_EXCHANGE128            15   
#define PF_CHANNELS_ENABLED                 16   
#define PF_XSAVE_ENABLED                    17   
#define PF_ARM_VFP_32_REGISTERS_AVAILABLE   18   
#define PF_ARM_NEON_INSTRUCTIONS_AVAILABLE  19   
#define PF_SECOND_LEVEL_ADDRESS_TRANSLATION 20   
#define PF_VIRT_FIRMWARE_ENABLED            21   
#define PF_RDWRFSGSBASE_AVAILABLE           22   
#define PF_FASTFAIL_AVAILABLE               23   
#define PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE 24   
#define PF_ARM_64BIT_LOADSTORE_ATOMIC       25   
#define PF_ARM_EXTERNAL_CACHE_AVAILABLE     26   
#define PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE  27   
#define PF_RDRAND_INSTRUCTION_AVAILABLE     28   

	DLL_IPC_PUBLIC BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature) {
		BOOL result;

		if (ProcessorFeature >= 0x40) {
			result = FALSE;
		}
		else {
			switch (ProcessorFeature) {
			case PF_MMX_INSTRUCTIONS_AVAILABLE:
			case PF_SSE3_INSTRUCTIONS_AVAILABLE:
			case PF_XMMI64_INSTRUCTIONS_AVAILABLE:
			case PF_XMMI_INSTRUCTIONS_AVAILABLE:
			case PF_COMPARE_EXCHANGE_DOUBLE:
			case PF_COMPARE_EXCHANGE128:
			case PF_COMPARE64_EXCHANGE128:
				return FALSE;
			default:
				result = ((BYTE *)0x7FFE0274)[ProcessorFeature];
			}
		}
		return result;
	}
};

unsigned int Entry() {
	return 1;
}

```

`ipclib/ipclib.h`:

```h
#ifndef _IPCLIB_H_
#define _IPCLIB_H_

#include "RingBuffer.h"
#include "../revtracer-wrapper/TokenRing.h"

#include "../CommonCrossPlatform/LibraryLayout.h"

#ifdef _MSC_VER
#define DEBUG_BREAK __asm \
{ __asm int 3 }
#else
#define DEBUG_BREAK asm volatile("int $0x3")
typedef unsigned int size_t;
#endif

#if defined _WIN32 || defined __CYGWIN__
	#ifdef _BUILDING_IPC_DLL
		#ifdef __GNUC__
			#define DLL_IPC_PUBLIC __attribute__ ((dllexport))
		#else
			#define DLL_IPC_PUBLIC __declspec(dllexport)
		#endif
	#else
		#ifdef __GNUC__
			#define DLL_IPC_PUBLIC __attribute__ ((dllimport))
		#else
			#define DLL_IPC_PUBLIC __declspec(dllimport)
		#endif
	#endif
	#define DLL_IPC_LOCAL
#else
	#if __GNUC__ >= 4
		#define DLL_IPC_PUBLIC __attribute__ ((visibility ("default")))
		#define DLL_IPC_LOCAL  __attribute__ ((visibility ("hidden")))
	#else
		#define DLL_IPC_PUBLIC
		#define DLL_IPC_LOCAL
	#endif
#endif

namespace ipc {
/* Define NULL pointer value */
#ifndef NULL
	#ifdef __cplusplus
		#define NULL    0
	#else  /* __cplusplus */
		#define NULL    ((void *)0)
	#endif  /* __cplusplus */
#endif  /* NULL */

#if !defined(_W64)
	#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86) || defined(_ARM_) || defined(_M_ARM)) && _MSC_VER >= 1300
		#define _W64 __w64
	#else
		#define _W64
	#endif
#endif

#if defined(_WIN64)
	typedef __int64 INT_PTR, *PINT_PTR;
	typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

	typedef __int64 LONG_PTR, *PLONG_PTR;
	typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

#define __int3264   __int64

#else
	typedef _W64 int INT_PTR, *PINT_PTR;
	typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

	typedef _W64 long LONG_PTR, *PLONG_PTR;
	typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

#define __int3264   __int32

#endif

	typedef unsigned long long QWORD;
	typedef unsigned long DWORD;
	typedef unsigned short WORD;
	typedef unsigned char BYTE;

	typedef void *ADDR_TYPE;
	typedef void *HANDLE;

	typedef int BOOL;


#define REQUEST_MEMORY_ALLOC				0x80
#define REQUEST_MEMORY_FREE					0x81
#define REQUEST_TAKE_SNAPSHOT				0x88
#define REQUEST_RESTORE_SNAPSHOT			0x89
#define REQUEST_INITIALIZE_CONTEXT			0x90
#define REQUEST_CLEANUP_CONTEXT				0x91
#define REQUEST_SYSCALL_CONTROL				0x95
#define REQUEST_BRANCH_HANDLER				0xA0
#define REQUEST_DUMMY						0xFF

#define REPLY_MEMORY_ALLOC					0xC0
#define REPLY_MEMORY_FREE					0xC1
#define REPLY_TAKE_SNAPSHOT					0xC8
#define REPLY_RESTORE_SNAPSHOT				0xC9
#define REPLY_INITIALIZE_CONTEXT			0xD0
#define REPLY_CLEANUP_CONTEXT				0xD1
#define REPLY_SYSCALL_CONTROL				0xD5
#define REPLY_BRANCH_HANDLER				0xE0
#define REPLY_DUMMY							0xFE

	struct IpcData {
		DWORD type;

		union {
			struct {
				void *pointer;
				DWORD offset;
			} asMemoryAllocReply;
			QWORD asTakeSnapshotReply;
			QWORD asRestoreSnapshotReply;
			DWORD asExecutionBeginReply;
			DWORD asExecutionControlReply;
			DWORD asExecutionEndReply;
			DWORD asBranchHandlerReply;

			DWORD asMemoryAllocRequest;
			void *asMemoryFreeRequest;
			void *asInitializeContextRequest;
			void *asCleanupContextRequest;
			struct {
				void *context;
				ADDR_TYPE nextInstruction;
				void *cbCtx;
			} asExecutionControlRequest, asExecutionBeginRequest;

			struct {
				void *context;
				void *cbCtx;
			} asExecutionEndRequest;

			struct {
				void *context;
				void *userContext;
			} asSyscallControlRequest;

			struct {
				void *executionEnv;
				void *userContext;
				ADDR_TYPE nextInstruction;
			} asBranchHandlerRequest;
		} data;
	};

#define DEBUGGED_PROCESS_TOKENID 1
#define CONTROL_PROCESS_TOKENID 0

	typedef void(*DbgPrintFunc)(const unsigned int dwMask, const char *fmt, ...);

	typedef void *(*MapMemoryFunc)(
		//unsigned long mapHandler,
		unsigned long access,
		unsigned long offset,
		unsigned long size,
		void *address);

	typedef int(*_vsnprintf_sFunc)(
		char *buffer,
		size_t count,
		const char *format,
		char *argptr
	);

	struct IpcImports {
		//WaitEventFunc waitEventFunc;
		//PostEventFunc postEventFunc;

		MapMemoryFunc mapMemory;
		_vsnprintf_sFunc vsnprintf_sFunc;
		revwrapper::TokenRing *ipcToken;
	};

	typedef void (*DebugPrintFunc)(DWORD printMask, const char *fmt, ...);

	typedef void *(*MemoryAllocFunc)(DWORD dwSize);
	typedef void (*MemoryFreeFunc)(void *ptr);

	typedef QWORD (*TakeSnapshotFunc)();
	typedef QWORD (*RestoreSnapshotFunc)();

	typedef void (*InitializeContextFunc)(void *context);
	typedef void (*CleanupContextFunc)(void *context);

	typedef DWORD (*BranchHandlerFunc)(void *context, void *userContext, ADDR_TYPE nextInstruction);
	typedef void (*SyscallControlFunc)(void *context, void *userContext);

	//typedef void InitializeIpcToken();
	typedef void (*InitializeFunc)();

	struct IpcExports {
		DebugPrintFunc debugPrint;
		MemoryAllocFunc memoryAlloc;
		MemoryFreeFunc memoryFree;

		TakeSnapshotFunc takeSnapshot;
		RestoreSnapshotFunc restoreSnapshot;

		InitializeContextFunc initializeContext;
		CleanupContextFunc cleanupContext;

		BranchHandlerFunc branchHandler;
		SyscallControlFunc syscallControl;

		InitializeFunc initialize;

		RingBuffer<(1 << 20)> *debugLog;
		IpcData *ipcData;
	};

	extern "C" {
		DLL_IPC_PUBLIC extern IpcImports ipcImports;
		DLL_IPC_PUBLIC extern IpcExports ipcExports;

		//DLL_IPC_PUBLIC extern IpcData ipcData;

/*#ifdef __linux__
		DLL_IPC_PUBLIC extern ShmTokenRingLin ipcToken;
#else
		DLL_IPC_PUBLIC extern ShmTokenRingWin ipcToken;
#endif*/


		//DLL_IPC_PUBLIC extern void InitializeIpcToken();


		DLL_IPC_PUBLIC BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature);
	}
};

#endif

```

`ipclib/ipclib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3E5A9A80-186E-4D0A-9279-E2D7EFB66706}</ProjectGuid>
    <RootNamespace>ipclib</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_BUILDING_IPC_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SectionAlignment>65536</SectionAlignment>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>Entry</EntryPointSymbol>
      <SubSystem>Console</SubSystem>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetDir)$(TargetFileName) $(SolutionDir)jsdemo\
copy $(TargetDir)$(ProjectName).pdb $(SolutionDir)jsdemo\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_BUILDING_IPC_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SectionAlignment>65536</SectionAlignment>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>Entry</EntryPointSymbol>
      <ImportLibrary>$(OutDir)$(TargetName).lib</ImportLibrary>
      <SubSystem>Console</SubSystem>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetDir)$(TargetFileName) $(SolutionDir)jsdemo\
copy $(TargetDir)$(ProjectName).pdb $(SolutionDir)jsdemo\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ipclib.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.h" />
    <ClInclude Include="ipclib.h" />
    <ClInclude Include="RingBuffer.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`libproc/libproc.cpp`:

```cpp
/* libunwind - a platform-independent unwind library
   Copyright (C) 2003-2004 Hewlett-Packard Co
   Copyright (C) 2007 David Mosberger-Tang
	Contributed by David Mosberger-Tang <dmosberger@gmail.com>

This file is part of libunwind.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */

#include "os-linux.h"
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>

inline char *ltoa (char *buf, long val)
{
	char *cp = buf, tmp;
	ssize_t i, len;

	do
	{
		*cp++ = '0' + (val % 10);
		val /= 10;
	}
	while (val);

	/* reverse the order of the digits: */
	len = cp - buf;
	--cp;
	for (i = 0; i < len / 2; ++i)
	{
		tmp = buf[i];
		buf[i] = cp[-i];
		cp[-i] = tmp;
	}
	return buf + len;
}

int maps_init(struct map_iterator *mi, pid_t pid)
{
	char path[sizeof ("/proc/0123456789/maps")], *cp;

	memcpy (path, "/proc/", 6);
	cp = ltoa (path + 6, pid);
	assert (cp + 6 < path + sizeof (path));
	memcpy (cp, "/maps", 6);

	mi->fd = open (path, O_RDONLY);
	if (mi->fd >= 0)
	{
		/* Try to allocate a page-sized buffer.  */
		mi->buf_size = getpagesize ();
		cp = (char*)mmap (0, mi->buf_size, PROT_READ | PROT_WRITE,
				MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
		if (cp == MAP_FAILED)
		{
			close(mi->fd);
			mi->fd = -1;
			return -1;
		}
		else
		{
			mi->offset = 0;
			mi->buf = mi->buf_end = cp + mi->buf_size;
			return 0;
		}
	}
	return -1;
}

char *skip_whitespace (char *cp)
{
	if (!cp)
		return NULL;

	while (*cp == ' ' || *cp == '\t')
		++cp;
	return cp;
}

char *scan_hex (char *cp, unsigned long *valp)
{
	unsigned long num_digits = 0, digit, val = 0;

	cp = skip_whitespace (cp);
	if (!cp)
		return NULL;

	while (1)
	{
		digit = *cp;
		if ((digit - '0') <= 9)
			digit -= '0';
		else if ((digit - 'a') < 6)
			digit -= 'a' - 10;
		else if ((digit - 'A') < 6)
			digit -= 'A' - 10;
		else
			break;
		val = (val << 4) | digit;
		++num_digits;
		++cp;
	}
	if (!num_digits)
		return NULL;
	*valp = val;
	return cp;
}

char *scan_dec (char *cp, unsigned long *valp)
{
	unsigned long num_digits = 0, digit, val = 0;

	if (!(cp = skip_whitespace (cp)))
		return NULL;

	while (1)
	{
		digit = *cp;
		if ((digit - '0') <= 9)
		{
			digit -= '0';
			++cp;
		}
		else
			break;
		val = (10 * val) + digit;
		++num_digits;
	}
	if (!num_digits)
		return NULL;
	*valp = val;
	return cp;
}

char *scan_char (char *cp, char *valp)
{
	if (!cp)
		return NULL;

	*valp = *cp;

	/* don't step over NUL terminator */
	if (*cp)
		++cp;
	return cp;
}

/* Scan a string delimited by white-space.  Fails on empty string or
   if string is doesn't fit in the specified buffer.  */
char *scan_string (char *cp, char *valp, size_t buf_size)
{
	size_t i = 0;

	if (!(cp = skip_whitespace (cp)))
		return NULL;

	while (*cp != ' ' && *cp != '\t' && *cp != '\0')
	{
		if ((valp != NULL) && (i < buf_size - 1))
			valp[i++] = *cp;
		++cp;
	}
	if (i == 0 || i >= buf_size)
		return NULL;
	valp[i] = '\0';
	return cp;
}

int maps_next (struct map_iterator *mi,
		unsigned long *low, unsigned long *high, unsigned long *offset,
		struct map_prot *mp)
{
	char perm[16], dash = 0, colon = 0, *cp;
	unsigned long major, minor, inum;
	ssize_t i, nread;

	if (mi->fd < 0)
		return 0;

	while (1)
	{
		ssize_t bytes_left = mi->buf_end - mi->buf;
		char *eol = NULL;

		for (i = 0; i < bytes_left; ++i)
		{
			if (mi->buf[i] == '\n')
			{
				eol = mi->buf + i;
				break;
			}
			else if (mi->buf[i] == '\0')
				break;
		}
		if (!eol)
		{
			/* copy down the remaining bytes, if any */
			if (bytes_left > 0)
				memmove (mi->buf_end - mi->buf_size, mi->buf, bytes_left);

			mi->buf = mi->buf_end - mi->buf_size;
			nread = read (mi->fd, mi->buf + bytes_left,
					mi->buf_size - bytes_left);
			if (nread <= 0)
				return 0;
			else if ((size_t) (nread + bytes_left) < mi->buf_size)
			{
				/* Move contents to the end of the buffer so we
				   maintain the invariant that all bytes between
				   mi->buf and mi->buf_end are valid.  */
				memmove (mi->buf_end - nread - bytes_left, mi->buf,
						nread + bytes_left);
				mi->buf = mi->buf_end - nread - bytes_left;
			}

			eol = mi->buf + bytes_left + nread - 1;

			for (i = bytes_left; i < bytes_left + nread; ++i)
				if (mi->buf[i] == '\n')
				{
					eol = mi->buf + i;
					break;
				}
		}
		cp = mi->buf;
		mi->buf = eol + 1;
		*eol = '\0';

		/* scan: "LOW-HIGH PERM OFFSET MAJOR:MINOR INUM PATH" */
		cp = scan_hex (cp, low);
		cp = scan_char (cp, &dash);
		cp = scan_hex (cp, high);
		cp = scan_string (cp, perm, sizeof (perm));
		mp->prot = ((perm[0] == 'r') & PROT_READ) |
			(((perm[1] == 'w') << 1) & PROT_WRITE) |
			(((perm[2] == 'x') << 2) & PROT_EXEC);
		mp->flags = ((perm[3] == 'p') ? MAP_PRIVATE : MAP_SHARED);
		cp = scan_hex (cp, offset);
		cp = scan_hex (cp, &major);
		cp = scan_char (cp, &colon);
		cp = scan_hex (cp, &minor);
		cp = scan_dec (cp, &inum);
		cp = mi->path = skip_whitespace (cp);
		if (!cp)
			continue;
		cp = scan_string (cp, NULL, 0);
		if (dash != '-' || colon != ':')
			continue;	/* skip line with unknown or bad format */
		return 1;
	}
	return 0;
}

void maps_close (struct map_iterator *mi)
{
	if (mi->fd < 0)
		return;
	close (mi->fd);
	mi->fd = -1;
	if (mi->buf)
	{
		munmap (mi->buf_end - mi->buf_size, mi->buf_size);
		mi->buf = mi->buf_end = 0;
	}
}

long get_rss() {
	long resident = 0;
	FILE* fp = NULL;

	if ( (fp = fopen( "/proc/self/statm", "r" )) == NULL )
		return (size_t)0L;

	if ( fscanf( fp, "%*s%ld", &resident) != 1 ) {
		fclose( fp );
		return (size_t)0L;
	}

	fclose( fp );
	return (size_t)resident * (size_t)sysconf( _SC_PAGESIZE);
}

```

`libproc/os-linux.h`:

```h
/* libunwind - a platform-independent unwind library
   Copyright (C) 2003-2004 Hewlett-Packard Co
   Copyright (C) 2007 David Mosberger-Tang
	Contributed by David Mosberger-Tang <dmosberger@gmail.com>

This file is part of libunwind.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */

#ifndef os_linux_h
#define os_linux_h

#include <assert.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdint.h>

struct map_iterator
{
	off_t offset;
	int fd;
	size_t buf_size;
	char *buf;
	char *buf_end;
	char *path;
};

struct map_prot
{
	uint32_t prot;
	uint32_t flags;
};

#define FREE 0
#define ALLOCATED 1

struct map_region
{
	unsigned long address;
	unsigned long size;
	uint32_t state;
};

extern int maps_init(struct map_iterator *mi, pid_t pid);

extern int maps_next (struct map_iterator *mi,
		unsigned long *low, unsigned long *high, unsigned long *offset,
		struct map_prot *mp);

extern void maps_close (struct map_iterator *mi);

extern long get_rss();
#endif /* os_linux_h */

```

`loader.setup/Loader.Setup.h`:

```h
#ifndef _LOADER_SETUP_H_
#define _LOADER_SETUP_H_

#include "../loader/Loader.h"

extern "C" bool InitLoaderOffsets(ext::LibraryLayout *libs, ldr::LoaderImports *api);

#endif
```

`loader.setup/Setup.Windows.cpp`:

```cpp
#ifndef __linux__

#include "../CommonCrossPlatform/Common.h"
#include "Loader.Setup.h"

extern "C" bool InitLoaderOffsets(ext::LibraryLayout *libs, ldr::LoaderImports *api) {

	LIB_T hNtDll = GET_LIB_HANDLER(L"ntdll.dll");
	DWORD baseNtDll = GET_LIB_BASE(hNtDll);

	if (!hNtDll) {
		return false;
	}

	libs->winLib.ntdllBase = baseNtDll;

	api->functions.winFunc.ntdll._ntMapViewOfSection = (DWORD)LOAD_PROC(hNtDll, "NtMapViewOfSection") - baseNtDll;
	api->functions.winFunc.ntdll._ntFlushInstructionCache = (DWORD)LOAD_PROC(hNtDll, "NtFlushInstructionCache") - baseNtDll;
	api->functions.winFunc.ntdll._ntFreeVirtualMemory = (DWORD)LOAD_PROC(hNtDll, "NtFreeVirtualMemory") - baseNtDll;

	return true;
}


#endif
```

`loader.setup/loader.setup.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{117888DC-1743-427D-9A65-D32029F42038}</ProjectGuid>
    <RootNamespace>loadersetup</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Loader.Setup.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Setup.Windows.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`loader.test/Loader/Abstract.Mapper.h`:

```h
#ifndef _ABSTRACT_MAPPER_H_
#define _ABSTRACT_MAPPER_H_

#include "Types.h"

class AbstractPEMapper {
public:
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) = 0;

	virtual DWORD FindImport(const char *moduleName, const char *funcName) = 0;
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal) = 0;
};

#endif


```

`loader.test/Loader/Extern.Mapper.cpp`:

```cpp
#include "Extern.Mapper.h"

#include <psapi.h>

bool SameFile(const char *s1, int l1, const char *s2, int l2) {
	/*int cLen = l1;
	if (l2 < cLen) cLen = l2;

	int o1 = l1 - cLen, o2 = l2 - cLen;

	for (int i = 0; i < cLen; ++i) {
		if (toupper(s1[o1 + i]) != toupper(s2[o2 + i])) {
			return false;
		}
	}

	if ((o1 > 0) && (s1[o1 - 1] != '\\')) {
		return false;
	}

	if ((o2 > 0) && (s2[o2 - 1] != '\\')) {
		return false;
	}

	return true;*/

	if (l1 != l2) {
		return false;
	}

	for (int i = 0; i < l1; ++i) {
		if (toupper(s1[i]) == toupper(s2[i])) {
			return false;
		}
	}

	return true;
}

HMODULE ExternMapper::RemoteFindModule(const char *module) {
	HMODULE hMods[1024];
	DWORD cbNeeded;

	int mLen = strlen(module);

	if (EnumProcessModules(hProc, hMods, sizeof(hMods), &cbNeeded)) {
		for (unsigned int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {
			char szModName[MAX_PATH];
			if (GetModuleFileNameExA(hProc, hMods[i], szModName, sizeof(szModName))) {
				int rLen = strlen(szModName);
				
				if (SameFile(module, mLen, szModName, rLen)) {
					return hMods[i];
				}
			}
		}
	}

	return NULL;
}

ExternMapper::ExternMapper(unsigned int pid) {
	hProc = OpenProcess(
		PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
		FALSE,
		pid
	);

	ownProcess = true;
}

ExternMapper::ExternMapper(HANDLE process) {
	hProc = process;
	ownProcess = false;
}

ExternMapper::~ExternMapper() {
	if (ownProcess) {
		CloseHandle(hProc);
	}
}

void *ExternMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return VirtualAllocEx(hProc, lpAddress, dwSize, MEM_RESERVE | MEM_COMMIT, flProtect);
}

bool ExternMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	DWORD oldProtect;
	return TRUE == VirtualProtectEx(hProc, lpAddress, dwSize, flProtect, &oldProtect);
}

bool ExternMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	return TRUE == WriteProcessMemory(hProc, lpAddress, lpBuffer, nSize, NULL);
}

/* This is very sloppy! */
/* Should work for ntdll. No WOW64 support. No export forwarding. */
DWORD ExternMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE rMod = RemoteFindModule(moduleName);
	HMODULE lMod = GetModuleHandleA(moduleName);

	if ((NULL == rMod) || (NULL == lMod)) {
		return 0xFFFFFFFF;
	}

	void *pFunc = GetProcAddress(lMod, funcName);
	return (DWORD)pFunc - (DWORD)lMod + (DWORD)rMod;
}

DWORD ExternMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE lMod = GetModuleHandleA(moduleName);
	char modName[MAX_PATH];

	GetModuleFileNameA(lMod, modName, sizeof(modName));
	HMODULE rMod = RemoteFindModule(modName);
	

	if ((NULL == rMod) || (NULL == lMod)) {
		return 0xFFFFFFFF;
	}

	void *pFunc = GetProcAddress(lMod, (LPCSTR)funcOrdinal);
	return (DWORD)pFunc - (DWORD)lMod + (DWORD)rMod;
}
```

`loader.test/Loader/Extern.Mapper.h`:

```h
#ifndef _EXTERN_MAPPER_H_
#define _EXTERN_MAPPER_H_

#include <Windows.h>

#include "Abstract.Mapper.h"

class ExternMapper : public AbstractPEMapper {
private :
	HANDLE hProc;
	bool ownProcess;

	HMODULE RemoteFindModule(const char *module);
public:
	ExternMapper(unsigned int pid);
	ExternMapper(HANDLE process);
	virtual ~ExternMapper();

	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif

```

`loader.test/Loader/Inproc.Mapper.cpp`:

```cpp
#include <Windows.h>
#include "Inproc.Mapper.h"


void *InprocMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return VirtualAlloc(lpAddress, dwSize, MEM_RESERVE | MEM_COMMIT, flProtect);
}

bool InprocMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	DWORD oldProtect;
	return TRUE == VirtualProtect(lpAddress, dwSize, flProtect, &oldProtect);
}

bool InprocMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	memcpy(lpAddress, lpBuffer, nSize);
	return true;
}

DWORD InprocMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, funcName);
}

DWORD InprocMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, (LPCSTR)funcOrdinal);
}
```

`loader.test/Loader/Inproc.Mapper.h`:

```h
#ifndef _INPROC_MAPPER_H_
#define _INPROC_MAPPER_H_

#include "Abstract.Mapper.h"

class InprocMapper : public AbstractPEMapper {
public :
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif
```

`loader.test/Loader/Mem.Mapper.cpp`:

```cpp
#include <Windows.h>
#include "Mem.Mapper.h"


void *MemMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return lpAddress;
}

bool MemMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return true;
}

bool MemMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	memcpy(lpAddress, lpBuffer, nSize);
	return true;
}

DWORD MemMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, funcName);
}

DWORD MemMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, (LPCSTR)funcOrdinal);
}
```

`loader.test/Loader/Mem.Mapper.h`:

```h
#ifndef _MEM_MAPPER_H_
#define _MEM_MAPPER_H_

#include "Abstract.Mapper.h"

class MemMapper : public AbstractPEMapper {
public :
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif
```

`loader.test/Loader/PE.ldr.cpp`:

```cpp
#include <stdio.h>
#include <vector>
using namespace std;

//#include "..\extern.h"

#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#endif

#include "PE.ldr.h"

//#include "common/debug-log.h"
//#define dbg_log DbgPrint

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5
#define IMAGE_REL_BASED_RESERVED              6
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9
#define IMAGE_REL_BASED_DIR64                 10

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     

#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     

#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define PAGE_REVERT_TO_FILE_MAP     0x80000000 

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

const USHORT DOS_MAGIC = 0x5A4D;
const DWORD PE_MAGIC = 0x00004550;
const WORD OPT32_MAGIC = 0x010B;
const WORD OPT64_MAGIC = 0x020B;

const WORD IMAGE_FILE_MACHINE_I386 = 0x14C;
const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Name;
	DWORD Base;
	DWORD NumberOfFunctions;
	DWORD NumberOfNames;
	DWORD AddressOfFunctions; // RVA from base of image
	DWORD AddressOfNames; // RVA from base of image
	DWORD AddressOfNameOrdinals; // RVA from base of image
} IMAGE_EXPORT_DIRECTORY;

void *FloatingPE::RVA(DWORD rva) const {
    for (int i = 0; i < peHdr.NumberOfSections; ++i) {
        if (rva >= sections[i].header.VirtualAddress) {
            DWORD dwOffset = rva - sections[i].header.VirtualAddress;
            if (dwOffset < sections[i].header.VirtualSize) {
                return sections[i].data + dwOffset;
            }
        }
    }
    return (void *)0;
}

bool FloatingPE::Relocate(DWORD newAddr) {
	long long offset = 0;
	IMAGE_BASE_RELOCATION *reloc;
    IMAGE_BASE_RELOCATION *term;

	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			offset = newAddr - optHdr.w32.ImageBase;
			optHdr.w32.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			offset = newAddr - optHdr.w64.ImageBase;
			optHdr.w64.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

    while (reloc < term) {
        //dbg_log("Relocation Block %08x %08x", reloc->VirtualAddress, reloc->SizeOfBlock);
        WORD *wloc = (WORD *)reloc + 4;
        int wlocCount = (reloc->SizeOfBlock - sizeof(*reloc)) / sizeof(*wloc);

        for (int i = 0; i < wlocCount; ++i) {
            //dbg_log("%x %x;\t", wloc[i] >> 12, wloc[i] & 0x0FFF);
			WORD type = wloc[i] >> 12;
			WORD off = wloc[i] & 0x0FFF;
			
			if ((i % 3) == 0) {
				//dbg_log("\n");
			}
			
			switch (type) {
				case IMAGE_REL_BASED_ABSOLUTE :
					break;
				case IMAGE_REL_BASED_HIGHLOW :
					*((DWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					//dbg_log("%08x -> %08x\t", reloc->VirtualAddress + off, *((DWORD *)RVA(reloc->VirtualAddress + off)));
					break;
				case IMAGE_REL_BASED_DIR64 :
					*((QWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					break;
				default :
					//__asm int 3;
					__debugbreak();
			}
        }
		//dbg_log("\n");
		reloc = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + reloc->SizeOfBlock);
    }


    return true;
}

bool FloatingPE::GetExport(const char *funcName, DWORD &funcRVA) const {
	DWORD exportRVA = 0;
	
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			exportRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			exportRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	};
	
	if (0 == exportRVA) {
		return false;
	}

	IMAGE_EXPORT_DIRECTORY *exprt = (IMAGE_EXPORT_DIRECTORY *)RVA(exportRVA);

	dbg_log("Number of functions: %d\n", exprt->NumberOfFunctions);
	dbg_log("Number of names: %d\n", exprt->NumberOfNames);

	DWORD *names = (DWORD *)RVA(exprt->AddressOfNames);
	int found = -1;
	for (DWORD i = 0; i < exprt->NumberOfNames; ++i) {
		char *name = (char *)RVA(names[i]);
		if (0 == strcmp(name, funcName)) {
			found = i;
			break;
		}
	}

	if (-1 == found) {
		return false;
	}

	WORD *ordinals = (WORD *)RVA(exprt->AddressOfNameOrdinals);
	WORD ordinal = ordinals[found] - (WORD)exprt->Base + 1;

	DWORD *exportTable = (DWORD *)RVA(exprt->AddressOfFunctions);
	funcRVA = exportTable[ordinal];

	return true;
}

DWORD FloatingPE::GetRequiredSize() const {
	DWORD maxAddr = 0;
	for (DWORD i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFF) & (~0xFFF);
		if (maxSec > maxAddr) {
			maxAddr = maxSec;
		}
	}

	return maxAddr;
}

DWORD FloatingPE::GetSectionCount() const {
	return sections.size();
}

const PESection *FloatingPE::GetSection(DWORD dwIdx) const {
	return &sections[dwIdx];
}

bool FloatingPE::FixImports(AbstractPEMapper &mapper) {
	DWORD importRVA = 0;
	
	
	switch (peHdr.Machine) {
	case IMAGE_FILE_MACHINE_I386:
		importRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	case IMAGE_FILE_MACHINE_AMD64:
		importRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	default:
		dbg_log("Unsupported machine type\n");
		return false;
	};

	if (0 == importRVA) {
		return true;
	}

    IMAGE_IMPORT_DESCRIPTOR *import = (IMAGE_IMPORT_DESCRIPTOR *)RVA(importRVA);
	if (NULL == import) {
		return false;
	}

    while (import->OriginalFirstThunk != 0) {
		char *name = (char *)RVA(import->Name);
        dbg_log("Directory for: %s\n", name);
		dbg_log("OFT: %08x, FT: %08x\n", import->OriginalFirstThunk, import->FirstThunk);
		DWORD *funcs = (DWORD *)RVA(import->OriginalFirstThunk);
		DWORD *iat = (DWORD *)RVA(import->FirstThunk);
        while (*funcs != 0) {
            if (0x80000000 & *funcs) {
                dbg_log("Import by ordinal %d\n", *funcs & 0x7FFF);
				*iat = mapper.FindImport(name, *funcs & 0x7FFF);
            } else {
				char *funcName = (char *)RVA(*funcs + 2);
                dbg_log("Import by name %s\n", funcName);
				*iat = mapper.FindImport(name, funcName);
            }

            funcs += 1;
			iat += 1;
        }

		import += 1;
    }

    return true;
}

bool FloatingPE::LoadPE(FILE *fModule) {
	if (NULL == fModule) {
		dbg_log("File open error!\n");
		return false;
	}

	if (1 != fread(&dosHdr, sizeof(dosHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (dosHdr.e_magic != DOS_MAGIC) {
		dbg_log("dosHdr.e_magic not valid\n");
		return false;
	}

	fseek(fModule, dosHdr.e_lfanew, SEEK_SET);


	if (1 != fread(&peHdr, sizeof(peHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (PE_MAGIC != peHdr.PeSignature) {
		dbg_log("peHdr.PeSignature not valid\n");
		return false;
	}

	//dbg_log("Machine: %d\n", peHdr.Machine);
	//dbg_log("NumberOfSections: %d\n", peHdr.NumberOfSections);
	//dbg_log("SizeOfOptionalHeader: %d\n", peHdr.SizeOfOptionalHeader);
	//dbg_log("Characteristics: %d\n", peHdr.Characteristics);

	DWORD optSize = 0;
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w32);
			break;
		case IMAGE_FILE_MACHINE_AMD64 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w64);
			break;
		default :
			dbg_log("Unsupported machine type\n");
			return false;
	}

	if (peHdr.SizeOfOptionalHeader != optSize) {
		dbg_log("Unsupported optional header\n");
		return false;
	}

	if (1 != fread(&optHdr, optSize, 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}


	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			if (OPT32_MAGIC != optHdr.c.Magic) {
				dbg_log("opt32Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %08x\n", optHdr.w32.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w32.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w32.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w32.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w32.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w32.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w32.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w32.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w32.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
			);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			if (OPT64_MAGIC != optHdr.c.Magic) {
				dbg_log("opt64Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %016x\n", optHdr.w64.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w64.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w64.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w64.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w64.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w64.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w64.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w64.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w64.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
				); break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

	

	sections.resize(peHdr.NumberOfSections);

	dbg_log("Name\t V.Size\t V.Addr\t R.Size\t R.Addr\t Characteristics\n");
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (1 != fread(&sections[i].header, sizeof(sections[i].header), 1, fModule)) {
			dbg_log("read error\n");
			return false;
		}

		dbg_log("%.8s\t %08x %08x %08x %08x %08x\n",
			sections[i].header.Name,
			sections[i].header.VirtualSize,
			sections[i].header.VirtualAddress,
			sections[i].header.SizeOfRawData,
			sections[i].header.PointerToRawData,
			sections[i].header.Characteristics);
	}

	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (!sections[i].Load(fModule)) {
			return false;
		}
	}

	return true;
}

FloatingPE::FloatingPE(const wchar_t *moduleName) {
	FILE *fModule; // = _wfopen_s(moduleName, L"rb");

	if (0 != _wfopen_s(&fModule, moduleName, L"rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}

FloatingPE::FloatingPE(const char *moduleName) {
	FILE *fModule; // = fopen(moduleName, "rb");

	if (0 != fopen_s(&fModule, moduleName, "rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}


FloatingPE::~FloatingPE() {
	//TODO: regular cleanup
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		sections[i].Unload();
	}
}

bool FloatingPE::MapPE(AbstractPEMapper &mapr, DWORD &baseAddr) {
	
	
	FixImports(mapr);
    
	
	DWORD maxAddr = 0;
	for (DWORD i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFF) & (~0xFFF);
		if (maxSec > maxAddr) {
			maxAddr = maxSec;
		}
	}
	

	baseAddr = (DWORD)mapr.CreateSection((void *)(baseAddr), maxAddr, PAGE_READWRITE);
	if (0 == baseAddr) {
		return false;
	}


	Relocate(baseAddr);

	//#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
	//#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
	//#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
	static const DWORD pVec[] = {
		PAGE_NOACCESS,
		PAGE_EXECUTE,
		PAGE_READONLY,
		PAGE_EXECUTE_READ,

		PAGE_READWRITE, // should be write only
		PAGE_EXECUTE_READWRITE, // should be execute write
		PAGE_READWRITE,
		PAGE_EXECUTE_READWRITE
	};

    for (unsigned int i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		if (sections[i].header.SizeOfRawData) {
			if (!mapr.WriteBytes((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].data, sections[i].header.SizeOfRawData)) {
				return false;
			}
		}

		DWORD protect = pVec[sections[i].header.Characteristics >> 29]; // get the three most significant bytes
		if (!mapr.ChangeProtect((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].header.VirtualSize, protect)) {
			return false;
		}
		
    }

	return true;
}

bool PESection::Load(FILE *fModule) {
    data = new unsigned char[header.SizeOfRawData];

    fseek(fModule, header.PointerToRawData, SEEK_SET);
    if (header.SizeOfRawData != fread(data, 1, header.SizeOfRawData, fModule)) {
        dbg_log("read error, in section %s\n", header.Name);
        return false;
    }

    return true;
}

void PESection::Unload() {
    if (data) {
        delete [] data;
    }
}

#ifdef DONOTPRINT
#undef dbg_log
#endif

















```

`loader.test/Loader/PE.ldr.h`:

```h
#ifndef _PE_LDR_H_
#define _PE_LDR_H_

#include <vector>
using namespace std;

#include "Types.h"
#include "Abstract.Mapper.h"


struct ImageSectionHeader {
    BYTE    Name[8];
    DWORD   VirtualSize;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
};

struct ImageDosHeader {  // DOS .EXE header
    USHORT e_magic;         // Magic number
    USHORT e_cblp;          // Bytes on last page of file
    USHORT e_cp;            // Pages in file
    USHORT e_crlc;          // Relocations
    USHORT e_cparhdr;       // Size of header in paragraphs
    USHORT e_minalloc;      // Minimum extra paragraphs needed
    USHORT e_maxalloc;      // Maximum extra paragraphs needed
    USHORT e_ss;            // Initial (relative) SS value
    USHORT e_sp;            // Initial SP value
    USHORT e_csum;          // Checksum
    USHORT e_ip;            // Initial IP value
    USHORT e_cs;            // Initial (relative) CS value
    USHORT e_lfarlc;        // File address of relocation table
    USHORT e_ovno;          // Overlay number
    USHORT e_res[4];        // Reserved words
    USHORT e_oemid;         // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;       // OEM information; e_oemid specific
    USHORT e_res2[10];      // Reserved words
    LONG   e_lfanew;        // File address of new exe header
};

struct ImagePeHeader {
    DWORD   PeSignature;
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
};

struct ImageDataDirectory {
    DWORD   VirtualAddress;
    DWORD   Size;
};

#pragma pack (push, 1)
struct ImageOptionalHeader {
	struct {
		WORD    Magic;
		BYTE    MajorLinkerVersion;
		BYTE    MinorLinkerVersion;
		DWORD   SizeOfCode;
		DWORD   SizeOfInitializedData;
		DWORD   SizeOfUninitializedData;
		DWORD   AddressOfEntryPoint;
		DWORD   BaseOfCode;
	} c;

	union {
		struct {
			DWORD   BaseOfData;
			DWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			DWORD   SizeOfStackReserve;
			DWORD   SizeOfStackCommit;
			DWORD   SizeOfHeapReserve;
			DWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w32;

		struct {
			QWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			QWORD   SizeOfStackReserve;
			QWORD   SizeOfStackCommit;
			QWORD   SizeOfHeapReserve;
			QWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w64;
	};   
};
#pragma pack (pop)

class PESection {
public :
	ImageSectionHeader header;
	unsigned char *data;

	bool Load(FILE *fModule);
	void Unload();
};

class FloatingPE {
private :
	bool isValid;

	ImageDosHeader dosHdr;
	ImagePeHeader peHdr;
	ImageOptionalHeader optHdr;

	vector<PESection> sections;

	void *RVA(DWORD rva) const;
	bool LoadPE(FILE *fModule);

public :
	FloatingPE(const char *moduleName);
	FloatingPE(const wchar_t *moduleName);
	~FloatingPE();

	bool Relocate(DWORD newAddr);
	bool FixImports(AbstractPEMapper &mapper);

	bool GetExport(const char *funcName, DWORD &funcRVA) const;
	DWORD GetRequiredSize() const;
	DWORD GetSectionCount() const;
	const PESection *GetSection(DWORD dwIdx) const;

	bool MapPE(AbstractPEMapper &mapr, DWORD &baseAddr);
	
	bool IsValid() const {
		return isValid;
	}
};

#endif

```

`loader.test/Loader/Types.h`:

```h
#ifndef _TYPES_H_
#define _TYPES_H_

typedef unsigned short USHORT;
typedef long LONG;

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned long long QWORD;

#endif

```

`loader.test/Main.cpp`:

```cpp
#include "../loader/loader.h"
#include <Windows.h>
#include <stdio.h>

#include "Loader/PE.ldr.h"
#include "Loader/Mem.Mapper.h"

int main() {
	HANDLE hMapping = CreateFileMappingA(
		INVALID_HANDLE_VALUE,
		NULL,
		PAGE_EXECUTE_READWRITE,
		0,
		0x508000,
		"Global\\Mumbojumbo"
	);

	if (NULL == hMapping) {
		printf("CreateFileMapping() error %d\n", GetLastError());
	}
	
	void *map = MapViewOfFileEx(
		hMapping,
		FILE_MAP_ALL_ACCESS,
		0,
		0,
		0,
		NULL
	);

	FloatingPE fpe("revtracer.dll");
	MemMapper mpr;

	DWORD dwAddr = (DWORD)map;
	fpe.MapPE(mpr, dwAddr);
	
	
	ldr::LoaderConfig *lCfg = &ldr::loaderConfig;
	wcscpy_s(lCfg->sharedMemoryName, L"Global\\Mumbojumbo");
	lCfg->mappingAddress = (ldr::ADDR_TYPE)(dwAddr + 0x1000000);
	lCfg->entryPoint = 0;

	ldr::LoaderAPI *lAPI = &ldr::loaderAPI;
	HMODULE hNtDll = GetModuleHandle("ntdll.dll");
	lAPI->ntOpenSection = GetProcAddress(hNtDll, "NtOpenSection");
	lAPI->ntMapViewOfSection = GetProcAddress(hNtDll, "NtMapViewOfSection");

	lAPI->ntOpenDirectoryObject = GetProcAddress(hNtDll, "NtOpenDirectoryObject");
	lAPI->ntClose = GetProcAddress(hNtDll, "NtClose");

	lAPI->rtlInitUnicodeStringEx = GetProcAddress(hNtDll, "RtlInitUnicodeStringEx");
	lAPI->rtlFreeUnicodeString = GetProcAddress(hNtDll, "RtlFreeUnicodeString");

	ldr::LoaderPerform();

	

	UnmapViewOfFile(map);
	CloseHandle(hMapping);

	return 0;
}
```

`loader.test/loader.test.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F35BBAE1-D0DA-421C-8652-8C5A45B98BC3}</ProjectGuid>
    <RootNamespace>loadertest</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>loader.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>loader.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Loader\Inproc.Mapper.cpp" />
    <ClCompile Include="Loader\Mem.Mapper.cpp" />
    <ClCompile Include="Loader\PE.ldr.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Loader\Abstract.Mapper.h" />
    <ClInclude Include="Loader\Inproc.Mapper.h" />
    <ClInclude Include="Loader\Mem.Mapper.h" />
    <ClInclude Include="Loader\PE.ldr.h" />
    <ClInclude Include="Loader\Types.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`loader/CMakeLists.txt`:

```txt
## loader CMakeLists.txt

set(LIBRARY_NAME "loader")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32 -std=c++11")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS}")
set(CMAKE_CXX_FLAGS_DEGUB "-g ${CMAKE_CXX_FLAGS}")

set(CMAKE_ASM_COMPILER as)
set(CMAKE_ASM_FLAGS "--32")
set(CMAKE_ASM_FLAGS_RELEASE "${CMAKE_ASM_FLAGS}")
set(CMAKE_ASM_FLAGS_DEBUG "-g ${CMAKE_ASM_FLAGS}")

add_library(${LIBRARY_NAME} SHARED
	Loader.Linux.cpp
	Loader.Linux.Stub.S
	)

target_link_libraries(${LIBRARY_NAME}
	rt
	dl
	)

# disable -${LIBRARY_NAME}_EXPORTS
set_target_properties(${LIBRARY_NAME}
	PROPERTIES
	DEFINE_SYMBOL ""
	)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`loader/Loader.Linux.Stub.S`:

```S
.intel_syntax noprefix
.global shadowStack
.global loaderConfig
.global LoaderInit

.section .init
	xchg esp, shadowStack
	pusha
	pushf
	
	lea eax, jumphere
	push eax
	call LoaderInit
	add esp, 4
	
	popf
	popa
	xchg esp, shadowStack
	jmp [loaderConfig + 8]
jumphere:

```

`loader/Loader.Linux.cpp`:

```cpp
#ifdef __linux__
#include "Loader.h"
#include <sys/mman.h>
#include <sys/stat.h>        /* For mode constants */
#include <asm/ldt.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <errno.h>
#include <link.h>

#include <vector>
#include <string>

#define DEBUG_BREAK asm volatile("int $0x3")

namespace ldr {

#define LIB_IPC_INDEX 0
#define LIB_PTHREAD_INDEX 1
#define LIB_REV_WRAPPER_INDEX 2
#define LIB_REVTRACER_INDEX 3
#define __NR_get_thread_area 244

typedef int(*RevWrapperInitCallback)(DWORD, DWORD);
typedef void *(*CallMapMemoryCallback)(unsigned long mapHandler, unsigned long access, unsigned long offset, unsigned long size, void *address);

//static void loaderInit(void) __attribute__((constructor));
static void destroy(void) __attribute__((destructor));

//struct LoaderAPI loaderAPI;
LoaderConfig loaderConfig;

// Do not use library dependent code here!
void *MapMemory(unsigned long access, unsigned long offset, unsigned long size, void *address) {
	//return mapMemory(loaderConfig.sharedMemory, access, offset, size, address);

	return mmap(address, size, access, MAP_SHARED, loaderConfig.sharedMemory, offset);
}

unsigned long FindFreeVirtualMemory(int shmFd, DWORD size) {
	void *addr = mmap(0, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, shmFd, 0);

	if (MAP_FAILED == addr) {
		printf("[Child] Couldn't find free virtual memory; errno %d\n", errno);
		return (unsigned long)addr;
	}

	munmap(addr, size);
	return (unsigned long)addr;
}

void InitSegmentDescriptors() {

	struct user_desc* table_entry_ptr = NULL;

	table_entry_ptr = (struct user_desc*)malloc(sizeof(struct user_desc));

	// segments max size if 0xff, so index max is 0x1f
	for (int index = 0; index < 0x1f; ++index) {
		table_entry_ptr->entry_number = index;
		int ret = syscall( __NR_get_thread_area,
				table_entry_ptr);
		// if entry number is not available
		unsigned value = 0x0;
		if (ret == -1 && errno != EINVAL) {
			printf("[Child]Error found when get_thread_area. errno %d\n", errno);
		} else if (ret == 0) {
			value = table_entry_ptr->base_addr;
		}

		for (int j = 0; j < 8; ++j) {
			WORD segmentvalue = (index << 3) | j;
			// bit #2 specifies LDT(set) or GDT(unset)
			if (j & 0x4) {
				loaderConfig.osData.linux.segments[segmentvalue] = 0xffffffff;
			} else {
				loaderConfig.osData.linux.segments[segmentvalue] = value;
			}
		}
	}
	free(table_entry_ptr);
}

int  InitializeAllocator() {
	loaderConfig.sharedMemory = shm_open("/thug_life", O_CREAT | O_RDWR | O_TRUNC | O_EXCL, 0644);
	if (loaderConfig.sharedMemory < 0) {
		printf("[Child] Could not allocate shared memory chunk. Exiting.\n");
		return -1;
	}

	int ret = ftruncate(loaderConfig.sharedMemory, 1 << 30);
	return loaderConfig.sharedMemory;
}

static int FindDependencies(struct dl_phdr_info *info, size_t size, void *data) {
	ext::LibraryLayout *libs = (ext::LibraryLayout *)data;
	//printf("[Child] module name=\"%s\" @ %08x\n", info->dlpi_name, info->dlpi_addr);

	const char *p = strrchr(info->dlpi_name, '/');
	p = (nullptr == p) ? info->dlpi_name : (p + 1);

	if (0 == strncmp("libc.so", p, 7)) {
		printf("Found libc @ %08x\n", info->dlpi_addr);
		libs->linLib.libcBase = info->dlpi_addr;
	} else if (0 == strncmp("librt.so", p, 8)) {
		printf("Found librt @ %08x\n", info->dlpi_addr); 
		libs->linLib.librtBase = info->dlpi_addr;
	} else if(0 == strncmp("libpthread.so", p, 13)) {
		printf("Found libpthread @ %08x\n", info->dlpi_addr);
		libs->linLib.libpthreadBase = info->dlpi_addr;
	}

	return 0;
}


unsigned long MapSharedLibraries(int shmFd) {
	//
	// Libs are mapped in the following order:
	//  librevwrapper | libipc | revtracer
	//

	std::vector<std::string> libNames = { "librevtracerwrapper.so", "libipc.so", "revtracer.dll"};

	for (int i = 0; i < libNames.size(); ++i) {
		CreateModule(libNames[i].c_str(), loaderConfig.osData.linux.mos[i].module);
		if (!loaderConfig.osData.linux.mos[i].module) {
			printf("[Child] Could not map %s lib in shm\n", libNames[i].c_str());
			return -1;
		}
		loaderConfig.osData.linux.mos[i].base = 0x0;
	}

	DWORD dwTotalSize = 0;
	for (int i = 0; i < libNames.size(); ++i) {
		loaderConfig.osData.linux.mos[i].size = (loaderConfig.osData.linux.mos[i].module->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
		dwTotalSize += loaderConfig.osData.linux.mos[i].size;
	}

	loaderConfig.osData.linux.mos[0].base = FindFreeVirtualMemory(shmFd, 1 << 30);
	printf("[Child] Mapped shared memory base address @%08lx\n", loaderConfig.osData.linux.mos[0].base);

	for (int i = 1; i < libNames.size(); ++i) {
		loaderConfig.osData.linux.mos[i].base = loaderConfig.osData.linux.mos[i - 1].base + loaderConfig.osData.linux.mos[i - 1].size;
	}

	DWORD offset = 0;
	for (int i = 0; i < libNames.size(); ++i) {
		bool callConstructors = false;
		if (libNames[i].compare("libpthread.so") == 0)
			callConstructors = true;

		MapModule(loaderConfig.osData.linux.mos[i].module, loaderConfig.osData.linux.mos[i].base, callConstructors, shmFd, offset);
		offset += loaderConfig.osData.linux.mos[i].size;
	}

	assert(offset == dwTotalSize);

	for (int i = 0; i < libNames.size(); ++i) {
		printf("[Child] Mapped library %s at address %08lx\n", libNames[i].c_str(), (DWORD)loaderConfig.osData.linux.mos[i].base);
	}

	loaderConfig.shmBase = (ADDR_TYPE)loaderConfig.osData.linux.mos[0].base;

	// Control is haded back to the parent
	// The parent uses loaderConfig.shmBase to load the so's, and fix all dependencies
	// The parent also sets loaderImports.libraries (a private address equal in both processes)
	DEBUG_BREAK;

	if (MAP_FAILED == mmap(loaderImports.libraries, sizeof(*loaderImports.libraries), PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0)) {
		printf("[Child] Couldn't map loaderImports.libraries; errno %d\n", errno);
	}

	dl_iterate_phdr(FindDependencies, loaderImports.libraries);

	/*RevWrapperInitCallback initRevWrapper;
	LoadExportedName(loaderConfig.osData.linux.mos[LIB_REV_WRAPPER_INDEX].module, loaderConfig.osData.linux.mos[LIB_REV_WRAPPER_INDEX].base, "InitRevtracerWrapper", initRevWrapper);
	printf("[Child] Found initRevWrapper address @%p\n", (void *)initRevWrapper);
	if (initRevWrapper(0, loaderConfig.osData.linux.mos[LIB_PTHREAD_INDEX].base) == -1) {
		printf("[Child] Could not find revwrapper needed libraries\n");
		return 0x0;
	} else {
		printf("[Child] Revwrapper init returned successfully\n");
	}

	LoadExportedName(loaderConfig.osData.linux.mos[LIB_REV_WRAPPER_INDEX].module, loaderConfig.osData.linux.mos[LIB_REV_WRAPPER_INDEX].base, "CallMapMemoryHandler", mapMemory);
	printf("[Child] Found mapMemory handler at address %08lx\n", (unsigned long)mapMemory);*/
	return loaderConfig.osData.linux.mos[LIB_IPC_INDEX].base;
}

extern "C" {
	DWORD miniStack[65536];
	DWORD shadowStack = (DWORD)&(miniStack[65532]);


	void LoaderInit(ADDR_TYPE jumpAddr) {
		loaderConfig.osData.linux.retAddr = jumpAddr;
		InitializeAllocator();
		MapSharedLibraries(loaderConfig.sharedMemory);
		InitSegmentDescriptors();

		//entryPoint = Returnaddres();
		//__asm int 3;

		if ((int)loaderConfig.shmBase == -1) {
			printf("[Child] Failed to map the shared mem\n");
		}
		printf("[Child] Shared mem address is %p. Fd is [%ld]\n", (void*)loaderConfig.shmBase, loaderConfig.sharedMemory);
		//fflush(stdout);

		// TODO check if disable sse is still needed
		// cleanup done in this commit
	}
};

/*void init() {
	
	__asm__(
		"xchgl %0, %%esp             \n\t"
		"pushal                      \n\t"
		"pushfl                      \n\t"
		"call %P1                    \n\t"
		"popfl                       \n\t"
		"popal                       \n\t"
		"xchgl %0, %%esp" : : "m" (shadowStack), "i" (LoaderInit)
	);
	__asm__(
		"jmp *%0" : : "m" (loaderConfig.entryPoint)
	);
}*/

void destroy() {
	shm_unlink("/thug_life");
}

LoaderImports loaderImports;

LoaderExports loaderExports = {
	MapMemory,
	nullptr
};

}; //namespace ldr


#endif

```

`loader/Loader.Windows.cpp`:

```cpp
#include "loader.h"

#include "../BinLoader/Types.h"

namespace ldr {

#define CALL_API(LIB, FUNC, TYPE) ((TYPE)((unsigned char *)ldr::loaderImports.libraries->winLib.##LIB##Base + ldr::loaderImports.functions.winFunc.##LIB##.##FUNC))

	/* Kernel32.dll replacements *********************************************************/

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

#define TRUE  1
#define FALSE 0

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define FILE_MAP_COPY       0x00000001
#define FILE_MAP_RESERVE    0x80000000

#define SECTION_QUERY                0x0001
#define SECTION_MAP_WRITE            0x0002
#define SECTION_MAP_READ             0x0004
#define SECTION_MAP_EXECUTE          0x0008
#define SECTION_EXTEND_SIZE          0x0010
#define SECTION_MAP_EXECUTE_EXPLICIT 0x0020 // not included in SECTION_ALL_ACCESS

#define SECTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|\
	SECTION_MAP_WRITE | \
	SECTION_MAP_READ | \
	SECTION_MAP_EXECUTE | \
	SECTION_EXTEND_SIZE)

#define FILE_MAP_WRITE      SECTION_MAP_WRITE
#define FILE_MAP_READ       SECTION_MAP_READ
#define FILE_MAP_ALL_ACCESS SECTION_ALL_ACCESS
#define FILE_MAP_EXECUTE    SECTION_MAP_EXECUTE_EXPLICIT

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     
#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     
#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400


	typedef int BOOL;
	typedef void *LPVOID;
	typedef long NTSTATUS;
	typedef void *HANDLE;
	typedef void *PVOID;
	typedef unsigned long ULONG;
	typedef long LONG;
	typedef long long LONGLONG;
	typedef DWORD ACCESS_MASK;
	typedef unsigned short USHORT;
	typedef wchar_t *PWSTR;
	typedef const wchar_t *PCWSTR;
	typedef unsigned long ULONG, *PULONG;
	typedef SIZE_T *PSIZE_T;


#define MEM_DECOMMIT	0x4000
#define MEM_RELEASE		0x8000

	typedef void (*FreeMemoryCall)(void *);
	typedef void *(*MapMemoryCall)(void *, unsigned long, unsigned long, unsigned long, void *);
	typedef void (*FlushInstructionCacheCall)(void);


	// ------------------- Memory mapping -------------------------

	typedef union _LARGE_INTEGER {
		struct {
			DWORD LowPart;
			LONG HighPart;
		};
		LONGLONG QuadPart;
	} LARGE_INTEGER, *PLARGE_INTEGER;

	typedef enum _SECTION_INHERIT {
		ViewShare = 1,
		ViewUnmap = 2
	} SECTION_INHERIT, *PSECTION_INHERIT;

	typedef NTSTATUS(*MapMemoryHandler) (
		HANDLE          SectionHandle,
		HANDLE          ProcessHandle,
		PVOID           *BaseAddress,
		ULONG_PTR       ZeroBits,
		SIZE_T          CommitSize,
		PLARGE_INTEGER  SectionOffset,
		PSIZE_T         ViewSize,
		SECTION_INHERIT InheritDisposition,
		ULONG           AllocationType,
		ULONG           Win32Protect
		);

	LPVOID Kernel32MapViewOfFileEx(
		HANDLE hFileMappingObject,
		DWORD dwDesiredAccess,
		DWORD dwFileOffsetHigh,
		DWORD dwFileOffsetLow,
		SIZE_T dwNumberOfBytesToMap,
		LPVOID lpBaseAddress
	) {
		NTSTATUS Status;
		LARGE_INTEGER SectionOffset;
		SIZE_T ViewSize;
		ULONG Protect;
		LPVOID ViewBase;

		/* Convert the offset */
		SectionOffset.LowPart = dwFileOffsetLow;
		SectionOffset.HighPart = dwFileOffsetHigh;

		/* Save the size and base */
		ViewBase = lpBaseAddress;
		ViewSize = dwNumberOfBytesToMap;

		/* Convert flags to NT Protection Attributes */
		if (dwDesiredAccess == FILE_MAP_COPY) {
			Protect = PAGE_WRITECOPY;
		}
		else if (dwDesiredAccess & FILE_MAP_WRITE) {
			Protect = (dwDesiredAccess & FILE_MAP_EXECUTE) ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
		}
		else if (dwDesiredAccess & FILE_MAP_READ) {
			Protect = (dwDesiredAccess & FILE_MAP_EXECUTE) ? PAGE_EXECUTE_READ : PAGE_READONLY;
		}
		else {
			Protect = PAGE_NOACCESS;
		}

		/* Map the section */
		Status = CALL_API(ntdll, _ntMapViewOfSection, MapMemoryHandler) (
			hFileMappingObject,
			(HANDLE)0xFFFFFFFF,
			&ViewBase,
			0,
			0,
			&SectionOffset,
			&ViewSize,
			ViewShare,
			0,
			Protect
		);

		if (!NT_SUCCESS(Status)) {
			/* We failed */
			__asm int 3;
			return NULL;
		}

		/* Return the base */
		return ViewBase;
	}

	void *WinMapMemory(unsigned long mapHandler, unsigned long access, unsigned long offset, unsigned long size, void *address) {
		return Kernel32MapViewOfFileEx(
			(void *)mapHandler,
			access,
			0,
			offset,
			size,
			address
		);
	}

	typedef NTSTATUS(*NtFreeVirtualMemoryFunc)(
		HANDLE ProcessHandle,
		PVOID *BaseAddress,
		PULONG RegionSize,
		ULONG FreeType
	);

	BOOL Kernel32VirtualFreeEx(
		HANDLE hProcess,
		LPVOID lpAddress,
		SIZE_T dwSize,
		DWORD  dwFreeType
	) {
		NTSTATUS ret;

		if ((unsigned __int16)(dwFreeType & 0x8000) && dwSize) {
			return FALSE;
		}
		else {
			ret = CALL_API(ntdll, _ntFreeVirtualMemory, NtFreeVirtualMemoryFunc) (hProcess, &lpAddress, (PULONG)&dwSize, dwFreeType);
				
			if (ret >= 0) {
				return TRUE;
			}

			return false;

			/*if ((0xC0000045 == ret) && ((HANDLE)0xFFFFFFFF == hProcess)) {
				if (FALSE == ((RtlFlushSecureMemoryCacheFunc)loaderAPI.rtlFlushSecureMemoryCache)(lpAddress, dwSize)) {
					return FALSE;
				}
				ret = ((NtFreeVirtualMemoryFunc)loaderAPI.ntFreeVirtualMemory)((HANDLE)0xFFFFFFFF, &lpAddress, (PULONG)&dwSize, dwFreeType);
				return (ret >= 0) ? TRUE : FALSE;
			}
			else {
				return FALSE;
			}*/
		}
	}


	LoaderConfig loaderConfig = {
		nullptr,
		0
	};

	LoaderImports loaderImports = {
		nullptr
	};

	DWORD miniStack[512];
	DWORD shadowStack = (DWORD)&(miniStack[510]);
	HANDLE hMap = NULL;

						
	//DLL_LOADER_PUBLIC void *MapMemory(DWORD desiredAccess, DWORD offset, SIZE_T size, LPVOID address) {
	void *MapMemory(unsigned long access, unsigned long offset, unsigned long size, void *address) {
		return Kernel32MapViewOfFileEx(hMap, access, 0, offset, size, address);
	}
	
	void SimulateDebugger() {
		__asm mov eax, fs:[0x18];
		__asm mov eax, [eax + 0x30];

		// eax is PEB

		// set is debugger present
		__asm mov byte ptr[eax + 0x02], 1;
		// set debug flags for heap
		__asm and dword ptr[eax + 0x68], 0x70;
	}

	void CppLoaderPerform() {
		hMap = loaderConfig.sharedMemory;

		SimulateDebugger();

		Kernel32VirtualFreeEx(
			(HANDLE)0xFFFFFFFF,
			loaderConfig.shmBase,
			0,
			MEM_RELEASE
		);
		
		for (DWORD s = 0; s < loaderConfig.osData.windows.sectionCount; ++s) {
			void *addr = MapMemory(
				loaderConfig.osData.windows.sections[s].desiredAccess,
				loaderConfig.osData.windows.sections[s].sectionOffset,
				(SIZE_T)loaderConfig.osData.windows.sections[s].mappingSize,
				loaderConfig.osData.windows.sections[s].mappingAddress
			);

			if (addr != loaderConfig.osData.windows.sections[s].mappingAddress) {
				__asm int 3;
			}
		}

		CALL_API(ntdll, _ntFlushInstructionCache, FlushInstructionCacheCall) ();
	}

	__declspec(naked) void LoaderPerform() {
		__asm {
			xchg esp, shadowStack;
			pushad;
			pushfd;
			call CppLoaderPerform;
			popfd;
			popad;
			xchg esp, shadowStack;
			jmp dword ptr[loaderConfig.entryPoint];
		}
	}


	LoaderExports loaderExports = {
		MapMemory,
		LoaderPerform
	};
};

unsigned int Entry() { 
	return 1;
}

```

`loader/Loader.h`:

```h
#ifndef _LOADER_H
#define _LOADER_H

#include "../BinLoader/LoaderAPI.h"
#include "../CommonCrossPlatform/LibraryLayout.h"

namespace ldr {
#if defined _WIN32 || defined __CYGWIN__
	#ifdef _BUILDING_LOADER_DLL
		#ifdef __GNUC__
			#define DLL_LOADER_PUBLIC __attribute__ ((dllexport))
		#else
			#define DLL_LOADER_PUBLIC __declspec(dllexport)
		#endif
	#else
		#ifdef __GNUC__
			#define DLL_LOADER_PUBLIC __attribute__ ((dllimport))
		#else
			#define DLL_LOADER_PUBLIC __declspec(dllimport)
		#endif
	#endif
	#define DLL_LOADER_LOCAL
#else
	#if __GNUC__ >= 4
		#define DLL_LOADER_PUBLIC __attribute__ ((visibility ("default")))
		#define DLL_LOADER_LOCAL  __attribute__ ((visibility ("hidden")))
	#else
		#define DLL_LOADER_PUBLIC
		#define DLL_LOADER_LOCAL
	#endif
#endif

/* Define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif  /* __cplusplus */
#endif  /* NULL */

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86) || defined(_ARM_) || defined(_M_ARM)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#if defined(_WIN64)
	typedef __int64 INT_PTR, *PINT_PTR;
	typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

	typedef __int64 LONG_PTR, *PLONG_PTR;
	typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

#define __int3264   __int64

#else
	typedef _W64 int INT_PTR, *PINT_PTR;
	typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

	typedef _W64 long LONG_PTR, *PLONG_PTR;
	typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

#define __int3264   __int32

#endif

	typedef unsigned long long QWORD;
	typedef unsigned long DWORD;
	typedef unsigned short WORD;
	typedef unsigned char BYTE;
	//typedef unsigned int SIZE_T;

	typedef void *ADDR_TYPE;

#if defined _WIN32 || defined __CYGWIN__
	typedef void *SHM_HANDLE;
#else
	typedef unsigned long SHM_HANDLE;
#endif

#define MAX_LIBS 0x10
#define MAX_SEGMENTS 0x100

	struct PESections {
		ADDR_TYPE mappingAddress;
		DWORD     mappingSize;
		DWORD     sectionOffset;
		DWORD     desiredAccess;
	};

	struct LoaderConfig {
		SHM_HANDLE sharedMemory;
		ADDR_TYPE shmBase;
		ADDR_TYPE entryPoint;

		union {
			struct {
				PESections sections[32];
				DWORD sectionCount;
			} windows;

			struct {
				ADDR_TYPE retAddr;
				MappedObject mos[MAX_LIBS];
				DWORD segments[MAX_SEGMENTS];
			} linux;
		} osData;
	};

#define MAX_LIBS 0x10
#define MAX_SEGMENTS 0x100

	struct LoaderImports {
		ext::LibraryLayout *libraries;

		union {
			struct {
				struct {
					unsigned int dummy;
				} libc;
			} linFunc;

			struct {
				struct {
					unsigned int _ntMapViewOfSection;
					unsigned int _ntFlushInstructionCache;
					unsigned int _ntFreeVirtualMemory;
				} ntdll;
			} winFunc;
		} functions;
		

		//unsigned long sharedMemoryAddress;
		//MappedObject mos[MAX_LIBS];
		//DWORD segments[MAX_SEGMENTS];
	};

	typedef void *(*MapMemoryFunc)(unsigned long access, unsigned long offset, unsigned long size, void *address);
	typedef void (*PerformFunc)();

	struct LoaderExports {
		MapMemoryFunc mapMemory;
		PerformFunc perform;
	};

	extern "C" {
		DLL_LOADER_PUBLIC extern LoaderConfig loaderConfig;
		DLL_LOADER_PUBLIC extern LoaderImports loaderImports;
		DLL_LOADER_PUBLIC extern LoaderExports loaderExports;
	};

};


#endif

```

`loader/Main.cpp`:

```cpp
#include <stdio.h>
extern void init(void);
int main() {
	init();
	printf("I am the traced process!\n");
}

```

`loader/Makefile`:

```
mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
makefile_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

lib_loader := libloader.so
CC := gcc
CXX := g++
AS := as

CPP_FILES := Loader.Linux.cpp
AS_FILES := Loader.Linux.Stub.S
OBJ_FILES := Loader.Linux.o Loader.Linux.Stub.o 
CC_FLAGS += -m32 -std=c++11
AS_FLAGS += --32
LIB_BINLOADER_PATH := ../BinLoader/libbinloader.a
LD_FLAGS := -lrt -ldl
LD_PATHS :=

prefix := /usr/local

all: $(lib_loader)

test: all
	g++ $(CC_FLAGS) -L. Main.cpp -o test -lloader

run-test: test
	LD_PRELOAD=$(lib_loader) ./test

install: $(lib_loader)
	install -m 0755 $(lib_loader) -t $(prefix)/lib -D

$(lib_loader): $(OBJ_FILES)
	$(CXX) $(CC_FLAGS) $(LD_PATHS) -shared -o $@ $^ $(LIB_BINLOADER_PATH) $(LD_FLAGS)

%.o: %.cpp
	$(CXX) $(CC_FLAGS) -c -o $@ $<

%.o: %.S
	$(AS) $(AS_FLAGS) -o $@ $<

.PHONY: clean
clean:
	$(RM) $(lib_loader) $(OBJ_FILES) test

```

`loader/loader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A04D7B87-303A-422A-8E6B-63DC92B11663}</ProjectGuid>
    <RootNamespace>loader</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_BUILDING_LOADER_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>Entry</EntryPointSymbol>
      <SubSystem>Console</SubSystem>
      <SectionAlignment>65536</SectionAlignment>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetDir)$(TargetFileName) $(SolutionDir)jsdemo\
copy $(TargetDir)$(ProjectName).pdb $(SolutionDir)jsdemo\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_BUILDING_LOADER_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Console</SubSystem>
      <EntryPointSymbol>Entry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Loader.Linux.cpp" />
    <ClCompile Include="Loader.Windows.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Loader.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Loader.Linux.Stub.S" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`makeSDK.bat`:

```bat
md %1
md %1\include

md %1\include\CommonCrossPlatform
copy CommonCrossPlatform\Common.h %1\include\CommonCrossPlatform
copy CommonCrossPlatform\BasicTypes.h %1\include\CommonCrossPlatform

md %1\include\Execution
copy Execution\Execution.h %1\include\Execution

md %1\include\revtracer
copy revtracer\common.h %1\include\revtracer
copy revtracer\DebugPrintFlags.h %1\include\revtracer
copy revtracer\environment.h %1\include\revtracer
copy revtracer\revtracer.h %1\include\revtracer
copy revtracer\river.h %1\include\revtracer
copy revtracer\RiverAddress.h %1\include\revtracer

md %1\include\SymbolicEnvironment
copy SymbolicEnvironment\Environment.h %1\include\SymbolicEnvironment
copy SymbolicEnvironment\LargeStack.h %1\include\SymbolicEnvironment
copy SymbolicEnvironment\SymbolicEnvironment.h %1\include\SymbolicEnvironment

md %1\win
md %1\win\lib
copy Debug\Execution.lib %1\win\lib
copy Debug\SymbolicEnvironment.lib %1\win\lib

md %1\win\bin
copy Debug\revtracer.dll %1\win\bin
copy Debug\revtracer.pdb %1\win\bin
copy Debug\revtracer-wrapper.dll %1\win\bin
copy Debug\revtracer-wrapper.pdb %1\win\bin
copy Debug\Execution.dll %1\win\bin
copy Debug\Execution.pdb %1\win\bin
copy Debug\SymbolicEnvironment.dll %1\win\bin
copy Debug\SymbolicEnvironment.pdb %1\win\bin
```

`makeSDK.sh`:

```sh
#!/usr/bin/env bash

[ $# -ne 2 ] && { echo "Usage: $0 <cmake-build-path> <dst>"; exit 1; }

if [ ! -d $1 ]; then
	echo "Src dir: $1 does not exist. Pass the build directory of river"
	exit 1;
fi

if [ -d $2 ]; then
	echo "Dst dir exists! Pass a non-existing destination dir"
	exit 1;
fi

mkdir $2
mkdir $1/include

mkdir $1/include/CommonCrossPlatform
cp CommonCrossPlatform/Common.h $1/include/CommonCrossPlatform
cp CommonCrossPlatform/BasicTypes.h $1/include/CommonCrossPlatform

mkdir $1/include/Execution
cp Execution/Execution.h $1/include/Execution

mkdir $1/include/revtracer
cp revtracer/common.h $1/include/revtracer
cp revtracer/DebugPrintFlags.h $1/include/revtracer
cp revtracer/environment.h $1/include/revtracer
cp revtracer/revtracer.h $1/include/revtracer
cp revtracer/river.h $1/include/revtracer
cp revtracer/RiverAddress.h $1/include/revtracer

mkdir $1/include/SymbolicEnvironment
cp SymbolicEnvironment/Environment.h $1/include/SymbolicEnvironment
cp SymbolicEnvironment/LargeStack.h $1/include/SymbolicEnvironment
cp SymbolicEnvironment/SymbolicEnvironment.h $1/include/SymbolicEnvironment

mkdir $1/lin
mkdir $1/lin/lib
cp revtracer/revtracer.dll $1/lin/lib
cp revtracer-wrapper/librevtracerwrapper.so $1/lin/lib
cp Execution/libexecution.so $1/lin/lib
cp loader/libloader.so $1/lin/lib
cp ipclib/libipc.so $1/lin/lib
cp SymbolicEnvironment/libsymbolicenvironment.so  $1/lin/lib

mkdir $1/libs
cp http-parser-payload/libhttp-parser.so $1/libs
cp freetype-payload/libfreetype.so $1/libs
cp gumbo-payload/libgumbo.so $1/libs
cp jsmn-payload/libjsmn.so $1/libs
cp libjpeg-turbo-payload/libjpeg_turbo.so $1/libs
cp libpng-payload/libpng.so $1/libs
cp libxml-payload/libxml.so $1/libs

```

`nodeaddon/binding.gyp`:

```gyp
{
    "targets": [
        {
            "target_name": "executionwrapper",
            "sources": [ "executionwrapper.cpp" ],
            "include_dirs": [
            	"../Execution",
                "<!(node -e \"require('nan')\")"
            ],
            "libraries": [
            	"-lD:/wrk/riverhg/Debug/Execution.lib",
            ]
        }
    ]
}
```

`nodeaddon/executionwrapper.cpp`:

```cpp
#ifndef BUILDING_NODE_EXTENSION
#define BUILDING_NODE_EXTENSION
#endif

#include <node.h>
#include <nan.h>
#include <node_object_wrap.h>

#include <Windows.h>

#include "../Execution/Execution.h"


using namespace v8;
//using namespace ;


class ExecutionWrapper : public node::ObjectWrap, public ExecutionObserver {
private:
    ExecutionController *controller;
	void *context;

    HANDLE hEvent;
    unsigned int result;    
    unsigned int eip;

    uv_async_t termAsync;
    uv_async_t eBeginAsync;
    uv_async_t eControlAsync;
    uv_async_t eEndAsync;


    static Persistent<Function> constructor;

    static void New(const FunctionCallbackInfo<Value> &args);

    static ExecutionWrapper *Factory();

    /*static void __stdcall TerminationNotify(void *ctx);
    static unsigned int __stdcall ExecutionBegin(void *ctx, unsigned int address);
    static unsigned int __stdcall ExecutionControl(void *ctx, unsigned int address);
    static unsigned int __stdcall ExecutionEnd(void *ctx);*/

public:
    static void Init(Local<Object> exports);

    static void GetState(const FunctionCallbackInfo<Value>& args);
    static void SetPath(const FunctionCallbackInfo<Value>& args);
    static void SetCmdLine(const FunctionCallbackInfo<Value>& args);
    static void Execute(const FunctionCallbackInfo<Value>& args);
    static void Terminate(const FunctionCallbackInfo<Value>& args);

    static void Control(const FunctionCallbackInfo<Value>& args);

    static void GetProcessVirtualMemory(const FunctionCallbackInfo<Value>& args);
    static void GetModules(const FunctionCallbackInfo<Value>& args);
    static void ReadProcessMemory(const FunctionCallbackInfo<Value>& args);

    static void SetTerminationNotification(const FunctionCallbackInfo<Value>& args);
    static void SetExecutionBeginNotification(const FunctionCallbackInfo<Value>& args);
    static void SetExecutionControlNotification(const FunctionCallbackInfo<Value>& args);
    static void SetExecutionEndNotification(const FunctionCallbackInfo<Value>& args);

    static void GetCurrentRegisters(const FunctionCallbackInfo<Value>& args);

    Persistent<Function> terminationNotification;
    Persistent<Function> executionBeginNotification;
    Persistent<Function> executionControlNotification;
    Persistent<Function> executionEndNotification;

    static void TermAsync(uv_async_t *handle);
    static void EBeginAsync(uv_async_t *handle);
    static void EControlAsync(uv_async_t *handle);
    static void EEndAsync(uv_async_t *handle);

	virtual unsigned int ExecutionBegin(void *ctx, void *address);
	virtual unsigned int ExecutionControl(void *ctx, void *address);
	virtual unsigned int ExecutionEnd(void *ctx);
	virtual void TerminationNotification(void *ctx);
};

ExecutionWrapper *ExecutionWrapper::Factory() {
    ExecutionWrapper *ret = new ExecutionWrapper();
    ret->controller = NewExecutionController(EXECUTION_EXTERNAL);

	ret->controller->SetExecutionObserver(ret);

    /*ret->controller->SetTerminationNotification(TerminationNotify);
    ret->controller->SetExecutionBeginNotification(ExecutionBegin);
    ret->controller->SetExecutionControlNotification(ExecutionControl);
    ret->controller->SetExecutionEndNotification(ExecutionEnd);*/

    uv_async_init(uv_default_loop(), &ret->termAsync, TermAsync);
    uv_async_init(uv_default_loop(), &ret->eBeginAsync, EBeginAsync);
    uv_async_init(uv_default_loop(), &ret->eControlAsync, EControlAsync);
    uv_async_init(uv_default_loop(), &ret->eEndAsync, EEndAsync);

    ret->termAsync.data = ret;
    ret->eBeginAsync.data = ret;
    ret->eControlAsync.data = ret;
    ret->eEndAsync.data = ret;

    ret->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    return ret;
}

Persistent<Function> ExecutionWrapper::constructor;

void ExecutionWrapper::New(const FunctionCallbackInfo<Value> &args) {
    //HandleScope scope;
    Isolate *isolate = args.GetIsolate();

    if (args.IsConstructCall()) {
        // Invoked as constructor: `new BdCoreObject(...)`
        //Local<String> param = args[0]->IsUndefined() ? "" : args[0]->ToString();
        //char *path = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();
        
        /*String::Utf8Value param(args[0]->ToString());
        std::string bdCoreLocation(*param);
        std::string bdPluginLocation = bdCoreLocation + "Plugins" PATH_SEP_STR;
        
        unsigned int thrCount = args[1]->Uint32Value();*/
        
        ExecutionWrapper* obj = Factory();

		/*obj->terminationNotification.Reset(isolate, Undefined(isolate));
		obj->executionBeginNotification.Reset(isolate, Undefined(isolate));
		obj->executionControlNotification.Reset(isolate, Undefined(isolate));
		obj->executionEndNotification.Reset(isolate, Undefined(isolate));*/

        obj->Wrap(args.This());
        args.GetReturnValue().Set(args.This());
        //return args.This();
    } else {
        // Invoked as plain function `BdCoreObject(...)`, turn into construct call.
        //return scope.Close(Undefined());
        args.GetReturnValue().Set(Undefined(isolate));
    }
}


// this gets called on the execution thread
void ExecutionWrapper::TerminationNotification(void *ctx) {
    uv_async_send(&termAsync);
}

// this gets called on the execution thread
unsigned int ExecutionWrapper::ExecutionBegin(void *ctx, void *address) {
	context = ctx;

    eip = (unsigned int)address;
    uv_async_send(&eBeginAsync);

    WaitForSingleObject(hEvent, INFINITE);

    return result;
}

// this gets called on the execution thread
unsigned int ExecutionWrapper::ExecutionControl(void *ctx, void *address) {
    eip = (unsigned int)address;
    uv_async_send(&eControlAsync);

    WaitForSingleObject(hEvent, INFINITE);

    return result;
}

// this gets called on the execution thread
unsigned int ExecutionWrapper::ExecutionEnd(void *ctx) {
    uv_async_send(&eEndAsync);

    WaitForSingleObject(hEvent, INFINITE);

    return result;
}

void ExecutionWrapper::Init(Local<Object> exports) {
    Isolate *isolate = exports->GetIsolate();
    // Prepare constructor template
    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
    tpl->SetClassName(String::NewFromUtf8(isolate, "ExecutionWrapper"));
    tpl->InstanceTemplate()->SetInternalFieldCount(1); // TODO: replace with internal field count
    
    
    // Prototype
    NODE_SET_PROTOTYPE_METHOD(tpl, "GetState",   GetState);
    NODE_SET_PROTOTYPE_METHOD(tpl, "SetPath",    SetPath);
    NODE_SET_PROTOTYPE_METHOD(tpl, "SetCmdLine", SetCmdLine);
    NODE_SET_PROTOTYPE_METHOD(tpl, "Execute",    Execute);
    NODE_SET_PROTOTYPE_METHOD(tpl, "Terminate",  Terminate);

    NODE_SET_PROTOTYPE_METHOD(tpl, "Control",    Control);

    NODE_SET_PROTOTYPE_METHOD(tpl, "GetProcessVirtualMemory", GetProcessVirtualMemory);
    NODE_SET_PROTOTYPE_METHOD(tpl, "GetModules", GetModules);
    NODE_SET_PROTOTYPE_METHOD(tpl, "ReadProcessMemory",       ReadProcessMemory);

    NODE_SET_PROTOTYPE_METHOD(tpl, "SetTerminationNotification",      SetTerminationNotification);
    NODE_SET_PROTOTYPE_METHOD(tpl, "SetExecutionBeginNotification",   SetExecutionBeginNotification);
    NODE_SET_PROTOTYPE_METHOD(tpl, "SetExecutionControlNotification", SetExecutionControlNotification);
    NODE_SET_PROTOTYPE_METHOD(tpl, "SetExecutionEndNotification",     SetExecutionEndNotification);

    NODE_SET_PROTOTYPE_METHOD(tpl, "GetCurrentRegisters",             GetCurrentRegisters);


    constructor.Reset(isolate, tpl->GetFunction());
    exports->Set(String::NewFromUtf8(isolate, "ExecutionWrapper"), tpl->GetFunction());
}


void ExecutionWrapper::GetState(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    args.GetReturnValue().Set(Number::New(isolate, _this->controller->GetState()));
}

void ExecutionWrapper::SetPath(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();
    String::Value pth(args[0]->ToString());
    wstring path((wchar_t *)*pth);

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    args.GetReturnValue().Set(
        Boolean::New(
            isolate,
            _this->controller->SetPath(
                path
            )
        )
    );
}

void ExecutionWrapper::SetCmdLine(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();
    String::Value cdl(args[0]->ToString());
    wstring cmdLine((wchar_t *)*cdl);

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    args.GetReturnValue().Set(
        Boolean::New(
            isolate,
            _this->controller->SetCmdLine(
                cmdLine
            )
        )
    );
}

void ExecutionWrapper::Execute(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    args.GetReturnValue().Set(Boolean::New(isolate, _this->controller->Execute()));
}

void ExecutionWrapper::Control(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    
    if (!args[0]->IsUint32()) {
        isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, "Wrong argument")));
        return;
    }

    _this->result = args[0]->Uint32Value();
    SetEvent(_this->hEvent);

    args.GetReturnValue().Set(Undefined(isolate));
}

void ExecutionWrapper::Terminate(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    args.GetReturnValue().Set(Boolean::New(isolate, _this->controller->WaitForTermination()));
}

void ExecutionWrapper::GetProcessVirtualMemory(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());

    VirtualMemorySection *sections = NULL;
    int count;
    if (_this->controller->GetProcessVirtualMemory(sections, count)) {
        Local<Array> arr = Array::New(isolate);

        for (int i = 0; i < count; ++i) {
            Local<Object> obj = Object::New(isolate);

            obj->Set(String::NewFromUtf8(isolate, "baseAddress"), Uint32::New(isolate, sections[i].BaseAddress));
            obj->Set(String::NewFromUtf8(isolate, "regionSize"), Uint32::New(isolate, sections[i].RegionSize));
            obj->Set(String::NewFromUtf8(isolate, "state"), Uint32::New(isolate, sections[i].State));
            obj->Set(String::NewFromUtf8(isolate, "protection"), Uint32::New(isolate, sections[i].Protection));
            obj->Set(String::NewFromUtf8(isolate, "type"), Uint32::New(isolate, sections[i].Type));

            arr->Set(i, obj);
        }

        args.GetReturnValue().Set(arr);
    } else {
        args.GetReturnValue().Set(Undefined(isolate));
    }
}

void ExecutionWrapper::GetModules(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());

    ModuleInfo *modules = NULL;
    int count;
    if (_this->controller->GetModules(modules, count)) {
        Local<Array> arr = Array::New(isolate);

        for (int i = 0; i < count; ++i) {
            Local<Object> obj = Object::New(isolate);

            obj->Set(String::NewFromUtf8(isolate, "moduleBase"), Uint32::New(isolate, modules[i].ModuleBase));
            obj->Set(String::NewFromUtf8(isolate, "size"), Uint32::New(isolate, modules[i].Size));
            obj->Set(String::NewFromUtf8(isolate, "name"), String::NewFromTwoByte(isolate, (uint16_t *)modules[i].Name));

            arr->Set(i, obj);
        }

        args.GetReturnValue().Set(arr);
    } else {
        args.GetReturnValue().Set(Undefined(isolate));
    }
}

void ExecutionWrapper::ReadProcessMemory(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    
    unsigned char *buffer;
    unsigned int base = args[0]->Uint32Value();
    unsigned int size = args[1]->Uint32Value();

    buffer = new unsigned char[size];
    if (_this->controller->ReadProcessMemory(base, size, buffer)) {
        args.GetReturnValue().Set(Nan::CopyBuffer((const char *)buffer, size).ToLocalChecked());
    } else {
        args.GetReturnValue().Set(Undefined(isolate));
    }

    delete [] buffer;
}

void ExecutionWrapper::SetTerminationNotification(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    _this->terminationNotification.Reset(isolate, Local<Function>::Cast(args[0]));

    args.GetReturnValue().Set(Undefined(isolate));
}

void ExecutionWrapper::SetExecutionBeginNotification(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    _this->executionBeginNotification.Reset(isolate, Local<Function>::Cast(args[0]));

    args.GetReturnValue().Set(Undefined(isolate));
}

void ExecutionWrapper::SetExecutionControlNotification(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    _this->executionControlNotification.Reset(isolate, Local<Function>::Cast(args[0]));

    args.GetReturnValue().Set(Undefined(isolate));
}

void ExecutionWrapper::SetExecutionEndNotification(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    _this->executionEndNotification.Reset(isolate, Local<Function>::Cast(args[0]));

    args.GetReturnValue().Set(Undefined(isolate));
}

void ExecutionWrapper::GetCurrentRegisters(const FunctionCallbackInfo<Value>& args) {
    Isolate *isolate = args.GetIsolate();

    ExecutionWrapper *_this = ObjectWrap::Unwrap<ExecutionWrapper>(args.Holder());
    
	rev::ExecutionRegs regs;
    _this->controller->GetCurrentRegisters(_this->context, &regs);
    
    Local<Object> obj = Object::New(isolate);

    obj->Set(String::NewFromUtf8(isolate, "edi"), Uint32::New(isolate, regs.edi));
    obj->Set(String::NewFromUtf8(isolate, "esi"), Uint32::New(isolate, regs.esi));
    obj->Set(String::NewFromUtf8(isolate, "ebp"), Uint32::New(isolate, regs.ebp));
    obj->Set(String::NewFromUtf8(isolate, "esp"), Uint32::New(isolate, regs.esp));

    obj->Set(String::NewFromUtf8(isolate, "ebx"), Uint32::New(isolate, regs.ebx));
    obj->Set(String::NewFromUtf8(isolate, "edx"), Uint32::New(isolate, regs.edx));
    obj->Set(String::NewFromUtf8(isolate, "ecx"), Uint32::New(isolate, regs.ecx));
    obj->Set(String::NewFromUtf8(isolate, "eax"), Uint32::New(isolate, regs.eax));

    obj->Set(String::NewFromUtf8(isolate, "eflags"), Uint32::New(isolate, regs.eflags));

    args.GetReturnValue().Set(obj);
}

void ExecutionWrapper::TermAsync(uv_async_t *handle) {
    Isolate* isolate = Isolate::GetCurrent();
    ExecutionWrapper *_this = (ExecutionWrapper *)handle->data;

	if (!_this->terminationNotification.IsEmpty()) {
		HandleScope scope(isolate);
		Local<Function> fTerm = Local<Function>::New(isolate, _this->terminationNotification);

    	if (fTerm->IsCallable()) {
    		fTerm->Call(Null(isolate), 0, NULL);
    	}
    }
}

void ExecutionWrapper::EBeginAsync(uv_async_t *handle) { 
    Isolate* isolate = Isolate::GetCurrent();
    ExecutionWrapper *_this = (ExecutionWrapper *)handle->data;

	if (!_this->executionBeginNotification.IsEmpty()) {
		HandleScope scope(isolate);
		Local<Function> eBegin = Local<Function>::New(isolate, _this->executionBeginNotification);
		if (eBegin->IsCallable()) {
            const unsigned argc = 1;
            Local<Value> argv[argc] = { Uint32::New(isolate, _this->eip) };

			Local<Value> ret = eBegin->Call(Null(isolate), argc, argv);

			if (!ret->IsUndefined()) {
				_this->result = ret->Uint32Value();
				SetEvent(_this->hEvent);
			}
		}
	}
}

void ExecutionWrapper::EControlAsync(uv_async_t *handle) { 
    Isolate* isolate = Isolate::GetCurrent();
    ExecutionWrapper *_this = (ExecutionWrapper *)handle->data;

    if (!_this->executionControlNotification.IsEmpty()) {
		HandleScope scope(isolate);
		Local<Function> eControl = Local<Function>::New(isolate, _this->executionControlNotification);

    	if (eControl->IsCallable()) {
            const unsigned argc = 1;
            Local<Value> argv[argc] = { Uint32::New(isolate, _this->eip) };

    		Local<Value> ret = eControl->Call(Null(isolate), argc, argv);

    		if (!ret->IsUndefined()) {
    			_this->result = ret->Uint32Value();
    			SetEvent(_this->hEvent);
    		}
    	}
    }
}

void ExecutionWrapper::EEndAsync(uv_async_t *handle) { 
    Isolate* isolate = Isolate::GetCurrent();
    ExecutionWrapper *_this = (ExecutionWrapper *)handle->data;

    if (!_this->executionEndNotification.IsEmpty()) {
		HandleScope scope(isolate);
		Local<Function> eEnd = Local<Function>::New(isolate, _this->executionEndNotification);
    	
		if (eEnd->IsCallable()) {
    		Local<Value> ret = eEnd->Call(Null(isolate), 0, NULL);

    		if (!ret->IsUndefined()) {
    			_this->result = ret->Uint32Value();
    			SetEvent(_this->hEvent);
    		}
    	}
    }
}

/*=========================================================================================*/

void InitAll(Handle<Object> exports) {
    ExecutionWrapper::Init(exports);
    //exports->Set(String::NewSymbol("Execution"), FunctionTemplate::New(CreateExecution)->GetFunction());
}

NODE_MODULE(executionwrapper, InitAll)




```

`nodeaddon/index.js`:

```js
var path = require("path");

var isDebug = (process.env["DEBUG"] == "true");
var modPath = isDebug 
    ? "./build/Debug/executionwrapper"
    : "./build/Release/executionwrapper";

console.log("Including: " + modPath);

module.exports = exports = require(modPath);

```

`notracer/Loader/Abstract.Mapper.h`:

```h
#ifndef _ABSTRACT_MAPPER_H_
#define _ABSTRACT_MAPPER_H_

#include "Types.h"

class AbstractPEMapper {
public:
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) = 0;

	virtual DWORD FindImport(const char *moduleName, const char *funcName) = 0;
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal) = 0;
};

#endif


```

`notracer/Loader/Inproc.Mapper.cpp`:

```cpp
#include <Windows.h>
#include "Inproc.Mapper.h"


void *InprocMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return VirtualAlloc(lpAddress, dwSize, MEM_RESERVE | MEM_COMMIT, flProtect);
}

bool InprocMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	DWORD oldProtect;
	return TRUE == VirtualProtect(lpAddress, dwSize, flProtect, &oldProtect);
}

bool InprocMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	memcpy(lpAddress, lpBuffer, nSize);
	return true;
}

DWORD InprocMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, funcName);
}

DWORD InprocMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, (LPCSTR)funcOrdinal);
}
```

`notracer/Loader/Inproc.Mapper.h`:

```h
#ifndef _INPROC_MAPPER_H_
#define _INPROC_MAPPER_H_

#include "Abstract.Mapper.h"

class InprocMapper : public AbstractPEMapper {
public :
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif
```

`notracer/Loader/PE.ldr.cpp`:

```cpp
#include <stdio.h>

#include <vector>
using namespace std;

//#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#endif

#include "PE.ldr.h"

//#include "common/debug-log.h"
#define dbg_log printf

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5
#define IMAGE_REL_BASED_RESERVED              6
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9
#define IMAGE_REL_BASED_DIR64                 10

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     

#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     

#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define PAGE_REVERT_TO_FILE_MAP     0x80000000 

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

const USHORT DOS_MAGIC = 0x5A4D;
const DWORD PE_MAGIC = 0x00004550;
const WORD OPT32_MAGIC = 0x010B;
const WORD OPT64_MAGIC = 0x020B;

const WORD IMAGE_FILE_MACHINE_I386 = 0x14C;
const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Name;
	DWORD Base;
	DWORD NumberOfFunctions;
	DWORD NumberOfNames;
	DWORD AddressOfFunctions; // RVA from base of image
	DWORD AddressOfNames; // RVA from base of image
	DWORD AddressOfNameOrdinals; // RVA from base of image
} IMAGE_EXPORT_DIRECTORY;

void *FloatingPE::RVA(DWORD rva) const {
    for (int i = 0; i < peHdr.NumberOfSections; ++i) {
        if (rva >= sections[i].header.VirtualAddress) {
            DWORD dwOffset = rva - sections[i].header.VirtualAddress;
            if (dwOffset < sections[i].header.VirtualSize) {
                return sections[i].data + dwOffset;
            }
        }
    }
    return (void *)0;
}

bool FloatingPE::Relocate(DWORD newAddr) {
	long long offset = 0;
	IMAGE_BASE_RELOCATION *reloc;
    IMAGE_BASE_RELOCATION *term;

	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			offset = newAddr - optHdr.w32.ImageBase;
			optHdr.w32.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			offset = newAddr - optHdr.w64.ImageBase;
			optHdr.w64.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

    while (reloc < term) {
        //dbg_log("Relocation Block %08x %08x", reloc->VirtualAddress, reloc->SizeOfBlock);
        WORD *wloc = (WORD *)reloc + 4;
        int wlocCount = (reloc->SizeOfBlock - sizeof(*reloc)) / sizeof(*wloc);

        for (int i = 0; i < wlocCount; ++i) {
            //dbg_log("%x %x;\t", wloc[i] >> 12, wloc[i] & 0x0FFF);
			WORD type = wloc[i] >> 12;
			WORD off = wloc[i] & 0x0FFF;
			
			if ((i % 3) == 0) {
				//dbg_log("\n");
			}
			
			switch (type) {
				case IMAGE_REL_BASED_ABSOLUTE :
					break;
				case IMAGE_REL_BASED_HIGHLOW :
					*((DWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					//dbg_log("%08x -> %08x\t", reloc->VirtualAddress + off, *((DWORD *)RVA(reloc->VirtualAddress + off)));
					break;
				case IMAGE_REL_BASED_DIR64 :
					*((QWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					break;
				default :
					//__asm int 3;
					__debugbreak();
			}
        }
		//dbg_log("\n");
		reloc = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + reloc->SizeOfBlock);
    }


    return true;
}

bool FloatingPE::GetExport(const char *funcName, DWORD &funcRVA) {
	DWORD exportRVA = 0;
	
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			exportRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			exportRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	};
	
	if (0 == exportRVA) {
		return false;
	}

	IMAGE_EXPORT_DIRECTORY *exprt = (IMAGE_EXPORT_DIRECTORY *)RVA(exportRVA);

	dbg_log("Number of functions: %d\n", exprt->NumberOfFunctions);
	dbg_log("Number of names: %d\n", exprt->NumberOfNames);

	DWORD *names = (DWORD *)RVA(exprt->AddressOfNames);
	int found = -1;
	for (DWORD i = 0; i < exprt->NumberOfNames; ++i) {
		char *name = (char *)RVA(names[i]);
		if (0 == strcmp(name, funcName)) {
			found = i;
			break;
		}
	}

	if (-1 == found) {
		return false;
	}

	WORD *ordinals = (WORD *)RVA(exprt->AddressOfNameOrdinals);
	WORD ordinal = ordinals[found] - (WORD)exprt->Base + 1;

	DWORD *exportTable = (DWORD *)RVA(exprt->AddressOfFunctions);
	funcRVA = exportTable[ordinal];

	return true;
}

bool FloatingPE::FixImports(AbstractPEMapper &mapper) {
	DWORD importRVA = 0;
	
	
	switch (peHdr.Machine) {
	case IMAGE_FILE_MACHINE_I386:
		importRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	case IMAGE_FILE_MACHINE_AMD64:
		importRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	default:
		dbg_log("Unsupported machine type\n");
		return false;
	};

	if (0 == importRVA) {
		return true;
	}

    IMAGE_IMPORT_DESCRIPTOR *import = (IMAGE_IMPORT_DESCRIPTOR *)RVA(importRVA);
	if (NULL == import) {
		return false;
	}

    while (import->OriginalFirstThunk != 0) {
		char *name = (char *)RVA(import->Name);
        dbg_log("Directory for: %s\n", name);
		dbg_log("OFT: %08x, FT: %08x\n", import->OriginalFirstThunk, import->FirstThunk);
		DWORD *funcs = (DWORD *)RVA(import->OriginalFirstThunk);
		DWORD *iat = (DWORD *)RVA(import->FirstThunk);
        while (*funcs != 0) {
            if (0x80000000 & *funcs) {
                dbg_log("Import by ordinal %d\n", *funcs & 0x7FFF);
				*iat = mapper.FindImport(name, *funcs & 0x7FFF);
            } else {
				char *funcName = (char *)RVA(*funcs + 2);
                dbg_log("Import by name %s\n", funcName);
				*iat = mapper.FindImport(name, funcName);
            }

            funcs += 1;
			iat += 1;
        }

		import += 1;
    }

    return true;
}

bool FloatingPE::LoadPE(FILE *fModule) {
	if (NULL == fModule) {
		dbg_log("File open error!\n");
		return false;
	}

	if (1 != fread(&dosHdr, sizeof(dosHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (dosHdr.e_magic != DOS_MAGIC) {
		dbg_log("dosHdr.e_magic not valid\n");
		return false;
	}

	fseek(fModule, dosHdr.e_lfanew, SEEK_SET);


	if (1 != fread(&peHdr, sizeof(peHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (PE_MAGIC != peHdr.PeSignature) {
		dbg_log("peHdr.PeSignature not valid\n");
		return false;
	}

	//dbg_log("Machine: %d\n", peHdr.Machine);
	//dbg_log("NumberOfSections: %d\n", peHdr.NumberOfSections);
	//dbg_log("SizeOfOptionalHeader: %d\n", peHdr.SizeOfOptionalHeader);
	//dbg_log("Characteristics: %d\n", peHdr.Characteristics);

	DWORD optSize = 0;
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w32);
			break;
		case IMAGE_FILE_MACHINE_AMD64 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w64);
			break;
		default :
			dbg_log("Unsupported machine type\n");
			return false;
	}

	if (peHdr.SizeOfOptionalHeader != optSize) {
		dbg_log("Unsupported optional header\n");
		return false;
	}

	if (1 != fread(&optHdr, optSize, 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}


	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			if (OPT32_MAGIC != optHdr.c.Magic) {
				dbg_log("opt32Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %08x\n", optHdr.w32.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w32.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w32.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w32.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w32.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w32.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w32.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w32.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w32.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
			);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			if (OPT64_MAGIC != optHdr.c.Magic) {
				dbg_log("opt64Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %016x\n", optHdr.w64.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w64.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w64.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w64.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w64.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w64.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w64.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w64.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w64.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
				); break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

	

	sections.resize(peHdr.NumberOfSections);

	dbg_log("Name\t V.Size\t V.Addr\t R.Size\t R.Addr\t Characteristics\n");
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (1 != fread(&sections[i].header, sizeof(sections[i].header), 1, fModule)) {
			dbg_log("read error\n");
			return false;
		}

		dbg_log("%.8s\t %08x %08x %08x %08x %08x\n",
			sections[i].header.Name,
			sections[i].header.VirtualSize,
			sections[i].header.VirtualAddress,
			sections[i].header.SizeOfRawData,
			sections[i].header.PointerToRawData,
			sections[i].header.Characteristics);
	}

	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (!sections[i].Load(fModule)) {
			return false;
		}
	}

	return true;
}

FloatingPE::FloatingPE(const wchar_t *moduleName) {
	FILE *fModule; // = _wfopen_s(moduleName, L"rb");

	if (0 != _wfopen_s(&fModule, moduleName, L"rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}

FloatingPE::FloatingPE(const char *moduleName) {
	FILE *fModule; // = fopen(moduleName, "rb");

	if (0 != fopen_s(&fModule, moduleName, "rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}


FloatingPE::~FloatingPE() {
	//TODO: regular cleanup
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		sections[i].Unload();
	}
}

bool FloatingPE::MapPE(AbstractPEMapper &mapr, DWORD &baseAddr) {
	
	
	FixImports(mapr);
    
	
	DWORD maxAddr = 0;
	for (DWORD i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFF) & (~0xFFF);
		if (maxSec > maxAddr) {
			maxAddr = maxSec;
		}
	}
	

	baseAddr = (DWORD)mapr.CreateSection((void *)(baseAddr), maxAddr, PAGE_READWRITE);
	if (0 == baseAddr) {
		return false;
	}


	Relocate(baseAddr);

	//#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
	//#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
	//#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
	static const DWORD pVec[] = {
		PAGE_NOACCESS,
		PAGE_EXECUTE,
		PAGE_READONLY,
		PAGE_EXECUTE_READ,

		PAGE_READWRITE, // should be write only
		PAGE_EXECUTE_READWRITE, // should be execute write
		PAGE_READWRITE,
		PAGE_EXECUTE_READWRITE
	};

    for (unsigned int i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		if (sections[i].header.SizeOfRawData) {
			if (!mapr.WriteBytes((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].data, sections[i].header.SizeOfRawData)) {
				return false;
			}
		}

		DWORD protect = pVec[sections[i].header.Characteristics >> 29]; // get the three most significant bytes
		if (!mapr.ChangeProtect((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].header.VirtualSize, protect)) {
			return false;
		}
		
    }

	return true;
}

bool PESection::Load(FILE *fModule) {
    data = new unsigned char[header.SizeOfRawData];

    fseek(fModule, header.PointerToRawData, SEEK_SET);
    if (header.SizeOfRawData != fread(data, 1, header.SizeOfRawData, fModule)) {
        dbg_log("read error, in section %s\n", header.Name);
        return false;
    }

    return true;
}

void PESection::Unload() {
    if (data) {
        delete [] data;
    }
}

#ifdef DONOTPRINT
#undef dbg_log
#endif

















```

`notracer/Loader/PE.ldr.h`:

```h
#ifndef _PE_LDR_H_
#define _PE_LDR_H_

#include <vector>
using namespace std;

#include "Types.h"
#include "Abstract.Mapper.h"


struct ImageSectionHeader {
    BYTE    Name[8];
    DWORD   VirtualSize;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
};

struct ImageDosHeader {  // DOS .EXE header
    USHORT e_magic;         // Magic number
    USHORT e_cblp;          // Bytes on last page of file
    USHORT e_cp;            // Pages in file
    USHORT e_crlc;          // Relocations
    USHORT e_cparhdr;       // Size of header in paragraphs
    USHORT e_minalloc;      // Minimum extra paragraphs needed
    USHORT e_maxalloc;      // Maximum extra paragraphs needed
    USHORT e_ss;            // Initial (relative) SS value
    USHORT e_sp;            // Initial SP value
    USHORT e_csum;          // Checksum
    USHORT e_ip;            // Initial IP value
    USHORT e_cs;            // Initial (relative) CS value
    USHORT e_lfarlc;        // File address of relocation table
    USHORT e_ovno;          // Overlay number
    USHORT e_res[4];        // Reserved words
    USHORT e_oemid;         // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;       // OEM information; e_oemid specific
    USHORT e_res2[10];      // Reserved words
    LONG   e_lfanew;        // File address of new exe header
};

struct ImagePeHeader {
    DWORD   PeSignature;
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
};

struct ImageDataDirectory {
    DWORD   VirtualAddress;
    DWORD   Size;
};

#pragma pack (push, 1)
struct ImageOptionalHeader {
	struct {
		WORD    Magic;
		BYTE    MajorLinkerVersion;
		BYTE    MinorLinkerVersion;
		DWORD   SizeOfCode;
		DWORD   SizeOfInitializedData;
		DWORD   SizeOfUninitializedData;
		DWORD   AddressOfEntryPoint;
		DWORD   BaseOfCode;
	} c;

	union {
		struct {
			DWORD   BaseOfData;
			DWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			DWORD   SizeOfStackReserve;
			DWORD   SizeOfStackCommit;
			DWORD   SizeOfHeapReserve;
			DWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w32;

		struct {
			QWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			QWORD   SizeOfStackReserve;
			QWORD   SizeOfStackCommit;
			QWORD   SizeOfHeapReserve;
			QWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w64;
	};   
};
#pragma pack (pop)

class PESection {
public :
	ImageSectionHeader header;
	unsigned char *data;

	bool Load(FILE *fModule);
	void Unload();
};

class FloatingPE {
private :
	bool isValid;

	ImageDosHeader dosHdr;
	ImagePeHeader peHdr;
	ImageOptionalHeader optHdr;

	vector<PESection> sections;

	void *RVA(DWORD rva) const;
	bool LoadPE(FILE *fModule);

public :
	FloatingPE(const char *moduleName);
	FloatingPE(const wchar_t *moduleName);
	~FloatingPE();

	bool Relocate(DWORD newAddr);
	bool FixImports(AbstractPEMapper &mapper);
	bool GetExport(const char *funcName, DWORD &funcRVA);

	bool MapPE(AbstractPEMapper &mapr, DWORD &baseAddr);
	
	bool IsValid() const {
		return isValid;
	}
};

#endif

```

`notracer/Loader/Types.h`:

```h
#ifndef _TYPES_H_
#define _TYPES_H_

typedef unsigned short USHORT;
typedef long LONG;

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned long long QWORD;

#endif

```

`notracer/MapPE.cpp`:

```cpp

#include "Loader/PE.ldr.h"
#include "Loader/Inproc.Mapper.h"

bool MapPE(DWORD &baseAddr) {
	InprocMapper mapper;
	FloatingPE pe("..\\lzo\\a.exe");

	if (!pe.MapPE(mapper, baseAddr)) {
		printf("Couldn't map pe!");
		return false;
	}

	return true;
}
```

`notracer/extern.cpp`:

```cpp
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

#include <Windows.h>

#include "extern.h"


void DbgPrint(const char *fmt, ...) {
	va_list va;

	va_start(va, fmt);
	vprintf(fmt, va);
	va_end(va);

	fflush(stdout);
}

void *EnvMemoryAlloc(unsigned long dwSize) {
	//return ExAllocatePoolWithTag(NonPagedPool, dwSize, 0x3070754C);
	void *ret = VirtualAlloc(NULL, dwSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	return ret;
}

void EnvMemoryFree(void *b) {
	//ExFreePoolWithTag(b, 0x3070754C);
	//VirtualFree(b);
}
```

`notracer/extern.h`:

```h
#ifndef _EXTERN_H
#define _EXTERN_H

/* Define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif  /* __cplusplus */
#endif  /* NULL */

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86) || defined(_ARM_) || defined(_M_ARM)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#if defined(_WIN64)
typedef __int64 INT_PTR, *PINT_PTR;
typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

typedef __int64 LONG_PTR, *PLONG_PTR;
typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

#define __int3264   __int64

#else
typedef _W64 int INT_PTR, *PINT_PTR;
typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

typedef _W64 long LONG_PTR, *PLONG_PTR;
typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

#define __int3264   __int32

#endif

typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;

void DbgPrint(const char *fmt, ...);

void *EnvMemoryAlloc(unsigned long dwSize);
void EnvMemoryFree(void *b);

#endif
```

`notracer/main.cpp`:

```cpp
#include "extern.h"
#include <stdio.h>

int overlap(unsigned int a1, unsigned int a2, unsigned int b1, unsigned int b2);

bool MapPE(DWORD &baseAddr);

typedef int(*MainFunc)(unsigned int argc, char *argv[]);

int main(unsigned int argc, char *argv[]) {
	DWORD baseAddr = 0;
	if (!MapPE(baseAddr)) {
		return false;
	}

	//MainFunc pMain = (MainFunc)(baseAddr + 0x1032);
	MainFunc pMain = (MainFunc)(baseAddr + 0x96CE);
	pMain(argc, argv);
	return 0;
}
```

`notracer/notracer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{576B9478-3A8E-4CFB-9B8B-6C609AED4E31}</ProjectGuid>
    <RootNamespace>notracer</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="extern.cpp" />
    <ClCompile Include="Loader\Inproc.Mapper.cpp" />
    <ClCompile Include="Loader\PE.ldr.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="MapPE.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="extern.h" />
    <ClInclude Include="Loader\Abstract.Mapper.h" />
    <ClInclude Include="Loader\Inproc.Mapper.h" />
    <ClInclude Include="Loader\PE.ldr.h" />
    <ClInclude Include="Loader\Types.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`release.conf`:

```conf
river.sdk.version=0.3.3

```

`revmaster/DualAllocator.cpp`:

```cpp
#include "DualAllocator.h"

DualAllocator::DualAllocator(DWORD size, HANDLE remoteProcess, const wchar_t *shmName, DWORD granularity) {
	hMapping = CreateFileMappingW(
		INVALID_HANDLE_VALUE,
		NULL,
		PAGE_EXECUTE_READWRITE,
		0,
		size,
		shmName
		);

	dwSize = size;
	dwUsed = 0;
	dwGran = granularity;

	hProcess[0] = GetCurrentProcess();
	hProcess[1] = remoteProcess;
}

DualAllocator::~DualAllocator() {
	CloseHandle(hMapping);
}

#include <stdio.h>
void *DualAllocator::Allocate(DWORD size, DWORD &offset) {
	printf("Looking for a 0x%08x block\n", size);

	size = (size + 0xFFF) & ~0xFFF;

	offset = 0xFFFFFFFF;
	if (dwUsed == dwSize) {
		return NULL;
	}
	offset = dwUsed;
	dwUsed += size;
	dwUsed += dwGran - 1;
	dwUsed &= ~(dwGran - 1);

	// now look for a suitable address;

	DWORD dwOffset = dwGran;
	DWORD dwCandidate = 0, dwCandidateSize = 0xFFFFFFFF;

	while (dwOffset < 0x7FFF0000) {
		MEMORY_BASIC_INFORMATION32 mbi;
		DWORD regionSize = 0xFFFFFFFF;
		bool regionFree = true;

		for (int i = 0; i < 2; ++i) {
			if (0 == VirtualQueryEx(hProcess[i], (LPCVOID)dwOffset, (PMEMORY_BASIC_INFORMATION)&mbi, sizeof(mbi))) {
				return NULL;
			}

			DWORD dwSize = mbi.RegionSize - (dwOffset - mbi.BaseAddress); // or allocationbase
			if (regionSize > dwSize) {
				regionSize = dwSize;
			}

			regionFree &= (MEM_FREE == mbi.State);
		}

		if (regionFree & (regionSize >= size) & (regionSize < dwCandidateSize)) {
			printf("    Candidate found @0x%08x size 0x%08x\n", dwOffset, regionSize);
			dwCandidate = dwOffset;
			dwCandidateSize = regionSize;

			if (regionSize == size) {
				break;
			}
		}

		dwOffset += regionSize;
		dwOffset += dwGran - 1;
		dwOffset &= ~(dwGran - 1);
	}

	if (0 == dwCandidate) {
		return NULL;
	}

	void *ptr = MapViewOfFileEx(
		hMapping,
		FILE_MAP_ALL_ACCESS,
		0,
		offset,
		size,
		(void *)dwCandidate
		);

	if (dwCandidate != (DWORD)ptr) {
		__asm int 3;
	}

	return ptr;
}

void DualAllocator::Free(void *ptr) {
	UnmapViewOfFile(ptr);
}
```

`revmaster/DualAllocator.h`:

```h
#ifndef _DUAL_ALLOCATOR_H_
#define _DUAL_ALLOCATOR_H_

#include <Windows.h>

class DualAllocator {
private:
	HANDLE hMapping;
	DWORD dwSize;
	DWORD dwUsed;
	DWORD dwGran;

	HANDLE hProcess[2];
public:
	DualAllocator(DWORD size, HANDLE remoteProcess, const wchar_t *shmName, DWORD granularity);
	~DualAllocator();

	void *Allocate(DWORD size, DWORD &offset);
	void Free(void *ptr);
};


#endif

```

`revmaster/Loader/Abstract.Mapper.h`:

```h
#ifndef _ABSTRACT_MAPPER_H_
#define _ABSTRACT_MAPPER_H_

#include "Types.h"

class AbstractPEMapper {
public:
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) = 0;

	virtual DWORD FindImport(const char *moduleName, const char *funcName) = 0;
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal) = 0;
};

#endif


```

`revmaster/Loader/Extern.Mapper.cpp`:

```cpp
#include "Extern.Mapper.h"

#include <psapi.h>

bool SameFile(const char *s1, int l1, const char *s2, int l2) {
	/*int cLen = l1;
	if (l2 < cLen) cLen = l2;

	int o1 = l1 - cLen, o2 = l2 - cLen;

	for (int i = 0; i < cLen; ++i) {
		if (toupper(s1[o1 + i]) != toupper(s2[o2 + i])) {
			return false;
		}
	}

	if ((o1 > 0) && (s1[o1 - 1] != '\\')) {
		return false;
	}

	if ((o2 > 0) && (s2[o2 - 1] != '\\')) {
		return false;
	}

	return true;*/

	if (l1 != l2) {
		return false;
	}

	for (int i = 0; i < l1; ++i) {
		if (toupper(s1[i]) == toupper(s2[i])) {
			return false;
		}
	}

	return true;
}

HMODULE ExternMapper::RemoteFindModule(const char *module) {
	HMODULE hMods[1024];
	DWORD cbNeeded;

	int mLen = strlen(module);

	if (EnumProcessModules(hProc, hMods, sizeof(hMods), &cbNeeded)) {
		for (unsigned int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {
			char szModName[MAX_PATH];
			if (GetModuleFileNameExA(hProc, hMods[i], szModName, sizeof(szModName))) {
				int rLen = strlen(szModName);
				
				if (SameFile(module, mLen, szModName, rLen)) {
					return hMods[i];
				}
			}
		}
	}

	return NULL;
}

ExternMapper::ExternMapper(unsigned int pid) {
	hProc = OpenProcess(
		PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
		FALSE,
		pid
	);

	ownProcess = true;
}

ExternMapper::ExternMapper(HANDLE process) {
	hProc = process;
	ownProcess = false;
}

ExternMapper::~ExternMapper() {
	if (ownProcess) {
		CloseHandle(hProc);
	}
}

void *ExternMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return VirtualAllocEx(hProc, lpAddress, dwSize, MEM_RESERVE | MEM_COMMIT, flProtect);
}

bool ExternMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	DWORD oldProtect;
	return TRUE == VirtualProtectEx(hProc, lpAddress, dwSize, flProtect, &oldProtect);
}

bool ExternMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	return TRUE == WriteProcessMemory(hProc, lpAddress, lpBuffer, nSize, NULL);
}

/* This is very sloppy! */
/* Should work for ntdll. No WOW64 support. No export forwarding. */
DWORD ExternMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE rMod = RemoteFindModule(moduleName);
	HMODULE lMod = GetModuleHandleA(moduleName);

	if ((NULL == rMod) || (NULL == lMod)) {
		return 0xFFFFFFFF;
	}

	void *pFunc = GetProcAddress(lMod, funcName);
	return (DWORD)pFunc - (DWORD)lMod + (DWORD)rMod;
}

DWORD ExternMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE lMod = GetModuleHandleA(moduleName);
	char modName[MAX_PATH];

	GetModuleFileNameA(lMod, modName, sizeof(modName));
	HMODULE rMod = RemoteFindModule(modName);
	

	if ((NULL == rMod) || (NULL == lMod)) {
		return 0xFFFFFFFF;
	}

	void *pFunc = GetProcAddress(lMod, (LPCSTR)funcOrdinal);
	return (DWORD)pFunc - (DWORD)lMod + (DWORD)rMod;
}
```

`revmaster/Loader/Extern.Mapper.h`:

```h
#ifndef _EXTERN_MAPPER_H_
#define _EXTERN_MAPPER_H_

#include <Windows.h>

#include "Abstract.Mapper.h"

class ExternMapper : public AbstractPEMapper {
private :
	HANDLE hProc;
	bool ownProcess;

	HMODULE RemoteFindModule(const char *module);
public:
	ExternMapper(unsigned int pid);
	ExternMapper(HANDLE process);
	virtual ~ExternMapper();

	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif

```

`revmaster/Loader/Inproc.Mapper.cpp`:

```cpp
#include <Windows.h>
#include "Inproc.Mapper.h"


void *InprocMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return VirtualAlloc(lpAddress, dwSize, MEM_RESERVE | MEM_COMMIT, flProtect);
}

bool InprocMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	DWORD oldProtect;
	return TRUE == VirtualProtect(lpAddress, dwSize, flProtect, &oldProtect);
}

bool InprocMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	memcpy(lpAddress, lpBuffer, nSize);
	return true;
}

DWORD InprocMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, funcName);
}

DWORD InprocMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, (LPCSTR)funcOrdinal);
}
```

`revmaster/Loader/Inproc.Mapper.h`:

```h
#ifndef _INPROC_MAPPER_H_
#define _INPROC_MAPPER_H_

#include "Abstract.Mapper.h"

class InprocMapper : public AbstractPEMapper {
public :
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif
```

`revmaster/Loader/Mem.Mapper.cpp`:

```cpp
#include <Windows.h>
#include "Mem.Mapper.h"


void *MemMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return lpAddress;
}

bool MemMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return true;
}

bool MemMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	memcpy(lpAddress, lpBuffer, nSize);
	return true;
}

DWORD MemMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, funcName);
}

DWORD MemMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, (LPCSTR)funcOrdinal);
}
```

`revmaster/Loader/Mem.Mapper.h`:

```h
#ifndef _MEM_MAPPER_H_
#define _MEM_MAPPER_H_

#include "Abstract.Mapper.h"

class MemMapper : public AbstractPEMapper {
public :
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif
```

`revmaster/Loader/PE.ldr.cpp`:

```cpp
#include <stdio.h>
#include <vector>
using namespace std;

//#include "..\extern.h"

#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#endif

#include "PE.ldr.h"

//#include "common/debug-log.h"
//#define dbg_log DbgPrint

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5
#define IMAGE_REL_BASED_RESERVED              6
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9
#define IMAGE_REL_BASED_DIR64                 10

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     

#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     

#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define PAGE_REVERT_TO_FILE_MAP     0x80000000 

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

const USHORT DOS_MAGIC = 0x5A4D;
const DWORD PE_MAGIC = 0x00004550;
const WORD OPT32_MAGIC = 0x010B;
const WORD OPT64_MAGIC = 0x020B;

const WORD IMAGE_FILE_MACHINE_I386 = 0x14C;
const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Name;
	DWORD Base;
	DWORD NumberOfFunctions;
	DWORD NumberOfNames;
	DWORD AddressOfFunctions; // RVA from base of image
	DWORD AddressOfNames; // RVA from base of image
	DWORD AddressOfNameOrdinals; // RVA from base of image
} IMAGE_EXPORT_DIRECTORY;

void *FloatingPE::RVA(DWORD rva) const {
    for (int i = 0; i < peHdr.NumberOfSections; ++i) {
        if (rva >= sections[i].header.VirtualAddress) {
            DWORD dwOffset = rva - sections[i].header.VirtualAddress;
            if (dwOffset < sections[i].header.VirtualSize) {
                return sections[i].data + dwOffset;
            }
        }
    }
    return (void *)0;
}

bool FloatingPE::Relocate(DWORD newAddr) {
	long long offset = 0;
	IMAGE_BASE_RELOCATION *reloc;
    IMAGE_BASE_RELOCATION *term;

	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			offset = newAddr - optHdr.w32.ImageBase;
			optHdr.w32.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			offset = newAddr - optHdr.w64.ImageBase;
			optHdr.w64.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

    while (reloc < term) {
        //dbg_log("Relocation Block %08x %08x", reloc->VirtualAddress, reloc->SizeOfBlock);
        WORD *wloc = (WORD *)reloc + 4;
        int wlocCount = (reloc->SizeOfBlock - sizeof(*reloc)) / sizeof(*wloc);

        for (int i = 0; i < wlocCount; ++i) {
            //dbg_log("%x %x;\t", wloc[i] >> 12, wloc[i] & 0x0FFF);
			WORD type = wloc[i] >> 12;
			WORD off = wloc[i] & 0x0FFF;
			
			if ((i % 3) == 0) {
				//dbg_log("\n");
			}
			
			switch (type) {
				case IMAGE_REL_BASED_ABSOLUTE :
					break;
				case IMAGE_REL_BASED_HIGHLOW :
					*((DWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					//dbg_log("%08x -> %08x\t", reloc->VirtualAddress + off, *((DWORD *)RVA(reloc->VirtualAddress + off)));
					break;
				case IMAGE_REL_BASED_DIR64 :
					*((QWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					break;
				default :
					//__asm int 3;
					__debugbreak();
			}
        }
		//dbg_log("\n");
		reloc = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + reloc->SizeOfBlock);
    }


    return true;
}

bool FloatingPE::GetExport(const char *funcName, DWORD &funcRVA) const {
	DWORD exportRVA = 0;
	
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			exportRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			exportRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	};
	
	if (0 == exportRVA) {
		return false;
	}

	IMAGE_EXPORT_DIRECTORY *exprt = (IMAGE_EXPORT_DIRECTORY *)RVA(exportRVA);

	dbg_log("Number of functions: %d\n", exprt->NumberOfFunctions);
	dbg_log("Number of names: %d\n", exprt->NumberOfNames);

	DWORD *names = (DWORD *)RVA(exprt->AddressOfNames);
	int found = -1;
	for (DWORD i = 0; i < exprt->NumberOfNames; ++i) {
		char *name = (char *)RVA(names[i]);
		if (0 == strcmp(name, funcName)) {
			found = i;
			break;
		}
	}

	if (-1 == found) {
		return false;
	}

	WORD *ordinals = (WORD *)RVA(exprt->AddressOfNameOrdinals);
	WORD ordinal = ordinals[found] - (WORD)exprt->Base + 1;

	DWORD *exportTable = (DWORD *)RVA(exprt->AddressOfFunctions);
	funcRVA = exportTable[ordinal];

	return true;
}

DWORD FloatingPE::GetRequiredSize() const {
	DWORD maxAddr = 0;
	for (DWORD i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFF) & (~0xFFF);
		if (maxSec > maxAddr) {
			maxAddr = maxSec;
		}
	}

	return maxAddr;
}

DWORD FloatingPE::GetSectionCount() const {
	return sections.size();
}

const PESection *FloatingPE::GetSection(DWORD dwIdx) const {
	return &sections[dwIdx];
}


bool FloatingPE::FixImports(AbstractPEMapper &mapper) {
	DWORD importRVA = 0;
	
	
	switch (peHdr.Machine) {
	case IMAGE_FILE_MACHINE_I386:
		importRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	case IMAGE_FILE_MACHINE_AMD64:
		importRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	default:
		dbg_log("Unsupported machine type\n");
		return false;
	};

	if (0 == importRVA) {
		return true;
	}

    IMAGE_IMPORT_DESCRIPTOR *import = (IMAGE_IMPORT_DESCRIPTOR *)RVA(importRVA);
	if (NULL == import) {
		return false;
	}

    while (import->OriginalFirstThunk != 0) {
		char *name = (char *)RVA(import->Name);
        dbg_log("Directory for: %s\n", name);
		dbg_log("OFT: %08x, FT: %08x\n", import->OriginalFirstThunk, import->FirstThunk);
		DWORD *funcs = (DWORD *)RVA(import->OriginalFirstThunk);
		DWORD *iat = (DWORD *)RVA(import->FirstThunk);
        while (*funcs != 0) {
            if (0x80000000 & *funcs) {
                dbg_log("Import by ordinal %d\n", *funcs & 0x7FFF);
				*iat = mapper.FindImport(name, *funcs & 0x7FFF);
            } else {
				char *funcName = (char *)RVA(*funcs + 2);
                dbg_log("Import by name %s\n", funcName);
				*iat = mapper.FindImport(name, funcName);
            }

            funcs += 1;
			iat += 1;
        }

		import += 1;
    }

    return true;
}

bool FloatingPE::LoadPE(FILE *fModule) {
	if (NULL == fModule) {
		dbg_log("File open error!\n");
		return false;
	}

	if (1 != fread(&dosHdr, sizeof(dosHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (dosHdr.e_magic != DOS_MAGIC) {
		dbg_log("dosHdr.e_magic not valid\n");
		return false;
	}

	fseek(fModule, dosHdr.e_lfanew, SEEK_SET);


	if (1 != fread(&peHdr, sizeof(peHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (PE_MAGIC != peHdr.PeSignature) {
		dbg_log("peHdr.PeSignature not valid\n");
		return false;
	}

	//dbg_log("Machine: %d\n", peHdr.Machine);
	//dbg_log("NumberOfSections: %d\n", peHdr.NumberOfSections);
	//dbg_log("SizeOfOptionalHeader: %d\n", peHdr.SizeOfOptionalHeader);
	//dbg_log("Characteristics: %d\n", peHdr.Characteristics);

	DWORD optSize = 0;
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w32);
			break;
		case IMAGE_FILE_MACHINE_AMD64 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w64);
			break;
		default :
			dbg_log("Unsupported machine type\n");
			return false;
	}

	if (peHdr.SizeOfOptionalHeader != optSize) {
		dbg_log("Unsupported optional header\n");
		return false;
	}

	if (1 != fread(&optHdr, optSize, 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}


	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			if (OPT32_MAGIC != optHdr.c.Magic) {
				dbg_log("opt32Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %08x\n", optHdr.w32.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w32.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w32.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w32.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w32.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w32.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w32.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w32.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w32.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
			);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			if (OPT64_MAGIC != optHdr.c.Magic) {
				dbg_log("opt64Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %016x\n", optHdr.w64.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w64.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w64.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w64.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w64.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w64.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w64.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w64.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w64.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
				); break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

	

	sections.resize(peHdr.NumberOfSections);

	dbg_log("Name\t V.Size\t V.Addr\t R.Size\t R.Addr\t Characteristics\n");
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (1 != fread(&sections[i].header, sizeof(sections[i].header), 1, fModule)) {
			dbg_log("read error\n");
			return false;
		}

		dbg_log("%.8s\t %08x %08x %08x %08x %08x\n",
			sections[i].header.Name,
			sections[i].header.VirtualSize,
			sections[i].header.VirtualAddress,
			sections[i].header.SizeOfRawData,
			sections[i].header.PointerToRawData,
			sections[i].header.Characteristics);
	}

	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (!sections[i].Load(fModule)) {
			return false;
		}
	}

	return true;
}

FloatingPE::FloatingPE(const wchar_t *moduleName) {
	FILE *fModule; // = _wfopen_s(moduleName, L"rb");

	if (0 != _wfopen_s(&fModule, moduleName, L"rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}

FloatingPE::FloatingPE(const char *moduleName) {
	FILE *fModule; // = fopen(moduleName, "rb");

	if (0 != fopen_s(&fModule, moduleName, "rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}


FloatingPE::~FloatingPE() {
	//TODO: regular cleanup
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		sections[i].Unload();
	}
}

bool FloatingPE::MapPE(AbstractPEMapper &mapr, DWORD &baseAddr) {
	
	
	FixImports(mapr);
    
	
	DWORD maxAddr = 0;
	for (DWORD i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFF) & (~0xFFF);
		if (maxSec > maxAddr) {
			maxAddr = maxSec;
		}
	}
	

	baseAddr = (DWORD)mapr.CreateSection((void *)(baseAddr), maxAddr, PAGE_READWRITE);
	if (0 == baseAddr) {
		return false;
	}


	Relocate(baseAddr);

	//#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
	//#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
	//#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
	static const DWORD pVec[] = {
		PAGE_NOACCESS,
		PAGE_EXECUTE,
		PAGE_READONLY,
		PAGE_EXECUTE_READ,

		PAGE_READWRITE, // should be write only
		PAGE_EXECUTE_READWRITE, // should be execute write
		PAGE_READWRITE,
		PAGE_EXECUTE_READWRITE
	};

    for (unsigned int i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		if (sections[i].header.SizeOfRawData) {
			if (!mapr.WriteBytes((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].data, sections[i].header.SizeOfRawData)) {
				return false;
			}
		}

		DWORD protect = pVec[sections[i].header.Characteristics >> 29]; // get the three most significant bytes
		if (!mapr.ChangeProtect((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].header.VirtualSize, protect)) {
			return false;
		}
		
    }

	return true;
}

bool PESection::Load(FILE *fModule) {
    data = new unsigned char[header.SizeOfRawData];

    fseek(fModule, header.PointerToRawData, SEEK_SET);
    if (header.SizeOfRawData != fread(data, 1, header.SizeOfRawData, fModule)) {
        dbg_log("read error, in section %s\n", header.Name);
        return false;
    }

    return true;
}

void PESection::Unload() {
    if (data) {
        delete [] data;
    }
}

#ifdef DONOTPRINT
#undef dbg_log
#endif

















```

`revmaster/Loader/PE.ldr.h`:

```h
#ifndef _PE_LDR_H_
#define _PE_LDR_H_

#include <vector>
using namespace std;

#include "Types.h"
#include "Abstract.Mapper.h"


struct ImageSectionHeader {
    BYTE    Name[8];
    DWORD   VirtualSize;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
};

struct ImageDosHeader {  // DOS .EXE header
    USHORT e_magic;         // Magic number
    USHORT e_cblp;          // Bytes on last page of file
    USHORT e_cp;            // Pages in file
    USHORT e_crlc;          // Relocations
    USHORT e_cparhdr;       // Size of header in paragraphs
    USHORT e_minalloc;      // Minimum extra paragraphs needed
    USHORT e_maxalloc;      // Maximum extra paragraphs needed
    USHORT e_ss;            // Initial (relative) SS value
    USHORT e_sp;            // Initial SP value
    USHORT e_csum;          // Checksum
    USHORT e_ip;            // Initial IP value
    USHORT e_cs;            // Initial (relative) CS value
    USHORT e_lfarlc;        // File address of relocation table
    USHORT e_ovno;          // Overlay number
    USHORT e_res[4];        // Reserved words
    USHORT e_oemid;         // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;       // OEM information; e_oemid specific
    USHORT e_res2[10];      // Reserved words
    LONG   e_lfanew;        // File address of new exe header
};

struct ImagePeHeader {
    DWORD   PeSignature;
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
};

struct ImageDataDirectory {
    DWORD   VirtualAddress;
    DWORD   Size;
};

#pragma pack (push, 1)
struct ImageOptionalHeader {
	struct {
		WORD    Magic;
		BYTE    MajorLinkerVersion;
		BYTE    MinorLinkerVersion;
		DWORD   SizeOfCode;
		DWORD   SizeOfInitializedData;
		DWORD   SizeOfUninitializedData;
		DWORD   AddressOfEntryPoint;
		DWORD   BaseOfCode;
	} c;

	union {
		struct {
			DWORD   BaseOfData;
			DWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			DWORD   SizeOfStackReserve;
			DWORD   SizeOfStackCommit;
			DWORD   SizeOfHeapReserve;
			DWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w32;

		struct {
			QWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			QWORD   SizeOfStackReserve;
			QWORD   SizeOfStackCommit;
			QWORD   SizeOfHeapReserve;
			QWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w64;
	};   
};
#pragma pack (pop)

class PESection {
public :
	ImageSectionHeader header;
	unsigned char *data;

	bool Load(FILE *fModule);
	void Unload();
};

class FloatingPE {
private :
	bool isValid;

	ImageDosHeader dosHdr;
	ImagePeHeader peHdr;
	ImageOptionalHeader optHdr;

	vector<PESection> sections;

	void *RVA(DWORD rva) const;
	bool LoadPE(FILE *fModule);

public :
	FloatingPE(const char *moduleName);
	FloatingPE(const wchar_t *moduleName);
	~FloatingPE();

	bool Relocate(DWORD newAddr);
	bool FixImports(AbstractPEMapper &mapper);

	bool GetExport(const char *funcName, DWORD &funcRVA) const;
	DWORD GetRequiredSize() const;
	DWORD GetSectionCount() const;
	const PESection *GetSection(DWORD dwIdx) const;

	bool MapPE(AbstractPEMapper &mapr, DWORD &baseAddr);
	
	bool IsValid() const {
		return isValid;
	}
};

#endif

```

`revmaster/Loader/Types.h`:

```h
#ifndef _TYPES_H_
#define _TYPES_H_

typedef unsigned short USHORT;
typedef long LONG;

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned long long QWORD;

#endif

```

`revmaster/Main.cpp`:

```cpp
#include <Windows.h>
#include <Psapi.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <tlhelp32.h>


#include "DualAllocator.h"

#include "Loader/Extern.Mapper.h"
#include "Loader/Mem.Mapper.h"
#include "Loader/PE.ldr.h"

#include "../loader/loader.h"
#include "../ipclib/ipclib.h"
#include "../revtracer/revtracer.h"

typedef long NTSTATUS;
typedef NTSTATUS(*NtYieldExecutionFunc)();

NtYieldExecutionFunc ntdllYieldExecution;

namespace ipc {
	void NtDllNtYieldExecution() {
		::ntdllYieldExecution();
	}
};

void InitSegment(HANDLE hThread, DWORD dwSeg, DWORD &offset) {
	LDT_ENTRY entry;
	DWORD base, limit;

	if (FALSE == GetThreadSelectorEntry(hThread, dwSeg, &entry)) {
		base = 0xFFFFFFFF;
		limit = 0;
	} else {
		base = entry.BaseLow | (entry.HighWord.Bytes.BaseMid << 16) | (entry.HighWord.Bytes.BaseHi << 24);
		limit = entry.LimitLow | (entry.HighWord.Bits.LimitHi << 16);
	}

	if (entry.HighWord.Bits.Granularity) {
		limit = (limit << 12) | 0x0FFF;
	}

	offset = base;
}


void InitSegments(HANDLE hThread, DWORD *segments) {
	for (DWORD i = 0; i < 0x100; ++i) {
		InitSegment(hThread, i, segments[i]);
	}
}


DualAllocator *shmAlloc = NULL;

FloatingPE *fLoader = NULL, *fIpcLib = NULL, *fRevTracer = NULL;

DWORD CharacteristicsToDesiredAccess(DWORD c) {
	DWORD r = 0;

	r |= (c & IMAGE_SCN_MEM_READ) ? FILE_MAP_READ : 0;
	r |= (c & IMAGE_SCN_MEM_WRITE) ? FILE_MAP_WRITE : 0;
	r |= (c & IMAGE_SCN_MEM_EXECUTE) ? FILE_MAP_EXECUTE : 0;
	return r;
}

char debugBuffer[4096];

bool FixProcessorFeature(HANDLE hProcess, DWORD newAddr) {
	HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
	unsigned char *ipfpAddr = (unsigned char *)GetProcAddress(hKernel32, "IsProcessorFeaturePresent");

	DWORD ipfpOffset = ipfpAddr - (unsigned char *)hKernel32;

	DWORD dwOffset = 0x10000;
	while (0x7FFE0000 >= dwOffset) {
		MEMORY_BASIC_INFORMATION32 mbi;
		char moduleName[MAX_PATH];

		VirtualQueryEx(hProcess, (PVOID)dwOffset, (PMEMORY_BASIC_INFORMATION)&mbi, sizeof(mbi));

		if ((MEM_COMMIT == mbi.State) && (SEC_IMAGE == mbi.Type) && (PAGE_READONLY == mbi.Protect)) {
			if (0 != GetMappedFileNameA(
				hProcess,
				(PVOID)dwOffset,
				moduleName,
				sizeof(moduleName)-1
			)) {
				int pos = strlen(moduleName) - 12;

				if ((pos >= 0) && (0 == strcmp(&moduleName[pos], "kernel32.dll"))) {
					break;
				}
			}
		}

		dwOffset += mbi.RegionSize;
	}

	if (0x7FFE0000 < dwOffset) {
		return false;
	}

	// IPFP is at dwOffset + ipfpOffset
	// next instruction is at dwOffset + ipfpOffset + 5
	// relative jmp is newAddr - dwOffset + ipfpOffset + 5
	unsigned char buf[5];
	DWORD dwJmp = newAddr - (dwOffset + ipfpOffset + 5);
	buf[0] = 0xE9; // relative jump
	*(DWORD *)&buf[1] = dwJmp;
	DWORD written;

	if (FALSE == WriteProcessMemory(hProcess, (PVOID)(dwOffset + ipfpOffset), buf, sizeof(buf), &written)) {
		return false;
	}

	return true;
}

bool UnmapMainModule(char *modName, DWORD pid, HANDLE hProcess) {
	HANDLE hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
	BYTE *mAddr = NULL;

	do {
		MODULEENTRY32 me32;

		// Take a snapshot of all modules in the specified process.
		if (hModuleSnap == INVALID_HANDLE_VALUE)
		{
			break;
		}

		// Set the size of the structure before using it.
		me32.dwSize = sizeof(MODULEENTRY32);

		// Retrieve information about the first module,
		// and exit if unsuccessful
		if (!Module32First(hModuleSnap, &me32))
		{
			CloseHandle(hModuleSnap);           // clean the snapshot object
			break;
		}

		// Now walk the module list of the process,
		// and display information about each module
		do
		{
			if (0 == _stricmp(modName, me32.szModule)) {
				mAddr = me32.modBaseAddr;
				break;
			}

		} while (Module32Next(hModuleSnap, &me32));
	} while (0);

	if (NULL != mAddr) {
		unsigned short tmp = 0;
		DWORD dwWr, oldPr;

		if (FALSE == VirtualProtectEx(hProcess, mAddr, sizeof(tmp), PAGE_READWRITE, &oldPr)) {
			return false;
		}

		if (FALSE == WriteProcessMemory(hProcess, mAddr, &tmp, sizeof(tmp), &dwWr)) {
			return false;
		}

		if (FALSE == VirtualProtectEx(hProcess, mAddr, sizeof(tmp), oldPr, &oldPr)) {
			return false;
		}

		return true;
	}

	return false;
}

int main() {
	STARTUPINFOW startup;
	PROCESS_INFORMATION pInfo;

	memset(&startup, 0, sizeof(startup));
	startup.cb = sizeof(startup);

	BOOL bRet = CreateProcessW(
		L"..\\lzo\\a.exe",
		L"",
		NULL,
		NULL,
		FALSE,
		CREATE_SUSPENDED,
		NULL,
		NULL,
		&startup,
		&pInfo
	);

	if (FALSE == bRet) {
		printf("CreateProcess() error %d\n", GetLastError());
		return 0;
	}

	//ldr::LoaderConfig ldrConfig;
	//ldrConfig.sharedMemoryName


	SYSTEM_INFO si;
	memset(&si, 0, sizeof(si));

	GetSystemInfo(&si);

	shmAlloc = new DualAllocator(1 << 30, pInfo.hProcess, L"Local\\MumuMem", si.dwAllocationGranularity);


	fLoader = new FloatingPE("loader.dll");
	ExternMapper mLoader(pInfo.hProcess);

	DWORD dwLoaderBase = 0x500000;
	if (!fLoader->MapPE(mLoader, dwLoaderBase)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	FlushInstructionCache(pInfo.hProcess, (LPVOID)dwLoaderBase, fLoader->GetRequiredSize());

	fIpcLib = new FloatingPE("ipclib.dll");
	fRevTracer = new FloatingPE("revtracer.dll");
	DWORD dwIpcLibSize = (fIpcLib->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
	DWORD dwRevTracerSize = (fRevTracer->GetRequiredSize() + 0xFFFF) & ~0xFFFF;
	DWORD dwTotalSize = dwIpcLibSize + dwRevTracerSize;
	DWORD dwOffset, dwWritten;
	
	BYTE *libs = (BYTE *)shmAlloc->Allocate(dwTotalSize, dwOffset);
	DWORD ipcLibAddr = (DWORD)libs, revTracerAddr = (DWORD)libs + dwIpcLibSize;
	DWORD ipcLibOffset = dwOffset, revTracerOffset = dwOffset + dwIpcLibSize;
	MemMapper mIpcLib, mRevTracer;

	if (!fIpcLib->MapPE(mIpcLib, ipcLibAddr) || !fRevTracer->MapPE(mRevTracer, revTracerAddr)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	FlushInstructionCache(pInfo.hProcess, (LPVOID)libs, dwTotalSize);

	// TODO: write loaderAPI
	HMODULE hNtDll = GetModuleHandleW(L"ntdll.dll");
	ldr::LoaderAPI ldrAPI;

//	ldrAPI.ntOpenSection = GetProcAddress(hNtDll, "NtOpenSection");
	ldrAPI.ntMapViewOfSection = GetProcAddress(hNtDll, "NtMapViewOfSection");

//	ldrAPI.ntOpenDirectoryObject = GetProcAddress(hNtDll, "NtOpenDirectoryObject");
//	ldrAPI.ntClose = GetProcAddress(hNtDll, "NtClose");

	ldrAPI.ntFlushInstructionCache = GetProcAddress(hNtDll, "NtFlushInstructionCache");

//	ldrAPI.rtlInitUnicodeStringEx = GetProcAddress(hNtDll, "RtlInitUnicodeStringEx");
//	ldrAPI.rtlFreeUnicodeString = GetProcAddress(hNtDll, "RtlFreeUnicodeString");

	DWORD ldrAPIOffset;
	if (!fLoader->GetExport("loaderAPI", ldrAPIOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	if (FALSE == WriteProcessMemory(pInfo.hProcess, (ldr::ADDR_TYPE)(dwLoaderBase + ldrAPIOffset), &ldrAPI, sizeof(ldrAPI), &dwWritten)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	ldr::LoaderConfig ldrCfg;
	DWORD dwPerform;

	if (!fRevTracer->GetExport("RevtracerPerform", dwPerform)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	memset(&ldrCfg, 0, sizeof(ldrCfg));
	ldrCfg.entryPoint = (ldr::ADDR_TYPE)(revTracerAddr + dwPerform); // TODO, populate later
	//ldrCfg.mappingAddress = 0; // TODO, populate later

	DWORD dwIpcLibSections = fIpcLib->GetSectionCount();
	DWORD sCount = 0;
	for (DWORD i = 0; i < dwIpcLibSections; ++i) {
		const PESection *sec = fIpcLib->GetSection(i);

		if (sec->header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		ldrCfg.sections[sCount].mappingAddress = (ldr::ADDR_TYPE)(ipcLibAddr + sec->header.VirtualAddress);
		ldrCfg.sections[sCount].mappingSize = (sec->header.VirtualSize + 0xFFF) & ~0xFFF;
		ldrCfg.sections[sCount].sectionOffset = ipcLibOffset + sec->header.VirtualAddress;
		ldrCfg.sections[sCount].desiredAccess = CharacteristicsToDesiredAccess(sec->header.Characteristics);
		sCount++;
	}

	DWORD dwRevTracerSections = fRevTracer->GetSectionCount();
	for (DWORD i = 0; i < dwRevTracerSections; ++i) {
		const PESection *sec = fRevTracer->GetSection(i);

		if (sec->header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		ldrCfg.sections[sCount].mappingAddress = (ldr::ADDR_TYPE)(revTracerAddr + sec->header.VirtualAddress);
		ldrCfg.sections[sCount].mappingSize = (sec->header.VirtualSize + 0xFFF) & ~0xFFF;
		ldrCfg.sections[sCount].sectionOffset = revTracerOffset + sec->header.VirtualAddress;
		ldrCfg.sections[sCount].desiredAccess = CharacteristicsToDesiredAccess(sec->header.Characteristics);
		sCount++;
	}
	
	ldrCfg.sectionCount = sCount;
	//wcscpy_s(ldrCfg.sharedMemoryName, L"Local\\MumuMem");
	ldrCfg.sharedMemory = NULL;

	DWORD ldrCfgOffset;
	if (!fLoader->GetExport("loaderConfig", ldrCfgOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	DWORD ldrMyIPFPOffset;
	if (!fLoader->GetExport("MyIsProcessorFeaturePresent", ldrMyIPFPOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	if (FALSE == WriteProcessMemory(pInfo.hProcess, (ldr::ADDR_TYPE)(dwLoaderBase + ldrCfgOffset), &ldrCfg, sizeof(ldrCfg), &dwWritten)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	DWORD ipcDebugLogOffset;
	ipc::RingBuffer<(1 << 20)> *debugLog;
	if (!fIpcLib->GetExport("debugLog", ipcDebugLogOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	debugLog = (ipc::RingBuffer<(1 << 20)> *)(ipcLibAddr + ipcDebugLogOffset);

	DWORD ipcTokenOffset;
	ipc::ShmTokenRing *ipcToken;
	if (!fIpcLib->GetExport("ipcToken", ipcTokenOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	ipcToken = (ipc::ShmTokenRing *)(ipcLibAddr + ipcTokenOffset);

	DWORD ipcAPIOffset;
	if (!fIpcLib->GetExport("ipcAPI", ipcAPIOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	ipc::IpcAPI *ipcAPI = (ipc::IpcAPI *)(ipcLibAddr + ipcAPIOffset);

	DWORD ipcDataOffset;
	if (!fIpcLib->GetExport("ipcData", ipcDataOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	ipc::IpcData *ipcData = (ipc::IpcData *)(ipcLibAddr + ipcDataOffset);
	
	//ipcAPI.ntSetEvent = GetProcAddress(hNtDll, "NtSetEvent");
	//ipcAPI.ntWaitForSingleObject = GetProcAddress(hNtDll, "NtWaitForSingleObject");
	ipcAPI->ntYieldExecution = GetProcAddress(hNtDll, "NtYieldExecution");
	ntdllYieldExecution = (NtYieldExecutionFunc)ipcAPI->ntYieldExecution;
	ipcAPI->vsnprintf_s = GetProcAddress(hNtDll, "_vsnprintf_s");

	DWORD dwMapMemoryOffset;
	if (!fLoader->GetExport("MapMemory", dwMapMemoryOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	ipcAPI->ldrMapMemory = (ipc::ADDR_TYPE)(dwLoaderBase + dwMapMemoryOffset);


	DWORD revAPIOffset;
	if (!fRevTracer->GetExport("revtracerAPI", revAPIOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	rev::RevtracerAPI *revAPI = (rev::RevtracerAPI *)(revTracerAddr + revAPIOffset);
	
	DWORD dwIpcFuncOffset;
	if (!fIpcLib->GetExport("Initialize", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->ipcLibInitialize = (rev::IpcLibInitFunc)(ipcLibAddr + dwIpcFuncOffset);

	if (!fIpcLib->GetExport("DebugPrint", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->dbgPrintFunc = (rev::DbgPrintFunc)(ipcLibAddr + dwIpcFuncOffset);

	if (!fIpcLib->GetExport("MemoryAllocFunc", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->memoryAllocFunc = (rev::MemoryAllocFunc)(ipcLibAddr + dwIpcFuncOffset);

	if (!fIpcLib->GetExport("MemoryFreeFunc", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->memoryFreeFunc = (rev::MemoryFreeFunc)(ipcLibAddr + dwIpcFuncOffset);

	if (!fIpcLib->GetExport("TakeSnapshot", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->takeSnapshot = (rev::TakeSnapshotFunc)(ipcLibAddr + dwIpcFuncOffset);
	
	if (!fIpcLib->GetExport("RestoreSnapshot", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->restoreSnapshot = (rev::RestoreSnapshotFunc)(ipcLibAddr + dwIpcFuncOffset);
	
	if (!fIpcLib->GetExport("InitializeContextFunc", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->initializeContext = (rev::InitializeContextFunc)(ipcLibAddr + dwIpcFuncOffset);
	
	if (!fIpcLib->GetExport("CleanupContextFunc", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->cleanupContext = (rev::CleanupContextFunc)(ipcLibAddr + dwIpcFuncOffset);

	/*if (!fIpcLib->GetExport("ExecutionBeginFunc", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->executionBegin = (rev::ExecutionBeginFunc)(ipcLibAddr + dwIpcFuncOffset);

	if (!fIpcLib->GetExport("ExecutionControlFunc", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->executionControl = (rev::ExecutionControlFunc)(ipcLibAddr + dwIpcFuncOffset);

	if (!fIpcLib->GetExport("ExecutionEndFunc", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->executionEnd = (rev::ExecutionEndFunc)(ipcLibAddr + dwIpcFuncOffset);*/

	if (!fIpcLib->GetExport("SyscallControlFunc", dwIpcFuncOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	revAPI->syscallControl = (rev::SyscallControlFunc)(ipcLibAddr + dwIpcFuncOffset);

	revAPI->lowLevel.ntAllocateVirtualMemory = GetProcAddress(hNtDll, "NtAllocateVirtualMemory");
	revAPI->lowLevel.ntFreeVirtualMemory = GetProcAddress(hNtDll, "NtFreeVirtualMemory");

	revAPI->lowLevel.ntQueryInformationThread = GetProcAddress(hNtDll, "NtQueryInformationThread");
	revAPI->lowLevel.ntTerminateProcess = GetProcAddress(hNtDll, "NtTerminateProcess");

	revAPI->lowLevel.rtlNtStatusToDosError = GetProcAddress(hNtDll, "RtlNtStatusToDosError");
	revAPI->lowLevel.vsnprintf_s = GetProcAddress(hNtDll, "_vsnprintf_s");

	CONTEXT ctx;
	memset(&ctx, 0, sizeof(ctx));
	ctx.ContextFlags = CONTEXT_ALL;
	if (FALSE == GetThreadContext(pInfo.hThread, &ctx)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	DWORD revCfgOffset;
	if (!fRevTracer->GetExport("revtracerConfig", revCfgOffset)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	rev::RevtracerConfig *revCfg = (rev::RevtracerConfig *)(revTracerAddr + revCfgOffset);

	revCfg->context = nullptr;
	revCfg->entryPoint = (rev::ADDR_TYPE)ctx.Eip;
	InitSegments(pInfo.hThread, revCfg->segmentOffsets);

	revCfg->hookCount = 0;

	DWORD ldrPerform;
	if (!fLoader->GetExport("LoaderPerform", ldrPerform)) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	ctx.Eip = dwLoaderBase + ldrPerform;
	SetThreadContext(pInfo.hThread, &ctx);

	DWORD exitCode;
	HANDLE hDbg = CreateFileA(
		"debug.log",
		GENERIC_WRITE,
		FILE_SHARE_READ,
		NULL,
		CREATE_ALWAYS,
		0,
		NULL
	);

	if (INVALID_HANDLE_VALUE == hDbg) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}
	
	HANDLE hOffs = CreateFileA(
		"bbs1.txt",
		GENERIC_WRITE,
		FILE_SHARE_READ,
		NULL,
		CREATE_ALWAYS,
		0,
		NULL
	);

	if (INVALID_HANDLE_VALUE == hOffs) {
		TerminateProcess(pInfo.hProcess, 0);
		return 0;
	}

	int cFile = _open_osfhandle((intptr_t)hOffs, _O_TEXT);
	FILE *fOffs = _fdopen(cFile, "wt");

	ResumeThread(pInfo.hThread); 
	
	bool bRunning = true;
	while (bRunning) {
		GetExitCodeProcess(pInfo.hProcess, &exitCode);

		if (STILL_ACTIVE != exitCode) {
			break;
		}

		ipcToken->Wait(REMOTE_TOKEN_USER);

		while (!debugLog->IsEmpty()) {
			int read;
			DWORD written;
			debugLog->Read(debugBuffer, sizeof(debugBuffer)-1, read);

			WriteFile(hDbg, debugBuffer, read, &written, NULL);
		}

		

		switch (ipcData->type) {
			case REPLY_MEMORY_ALLOC :
			case REPLY_MEMORY_FREE :
			case REPLY_TAKE_SNAPSHOT :
			case REPLY_RESTORE_SNAPSHOT :
			case REPLY_INITIALIZE_CONTEXT :
			case REPLY_CLEANUP_CONTEXT :
			//case REPLY_EXECUTION_CONTORL :
			case REPLY_SYSCALL_CONTROL :
				__asm int 3;
				break;
			
			case REQUEST_MEMORY_ALLOC: {
				DWORD offset;
				ipcData->type = REPLY_MEMORY_ALLOC;
				ipcData->data.asMemoryAllocReply.pointer = shmAlloc->Allocate(ipcData->data.asMemoryAllocRequest, offset);
				ipcData->data.asMemoryAllocReply.offset = offset;
				break;
			}

			/*case REQUEST_EXECUTION_BEGIN: {
				ipc::ADDR_TYPE next = ipcData->data.asExecutionBeginRequest.nextInstruction;
				
				
				ipcData->type = REPLY_EXECUTION_BEGIN;
				ipcData->data.asExecutionBeginReply = EXECUTION_ADVANCE;
				if (!FixProcessorFeature(pInfo.hProcess, dwLoaderBase + ldrMyIPFPOffset) || !UnmapMainModule("a.exe", pInfo.dwProcessId, pInfo.hProcess)) {
					ipcData->data.asExecutionBeginReply = EXECUTION_TERMINATE;
				}
				break;
			}

			case REQUEST_EXECUTION_CONTORL: {
				ipc::ADDR_TYPE next = ipcData->data.asExecutionControlRequest.nextInstruction;

				char mf[MAX_PATH];
				char defMf[8] = "??";

				DWORD dwSz = GetMappedFileNameA(GetCurrentProcess(), next, mf, sizeof(mf)-1);

				char *module = defMf;
				for (unsigned int i = 1; i < dwSz; ++i) {
					if (mf[i - 1] == '\\') {
						module = &mf[i];
					}
				}

				for (char *t = module; *t != '\0'; ++t) {
					*t = toupper(*t);
				}

				fprintf(fOffs, "%s + 0x%04x\n", module, (DWORD)next);
				fflush(fOffs);

				ipcData->type = REPLY_EXECUTION_CONTORL;
				ipcData->data.asExecutionControlReply = EXECUTION_ADVANCE;
				break;
			}

			case REQUEST_EXECUTION_END:
				ipcData->type = REPLY_EXECUTION_END;
				ipcData->data.asExecutionEndReply = EXECUTION_TERMINATE;
				bRunning = false;
				break;*/

			case REQUEST_SYSCALL_CONTROL:
				ipcData->type = REPLY_SYSCALL_CONTROL;
				break;

			default :
				__asm int 3;
				break;
		}

		ipcToken->Release(REMOTE_TOKEN_USER);
	}

	while (!debugLog->IsEmpty()) {
		int read;
		DWORD written;
		debugLog->Read(debugBuffer, sizeof(debugBuffer)-1, read);

		WriteFile(hDbg, debugBuffer, read, &written, NULL);
	}


	CloseHandle(hDbg);
	CloseHandle(hOffs);

	WaitForSingleObject(pInfo.hThread, INFINITE);


	system("pause");

	return 0;
}
```

`revmaster/revmaster.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{BF3D3D57-E671-4A69-BCC1-D739B02D0B24}</ProjectGuid>
    <RootNamespace>revmaster</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\ipclib\ShmTokenRing.cpp" />
    <ClCompile Include="DualAllocator.cpp" />
    <ClCompile Include="Loader\Extern.Mapper.cpp" />
    <ClCompile Include="Loader\Inproc.Mapper.cpp" />
    <ClCompile Include="Loader\Mem.Mapper.cpp" />
    <ClCompile Include="Loader\PE.ldr.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\ipclib\RingBuffer.h" />
    <ClInclude Include="..\ipclib\ShmTokenRing.h" />
    <ClInclude Include="DualAllocator.h" />
    <ClInclude Include="Loader\Abstract.Mapper.h" />
    <ClInclude Include="Loader\Extern.Mapper.h" />
    <ClInclude Include="Loader\Inproc.Mapper.h" />
    <ClInclude Include="Loader\Mem.Mapper.h" />
    <ClInclude Include="Loader\PE.ldr.h" />
    <ClInclude Include="Loader\Types.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`revtracer-wrapper/CMakeLists.txt`:

```txt
## revtracer-wrapper CMakeLists.txt

set(LIBRARY_NAME "revtracerwrapper")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -m32 -std=c++11")

add_library(${LIBRARY_NAME} SHARED
	RevtracerWrapper.cpp
	Wrapper.Linux.cpp
	Wrapper.Windows.cpp
	)

target_link_libraries(${LIBRARY_NAME}
	binloader
	dl
	)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`revtracer-wrapper/Main.cpp`:

```cpp
#include "RevtracerWrapper.h"
#include <stdio.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <semaphore.h>
#include "../BinLoader/LoaderAPI.h"


// Used for revtracer wrapper local tests
//
int TestCallMapMemoryHandler_basic() {
	void *address = (void*)0;
	void *addr = revwrapper::CallMapMemoryHandler(0, 0, 0, 1000, address);
	printf("[TestCallMapMemoryHandler_basic] Result [%p]\n", addr);
	return addr == (void*)-1;
}

int TestCallMapMemoryHandler_valid_shm() {
	int shmFd = revwrapper::CallOpenSharedMemory("/test-valid-shm", O_CREAT | O_RDWR | O_TRUNC | O_EXCL, 0644);
	assert(shmFd != -1);
	void *address = (void*)0xb7aab000;
	void *addr = revwrapper::CallMapMemoryHandler(shmFd, 0, 0, 1000, address);
	revwrapper::CallUnlinkSharedMemory("/test-valid-shm");
	printf("[TestCallMapMemoryHandler_valid_shm] Result [%p]\n", addr);
	return addr != (void*)-1;
}

int TestSemaphore() {
	sem_t semaphore;
	int ret = revwrapper::CallInitSemaphore((void*)&semaphore, 0, 1);
	assert(ret == 0);
	ret = revwrapper::CallWaitSemaphore((void*)&semaphore, true);
	assert(ret == 0);
	ret = revwrapper::CallPostSemaphore((void*)&semaphore);
	assert(ret == 0);
	int value = 0;
	ret = revwrapper::CallGetValueSemaphore((void*)&semaphore, &value);
	assert(ret == 0);
	ret = revwrapper::CallDestroySemaphore((void*)&semaphore);
	assert(ret == 0);
	return 1;
}

int main () {
  MODULE_PTR lpModule;
  BASE_PTR lpBase;
  CreateModule("libpthread.so", lpModule);
  MapModule(lpModule, lpBase, true);
  int ret = revwrapper::InitRevtracerWrapper(0, lpBase);
  if (ret != 0) {
	  printf("Cannot initialize revtracer-wrapper\n");
	  return 0;
  }
  assert(TestCallMapMemoryHandler_basic() == 1);
  assert(TestCallMapMemoryHandler_valid_shm() == 1);
  assert(TestSemaphore() == 1);
}

```

`revtracer-wrapper/Makefile`:

```
lib_revwrapper := librevtracerwrapper.so
CC := gcc
CXX := g++
CPP_FILES := RevtracerWrapper.cpp Wrapper.Linux.cpp Wrapper.Windows.cpp
OBJ_FILES := $(addprefix ,$(notdir $(CPP_FILES:.cpp=.o)))
LD_FLAGS := -ldl
CC_FLAGS += -g -m32 -std=c++11
LIB_BINLOADER_PATH := ../BinLoader/libbinloader.a
prefix := /usr/local

all: $(lib_revwrapper)

test: $(lib_revwrapper) Main.o
	$(CXX) $(CC_FLAGS) Main.o -L. -lrevtracerwrapper -lrt -o test

install: $(lib_revwrapper)
	install -m 0755 $(lib_revwrapper) -t $(prefix)/lib -D

$(lib_revwrapper): $(OBJ_FILES)
	$(CXX) $(CC_FLAGS) -shared -o $@ $^ $(LIB_BINLOADER_PATH) $(LD_FLAGS)

%.o: %.cpp
	   $(CXX) $(CC_FLAGS) -c $(CC_LIB) -o $@ $<

.PHONY: clean
clean:
	$(RM) $(lib_revwrapper) $(OBJ_FILES) test Main.o lib/*

```

`revtracer-wrapper/RevtracerWrapper.cpp`:

```cpp
#include "RevtracerWrapper.h"
#include "../CommonCrossPlatform/Common.h"

#include "Wrapper.Global.h"

AllocateVirtualFunc allocateVirtual;
FreeVirtualFunc freeVirtual;
MapMemoryFunc mapMemory;

TerminateProcessFunc terminateProcess;
GetTerminationCodeFunc getTerminationCode;

FormatPrintFunc formatPrint;

WriteFileFunc writeFile;
ToErrnoFunc toErrno;

YieldExecutionFunc yieldExecution;
InitEventFunc initEvent;
WaitEventFunc waitEvent;
PostEventFunc postEvent;
DestroyEventFunc destroyEvent;
GetValueEventFunc getvalueEvent;

OpenSharedMemoryFunc openSharedMemory;
UnlinkSharedMemoryFunc unlinkSharedMemory;

FlushInstructionCacheFunc flushInstructionCache;

void *CallAllocateMemoryHandler(unsigned long dwSize)
{
	return allocateVirtual(dwSize);
}

void CallFreeMemoryHandler(void *address) {
	return freeVirtual(address);
}

void *CallMapMemoryHandler(unsigned long mapHandler, unsigned long access, unsigned long offset, unsigned long size, void *address) {
	return mapMemory(mapHandler, access, offset, size, address);
}

void CallTerminateProcessHandler(void) {
	terminateProcess(0);
}

void *CallGetTerminationCodeHandler(void) {
	return getTerminationCode();
}

int CallFormattedPrintHandler(char * buffer, unsigned int sizeOfBuffer, const char * format, char *argptr) {
	return formatPrint(buffer, sizeOfBuffer, format, (char *)argptr);
}

bool CallWriteFile(void *handle, void *buffer, unsigned int size, unsigned long *written) {
	return writeFile(handle, buffer, size, written);
}

long CallConvertToSystemErrorHandler(long status) {
	return toErrno(status);
}

// Used until we replace the ipclib spinlock with signals / events
long CallYieldExecution(void) {
	return yieldExecution();
}

bool CallInitEvent(void *handle, bool isSet) {
	return initEvent(handle, isSet);
}

bool CallWaitEvent(void *handle, int timeout) {
	return waitEvent(handle, timeout);
}

bool CallPostEvent(void *handle) {
	return postEvent(handle);
}

void CallDestroyEvent(void *handle) {
	destroyEvent(handle);
}

void CallGetValueEvent(void *handle, int *ret) {
	*ret = getvalueEvent(handle);
}

int CallOpenSharedMemory(const char *name, int oflag, int mode) {
	return openSharedMemory(name, oflag, mode);
}

int CallUnlinkSharedMemory(const char *name) {
	return unlinkSharedMemory(name);
}

void CallFlushInstructionCache(void) {
	flushInstructionCache();
}

namespace revwrapper {
	extern "C" bool InitRevtracerWrapper(void *configPage);

	DLL_WRAPPER_PUBLIC WrapperImports wrapperImports;
	
}; //namespace revwrapper

```

`revtracer-wrapper/RevtracerWrapper.h`:

```h
#ifndef _REVTRACER_WRAPPER_H
#define _REVTRACER_WRAPPER_H

#include "../CommonCrossPlatform/LibraryLayout.h"
#include "TokenRing.h"

namespace revwrapper {
	#if defined _WIN32 || defined __CYGWIN__
		#ifdef _BUILDING_REVTRACER_WRAPPER_DLL
			#ifdef __GNUC__
				#define DLL_WRAPPER_PUBLIC __attribute__ ((dllexport))
			#else
				#define DLL_WRAPPER_PUBLIC __declspec(dllexport)
			#endif
		#else
			#ifdef __GNUC__
				#define DLL_WRAPPER_PUBLIC __attribute__ ((dllimport))
			#else
				#define DLL_WRAPPER_PUBLIC __declspec(dllimport)
			#endif
		#endif
		#define DLL_WRAPPER_LOCAL
	#else
		#if __GNUC__ >= 4
			#define DLL_WRAPPER_PUBLIC __attribute__ ((visibility ("default")))
			#define DLL_WRAPPER_LOCAL  __attribute__ ((visibility ("hidden")))
		#else
			#define DLL_WRAPPER_PUBLIC
			#define DLL_WRAPPER_LOCAL
		#endif
	#endif

	#define WAIT_INFINITE 0x3FFFFFFF

	struct WrapperImports {
		ext::LibraryLayout *libraries;

		union {
			struct {
				struct {
					unsigned int _virtualAlloc;
					unsigned int _virtualFree;
					unsigned int _terminateProcess;
					unsigned int _writeFile;
					unsigned int _waitForSingleObject;
					unsigned int _formatPrint;
					unsigned int _print;
					unsigned int _clockGetTime;
				} libc;

				struct {
					unsigned int _shm_open;
					unsigned int _shm_unlink;
				} librt;

				struct {
					unsigned int _yieldExecution;
					unsigned int _sem_init;
					unsigned int _sem_wait;
					unsigned int _sem_timedwait;
					unsigned int _sem_post;
					unsigned int _sem_destroy;
					unsigned int _sem_getvalue;
				} libpthread;
			} linFunc;

			struct {
				struct {
					unsigned int _virtualAlloc;
					unsigned int _virtualFree;
					unsigned int _mapMemory;

					unsigned int _flushMemoryCache;

					unsigned int _terminateProcess;

					unsigned int _writeFile;
					unsigned int _waitForSingleObject;

					unsigned int _systemError;

					unsigned int _formatPrint;

					unsigned int _ntYieldExecution;
					unsigned int _flushInstructionCache;

					unsigned int _createEvent;
					unsigned int _setEvent;
				} ntdll;
			} winFunc;
		} functions;
	};

	/** Initializes the API-wrapper */
	typedef bool(*InitRevtracerWrapperFunc)(void *configPage);

	/** Allocates virtual memory */
	typedef void *(*AllocateMemoryFunc)(unsigned long);

	/** Frees virtual memory */
	typedef void (*FreeMemoryFunc)(void*);

	/** Terminates the current process */
	typedef void (*TerminateProcessFunc)(int);

	/** Gets the address of the last executed basic block (before the process is terminated) */
	typedef void *(*GetTerminationCodeFunc)(void);

	/** Formatted print utility function */
	typedef int (*FormattedPrintFunc)(
		char *buffer,
		unsigned int sizeOfBuffer,
		const char *format,
		char *argptr
	);

	/** Write to file utility function (used only for basic block logging) */
	typedef bool (*WriteFileFunc)(
		void *handle,
		void *buffer,
		unsigned int size,
		unsigned long *written
	);

	/** Init semaphore */
	typedef bool (*InitEventFunc)(
		void *handle,
		bool isSet
	);

	/** Wait for semaphore, set timeout to 0 for trywait, or WAIT_INFINITE for a permanent wait */
	typedef bool (*WaitEventFunc)(
		void *handle,
		int timeout
	);

	/** Post semaphore */
	typedef bool (*PostEventFunc)(
		void *handle
	);

	/** Destroy semaphore */
	typedef void (*DestroyEventFunc)(
		void *handle
	);

	/** Get value semaphore */
	typedef void (*GetValueEventFunc)(
		void *handle,
		int *ret
	);

	/** Open shared mem */
	typedef int (*OpenSharedMemoryFunc)(
		const char *name,
		int oflag,
		int mode
	);

	/** Unlink shared mem */
	typedef int (*UnlinkSharedMemoryFunc)(
		const char *name
	);

	/** Flush contents of instruction cache */
	typedef void (*FlushInstructionCacheFunc)(void);

	struct WrapperExports {
		InitRevtracerWrapperFunc initRevtracerWrapper;
		AllocateMemoryFunc allocateMemory;
		FreeMemoryFunc freeMemory;

		TerminateProcessFunc terminateProcess;
		GetTerminationCodeFunc getTerminationCode;

		FormattedPrintFunc formattedPrint;

		WriteFileFunc writeFile;

		InitEventFunc initEvent;
		WaitEventFunc waitEvent;
		PostEventFunc postEvent;
		DestroyEventFunc destroyEvent;
		GetValueEventFunc getValueEvent;
		OpenSharedMemoryFunc openSharedMemory;
		UnlinkSharedMemoryFunc unlinkSharedMemory;

		TokenRing *tokenRing;
	};

	extern "C" {
		DLL_WRAPPER_PUBLIC extern WrapperImports wrapperImports;
		DLL_WRAPPER_PUBLIC extern WrapperExports wrapperExports;
	};
}; //namespace revwrapper

#endif

```

`revtracer-wrapper/ShmTokenRingLin.cpp`:

```cpp
#ifdef __linux__

#include "ShmTokenRingLin.h"
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#else
#define dbg_log(fmt,...) { printf(fmt, ##__VA_ARGS__); fflush(stdout); }
#endif


#define DEBUG_BREAK asm volatile("int $0x3")

namespace revwrapper {

	ShmTokenRingLin::~ShmTokenRingLin() {
		dbg_log("[ShmTokenRingLin] Destructor is called\n");
		((DestroySemaphoreHandler)ipcAPI->destroySemaphore)((void*)&use_semaphore);
		for (int i = 0; i < MAX_USER_COUNT; i++)
			if (valid[i]) {
				((DestroySemaphoreHandler)ipcAPI->destroySemaphore)((void*)&semaphores[i]);
			}
	}

	void dump_sem_mem(sem_t *s) {
		dbg_log("!!!!!!!!!!!!!!!!!!!!!!!!!!!1Dumping mem for semaphore  %p\n", s);
		unsigned char *p = (unsigned char*)s;
		for (int i = 0; i < 16; i++)
			dbg_log("%x ", *(p + i));
		dbg_log("\n");
	}

	void ShmTokenRingLin::Init(long presetUsers) {
		dbg_log("[ShmTokenRingLin] Initialization with %lu presetUsers\n", presetUsers);

		userCount = presetUsers;
		currentOwner = 0;

		((InitSemaphoreHandler)ipcAPI->initSemaphore)((void*)&use_semaphore, 1, 1);

		sem_t s;
		for (int i = 0; i < MAX_USER_COUNT; i++) {
			valid[i] = false;
		}
	}


	void ShmTokenRingLin::SetIpcApiHandler(IpcAPI *ipcAPI) {
		this->ipcAPI = ipcAPI;
	}

	unsigned long ShmTokenRingLin::Use(unsigned long id) {

		int ret = 0;
		if (id >= MAX_USER_COUNT) {
			return -1;
		}

		((GetvalueSemaphoreHandler)ipcAPI->getvalueSemaphore)(&use_semaphore, &ret);
		dbg_log("[ShmTokenRingLin] User %lu tries to start this %p sem value %d\n", id, &use_semaphore, ret);
		ret = ((WaitSemaphoreFunc)ipcAPI->waitSemaphore)(&use_semaphore, true);
		if (ret != 0) {
			dbg_log("[ShmTokenRingLin] Wait for use_semaphore failed\n");
		}
		((GetvalueSemaphoreHandler)ipcAPI->getvalueSemaphore)(&use_semaphore, &ret);
		dbg_log("[ShmTokenRingLin] Sem value after wait is %d\n", ret);
		dump_sem_mem(&semaphores[id]);
		ret = ((InitSemaphoreHandler)ipcAPI->initSemaphore)(&semaphores[id], 1, 0);
		dump_sem_mem(&semaphores[id]);

		dbg_log("[ShmTokenRingLin] Inited sem %lu with ret %d addr %p\n", id, ret, &semaphores[id]);
		valid[id] = true;
		userCount += 1;
		ret = ((PostSemaphoreFunc)ipcAPI->postSemaphore)(&use_semaphore);
		if (ret != 0) {
			dbg_log("[ShmTokenRingLin] Post use_semaphore failed\n");
		}

		((GetvalueSemaphoreHandler)ipcAPI->getvalueSemaphore)(&use_semaphore, &ret);
		dbg_log("[ShmTokenRingLin] User %lu started this  %p sem val %d\n", id, this, ret);
		return id;
	}

	bool ShmTokenRingLin::Wait(long int userId, bool blocking) {

		while(1) {
			dbg_log("[ShmTokenRingLin] User %ld waiting for token sem valid %d\n", userId, (int)valid[userId]);
			int ret = ((WaitSemaphoreFunc)ipcAPI->waitSemaphore)(&semaphores[userId], blocking);
			if (ret != 0) {
				if (!blocking)
					return false;
			} else {
				dump_sem_mem(&semaphores[userId]);
				((GetvalueSemaphoreHandler)ipcAPI->getvalueSemaphore)(&semaphores[userId], &ret);
				dbg_log("[ShmTokenRingLin] !!! User %ld wait finished sem %p sem val = %d\n", userId, &semaphores[userId], ret);
				dump_sem_mem(&semaphores[userId]);
				return true;
			}
		}

	}

	void ShmTokenRingLin::Release(long userId) {

		unsigned long localCurrentOwner = (userId + 1) % userCount;
		if (!valid[localCurrentOwner]) {
			dbg_log("[ShmTokenRingLin] Trying to release invalid semaphore %lu\n", localCurrentOwner);
			return;
		}
		int ret = ((PostSemaphoreFunc)ipcAPI->postSemaphore)(&semaphores[localCurrentOwner]);
		dbg_log("[ShmTokenRingLin] User %lu unlocks sem for %lu ret %d\n", userId, localCurrentOwner, ret);
	}
} //namespace ipc

#endif

```

`revtracer-wrapper/ShmTokenRingLin.h`:

```h
#ifndef _SHM_TOKEN_RING_LIN
#define _SHM_TOKEN_RING_LIN

#ifdef __linux__
#include <semaphore.h>
#include "common.h"
#define MAX_USER_COUNT 2

namespace revwrapper {
	class ShmTokenRingLin {
	private:
		sem_t semaphores[MAX_USER_COUNT];
		bool valid[MAX_USER_COUNT];
		sem_t use_semaphore;
		IpcAPI *ipcAPI;
		volatile long currentOwner;
		volatile long userCount;

	public:
		~ShmTokenRingLin();
		void Init(long presetUsers);
		void SetIpcApiHandler(IpcAPI *ipcAPI);

		unsigned long Use(unsigned long id);

		bool Wait(long int userId, bool blocking = true);
		void Release(long userId);
	};

} //namespace revwrapper

#endif

#endif

```

`revtracer-wrapper/ShmTokenRingWin.cpp`:

```cpp
#if defined _WIN32 || defined __CYGWIN__


//#include "ipclib.h"



namespace revwrapper {


};

#endif
```

`revtracer-wrapper/TokenRing.Linux.h`:

```h
#ifndef _TOKEN_RING_LINUX_H_
#define _TOKEN_RING_LINUX_H_

#if defined __linux__
#include <semaphore.h>
#include "../CommonCrossPlatform/Common.h"

namespace revwrapper {

	#define MAX_USER_COUNT 4

	struct TokenRingOsData {
		long userCount;

		sem_t semaphores[MAX_USER_COUNT];
	};
};


#endif

#endif

```

`revtracer-wrapper/TokenRing.Windows.h`:

```h
#ifndef _TOKEN_RING_WINDOWS_H_
#define _TOKEN_RING_WINDOWS_H_

#if defined _WIN32 || defined __CYGWIN__

namespace revwrapper {
	typedef void *HANDLE;

	#define MAX_USER_COUNT 4

	struct TokenRingOsData {
		long userCount;

		HANDLE waitSem[MAX_USER_COUNT];
		HANDLE postSem[MAX_USER_COUNT];
	};
};

#endif

#endif

```

`revtracer-wrapper/TokenRing.h`:

```h
#ifndef _ABSTRACT_TOKEN_RING_
#define	_ABSTRACT_TOKEN_RING_

namespace revwrapper {
	
	typedef bool(*WaitEventFunc)(void *handle, int timeout);
	typedef bool(*PostEventFunc)(void *handle);

#define RING_OS_DATA_SIZE 64


	struct TokenRing;

	struct TokenRingOps {
		typedef bool(*WaitFunc)(TokenRing *_this, long userId, bool blocking);
		typedef void(*ReleaseFunc)(TokenRing *_this, long userId);
		
		WaitFunc __Wait;
		ReleaseFunc __Release;
	};

	struct TokenRing {
		TokenRingOps *ops;
		unsigned char osData[RING_OS_DATA_SIZE];

		//friend bool InitTokenRing(TokenRing *_this, long userCount, unsigned int *pids, long token);
		//friend struct TokenRingOps;
		
		bool Wait(long userId, bool blocking = true) {
			return ops->__Wait(this, userId, blocking);
		}

		void Release(long userId) {
			ops->__Release(this, userId);
		}
	};

	
} //namespace ipc

#endif

```

`revtracer-wrapper/UnifiedTokenRing.cpp`:

```cpp
#include "AbstractShmTokenRing.h"

#ifdef __linux__
#include "ShmTokenRingLin.h"
#elif defined(_WIN32)
#include "ShmTokenRingWin.h"
#endif

namespace ipc {
	AbstractShmTokenRing *AbstractShmTokenRingFactory(void) {
#ifdef __linux__
		return new ShmTokenRingLin();
#elif defined(_WIN32)
		return new ShmTokenRingWin();
#endif
	}
}

```

`revtracer-wrapper/Wrapper.Global.h`:

```h
#ifndef _WRAPPER_GLOBAL_H_
#define _WRAPPER_GLOBAL_H_

typedef void *(*AllocateVirtualFunc)(unsigned long);
typedef void (*FreeVirtualFunc)(void *);
typedef void *(*MapMemoryFunc)(unsigned long, unsigned long, unsigned long, unsigned long, void *);

typedef void (*TerminateProcessFunc)(int);
typedef void *(*GetTerminationCodeFunc)();

typedef int (*FormatPrintFunc)(char *buffer, size_t sizeOfBuffer, const char *format, char *);

typedef bool (*WriteFileFunc)(void *, void *, size_t, unsigned long *);
typedef long (*ToErrnoFunc)(long);

typedef long (*YieldExecutionFunc)(void);
typedef bool (*InitEventFunc)(void *, bool);
typedef bool (*WaitEventFunc)(void *, int);
typedef bool (*PostEventFunc)(void *);
typedef void (*DestroyEventFunc)(void *);
typedef int (*GetValueEventFunc) (void *);

typedef int (*OpenSharedMemoryFunc) (const char *, int, int);
typedef int (*UnlinkSharedMemoryFunc) (const char *);

typedef void (*FlushInstructionCacheFunc)(void);


extern AllocateVirtualFunc allocateVirtual;
extern FreeVirtualFunc freeVirtual;
extern MapMemoryFunc mapMemory;

extern TerminateProcessFunc terminateProcess;
extern GetTerminationCodeFunc getTerminationCode;

extern FormatPrintFunc formatPrint;

extern WriteFileFunc writeFile;
extern ToErrnoFunc toErrno;

extern YieldExecutionFunc yieldExecution;
extern InitEventFunc initEvent;
extern WaitEventFunc waitEvent;
extern PostEventFunc postEvent;
extern DestroyEventFunc destroyEvent;
extern GetValueEventFunc getvalueEvent;

extern OpenSharedMemoryFunc openSharedMemory;
extern UnlinkSharedMemoryFunc unlinkSharedMemory;

extern FlushInstructionCacheFunc flushInstructionCache;

#endif

```

`revtracer-wrapper/Wrapper.Linux.cpp`:

```cpp
#ifdef __linux__

#include <dlfcn.h>
#include <stdarg.h>

#include "Wrapper.Global.h"
#include "TokenRing.h"
#include "TokenRing.Linux.h"

#include "RevtracerWrapper.h"
#include "../BinLoader/LoaderAPI.h"
#include "../CommonCrossPlatform/Common.h"

#include <semaphore.h>
#include <time.h>
#include <asm/ldt.h>

#define CALL_API(LIB, FUNC, TYPE) ((TYPE)((unsigned char *)revwrapper::wrapperImports.libraries->linLib.LIB##Base + revwrapper::wrapperImports.functions.linFunc.LIB.FUNC))

/*typedef void* lib_t;

DLL_WRAPPER_LOCAL MODULE_PTR lpthreadModule;
DLL_WRAPPER_LOCAL lib_t lcModule, lrtModule;*/

typedef int (*PrintfHandler)(const char *format, ...);
PrintfHandler _print;

// ------------------- Memory allocation ----------------------
typedef void* (*AllocateMemoryHandler)(
	void *addr,
	size_t length, 
	int prot, 
	int flags, 
	int fd, 
	off_t offset
);

//AllocateMemoryHandler _virtualAlloc;

void *LinAllocateVirtual(unsigned long size) {
	//return _virtualAlloc(NULL, size, 0x7, 0x21, 0, 0); // RWX shared anonymous
	return CALL_API(libc, _virtualAlloc, AllocateMemoryHandler) (NULL, size, 0x7, 0x21, 0, 0); // RWX shared anonymous
}

// ------------------- Memory deallocation --------------------
typedef int (*FreeMemoryHandler)(
	void *addr, 
	size_t length
);

void LinFreeVirtual(void *address) {
	// TODO: implement some size retrieval mechanism
	// CALL_API(libc, _virtualFree, FreeMemoryHandler)
}

// ------------------- Memory mapping ------------------------
typedef AllocateMemoryHandler MapMemoryHandler;

void *LinMapMemory(unsigned long mapHandler, unsigned long access, unsigned long offset, unsigned long size, void *address) {
	void *addr =  CALL_API(libc, _virtualAlloc, AllocateMemoryHandler) (address, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, (int)mapHandler, offset);
	_print("[RevtracerWrapper] LinMapMemory: received %p input shm %d size %lu address %p at offset %08lx\n", addr, (int)mapHandler, size, address, offset);
	return addr;
}

// ------------------- Process termination --------------------
typedef void(*TerminateProcessHandler)(
	int status
);

void LinTerminateProcess(int retCode) {
	CALL_API(libc, _terminateProcess, TerminateProcessHandler) (retCode);
}

void *LinGetTerminationCodeFunc() {
	return CALL_API(libc, _terminateProcess, void *);
}

// ------------------- Write file -----------------------------
typedef ssize_t(*WriteFileHandler)(
	int fd, 
	const void *buf, 
	size_t count
);

bool LinWriteFile(void *handle, void *buffer, size_t size, unsigned long *written) {
	*written = CALL_API(libc, _writeFile, WriteFileHandler) ((int)handle, buffer, size);
	return (0 <= written);
}

// ------------------- Error codes ----------------------------

long LinToErrno(long ntStatus) {
	return ntStatus;
}

// ------------------- Formatted print ------------------------
typedef int(*FormatPrintHandler)(
	char *buffer,
	size_t count,
	const char *format,
	va_list argptr
	);

int LinFormatPrint(char *buffer, size_t sizeOfBuffer, const char *format, char *argptr) {
	return CALL_API(libc, _formatPrint, FormatPrintHandler) (buffer, sizeOfBuffer - 1, format, (va_list)argptr);
}

// ------------------- Yield execution ------------------------
typedef int(*YieldExecutionHandler) (void);

long LinYieldExecution(void) {
	return (long) CALL_API(libpthread, _yieldExecution, YieldExecutionHandler) ();
}

// ------------------- Flush instr cache ----------------------
void LinFlushInstructionCache(void) {
}

// ------------------- Wait semaphore -------------------------
typedef int(*WaitSemaphoreFunc) (sem_t *);
typedef int(*PostSemaphoreFunc) (sem_t *);
typedef int(*TimedWaitSemaphoreFunc) (sem_t *, const struct timespec *);
typedef int(*ClockGetTimeFunc) (clockid_t clk_id, struct timespec *tp);

static long sec_to_nsec = 1000000000;

#define __NR_get_thread_area 244
void DebugSegmentDescriptors() {
	struct user_desc* table_entry_ptr = NULL;

	table_entry_ptr = (struct user_desc*)malloc(sizeof(struct user_desc));

	for (int i = 0; i < 0x100; i) {
		table_entry_ptr->entry_number = i;
		int ret = syscall( __NR_get_thread_area,
				table_entry_ptr);
		if (ret == -1 && errno == EINVAL) {
		} else if (ret == 0) {
			_print("[RevtracerWrapper] Segment %d base %08x\n", i, table_entry_ptr->base_addr);
		} else {
			printf("[Child] Error found when get_thread_area. errno %d\n", errno);
		}
	}
	free(table_entry_ptr);
}

bool LinWaitSemaphore(void *semaphore, bool blocking) {
	if (blocking) {
		//return _waitSemaphore((sem_t *)semaphore);
		return 0 == CALL_API(libpthread, _sem_wait, WaitSemaphoreFunc)((sem_t *)semaphore);
	} else {
		int ret;
		int timeout = 3;
		struct timespec abs_timeout;

		if (CALL_API(libc, _clockGetTime, ClockGetTimeFunc)(CLOCK_REALTIME, &abs_timeout) == -1) {
			_print("[RevtracerWrapper] Cannot get current time\n");
			return -1;
		}

		//abs_timeout.tv_nsec += timeout * sec_to_nsec;
		abs_timeout.tv_sec += timeout;
		//abs_timeout.tv_nsec %= 1000000000;

		unsigned int segments[0x100];
		return 0 == CALL_API(libpthread, _sem_timedwait, TimedWaitSemaphoreFunc)((sem_t *)semaphore, &abs_timeout);
		//DEBUG_BREAK;
	}
}

bool LinPostSemaphore(void *semaphore) {
	//return TRUE == SetEvent(*(HANDLE *)handle);
	return 0 == CALL_API(libpthread, _sem_post, PostSemaphoreFunc)((sem_t *)semaphore);
}

// ------------------- Token ring -----------------------------

namespace revwrapper {

	bool TokenRingWait(TokenRing *_this, long userId, bool blocking) {
		return LinWaitSemaphore(
			&((TokenRingOsData *)_this->osData)->semaphores[userId], 
			blocking
		);
	}

	void TokenRingRelease(TokenRing *_this, long userId) {
		long nextId = userId + 1;
		if (((TokenRingOsData *)_this->osData)->userCount == nextId) {
			nextId = 0;
		}

		/*if (1 == nextId) {
			void *p = &((TokenRingOsData *)_this->osData)->semaphores[nextId];
			int sz = sizeof(((TokenRingOsData *)_this->osData)->semaphores[nextId]);
			DEBUG_BREAK;
		}*/

		LinPostSemaphore(
			&((TokenRingOsData *)_this->osData)->semaphores[nextId]
		);
	}
};

// ------------------- Initialization -------------------------

namespace revwrapper {
	extern "C" bool InitRevtracerWrapper(void *configPage) {
		/*lcModule = dlopen("libc.so", RTLD_LAZY);
		lrtModule = dlopen("librt.so", RTLD_LAZY);
		CreateModule("libpthread.so", lpthreadModule);
		//TODO find base addresses

		if (!lcModule || !lpthreadModule) {
			DEBUG_BREAK;
			return -1;
		}

		// get functionality from ntdll
		_virtualAlloc = (AllocateMemoryHandler)LOAD_PROC(lcModule, "mmap");
		_virtualFree = (FreeMemoryHandler)LOAD_PROC(lcModule, "munmap");

		_terminateProcess = (TerminateProcessHandler)LOAD_PROC(lcModule, "exit");

		_writeFile = (WriteFileHandler)LOAD_PROC(lcModule, "write");

		_formatPrint = (FormatPrintHandler)LOAD_PROC(lcModule, "vsnprintf");
		_print = (PrintfHandler)LOAD_PROC(lcModule, "printf");

		LoadExportedName(lpthreadModule, lpthreadBase, "pthread_yield", _yieldExecution);*/

		// set global functionality
		allocateVirtual = LinAllocateVirtual;
		freeVirtual = LinFreeVirtual;
		mapMemory = LinMapMemory;

		terminateProcess = LinTerminateProcess;
		getTerminationCode = LinGetTerminationCodeFunc;

		toErrno = LinToErrno;
		formatPrint = LinFormatPrint;
		//_print("[RevtracerWrapper] InitRevtracerWrapper success\n");

		yieldExecution = LinYieldExecution;
		/*LoadExportedName(lpthreadModule, lpthreadBase, "sem_init", initSemaphore);
		_print("[RevtracerWrapper] Found InitSemaphoreFunc @address %08lx\n", (void*)initSemaphore);
		LoadExportedName(lpthreadModule, lpthreadBase, "sem_wait", _waitSemaphore);
		LoadExportedName(lpthreadModule, lpthreadBase, "sem_timedwait", _timedWaitSemaphore);
		LoadExportedName(lpthreadModule, lpthreadBase, "sem_post", postSemaphore);
		LoadExportedName(lpthreadModule, lpthreadBase, "sem_destroy", destroySemaphore);
		LoadExportedName(lpthreadModule, lpthreadBase, "sem_getvalue", getvalueSemaphore);
		_clockGetTime = (ClockGetTimeFunc)LOAD_PROC(lcModule, "clock_gettime");

		waitSemaphore = LinWaitSemaphore;
		openSharedMemory = (OpenSharedMemoryFunc)LOAD_PROC(lrtModule, "shm_open");
		unlinkSharedMemory = (UnlinkSharedMemoryFunc)LOAD_PROC(lrtModule, "shm_unlink");*/

		flushInstructionCache = LinFlushInstructionCache;
		return true;
	}

	TokenRingOps trOps = {
		TokenRingWait,
		TokenRingRelease
	};

	TokenRing tokenRing = { &trOps };

	DLL_WRAPPER_PUBLIC WrapperExports wrapperExports = {
		InitRevtracerWrapper, // remove if unused in linux
		LinAllocateVirtual,
		LinFreeVirtual,

		LinTerminateProcess,
		LinGetTerminationCodeFunc,

		LinFormatPrint,

		LinWriteFile,

		nullptr, //WinInitEvent,
		nullptr, //WinWaitEvent,
		nullptr, //WinPostEvent,
		nullptr, //WinDestroyEvent,
		nullptr, //WinGetValueEvent,
		nullptr, //CallOpenSharedMemory,
		nullptr, //CallUnlinkSharedMemory

		&tokenRing
	};
}; //namespace revwrapper

#endif

```

`revtracer-wrapper/Wrapper.Windows.cpp`:

```cpp
#if defined _WIN32 || defined __CYGWIN__

//#include <Windows.h>

#include "Wrapper.Global.h"
#include "TokenRing.h"
#include "TokenRing.Windows.h"

#include "RevtracerWrapper.h"
#include "../CommonCrossPlatform/BasicTypes.h"
using namespace nodep;

#define CALL_API(LIB, FUNC, TYPE) ((TYPE)((unsigned char *)revwrapper::wrapperImports.libraries->winLib.##LIB##Base + revwrapper::wrapperImports.functions.winFunc.##LIB##.##FUNC))

typedef long NTSTATUS;
#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

// ------------------- Memory allocation ----------------------
typedef NTSTATUS(__stdcall *AllocateMemoryHandler)(
	HANDLE               ProcessHandle,
	LPVOID               *BaseAddress,
	DWORD                ZeroBits,
	SIZE_T               *RegionSize,
	DWORD                AllocationType,
	DWORD                Protect);

LPVOID __stdcall Kernel32VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {
	LPVOID addr = lpAddress;
	if (lpAddress && (unsigned int)lpAddress < 0x10000) {
		//RtlSetLastWin32Error(87);
	}
	else {
		//NTSTATUS ret = ((AllocateMemoryHandler)((unsigned char *)libLayout->windows.ntdllBase + windowsFunctions.ntdll._virtualAlloc))(
		NTSTATUS ret = CALL_API(ntdll, _virtualAlloc, AllocateMemoryHandler) (
			hProcess,
			&addr,
			0,
			&dwSize,
			flAllocationType & 0xFFFFFFF0,
			flProtect
			);
		if (NT_SUCCESS(ret)) {
			return addr;
		}
		//SetLastError(ret);
	}
	return 0;
}

LPVOID __stdcall Kernel32VirtualAlloc(LPVOID lpAddress, size_t dwSize, DWORD flAllocationType, DWORD flProtect) {
	return Kernel32VirtualAllocEx((HANDLE)0xFFFFFFFF, lpAddress, dwSize, flAllocationType, flProtect);

	//unsigned long access, unsigned long offset, unsigned long size, void *address
}

#define MEM_COMMIT                  0x1000      
#define MEM_RESERVE                 0x2000  
#define MEM_DECOMMIT                0x4000      
#define MEM_RELEASE                 0x8000  

#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80    

void *WinAllocateVirtual(unsigned long size) {
	return Kernel32VirtualAlloc(NULL, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
}

// -------------------- Flush Memory Cache --------------------

typedef BOOL(*RtlFlushSecureMemoryCacheHandler)(
		LPVOID 	MemoryCache,
		SIZE_T 	MemoryLength
	);

// ------------------- Memory deallocation --------------------
typedef NTSTATUS(*FreeMemoryHandler)(
	HANDLE ProcessHandle,
	LPVOID *BaseAddress,
	PULONG RegionSize,
	ULONG FreeType
);

BOOL Kernel32VirtualFreeEx(
		HANDLE hProcess,
		LPVOID lpAddress,
		SIZE_T dwSize,
		DWORD  dwFreeType
	) {
		NTSTATUS ret;

		if ((unsigned __int16)(dwFreeType & 0x8000) && dwSize) {
			return FALSE;
		} else {
			ret = CALL_API(ntdll, _virtualFree, FreeMemoryHandler) (
				hProcess,
				&lpAddress, 
				(PULONG)dwSize, 
				dwFreeType
			);
			if (ret >= 0) {
				return TRUE;
			}

			if ((0xC0000045 == ret) && ((HANDLE)0xFFFFFFFF == hProcess)) {
				if (FALSE == CALL_API(ntdll, _flushMemoryCache, RtlFlushSecureMemoryCacheHandler) (lpAddress, dwSize)) {
					return FALSE;
				}
				ret = CALL_API(ntdll, _virtualFree, FreeMemoryHandler) (
					hProcess,
					&lpAddress, 
					(PULONG)dwSize, 
					dwFreeType
				);
				return (ret >= 0) ? TRUE : FALSE;
			} else {
				return FALSE;
			}
		}
	}

void WinFreeVirtual(void *address) {
	Kernel32VirtualFreeEx((HANDLE)0xFFFFFFFF, &address, 0, MEM_RELEASE);
}

// ------------------- Process termination --------------------
typedef NTSTATUS(__stdcall *TerminateProcessHandler)(
	HANDLE ProcessHandle,
	NTSTATUS ExitStatus
);

void WinTerminateProcess(int retCode) {
	CALL_API(ntdll, _terminateProcess, TerminateProcessHandler) ((HANDLE)0xFFFFFFFF, (NTSTATUS)retCode);
}

void *WinGetTerminationCodeFunc() {
	return (void *)CALL_API(ntdll, _terminateProcess, TerminateProcessHandler);
}


// ------------------- Write file -----------------------------
void *GetTEB() {
	DWORD r;
	__asm mov eax, dword ptr fs : [0x18];
	__asm mov r, eax
	return (void *)r;
}

void *GetPEB(void *teb) {
	return (void *)*((DWORD *)teb + 0x0C);
}

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;
	ULONG Flags;
	ULONG DebugFlags;
	LPVOID ConsoleHandle;
	ULONG ConsoleFlags;
	LPVOID StandardInput;
	LPVOID StandardOutput;
	LPVOID StandardError;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		LPVOID    Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

PRTL_USER_PROCESS_PARAMETERS GetUserProcessParameters(void *peb) {
	return (PRTL_USER_PROCESS_PARAMETERS)(*((DWORD *)peb + 0x10));
}

typedef NTSTATUS(__stdcall *WriteFileHandler)(
	HANDLE FileHandle,
	HANDLE Event,
	LPVOID ApcRoutine,
	LPVOID ApcContext,
	PIO_STATUS_BLOCK IoStatusBlock,
	LPVOID Buffer,
	ULONG Length,
	LPVOID ByteOffset,
	LPVOID Key
);

typedef NTSTATUS(__stdcall *NtWaitForSingleObjectFunc)(
	HANDLE Handle,
	BOOL Alertable,
	LPVOID Timeout
);

#define STATUS_WAIT_0                           ((DWORD   )0x00000000L) 
#define STATUS_ABANDONED_WAIT_0          ((DWORD   )0x00000080L)    
#define STATUS_USER_APC                  ((DWORD   )0x000000C0L)    
#define STATUS_TIMEOUT                   ((DWORD   )0x00000102L)    
#define STATUS_PENDING                   ((DWORD   )0x00000103L) 

BOOL Kernel32WriteFile(
	HANDLE hFile,
	LPVOID lpBuffer,
	DWORD nNumberOfBytesToWrite,
	DWORD *lpNumberOfBytesWritten
) {
	IO_STATUS_BLOCK ioStatus;

	ioStatus.Status = 0;
	ioStatus.Information = 0;

	if (lpNumberOfBytesWritten) {
		*lpNumberOfBytesWritten = 0;
	}

	PRTL_USER_PROCESS_PARAMETERS upp = GetUserProcessParameters(GetPEB(GetTEB()));
	HANDLE hIntFile = hFile;
	switch ((DWORD)hFile) {
	case 0xFFFFFFF4:
		hIntFile = upp->StandardError;
		break;
	case 0xFFFFFFF5:
		hIntFile = upp->StandardOutput;
		break;
	case 0xFFFFFFF6:
		hIntFile = upp->StandardInput;
		break;
	};

	NTSTATUS ret = CALL_API(ntdll, _writeFile, WriteFileHandler) (
		hIntFile,
		NULL,
		NULL,
		NULL,
		&ioStatus,
		lpBuffer,
		nNumberOfBytesToWrite,
		NULL,
		NULL
	);

	if (ret == STATUS_PENDING) {
		ret = CALL_API(ntdll, _waitForSingleObject, NtWaitForSingleObjectFunc) (
			hIntFile,
			FALSE,
			NULL
			);
		if (ret < 0) {
			if ((ret & 0xC0000000) == 0x80000000) {
				*lpNumberOfBytesWritten = ioStatus.Information;
			}
			//DefaultSetLastError(ret);
			return FALSE;
		}
		ret = ioStatus.Status;
	}

	if (ret >= 0) {
		*lpNumberOfBytesWritten = ioStatus.Information;
		return TRUE;
	}
	if ((ret & 0xC0000000) == 0x80000000) {
		*lpNumberOfBytesWritten = ioStatus.Information;
	}
	//DefaultSetLastError(ret);
	return FALSE;
}

bool WinWriteFile(void *handle, void *buffer, size_t size, unsigned long *written) {
	return TRUE == Kernel32WriteFile(handle, buffer, size, written);
}

// ------------------- Events ---------------------------------

//TODO: fix compilation warnings on windows (we _ARE_ including Windows.h here)

#define CREATE_EVENT_MANUAL_RESET 1
#define CREATE_EVENT_INITIAL_SET  2

#define EVENT_ALL_ACCESS			0x1F0003

typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	LPVOID           SecurityDescriptor;
	LPVOID           SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

int __stdcall BaseFormatObjectAttributes(OBJECT_ATTRIBUTES *objectAttributes)
{
	objectAttributes->SecurityQualityOfService = 0;
	objectAttributes->Attributes = 0;
	//v7 = (void(__stdcall *)(OBJECT_ATTRIBUTES *))dword_10152984;
	objectAttributes->RootDirectory = nullptr;
	objectAttributes->Length = 24;
	objectAttributes->ObjectName = nullptr;
	objectAttributes->SecurityDescriptor = nullptr;

	/*if (v7)
	{
		if (v7 == BasepAdjustObjectAttributesForPrivateNamespace)
		{
			BasepAdjustObjectAttributesForPrivateNamespace(objectAttributes);
		}
		else
		{
			__guard_check_icall_fptr(v7);
			v7(objectAttributes);
		}
	}*/
	//*(_DWORD *)a4 = objectAttributes;
	return 0;
}

typedef enum _EVENT_TYPE {
	NotificationEvent,
	SynchronizationEvent
} EVENT_TYPE;

typedef DWORD ACCESS_MASK;

typedef NTSTATUS(__stdcall *NtCreateEventFunc)(
	HANDLE             *EventHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	EVENT_TYPE         EventType,
	BOOLEAN            InitialState
);

HANDLE __stdcall CreateEventExW(DWORD flags, ACCESS_MASK DesiredAccess)
{
	NTSTATUS ret; // eax@3
	NTSTATUS v6; // ecx@12
	OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-28h]@3
	HANDLE EventHandle; // [sp+Ch] [bp-24h]@5
	//char v10; // [sp+18h] [bp-18h]@3

	if (flags & 0xFFFFFFFC)
	{
		v6 = 0xC00000F1;
		return nullptr;
	}
	
	ret = BaseFormatObjectAttributes(&ObjectAttributes);
	if (ret < 0) {
		return nullptr;
	}

	ret = CALL_API(ntdll, _createEvent, NtCreateEventFunc) (
		&EventHandle,
		DesiredAccess,
		&ObjectAttributes,
		(EVENT_TYPE)(~(BYTE)flags & 1),
		((BYTE)flags >> 1) & 1
	);

	if (ret < 0) {
		return nullptr;
	}

	/*if (ret == 0x40000000)
		RtlSetLastWin32Error(0xB7);
	else
		RtlSetLastWin32Error(0);*/
	return EventHandle;
}

HANDLE __stdcall CreateEventW(/*LPSECURITY_ATTRIBUTES lpEventAttributes = nullptr,*/ BOOL bManualReset, BOOL bInitialState /*, LPCWSTR lpName = nullptr */)
{
	DWORD flags;

	flags = 0;
	if (bManualReset) {
		flags = CREATE_EVENT_MANUAL_RESET;
	}
	if (bInitialState) {
		flags |= CREATE_EVENT_INITIAL_SET;
	}
		
	return CreateEventExW(flags, EVENT_ALL_ACCESS);
}

typedef NTSTATUS(__stdcall *NtSetEventFunc)(
	HANDLE EventHandle, 
	PULONG PreviousState
);

BOOL __stdcall SetEvent(HANDLE hEvent) {
	NTSTATUS ret = CALL_API(ntdll, _setEvent, NtSetEventFunc) (hEvent, 0);
	if (ret < 0) {
		return FALSE;
	}
	return TRUE;
}

bool WinInitEvent(void *handle, bool isSet) {
	*(HANDLE *)handle = CreateEventW(false, isSet);
	return true;
}

bool WinWaitEvent(void *handle, int timeout) {
	LARGE_INTEGER liWait, *pliWait = nullptr;
	
	if (timeout != WAIT_INFINITE) {
		liWait.QuadPart = -10000 * timeout; //hundreds of nanoseconds
		pliWait = &liWait;
	}

	return STATUS_WAIT_0 == CALL_API(ntdll, _waitForSingleObject, NtWaitForSingleObjectFunc) (
		*(HANDLE *) handle,
		FALSE,
		pliWait
	);
}

bool WinPostEvent(void *handle) {
	return TRUE == SetEvent(*(HANDLE *)handle);
}

void WinDestroyEvent(void *handle) {
	// NOT IMPLEMENTED
}

void WinGetValueEvent(void *handle, int *value) {
	// NOT IMPLEMENTED
	*value = -1;
}


// ------------------- Error codes ----------------------------

typedef DWORD(__stdcall *ConvertToSystemErrorHandler)(
	NTSTATUS status
);

long WinToErrno(long ntStatus) {
	return CALL_API(ntdll, _systemError, ConvertToSystemErrorHandler) (ntStatus);
}

// ------------------- Formatted print ------------------------

#define _TRUNCATE ((size_t)-1)
typedef char* va_list;
typedef int (*FormatPrintHandler)(
	char *buffer,
	size_t sizeOfBuffer,
	size_t count,
	const char *format,
	va_list argptr
);

int WinFormatPrint(char *buffer, size_t sizeOfBuffer, const char *format, char *argptr) {
	return CALL_API(ntdll, _formatPrint, FormatPrintHandler) (buffer, sizeOfBuffer, _TRUNCATE, format, (va_list)argptr);
}

// ------------------- Flush instruction cache ----------------

typedef NTSTATUS(*FlushInstructionCacheHandler)(
		HANDLE hProcess,
		LPVOID address,
		SIZE_T size
	);

void WinFlushInstructionCache(void) {
	CALL_API(ntdll, _flushInstructionCache, FlushInstructionCacheHandler) ((HANDLE)0xFFFFFFFF, NULL, 0);
}


// ------------------- Token ring -----------------------------

namespace revwrapper {

	bool TokenRingWait(TokenRing *_this, long userId, bool blocking) {
		//ShmTokenRingWin *_this = (ShmTokenRingWin *)ring;
		//TokenRingWinData *_data = (TokenRingWinData *)_this->osData;
		return WinWaitEvent(&((TokenRingOsData *)_this->osData)->waitSem[userId], blocking ? WAIT_INFINITE : 1000);
	}

	void TokenRingRelease(TokenRing *_this, long userId) {
		long nextId = userId + 1;
		if (((TokenRingOsData *)_this->osData)->userCount == nextId) {
			nextId = 0;
		}

		WinPostEvent(&((TokenRingOsData *)_this->osData)->postSem[nextId]);
	}
};


// ------------------- Initialization -------------------------

namespace revwrapper {

	extern "C" {
		bool InitRevtracerWrapper(void *configPage) {

			flushInstructionCache = WinFlushInstructionCache;
			return true;
		}
	};

	TokenRingOps trOps = {
		TokenRingWait,
		TokenRingRelease
	};

	TokenRing tokenRing = { &trOps };

	DLL_WRAPPER_PUBLIC WrapperExports wrapperExports = {
		InitRevtracerWrapper, // remove if unused in linux
		WinAllocateVirtual,
		WinFreeVirtual,

		WinTerminateProcess,
		WinGetTerminationCodeFunc,

		WinFormatPrint,

		WinWriteFile,

		nullptr, //WinInitEvent,
		nullptr, //WinWaitEvent,
		nullptr, //WinPostEvent,
		nullptr, //WinDestroyEvent,
		nullptr, //WinGetValueEvent,
		nullptr, //CallOpenSharedMemory,
		nullptr, //CallUnlinkSharedMemory

		&tokenRing
	};
}; // namespace revwrapper

DWORD DllEntry() {
	return 1;
}

#endif

```

`revtracer-wrapper/revtracer-wrapper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3F22D7DF-8353-409A-8A65-3E1987E439C8}</ProjectGuid>
    <RootNamespace>revtracerwrapper</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_BUILDING_REVTRACER_WRAPPER_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>DllEntry</EntryPointSymbol>
      <SectionAlignment>65536</SectionAlignment>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>DllEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="RevtracerWrapper.cpp" />
    <ClCompile Include="ShmTokenRingLin.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Wrapper.Linux.cpp" />
    <ClCompile Include="Wrapper.Windows.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\CommonCrossPlatform\LibraryLayout.h" />
    <ClInclude Include="RevtracerWrapper.h" />
    <ClInclude Include="ShmTokenRingLin.h">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="TokenRing.h" />
    <ClInclude Include="TokenRing.Linux.h" />
    <ClInclude Include="TokenRing.Windows.h" />
    <ClInclude Include="Wrapper.Global.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`revtracer-wrapper/setup-libs.sh`:

```sh
#! /bin/bash
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

rm -rf $DIR/lib
mkdir $DIR/lib

ln --symbolic -T `find /lib -name libc.so.6 -path *i386*` $DIR//lib/libc.so
ln --symbolic -T `find /lib -name libpthread.so.0 -path *i386*` $DIR/lib/libpthread.so
ln --symbolic -T `find /lib -name librt.so.1 -path *i386*` $DIR/lib/librt.so
ln --symbolic -T `find /lib -name ld-linux.so.2 -path *i386*` $DIR/lib/ld-linux.so.2

```

`revtracer/AddressContainer.cpp`:

```cpp
#include "revtracer.h"
#include "common.h"
#include "AddressContainer.h"

static const nodep::DWORD printMask = PRINT_INFO | PRINT_INSPECTION;

using namespace nodep;
using namespace rev;

void AddressContainer::InitPageAllocator() {
	freePageCount = MAX_CONTAINER_PAGES;

	for (DWORD i = 0; i < freePageCount; ++i) {
		freePages[i] = &pages[i];
	}
}

ContainerPage *AddressContainer::AllocPage() {
	if (0 == freePageCount) {
		return NULL;
	}

	freePageCount--;

	for (int i = 0; i < 1024; ++i) {
		freePages[freePageCount]->mem[i] = 0;
	}

	return freePages[freePageCount];
}

void AddressContainer::FreePage(ContainerPage *page) {
	freePages[freePageCount] = page;
	freePageCount++;
}

void AddressContainer::Init() {
	root = NULL;

	InitPageAllocator();
}

DWORD AddressContainer::RecursiveSet(ContainerPage *&page, DWORD dwAddress, DWORD value, DWORD mask, DWORD shift) {
	if (NULL == page) {
		if (0 == value) {
			return 0;
		}

		page = AllocPage();

		if (NULL == page) {
			return 0xFFFFFFFF;
		}
	}

	if (0 == shift) {
		DWORD dwRet = page->mem[(dwAddress & mask) >> shift];
		page->mem[(dwAddress & mask) >> shift] = value;
		return dwRet;
	}

	return RecursiveSet((ContainerPage *&)page->mem[(dwAddress & mask) >> shift], dwAddress, value, mask >> 10, shift - 10);
}

DWORD AddressContainer::Set(DWORD dwAddress, DWORD value) {
	ContainerPage *cPage = root;

	DWORD ret = 0;
	DWORD aMask = 0x3FF00000;
	BYTE aShift = 20;

	dwAddress >>= 2;

	return RecursiveSet(root, dwAddress, value, aMask, aShift);
}

DWORD AddressContainer::Get(DWORD dwAddress) const {
	ContainerPage *cPage = root;
	DWORD ret = 0;
	DWORD aMask = 0x3FF00000;
	BYTE aShift = 20;

	dwAddress >>= 2;

	while (NULL != cPage) {
		cPage = (ContainerPage *)cPage->mem[(dwAddress & aMask) >> aShift];

		aMask >>= 10;
		aShift -= 10;

		if (0 == aMask) {
			ret = (DWORD)cPage;
			break;
		}
	}

	return ret;
}

void AddressContainer::RecursivePrintAddreses(ContainerPage *page, DWORD prefix, DWORD shift) const {
	if (NULL == page) {
		return;
	}

	if (0 == shift) {
		for (DWORD i = 0; i < 1024; ++i) {
			if (0 != page->mem[i]) {
				TRACKING_PRINT(printMask, " @ 0x%08x - %d\n", (prefix | i) << 2, page->mem[i]);
			}
		}
	} else {
		for (DWORD i = 0; i < 1024; ++i) {
			RecursivePrintAddreses((ContainerPage *)page->mem[i], prefix | (i << shift), shift - 10);
		}
	}
}

void AddressContainer::PrintAddreses() const {
	RecursivePrintAddreses(root, 0, 20);
}

```

`revtracer/AddressContainer.h`:

```h
#ifndef _ADDRESS_CONTAINER_H
#define _ADDRESS_CONTAINER_H

#include "revtracer.h"

#define MAX_CONTAINER_PAGES			1024

struct ContainerPage {
	nodep::DWORD mem[1024];
};

class AddressContainer {
private :
	ContainerPage pages[MAX_CONTAINER_PAGES];
	ContainerPage *freePages[MAX_CONTAINER_PAGES];
	nodep::DWORD freePageCount;
	
	void InitPageAllocator();
	ContainerPage *AllocPage();
	void FreePage(ContainerPage *page);

	ContainerPage *root;

	nodep::DWORD RecursiveSet(ContainerPage *&page, nodep::DWORD dwAddress, nodep::DWORD value, nodep::DWORD mask, nodep::DWORD shift);
	void RecursivePrintAddreses(ContainerPage *page, nodep::DWORD prefix, nodep::DWORD shift) const;
public :
	//AddressContainer();
	void Init();

	nodep::DWORD Set(nodep::DWORD dwAddress, nodep::DWORD value);
	nodep::DWORD Get(nodep::DWORD dwAddress) const;

	void PrintAddreses() const;
};


#endif
```

`revtracer/CMakeLists.txt`:

```txt
## revtracer CMakeLists.txt

set(CMAKE_VERBOSE_MAKEFILE true)
set(CMAKE_CXX_COMPILER i686-w64-mingw32-g++)

set(FLAGS_CROSS "-D_cdecl=\"__attribute__((cdecl))\" \
	-D_stdcall=\"__attribute__((stdcall))\"")
set(CMAKE_CXX_FLAGS "-g -m32 -march=i386 -fno-exceptions \
	-fno-stack-protector -fcheck-new -std=c++11 ${FLAGS_CROSS} \
	-D_BUILDING_REVTRACER_DLL")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS}")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_RELEASE} -D_REVTRACER_DEBUG_PRINT_")

set(CMAKE_SHARED_LINKER_FLAGS "--disable-stdcall-fixup -static-libstdc++")

set(CMAKE_ASM_COMPILER i686-w64-mingw32-as)
set(CMAKE_ASM_FLAGS "--32")
set(CMAKE_ASM_FLAGS_RELEASE "${CMAKE_ASM_FLAGS}")
set(CMAKE_ASM_FLAGS_DEBUG "${CMAKE_ASM_FLAGS} -g")

set_source_files_properties(revtracer.stub.S PROPERTIES COMPILE_FLAGS "${CMAKE_ASM_FLAGS}")

add_library(revtracer SHARED
	AddressContainer.cpp
	api.cpp
	callgates.cpp
	cb.cpp crc32.cpp
	crtStub.cpp
	execenv.cpp
	GenericX86Assembler.cpp
	mm.cpp modrm32.cpp
	PreTrackingX86Assembler.cpp
	RelocableCodeBuffer.cpp
	revtracer.cpp
	RiverAddress.cpp
	TranslatorUtil.cpp
	RiverMetaTranslator.cpp
	RiverRepTranslator.cpp
	RiverRepAssembler.cpp
	RiverPrintTable.cpp
	RiverReverseTranslator.cpp
	RiverSaveTranslator.cpp
	RiverTrackingX86Assembler.cpp
	RiverX86Assembler.cpp
	RiverX86Disassembler.cpp
	NativeX86Assembler.cpp
	SymbopReverseTranslator.cpp
	SymbopTranslator.cpp
	SymbopSaveTranslator.cpp
	sync.cpp
	Tracking.cpp
	TrackingX86Assembler.cpp
	X86Assembler.cpp
	X86AssemblerFuncs.cpp
	RiverX86DisassemblerTable.cpp
	codegen.cpp
	revtracer.stub.S
	)

# disable -revtracer_EXPORTS
set_target_properties(revtracer
	PROPERTIES
	DEFINE_SYMBOL ""
	NO_SONAME ON
	PREFIX ""
	SUFFIX ".dll"
  PUBLIC_HEADER "DebugPrintFlags.h;RiverAddress.h;common.h;environment.h;revtracer.h;river.h"
	)

install(TARGETS revtracer
  LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX}/lib
  PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_PREFIX}/include/revtracer)

```

`revtracer/CodeGen.h`:

```h
#ifndef _CODEGEN_H
#define _CODEGEN_H

#include "river.h"
#include "cb.h"
#include "Runtime.h"

#include "RiverX86Disassembler.h"

#include "X86Assembler.h"

#include "RiverMetaTranslator.h"

#include "RiverRepTranslator.h"

#include "RiverReverseTranslator.h"
#include "RiverSaveTranslator.h"

#include "SymbopTranslator.h"
#include "SymbopSaveTranslator.h"
#include "SymbopReverseTranslator.h"

#define RIVER_FORWARD_INSTRUCTIONS					1024
#define RIVER_BACKWARD_INSTRUCTIONS					1024

#define SYMBOP_TRACK_INSTRUCTIONS					1024
#define SYMBOP_TRACK_FORWARD_INSTRUCTIONS			1024
#define SYMBOP_TRACK_BACKWARD_INSTRUCTIONS			1024

/* A resettable river code translator */
class RiverCodeGen {
private :
	RiverHeap *heap;
	
	RiverX86Disassembler disassembler;
	X86Assembler assembler;

	RiverMetaTranslator metaTranslator;

	RiverRepTranslator repTranslator;

	RiverReverseTranslator revTranslator;
	RiverSaveTranslator saveTranslator;

	SymbopTranslator symbopTranslator;
	SymbopSaveTranslator symbopSaveTranslator;
	SymbopReverseTranslator symbopReverseTranslator;

	nodep::DWORD TranslateBasicBlock(nodep::BYTE *px86,
			nodep::DWORD &dwInst, nodep::BYTE *&disasm,
			nodep::DWORD dwTranslationFlags, nodep::DWORD *disassFlags,
			struct rev::BranchNext *next, RevtracerError *rerror);
public :
	struct RiverInstruction fwRiverInst[RIVER_FORWARD_INSTRUCTIONS];
	struct RiverInstruction bkRiverInst[RIVER_BACKWARD_INSTRUCTIONS];
	struct RiverInstruction symbopInst[SYMBOP_TRACK_INSTRUCTIONS];
	struct RiverInstruction symbopFwRiverInst[SYMBOP_TRACK_FORWARD_INSTRUCTIONS];
	struct RiverInstruction symbopBkRiverInst[SYMBOP_TRACK_BACKWARD_INSTRUCTIONS];

	struct RiverAddress32 trRiverAddr[16384];
	
	nodep::DWORD trInstCount, fwInstCount, bkInstCount, /*srInstCount,*/ sfInstCount, sbInstCount, addrCount, outBufferSize;
	nodep::DWORD symbopInstCount;

	unsigned char *outBuffer;
	unsigned int regVersions[8];

	RelocableCodeBuffer codeBuffer;
public :
	RiverCodeGen();
	~RiverCodeGen();

	bool Init(RiverHeap *hp, RiverRuntime *rt, nodep::DWORD buffSz, nodep::DWORD dwTranslationFlags);
	bool Destroy();
	void Reset();

	struct RiverAddress *AllocAddr(nodep::WORD flags);
	struct RiverAddress *CloneAddress(const RiverAddress &mem, nodep::WORD flags);

	unsigned int GetCurrentReg(unsigned char regName) const;
	unsigned int GetPrevReg(unsigned char regName) const;

	unsigned int NextReg(unsigned char regName);

	bool Translate(RiverBasicBlock *pCB, nodep::DWORD dwTranslationFlags, RevtracerError *rerror);
	bool DisassembleSingle(nodep::BYTE *&px86, RiverInstruction *rOut, nodep::DWORD &count, nodep::DWORD &dwFlags, RevtracerError *rerror);
};

#endif

```

`revtracer/DebugPrintFlags.h`:

```h
#ifndef _DEBUG_PRINT_FLAGS_H_
#define _DEBUG_PRINT_FLAGS_H_

// message type
#define PRINT_ERROR					0x01000000
#define PRINT_INFO					0x02000000
#define PRINT_DEBUG					0x03000000
#define PRINT_MESSAGE_MASK			0x0F000000
#define PRINT_MESSAGE_SHIFT			24

// execution stages
#define PRINT_BRANCH_HANDLER		0x00100000
#define PRINT_DISASSEMBLY			0x00200000
#define PRINT_TRANSLATION			0x00300000
#define PRINT_ASSEMBLY				0x00400000
#define PRINT_RUNTIME				0x00500000
#define PRINT_INSPECTION			0x00600000
#define PRINT_CONTAINER				0x00700000
#define PRINT_EXECUTION_MASK		0x00F00000
#define PRINT_EXECUTION_SHIFT		20

// code type - only for translation and assembly
#define PRINT_NATIVE				0x00010000
#define PRINT_RIVER					0x00020000
#define PRINT_TRACKING				0x00030000
#define PRINT_SYMBOLIC				0x00040000
#define PRINT_CODE_TYPE_MASK		0x000F0000
#define PRINT_CODE_TYPE_SHIFT		16

// code direction, only for river, tracking and symbolic
#define PRINT_FORWARD				0x00001000
#define PRINT_BACKWARD				0x00002000
#define PRINT_CODE_DIRECTION_MASK	0x0000F000
#define PRINT_CODE_DIRECTION_SHIFT	12


#endif

```

`revtracer/GenericX86Assembler.cpp`:

```cpp
#include "GenericX86Assembler.h"

#define X86_OPZISE_PREFIX			0x66

#define X86_LOCK_PREFIX				0xF0

#define X86_ESSEG_PREFIX			0x26
#define X86_CSSEG_PREFIX			0x2E
#define X86_SSSEG_PREFIX			0x36
#define X86_DSSEG_PREFIX			0x3E
#define X86_FSSEG_PREFIX			0x64
#define X86_GSSEG_PREFIX			0x65

bool GenericX86Assembler::Init(RiverRuntime *rt) {
	runtime = rt;
	return true;
}

bool GeneratePrefixes(const RiverInstruction &ri, nodep::BYTE *&px86) {
	if (ri.modifiers & RIVER_MODIFIER_LOCK) {
		*px86 = X86_LOCK_PREFIX;
		px86++;
	}

	if (ri.modifiers & RIVER_MODIFIER_O16) {
		*px86 = X86_OPZISE_PREFIX;
		px86++;
	}

	switch (ri.modifiers & 0x07) {
	case RIVER_MODIFIER_ESSEG:
		*px86 = X86_ESSEG_PREFIX;
		px86++;
		break;
	case RIVER_MODIFIER_CSSEG:
		*px86 = X86_CSSEG_PREFIX;
		px86++;
		break;
	case RIVER_MODIFIER_SSSEG:
		*px86 = X86_SSSEG_PREFIX;
		px86++;
		break;
	case RIVER_MODIFIER_DSSEG:
		*px86 = X86_DSSEG_PREFIX;
		px86++;
		break;
	case RIVER_MODIFIER_FSSEG:
		*px86 = X86_FSSEG_PREFIX;
		px86++;
		break;
	case RIVER_MODIFIER_GSSEG:
		*px86 = X86_GSSEG_PREFIX;
		px86++;
		break;
	}
	return true;
}

bool ClearPrefixes(const RiverInstruction &ri, nodep::BYTE *&px86) {
	if (ri.modifiers & 0x07) {
		px86--;
	}

	if (ri.modifiers & RIVER_MODIFIER_REPNZ) {
		px86--;
	}

	if (ri.modifiers & RIVER_MODIFIER_REPZ) {
		px86--;
	}

	if (ri.modifiers & RIVER_MODIFIER_REP) {
		px86--;
	}

	if (ri.modifiers & RIVER_MODIFIER_LOCK) {
		px86--;
	}

	return true;
}

```

`revtracer/GenericX86Assembler.h`:

```h
#ifndef _GENERIC_X86_ASSEMBLER_H
#define _GENERIC_X86_ASSEMBLER_H

#include "revtracer.h"
#include "river.h"
#include "Runtime.h"

#include "RelocableCodeBuffer.h"

#define ASSEMBLER_DIR_FORWARD		0x00
#define ASSEMBLER_DIR_BACKWARD		0x01

#define ASSEMBLER_CODE_NATIVE		0x00
#define ASSEMBLER_CODE_TRACKING		0x02

class UnusedRegister {
	//virtual nodep::Acquire()
};

class GenericX86Assembler {
protected :
	RiverRuntime *runtime;

public:
	virtual bool Init(RiverRuntime *rt);
	virtual bool Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType) = 0;
};

bool GeneratePrefixes(const RiverInstruction &ri, nodep::BYTE *&px86);
bool ClearPrefixes(const RiverInstruction &ri, nodep::BYTE *&px86);

#endif
```

`revtracer/Loader/Abstract.Mapper.h`:

```h
#ifndef _ABSTRACT_MAPPER_H_
#define _ABSTRACT_MAPPER_H_

#include "Types.h"

class AbstractPEMapper {
public:
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) = 0;

	virtual DWORD FindImport(const char *moduleName, const char *funcName) = 0;
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal) = 0;
};

#endif


```

`revtracer/Loader/Inproc.Mapper.cpp`:

```cpp
#include <Windows.h>
#include "Inproc.Mapper.h"


void *InprocMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return VirtualAlloc(lpAddress, dwSize, MEM_RESERVE | MEM_COMMIT, flProtect);
}

bool InprocMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	DWORD oldProtect;
	return TRUE == VirtualProtect(lpAddress, dwSize, flProtect, &oldProtect);
}

bool InprocMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	memcpy(lpAddress, lpBuffer, nSize);
	return true;
}

DWORD InprocMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, funcName);
}

DWORD InprocMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, (LPCSTR)funcOrdinal);
}
```

`revtracer/Loader/Inproc.Mapper.h`:

```h
#ifndef _INPROC_MAPPER_H_
#define _INPROC_MAPPER_H_

#include "Abstract.Mapper.h"

class InprocMapper : public AbstractPEMapper {
public :
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif
```

`revtracer/Loader/PE.ldr.cpp`:

```cpp
#include <stdio.h>
#include <vector>
using namespace std;

#include "..\extern.h"

//#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#endif

#include "PE.ldr.h"

//#include "common/debug-log.h"
#define dbg_log DbgPrint

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5
#define IMAGE_REL_BASED_RESERVED              6
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9
#define IMAGE_REL_BASED_DIR64                 10

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     

#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     

#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define PAGE_REVERT_TO_FILE_MAP     0x80000000 

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

const USHORT DOS_MAGIC = 0x5A4D;
const DWORD PE_MAGIC = 0x00004550;
const WORD OPT32_MAGIC = 0x010B;
const WORD OPT64_MAGIC = 0x020B;

const WORD IMAGE_FILE_MACHINE_I386 = 0x14C;
const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Name;
	DWORD Base;
	DWORD NumberOfFunctions;
	DWORD NumberOfNames;
	DWORD AddressOfFunctions; // RVA from base of image
	DWORD AddressOfNames; // RVA from base of image
	DWORD AddressOfNameOrdinals; // RVA from base of image
} IMAGE_EXPORT_DIRECTORY;

void *FloatingPE::RVA(DWORD rva) const {
    for (int i = 0; i < peHdr.NumberOfSections; ++i) {
        if (rva >= sections[i].header.VirtualAddress) {
            DWORD dwOffset = rva - sections[i].header.VirtualAddress;
            if (dwOffset < sections[i].header.VirtualSize) {
                return sections[i].data + dwOffset;
            }
        }
    }
    return (void *)0;
}

bool FloatingPE::Relocate(DWORD newAddr) {
	long long offset = 0;
	IMAGE_BASE_RELOCATION *reloc;
    IMAGE_BASE_RELOCATION *term;

	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			offset = newAddr - optHdr.w32.ImageBase;
			optHdr.w32.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			offset = newAddr - optHdr.w64.ImageBase;
			optHdr.w64.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

    while (reloc < term) {
        //dbg_log("Relocation Block %08x %08x", reloc->VirtualAddress, reloc->SizeOfBlock);
        WORD *wloc = (WORD *)reloc + 4;
        int wlocCount = (reloc->SizeOfBlock - sizeof(*reloc)) / sizeof(*wloc);

        for (int i = 0; i < wlocCount; ++i) {
            //dbg_log("%x %x;\t", wloc[i] >> 12, wloc[i] & 0x0FFF);
			WORD type = wloc[i] >> 12;
			WORD off = wloc[i] & 0x0FFF;
			
			if ((i % 3) == 0) {
				//dbg_log("\n");
			}
			
			switch (type) {
				case IMAGE_REL_BASED_ABSOLUTE :
					break;
				case IMAGE_REL_BASED_HIGHLOW :
					*((DWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					//dbg_log("%08x -> %08x\t", reloc->VirtualAddress + off, *((DWORD *)RVA(reloc->VirtualAddress + off)));
					break;
				case IMAGE_REL_BASED_DIR64 :
					*((QWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					break;
				default :
					//__asm int 3;
					__debugbreak();
			}
        }
		//dbg_log("\n");
		reloc = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + reloc->SizeOfBlock);
    }


    return true;
}

bool FloatingPE::GetExport(const char *funcName, DWORD &funcRVA) {
	DWORD exportRVA = 0;
	
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			exportRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			exportRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	};
	
	if (0 == exportRVA) {
		return false;
	}

	IMAGE_EXPORT_DIRECTORY *exprt = (IMAGE_EXPORT_DIRECTORY *)RVA(exportRVA);

	dbg_log("Number of functions: %d\n", exprt->NumberOfFunctions);
	dbg_log("Number of names: %d\n", exprt->NumberOfNames);

	DWORD *names = (DWORD *)RVA(exprt->AddressOfNames);
	int found = -1;
	for (DWORD i = 0; i < exprt->NumberOfNames; ++i) {
		char *name = (char *)RVA(names[i]);
		if (0 == strcmp(name, funcName)) {
			found = i;
			break;
		}
	}

	if (-1 == found) {
		return false;
	}

	WORD *ordinals = (WORD *)RVA(exprt->AddressOfNameOrdinals);
	WORD ordinal = ordinals[found] - (WORD)exprt->Base + 1;

	DWORD *exportTable = (DWORD *)RVA(exprt->AddressOfFunctions);
	funcRVA = exportTable[ordinal];

	return true;
}

bool FloatingPE::FixImports(AbstractPEMapper &mapper) {
	DWORD importRVA = 0;
	
	
	switch (peHdr.Machine) {
	case IMAGE_FILE_MACHINE_I386:
		importRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	case IMAGE_FILE_MACHINE_AMD64:
		importRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	default:
		dbg_log("Unsupported machine type\n");
		return false;
	};

	if (0 == importRVA) {
		return true;
	}

    IMAGE_IMPORT_DESCRIPTOR *import = (IMAGE_IMPORT_DESCRIPTOR *)RVA(importRVA);
	if (NULL == import) {
		return false;
	}

    while (import->OriginalFirstThunk != 0) {
		char *name = (char *)RVA(import->Name);
        dbg_log("Directory for: %s\n", name);
		dbg_log("OFT: %08x, FT: %08x\n", import->OriginalFirstThunk, import->FirstThunk);
		DWORD *funcs = (DWORD *)RVA(import->OriginalFirstThunk);
		DWORD *iat = (DWORD *)RVA(import->FirstThunk);
        while (*funcs != 0) {
            if (0x80000000 & *funcs) {
                dbg_log("Import by ordinal %d\n", *funcs & 0x7FFF);
				*iat = mapper.FindImport(name, *funcs & 0x7FFF);
            } else {
				char *funcName = (char *)RVA(*funcs + 2);
                dbg_log("Import by name %s\n", funcName);
				*iat = mapper.FindImport(name, funcName);
            }

            funcs += 1;
			iat += 1;
        }

		import += 1;
    }

    return true;
}

bool FloatingPE::LoadPE(FILE *fModule) {
	if (NULL == fModule) {
		dbg_log("File open error!\n");
		return false;
	}

	if (1 != fread(&dosHdr, sizeof(dosHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (dosHdr.e_magic != DOS_MAGIC) {
		dbg_log("dosHdr.e_magic not valid\n");
		return false;
	}

	fseek(fModule, dosHdr.e_lfanew, SEEK_SET);


	if (1 != fread(&peHdr, sizeof(peHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (PE_MAGIC != peHdr.PeSignature) {
		dbg_log("peHdr.PeSignature not valid\n");
		return false;
	}

	//dbg_log("Machine: %d\n", peHdr.Machine);
	//dbg_log("NumberOfSections: %d\n", peHdr.NumberOfSections);
	//dbg_log("SizeOfOptionalHeader: %d\n", peHdr.SizeOfOptionalHeader);
	//dbg_log("Characteristics: %d\n", peHdr.Characteristics);

	DWORD optSize = 0;
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w32);
			break;
		case IMAGE_FILE_MACHINE_AMD64 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w64);
			break;
		default :
			dbg_log("Unsupported machine type\n");
			return false;
	}

	if (peHdr.SizeOfOptionalHeader != optSize) {
		dbg_log("Unsupported optional header\n");
		return false;
	}

	if (1 != fread(&optHdr, optSize, 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}


	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			if (OPT32_MAGIC != optHdr.c.Magic) {
				dbg_log("opt32Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %08x\n", optHdr.w32.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w32.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w32.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w32.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w32.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w32.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w32.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w32.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w32.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
			);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			if (OPT64_MAGIC != optHdr.c.Magic) {
				dbg_log("opt64Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %016x\n", optHdr.w64.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w64.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w64.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w64.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w64.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w64.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w64.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w64.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w64.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
				); break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

	

	sections.resize(peHdr.NumberOfSections);

	dbg_log("Name\t V.Size\t V.Addr\t R.Size\t R.Addr\t Characteristics\n");
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (1 != fread(&sections[i].header, sizeof(sections[i].header), 1, fModule)) {
			dbg_log("read error\n");
			return false;
		}

		dbg_log("%.8s\t %08x %08x %08x %08x %08x\n",
			sections[i].header.Name,
			sections[i].header.VirtualSize,
			sections[i].header.VirtualAddress,
			sections[i].header.SizeOfRawData,
			sections[i].header.PointerToRawData,
			sections[i].header.Characteristics);
	}

	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (!sections[i].Load(fModule)) {
			return false;
		}
	}

	return true;
}

FloatingPE::FloatingPE(const wchar_t *moduleName) {
	FILE *fModule; // = _wfopen_s(moduleName, L"rb");

	if (0 != _wfopen_s(&fModule, moduleName, L"rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}

FloatingPE::FloatingPE(const char *moduleName) {
	FILE *fModule; // = fopen(moduleName, "rb");

	if (0 != fopen_s(&fModule, moduleName, "rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}


FloatingPE::~FloatingPE() {
	//TODO: regular cleanup
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		sections[i].Unload();
	}
}

bool FloatingPE::MapPE(AbstractPEMapper &mapr, DWORD &baseAddr) {
	
	
	FixImports(mapr);
    
	
	DWORD maxAddr = 0;
	for (DWORD i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFF) & (~0xFFF);
		if (maxSec > maxAddr) {
			maxAddr = maxSec;
		}
	}
	

	baseAddr = (DWORD)mapr.CreateSection((void *)(baseAddr), maxAddr, PAGE_READWRITE);
	if (0 == baseAddr) {
		return false;
	}


	Relocate(baseAddr);

	//#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
	//#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
	//#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
	static const DWORD pVec[] = {
		PAGE_NOACCESS,
		PAGE_EXECUTE,
		PAGE_READONLY,
		PAGE_EXECUTE_READ,

		PAGE_READWRITE, // should be write only
		PAGE_EXECUTE_READWRITE, // should be execute write
		PAGE_READWRITE,
		PAGE_EXECUTE_READWRITE
	};

    for (unsigned int i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		if (sections[i].header.SizeOfRawData) {
			if (!mapr.WriteBytes((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].data, sections[i].header.SizeOfRawData)) {
				return false;
			}
		}

		DWORD protect = pVec[sections[i].header.Characteristics >> 29]; // get the three most significant bytes
		if (!mapr.ChangeProtect((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].header.VirtualSize, protect)) {
			return false;
		}
		
    }

	return true;
}

bool PESection::Load(FILE *fModule) {
    data = new unsigned char[header.SizeOfRawData];

    fseek(fModule, header.PointerToRawData, SEEK_SET);
    if (header.SizeOfRawData != fread(data, 1, header.SizeOfRawData, fModule)) {
        dbg_log("read error, in section %s\n", header.Name);
        return false;
    }

    return true;
}

void PESection::Unload() {
    if (data) {
        delete [] data;
    }
}

#ifdef DONOTPRINT
#undef dbg_log
#endif

















```

`revtracer/Loader/PE.ldr.h`:

```h
#ifndef _PE_LDR_H_
#define _PE_LDR_H_

#include <vector>
using namespace std;

#include "Types.h"
#include "Abstract.Mapper.h"


struct ImageSectionHeader {
    BYTE    Name[8];
    DWORD   VirtualSize;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
};

struct ImageDosHeader {  // DOS .EXE header
    USHORT e_magic;         // Magic number
    USHORT e_cblp;          // Bytes on last page of file
    USHORT e_cp;            // Pages in file
    USHORT e_crlc;          // Relocations
    USHORT e_cparhdr;       // Size of header in paragraphs
    USHORT e_minalloc;      // Minimum extra paragraphs needed
    USHORT e_maxalloc;      // Maximum extra paragraphs needed
    USHORT e_ss;            // Initial (relative) SS value
    USHORT e_sp;            // Initial SP value
    USHORT e_csum;          // Checksum
    USHORT e_ip;            // Initial IP value
    USHORT e_cs;            // Initial (relative) CS value
    USHORT e_lfarlc;        // File address of relocation table
    USHORT e_ovno;          // Overlay number
    USHORT e_res[4];        // Reserved words
    USHORT e_oemid;         // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;       // OEM information; e_oemid specific
    USHORT e_res2[10];      // Reserved words
    LONG   e_lfanew;        // File address of new exe header
};

struct ImagePeHeader {
    DWORD   PeSignature;
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
};

struct ImageDataDirectory {
    DWORD   VirtualAddress;
    DWORD   Size;
};

#pragma pack (push, 1)
struct ImageOptionalHeader {
	struct {
		WORD    Magic;
		BYTE    MajorLinkerVersion;
		BYTE    MinorLinkerVersion;
		DWORD   SizeOfCode;
		DWORD   SizeOfInitializedData;
		DWORD   SizeOfUninitializedData;
		DWORD   AddressOfEntryPoint;
		DWORD   BaseOfCode;
	} c;

	union {
		struct {
			DWORD   BaseOfData;
			DWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			DWORD   SizeOfStackReserve;
			DWORD   SizeOfStackCommit;
			DWORD   SizeOfHeapReserve;
			DWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w32;

		struct {
			QWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			QWORD   SizeOfStackReserve;
			QWORD   SizeOfStackCommit;
			QWORD   SizeOfHeapReserve;
			QWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w64;
	};   
};
#pragma pack (pop)

class PESection {
public :
	ImageSectionHeader header;
	unsigned char *data;

	bool Load(FILE *fModule);
	void Unload();
};

class FloatingPE {
private :
	bool isValid;

	ImageDosHeader dosHdr;
	ImagePeHeader peHdr;
	ImageOptionalHeader optHdr;

	vector<PESection> sections;

	void *RVA(DWORD rva) const;
	bool LoadPE(FILE *fModule);

public :
	FloatingPE(const char *moduleName);
	FloatingPE(const wchar_t *moduleName);
	~FloatingPE();

	bool Relocate(DWORD newAddr);
	bool FixImports(AbstractPEMapper &mapper);
	bool GetExport(const char *funcName, DWORD &funcRVA);

	bool MapPE(AbstractPEMapper &mapr, DWORD &baseAddr);
	
	bool IsValid() const {
		return isValid;
	}
};

#endif

```

`revtracer/Loader/Types.h`:

```h
#ifndef _TYPES_H_
#define _TYPES_H_

typedef unsigned short USHORT;
typedef long LONG;

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned long long QWORD;

#endif

```

`revtracer/Makefile`:

```
lib_revtracer := revtracer.dll

CXX := i686-w64-mingw32-g++
AS := i686-w64-mingw32-as

CPP_FILES := AddressContainer.cpp api.cpp callgates.cpp cb.cpp crc32.cpp crtStub.cpp execenv.cpp GenericX86Assembler.cpp mm.cpp modrm32.cpp PreTrackingX86Assembler.cpp RelocableCodeBuffer.cpp revtracer.cpp RiverAddress.cpp RiverMetaTranslator.cpp RiverPrintTable.cpp RiverReverseTranslator.cpp RiverSaveTranslator.cpp RiverTrackingX86Assembler.cpp RiverX86Assembler.cpp RiverX86Disassembler.cpp NativeX86Assembler.cpp SymbopReverseTranslator.cpp SymbopTranslator.cpp SymbopSaveTranslator.cpp sync.cpp Tracking.cpp TrackingX86Assembler.cpp X86Assembler.cpp X86AssemblerFuncs.cpp RiverX86DisassemblerTable.cpp codegen.cpp
AS_FILES := revtracer.stub.S
OBJ_FILES := $(addprefix ,$(notdir $(CPP_FILES:.cpp=.o)))
OBJAS_FILES := $(addprefix ,$(notdir $(AS_FILES:.S=.o)))

LD_FLAGS :=
AS_FLAGS += --32
CC_FLAGS_CROSS = -D_cdecl="__attribute__((cdecl))" -D_stdcall="__attribute__((stdcall))"
CC_FLAGS += -g -m32 -march=i386 -fno-exceptions -fno-stack-protector -fcheck-new -std=c++11 $(CC_FLAGS_CROSS) -D_BUILDING_REVTRACER_DLL #-D_REVTRACER_DEBUG_PRINT_
prefix := /usr/local

all: $(lib_revtracer)

install: $(lib_revtracer)
	install -m 0755 $(lib_revtracer) -t $(prefix)/lib -D

$(lib_revtracer): $(OBJ_FILES) $(OBJAS_FILES)
	$(CXX) $(CC_FLAGS) --disable-stdcall-fixup -static-libstdc++ -shared -o $@ $^

%.o: %.cpp
	$(CXX)  $(CC_FLAGS) -c -o $@ $<

%.o: %.S
	$(AS) $(AS_FLAGS) -o $@ $<

.PHONY: clean
clean:
	$(RM) $(lib_revtracer) $(OBJ_FILES) $(OBJAS_FILES)

```

`revtracer/NativeX86Assembler.cpp`:

```cpp
#include "NativeX86Assembler.h"

#include "mm.h"

extern nodep::DWORD dwSysHandler; // = 0; // &SysHandler
extern nodep::DWORD dwSysEndHandler; // = 0; // &SysEndHandler
extern nodep::DWORD dwBranchHandler; // = 0; // &BranchHandler

bool NativeX86Assembler::Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType) {
	nodep::DWORD dwTable = 0;

	if (ri.modifiers & RIVER_MODIFIER_EXT) {
		*px86.cursor = 0x0F;
		px86.cursor++;
		dwTable = 1;
	}

	(this->*assembleOpcodes[dwTable][ri.opCode])(ri, px86, pFlags, instrCounter);
	(this->*assembleOperands[dwTable][ri.opCode])(ri, px86);
	return true;
}

/* =========================================== */
/* Opcode assemblers                           */
/* =========================================== */


#include "X86AssemblerFuncs.h"

void NativeX86Assembler::AssembleUnkInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	::AssembleUnkInstr(ri, px86, pFlags, instrCounter);
}

void NativeX86Assembler::AssembleDefaultInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	::AssembleDefaultInstr(ri, px86, pFlags, instrCounter);
}

void NativeX86Assembler::AssemblePlusRegInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	::AssemblePlusRegInstr(ri, px86, pFlags, instrCounter);
}

void NativeX86Assembler::AssembleRelJMPInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	static const nodep::BYTE pBranchJMP[] = {
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large ds:<dwVirtualStack>
		0x9C, 										// 0x06 - pushf
		0x60,										// 0x07 - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x0D - popf
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <jump_addr>
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x13 - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x18 - call <dwBranchHandler>
		0x61,										// 0x1E - popa
		0x9D,										// 0x1F - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x20 - xchg esp, large ds:<dwVirtualStack>
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x26 - jmp large dword ptr ds:<jumpbuff>	
	};

	int addrJump = (int)(ri.operands[1].asImm32);

	switch (RIVER_OPSIZE(ri.opTypes[0])) {
	case RIVER_OPSIZE_8:
		addrJump += (char)ri.operands[0].asImm8;
		break;
	case RIVER_OPSIZE_16:
		addrJump += (short)ri.operands[0].asImm16;
		break;
	case RIVER_OPSIZE_32:
		addrJump += (int)ri.operands[0].asImm32;
		break;
	}

	rev_memcpy(px86.cursor, pBranchJMP, sizeof(pBranchJMP));
	*(unsigned int *)(&(px86.cursor[0x02])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x0F])) = addrJump;
	*(unsigned int *)(&(px86.cursor[0x14])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x1A])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x22])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x28])) = (unsigned int)&runtime->jumpBuff;

	px86.cursor += sizeof(pBranchJMP);
	pFlags |= RIVER_FLAG_BRANCH;
	instrCounter += 12;
}

void NativeX86Assembler::AssembleJMPInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	static const nodep::BYTE pBranchJMP[] = {
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large ds:<dwVirtualStack>
		0x9C, 										// 0x06 - pushf
		0x60,										// 0x07 - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x0D - popf
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <jump_addr>
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x13 - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x18 - call <dwBranchHandler>
		0x61,										// 0x1E - popa
		0x9D,										// 0x1F - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x20 - xchg esp, large ds:<dwVirtualStack>
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x26 - jmp large dword ptr ds:<jumpbuff>	
	};

	int addrJump = (int)(ri.operands[0].asImm32);

	rev_memcpy(px86.cursor, pBranchJMP, sizeof(pBranchJMP));
	*(unsigned int *)(&(px86.cursor[0x02])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x0F])) = addrJump;
	*(unsigned int *)(&(px86.cursor[0x14])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x1A])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x22])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x28])) = (unsigned int)&runtime->jumpBuff;

	px86.cursor += sizeof(pBranchJMP);
	pFlags |= RIVER_FLAG_BRANCH;
	instrCounter += 12;
}

void NativeX86Assembler::AssembleLeaveForSyscall(
	const RiverInstruction &ri,
	RelocableCodeBuffer &px86,
	nodep::DWORD &pFlags,
	nodep::DWORD &instrCounter,
	NativeX86Assembler::AssembleOpcodeFunc opcodeFunc,
	NativeX86Assembler::AssembleOperandsFunc operandsFunc
) {
	static const nodep::BYTE pBranchSyscall[] = {
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large ds:<dwVirtualStack>
		0x9C, 										// 0x06 - pushf
		0x60,										// 0x07 - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x0D - popf
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x13 - call <dwSysHandler>
		0x61,										// 0x19 - popa
		0x9D,										// 0x1A - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x1B - xchg esp, large ds:<dwVirtualStack>
	};

	rev_memcpy(px86.cursor, pBranchSyscall, sizeof(pBranchSyscall));
	*(unsigned int *)(&(px86.cursor[0x02])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x0F])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x15])) = (unsigned int)&dwSysHandler;
	*(unsigned int *)(&(px86.cursor[0x1D])) = (unsigned int)&runtime->virtualStack;
	px86.cursor += sizeof(pBranchSyscall);
	instrCounter += 10;

	// assemble actual syscall
	GeneratePrefixes(ri, px86.cursor);

	(*this.*opcodeFunc)(ri, px86, pFlags, instrCounter);
	(*this.*operandsFunc)(ri, px86);

	// call $a
	static const nodep::BYTE pBranchSysret[] = {
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large ds:<dwVirtualStack>
		0x9C, 										// 0x06 - pushf
		0x60,										// 0x07 - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x0D - popf
		//0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <jump_addr>  TODO win
		0xFF, 0x35, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <jump_addr>
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x14 - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x19 - call <dwBranchHandler>
		0x61,										// 0x1F - popa
		0x9D,										// 0x20 - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x21 - xchg esp, large ds:<dwVirtualStack>
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x27 - jmp large dword ptr ds:<jumpbuff>	
	};

	//TODO win
	//int addrJump = (int)(ri.operands[1].asImm32);
	//int addrJump = (int)runtime->jumpBuff;

	rev_memcpy(px86.cursor, pBranchSysret, sizeof(pBranchSysret));
	*(unsigned int *)(&(px86.cursor[0x02])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x10])) = (unsigned int)&runtime->jumpBuff;
	*(unsigned int *)(&(px86.cursor[0x15])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x1B])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x23])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x29])) = (unsigned int)&runtime->jumpBuff;

	px86.cursor += sizeof(pBranchSysret);
	pFlags |= RIVER_FLAG_BRANCH;
	instrCounter += 12;
}

void NativeX86Assembler::AssembleRelJmpCondInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	static const nodep::BYTE pBranchJCC[] = {
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large ds:<dwVirtualStack>
		0x9C, 										// 0x06 - pushf
		0x60,										// 0x07 - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x0D - popf
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <original_address>
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x13 - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x18 - call <branch_handler>
		0x61,										// 0x1E - popa
		0x9D,										// 0x1F - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x20 - xchg esp, large ds:<dwVirtualStack>
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x26 - jmp large dword ptr ds:<jumpbuff>
	};

	int addrFallThrough = (int)(ri.operands[1].asImm32);
	int addrJump = addrFallThrough;

	switch (RIVER_OPSIZE(ri.opTypes[0])) {
	case RIVER_OPSIZE_8:
		addrJump += (char)ri.operands[0].asImm8;
		break;
	case RIVER_OPSIZE_16:
		addrJump += (short)ri.operands[0].asImm16;
		break;
	case RIVER_OPSIZE_32:
		addrJump += (int)ri.operands[0].asImm32;
		break;
	}

	/* copy the Jcc instruction */
	*px86.cursor = ri.opCode;
	px86.cursor++;

	switch (RIVER_OPSIZE(ri.opTypes[0])) {
	case RIVER_OPSIZE_8:
		*px86.cursor = sizeof(pBranchJCC);
		px86.cursor += 1;
		break;
	case RIVER_OPSIZE_16:
		*(nodep::WORD *)px86.cursor = sizeof(pBranchJCC);
		px86.cursor += 2;
		break;
	case RIVER_OPSIZE_32:
		*(nodep::DWORD *)px86.cursor = sizeof(pBranchJCC);
		px86.cursor += 4;
		break;
	}


	rev_memcpy(px86.cursor, pBranchJCC, sizeof(pBranchJCC));

	*(unsigned int *)(&(px86.cursor[0x02])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x0F])) = addrFallThrough;
	*(unsigned int *)(&(px86.cursor[0x14])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x1A])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x22])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x28])) = (unsigned int)&runtime->jumpBuff;
	px86.cursor += sizeof(pBranchJCC);


	rev_memcpy(px86.cursor, pBranchJCC, sizeof(pBranchJCC));

	*(unsigned int *)(&(px86.cursor[0x02])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x0F])) = addrJump;
	*(unsigned int *)(&(px86.cursor[0x14])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x1A])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x22])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x28])) = (unsigned int)&runtime->jumpBuff;
	px86.cursor += sizeof(pBranchJCC);

	pFlags |= RIVER_FLAG_BRANCH;
	instrCounter += 25;
}

void NativeX86Assembler::AssembleCallInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	static const nodep::BYTE pBranchCall[] = {
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x00 - push <retAddr>
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x05 - xchg esp, large ds:<dwVirtualStack>
		0x9C, 										// 0x0B - pushf
		0x60,										// 0x0C - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x0D - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x12 - popf
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x13 - push <jumpAddr>
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x18 - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x1D - call <dwBranchHandler>

		0x61,										// 0x23 - popa
		0x9D,										// 0x24 - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x25 - xchg esp, large ds:<dwVirtualStack>
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x2B - jmp large dword ptr ds:<jumpbuff>
	};

	int retAddr = (int)(ri.operands[1].asImm32);
	int addrJump = (int)(ri.operands[1].asImm32);

	switch (RIVER_OPSIZE(ri.opTypes[0])) {
	case RIVER_OPSIZE_8:
		addrJump += (char)ri.operands[0].asImm8;
		break;
	case RIVER_OPSIZE_16:
		addrJump += (short)ri.operands[0].asImm16;
		break;
	case RIVER_OPSIZE_32:
		addrJump += (int)ri.operands[0].asImm32;
		break;
	}

	rev_memcpy(px86.cursor, pBranchCall, sizeof(pBranchCall));
	*(unsigned int *)(&(px86.cursor[0x01])) = retAddr;
	*(unsigned int *)(&(px86.cursor[0x07])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x14])) = addrJump;
	*(unsigned int *)(&(px86.cursor[0x19])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x1F])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x27])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x2D])) = (unsigned int)&runtime->jumpBuff;
	px86.cursor += sizeof(pBranchCall);

	pFlags |= RIVER_FLAG_BRANCH;
	instrCounter += 25;
}

void NativeX86Assembler::AssembleFFJumpInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	static const unsigned char pGetAddrCode[] = {
		0xA3, 0x00, 0x00, 0x00, 0x00,				// 0x00 - [<dwEaxSave>], eax
		0x8B										// 0x05 - mov ...
	};

	static const unsigned char pBranchFFCall[] = {
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large [<dwVirtualStack>]
		0x9C, 										// 0x06 - pushf
		0x60,										// 0x07 - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x0D - popf
		0x50,                            			// 0x0E - push eax
		0xA1, 0x00, 0x00, 0x00, 0x00,				// 0x0F	- mov eax, [<dwEaxSave>]
		0x89, 0x44, 0x24, 0x20,						// 0x14 - mov [esp+0x20], eax // fix the eax value
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x18 - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,         // 0x1D - call [<dwBranchHandler>]
		0x61,										// 0x23 - popa
		0x9D,										// 0x24 - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x25 - xchg esp, large ds:<dwVirtualStack>
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x2B - jmp large dword ptr ds:<jumpbuff>
	};


	rev_memcpy(px86.cursor, pGetAddrCode, sizeof(pGetAddrCode));
	*(unsigned int *)(&(px86.cursor[1])) = (unsigned int)&runtime->returnRegister;
	px86.cursor += sizeof(pGetAddrCode);
	ri.operands[0].asAddress->EncodeTox86(px86.cursor, RIVER_REG_xAX, 0, 0); // use flags?

	rev_memcpy(px86.cursor, pBranchFFCall, sizeof(pBranchFFCall));
	*(unsigned int *)(&(px86.cursor[0x02])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x10])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x19])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x1F])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x27])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x2D])) = (unsigned int)&runtime->jumpBuff;
	px86.cursor += sizeof(pBranchFFCall);
	pFlags |= RIVER_FLAG_BRANCH;

	instrCounter += 16;
}

//void NativeX86Assembler::AssembleSyscall2(const RiverInstruction &ri, RelocableCodeBuffer &px86, rev::DWORD &pFlags, rev::DWORD &instrCounter) {
//	static const unsigned char pSaveEdxCode[] = {
//		0xA3, 0x00, 0x00, 0x00, 0x00,					// 0x00 - mov [<eaxSave>], eax
//		0x8B, 0x02,										// 0x05 - mov eax, [edx]
//		0xA3, 0x00, 0x00, 0x00, 0x00,					// 0x07 - mov [<espSave>], eax
//		0xA1, 0x00, 0x00, 0x00, 0x00,					// 0x0C - mov eax, [<eaxSave>]
//		0xC7, 0x02, 0x00, 0x00, 0x00, 0x00,				// 0x11 - mov [edx], imm32
//		0x0F, 0x34,										// 0x17 - syscall
//		0xFF, 0x35, 0x00, 0x00, 0x00, 0x00				// 0x19 - push [<espSave>]
//	};
//
//	rev_memcpy(px86.cursor, pSaveEdxCode, sizeof(pSaveEdxCode));
//	*(unsigned int *)(&(px86.cursor[0x01])) = (unsigned int)&runtime->returnRegister;
//	*(unsigned int *)(&(px86.cursor[0x08])) = (unsigned int)&runtime->jumpBuff;
//	*(unsigned int *)(&(px86.cursor[0x0D])) = (unsigned int)&runtime->returnRegister;
//	*(unsigned int *)(&(px86.cursor[0x13])) = ((unsigned int)px86.cursor) + 0x19;
//	*(unsigned int *)(&(px86.cursor[0x1B])) = (unsigned int)&runtime->jumpBuff;
//
//	px86.SetRelocation(&px86.cursor[0x13]);
//	//needsRAFix = true;
//	//rvAddress = &px86[0x13];
//
//	px86.cursor += sizeof(pSaveEdxCode);
//	instrCounter += 7;
//}


template <nodep::BYTE opcode>
void NativeX86Assembler::AssembleSyscall2(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {

	//<__kernel_vsyscall>:push   ecx
	//<__kernel_vsyscall+1>:push   edx
	//<__kernel_vsyscall+2>:push   ebp
	//<__kernel_vsyscall+3>:mov    ebp,esp
	//<__kernel_vsyscall+5>:sysenter
	//<__kernel_vsyscall+7>:int    0x80
	//<__kernel_vsyscall+9>:pop    ebp
	//<__kernel_vsyscall+10>:pop    edx
	//<__kernel_vsyscall+11>:pop    ecx
	//<__kernel_vsyscall+12>:ret

	static const unsigned char pSaveRetCode[] = {
		0xA3, 0x00, 0x00, 0x00, 0x00,                     // 0x00 - mov [<eaxSave>], eax
		0x8B, 0x44, 0x24, 0x0C,                            // 0x05 - mov eax,DWORD PTR [esp+0xc]
		0xA3, 0x00, 0x00, 0x00, 0x00,                     // 0x09 - mov [<espSave>], eax
		0xA1, 0x00, 0x00, 0x00, 0x00,                     // 0x0e - mov eax, [<eaxSave>]
		0xC7, 0x44, 0x24, 0x0C, 0x00, 0x00, 0x00, 0x00, // 0x13 - mov DWORD PTR [esp+0xc],0x0
		0x0F, 0x05,                                     // 0x1b - sysenter
		0xA3, 0x00, 0x00, 0x00, 0x00,                     // 0x1d - mov [<eaxSave>], eax
		0xA1, 0x00, 0x00, 0x00, 0x00,                     // 0x22 - mov eax, [<espSave>]
		0x89, 0x44, 0x24, 0xFC,                         // 0x27 - mov [esp - 4], eax
		0xA1, 0x00, 0x00, 0x00, 0x00                     // 0x2b - mov eax, [<eaxSave>]
	};

	rev_memcpy(px86.cursor, pSaveRetCode, sizeof(pSaveRetCode));
	*(unsigned int *)(&(px86.cursor[0x01])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x0A])) = (unsigned int)&runtime->jumpBuff;
	*(unsigned int *)(&(px86.cursor[0x0F])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x17])) = ((unsigned int)px86.cursor) + 0x1D;
	px86.cursor[0x1C] = opcode;
	*(unsigned int *)(&(px86.cursor[0x1E])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x23])) = (unsigned int)&runtime->jumpBuff;
	*(unsigned int *)(&(px86.cursor[0x2C])) = (unsigned int)&runtime->returnRegister;

	px86.SetRelocation(&px86.cursor[0x17]);
	//needsRAFix = true;
	//rvAddress = &px86[0x13];

	px86.cursor += sizeof(pSaveRetCode);
	instrCounter += 10;
}


template <nodep::BYTE opcode>
void NativeX86Assembler::AssembleSyscall(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	px86.cursor--;
	ClearPrefixes(ri, px86.cursor);
	AssembleLeaveForSyscall(ri, px86, pFlags, instrCounter, &NativeX86Assembler::AssembleSyscall2<opcode>, &NativeX86Assembler::AssembleNoOp);
}

void NativeX86Assembler::AssembleFarJump2(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	static const unsigned char pBranchFarJmp[] = {
		0x8F, 0x05, 0x00, 0x00, 0x00, 0x00,			// 0x00 - pop [<eaxSave>]
		0xEB, 0x07,									// 0x06 - jmp $+7
		0xEA, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00,   // 0x08 - jmpf 0x33:12345678 - the actual syscall
		0xE8, 0xF4, 0xFF, 0xFF, 0xFF,				// 0x0F - call $-7

		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x14 - xchg esp, large ds:<dwVirtualStack>
		0x9C, 										// 0x1A - pushf
		0x60,										// 0x1B - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x1C - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x21 - popf
		0xFF, 0x35, 0x00, 0x00, 0x00, 0x00,			// 0x22 - push <jump_addr>
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x28 - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x2D - call <dwBranchHandler>
		0x61,										// 0x33 - popa
		0x9D,										// 0x34 - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x35 - xchg esp, large ds:<dwVirtualStack>
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x3B - jmp large dword ptr ds:<jumpbuff>	
	};

	rev_memcpy(px86.cursor, pBranchFarJmp, sizeof(pBranchFarJmp));
	*(unsigned int *)(&(px86.cursor[0x02])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x09])) = (unsigned int)ri.operands[0].asImm32;
	*(unsigned short *)(&(px86.cursor[0x0D])) = (unsigned short)ri.operands[1].asImm16;

	*(unsigned int *)(&(px86.cursor[0x16])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x24])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x29])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x2F])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x37])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x3D])) = (unsigned int)&runtime->jumpBuff;


	px86.cursor += sizeof(pBranchFarJmp);
	instrCounter += 15;
}

void NativeX86Assembler::AssembleFarJumpInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	ClearPrefixes(ri, px86.cursor);
	AssembleLeaveForSyscall(ri, px86, pFlags, instrCounter, &NativeX86Assembler::AssembleFarJump2, &NativeX86Assembler::AssembleNoOp);
}

void NativeX86Assembler::AssembleFFCallInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	/*static const char pGetAddrCode[] = {
	0xA3, 0x00, 0x00, 0x00, 0x00,				// 0x00 - [<dwEaxSave>], eax
	//0x8B										// 0x05 - mov ...
	};*/

	static const unsigned char pBranchFFCall[] = {
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x00 - push <retAddr>
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x05 - xchg esp, large [<dwVirtualStack>]
		0x9C, 										// 0x0B - pushf
		0x60,										// 0x0C - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x0D - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x12 - popf
		0x50,                            			// 0x13 - push eax
		0xA1, 0x00, 0x00, 0x00, 0x00,				// 0x14	- mov eax, [<dwEaxSave>]
		0x89, 0x44, 0x24, 0x20,						// 0x19 - mov [esp+0x20], eax // fix the eax value
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x1D - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,         // 0x22 - call [<dwBranchHandler>]

		0x61,										// 0x28 - popa
		0x9D,										// 0x29 - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x2A - xchg esp, large ds:<dwVirtualStack>
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x30 - jmp large dword ptr ds:<jumpbuff>
	};

	ClearPrefixes(ri, px86.cursor);

	if ((ri.modifiers & 0x07) == RIVER_MODIFIER_FSSEG) {
		AssembleLeaveForSyscall(ri, px86, pFlags, instrCounter, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleSubOpModRMOp);
		pFlags |= RIVER_FLAG_BRANCH;
		return;
	}

	int retAddr = (int)(ri.operands[1].asImm32);

	*px86.cursor = 0xA3; // xchg eax, [<eaxSave>] 
	++px86.cursor;
	*(unsigned int *)(px86.cursor) = (unsigned int)&runtime->returnRegister;
	px86.cursor += 4;

	GeneratePrefixes(ri, px86.cursor);
	*px86.cursor = 0x8B; // mov eax, [jmpAddr]
	++px86.cursor;
	ri.operands[0].asAddress->EncodeTox86(px86.cursor, RIVER_REG_xAX, 0, 0); // use flags?

	rev_memcpy(px86.cursor, pBranchFFCall, sizeof(pBranchFFCall));

	*(unsigned int *)(&(px86.cursor[0x01])) = retAddr;
	*(unsigned int *)(&(px86.cursor[0x07])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x15])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x1E])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x24])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x2C])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x32])) = (unsigned int)&runtime->jumpBuff;
	px86.cursor += sizeof(pBranchFFCall);
	pFlags |= RIVER_FLAG_BRANCH;

	instrCounter += 17;
}

void NativeX86Assembler::AssembleRetnInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	//RetImm - copy the value
	//Retn - 0
	//RetFar - 4
	static const nodep::BYTE pBranchRet[] = {
		0xA3, 0x00, 0x00, 0x00, 0x00,				// 0x00 - mov [<dwEaxSave>], eax
		0x58,										// 0x05 - pop eax
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x06 - xchg esp, large ds:<dwVirtualStack>
		0x9C,			 							// 0x0C - pushf
		0x60,										// 0x0D - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x0E - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x13 - popf
		0x50,										// 0x14 - push eax
		0xA1, 0x00, 0x00, 0x00, 0x00,				// 0x15	- mov eax, [<dwEaxSave>]
		0x89, 0x44, 0x24, 0x20,						// 0x1A - mov [esp+0x20], eax // fix the eax value
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x1E - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x23 - call <branch_handler>

		0x61,										// 0x29 - popa
		0x9D,										// 0x2A - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x2B - xchg esp, large ds:<dwVirtualStack>
		0x8D, 0xA4, 0x24, 0x00, 0x00, 0x00, 0x00,   // 0x31 - lea esp, [esp + <pI>] // probably sub esp, xxx
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x38 - jmp large dword ptr ds:<jumpbuff>
	};

	unsigned short stackSpace = 0;
	rev_memcpy(px86.cursor, pBranchRet, sizeof(pBranchRet));

	*(unsigned int *)(&(px86.cursor[0x01])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x08])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x16])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x1F])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x25])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x2D])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x34])) = stackSpace;
	*(unsigned int *)(&(px86.cursor[0x3A])) = (unsigned int)&runtime->jumpBuff;

	px86.cursor += sizeof(pBranchRet);
	pFlags |= RIVER_FLAG_BRANCH;
	instrCounter += 17;
}

void NativeX86Assembler::AssembleRetnImmInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	//RetImm - copy the value
	//Retn - 0
	//RetFar - 4
	static const nodep::BYTE pBranchRet[] = {
		0xA3, 0x00, 0x00, 0x00, 0x00,				// 0x00 - mov [<dwEaxSave>], eax
		0x58,										// 0x05 - pop eax
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x06 - xchg esp, large ds:<dwVirtualStack>
		0x9C,			 							// 0x0C - pushf
		0x60,										// 0x0D - pusha
		0x68, 0x46, 0x02, 0x00, 0x00,				// 0x0E - push 0x00000246 - NEW FLAGS
		0x9D,										// 0x13 - popf
		0x50,										// 0x14 - push eax
		0xA1, 0x00, 0x00, 0x00, 0x00,				// 0x15	- mov eax, [<dwEaxSave>]
		0x89, 0x44, 0x24, 0x20,						// 0x1A - mov [esp+0x20], eax // fix the eax value
		0x68, 0x00, 0x00, 0x00, 0x00,				// 0x1E - push <execution_environment>
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x23 - call <branch_handler>

		0x61,										// 0x29 - popa
		0x9D,										// 0x2A - popf
		0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x2B - xchg esp, large ds:<dwVirtualStack>
		0x8D, 0xA4, 0x24, 0x00, 0x00, 0x00, 0x00,   // 0x31 - lea esp, [esp + <pI>] // probably sub esp, xxx
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x38 - jmp large dword ptr ds:<jumpbuff>
	};

	unsigned short stackSpace = ri.operands[0].asImm16;
	rev_memcpy(px86.cursor, pBranchRet, sizeof(pBranchRet));

	*(unsigned int *)(&(px86.cursor[0x01])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x08])) = (unsigned int)&runtime->virtualStack;
	*(unsigned int *)(&(px86.cursor[0x16])) = (unsigned int)&runtime->returnRegister;
	*(unsigned int *)(&(px86.cursor[0x1F])) = (unsigned int)runtime;
	*(unsigned int *)(&(px86.cursor[0x25])) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&(px86.cursor[0x2D])) = (unsigned int)&runtime->virtualStack;

	*(unsigned int *)(&(px86.cursor[0x34])) = stackSpace;
	*(unsigned int *)(&(px86.cursor[0x3A])) = (unsigned int)&runtime->jumpBuff;

	px86.cursor += sizeof(pBranchRet);
	pFlags |= RIVER_FLAG_BRANCH;
	instrCounter += 17;
}


/* =========================================== */
/* Operand assemblers                          */
/* =========================================== */

void NativeX86Assembler::AssembleUnknownOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleUnknownOp(ri, px86);
}

void NativeX86Assembler::AssembleNoOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleNoOp(ri, px86);
}

void NativeX86Assembler::AssembleModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleModRMImm8Op(ri, px86);
}

void NativeX86Assembler::AssembleModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleModRMImm32Op(ri, px86);
}

void NativeX86Assembler::AssembleRegModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleRegModRMOp(ri, px86);
}

void NativeX86Assembler::AssembleModRMRegOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleModRMRegOp(ri, px86);
}

void NativeX86Assembler::AssembleSubOpModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleSubOpModRMOp(ri, px86);
}

void NativeX86Assembler::AssembleSubOpModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleSubOpModRMImm8Op(ri, px86);
}

void NativeX86Assembler::AssembleSubOpModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleSubOpModRMImm32Op(ri, px86);
}

void NativeX86Assembler::AssembleRegModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleRegModRMImm32Op(ri, px86);
}

void NativeX86Assembler::AssembleRegModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleRegModRMImm8Op(ri, px86);
}

void NativeX86Assembler::AssembleModRMRegImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	::AssembleModRMRegImm8Op(ri, px86);
}


/* =========================================== */
/* Additional assembly tables                  */
/* =========================================== */

NativeX86Assembler::AssembleOpcodeFunc NativeX86Assembler::assemble0xF6Instr[8] = {
	/*0x00*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
	/*0x04*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr
};

NativeX86Assembler::AssembleOperandsFunc NativeX86Assembler::assemble0xF6Op[8] = {
	/*0x00*/ &NativeX86Assembler::AssembleSubOpModRMImm8Op, &NativeX86Assembler::AssembleSubOpModRMImm8Op, &NativeX86Assembler::AssembleModRMOp<3>, &NativeX86Assembler::AssembleModRMOp<4>,
	/*0x04*/ &NativeX86Assembler::AssembleModRMOp<4>, &NativeX86Assembler::AssembleModRMOp<5>, &NativeX86Assembler::AssembleModRMOp<6>, &NativeX86Assembler::AssembleModRMOp<7>,
};

NativeX86Assembler::AssembleOpcodeFunc NativeX86Assembler::assemble0xF7Instr[8] = {
	/*0x00*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
	/*0x04*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr
};

NativeX86Assembler::AssembleOperandsFunc NativeX86Assembler::assemble0xF7Op[8] = {
	/*0x00*/ &NativeX86Assembler::AssembleSubOpModRMImm32Op, &NativeX86Assembler::AssembleSubOpModRMImm32Op, &NativeX86Assembler::AssembleModRMOp<2>, &NativeX86Assembler::AssembleModRMOp<3>,
	/*0x04*/ &NativeX86Assembler::AssembleModRMOp<4>, &NativeX86Assembler::AssembleModRMOp<5>, &NativeX86Assembler::AssembleModRMOp<6>, &NativeX86Assembler::AssembleModRMOp<6>,
};

NativeX86Assembler::AssembleOpcodeFunc NativeX86Assembler::assemble0xFFInstr[8] = {
	/*0x00*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleFFCallInstr, &NativeX86Assembler::AssembleUnkInstr,
	/*0x04*/ &NativeX86Assembler::AssembleFFJumpInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr
};

NativeX86Assembler::AssembleOperandsFunc NativeX86Assembler::assemble0xFFOp[8] = {
	/*0x00*/ &NativeX86Assembler::AssembleSubOpModRMOp, &NativeX86Assembler::AssembleSubOpModRMOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleUnknownOp,
	/*0x04*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleModRMOp<6>, &NativeX86Assembler::AssembleUnknownOp,
};

NativeX86Assembler::AssembleOpcodeFunc NativeX86Assembler::assemble0x0FC7Instr[8] = {
	/*0x00*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
	/*0x04*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr
};

NativeX86Assembler::AssembleOperandsFunc NativeX86Assembler::assemble0x0FC7Op[8] = {
	/*0x00*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleSubOpModRMOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
	/*0x04*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
};

/* =========================================== */
/* Assembly tables                             */
/* =========================================== */

NativeX86Assembler::AssembleOpcodeFunc NativeX86Assembler::assembleOpcodes[2][0x100] = {
	{
		/*0x00*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x04*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x08*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x0C*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x10*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x14*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x18*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x1C*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x20*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x24*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x28*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x2C*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x30*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x34*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x38*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x3C*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x40*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0x44*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0x48*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0x4C*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,

		/*0x50*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0x54*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0x58*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0x5C*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,

		/*0x60*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x64*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x68*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x6C*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x70*/ &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr,
		/*0x74*/ &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr,
		/*0x78*/ &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr,
		/*0x7C*/ &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr,

		/*0x80*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x84*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x88*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x8C*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr,

		/*0x90*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0x94*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0x98*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x9C*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0xA0*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0xA4*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0xA8*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0xAC*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,

		/*0xB0*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0xB4*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0xB8*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0xBC*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,

		/*0xC0*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleRetnImmInstr, &NativeX86Assembler::AssembleRetnInstr,
		/*0xC4*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0xC8*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xCC*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0xD0*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0xD4*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xD8*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xDC*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0xE0*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleRelJmpCondInstr,
		/*0xE4*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xE8*/ &NativeX86Assembler::AssembleCallInstr, &NativeX86Assembler::AssembleRelJMPInstr, &NativeX86Assembler::AssembleFarJumpInstr, &NativeX86Assembler::AssembleRelJMPInstr,
		/*0xEC*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0xF0*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xF4*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleSubOpInstr<assemble0xF6Instr>, &NativeX86Assembler::AssembleSubOpInstr<assemble0xF7Instr>,
		/*0xF8*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xFC*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleSubOpInstr<assemble0xFFInstr>
	}, {
		/*0x00*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x04*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleSyscall<0x05>, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x08*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x0C*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x10*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x14*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x18*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x1C*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr,

		/*0x20*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x24*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x28*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x2C*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x30*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x34*/ &NativeX86Assembler::AssembleSyscall<0x34>, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x38*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x3C*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x40*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x44*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x48*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x4C*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,

		/*0x50*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x54*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x58*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x5C*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x60*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x64*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x68*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x6C*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x70*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x74*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x78*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0x7C*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0x80*/ &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr,
		/*0x84*/ &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr,
		/*0x88*/ &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr,
		/*0x8C*/ &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr, &NativeX86Assembler::AssembleRelJmpCondInstr,

		/*0x90*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x94*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x98*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0x9C*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,

		/*0xA0*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0xA4*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xA8*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0xAC*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr,

		/*0xB0*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0xB4*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,
		/*0xB8*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xBC*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr,

		/*0xC0*/ &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleDefaultInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xC4*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleSubOpInstr<NativeX86Assembler::assemble0x0FC7Instr>,
		/*0xC8*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,
		/*0xCC*/ &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr, &NativeX86Assembler::AssemblePlusRegInstr,

		/*0xD0*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xD4*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xD8*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xDC*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0xE0*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xE4*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xE8*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xEC*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,

		/*0xF0*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xF4*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xF8*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr,
		/*0xFC*/ &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr, &NativeX86Assembler::AssembleUnkInstr
	}
};

NativeX86Assembler::AssembleOperandsFunc NativeX86Assembler::assembleOperands[2][0x100] = {
	{
		/*0x00*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x04*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x08*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x0C*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x10*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x14*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x18*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x1C*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x20*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x24*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x28*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x2C*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x30*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x34*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x38*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x3C*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x40*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x44*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x48*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x4C*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,

		/*0x50*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x54*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x58*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x5C*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,

		/*0x60*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x64*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x68*/ &NativeX86Assembler::AssembleImmOp<0, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleRegModRMImm32Op, &NativeX86Assembler::AssembleImmOp<0, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleRegModRMImm8Op,
		/*0x6C*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x70*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x74*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x78*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x7C*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,

		/*0x80*/ &NativeX86Assembler::AssembleSubOpModRMImm8Op, &NativeX86Assembler::AssembleSubOpModRMImm32Op, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleSubOpModRMImm8Op,
		/*0x84*/ &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x88*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x8C*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleModRMOp<0>,

		/*0x90*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x94*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x98*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x9C*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0xA0*/ &NativeX86Assembler::AssembleMoffs8<1>, &NativeX86Assembler::AssembleMoffs32<1>, &NativeX86Assembler::AssembleMoffs8<0>, &NativeX86Assembler::AssembleMoffs32<0>,
		/*0xA4*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0xA8*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0xAC*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,

		/*0xB0*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB4*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB8*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xBC*/ &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>, &NativeX86Assembler::AssembleImmOp<1, RIVER_OPSIZE_32>,

		/*0xC0*/ &NativeX86Assembler::AssembleSubOpModRMImm8Op, &NativeX86Assembler::AssembleSubOpModRMImm8Op, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0xC4*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleModRMImm8Op, &NativeX86Assembler::AssembleModRMImm32Op,
		/*0xC8*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xCC*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0xD0*/ &NativeX86Assembler::AssembleSubOpModRMOp, &NativeX86Assembler::AssembleSubOpModRMOp, &NativeX86Assembler::AssembleSubOpModRMOp, &NativeX86Assembler::AssembleSubOpModRMOp,
		/*0xD4*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xD8*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xDC*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0xE0*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleNoOp,
		/*0xE4*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xE8*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0xEC*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0xF0*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xF4*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleSubOpOp<assemble0xF6Op>, &NativeX86Assembler::AssembleSubOpOp<assemble0xF7Op>,
		/*0xF8*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xFC*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleSubOpModRMOp, &NativeX86Assembler::AssembleSubOpOp<assemble0xFFOp>
	}, {
		/*0x00*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x04*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x08*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x0C*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x10*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x14*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x18*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x1C*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleSubOpModRMOp,

		/*0x20*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x24*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x28*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x2C*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x30*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x34*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x38*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x3C*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x40*/ &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x44*/ &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x48*/ &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0x4C*/ &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,

		/*0x50*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x54*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x58*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x5C*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x60*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x64*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x68*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x6C*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x70*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x74*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x78*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0x7C*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0x80*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x84*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x88*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0x8C*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,

		/*0x90*/ &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>,
		/*0x94*/ &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>,
		/*0x98*/ &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>,
		/*0x9C*/ &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>, &NativeX86Assembler::AssembleModRMOp<0>,

		/*0xA0*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleModRMRegOp,
		/*0xA4*/ &NativeX86Assembler::AssembleModRMRegImm8Op, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xA8*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleModRMRegOp,
		/*0xAC*/ &NativeX86Assembler::AssembleModRMRegImm8Op, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleRegModRMOp,

		/*0xB0*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleModRMRegOp,
		/*0xB4*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,
		/*0xB8*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleSubOpModRMImm8Op, &NativeX86Assembler::AssembleUnknownOp,
		/*0xBC*/ &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp, &NativeX86Assembler::AssembleRegModRMOp,

		/*0xC0*/ &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleModRMRegOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xC4*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleSubOpOp<NativeX86Assembler::assemble0x0FC7Op>,
		/*0xC8*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,
		/*0xCC*/ &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp, &NativeX86Assembler::AssembleNoOp,

		/*0xD0*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xD4*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xD8*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xDC*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0xE0*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xE4*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xE8*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xEC*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,

		/*0xF0*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xF4*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xF8*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp,
		/*0xFC*/ &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp, &NativeX86Assembler::AssembleUnknownOp
	}
};

```

`revtracer/NativeX86Assembler.h`:

```h
#ifndef _NATIVE_X86_ASSEMBLER_H
#define _NATIVE_X86_ASSEMBLER_H

#include "GenericX86Assembler.h"
#include "X86AssemblerFuncs.h"

class NativeX86Assembler : public GenericX86Assembler {
private :
	typedef void(NativeX86Assembler::*AssembleOpcodeFunc)(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	typedef void(NativeX86Assembler::*AssembleOperandsFunc)(const RiverInstruction &ri, RelocableCodeBuffer &px86);

	static AssembleOpcodeFunc assemble0xF6Instr[8];
	static AssembleOperandsFunc assemble0xF6Op[8];

	static AssembleOpcodeFunc assemble0xF7Instr[8];
	static AssembleOperandsFunc assemble0xF7Op[8];

	static AssembleOpcodeFunc assemble0xFFInstr[8];
	static AssembleOperandsFunc assemble0xFFOp[8];

	static AssembleOpcodeFunc assemble0x0FC7Instr[8];
	static AssembleOperandsFunc assemble0x0FC7Op[8];

	static AssembleOpcodeFunc assembleOpcodes[2][0x100];
	static AssembleOperandsFunc assembleOperands[2][0x100];

//public :
	//bool Assemble(RiverInstruction *pRiver, nodep::DWORD dwInstrCount, nodep::BYTE *px86, nodep::DWORD flg, nodep::DWORD &instrCounter, nodep::DWORD &byteCounter);
public :
	virtual bool Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType);
private :
	/* opcodes assemblers */
	void AssembleUnkInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleDefaultInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssemblePlusRegInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleRelJMPInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleJMPInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleRelJmpCondInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleCallInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleFFCallInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleFFJumpInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleRetnInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleRetnImmInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleFarJumpInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleFarJump2(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	
	template <nodep::BYTE opcode>
	void AssembleSyscall(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	template <nodep::BYTE opcode>
	void AssembleSyscall2(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleLeaveForSyscall(
		const RiverInstruction &ri,
		RelocableCodeBuffer &px86,
		nodep::DWORD &pFlags,
		nodep::DWORD &instrCounter,
		NativeX86Assembler::AssembleOpcodeFunc opcodeFunc,
		NativeX86Assembler::AssembleOperandsFunc operandsFunc
	);

	/*template <AssembleOpcodeFunc fRiver, AssembleOpcodeFunc fNormal> void AssembleRiverInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
		if (ri.family & RIVER_FAMILY_RIVEROP) {
			(this->*fRiver)(ri, px86, pFlags, instrCounter);
		}
		else {
			(this->*fNormal)(ri, px86, pFlags, instrCounter);
		}
	}*/

	template <AssembleOpcodeFunc *fSubOps> void AssembleSubOpInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
		(this->*fSubOps[ri.subOpCode])(ri, px86, pFlags, instrCounter);
	}

	void AssembleRiverAddSubInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	/* operand helpers */
	/*void AssembleModRMOp(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE extra);
	void AssembleImmOp(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE immSize);

	void AssembleMoffs(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE immSize);*/

	/* Operand assembler functions */
	void AssembleUnknownOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);
	void AssembleNoOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);

	template <nodep::BYTE opIdx, nodep::BYTE immSize> void AssembleImmOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
		::AssembleImmOp(opIdx, ri, px86, immSize);
	}

	template <int extra> void AssembleModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
		::AssembleModRMOp(0, ri, px86, extra);
	}

	void AssembleModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);
	void AssembleModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);

	void AssembleRegModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);
	void AssembleModRMRegOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);
	void AssembleSubOpModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);
	void AssembleSubOpModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);
	void AssembleSubOpModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);

	void AssembleRegModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);
	void AssembleRegModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);

	void AssembleModRMRegImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);

	template <AssembleOperandsFunc *fSubOps> void AssembleSubOpOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
		(this->*fSubOps[ri.subOpCode])(ri, px86);
	}

	template <nodep::BYTE opIdx> void AssembleMoffs8(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
		::AssembleMoffs(opIdx, ri, px86, RIVER_OPSIZE_32);
	}

	template <nodep::BYTE opIdx> void AssembleMoffs32(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
		::AssembleMoffs(opIdx, ri, px86, RIVER_OPSIZE_32);
	}
};

#endif

```

`revtracer/PreTrackingX86Assembler.cpp`:

```cpp
#include "PreTrackingX86Assembler.h"

#include "X86AssemblerFuncs.h"

using namespace rev;

nodep::BYTE LogB2(nodep::BYTE x) {
	nodep::BYTE r = 0;

	if (x & 0xF0) { r += 4; x >>= 4; }
	if (x & 0x0C) { r += 2; x >>= 2; }
	if (x & 0x02) { r += 1; x >>= 1; }

	return r;
}


nodep::BYTE SelectUnusedRegister(nodep::BYTE &uIn) {
	nodep::BYTE reg = uIn;
	reg &= -reg;
	uIn &= ~reg;

	return LogB2(reg);
}

const nodep::BYTE PreTrackingAssembler::regByte[] = { 0x05, 0x0D, 0x15, 0x1D, 0x25, 0x2D, 0x35, 0x3D };

void PreTrackingAssembler::SaveUnusedRegister(nodep::BYTE reg, RelocableCodeBuffer &px86, int idx) {
	const nodep::BYTE preTrackMemPrefix[] = {
		0x89, 0x05, 0x00, 0x00, 0x00, 0x00
	};

	nodep::DWORD dest = (nodep::DWORD)&runtime->returnRegister;
	if (idx) {
		dest = (nodep::DWORD)&runtime->secondaryRegister;
	}

	rev_memcpy(px86.cursor, preTrackMemPrefix, sizeof(preTrackMemPrefix));
	px86.cursor[1] = regByte[reg];
	*(nodep::DWORD *)(&px86.cursor[2]) = dest;
	px86.cursor += sizeof(preTrackMemPrefix);

}

void PreTrackingAssembler::RestoreUnusedRegister(nodep::BYTE reg, RelocableCodeBuffer &px86, int idx) {
	const nodep::BYTE preTrackMemSuffix[] = {
		0x8B, 0x05, 0x00, 0x00, 0x00, 0x00
	};

	nodep::DWORD dest = (nodep::DWORD)&runtime->returnRegister;
	if (idx) {
		dest = (nodep::DWORD)&runtime->secondaryRegister;
	}

	rev_memcpy(px86.cursor, preTrackMemSuffix, sizeof(preTrackMemSuffix));
	px86.cursor[1] = regByte[reg];
	*(nodep::DWORD *)(&px86.cursor[2]) = dest;
	px86.cursor += sizeof(preTrackMemSuffix);
}

void PreTrackingAssembler::AssemblePreTrackAddr(RiverAddress *addr, nodep::BYTE riverFamily, nodep::BYTE repReg, RelocableCodeBuffer &px86, nodep::DWORD &instrCounter) {

	nodep::DWORD flags = 0;
	nodep::BYTE unusedRegisters = addr->GetUnusedRegisters() & 0xCF;

	if (riverFamily & RIVER_FAMILY_FLAG_ORIG_xSP) {
		unusedRegisters &= ~(1 << repReg);
	}

	nodep::BYTE cReg = SelectUnusedRegister(unusedRegisters);

	SaveUnusedRegister(cReg, px86, 0);
	instrCounter++;

	{   // wrap up in RAII - lea <cReg>, <address>
		RiverInstruction rLea;
		rLea.opCode = 0x8D;
		rLea.modifiers = rLea.specifiers = 0;
		rLea.family = RIVER_FAMILY_PRETRACK;
		rLea.opTypes[0] = RIVER_OPTYPE_REG;
		rLea.operands[0].asRegister.versioned = cReg;

		rLea.opTypes[1] = RIVER_OPTYPE_MEM;
		rLea.operands[1].asAddress = addr;

		rLea.opTypes[2] = rLea.opTypes[3] = RIVER_OPTYPE_NONE;
		rLea.PromoteModifiers();
		rLea.TrackEspAsParameter();
		rLea.TrackUnusedRegisters();

		GeneratePrefixes(rLea, px86.cursor);
		AssembleDefaultInstr(rLea, px86, flags, instrCounter);
		AssembleRegModRMOp(rLea, px86);
	}

	if (addr->HasSegment()) {
		nodep::BYTE sReg = SelectUnusedRegister(unusedRegisters);

		if (riverFamily & RIVER_FAMILY_FLAG_ORIG_xSP) {
			unusedRegisters &= ~(1 << repReg);
		}

		// save reg
		SaveUnusedRegister(sReg, px86, 1);
		instrCounter++;

		{	// wrap up in RAII - mov <sReg>, segment
			RiverInstruction rOps;
			RiverAddress32 rAddr;
			rOps.opCode = 0x8C;
			rOps.modifiers = rOps.specifiers = 0;
			rOps.family = RIVER_FAMILY_PRETRACK;

			rOps.opTypes[0] = RIVER_OPTYPE_REG;
			rOps.operands[0].asRegister.versioned = addr->GetSegment() - 1; //sReg;

			rOps.opTypes[1] = RIVER_OPTYPE_MEM;
			rOps.operands[1].asAddress = &rAddr;

			rAddr.type = RIVER_ADDR_DIRTY;
			rAddr.scaleAndSegment = 0;
			rAddr.index.versioned = 0;
			rAddr.base.versioned = 0;
			rAddr.base.name = sReg; //addr->GetSegment() - 1;
			rAddr.disp.d32 = 0;

			rOps.opTypes[2] = rOps.opTypes[3] = RIVER_OPTYPE_NONE;
			rOps.PromoteModifiers();
			rOps.TrackEspAsParameter();
			rOps.TrackUnusedRegisters();

			GeneratePrefixes(rOps, px86.cursor);
			AssembleDefaultInstr(rOps, px86, flags, instrCounter);
			AssembleRegModRMOp(rOps, px86);
		}

		{	// wrap up in RAII - lea <sReg>, [sReg * 4 + segmentOffsets]
			RiverInstruction rOps;
			RiverAddress32 rAddr;
			rOps.opCode = 0x8D;
			rOps.modifiers = rOps.specifiers = 0;
			rOps.family = RIVER_FAMILY_PRETRACK;

			rOps.opTypes[0] = RIVER_OPTYPE_REG;
			rOps.operands[0].asRegister.versioned = sReg;

			rOps.opTypes[1] = RIVER_OPTYPE_MEM;
			rOps.operands[1].asAddress = &rAddr;

			rAddr.type = RIVER_ADDR_SCALE | RIVER_ADDR_INDEX | RIVER_ADDR_DISP | RIVER_ADDR_DIRTY;
			rAddr.scaleAndSegment = 0;
			rAddr.SetScale(4);
			rAddr.index.versioned = sReg;
			rAddr.base.versioned = 0;
			rAddr.disp.d32 = (nodep::DWORD)revtracerConfig.segmentOffsets;

			rOps.opTypes[2] = rOps.opTypes[3] = RIVER_OPTYPE_NONE;
			rOps.PromoteModifiers();
			rOps.TrackEspAsParameter();
			rOps.TrackUnusedRegisters();

			GeneratePrefixes(rOps, px86.cursor);
			AssembleDefaultInstr(rOps, px86, flags, instrCounter);
			AssembleRegModRMOp(rOps, px86);
		}

		{	// wrap up in RAII - lea <cReg>, [cReg + sReg]
			RiverInstruction rOps;
			RiverAddress32 rAddr;
			rOps.opCode = 0x8D;
			rOps.modifiers = rOps.specifiers = 0;
			rOps.family = RIVER_FAMILY_PRETRACK;

			rOps.opTypes[0] = RIVER_OPTYPE_REG;
			rOps.operands[0].asRegister.versioned = cReg;

			rOps.opTypes[1] = RIVER_OPTYPE_MEM;
			rOps.operands[1].asAddress = &rAddr;

			rAddr.type = RIVER_ADDR_SCALE | RIVER_ADDR_INDEX | RIVER_ADDR_BASE | RIVER_ADDR_DIRTY;
			rAddr.scaleAndSegment = 0;
			rAddr.SetScale(1);
			rAddr.index.versioned = sReg;
			rAddr.base.versioned = cReg;
			rAddr.disp.d32 = 0;

			rOps.opTypes[2] = rOps.opTypes[3] = RIVER_OPTYPE_NONE;
			rOps.PromoteModifiers();
			rOps.TrackEspAsParameter();
			rOps.TrackUnusedRegisters();

			GeneratePrefixes(rOps, px86.cursor);
			AssembleDefaultInstr(rOps, px86, flags, instrCounter);
			AssembleRegModRMOp(rOps, px86);
		}

		// restore reg
		RestoreUnusedRegister(sReg, px86, 1);
		instrCounter++;
	}

	px86.cursor[0] = 0x50 + cReg; // push reg;
	px86.cursor++;
	instrCounter++;

	if (addr->type & RIVER_ADDR_BASE) {
		nodep::BYTE reg = GetFundamentalRegister(addr->base.name);

		if ((riverFamily & RIVER_FAMILY_FLAG_ORIG_xSP) && (reg == RIVER_REG_xSP)) {
			reg = repReg;
		}

		px86.cursor[0] = 0x50 + GetFundamentalRegister(reg); // push reg;
		px86.cursor++;
		instrCounter++;
	}

	if (addr->type & RIVER_ADDR_INDEX) {
		nodep::BYTE reg = GetFundamentalRegister(addr->index.name);

		if ((riverFamily & RIVER_FAMILY_FLAG_ORIG_xSP) && (reg == RIVER_REG_xSP)) {
			reg = repReg;
		}
		
		px86.cursor[0] = 0x50 + GetFundamentalRegister(reg); // push reg;
		px86.cursor++;
		instrCounter++;
	}

	RestoreUnusedRegister(cReg, px86, 0);
	instrCounter++;
}

void PreTrackingAssembler::AssemblePreTrackMem(RiverAddress *addr, nodep::BYTE riverFamily, nodep::BYTE repReg, RelocableCodeBuffer &px86, nodep::DWORD &instrCounter) {

	const nodep::BYTE andRegVal[] = { 0x9C, 0x83, 0xE0, 0xFC, 0x9D };
	const nodep::BYTE pushEax4[] = { 0xFF, 0x70, 0x04 };
	const nodep::BYTE pushEax[] = { 0xFF, 0x30 };
	const nodep::BYTE segmentPrefix[] = { 0x00, 0x26, 0x2E, 0x36, 0x3E, 0x64, 0x65 };

	nodep::DWORD flags = 0;
	nodep::BYTE unusedRegisters = addr->GetUnusedRegisters() & 0xCF;

	if (riverFamily & RIVER_FAMILY_FLAG_ORIG_xSP) {
		unusedRegisters &= ~(1 << repReg);
	}

	nodep::BYTE cReg = SelectUnusedRegister(unusedRegisters);

	SaveUnusedRegister(cReg, px86, 0);
	instrCounter++;

	{   // wrap up in RAII - lea <cReg>, <address>
		RiverInstruction rLea;
		rLea.opCode = 0x8D;
		rLea.modifiers = rLea.specifiers = 0;
		rLea.family = RIVER_FAMILY_PRETRACK;
		rLea.opTypes[0] = RIVER_OPTYPE_REG;
		rLea.operands[0].asRegister.versioned = cReg;

		rLea.opTypes[1] = RIVER_OPTYPE_MEM;
		rLea.operands[1].asAddress = addr;

		rLea.opTypes[2] = rLea.opTypes[3] = RIVER_OPTYPE_NONE;
		rLea.PromoteModifiers();
		rLea.TrackEspAsParameter();
		rLea.TrackUnusedRegisters();

		GeneratePrefixes(rLea, px86.cursor);
		AssembleDefaultInstr(rLea, px86, flags, instrCounter);
		AssembleRegModRMOp(rLea, px86);
	}

	if (addr->HasSegment()) {
		nodep::BYTE sReg = SelectUnusedRegister(unusedRegisters);

		if (riverFamily & RIVER_FAMILY_FLAG_ORIG_xSP) {
			unusedRegisters &= ~(1 << repReg);
		}

		// save reg
		SaveUnusedRegister(sReg, px86, 1);
		instrCounter++;

		{	// wrap up in RAII - mov <sReg>, segment
			RiverInstruction rOps;
			RiverAddress32 rAddr;
			rOps.opCode = 0x8C;
			rOps.modifiers = rOps.specifiers = 0;
			rOps.family = RIVER_FAMILY_PRETRACK;

			rOps.opTypes[0] = RIVER_OPTYPE_REG;
			rOps.operands[0].asRegister.versioned = addr->GetSegment() - 1; //sReg;

			rOps.opTypes[1] = RIVER_OPTYPE_MEM;
			rOps.operands[1].asAddress = &rAddr;

			rAddr.type = RIVER_ADDR_DIRTY;
			rAddr.scaleAndSegment = 0;
			rAddr.index.versioned = 0;
			rAddr.base.versioned = 0;
			rAddr.base.name = sReg; //addr->GetSegment() - 1;
			rAddr.disp.d32 = 0;

			rOps.opTypes[2] = rOps.opTypes[3] = RIVER_OPTYPE_NONE;
			rOps.PromoteModifiers();
			rOps.TrackEspAsParameter();
			rOps.TrackUnusedRegisters();

			GeneratePrefixes(rOps, px86.cursor);
			AssembleDefaultInstr(rOps, px86, flags, instrCounter);
			AssembleRegModRMOp(rOps, px86);
		}

		{	// wrap up in RAII - lea <sReg>, [sReg * 4 + segmentOffsets]
			RiverInstruction rOps;
			RiverAddress32 rAddr;
			rOps.opCode = 0x8D;
			rOps.modifiers = rOps.specifiers = 0;
			rOps.family = RIVER_FAMILY_PRETRACK;

			rOps.opTypes[0] = RIVER_OPTYPE_REG;
			rOps.operands[0].asRegister.versioned = sReg;

			rOps.opTypes[1] = RIVER_OPTYPE_MEM;
			rOps.operands[1].asAddress = &rAddr;

			rAddr.type = RIVER_ADDR_SCALE | RIVER_ADDR_INDEX | RIVER_ADDR_DISP | RIVER_ADDR_DIRTY;
			rAddr.scaleAndSegment = 0;
			rAddr.SetScale(4);
			rAddr.index.versioned = sReg;
			rAddr.base.versioned = 0;
			rAddr.disp.d32 = (nodep::DWORD)revtracerConfig.segmentOffsets;

			rOps.opTypes[2] = rOps.opTypes[3] = RIVER_OPTYPE_NONE;
			rOps.PromoteModifiers();
			rOps.TrackEspAsParameter();
			rOps.TrackUnusedRegisters();

			GeneratePrefixes(rOps, px86.cursor);
			AssembleDefaultInstr(rOps, px86, flags, instrCounter);
			AssembleRegModRMOp(rOps, px86);
		}

		{	// wrap up in RAII - lea <cReg>, [cReg + sReg]
			RiverInstruction rOps;
			RiverAddress32 rAddr;
			rOps.opCode = 0x8D;
			rOps.modifiers = rOps.specifiers = 0;
			rOps.family = RIVER_FAMILY_PRETRACK;

			rOps.opTypes[0] = RIVER_OPTYPE_REG;
			rOps.operands[0].asRegister.versioned = cReg;

			rOps.opTypes[1] = RIVER_OPTYPE_MEM;
			rOps.operands[1].asAddress = &rAddr;

			rAddr.type = RIVER_ADDR_SCALE | RIVER_ADDR_INDEX | RIVER_ADDR_BASE | RIVER_ADDR_DIRTY;
			rAddr.scaleAndSegment = 0;
			rAddr.SetScale(1);
			rAddr.index.versioned = sReg;
			rAddr.base.versioned = cReg;
			rAddr.disp.d32 = 0;

			rOps.opTypes[2] = rOps.opTypes[3] = RIVER_OPTYPE_NONE;
			rOps.PromoteModifiers();
			rOps.TrackEspAsParameter();
			rOps.TrackUnusedRegisters();

			GeneratePrefixes(rOps, px86.cursor);
			AssembleDefaultInstr(rOps, px86, flags, instrCounter);
			AssembleRegModRMOp(rOps, px86);
		}

		// restore reg
		RestoreUnusedRegister(sReg, px86, 1);
		instrCounter++;
	}

	rev_memcpy(px86.cursor, andRegVal, sizeof(andRegVal));
	px86.cursor[2] += cReg;
	px86.cursor += sizeof(andRegVal);

	rev_memcpy(px86.cursor, pushEax4, sizeof(pushEax4));
	px86.cursor[1] += cReg;
	px86.cursor += sizeof(pushEax4);

	rev_memcpy(px86.cursor, pushEax, sizeof(pushEax));
	px86.cursor[1] += cReg;
	px86.cursor += sizeof(pushEax);

	instrCounter += 5;

	RestoreUnusedRegister(cReg, px86, 0);
	instrCounter++;
}

bool PreTrackingAssembler::Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType) {
	switch (ri.opCode) {
		case 0x9C :
			::AssembleDefaultInstr(ri, px86, pFlags, instrCounter);
			::AssembleNoOp(ri, px86);
			instrCounter++;
			break;

		case 0x50 :
			::AssemblePlusRegInstr(ri, px86, pFlags, instrCounter);
			instrCounter++;
			break;

		case 0x8D :
			ClearPrefixes(ri, px86.cursor);
			AssemblePreTrackAddr(ri.operands[0].asAddress, ri.family, repReg, px86, instrCounter);
			break;

		case 0xFF :
			if (6 == ri.subOpCode) {
				ClearPrefixes(ri, px86.cursor);
				AssemblePreTrackMem(ri.operands[0].asAddress, ri.family, repReg, px86, instrCounter);
				break;
			} else {
				DEBUG_BREAK;
			}

		default :
			DEBUG_BREAK;
	}

	return true;
}

```

`revtracer/PreTrackingX86Assembler.h`:

```h
#ifndef _PRETRACKING_ASSEMBLER_H_
#define _PRETRACKING_ASSEMBLER_H_

#include "GenericX86Assembler.h"

class PreTrackingAssembler : public GenericX86Assembler {
private :
	static const nodep::BYTE regByte[];

	void SaveUnusedRegister(nodep::BYTE reg, RelocableCodeBuffer &px86, int idx);
	void RestoreUnusedRegister(nodep::BYTE reg, RelocableCodeBuffer &px86, int idx);

	void AssemblePreTrackAddr(RiverAddress *addr, nodep::BYTE riverFamily, nodep::BYTE repReg, RelocableCodeBuffer &px86, nodep::DWORD &instrCounter);
	void AssemblePreTrackMem(RiverAddress * addr, nodep::BYTE riverFamily, nodep::BYTE repReg, RelocableCodeBuffer &px86, nodep::DWORD & instrCounter);
public :
	virtual bool Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType);
};

#endif

```

`revtracer/RelocableCodeBuffer.cpp`:

```cpp
#include "RelocableCodeBuffer.h"

using namespace rev;

RelocableCodeBuffer::RelocableCodeBuffer() {
	buffer = NULL;
	Reset();
}

void RelocableCodeBuffer::Init(nodep::BYTE *buff) {
	buffer = buff;
	Reset();
}

void RelocableCodeBuffer::Reset() {
	needsRAFix = needsRepFix = false;
	rvAddress = NULL;
	repInitCursor = NULL;
	cursor = buffer;
}

void RelocableCodeBuffer::SetRelocation(nodep::BYTE *reloc) {
	needsRAFix = true;
	rvAddress = reloc;
}

void RelocableCodeBuffer::CopyToFixed(nodep::BYTE *dst) const {
	rev_memcpy(dst, buffer, cursor - buffer);
	if (needsRAFix) {
		nodep::DWORD offset = (rvAddress - buffer);

		*(nodep::DWORD *)(&dst[offset]) -= (nodep::DWORD)buffer;
		*(nodep::DWORD *)(&dst[offset]) += (nodep::DWORD)dst;
	}
}
 void RelocableCodeBuffer::MarkRepInit() {
	 needsRepFix = true;
	 repInitCursor = cursor;
 }

void RelocableCodeBuffer::MarkRepFini() {
	const nodep::DWORD jmpSize = 5;
	const nodep::DWORD loopSize = 2;
	const nodep::DWORD repinitInstrSize = jmpSize + jmpSize + loopSize + jmpSize;
	const nodep::DWORD farloopInstrSize = jmpSize + 3 + loopSize;
	const nodep::DWORD repfiniInstrSize = jmpSize + jmpSize + farloopInstrSize;

	nodep::DWORD actualCodeSize = cursor - repInitCursor - (repinitInstrSize + repfiniInstrSize);

	// fix jumps
	nodep::BYTE *jmpWrapin = repInitCursor + 1;
	*(nodep::DWORD *)(jmpWrapin) += actualCodeSize;

	nodep::BYTE *jmpCodeout = repInitCursor + jmpSize + jmpSize + loopSize + 1;
	*(nodep::DWORD *)(jmpCodeout) += actualCodeSize;

	nodep::BYTE *jmpLoop = repInitCursor + jmpSize + jmpSize + loopSize + jmpSize + actualCodeSize + 1;
	*(nodep::DWORD *)(jmpLoop) -= actualCodeSize;

	nodep::BYTE *jmpInit = cursor - (loopSize + 3 + jmpSize) + 1;
	*(nodep::DWORD *)(jmpInit) -= actualCodeSize;

	needsRepFix = false;
	repInitCursor = NULL;
}



```

`revtracer/RelocableCodeBuffer.h`:

```h
#ifndef _RELOCABLE_CODE_BUFFER_H
#define _RELOCABLE_CODE_BUFFER_H

#include "revtracer.h"
#include "mm.h"

class RelocableCodeBuffer {
private :
	nodep::BYTE *buffer;
	nodep::BYTE *repInitCursor;
	bool needsRAFix, needsRepFix;
	nodep::BYTE *rvAddress;
public :
	nodep::BYTE *cursor;

	RelocableCodeBuffer();
	void Init(nodep::BYTE *buff);

	void Reset();
	void SetRelocation(nodep::BYTE *reloc);
	void CopyToFixed(nodep::BYTE *dst) const;


	/* ->>> loop init
	 * repinit <=> jmp repfini
	 * **actual code**
	 * repfini <=> jmp loop
	 */
	// start counting instructions
	void MarkRepInit();
	// fix jump offsets
	void MarkRepFini();
};

#endif

```

`revtracer/RepInstrumentation.S`:

```S
BITS 32

/*
 * this code is the equivalent of rep modifier
 * the code between `init` label and `jmp wrapout`
 * should work fine if ecx value is not 0, otherwise it's infinite loop
 *
 * the code between wrapin and wrapout is what we call a `farloop`
 * loop operand is signed imm8 so if the instrumented code that
 * we `rep` is larger than 127 bytes, loop cannot jump enough. So we use
 * loop to a jmp instruction that points to the actual target
 *
 * `lea ecx, ecx + 1` is needed in case ecx value is zero. In order for
 * loop to have valid behavior, ecx must be one before reaching the loop
 * instruction, thus triggering the loop not to take the natural path,
 * but to exit.
 */

	jmp wrapin
init:
	jmp codein
loop:
	loop init
	jmp codeout

codein:
	// actual code
	jmp loop
codeout:
	jmp wrapout

farloop:
	jmp init
wrapin:
	lea ecx, [ecx + 1]
	loop farloop
wrapout:

```

`revtracer/RiverAddress.cpp`:

```cpp
#include "river.h"
#include "CodeGen.h"

nodep::BYTE GetFundamentalRegister(nodep::BYTE reg) {
	if (reg < 0x20) {
		return reg & 0x07;
	}
	return reg;
}

void RiverAddress::DecodeFlags(nodep::WORD flags) {
	if (flags & 0x0007) {
		SetSegment((nodep::BYTE)flags & 0x0007);
	}
}

nodep::BYTE RiverAddress::GetUnusedRegisters() const {
	nodep::BYTE ret = 0xCF;
	nodep::BYTE tmp;

	if ((0 == type) || (type & RIVER_ADDR_BASE)) {
		tmp = GetFundamentalRegister(base.name);
		ret &= ~(1 << tmp);
	}

	if (type & RIVER_ADDR_INDEX) {
		tmp = GetFundamentalRegister(index.name);
		ret &= ~(1 << tmp);
	}

	return ret;
}

nodep::BYTE RiverAddress32::DecodeRegister(nodep::BYTE id, nodep::WORD flags) {
	if (flags & RIVER_MODIFIER_O8) { // we expect a 8 byte register
		return (id & 0x03) | ((id & 0x04) ? RIVER_REG_SZ8_H : RIVER_REG_SZ8_L);
	} else if (flags & RIVER_MODIFIER_O16) { // we expect a 16 byte register
		return id | RIVER_REG_SZ16;
	} else {
		return id | RIVER_REG_SZ32;
	}
}

nodep::BYTE RiverAddress32::EncodeRegister(nodep::WORD flags) {
	if (flags & RIVER_MODIFIER_O8) { // we expect a 8 byte register
		return (base.name & 0x03) + (((base.name & 0x04) == RIVER_REG_SZ8_H) ? 4 : 0);
	} else {
		return base.name & 0x07;
	}
}

bool RiverAddress32::DecodeSib(RiverCodeGen &cg, unsigned char *&px86) {
	sib = *px86;

	nodep::BYTE ss = sib >> 6;
	nodep::BYTE idx = (sib >> 3) & 0x7;
	nodep::BYTE bs = sib & 0x7;

	type |= RIVER_ADDR_SCALE;
	CopyScale(ss);

	if (4 != idx) {
		type |= RIVER_ADDR_INDEX;
		index.versioned = cg.GetCurrentReg(idx);
	}

	if (5 == bs) {
		nodep::BYTE mod = modRM >> 6;

		type |= (1 & mod) ? RIVER_ADDR_DISP8 : RIVER_ADDR_DISP;
		if (0 != mod) {
			type |= RIVER_ADDR_BASE;
			base.versioned = cg.GetCurrentReg(RIVER_REG_xBP);
		}
	} else {
		type |= RIVER_ADDR_BASE;
		base.versioned = cg.GetCurrentReg(bs);
	}

	px86++;
	return true;
}

bool RiverAddress32::DecodeFromx86(RiverCodeGen &cg, unsigned char *&px86, nodep::BYTE &extra, nodep::WORD flags) {
	scaleAndSegment = 0;
	DecodeFlags(flags);
	index.versioned = RIVER_REG_NONE;
	base.versioned = RIVER_REG_NONE;
	sib = 0;
	disp.d32 = 0;
	type = 0;

	modRM = *px86;
	px86++;

	nodep::BYTE mod = modRM >> 6, rm = modRM & 0x07;
	extra = (modRM >> 3) & 0x07;

	switch (mod) {
		case 0 :
			type = 0;
			break;
		case 1 :
			type = RIVER_ADDR_DISP8;
			break;
		case 2 :
			type = RIVER_ADDR_DISP;
			break;
		case 3 :
			type = 0; // direct register
			base.versioned = cg.GetCurrentReg(DecodeRegister(rm, flags));
			return true;
	}

	if (4 == rm) {
		DecodeSib(cg, px86);
	} else if ((0 == mod) && (5 == rm)) {
		type = RIVER_ADDR_DISP;
	} else {
		type |= RIVER_ADDR_BASE;
		base.versioned = cg.GetCurrentReg(rm);
	}

	if (type & RIVER_ADDR_DISP8) {
		disp.d8 = *px86;
		px86++;
	} else if (type & RIVER_ADDR_DISP) {
		disp.d32 = *(nodep::DWORD *)px86;
		px86 += 4;
	}

	return true;
}

#define RIVER_REG_EXP32(rg)  ((rg) & 0x07)

void RiverAddress32::FixEsp() {
	if (RIVER_REG_NONE != base.versioned) {
		if (RIVER_REG_EXP32(base.name) == RIVER_REG_xSP) {
			base.versioned = RIVER_REG_xAX;
			type |= RIVER_ADDR_DIRTY;
		}
	}

	if (type & RIVER_ADDR_INDEX) {
		if (RIVER_REG_EXP32(index.name) == RIVER_REG_xSP) {
			index.name = RIVER_REG_xAX;
			type |= RIVER_ADDR_DIRTY;
		}
	}
}

bool RiverAddress32::CleanAddr(nodep::WORD flags) {
	unsigned char mod, rm;
	
	type &= ~RIVER_ADDR_DIRTY;
	if (0 == type) {
		mod = 3;
		rm = EncodeRegister(flags);
	} else {

		// move esp from base to index
		if (type & RIVER_ADDR_BASE) {
			if (RIVER_REG_EXP32(base.name) == RIVER_REG_xSP) {
				if (type & RIVER_ADDR_INDEX) {
					return false;
				} else {
					index.versioned = base.versioned;
					base.name = RIVER_REG_NONE;

					type &= ~RIVER_ADDR_BASE;
					type |= RIVER_ADDR_INDEX | RIVER_ADDR_SCALE;

					scaleAndSegment = 0;
				}
			}
		}

		switch (type & (RIVER_ADDR_DISP8 | RIVER_ADDR_DISP)) {
			case 0:
				mod = 0;
				break;
			case RIVER_ADDR_DISP8:
				mod = 1;
				break;
			case RIVER_ADDR_DISP:
				mod = 2;
				break;
			default:
				return false;
		}

		if ((type & RIVER_ADDR_INDEX) || (type & RIVER_ADDR_SCALE)) {
		//if ((type & RIVER_ADDR_INDEX) && (type & RIVER_ADDR_SCALE)) {
			// handle sib
			rm = 4;

			unsigned char ss, idx, bs;
			if (type & RIVER_ADDR_SCALE) {
				ss = GetScaleBits();
			} else {
				ss = 0;
			}

			if (type & RIVER_ADDR_BASE) {
				bs = base.name;
			} else {
				bs = 5;
				mod = 0;
			}

			if (type & RIVER_ADDR_INDEX) {
				idx = index.name;
			} else {
				idx = 4;
			}

			sib = (ss << 6) | (idx << 3) | (bs);
		} else {
			if (0 == (type & RIVER_ADDR_BASE)) { // there is no base
				if (type & RIVER_ADDR_DISP) { // simply a displacement
					mod = 0;
					rm = 5;
				} else { // no 32bit displacement either
					return false;
				}
			} else {
				rm = base.name;
			}
		}
	}

	modRM = (mod << 6) | rm;
	return true;
}


bool RiverAddress32::EncodeTox86(unsigned char *&px86, nodep::BYTE extra, nodep::BYTE family, nodep::WORD modifiers) {
	if (family & RIVER_FAMILY_FLAG_ORIG_xSP) {
		RiverAddress32 rAddr;
		rev_memcpy(&rAddr, this, sizeof(rAddr));

		rAddr.FixEsp();
		return rAddr.EncodeTox86(px86, extra, family & (~RIVER_FAMILY_FLAG_ORIG_xSP), modifiers);
	}

	if (type & RIVER_ADDR_DIRTY) {
		if (!CleanAddr(modifiers)) {
			DEBUG_BREAK;
			return false;
		}
	}

	*px86 = (modRM & 0xC7) | (extra << 3);
	px86++;

	if (type & (RIVER_ADDR_INDEX | RIVER_ADDR_SCALE)) {
		*px86 = sib;
		px86++;
	}

	if (type & RIVER_ADDR_DISP8) {
		*px86 = disp.d8;
		px86++;
	} else if (type & RIVER_ADDR_DISP) {
		*(nodep::DWORD *)px86 = disp.d32;
		px86 += 4;
	}

	return true;
}

```

`revtracer/RiverAddress.h`:

```h
#ifndef _RIVER_ADDRESS_H
#define _RIVER_ADDRESS_H

//#include "river.h"
//#include "CodeGen.h"		

class RiverCodeGen;

struct RiverAddress {
	nodep::BYTE type; 						/* 0x00 - combination of RIVER_ADDR* flags */
	nodep::BYTE scaleAndSegment;			/* 0x01 - scale 1, 2, 4, or 8 */
	nodep::BYTE modRM; 					/* 0x02 - original modrm byte */
	nodep::BYTE sib;   					/* 0x03 - original sib byte */
	union RiverRegister base;		/* 0x04 - base register */
	union RiverRegister index;		/* 0x08 - index register */
	union {
		nodep::BYTE d8;
		nodep::DWORD d32;
	} disp;							/* 0x0C - displacement */

	inline nodep::BYTE GetScale() const {
		return 1 << (scaleAndSegment & 0x3);
	}

	inline nodep::BYTE GetScaleBits() const {
		return scaleAndSegment & 0x03;
	}

	inline void CopyScale(nodep::BYTE scale) {
		scaleAndSegment &= 0xFC;
		scaleAndSegment |= scale;
	}

	inline bool SetScale(nodep::BYTE scale) {
		static const nodep::BYTE sTbl[] = { 0xFF, 0, 1, 0xFF, 2, 0xFF, 0xFF, 0xFF, 4 };
		nodep::BYTE sb = sTbl[scale];
		if (0xFF == sb) {
			return false;
		}
		CopyScale(sb);
	}

	inline nodep::BYTE HasSegment() const {
		return scaleAndSegment & 0xFC;
	}

	inline nodep::BYTE GetSegment() const {
		return scaleAndSegment >> 2;
	}

	inline void SetSegment(nodep::BYTE segment) {
		scaleAndSegment &= 0x03;
		scaleAndSegment |= segment << 2;
	}

	nodep::BYTE GetUnusedRegisters() const;

	void DecodeFlags(nodep::WORD flags);

	virtual bool DecodeFromx86(RiverCodeGen &cg, unsigned char *&px86, nodep::BYTE &extra, nodep::WORD flags) = 0;
	virtual bool EncodeTox86(unsigned char *&px86, nodep::BYTE extra, nodep::BYTE family, nodep::WORD modifiers) = 0;
};

struct RiverAddress16 : public RiverAddress {
	bool DecodeSib(RiverCodeGen &cg, unsigned char *&px86);

	virtual bool DecodeFromx86(RiverCodeGen &cg, unsigned char *&px86, nodep::BYTE &extra, nodep::WORD flags);
	virtual bool EncodeTox86(unsigned char *&px86, nodep::BYTE extra, nodep::BYTE family, nodep::WORD modifiers);
};

struct RiverAddress32 : public RiverAddress {
	void FixEsp();
	bool CleanAddr(nodep::WORD flags);
	
	nodep::BYTE DecodeRegister(nodep::BYTE id, nodep::WORD flags);
	nodep::BYTE EncodeRegister(nodep::WORD flags);

	bool DecodeSib(RiverCodeGen &cg, unsigned char *&px86);

	virtual bool DecodeFromx86(RiverCodeGen &cg, unsigned char *&px86, nodep::BYTE &extra, nodep::WORD flags);
	virtual bool EncodeTox86(unsigned char *&px86, nodep::BYTE extra, nodep::BYTE family, nodep::WORD modifiers);
};


#endif

```

`revtracer/RiverMetaTranslator.cpp`:

```cpp
#include "RiverMetaTranslator.h"
#include "CodeGen.h"
#include "TranslatorUtil.h"

void RiverMetaTranslator::MakeAddNoFlagsRegImm8(RiverInstruction *rOut, const RiverRegister &reg, unsigned char offset, nodep::BYTE family, nodep::DWORD addr) {
	unsigned char rg = (reg.name & 0x07) | RIVER_OPSIZE_32;

	rOut->opCode = 0x83;
	rOut->subOpCode = 0;
	rOut->modifiers = 0;
	rOut->family = family;
	rOut->specifiers = RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_MODIFIES_OP1;

	rOut->modFlags = rOut->testFlags = 0;

	rOut->opTypes[0] = RIVER_OPTYPE_REG | RIVER_OPSIZE_32;
	rOut->operands[0].asRegister.versioned = codegen->GetCurrentReg(rg);

	rOut->opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
	rOut->operands[1].asImm8 = offset;

	rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rOut->instructionAddress = addr;

	rOut->TrackUnusedRegisters();
}

void RiverMetaTranslator::MakeSubNoFlagsRegImm8(RiverInstruction *rOut, const RiverRegister &reg, unsigned char offset, nodep::BYTE family, nodep::DWORD addr) {
	unsigned char rg = (reg.name & 0x07) | RIVER_OPSIZE_32;

	rOut->opCode = 0x83;
	rOut->subOpCode = 5;
	rOut->modifiers = 0;
	rOut->family = family;
	rOut->specifiers = RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_MODIFIES_OP1;

	rOut->modFlags = rOut->testFlags = 0;

	rOut->opTypes[0] = RIVER_OPTYPE_REG | RIVER_OPSIZE_32;
	rOut->operands[0].asRegister.versioned = codegen->GetCurrentReg(rg);

	rOut->opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
	rOut->operands[1].asImm8 = offset;

	rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rOut->instructionAddress = addr;

	rOut->TrackUnusedRegisters();
}

void RiverMetaTranslator::MakeMovRegMem32(RiverInstruction *rOut, const RiverRegister &reg, const RiverAddress &mem, nodep::BYTE family, nodep::DWORD addr) {
	rOut->opCode = 0x8B;
	rOut->subOpCode = 0;
	rOut->modifiers = 0;
	rOut->family = family;
	rOut->specifiers = RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1 | RIVER_SPEC_MODIFIES_OP1;

	rOut->modFlags = rOut->testFlags = 0;

	rOut->opTypes[0] = RIVER_OPTYPE_REG | RIVER_OPSIZE_32;
	rOut->operands[0].asRegister.versioned = reg.versioned;

	rOut->opTypes[1] = RIVER_OPTYPE_MEM | RIVER_OPSIZE_32;
	rOut->operands[1].asAddress = codegen->CloneAddress(mem, 0);

	rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rOut->instructionAddress = addr;
}

void RiverMetaTranslator::MakeMovMemReg32(RiverInstruction *rOut, const RiverAddress &mem, const RiverRegister &reg, nodep::BYTE family, nodep::DWORD addr) {
	rOut->opCode = 0x89;
	rOut->subOpCode = 0;
	rOut->modifiers = 0;
	rOut->family = family;
	rOut->specifiers = RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1 | RIVER_SPEC_MODIFIES_OP1;

	rOut->modFlags = rOut->testFlags = 0;

	rOut->opTypes[0] = RIVER_OPTYPE_MEM | RIVER_OPSIZE_32;
	rOut->operands[0].asAddress = codegen->CloneAddress(mem, 0);

	rOut->opTypes[1] = RIVER_OPTYPE_REG | RIVER_OPSIZE_32;
	rOut->operands[1].asRegister.versioned = reg.versioned;

	rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rOut->instructionAddress = addr;
}

void RiverMetaTranslator::MakeMovMemImm32(RiverInstruction *rOut, const RiverAddress &mem, nodep::DWORD imm, nodep::BYTE family, nodep::DWORD addr) {
	rOut->opCode = 0xC7;
	rOut->subOpCode = 0;
	rOut->modifiers = 0;
	rOut->family = family;
	rOut->specifiers = RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1 | RIVER_SPEC_MODIFIES_OP1;

	rOut->modFlags = rOut->testFlags = 0;

	rOut->opTypes[0] = RIVER_OPTYPE_MEM | RIVER_OPSIZE_32;
	rOut->operands[0].asAddress = codegen->CloneAddress(mem, 0);

	rOut->opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_32;
	rOut->operands[1].asImm32 = imm;

	rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rOut->instructionAddress = addr;
}

void RiverMetaTranslator::MakeMovMemMem32(RiverInstruction *rOut, const RiverAddress &memd, const RiverAddress &mems, nodep::BYTE family, nodep::DWORD addr) {
	rOut->opCode = 0xA5;
	rOut->subOpCode = 0;
	rOut->modifiers = 0;
	rOut->family = family;
	rOut->specifiers = RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1 | RIVER_SPEC_MODIFIES_OP1;

	rOut->modFlags = rOut->testFlags = 0;

	rOut->opTypes[0] = RIVER_OPTYPE_MEM | RIVER_OPSIZE_32;
	rOut->operands[0].asAddress = codegen->CloneAddress(memd, 0);

	rOut->opTypes[1] = RIVER_OPTYPE_MEM | RIVER_OPSIZE_32;
	rOut->operands[1].asAddress = codegen->CloneAddress(mems, 0);

	rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rOut->instructionAddress = addr;
}

bool RiverMetaTranslator::Init(RiverCodeGen *cg) {
	codegen = cg;
	return true;
}

bool RiverMetaTranslator::Translate(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount) {
	nodep::DWORD dwTable = (RIVER_MODIFIER_EXT & rIn.modifiers) ? 1 : 0;

	if (rIn.family == RIVER_FAMILY_NATIVE) {
		(this->*translateOpcodes[dwTable][rIn.opCode])(rOut, rIn, instrCount);
	}
	else {
		CopyInstruction(codegen, rOut[0], rIn);
		instrCount++;
	}
	return true;
}

void RiverMetaTranslator::TranslateUnk(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	DEBUG_BREAK;
}

void RiverMetaTranslator::TranslateDefault(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	CopyInstruction(codegen, rOut[0], rIn);
	instrCount += 1;
}

void RiverMetaTranslator::TranslatePushReg(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	MakeMovMemReg32(&rOut[0], *(rIn.operands[2].asAddress), rIn.operands[0].asRegister, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	MakeSubNoFlagsRegImm8(&rOut[1], rIn.operands[1].asRegister, 0x04, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	CopyInstruction(codegen, rOut[2], rIn);
	rOut[2].family |= RIVER_FAMILY_FLAG_METAPROCESSED;
	instrCount += 3;
}

void RiverMetaTranslator::TranslatePushMem(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	MakeMovMemMem32(&rOut[0], *(rIn.operands[2].asAddress), *(rIn.operands[0].asAddress), RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	MakeSubNoFlagsRegImm8(&rOut[1], rIn.operands[1].asRegister, 0x04, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	CopyInstruction(codegen, rOut[2], rIn);
	rOut[2].family |= RIVER_FAMILY_FLAG_METAPROCESSED;
	instrCount += 3;
}

void RiverMetaTranslator::TranslatePusha(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	RiverAddress32 rStack;
	RiverRegister rReg;

	rStack.type = RIVER_ADDR_BASE | RIVER_ADDR_DISP8 | RIVER_ADDR_DIRTY;
	rStack.base.versioned = codegen->GetPrevReg(RIVER_REG_xSP);
	
	rStack.disp.d8 = 0xFC;
	rReg.versioned = codegen->GetCurrentReg(RIVER_REG_xAX);
	MakeMovMemReg32(&rOut[0], rStack, rReg, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	rStack.disp.d8 = 0xF8;
	rReg.versioned = codegen->GetCurrentReg(RIVER_REG_xCX);
	MakeMovMemReg32(&rOut[1], rStack, rReg, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	rStack.disp.d8 = 0xF4;
	rReg.versioned = codegen->GetCurrentReg(RIVER_REG_xDX);
	MakeMovMemReg32(&rOut[2], rStack, rReg, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	rStack.disp.d8 = 0xF0;
	rReg.versioned = codegen->GetCurrentReg(RIVER_REG_xBX);
	MakeMovMemReg32(&rOut[3], rStack, rReg, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	rStack.disp.d8 = 0xEC;
	rReg.versioned = codegen->GetPrevReg(RIVER_REG_xSP);
	MakeMovMemReg32(&rOut[4], rStack, rReg, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	rStack.disp.d8 = 0xE8;
	rReg.versioned = codegen->GetCurrentReg(RIVER_REG_xBP);
	MakeMovMemReg32(&rOut[5], rStack, rReg, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	rStack.disp.d8 = 0xE4;
	rReg.versioned = codegen->GetCurrentReg(RIVER_REG_xSI);
	MakeMovMemReg32(&rOut[6], rStack, rReg, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	rStack.disp.d8 = 0xE0;
	rReg.versioned = codegen->GetCurrentReg(RIVER_REG_xDI);
	MakeMovMemReg32(&rOut[7], rStack, rReg, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	rReg.versioned = codegen->GetCurrentReg(RIVER_REG_xSP);
	MakeSubNoFlagsRegImm8(&rOut[8], rReg, 0x20, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	CopyInstruction(codegen, rOut[9], rIn);
	rOut[9].family |= RIVER_FAMILY_FLAG_METAPROCESSED;
	instrCount += 10;
}

void RiverMetaTranslator::TranslatePopReg(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	MakeMovRegMem32(&rOut[0], rIn.operands[0].asRegister, *rIn.operands[2].asAddress, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	MakeAddNoFlagsRegImm8(&rOut[1], rIn.operands[1].asRegister, 0x04, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	
	CopyInstruction(codegen, rOut[2], rIn);
	rOut[2].family |= RIVER_FAMILY_FLAG_METAPROCESSED;
	instrCount += 3;
}

void RiverMetaTranslator::TranslatePopMem(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	MakeMovMemMem32(&rOut[0], *rIn.operands[0].asAddress, *rIn.operands[2].asAddress, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	MakeAddNoFlagsRegImm8(&rOut[1], rIn.operands[1].asRegister, 0x04, RIVER_FAMILY_PREMETA, rIn.instructionAddress);

	CopyInstruction(codegen, rOut[2], rIn);
	rOut[2].family |= RIVER_FAMILY_FLAG_METAPROCESSED;
	instrCount += 3;
}

void RiverMetaTranslator::TranslateCall(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	MakeMovMemImm32(&rOut[0], *(rIn.operands[3].asAddress), rIn.operands[1].asImm32, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	MakeSubNoFlagsRegImm8(&rOut[1], rIn.operands[2].asRegister, 0x04, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	CopyInstruction(codegen, rOut[2], rIn);
	rOut[2].family |= RIVER_FAMILY_FLAG_METAPROCESSED;
	instrCount += 3;
}

void RiverMetaTranslator::TranslateRet(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	MakeAddNoFlagsRegImm8(&rOut[0], rIn.operands[0].asRegister, 0x04, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	CopyInstruction(codegen, rOut[1], rIn);
	rOut[1].family |= RIVER_FAMILY_FLAG_METAPROCESSED;
	instrCount += 2;
}

void RiverMetaTranslator::TranslateRetn(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	MakeAddNoFlagsRegImm8(&rOut[0], rIn.operands[1].asRegister, rIn.operands[0].asImm16 + 0x04, RIVER_FAMILY_PREMETA, rIn.instructionAddress);
	CopyInstruction(codegen, rOut[1], rIn);
	rOut[1].family |= RIVER_FAMILY_FLAG_METAPROCESSED;
	instrCount += 2;
}

RiverMetaTranslator::TranslateOpcodeFunc RiverMetaTranslator::translate0xFFOp[8] = {
	&RiverMetaTranslator::TranslateDefault,
	&RiverMetaTranslator::TranslateDefault,
	&RiverMetaTranslator::TranslateCall,
	&RiverMetaTranslator::TranslateDefault,
	&RiverMetaTranslator::TranslateDefault,
	&RiverMetaTranslator::TranslateDefault,
	&RiverMetaTranslator::TranslatePushMem,
	&RiverMetaTranslator::TranslateDefault,
};


RiverMetaTranslator::TranslateOpcodeFunc RiverMetaTranslator::translateOpcodes[2][0x100] = {
	{
		/* 0x00 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x01 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x02 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x03 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x04 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x05 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x06 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x07 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x08 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x09 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x0A */ &RiverMetaTranslator::TranslateDefault,
		/* 0x0B */ &RiverMetaTranslator::TranslateDefault,
		/* 0x0C */ &RiverMetaTranslator::TranslateDefault,
		/* 0x0D */ &RiverMetaTranslator::TranslateDefault,
		/* 0x0E */ &RiverMetaTranslator::TranslateDefault,
		/* 0x0F */ &RiverMetaTranslator::TranslateDefault,
		/* 0x10 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x11 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x12 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x13 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x14 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x15 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x16 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x17 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x18 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x19 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x1A */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x1B */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x1C */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x1D */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x1E */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x1F */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x20 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x21 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x22 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x23 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x24 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x25 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x26 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x27 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x28 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x29 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x2A */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x2B */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x2C */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x2D */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x2E */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x2F */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x30 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x31 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x32 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x33 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x34 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x35 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x36 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x37 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x38 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x39 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x3A */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x3B */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x3C */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x3D */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x3E */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x4F */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x40 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x41 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x42 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x43 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x44 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x45 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x46 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x47 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x48 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x49 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x4A */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x4B */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x4C */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x4D */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x4E */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x4F */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x50 */ &RiverMetaTranslator::TranslatePushReg,
		/* 0x51 */ &RiverMetaTranslator::TranslatePushReg,
		/* 0x52 */ &RiverMetaTranslator::TranslatePushReg,
		/* 0x53 */ &RiverMetaTranslator::TranslatePushReg,
		/* 0x54 */ &RiverMetaTranslator::TranslatePushReg,
		/* 0x55 */ &RiverMetaTranslator::TranslatePushReg,
		/* 0x56 */ &RiverMetaTranslator::TranslatePushReg,
		/* 0x57 */ &RiverMetaTranslator::TranslatePushReg,
		/* 0x58 */ &RiverMetaTranslator::TranslatePopReg,
		/* 0x59 */ &RiverMetaTranslator::TranslatePopReg,
		/* 0x5A */ &RiverMetaTranslator::TranslatePopReg,
		/* 0x5B */ &RiverMetaTranslator::TranslatePopReg,
		/* 0x5C */ &RiverMetaTranslator::TranslatePopReg,
		/* 0x5D */ &RiverMetaTranslator::TranslatePopReg,
		/* 0x5E */ &RiverMetaTranslator::TranslatePopReg,
		/* 0x5F */ &RiverMetaTranslator::TranslatePopReg,
		/* 0x60 */ &RiverMetaTranslator::TranslatePusha,
		/* 0x61 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x62 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x63 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x64 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x65 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x66 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x67 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x68 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x69 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x6A */ &RiverMetaTranslator::TranslateDefault,
		/* 0x6B */ &RiverMetaTranslator::TranslateDefault,
		/* 0x6C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x6D */ &RiverMetaTranslator::TranslateUnk,
		/* 0x6E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x6F */ &RiverMetaTranslator::TranslateUnk,
		/* 0x70 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x71 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x72 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x73 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x74 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x75 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x76 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x77 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x78 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x79 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x7A */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x7B */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x7C */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x7D */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x7E */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x7F */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x80 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x01 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x82 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x83 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x84 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x85 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x86 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x87 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x88 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x89 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x8A */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x8B */ &RiverMetaTranslator::TranslateDefault,
		/* 0x8C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x8D */ &RiverMetaTranslator::TranslateDefault,
		/* 0x8E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x8F */ &RiverMetaTranslator::TranslatePopMem,
		/* 0x90 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x91 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x92 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x93 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x94 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x95 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x96 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x97 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x98 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x99 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x9A */ &RiverMetaTranslator::TranslateUnk,
		/* 0x9B */ &RiverMetaTranslator::TranslateUnk,
		/* 0x9C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x9D */ &RiverMetaTranslator::TranslateUnk,
		/* 0x9E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x9F */ &RiverMetaTranslator::TranslateUnk,
		/* 0xA0 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA1 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA2 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA3 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA4 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA5 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA6 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA7 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA8 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA9 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xAA */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xAB */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xAC */ &RiverMetaTranslator::TranslateUnk, 
		/* 0xAD */ &RiverMetaTranslator::TranslateUnk, 
		/* 0xAE */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xAF */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB0 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB1 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB2 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB3 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB4 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB5 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB6 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB7 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB8 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xB9 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xBA */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xBB */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xBC */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xBD */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xBE */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xBF */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xC0 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC1 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC2 */ &RiverMetaTranslator::TranslateRetn,
		/* 0xC3 */ &RiverMetaTranslator::TranslateRet,
		/* 0xC4 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xC5 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xC6 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC7 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC8 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC9 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCA */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCB */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCC */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCD */ &RiverMetaTranslator::TranslateUnk,
		/* 0xCE */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCF */ &RiverMetaTranslator::TranslateDefault,
		/* 0xD0 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xD1 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xD2 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xD3 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xD4 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD5 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD6 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD7 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD8 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD9 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDA */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDB */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDC */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDD */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDE */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDF */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE0 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xE1 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xE2 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xE3 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xE4 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE5 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE6 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE7 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE8 */ &RiverMetaTranslator::TranslateCall,
		/* 0xE9 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xEA */ &RiverMetaTranslator::TranslateDefault,
		/* 0xEB */ &RiverMetaTranslator::TranslateDefault,
		/* 0xEC */ &RiverMetaTranslator::TranslateUnk,
		/* 0xED */ &RiverMetaTranslator::TranslateUnk,
		/* 0xEE */ &RiverMetaTranslator::TranslateUnk,
		/* 0xEF */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF0 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xF1 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF2 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xF3 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xF4 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF5 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF6 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xF7 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xF8 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF9 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xFA */ &RiverMetaTranslator::TranslateUnk,
		/* 0xFB */ &RiverMetaTranslator::TranslateUnk,
		/* 0xFC */ &RiverMetaTranslator::TranslateDefault,
		/* 0xFD */ &RiverMetaTranslator::TranslateDefault,
		/* 0xFE */ &RiverMetaTranslator::TranslateDefault,
		/* 0xFF */ &RiverMetaTranslator::TranslateSubOp<translate0xFFOp>
	}, {
		/* 0x00 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x01 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x02 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x03 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x04 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x05 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x06 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x07 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x08 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x09 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x0A */ &RiverMetaTranslator::TranslateUnk,
		/* 0x0B */ &RiverMetaTranslator::TranslateUnk,
		/* 0x0C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x0D */ &RiverMetaTranslator::TranslateUnk,
		/* 0x0E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x0F */ &RiverMetaTranslator::TranslateUnk,
		/* 0x10 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x11 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x12 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x13 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x14 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x15 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x16 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x17 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x18 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x19 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x1A */ &RiverMetaTranslator::TranslateUnk,
		/* 0x1B */ &RiverMetaTranslator::TranslateUnk,
		/* 0x1C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x1D */ &RiverMetaTranslator::TranslateUnk,
		/* 0x1E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x1F */ &RiverMetaTranslator::TranslateDefault,
		/* 0x20 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x21 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x22 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x23 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x24 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x25 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x26 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x27 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x28 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x29 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x2A */ &RiverMetaTranslator::TranslateUnk,
		/* 0x2B */ &RiverMetaTranslator::TranslateUnk,
		/* 0x2C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x2D */ &RiverMetaTranslator::TranslateUnk,
		/* 0x2E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x2F */ &RiverMetaTranslator::TranslateUnk,
		/* 0x30 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x31 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x32 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x33 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x34 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x35 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x36 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x37 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x38 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x39 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x3A */ &RiverMetaTranslator::TranslateUnk,
		/* 0x3B */ &RiverMetaTranslator::TranslateUnk,
		/* 0x3C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x3D */ &RiverMetaTranslator::TranslateUnk,
		/* 0x3E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x4F */ &RiverMetaTranslator::TranslateUnk,
		/* 0x40 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x41 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x42 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x43 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x44 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x45 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x46 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x47 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x48 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x49 */ &RiverMetaTranslator::TranslateDefault,
		/* 0x4A */ &RiverMetaTranslator::TranslateDefault,
		/* 0x4B */ &RiverMetaTranslator::TranslateDefault,
		/* 0x4C */ &RiverMetaTranslator::TranslateDefault,
		/* 0x4D */ &RiverMetaTranslator::TranslateDefault,
		/* 0x4E */ &RiverMetaTranslator::TranslateDefault,
		/* 0x4F */ &RiverMetaTranslator::TranslateDefault,
		/* 0x50 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x51 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x52 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x53 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x54 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x55 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x56 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x57 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x58 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x59 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x5A */ &RiverMetaTranslator::TranslateUnk,
		/* 0x5B */ &RiverMetaTranslator::TranslateUnk,
		/* 0x5C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x5D */ &RiverMetaTranslator::TranslateUnk,
		/* 0x5E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x5F */ &RiverMetaTranslator::TranslateUnk,
		/* 0x60 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x61 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x62 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x63 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x64 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x65 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x66 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x67 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x68 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x69 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x6A */ &RiverMetaTranslator::TranslateUnk,
		/* 0x6B */ &RiverMetaTranslator::TranslateUnk,
		/* 0x6C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x6D */ &RiverMetaTranslator::TranslateUnk,
		/* 0x6E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x6F */ &RiverMetaTranslator::TranslateUnk,
		/* 0x70 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x71 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x72 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x73 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x74 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x75 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x76 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x77 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x78 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x79 */ &RiverMetaTranslator::TranslateUnk,
		/* 0x7A */ &RiverMetaTranslator::TranslateUnk,
		/* 0x7B */ &RiverMetaTranslator::TranslateUnk,
		/* 0x7C */ &RiverMetaTranslator::TranslateUnk,
		/* 0x7D */ &RiverMetaTranslator::TranslateUnk,
		/* 0x7E */ &RiverMetaTranslator::TranslateUnk,
		/* 0x7F */ &RiverMetaTranslator::TranslateUnk,
		/* 0x80 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x01 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x82 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x83 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x84 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x85 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x86 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x87 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x88 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x89 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x8A */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x8B */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x8C */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x8D */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x8E */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x8F */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x90 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x91 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x92 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x93 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x94 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x95 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x96 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x97 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x98 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x99 */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x9A */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x9B */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x9C */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x9D */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x9E */ &RiverMetaTranslator::TranslateDefault, 
		/* 0x9F */ &RiverMetaTranslator::TranslateDefault, 
		/* 0xA0 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xA1 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xA2 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xA3 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xA4 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xA5 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xA6 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xA7 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xA8 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xA9 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xAA */ &RiverMetaTranslator::TranslateUnk,
		/* 0xAB */ &RiverMetaTranslator::TranslateDefault,
		/* 0xAC */ &RiverMetaTranslator::TranslateDefault,
		/* 0xAD */ &RiverMetaTranslator::TranslateDefault,
		/* 0xAE */ &RiverMetaTranslator::TranslateUnk,
		/* 0xAF */ &RiverMetaTranslator::TranslateDefault,
		/* 0xB0 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xB1 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xB2 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xB3 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xB4 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xB5 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xB6 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xB7 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xB8 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xB9 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xBA */ &RiverMetaTranslator::TranslateDefault,
		/* 0xBB */ &RiverMetaTranslator::TranslateUnk,
		/* 0xBC */ &RiverMetaTranslator::TranslateDefault,
		/* 0xBD */ &RiverMetaTranslator::TranslateDefault,
		/* 0xBE */ &RiverMetaTranslator::TranslateDefault,
		/* 0xBF */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC0 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC1 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC2 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xC3 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xC4 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xC5 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xC6 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xC7 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC8 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xC9 */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCA */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCB */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCC */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCD */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCE */ &RiverMetaTranslator::TranslateDefault,
		/* 0xCF */ &RiverMetaTranslator::TranslateDefault,
		/* 0xD0 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD1 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD2 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD3 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD4 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD5 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD6 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD7 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD8 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xD9 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDA */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDB */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDC */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDD */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDE */ &RiverMetaTranslator::TranslateUnk,
		/* 0xDF */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE0 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE1 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE2 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE3 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE4 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE5 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE6 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE7 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE8 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xE9 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xEA */ &RiverMetaTranslator::TranslateUnk,
		/* 0xEB */ &RiverMetaTranslator::TranslateUnk,
		/* 0xEC */ &RiverMetaTranslator::TranslateUnk,
		/* 0xED */ &RiverMetaTranslator::TranslateUnk,
		/* 0xEE */ &RiverMetaTranslator::TranslateUnk,
		/* 0xEF */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF0 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF1 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF2 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF3 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF4 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF5 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF6 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF7 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF8 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xF9 */ &RiverMetaTranslator::TranslateUnk,
		/* 0xFA */ &RiverMetaTranslator::TranslateUnk,
		/* 0xFB */ &RiverMetaTranslator::TranslateUnk,
		/* 0xFC */ &RiverMetaTranslator::TranslateUnk,
		/* 0xFD */ &RiverMetaTranslator::TranslateUnk,
		/* 0xFE */ &RiverMetaTranslator::TranslateUnk,
		/* 0xFF */ &RiverMetaTranslator::TranslateUnk
	}
};


```

`revtracer/RiverMetaTranslator.h`:

```h
#ifndef _RIVER_META_TRANSLATOR_H
#define _RIVER_META_TRANSLATOR_H

#include "revtracer.h"
#include "river.h"

class RiverCodeGen;

class RiverMetaTranslator {
private: 
	RiverCodeGen *codegen;

	typedef void(RiverMetaTranslator::*TranslateOpcodeFunc)(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);

	static TranslateOpcodeFunc translateOpcodes[2][0x100];
	static TranslateOpcodeFunc translate0xFFOp[8];
public:
	bool Init(RiverCodeGen *cg);
	bool Translate(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount);

private:
	void MakeAddNoFlagsRegImm8(RiverInstruction *rOut, const RiverRegister &reg, unsigned char offset, nodep::BYTE family, nodep::DWORD addr);
	void MakeSubNoFlagsRegImm8(RiverInstruction *rOut, const RiverRegister &reg, unsigned char offset, nodep::BYTE family, nodep::DWORD addr);

	void MakeMovRegMem32(RiverInstruction *rOut, const RiverRegister &reg, const RiverAddress &mem, nodep::BYTE family, nodep::DWORD addr);
	void MakeMovMemReg32(RiverInstruction *rOut, const RiverAddress &mem, const RiverRegister &reg, nodep::BYTE family, nodep::DWORD addr);
	void MakeMovMemMem32(RiverInstruction *rOut, const RiverAddress &memd, const RiverAddress &mems, nodep::BYTE family, nodep::DWORD addr);


	void MakeMovMemImm32(RiverInstruction *rOut, const RiverAddress &mem, nodep::DWORD imm, nodep::BYTE family, nodep::DWORD addr);

	void TranslateUnk(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslateDefault(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslatePushReg(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslatePushMem(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslatePusha(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);

	void TranslatePopReg(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslatePopMem(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);

	void TranslateCall(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslateRet(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslateRetn(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);

	template <TranslateOpcodeFunc *fSubOps> void TranslateSubOp(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
		(this->*fSubOps[rIn.subOpCode])(rOut, rIn, instrCount);
	}
};

#endif

```

`revtracer/RiverPrintTable.cpp`:

```cpp
#include "river.h"
#include "riverinternl.h"

#include "revtracer.h"

//#include <stdio.h>

extern const char PrintMnemonicTable00[][10];
extern const char PrintMnemonicTable0F[][10];
extern const char PrintMnemonicExt[][8][10];


extern const char RegNames[][4];
extern const char MemSizes[][6];

void PrintPrefixes(nodep::DWORD printMask, struct RiverInstruction *ri) {
	if (ri->family & RIVER_FAMILY_FLAG_IGNORE) {
		revtracerImports.dbgPrintFunc(printMask, "ignore");
	}

	if (ri->family & RIVER_FAMILY_FLAG_ORIG_xSP) {
		revtracerImports.dbgPrintFunc(printMask, "esp");
	}

	switch (RIVER_FAMILY(ri->family)) {
		case RIVER_FAMILY_RIVER:
			revtracerImports.dbgPrintFunc(printMask, "river");
			break;
		case RIVER_FAMILY_TRACK :
			revtracerImports.dbgPrintFunc(printMask, "track");
			break;
		case RIVER_FAMILY_PRETRACK :
			revtracerImports.dbgPrintFunc(printMask, "pretrack");
			break;
		case RIVER_FAMILY_PREMETA :
			revtracerImports.dbgPrintFunc(printMask, "premeta");
			break;
		case RIVER_FAMILY_POSTMETA:
			revtracerImports.dbgPrintFunc(printMask, "postmeta");
			break;
		case RIVER_FAMILY_RIVER_TRACK:
			revtracerImports.dbgPrintFunc(printMask, "rivertrack");
			break;
		case RIVER_FAMILY_REP:
			break;
	}
}

void PrintMnemonic(nodep::DWORD printMask, struct RiverInstruction *ri) {
	const char (*mTable)[10] = PrintMnemonicTable00;

	if (RIVER_MODIFIER_EXT & ri->modifiers) {
		mTable = PrintMnemonicTable0F;
	}

	if (ri->family == RIVER_FAMILY_REP) {
		switch(ri->opCode) {
			case 0xF2:
				revtracerImports.dbgPrintFunc(printMask, "repinit");
				break;
			case 0xF3:
				revtracerImports.dbgPrintFunc(printMask, "repfini");
				break;
			case 0xCC:
				break;
			default:
				DEBUG_BREAK;
		}
	} else {
		if ('a' <= mTable[ri->opCode][0]) {
			revtracerImports.dbgPrintFunc(printMask, "%s ", mTable[ri->opCode]);
		} else {
			revtracerImports.dbgPrintFunc(printMask, "%s ", PrintMnemonicExt[mTable[ri->opCode][0]][ri->subOpCode]);
		}
	}
}

void PrintRegister(nodep::DWORD printMask, struct RiverInstruction *ri, union RiverRegister *reg) {
	revtracerImports.dbgPrintFunc(printMask, "%s$%d", RegNames[reg->name], reg->versioned >> 8);
}

void PrintOperand(nodep::DWORD printMask, struct RiverInstruction *ri, nodep::DWORD idx) {
	bool bWr = false;

	if (RIVER_OPFLAG_IMPLICIT & ri->opTypes[idx]) {
		revtracerImports.dbgPrintFunc(printMask, "{");
	}

	switch (RIVER_OPTYPE(ri->opTypes[idx])) {
		case RIVER_OPTYPE_IMM :
			switch (ri->opTypes[idx] & 0x03) {
				case RIVER_OPSIZE_8 :
					revtracerImports.dbgPrintFunc(printMask, "0x%02x", ri->operands[idx].asImm8);
					break;
				case RIVER_OPSIZE_16:
					revtracerImports.dbgPrintFunc(printMask, "0x%04x", ri->operands[idx].asImm16);
					break;
				case RIVER_OPSIZE_32:
					revtracerImports.dbgPrintFunc(printMask, "0x%08x", ri->operands[idx].asImm32);
					break;
			};
			break;

		case RIVER_OPTYPE_REG :
			revtracerImports.dbgPrintFunc(printMask, "%s$%d", RegNames[ri->operands[idx].asRegister.name], ri->operands[idx].asRegister.versioned >> 8);
			break;

		case RIVER_OPTYPE_MEM :
			if (0 == ri->operands[idx].asAddress->type) {
				revtracerImports.dbgPrintFunc(printMask, "%s$%d", RegNames[ri->operands[idx].asAddress->base.name], ri->operands[idx].asAddress->base.versioned >> 8);
				break;
			}

			revtracerImports.dbgPrintFunc(printMask, "%s ptr ", MemSizes[ri->opTypes[idx] & 0x03]);

			if (ri->operands[idx].asAddress->HasSegment()) {
				revtracerImports.dbgPrintFunc(printMask, "%s:", RegNames[RIVER_REG_SEGMENT | (ri->operands[idx].asAddress->GetSegment() - 1)]);
			}

			revtracerImports.dbgPrintFunc(printMask, "[");
			if (ri->operands[idx].asAddress->type & RIVER_ADDR_BASE) {
				revtracerImports.dbgPrintFunc(printMask, "%s$%d", RegNames[ri->operands[idx].asAddress->base.name], ri->operands[idx].asAddress->base.versioned >> 8);
				bWr = true;
			}

			if (ri->operands[idx].asAddress->type & RIVER_ADDR_INDEX) {
				if (bWr) {
					revtracerImports.dbgPrintFunc(printMask, "+");
				}

				if (ri->operands[idx].asAddress->type & RIVER_ADDR_SCALE) {
					revtracerImports.dbgPrintFunc(printMask, "%d*", ri->operands[idx].asAddress->GetScale());
				}

				revtracerImports.dbgPrintFunc(printMask, "%s$%d", RegNames[ri->operands[idx].asAddress->index.name], ri->operands[idx].asAddress->index.versioned >> 8);
				bWr = true;
			}

			if (ri->operands[idx].asAddress->type & (RIVER_ADDR_DISP8 | RIVER_ADDR_DISP)) {
				if (bWr) {
					revtracerImports.dbgPrintFunc(printMask, "+");
				}

				switch (ri->operands[idx].asAddress->type & (RIVER_ADDR_DISP8 | RIVER_ADDR_DISP)) {
					case RIVER_ADDR_DISP8 :
						revtracerImports.dbgPrintFunc(printMask, "0x%02x", ri->operands[idx].asAddress->disp.d8);
						break;
					/*case RIVER_ADDR_DISP16:
						DbgPrint("0x%04x", ri->operands[idx].asAddress->disp.d16);
						break;*/
					case RIVER_ADDR_DISP:
						revtracerImports.dbgPrintFunc(printMask, "0x%08x", ri->operands[idx].asAddress->disp.d32);
						break;
				}
			}
				 

			revtracerImports.dbgPrintFunc(printMask, "]");
			break;
	}

	if (RIVER_OPFLAG_IMPLICIT & ri->opTypes[idx]) {
		revtracerImports.dbgPrintFunc(printMask, "}");
	}
}

void PrintOperands(nodep::DWORD printMask, struct RiverInstruction *ri) {
	PrintOperand(printMask, ri, 0);

	for (int i = 1; i < 4; ++i) {
		if (ri->opTypes[i] != RIVER_OPTYPE_NONE) {
			revtracerImports.dbgPrintFunc(printMask, ", ");
			PrintOperand(printMask, ri, i);
		}
	}
}

void RiverPrintInstruction(nodep::DWORD printMask, struct RiverInstruction *ri) {
	if (ri->family & RIVER_FAMILY_FLAG_IGNORE) {
		return;
	}
	PrintPrefixes(printMask, ri);
	PrintMnemonic(printMask, ri);
	PrintOperands(printMask, ri);
	revtracerImports.dbgPrintFunc(printMask, "\n");
	//printf("%s", )
}

const char MemSizes[][6] = {
	"dword", "word", "byte"
};

const char RegNames[][4] = {
	"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi",
	 "ax",  "cx",  "dx",  "bx",  "sp",  "bp",  "si",  "di",
	 "al",  "cl",  "dl",  "bl",  "--",  "--",  "--",  "--",
	 "ah",  "ch",  "dh",  "bh",  "--",  "--",  "--",  "--",

	 "es",  "cs",  "ss",  "ds",  "fs",  "gs",  "--",  "--",
	"cr0",  "--", "cr2", "cr3", "cr4",  "--",  "--",  "--",
	"dr0", "dr1", "dr2", "dr3", "dr4", "dr5", "dr6", "dr7"
};

const char PrintMnemonicTable00[][10] = {
	/*0x00*/"add", "add", "add", "add", "add", "add", "", "", "or",  "or",  "or",  "or",  "or",  "or", "", "",
	/*0x10*/"adc", "adc", "adc", "adc", "adc", "adc", "", "", "sbb", "sbb", "sbb", "sbb", "sbb", "sbb", "", "",
	/*0x20*/"and", "and", "and", "and", "and", "and", "", "", "sub", "sub", "sub", "sub", "sub", "sub", "", "",
	/*0x30*/"xor", "xor", "xor", "xor", "xor", "xor", "", "", "cmp", "cmp", "cmp", "cmp", "cmp", "cmp", "", "",
	/*0x40*/"inc", "inc", "inc", "inc", "inc", "inc", "inc", "inc", "dec", "dec", "dec", "dec", "dec", "dec", "dec", "dec",
	/*0x50*/"push", "push", "push", "push", "push", "push", "push", "push", "pop", "pop", "pop", "pop", "pop", "pop", "pop", "pop",
	/*0x60*/"", "", "", "", "", "", "", "", "push", "imul", "push", "imul", "", "", "", "",
	/*0x70*/"jo", "jno", "jc", "jnc", "jz", "jnz", "jbe", "jnbe", "js", "jns", "jp", "jnp", "jl", "jnl", "jle", "jnle",
	/*0x80*/"\1", "\1", "\1", "\1", "test", "test", "xchg", "xchg", "mov", "mov", "mov", "mov", "", "lea", "", "pop",
	/*0x90*/"nop", "xchg", "xchg", "xchg", "xchg", "xchg", "xchg", "xchg", "", "cdq", "", "", "pushf", "popf", "", "",
	/*0xA0*/"mov", "mov", "mov", "mov", "movs", "movs", "cmps", "cmps", "test", "test", "stos", "stos", "", "", "scas", "scas",
	/*0xB0*/"mov", "mov", "mov", "mov", "mov", "mov", "mov", "mov", "mov", "mov", "mov", "mov", "mov", "mov", "mov", "mov",
	/*0xC0*/"\2", "\2", "retn", "retn", "", "", "mov", "mov", "", "leave", "", "", "", "", "", "",
	/*0xD0*/"\2", "\2", "\2", "\2", "", "", "", "", "", "", "", "", "", "", "", "",
	/*0xE0*/"loopnz", "loopz", "loop", "jecx", "", "", "", "", "call", "jmp", "jmpf", "jmp", "", "", "", "",
	/*0xF0*/"", "", "", "", "", "", "\4", "\4", "", "", "", "", "cld", "std", "\6", "\3"
};

const char PrintMnemonicTable0F[][10] = {
	/*0x00*/"", "", "lar", "lsl", "", "syscall", "", "", "", "", "", "", "", "", "", "",
	/*0x10*/"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	/*0x20*/"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	/*0x30*/"", "rdtsc", "", "", "sysenter", "", "", "", "", "", "", "", "", "", "", "",
	/*0x40*/"cmovo", "cmovno", "cmovc", "cmovnc", "cmovz", "cmovnz", "cmovbe", "cmovnbe", "cmovs", "cmovns", "cmovp", "cmovnp", "cmovl", "cmovnl", "cmovle", "cmovnle",
	/*0x50*/"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	/*0x60*/"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	/*0x70*/"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	/*0x80*/"jo", "jno", "jc", "jnc", "jz", "jnz", "jbe", "jnbe", "js", "jns", "jp", "jnp", "jl", "jnl", "jle", "jnle",
	/*0x90*/"seto", "setno", "setc", "setnc", "setz", "setnz", "setbe", "setnbe", "sets", "setns", "setp", "setnp", "setl", "setnl", "setle", "setnle",
	/*0xA0*/"", "", "cpuid", "", "shld", "shld", "", "", "", "", "", "", "shrd", "shrd", "", "imul",
	/*0xB0*/"cmpxchg", "cmpxchg", "", "", "", "", "movzx", "movzx", "", "", "\5", "", "bsf", "bsr", "movsx", "movsx",
	/*0xC0*/"xadd", "xadd", "", "", "", "", "", "\7", "bswap", "bswap", "bswap", "bswap", "bswap", "bswap", "bswap", "bswap",
	/*0xD0*/"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	/*0xE0*/"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	/*0xF0*/"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""
};

const char PrintMnemonicExt[][8][10] = {
	/*for unknown */{ "___", "___", "___", "___", "___", "___", "___", "___" },
	/*for 0x83    */{ "add",  "or", "adc", "sbb", "and", "sub", "xor", "cmp" },
	/*for 0xC0/C1 */{ "rol", "ror", "rcl", "rcr", "shl", "shr", "sal", "sar"},
	/*for 0xFF    */{ "inc", "dec", "call", "call", "jmp", "jmp", "push", "___" },
	/*for 0xF6/F7 */{ "test", "test", "not", "neg", "mul", "imul", "div", "idiv" },
	/*for 0x0FBA  */{ "___", "___", "___", "___", "bt", "bts", "btr", "btc" },
	/*for 0xFE    */{ "inc", "dec", "___", "___", "___", "___", "___", "___" },
	/*for 0x0FC7  */{ "___", "cmpxchg8b", "___", "___", "___", "___", "___", "___" }
};

```

`revtracer/RiverRepAssembler.cpp`:

```cpp
#include "RiverRepAssembler.h"

const unsigned jmpSize = 5;
const unsigned loopSize = 2;

void AssembleDebugBreak(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter) {
	static const nodep::BYTE intCode = 0xcc;

	*px86.cursor = intCode;
	px86.cursor += 1;
	instrCounter += 1;
}

void AssembleRepinitInstruction(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &instrCounter) {
	static const nodep::BYTE repinitCode[] = {
		0xE9, 0x00, 0x00, 0x00, 0x00,        //jmp wrapin
		0xE9, 0x00, 0x00, 0x00, 0x00,        //jmp codein
		0x00, 0x00,                          //loop init
		0xE9, 0x00, 0x00, 0x00, 0x00		 //jmp codeout
	};

	rev_memcpy(px86.cursor, repinitCode, sizeof(repinitCode));

	unsigned wrapinOffset = jmpSize + loopSize + jmpSize +
		jmpSize + jmpSize + jmpSize; // actual code size is fixed RelocableCodeBuffer::MarkRepFini
	*(unsigned int *)(px86.cursor + 1) = wrapinOffset;

	unsigned codeinOffset = loopSize + jmpSize;
	*(unsigned int *)(px86.cursor + 6) = codeinOffset;

	nodep::BYTE loopOpcode = 0x0;
	if (ri.modifiers & RIVER_MODIFIER_REP) {
		loopOpcode = 0xE2;
	} else if (ri.modifiers & RIVER_MODIFIER_REPZ) {
		loopOpcode = 0xE1;
	} else if (ri.modifiers & RIVER_MODIFIER_REPNZ) {
		loopOpcode = 0xE0;
	} else {
		DEBUG_BREAK;
	}
	*(px86.cursor + 10) = loopOpcode;
	*(px86.cursor + 11) = (nodep::BYTE)(-1 * (loopSize + jmpSize));

	*(unsigned int *)(px86.cursor + 13) = jmpSize; //actual code size is fixed in RelocableCodeBuffer::MarkRepFini

	px86.cursor += sizeof(repinitCode);
	instrCounter += 4;
}

void AssembleFarloopInstruction(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter) {
	static const nodep::BYTE farloopCode[] = {
		0xE9, 0x00, 0x00, 0x00, 0x00,	//jmp init
		0x8D, 0x49, 0x01,				//lea ecx, [ecx + 1]
		0xE2, 0x00						//loop farloop
	};

	rev_memcpy(px86.cursor, farloopCode, sizeof(farloopCode));

	unsigned initOffset = -1 * (jmpSize + jmpSize + jmpSize + jmpSize +
			loopSize + jmpSize); //actual code size is fixed by RelocableCodeBuffer::MarkRepFini
	*(nodep::DWORD *)(px86.cursor + 1) = initOffset;

	nodep::BYTE loopOffset = (nodep::BYTE)(-1 * (loopSize + 3 + jmpSize));
	*(px86.cursor + 9) = loopOffset;

	px86.cursor += sizeof(farloopCode);
	instrCounter += 3;
}

void AssembleRepfiniInstruction(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter) {
	static const nodep::BYTE repfiniCode[] = {
		0xE9, 0x00, 0x00, 0x00, 0x00, //jmp loop
		0xE9, 0x00, 0x00, 0x00, 0x00  //jmp wrapout
	};

	rev_memcpy(px86.cursor, repfiniCode, sizeof(repfiniCode));

	unsigned jmpLoopOffset = -1 * (jmpSize + jmpSize + loopSize); //actual code size is fixed by RelocableCodeBuffer::MarkRepFini
	*(unsigned int *)(px86.cursor + 1) = jmpLoopOffset;

	unsigned jmpWrapoutOffset = jmpSize + 3 + loopSize;
	*(unsigned int *)(px86.cursor + 6) = jmpWrapoutOffset;

	px86.cursor += sizeof(repfiniCode);
	instrCounter+= 2;

	AssembleFarloopInstruction(px86, instrCounter);
}

/* rep prefixed instructions are translated as described in RiverRepTranslator
 * instructions repinit and repfini are used to compute the actual code size.
 * The jump offsets are fixed afterwards
 */
bool RiverRepAssembler::Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType) {
	// handle repinit and repfini
	switch(ri.opCode) {
		case 0xF2:
			px86.MarkRepInit();
			AssembleRepinitInstruction(ri, px86, instrCounter);
			break;
		case 0xF3:
			AssembleRepfiniInstruction(px86, instrCounter);
			px86.MarkRepFini();
			break;
		case 0xcc:
			AssembleDebugBreak(px86, instrCounter);
			break;
		default:
			DEBUG_BREAK;
	}
}

```

`revtracer/RiverRepAssembler.h`:

```h
#ifndef _RIVER_REP_ASSEMBLER_H
#define _RIVER_REP_ASSEMBLER_H

#include "GenericX86Assembler.h"

class RiverRepAssembler : public GenericX86Assembler {
	public:
		virtual bool Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86,  nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType);
};

#endif

```

`revtracer/RiverRepTranslator.cpp`:

```cpp
#include "RiverRepTranslator.h"
#include "CodeGen.h"
#include "TranslatorUtil.h"

bool RiverRepTranslator::Init(RiverCodeGen *cg) {
	codegen = cg;
	return true;
}

void MakeDebugBreak(RiverInstruction *rOut, nodep::BYTE family) {
	rOut->opCode = 0xcc;
	rOut->family = family;
	rOut->modifiers = rOut->specifiers = 0;

	rOut->modFlags = rOut->testFlags = 0;
	rOut->instructionAddress = 0;
}

void MakeRepInitInstruction(RiverInstruction *rOut, nodep::BYTE family, nodep::DWORD modifiers, nodep::DWORD addr) {
	rOut->opCode = 0xF2;
	rOut->subOpCode = 0x0;
	rOut->family = family;
	rOut->modifiers = modifiers;
	rOut->specifiers = 0;

	rOut->modFlags = rOut->testFlags = 0;

	for (int i = 0; i < 4; ++i) {
		rOut->opTypes[i] = RIVER_OPTYPE_NONE;
	}

	rOut->instructionAddress = addr;
}

void MakeRepFiniInstruction(RiverInstruction *rOut, nodep::BYTE family, nodep::DWORD addr) {
	rOut->opCode = 0xF3;
	rOut->subOpCode = 0x0;
	rOut->family = family;
	rOut->modifiers = rOut->specifiers = 0;

	rOut->modFlags = rOut->testFlags = 0;

	for (int i = 0; i < 4; ++i) {
		rOut->opTypes[i] = RIVER_OPTYPE_NONE;
	}

	rOut->instructionAddress = addr;
}


void RiverRepTranslator::TranslateDefault(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount) {
	CopyInstruction(codegen, rOut[0], rIn);
	instrCount++;
}

/* translation layout
 *  repinit
 * code:
 *	//actual code//
 *	repfini
 *
 *	repinit translates to:
 *	 jmp code
 *	 loop init
 *	 jmp repfini
 *
 *	repfini translates to:
 *	 jmp loop
 */
void RiverRepTranslator::TranslateCommon(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount, nodep::DWORD riverModifier) {
	nodep::DWORD localInstrCount = 0;

	// add custom instruction to mark the beggining of a rep sequence
	MakeRepInitInstruction(&rOut[localInstrCount], RIVER_FAMILY_REP, rIn.modifiers, rIn.instructionAddress);
	localInstrCount++;

	// insert body (for the moment, the input instruction, other
	// translators will decorate it
	CopyInstruction(codegen, rOut[localInstrCount], rIn);
	// remove rep modifier
	rOut[localInstrCount].modifiers &= ~(RIVER_MODIFIER_REP | RIVER_MODIFIER_REPZ | RIVER_MODIFIER_REPNZ);
	localInstrCount++;

	//insert repfini
	MakeRepFiniInstruction(&rOut[localInstrCount], RIVER_FAMILY_REP, rIn.instructionAddress);
	localInstrCount++;

	instrCount += localInstrCount;
}

bool RiverRepTranslator::Translate(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount) {
	if (!(rIn.modifiers & RIVER_MODIFIER_REP ||
				rIn.modifiers & RIVER_MODIFIER_REPZ ||
				rIn.modifiers & RIVER_MODIFIER_REPNZ)) {
		TranslateDefault(rIn, rOut, instrCount);
		return true;
	}

	switch (rIn.opCode) {
		case 0x6C: case 0x6D: //INS 8/16/32
		case 0xA4: case 0xA5: //MOVS 8/16/32
		case 0x6E: case 0x6F: //OUTS 8/16/32
		case 0xAC: case 0xAD: //LODS 8/16/32
		case 0xAA: case 0xAB: //STOS 8/16/32
			RiverInstruction rInFixed;
			CopyInstruction(codegen, rInFixed, rIn);
			rInFixed.modifiers &= ~(RIVER_MODIFIER_REPZ);
			rInFixed.modifiers |= RIVER_MODIFIER_REP;
			// we need this workaround to fix the modifier
			TranslateCommon(rInFixed, rOut, instrCount, RIVER_MODIFIER_REP);
			return true;
		default:
			break;
	}

	if (rIn.modifiers & RIVER_MODIFIER_REPZ) {
		switch(rIn.opCode) {
			case 0xA6: case 0xA7: //CMPS 8/16/32
			case 0xAE: case 0xAF: //SCAS 8/16/32
				TranslateCommon(rIn, rOut, instrCount, RIVER_MODIFIER_REPZ);
				return true;
			default:
				TranslateDefault(rIn, rOut, instrCount);
				return true;
		}
	}

	if (rIn.modifiers & RIVER_MODIFIER_REPNZ) {
		switch(rIn.opCode) {
			case 0xA6: case 0xA7: //CMPS 8/16/32
			case 0xAE: case 0xAF: //SCAS 8/16/32
				TranslateCommon(rIn, rOut, instrCount, RIVER_MODIFIER_REPNZ);
				return true;
			default:
				TranslateDefault(rIn, rOut, instrCount);
				return true;
		}
	}
}


```

`revtracer/RiverRepTranslator.h`:

```h
#ifndef _RIVER_REP_TRANSLATOR_
#define _RIVER_REP_TRANSLATOR_

#include "river.h"

class RiverCodeGen;

class RiverRepTranslator {
	public:
		bool Init(RiverCodeGen *cg);
		bool Translate(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount);
	private:
		RiverCodeGen *codegen;
		void TranslateDefault(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount);
		void TranslateCommon(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount, nodep::DWORD riverModifier);
};

#endif

```

`revtracer/RiverReverseTranslator.cpp`:

```cpp
#include "CodeGen.h"
#include "TranslatorUtil.h"

bool RiverReverseTranslator::Init(RiverCodeGen *cg) {
	codegen = cg;
	return true;
}

bool RiverReverseTranslator::Translate(const RiverInstruction &rIn, RiverInstruction &rOut) {
	if (RIVER_FAMILY_RIVER != RIVER_FAMILY(rIn.family)) {
		CopyInstruction(codegen, rOut, rIn);
		rOut.family |= RIVER_FAMILY_FLAG_IGNORE;
		return true;
	}

	nodep::DWORD dwTable = (RIVER_MODIFIER_EXT & rIn.modifiers) ? 1 : 0;
	(this->*translateOpcodes[dwTable][rIn.opCode])(rOut, rIn);

	return true;
}

void RiverReverseTranslator::TranslateUnk(RiverInstruction &rOut, const RiverInstruction &rIn) {
	DEBUG_BREAK;
}

void RiverReverseTranslator::TranslatePushReg(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);
	rOut.opCode += 8;
}

void RiverReverseTranslator::TranslatePopReg(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);
	rOut.opCode -= 8;
}

void RiverReverseTranslator::TranslatePushf(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);
	rOut.opCode += 1;
}

void RiverReverseTranslator::TranslatePopf(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);
	rOut.opCode -= 1;
}

void RiverReverseTranslator::TranslatePushModRM(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);

	if (rOut.subOpCode != 6) {
		rOut.family |= RIVER_FAMILY_FLAG_IGNORE;
	} else {
		rOut.opCode = 0x8F; // pop
		rOut.subOpCode = 0x00;

		rOut.operands[0].asAddress->modRM &= 0xC7; // clear the subOpCode from the modrm byte
	}
}

void RiverReverseTranslator::TranslatePopModRM(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);

	if (rOut.subOpCode != 0) {
		rOut.family |= RIVER_FAMILY_FLAG_IGNORE;
	}
	else {
		rOut.opCode = 0xFF; // push
		rOut.subOpCode = 0x06;
		rOut.opCode -= 1;

		rOut.operands[0].asAddress->modRM &= 0xC7; // clear the subOpCode from the modrm byte
		rOut.operands[0].asAddress->modRM |= 0x06 << 3; // set the subOpCode from the modrm byte
	}
}

void RiverReverseTranslator::Translate0x83(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);

	switch (rOut.subOpCode) {
		case 0:
		case 5:
			rOut.subOpCode ^= 5;
			rOut.operands[0].asRegister.versioned -= 0x100; // previous register version
			break;
		default:
			DEBUG_BREAK;
	}
}




RiverReverseTranslator::TranslateOpcodeFunc RiverReverseTranslator::translateOpcodes[2][0x100] = {
	{
		/*0x00*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x04*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x08*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x0C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x10*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x14*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x18*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x1C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x20*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x24*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x28*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x2C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x30*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x34*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x38*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x3C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x40*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x44*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x48*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x4C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x50*/&RiverReverseTranslator::TranslatePushReg, &RiverReverseTranslator::TranslatePushReg, &RiverReverseTranslator::TranslatePushReg, &RiverReverseTranslator::TranslatePushReg,
		/*0x54*/&RiverReverseTranslator::TranslatePushReg, &RiverReverseTranslator::TranslatePushReg, &RiverReverseTranslator::TranslatePushReg, &RiverReverseTranslator::TranslatePushReg,
		/*0x58*/&RiverReverseTranslator::TranslatePopReg, &RiverReverseTranslator::TranslatePopReg, &RiverReverseTranslator::TranslatePopReg, &RiverReverseTranslator::TranslatePopReg,
		/*0x5C*/&RiverReverseTranslator::TranslatePopReg, &RiverReverseTranslator::TranslatePopReg, &RiverReverseTranslator::TranslatePopReg, &RiverReverseTranslator::TranslatePopReg,

		/*0x60*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x64*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x68*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x6C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x70*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x74*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x78*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x7C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x80*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::Translate0x83,
		/*0x84*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x88*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x8C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslatePopModRM,

		/*0x90*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x94*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x98*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x9C*/&RiverReverseTranslator::TranslatePushf, &RiverReverseTranslator::TranslatePopf, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xA0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xA4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xA8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xAC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xB0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xB4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xB8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xBC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xC0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xC4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xC8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xCC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xD0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xD4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xD8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xDC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xE0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xE4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xE8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xEC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xF0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xF4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xF8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xFC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslatePushModRM
	}, {
		/*0x00*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x04*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x08*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x0C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x10*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x14*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x18*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x1C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x20*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x24*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x28*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x2C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x30*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x34*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x38*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x3C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x40*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x44*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x48*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x4C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x50*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x54*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x58*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x5C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x60*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x64*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x68*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x6C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x70*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x74*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x78*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x7C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x80*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x84*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x88*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x8C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0x90*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x94*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x98*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0x9C*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xA0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xA4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xA8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xAC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xB0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xB4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xB8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xBC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xC0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xC4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xC8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xCC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xD0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xD4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xD8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xDC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xE0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xE4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xE8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xEC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,

		/*0xF0*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xF4*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xF8*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk,
		/*0xFC*/&RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk, &RiverReverseTranslator::TranslateUnk
	}
};


```

`revtracer/RiverReverseTranslator.h`:

```h
#ifndef _RIVER_REVERSE_TRANSLATOR_H
#define _RIVER_REVERSE_TRANSLATOR_H

#include "revtracer.h"
#include "river.h"

using namespace rev;

class RiverCodeGen;

class RiverReverseTranslator {
private :
	RiverCodeGen *codegen;
	typedef void(RiverReverseTranslator::*TranslateOpcodeFunc)(RiverInstruction &rOut, const RiverInstruction &rIn);

	static TranslateOpcodeFunc translateOpcodes[2][0x100];
public :
	bool Init(RiverCodeGen *cg);
	bool Translate(const RiverInstruction &rIn, RiverInstruction &rOut);
private :
	void TranslateUnk(RiverInstruction &rOut, const RiverInstruction &rIn);
	void TranslatePushReg(RiverInstruction &rOut, const RiverInstruction &rIn);
	void TranslatePopReg(RiverInstruction &rOut, const RiverInstruction &rIn);
	void TranslatePushf(RiverInstruction &rOut, const RiverInstruction &rIn);
	void TranslatePopf(RiverInstruction &rOut, const RiverInstruction &rIn);
	void TranslatePushModRM(RiverInstruction &rOut, const RiverInstruction &rIn);
	void TranslatePopModRM(RiverInstruction &rOut, const RiverInstruction &rIn);
	void Translate0x83(RiverInstruction &rOut, const RiverInstruction &rIn);
};

#endif

```

`revtracer/RiverSaveTranslator.cpp`:

```cpp
#include "RiverSaveTranslator.h"
#include "CodeGen.h"
#include "TranslatorUtil.h"

bool RiverSaveTranslator::Init(RiverCodeGen *cg) {
	codegen = cg;
	return true;
}

bool RiverSaveTranslator::Translate(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount) {
	nodep::DWORD dwTable = (RIVER_MODIFIER_EXT & rIn.modifiers) ? 1 : 0;

	if (RIVER_FAMILY(rIn.family) == RIVER_FAMILY_NATIVE) {
		(this->*translateOpcodes[dwTable][rIn.opCode])(rOut, rIn, instrCount);
	} else {
		CopyInstruction(codegen, rOut[0], rIn);
		instrCount++;
	}

	return true;
}

/* =========================================== */
/* Translation helpers                         */
/* =========================================== */

void RiverSaveTranslator::MakeSaveFlags(RiverInstruction *rOut) {
	rOut->opCode = 0x9C; // PUSHF
	rOut->modifiers = 0;
	rOut->family = RIVER_FAMILY_RIVER;
	rOut->specifiers = 0; // maybe
	rOut->unusedRegisters = RIVER_UNUSED_ALL;

	rOut->opTypes[0] = rOut->opTypes[1] = rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;
}

void RiverSaveTranslator::MakeSaveReg(RiverInstruction *rOut, const RiverRegister &reg, unsigned short familyFlag) {
	//unsigned char rg = (reg.name & 0x07) | RIVER_OPSIZE_32;

	rOut->opCode = 0x50; // | (reg.name & 0x07); //PUSH
	rOut->modifiers = 0;
	rOut->family = RIVER_FAMILY_RIVER | familyFlag;
	rOut->specifiers = 0;

	rOut->opTypes[0] = RIVER_OPTYPE_REG | RIVER_OPSIZE_32;
	rOut->operands[0].asRegister.versioned = codegen->GetPrevReg(reg.name);

	if (RIVER_REG_xSP == GetFundamentalRegister(reg.name)) {
		rOut->family |= RIVER_FAMILY_FLAG_ORIG_xSP;
	}

	rOut->opTypes[1] = rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rOut->TrackUnusedRegisters();
}

void RiverSaveTranslator::MakeSaveMem(RiverInstruction *rOut, const RiverAddress &mem, unsigned short familyFlag, const RiverInstruction &rIn) {
	if (mem.type == 0) {
		MakeSaveReg(rOut, mem.base, familyFlag);
	} else {
		rOut->opCode = 0xFF; // PUSH (ext + 6)
		rOut->modifiers = 0;
		rOut->family = RIVER_FAMILY_RIVER | familyFlag | ((rIn.specifiers & RIVER_SPEC_MODIFIES_xSP) ? RIVER_FAMILY_FLAG_ORIG_xSP : 0);
		rOut->subOpCode = 0x06;

		rOut->opTypes[0] = RIVER_OPTYPE_MEM | RIVER_OPSIZE_32;
		rOut->operands[0].asAddress = codegen->CloneAddress(mem, 0); // FIXME: needs te kind of address to be cloned
		rOut->operands[0].asAddress->modRM &= 0xC7;
		rOut->operands[0].asAddress->modRM |= rOut->subOpCode << 3;
		rOut->opTypes[1] = rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

		rOut->PromoteModifiers();
		rOut->TrackUnusedRegisters();
	}
}

void RiverSaveTranslator::MakeSaveMemOffset(RiverInstruction *rOut, const RiverAddress &mem, int offset, unsigned short auxFlags, const RiverInstruction &rIn) {
	if (mem.type == 0) {
		DEBUG_BREAK;
	}
	else {
		RiverAddress32 tMem;
		rev_memcpy(&tMem, &mem, sizeof(tMem));

		if (tMem.type & RIVER_ADDR_DISP8) {
			tMem.disp.d32 = tMem.disp.d8;
			tMem.type &= ~RIVER_ADDR_DISP8;
			tMem.type |= RIVER_ADDR_DISP | RIVER_ADDR_DIRTY;
		}

		if (0 == (tMem.type & RIVER_ADDR_DISP)) {
			tMem.disp.d32 = 0;
			tMem.type |= RIVER_ADDR_DISP | RIVER_ADDR_DIRTY;
		}

		tMem.disp.d32 += offset;
		MakeSaveMem(rOut, tMem, auxFlags, rIn);
	}
}

void RiverSaveTranslator::MakeSaveOp(RiverInstruction *rOut, unsigned char opType, const RiverOperand &op, const RiverInstruction &rIn) {
	switch (RIVER_OPTYPE(opType)) {
	case RIVER_OPTYPE_NONE:
	case RIVER_OPTYPE_IMM:
		DEBUG_BREAK;
		break;
	case RIVER_OPTYPE_REG:
		MakeSaveReg(rOut, op.asRegister, 0);
		break;
	case RIVER_OPTYPE_MEM:
		MakeSaveMem(rOut, *op.asAddress, 0, rIn);
		break;
	}
}

void RiverSaveTranslator::MakeSaveAtxSP(RiverInstruction *rOut, const RiverInstruction &rIn) {
	RiverAddress32 rTmp;

	rTmp.scaleAndSegment = 0;
	rTmp.type = RIVER_ADDR_BASE | RIVER_ADDR_DISP8;
	rTmp.base.versioned = codegen->GetPrevReg(RIVER_REG_xSP); // Here lies the original xSP
	rTmp.index.versioned = RIVER_REG_NONE;
	rTmp.disp.d8 = 0xFC;

	rTmp.modRM = 0x70; // actually save xAX (because xSP is used for other stuff)

	MakeSaveMem(rOut, rTmp, RIVER_FAMILY_FLAG_ORIG_xSP, rIn);
}

void RiverSaveTranslator::SaveOperands(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	if (RIVER_SPEC_MODIFIES_FLG & rIn.specifiers) {
		MakeSaveFlags(rOut);
		instrCount++;
		rOut++;
	}

	for (int i = 3; i >= 0; --i) {
		if (RIVER_SPEC_MODIFIES_OP(i) & rIn.specifiers) {
			MakeSaveOp(rOut, rIn.opTypes[i], rIn.operands[i], rIn);
			instrCount++;
			rOut++;
		}
	}

	CopyInstruction(codegen, *rOut, rIn);
	instrCount++;
}

/* Opcode translators */

void RiverSaveTranslator::TranslateUnk(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	DEBUG_BREAK;
}

void RiverSaveTranslator::TranslateDefault(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	/*if (RIVER_SPEC_MODIFIES_xSP & rIn.specifiers) {
		DEBUG_BREAK;
	}*/

	SaveOperands(rOut, rIn, instrCount);
}

void RiverSaveTranslator::TranslateSaveCPUID(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	RiverRegister tmpReg;

	tmpReg.name = RIVER_REG_xAX;
	MakeSaveReg(rOut, tmpReg, 0);
	instrCount++;
	rOut++;

	tmpReg.name = RIVER_REG_xCX;
	MakeSaveReg(rOut, tmpReg, 0);
	instrCount++;
	rOut++;

	tmpReg.name = RIVER_REG_xDX;
	MakeSaveReg(rOut, tmpReg, 0);
	instrCount++;
	rOut++;

	tmpReg.name = RIVER_REG_xBX;
	MakeSaveReg(rOut, tmpReg, 0);
	instrCount++;
	rOut++;

	CopyInstruction(codegen, *rOut, rIn);
	instrCount++;
	rOut++;
}

void RiverSaveTranslator::TranslateSaveCMPXCHG8B(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
	RiverRegister tmpReg; 

	MakeSaveFlags(rOut);
	instrCount++;
	rOut++;

	tmpReg.name = RIVER_REG_xAX;
	MakeSaveReg(rOut, tmpReg, 0);
	instrCount++;
	rOut++;

	tmpReg.name = RIVER_REG_xDX;
	MakeSaveReg(rOut, tmpReg, 0);
	instrCount++;
	rOut++;

	MakeSaveMem(rOut, *(rIn.operands[0].asAddress), 0, rIn);
	instrCount++;
	rOut++;

	MakeSaveMemOffset(rOut, *(rIn.operands[0].asAddress), 0x04, 0, rIn);
	instrCount++;
	rOut++;

	CopyInstruction(codegen, *rOut, rIn);
	instrCount++;
	rOut++;
}

/* =========================================== */
/* Translation table                           */
/* =========================================== */

RiverSaveTranslator::TranslateOpcodeFunc RiverSaveTranslator::translateOpcodes[2][0x100] = {
	{
		/*0x00*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x04*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk,
		/*0x08*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x0C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x10*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x14*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk,
		/*0x18*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x1C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x20*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x24*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x28*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x2C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x30*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x34*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x38*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x3C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x40*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x44*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x48*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x4C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,

		/*0x50*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x54*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x58*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x5C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,

		/*0x60*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x64*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x68*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x6C*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x70*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x74*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x78*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x7C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,

		/*0x80*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault,
		/*0x84*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x88*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x8C*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x90*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x94*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x98*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x9C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,

		/*0xA0*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0xA4*/&RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateDefault>, &RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateDefault>, &RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateDefault>, &RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateDefault>,
		/*0xA8*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateDefault>, &RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateDefault>,
		/*0xAC*/&RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateUnk>, &RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateUnk>, &RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateDefault>, &RiverSaveTranslator::TranslateRep<&RiverSaveTranslator::TranslateDefault>,

		/*0xB0*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0xB4*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0xB8*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0xBC*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,

		/*0xC0*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0xC4*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0xC8*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xCC*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0xD0*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0xD4*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xD8*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xDC*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0xE0*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault,
		/*0xE4*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xE8*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::SaveOperands, &RiverSaveTranslator::SaveOperands, &RiverSaveTranslator::SaveOperands,
		/*0xEC*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0xF0*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xF4*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateSubOp<RiverSaveTranslator::translate0xF7>,
		/*0xF8*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xFC*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateSubOp<RiverSaveTranslator::translate0xFF>
	}, {
		/*0x00*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x04*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x08*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x0C*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x10*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x14*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x18*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x1C*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x20*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x24*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x28*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x2C*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x30*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x34*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x38*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x3C*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x40*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x44*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x48*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x4C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,

		/*0x50*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x54*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x58*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x5C*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x60*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x64*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x68*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x6C*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x70*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x74*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x78*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0x7C*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0x80*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x84*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x88*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x8C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,

		/*0x90*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x94*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x98*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0x9C*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,

		/*0xA0*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateSaveCPUID, &RiverSaveTranslator::TranslateUnk,
		/*0xA4*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xA8*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault,
		/*0xAC*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault,

		/*0xB0*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault,
		/*0xB4*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,
		/*0xB8*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk,
		/*0xBC*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault,

		/*0xC0*/&RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateDefault, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xC4*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateSubOp<RiverSaveTranslator::translate0x0FC7>,
		/*0xC8*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xCC*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0xD0*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xD4*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xD8*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xDC*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0xE0*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xE4*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xE8*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xEC*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,

		/*0xF0*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xF4*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xF8*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk,
		/*0xFC*/&RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk, &RiverSaveTranslator::TranslateUnk
	}
};

RiverSaveTranslator::TranslateOpcodeFunc RiverSaveTranslator::translate0xF7[8] = {
	&RiverSaveTranslator::TranslateDefault, 
	&RiverSaveTranslator::TranslateDefault, 
	&RiverSaveTranslator::TranslateDefault, 
	&RiverSaveTranslator::TranslateDefault,
	&RiverSaveTranslator::TranslateDefault,
	&RiverSaveTranslator::TranslateDefault,
	&RiverSaveTranslator::TranslateDefault,
	&RiverSaveTranslator::TranslateDefault
};


RiverSaveTranslator::TranslateOpcodeFunc RiverSaveTranslator::translate0xFF[8] = {
	&RiverSaveTranslator::TranslateDefault, 
	&RiverSaveTranslator::TranslateDefault, 
	&RiverSaveTranslator::TranslateDefault,
	&RiverSaveTranslator::TranslateDefault,
	&RiverSaveTranslator::TranslateDefault, 
	&RiverSaveTranslator::TranslateDefault, 
	&RiverSaveTranslator::TranslateDefault,
	&RiverSaveTranslator::TranslateUnk
};

RiverSaveTranslator::TranslateOpcodeFunc RiverSaveTranslator::translate0x0FC7[8] = {
	&RiverSaveTranslator::TranslateUnk, 
	&RiverSaveTranslator::TranslateSaveCMPXCHG8B, 
	&RiverSaveTranslator::TranslateUnk, 
	&RiverSaveTranslator::TranslateUnk,
	&RiverSaveTranslator::TranslateUnk, 
	&RiverSaveTranslator::TranslateUnk, 
	&RiverSaveTranslator::TranslateUnk, 
	&RiverSaveTranslator::TranslateUnk
};

```

`revtracer/RiverSaveTranslator.h`:

```h
#ifndef _RIVER_SAVE_TRANSLATOR_H
#define _RIVER_SAVE_TRANSLATOR_H

#include "revtracer.h"
#include "river.h"

class RiverCodeGen;

class RiverSaveTranslator {
private :
	RiverCodeGen *codegen;

	typedef void(RiverSaveTranslator::*TranslateOpcodeFunc)(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	
	static TranslateOpcodeFunc translateOpcodes[2][0x100];
	static TranslateOpcodeFunc translate0xF7[8], translate0xFF[8], translate0x0FC7[8];

public :
	bool Init(RiverCodeGen *cg);
	bool Translate(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount);

private :
	/* Translation helpers */
	void MakeSaveFlags(RiverInstruction *rOut);
	void MakeSaveReg(RiverInstruction *rOut, const RiverRegister &reg, unsigned short familyFlag);
	void MakeSaveMem(RiverInstruction *rOut, const RiverAddress &mem, unsigned short auxFlags, const RiverInstruction &rIn);
	void MakeSaveMemOffset(RiverInstruction *rOut, const RiverAddress &mem, int offset, unsigned short auxFlags, const RiverInstruction &rIn);
	void MakeAddNoFlagsRegImm8(RiverInstruction *rOut, const RiverRegister &reg, unsigned char offset, unsigned short auxFlags);
	void MakeSubNoFlagsRegImm8(RiverInstruction *rOut, const RiverRegister &reg, unsigned char offset, unsigned short auxFlags);
	void MakeSaveOp(RiverInstruction *rOut, unsigned char opType, const RiverOperand &op, const RiverInstruction &rIn);
	void MakeSaveAtxSP(RiverInstruction *rOut, const RiverInstruction &rIn);

	void SaveOperands(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);

	/* Opcode translators */
	void TranslateUnk(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslateDefault(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslateSaveCPUID(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);
	void TranslateSaveCMPXCHG8B(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount);

	template <TranslateOpcodeFunc subOp> void TranslateRep(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
		if ((rIn.modifiers & RIVER_MODIFIER_REP) || (rIn.modifiers & RIVER_MODIFIER_REPZ) || (rIn.modifiers & RIVER_MODIFIER_REPNZ)) {
			RiverRegister tmpReg;

			tmpReg.name = RIVER_REG_xCX;
			MakeSaveReg(rOut, tmpReg, 0);
			instrCount++;
			rOut++;
		}

		(this->*subOp)(rOut, rIn, instrCount);
	}

	template <TranslateOpcodeFunc *fSubOps> void TranslateSubOp(RiverInstruction *rOut, const RiverInstruction &rIn, nodep::DWORD &instrCount) {
		(this->*fSubOps[rIn.subOpCode])(rOut, rIn, instrCount);
	}
};

#endif

```

`revtracer/RiverTrackingX86Assembler.cpp`:

```cpp
#include "RiverTrackingX86Assembler.h"

using namespace rev;

extern nodep::DWORD dwAddressTrackHandler;
extern nodep::DWORD dwAddressMarkHandler;

void RiverTrackingX86Assembler::AssemblePushFlg(nodep::DWORD testFlags, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE markFlagInstr[] = { 0xFF, 0x35, 0x00, 0x00, 0x00, 0x00 };

	for (nodep::BYTE c = 0, m = 1; m < RIVER_SPEC_FLAG_EXT; ++c, m <<= 1) {
		if (m & testFlags) {
			rev_memcpy(px86.cursor, markFlagInstr, sizeof(markFlagInstr));
			*(nodep::DWORD *)(&px86.cursor[0x02]) = (nodep::DWORD)&runtime->taintedFlags[c];
			px86.cursor += sizeof(markFlagInstr);
			instrCounter++;
		}
	}
}

void RiverTrackingX86Assembler::AssemblePushReg(const RiverRegister &reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE markRegInstr[] = { 0xFF, 0x35, 0x00, 0x00, 0x00, 0x00 };

	rev_memcpy(px86.cursor, markRegInstr, sizeof(markRegInstr));
	*(nodep::DWORD *)(&px86.cursor[0x02]) = (nodep::DWORD)&runtime->taintedRegisters[GetFundamentalRegister(reg.name)];
	px86.cursor += sizeof(markRegInstr);
	instrCounter++;
}

void RiverTrackingX86Assembler::AssemblePushMem(const RiverAddress *addr, nodep::BYTE offset, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE trackMemInstr[] = {
		0xFF, 0x76, 0x00,								// 0x00 - push [esi + 0x00] - effective address
		0x50											// 0x03
	};

	const nodep::BYTE trackSegInstr[] = {
		0xFF, 0x76, 0x00								// 0x00 - push [esi + 0x00] - segment index
	};

	const nodep::BYTE trackImmInstr[] = {
		0x6A, 0x00										// 0x00 - push 0 - no segment
	};

	if (addr->HasSegment()) {
		rev_memcpy(px86.cursor, trackSegInstr, sizeof(trackSegInstr));
		px86.cursor[0x02] = ~((offset - 1) << 2) + 1;
		px86.cursor += sizeof(trackSegInstr);
	}
	else {
		rev_memcpy(px86.cursor, trackImmInstr, sizeof(trackImmInstr));
		px86.cursor[0x02] = ~((offset - 1) << 2) + 1;
		px86.cursor += sizeof(trackImmInstr);
	}

	rev_memcpy(px86.cursor, trackMemInstr, sizeof(trackMemInstr));
	px86.cursor[0x02] = ~(offset << 2) + 1;
	px86.cursor += sizeof(trackMemInstr);
	instrCounter += 3;
}

/*void RiverTrackingX86Assembler::AssembleRiverPostMarkMemory(RelocableCodeBuffer &px86, DWORD &pFlags, DWORD &instrCounter) {
	const BYTE trackEax[] = { 0x50 };

	memcpy(px86.cursor, trackEax, sizeof(trackEax));
	px86.cursor += sizeof(trackEax);

	instrCounter += 1;
}*/

void RiverTrackingX86Assembler::AssemblePopFlg(nodep::DWORD testFlags, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE unmarkFlagInstr[] = { 0x8F, 0x05, 0x00, 0x00, 0x00, 0x00 };

	for (nodep::BYTE c = 7, m = RIVER_SPEC_FLAG_EXT; m > 0; --c, m >>= 1) {
		if (m & testFlags) {
			rev_memcpy(px86.cursor, unmarkFlagInstr, sizeof(unmarkFlagInstr));
			*(nodep::DWORD *)(&px86.cursor[0x02]) = (nodep::DWORD)&runtime->taintedFlags[c];
			px86.cursor += sizeof(unmarkFlagInstr);
			instrCounter++;
		}
	}
}

void RiverTrackingX86Assembler::AssemblePopReg(const RiverRegister &reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE unmarkRegInstr[] = { 0x8F, 0x05, 0x00, 0x00, 0x00, 0x00 };

	rev_memcpy(px86.cursor, unmarkRegInstr, sizeof(unmarkRegInstr));
	*(nodep::DWORD *)(&px86.cursor[0x02]) = (nodep::DWORD)&runtime->taintedRegisters[GetFundamentalRegister(reg.name)];
	px86.cursor += sizeof(unmarkRegInstr);
	instrCounter++;
}

void RiverTrackingX86Assembler::AssemblePopMem(const RiverAddress *addr, nodep::BYTE offset, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter)  {
	const nodep::BYTE unmarkRegMem[] = {
		0x58,											// 0x06 - pop eax
		0x5F,											// 0x07 - pop edi
		0x5E											// 0x08 - pop esi
	};

	rev_memcpy(px86.cursor, unmarkRegMem, sizeof(unmarkRegMem));
	px86.cursor += sizeof(unmarkRegMem);
	instrCounter += 3;
}

bool RiverTrackingX86Assembler::Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType) {
	switch (ri.opCode) {
		case 0x9C : // push flags
			AssemblePushFlg(ri.operands[0].asImm8, px86, pFlags, instrCounter);
			break;

		case 0x9D : // pop flags
			AssemblePopFlg(ri.operands[0].asImm8, px86, pFlags, instrCounter);
			break;

		case 0x50 : // push reg
			AssemblePushReg(ri.operands[0].asRegister, px86, pFlags, instrCounter);
			break;

		case 0x58 : // pop reg
			AssemblePopReg(ri.operands[0].asRegister, px86, pFlags, instrCounter);
			break;

		case 0xFF : // push mem
			if (6 == ri.subOpCode) {
				AssemblePushMem(ri.operands[0].asAddress, ri.operands[1].asImm8, px86, pFlags, instrCounter);
			} else {
				DEBUG_BREAK;
			}
			break;

		case 0x8F :
			AssemblePopMem(ri.operands[0].asAddress, ri.operands[1].asImm8, px86, pFlags, instrCounter);
			break;

		/*case 0xE8 : // call
			AssembleUnmark(px86, pFlags, instrCounter);
			break;*/

		default :
			DEBUG_BREAK;

	}

	return true;
}

```

`revtracer/RiverTrackingX86Assembler.h`:

```h
#ifndef _RIVER_TRACKING_X86_ASSEMBLER_H_
#define _RIVER_TRACKING_X86_ASSEMBLER_H_

#include "GenericX86Assembler.h"

class RiverTrackingX86Assembler : public GenericX86Assembler {
private:
	void AssemblePushFlg(nodep::DWORD testFlags, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssemblePushReg(const RiverRegister &reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssemblePushMem(const RiverAddress *addr, nodep::BYTE offset, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssemblePopFlg(nodep::DWORD testFlags, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssemblePopReg(const RiverRegister &reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssemblePopMem(const RiverAddress *addr, nodep::BYTE offset, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleUnmark(RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
public:
	virtual bool Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType);
};

#endif
```

`revtracer/RiverX86Assembler.cpp`:

```cpp
#include <intrin.h>

#include "RiverX86Assembler.h"
#include "X86AssemblerFuncs.h"

#include "mm.h"

using namespace rev;

extern const nodep::BYTE specAssemblerTbl[2][0x100];

#define X86_OPZISE_PREFIX			0x66

#define X86_LOCK_PREFIX				0xF0
#define X86_REPNZ_PREFIX			0xF2
#define X86_REPZ_PREFIX				0xF3
#define X86_REP_PREFIX				0xF3

#define X86_ESSEG_PREFIX			0x26
#define X86_CSSEG_PREFIX			0x2E
#define X86_SSSEG_PREFIX			0x36
#define X86_DSSEG_PREFIX			0x3E
#define X86_FSSEG_PREFIX			0x64
#define X86_GSSEG_PREFIX			0x65

#define FLAG_GENERATE_RIVER_xSP		0x0F
/*#define FLAG_GENERATE_RIVER_xSP_xAX	0x01
#define FLAG_GENERATE_RIVER_xSP_xCX	0x02
#define FLAG_GENERATE_RIVER_xSP_xDX	0x04
#define FLAG_GENERATE_RIVER_xSP_xBX	0x08*/

#define FLAG_SKIP_METAOP			0x10
#define FLAG_GENERATE_RIVER			0x20


extern nodep::DWORD dwSysHandler; // = 0; // &SysHandler
extern nodep::DWORD dwSysEndHandler; // = 0; // &SysEndHandler
extern nodep::DWORD dwBranchHandler; // = 0; // &BranchHandler

void RiverX86Assembler::SwitchToRiver(nodep::BYTE *&px86, nodep::DWORD &instrCounter) {
	static const unsigned char code[] = { 0x87, 0x25, 0x00, 0x00, 0x00, 0x00 };			// 0x00 - xchg esp, large ds:<dwVirtualStack>}

	rev_memcpy(px86, code, sizeof(code));
	*(unsigned int *)(&(px86[0x02])) = (unsigned int)&runtime->execBuff;

	px86 += sizeof(code);
	instrCounter++;
}

void RiverX86Assembler::SwitchToRiverEsp(nodep::BYTE *&px86, nodep::DWORD &instrCounter, nodep::BYTE repReg) {
	static const unsigned char code[] = { 0x87, 0x05, 0x00, 0x00, 0x00, 0x00 };			// 0x00 - xchg eax, large ds:<dwVirtualStack>}

	rev_memcpy(px86, code, sizeof(code));
	px86[0x01] |= (repReg & 0x03); // choose the acording replacement register
	*(unsigned int *)(&(px86[0x02])) = (unsigned int)&runtime->execBuff;

	px86 += sizeof(code);
	instrCounter++;
}

bool RiverX86Assembler::Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType) {
	nodep::DWORD dwTable = 0;

	if (ri.modifiers & RIVER_MODIFIER_EXT) {
		*px86.cursor = 0x0F;
		px86.cursor++;
		dwTable = 1;
	}

	/*
	(this->*assembleOpcodes[dwTable][ri.opCode])(ri, px86, pFlags, instrCounter);
	(this->*assembleOperands[dwTable][ri.opCode])(ri, px86);
	*/

	if (1 == dwTable) {
		DEBUG_BREAK;
	} else {
		switch (ri.opCode) {
			case 0x50:
			case 0x58:
				AssemblePlusRegInstr(ri, px86, pFlags, instrCounter);
				AssembleNoOp(ri, px86);
				break;

			case 0x84:
				AssembleRiverAddSubInstr(ri, px86, pFlags, instrCounter);
				AssembleRiverAddSubOp(ri, px86);
				break;

			case 0x8F:
				::AssembleDefaultInstr(ri, px86, pFlags, instrCounter);
				::AssembleModRMOp(0, ri, px86, 0);
				break;

			case 0x9C:
			case 0x9D:
				::AssembleDefaultInstr(ri, px86, pFlags, instrCounter);
				::AssembleNoOp(ri, px86);
				break;

			case 0xFF:
				if (6 == ri.subOpCode) {
					AssembleDefaultInstr(ri, px86, pFlags, instrCounter);
					AssembleModRMOp(0, ri, px86, 6);
				} else {
					DEBUG_BREAK;
				}
				break;
			default :
				DEBUG_BREAK;
		}
	}
	return true;
}


void RiverX86Assembler::AssembleRiverAddSubInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	*px86.cursor = 0x8d; // add and sub are converted to lea
	px86.cursor++;
	instrCounter++;
}

void RiverX86Assembler::AssembleRiverAddSubOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	RiverInstruction rTmp;
	RiverAddress32 addr;

	addr.type = RIVER_ADDR_DIRTY | RIVER_ADDR_BASE | RIVER_ADDR_DISP8;
	addr.base.versioned = ri.operands[0].asRegister.versioned;

	addr.disp.d8 = ri.operands[1].asImm8;

	if (ri.subOpCode == 5) {
		addr.disp.d8 = ~addr.disp.d8 + 1;
	}

	addr.modRM |= ri.operands[0].asRegister.name << 3;

	rTmp.opTypes[0] = ri.opTypes[0];
	rTmp.operands[0].asRegister.versioned = ri.operands[0].asRegister.versioned;

	rTmp.opTypes[1] = RIVER_OPTYPE_MEM; // no size specified;
	rTmp.operands[1].asAddress = &addr;


	AssembleRegModRMOp(rTmp, px86);
}

void RiverX86Assembler::AssembleRegModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(1, ri, px86, ri.operands[0].asRegister.name);
}

void RiverX86Assembler::AssembleModRMOp(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE extra) {
	ri.operands[opIdx].asAddress->EncodeTox86(px86.cursor, extra, ri.family, ri.modifiers);
}

```

`revtracer/RiverX86Assembler.h`:

```h
#ifndef _RIVER_X86_ASSEMBLER_H
#define _RIVER_X86_ASSEMBLER_H

#include "revtracer.h"
#include "river.h"
#include "Runtime.h"

#include "GenericX86Assembler.h"

class RiverX86Assembler : public GenericX86Assembler {
private :
	bool needsRAFix;
	nodep::BYTE *rvAddress;

	void SwitchToRiver(nodep::BYTE *&px86, nodep::DWORD &instrCounter);
	void SwitchToRiverEsp(nodep::BYTE *&px86, nodep::DWORD &instrCounter, nodep::BYTE repReg);
	void EndRiverConversion(nodep::BYTE *&px86, nodep::DWORD &pFlags, nodep::BYTE &repReg, nodep::DWORD &instrCounter);

	bool GenerateTransitions(const RiverInstruction &ri, nodep::BYTE *&px86, nodep::DWORD &pFlags, nodep::BYTE &repReg,  nodep::DWORD &instrCounter);

public :
	//bool Init(RiverRuntime *rt);
	//bool Assemble(RiverInstruction *pRiver,  nodep::WORD dwInstrCount, BYTE *px86,  nodep::WORD flg,  nodep::WORD &instrCounter,  nodep::WORD &byteCounter);
	virtual bool Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86,  nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg,  nodep::DWORD &instrCounter, nodep::BYTE outputType);

private :
	void AssembleRiverAddSubInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleRiverAddSubOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);

	void AssembleRegModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);

	void AssembleModRMOp(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE extra);
};


#endif

```

`revtracer/RiverX86Disassembler.cpp`:

```cpp
#include "RiverX86Disassembler.h"
#include "CodeGen.h"

extern const nodep::WORD specTbl[2][0x100];
extern const nodep::WORD _specTblExt[][8];
extern const nodep::WORD testFlagExt[][8];

nodep::WORD GetSpecifiers(RiverInstruction &ri) {
	//const WORD *specTbl = specTbl00;
	nodep::DWORD dwTable = (RIVER_MODIFIER_EXT & ri.modifiers) ? 1 : 0;
	nodep::WORD tmp = specTbl[dwTable][ri.opCode];

	if (tmp == 0xFF) {
		DEBUG_BREAK;
	}

	if (tmp & RIVER_SPEC_MODIFIES_EXT) {
		tmp = _specTblExt[tmp & 0x7F][ri.subOpCode];
	}

	if (tmp == 0xFF) {
		DEBUG_BREAK;
	}

	return tmp;
}

void RiverX86Disassembler::TrackModifiedRegisters(RiverInstruction &ri) {
	//bool modifiysp = true;
	if (RIVER_SPEC_MODIFIES_xSP & ri.specifiers) {
		codegen->NextReg(RIVER_REG_xSP);
		//modifiysp = false;
	}

	if ((RIVER_SPEC_MODIFIES_OP2 & ri.specifiers) && (RIVER_OPTYPE_REG == RIVER_OPTYPE(ri.opTypes[1]))) {
		ri.operands[1].asRegister.versioned = codegen->NextReg(ri.operands[1].asRegister.name);
	}

	if ((RIVER_SPEC_MODIFIES_OP1 & ri.specifiers) && (RIVER_OPTYPE_REG == RIVER_OPTYPE(ri.opTypes[0]))) {
		ri.operands[0].asRegister.versioned = codegen->NextReg(ri.operands[0].asRegister.name);
	}
}

void RiverX86Disassembler::TrackFlagUsage(RiverInstruction &ri) {
	nodep::DWORD dwTable = (RIVER_MODIFIER_EXT & ri.modifiers) ? 1 : 0;
	nodep::BYTE tmp = modFlags[dwTable][ri.opCode];

	if (tmp == 0xFF) {
		DEBUG_BREAK;
	}

	if (tmp & RIVER_SPEC_FLAG_EXT) {
		tmp = 0; //modFlagExt[tmp & 0x7F][ri.subOpCode];
	}

	if (tmp == 0xFF) {
		DEBUG_BREAK;
	}

	ri.modFlags = tmp;

	tmp = testFlags[dwTable][ri.opCode];

	if (tmp == 0xFF) {
		DEBUG_BREAK;
	}

	if (tmp & RIVER_SPEC_FLAG_EXT) {
		tmp = testFlagExt[tmp & 0x7F][ri.subOpCode];
	}

	if (tmp == 0xFF) {
		DEBUG_BREAK;
	}

	ri.testFlags = tmp;
}

bool RiverX86Disassembler::Init(RiverCodeGen *cg) {
	codegen = cg;
	return true;
}

bool RiverX86Disassembler::Translate(nodep::BYTE *&px86, RiverInstruction &rOut, nodep::DWORD &flags) {
	nodep::DWORD dwTable = 0;

	rOut.modifiers = 0;
	rOut.specifiers = 0;
	rOut.family = 0;
	rOut.subOpCode = 0;
	rOut.opTypes[0] = rOut.opTypes[1] = rOut.opTypes[2] = rOut.opTypes[3] = RIVER_OPTYPE_NONE;
	rOut.instructionAddress = (nodep::DWORD)px86;
	rOut.modFlags = 0;
	rOut.testFlags = 0;

	flags = 0;
	do {
		nodep::BYTE* currentInstr = px86;
		dwTable = (rOut.modifiers & RIVER_MODIFIER_EXT) ? 1 : 0;

		flags &= ~RIVER_FLAG_PFX;
		(this->*disassembleOpcodes[dwTable][*px86])(px86, rOut, flags);
		if ((px86 == (nodep::BYTE *)INVALID_ADDRESS) && (currentInstr != px86)) {
			px86 = currentInstr;
			return false;
		}
	} while (flags & RIVER_FLAG_PFX);

	dwTable = (rOut.modifiers & RIVER_MODIFIER_EXT) ? 1 : 0;

	nodep::BYTE* currentInstr = px86;
	(this->*disassembleOperands[dwTable][rOut.opCode])(px86, rOut);
	if ((px86 == (nodep::BYTE *)INVALID_ADDRESS) && (currentInstr != px86)) {
		px86 = currentInstr;
		return false;
	}
	TrackModifiedRegisters(rOut);
	TrackFlagUsage(rOut);
	rOut.TrackEspAsParameter();
	rOut.TrackUnusedRegisters();
	return true;
}

/* =========================================== */
/* Opcode disassemblers                        */
/* =========================================== */

void RiverX86Disassembler::DisassembleUnkInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
	static nodep::BYTE opcode, extPrefix;
	static nodep::DWORD address;

	revtracerImports.dbgPrintFunc(PRINT_ERROR | PRINT_DISASSEMBLY, "Disassembling unknown instruction %02x %02x \n", ri.modifiers & RIVER_MODIFIER_EXT ? 0x0F : 0x00, *px86);
	opcode = *px86;
	extPrefix = (ri.modifiers & RIVER_MODIFIER_EXT) ? 0x0F : 0x00;
	address = ri.instructionAddress;
	px86 = (nodep::BYTE*)INVALID_ADDRESS;
}

/* =========================================== */
/* Operand helpers                             */
/* =========================================== */

void RiverX86Disassembler::DisassembleImmOp(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri, nodep::BYTE immSize) {
	ri.opTypes[opIdx] = RIVER_OPTYPE_IMM | immSize;
	switch (immSize) {
	case RIVER_OPSIZE_8:
		ri.operands[opIdx].asImm8 = *((nodep::BYTE *)px86);
		px86++;
		break;
	case RIVER_OPSIZE_16:
		ri.operands[opIdx].asImm16 = *((nodep::WORD *)px86);
		px86 += 2;
		break;
	case RIVER_OPSIZE_32:
		if (ri.modifiers & RIVER_MODIFIER_O16) {
			ri.operands[opIdx].asImm16 = *((nodep::WORD *)px86);
			px86 += 2;
		} else {
			ri.operands[opIdx].asImm32 = *((nodep::DWORD *)px86);
			px86 += 4;
		}
		break;
	}
}

// used when disass reg from ext bits of modRM
void RiverX86Disassembler::DisassembleExtRegOp(nodep::BYTE opIdx, RiverInstruction &ri, nodep::BYTE reg) {
	DisassembleRegOp(opIdx, ri, reg);
}

void RiverX86Disassembler::DisassembleRegOp(nodep::BYTE opIdx, RiverInstruction &ri, nodep::BYTE reg) {
	if (RIVER_MODIFIER_O8 & ri.modifiers) {
		if (reg <= 3) {
			reg |= RIVER_REG_SZ8_L;
		} else if (reg < 8) { // if reg >= 8 means register is explicitly specified
			reg -= 4;
			reg |= RIVER_REG_SZ8_H;
		}
	} else if (RIVER_MODIFIER_O16 & ri.modifiers) {
		reg |= RIVER_REG_SZ16;
	}
	nodep::BYTE opType = RIVER_OPTYPE_REG;
	if (RIVER_MODIFIER_O8 & ri.modifiers) {
		opType |= RIVER_OPSIZE_8;
	}
	else if (RIVER_MODIFIER_O16 & ri.modifiers) {
		opType |= RIVER_OPSIZE_16;
	}

	ri.opTypes[opIdx] = opType;
	ri.operands[opIdx].asRegister.versioned = codegen->GetCurrentReg(reg);
}

void RiverX86Disassembler::DisassembleModRMOp(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri, nodep::BYTE &extra) {
	RiverAddress *rAddr;
	nodep::BYTE mod = *px86 >> 6;
	nodep::BYTE rm = *px86 & 0x07;
	
	rAddr = codegen->AllocAddr(ri.modifiers); //new RiverAddress;
	rAddr->DecodeFromx86(*codegen, px86, extra, ri.modifiers);

	nodep::BYTE opType = RIVER_OPTYPE_MEM;
	if (RIVER_MODIFIER_O8 & ri.modifiers) {
		opType |= RIVER_OPSIZE_8;
	}
	else if (RIVER_MODIFIER_O16 & ri.modifiers) {
		opType |= RIVER_OPSIZE_16;
	}

	ri.opTypes[opIdx] = opType;
	ri.operands[opIdx].asAddress = rAddr;
}

void RiverX86Disassembler::DisassembleSzModRMOp(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri, nodep::BYTE &extra, nodep::WORD sz) {
	RiverAddress *rAddr;
	nodep::BYTE mod = *px86 >> 6;
	nodep::BYTE rm = *px86 & 0x07;

	nodep::WORD tmpMod = 0;

	nodep::BYTE opType = RIVER_OPTYPE_MEM;
	if (RIVER_MODIFIER_O8 & sz) {
		opType |= RIVER_OPSIZE_8;
		tmpMod |= RIVER_MODIFIER_O8;
	} else if (RIVER_MODIFIER_O16 & sz) {
		opType |= RIVER_OPSIZE_16;
		tmpMod |= RIVER_MODIFIER_O16;
	}

	rAddr = codegen->AllocAddr(ri.modifiers); //new RiverAddress;
	rAddr->DecodeFromx86(*codegen, px86, extra, ri.modifiers | tmpMod);
	
	ri.opTypes[opIdx] = opType;
	ri.operands[opIdx].asAddress = rAddr;
}

void RiverX86Disassembler::DisassembleMoffs8(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri) {
	RiverAddress *rAddr;

	rAddr = codegen->AllocAddr(ri.modifiers); //new RiverAddress;
	rAddr->DecodeFlags(ri.modifiers); 
	rAddr->type = RIVER_ADDR_DISP8 | RIVER_ADDR_DIRTY;
	rAddr->disp.d8 = *px86;

	nodep::BYTE opType = RIVER_OPTYPE_MEM;
	if (RIVER_MODIFIER_O8 & ri.modifiers) {
		opType |= RIVER_OPSIZE_8;
	}
	else if (RIVER_MODIFIER_O16 & ri.modifiers) {
		opType |= RIVER_OPSIZE_16;
	}

	px86++;

	ri.opTypes[opIdx] = opType;
	ri.operands[opIdx].asAddress = rAddr;
}

void RiverX86Disassembler::DisassembleMoffs32(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri) {
	RiverAddress *rAddr;

	rAddr = codegen->AllocAddr(ri.modifiers); //new RiverAddress;
	rAddr->scaleAndSegment = 0;
	rAddr->DecodeFlags(ri.modifiers);
	rAddr->type = RIVER_ADDR_DISP | RIVER_ADDR_DIRTY;
	
	if (ri.modifiers & RIVER_MODIFIER_A16) {
		rAddr->disp.d32 = *(nodep::WORD *)px86;
		px86 += 2;
	} else {
		rAddr->disp.d32 = *(nodep::DWORD *)px86;
		px86 += 4;
	}
	
	nodep::BYTE opType = RIVER_OPTYPE_MEM;
	if (RIVER_MODIFIER_O8 & ri.modifiers) {
		opType |= RIVER_OPSIZE_8;
	}
	else if (RIVER_MODIFIER_O16 & ri.modifiers) {
		opType |= RIVER_OPSIZE_16;
	}

	ri.opTypes[opIdx] = opType;
	ri.operands[opIdx].asAddress = rAddr;
}

/* =========================================== */
/* Operand disassemblers                       */
/* =========================================== */

void RiverX86Disassembler::DisassembleUnkOp(nodep::BYTE *&px86, RiverInstruction &ri) {
	px86 = (nodep::BYTE*)INVALID_ADDRESS;
}

void RiverX86Disassembler::DisassembleNoOp(nodep::BYTE *&px86, RiverInstruction &ri) {
}

void RiverX86Disassembler::DisassembleRegModRM(nodep::BYTE *&px86, RiverInstruction &ri) {
	nodep::BYTE sec;
	DisassembleModRMOp(1, px86, ri, sec);
	DisassembleExtRegOp(0, ri, sec);
}

void RiverX86Disassembler::DisassembleModRMReg(nodep::BYTE *&px86, RiverInstruction &ri) {
	nodep::BYTE sec;
	DisassembleModRMOp(0, px86, ri, sec);
	DisassembleExtRegOp(1, ri, sec);
}

void RiverX86Disassembler::DisassembleModRMImm8(nodep::BYTE *&px86, RiverInstruction &ri) {
	nodep::BYTE sec;
	DisassembleModRMOp(0, px86, ri, sec);
	DisassembleImmOp(1, px86, ri, RIVER_OPSIZE_8);
}

void RiverX86Disassembler::DisassembleModRMImm32(nodep::BYTE *&px86, RiverInstruction &ri) {
	nodep::BYTE sec;
	DisassembleModRMOp(0, px86, ri, sec);
	DisassembleImmOp(1, px86, ri, RIVER_OPSIZE_32);
}

void RiverX86Disassembler::DisassembleSubOpModRM(nodep::BYTE *&px86, RiverInstruction &ri) {
	DisassembleModRMOp(0, px86, ri, ri.subOpCode);
}

void RiverX86Disassembler::DisassembleSubOpModRMImm8(nodep::BYTE *&px86, RiverInstruction &ri) {
	DisassembleModRMOp(0, px86, ri, ri.subOpCode);
	DisassembleImmOp(1, px86, ri, RIVER_OPSIZE_8);
}

void RiverX86Disassembler::DisassembleSubOpModRMImm32(nodep::BYTE *&px86, RiverInstruction &ri) {
	DisassembleModRMOp(0, px86, ri, ri.subOpCode);
	DisassembleImmOp(1, px86, ri, RIVER_OPSIZE_32);
}

void RiverX86Disassembler::DisassembleImm8(nodep::BYTE *&px86, RiverInstruction &ri) {
	DisassembleImmOp(0, px86, ri, RIVER_OPSIZE_8);
}

void RiverX86Disassembler::DisassembleImm16(nodep::BYTE *&px86, RiverInstruction &ri) {
	DisassembleImmOp(0, px86, ri, RIVER_OPSIZE_16);
}

void RiverX86Disassembler::DisassembleImm32(nodep::BYTE *&px86, RiverInstruction &ri) {
	DisassembleImmOp(0, px86, ri, RIVER_OPSIZE_32);
}

void RiverX86Disassembler::DisassembleImm32Imm16(nodep::BYTE *&px86, RiverInstruction &ri) {
	DisassembleImmOp(0, px86, ri, RIVER_OPSIZE_32);
	DisassembleImmOp(1, px86, ri, RIVER_OPSIZE_16);
}

void RiverX86Disassembler::DisassembleModRMRegImm8(nodep::BYTE *&px86, RiverInstruction &ri) {
	nodep::BYTE sec;
	DisassembleModRMOp(0, px86, ri, sec);
	DisassembleExtRegOp(1, ri, sec);
	DisassembleImmOp(2, px86, ri, RIVER_OPSIZE_8);
}

void RiverX86Disassembler::DisassembleRegModRMImm8(nodep::BYTE *&px86, RiverInstruction &ri) {
	nodep::BYTE sec;
	DisassembleModRMOp(1, px86, ri, sec);
	DisassembleExtRegOp(0, ri, sec);
	DisassembleImmOp(2, px86, ri, RIVER_OPSIZE_8);
}

void RiverX86Disassembler::DisassembleRegModRMImm32(nodep::BYTE *&px86, RiverInstruction &ri) {
	nodep::BYTE sec;
	DisassembleModRMOp(1, px86, ri, sec);
	DisassembleExtRegOp(0, ri, sec);
	DisassembleImmOp(2, px86, ri, RIVER_OPSIZE_32);
}

// 32 EAX AX
// 16 AX AL
nodep::BYTE LookupConvertRegSize[2][2] = {
	{ RIVER_REG_SZ32, RIVER_REG_SZ16 },
	{ RIVER_REG_SZ16, RIVER_REG_SZ8_L }
};

void RiverX86Disassembler::DisassembleConvertOperands(nodep::BYTE opIdx, RiverInstruction &ri) {
	nodep::BYTE reg = RIVER_REG_xAX;
	unsigned indexLookup = 0;

	if (ri.modifiers & RIVER_MODIFIER_O16) {
		ri.opTypes[opIdx] = RIVER_OPTYPE_REG | (RIVER_OPSIZE_16 + opIdx);
		indexLookup = 1;
	} else {
		ri.opTypes[opIdx] = RIVER_OPTYPE_REG | (RIVER_OPSIZE_32 + opIdx);
	}

	reg |= LookupConvertRegSize[indexLookup][opIdx];
	ri.operands[opIdx].asRegister.versioned = codegen->GetCurrentReg(reg);
}

void RiverX86Disassembler::DisassembleConvertxAx(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
	ri.opCode = *px86;
	for (int i = 0; i < 2; ++i) {
		DisassembleConvertOperands(i, ri);
	}
	px86++;
}

/* =========================================== */
/* Specifier tables                            */
/* =========================================== */

const nodep::WORD specTbl[2][0x100] = {
		{
			/*0x00*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x01*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x02*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x03*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x04*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x05*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x06*/ RIVER_SPEC_MODIFIES_xSP | RIVER_SPEC_IGNORES_FLG,
			/*0x07*/ 0xFF,
			/*0x08*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x09*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x0A*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x0B*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x0C*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x0D*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x0E*/ 0xFF,
			/*0x0F*/ 0,
			/*0x10*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x11*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x12*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x13*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x14*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x15*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x16*/ RIVER_SPEC_MODIFIES_xSP | RIVER_SPEC_IGNORES_FLG,
			/*0x17*/ 0xFF,
			/*0x18*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x19*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x1A*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x1B*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x1C*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x1D*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x1E*/ 0xFF,
			/*0x1F*/ 0xFF,
			/*0x20*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x21*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x22*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x23*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x24*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x25*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x26*/ 0xFF,
			/*0x27*/ 0xFF,
			/*0x28*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x29*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x2A*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x2B*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x2C*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x2D*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x2E*/ 0xFF,
			/*0x2F*/ 0xFF,
			/*0x30*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x31*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x32*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x33*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x34*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x35*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x36*/ 0xFF,
			/*0x37*/ 0xFF,
			/*0x38*/ RIVER_SPEC_MODIFIES_FLG,
			/*0x39*/ RIVER_SPEC_MODIFIES_FLG,
			/*0x3A*/ RIVER_SPEC_MODIFIES_FLG,
			/*0x3B*/ RIVER_SPEC_MODIFIES_FLG,
			/*0x3C*/ RIVER_SPEC_MODIFIES_FLG,
			/*0x3D*/ RIVER_SPEC_MODIFIES_FLG,
			/*0x3E*/ 0xFF,
			/*0x3F*/ 0xFF,
			/*0x40*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x41*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x42*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x43*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x44*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x45*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x46*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x47*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x48*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x49*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x4A*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x4B*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x4C*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x4D*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x4E*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x4F*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x50*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x51*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x52*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x53*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x54*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x55*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x56*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x57*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x58*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x59*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x5A*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x5B*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x5C*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x5D*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x5E*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x5F*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x60*/ 0xFF,
			/*0x61*/ 0xFF,
			/*0x62*/ 0xFF,
			/*0x63*/ 0xFF,
			/*0x64*/ 0,
			/*0x65*/ 0,
			/*0x66*/ 0,
			/*0x67*/ 0,
			/*0x68*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x69*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x6A*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			/*0x6B*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x6C*/ 0xFF,
			/*0x6D*/ 0xFF,
			/*0x6E*/ 0xFF,
			/*0x6F*/ 0xFF,
			/*0x70*/ 0,
			/*0x71*/ 0,
			/*0x72*/ 0,
			/*0x73*/ 0,
			/*0x74*/ 0,
			/*0x75*/ 0,
			/*0x76*/ 0,
			/*0x77*/ 0,
			/*0x78*/ 0,
			/*0x79*/ 0,
			/*0x7A*/ 0,
			/*0x7B*/ 0,
			/*0x7C*/ 0,
			/*0x7D*/ 0,
			/*0x7E*/ 0,
			/*0x7F*/ 0,
			/*0x80*/ RIVER_SPEC_MODIFIES_EXT,
			/*0x81*/ RIVER_SPEC_MODIFIES_EXT,
			/*0x82*/ RIVER_SPEC_MODIFIES_EXT,
			/*0x83*/ RIVER_SPEC_MODIFIES_EXT,
			/*0x84*/ RIVER_SPEC_MODIFIES_FLG,
			/*0x85*/ RIVER_SPEC_MODIFIES_FLG,
			/*0x86*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x87*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x88*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x89*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x8A*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x8B*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x8C*/ 0xFF,
			/*0x8D*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1 | RIVER_SPEC_IGNORES_MEMORY,
			/*0x8E*/ 0xFF,
			/*0x8F*/ 0xFF,
			/*0x90*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x91*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x92*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x93*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x94*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x95*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x96*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x97*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x98*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_MEMORY,
			/*0x99*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0x9A*/ 0xFF,
			/*0x9B*/ 0xFF,
			/*0x9C*/ 0xFF,
			/*0x9D*/ 0xFF,
			/*0x9E*/ 0xFF,
			/*0x9F*/ 0xFF,
			/*0xA0*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xA1*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xA2*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xA3*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xA4*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_OP3,
			/*0xA5*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_OP3, 
			/*0xA6*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_FLG,
			/*0xA7*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_FLG,
			/*0xA8*/ RIVER_SPEC_MODIFIES_FLG,
			/*0xA9*/ RIVER_SPEC_MODIFIES_FLG,
			/*0xAA*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_OP3,
			/*0xAB*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_OP3,
			/*0xAC*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_OP3,
			/*0xAD*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_OP3,
			/*0xAE*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xAF*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xB0*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB1*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB2*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB3*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB4*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB5*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB6*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB7*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB8*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB9*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xBA*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xBB*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xBC*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xBD*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xBE*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xBF*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xC0*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xC1*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xC2*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG,
			/*0xC3*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0xC4*/ 0xFF,
			/*0xC5*/ 0xFF,
			/*0xC6*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xC7*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xC8*/ 0xFF,
			/*0xC9*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_OP1 | RIVER_SPEC_IGNORES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0xCA*/ 0xFF,
			/*0xCB*/ 0xFF,
			/*0xCC*/ 0xFF,
			/*0xCD*/ 0xFF,
			/*0xCE*/ 0xFF,
			/*0xCF*/ 0xFF,
			/*0xD0*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xD1*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xD2*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xD3*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xD4*/ 0xFF,
			/*0xD5*/ 0xFF,
			/*0xD6*/ 0xFF,
			/*0xD7*/ 0xFF,
			/*0xD8*/ 0xFF,
			/*0xD9*/ 0xFF,
			/*0xDA*/ 0xFF,
			/*0xDB*/ 0xFF,
			/*0xDC*/ 0xFF,
			/*0xDD*/ 0xFF,
			/*0xDE*/ 0xFF,
			/*0xDF*/ 0xFF,
			/*0xE0*/ 0xFF,
			/*0xE1*/ 0xFF,
			/*0xE2*/ 0xFF,
			/*0xE3*/ 0,
			/*0xE4*/ 0xFF,
			/*0xE5*/ 0xFF,
			/*0xE6*/ 0xFF,
			/*0xE7*/ 0xFF,
			/*0xE8*/ RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_MODIFIES_OP4 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP4,
			/*0xE9*/ 0,
			/*0xEA*/ 0,
			/*0xEB*/ 0,
			/*0xEC*/ 0xFF,
			/*0xED*/ 0xFF,
			/*0xEE*/ 0xFF,
			/*0xEF*/ 0xFF,
			/*0xF0*/ 0,
			/*0xF1*/ 0xFF,
			/*0xF2*/ 0,
			/*0xF3*/ 0,
			/*0xF4*/ 0xFF,
			/*0xF5*/ 0xFF,
			/*0xF6*/ RIVER_SPEC_MODIFIES_EXT | 2,
			/*0xF7*/ RIVER_SPEC_MODIFIES_EXT | 2,
			/*0xF8*/ 0xFF,
			/*0xF9*/ 0xFF,
			/*0xFA*/ 0xFF,
			/*0xFB*/ 0xFF,
			/*0xFC*/ RIVER_SPEC_MODIFIES_FLG,
			/*0xFD*/ RIVER_SPEC_MODIFIES_FLG,
			/*0xFE*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xFF*/ RIVER_SPEC_MODIFIES_EXT | 1
		}, {
			/*0x00*/ 0xFF,
			/*0x01*/ 0xFF,
			/*0x02*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x03*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0x04*/ 0xFF,
			/*0x05*/ 0x00,
			/*0x06*/ 0xFF,
			/*0x07*/ 0xFF,
			/*0x08*/ 0xFF,
			/*0x09*/ 0xFF,
			/*0x0A*/ 0xFF,
			/*0x0B*/ 0xFF,
			/*0x0C*/ 0xFF,
			/*0x0D*/ 0xFF,
			/*0x0E*/ 0xFF,
			/*0x0F*/ 0,
			/*0x10*/ 0xFF,
			/*0x11*/ 0xFF,
			/*0x12*/ 0xFF,
			/*0x13*/ 0xFF,
			/*0x14*/ 0xFF,
			/*0x15*/ 0xFF,
			/*0x16*/ 0xFF,
			/*0x17*/ 0xFF,
			/*0x18*/ 0xFF,
			/*0x19*/ 0xFF,
			/*0x1A*/ 0xFF,
			/*0x1B*/ 0xFF,
			/*0x1C*/ 0xFF,
			/*0x1D*/ 0xFF,
			/*0x1E*/ 0xFF,
			/*0x1F*/ 0xFF,
			/*0x20*/ 0xFF,
			/*0x21*/ 0xFF,
			/*0x22*/ 0xFF,
			/*0x23*/ 0xFF,
			/*0x24*/ 0xFF,
			/*0x25*/ 0xFF,
			/*0x26*/ 0xFF,
			/*0x27*/ 0xFF,
			/*0x28*/ 0xFF,
			/*0x29*/ 0xFF,
			/*0x2A*/ 0xFF,
			/*0x2B*/ 0xFF,
			/*0x2C*/ 0xFF,
			/*0x2D*/ 0xFF,
			/*0x2E*/ 0xFF,
			/*0x2F*/ 0xFF,
			/*0x30*/ 0xFF,
			/*0x31*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_IGNORES_OP1 | RIVER_SPEC_IGNORES_OP2 | RIVER_SPEC_IGNORES_FLG,
			/*0x32*/ 0xFF,
			/*0x33*/ 0xFF,
			/*0x34*/ 0x00,
			/*0x35*/ 0xFF,
			/*0x36*/ 0xFF,
			/*0x37*/ 0xFF,
			/*0x38*/ 0xFF,
			/*0x39*/ 0xFF,
			/*0x3A*/ 0xFF,
			/*0x3B*/ 0xFF,
			/*0x3C*/ 0xFF,
			/*0x3D*/ 0xFF,
			/*0x3E*/ 0xFF,
			/*0x3F*/ 0xFF,
			/*0x40*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x41*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x42*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x43*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x44*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x45*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x46*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x47*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x48*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x49*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x4A*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x4B*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x4C*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x4D*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x4E*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x4F*/ RIVER_SPEC_MODIFIES_OP1,
			/*0x50*/ 0xFF,
			/*0x51*/ 0xFF,
			/*0x52*/ 0xFF,
			/*0x53*/ 0xFF,
			/*0x54*/ 0xFF,
			/*0x55*/ 0xFF,
			/*0x56*/ 0xFF,
			/*0x57*/ 0xFF,
			/*0x58*/ 0xFF,
			/*0x59*/ 0xFF,
			/*0x5A*/ 0xFF,
			/*0x5B*/ 0xFF,
			/*0x5C*/ 0xFF,
			/*0x5D*/ 0xFF,
			/*0x5E*/ 0xFF,
			/*0x5F*/ 0xFF,
			/*0x60*/ 0xFF,
			/*0x61*/ 0xFF,
			/*0x62*/ 0xFF,
			/*0x63*/ 0xFF,
			/*0x64*/ 0xFF,
			/*0x65*/ 0xFF,
			/*0x66*/ 0xFF,
			/*0x67*/ 0xFF,
			/*0x68*/ 0xFF,
			/*0x69*/ 0xFF,
			/*0x6A*/ 0xFF,
			/*0x6B*/ 0xFF,
			/*0x6C*/ 0xFF,
			/*0x6D*/ 0xFF,
			/*0x6E*/ 0xFF,
			/*0x6F*/ 0xFF,
			/*0x70*/ 0xFF,
			/*0x71*/ 0xFF,
			/*0x72*/ 0xFF,
			/*0x73*/ 0xFF,
			/*0x74*/ 0xFF,
			/*0x75*/ 0xFF,
			/*0x76*/ 0xFF,
			/*0x77*/ 0xFF,
			/*0x78*/ 0xFF,
			/*0x79*/ 0xFF,
			/*0x7A*/ 0xFF,
			/*0x7B*/ 0xFF,
			/*0x7C*/ 0xFF,
			/*0x7D*/ 0xFF,
			/*0x7E*/ 0xFF,
			/*0x7F*/ 0xFF,
			/*0x80*/ 0,
			/*0x81*/ 0,
			/*0x82*/ 0,
			/*0x83*/ 0,
			/*0x84*/ 0,
			/*0x85*/ 0,
			/*0x86*/ 0,
			/*0x87*/ 0,
			/*0x88*/ 0,
			/*0x89*/ 0,
			/*0x8A*/ 0,
			/*0x8B*/ 0,
			/*0x8C*/ 0,
			/*0x8D*/ 0,
			/*0x8E*/ 0,
			/*0x8F*/ 0,
			/*0x90*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x91*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x92*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x93*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x94*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x95*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x96*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x97*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x98*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x99*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x9A*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x9B*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x9C*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x9D*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x9E*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0x9F*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_OP1,
			/*0xA0*/ 0xFF,
			/*0xA1*/ 0xFF,
			/*0xA2*/ RIVER_SPEC_MODIFIES_CUSTOM,
			/*0xA3*/ RIVER_SPEC_MODIFIES_FLG,
			/*0xA4*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xA5*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xA6*/ 0xFF,
			/*0xA7*/ 0xFF,
			/*0xA8*/ 0xFF,
			/*0xA9*/ 0xFF,
			/*0xAA*/ 0xFF,
			/*0xAB*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xAC*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xAD*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xAE*/ 0xFF,
			/*0xAF*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xB0*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_MODIFIES_FLG,
			/*0xB1*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_MODIFIES_FLG,
			/*0xB2*/ 0xFF,
			/*0xB3*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xB4*/ 0xFF,
			/*0xB5*/ 0xFF,
			/*0xB6*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB7*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xB8*/ 0xFF,
			/*0xB9*/ 0xFF,
			/*0xBA*/ RIVER_SPEC_MODIFIES_EXT | 3,
			/*0xBB*/ 0xFF,
			/*0xBC*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xBD*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xBE*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xBF*/ RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP1,
			/*0xC0*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xC1*/ RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG,
			/*0xC2*/ 0xFF,
			/*0xC3*/ 0xFF,
			/*0xC4*/ 0xFF,
			/*0xC5*/ 0xFF,
			/*0xC6*/ 0xFF,
			/*0xC7*/ RIVER_SPEC_MODIFIES_CUSTOM,
			/*0xC8*/ RIVER_SPEC_MODIFIES_OP1,
			/*0xC9*/ RIVER_SPEC_MODIFIES_OP1,
			/*0xCA*/ RIVER_SPEC_MODIFIES_OP1,
			/*0xCB*/ RIVER_SPEC_MODIFIES_OP1,
			/*0xCC*/ RIVER_SPEC_MODIFIES_OP1,
			/*0xCD*/ RIVER_SPEC_MODIFIES_OP1,
			/*0xCE*/ RIVER_SPEC_MODIFIES_OP1,
			/*0xCF*/ RIVER_SPEC_MODIFIES_OP1,
			/*0xD0*/ 0xFF,
			/*0xD1*/ 0xFF,
			/*0xD2*/ 0xFF,
			/*0xD3*/ 0xFF,
			/*0xD4*/ 0xFF,
			/*0xD5*/ 0xFF,
			/*0xD6*/ 0xFF,
			/*0xD7*/ 0xFF,
			/*0xD8*/ 0xFF,
			/*0xD9*/ 0xFF,
			/*0xDA*/ 0xFF,
			/*0xDB*/ 0xFF,
			/*0xDC*/ 0xFF,
			/*0xDD*/ 0xFF,
			/*0xDE*/ 0xFF,
			/*0xDF*/ 0xFF,
			/*0xE0*/ 0xFF,
			/*0xE1*/ 0xFF,
			/*0xE2*/ 0xFF,
			/*0xE3*/ 0xFF,
			/*0xE4*/ 0xFF,
			/*0xE5*/ 0xFF,
			/*0xE6*/ 0xFF,
			/*0xE7*/ 0xFF,
			/*0xE8*/ 0xFF,
			/*0xE9*/ 0xFF,
			/*0xEA*/ 0xFF,
			/*0xEB*/ 0xFF,
			/*0xEC*/ 0xFF,
			/*0xED*/ 0xFF,
			/*0xEE*/ 0xFF,
			/*0xEF*/ 0xFF,
			/*0xF0*/ 0xFF,
			/*0xF1*/ 0xFF,
			/*0xF2*/ 0xFF,
			/*0xF3*/ 0xFF,
			/*0xF4*/ 0xFF,
			/*0xF5*/ 0xFF,
			/*0xF6*/ 0xFF,
			/*0xF7*/ 0xFF,
			/*0xF8*/ 0xFF,
			/*0xF9*/ 0xFF,
			/*0xFA*/ 0xFF,
			/*0xFB*/ 0xFF,
			/*0xFC*/ 0xFF,
			/*0xFD*/ 0xFF,
			/*0xFE*/ 0xFF,
			/*0xFF*/ 0xFF
		}
};

const nodep::WORD _specTblExt[][8] = {
		{ 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_FLG 
		},
		/* for 0xFF    */{ 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_MODIFIES_OP4 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP4,
			0,
			0, 
			0, 
			RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_IGNORES_FLG | RIVER_SPEC_IGNORES_OP3,
			0 
		},
		/* for 0xF6/F7 */{ 
			RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, 
			RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_MODIFIES_FLG,
			RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_MODIFIES_FLG,
			RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_MODIFIES_FLG,
			RIVER_SPEC_MODIFIES_OP2 | RIVER_SPEC_MODIFIES_OP3 | RIVER_SPEC_MODIFIES_FLG
		},
		/* for 0x0FBA  */{ 0xFF, 0xFF, 0xFF, 0xFF, RIVER_SPEC_MODIFIES_FLG, RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG, RIVER_SPEC_MODIFIES_OP1 | RIVER_SPEC_MODIFIES_FLG },
};

const nodep::WORD testFlagExt[][8] = {
	{ //0x80 0x81 0x82 0x83
	  //0xc0 0xc1
		0, 0,
		RIVER_SPEC_FLAG_CF, RIVER_SPEC_FLAG_CF,
		0, 0,
		0, 0
	}
};

```

`revtracer/RiverX86Disassembler.h`:

```h
#ifndef _RIVER_X86_DISASSEMBLER_H
#define _RIVER_X86_DISASSEMBLER_H

#include "revtracer.h"
#include "river.h"

class RiverCodeGen;

nodep::WORD GetSpecifiers(RiverInstruction &ri);

class RiverX86Disassembler {
private:
	RiverCodeGen *codegen;

	void TrackModifiedRegisters(RiverInstruction &ri);
	/*void TrackUnusedRegisters(RiverInstruction &ri);
	void TrackUnusedRegistersOperand(RiverInstruction &ri, BYTE optype, const RiverOperand &op);*/

	typedef void(RiverX86Disassembler::*DisassembleOpcodeFunc)(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags);
	typedef void(RiverX86Disassembler::*DisassembleExtraFunc)(nodep::BYTE extra, RiverInstruction &ri);
	typedef void(RiverX86Disassembler::*DisassembleOperandsFunc)(nodep::BYTE *&px86, RiverInstruction &ri);

	static DisassembleOpcodeFunc disassembleOpcodes[2][0x100];
	static DisassembleOperandsFunc disassembleOperands[2][0x100];

	static nodep::BYTE testFlags[2][0x100];
	static nodep::BYTE modFlags[2][0x100];
	void TrackFlagUsage(RiverInstruction &ri);

	static DisassembleOpcodeFunc disassemble0xFFInstr[8];
	static DisassembleOperandsFunc disassemble0xFFOp[8];

	static DisassembleOpcodeFunc disassemble0xF6Instr[8];
	static DisassembleOperandsFunc disassemble0xF6Op[8]; 
	
	static DisassembleOpcodeFunc disassemble0xF7Instr[8];
	static DisassembleOperandsFunc disassemble0xF7Op[8];

	static DisassembleOpcodeFunc disassemble0x0FC7Instr[8];
	static DisassembleOperandsFunc disassemble0x0FC7Op[8];
public :
	bool Init(RiverCodeGen *cg);

	bool Translate(nodep::BYTE *&px86, RiverInstruction &rOut, nodep::DWORD &flags);
private :
	/* opcodes disassemblers */
	void DisassembleUnkInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags);

	template <nodep::WORD modifiers = 0, nodep::WORD tflags = 0> void DisassembleDefaultInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		ri.opCode = *px86;
		ri.modifiers |= modifiers;
		ri.specifiers = GetSpecifiers(ri);
		flags |= tflags;
		px86++;
	}


	void DisassembleConvertOperands(nodep::BYTE opIdx, RiverInstruction &ri);
	void DisassembleConvertxAx(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags);

	template <nodep::WORD modifiers = 0, nodep::WORD tflags = 0> void DisassembleExtInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		/*ri.opCode = *px86;
		px86++;

		ri.subOpCode = (*px86 >> 3) & 0x07;
		ri.specifiers = GetSpecifiers(ri);*/

		ri.opCode = *px86;
		px86++;
		ri.subOpCode = (*px86 >> 3) & 0x07;
		ri.modifiers |= modifiers;
		ri.specifiers = GetSpecifiers(ri);
		flags |= tflags;
	}

	template <nodep::WORD segment> void DisassembleSegInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		flags |= RIVER_FLAG_PFX;
		ri.modifiers &= 0xF8;
		ri.modifiers |= segment;

		px86++;
	}

	template <nodep::BYTE base, nodep::WORD modifiers = 0> void DisassemblePlusRegInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		ri.opCode = base;
		ri.modifiers |= modifiers;
		ri.specifiers = GetSpecifiers(ri);
		DisassembleRegOp(0, ri, *px86 - base);
		px86++;
	}

	template <nodep::BYTE regName, nodep::WORD modifiers = 0> void DisassembleDefaultRegInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		ri.opCode = *px86;
		ri.modifiers |= modifiers;
		ri.specifiers = GetSpecifiers(ri);
		DisassembleRegOp(0, ri, regName);
		px86++;
	}

	template <nodep::BYTE regName, nodep::WORD modifiers = 0> void DisassembleDefaultSecondRegInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		ri.opCode = *px86;
		ri.modifiers |= modifiers;
		ri.specifiers = GetSpecifiers(ri);
		DisassembleRegOp(1, ri, regName);
		px86++;
	}

	template <nodep::BYTE regName0, nodep::BYTE regName1, nodep::WORD modifiers = 0> void DisassembleDefault2RegInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		ri.opCode = *px86;
		ri.modifiers |= modifiers;
		ri.specifiers = GetSpecifiers(ri);
		DisassembleRegOp(0, ri, regName0);
		DisassembleRegOp(1, ri, regName1);
		px86++;
	}

	template <nodep::BYTE instrLen> void DisassembleRelJmpInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		ri.opCode = *px86;
		ri.specifiers = GetSpecifiers(ri);
		ri.opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_32;
		ri.operands[1].asImm32 = (nodep::DWORD)px86 + instrLen;
		flags |= RIVER_FLAG_BRANCH;
		flags |= RIVER_BRANCH_TYPE_IMM;

		switch(ri.opCode) {
		case 0x70: case 0x71: case 0x72: case 0x73:
		case 0x74: case 0x75: case 0x76: case 0x77:
		case 0x78: case 0x79: case 0x7A: case 0x7B:
		case 0x7C: case 0x7D: case 0x7E: case 0x7F:
		case 0xE3: /*jcxz*/
		case 0x80: case 0x81: case 0x82: case 0x83:
		case 0x84: case 0x85: case 0x86: case 0x87:
		case 0x88: case 0x89: case 0x8A: case 0x8B:
		case 0x8C: case 0x8D: case 0x8E: case 0x8F:
				flags |= RIVER_BRANCH_INSTR_JXX;
				break;
		case 0xE9: case 0xEB:
				flags |= RIVER_BRANCH_INSTR_JMP;
				break;
		case 0xE8:
				flags |= RIVER_BRANCH_INSTR_CALL;
				break;
		case 0x34:
				flags |= RIVER_BRANCH_INSTR_SYSCALL;
				break;
		case 0x05:
				break;
		default:
				DEBUG_BREAK;

		}
		px86++;
	}

	void DisassembleRelJmpModRMInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		nodep::BYTE extra;
		ri.opCode = *px86;
		ri.specifiers = GetSpecifiers(ri);

		px86++;
		DisassembleModRMOp(0, px86, ri, extra);
		switch(RIVER_OPTYPE(ri.opTypes[0])) {
		case RIVER_OPTYPE_REG:
			flags |= RIVER_BRANCH_TYPE_REG;
			break;
		case RIVER_OPTYPE_MEM:
			flags |= RIVER_BRANCH_TYPE_MEM;
			break;
		default:
			DEBUG_BREAK;
		}

		ri.opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_32;
		ri.operands[1].asImm32 = (nodep::DWORD)px86;
		flags |= RIVER_FLAG_BRANCH;

		switch(ri.subOpCode) {
		case 0x02:
			flags |= RIVER_BRANCH_INSTR_CALL;
			break;
		case 0x04:
			flags |= RIVER_BRANCH_INSTR_JMP;
			break;
		default:
			DEBUG_BREAK;
		}
	}

	/*void DisassembleExtInstr(BYTE *&px86, RiverInstruction &ri, DWORD &flags);*/

	template <DisassembleOpcodeFunc *fSubOps> void DisassembleSubOpInstr(nodep::BYTE *&px86, RiverInstruction &ri, nodep::DWORD &flags) {
		ri.subOpCode = (*(px86 + 1) >> 3) & 0x7;
		(this->*fSubOps[ri.subOpCode])(px86, ri, flags);
	}

	/* operand helpers */
	void DisassembleImmOp(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri, nodep::BYTE immSize);
	void DisassembleRegOp(nodep::BYTE opIdx, RiverInstruction &ri, nodep::BYTE reg);
	void DisassembleExtRegOp(nodep::BYTE opIdx, RiverInstruction &ri, nodep::BYTE reg);
	void DisassembleModRMOp(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri, nodep::BYTE &extra);
	void DisassembleSzModRMOp(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri, nodep::BYTE &extra, nodep::WORD sz);
	void DisassembleMoffs8(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleMoffs32(nodep::BYTE opIdx, nodep::BYTE *&px86, RiverInstruction &ri);

	/* extra disassemblers */
	void DropExtra(nodep::BYTE extra, RiverInstruction &ri) {}
	void SubOpExtra(nodep::BYTE extra, RiverInstruction &ri) {
		ri.subOpCode = extra;
	}
	template <nodep::BYTE opIdx> void RegExtra(nodep::BYTE extra, RiverInstruction &ri) {
		DisassembleRegOp(opIdx, ri, extra);
	}

	/* operand disassemblers */
	void DisassembleUnkOp(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleNoOp(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleRegModRM(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleModRMReg(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleModRMImm8(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleModRMImm32(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleSubOpModRM(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleSubOpModRMImm8(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleSubOpModRMImm32(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleImm8(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleImm16(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleImm32(nodep::BYTE *&px86, RiverInstruction &ri);

	void DisassembleImm32Imm16(nodep::BYTE *&px86, RiverInstruction &ri);

	void DisassembleRegModRMImm32(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleRegModRMImm8(nodep::BYTE *&px86, RiverInstruction &ri);
	void DisassembleModRMRegImm8(nodep::BYTE *&px86, RiverInstruction &ri);

	template <nodep::BYTE opIdx> void DisassembleMoffs8(nodep::BYTE *&px86, RiverInstruction &ri) {
		DisassembleMoffs32(opIdx, px86, ri);
	}

	template <nodep::BYTE opIdx> void DisassembleMoffs32(nodep::BYTE *&px86, RiverInstruction &ri) {
		DisassembleMoffs32(opIdx, px86, ri);
	}

	template <nodep::BYTE opIdx, nodep::BYTE immSize> void DisassembleImmOp(nodep::BYTE *&px86, RiverInstruction &ri) {
		DisassembleImmOp(opIdx, px86, ri, immSize);
	}

	template <nodep::BYTE opIdx> void DisassembleModRM(nodep::BYTE *&px86, RiverInstruction &ri) {
		nodep::BYTE extra;
		DisassembleModRMOp(opIdx, px86, ri, extra);
	}

	template <DisassembleOperandsFunc *fSubOps> void DisassembleSubOpOp(nodep::BYTE *&px86, RiverInstruction &ri) {
		(this->*fSubOps[ri.subOpCode])(px86, ri);
	}

	//TODO modify this to work as 0xbe
	template <nodep::WORD secondOpSz> void DisassembleRegSzModRM(nodep::BYTE *&px86, RiverInstruction &ri) {
		nodep::BYTE sec;
		DisassembleSzModRMOp(1, px86, ri, sec, secondOpSz);
		DisassembleRegOp(0, ri, sec);
	}

	template <nodep::BYTE opIdx, nodep::BYTE opFlg, nodep::BYTE value, DisassembleOperandsFunc cont> void DisassembleConstImmOperand(nodep::BYTE *&px86, RiverInstruction &ri) {
		(this->*cont)(px86, ri);
		ri.opTypes[opIdx] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8 | opFlg;
		ri.operands[opIdx].asImm8 = value;
	}

	template <nodep::BYTE opIdx, nodep::BYTE opFlg, nodep::BYTE regName, DisassembleOperandsFunc cont> void DisassembleConstRegOperand(nodep::BYTE *&px86, RiverInstruction &ri) {
		(this->*cont)(px86, ri);

		//ri.opTypes[opIdx] = RIVER_OPTYPE_REG | opFlg;
		//ri.operands[opIdx].asRegister.versioned = codegen->GetCurrentReg(regName);

		DisassembleRegOp(opIdx, ri, regName);
		ri.opTypes[opIdx] |= opFlg;
	}

	template <nodep::BYTE opIdx, nodep::BYTE opSize, DisassembleOperandsFunc cont> void DisassembleFixOperandSize(nodep::BYTE *&px86, RiverInstruction &ri) {
		(this->*cont)(px86, ri);
		ri.opTypes[opIdx] = RIVER_OPTYPE(ri.opTypes[opIdx]) | opSize;
	}

	template <nodep::BYTE opIdx, nodep::BYTE opFlg, nodep::BYTE base, nodep::BYTE disp8, DisassembleOperandsFunc cont> void DisassembleConstMemOperand(nodep::BYTE *&px86, RiverInstruction &ri);
};

#endif

```

`revtracer/RiverX86DisassemblerTable.cpp`:

```cpp
#include "RiverX86Disassembler.h"

#include "CodeGen.h"

/* =========================================== */
/* Disassembly tables                          */
/* =========================================== */

template <nodep::BYTE opIdx, nodep::BYTE opFlg, nodep::BYTE base, nodep::BYTE disp8, RiverX86Disassembler::DisassembleOperandsFunc cont> void RiverX86Disassembler::DisassembleConstMemOperand(nodep::BYTE *&px86, RiverInstruction &ri) {
		(this->*cont)(px86, ri);

		RiverAddress32 *rAddr = (RiverAddress32 *)codegen->AllocAddr(ri.modifiers); //new RiverAddress;
		
		rAddr->scaleAndSegment = 0;
		rAddr->type = RIVER_ADDR_BASE | RIVER_ADDR_DIRTY;
		rAddr->type |= (disp8 != 0) ? RIVER_ADDR_DISP8 : 0;
		
		nodep::BYTE opType = RIVER_OPTYPE_MEM | opFlg;
		if (RIVER_MODIFIER_O8 & ri.modifiers) {
			opType |= RIVER_OPSIZE_8;
		}
		else if (RIVER_MODIFIER_O16 & ri.modifiers) {
			opType |= RIVER_OPSIZE_16;
		}

		rAddr->base.versioned = codegen->GetCurrentReg(base);
		rAddr->disp.d8 = disp8;

		ri.opTypes[opIdx] = opType;
		ri.operands[opIdx].asAddress = rAddr;
	}

RiverX86Disassembler::DisassembleOpcodeFunc RiverX86Disassembler::disassembleOpcodes[2][0x100] = {
		{
			/*0x00*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x04*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_ES>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_ES>,
			/*0x08*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x0C*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_CS>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_EXT, RIVER_FLAG_PFX>,

			/*0x10*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x14*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_SS>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_SS>,
			/*0x18*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x1C*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_DS>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_DS>,

			/*0x20*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x24*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleSegInstr<RIVER_MODIFIER_ESSEG>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>,
			/*0x28*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x2C*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleSegInstr<RIVER_MODIFIER_CSSEG>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>,

			/*0x30*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x34*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleSegInstr<RIVER_MODIFIER_SSSEG>, &RiverX86Disassembler::DisassembleDefault2RegInstr<RIVER_REG_AL, RIVER_REG_AH, RIVER_MODIFIER_O8>,
			/*0x38*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x3C*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleSegInstr<RIVER_MODIFIER_DSSEG>, &RiverX86Disassembler::DisassembleDefault2RegInstr<RIVER_REG_AL, RIVER_REG_AH, RIVER_MODIFIER_O8>,

			/*0x40*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x40>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x40>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x40>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x40>,
			/*0x44*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x40>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x40>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x40>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x40>,
			/*0x48*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x48>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x48>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x48>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x48>,
			/*0x4C*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x48>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x48>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x48>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x48>,

			/*0x50*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x50>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x50>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x50>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x50>,
			/*0x54*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x50>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x50>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x50>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x50>,
			/*0x58*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x58>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x58>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x58>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x58>,
			/*0x5C*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x58>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x58>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x58>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x58>,

			/*0x60*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x64*/ &RiverX86Disassembler::DisassembleSegInstr<RIVER_MODIFIER_FSSEG>, &RiverX86Disassembler::DisassembleSegInstr<RIVER_MODIFIER_GSSEG>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O16, RIVER_FLAG_PFX>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_A16, RIVER_FLAG_PFX>,
			/*0x68*/ &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x6C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0x70*/ &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>,
			/*0x74*/ &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>,
			/*0x78*/ &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>,
			/*0x7C*/ &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>,

			/*0x80*/ &RiverX86Disassembler::DisassembleExtInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleExtInstr, &RiverX86Disassembler::DisassembleExtInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleExtInstr,
			/*0x84*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x88*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x8C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0x90*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x90>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x90>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x90>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x90>,
			/*0x94*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0x90>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x90>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x90>, &RiverX86Disassembler::DisassemblePlusRegInstr<0x90>,
			/*0x98*/ &RiverX86Disassembler::DisassembleConvertxAx, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x9C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0xA0*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleDefaultSecondRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultSecondRegInstr<RIVER_REG_xAX>,
			/*0xA4*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0xA8*/ &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_AL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultRegInstr<RIVER_REG_xAX>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0xAC*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,

			/*0xB0*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0xB0, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB0, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB0, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB0, RIVER_MODIFIER_O8>,
			/*0xB4*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0xB0, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB0, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB0, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB0, RIVER_MODIFIER_O8>,
			/*0xB8*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0xB8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB8>,
			/*0xBC*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0xB8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xB8>,

			/*0xC0*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<0, RIVER_FLAG_BRANCH | RIVER_MODIFIER_O16 | RIVER_BRANCH_INSTR_RET | RIVER_BRANCH_TYPE_MEM>, &RiverX86Disassembler::DisassembleDefaultInstr<0, RIVER_FLAG_BRANCH | RIVER_BRANCH_INSTR_RET | RIVER_BRANCH_TYPE_MEM>,
			/*0xC4*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0xC8*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xCC*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0xD0*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultSecondRegInstr<RIVER_REG_CL, RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultSecondRegInstr<RIVER_REG_CL>,
			/*0xD4*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xD8*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xDC*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0xE0*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleRelJmpInstr<2>,
			/*0xE4*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xE8*/ &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleDefaultInstr<0, RIVER_FLAG_BRANCH | RIVER_BRANCH_INSTR_JMP | RIVER_BRANCH_TYPE_IMM>, &RiverX86Disassembler::DisassembleRelJmpInstr<2>,
			/*0xEC*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0xF0*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_LOCK, RIVER_FLAG_PFX>, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_REPNZ, RIVER_FLAG_PFX>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_REPZ, RIVER_FLAG_PFX>,
			/*0xF4*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleSubOpInstr<disassemble0xF6Instr>, &RiverX86Disassembler::DisassembleSubOpInstr<disassemble0xF7Instr>,
			/*0xF8*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xFC*/ &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleSubOpInstr<disassemble0xFFInstr>
		}, {
			/*0x00*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x04*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleRelJmpInstr<1>, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x08*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x0C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0x10*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x14*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x18*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x1C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr,

			/*0x20*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x24*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x28*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x2C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0x30*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x34*/ &RiverX86Disassembler::DisassembleRelJmpInstr<1>, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x38*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x3C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0x40*/ &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x44*/ &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x48*/ &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0x4C*/ &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,

			/*0x50*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x54*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x58*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x5C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0x60*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x64*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x68*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x6C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0x70*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x74*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x78*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0x7C*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0x80*/ &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>,
			/*0x84*/ &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>,
			/*0x88*/ &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>,
			/*0x8C*/ &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>, &RiverX86Disassembler::DisassembleRelJmpInstr<5>,

			/*0x90*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>,
			/*0x94*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>,
			/*0x98*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>,
			/*0x9C*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>,

			/*0xA0*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0xA4*/ &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xA8*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0xAC*/ &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr,

			/*0xB0*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0xB4*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
			/*0xB8*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleExtInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xBC*/ &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,

			/*0xC0*/ &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xC4*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleSubOpInstr<RiverX86Disassembler::disassemble0x0FC7Instr>,
			/*0xC8*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0xC8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xC8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xC8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xC8>,
			/*0xCC*/ &RiverX86Disassembler::DisassemblePlusRegInstr<0xC8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xC8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xC8>, &RiverX86Disassembler::DisassemblePlusRegInstr<0xC8>,

			/*0xD0*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xD4*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xD8*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xDC*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0xE0*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xE4*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xE8*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xEC*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,

			/*0xF0*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xF4*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xF8*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
			/*0xFC*/ &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr
		}
};

RiverX86Disassembler::DisassembleOperandsFunc RiverX86Disassembler::disassembleOperands[2][0x100] = {
	{
		/*0x00*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x01*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x02*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x03*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x04*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0x05*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0x06*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x07*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x08*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x09*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x0A*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x0B*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x0C*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0x0D*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0x0E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x0F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x10*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x11*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x12*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x13*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x14*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0x15*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0x16*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x17*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x18*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x19*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x1A*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x1B*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x1C*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0x1D*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0x1E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x1F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x20*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x21*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x22*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x23*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x24*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0x25*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0x26*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x27*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x28*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x29*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x2A*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x2B*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x2C*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0x2D*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0x2E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x2F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x30*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x31*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x32*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x33*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x34*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0x35*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0x36*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x37*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x38*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x39*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x3A*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x3B*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x3C*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0x3D*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0x3E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x3F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x40*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x41*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x42*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x43*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x44*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x45*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x46*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x47*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x48*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x49*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x4A*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x4B*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x4C*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x4D*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x4E*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x4F*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x50*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x51*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x52*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x53*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x54*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x55*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x56*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x57*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x58*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x59*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x5A*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x5B*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x5C*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x5D*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x5E*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x5F*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x60*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x61*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x62*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x63*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x64*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x65*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x66*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x67*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x68*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleImm32> >,
		/*0x69*/ &RiverX86Disassembler::DisassembleRegModRMImm32,
		/*0x6A*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleImm8> >,
		/*0x6B*/ &RiverX86Disassembler::DisassembleRegModRMImm8,
		/*0x6C*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x6D*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x6E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x6F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x70*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x71*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x72*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x73*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x74*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x75*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x76*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x77*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x78*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x79*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x7A*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x7B*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x7C*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x7D*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x7E*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x7F*/ &RiverX86Disassembler::DisassembleImm8,
		/*0x80*/ &RiverX86Disassembler::DisassembleSubOpModRMImm8,
		/*0x81*/ &RiverX86Disassembler::DisassembleSubOpModRMImm32,
		/*0x82*/ &RiverX86Disassembler::DisassembleSubOpModRMImm8,
		/*0x83*/ &RiverX86Disassembler::DisassembleSubOpModRMImm8,
		/*0x84*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x85*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x86*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x87*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x88*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x89*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0x8A*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x8B*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x8C*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x8D*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x8E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x8F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x90*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, 0, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleNoOp>,
		/*0x91*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, 0, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleNoOp>,
		/*0x92*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, 0, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleNoOp>,
		/*0x93*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, 0, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleNoOp>,
		/*0x94*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, 0, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleNoOp>,
		/*0x95*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, 0, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleNoOp>,
		/*0x96*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, 0, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleNoOp>,
		/*0x97*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, 0, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleNoOp>,
		/*0x98*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x99*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDX, &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0x9A*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x9B*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x9C*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleUnkOp> >,
		/*0x9D*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x9E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x9F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xA0*/ &RiverX86Disassembler::DisassembleMoffs8<1>,
		/*0xA1*/ &RiverX86Disassembler::DisassembleMoffs32<1>,
		/*0xA2*/ &RiverX86Disassembler::DisassembleMoffs8<0>,
		/*0xA3*/ &RiverX86Disassembler::DisassembleMoffs32<0>,
		/*0xA4*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSI, 
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00,
					&RiverX86Disassembler::DisassembleConstMemOperand<3, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSI, 0x00, 
						&RiverX86Disassembler::DisassembleNoOp 
					> 
				> 
			> 
		>,
		/*0xA5*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSI,
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00,
					&RiverX86Disassembler::DisassembleConstMemOperand<3, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSI, 0x00,
						&RiverX86Disassembler::DisassembleNoOp
					>
				>
			>
		>,
		/*0xA6*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSI,
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00,
					&RiverX86Disassembler::DisassembleConstMemOperand<3, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSI, 0x00,
						&RiverX86Disassembler::DisassembleNoOp
					>
				>
			>
		>,
		/*0xA7*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSI,
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00,
					&RiverX86Disassembler::DisassembleConstMemOperand<3, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSI, 0x00,
						&RiverX86Disassembler::DisassembleNoOp
					>
				>
			>
		>,
		/*0xA8*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xA9*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xAA*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00, 
					&RiverX86Disassembler::DisassembleNoOp 
				>
			>
		>,
		/*0xAB*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00,
					&RiverX86Disassembler::DisassembleNoOp
				>
			>
		>,
		/*0xAC*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00,
					&RiverX86Disassembler::DisassembleNoOp
				>
			>
		>,
		/*0xAD*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00,
					&RiverX86Disassembler::DisassembleNoOp
				>
			>
		>,
		/*0xAE*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00,
					&RiverX86Disassembler::DisassembleNoOp
				>
			>
		>,
		/*0xAF*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
				&RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x00,
					&RiverX86Disassembler::DisassembleNoOp
				>
			>
		>,
		/*0xB0*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB1*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB2*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB3*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB4*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB5*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB6*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB7*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_8>,
		/*0xB8*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xB9*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xBA*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xBB*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xBC*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xBD*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xBE*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xBF*/ &RiverX86Disassembler::DisassembleImmOp<1, RIVER_OPSIZE_32>,
		/*0xC0*/ &RiverX86Disassembler::DisassembleSubOpModRMImm8,
		/*0xC1*/ &RiverX86Disassembler::DisassembleSubOpModRMImm8,
		/*0xC2*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleImm16> >,
		/*0xC3*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0x00, &RiverX86Disassembler::DisassembleNoOp> >,
		/*0xC4*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xC5*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xC6*/ &RiverX86Disassembler::DisassembleModRMImm8,
		/*0xC7*/ &RiverX86Disassembler::DisassembleModRMImm32,
		/*0xC8*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xC9*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xBP,
				&RiverX86Disassembler::DisassembleNoOp
			>
		>,
		/*0xCA*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xCB*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xCC*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xCD*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xCE*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xCF*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD0*/ &RiverX86Disassembler::DisassembleConstImmOperand<1, RIVER_OPFLAG_IMPLICIT, 1, &RiverX86Disassembler::DisassembleSubOpModRM>,
		/*0xD1*/ &RiverX86Disassembler::DisassembleConstImmOperand<1, RIVER_OPFLAG_IMPLICIT, 1, &RiverX86Disassembler::DisassembleSubOpModRM>,
		/*0xD2*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_CL, &RiverX86Disassembler::DisassembleSubOpModRM>,
		/*0xD3*/ &RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_CL, &RiverX86Disassembler::DisassembleSubOpModRM>,
		/*0xD4*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD5*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD6*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD7*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD8*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD9*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDA*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDB*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDC*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDD*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDE*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDF*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE0*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE1*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE2*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE3*/ &RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xCX, &RiverX86Disassembler::DisassembleImm8>,
		/*0xE4*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE5*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE6*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE7*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE8*/ &RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<3, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleImm32> >,
		/*0xE9*/ &RiverX86Disassembler::DisassembleImm32,
		/*0xEA*/ &RiverX86Disassembler::DisassembleImm32Imm16,
		/*0xEB*/ &RiverX86Disassembler::DisassembleImm8,
		/*0xEC*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xED*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xEE*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xEF*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF0*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF1*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF2*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF3*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF4*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF5*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF6*/ &RiverX86Disassembler::DisassembleSubOpOp<RiverX86Disassembler::disassemble0xF6Op>,
		/*0xF7*/ &RiverX86Disassembler::DisassembleSubOpOp<RiverX86Disassembler::disassemble0xF7Op>,
		/*0xF8*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF9*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xFA*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xFB*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xFC*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xFD*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xFE*/ &RiverX86Disassembler::DisassembleSubOpModRM,
		/*0xFF*/ &RiverX86Disassembler::DisassembleSubOpOp<RiverX86Disassembler::disassemble0xFFOp>
	}, {
		/*0x00*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x01*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x02*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x03*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x04*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x05*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x06*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x07*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x08*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x09*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x0A*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x0B*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x0C*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x0D*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x0E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x0F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x10*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x11*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x12*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x13*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x14*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x15*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x16*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x17*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x18*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x19*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x1A*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x1B*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x1C*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x1D*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x1E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x1F*/ &RiverX86Disassembler::DisassembleSubOpModRM,
		/*0x20*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x21*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x22*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x23*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x24*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x25*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x26*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x27*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x28*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x29*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x2A*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x2B*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x2C*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x2D*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x2E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x2F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x30*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x31*/ &RiverX86Disassembler::DisassembleConstRegOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
			&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDX, 
				&RiverX86Disassembler::DisassembleNoOp
			>
		>,
		/*0x32*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x33*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x34*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0x35*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x36*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x37*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x38*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x39*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x3A*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x3B*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x3C*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x3D*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x3E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x3F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x40*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x41*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x42*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x43*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x44*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x45*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x46*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x47*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x48*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x49*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x4A*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x4B*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x4C*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x4D*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x4E*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x4F*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0x50*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x51*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x52*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x53*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x54*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x55*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x56*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x57*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x58*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x59*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x5A*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x5B*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x5C*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x5D*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x5E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x5F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x60*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x61*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x62*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x63*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x64*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x65*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x66*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x67*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x68*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x69*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x6A*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x6B*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x6C*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x6D*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x6E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x6F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x70*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x71*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x72*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x73*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x74*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x75*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x76*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x77*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x78*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x79*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x7A*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x7B*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x7C*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x7D*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x7E*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x7F*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0x80*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x81*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x82*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x83*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x84*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x85*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x86*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x87*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x88*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x89*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x8A*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x8B*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x8C*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x8D*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x8E*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x8F*/ &RiverX86Disassembler::DisassembleImm32,
		/*0x90*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x91*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x92*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x93*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x94*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x95*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x96*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x97*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x98*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x99*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x9A*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x9B*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x9C*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x9D*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x9E*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0x9F*/ &RiverX86Disassembler::DisassembleModRM<0>,
		/*0xA0*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xA1*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xA2*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xA3*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0xA4*/ &RiverX86Disassembler::DisassembleModRMRegImm8,
		/*0xA5*/ &RiverX86Disassembler::DisassembleConstMemOperand<0, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSI, 0x0,
					&RiverX86Disassembler::DisassembleConstMemOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDI, 0x0,
						&RiverX86Disassembler::DisassembleConstRegOperand<2, 0, RIVER_REG_CL, &RiverX86Disassembler::DisassembleNoOp>
					>
				 >,
		/*0xA6*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xA7*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xA8*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xA9*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xAA*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xAB*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0xAC*/ &RiverX86Disassembler::DisassembleModRMRegImm8,
		/*0xAD*/ &RiverX86Disassembler::DisassembleConstRegOperand<2, 0, RIVER_REG_CL, &RiverX86Disassembler::DisassembleModRMReg>,
		/*0xAE*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xAF*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0xB0*/ &RiverX86Disassembler::DisassembleConstRegOperand<2, 0, RIVER_REG_AL, &RiverX86Disassembler::DisassembleModRMReg>,
		/*0xB1*/ &RiverX86Disassembler::DisassembleConstRegOperand<2, 0, RIVER_REG_xAX, &RiverX86Disassembler::DisassembleModRMReg>,
		/*0xB2*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xB3*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0xB4*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xB5*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xB6*/ &RiverX86Disassembler::DisassembleRegSzModRM<RIVER_MODIFIER_O8>,
		/*0xB7*/ &RiverX86Disassembler::DisassembleRegSzModRM<RIVER_MODIFIER_O16>,
		/*0xB8*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xB9*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xBA*/ &RiverX86Disassembler::DisassembleSubOpModRMImm8,
		/*0xBB*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xBC*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0xBD*/ &RiverX86Disassembler::DisassembleRegModRM,
		/*0xBE*/ &RiverX86Disassembler::DisassembleFixOperandSize<1, RIVER_OPSIZE_8, &RiverX86Disassembler::DisassembleRegModRM>,
		/*0xBF*/ &RiverX86Disassembler::DisassembleFixOperandSize<1, RIVER_OPSIZE_16, &RiverX86Disassembler::DisassembleRegModRM>,
		/*0xC0*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0xC1*/ &RiverX86Disassembler::DisassembleModRMReg,
		/*0xC2*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xC3*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xC4*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xC5*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xC6*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xC7*/ &RiverX86Disassembler::DisassembleSubOpOp<RiverX86Disassembler::disassemble0x0FC7Op>,
		/*0xC8*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xC9*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xCA*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xCB*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xCC*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xCD*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xCE*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xCF*/ &RiverX86Disassembler::DisassembleNoOp,
		/*0xD0*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD1*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD2*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD3*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD4*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD5*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD6*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD7*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD8*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xD9*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDA*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDB*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDC*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDD*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDE*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xDF*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE0*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE1*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE2*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE3*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE4*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE5*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE6*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE7*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE8*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xE9*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xEA*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xEB*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xEC*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xED*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xEE*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xEF*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF0*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF1*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF2*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF3*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF4*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF5*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF6*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF7*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF8*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xF9*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xFA*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xFB*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xFC*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xFD*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xFE*/ &RiverX86Disassembler::DisassembleUnkOp,
		/*0xFF*/ &RiverX86Disassembler::DisassembleUnkOp
	}
};

RiverX86Disassembler::DisassembleOpcodeFunc RiverX86Disassembler::disassemble0xF6Instr[8] = {
/*0x00*/	&RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>, &RiverX86Disassembler::DisassembleDefaultInstr<RIVER_MODIFIER_O8>,
/*0x04*/	&RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr
};

RiverX86Disassembler::DisassembleOperandsFunc RiverX86Disassembler::disassemble0xF6Op[8] = {
/*0x00*/	&RiverX86Disassembler::DisassembleModRMImm8,
/*0x01*/	&RiverX86Disassembler::DisassembleModRMImm8,
/*0x02*/	&RiverX86Disassembler::DisassembleSubOpModRM,
/*0x03*/	&RiverX86Disassembler::DisassembleSubOpModRM,
/*0x04*/	&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ16,
				&RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ8_L,
					&RiverX86Disassembler::DisassembleModRM<0>
				>
			>,
/*0x05*/	&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ16,
				&RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ8_L,
					&RiverX86Disassembler::DisassembleModRM<0>
				>
			>,
/*0x06*/	&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ8_L,
				&RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ8_H,
					&RiverX86Disassembler::DisassembleConstRegOperand<3, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ16,
						&RiverX86Disassembler::DisassembleModRM<0>
					>
				>
			>,
/*0x07*/	&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ8_L,
				&RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ8_H,
					&RiverX86Disassembler::DisassembleConstRegOperand<3, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX | RIVER_REG_SZ16,
						&RiverX86Disassembler::DisassembleModRM<0>
					>
				>
			>
};


RiverX86Disassembler::DisassembleOpcodeFunc RiverX86Disassembler::disassemble0xF7Instr[8] = {
	&RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr,
	&RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleDefaultInstr
};

RiverX86Disassembler::DisassembleOperandsFunc RiverX86Disassembler::disassemble0xF7Op[8] = {
	&RiverX86Disassembler::DisassembleModRMImm32,
	&RiverX86Disassembler::DisassembleModRMImm32,
	&RiverX86Disassembler::DisassembleSubOpModRM,
	&RiverX86Disassembler::DisassembleSubOpModRM,
	&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
		&RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDX,
			&RiverX86Disassembler::DisassembleModRM<0>
		>
	>,
	&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
		&RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDX,
			&RiverX86Disassembler::DisassembleModRM<0>
		>
	>, 
	&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
		&RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDX,
			&RiverX86Disassembler::DisassembleModRM<0>
		>
	>, 
	&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xAX,
		&RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xDX,
			&RiverX86Disassembler::DisassembleModRM<0>
		>
	>
};


RiverX86Disassembler::DisassembleOpcodeFunc RiverX86Disassembler::disassemble0xFFInstr[8] = {
	&RiverX86Disassembler::DisassembleDefaultInstr, 
	&RiverX86Disassembler::DisassembleDefaultInstr, 
	&RiverX86Disassembler::DisassembleRelJmpModRMInstr, 
	&RiverX86Disassembler::DisassembleUnkInstr,
	&RiverX86Disassembler::DisassembleRelJmpModRMInstr, 
	&RiverX86Disassembler::DisassembleUnkInstr, 
	&RiverX86Disassembler::DisassembleDefaultInstr, 
	&RiverX86Disassembler::DisassembleUnkInstr
};

RiverX86Disassembler::DisassembleOperandsFunc RiverX86Disassembler::disassemble0xFFOp[8] = {
	&RiverX86Disassembler::DisassembleSubOpModRM, 
	&RiverX86Disassembler::DisassembleSubOpModRM, 
	&RiverX86Disassembler::DisassembleConstRegOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<3, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleNoOp> >,
	&RiverX86Disassembler::DisassembleUnkOp,
	&RiverX86Disassembler::DisassembleNoOp, 
	&RiverX86Disassembler::DisassembleUnkOp, 
	&RiverX86Disassembler::DisassembleConstRegOperand<1, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, &RiverX86Disassembler::DisassembleConstMemOperand<2, RIVER_OPFLAG_IMPLICIT, RIVER_REG_xSP, 0xFC, &RiverX86Disassembler::DisassembleSubOpModRM> >,
	&RiverX86Disassembler::DisassembleUnkOp
};

RiverX86Disassembler::DisassembleOpcodeFunc RiverX86Disassembler::disassemble0x0FC7Instr[8] = {
	&RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleDefaultInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr,
	&RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr, &RiverX86Disassembler::DisassembleUnkInstr
};

RiverX86Disassembler::DisassembleOperandsFunc RiverX86Disassembler::disassemble0x0FC7Op[8] = {
	&RiverX86Disassembler::DisassembleUnkOp, &RiverX86Disassembler::DisassembleModRM<0>, &RiverX86Disassembler::DisassembleUnkOp, &RiverX86Disassembler::DisassembleUnkOp,
	&RiverX86Disassembler::DisassembleUnkOp, &RiverX86Disassembler::DisassembleUnkOp, &RiverX86Disassembler::DisassembleUnkOp, &RiverX86Disassembler::DisassembleUnkOp
};



nodep::BYTE RiverX86Disassembler::testFlags[2][0x100] = {
	{
		/*0x00*/ 0,
		/*0x01*/ 0,
		/*0x02*/ 0,
		/*0x03*/ 0,
		/*0x04*/ 0,
		/*0x05*/ 0,
		/*0x06*/ 0,
		/*0x07*/ 0,
		/*0x08*/ 0,
		/*0x09*/ 0,
		/*0x0A*/ 0,
		/*0x0B*/ 0,
		/*0x0C*/ 0,
		/*0x0D*/ 0,
		/*0x0E*/ 0,
		/*0x0F*/ 0,
		/*0x10*/ RIVER_SPEC_FLAG_CF,
		/*0x11*/ RIVER_SPEC_FLAG_CF,
		/*0x12*/ RIVER_SPEC_FLAG_CF,
		/*0x13*/ RIVER_SPEC_FLAG_CF,
		/*0x14*/ RIVER_SPEC_FLAG_CF,
		/*0x15*/ RIVER_SPEC_FLAG_CF,
		/*0x16*/ 0,
		/*0x17*/ 0,
		/*0x18*/ RIVER_SPEC_FLAG_CF,
		/*0x19*/ RIVER_SPEC_FLAG_CF,
		/*0x1A*/ RIVER_SPEC_FLAG_CF,
		/*0x1B*/ RIVER_SPEC_FLAG_CF,
		/*0x1C*/ RIVER_SPEC_FLAG_CF,
		/*0x1D*/ RIVER_SPEC_FLAG_CF,
		/*0x1E*/ 0,
		/*0x1F*/ 0,
		/*0x20*/ 0,
		/*0x21*/ 0,
		/*0x22*/ 0,
		/*0x23*/ 0,
		/*0x24*/ 0,
		/*0x25*/ 0,
		/*0x26*/ 0,
		/*0x27*/ RIVER_SPEC_FLAG_AF | RIVER_SPEC_FLAG_CF,
		/*0x28*/ 0,
		/*0x29*/ 0,
		/*0x2A*/ 0,
		/*0x2B*/ 0,
		/*0x2C*/ 0,
		/*0x2D*/ 0,
		/*0x2E*/ 0,
		/*0x2F*/ RIVER_SPEC_FLAG_AF | RIVER_SPEC_FLAG_CF,
		/*0x30*/ 0,
		/*0x31*/ 0,
		/*0x32*/ 0,
		/*0x33*/ 0,
		/*0x34*/ 0,
		/*0x35*/ 0,
		/*0x36*/ 0,
		/*0x37*/ RIVER_SPEC_FLAG_AF,
		/*0x38*/ 0,
		/*0x39*/ 0,
		/*0x3A*/ 0,
		/*0x3B*/ 0,
		/*0x3C*/ 0,
		/*0x3D*/ 0,
		/*0x3E*/ 0,
		/*0x3F*/ RIVER_SPEC_FLAG_AF,
		/*0x40*/ 0,
		/*0x41*/ 0,
		/*0x42*/ 0,
		/*0x43*/ 0,
		/*0x44*/ 0,
		/*0x45*/ 0,
		/*0x46*/ 0,
		/*0x47*/ 0,
		/*0x48*/ 0,
		/*0x49*/ 0,
		/*0x4A*/ 0,
		/*0x4B*/ 0,
		/*0x4C*/ 0,
		/*0x4D*/ 0,
		/*0x4E*/ 0,
		/*0x4F*/ 0,
		/*0x50*/ 0,
		/*0x51*/ 0,
		/*0x52*/ 0,
		/*0x53*/ 0,
		/*0x54*/ 0,
		/*0x55*/ 0,
		/*0x56*/ 0,
		/*0x57*/ 0,
		/*0x58*/ 0,
		/*0x59*/ 0,
		/*0x5A*/ 0,
		/*0x5B*/ 0,
		/*0x5C*/ 0,
		/*0x5D*/ 0,
		/*0x5E*/ 0,
		/*0x5F*/ 0,
		/*0x60*/ 0,
		/*0x61*/ 0,
		/*0x62*/ 0,
		/*0x63*/ 0,
		/*0x64*/ 0,
		/*0x65*/ 0,
		/*0x66*/ 0,
		/*0x67*/ 0,
		/*0x68*/ 0,
		/*0x69*/ 0,
		/*0x6A*/ 0,
		/*0x6B*/ 0,
		/*0x6C*/ RIVER_SPEC_FLAG_DF,
		/*0x6D*/ RIVER_SPEC_FLAG_DF,
		/*0x6E*/ RIVER_SPEC_FLAG_DF,
		/*0x6F*/ RIVER_SPEC_FLAG_DF,
		/*0x70*/ RIVER_SPEC_FLAG_OF,
		/*0x71*/ RIVER_SPEC_FLAG_OF,
		/*0x72*/ RIVER_SPEC_FLAG_CF,
		/*0x73*/ RIVER_SPEC_FLAG_CF,
		/*0x74*/ RIVER_SPEC_FLAG_ZF,
		/*0x75*/ RIVER_SPEC_FLAG_ZF,
		/*0x76*/ RIVER_SPEC_FLAG_CF | RIVER_SPEC_FLAG_ZF,
		/*0x77*/ RIVER_SPEC_FLAG_CF | RIVER_SPEC_FLAG_ZF,
		/*0x78*/ RIVER_SPEC_FLAG_SF,
		/*0x79*/ RIVER_SPEC_FLAG_SF,
		/*0x7A*/ RIVER_SPEC_FLAG_PF,
		/*0x7B*/ RIVER_SPEC_FLAG_PF,
		/*0x7C*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF,
		/*0x7D*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF,
		/*0x7E*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_ZF,
		/*0x7F*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_ZF,
		/*0x80*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0x81*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0x82*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0x83*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0x84*/ 0, 
		/*0x85*/ 0,
		/*0x86*/ 0,
		/*0x87*/ 0,
		/*0x88*/ 0,
		/*0x89*/ 0,
		/*0x8A*/ 0,
		/*0x8B*/ 0,
		/*0x8C*/ 0,
		/*0x8D*/ 0,
		/*0x8E*/ 0,
		/*0x8F*/ 0,
		/*0x90*/ 0,
		/*0x91*/ 0,
		/*0x92*/ 0,
		/*0x93*/ 0,
		/*0x94*/ 0,
		/*0x95*/ 0,
		/*0x96*/ 0,
		/*0x97*/ 0,
		/*0x98*/ 0,
		/*0x99*/ 0,
		/*0x9A*/ 0,
		/*0x9B*/ 0,
		/*0x9C*/ 0,
		/*0x9D*/ 0,
		/*0x9E*/ 0,
		/*0x9F*/ RIVER_SPEC_FLAG_SZAPC,
		/*0xA0*/ 0,
		/*0xA1*/ 0,
		/*0xA2*/ 0,
		/*0xA3*/ 0,
		/*0xA4*/ RIVER_SPEC_FLAG_DF,
		/*0xA5*/ RIVER_SPEC_FLAG_DF,
		/*0xA6*/ RIVER_SPEC_FLAG_DF,
		/*0xA7*/ RIVER_SPEC_FLAG_DF,
		/*0xA8*/ 0,
		/*0xA9*/ 0,
		/*0xAA*/ RIVER_SPEC_FLAG_DF,
		/*0xAB*/ RIVER_SPEC_FLAG_DF,
		/*0xAC*/ RIVER_SPEC_FLAG_DF,
		/*0xAD*/ RIVER_SPEC_FLAG_DF,
		/*0xAE*/ RIVER_SPEC_FLAG_DF,
		/*0xAF*/ RIVER_SPEC_FLAG_DF,
		/*0xB0*/ 0,
		/*0xB1*/ 0,
		/*0xB2*/ 0,
		/*0xB3*/ 0,
		/*0xB4*/ 0,
		/*0xB5*/ 0,
		/*0xB6*/ 0,
		/*0xB7*/ 0,
		/*0xB8*/ 0,
		/*0xB9*/ 0,
		/*0xBA*/ 0,
		/*0xBB*/ 0,
		/*0xBC*/ 0,
		/*0xBD*/ 0,
		/*0xBE*/ 0,
		/*0xBF*/ 0,
		/*0xC0*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0xC1*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0xC2*/ 0, 
		/*0xC3*/ 0,
		/*0xC4*/ 0,
		/*0xC5*/ 0,
		/*0xC6*/ 0,
		/*0xC7*/ 0,
		/*0xC8*/ 0,
		/*0xC9*/ 0,
		/*0xCA*/ 0,
		/*0xCB*/ 0,
		/*0xCC*/ 0,
		/*0xCD*/ 0,
		/*0xCE*/ RIVER_SPEC_FLAG_OF,
		/*0xCF*/ 0,
		/*0xD0*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0xD1*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0xD2*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0xD3*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0xD4*/ 0,
		/*0xD5*/ 0,
		/*0xD6*/ RIVER_SPEC_FLAG_CF,
		/*0xD7*/ 0,
		/*0xD8*/ 0,
		/*0xD9*/ 0xFF,
		/*0xDA*/ 0xFF,
		/*0xDB*/ 0xFF,
		/*0xDC*/ 0xFF,
		/*0xDD*/ 0xFF,
		/*0xDE*/ 0xFF,
		/*0xDF*/ 0xFF,
		/*0xE0*/ RIVER_SPEC_FLAG_CF,
		/*0xE1*/ RIVER_SPEC_FLAG_CF,
		/*0xE2*/ 0,
		/*0xE3*/ 0,
		/*0xE4*/ 0,
		/*0xE5*/ 0,
		/*0xE6*/ 0,
		/*0xE7*/ 0,
		/*0xE8*/ 0,
		/*0xE9*/ 0,
		/*0xEA*/ 0,
		/*0xEB*/ 0,
		/*0xEC*/ 0,
		/*0xED*/ 0,
		/*0xEE*/ 0,
		/*0xEF*/ 0,
		/*0xF0*/ 0,
		/*0xF1*/ 0,
		/*0xF2*/ RIVER_SPEC_FLAG_ZF,
		/*0xF3*/ RIVER_SPEC_FLAG_ZF,
		/*0xF4*/ 0,
		/*0xF5*/ RIVER_SPEC_FLAG_CF,
		/*0xF6*/ 0,
		/*0xF7*/ 0,
		/*0xF8*/ 0,
		/*0xF9*/ 0,
		/*0xFA*/ 0,
		/*0xFB*/ 0,
		/*0xFC*/ 0,
		/*0xFD*/ 0,
		/*0xFE*/ 0,
		/*0xFF*/ 0
	},
	{
		/*0x00*/ 0,
		/*0x01*/ 0,
		/*0x02*/ 0,
		/*0x03*/ 0,
		/*0x04*/ 0,
		/*0x05*/ 0,
		/*0x06*/ 0,
		/*0x07*/ 0,
		/*0x08*/ 0,
		/*0x09*/ 0,
		/*0x0A*/ 0,
		/*0x0B*/ 0,
		/*0x0C*/ 0,
		/*0x0D*/ 0,
		/*0x0E*/ 0,
		/*0x0F*/ 0,
		/*0x10*/ 0,
		/*0x11*/ 0,
		/*0x12*/ 0,
		/*0x13*/ 0,
		/*0x14*/ 0,
		/*0x15*/ 0,
		/*0x16*/ 0,
		/*0x17*/ 0,
		/*0x18*/ 0,
		/*0x19*/ 0,
		/*0x1A*/ 0,
		/*0x1B*/ 0,
		/*0x1C*/ 0,
		/*0x1D*/ 0,
		/*0x1E*/ 0,
		/*0x1F*/ 0,
		/*0x20*/ 0,
		/*0x21*/ 0,
		/*0x22*/ 0,
		/*0x23*/ 0,
		/*0x24*/ 0,
		/*0x25*/ 0,
		/*0x26*/ 0,
		/*0x27*/ 0,
		/*0x28*/ 0,
		/*0x29*/ 0,
		/*0x2A*/ 0,
		/*0x2B*/ 0,
		/*0x2C*/ 0,
		/*0x2D*/ 0,
		/*0x2E*/ 0,
		/*0x2F*/ 0,
		/*0x30*/ 0,
		/*0x31*/ 0,
		/*0x32*/ 0,
		/*0x33*/ 0,
		/*0x34*/ 0,
		/*0x35*/ 0,
		/*0x36*/ 0,
		/*0x37*/ 0,
		/*0x38*/ 0,
		/*0x39*/ 0,
		/*0x3A*/ 0,
		/*0x3B*/ 0,
		/*0x3C*/ 0,
		/*0x3D*/ 0,
		/*0x3E*/ 0,
		/*0x3F*/ 0,
		/*0x40*/ RIVER_SPEC_FLAG_OF,
		/*0x41*/ RIVER_SPEC_FLAG_OF,
		/*0x42*/ RIVER_SPEC_FLAG_CF,
		/*0x43*/ RIVER_SPEC_FLAG_CF,
		/*0x44*/ RIVER_SPEC_FLAG_ZF,
		/*0x45*/ RIVER_SPEC_FLAG_ZF,
		/*0x46*/ RIVER_SPEC_FLAG_CF | RIVER_SPEC_FLAG_ZF,
		/*0x47*/ RIVER_SPEC_FLAG_CF | RIVER_SPEC_FLAG_ZF,
		/*0x48*/ RIVER_SPEC_FLAG_SF,
		/*0x49*/ RIVER_SPEC_FLAG_SF,
		/*0x4A*/ RIVER_SPEC_FLAG_PF,
		/*0x4B*/ RIVER_SPEC_FLAG_PF,
		/*0x4C*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF,
		/*0x4D*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF,
		/*0x4E*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_ZF,
		/*0x4F*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_ZF,
		/*0x50*/ 0,
		/*0x51*/ 0,
		/*0x52*/ 0,
		/*0x53*/ 0,
		/*0x54*/ 0,
		/*0x55*/ 0,
		/*0x56*/ 0,
		/*0x57*/ 0,
		/*0x58*/ 0,
		/*0x59*/ 0,
		/*0x5A*/ 0,
		/*0x5B*/ 0,
		/*0x5C*/ 0,
		/*0x5D*/ 0,
		/*0x5E*/ 0,
		/*0x5F*/ 0,
		/*0x60*/ 0,
		/*0x61*/ 0,
		/*0x62*/ 0,
		/*0x63*/ 0,
		/*0x64*/ 0,
		/*0x65*/ 0,
		/*0x66*/ 0,
		/*0x67*/ 0,
		/*0x68*/ 0,
		/*0x69*/ 0,
		/*0x6A*/ 0,
		/*0x6B*/ 0,
		/*0x6C*/ 0,
		/*0x6D*/ 0,
		/*0x6E*/ 0,
		/*0x6F*/ 0,
		/*0x70*/ 0,
		/*0x71*/ 0,
		/*0x72*/ 0,
		/*0x73*/ 0,
		/*0x74*/ 0,
		/*0x75*/ 0,
		/*0x76*/ 0,
		/*0x77*/ 0,
		/*0x78*/ 0,
		/*0x79*/ 0,
		/*0x7A*/ 0,
		/*0x7B*/ 0,
		/*0x7C*/ 0,
		/*0x7D*/ 0,
		/*0x7E*/ 0,
		/*0x7F*/ 0,
		/*0x80*/ RIVER_SPEC_FLAG_OF,
		/*0x81*/ RIVER_SPEC_FLAG_OF,
		/*0x82*/ RIVER_SPEC_FLAG_CF,
		/*0x83*/ RIVER_SPEC_FLAG_CF,
		/*0x84*/ RIVER_SPEC_FLAG_ZF,
		/*0x85*/ RIVER_SPEC_FLAG_ZF,
		/*0x86*/ RIVER_SPEC_FLAG_CF | RIVER_SPEC_FLAG_ZF,
		/*0x87*/ RIVER_SPEC_FLAG_CF | RIVER_SPEC_FLAG_ZF,
		/*0x88*/ RIVER_SPEC_FLAG_SF,
		/*0x89*/ RIVER_SPEC_FLAG_SF,
		/*0x8A*/ RIVER_SPEC_FLAG_PF,
		/*0x8B*/ RIVER_SPEC_FLAG_PF,
		/*0x8C*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF,
		/*0x8D*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF,
		/*0x8E*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_ZF,
		/*0x8F*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_ZF,
		/*0x90*/ RIVER_SPEC_FLAG_OF,
		/*0x91*/ RIVER_SPEC_FLAG_OF,
		/*0x92*/ RIVER_SPEC_FLAG_CF,
		/*0x93*/ RIVER_SPEC_FLAG_CF,
		/*0x94*/ RIVER_SPEC_FLAG_ZF,
		/*0x95*/ RIVER_SPEC_FLAG_ZF,
		/*0x96*/ RIVER_SPEC_FLAG_CF | RIVER_SPEC_FLAG_ZF,
		/*0x97*/ RIVER_SPEC_FLAG_CF | RIVER_SPEC_FLAG_ZF,
		/*0x98*/ RIVER_SPEC_FLAG_SF,
		/*0x99*/ RIVER_SPEC_FLAG_SF,
		/*0x9A*/ RIVER_SPEC_FLAG_PF,
		/*0x9B*/ RIVER_SPEC_FLAG_PF,
		/*0x9C*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF,
		/*0x9D*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF,
		/*0x9E*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_ZF,
		/*0x9F*/ RIVER_SPEC_FLAG_OF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_ZF,
		/*0xA0*/ 0,
		/*0xA1*/ 0,
		/*0xA2*/ 0,
		/*0xA3*/ 0,
		/*0xA4*/ 0,
		/*0xA5*/ 0,
		/*0xA6*/ 0,
		/*0xA7*/ 0,
		/*0xA8*/ 0,
		/*0xA9*/ 0,
		/*0xAA*/ 0,
		/*0xAB*/ 0,
		/*0xAC*/ 0,
		/*0xAD*/ 0,
		/*0xAE*/ 0,
		/*0xAF*/ 0,
		/*0xB0*/ 0,
		/*0xB1*/ 0,
		/*0xB2*/ 0,
		/*0xB3*/ 0,
		/*0xB4*/ 0,
		/*0xB5*/ 0,
		/*0xB6*/ 0,
		/*0xB7*/ 0,
		/*0xB8*/ 0,
		/*0xB9*/ 0,
		/*0xBA*/ 0,
		/*0xBB*/ 0,
		/*0xBC*/ 0,
		/*0xBD*/ 0,
		/*0xBE*/ 0,
		/*0xBF*/ 0,
		/*0xC0*/ 0,
		/*0xC1*/ 0,
		/*0xC2*/ 0,
		/*0xC3*/ 0,
		/*0xC4*/ 0,
		/*0xC5*/ 0,
		/*0xC6*/ 0,
		/*0xC7*/ 0,
		/*0xC8*/ 0,
		/*0xC9*/ 0,
		/*0xCA*/ 0,
		/*0xCB*/ 0,
		/*0xCC*/ 0,
		/*0xCD*/ 0,
		/*0xCE*/ 0,
		/*0xCF*/ 0,
		/*0xD0*/ 0,
		/*0xD1*/ 0,
		/*0xD2*/ 0,
		/*0xD3*/ 0,
		/*0xD4*/ 0,
		/*0xD5*/ 0,
		/*0xD6*/ 0,
		/*0xD7*/ 0,
		/*0xD8*/ 0,
		/*0xD9*/ 0,
		/*0xDA*/ 0,
		/*0xDB*/ 0,
		/*0xDC*/ 0,
		/*0xDD*/ 0,
		/*0xDE*/ 0,
		/*0xDF*/ 0,
		/*0xE0*/ 0,
		/*0xE1*/ 0,
		/*0xE2*/ 0,
		/*0xE3*/ 0,
		/*0xE4*/ 0,
		/*0xE5*/ 0,
		/*0xE6*/ 0,
		/*0xE7*/ 0,
		/*0xE8*/ 0,
		/*0xE9*/ 0,
		/*0xEA*/ 0,
		/*0xEB*/ 0,
		/*0xEC*/ 0,
		/*0xED*/ 0,
		/*0xEE*/ 0,
		/*0xEF*/ 0,
		/*0xF0*/ 0,
		/*0xF1*/ 0,
		/*0xF2*/ 0,
		/*0xF3*/ 0,
		/*0xF4*/ 0,
		/*0xF5*/ 0,
		/*0xF6*/ 0,
		/*0xF7*/ 0,
		/*0xF8*/ 0,
		/*0xF9*/ 0,
		/*0xFA*/ 0,
		/*0xFB*/ 0,
		/*0xFC*/ 0,
		/*0xFD*/ 0,
		/*0xFE*/ 0,
		/*0xFF*/ 0
	}
};

nodep::BYTE RiverX86Disassembler::modFlags[2][0x100] = {
	{
		/*0x00*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x01*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x02*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x03*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x04*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x05*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x06*/ 0,
		/*0x07*/ 0,
		/*0x08*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x09*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x0A*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x0B*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x0C*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x0D*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x0E*/ 0,
		/*0x0F*/ 0,
		/*0x10*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x11*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x12*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x13*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x14*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x15*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x16*/ 0,
		/*0x17*/ 0,
		/*0x18*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x19*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x1A*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x1B*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x1C*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x1D*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x1E*/ 0,
		/*0x1F*/ 0,
		/*0x20*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x21*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x22*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x23*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x24*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x25*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x26*/ 0,
		/*0x27*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x28*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x29*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x2A*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x2B*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x2C*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x2D*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x2E*/ 0,
		/*0x2F*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x30*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x31*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x32*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x33*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x34*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x35*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x36*/ 0,
		/*0x37*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x38*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x39*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x3A*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x3B*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x3C*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x3D*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x3E*/ 0,
		/*0x3F*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x40*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x41*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x42*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x43*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x44*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x45*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x46*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x47*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x48*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x49*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x4A*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x4B*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x4C*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x4D*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x4E*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x4F*/ RIVER_SPEC_FLAG_OSZAP,
		/*0x50*/ 0,
		/*0x51*/ 0,
		/*0x52*/ 0,
		/*0x53*/ 0,
		/*0x54*/ 0,
		/*0x55*/ 0,
		/*0x56*/ 0,
		/*0x57*/ 0,
		/*0x58*/ 0,
		/*0x59*/ 0,
		/*0x5A*/ 0,
		/*0x5B*/ 0,
		/*0x5C*/ 0,
		/*0x5D*/ 0,
		/*0x5E*/ 0,
		/*0x5F*/ 0,
		/*0x60*/ 0,
		/*0x61*/ 0,
		/*0x62*/ 0xFF,
		/*0x63*/ RIVER_SPEC_FLAG_ZF,
		/*0x64*/ 0,
		/*0x65*/ 0,
		/*0x66*/ 0,
		/*0x67*/ 0,
		/*0x68*/ 0,
		/*0x69*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x6A*/ 0,
		/*0x6B*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x6C*/ 0,
		/*0x6D*/ 0,
		/*0x6E*/ 0,
		/*0x6F*/ 0,
		/*0x70*/ 0,
		/*0x71*/ 0,
		/*0x72*/ 0,
		/*0x73*/ 0,
		/*0x74*/ 0,
		/*0x75*/ 0,
		/*0x76*/ 0,
		/*0x77*/ 0,
		/*0x78*/ 0,
		/*0x79*/ 0,
		/*0x7A*/ 0,
		/*0x7B*/ 0,
		/*0x7C*/ 0,
		/*0x7D*/ 0,
		/*0x7E*/ 0,
		/*0x7F*/ 0,
		/*0x80*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x81*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x82*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x83*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x84*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x85*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x86*/ 0,
		/*0x87*/ 0,
		/*0x88*/ 0,
		/*0x89*/ 0,
		/*0x8A*/ 0,
		/*0x8B*/ 0,
		/*0x8C*/ 0,
		/*0x8D*/ 0,
		/*0x8E*/ 0,
		/*0x8F*/ 0,
		/*0x90*/ 0,
		/*0x91*/ 0,
		/*0x92*/ 0,
		/*0x93*/ 0,
		/*0x94*/ 0,
		/*0x95*/ 0,
		/*0x96*/ 0,
		/*0x97*/ 0,
		/*0x98*/ 0,
		/*0x99*/ 0,
		/*0x9A*/ 0,
		/*0x9B*/ 0xFF,
		/*0x9C*/ 0,
		/*0x9D*/ 0,
		/*0x9E*/ RIVER_SPEC_FLAG_SZAPC,
		/*0x9F*/ 0,
		/*0xA0*/ 0,
		/*0xA1*/ 0,
		/*0xA2*/ 0,
		/*0xA3*/ 0,
		/*0xA4*/ 0,
		/*0xA5*/ 0,
		/*0xA6*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xA7*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xA8*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xA9*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xAA*/ 0,
		/*0xAB*/ 0,
		/*0xAC*/ 0,
		/*0xAD*/ 0,
		/*0xAE*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xAF*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xB0*/ 0,
		/*0xB1*/ 0,
		/*0xB2*/ 0,
		/*0xB3*/ 0,
		/*0xB4*/ 0,
		/*0xB5*/ 0,
		/*0xB6*/ 0,
		/*0xB7*/ 0,
		/*0xB8*/ 0,
		/*0xB9*/ 0,
		/*0xBA*/ 0,
		/*0xBB*/ 0,
		/*0xBC*/ 0,
		/*0xBD*/ 0,
		/*0xBE*/ 0,
		/*0xBF*/ 0,
		/*0xC0*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xC1*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xC2*/ 0,
		/*0xC3*/ 0,
		/*0xC4*/ 0,
		/*0xC5*/ 0,
		/*0xC6*/ 0,
		/*0xC7*/ 0,
		/*0xC8*/ 0,
		/*0xC9*/ 0,
		/*0xCA*/ 0,
		/*0xCB*/ 0,
		/*0xCC*/ 0xFF,
		/*0xCD*/ 0xFF,
		/*0xCE*/ 0xFF,
		/*0xCF*/ 0,
		/*0xD0*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xD1*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xD2*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xD3*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xD4*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xD5*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xD6*/ 0,
		/*0xD7*/ 0,
		/*0xD8*/ 0xFF,
		/*0xD9*/ 0xFF,
		/*0xDA*/ 0xFF,
		/*0xDB*/ 0xFF,
		/*0xDC*/ 0xFF,
		/*0xDD*/ 0xFF,
		/*0xDE*/ 0xFF,
		/*0xDF*/ 0xFF,
		/*0xE0*/ 0,
		/*0xE1*/ 0,
		/*0xE2*/ 0,
		/*0xE3*/ 0,
		/*0xE4*/ 0,
		/*0xE5*/ 0,
		/*0xE6*/ 0,
		/*0xE7*/ 0,
		/*0xE8*/ 0,
		/*0xE9*/ 0,
		/*0xEA*/ 0,
		/*0xEB*/ 0,
		/*0xEC*/ 0,
		/*0xED*/ 0,
		/*0xEE*/ 0,
		/*0xEF*/ 0,
		/*0xF0*/ 0,
		/*0xF1*/ 0xFF,
		/*0xF2*/ 0,
		/*0xF3*/ 0,
		/*0xF4*/ 0,
		/*0xF5*/ RIVER_SPEC_FLAG_CF,
		/*0xF6*/ RIVER_SPEC_FLAG_OSZAPC, // replace with ext
		/*0xF7*/ RIVER_SPEC_FLAG_OSZAPC, // replace with ext
		/*0xF8*/ RIVER_SPEC_FLAG_CF,
		/*0xF9*/ RIVER_SPEC_FLAG_CF,
		/*0xFA*/ 0xFF,
		/*0xFB*/ 0xFF,
		/*0xFC*/ RIVER_SPEC_FLAG_DF,
		/*0xFD*/ RIVER_SPEC_FLAG_DF,
		/*0xFE*/ RIVER_SPEC_FLAG_OSZAP,
		/*0xFF*/ RIVER_SPEC_FLAG_OSZAP
	}, {
		/*0x00*/ 0xFF,
		/*0x01*/ 0xFF,
		/*0x02*/ 0xFF,
		/*0x03*/ RIVER_SPEC_FLAG_ZF,
		/*0x04*/ 0xFF,
		/*0x05*/ 0, // should be 0xFF
		/*0x06*/ 0xFF,
		/*0x07*/ 0xFF,
		/*0x08*/ 0xFF,
		/*0x09*/ 0xFF,
		/*0x0A*/ 0xFF,
		/*0x0B*/ 0xFF,
		/*0x0C*/ 0xFF,
		/*0x0D*/ 0xFF,
		/*0x0E*/ 0xFF,
		/*0x0F*/ 0xFF,
		/*0x10*/ 0,
		/*0x11*/ 0,
		/*0x12*/ 0,
		/*0x13*/ 0,
		/*0x14*/ 0,
		/*0x15*/ 0,
		/*0x16*/ 0,
		/*0x17*/ 0,
		/*0x18*/ 0,
		/*0x19*/ 0,
		/*0x1A*/ 0,
		/*0x1B*/ 0,
		/*0x1C*/ 0,
		/*0x1D*/ 0,
		/*0x1E*/ 0,
		/*0x1F*/ 0,
		/*0x20*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x21*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x22*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x23*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x24*/ 0xFF,
		/*0x25*/ 0xFF,
		/*0x26*/ 0xFF,
		/*0x27*/ 0xFF,
		/*0x28*/ 0,
		/*0x29*/ 0,
		/*0x2A*/ 0,
		/*0x2B*/ 0,
		/*0x2C*/ 0,
		/*0x2D*/ 0,
		/*0x2E*/ 0xFF,
		/*0x2F*/ 0xFF,
		/*0x30*/ 0,
		/*0x31*/ 0,
		/*0x32*/ 0,
		/*0x33*/ 0,
		/*0x34*/ 0, // should be 0xFF
		/*0x35*/ 0,
		/*0x36*/ 0,
		/*0x37*/ 0,
		/*0x38*/ 0xFF, // three byte opcodes!!!
		/*0x39*/ 0xFF,
		/*0x3A*/ 0xFF, // three byte opcodes!!!
		/*0x3B*/ 0xFF,
		/*0x3C*/ 0xFF,
		/*0x3D*/ 0xFF,
		/*0x3E*/ 0xFF,
		/*0x3F*/ 0xFF,
		/*0x40*/ 0,
		/*0x41*/ 0,
		/*0x42*/ 0,
		/*0x43*/ 0,
		/*0x44*/ 0,
		/*0x45*/ 0,
		/*0x46*/ 0,
		/*0x47*/ 0,
		/*0x48*/ 0,
		/*0x49*/ 0,
		/*0x4A*/ 0,
		/*0x4B*/ 0,
		/*0x4C*/ 0,
		/*0x4D*/ 0,
		/*0x4E*/ 0,
		/*0x4F*/ 0,
		/*0x50*/ 0,
		/*0x51*/ 0,
		/*0x52*/ 0,
		/*0x53*/ 0,
		/*0x54*/ 0,
		/*0x55*/ 0,
		/*0x56*/ 0,
		/*0x57*/ 0,
		/*0x58*/ 0,
		/*0x59*/ 0,
		/*0x5A*/ 0,
		/*0x5B*/ 0,
		/*0x5C*/ 0,
		/*0x5D*/ 0,
		/*0x5E*/ 0,
		/*0x5F*/ 0,
		/*0x60*/ 0,
		/*0x61*/ 0,
		/*0x62*/ 0,
		/*0x63*/ 0,
		/*0x64*/ 0,
		/*0x65*/ 0,
		/*0x66*/ 0,
		/*0x67*/ 0,
		/*0x68*/ 0,
		/*0x69*/ 0,
		/*0x6A*/ 0,
		/*0x6B*/ 0,
		/*0x6C*/ 0,
		/*0x6D*/ 0,
		/*0x6E*/ 0,
		/*0x6F*/ 0,
		/*0x70*/ 0,
		/*0x71*/ 0,
		/*0x72*/ 0,
		/*0x73*/ 0,
		/*0x74*/ 0,
		/*0x75*/ 0,
		/*0x76*/ 0,
		/*0x77*/ 0,
		/*0x78*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x79*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0x7A*/ 0xFF,
		/*0x7B*/ 0xFF,
		/*0x7C*/ 0,
		/*0x7D*/ 0,
		/*0x7E*/ 0,
		/*0x7F*/ 0,
		/*0x80*/ 0,
		/*0x81*/ 0,
		/*0x82*/ 0,
		/*0x83*/ 0,
		/*0x84*/ 0,
		/*0x85*/ 0,
		/*0x86*/ 0,
		/*0x87*/ 0,
		/*0x88*/ 0,
		/*0x89*/ 0,
		/*0x8A*/ 0,
		/*0x8B*/ 0,
		/*0x8C*/ 0,
		/*0x8D*/ 0,
		/*0x8E*/ 0,
		/*0x8F*/ 0,
		/*0x90*/ 0,
		/*0x91*/ 0,
		/*0x92*/ 0,
		/*0x93*/ 0,
		/*0x94*/ 0,
		/*0x95*/ 0,
		/*0x96*/ 0,
		/*0x97*/ 0,
		/*0x98*/ 0,
		/*0x99*/ 0,
		/*0x9A*/ 0,
		/*0x9B*/ 0,
		/*0x9C*/ 0,
		/*0x9D*/ 0,
		/*0x9E*/ 0,
		/*0x9F*/ 0,
		/*0xA0*/ 0,
		/*0xA1*/ 0,
		/*0xA2*/ 0,
		/*0xA3*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xA4*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xA5*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xA6*/ 0xFF,
		/*0xA7*/ 0xFF,
		/*0xA8*/ 0,
		/*0xA9*/ 0,
		/*0xAA*/ 0,
		/*0xAB*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xAC*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xAD*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xAE*/ 0,
		/*0xAF*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xB0*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xB1*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xB2*/ 0,
		/*0xB3*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xB4*/ 0,
		/*0xB5*/ 0,
		/*0xB6*/ 0,
		/*0xB7*/ 0,
		/*0xB8*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xB9*/ 0xFF,
		/*0xBA*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xBB*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xBC*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xBD*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xBE*/ 0,
		/*0xBF*/ 0,
		/*0xC0*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xC1*/ RIVER_SPEC_FLAG_OSZAPC,
		/*0xC2*/ 0,
		/*0xC3*/ 0,
		/*0xC4*/ 0,
		/*0xC5*/ 0,
		/*0xC6*/ 0,
		/*0xC7*/ RIVER_SPEC_FLAG_EXT | 0,
		/*0xC8*/ 0,
		/*0xC9*/ 0,
		/*0xCA*/ 0,
		/*0xCB*/ 0,
		/*0xCC*/ 0,
		/*0xCD*/ 0,
		/*0xCE*/ 0,
		/*0xCF*/ 0,
		/*0xD0*/ 0,
		/*0xD1*/ 0,
		/*0xD2*/ 0,
		/*0xD3*/ 0,
		/*0xD4*/ 0,
		/*0xD5*/ 0,
		/*0xD6*/ 0,
		/*0xD7*/ 0,
		/*0xD8*/ 0,
		/*0xD9*/ 0,
		/*0xDA*/ 0,
		/*0xDB*/ 0,
		/*0xDC*/ 0,
		/*0xDD*/ 0,
		/*0xDE*/ 0,
		/*0xDF*/ 0,
		/*0xE0*/ 0,
		/*0xE1*/ 0,
		/*0xE2*/ 0,
		/*0xE3*/ 0,
		/*0xE4*/ 0,
		/*0xE5*/ 0,
		/*0xE6*/ 0,
		/*0xE7*/ 0,
		/*0xE8*/ 0,
		/*0xE9*/ 0,
		/*0xEA*/ 0,
		/*0xEB*/ 0,
		/*0xEC*/ 0,
		/*0xED*/ 0,
		/*0xEE*/ 0,
		/*0xEF*/ 0,
		/*0xF0*/ 0,
		/*0xF1*/ 0,
		/*0xF2*/ 0,
		/*0xF3*/ 0,
		/*0xF4*/ 0,
		/*0xF5*/ 0,
		/*0xF6*/ 0,
		/*0xF7*/ 0,
		/*0xF8*/ 0,
		/*0xF9*/ 0,
		/*0xFA*/ 0,
		/*0xFB*/ 0,
		/*0xFC*/ 0,
		/*0xFD*/ 0,
		/*0xFE*/ 0,
		/*0xFF*/ 0
	}
};

```

`revtracer/Runtime.h`:

```h
#ifndef _RUNTIME_H
#define _RUNTIME_H

#include "revtracer.h"

/* River runtime context */
/* TODO: make the runtime threadsafe */
struct RiverRuntime {
	nodep::UINT_PTR virtualStack;				// + 0x00 - mandatory first member (used in vm-rm transitions)
	nodep::UINT_PTR returnRegister;			// + 0x04 - ax/eax/rax value
	nodep::UINT_PTR jumpBuff;					// + 0x08
	nodep::UINT_PTR execBuff;					// + 0x0C
	nodep::UINT_PTR trackBuff;				// + 0x10
	nodep::UINT_PTR trackBase;				// + 0x14
	nodep::UINT_PTR taintedAddresses;			// + 0x18
	nodep::UINT_PTR registers;				// + 0x1C

	nodep::DWORD taintedFlags[8];				// + 0x20
	nodep::DWORD taintedRegisters[8];			// + 0x40

	nodep::UINT_PTR trackStack;				// + 0x60
	nodep::UINT_PTR secondaryRegister;		// + 0x64
	nodep::DWORD firstEsp;
};

#endif

```

`revtracer/SymbopReverseTranslator.cpp`:

```cpp
#include "SymbopReverseTranslator.h"
#include "CodeGen.h"
#include "TranslatorUtil.h"

bool SymbopReverseTranslator::Init(RiverCodeGen *cg) {
	codegen = cg;
	return true;
}

bool SymbopReverseTranslator::Translate(const RiverInstruction &rIn, RiverInstruction &rOut) {
	if ((RIVER_FAMILY_RIVER_TRACK != RIVER_FAMILY(rIn.family)) &&
		(RIVER_FAMILY_TRACK != RIVER_FAMILY(rIn.family))) {
		return false;
	}

	if (RIVER_FAMILY_RIVER_TRACK == RIVER_FAMILY(rIn.family)) {
		switch (rIn.opCode) {
			case 0x9C : // pushf
				TranslatePushFlg(rOut, rIn);
				break;
			case 0x50 : // push reg
				TranslatePushReg(rOut, rIn);
				break;
			case 0xFF : // push mem
				if (6 == rIn.subOpCode) {
					TranslatePushMem(rOut, rIn);
				} else {
					return false;
				}

				break;

			case 0x9D :
			case 0x58 :
			case 0x8F :
				return false;
				break;
			default :
				CopyInstruction(codegen, rOut, rIn);
				rOut.family |= RIVER_FAMILY_FLAG_IGNORE;
				break;
		};
	} else if (RIVER_FAMILY_TRACK == RIVER_FAMILY(rIn.family)) {
		switch (rIn.opCode) {
			case 0x8F :
				CopyInstruction(codegen, rOut, rIn);
				break;
			default :
				CopyInstruction(codegen, rOut, rIn);
				rOut.family |= RIVER_FAMILY_FLAG_IGNORE;
				break;
		}
	} else {
		CopyInstruction(codegen, rOut, rIn);
		rOut.family |= RIVER_FAMILY_FLAG_IGNORE;
	}

	return true;
}

void SymbopReverseTranslator::TranslatePushReg(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);
	rOut.opCode += 8;
}

void SymbopReverseTranslator::TranslatePushFlg(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);
	rOut.opCode += 1;
}

void SymbopReverseTranslator::TranslatePushMem(RiverInstruction &rOut, const RiverInstruction &rIn) {
	CopyInstruction(codegen, rOut, rIn);
	rOut.opCode = 0x8F;
	rOut.subOpCode = 0;
}

```

`revtracer/SymbopReverseTranslator.h`:

```h
#ifndef _SYMBOP_REVERSE_TRANSLATOR_H_
#define _SYMBOP_REVERSE_TRANSLATOR_H_

#include "revtracer.h"
#include "river.h"

using namespace rev;

class RiverCodeGen;

class SymbopReverseTranslator {
private :
	RiverCodeGen *codegen;

public :
	bool Init(RiverCodeGen *cg);
	bool Translate(const RiverInstruction &rIn, RiverInstruction &rOut);

private :
	void TranslatePushReg(RiverInstruction &rOut, const RiverInstruction &rIn);
	void TranslatePushFlg(RiverInstruction &rOut, const RiverInstruction &rIn);
	void TranslatePushMem(RiverInstruction &rOut, const RiverInstruction &rIn);
};

#endif

```

`revtracer/SymbopSaveTranslator.cpp`:

```cpp
#include "SymbopSaveTranslator.h"

#include "CodeGen.h"
#include "TranslatorUtil.h"

bool SymbopSaveTranslator::Init(RiverCodeGen *cg) {
	codegen = cg;
	return true;

}

void SymbopSaveTranslator::MakePushFlg(nodep::BYTE flags, RiverInstruction *&rOut, nodep::DWORD &instrCount) {
	rOut->opCode = 0x9C;
	rOut->subOpCode = 0;
	rOut->modifiers = 0;
	rOut->family = RIVER_FAMILY_RIVER_TRACK;

	rOut->opTypes[0] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
	rOut->operands[0].asImm8 = flags;

	rOut->opTypes[1] = rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rOut++;
	instrCount++;
}

void SymbopSaveTranslator::MakePushReg(RiverRegister reg, RiverInstruction *&rOut, nodep::DWORD &instrCount) {
	rOut->opCode = 0x50;
	rOut->subOpCode = 0;
	rOut->modifiers = 0;
	rOut->family = RIVER_FAMILY_RIVER_TRACK;

	rOut->opTypes[0] = RIVER_OPTYPE_REG | RIVER_OPSIZE_32;
	rOut->operands[0].asRegister.versioned = reg.versioned;

	rOut->opTypes[1] = rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rOut++;
	instrCount++;
}

void SymbopSaveTranslator::MakePushMem(const RiverInstruction &rIn, RiverInstruction *&rOut, nodep::DWORD &instrCount) {
	rOut->opCode = 0xFF;
	rOut->subOpCode = 6;
	rOut->modifiers = 0;
	rOut->family = RIVER_FAMILY_RIVER_TRACK;

	rOut->opTypes[0] = RIVER_OPTYPE_MEM | RIVER_OPSIZE_32;
	rOut->operands[0].asAddress = codegen->CloneAddress(*rIn.operands[0].asAddress, rIn.modifiers);

	rOut->opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
	rOut->operands[1].asImm8 = rIn.operands[1].asImm8;
	
	rOut->opTypes[2] = rOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rOut++;
	instrCount++;
}

bool SymbopSaveTranslator::Translate(const RiverInstruction &rIn, RiverInstruction *rOut, nodep::DWORD &instrCount) {
	if (RIVER_FAMILY_TRACK != RIVER_FAMILY(rIn.family)) {
		DEBUG_BREAK;
	}

	switch (rIn.opCode) {
		case 0x9D : //markflags
			MakePushFlg(rIn.operands[0].asImm8, rOut, instrCount);
			break;
		case 0x58 : //markreg
			MakePushReg(rIn.operands[0].asRegister, rOut, instrCount);
			break;
	}

	CopyInstruction(codegen, *rOut, rIn);
	rOut++;
	instrCount++;

	switch (rIn.opCode) {
		case 0x8F: //markmem
			MakePushMem(rIn, rOut, instrCount);
			break;
	}

	return true;
}

```

`revtracer/SymbopSaveTranslator.h`:

```h
#ifndef _SYMBOP_SAVE_TRANSLATOR_H_
#define _SYMBOP_SAVE_TRANSLATOR_H_

#include "revtracer.h"
#include "river.h"

class SymbopSaveTranslator {
private :
	RiverCodeGen *codegen;

	void MakePushFlg(nodep::BYTE flags, RiverInstruction *&rOut, nodep::DWORD &instrCount);
	void MakePushReg(RiverRegister reg, RiverInstruction *&rOut, nodep::DWORD &instrCount);
	void MakePushMem(const RiverInstruction &rIn, RiverInstruction *&rOut, nodep::DWORD &instrCount);
public :
	bool Init(RiverCodeGen *cg);

	bool Translate(const RiverInstruction &rIn, RiverInstruction *rMainOut, nodep::DWORD &instrCount);
};


#endif

```

`revtracer/SymbopTranslator.cpp`:

```cpp
#include "SymbopTranslator.h"

#include "CodeGen.h"
#include "TranslatorUtil.h"

nodep::DWORD SymbopTranslator::GetMemRepr(const RiverAddress &mem) {
	return 0;
}

bool SymbopTranslator::Init(RiverCodeGen *cg) {
	codegen = cg;
	return true;
}

bool SymbopTranslator::Translate(const RiverInstruction &rIn, RiverInstruction *rMainOut, nodep::DWORD &instrCount, RiverInstruction *rTrackOut, nodep::DWORD &trackCount, nodep::DWORD dwTranslationFlags) {
	if ((RIVER_FAMILY(rIn.family) == RIVER_FAMILY_RIVER) || (RIVER_FAMILY_FLAG_METAPROCESSED & rIn.family)) {
		/* do not track river operations */
		CopyInstruction(codegen, *rMainOut, rIn);
		rMainOut++;
		instrCount++;
		return true;
	}

	nodep::DWORD dwTable = (RIVER_MODIFIER_EXT & rIn.modifiers) ? 1 : 0;
	(this->*translateOpcodes[dwTable][rIn.opCode])(rIn, rMainOut, instrCount, rTrackOut, trackCount, dwTranslationFlags);

	return true;
}

void SymbopTranslator::MakeInitTrack(const RiverInstruction &rIn, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	trackedValues = 0;

	rTrackOut->opCode = 0xB8; // mov eax, 0
	rTrackOut->subOpCode = 0;
	rTrackOut->modifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK;

	rTrackOut->opTypes[0] = RIVER_OPTYPE_REG;
	rTrackOut->operands[0].asRegister.versioned = RIVER_REG_xDI;

	rTrackOut->opTypes[1] = RIVER_OPTYPE_IMM; 
	rTrackOut->operands[1].asImm32 = 0;

	rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rTrackOut->instructionAddress = rIn.instructionAddress;

	rTrackOut++;
	trackCount++;
}

void SymbopTranslator::MakeCleanTrack(RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	rTrackOut->opCode = 0xC3; // mov eax, 0
	rTrackOut->subOpCode = 0;
	rTrackOut->modifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK;

	rTrackOut->opTypes[0] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
	rTrackOut->operands[0].asImm8 = trackedValues;

	rTrackOut->opTypes[1] = rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rTrackOut++;
	trackCount++;

}

/*= FLAGS ====================================================================*/

nodep::DWORD SymbopTranslator::SaveFlagValues(RiverInstruction *&rMainOut, nodep::DWORD &instrCount) {
	trackedValues += 1;

	rMainOut->opCode = 0x9C;
	rMainOut->opTypes[0] = rMainOut->opTypes[1] = rMainOut->opTypes[2] = rMainOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rMainOut->modifiers = 0;
	rMainOut->specifiers = 0;
	rMainOut->family = RIVER_FAMILY_PRETRACK;
	rMainOut++;
	instrCount++;

	return trackedValues - 1;
}

nodep::DWORD SymbopTranslator::MakeTrackFlg(nodep::BYTE flags, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	rTrackOut->opCode = 0x9C; // pushf
	rTrackOut->opTypes[0] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
	rTrackOut->operands[0].asImm8 = flags;
		
	rTrackOut->opTypes[1] = rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rTrackOut->subOpCode = 0;
	rTrackOut->modifiers = 0;
	rTrackOut->specifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK;

	rTrackOut++;
	trackCount++;

	return SaveFlagValues(rMainOut, instrCount);
}

nodep::DWORD SymbopTranslator::MakeMarkFlg(nodep::BYTE flags, nodep::DWORD offset, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	rTrackOut->opCode = 0x9D; // popf
	rTrackOut->opTypes[0] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
	rTrackOut->operands[0].asImm8 = flags;
		
	rTrackOut->opTypes[1] = rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rTrackOut->subOpCode = 0;
	rTrackOut->modifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK;

	rTrackOut++;
	trackCount++;

	return SaveFlagValues(rMainOut, instrCount);
}

/*= REGISTER =================================================================*/

nodep::DWORD SymbopTranslator::SaveRegValue(const RiverRegister &reg, RiverInstruction *&rMainOut, nodep::DWORD &instrCount) {
	trackedValues += 1; 
	
	rMainOut->opCode = 0x50; // lea eax, [mem]
	rMainOut->modifiers = 0;
	rMainOut->family = RIVER_FAMILY_PRETRACK | ((RIVER_REG_xSP == (reg.name & 0x07)) ? RIVER_FAMILY_FLAG_ORIG_xSP : 0);
	rMainOut->opTypes[0] = RIVER_OPTYPE_REG;
	rMainOut->operands[0].asRegister.versioned = reg.versioned;
	rMainOut->opTypes[1] = rMainOut->opTypes[2] = rMainOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rMainOut->TrackEspAsParameter();
	rMainOut->TrackUnusedRegisters();
	rMainOut++;
	instrCount++;

	return trackedValues - 1;
}

nodep::DWORD SymbopTranslator::MakeTrackReg(bool ignoresValue, const RiverRegister &reg, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	rTrackOut->opCode = 0x50; // push + r
	rTrackOut->opTypes[0] = RIVER_OPTYPE_REG;
	rTrackOut->operands[0].asRegister.versioned = reg.versioned;
	rTrackOut->opTypes[1] = rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rTrackOut->modifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK | ((RIVER_REG_xSP == (reg.name & 0x07)) ? RIVER_FAMILY_FLAG_ORIG_xSP : 0);
	rTrackOut->TrackEspAsParameter();
	rTrackOut->TrackUnusedRegisters();
	rTrackOut++;
	trackCount++;

	return ignoresValue ? 0xFFFFFFFF : SaveRegValue(reg, rMainOut, instrCount);
}

nodep::DWORD SymbopTranslator::MakeMarkReg(const RiverRegister &reg, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	rTrackOut->opCode = 0x58; // pop + r

	rTrackOut->opTypes[0] = RIVER_OPTYPE_REG;
	rTrackOut->operands[0].asRegister.versioned = reg.versioned;

	rTrackOut->opTypes[1] = rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;

	rTrackOut->modifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK | ((RIVER_REG_xSP == (reg.name & 0x07)) ? RIVER_FAMILY_FLAG_ORIG_xSP : 0);

	rTrackOut->TrackEspAsParameter();
	rTrackOut->TrackUnusedRegisters();
	
	rTrackOut++;
	trackCount++;

	return SaveRegValue(reg, rMainOut, instrCount);
}

/*= MEMORY ===================================================================*/

nodep::DWORD SymbopTranslator::SaveMemValue(bool ignoresMemory, const RiverAddress &mem, RiverInstruction *&rMainOut, nodep::DWORD &instrCount) {
	if (0 == mem.type) {
		return SaveRegValue(mem.base, rMainOut, instrCount);
	}

	if (!ignoresMemory) {
		trackedValues += 2;

		rMainOut->opCode = 0xFF;
		rMainOut->specifiers = 0;
		rMainOut->subOpCode = 0x06;
		rMainOut->modifiers = 0;
		rMainOut->family = RIVER_FAMILY_PRETRACK;
		rMainOut->opTypes[0] = RIVER_OPTYPE_MEM;
		rMainOut->operands[0].asAddress = codegen->CloneAddress(mem, 0);
		rMainOut->opTypes[1] = rMainOut->opTypes[2] = rMainOut->opTypes[3] = RIVER_OPTYPE_NONE;
		rMainOut->TrackEspAsParameter();
		rMainOut->TrackUnusedRegisters();
		rMainOut++;
		instrCount++;

		return trackedValues - 2;
	}

	return 0xFFFFFFFF;
}

nodep::DWORD SymbopTranslator::MakeTrackMem(bool ignoresValue, bool ignoresMemory, const RiverAddress &mem, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	if (0 == mem.type) {
		return MakeTrackReg(ignoresValue, mem.base, rMainOut, instrCount, rTrackOut, trackCount);
	}

	rTrackOut->opCode = 0xFF;
	rTrackOut->subOpCode = 6;
	rTrackOut->specifiers = 0;
	rTrackOut->modifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK;
	rTrackOut->opTypes[0] = RIVER_OPTYPE_MEM;
	rTrackOut->operands[0].asAddress = codegen->CloneAddress(mem, 0);
	rTrackOut->opTypes[1] = rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rTrackOut->TrackEspAsParameter();
	rTrackOut->TrackUnusedRegisters();
	rTrackOut++;
	trackCount++;

	return ignoresValue ? 0xFFFFFFFF : SaveMemValue(ignoresMemory, mem, rMainOut, instrCount);
}

nodep::DWORD SymbopTranslator::MakeMarkMem(bool ignoresMemory, const RiverAddress &mem, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	if (0 == mem.type) {
		return MakeMarkReg(mem.base, rMainOut, instrCount, rTrackOut, trackCount);
	}

	rTrackOut->opCode = 0x8D;
	rTrackOut->specifiers = 0;
	rTrackOut->modifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK;
	rTrackOut->opTypes[0] = RIVER_OPTYPE_MEM;
	rTrackOut->operands[0].asAddress = codegen->CloneAddress(mem, 0);
	rTrackOut->opTypes[1] = rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rTrackOut->TrackEspAsParameter();
	rTrackOut->TrackUnusedRegisters();
	rTrackOut++;
	trackCount++;

	return SaveMemValue(ignoresMemory, mem, rMainOut, instrCount);
}

/*= ADDRESS ==================================================================*/

nodep::DWORD SymbopTranslator::SaveAddrValue(const RiverAddress &mem, RiverInstruction *&rMainOut, nodep::DWORD &instrCount) {
	if (0 == mem.type) {
		return 0xFFFFFFFF;
	}

	nodep::DWORD ret = trackedValues;

	trackedValues++; // put address value on the stack

	rMainOut->opCode = 0x8D;
	rMainOut->specifiers = 0;
	rMainOut->modifiers = 0;
	rMainOut->family = RIVER_FAMILY_PRETRACK;
	rMainOut->opTypes[0] = RIVER_OPTYPE_MEM;
	rMainOut->operands[0].asAddress = codegen->CloneAddress(mem, 0);

	//rMainOut->opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
	//rMainOut->operands[1].asImm8 = (specifiers & RIVER_SPEC_IGNORES_MEMORY) ? 0 : 1;

	rMainOut->opTypes[1] = rMainOut->opTypes[2] = rMainOut->opTypes[3] = RIVER_OPTYPE_NONE;

	if (mem.type & RIVER_ADDR_BASE) {
		trackedValues++; // put the base register value on the stack
	}

	if (mem.type & RIVER_ADDR_INDEX) {
		trackedValues++; // put the index register value on the stack
	}

	rMainOut->PromoteModifiers();
	rMainOut->TrackEspAsParameter();
	rMainOut->TrackUnusedRegisters();
	rMainOut++;
	instrCount++;

	return ret;
}


/*nodep::DWORD SymbopTranslator::MakeTrackAddress(nodep::WORD specifiers, const RiverOperand &op, nodep::BYTE optype, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount, nodep::DWORD &valuesOut) {
	if (RIVER_OPTYPE_MEM != RIVER_OPTYPE(optype)) {
		return 0xFFFFFFFF;
	}

	if (0 == op.asAddress->type) {
		return 0xFFFFFFFF;
	}

	trackedValues += 1;
	if (op.asAddress->HasSegment()) {
		trackedValues += 1;
	}

	nodep::DWORD ret = trackedValues - 1;

	rMainOut->opCode = 0x8D;
	rMainOut->specifiers = 0;
	rMainOut->modifiers = 0;
	rMainOut->family = RIVER_FAMILY_PRETRACK;
	rMainOut->opTypes[0] = RIVER_OPTYPE_MEM;
	rMainOut->operands[0].asAddress = codegen->CloneAddress(*op.asAddress, 0);

	rMainOut->opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
	rMainOut->operands[1].asImm8 = (specifiers & RIVER_SPEC_IGNORES_MEMORY) ? 0 : 1;

	rMainOut->opTypes[2] = rMainOut->opTypes[3] = RIVER_OPTYPE_NONE;

	if (op.asAddress->type & RIVER_ADDR_BASE) {
		trackedValues++;
	}

	if (op.asAddress->type & RIVER_ADDR_INDEX) {
		trackedValues++;
	}
	
	rMainOut->PromoteModifiers();
	rMainOut->TrackEspAsParameter();
	rMainOut->TrackUnusedRegisters();
	rMainOut++;
	instrCount++;

	rTrackOut->opCode = 0x8D;
	rTrackOut->specifiers = 0;
	rTrackOut->modifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK;
	rTrackOut->opTypes[0] = RIVER_OPTYPE_MEM;
	rTrackOut->operands[0].asAddress = codegen->CloneAddress(*op.asAddress, 0);
	rTrackOut->opTypes[1] = rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rTrackOut->TrackEspAsParameter();
	rTrackOut->TrackUnusedRegisters();
	rTrackOut++;
	trackCount++;

	return ret;
}

void SymbopTranslator::MakeTrackMem(const RiverAddress &mem, nodep::WORD specifiers, nodep::DWORD addrOffset, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	if (0 == mem.type) {
		return MakeTrackReg(mem.base, rTrackOut, trackCount);
	}

	if (0 == (specifiers & RIVER_SPEC_IGNORES_MEMORY)) {
		rTrackOut->opCode = 0xFF;
		rTrackOut->specifiers = 0;
		rTrackOut->subOpCode = 0x06;
		rTrackOut->modifiers = 0;
		rTrackOut->family = RIVER_FAMILY_TRACK;
		rTrackOut->opTypes[0] = RIVER_OPTYPE_MEM;
		rTrackOut->operands[0].asAddress = codegen->CloneAddress(mem, 0);
		rTrackOut->opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
		rTrackOut->operands[1].asImm8 = (nodep::BYTE)addrOffset;
		rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
		rTrackOut->TrackEspAsParameter();
		rTrackOut->TrackUnusedRegisters();
		rTrackOut++;
		trackCount++;
	}
}

void SymbopTranslator::MakeMarkMem(const RiverAddress &mem, nodep::WORD specifiers, nodep::DWORD addrOffset, nodep::DWORD valueOffset, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	if (0 == mem.type) {
		MakeMarkReg(mem.base, addrOffset, valueOffset, rMainOut, instrCount, rTrackOut, trackCount);
		return;
	}

	if (0 == (specifiers & RIVER_SPEC_IGNORES_MEMORY)) {
		rTrackOut->opCode = 0x8F;
		rTrackOut->subOpCode = 0x00;
		rTrackOut->modifiers = 0;
		rTrackOut->family = RIVER_FAMILY_TRACK;
		rTrackOut->opTypes[0] = RIVER_OPTYPE_MEM;
		rTrackOut->operands[0].asAddress = codegen->CloneAddress(mem, 0);
		rTrackOut->opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_8;
		rTrackOut->operands[1].asImm8 = (nodep::BYTE)addrOffset;
		rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
		rTrackOut->TrackEspAsParameter();
		rTrackOut->TrackUnusedRegisters();

		rTrackOut++;
		trackCount++;
	}
}*/

nodep::DWORD SymbopTranslator::MakeTrackOp(nodep::DWORD opIdx, const nodep::BYTE type, const RiverOperand &op, nodep::WORD specifiers, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	nodep::DWORD valueOffset = 0xFFFFFFFF;
	switch (RIVER_OPTYPE(type)) {
	case RIVER_OPTYPE_REG:
		valueOffset = MakeTrackReg((specifiers & RIVER_SPEC_IGNORES_OP(opIdx)) != 0, op.asRegister, rMainOut, instrCount, rTrackOut, trackCount);
		break;
	case RIVER_OPTYPE_MEM:
		valueOffset = MakeTrackMem((specifiers & RIVER_SPEC_IGNORES_OP(opIdx)) != 0, (RIVER_SPEC_IGNORES_MEMORY & specifiers) != 0, *op.asAddress, rMainOut, instrCount, rTrackOut, trackCount);
		break;
	}

	return valueOffset;
}

nodep::DWORD SymbopTranslator::MakeMarkOp(const nodep::BYTE type, nodep::WORD specifiers, const RiverOperand &op, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	nodep::DWORD valueOffset = 0xFFFFFFFF;
	
	switch (RIVER_OPTYPE(type)) {
	case RIVER_OPTYPE_REG:
		valueOffset = MakeMarkReg(op.asRegister, rMainOut, instrCount, rTrackOut, trackCount);
		break;
	case RIVER_OPTYPE_MEM:
		valueOffset = MakeMarkMem((RIVER_SPEC_IGNORES_MEMORY & specifiers) != 0, *op.asAddress, rMainOut, instrCount, rTrackOut, trackCount);
		break;
	}

	return valueOffset;
}

void SymbopTranslator::MakeCallSymbolic(const RiverInstruction &rIn, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount) {
	rTrackOut->opCode = 0xE8;
	rTrackOut->subOpCode = 0x00;
	rTrackOut->modifiers = 0;
	rTrackOut->family = RIVER_FAMILY_TRACK;
	rTrackOut->opTypes[0] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_32;
	rTrackOut->operands[0].asImm32 = rIn.instructionAddress;
	rTrackOut->opTypes[1] = rTrackOut->opTypes[2] = rTrackOut->opTypes[3] = RIVER_OPTYPE_NONE;
	rTrackOut->TrackEspAsParameter();
	rTrackOut->TrackUnusedRegisters();

	rTrackOut++;
	trackCount++;
}

void SymbopTranslator::TranslateUnk(const RiverInstruction &rIn, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount, nodep::DWORD dwTranslationFlags) {
	static nodep::BYTE lastOpcode;
	static nodep::DWORD lastAddr;

	lastOpcode = rIn.opCode;
	lastAddr = rIn.instructionAddress;
	revtracerImports.dbgPrintFunc(PRINT_ERROR | PRINT_DISASSEMBLY, "Translating unknown instruction %02x %02x \n", rIn.modifiers & RIVER_MODIFIER_EXT ? 0x0F : 0x00, lastOpcode);

	DEBUG_BREAK;
}

void SymbopTranslator::TranslateDefault(const RiverInstruction &rIn, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount, nodep::DWORD dwTranslationFlags) {
	nodep::DWORD addressOffsets[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
	nodep::DWORD inValueOffsets[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
	nodep::DWORD outValueOffsets[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
	nodep::DWORD inFlagOffset = 0xFFFFFFFF, outFlagOffset = 0xFFFFFFFF;

	MakeInitTrack(rIn, rTrackOut, trackCount);

	for (int i = 3; i >= 0; --i) {
		if (RIVER_OPTYPE_MEM == RIVER_OPTYPE(rIn.opTypes[i])) {
			addressOffsets[i] = SaveAddrValue(*rIn.operands[i].asAddress, rMainOut, instrCount);
			//MakeTrackAddress(rIn.specifiers, rIn.operands[i], rIn.opTypes[i], rMainOut, instrCount, rTrackOut, trackCount, inValueOffsets[i]);
		}
	}

	if (/*(0 == (RIVER_SPEC_IGNORES_FLG & rIn.specifiers)) ||*/ (0 != (rIn.testFlags | rIn.modFlags))) {
		// TODO: flag unset for ignored flags!
		inFlagOffset = MakeTrackFlg(rIn.testFlags | rIn.modFlags, rMainOut, instrCount, rTrackOut, trackCount);
	}

	for (int i = 3; i >= 0; --i) {
		if (RIVER_OPTYPE_NONE != rIn.opTypes[i]) {
			inValueOffsets[i] = MakeTrackOp(i, rIn.opTypes[i], rIn.operands[i], rIn.specifiers, rMainOut, instrCount, rTrackOut, trackCount);
		}
	}

	// make opcode
	CopyInstruction(codegen, *rMainOut, rIn);
	rMainOut++;
	instrCount++;

	if (rIn.modFlags) { //RIVER_SPEC_MODIFIES_FLG & rIn.specifiers) {
		outFlagOffset = MakeMarkFlg(rIn.modFlags, inFlagOffset, rMainOut, instrCount, rTrackOut, trackCount);
	}

	for (int i = 3; i >= 0; --i) {
		if ((RIVER_OPTYPE_NONE != rIn.opTypes[i]) && (RIVER_SPEC_MODIFIES_OP(i) & rIn.specifiers)) {
			outValueOffsets[i] = MakeMarkOp(rIn.opTypes[i], rIn.specifiers, rIn.operands[i], rMainOut, instrCount, rTrackOut, trackCount);
		}
	}

	if (dwTranslationFlags & TRACER_FEATURE_ADVANCED_TRACKING) {
		MakeCallSymbolic(rIn, rMainOut, instrCount, rTrackOut, trackCount);
	}

	MakeCleanTrack(rTrackOut, trackCount);
}






SymbopTranslator::TranslateOpcodeFunc SymbopTranslator::translateOpcodes[2][0x100] = {
	{
		/* 0x00 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x04 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x08 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x0C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0x10 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x14 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x18 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x1C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0x20 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x24 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x28 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x2C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0x30 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x34 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x38 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x3C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0x40 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x44 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x48 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x4C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* not really default */
		/* 0x50 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x54 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x58 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x5C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0x60 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x64 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x68 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x6C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0x70 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x74 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x78 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x7C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0x80 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x84 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x88 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x8C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0x90 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x94 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x98 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x9C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0xA0 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xA4 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xA8 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xAC */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0xB0 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xB4 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xB8 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xBC */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0xC0 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xC4 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xC8 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xCC */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0xD0 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xD4 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xD8 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xDC */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0xE0 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xE4 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xE8 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xEC */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0xF0 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xF4 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xF8 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xFC */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault
	}, {
		/* 0x00 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x04 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x08 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x0C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0x10 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x14 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x18 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x1C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0x20 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x24 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x28 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x2C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0x30 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x34 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x38 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x3C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0x40 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x44 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x48 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x4C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0x50 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x54 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x58 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x5C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0x60 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x64 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x68 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x6C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0x70 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x74 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x78 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0x7C */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0x80 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x84 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x88 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x8C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0x90 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x94 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x98 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0x9C */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0xA0 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xA4 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xA8 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault,
		/* 0xAC */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault,

		/* 0xB0 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault,
		/* 0xB4 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,
		/* 0xB8 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk,
		/* 0xBC */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault,

		/* 0xC0 */ &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateDefault, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xC4 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateDefault,
		/* 0xC8 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xCC */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0xD0 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xD4 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xD8 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xDC */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0xE0 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xE4 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xE8 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xEC */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,

		/* 0xF0 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xF4 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xF8 */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk,
		/* 0xFC */ &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk, &SymbopTranslator::TranslateUnk
	}
};

```

`revtracer/SymbopTranslator.h`:

```h
#ifndef _SYMBOP_TRANSLATOR_H
#define _SYMBOP_TRANSLATOR_H

#include "revtracer.h"
#include "river.h"

/* SYMBOP ABI */
/* - if the instruction uses any flag as input or output no inline code is generated 
   - a symboppushf tracking instruction is generated
*/

/* - if the instruction uses a register as input or output no inline code is generated
   - a symboppushreg <regname> tracking instruction is generated
*/

/* - if the instruction uses a memory location as input or output the following instructions are generated:
		- push imm8/16/32	- push the offset on the stack
		- lea reg, mem		- in order to determine the effective address resolved
		- push reg			- push the reg on the stack
		- push modrm		- push a dword containting scale, index, base
   - a symboppushmem tracking instruction is generated
*/
/* - each instruction generates an inline push opcode instruction
   - each instruction generates a symboptrack instruction
*/

class RiverCodeGen;

class SymbopTranslator {
private :
	nodep::BYTE trackedValues;

	RiverCodeGen *codegen;

	nodep::DWORD GetMemRepr(const RiverAddress &mem);

	typedef void(SymbopTranslator::*TranslateOpcodeFunc)(const RiverInstruction &rIn, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount, nodep::DWORD dwTranslationFlags);
	static TranslateOpcodeFunc translateOpcodes[2][0x100];
public :
	bool Init(RiverCodeGen *cg);

	bool Translate(const RiverInstruction &rIn, RiverInstruction *rMainOut, nodep::DWORD &instrCount, RiverInstruction *rTrackOut, nodep::DWORD &trackCount, nodep::DWORD dwTranslationFlags);

private :
	/* Translation helpers */
	void MakeInitTrack(const RiverInstruction &rIn, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);
	void MakeCleanTrack(RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);

	nodep::DWORD SaveFlagValues(RiverInstruction *& rMainOut, nodep::DWORD & instrCount);
	nodep::DWORD MakeTrackFlg(nodep::BYTE flags, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);
	nodep::DWORD MakeMarkFlg(nodep::BYTE flags, nodep::DWORD offset, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);

	
	nodep::DWORD SaveRegValue(const RiverRegister &reg, RiverInstruction *&rMainOut, nodep::DWORD &instrCount);
	nodep::DWORD MakeTrackReg(bool ignoresValue, const RiverRegister &reg, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);
	nodep::DWORD MakeMarkReg(const RiverRegister &reg, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);


	nodep::DWORD SaveMemValue(bool ignoresMemory, const RiverAddress & mem, RiverInstruction *& rMainOut, nodep::DWORD & instrCount);
	nodep::DWORD MakeTrackMem(bool ignoresValue, bool ignoresMemory, const RiverAddress & mem, RiverInstruction *& rMainOut, nodep::DWORD & instrCount, RiverInstruction *& rTrackOut, nodep::DWORD & trackCount);
	nodep::DWORD MakeMarkMem(bool ignoresMemory, const RiverAddress & mem, RiverInstruction *& rMainOut, nodep::DWORD & instrCount, RiverInstruction *& rTrackOut, nodep::DWORD & trackCount);

	nodep::DWORD SaveAddrValue(const RiverAddress &mem, RiverInstruction *&rMainOut, nodep::DWORD &instrCount);

	//nodep::DWORD MakePreTrackMem(const RiverAddress &mem, nodep::WORD specifiers, nodep::DWORD addrOffset, RiverInstruction *&rMainOut, nodep::DWORD &instrCount);
	//void MakeTrackMem(const RiverAddress &mem, nodep::WORD specifiers, nodep::DWORD addrOffset, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);
	
	
	//nodep::DWORD MakeTrackAddress(nodep::WORD specifiers, const RiverOperand &op, nodep::BYTE optype, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount, nodep::DWORD &valuesOut);

	//void MakeMarkMem(const RiverAddress &mem, nodep::WORD specifiers, nodep::DWORD addrOffset, nodep::DWORD valueOffset, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);
	//void MakeSkipMem(const RiverAddress &mem, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);
	
	/*  */
	nodep::DWORD MakeTrackOp(nodep::DWORD opIdx, const nodep::BYTE type, const RiverOperand &op, nodep::WORD specifiers, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);
	nodep::DWORD MakeMarkOp(const nodep::BYTE type, nodep::WORD specifiers, const RiverOperand &op, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);

	void MakeCallSymbolic(const RiverInstruction &rIn, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount);

	/* Translators */
	void TranslateUnk(const RiverInstruction &rIn, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount, nodep::DWORD dwTranslationFlags);
	void TranslateDefault(const RiverInstruction &rIn, RiverInstruction *&rMainOut, nodep::DWORD &instrCount, RiverInstruction *&rTrackOut, nodep::DWORD &trackCount, nodep::DWORD dwTranslationFlags);
};


#endif

```

`revtracer/Tracking.cpp`:

```cpp
#include "Tracking.h"
#include "common.h"

#define PRINT_RUNTIME_TRACKING	PRINT_INFO | PRINT_RUNTIME | PRINT_TRACKING

namespace rev {
#ifndef _NO_TRACK_CALLBACKS_
	nodep::DWORD __stdcall TrackAddr(void *pEnv, nodep::DWORD dwAddr, nodep::DWORD segSel) {
		nodep::DWORD ret = ((::ExecutionEnvironment *)pEnv)->ac.Get(dwAddr + revtracerConfig.segmentOffsets[segSel & 0xFFFF]);
		
		TRACKING_PRINT(PRINT_RUNTIME_TRACKING, "TrackAddr 0x%08x => 0x%08X\n", dwAddr + revtracerConfig.segmentOffsets[segSel & 0xFFFF], ret);

		if (0 != ret) {
			revtracerImports.trackCallback(ret, dwAddr, segSel);
		}

		return ret;
	}

	nodep::DWORD __stdcall MarkAddr(void *pEnv, nodep::DWORD dwAddr, nodep::DWORD value, nodep::DWORD segSel) {
		TRACKING_PRINT(PRINT_RUNTIME_TRACKING, "MarkAddr 0x%08x <= %d\n", dwAddr + revtracerConfig.segmentOffsets[segSel & 0xFFFF], value);
		nodep::DWORD ret = ((::ExecutionEnvironment *)pEnv)->ac.Set(dwAddr + revtracerConfig.segmentOffsets[segSel & 0xFFFF], value);

		if (0 != ret) {
			revtracerImports.markCallback(ret, value, dwAddr, segSel);
		}

		return ret;
	}
#else

	nodep::DWORD __stdcall TrackAddr(void *pEnv, nodep::DWORD dwAddr, nodep::DWORD segSel) {
		return ((::ExecutionEnvironment *)pEnv)->ac.Get(dwAddr);
	}

	nodep::DWORD __stdcall MarkAddr(void *pEnv, nodep::DWORD dwAddr, nodep::DWORD value, nodep::DWORD segSel) {
		return ((::ExecutionEnvironment *)pEnv)->ac.Set(dwAddr, value);
	}

#endif
};

```

`revtracer/Tracking.h`:

```h
#ifndef _TRACKING_H_
#define _TRACKING_H_

#include "../CommonCrossPlatform/BasicTypes.h"
#include "execenv.h"

namespace rev {
	//TrackingTable<Temp, 128> trItem;

	nodep::DWORD __stdcall TrackAddr(void *pEnv, nodep::DWORD dwAddr, nodep::DWORD segSel);
	nodep::DWORD __stdcall MarkAddr(void *pEnv, nodep::DWORD dwAddr, nodep::DWORD value, nodep::DWORD segSel);
		
};

#endif



```

`revtracer/TrackingX86Assembler.cpp`:

```cpp
#include "TrackingX86Assembler.h"

#include "X86AssemblerFuncs.h"
#include "mm.h"

using namespace rev;

extern nodep::DWORD dwAddressTrackHandler;
extern nodep::DWORD dwAddressMarkHandler;
extern nodep::DWORD dwSymbolicHandler;

void TrackingX86Assembler::AssembleTrackFlag(nodep::DWORD testFlags, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE trackFlagInstr[] = { 0x0B, 0x3D, 0x00, 0x00, 0x00, 0x00 };

	for (nodep::BYTE c = 0, m = 1; m < RIVER_SPEC_FLAG_EXT; ++c, m <<= 1) {
		if (m & testFlags) {
			rev_memcpy(px86.cursor, trackFlagInstr, sizeof(trackFlagInstr));
			*(nodep::DWORD *)(&px86.cursor[0x02]) = (nodep::DWORD)&runtime->taintedFlags[c];
			px86.cursor += sizeof(trackFlagInstr);
			instrCounter++;
		}
	}
}

void TrackingX86Assembler::AssembleMarkFlag(nodep::DWORD modFlags, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	// mov [offset], edx 0x89, 0x15, 0x00, 0x00, 0x00, 0x00
	// TODO: implement register renaming and overlapping registers
	const nodep::BYTE markFlagInstr[] = { 0x89, 0x3D, 0x00, 0x00, 0x00, 0x00 };

	for (nodep::BYTE c = 0, m = 1; m < RIVER_SPEC_FLAG_EXT; ++c, m <<= 1) {
		if (m & modFlags) {
			rev_memcpy(px86.cursor, markFlagInstr, sizeof(markFlagInstr));
			*(nodep::DWORD *)(&px86.cursor[0x02]) = (nodep::DWORD)&runtime->taintedFlags[c];
			px86.cursor += sizeof(markFlagInstr);
			instrCounter++;
		}
	}
}

void TrackingX86Assembler::AssembleTrackRegister(const RiverRegister &reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	// or edi, [offset] 0x0B, 0x15, 0x00, 0x00, 0x00, 0x00
	// TODO: implement register renaming, and overlapping registers
	const nodep::BYTE trackRegInstr[] = { 0x0B, 0x3D, 0x00, 0x00, 0x00, 0x00 };

	rev_memcpy(px86.cursor, trackRegInstr, sizeof(trackRegInstr));
	*(nodep::DWORD *)(&px86.cursor[0x02]) = (nodep::DWORD)&runtime->taintedRegisters[GetFundamentalRegister(reg.name)];
	px86.cursor += sizeof(trackRegInstr);
	instrCounter++;
}

void TrackingX86Assembler::AssembleMarkRegister(const RiverRegister &reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	// mov [offset], edx 0x89, 0x15, 0x00, 0x00, 0x00, 0x00
	// TODO: implement register renaming and overlapping registers
	const nodep::BYTE markRegInstr[] = { 0x89, 0x3D, 0x00, 0x00, 0x00, 0x00 };

	rev_memcpy(px86.cursor, markRegInstr, sizeof(markRegInstr));
	*(nodep::DWORD *)(&px86.cursor[0x02]) = (nodep::DWORD)&runtime->taintedRegisters[GetFundamentalRegister(reg.name)];
	px86.cursor += sizeof(markRegInstr);
	instrCounter++;
}

void TrackingX86Assembler::AssembleTrackMemory(const RiverAddress *addr, nodep::BYTE offset, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE trackMemInstr[] = {
		0xFF, 0x76, 0x00,								// 0x00 - push [esi + 0x00] - effective address
		0xFF, 0x35, 0x00, 0x00, 0x00, 0x00,				// 0x03 - push [address_hash]
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,				// 0x09 - call [dwAddressTrackHandler]
		0x09, 0xC7										// 0x0F - or edi, eax
	};

	const nodep::BYTE trackSegInstr[] = {
		0xFF, 0x76, 0x00								// 0x00 - push [esi + 0x00] - segment index
	};

	const nodep::BYTE trackImmInstr[] = {
		0x6A, 0x00										// 0x00 - push 0 - no segment
	};

	if (addr->HasSegment()) {
		rev_memcpy(px86.cursor, trackSegInstr, sizeof(trackSegInstr));
		px86.cursor[0x02] = ~((offset - 1) << 2) + 1;
		px86.cursor += sizeof(trackSegInstr);
	} else {
		rev_memcpy(px86.cursor, trackImmInstr, sizeof(trackImmInstr));
		px86.cursor += sizeof(trackImmInstr);
	}

	rev_memcpy(px86.cursor, trackMemInstr, sizeof(trackMemInstr));
	px86.cursor[0x02] = ~(offset << 2) + 1;
	*(nodep::DWORD *)(&px86.cursor[0x05]) = (nodep::DWORD)&runtime->taintedAddresses;
	*(nodep::DWORD *)(&px86.cursor[0x0B]) = (nodep::DWORD)&dwAddressTrackHandler;
	px86.cursor += sizeof(trackMemInstr);
	instrCounter += 5;
}

void TrackingX86Assembler::AssembleTrackAddress(const RiverAddress *addr, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	if ((0 == addr->type) || (addr->type & RIVER_ADDR_BASE)) {
		AssembleTrackRegister(addr->base, px86, pFlags, instrCounter);
	}

	if (addr->type & RIVER_ADDR_INDEX) {
		AssembleTrackRegister(addr->index, px86, pFlags, instrCounter);
	}
}

void TrackingX86Assembler::AssembleMarkMemory(const RiverAddress *addr, nodep::BYTE offset, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE markMemInstr[] = { 
		0x57,											// 0x00 - push edi
		0xFF, 0x76,	0x00,								// 0x01 - push [esi - offset] - effective address
		0xFF, 0x35, 0x00, 0x00, 0x00, 0x00,				// 0x04 - push [address_hash]
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00				// 0x0A - call [dwAddressMarkHandler]
	};

	const nodep::BYTE markSegInstr[] = {
		0xFF, 0x76, 0x00								// 0x00 - push [esi + 0x00] - segment index
	};

	const nodep::BYTE markImmInstr[] = {
		0x6A, 0x00										// 0x00 - push 0 - no segment
	};

	if (addr->HasSegment()) {
		rev_memcpy(px86.cursor, markSegInstr, sizeof(markSegInstr));
		px86.cursor[0x02] = ~((offset - 1) << 2) + 1;
		px86.cursor += sizeof(markSegInstr);
	}
	else {
		rev_memcpy(px86.cursor, markImmInstr, sizeof(markImmInstr));
		px86.cursor += sizeof(markImmInstr);
	}

	rev_memcpy(px86.cursor, markMemInstr, sizeof(markMemInstr));
	*(nodep::BYTE *)(&px86.cursor[0x03]) = (nodep::BYTE)(~(offset << 2) + 1);
	*(nodep::DWORD *)(&px86.cursor[0x06]) = (nodep::DWORD)&runtime->taintedAddresses;
	*(nodep::DWORD *)(&px86.cursor[0x0C]) = (nodep::DWORD)&dwAddressMarkHandler;
	px86.cursor += sizeof(markMemInstr);
	instrCounter += 4;
}

void TrackingX86Assembler::AssembleAdjustESI(nodep::BYTE count, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE adjustESI[] = {
		0x8D, 0x76, 0x00
	};

	rev_memcpy(px86.cursor, adjustESI, sizeof(adjustESI));
	*(nodep::BYTE *)(&px86.cursor[0x02]) = (nodep::BYTE) (~(count << 2) + 1);
	px86.cursor += sizeof(adjustESI);
	instrCounter += 4;
}

void TrackingX86Assembler::AssembleSetZero(nodep::BYTE reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	reg &= 0x07;
	px86.cursor[0] = 0x31;
	px86.cursor[1] = 0xC0 | (reg << 3) | reg;
	px86.cursor += 2;
	instrCounter += 1;
}

nodep::DWORD TrackingX86Assembler::GetOperandTrackSize(const RiverInstruction &ri, nodep::BYTE idx) {
	switch (RIVER_OPTYPE(ri.opTypes[idx])) {
		case RIVER_OPTYPE_IMM :
			return 0;
		case RIVER_OPTYPE_REG :
			return 1;
		case RIVER_OPTYPE_MEM :
			if (ri.specifiers & RIVER_SPEC_IGNORES_MEMORY) {
				return 1;
			}
			return 2;
		default :
			DEBUG_BREAK;
			return 0;
	}
}

void TrackingX86Assembler::AssembleUnmark(RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE unmarkMem[] = {
		0x56,											// 0x00 - push esi
		0x50,											// 0x01 - push eax
		0x57,											// 0x02 - push edi
		0xFF, 0x35, 0x00, 0x00, 0x00, 0x00,				// 0x03 - push [address_hash]
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00				// 0x09 - call [dwAddressMarkHandler]
	};

	rev_memcpy(px86.cursor, unmarkMem, sizeof(unmarkMem));
	*(nodep::DWORD *)(&px86.cursor[0x05]) = (nodep::DWORD)&runtime->taintedAddresses;
	*(nodep::DWORD *)(&px86.cursor[0x0B]) = (nodep::DWORD)&dwAddressMarkHandler;
	px86.cursor += sizeof(unmarkMem);
	instrCounter += 3;
}

void TrackingX86Assembler::AssembleSymbolicCall(nodep::DWORD address, nodep::BYTE index, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	const nodep::BYTE symCall[] = {
		0x74, 0x11,										// 0x00 - jz <over_this_block>
		0x68, 0x00, 0x00, 0x00, 0x00,					// 0x02 - push instructionAddress
		0x56,											// 0x07 - push esi - data offset
		0x68, 0x00, 0x00, 0x00, 0x00,					// 0x08	- push runtimeContext (or env)
		0xFF, 0x15, 0x00, 0x00, 0x00, 0x00				// 0x0D - call [dwSymbolicHandler]
	};

	rev_memcpy(px86.cursor, symCall, sizeof(symCall));
	*(nodep::DWORD *)(&px86.cursor[0x03]) = address;
	*(nodep::DWORD *)(&px86.cursor[0x09]) = (nodep::DWORD)runtime;
	*(nodep::DWORD *)(&px86.cursor[0x0F]) = (nodep::DWORD)&revtracerImports.symbolicHandler;
	px86.cursor += sizeof(symCall);
	instrCounter += 5;
}

void TrackingX86Assembler::SetTranslationFlags(nodep::DWORD dwFlags) {
	dwTranslationFlags = dwFlags;
}

bool TrackingX86Assembler::Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType) {
	if (0 == (RIVER_SPEC_FLAG_EXT & ri.modifiers)) {
		switch (ri.opCode) {
			case 0x50 :
				AssembleTrackRegister(ri.operands[0].asRegister, px86, pFlags, instrCounter);
				break;

			case 0x58 :
				if (0 == (TRACER_FEATURE_ADVANCED_TRACKING & dwTranslationFlags)) {
					AssembleMarkRegister(ri.operands[0].asRegister, px86, pFlags, instrCounter);
				}
				break;

			case 0x8D :
				AssembleTrackAddress(ri.operands[0].asAddress, px86, pFlags, instrCounter);
				break;

			case 0x8F :
				if (ASSEMBLER_DIR_BACKWARD & outputType) {
					AssembleUnmark(px86, pFlags, instrCounter);
				}
				else {
					if (0 == (TRACER_FEATURE_ADVANCED_TRACKING & dwTranslationFlags)) {
						AssembleMarkMemory(ri.operands[0].asAddress, ri.operands[1].asImm8, px86, pFlags, instrCounter);
					}
				}
				break;

			case 0x9C :
				AssembleTrackFlag(ri.operands[0].asImm8, px86, pFlags, instrCounter);
				break;

			case 0x9D :
				if (0 == (TRACER_FEATURE_ADVANCED_TRACKING & dwTranslationFlags)) {
					AssembleMarkFlag(ri.operands[0].asImm8, px86, pFlags, instrCounter);
				}
				break;

			case 0xB8 : // used as tracking initialization (mov eax, 0)
				if (0 == ri.operands[1].asImm32) {
					AssembleSetZero(ri.operands[0].asRegister.name, px86, pFlags, instrCounter);
				} else {
					::AssemblePlusRegInstr(ri, px86, pFlags, instrCounter);
					::AssembleImmOp<1, RIVER_OPSIZE_32>(ri, px86);
				}
				break;

			case 0xC3 :
				AssembleAdjustESI(ri.operands[0].asImm8, px86, pFlags, instrCounter);
				break;

			case 0xFF :
				if (6 == ri.subOpCode) {
					AssembleTrackMemory(ri.operands[0].asAddress, ri.operands[1].asImm8, px86, pFlags, instrCounter);
				} else {
					DEBUG_BREAK;
				}
				break;

			case 0xE8 :
				AssembleSymbolicCall(ri.operands[0].asImm32, ri.operands[1].asImm8, px86, pFlags, instrCounter);
				break;
			default :
				DEBUG_BREAK;
		}

		return true;
	} else {
		return true;
	}
}

```

`revtracer/TrackingX86Assembler.h`:

```h
#ifndef _TRACKING_X86_ASSEMBLER_
#define _TRACKING_X86_ASSEMBLER_

#include "GenericX86Assembler.h"

class TrackingX86Assembler : public GenericX86Assembler {
private :
	void AssembleTrackFlag(nodep::DWORD testFlags, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleMarkFlag(nodep::DWORD testFlags, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleTrackRegister(const RiverRegister &reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleMarkRegister(const RiverRegister &reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleTrackMemory(const RiverAddress *addr, nodep::BYTE offset, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleMarkMemory(const RiverAddress *addr, nodep::BYTE offset, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleTrackAddress(const RiverAddress *addr, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleUnmark(RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleAdjustESI(nodep::BYTE count, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
	void AssembleSetZero(nodep::BYTE reg, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	void AssembleSymbolicCall(nodep::DWORD address, nodep::BYTE index, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

	nodep::DWORD GetOperandTrackSize(const RiverInstruction &ri, nodep::BYTE idx);

	nodep::DWORD dwTranslationFlags;
public :
	void SetTranslationFlags(nodep::DWORD dwFlags);

	virtual bool Translate(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType);
};


#endif

```

`revtracer/TranslatorUtil.cpp`:

```cpp
#include "TranslatorUtil.h"
#include "CodeGen.h"

void CopyInstruction(RiverCodeGen *codegen, RiverInstruction &rOut, const RiverInstruction &rIn) {
	rev_memcpy(&rOut, &rIn, sizeof(rOut));

	for (int i = 0; i < 4; ++i) {
		if (RIVER_OPTYPE_MEM == RIVER_OPTYPE(rIn.opTypes[i])) {
			rOut.operands[i].asAddress = codegen->CloneAddress(*rIn.operands[i].asAddress, rIn.modifiers);
		}
	}
}

```

`revtracer/TranslatorUtil.h`:

```h
#ifndef _TRANSLATOR_UTIL_
#define _TRANSLATOR_UTIL_

#include "river.h"

void CopyInstruction(RiverCodeGen *codegen, RiverInstruction &rOut, const RiverInstruction &rIn);
#endif

```

`revtracer/VBoxSnapshotDll.h`:

```h
/* $Id: VBoxHook.h $ */
/** @file
 * VBoxHook -- Global windows hook dll.
 */

/*
 * Copyright (C) 2006-2013 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */
#ifndef ___winnt_include_VBoxSnapshotDll_h
#define ___winnt_include_VBoxSnapshotDll_h

#include <Windows.h>
#include <stdint.h>

#define VBOXSNAPSHOTDLL_DLL_NAME              "VBoxSnapshotDll.dll"

extern "C" uint64_t BDTakeSnapshot();
extern "C" uint64_t BDRestoreSnapshot();
extern "C" BOOL BDSnapshotInit();

typedef uint64_t (*BDTakeSnapshotType)();
typedef uint64_t (*BDRestoreSnapshotType)();
typedef BOOL (*BDSnapshotInitType)();

// This values are extracted from the HostServices/GuestSnapshot/service.cpp file
#define BD_SNAPSHOT_FAIL 0
#define BD_SNAPSHOT_TAKE 1
#define BD_SNAPSHOT_RESTORE 2

#endif
```

`revtracer/X86Assembler.cpp`:

```cpp
#include "revtracer.h"
#include "common.h"

#include "X86Assembler.h"

#include "mm.h"

using namespace rev;

#define FLAG_GENERATE_RIVER_xSP		0x0F
/*#define FLAG_GENERATE_RIVER_xSP_xAX	0x01
#define FLAG_GENERATE_RIVER_xSP_xCX	0x02
#define FLAG_GENERATE_RIVER_xSP_xDX	0x04
#define FLAG_GENERATE_RIVER_xSP_xBX	0x08*/

#define FLAG_SKIP_METAOP			0x10
//#define FLAG_GENERATE_RIVER			0x20

static void FixRiverEspOp(nodep::BYTE opType, RiverOperand *op, nodep::BYTE repReg) {
	switch (RIVER_OPTYPE(opType)) {
	case RIVER_OPTYPE_IMM:
	case RIVER_OPTYPE_NONE:
		break;
	case RIVER_OPTYPE_REG:
		if (op->asRegister.name == RIVER_REG_xSP) {
			op->asRegister.versioned = repReg;
		}
		break;
	case RIVER_OPTYPE_MEM:
		break;
	default:
		DEBUG_BREAK;
	}
}

const RiverInstruction *FixRiverEspInstruction(const RiverInstruction &rIn, RiverInstruction *rTmp, RiverAddress *aTmp) {
	if (rIn.family & RIVER_FAMILY_FLAG_ORIG_xSP) {
		nodep::BYTE repReg = rIn.GetUnusedRegister();

		rev_memcpy(rTmp, &rIn, sizeof(*rTmp));
		for (nodep::BYTE i = 0; i < 4; ++i) {
			if (rIn.opTypes[i] != RIVER_OPTYPE_NONE) {
				if (RIVER_OPTYPE(rIn.opTypes[i]) == RIVER_OPTYPE_MEM) {
					rTmp->operands[i].asAddress = aTmp;
					rev_memcpy(aTmp, rIn.operands[i].asAddress, sizeof(*aTmp));
				}
				FixRiverEspOp(rTmp->opTypes[i], &rTmp->operands[i], repReg);
			}
		}

		return rTmp;
	}
	else {
		return &rIn;
	}
}

void X86Assembler::SwitchToRiver(nodep::BYTE *&px86, nodep::DWORD &instrCounter) {
	static const unsigned char code[] = { 0x87, 0x25, 0x00, 0x00, 0x00, 0x00 };			// 0x00 - xchg esp, large ds:<dwVirtualStack>}

	rev_memcpy(px86, code, sizeof(code));
	*(unsigned int *)(&(px86[0x02])) = (unsigned int)&runtime->execBuff;

	px86 += sizeof(code);
	instrCounter++;
}

void X86Assembler::SwitchToRiverEsp(nodep::BYTE *&px86, nodep::DWORD &instrCounter, nodep::BYTE repReg) {
	static const unsigned char code[] = { 0x87, 0x05, 0x00, 0x00, 0x00, 0x00 };			// 0x00 - xchg eax, large ds:<dwVirtualStack>}

	rev_memcpy(px86, code, sizeof(code));
	px86[0x01] |= (repReg & 0x03); // choose the acording replacement register
	*(unsigned int *)(&(px86[0x02])) = (unsigned int)&runtime->execBuff;

	px86 += sizeof(code);
	instrCounter++;
}

void X86Assembler::EndRiverConversion(RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter) {
	if (RIVER_FAMILY_NATIVE != currentFamily) {
		nodep::DWORD currentStack;

		switch (currentFamily)	{
			case RIVER_FAMILY_NATIVE:
				break;
			case RIVER_FAMILY_RIVER:
				currentStack = (nodep::DWORD)&runtime->execBuff;
				break;
			case RIVER_FAMILY_PRETRACK:
				currentStack = (nodep::DWORD)&runtime->trackBuff;
				break;
			default:
				DEBUG_BREAK;
				break;
		}

		SwitchToNative(px86, currentFamily, repReg, instrCounter, currentStack);
	}
}

bool X86Assembler::TranslateNative(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType) {
	// skip ignored instructions
	if (ri.family & RIVER_FAMILY_FLAG_IGNORE) {
		return true;
	}

	//if (/*(RIVER_FAMILY(ri.family) == RIVER_FAMILY_TRACK) || */(RIVER_FAMILY(ri.family) == RIVER_FAMILY_PRETRACK)) {
	//	return true;
	//}

	/*if ((RIVER_FAMILY_RIVER == RIVER_FAMILY(ri.family)) && (0x10 & pFlags)) {
		return true;
	}*/

	// when generating fwcode skip meta instructions
	if ((RIVER_FAMILY(ri.family) == RIVER_FAMILY_PREMETA) || (RIVER_FAMILY(ri.family) == RIVER_FAMILY_POSTMETA)) {
		if (pFlags & FLAG_SKIP_METAOP) {
			return true;
		}
	}

	GenerateTransitionsNative(ri, px86, pFlags, currentFamily, repReg, instrCounter);
	GeneratePrefixes(ri, px86.cursor);

	RiverInstruction rInstr;
	RiverAddress32 rAddr;

	const RiverInstruction *rOut = FixRiverEspInstruction(ri, &rInstr, &rAddr);

	nodep::DWORD dwTable = 0;

	/*if (rOut->modifiers & RIVER_MODIFIER_EXT) {
		*px86.cursor = 0x0F;
		px86.cursor++;
		dwTable = 1;
	}*/

	//(this->*assembleOpcodes[dwTable][rOut->opCode])(*rOut, px86, pFlags, instrCounter);
	//(this->*assembleOperands[dwTable][rOut->opCode])(*rOut, px86);

	GenericX86Assembler *casm = &nAsm;

	if (RIVER_FAMILY(rOut->family) == RIVER_FAMILY_RIVER) {
		casm = &rAsm;
	} else if (RIVER_FAMILY(rOut->family) == RIVER_FAMILY_REP) {
		casm = &rrAsm;
	} else if (RIVER_FAMILY(rOut->family) == RIVER_FAMILY_TRACK) {
		casm = &tAsm;
	} else if (RIVER_FAMILY(rOut->family) == RIVER_FAMILY_PRETRACK) {
		casm = &ptAsm;
	} else if (RIVER_FAMILY(rOut->family) == RIVER_FAMILY_RIVER_TRACK) {
		casm = &rtAsm;
	} else if (RIVER_FAMILY(rOut->family) != RIVER_FAMILY_NATIVE) {
		DEBUG_BREAK;
	}

	casm->Translate(*rOut, px86, pFlags, currentFamily, repReg, instrCounter, outputType);


	return true;
}

bool X86Assembler::TranslateTracking(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType) {
	if (RIVER_FAMILY_FLAG_IGNORE & ri.family) {
		return true;
	}

	GenerateTransitionsTracking(ri, px86, pFlags, currentFamily, repReg, instrCounter);
	GeneratePrefixes(ri, px86.cursor);
	
	GenericX86Assembler *casm = &tAsm;

	if (RIVER_FAMILY(ri.family) == RIVER_FAMILY_TRACK) {
		casm = &tAsm;
	} else if (RIVER_FAMILY(ri.family) == RIVER_FAMILY_RIVER_TRACK) {
		casm = &rtAsm;
	} else {
		DEBUG_BREAK;
	}
	
	casm->Translate(ri, px86, pFlags, currentFamily, repReg, instrCounter, outputType);

	return true;
}

void X86Assembler::AssembleTrackingEnter(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter) {
	static const nodep::BYTE trackingEnter[] = {
		0x55,								// 0x00 - push ebp
		0x89, 0xE5,							// 0x01 - mov ebp, esp
		0x57,								// 0x03 - push edi
		0x56,								// 0x04 - push esi
		0x8B, 0x75, 0x08					// 0x05 - mov esi, [ebp + 8] ; esi <- trackbuffer
	};

	rev_memcpy(px86.cursor, trackingEnter, sizeof(trackingEnter));
	px86.cursor += sizeof(trackingEnter);

	instrCounter += 5;
}

void X86Assembler::AssembleTrackingLeave(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter) {
	static const nodep::BYTE trackingLeave[] = {
		0x5E,								// 0x00 - pop esi
		0x5F,								// 0x01 - pop edi
		0x89, 0xEC,							// 0x02 - mov esp, ebp
		0x5D,								// 0x04 - pop ebp
		0xC3								// 0x05 - ret
	};

	rev_memcpy(px86.cursor, trackingLeave, sizeof(trackingLeave));
	px86.cursor += sizeof(trackingLeave);

	instrCounter += 5;
}

bool X86Assembler::Assemble(RiverInstruction *pRiver, nodep::DWORD dwInstrCount, RelocableCodeBuffer &px86, nodep::DWORD flg, nodep::DWORD &instrCounter, nodep::DWORD &byteCounter, nodep::BYTE outputType) {
	nodep::BYTE *pTmp = px86.cursor, *pAux = px86.cursor;
	nodep::DWORD pFlags = flg;
	nodep::BYTE currentFamily = (outputType & ASSEMBLER_CODE_TRACKING) ? RIVER_FAMILY_TRACK : RIVER_FAMILY_NATIVE;
	nodep::BYTE repReg = 0;

	static const char headers[][35] = {
		" river to x86 (native forward) ===",
		" river to x86 (native backward) ==",
		" river to x86 (tracking forward) =",
		" river to x86 (tracking backward) "
	};

	static const nodep::DWORD masks[] = {
		PRINT_NATIVE | PRINT_FORWARD,
		PRINT_NATIVE | PRINT_BACKWARD,
		PRINT_TRACKING | PRINT_FORWARD,
		PRINT_TRACKING | PRINT_BACKWARD
	};

	nodep::DWORD printMask = PRINT_INFO | PRINT_ASSEMBLY | masks[outputType];

	TRANSLATE_PRINT(printMask, "=%s============================================\n", headers[outputType]);

	if (ASSEMBLER_CODE_TRACKING & outputType) {
		AssembleTrackingEnter(px86, instrCounter);
		for (; pTmp < px86.cursor; ++pTmp) {
			TRANSLATE_PRINT(printMask, "%02x ", *pTmp);
		}
		TRANSLATE_PRINT(printMask, "\n");
	}

	for (nodep::DWORD i = 0; i < dwInstrCount; ++i) {
		pTmp = px86.cursor;

		if (ASSEMBLER_CODE_TRACKING & outputType) {
			if (!TranslateTracking(pRiver[i], px86, pFlags, currentFamily, repReg, instrCounter, outputType)) {
				return false;
			}
		} else {
			if (!TranslateNative(pRiver[i], px86, pFlags, currentFamily, repReg, instrCounter, outputType)) {
				return false;
			}
		}

		// some instructions (repinit/repfini) are fixed after
		// this print so the jump offsets could be 00 00 00 00
		//  in logs.
		for (; pTmp < px86.cursor; ++pTmp) {
			TRANSLATE_PRINT(printMask, "%02x ", *pTmp);
		}
		TRANSLATE_PRINT(printMask, "\n");
	}

	if (ASSEMBLER_CODE_TRACKING & outputType) {
		if (RIVER_FAMILY(currentFamily) == RIVER_FAMILY_RIVER_TRACK) {
			SwitchToStack(px86, instrCounter, (nodep::DWORD)&runtime->trackStack);
			currentFamily = RIVER_FAMILY_TRACK;
		}
		AssembleTrackingLeave(px86, instrCounter);
		for (; pTmp < px86.cursor; ++pTmp) {
			TRANSLATE_PRINT(printMask, "%02x ", *pTmp);
		}
		TRANSLATE_PRINT(printMask, "\n");
	} else {
		EndRiverConversion(px86, pFlags, currentFamily, repReg, instrCounter);
		for (; pTmp < px86.cursor; ++pTmp) {
			TRANSLATE_PRINT(printMask, "%02x ", *pTmp);
		}
		TRANSLATE_PRINT(printMask, "\n");
	}

	TRANSLATE_PRINT(printMask, "===============================================================================\n");
	byteCounter = px86.cursor - pAux;
	return true;
}

void X86Assembler::SwitchEspWithReg(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter, nodep::BYTE repReg, nodep::DWORD dwStack) {
	static const nodep::BYTE code[] = { 0x87, 0x05, 0x00, 0x00, 0x00, 0x00 };			// 0x00 - xchg eax, large ds:<dwVirtualStack>}

	rev_memcpy(px86.cursor, code, sizeof(code));
	px86.cursor[0x01] |= (repReg & 0x03); // choose the acording replacement register
	*(nodep::DWORD *)(&px86.cursor[0x02]) = dwStack;

	px86.cursor += sizeof(code);
	instrCounter++;
}

void X86Assembler::SwitchToStack(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter, nodep::DWORD dwStack) {
	static const unsigned char code[] = { 0x87, 0x25, 0x00, 0x00, 0x00, 0x00 };			// 0x00 - xchg esp, large ds:<dwVirtualStack>}

	rev_memcpy(px86.cursor, code, sizeof(code));
	*(nodep::DWORD *)(&px86.cursor[0x02]) = dwStack;

	px86.cursor += sizeof(code);
	instrCounter++;
}

bool X86Assembler::SwitchToNative(RelocableCodeBuffer &px86, nodep::BYTE &currentFamily, nodep::BYTE repReg, nodep::DWORD &instrCounter, nodep::DWORD dwStack) {
	if (currentFamily & RIVER_FAMILY_FLAG_ORIG_xSP) {
		SwitchEspWithReg(px86, instrCounter, repReg, dwStack);
		currentFamily &= ~RIVER_FAMILY_FLAG_ORIG_xSP;
	}

	switch (RIVER_FAMILY(currentFamily)) {
		case RIVER_FAMILY_NATIVE : 
			break;
		case RIVER_FAMILY_RIVER :
			SwitchToStack(px86, instrCounter, (nodep::DWORD)&runtime->execBuff);
			break;
		case RIVER_FAMILY_PRETRACK :
			SwitchToStack(px86, instrCounter, (nodep::DWORD)&runtime->trackBuff);
			break;
		default:
			DEBUG_BREAK;
			break;
	}

	currentFamily = RIVER_FAMILY_NATIVE;
	return true;
}

bool X86Assembler::GenerateTransitionsNative(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter) {
	nodep::BYTE cf = RIVER_FAMILY(currentFamily);
	nodep::BYTE tf = RIVER_FAMILY(ri.family);

	if (cf == RIVER_FAMILY_REP)
		cf = RIVER_FAMILY_NATIVE;

	if (tf == RIVER_FAMILY_REP)
		tf = RIVER_FAMILY_NATIVE;

	nodep::DWORD currentStack = 0;

	switch (cf)	{
		case RIVER_FAMILY_NATIVE:
			break;
		case RIVER_FAMILY_RIVER:
			currentStack = (nodep::DWORD)&runtime->execBuff;
			break;
		case RIVER_FAMILY_PRETRACK:
			currentStack = (nodep::DWORD)&runtime->trackBuff;
			break;
		default:
			DEBUG_BREAK;
			break;
	}

	if (cf != tf) {
		SwitchToNative(px86, currentFamily, repReg, instrCounter, currentStack);
		cf = RIVER_FAMILY(currentFamily);
	}

	if (cf != tf) {
		switch (tf) {
			case RIVER_FAMILY_NATIVE :
				break;
			case RIVER_FAMILY_RIVER :
				SwitchToStack(px86, instrCounter, (nodep::DWORD)&runtime->execBuff);
				currentFamily = RIVER_FAMILY_RIVER;
				currentStack = (nodep::DWORD)&runtime->execBuff;
				break;
			case RIVER_FAMILY_PRETRACK :
				SwitchToStack(px86, instrCounter, (nodep::DWORD)&runtime->trackBuff);
				currentFamily = RIVER_FAMILY_PRETRACK;
				currentStack = (nodep::DWORD)&runtime->trackBuff;
				break;
			case RIVER_FAMILY_RIVER_TRACK :
				SwitchToStack(px86, instrCounter, (nodep::DWORD)&runtime->trackStack);
				currentFamily = RIVER_FAMILY_RIVER_TRACK;
				currentStack = (nodep::DWORD)&runtime->trackStack;
			default:
				DEBUG_BREAK;
				break;
		}
	}

	// now both current and target families have the same value
	if (RIVER_FAMILY_FLAG_ORIG_xSP & currentFamily) { // current family preservers ESP
		if (RIVER_FAMILY_FLAG_ORIG_xSP & ri.family) { // target family preservers ESP
			if (0 == ((1 << repReg) & ri.unusedRegisters)) { // switch repReg
				SwitchEspWithReg(px86, instrCounter, repReg, currentStack);
				repReg = ri.GetUnusedRegister();
				SwitchEspWithReg(px86, instrCounter, repReg, currentStack);
			}
		} else {
			SwitchEspWithReg(px86, instrCounter, repReg, currentStack);
			currentFamily &= ~RIVER_FAMILY_FLAG_ORIG_xSP;
		}
	} else { // current family doesn't preserve ESP
		if (RIVER_FAMILY_FLAG_ORIG_xSP & ri.family) {
			SwitchEspWithReg(px86, instrCounter, repReg, currentStack);
			currentFamily |= RIVER_FAMILY_FLAG_ORIG_xSP;
		}
	}

	return true;
}

bool X86Assembler::GenerateTransitionsTracking(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter) {
	nodep::BYTE cf = RIVER_FAMILY(currentFamily);
	nodep::BYTE tf = RIVER_FAMILY(ri.family);

	if ((tf != RIVER_FAMILY_RIVER_TRACK) && (tf != RIVER_FAMILY_TRACK)) {
		DEBUG_BREAK;
	}

	if (cf != tf) {
		SwitchToStack(px86, instrCounter, (nodep::DWORD)&runtime->trackStack);
		currentFamily = ri.family;
	}

	return true;
}

bool X86Assembler::Init(RiverRuntime *runtime, nodep::DWORD dwTranslationFlags) {
	this->runtime = runtime;

	nAsm.Init(runtime);
	rAsm.Init(runtime);
	rrAsm.Init(runtime);
	ptAsm.Init(runtime);
	tAsm.Init(runtime);
	tAsm.SetTranslationFlags(dwTranslationFlags);
	rtAsm.Init(runtime);

	return true;
}

```

`revtracer/X86Assembler.h`:

```h
#ifndef _X86_ASSEMBLER_H
#define _X86_ASSEMBLER_H

#include "GenericX86Assembler.h"

// also include sub assemblers
#include "NativeX86Assembler.h"
#include "RiverX86Assembler.h"
#include "RiverRepAssembler.h"
#include "PreTrackingX86Assembler.h"
#include "TrackingX86Assembler.h"
#include "RiverTrackingX86Assembler.h"


class X86Assembler /*: public GenericX86Assembler*/ {
private :
	RiverRuntime *runtime;

	NativeX86Assembler nAsm;
	RiverX86Assembler rAsm;
	RiverRepAssembler rrAsm;
	PreTrackingAssembler ptAsm;
	TrackingX86Assembler tAsm;
	RiverTrackingX86Assembler rtAsm;

	void SwitchToRiver(nodep::BYTE *&px86, nodep::DWORD &instrCounter);
	void SwitchToRiverEsp(nodep::BYTE *&px86, nodep::DWORD &instrCounter, nodep::BYTE repReg);
	void EndRiverConversion(RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter);

	void SwitchEspWithReg(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter, nodep::BYTE repReg, nodep::DWORD dwStack);
	void SwitchToStack(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter, nodep::DWORD dwStack);
	bool SwitchToNative(RelocableCodeBuffer &px86, nodep::BYTE &currentFamily, nodep::BYTE repReg, nodep::DWORD &instrCounter, nodep::DWORD dwStack);

	bool GenerateTransitionsNative(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter);
	bool GenerateTransitionsTracking(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter);

	void AssembleTrackingEnter(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter);
	void AssembleTrackingLeave(RelocableCodeBuffer &px86, nodep::DWORD &instrCounter);

	//bool GenerateTransitions(const RiverInstruction &ri, nodep::BYTE *&px86, nodep::DWORD &pFlags, nodep::BYTE &repReg, nodep::DWORD &instrCounter);
	bool TranslateNative(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType);
	bool TranslateTracking(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::BYTE &currentFamily, nodep::BYTE &repReg, nodep::DWORD &instrCounter, nodep::BYTE outputType);
public :
	virtual bool Init(RiverRuntime *rt, nodep::DWORD dwTranslationFlags);

	virtual bool Assemble(RiverInstruction *pRiver, nodep::DWORD dwInstrCount, RelocableCodeBuffer &px86, nodep::DWORD flg, nodep::DWORD &instrCounter, nodep::DWORD &byteCounter, nodep::BYTE outputType);
	//bool AssembleTracking(RiverInstruction *pRiver, nodep::DWORD dwInstrCount, RelocableCodeBuffer &px86, nodep::DWORD flg, nodep::DWORD &instrCounter, nodep::DWORD &byteCounter);
};



#endif

```

`revtracer/X86AssemblerFuncs.cpp`:

```cpp
#include "X86AssemblerFuncs.h"

using namespace rev;

void AssembleUnkInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	DEBUG_BREAK;
}

void AssembleDefaultInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	*px86.cursor = ri.opCode;
	px86.cursor++;
	instrCounter++;
}

void AssemblePlusRegInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter) {
	unsigned char regName = ri.operands[0].asRegister.name & 0x07; // verify if 8 bit operand
	*px86.cursor = ri.opCode + regName;
	px86.cursor++;
	instrCounter++;
}

/* =========================================== */
/* Operand helpers                             */
/* =========================================== */

void AssembleModRMOp(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE extra) {
	ri.operands[opIdx].asAddress->EncodeTox86(px86.cursor, extra, ri.family, ri.modifiers);
}

void AssembleImmOp(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE immSize) {
	switch (immSize) {
	case RIVER_OPSIZE_8:
		*((nodep::BYTE *)px86.cursor) = ri.operands[opIdx].asImm8;
		px86.cursor++;
		break;
	case RIVER_OPSIZE_16:
		*((nodep::WORD *)px86.cursor) = (nodep::WORD)ri.operands[opIdx].asImm16;
		px86.cursor += 2;
		break;
	case RIVER_OPSIZE_32:
		if (ri.modifiers & RIVER_MODIFIER_O16) {
			*((nodep::WORD *)px86.cursor) = (nodep::WORD)ri.operands[opIdx].asImm16;
			px86.cursor += 2;
		}
		else {
			*((nodep::DWORD *)px86.cursor) = ri.operands[opIdx].asImm32;
			px86.cursor += 4;
		}
		break;
	}
}

void AssembleMoffs(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE immSize) {
	switch (immSize) {
	case RIVER_OPSIZE_8:
		*((nodep::BYTE *)px86.cursor) = ri.operands[opIdx].asAddress->disp.d8;
		px86.cursor++;
		break;
	case RIVER_OPSIZE_16:
		*((nodep::WORD *)px86.cursor) = (nodep::WORD)ri.operands[opIdx].asAddress->disp.d32;
		px86.cursor += 2;
		break;
	case RIVER_OPSIZE_32:
		*((nodep::DWORD *)px86.cursor) = ri.operands[opIdx].asAddress->disp.d32;
		px86.cursor += 4;
		break;
	}
}

/* =========================================== */
/* Operand assemblers                          */
/* =========================================== */

void AssembleUnknownOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	DEBUG_BREAK;
}

void AssembleNoOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
}

void AssembleModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(0, ri, px86, 0);
	AssembleImmOp(1, ri, px86, RIVER_OPSIZE_8);
}

void AssembleModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(0, ri, px86, 0);
	AssembleImmOp(1, ri, px86, RIVER_OPSIZE_32);
}

void AssembleRegModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	// TODO duplicated code
	nodep::BYTE reg = ri.operands[0].asRegister.name;
	if (RIVER_MODIFIER_O8 & ri.modifiers) {
		if ((RIVER_REG_SZ8_H & reg) == RIVER_REG_SZ8_H) {
			reg = GetFundamentalRegister(reg) + 4;
		} else {
			reg = GetFundamentalRegister(reg);
		}
	}
	else if (RIVER_MODIFIER_O16 & ri.modifiers) {
		reg = GetFundamentalRegister(reg);
	}
	AssembleModRMOp(1, ri, px86, reg);
}

void AssembleModRMRegOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	//handle ext bits for modRMReg and RegModRM
	// TODO duplicated code
	nodep::BYTE reg = ri.operands[1].asRegister.name;
	if (RIVER_MODIFIER_O8 & ri.modifiers) {
		if (RIVER_REG_SZ8_H & reg) {
			reg = GetFundamentalRegister(reg) + 4;
		} else {
			reg = GetFundamentalRegister(reg);
		}
	}
	else if (RIVER_MODIFIER_O16 & ri.modifiers) {
		reg = GetFundamentalRegister(reg);
	}
	AssembleModRMOp(0, ri, px86, reg);
}

void AssembleSubOpModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(0, ri, px86, ri.subOpCode);
}

void AssembleSubOpModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(0, ri, px86, ri.subOpCode);
	AssembleImmOp(1, ri, px86, RIVER_OPSIZE_8);
}

void AssembleSubOpModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(0, ri, px86, ri.subOpCode);
	AssembleImmOp(1, ri, px86, RIVER_OPSIZE_32);
}

void AssembleRegModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(1, ri, px86, ri.operands[0].asRegister.name);
	AssembleImmOp(2, ri, px86, RIVER_OPSIZE_32);
}

void AssembleRegModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(1, ri, px86, ri.operands[0].asRegister.name);
	AssembleImmOp(2, ri, px86, RIVER_OPSIZE_8);
}

void AssembleModRMRegImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(0, ri, px86, ri.operands[1].asRegister.name);
	AssembleImmOp(2, ri, px86, RIVER_OPSIZE_8);
}

```

`revtracer/X86AssemblerFuncs.h`:

```h
#ifndef _X86_ASSEMBLER_FUNCS_
#define _X86_ASSEMBLER_FUNCS_


#include "river.h"
#include "RelocableCodeBuffer.h"

/* Opcode assembler functions */
void AssembleUnkInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
void AssembleDefaultInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);
void AssemblePlusRegInstr(const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::DWORD &pFlags, nodep::DWORD &instrCounter);

/* Operand helper funcs */
void AssembleModRMOp(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE extra);
void AssembleImmOp(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE immSize);
void AssembleMoffs(unsigned int opIdx, const RiverInstruction &ri, RelocableCodeBuffer &px86, nodep::BYTE immSize);


/* Operand assembler functions */
void AssembleUnknownOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);
void AssembleNoOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);

template <nodep::BYTE opIdx, nodep::BYTE immSize> void AssembleImmOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleImmOp(opIdx, ri, px86, immSize);
}

template <int extra> void AssembleModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleModRMOp(0, ri, px86, extra);
}

void AssembleModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);
void AssembleModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);

void AssembleRegModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);
void AssembleModRMRegOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);
void AssembleSubOpModRMOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);
void AssembleSubOpModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);
void AssembleSubOpModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);

void AssembleRegModRMImm32Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);
void AssembleRegModRMImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);

void AssembleModRMRegImm8Op(const RiverInstruction &ri, RelocableCodeBuffer &px86);

void AssembleRiverAddSubOp(const RiverInstruction &ri, RelocableCodeBuffer &px86);

template <nodep::BYTE opIdx> void AssembleMoffs8(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleMoffs(opIdx, ri, px86, RIVER_OPSIZE_32);
}

template <nodep::BYTE opIdx> void AssembleMoffs32(const RiverInstruction &ri, RelocableCodeBuffer &px86) {
	AssembleMoffs(opIdx, ri, px86, RIVER_OPSIZE_32);
}

#endif
```

`revtracer/api.cpp`:

```cpp
#include "revtracer.h"

#include "common.h"
#include "execenv.h"
#include "river.h"

#include "AddressContainer.h"
#include "Tracking.h"

using namespace nodep;

#define PRINT_RUNTIME_TRACKING	PRINT_INFO | PRINT_RUNTIME | PRINT_TRACKING
#define PRINT_BRANCHING_ERROR	PRINT_ERROR | PRINT_BRANCH_HANDLER
#define PRINT_BRANCHING_DEBUG	PRINT_DEBUG | PRINT_BRANCH_HANDLER
#define PRINT_BRANCHING_INFO	PRINT_INFO | PRINT_BRANCH_HANDLER

#define DEBUG_BREAK_ { \
	*(WORD *)revtracerConfig.mainModule = 'ZM'; \
	DEBUG_BREAK; \
	*(WORD *)revtracerConfig.mainModule = '  '; \
}

DWORD dwAddressTrackHandler = (DWORD)&rev::TrackAddr;
DWORD dwAddressMarkHandler = (DWORD)&rev::MarkAddr;

void RiverPrintInstruction(DWORD printMask, RiverInstruction *ri);
void DirectionHandler(DWORD dwDirection, ExecutionEnvironment *pEnv, ADDR_TYPE addr);

extern "C" {
	void PushToExecutionBuffer(ExecutionEnvironment *pEnv, DWORD value) {
		pEnv->runtimeContext.execBuff -= 4;
		*((DWORD *)pEnv->runtimeContext.execBuff) = value;
	}

	DWORD PopFromExecutionBuffer(ExecutionEnvironment *pEnv) {
		DWORD ret = *((DWORD *)pEnv->runtimeContext.execBuff);
		pEnv->runtimeContext.execBuff += 4;
		return ret;
	}

	DWORD TopFromExecutionBuffer(ExecutionEnvironment *pEnv) {
		return *((DWORD *)pEnv->runtimeContext.execBuff);
	}

	bool ExecutionBufferEmpty(ExecutionEnvironment *pEnv) {
		return (DWORD)pEnv->executionBase == pEnv->runtimeContext.execBuff;
	}

	void ClearExecutionBuffer(ExecutionEnvironment *pEnv) {
		pEnv->runtimeContext.execBuff = pEnv->executionBase;
	}

	typedef DWORD (*NtTerminateProcessFunc)(
		DWORD ProcessHandle,
		DWORD ExitStatus
	);


	void __stdcall BranchHandler(ExecutionEnvironment *pEnv, ADDR_TYPE a) {
		//ExecutionRegs *currentRegs = (ExecutionRegs *)((&a) + 1);
		pEnv->runtimeContext.registers = (UINT_PTR)((&a) + 1);
		pEnv->runtimeContext.trackBuff = pEnv->runtimeContext.trackBase;

		if (pEnv->bForward) {
			PushToExecutionBuffer(pEnv, pEnv->lastFwBlock);
		}


		DWORD *stk = (DWORD *)pEnv->runtimeContext.virtualStack;
		DWORD esp = pEnv->runtimeContext.virtualStack;
		BRANCHING_PRINT(PRINT_BRANCHING_DEBUG, "EIP: 0x%08x Stack addr: %p stk: %p\n", a, &(pEnv->runtimeContext.virtualStack), stk);
		BRANCHING_PRINT(PRINT_BRANCHING_DEBUG, "0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x\n", stk + 0x00, stk[0], stk[1], stk[2], stk[3]);
		BRANCHING_PRINT(PRINT_BRANCHING_DEBUG, "EAX: 0x%08x  ECX: 0x%08x  EDX: 0x%08x  EBX: 0x%08x\n",
			((ExecutionRegs*)pEnv->runtimeContext.registers)->eax, 
			((ExecutionRegs*)pEnv->runtimeContext.registers)->ecx,
			((ExecutionRegs*)pEnv->runtimeContext.registers)->edx,
			((ExecutionRegs*)pEnv->runtimeContext.registers)->ebx);
		BRANCHING_PRINT(PRINT_BRANCHING_DEBUG, "ESP: 0x%08x  EBP: 0x%08x  ESI: 0x%08x  EDI: 0x%08x\n",
			esp,
			((ExecutionRegs*)pEnv->runtimeContext.registers)->ebp,
			((ExecutionRegs*)pEnv->runtimeContext.registers)->esi,
			((ExecutionRegs*)pEnv->runtimeContext.registers)->edi);
		BRANCHING_PRINT(PRINT_BRANCHING_DEBUG, "Flags: 0x%08x\n",
			((ExecutionRegs*)pEnv->runtimeContext.registers)->eflags);

		DWORD dwDirection = revtracerImports.branchHandler(pEnv, pEnv->userContext, a);
		DirectionHandler(dwDirection, pEnv, a);
	}

	void __stdcall SysHandler(struct ExecutionEnvironment *pEnv) {
		revtracerImports.dbgPrintFunc(PRINT_BRANCHING_INFO, "SysHandler!!!\n");
	}
};

template<DWORD Direction>
bool ProcessDirection(ExecutionEnvironment *pEnv, ADDR_TYPE nextInstruction);

template<>
bool ProcessDirection<EXECUTION_TERMINATE>(ExecutionEnvironment *pEnv, ADDR_TYPE nextInstruction) {
	//revtracerAPI.dbgPrintFunc(PRINT_INFO | PRINT_INSPECTION, " +++ Tainted addresses +++ \n");
	pEnv->ac.PrintAddreses();
	//revtracerAPI.dbgPrintFunc(PRINT_INFO | PRINT_INSPECTION, " +++++++++++++++++++++++++ \n");

	//((NtTerminateProcessFunc)revtracerAPI.lowLevel.ntTerminateProcess)(0xFFFFFFFF, 0);

	pEnv->runtimeContext.jumpBuff = pEnv->exitAddr;
	return true;
}

template<>
bool ProcessDirection<EXECUTION_RESTART>(ExecutionEnvironment *pEnv, ADDR_TYPE nextInstruction) {
	BRANCHING_PRINT(PRINT_BRANCHING_INFO, "RESTART Requested\n", revtracerConfig.entryPoint);
	pEnv->lastFwBlock = 0;
	ClearExecutionBuffer(pEnv);

	pEnv->runtimeContext.registers = (UINT_PTR)((&nextInstruction) + 1);

	// need to push the return address again
	DWORD nextDirection = revtracerImports.branchHandler(pEnv, pEnv->userContext, revtracerConfig.entryPoint);
	if (nextDirection == EXECUTION_ADVANCE) {
		pEnv->runtimeContext.virtualStack -= 4;
		*((ADDR_TYPE *)pEnv->runtimeContext.virtualStack) = nextInstruction;
		pEnv->lastFwBlock = (UINT_PTR)revtracerConfig.entryPoint;
		pEnv->bForward = 1;
		DirectionHandler(nextDirection, pEnv, revtracerConfig.entryPoint);
	} else {
		pEnv->runtimeContext.jumpBuff = (UINT_PTR)revtracerImports.lowLevel.ntTerminateProcess;
	}
	return true;
}

template<>
bool ProcessDirection<EXECUTION_ADVANCE>(ExecutionEnvironment *pEnv, ADDR_TYPE nextInstruction) {
	RiverBasicBlock *pCB;
	// go forwards
	TRANSLATE_PRINT(PRINT_BRANCHING_INFO, "Going Forwards from %08X!!!\n", nextInstruction);
	TRANSLATE_PRINT(PRINT_BRANCHING_INFO, "Looking for block\n");

	pCB = pEnv->blockCache.FindBlock((nodep::UINT_PTR)nextInstruction);

	if (pCB) {
		TRANSLATE_PRINT(PRINT_BRANCHING_INFO, "Block found\n");
	} else {
		TRANSLATE_PRINT(PRINT_BRANCHING_INFO, "Not Found\n");
		pCB = pEnv->blockCache.NewBlock((nodep::UINT_PTR)nextInstruction);

		RevtracerError rerror;
		bool ret = pEnv->codeGen.Translate(pCB, pEnv->generationFlags, &rerror);

		if (!ret && rerror.errorCode != RERROR_OK) {
			auto nextDirection = revtracerImports.errorHandler(pEnv, pEnv->userContext, &rerror);
			if (nextDirection == EXECUTION_RESTART) {
				ProcessDirection<EXECUTION_RESTART>(pEnv, nextInstruction);
			} else {
				ProcessDirection<EXECUTION_TERMINATE>(pEnv, nextInstruction);
			}
			return false;
		}

		TRANSLATE_PRINT(PRINT_BRANCHING_INFO, "= river saving code ===========================================================\n");
		for (DWORD i = 0; i < pEnv->codeGen.fwInstCount; ++i) {
			TRANSLATE_PRINT_INSTRUCTION(PRINT_BRANCHING_INFO, &pEnv->codeGen.fwRiverInst[i]);
		}
		TRANSLATE_PRINT(PRINT_BRANCHING_INFO, "===============================================================================\n");

		if (TRACER_FEATURE_REVERSIBLE & pEnv->generationFlags) {
			TRANSLATE_PRINT(PRINT_BRANCHING_INFO, "= river reversing code ========================================================\n");
			for (DWORD i = 0; i < pEnv->codeGen.bkInstCount; ++i) {
				TRANSLATE_PRINT_INSTRUCTION(PRINT_BRANCHING_INFO, &pEnv->codeGen.bkRiverInst[i]);
			}
			TRANSLATE_PRINT(PRINT_BRANCHING_INFO, "===============================================================================\n");
		}
	}
	pCB->MarkForward();
	pEnv->lastFwBlock = pCB->address;
	pEnv->bForward = 1;

	pEnv->runtimeContext.jumpBuff = (DWORD)pCB->pFwCode;
	return true;
}

template<>
bool ProcessDirection<EXECUTION_BACKTRACK>(ExecutionEnvironment *pEnv, ADDR_TYPE nextInstruction) {
	RiverBasicBlock *pCB;

	// go backwards
	DWORD addr = PopFromExecutionBuffer(pEnv);
	revtracerImports.dbgPrintFunc(PRINT_BRANCHING_INFO, "Going Backwards to %08X!!!\n", addr);

	revtracerImports.dbgPrintFunc(PRINT_BRANCHING_INFO, "Looking for block\n");
	pCB = pEnv->blockCache.FindBlock(addr);
	if (pCB) {
		revtracerImports.dbgPrintFunc(PRINT_BRANCHING_INFO, "Block found\n");
		pCB->MarkBackward();
		//pEnv->posHist -= 1;

		pEnv->bForward = 0;
		pEnv->runtimeContext.jumpBuff = (DWORD)pCB->pBkCode;
	}
	else {
		revtracerImports.dbgPrintFunc(PRINT_BRANCHING_ERROR, "No reverse block found!");
		return false;
	}
	return true;
}

void DirectionHandler(DWORD dwDirection, ExecutionEnvironment *pEnv, ADDR_TYPE addr) {
	if (EXECUTION_BACKTRACK == dwDirection) {
		ProcessDirection<EXECUTION_BACKTRACK>(pEnv, addr);
	} else if (EXECUTION_ADVANCE == dwDirection) {
		ProcessDirection<EXECUTION_ADVANCE>(pEnv, addr);
	} else if (EXECUTION_TERMINATE == dwDirection) {
		ProcessDirection<EXECUTION_TERMINATE>(pEnv, addr);
	} else if (EXECUTION_RESTART == dwDirection) {
		ProcessDirection<EXECUTION_RESTART>(pEnv, addr);
	}
}


DWORD DllEntry() {
	return 1;
}

```

`revtracer/callgates.cpp`:

```cpp
#include <intrin.h>

#include "common.h"
#include "callgates.h"
#include "cb.h"
#include "mm.h"
//#include "BaseTsd.h"

#include "execenv.h"

#include "revtracer.h"

using namespace nodep;

//void DbgPrint(const char *fmt, ...);

void Stopper(struct ExecutionEnvironment *pEnv, BYTE *s) {
	RiverBasicBlock *pStop;
	RevtracerError rerror;

	revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_CONTAINER, "STOPPER: %p.\n", s);
	pStop = pEnv->blockCache.NewBlock((UINT_PTR)s);
	pEnv->codeGen.Translate(pStop, 0x80000000, &rerror); // this will fix pStop->CRC and pStop->Size
	pEnv->exitAddr = (DWORD)s;
}

void SetEsp(struct ExecutionEnvironment *pEnv, nodep::DWORD esp) {
	pEnv->runtimeContext.firstEsp = esp;
}

#ifdef _MSC_VER
#define GET_RETURN_ADDR _ReturnAddress
#define CALLING_CONV(conv) __##conv
#else
#define GET_RETURN_ADDR() ({ int addr; asm volatile("mov 4(%%ebp), %0" : "=r" (addr)); addr; })
#define GET_ESP() ({ int esp; asm volatile("mov %%esp, %0" : "=r" (esp)); esp; })
#define CALLING_CONV(conv) __attribute__((conv))
#endif

#define _RET_ADDR_FUNC_2(conv, paramCount, ...) \
	nodep::DWORD CALLING_CONV(conv) RetAddr_##conv##_##paramCount (__VA_ARGS__) { \
		return (nodep::DWORD)GET_RETURN_ADDR(); \
	}

#define _RET_ADDR_FUNC_(conv, paramCount, ...) _RET_ADDR_FUNC_2(conv, paramCount, __VA_ARGS__)

nodep::DWORD CALLING_CONV(naked) EspAddr () {
	return (nodep::DWORD)GET_ESP();
}


_RET_ADDR_FUNC_(cdecl, 0);
_RET_ADDR_FUNC_(cdecl, 1, void *);
_RET_ADDR_FUNC_(cdecl, 2, void *, void *);
_RET_ADDR_FUNC_(cdecl, 3, void *, void *, void *);
_RET_ADDR_FUNC_(cdecl, 4, void *, void *, void *, void *);

_RET_ADDR_FUNC_(stdcall, 0);
_RET_ADDR_FUNC_(stdcall, 1, void *);
_RET_ADDR_FUNC_(stdcall, 2, void *, void *);
_RET_ADDR_FUNC_(stdcall, 3, void *, void *, void *);
_RET_ADDR_FUNC_(stdcall, 4, void *, void *, void *, void *);

nodep::DWORD __declspec(noinline) call_cdecl_0(struct ExecutionEnvironment *env, _fn_cdecl_0 f) {
	DWORD ret;
	RevtracerError rerror;
	RiverBasicBlock *pBlock;

	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	//pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_cdecl_0 funcs[] = {
		EspAddr,
		RetAddr_cdecl_0,
		(_fn_cdecl_0)(pBlock->pFwCode)

	};

	for (int i = 0; i < 3; ++i) {
		ret = (funcs[i])();
		if (0 == i) {
			SetEsp(env, ret);
		} else if (1 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

DWORD __declspec(noinline) call_cdecl_1(struct ExecutionEnvironment *env, _fn_cdecl_1 f, void *p1) {
	DWORD ret;
	RevtracerError rerror;
	RiverBasicBlock *pBlock;

	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_cdecl_1 funcs[] = {
		RetAddr_cdecl_1,
		(_fn_cdecl_1)(pBlock->pFwCode)

	};

	for (int i = 0; i < 2; ++i) {
		ret = (funcs[i])(p1);
		if (0 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

DWORD __declspec(noinline) call_cdecl_2(struct ExecutionEnvironment *env, _fn_cdecl_2 f, void *p1, void *p2) {
	DWORD ret;
	RevtracerError rerror;
	RiverBasicBlock *pBlock; 
	
	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_cdecl_2 funcs[] = {
		RetAddr_cdecl_2,
		(_fn_cdecl_2)(pBlock->pFwCode)

	};

	for (int i = 0; i < 2; ++i) {
		ret = (funcs[i])(p1, p2);
		if (0 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

DWORD __declspec(noinline) call_cdecl_3(struct ExecutionEnvironment *env, _fn_cdecl_3 f, void *p1, void *p2, void *p3) {
	DWORD ret;
	RevtracerError rerror;
	RiverBasicBlock *pBlock;

	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_cdecl_3 funcs[] = {
		RetAddr_cdecl_3,
		(_fn_cdecl_3)(pBlock->pFwCode)

	};

	for (int i = 0; i < 2; ++i) {
		ret = (funcs[i])(p1, p2, p3);
		if (0 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

DWORD __declspec(noinline) call_cdecl_4(struct ExecutionEnvironment *env, _fn_cdecl_4 f, void *p1, void *p2, void *p3, void *p4) {
	DWORD ret;
	RevtracerError rerror;
	RiverBasicBlock *pBlock;

	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_cdecl_4 funcs[] = {
		RetAddr_cdecl_4,
		(_fn_cdecl_4)(pBlock->pFwCode)

	};

	for (int i = 0; i < 2; ++i) {
		ret = (funcs[i])(p1, p2, p3, p4);
		if (0 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

DWORD __declspec(noinline) call_stdcall_0(struct ExecutionEnvironment *env, _fn_stdcall_0 f) {
	RiverBasicBlock *pBlock;
	RevtracerError rerror;
	DWORD ret;

	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_stdcall_0 funcs[] = {
		RetAddr_stdcall_0,
		(_fn_stdcall_0)(pBlock->pFwCode)

	};

	for (int i = 0; i < 2; ++i) {
		ret = (funcs[i])();
		if (0 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

DWORD __declspec(noinline) call_stdcall_1(struct ExecutionEnvironment *env, _fn_stdcall_1 f, void *p1) {
	DWORD ret;
	RevtracerError rerror;
	RiverBasicBlock *pBlock;

	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_stdcall_1 funcs[] = {
		RetAddr_stdcall_1,
		(_fn_stdcall_1)(pBlock->pFwCode)

	};

	for (int i = 0; i < 2; ++i) {
		ret = (funcs[i])(p1);
		if (0 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

DWORD __declspec(noinline) call_stdcall_2(struct ExecutionEnvironment *env, _fn_stdcall_2 f, void *p1, void *p2) {
	DWORD ret;
	RevtracerError rerror;
	RiverBasicBlock *pBlock;

	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_stdcall_2 funcs[] = {
		RetAddr_stdcall_2,
		(_fn_stdcall_2)(pBlock->pFwCode)

	};

	for (int i = 0; i < 2; ++i) {
		ret = (funcs[i])(p1, p2);
		if (0 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

DWORD __declspec(noinline) call_stdcall_3(struct ExecutionEnvironment *env, _fn_stdcall_3 f, void *p1, void *p2, void *p3) {
	DWORD ret;
	RevtracerError rerror;
	RiverBasicBlock *pBlock;

	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_stdcall_3 funcs[] = {
		RetAddr_stdcall_3,
		(_fn_stdcall_3)(pBlock->pFwCode)

	};

	for (int i = 0; i < 2; ++i) {
		ret = (funcs[i])(p1, p2, p3);
		if (0 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

DWORD __declspec(noinline) call_stdcall_4(struct ExecutionEnvironment *env, _fn_stdcall_4 f, void *p1, void *p2, void *p3, void *p4) {
	DWORD ret;
	RevtracerError rerror;
	RiverBasicBlock *pBlock;

	pBlock = env->blockCache.NewBlock((UINT_PTR)f);
	pBlock->address = (DWORD) f;
	env->codeGen.Translate(pBlock, env->generationFlags, &rerror);
	env->bForward = 1;
	env->lastFwBlock = (DWORD)f;
	pBlock->MarkForward();
	//AddBlock(env, pBlock);

	_fn_stdcall_4 funcs[] = {
		RetAddr_stdcall_4,
		(_fn_stdcall_4)(pBlock->pFwCode)

	};

	for (int i = 0; i < 2; ++i) {
		ret = (funcs[i])(p1, p2, p3, p4);
		if (0 == i) {
			Stopper(env, (BYTE *)ret);
		}
	}

	return ret;
}

```

`revtracer/callgates.h`:

```h
#ifndef _CALL_GATES_H
#define _CALL_GATES_H

#include "environment.h"
#include "revtracer.h"

typedef nodep::DWORD (_cdecl *_fn_cdecl_0) (void);
typedef nodep::DWORD (_cdecl *_fn_cdecl_1) (void *);
typedef nodep::DWORD (_cdecl *_fn_cdecl_2) (void *, void *);
typedef nodep::DWORD (_cdecl *_fn_cdecl_3) (void *, void *, void *);
typedef nodep::DWORD (_cdecl *_fn_cdecl_4) (void *, void *, void *, void *);

typedef nodep::DWORD (_stdcall *_fn_stdcall_0) (void);
typedef nodep::DWORD (_stdcall *_fn_stdcall_1) (void *);
typedef nodep::DWORD (_stdcall *_fn_stdcall_2) (void *, void *);
typedef nodep::DWORD (_stdcall *_fn_stdcall_3) (void *, void *, void *);
typedef nodep::DWORD (_stdcall *_fn_stdcall_4) (void *, void *, void *, void *);

nodep::DWORD __declspec(noinline) call_cdecl_0(struct ExecutionEnvironment *env, _fn_cdecl_0 f);
nodep::DWORD __declspec(noinline) call_cdecl_1(struct ExecutionEnvironment *env, _fn_cdecl_1 f, void *);
nodep::DWORD __declspec(noinline) call_cdecl_2(struct ExecutionEnvironment *env, _fn_cdecl_2 f, void *, void *);
nodep::DWORD __declspec(noinline) call_cdecl_3(struct ExecutionEnvironment *env, _fn_cdecl_3 f, void *, void *, void *);
nodep::DWORD __declspec(noinline) call_cdecl_4(struct ExecutionEnvironment *env, _fn_cdecl_4 f, void *, void *, void *, void *);

nodep::DWORD __declspec(noinline) call_stdcall_0(struct ExecutionEnvironment *env, _fn_stdcall_0 f);
nodep::DWORD __declspec(noinline) call_stdcall_1(struct ExecutionEnvironment *env, _fn_stdcall_1 f, void *);
nodep::DWORD __declspec(noinline) call_stdcall_2(struct ExecutionEnvironment *env, _fn_stdcall_2 f, void *, void *);
nodep::DWORD __declspec(noinline) call_stdcall_3(struct ExecutionEnvironment *env, _fn_stdcall_3 f, void *, void *, void *);
nodep::DWORD __declspec(noinline) call_stdcall_4(struct ExecutionEnvironment *env, _fn_stdcall_4 f, void *, void *, void *, void *);



#endif

```

`revtracer/cb.cpp`:

```cpp
#include "common.h"
#include "revtracer.h"
#include "cb.h"
#include "sync.h"
#include "crc32.h"
#include "mm.h"

/*#define HASH_TABLE_SIZE 0x10000
#define HISTORY_SIZE 0x10000*/

void RiverBasicBlock::MarkForward() {
	dwFwPasses++;
}

void RiverBasicBlock::MarkBackward() {
	dwBkPasses++;
}


nodep::DWORD HashFunc(unsigned int logHashSize, unsigned long a) {
	//DbgPrint("Value = %08x\n", a);
	//DbgPrint("logHashSize = %08x\n", logHashSize);
	//DbgPrint("mask = %08x\n", ((1 << logHashSize) - 1));
	return a & ((1 << logHashSize) - 1);
}

#ifndef BLOCK_CACHE_READ_ONLY
RiverBasicBlockCache::RiverBasicBlockCache() {
	hashTable = NULL;
	logHashSize = 0;
}

RiverBasicBlockCache::~RiverBasicBlockCache() {
	if (0 != logHashSize) {
		Destroy();
	}
}

RiverBasicBlock *RiverBasicBlockCache::NewBlock(nodep::UINT_PTR a) {
	RiverBasicBlock *pNew;
	
	pNew = (RiverBasicBlock *)heap->Alloc(sizeof(*pNew));

	if (NULL == pNew) {
		return NULL;
	}

	rev_memset(pNew, 0, sizeof(*pNew));
	pNew->address = a;

	//cbLock.Lock();

	nodep::DWORD dwHash = HashFunc(logHashSize, pNew->address); // & 0xFFFF;

	pNew->pNext = hashTable[dwHash];
	hashTable[dwHash] = pNew;

	//cbLock.Unlock();

	return pNew;
}

bool RiverBasicBlockCache::Init(RiverHeap *hp, nodep::DWORD logHSize, nodep::DWORD histSize) {
	heap = hp;

	logHashSize = logHSize;
	historySize = histSize;
	rev::revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_RUNTIME, "BlockCache initialized @%p\n", this);
	hashTable = (RiverBasicBlock **)rev::revtracerImports.memoryAllocFunc((1 << logHashSize) * sizeof(hashTable[0]));
	rev::revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_RUNTIME, "BlockCache hashtable @%p\n", hashTable);

	if (0 == hashTable) {
		return false;
	}
	 
	rev_memset(hashTable, 0, (1 << logHashSize) * sizeof(hashTable[0]));

	/*history = (UINT_PTR *)EnvMemoryAlloc(historySize * sizeof (history[0]));

	if (NULL == pEnv->history) {
	EnvMemoryFree((BYTE *)pEnv->hashTable);
	return 0;
	}

	memset (pEnv->history, 0, historySize * sizeof (pEnv->history[0]));

	DbgPrint("History is at %p.\n", pEnv->history);

	pEnv->posHist = pEnv->totHist = 0;*/
	return true;
}

bool RiverBasicBlockCache::Destroy() {
	unsigned long idx, midx;
	RiverBasicBlock *pWalk, *pAdd;

	//	SC_Lock (&dwCBLock);

	midx = 1 << logHashSize;
	idx = 0;

	for (idx = 0; idx < midx; ++idx) {
		pWalk = hashTable[idx];

		while (pWalk) {
			//	DbgPrint("[%08X] [%08X] %08X -> %p.\n", pWalk, pWalk->dwParses & 0x7FFFFFFF, pWalk->address, pWalk->pCode);

			pAdd = pWalk;
			pWalk = pWalk->pNext;

			if (pAdd->address != (nodep::UINT_PTR)pAdd->pCode) {
				heap->Free(pAdd->pCode);
			}

			heap->Free(pAdd);
		}
	}

	//	SC_Unlock (&dwCBLock);

	rev::revtracerImports.memoryFreeFunc((nodep::BYTE *)hashTable);
	hashTable = NULL;
	logHashSize = 0;


	/*EnvMemoryFree ((BYTE *)pEnv->history);
	pEnv->history = NULL;*/
	return true;
}

#endif

RiverBasicBlock *RiverBasicBlockCache::FindBlock(nodep::UINT_PTR a) {
	RiverBasicBlock *pWalk;
	int arr = 0;
	
	//DEBUG_BREAK; 
	unsigned long hash = HashFunc(logHashSize, a);

	//cbLock.Lock();
	pWalk = hashTable[hash];

	while (pWalk) {
		if (pWalk->address == a) {
			if (RIVER_BASIC_BLOCK_DETOUR & pWalk->dwFlags) { // do not crc check this block as it is a detour
				//cbLock.Unlock();
				return pWalk;
			}

#ifndef BLOCK_CACHE_READ_ONLY
			if (pWalk->dwCRC == (unsigned long) crc32 (0xEDB88320, (nodep::BYTE *) a, pWalk->dwSize)) {
				//cbLock.Unlock();
				return pWalk;
			} else {
				//	_asm int 3
				//	dbg1 ("___SMC___ at address %08X.\n", a);

				//cbLock.Unlock();
				return NULL;
			}
#else
			//cbLock.Unlock();
			return pWalk;
#endif
		}

		pWalk = pWalk->pNext;
		if (++arr > 0x800) {
			//cbLock.Unlock();
			DEBUG_BREAK;
		}
	}

	//cbLock.Unlock();

	return NULL;
}

void RiverBasicBlockCache::ForEachBlock(void *ctx, BlockCallback cb) {
	for (int i = 0; i < (1 << logHashSize); ++i) {
		RiverBasicBlock *pWalk = hashTable[i];

		while (pWalk) {
			cb(ctx, pWalk);
			pWalk = pWalk->pNext;
		}
	}
}



```

`revtracer/cb.h`:

```h
#ifndef _CB_H
#define _CB_H

#include "revtracer.h"
#include "mm.h"
#include "sync.h"

#define RIVER_BASIC_BLOCK_DETOUR				0x80000000

class RiverBasicBlock {
public :
	/* informations about the real block */
	nodep::UINT_PTR			address; // original address
	nodep::DWORD				dwSize;  // block size
	nodep::DWORD				dwCRC;   // block crc
	nodep::DWORD				dwFlags; // block flags

	/* statistical translation information */
	nodep::DWORD				dwOrigOpCount; // number of instructions in the original block
	nodep::DWORD				dwFwOpCount; // number of instructions in the translated block
	nodep::DWORD				dwBkOpCount; // number of instructions in the reverse block
	nodep::DWORD				dwTrOpCount; // number of instructions in the tracking code
	nodep::DWORD				dwRtOpCount; // number of instructions in the reverse trakcing code

	/* statistical runtime information */
	nodep::DWORD				dwFwPasses; // number of block executions
	nodep::DWORD				dwBkPasses; // number of reverse block executions

	/* actual code information */
	unsigned char		*pCode; // deprecated
	unsigned char       *pFwCode; // forward bb
	unsigned char       *pBkCode; // reverse bb
	unsigned char		*pTrackCode; // tracking code
	unsigned char		*pRevTrackCode; // reverse tracking code
	unsigned char       *pDisasmCode; // disassembled code

	/* control flow data */
	nodep::DWORD				dwBranchType;
	nodep::DWORD				dwBranchInstruction;
	struct rev::BranchNext		pBranchNext[2];

	/* block linkage (for hash table) */
	RiverBasicBlock		*pNext;

	/* branching cache, in order to speed up lookup */
	RiverBasicBlock		*pBranchCache[2];

	void MarkForward();
	void MarkBackward();
};

class RiverBasicBlockCache {
private :
	RiverHeap *heap;
public :
	RiverMutex cbLock; //  = 0;
	RiverBasicBlock **hashTable; // = 0
	nodep::DWORD historySize, logHashSize;

	RiverBasicBlockCache();
	~RiverBasicBlockCache();

	bool Init(RiverHeap *hp, nodep::DWORD logHSize, nodep::DWORD histSize);
	bool Destroy();

	RiverBasicBlock *NewBlock(nodep::UINT_PTR addr);
	RiverBasicBlock *FindBlock(nodep::UINT_PTR addr);

	typedef void(*BlockCallback)(void *, RiverBasicBlock *);
	void ForEachBlock(void *ctx, BlockCallback cb);
};

//RiverBasicBlock *NewBlock(struct _exec_env *pEnv);
//RiverBasicBlock *FindBlock(struct _exec_env *pEnv, unsigned long);

//void AddBlock(struct _exec_env *pEnv, RiverBasicBlock*);

void PrintHistory(struct ExecutionEnvironment *pEnv);
nodep::DWORD DumpHistory(struct ExecutionEnvironment *pEnv, unsigned char *o, unsigned long s, unsigned long *sz);

#endif


```

`revtracer/codegen.cpp`:

```cpp
#include "CodeGen.h"

#include "common.h"
#include "cb.h"
#include "mm.h"
#include "modrm32.h"
#include "crc32.h"
#include "revtracer.h"

#include "river.h"

#include "RiverX86Disassembler.h"
#include "RiverReverseTranslator.h"
#include "RiverSaveTranslator.h"

RiverCodeGen::RiverCodeGen() {
	outBufferSize = 0;
	outBuffer = NULL;
	heap = NULL;
}

RiverCodeGen::~RiverCodeGen() {
	if (0 != outBufferSize) {
		Destroy();
	}
}

bool RiverCodeGen::Init(RiverHeap *hp, RiverRuntime *rt, nodep::DWORD buffSz, nodep::DWORD dwTranslationFlags) {
	heap = hp;
	if (NULL == (outBuffer = (unsigned char *)revtracerImports.memoryAllocFunc(buffSz))) {
		return false;
	}
	outBufferSize = buffSz;
	codeBuffer.Init(outBuffer);

	disassembler.Init(this);

	metaTranslator.Init(this);

	repTranslator.Init(this);

	revTranslator.Init(this);
	saveTranslator.Init(this);

	symbopTranslator.Init(this);
	symbopSaveTranslator.Init(this);
	symbopReverseTranslator.Init(this);

	return assembler.Init(rt, dwTranslationFlags);
}

bool RiverCodeGen::Destroy() {
	revtracerImports.memoryFreeFunc(outBuffer);
	outBuffer = NULL;
	outBufferSize = 0;
	heap = NULL;
	return true;
}

void RiverCodeGen::Reset() {
	addrCount = trInstCount = fwInstCount = bkInstCount = 0;
	symbopInstCount = 0;
	rev_memset(regVersions, 0, sizeof(regVersions));
}


static int callCount = 0;
struct RiverAddress *RiverCodeGen::AllocAddr(nodep::WORD flags) {
	struct RiverAddress *ret = &trRiverAddr[addrCount];
	callCount++;
	addrCount++;
	return ret;
}

RiverAddress *RiverCodeGen::CloneAddress(const RiverAddress &mem, nodep::WORD flags) {
	struct RiverAddress *ret = AllocAddr(flags);
	rev_memcpy(ret, &mem, sizeof(*ret));
	return ret;
}


unsigned int RiverCodeGen::GetCurrentReg(unsigned char regName) const {
	if (RIVER_REG_NONE == (regName)) return regName;
	nodep::BYTE rTmp = regName & 0x07;
	return regVersions[rTmp] | regName;
}

unsigned int RiverCodeGen::GetPrevReg(unsigned char regName) const {
	if (RIVER_REG_NONE == (regName)) return regName;
	nodep::BYTE rTmp = regName & 0x07;
	return (regVersions[rTmp] - 0x100) | regName;
}

unsigned int RiverCodeGen::NextReg(unsigned char regName) {
	if (regName > 0x20) DEBUG_BREAK;
	regVersions[regName & 0x07] += 0x100;
	return GetCurrentReg(regName);
}




nodep::DWORD dwTransLock = 0;

extern "C" {
	void __stdcall BranchHandler(struct ExecutionEnvironment *pEnv, ADDR_TYPE a);
	void __stdcall SysHandler(struct ExecutionEnvironment *pEnv);
};

nodep::DWORD dwSysHandler    = (nodep::DWORD) ::SysHandler;
nodep::DWORD dwBranchHandler = (nodep::DWORD) ::BranchHandler;

unsigned char *DuplicateBuffer(RiverHeap *h, unsigned char *p, unsigned int sz) {
	unsigned int mSz = (sz + 0x0F) & ~0x0F;
	
	unsigned char *pBuf = (unsigned char *)h->Alloc(mSz);
	if (pBuf == NULL) {
		return NULL;
	}

	rev_memcpy(pBuf, p, sz);
	rev_memset(pBuf + sz, 0x90, mSz - sz);
	return pBuf;
}

unsigned char *ConsolidateBlock(RiverHeap *h, unsigned char *outBuff, unsigned int outSz, unsigned char *saveBuff, unsigned int saveSz) {
	unsigned int mSz = (outSz + saveSz + 0x0F) & (~0x0F);

	unsigned char *pBuf = (unsigned char *)h->Alloc(mSz);
	if (NULL == pBuf) {
		return NULL;
	}

	rev_memcpy(pBuf, saveBuff, saveSz);
	rev_memcpy(&pBuf[saveSz], outBuff, outSz);
	rev_memset(&pBuf[saveSz + outSz], 0x90, mSz - outSz - saveSz);
	return pBuf;
}

void MakeJMP(struct RiverInstruction *ri, nodep::DWORD jmpAddr) {
	ri->modifiers = 0;
	ri->specifiers = 0;
	ri->family = 0;
	ri->opCode = 0xE9;
	ri->opTypes[0] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_32;
	ri->operands[0].asImm32 = jmpAddr;

	ri->opTypes[1] = RIVER_OPTYPE_IMM | RIVER_OPSIZE_32;
	ri->operands[1].asImm32 = 0;
}

void RiverPrintInstruction(nodep::DWORD printMask, RiverInstruction *ri);

bool RiverCodeGen::DisassembleSingle(nodep::BYTE *&px86, RiverInstruction *rOut, nodep::DWORD &count, nodep::DWORD &dwFlags, RevtracerError *rerror) {
	bool ret = true;
	RiverInstruction dis;

	ret = disassembler.Translate(px86, dis, dwFlags);
	rerror->instructionAddress = dis.instructionAddress;
	rerror->prefix = (dis.modifiers & RIVER_MODIFIER_EXT) ? 0x0F : 0x00;
	rerror->opcode = *px86;

	if (!ret) {
		rerror->errorCode = RERROR_UNK_INSTRUCTION;
		rerror->instructionAddress = dis.instructionAddress;
		rerror->translatorId = RIVER_DISASSEMBLER_ID;
		return ret;
	}

	nodep::DWORD localRepCount = 0;
	RiverInstruction localInstrBuffer[16];
	ret = repTranslator.Translate(dis,
			(RiverInstruction *)&localInstrBuffer,
			localRepCount);

	if (!ret) {
		rerror->errorCode = RERROR_UNK_INSTRUCTION;
		rerror->instructionAddress = dis.instructionAddress;
		rerror->translatorId = RIVER_REP_TRANSLATOR_ID;
		return ret;
	}

	for (unsigned i = 0; i < localRepCount; ++i) {
		nodep::DWORD localMetaCount = 0;
		/*TRANSLATE_PRINT(PRINT_INFO, "instrIndex[%d], count[%d], opcode[0x%02X], instraddr[%p]\n", i, count,
				localInstrBuffer[i].opCode,
				dis.instructionAddress);*/
		ret = metaTranslator.Translate(localInstrBuffer[i], rOut + count, localMetaCount);
		count += localMetaCount;

		if (!ret) {
			rerror->errorCode = RERROR_UNK_INSTRUCTION;
			rerror->translatorId = RIVER_META_TRANSLATOR_ID;
			rerror->instructionAddress = dis.instructionAddress;
			return ret;
		}
	}

	rerror->errorCode = RERROR_OK;
	rerror->translatorId = RIVER_NONE_ID;
	rerror->instructionAddress = dis.instructionAddress;
	return ret;
}

nodep::DWORD RiverCodeGen::TranslateBasicBlock(nodep::BYTE *px86,
		nodep::DWORD &dwInst, nodep::BYTE *&disasm,
		nodep::DWORD dwTranslationFlags, nodep::DWORD *disassFlags,
		struct rev::BranchNext *next, RevtracerError *rerror) {
	bool ret;
	nodep::BYTE *pTmp = px86;
	nodep::DWORD pFlags = 0;

	TRANSLATE_PRINT(PRINT_INFO | PRINT_DISASSEMBLY, "= x86 to river ================================================================\n");

	//RiverInstruction dis;
	//RiverInstruction symbopMain[16]; // , symbopTrack[16];

	RiverInstruction instrBuffers[3][16];
	nodep::DWORD instrCounts[3], currentBuffer;

	//nodep::DWORD svCount, metaCount; // , trackCount;

	do {
		nodep::BYTE *pAux = pTmp;
		nodep::DWORD iSize;

		currentBuffer = 0;
		instrCounts[currentBuffer] = 0;

		//disassembler.Translate(pTmp, dis, pFlags);
		//metaTranslator.Translate(dis, instrBuffers[currentBuffer], instrCounts[currentBuffer]);

		RiverInstruction *ri = instrBuffers[currentBuffer];
		DisassembleSingle(pTmp, ri, instrCounts[currentBuffer], pFlags, rerror);

		// set disassemble flags when branch instruction is found
		if (pFlags & RIVER_FLAG_BRANCH) {
			*disassFlags = pFlags;
			rev_memset(next, 0, 2 * sizeof(struct BranchNext));

			// get last instruction from translation array
			RiverInstruction *tmpRi = ri + instrCounts[currentBuffer] - 1;

			// set next instructions and branch taken info
			if (RIVER_OPTYPE(tmpRi->opTypes[0]) == RIVER_OPTYPE_IMM) {
				next[0].taken = true;
				next[0].address = tmpRi->operands[1].asImm32;

				switch(RIVER_OPSIZE(tmpRi->opTypes[0])) {
				case RIVER_OPSIZE_32:
					next[0].address = (unsigned)((int)next[0].address + (int)tmpRi->operands[0].asImm32);
					break;
				case RIVER_OPSIZE_16:
					next[0].address = (unsigned)((int)next[0].address + (short)tmpRi->operands[0].asImm16);
					break;
				case RIVER_OPSIZE_8:
					next[0].address = (unsigned)((int)next[0].address + (char)tmpRi->operands[0].asImm8);
					break;
				default:
					DEBUG_BREAK;
				}

				if (pFlags & RIVER_BRANCH_INSTR_JXX) {
					next[1].taken = false;
					next[1].address = tmpRi->operands[1].asImm32;
				}
			} else if (RIVER_OPTYPE(tmpRi->opTypes[0]) == RIVER_OPTYPE_MEM ||
					RIVER_OPTYPE(tmpRi->opTypes[0]) == RIVER_OPTYPE_REG) {
				next[0].taken = true;
				next[0].address = 0x00000000;
			}
		}

		if (rerror->errorCode != RERROR_OK) {
			return 0;
		}

		nodep::DWORD addrCount = 0;

		for (nodep::DWORD i = 0; i < instrCounts[currentBuffer]; ++i) {
			for (nodep::DWORD j = 0; j < 4; ++j) {
				if (RIVER_OPTYPE(instrBuffers[currentBuffer][i].opTypes[j]) == RIVER_OPTYPE_MEM) {
					addrCount++;
				}
			}
		}
		RiverAddress *serialAddress = nullptr;
		RiverInstruction *serialInstr = (RiverInstruction *)heap->Alloc(
			instrCounts[currentBuffer] * sizeof(serialInstr[0])
			+ addrCount * sizeof(serialAddress[0])
		); // put head of buffer here
		serialAddress = (RiverAddress *)&serialInstr[instrCounts[currentBuffer]];

		addrCount = 0;
		rev_memcpy(serialInstr, instrBuffers[currentBuffer], instrCounts[currentBuffer] * sizeof(serialInstr[0]));
		for (nodep::DWORD i = 0; i < instrCounts[currentBuffer]; ++i) {
			for (nodep::DWORD j = 0; j < 4; ++j) {
				instrBuffers[currentBuffer][i].instructionAddress = (nodep::DWORD)&serialInstr[i];

				if (RIVER_OPTYPE(serialInstr[i].opTypes[j]) == RIVER_OPTYPE_MEM) {
					rev_memcpy(&serialAddress[addrCount], serialInstr[i].operands[j].asAddress, sizeof(serialAddress[0]));
					serialInstr[i].operands[j].asAddress = &serialAddress[addrCount];
					addrCount++;
				}
			}
		}

		disasm = (unsigned char *)serialInstr;

		for (nodep::DWORD i = 0; i < instrCounts[currentBuffer]; ++i) {
			if (RIVER_FAMILY_NATIVE == RIVER_FAMILY(instrBuffers[currentBuffer][i].family)) {

				TRANSLATE_PRINT(PRINT_INFO | PRINT_DISASSEMBLY, ".%08x    ", pAux);
				iSize = pTmp - pAux;
				for (nodep::DWORD i = 0; i < iSize; ++i) {
					TRANSLATE_PRINT(PRINT_INFO | PRINT_DISASSEMBLY, "%02x ", pAux[i]);
				}

				for (nodep::DWORD i = iSize; i < 8; ++i) {
					TRANSLATE_PRINT(PRINT_INFO | PRINT_DISASSEMBLY, "   ");
				}
			}
			else {
				TRANSLATE_PRINT(PRINT_INFO | PRINT_DISASSEMBLY, ".                                    ");
			}

			TRANSLATE_PRINT_INSTRUCTION(PRINT_INFO | PRINT_DISASSEMBLY, &instrBuffers[0][i]);
		}
		currentBuffer++;

		if (TRACER_FEATURE_REVERSIBLE & dwTranslationFlags) {
			instrCounts[currentBuffer] = 0;
			for (nodep::DWORD i = 0; i < instrCounts[currentBuffer - 1]; ++i) {
				ret = saveTranslator.Translate(
						instrBuffers[currentBuffer - 1][i], 
						&instrBuffers[currentBuffer][instrCounts[currentBuffer]], 
						instrCounts[currentBuffer]
						);
				if (!ret) {
					rerror->translatorId = RIVER_SAVE_TRANSLATOR_ID;
					rerror->errorCode = RERROR_UNK_INSTRUCTION;
					return 0;
				}
			}
			currentBuffer++;
		}

		if (TRACER_FEATURE_TRACKING & dwTranslationFlags) {
			instrCounts[currentBuffer] = 0;
			for (nodep::DWORD i = 0; i < instrCounts[currentBuffer - 1]; ++i) {
				ret = symbopTranslator.Translate(
						instrBuffers[currentBuffer - 1][i], 
						&instrBuffers[currentBuffer][instrCounts[currentBuffer]], 
						instrCounts[currentBuffer], 
						&symbopInst[symbopInstCount], 
						symbopInstCount,
						dwTranslationFlags
						);
				if (!ret) {
					rerror->translatorId = RIVER_SYMBOP_TRANSLATOR_ID;
					rerror->errorCode = RERROR_UNK_INSTRUCTION;
					return 0;
				}
			}
			currentBuffer++;
		}

		rev_memcpy(&fwRiverInst[fwInstCount], instrBuffers[currentBuffer - 1], sizeof(fwRiverInst[0]) * instrCounts[currentBuffer - 1]);
		fwInstCount += instrCounts[currentBuffer - 1];

		dwInst++;
	} while (!(pFlags & RIVER_FLAG_BRANCH));

	TRANSLATE_PRINT(PRINT_INFO | PRINT_DISASSEMBLY, "===============================================================================\n");
	return pTmp - px86;
}

void GetSerializableInstruction(const RiverInstruction &rI, RiverInstruction &rO) {
	rev_memcpy(&rO, &rI, sizeof(rI));

	for (int i = 0; i < 4; ++i) {
		if (RIVER_OPTYPE(rO.opTypes[i]) == RIVER_OPTYPE_MEM) {
			rO.operands[i].asAddress = NULL;
		}
	}
}

bool SerializeInstructions(const RiverInstruction *code, int count) {
	RiverInstruction tmp;
	nodep::DWORD dwWr;
	nodep::BOOL ret;
	for (int i = 0; i < count; ++i) {
		GetSerializableInstruction(code[i], tmp);
		ret = ((rev::WriteFileCall)revtracerImports.lowLevel.ntWriteFile)(revtracerConfig.hBlocks, 0, &tmp, sizeof(tmp), &dwWr);
		if (0 == ret) {
			//debug print something
			return false;
		}

		for (int j = 0; j < 4; ++j) {
			if (RIVER_OPTYPE(code[i].opTypes[j]) == RIVER_OPTYPE_MEM) {
				ret = ((rev::WriteFileCall)revtracerImports.lowLevel.ntWriteFile)(revtracerConfig.hBlocks, 0,
					&code[i].operands[j].asAddress->type, sizeof(*code[i].operands[j].asAddress) - sizeof(void *), &dwWr);
				if (0 == ret) {
					//debug print something
					return false;
				}
			}
		}
	}
	return true;
}

bool SaveToStream(
	const RiverInstruction *forwardCode, nodep::DWORD dwFwOpCount, 
	const RiverInstruction *backwardCode, nodep::DWORD dwBkOpCount,
	const RiverInstruction *trackCode, nodep::DWORD dwTrOpCount
) {
	/*nodep::DWORD header[4] = { 'BBVR', dwFwOpCount, dwBkOpCount, dwTrOpCount };
	nodep::DWORD dwWr;
	BOOL ret;

	ret = ((rev::WriteFileCall)revtracerImports.lowLevel.ntWriteFile)(revtracerConfig.hBlocks, header, sizeof(header), &dwWr);
	if (0 == ret) {
		//debug print something
		return false;
	}

	if (
		!SerializeInstructions(forwardCode, dwFwOpCount) ||
		!SerializeInstructions(backwardCode, dwBkOpCount) ||
		!SerializeInstructions(trackCode, dwTrOpCount)
		) {
		return false;
	}*/

	return true;
}

void SetBranchInfo(RiverBasicBlock *pCB, nodep::DWORD disassFlags) {
	if (disassFlags & RIVER_BRANCH_INSTR_RET) {
		pCB->dwBranchInstruction = RIVER_JUMP_INSTR_RET;
	} else if (disassFlags & RIVER_BRANCH_INSTR_JMP) {
		pCB->dwBranchInstruction = RIVER_JUMP_INSTR_JMP;
	} else if (disassFlags & RIVER_BRANCH_INSTR_JXX) {
		pCB->dwBranchInstruction = RIVER_JUMP_INSTR_JXX;
	} else if (disassFlags & RIVER_BRANCH_INSTR_CALL) {
		pCB->dwBranchInstruction = RIVER_JUMP_INSTR_CALL;
	} else if (disassFlags & RIVER_BRANCH_INSTR_SYSCALL) {
		pCB->dwBranchInstruction = RIVER_JUMP_INSTR_SYSCALL;
	}

	if (disassFlags & RIVER_BRANCH_TYPE_IMM) {
		pCB->dwBranchType = RIVER_JUMP_TYPE_IMM;
	} else if (disassFlags & RIVER_BRANCH_TYPE_MEM) {
		pCB->dwBranchType = RIVER_JUMP_TYPE_MEM;
	} else if (disassFlags & RIVER_BRANCH_TYPE_REG) {
		pCB->dwBranchType = RIVER_JUMP_TYPE_REG;
	}
}

bool RiverCodeGen::Translate(RiverBasicBlock *pCB, nodep::DWORD dwTranslationFlags, RevtracerError *rerror) {
	bool ret;

	if (dwTranslationFlags & 0x80000000) {
		pCB->dwSize = 0;
		pCB->dwCRC = (nodep::DWORD)crc32(0xEDB88320, (nodep::BYTE *)pCB->address, 0);

		outBufferSize = 0;
		pCB->pCode = pCB->pFwCode = (unsigned char *)pCB->address;
		pCB->pBkCode = NULL;

		rerror->errorCode = RERROR_OK;
		return true;
	} else {

		Reset();

		nodep::DWORD disassFlags;
		pCB->dwOrigOpCount = 0;
		pCB->dwSize = TranslateBasicBlock((nodep::BYTE *)pCB->address,
				pCB->dwOrigOpCount, pCB->pDisasmCode, dwTranslationFlags,
				&disassFlags, pCB->pBranchNext, rerror);

		SetBranchInfo(pCB, disassFlags);

		if (pCB->dwSize == 0 && rerror->errorCode != RERROR_OK) {
			return false;
		}

		trInstCount += pCB->dwOrigOpCount;
		pCB->dwCRC = (nodep::DWORD)crc32(0xEDB88320, (nodep::BYTE *)pCB->address, pCB->dwSize);

		revtracerImports.dbgPrintFunc(PRINT_DEBUG, "## this: %08x\n", (nodep::DWORD)this);

		if (dwTranslationFlags & TRACER_FEATURE_REVERSIBLE) {
			// generate the reverse basic block representations
			revtracerImports.dbgPrintFunc(PRINT_DEBUG, "##Rev: %08x %d instructions\n", fwRiverInst, fwInstCount);
			for (nodep::DWORD i = 0; i < fwInstCount; ++i) {
				//TranslateReverse(this, &fwRiverInst[fwInstCount - 1 - i], &bkRiverInst[i], &tmp);
				const RiverInstruction ri = fwRiverInst[fwInstCount - 1 - i];
				ret = revTranslator.Translate(ri, bkRiverInst[i]);
				if (!ret) {
					rerror->prefix = (ri.modifiers | RIVER_MODIFIER_EXT) ? 0xFF : 0x00;
					rerror->opcode = *((nodep::BYTE*)ri.instructionAddress);
					rerror->translatorId = RIVER_REVERSE_TRANSLATOR_ID;
					rerror->instructionAddress = ri.instructionAddress;
					rerror->errorCode = RERROR_UNK_INSTRUCTION;
					return false;
				}
			}
			MakeJMP(&bkRiverInst[fwInstCount], pCB->address);
			bkInstCount = fwInstCount + 1;
		}

		if (dwTranslationFlags & TRACER_FEATURE_TRACKING) {
			TRANSLATE_PRINT(PRINT_INFO | PRINT_TRANSLATION | PRINT_TRACKING, "= SymbopTrack =================================================================\n");
			for (unsigned int i = 0; i < symbopInstCount; ++i) {
				TRANSLATE_PRINT_INSTRUCTION(PRINT_INFO | PRINT_TRANSLATION | PRINT_TRACKING, &symbopInst[i]);
			}
			TRANSLATE_PRINT(PRINT_INFO | PRINT_TRANSLATION | PRINT_TRACKING, "===============================================================================\n");

			if (dwTranslationFlags & TRACER_FEATURE_REVERSIBLE) {
				sfInstCount = 0;
				for (unsigned int i = 0; i < symbopInstCount; ++i) {
					const RiverInstruction si = symbopInst[i];
					ret = symbopSaveTranslator.Translate(si, &symbopFwRiverInst[sfInstCount], sfInstCount);
					if (!ret) {
						rerror->prefix = (si.modifiers | RIVER_MODIFIER_EXT) ? 0xFF : 0x00;
						rerror->opcode = *((nodep::BYTE*)si.instructionAddress);
						rerror->translatorId = RIVER_SYMBOP_SAVE_TRANSLATOR_ID;
						rerror->instructionAddress = si.instructionAddress;
						rerror->errorCode = RERROR_UNK_INSTRUCTION;
						return false;
					}
				}

				TRANSLATE_PRINT(PRINT_INFO | PRINT_TRANSLATION | PRINT_TRACKING | PRINT_FORWARD, "= SymbopFwRiverTrack ==========================================================\n");
				for (nodep::DWORD i = 0; i < sfInstCount; ++i) {
					TRANSLATE_PRINT_INSTRUCTION(PRINT_INFO | PRINT_TRANSLATION | PRINT_TRACKING | PRINT_FORWARD, &symbopFwRiverInst[i]);
				}
				TRANSLATE_PRINT(PRINT_INFO | PRINT_TRANSLATION | PRINT_TRACKING | PRINT_FORWARD, "===============================================================================\n");

				for (nodep::DWORD i = 0; i < sfInstCount; ++i) {
					const RiverInstruction sfri = symbopFwRiverInst[sfInstCount - 1 - i];
					ret = symbopReverseTranslator.Translate(sfri, symbopBkRiverInst[i]);
					if (!ret) {
						rerror->prefix = (sfri.modifiers | RIVER_MODIFIER_EXT) ? 0xFF : 0x00;
						rerror->opcode = *((nodep::BYTE*)sfri.instructionAddress);
						rerror->translatorId = RIVER_SYMBOP_REVERSE_TRANSLATOR_ID;
						rerror->instructionAddress = sfri.instructionAddress;
						rerror->errorCode = RERROR_UNK_INSTRUCTION;
						return false;
					}
				}
				sbInstCount = sfInstCount;

				TRANSLATE_PRINT(PRINT_INFO | PRINT_TRANSLATION | PRINT_TRACKING | PRINT_BACKWARD, "= SymbopBkRiverTrack ==========================================================\n");
				for (nodep::DWORD i = 0; i < sbInstCount; ++i) {
					TRANSLATE_PRINT_INSTRUCTION(PRINT_INFO | PRINT_TRANSLATION | PRINT_TRACKING | PRINT_BACKWARD, &symbopBkRiverInst[i]);
				}
				TRANSLATE_PRINT(PRINT_INFO | PRINT_TRANSLATION | PRINT_TRACKING | PRINT_BACKWARD, "===============================================================================\n");
			}
		}


		if (revtracerConfig.dumpBlocks) {
			SaveToStream(fwRiverInst, fwInstCount, bkRiverInst, bkInstCount, symbopInst, symbopInstCount);
		}

		//outBufferSize = rivertox86(this, rt, trRiverInst, trInstCount, outBuffer, 0x00);
		//assembler.Assemble(trRiverInst, trInstCount, outBuffer, 0x00, pCB->, outBufferSize);
		//pCB->pCode = DuplicateBuffer(heap, outBuffer, outBufferSize);

		//outBufferSize = rivertox86(this, rt, fwRiverInst, fwInstCount, outBuffer, 0x01);
		codeBuffer.Reset();
		assembler.Assemble(fwRiverInst, fwInstCount, codeBuffer, 0x10, pCB->dwFwOpCount, outBufferSize, ASSEMBLER_CODE_NATIVE | ASSEMBLER_DIR_FORWARD);
		pCB->pFwCode = DuplicateBuffer(heap, outBuffer, outBufferSize);
		//assembler.CopyFix(pCB->pFwCode, outBuffer);
		codeBuffer.CopyToFixed(pCB->pFwCode);
		
		//outBufferSize = rivertox86(this, rt, bkRiverInst, bkInstCount, outBuffer, 0x00);

		if (dwTranslationFlags & TRACER_FEATURE_REVERSIBLE) {
			codeBuffer.Reset();
			assembler.Assemble(bkRiverInst, bkInstCount, codeBuffer, 0x00, pCB->dwBkOpCount, outBufferSize, ASSEMBLER_CODE_NATIVE | ASSEMBLER_DIR_BACKWARD);
			pCB->pBkCode = DuplicateBuffer(heap, outBuffer, outBufferSize);
			//assembler.CopyFix(pCB->pBkCode, outBuffer);
			codeBuffer.CopyToFixed(pCB->pBkCode);
		}

		if (dwTranslationFlags & TRACER_FEATURE_TRACKING) {
			RiverInstruction *fwTrace = symbopInst;
			nodep::DWORD fwTraceCount = symbopInstCount;

			if (dwTranslationFlags & TRACER_FEATURE_REVERSIBLE) {
				fwTrace = symbopFwRiverInst;
				fwTraceCount = sfInstCount;
			}

			codeBuffer.Reset();
			assembler.Assemble(fwTrace, fwTraceCount, codeBuffer, 0x10, pCB->dwTrOpCount, outBufferSize, ASSEMBLER_CODE_TRACKING | ASSEMBLER_DIR_FORWARD);
			pCB->pTrackCode = DuplicateBuffer(heap, outBuffer, outBufferSize);
			codeBuffer.CopyToFixed(pCB->pTrackCode);

			if (dwTranslationFlags & TRACER_FEATURE_REVERSIBLE) {
				codeBuffer.Reset();
				assembler.Assemble(symbopBkRiverInst, sbInstCount, codeBuffer, 0x00, pCB->dwRtOpCount, outBufferSize, ASSEMBLER_CODE_TRACKING | ASSEMBLER_DIR_BACKWARD);
				pCB->pRevTrackCode = DuplicateBuffer(heap, outBuffer, outBufferSize);
				codeBuffer.CopyToFixed(pCB->pRevTrackCode);
			}
		}

		return true;
	}
}

```

`revtracer/common.h`:

```h
#ifndef _COMMON_H
#define _COMMON_H

#ifdef _REVTRACER_DEBUG_PRINT_
#define ENABLE_DEBUG_TRANSLATIONS
#define ENABLE_DEBUG_TRACKING
#define ENABLE_DEBUG_BRANCHING
#endif


#ifdef ENABLE_DEBUG_TRANSLATIONS
#define TRANSLATE_PRINT revtracerImports.dbgPrintFunc
#define TRANSLATE_PRINT_INSTRUCTION RiverPrintInstruction
#else
#define TRANSLATE_PRINT
#define TRANSLATE_PRINT_INSTRUCTION
#endif

#ifdef ENABLE_DEBUG_TRACKING
#define TRACKING_PRINT revtracerImports.dbgPrintFunc
#define LIB_TRACKING_PRINT exec->DebugPrintf
#else
#define TRACKING_PRINT
#define LIB_TRACKING_PRINT
#endif

#ifdef ENABLE_DEBUG_BRANCHING
#define BRANCHING_PRINT revtracerImports.dbgPrintFunc
#else
#define BRANCHING_PRINT
#endif

#ifdef _MSC_VER
#define DEBUG_BREAK __asm \
{ __asm int 3 }
#else
#define DEBUG_BREAK asm volatile("int $0x3")
typedef unsigned int size_t;
#endif

#endif

```

`revtracer/crc32.cpp`:

```cpp
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id: crc32.cpp,v 1.1 2005/03/17 10:30:53 mihai Exp $ */

/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */

const unsigned long crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};


/* ========================================================================= */

#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
unsigned long crc32 (unsigned long crc, unsigned char *buf, unsigned long len)
{
    if (!buf) return 0L;

    crc = crc ^ 0xffffffffL;

    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}


```

`revtracer/crc32.h`:

```h
#ifndef _CRC32_H
#define _CRC32_H

unsigned long crc32 (unsigned long crc, unsigned char *buf, unsigned long len);

#endif

```

`revtracer/crtStub.cpp`:

```cpp
#include "common.h"

extern "C" int __cdecl _purecall(void) {
	DEBUG_BREAK;
	return 0;
}
```

`revtracer/environment.h`:

```h
#ifndef _ENVIRONMENT_H
#define _ENVIRONMENT_H

#include "revtracer.h"

//void *EnvMemoryAlloc (DWORD dwSize);
//void EnvMemoryFree (void *b);

extern "C" {
	void __stdcall BranchHandler(
		struct ExecutionEnvironment *, 
		rev::ADDR_TYPE
	);
	void __stdcall SysHandler(
		struct ExecutionEnvironment *
	);
	void __cdecl   SysEndHandler(
		struct ExecutionEnvironment *, 
		nodep::DWORD, 
		nodep::DWORD, 
		nodep::DWORD, 
		nodep::DWORD, 
		nodep::DWORD, 
		nodep::DWORD, 
		nodep::DWORD, 
		nodep::DWORD, 
		nodep::DWORD
	);
};

int dbg0(char *pFormat);
int dbg1(char *pFormat, nodep::DWORD p1);
int dbg2(char *pFormat, nodep::DWORD p1, nodep::DWORD p2);

#endif

```

`revtracer/execenv.cpp`:

```cpp
#include "execenv.h"
#include "mm.h"
#include "cb.h"

#include "revtracer.h"

void *ExecutionEnvironment::operator new(size_t sz){
	void *storage = revtracerImports.memoryAllocFunc(sz);
	if (NULL == storage) {
		DEBUG_BREAK;
		return NULL;
	}
	return storage;
}

void ExecutionEnvironment::operator delete(void *ptr) {
	revtracerImports.memoryFreeFunc((nodep::BYTE *)ptr);
}

ExecutionEnvironment::ExecutionEnvironment(nodep::DWORD flags, unsigned int heapSize, unsigned int historySize, unsigned int executionSize, unsigned int trackSize, unsigned int logHashSize, unsigned int outBufferSize) {
	bValid = false;
	generationFlags = flags;
	exitAddr = 0xFFFFCAFE;
	if (0 == heap.Init(heapSize)) {
		return;
	}

	//if (0 == InitBlock(pEnv, logHashSize, historySize)) {
	if (0 == blockCache.Init(&heap, logHashSize, historySize)) {
		heap.Destroy();
		return;
	}

	if (0 == (executionBuffer = (nodep::UINT_PTR *)revtracerImports.memoryAllocFunc(executionSize + trackSize + 4096))) {
		blockCache.Destroy();
		heap.Destroy();
		return;
	}

	if (!codeGen.Init(&heap, &runtimeContext, outBufferSize, generationFlags)) {
		revtracerImports.memoryFreeFunc(executionBuffer);
		blockCache.Destroy();
		heap.Destroy();
		return;
	}

	if (NULL == (pStack = (unsigned char *)revtracerImports.memoryAllocFunc(0x100000))) {
		codeGen.Destroy();
		revtracerImports.memoryFreeFunc(executionBuffer);
		blockCache.Destroy();
		heap.Destroy();
		return;
	}


	rev_memset(pStack, 0, 0x100000);

	runtimeContext.execBuff = (nodep::DWORD)executionBuffer + executionSize - 4; //TODO: make independant track buffer 
	executionBase = runtimeContext.execBuff;

	runtimeContext.trackStack = (nodep::DWORD)executionBuffer + executionSize + trackSize - 4;
	runtimeContext.trackBuff = runtimeContext.trackBase = (nodep::DWORD)executionBuffer + executionSize + trackSize + 4096;
	runtimeContext.virtualStack = (nodep::DWORD)pStack + 0xFFFF0;
	runtimeContext.firstEsp = 0xFFFFFFFF;

	ac.Init();
	//this is a major hack...
	// remove after addres tracking is completely decoupled from the reversible tracking
	runtimeContext.taintedAddresses = (nodep::UINT_PTR)this;

	bValid = true;
}

/*struct _exec_env *_exec_env::NewEnv(unsigned int heapSize, unsigned int historySize, unsigned int executionSize, unsigned int logHashSize, unsigned int outBufferSize) {
	struct _exec_env *pEnv;

	if (NULL == (pEnv = (struct _exec_env *)EnvMemoryAlloc(sizeof(*pEnv)))) {
		return NULL;
	}

	struct _exec_env *tEnv = new (pEnv)_exec_env(heapSize, historySize, executionSize, logHashSize, outBufferSize);

	if ((NULL == tEnv) || (!tEnv->bValid)) {
		EnvMemoryFree((BYTE *)pEnv);
		return NULL;
	}

	return pEnv;
}*/

ExecutionEnvironment::~ExecutionEnvironment() {
	blockCache.Destroy(); 
	heap.Destroy();

	revtracerImports.memoryFreeFunc((nodep::BYTE *)executionBuffer);

	revtracerImports.memoryFreeFunc((nodep::BYTE *)pStack);
	pStack = NULL;
}

/*void SetUserContext(struct ExecutionEnvironment *pEnv, void *ptr) {
	pEnv->userContext = ptr;
}*/

/*void *AllocUserContext(struct ExecutionEnvironment *pEnv, unsigned int size) {
	if (NULL != pEnv->userContext) {
		return NULL;
	}

	pEnv->userContext = pEnv->heap.Alloc(size);
	rev_memset(pEnv->userContext, 0, size);
	return pEnv->userContext;
}

void DeleteUserContext(struct ExecutionEnvironment *pEnv) {
	if (NULL == pEnv->userContext) {
		return;
	}

	pEnv->heap.Free(pEnv->userContext);
	pEnv->userContext = NULL;
}*/

```

`revtracer/execenv.h`:

```h
#ifndef _EXEC_ENV_H
#define _EXEC_ENV_H

#include "environment.h"
#include "sync.h"
#include "river.h"
#include "mm.h"
#include "cb.h"
#include "CodeGen.h"
#include "Runtime.h"
#include "AddressContainer.h"

struct ExecutionEnvironment {
	RiverRuntime runtimeContext;

	nodep::UINT_PTR saveLog;
	
	unsigned int /*heapSize,*/ historySize /*, logHashSize*/, outBufferSize;

	unsigned char *pStack; // = NULL;

	RiverHeap heap;

	//_tbm_mutex cbLock; //  = 0;
	//struct _cb_info **hashTable; // = 0
	RiverBasicBlockCache blockCache;

	nodep::UINT_PTR lastFwBlock;
	//UINT_PTR *history;
	//unsigned long posHist, totHist; // = 0;

	nodep::UINT_PTR *executionBuffer, executionBase;

	//unsigned char *saveBuffer;

	unsigned int bForward;

	RiverCodeGen codeGen;

	nodep::DWORD exitAddr;

	bool bValid;
	void *userContext;

	AddressContainer ac;

	nodep::DWORD generationFlags;
public :
	void* operator new(size_t);
	void operator delete(void*);

	ExecutionEnvironment(nodep::DWORD flags, unsigned int heapSize, unsigned int historySize, unsigned int executionSize, unsigned int trackSize, unsigned int logHashSize, unsigned int outBufferSize);
	~ExecutionEnvironment();
};

void *AllocUserContext(struct ExecutionEnvironment *pEnv, unsigned int size);
void DeleteUserContext(struct ExecutionEnvironment *pEnv);

#endif

```

`revtracer/extern.cpp`:

```cpp
#include <stdlib.h>
//#include <stdio.h>
#include <stdarg.h>
#include <share.h>

#include <Windows.h>
#include <winternl.h>
#include <intrin.h>

#include "extern.h"

/*#ifdef USE_VBOX_SNAPSHOTS
#include "VBoxSnapshotDll.h"

HMODULE hVboxDll = NULL;
BDTakeSnapshotType takeSnapshot = NULL;
BDRestoreSnapshotType restoreSnapshot = NULL;
BDSnapshotInitType initSnapshot = NULL;

struct SnapshotInitializer {
	SnapshotInitializer() {
		hVboxDll = LoadLibrary(VBOXSNAPSHOTDLL_DLL_NAME);

		if (NULL == hVboxDll) {
			return;
		}

		initSnapshot = (BDSnapshotInitType)GetProcAddress(hVboxDll, "BDSnapshotInit");

		if ((NULL == initSnapshot) || (FALSE == initSnapshot())) {
			return;
		}

		takeSnapshot = (BDTakeSnapshotType)GetProcAddress(hVboxDll, "BDTakeSnapshot");
		restoreSnapshot = (BDTakeSnapshotType)GetProcAddress(hVboxDll, "BDRestoreSnapshot");
	}

	~SnapshotInitializer() {
		if (NULL != hVboxDll) {
			FreeLibrary(hVboxDll);
		}
	}
} _snapshotInitializer;
#endif*/

void __declspec(dllimport) RtlSetLastWin32Error(ULONG);
int __stdcall MyBaseSetLastNTError(NTSTATUS nErr) {
	
	ULONG dErr = RtlNtStatusToDosError(nErr);
	//RtlSetLastWin32Error(dErr);
	return dErr;
}

QWORD __TakeSnapshot() {
#ifdef USE_VBOX_SNAPSHOTS
	/*if (NULL != takeSnapshot) {
		return takeSnapshot();
	}
	return BD_SNAPSHOT_FAIL;*/
#endif
	return 0;
}

TakeSnapshotFunc TakeSnapshot = __TakeSnapshot;

QWORD __RestoreSnapshot() {
#ifdef USE_VBOX_SNAPSHOTS
	/*if (NULL != restoreSnapshot) {
		return restoreSnapshot();
	}
	return BD_SNAPSHOT_FAIL;*/
#endif
	return 0;
}

RestoreSnapshotFunc RestoreSnapshot = __RestoreSnapshot;

__declspec(dllexport) DWORD myRtlExitUserProcess;

//DWORD dwExitProcess = (DWORD)RtlExitUserProcess;

__declspec(dllimport) int vsnprintf_s(
	char *buffer,
	size_t sizeOfBuffer,
	size_t count,
	const char *format,
	va_list argptr
);

/*struct _ {
	HANDLE fDbg;
	_() {
		fDbg = CreateFile("translation.log", GENERIC_WRITE, FILE_SHARE_READ, NULL, TRUNCATE_EXISTING, 0, NULL);
		if (INVALID_HANDLE_VALUE == fDbg) {
			__asm int 3;
		}
	}

	~_() {
		CloseHandle(fDbg);
	}
} __;

void __DbgPrint(const char *fmt, ...) {
	va_list va;
	char tmpBuff[512];

	va_start(va, fmt);
	int sz = vsnprintf_s(tmpBuff, sizeof(tmpBuff)-1, sizeof(tmpBuff)-1, fmt, va);
	va_end(va);

	unsigned long wr;
	WriteFile(__.fDbg, tmpBuff, sz * sizeof(tmpBuff[0]), &wr, NULL);
	//FlushFileBuffers(__.fDbg);
}*/

void ___DbgPrint(const char *fmt, ...) {
}

DbgPrintFunc DbgPrint = ___DbgPrint;


typedef NTSTATUS(NTAPI *NtAllocateVirtualMemoryFunc)(
	IN HANDLE               ProcessHandle,
	IN OUT PVOID            *BaseAddress,
	IN ULONG                ZeroBits,
	IN OUT PULONG           RegionSize,
	IN ULONG                AllocationType,
	IN ULONG                Protect);

__declspec(dllexport) NtAllocateVirtualMemoryFunc MyNtAllocateVirtualMemory;

LPVOID __stdcall MyVirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {
	LPVOID addr = lpAddress;
	if (lpAddress && (unsigned int)lpAddress < 0x10000) {
		//RtlSetLastWin32Error(87);
	} else {
		NTSTATUS ret = MyNtAllocateVirtualMemory(
			hProcess, 
			&addr, 
			0, 
			&dwSize, 
			flAllocationType & 0xFFFFFFF0, 
			flProtect
		);
		if (NT_SUCCESS(ret)) {
			return addr;
		}
		MyBaseSetLastNTError(ret);
	}
	return 0;
}


LPVOID __stdcall MyVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {
	return MyVirtualAllocEx((HANDLE)0xFFFFFFFF, lpAddress, dwSize, flAllocationType, flProtect);
}


void *__EnvMemoryAlloc(unsigned long dwSize) {
	//return ExAllocatePoolWithTag(NonPagedPool, dwSize, 0x3070754C);
	void *ret = MyVirtualAlloc(NULL, dwSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	return ret;
}

MemoryAllocFunc EnvMemoryAlloc = __EnvMemoryAlloc;

void __EnvMemoryFree(void *b) {
	//ExFreePoolWithTag(b, 0x3070754C);
	//VirtualFree(b);
}

MemoryFreeFunc EnvMemoryFree = __EnvMemoryFree;

typedef BOOL (*MyIPFPFunc)(DWORD ProcessorFeature);

BOOL __stdcall MyIsProcessorFeaturePresent(DWORD ProcessorFeature) {
	static MyIPFPFunc func = NULL;

	/*if (NULL == func) {
		HMODULE hKernel = GetModuleHandle("kernel32.dll");
		func = (MyIPFPFunc)GetProcAddress(hKernel, "IsProcessorFeaturePresent");
	}*/

	switch (ProcessorFeature) {
	case PF_MMX_INSTRUCTIONS_AVAILABLE :
	case PF_SSE3_INSTRUCTIONS_AVAILABLE :
	case PF_XMMI64_INSTRUCTIONS_AVAILABLE :
	case PF_XMMI_INSTRUCTIONS_AVAILABLE :
	case PF_COMPARE_EXCHANGE_DOUBLE :
	case PF_COMPARE_EXCHANGE128 :
	case PF_COMPARE64_EXCHANGE128 :
		return FALSE;
	default:
		//return func(ProcessorFeature);
		return TRUE;
	}
}

VOID __stdcall MyExitProcess(DWORD retCode) {
	//printf("Guest process exited with code %d\n", retCode);
}
```

`revtracer/main.cpp`:

```cpp
#include "common.h"
#include "extern.h"
#include "cb.h"
#include "callgates.h"

#include "AddressContainer.h"

#include "river.h"
#include <intrin.h>

#include <stdio.h>
#include <stdlib.h>

FILE *fBlocks;

extern DWORD segmentOffsets[0x100];

AddressContainer ac;

DWORD __stdcall TrackAddr(struct _exec_env *pEnv, DWORD dwAddr, DWORD segSel) {
	DWORD ret = ac.Get(dwAddr + segmentOffsets[segSel & 0xFFFF]);
	DbgPrint("TrackAddr 0x%08x => %d\n", dwAddr + segmentOffsets[segSel & 0xFFFF], ret);
	return ret;
}

DWORD __stdcall MarkAddr(struct _exec_env *pEnv, DWORD dwAddr, DWORD value, DWORD segSel) {
	DbgPrint("MarkAddr 0x%08x <= %d\n", dwAddr + segmentOffsets[segSel & 0xFFFF], value);
	return ac.Set(dwAddr + segmentOffsets[segSel & 0xFFFF], value);
}

DWORD dwAddressTrackHandler = (DWORD)&TrackAddr;
DWORD dwAddressMarkHandler = (DWORD)&MarkAddr;

struct UserCtx {
	DWORD callCount;
};

void RiverPrintInstruction(struct RiverInstruction *ri);
void TransalteSave(struct _exec_env *pEnv, struct RiverInstruction *rIn, struct RiverInstruction *rOut, DWORD *outCount);
void TranslateReverse(struct _exec_env *pEnv, struct RiverInstruction *rIn, struct RiverInstruction *rOut, DWORD *outCount);

void PushToExecutionBuffer(struct _exec_env *pEnv, DWORD value) {
	pEnv->runtimeContext.execBuff -= 4;
	*((DWORD *)pEnv->runtimeContext.execBuff) = value;
}

DWORD PopFromExecutionBuffer(struct _exec_env *pEnv) {
	DWORD ret = *((DWORD *)pEnv->runtimeContext.execBuff);
	pEnv->runtimeContext.execBuff += 4;
	return ret;
}

DWORD TopFromExecutionBuffer(struct _exec_env *pEnv) {
	return *((DWORD *)pEnv->runtimeContext.execBuff);
}

extern DWORD dwExitProcess;
struct Regs {
	DWORD edi;
	DWORD esi;
	DWORD ebp;
	DWORD esp;

	DWORD ebx;
	DWORD edx;
	DWORD ecx;
	DWORD eax;
	DWORD eflags;
} regClone[2];
DWORD execStack[2];

bool RegCheck(struct _exec_env *pEnv, const Regs &r1, const Regs &r2) {
	if (r1.eax != r2.eax) {
		DbgPrint("EAX inconsistent!\n");
		return false;
	}

	if (r1.ecx != r2.ecx) {
		DbgPrint("ECX inconsistent!\n");
		return false;
	}

	if (r1.edx != r2.edx) {
		DbgPrint("EDX inconsistent!\n");
		return false;
	}

	if (r1.ebx != r2.ebx) {
		DbgPrint("EBX inconsistent!\n");
		return false;
	}

	if (r1.esp != r2.esp) {
		DbgPrint("ESP inconsistent!\n");
		return false;
	}

	if (r1.ebp != r2.ebp) {
		DbgPrint("EBP inconsistent!\n");
		return false;
	}

	if (r1.esi != r2.esi) {
		DbgPrint("ESI inconsistent!\n");
		return false;
	}

	if (r1.edi != r2.edi) {
		DbgPrint("ESI inconsistent!\n");
		return false;
	}

	if (r1.eflags != r2.eflags) {
		DbgPrint("EFLAGS inconsistent!\n");
		return false;
	}
	return true;
}

struct ExecStats {
	int blocksForward, blocksBackward;
	int nativeForward, nativeBackward;
	int transForward, transBackward;
};

void AddStates(void *ctx, RiverBasicBlock *bb) {
	ExecStats *stats = (ExecStats *)ctx;

	stats->blocksForward += bb->dwFwPasses;
	stats->blocksBackward += bb->dwBkPasses;

	stats->transForward += bb->dwFwPasses * bb->dwFwOpCount;
	stats->transBackward += bb->dwBkPasses * bb->dwBkOpCount;

	stats->nativeForward += bb->dwFwPasses * bb->dwOrigOpCount;
	stats->nativeBackward += bb->dwBkPasses * bb->dwOrigOpCount;
}

void PrintStats(struct _exec_env *env) {
	ExecStats stats;
	memset(&stats, 0, sizeof(stats));

	env->blockCache.ForEachBlock(&stats, AddStates);
	DbgPrint("========================================\n");
	DbgPrint("Native fw:%9d; Native bw:%9d\n", stats.nativeForward, stats.nativeBackward);
	DbgPrint("Blocks fw:%9d; Blocks bw:%9d\n", stats.blocksForward, stats.blocksBackward);
	DbgPrint("Trans fw: %9d; Trans bw: %9d\n", stats.transForward,  stats.transBackward);
	DbgPrint("========================================\n");
}

typedef void(*TrackFunc)(DWORD trackBuffer);

void __stdcall BranchHandler(struct _exec_env *pEnv, DWORD a) {
	Regs *currentRegs = (Regs *)((&a) + 1);
	RiverBasicBlock *pCB;
	struct UserCtx *ctx = (struct UserCtx *)pEnv->userContext;

	if (0x0f00100a == a) {
		ac.Set(0x0f000000 + 0x30540, 1);
		ac.Set(0x0f000000 + 0x30544, 2);
		ac.Set(0x0f000000 + 0x30548, 4);
		ac.Set(0x0f000000 + 0x3054C, 8);

	}

	pEnv->runtimeContext.trackBuff = pEnv->runtimeContext.trackBase;

	//DbgPrint("BranchHandler: %08X\n", a);

	DWORD dwLastBlock = pEnv->lastFwBlock; //TopFromExecutionBuffer(pEnv);
	RiverBasicBlock *pLast = pEnv->blockCache.FindBlock(dwLastBlock);
	if (NULL != pLast) {
		((TrackFunc)pLast->pTrackCode)(pEnv->runtimeContext.trackBase - 4);
	}


	fprintf(fBlocks, "0x%08x\n", a /*& 0xFFFF*/);
	fflush(fBlocks);

	if (a == dwExitProcess) {
		PrintStats(pEnv);
		DbgPrint(" +++ Tainted addresses +++ \n");
		ac.PrintAddreses();
		DbgPrint(" +++++++++++++++++++++++++ \n");
		exit(0);
	}


	//DbgPrint("pEnv %08X\n", pEnv);
	//DbgPrint("sizes: %08X, %08X, %08X, %08X\n", pEnv->heapSize, pEnv->historySize, pEnv->logHashSize, pEnv->outBufferSize);
	if (pEnv->bForward) {
		PushToExecutionBuffer(pEnv, pEnv->lastFwBlock);
	} else {
		/*if (!RegCheck(pEnv, *currentRegs, regClone)) {
			__asm int 3;
		}*/
		switch (ctx->callCount % 5) {
		case 3:
			//copy the registers to validate them later
			if (!RegCheck(pEnv, *currentRegs, regClone[1])) {
				__asm int 3;
			}

			if (execStack[1] != pEnv->runtimeContext.virtualStack) {
				//__asm int 3
			}
			break;
		case 4:
			//copy the registers to validate them later
			if (!RegCheck(pEnv, *currentRegs, regClone[0])) {
				__asm int 3;
			}

			if (execStack[0] != pEnv->runtimeContext.virtualStack) {
				//__asm int 3
			}
			break;
		}
	}

	ctx->callCount++;

	DWORD *stk = (DWORD *)pEnv->runtimeContext.virtualStack;
	DbgPrint("Stack :\n");
	DbgPrint("0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x\n", stk + 0x00, stk[0], stk[1], stk[2], stk[3]);
	DbgPrint("EAX: 0x%08x  ECX: 0x%08x  EDX: 0x%08x  EBX: 0x%08x\n", currentRegs->eax, currentRegs->ecx, currentRegs->edx, currentRegs->ebx);
	DbgPrint("ESP: 0x%08x  EBP: 0x%08x  ESI: 0x%08x  EDI: 0x%08x\n", currentRegs->esp, currentRegs->ebp, currentRegs->esi, currentRegs->edi);
	DbgPrint("Flags: 0x%08x\n", currentRegs->eflags);

	DbgPrint("Tainted registers :\n");
	DbgPrint("EAX: 0x%08x  ECX: 0x%08x  EDX: 0x%08x  EBX: 0x%08x\n", pEnv->runtimeContext.taintedRegisters[0], pEnv->runtimeContext.taintedRegisters[1], pEnv->runtimeContext.taintedRegisters[2], pEnv->runtimeContext.taintedRegisters[3]);
	DbgPrint("ESP: 0x%08x  EBP: 0x%08x  ESI: 0x%08x  EDI: 0x%08x\n", pEnv->runtimeContext.taintedRegisters[4], pEnv->runtimeContext.taintedRegisters[5], pEnv->runtimeContext.taintedRegisters[6], pEnv->runtimeContext.taintedRegisters[7]);
	DbgPrint("CF: 0x%08x  PF: 0x%08x  AF: 0x%08x  ZF: 0x%08x  SF: 0x%08x  OF: 0x%08x  DF: 0x%08x\n", 
		pEnv->runtimeContext.taintedFlags[0],
		pEnv->runtimeContext.taintedFlags[1],
		pEnv->runtimeContext.taintedFlags[2],
		pEnv->runtimeContext.taintedFlags[3],
		pEnv->runtimeContext.taintedFlags[4],
		pEnv->runtimeContext.taintedFlags[5],
		pEnv->runtimeContext.taintedFlags[6]
	);
	/*DbgPrint("0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x\n", stk + 0x10, stk[4], stk[5], stk[6], stk[7]);
	DbgPrint("0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x\n", stk + 0x20, stk[8], stk[9], stk[10], stk[11]);
	DbgPrint("0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x\n", stk + 0x30, stk[12], stk[13], stk[14], stk[15]);*/

	if ((ctx->callCount % 5) > 5) {
		// go backwards
		DWORD addr = PopFromExecutionBuffer(pEnv);
		DbgPrint("Going Backwards to %08X!!!\n", addr);
		
		DbgPrint("Looking for block\n");
		pCB = pEnv->blockCache.FindBlock(addr);
		if (pCB) {
			DbgPrint("Block found\n");
			pCB->MarkBackward();
			//pEnv->posHist -= 1;
			pEnv->bForward = 0;
			pEnv->runtimeContext.jumpBuff = (DWORD)pCB->pBkCode;
		}
		else {
			DbgPrint("No reverse block found!");
			__asm int 3;
		}

	} else {
		// go forwards
		DbgPrint("Going Forwards from %08X!!!\n", a);
		__try {
			DbgPrint("Looking for block\n");
			pCB = pEnv->blockCache.FindBlock(a);
			if (pCB) {
				DbgPrint("Block found\n");
			} else {
				DbgPrint("Not Found\n");
				pCB = pEnv->blockCache.NewBlock(a);

				pEnv->codeGen.Translate(pCB, 0);

				DbgPrint("= river saving code ===========================================================\n");
				for (DWORD i = 0; i < pEnv->codeGen.fwInstCount; ++i) {
					RiverPrintInstruction(&pEnv->codeGen.fwRiverInst[i]);
				}
				DbgPrint("===============================================================================\n");

				DbgPrint("= river reversing code ========================================================\n");
				for (DWORD i = 0; i < pEnv->codeGen.bkInstCount; ++i) {
					RiverPrintInstruction(&pEnv->codeGen.bkRiverInst[i]);
				}
				DbgPrint("===============================================================================\n");
			}
			pCB->MarkForward();
			//pEnv->jumpBuff = (DWORD)pCB->pCode;
			//TouchBlock(pEnv, pCB);
			pEnv->lastFwBlock = pCB->address;
			pEnv->bForward = 1;

			switch (ctx->callCount % 5) {
				case 1: 
					//copy the registers to validate them later
					memcpy(&regClone[0], currentRegs, sizeof(regClone[0]));
					execStack[0] = pEnv->runtimeContext.virtualStack;
					break;
				case 2:
					//copy the registers to validate them later
					memcpy(&regClone[1], currentRegs, sizeof(regClone[1]));
					execStack[1] = pEnv->runtimeContext.virtualStack;
					break;
			}
			

			pEnv->runtimeContext.jumpBuff = (DWORD)pCB->pFwCode;
			fflush(stdout);
		}
		__except (1) { //EXCEPTION_EXECUTE_HANDLER
			pEnv->runtimeContext.jumpBuff = a;

			/*if ((pCB != NULL) && (pCB->dwParses > 0x800)) {
			int *a = 0;
			*a = arr;
			}*/
		}
	}
}


void __stdcall SysHandler(struct _exec_env *pEnv) {
	DbgPrint("SysHandler!!!\n");

	fprintf(fBlocks, "Syscall!!\n");
	fflush(fBlocks);

	TakeSnapshot();
}

int overlap(unsigned int a1, unsigned int a2, unsigned int b1, unsigned int b2);

bool MapPE(DWORD &baseAddr);

int main(unsigned int argc, char *argv[]) {
	/*DWORD baseAddr = 0xf000000;
	if (!MapPE(baseAddr)) {
		return false;
	}

	fopen_s(&fBlocks, "blocks.log", "wt");
	
	struct _exec_env *pEnv;
	struct UserCtx *ctx;
	DWORD dwCount = 0;
	pEnv = new _exec_env(0x1000000, 0x10000, 0x2000000, 16, 0x10000);

	pEnv->userContext = AllocUserContext(pEnv, sizeof(struct UserCtx));
	ctx = (struct UserCtx *)pEnv->userContext;
	ctx->callCount = 0;*/

	//unsigned char *pOverlap = (unsigned char *)*(unsigned int *)((unsigned char *)overlap + 1);
	//pOverlap += (UINT_PTR)overlap + 5;

	/*x86toriver(pEnv, pOverlap, ris, &dwCount);
	rivertox86(pEnv, ris, dwCount, tBuff);*/

	//DWORD ret = call_cdecl_4(pEnv, (_fn_cdecl_4)&overlap, (void *)3, (void *)7, (void *)2, (void *)10);
	//unsigned char *pMain = (unsigned char *)baseAddr + 0x96CE;
	//unsigned char *pMain = (unsigned char *)baseAddr + 0x1347;
	/*DWORD ret = call_cdecl_2(pEnv, (_fn_cdecl_2)pMain, (void *)argc, (void *)argv);
	DbgPrint("Done. ret = %d\n\n", ret);

	PrintStats(pEnv);

	DbgPrint(" +++ Tainted addresses +++ \n");
	ac.PrintAddreses();
	DbgPrint(" +++++++++++++++++++++++++ \n");*/

	/*DbgPrint("Test %d\n", overlap(3, 7, 2, 10));*/

	//fclose(fBlocks);

	return 0;
}
```

`revtracer/mm.cpp`:

```cpp
#include "mm.h"

//#include "lup.h" //for now
//volatile DWORD dwMMLock			= 0;

#include "common.h"
#include "revtracer.h"

extern "C" void rev_memcpy(void *dest, const void *src, unsigned int size) {
	for (unsigned int i = 0; i < size; ++i) {
		((char *)dest)[i] = ((char *)src)[i];
	}
}

extern "C" void rev_memset(void *dest, int val, unsigned int size) {
	for (unsigned int i = 0; i < size; ++i) {
		((char *)dest)[i] = val;
	}
}

struct HeapZone {
	HeapZone *Prev; // 0xFFFFFFFF if this is the first block
	HeapZone *Next; // 0xFFFFFFFF if this is the last block
	nodep::DWORD Size; // size of this block
	nodep::DWORD Type; // 0 - free, 1 - allocated
};

RiverHeap::RiverHeap() {
	pHeap = NULL;
	pFirstFree = NULL;
	size = 0;
}

RiverHeap::~RiverHeap() {
	if (0 != size) {
		Destroy();
	}
}

bool RiverHeap::Init(nodep::DWORD heapSize) {
	HeapZone *fz;
	unsigned char *tHeap;

	tHeap = pHeap = (unsigned char *)rev::revtracerImports.memoryAllocFunc(heapSize);

	if (!tHeap) {
		return false;
	}
	
	rev_memset(tHeap, 0, heapSize);

	fz = (HeapZone *)tHeap; 

	fz->Next = (HeapZone *) 0xFFFFFFFF;
	fz->Prev = (HeapZone *) 0xFFFFFFFF;
	fz->Type = 0;
	fz->Size = size - sizeof(HeapZone);

	pFirstFree = fz;

	size = heapSize;
	return true;
}

bool RiverHeap::Destroy() {
	if (pHeap) {
		rev::revtracerImports.memoryFreeFunc(pHeap);
		pHeap = NULL;
		pFirstFree = NULL;
		size = 0;
	}

	return true;
}


void RiverHeap::PrintInfo(HeapZone *fz) {
	rev::revtracerImports.dbgPrintFunc(PRINT_INSPECTION | PRINT_DEBUG, "FirstFree: %08X.\n", (nodep::DWORD)pFirstFree);
	rev::revtracerImports.dbgPrintFunc(PRINT_INSPECTION | PRINT_DEBUG, "fz  Addr : %08X.\n", (nodep::DWORD)fz);
	rev::revtracerImports.dbgPrintFunc(PRINT_INSPECTION | PRINT_DEBUG, "fz->Next : %08X.\n", (nodep::DWORD)fz->Next);
	rev::revtracerImports.dbgPrintFunc(PRINT_INSPECTION | PRINT_DEBUG, "fz->Prev : %08X.\n", (nodep::DWORD)fz->Prev);
	rev::revtracerImports.dbgPrintFunc(PRINT_INSPECTION | PRINT_DEBUG, "fz->Type : %08X.\n", (nodep::DWORD)fz->Type);
	rev::revtracerImports.dbgPrintFunc(PRINT_INSPECTION | PRINT_DEBUG, "fz->Size : %08X.\n", (nodep::DWORD)fz->Size);
	rev::revtracerImports.dbgPrintFunc(PRINT_INSPECTION | PRINT_DEBUG, "\n");
}


void *RiverHeap::Alloc(nodep::DWORD sz) {
	nodep::BYTE *b;
	nodep::DWORD first;
	HeapZone *fz, *nfz;

	sz += 3;
	sz &= ~3L;

//	SC_Lock (&dwMMLock);

	first = 1;

	fz = pFirstFree;

	do{
	//	SC_PrintInfo (fz);

		if (fz->Type == 0) {// free block
			if (sz + sizeof (HeapZone) <= fz->Size) {
			//	printf("Found a block of %d bytes. We need only %d.\n", fz->Size, sz);

				b = (nodep::BYTE *) fz + sizeof (HeapZone);

				nfz = (HeapZone *) ((nodep::BYTE *) fz + sizeof (HeapZone) + sz);

				if (fz->Next != (HeapZone *) 0xFFFFFFFF)
				{
					fz->Next->Prev = nfz;
				}

				nfz->Next = fz->Next;
				nfz->Prev = fz;
				nfz->Type = 0;
				nfz->Size = fz->Size - sz - sizeof (HeapZone);

				fz->Next = nfz;
				fz->Type = 1;
				fz->Size = sz;

				if (first) {
					pFirstFree = nfz;
				}

			//	SC_Unlock (&dwMMLock);
				
				return b;
			} else {
			//	printf("Free block, but only %d in size!\n", fz->Size);
				first = 0;
			}
		}

		fz = (HeapZone *) fz->Next;

	} while (fz != (HeapZone *) 0xFFFFFFFF);

//	SC_Unlock (&dwMMLock);

	return NULL;
}

void RiverHeap::List() {
	nodep::DWORD dwMaxSize;
	HeapZone *fz;

	fz = (HeapZone *)pHeap;

//	SC_Lock (&dwMMLock);

	dwMaxSize = 0;

	do{

	//	SC_PrintInfo (fz);

		if (fz->Type == 1)
		{		
		//	printf("fz->addr : %08X, fz->size : %08X.\n", fz, fz->Size);
			dwMaxSize += fz->Size;
		}

		fz = (HeapZone *) fz->Next;

	} while (fz != (HeapZone *) 0xFFFFFFFF);

//	printf("%d bytes of memory are in use.\n", dwMaxSize);

//	SC_Unlock (&dwMMLock);
}

void RiverHeap::Free(void *p) {
	HeapZone *fz, *wfz;

//	SC_Lock (&dwMMLock);

	fz = (HeapZone *) ((nodep::BYTE *)p - sizeof (HeapZone));

//	SC_PrintInfo (fz);

	fz->Type = 0;

	wfz = fz->Next;

	if (wfz != (HeapZone *) 0xFFFFFFFF) {// present?
		if (wfz->Type == 0) {// free?
			fz->Next = wfz->Next;
			fz->Size = fz->Size + wfz->Size + sizeof (HeapZone);
			fz->Type = 0;
		}
	}

	if (fz < pFirstFree) {
		pFirstFree = fz;
	}

	wfz = fz->Prev;

	if (wfz != (HeapZone *) 0xFFFFFFFF) {// present?
		if (wfz->Type == 0) {// free?
			wfz->Next = fz->Next;
			wfz->Size = wfz->Size + fz->Size + sizeof (HeapZone);

			if (wfz < pFirstFree) {
				pFirstFree = wfz;
			}
		}
	}

//	SC_Unlock (&dwMMLock);
}


```

`revtracer/mm.h`:

```h
#ifndef __MM_H
#define __MM_H

#include "revtracer.h"

#define HEAP_SIZE 0x100000

extern "C" void rev_memcpy(void *dest, const void *src, unsigned int size);
extern "C" void rev_memset(void *dest, int val, unsigned int size);

struct HeapZone;

/* A self contained heap */
class RiverHeap {
private :
	nodep::BYTE *pHeap;
	HeapZone *pFirstFree;
	nodep::DWORD size;
public :
	RiverHeap();
	~RiverHeap();

	bool Init(nodep::DWORD heapSize);
	bool Destroy();

	void PrintInfo(HeapZone *fz);
	void List();

	void *Alloc(nodep::DWORD size);
	void Free(void *ptr);
};

#endif // __MM_H


```

`revtracer/modrm32.cpp`:

```cpp

#include "execenv.h"
#include "modrm32.h"


nodep::BYTE Modrm16 [0x100] = 
			{
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 

				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 

				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03,
 
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01,
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01,
				01, 01, 01, 01, 01, 01, 01, 01
			};


nodep::DWORD GetModrmSize (nodep::DWORD dwFlags, nodep::BYTE *pI)
{
	nodep::DWORD dwExtra;
	nodep::BYTE bModRM, bRM, bMod, bSIB;

	if (dwFlags & FLAG_A16)
	{
		return (nodep::DWORD) (Modrm16 [pI[1]] - 1);
	}

	bModRM 		= * (pI + 1);

	bRM    		= bModRM & 0x07;
	bMod   		= bModRM >> 6;

	dwExtra = 0;

	switch (bMod)
	{
		case 0x00:
		{
			switch (bRM)
			{
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				{
					break;
				}
				case 0x04:
				{
					dwExtra = 1;
					bSIB = * (pI + 2);
					if ((bSIB & 0x07) == 0x05) // EBP
					{
						dwExtra += 4;
					}
					break;
				}
				case 0x05:
				{
					// imm32
					dwExtra = 4;
					break;
				}
				case 0x06:
				case 0x07:
				default:
				{
					break;
				}
			}
			break;
		}

		case 0x01:
		{
			switch (bRM)
			{
				case 0x04:
				{
					dwExtra = 2;
					break;
				}
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x05:
				case 0x06:
				case 0x07:
				default:
				{
					dwExtra = 1;
					break;
				}
			}
			break;
		}

		case 0x02:
		{
			switch (bRM)
			{
				case 0x04:
				{
					dwExtra = 5;
					break;
				}
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x05:
				case 0x06:
				case 0x07:
				default:
				{
					dwExtra = 4;
					break;
				}
			}
			break;
		}
		default : break;
	}

	return dwExtra;
}

```

`revtracer/modrm32.h`:

```h
#ifndef _MODRM32_H
#define _MODRM32_H

#define FLAG_NONE	0x00000000
#define FLAG_REP	0x00000001
#define FLAG_SEG	0x00000002
#define FLAG_O16	0x00000004
#define FLAG_A16	0x00000008
#define FLAG_LOCK	0x00000010
#define FLAG_EXT	0x00000020

/* river flag to mark a disabled instruction */
#define FLAG_RNONE  0x10000000
/* river flag to mark a custom opcode */
#define FLAG_RIVER  0x20000000
#define FLAG_PFX	0x40000000
#define FLAG_BRANCH	0x80000000

nodep::DWORD GetModrmSize (nodep::DWORD, nodep::BYTE *pI);

#endif //  _MODRM32_H


```

`revtracer/revtracer.cpp`:

```cpp
#include "revtracer.h"

#include "execenv.h"
#include "callgates.h"

#include <intrin.h>


//void InitSymbolicHandler(ExecutionEnvironment *pEnv);
//void *CreateSymbolicVariable(const char *name);

namespace rev {

	/* Kernel32.dll replacements *********************************************************/

	typedef void *LPVOID, *PVOID;
	typedef long NTSTATUS;
	typedef void *HANDLE;
	typedef int BOOL;
	typedef const void *LPCVOID;
	typedef nodep::DWORD *LPDWORD;

	typedef unsigned long ULONG;

#define TRUE  1
#define FALSE 0

#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     

#define MEM_COMMIT                  0x1000      
#define MEM_RESERVE                 0x2000      

	typedef void* (*AllocateMemoryCall)(size_t size);

	HANDLE Kernel32GetCurrentThread() {
		return (HANDLE)0xFFFFFFFE;
	}

	typedef struct {
		nodep::WORD    LimitLow;
		nodep::WORD    BaseLow;
		union {
			struct {
				nodep::BYTE    BaseMid;
				nodep::BYTE    Flags1;     // Declare as bytes to avoid alignment
				nodep::BYTE    Flags2;     // Problems.
				nodep::BYTE    BaseHi;
			} Bytes;
			struct {
				nodep::DWORD   BaseMid : 8;
				nodep::DWORD   Type : 5;
				nodep::DWORD   Dpl : 2;
				nodep::DWORD   Pres : 1;
				nodep::DWORD   LimitHi : 4;
				nodep::DWORD   Sys : 1;
				nodep::DWORD   Reserved_0 : 1;
				nodep::DWORD   Default_Big : 1;
				nodep::DWORD   Granularity : 1;
				nodep::DWORD   BaseHi : 8;
			} Bits;
		} HighWord;
	} LDT_ENTRY, *LPLDT_ENTRY;

	typedef nodep::DWORD THREADINFOCLASS;



	/* Default API functions ************************************************************/

	void NoDbgPrint(const unsigned int printMask, const char *fmt, ...) { }

	void DefaultIpcInitialize() {
	}

	void *DefaultMemoryAlloc(unsigned long dwSize) {
		DEBUG_BREAK;
		return nullptr;
	}

	void DefaultMemoryFree(void *ptr) {
		DEBUG_BREAK;
	}

	nodep::QWORD DefaultTakeSnapshot() {
		return 0;
	}

	nodep::QWORD DefaultRestoreSnapshot() {
		return 0;
	}

	void DefaultInitializeContextFunc(void *context) { }
	void DefaultCleanupContextFunc(void *context) { }

	nodep::DWORD DefaultExecutionBeginFunc(void *context, ADDR_TYPE nextInstruction, void *cbCtx) {
		return EXECUTION_ADVANCE;
	}

	nodep::DWORD DefaultExecutionControlFunc(void *context, ADDR_TYPE nextInstruction, void *cbCtx) {
		return EXECUTION_ADVANCE;
	}

	nodep::DWORD DefaultExecutionEndFunc(void *context, void *cbCtx) {
		return EXECUTION_TERMINATE;
	}

	nodep::DWORD DefaultBranchHandlerFunc(void *context, void *userContext, ADDR_TYPE nextInstruction) {
		return EXECUTION_ADVANCE;
	}

	nodep::DWORD DefaultErrorHandlerFunc(void *context, void *userContext, RevtracerError *rerror) {
		return EXECUTION_TERMINATE;
	}

	void DefaultSyscallControlFunc(void *context, void *userContext) { }

	void DefaultTrackCallback(nodep::DWORD value, nodep::DWORD address, nodep::DWORD segSel) { }
	void DefaultMarkCallback(nodep::DWORD oldValue, nodep::DWORD newValue, nodep::DWORD address, nodep::DWORD segSel) { }

	void DefaultNtAllocateVirtualMemory() {
		DEBUG_BREAK;
	}

	void DefaultNtFreeVirtualMemory() {
		DEBUG_BREAK;
	}

	void DefaultNtQueryInformationThread() {
		DEBUG_BREAK;
	}

	void DefaultRtlNtStatusToDosError() {
		DEBUG_BREAK;
	}

	void Defaultvsnprintf_s() {
		DEBUG_BREAK;
	}

	void __stdcall DefaultSymbolicHandler(void *context, void *offset, void *address) {
		return;
	}

	/* Execution context callbacks ********************************************************/
	void GetFirstEsp(void *ctx, nodep::DWORD &esp) {
		struct ExecutionEnvironment *pCtx = (struct ExecutionEnvironment *)ctx;
		esp = pCtx->runtimeContext.firstEsp;
	}

	void GetCurrentRegisters(void *ctx, ExecutionRegs *regs) {
		struct ExecutionEnvironment *pCtx = (struct ExecutionEnvironment *)ctx;
		rev_memcpy(regs, (struct ExecutionEnvironment *)pCtx->runtimeContext.registers, sizeof(*regs));
		regs->esp = pCtx->runtimeContext.virtualStack;
	}

	void *GetMemoryInfo(void *ctx, ADDR_TYPE addr) {
		struct ExecutionEnvironment *pEnv = (struct ExecutionEnvironment *)ctx;
		nodep::DWORD ret = pEnv->ac.Get((nodep::DWORD)addr/* + revtracerConfig.segmentOffsets[segSel & 0xFFFF]*/);
		return (void *)ret;
	}

	bool GetLastBasicBlockInfo(void *ctx, BasicBlockInfo *info) {
		struct ExecutionEnvironment *pEnv = (struct ExecutionEnvironment *)ctx;

		RiverBasicBlock *pCB = pEnv->blockCache.FindBlock(pEnv->lastFwBlock);
		if (nullptr != pCB) {
			info->address = (rev::ADDR_TYPE)pCB->address;
			info->cost = pCB->dwOrigOpCount;
			info->branchType = pCB->dwBranchType;
			info->branchInstruction = pCB->dwBranchInstruction;
			info->nInstructions = pCB->dwOrigOpCount;
			// branch taken
			info->branchNext[0] = pCB->pBranchNext[0];
			//branch not taken
			info->branchNext[1] = pCB->pBranchNext[1];
		}
		return false;
	}


	/* Inproc API *************************************************************************/

	RevtracerImports revtracerImports = {
		NoDbgPrint,

		DefaultMemoryAlloc,
		DefaultMemoryFree,

		DefaultTakeSnapshot,
		DefaultRestoreSnapshot,

		DefaultInitializeContextFunc,
		DefaultCleanupContextFunc,
		
		DefaultBranchHandlerFunc,
		DefaultErrorHandlerFunc,
		DefaultSyscallControlFunc,

		DefaultIpcInitialize,

		DefaultTrackCallback,
		DefaultMarkCallback,

		DefaultSymbolicHandler,

		{
			(ADDR_TYPE)DefaultNtQueryInformationThread,
			(ADDR_TYPE)DefaultRtlNtStatusToDosError,

			(ADDR_TYPE)Defaultvsnprintf_s
		}
	};

	RevtracerConfig revtracerConfig = {
		0,
		0
	};

	RevtracerVersion revtracerVersion = {
		0,
		1,
		1
	};

	struct ExecutionEnvironment *pEnv = NULL;

	void CreateHook(ADDR_TYPE orig, ADDR_TYPE det) {
		RevtracerError rerror;
		RiverBasicBlock *pBlock = pEnv->blockCache.NewBlock((nodep::UINT_PTR)orig);

		pBlock->address = (nodep::DWORD)det;
		pEnv->codeGen.Translate(pBlock, revtracerConfig.featureFlags, &rerror);
		pBlock->address = (nodep::DWORD)orig;
		pBlock->dwFlags |= RIVER_BASIC_BLOCK_DETOUR;

		revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_CONTAINER, "Added detour from 0x%08x to 0x%08x\n", orig, det);
	}

#ifdef _MSC_VER
#define ADDR_OF_RET_ADDR _AddressOfReturnAddress
#else
#define ADDR_OF_RET_ADDR() ({ int addr; __asm__ ("lea 4(%%ebp), %0" : : "r" (addr)); addr; })
#endif

	extern "C" {
		nodep::DWORD miniStack[4096];
		nodep::DWORD shadowStack = (nodep::DWORD)&(miniStack[4090]);

		void TracerInitialization() { // parameter is not initialized (only used to get the 
			nodep::UINT_PTR rgs = (nodep::UINT_PTR)ADDR_OF_RET_ADDR() + sizeof(void *);

			Initialize();
			pEnv->runtimeContext.registers = rgs;

			revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_CONTAINER, "Entry point @%08x\n", (nodep::DWORD)revtracerConfig.entryPoint);
			RiverBasicBlock *pBlock = pEnv->blockCache.NewBlock((nodep::UINT_PTR)revtracerConfig.entryPoint);
			RevtracerError rerror;
			pBlock->address = (nodep::DWORD)revtracerConfig.entryPoint;
			pEnv->codeGen.Translate(pBlock, revtracerConfig.featureFlags, &rerror);

			revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_CONTAINER, "New entry point @%08x\n", (nodep::DWORD)pBlock->pFwCode);

			// TODO: replace with address of the actual terminate process
			pEnv->exitAddr = (nodep::DWORD)revtracerImports.lowLevel.ntTerminateProcess;

			/*pEnv->runtimeContext.execBuff -= 4;
			*((DWORD *)pEnv->runtimeContext.execBuff) = (DWORD)revtracerConfig.entryPoint;*/

			//switch (revtracerImports.executionBegin(pEnv->userContext, revtracerConfig.entryPoint, pEnv)) {
			switch (revtracerImports.branchHandler(pEnv, pEnv->userContext, revtracerConfig.entryPoint)) {
			case EXECUTION_ADVANCE:
				revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_CONTAINER, "%d detours needed.\n", revtracerConfig.hookCount);
				for (nodep::DWORD i = 0; i < revtracerConfig.hookCount; ++i) {
					CreateHook(revtracerConfig.hooks[i].originalAddr, revtracerConfig.hooks[i].detourAddr);
				}
				pEnv->lastFwBlock = (nodep::UINT_PTR)revtracerConfig.entryPoint;
				pEnv->bForward = 1;
				pBlock->MarkForward();

				revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_CONTAINER, "Translated entry point %08x.\n", pBlock->pFwCode);
				revtracerConfig.entryPoint = pBlock->pFwCode;
				break;
			case EXECUTION_TERMINATE:
				revtracerConfig.entryPoint = revtracerImports.lowLevel.ntTerminateProcess;
				break;
			case EXECUTION_BACKTRACK:
				revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_CONTAINER, "EXECUTION_BACKTRACK @executionBegin");
				revtracerConfig.entryPoint = revtracerImports.lowLevel.ntTerminateProcess;
				break;
			}
		}
	};

	nodep::DWORD __stdcall MarkAddr(void *pEnv, nodep::DWORD dwAddr, nodep::DWORD value, nodep::DWORD segSel);
	void MarkMemoryValue(void *ctx, ADDR_TYPE addr, nodep::DWORD value) {
		MarkAddr((ExecutionEnvironment *)ctx, (nodep::DWORD)addr, value, 0x2B);
	}

	/* DLL API ****************************************************************************/


	/*void SetDbgPrint(DbgPrintFunc func) {
		revtracerImports.dbgPrintFunc = func;
	}

	void SetMemoryMgmt(MemoryAllocFunc alc, MemoryFreeFunc fre) {
		revtracerImports.memoryAllocFunc = alc;
		revtracerImports.memoryFreeFunc = fre;
	}

	void SetSnapshotMgmt(TakeSnapshotFunc ts, RestoreSnapshotFunc rs) {
		revtracerImports.takeSnapshot = ts;
		revtracerImports.restoreSnapshot = rs;
	}

	void SetLowLevelAPI(LowLevelRevtracerAPI *llApi) {
		revtracerImports.lowLevel.ntTerminateProcess = llApi->ntTerminateProcess;
		revtracerImports.lowLevel.ntWriteFile = llApi->ntWriteFile;

		revtracerImports.lowLevel.vsnprintf_s = llApi->vsnprintf_s;
	}

	void SetContextMgmt(InitializeContextFunc initCtx, CleanupContextFunc cleanCtx) {
		revtracerImports.initializeContext = initCtx;
		revtracerImports.cleanupContext = cleanCtx;
	}

	//void SetControlMgmt(ExecutionControlFunc execCtl, SyscallControl syscallCtl) {
	void SetControlMgmt(BranchHandlerFunc branchCtl, SyscallControlFunc syscallCtl) {
		revtracerImports.branchHandler = branchCtl;
		revtracerImports.syscallControl = syscallCtl;
	}

	void SetContext(ADDR_TYPE ctx) {
		revtracerConfig.context = ctx;
	}

	void SetEntryPoint(ADDR_TYPE ep) {
		revtracerConfig.entryPoint = ep;
	}*/

	void Initialize() {
		revtracerImports.ipcLibInitialize();

		revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_CONTAINER, "Feature flags %08x, entrypoint %08x\n", revtracerConfig.featureFlags, revtracerConfig.entryPoint);

		pEnv = new ExecutionEnvironment(revtracerConfig.featureFlags, 0x1000000, 0x10000, 0x4000000, 0x4000000, 16, 0x10000);
		pEnv->userContext = revtracerConfig.context; //AllocUserContext(pEnv, revtracerConfig.contextSize);

		revtracerConfig.pRuntime = &pEnv->runtimeContext;
	}

	void Execute(int argc, char *argv[]) {
		nodep::DWORD ret;
		struct ExecutionRegs regs;

		pEnv->runtimeContext.registers = (nodep::UINT_PTR)&regs;
		if (EXECUTION_ADVANCE == revtracerImports.branchHandler(pEnv, pEnv->userContext, revtracerConfig.entryPoint)) {
			for (nodep::DWORD i = 0; i < revtracerConfig.hookCount; ++i) {
				CreateHook(revtracerConfig.hooks[i].originalAddr, revtracerConfig.hooks[i].detourAddr);
			}
			for (nodep::DWORD i = 0; i < revtracerConfig.hookCount; ++i) {
				CreateHook(revtracerConfig.hooks[i].originalAddr, revtracerConfig.hooks[i].detourAddr);
			}
			// TODO save state
			nodep::DWORD ret = call_cdecl_0(pEnv, (_fn_cdecl_0)revtracerConfig.entryPoint);
			// TODO if error=> restore state
			revtracerImports.dbgPrintFunc(PRINT_INFO | PRINT_CONTAINER, "Done. ret = %d\n\n", ret);
		}
	}

};

extern "C" {
	void RevtracerPerform();
#ifdef _MSC_VER
	NAKED void RevtracerPerform() {
		__asm {
			xchg esp, shadowStack;
			pushad;
			pushfd;
			call TracerInitialization;
			popfd;
			popad;
			xchg esp, shadowStack;

			jmp dword ptr[revtracerConfig.entryPoint];
		}
	}
#endif
};

namespace rev {
	RevtracerExports revtracerExports = {
		GetFirstEsp,
		GetCurrentRegisters,
		GetMemoryInfo,
		GetLastBasicBlockInfo,
		MarkMemoryValue,

		::RevtracerPerform
	};
};

```

`revtracer/revtracer.h`:

```h
#ifndef _REVTRACER_H
#define _REVTRACER_H

#include "DebugPrintFlags.h"
#include "../CommonCrossPlatform/BasicTypes.h"
#include "common.h"

#define TRACER_FEATURE_REVERSIBLE				0x00000001
#define TRACER_FEATURE_TRACKING					0x00000002
#define TRACER_FEATURE_ADVANCED_TRACKING		0x00000004 // never use this flag --- use _SYMBOLIC instead
#define TRACER_FEATURE_SYMBOLIC					(TRACER_FEATURE_TRACKING | TRACER_FEATURE_ADVANCED_TRACKING)

namespace rev {

#if defined _WIN32 || defined __CYGWIN__
	#ifdef _BUILDING_REVTRACER_DLL
		#ifdef _MSC_VER
			#define DLL_REVTRACER_PUBLIC __declspec(dllexport)
			#define NAKED  __declspec(naked)
		#else
			#define DLL_REVTRACER_PUBLIC __attribute__ ((dllexport))
			#define NAKED
		#endif
	#else
		#ifdef _MSC_VER
			#define DLL_REVTRACER_PUBLIC __declspec(dllimport)
		#else
			#define DLL_REVTRACER_PUBLIC __attribute__ ((dllimport))
		#endif
	#endif
	#define DLL_LOCAL
#else
	#if __GNUC__ >= 4
		#define DLL_REVTRACER_PUBLIC __attribute__ ((visibility ("default")))
		#define DLL_LOCAL  __attribute__ ((visibility ("hidden")))
	  #define NAKED  __attribute__ ((naked))
	#else
		#define DLL_REVTRACER_PUBLIC
		#define DLL_LOCAL
	#endif
#endif


	typedef void *ADDR_TYPE;
	typedef struct RevtracerError RevtracerError;

	typedef void(*DbgPrintFunc)(const unsigned int dwMask, const char *fmt, ...);
	typedef void *(*MemoryAllocFunc)(nodep::DWORD dwSize);
	typedef void(*MemoryFreeFunc)(void *ptr);

	typedef nodep::QWORD(*TakeSnapshotFunc)();
	typedef nodep::QWORD(*RestoreSnapshotFunc)();

#define EXECUTION_ADVANCE					0x00000000
#define EXECUTION_BACKTRACK					0x00000001
#define EXECUTION_TERMINATE					0x00000002
#define EXECUTION_RESTART					0x00000003

	typedef void(*InitializeContextFunc)(void *context);
	typedef void(*CleanupContextFunc)(void *context);

	typedef nodep::DWORD(*BranchHandlerFunc)(void *context, void *userContext, ADDR_TYPE nextInstruction);
	typedef nodep::DWORD(*ErrorHandlerFunc)(void *context, void *userContext, RevtracerError *rerror);
	typedef void(*SyscallControlFunc)(void *context, void *userContext);
	typedef void(*IpcLibInitFunc)();

	typedef void(*TrackCallbackFunc)(nodep::DWORD value, nodep::DWORD address, nodep::DWORD segment);
	typedef void(*MarkCallbackFunc)(nodep::DWORD oldValue, nodep::DWORD newValue, nodep::DWORD address, nodep::DWORD segment);

	typedef void(__stdcall *SymbolicHandlerFunc)(void *context, void *offset, void *instr);

	//Revtracer Wrapper API functions type
	typedef bool (*WriteFileCall)(void *handle, int fd, void *buffer, size_t size, unsigned long *written);

	struct LowLevelRevtracerAPI {
		/* Low level ntdll.dll functions */
		//ADDR_TYPE ntAllocateVirtualMemory;
		//ADDR_TYPE ntFreeVirtualMemory;
		//ADDR_TYPE ntQueryInformationThread;
		ADDR_TYPE ntTerminateProcess;

		ADDR_TYPE ntWriteFile;
		ADDR_TYPE vsnprintf_s;
	};

	struct RevtracerImports {
		/* Logging function */
		DbgPrintFunc dbgPrintFunc;

		/* Memory management function */
		MemoryAllocFunc memoryAllocFunc;
		MemoryFreeFunc memoryFreeFunc;

		/* VM Snapshot control */
		TakeSnapshotFunc takeSnapshot;
		RestoreSnapshotFunc restoreSnapshot;

		/* Execution callbacks */
		InitializeContextFunc initializeContext;
		CleanupContextFunc cleanupContext;
		BranchHandlerFunc branchHandler;
		ErrorHandlerFunc errorHandler;
		SyscallControlFunc syscallControl;

		/* IpcLib initialization */
		IpcLibInitFunc ipcLibInitialize;

		/* Variable tracking callbacks */
		TrackCallbackFunc trackCallback;
		MarkCallbackFunc markCallback;

		/* Symbolic synchronization function */
		SymbolicHandlerFunc symbolicHandler;

		LowLevelRevtracerAPI lowLevel;
	};

	struct CodeHooks {
		ADDR_TYPE originalAddr;
		ADDR_TYPE detourAddr;
	};

	class SymbolicExecutor;
	class SymbolicEnvironment;
	typedef SymbolicExecutor *(*SymbolicExecutorConstructor)(SymbolicEnvironment *env);

	struct RevtracerConfig {
		ADDR_TYPE entryPoint;
		ADDR_TYPE mainModule;
		ADDR_TYPE context;
		nodep::DWORD segmentOffsets[0x100];

		nodep::DWORD featureFlags;

		nodep::BOOL dumpBlocks;
		nodep::HANDLE hBlocks;

		void *pRuntime;

		nodep::DWORD hookCount;
		CodeHooks hooks[0x100];
	};

#define RERROR_OK              0x00000000
#define RERROR_UNK_INSTRUCTION 0x00000001

#define RIVER_NONE_ID                        0x00000000
#define RIVER_DISASSEMBLER_ID                0x00000001
#define RIVER_META_TRANSLATOR_ID             0x00000002
#define RIVER_SAVE_TRANSLATOR_ID             0x00000003
#define RIVER_SYMBOP_TRANSLATOR_ID           0x00000004
#define RIVER_SYMBOP_SAVE_TRANSLATOR_ID      0x00000005
#define RIVER_SYMBOP_REVERSE_TRANSLATOR_ID   0x00000006
#define RIVER_REVERSE_TRANSLATOR_ID          0x00000007
#define RIVER_REP_TRANSLATOR_ID              0x00000008

#define INVALID_ADDRESS			0xFFFFFFFF

	struct RevtracerError {
		nodep::BYTE prefix;
		nodep::BYTE opcode;
		nodep::DWORD translatorId;
		nodep::DWORD instructionAddress;

		nodep::DWORD errorCode;
	};


	struct ExecutionRegs {
		nodep::DWORD edi;
		nodep::DWORD esi;
		nodep::DWORD ebp;
		nodep::DWORD esp;

		nodep::DWORD ebx;
		nodep::DWORD edx;
		nodep::DWORD ecx;
		nodep::DWORD eax;
		nodep::DWORD eflags;
	};

	struct BranchNext {
		nodep::DWORD address;
		nodep::DWORD taken;
	};

	struct BasicBlockInfo {
		ADDR_TYPE address;
		nodep::DWORD cost;
		nodep::DWORD branchType;
		nodep::DWORD branchInstruction;
		nodep::DWORD nInstructions;
		struct BranchNext branchNext[2];
	};

	typedef void (*GetFirstEspFunc)(void *ctx, nodep::DWORD &esp);
	typedef void (*GetCurrentRegistersFunc)(void *ctx, ExecutionRegs *regs);
	typedef void *(*GetMemoryInfoFunc)(void *ctx, ADDR_TYPE addr);
	typedef bool (*GetLastBasicBlockInfoFunc)(void *ctx, BasicBlockInfo *info);
	typedef void (*MarkMemoryValueFunc)(void *ctx, ADDR_TYPE addr, nodep::DWORD value);
	typedef void (*RevtracerPerformFunc)();

	struct RevtracerVersion {
		nodep::BYTE major;
		nodep::BYTE minor;
		nodep::WORD build;
	};

	struct RevtracerExports {
		GetFirstEspFunc getFirstEsp;
		GetCurrentRegistersFunc getCurrentRegisters;
		GetMemoryInfoFunc getMemoryInfo;
		GetLastBasicBlockInfoFunc getLastBasicBlockInfo;
		MarkMemoryValueFunc markMemoryValue;

		/* Can be used as an EP for in process execution  */
		RevtracerPerformFunc revtracerPerform;
	};

	extern "C" {
		/* In process API *********************************/
		DLL_REVTRACER_PUBLIC extern RevtracerConfig revtracerConfig;
		DLL_REVTRACER_PUBLIC extern RevtracerImports revtracerImports;
		DLL_REVTRACER_PUBLIC extern RevtracerExports revtracerExports;


		/* DLL API ****************************************/

		/*DLL_REVTRACER_PUBLIC void SetDbgPrint(DbgPrintFunc);
		DLL_REVTRACER_PUBLIC void SetMemoryMgmt(MemoryAllocFunc alc, MemoryFreeFunc fre);
		DLL_REVTRACER_PUBLIC void SetSnapshotMgmt(TakeSnapshotFunc ts, RestoreSnapshotFunc rs);
		DLL_REVTRACER_PUBLIC void SetLowLevelAPI(LowLevelRevtracerAPI *llApi);
		DLL_REVTRACER_PUBLIC void SetContextMgmt(InitializeContextFunc initCtx, CleanupContextFunc cleanCtx);
		DLL_REVTRACER_PUBLIC void SetControlMgmt(BranchHandlerFunc branchCtl, SyscallControlFunc syscallCtl);


		DLL_REVTRACER_PUBLIC void SetContext(ADDR_TYPE ctx);
		DLL_REVTRACER_PUBLIC void SetEntryPoint(ADDR_TYPE ep);*/

		DLL_REVTRACER_PUBLIC void Initialize();
		DLL_REVTRACER_PUBLIC void Execute(int argc, char *argv[]);
	};

};


#endif

```

`revtracer/revtracer.stub.S`:

```S
.intel_syntax noprefix
.global _RevtracerPerform
.global _shadowStack
.global _TracerInitialization
.global _revtracerConfig

.text
_RevtracerPerform:
	xchg esp, _shadowStack
	pusha
	pushf
	
	call _TracerInitialization
	
	popf
	popa
	xchg esp, _shadowStack
	jmp [_revtracerConfig + 0]

```

`revtracer/revtracer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="BasicTypes.h" />
    <ClInclude Include="callgates.h" />
    <ClInclude Include="cb.h" />
    <ClInclude Include="CodeGen.h" />
    <ClInclude Include="DebugPrintFlags.h" />
    <ClInclude Include="GenericX86Assembler.h" />
    <ClInclude Include="AddressContainer.h" />
    <ClInclude Include="PreTrackingX86Assembler.h" />
    <ClInclude Include="revtracer.h" />
    <ClInclude Include="RiverRepAssembler.h" />
    <ClInclude Include="RiverRepTranslator.h" />
    <ClInclude Include="RiverTrackingX86Assembler.h" />
    <ClInclude Include="SymbopReverseTranslator.h" />
    <ClInclude Include="SymbopSaveTranslator.h" />
    <ClInclude Include="Tracking.h" />
    <ClInclude Include="TrackingX86Assembler.h" />
    <ClInclude Include="TranslatorUtil.h" />
    <ClInclude Include="X86AssemblerFuncs.h" />
    <ClInclude Include="RelocableCodeBuffer.h" />
    <ClInclude Include="X86Assembler.h" />
    <ClInclude Include="NativeX86Assembler.h" />
    <ClInclude Include="river.h" />
    <ClInclude Include="RiverAddress.h" />
    <ClInclude Include="riverinternl.h" />
    <ClInclude Include="RiverMetaTranslator.h" />
    <ClInclude Include="RiverReverseTranslator.h" />
    <ClInclude Include="RiverSaveTranslator.h" />
    <ClInclude Include="RiverX86Assembler.h" />
    <ClInclude Include="RiverX86Disassembler.h" />
    <ClInclude Include="Runtime.h" />
    <ClInclude Include="SymbopTranslator.h" />
    <ClInclude Include="common.h" />
    <ClInclude Include="crc32.h" />
    <ClInclude Include="environment.h" />
    <ClInclude Include="execenv.h" />
    <ClInclude Include="mm.h" />
    <ClInclude Include="modrm32.h" />
    <ClInclude Include="sync.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AddressContainer.cpp" />
    <ClCompile Include="api.cpp" />
    <ClCompile Include="callgates.cpp">
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Default</BasicRuntimeChecks>
      <BufferSecurityCheck Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</BufferSecurityCheck>
    </ClCompile>
    <ClCompile Include="cb.cpp" />
    <ClCompile Include="codegen.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="crc32.cpp" />
    <ClCompile Include="crtStub.cpp" />
    <ClCompile Include="execenv.cpp" />
    <ClCompile Include="GenericX86Assembler.cpp" />
    <ClCompile Include="mm.cpp" />
    <ClCompile Include="modrm32.cpp" />
    <ClCompile Include="PreTrackingX86Assembler.cpp" />
    <ClCompile Include="RelocableCodeBuffer.cpp" />
    <ClCompile Include="revtracer.cpp" />
    <ClCompile Include="revtracer.stub.S">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="RiverAddress.cpp" />
    <ClCompile Include="RiverMetaTranslator.cpp" />
    <ClCompile Include="RiverPrintTable.cpp" />
    <ClCompile Include="RiverRepAssembler.cpp" />
    <ClCompile Include="RiverRepTranslator.cpp" />
    <ClCompile Include="RiverReverseTranslator.cpp" />
    <ClCompile Include="RiverSaveTranslator.cpp" />
    <ClCompile Include="RiverTrackingX86Assembler.cpp" />
    <ClCompile Include="RiverX86Assembler.cpp" />
    <ClCompile Include="RiverX86Disassembler.cpp" />
    <ClCompile Include="NativeX86Assembler.cpp">
      <IntrinsicFunctions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</IntrinsicFunctions>
    </ClCompile>
    <ClCompile Include="SymbopReverseTranslator.cpp" />
    <ClCompile Include="SymbopTranslator.cpp" />
    <ClCompile Include="SymbopSaveTranslator.cpp" />
    <ClCompile Include="sync.cpp" />
    <ClCompile Include="Tracking.cpp" />
    <ClCompile Include="TrackingX86Assembler.cpp" />
    <ClCompile Include="TranslatorUtil.cpp" />
    <ClCompile Include="X86Assembler.cpp" />
    <ClCompile Include="X86AssemblerFuncs.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="RiverX86DisassemblerTable.cpp">
      <FileType>Document</FileType>
    </ClCompile>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F348D3BE-A0A6-42C5-ACBE-806AC106ACC3}</ProjectGuid>
    <RootNamespace>revtracer</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_BUILDING_REVTRACER_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <EntryPointSymbol>DllEntry</EntryPointSymbol>
      <SectionAlignment>65536</SectionAlignment>
      <Profile>true</Profile>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetDir)$(TargetFileName) $(SolutionDir)jsdemo\
copy $(TargetDir)$(ProjectName).pdb $(SolutionDir)jsdemo\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_BUILDING_REVTRACER_DLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ExceptionHandling>false</ExceptionHandling>
      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SectionAlignment>65536</SectionAlignment>
      <EntryPointSymbol>DllEntry</EntryPointSymbol>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetDir)$(TargetFileName) $(SolutionDir)jsdemo\
copy $(TargetDir)$(ProjectName).pdb $(SolutionDir)jsdemo\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`revtracer/river.h`:

```h
#ifndef _RIVER_H
#define _RIVER_H

/* river (spelled backwards) stands for the REVersible Intermediate Representation */
/* river is a fixed length extended x86 instruction set */
/* river is designed to be efficiently translated to and from x86 */

#include "common.h"
#include "environment.h"

/* River mofifiers (present in riverInstruction.modifiers) */
#define RIVER_MODIFIER_NOSEG		0x0000
#define RIVER_MODIFIER_ESSEG		0x0001
#define RIVER_MODIFIER_CSSEG		0x0002
#define RIVER_MODIFIER_SSSEG		0x0003
#define RIVER_MODIFIER_DSSEG		0x0004
#define RIVER_MODIFIER_FSSEG		0x0005
#define RIVER_MODIFIER_GSSEG		0x0006


#define RIVER_MODIFIER_EXT 			0x0008
/* no corresponding prefix */
#define RIVER_MODIFIER_O8			0x0010
#define RIVER_MODIFIER_O16 			0x0020
#define RIVER_MODIFIER_A16 			0x0040
#define RIVER_MODIFIER_LOCK			0x0080
#define RIVER_MODIFIER_REP 			0x0100
#define RIVER_MODIFIER_REPZ			0x0200
#define RIVER_MODIFIER_REPNZ		0x0400

#define RIVER_FAMILY(fam) ((fam) & 0x1F)

#define RIVER_FAMILY_NATIVE				0x00
#define RIVER_FAMILY_RIVER				0x01
#define RIVER_FAMILY_TRACK				0x02
#define RIVER_FAMILY_PRETRACK			0x03
#define RIVER_FAMILY_PREMETA			0x04
#define RIVER_FAMILY_POSTMETA			0x05
#define RIVER_FAMILY_RIVER_TRACK		0x06
#define RIVER_FAMILY_REP                0x07

#define RIVER_FAMILY_FLAG_METAPROCESSED	0x20
#define RIVER_FAMILY_FLAG_ORIG_xSP		0x40
#define RIVER_FAMILY_FLAG_IGNORE		0x80

/* River translation flags present in the pFlags argument */
#define RIVER_FLAG_PFX				0x00000001
#define RIVER_FLAG_OPCODE			0x00000002
#define RIVER_FLAG_BRANCH			0x00000100

/* Branch instructions and types used for control-flow analysis */
#define RIVER_BRANCH_INSTR_RET		0x00001000
#define RIVER_BRANCH_INSTR_JMP		0x00002000
#define RIVER_BRANCH_INSTR_JXX		0x00004000
#define RIVER_BRANCH_INSTR_CALL		0x00008000
#define RIVER_BRANCH_INSTR_SYSCALL	0x00010000

#define RIVER_BRANCH_TYPE_IMM		0x00020000
#define RIVER_BRANCH_TYPE_REG		0x00040000
#define RIVER_BRANCH_TYPE_MEM		0x00080000

/* River jump instruction used in tracers*/
#define RIVER_JUMP_INSTR_RET				0x00
#define RIVER_JUMP_INSTR_JMP				0x01
#define RIVER_JUMP_INSTR_JXX				0x02
#define RIVER_JUMP_INSTR_CALL				0x03
#define RIVER_JUMP_INSTR_SYSCALL			0x04

/* River jump types used in tracer */
#define RIVER_JUMP_TYPE_IMM 				0x00
#define RIVER_JUMP_TYPE_MEM 				0x01
#define RIVER_JUMP_TYPE_REG 				0x02

/* River virtual register names */
#define RIVER_REG_xAX				0x00
#define RIVER_REG_xCX				0x01
#define RIVER_REG_xDX				0x02
#define RIVER_REG_xBX				0x03
#define RIVER_REG_xSP				0x04
#define RIVER_REG_xBP				0x05
#define RIVER_REG_xSI				0x06
#define RIVER_REG_xDI				0x07

/* River virtual register sizes, to e used in conjunction with the register names*/
#define RIVER_REG_SZ32				0x00
#define RIVER_REG_SZ16				0x08
#define RIVER_REG_SZ8_L				0x10
#define RIVER_REG_SZ8_H				0x18

#define RIVER_REG_SEGMENT			0x20
#define RIVER_REG_ES				0x20
#define RIVER_REG_CS				0x21
#define RIVER_REG_SS				0x22
#define RIVER_REG_DS				0x23
#define RIVER_REG_FS				0x24
#define RIVER_REG_GS				0x25

#define RIVER_REG_CONTROL			0x30
#define RIVER_REG_CR0				0x30
#define RIVER_REG_CR2				0x32
#define RIVER_REG_CR3				0x33
#define RIVER_REG_CR4				0x34

#define RIVER_REG_DEBUG				0x40
#define RIVER_REG_DR0				0x40
#define RIVER_REG_DR1				0x41
#define RIVER_REG_DR2				0x42
#define RIVER_REG_DR3				0x43
#define RIVER_REG_DR4				0x44
#define RIVER_REG_DR5				0x45
#define RIVER_REG_DR6				0x46
#define RIVER_REG_DR7				0x47

nodep::BYTE GetFundamentalRegister(nodep::BYTE reg);

/* TODO: add MM0-7 and XMM0-7 */

/* River void virtual register */
#define RIVER_REG_NONE				0x20

/* Define some widely used registers */
#define RIVER_REG_AL				(RIVER_REG_xAX | RIVER_REG_SZ8_L)
#define RIVER_REG_AH				(RIVER_REG_xAX | RIVER_REG_SZ8_H)
#define RIVER_REG_CL				(RIVER_REG_xCX | RIVER_REG_SZ8_L)

union RiverRegister {
	nodep::DWORD versioned;
	nodep::BYTE name;
};

/* River address components, to be used in RiverAddress::type */
#define RIVER_ADDR_DISP8			0x01
#define RIVER_ADDR_DISP				0x02
#define RIVER_ADDR_SCALE			0x04
#define RIVER_ADDR_BASE				0x08
#define RIVER_ADDR_INDEX			0x10
/* Marks the address as needing recalculation */
#define RIVER_ADDR_DIRTY			0x80

#include "RiverAddress.h"



/* River operand types */
#define RIVER_OPTYPE_NONE			0x00
#define RIVER_OPTYPE_IMM			0x04
#define RIVER_OPTYPE_REG			0x08
#define RIVER_OPTYPE_MEM			0x0C
#define RIVER_OPTYPE_ALL			0x10

#define RIVER_OPTYPE(type) ((type) & 0x1C)
#define RIVER_OPSIZE(type) ((type) & 0x03)

/* River operand sizes */
#define RIVER_OPSIZE_32				0x00
#define RIVER_OPSIZE_16				0x01
#define RIVER_OPSIZE_8				0x02

/* River operand flags */
#define RIVER_OPFLAG_IMPLICIT		0x80

/* River operation specifiers */
#define RIVER_SPEC_MODIFIES_OP1		0x0001
#define RIVER_SPEC_MODIFIES_OP2		0x0002
#define RIVER_SPEC_MODIFIES_OP3		0x0004
#define RIVER_SPEC_MODIFIES_OP4		0x0008
#define RIVER_SPEC_MODIFIES_OP(idx) (0x0001 << (idx))

#define RIVER_SPEC_MODIFIES_FLG		0x0010
/* Modifies some onther fields also (maybe use a function table) */
#define RIVER_SPEC_MODIFIES_xSP		0x0020

/* Modifies customm fields, must have a custom save/restore function */
#define RIVER_SPEC_MODIFIES_CUSTOM  0x0040

/* Memory contents gets not addressed. (LEA for instance). */
#define RIVER_SPEC_IGNORES_MEMORY	0x0080

/* Means that the particular operand is only used as a destination */
#define RIVER_SPEC_IGNORES_OP1		0x0100
#define RIVER_SPEC_IGNORES_OP2		0x0200
#define RIVER_SPEC_IGNORES_OP3		0x0400
#define RIVER_SPEC_IGNORES_OP4		0x0800
#define RIVER_SPEC_IGNORES_OP(idx)	(0x0100 << (idx))
#define RIVER_SPEC_IGNORES_FLG		0x1000

/* Operation flags */
#define RIVER_SPEC_IDX_CF			0x00
#define RIVER_SPEC_IDX_PF			0x01
#define RIVER_SPEC_IDX_AF			0x02
#define RIVER_SPEC_IDX_ZF			0x03
#define RIVER_SPEC_IDX_SF			0x04
#define RIVER_SPEC_IDX_OF			0x05
#define RIVER_SPEC_IDX_DF			0x06

#define RIVER_SPEC_FLAG_CF			(1 << RIVER_SPEC_IDX_CF)
#define RIVER_SPEC_FLAG_PF			(1 << RIVER_SPEC_IDX_PF)
#define RIVER_SPEC_FLAG_AF			(1 << RIVER_SPEC_IDX_AF)
#define RIVER_SPEC_FLAG_ZF			(1 << RIVER_SPEC_IDX_ZF)
#define RIVER_SPEC_FLAG_SF			(1 << RIVER_SPEC_IDX_SF)
#define RIVER_SPEC_FLAG_OF			(1 << RIVER_SPEC_IDX_OF)
#define RIVER_SPEC_FLAG_DF			(1 << RIVER_SPEC_IDX_DF)
#define RIVER_SPEC_FLAG_EXT			0x80

#define RIVER_SPEC_FLAG_SZAPC		(RIVER_SPEC_FLAG_PF | RIVER_SPEC_FLAG_AF | RIVER_SPEC_FLAG_ZF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_CF)
#define RIVER_SPEC_FLAG_OSZAP		(RIVER_SPEC_FLAG_PF | RIVER_SPEC_FLAG_AF | RIVER_SPEC_FLAG_ZF | RIVER_SPEC_FLAG_SF | RIVER_SPEC_FLAG_OF)
#define RIVER_SPEC_FLAG_OSZAPC		(RIVER_SPEC_FLAG_CF | RIVER_SPEC_FLAG_OSZAP)


/* Use a secondary table for lookup*/
#define RIVER_SPEC_MODIFIES_EXT		0x8000

/* When xSP is needed these registers can be used for the swap */
#define RIVER_UNUSED_xAX			0x01
#define RIVER_UNUSED_xCX			0x02
#define RIVER_UNUSED_xDX			0x04
#define RIVER_UNUSED_xBX			0x08
#define RIVER_UNUSED_ALL			0x0F

union RiverOperand {
	nodep::BYTE asImm8;
	nodep::WORD asImm16;
	nodep::DWORD asImm32;
	RiverRegister asRegister;
	RiverAddress *asAddress;
};

struct RiverInstruction {
	nodep::WORD modifiers; // modifiers introduced by prefixes or opcode
	nodep::WORD specifiers; // instruction specific flags

	nodep::BYTE family; // instruction family (allows for multiple instruction streams to be interleaved
	nodep::BYTE unusedRegisters;
	nodep::BYTE opCode;
	nodep::BYTE subOpCode;

	nodep::BYTE disassFlags, modFlags, testFlags;

	nodep::BYTE opTypes[4];
	union RiverOperand operands[4];

	nodep::DWORD instructionAddress; // relevant only for native and meta instructions

	inline void PromoteModifiers() {
		for (int i = 0; i < 4; ++i) {
			if (RIVER_OPTYPE_MEM == RIVER_OPTYPE(opTypes[i])) {
				if (operands[i].asAddress->HasSegment()) {
					modifiers |= operands[i].asAddress->GetSegment();
					break;
				}

				/*if ((operands[0].asAddress->type & RIVER_ADDR_BASE) && (RIVER_REG_xSP == GetFundamentalRegister(operands[0].asAddress->base.name))) {
				modifiers |= RIVER_MODIFIER_ORIG_xSP;
				}

				if ((operands[0].asAddress->type & RIVER_ADDR_INDEX) && (RIVER_REG_xSP == GetFundamentalRegister(operands[0].asAddress->index.name))) {
				modifiers |= RIVER_MODIFIER_ORIG_xSP;
				}*/
			}
		}
	}

	inline nodep::BYTE GetUnusedRegister() const {
		if (unusedRegisters & 0x03) {
			if (unusedRegisters & 0x01) {
				return RIVER_REG_xAX;
			}
			return RIVER_REG_xCX;
		} else if (unusedRegisters & 0x0C) {
			if (unusedRegisters & 0x04) {
				return RIVER_REG_xDX;
			}
			return RIVER_REG_xBX;
		} else {
			DEBUG_BREAK;
		}
	}

	void TrackUnusedRegistersOperand(nodep::BYTE optype, const RiverOperand &op) {
		nodep::BYTE reg;
		switch (RIVER_OPTYPE(optype)) {
			case RIVER_OPTYPE_IMM:
				break;
			case RIVER_OPTYPE_REG:
				reg = GetFundamentalRegister(op.asRegister.name);
				if (reg < 4) {
					unusedRegisters &= ~(1 << reg);
				}
				break;
			case RIVER_OPTYPE_MEM:
				if ((op.asAddress->type & RIVER_ADDR_BASE) || (op.asAddress->type == 0)){
					reg = GetFundamentalRegister(op.asAddress->base.name);
					if (reg < 4) {
						unusedRegisters &= ~(1 << reg);
					}
				}
				if (op.asAddress->type & RIVER_ADDR_INDEX) {
					reg = GetFundamentalRegister(op.asAddress->index.name);
					if (reg < 4) {
						unusedRegisters &= ~(1 << reg);
					}
				}
				break;
		}
	}

	void TrackEspOperand(nodep::BYTE optype, const RiverOperand &op) {
		nodep::BYTE reg;
		switch (RIVER_OPTYPE(optype)) {
			case RIVER_OPTYPE_IMM:
				break;
			case RIVER_OPTYPE_REG:
				reg = GetFundamentalRegister(op.asRegister.name);
				if (RIVER_REG_xSP == reg) {
					specifiers |= RIVER_SPEC_MODIFIES_xSP;
					family |= RIVER_FAMILY_FLAG_ORIG_xSP;
				}
				break;
			case RIVER_OPTYPE_MEM:
				if ((op.asAddress->type & RIVER_ADDR_BASE) || (0 == op.asAddress->type)) {
					reg = GetFundamentalRegister(op.asAddress->base.name);
					if (RIVER_REG_xSP == reg) {
						specifiers |= RIVER_SPEC_MODIFIES_xSP;
						family |= RIVER_FAMILY_FLAG_ORIG_xSP;
					}
				}
				if (op.asAddress->type & RIVER_ADDR_INDEX) {
					reg = GetFundamentalRegister(op.asAddress->index.name);
					if (RIVER_REG_xSP == reg) {
						specifiers |= RIVER_SPEC_MODIFIES_xSP;
						family |= RIVER_FAMILY_FLAG_ORIG_xSP;
					}
				}
				break;
		}

		if (RIVER_FAMILY_NATIVE == RIVER_FAMILY(family)) {
			family &= ~RIVER_FAMILY_FLAG_ORIG_xSP;
		}
	}

	void TrackEspAsParameter() {
		for (int i = 0; i < 4; ++i) {
			TrackEspOperand(opTypes[i], operands[i]);
		}
	}

	void TrackUnusedRegisters() {
		unusedRegisters = 0x00;
		if ((RIVER_SPEC_MODIFIES_xSP & specifiers) || (RIVER_FAMILY_FLAG_ORIG_xSP & family)) {
			unusedRegisters = RIVER_UNUSED_ALL;

			for (int i = 0; i < 4; ++i) {
				//if (RIVER_SPEC_MODIFIES_OP2 & specifiers) {
				TrackUnusedRegistersOperand(opTypes[i], operands[i]);
				//}
			}
		}
	}
};

//#include "execenv.h"



#endif

```

`revtracer/riverinternl.h`:

```h
#ifndef _RIVER_INTERNAL_H
#define _RIVER_INTERNAL_H

#include "river.h"
#include "CodeGen.h"
#include "Runtime.h"

typedef void(*AssemblingOpcodeFunc)(RiverCodeGen *cg, RiverRuntime *rt, struct RiverInstruction *ri, nodep::BYTE **px86, nodep::DWORD *pFlags);
typedef void(*AssemblingOperandsFunc)(RiverCodeGen *cg, struct RiverInstruction *ri, nodep::BYTE **px86);

typedef void(*TranslateOpcodeFunc)(RiverCodeGen *cg, struct RiverInstruction *ri, nodep::BYTE **px86, nodep::DWORD *pFlags);
typedef void(*TranslateOperandsFunc)(RiverCodeGen *cg, struct RiverInstruction *ri, nodep::BYTE **px86);

typedef void(*ConvertInstructionFunc)(RiverCodeGen *cg, struct RiverInstruction *rIn, struct RiverInstruction *rOut, nodep::DWORD *outCount);


/*extern const TranslateOpcodeFunc TranslateOpcodeTable00[];
extern const TranslateOpcodeFunc TranslateOpcodeTable0F[];

extern const TranslateOperandsFunc TranslateOperandsTable00[];
extern const TranslateOperandsFunc TranslateOperandsTable0F[];*/

#endif

```

`revtracer/sync.cpp`:

```cpp
//#include <Wdm.h>
#include "revtracer.h"
#include "sync.h"

//using namespace rev;
#ifdef _MSC_VER
#include <intrin.h>
#define LOCK_XCHG(target, value) _InterlockedExchange(target, value)
#else
#define LOCK_XCHG(target, value) ({ asm volatile("xchgl %0, %1" : "+m"(*target) : "r"(value) : "memory"); value; })
#endif

RiverMutex::RiverMutex() {
	mtx = 0;
}

RiverMutex::~RiverMutex() {
}

void RiverMutex::Lock() {
	while (1) {
		if (0 == LOCK_XCHG(&mtx, 1)) {
			break;
		}

		//Sleep?
	}
}

void RiverMutex::Unlock() {
	//DbgPrint("UNLOCK %08x\n", mutex);
	LOCK_XCHG(&mtx, 0);
}

```

`revtracer/sync.h`:

```h
#ifndef _SYNC_H
#define _SYNC_H

class RiverMutex {
private :
	volatile long mtx;
public :
	RiverMutex();
	~RiverMutex();

	void Lock();
	void Unlock();
};

#endif

```

`revtracerexe/Extern.cpp`:

```cpp
#include <stdlib.h>
//#include <stdio.h>
#include <stdarg.h>
#include <share.h>

#include <Windows.h>
#include <winternl.h>
#include <intrin.h>

#include "extern.h"
#include "../revtracer/revtracer.h"

__declspec(dllimport) int vsnprintf_s(
	char *buffer,
	size_t sizeOfBuffer,
	size_t count,
	const char *format,
	va_list argptr
);

void ___DbgPrint(const char *fmt, ...) {
}

DbgPrintFunc DbgPrint = ___DbgPrint;

typedef BOOL (*MyIPFPFunc)(DWORD ProcessorFeature);

BOOL __stdcall MyIsProcessorFeaturePresent(DWORD ProcessorFeature) {
	static MyIPFPFunc func = NULL;

	/*if (NULL == func) {
		HMODULE hKernel = GetModuleHandle("kernel32.dll");
		func = (MyIPFPFunc)GetProcAddress(hKernel, "IsProcessorFeaturePresent");
	}*/

	switch (ProcessorFeature) {
	case PF_MMX_INSTRUCTIONS_AVAILABLE :
	case PF_SSE3_INSTRUCTIONS_AVAILABLE :
	case PF_XMMI64_INSTRUCTIONS_AVAILABLE :
	case PF_XMMI_INSTRUCTIONS_AVAILABLE :
	case PF_COMPARE_EXCHANGE_DOUBLE :
	case PF_COMPARE_EXCHANGE128 :
	case PF_COMPARE64_EXCHANGE128 :
		return FALSE;
	default:
		//return func(ProcessorFeature);
		return TRUE;
	}
}

VOID __stdcall MyExitProcess(DWORD retCode) {
	//rev::RevtracerAPI *api = &rev::revtracerAPI;
	//api->dbgPrintFunc("Guest process exited with code %d\n", retCode);
	ExitProcess(retCode);
}
```

`revtracerexe/Extern.h`:

```h
#ifndef _EXTERN_H
#define _EXTERN_H

/* Define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif  /* __cplusplus */
#endif  /* NULL */

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86) || defined(_ARM_) || defined(_M_ARM)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#if defined(_WIN64)
typedef __int64 INT_PTR, *PINT_PTR;
typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

typedef __int64 LONG_PTR, *PLONG_PTR;
typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

#define __int3264   __int64

#else
typedef _W64 int INT_PTR, *PINT_PTR;
typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

typedef _W64 long LONG_PTR, *PLONG_PTR;
typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

#define __int3264   __int32

#endif

typedef void *ADDR_TYPE;

typedef unsigned long long QWORD;
typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;

typedef void(*DbgPrintFunc)(const char *fmt, ...);
typedef void *(*MemoryAllocFunc)(DWORD dwSize);
typedef void(*MemoryFreeFunc)(void *ptr);


typedef QWORD(*TakeSnapshotFunc)();
typedef QWORD(*RestoreSnapshotFunc)();




extern DbgPrintFunc DbgPrint;

extern MemoryAllocFunc EnvMemoryAlloc;
extern MemoryFreeFunc EnvMemoryFree;

extern TakeSnapshotFunc TakeSnapshot;
extern RestoreSnapshotFunc RestoreSnapshot;

/*void DbgPrint(const char *fmt, ...);

void *EnvMemoryAlloc(unsigned long dwSize);
void EnvMemoryFree(void *b);

unsigned long long TakeSnapshot();
unsigned long long RestoreSnapshot();*/

#endif
```

`revtracerexe/Loader/Abstract.Mapper.h`:

```h
#ifndef _ABSTRACT_MAPPER_H_
#define _ABSTRACT_MAPPER_H_

#include "Types.h"

class AbstractPEMapper {
public:
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) = 0;

	virtual DWORD FindImport(const char *moduleName, const char *funcName) = 0;
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal) = 0;
};

#endif


```

`revtracerexe/Loader/Inproc.Mapper.cpp`:

```cpp
#include <Windows.h>
#include "Inproc.Mapper.h"


void *InprocMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return VirtualAlloc(lpAddress, dwSize, MEM_RESERVE | MEM_COMMIT, flProtect);
}

bool InprocMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	DWORD oldProtect;
	return TRUE == VirtualProtect(lpAddress, dwSize, flProtect, &oldProtect);
}

bool InprocMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	memcpy(lpAddress, lpBuffer, nSize);
	return true;
}

DWORD InprocMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, funcName);
}

DWORD InprocMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, (LPCSTR)funcOrdinal);
}
```

`revtracerexe/Loader/Inproc.Mapper.h`:

```h
#ifndef _INPROC_MAPPER_H_
#define _INPROC_MAPPER_H_

#include "Abstract.Mapper.h"

class InprocMapper : public AbstractPEMapper {
public :
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif
```

`revtracerexe/Loader/PE.ldr.cpp`:

```cpp
#include <stdio.h>
#include <vector>
using namespace std;

#include "..\extern.h"

//#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#endif

#include "PE.ldr.h"

//#include "common/debug-log.h"
#define dbg_log DbgPrint

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5
#define IMAGE_REL_BASED_RESERVED              6
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9
#define IMAGE_REL_BASED_DIR64                 10

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     

#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     

#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define PAGE_REVERT_TO_FILE_MAP     0x80000000 

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

const USHORT DOS_MAGIC = 0x5A4D;
const DWORD PE_MAGIC = 0x00004550;
const WORD OPT32_MAGIC = 0x010B;
const WORD OPT64_MAGIC = 0x020B;

const WORD IMAGE_FILE_MACHINE_I386 = 0x14C;
const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Name;
	DWORD Base;
	DWORD NumberOfFunctions;
	DWORD NumberOfNames;
	DWORD AddressOfFunctions; // RVA from base of image
	DWORD AddressOfNames; // RVA from base of image
	DWORD AddressOfNameOrdinals; // RVA from base of image
} IMAGE_EXPORT_DIRECTORY;

void *FloatingPE::RVA(DWORD rva) const {
    for (int i = 0; i < peHdr.NumberOfSections; ++i) {
        if (rva >= sections[i].header.VirtualAddress) {
            DWORD dwOffset = rva - sections[i].header.VirtualAddress;
            if (dwOffset < sections[i].header.VirtualSize) {
                return sections[i].data + dwOffset;
            }
        }
    }
    return (void *)0;
}

bool FloatingPE::Relocate(DWORD newAddr) {
	long long offset = 0;
	IMAGE_BASE_RELOCATION *reloc;
    IMAGE_BASE_RELOCATION *term;

	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			offset = newAddr - optHdr.w32.ImageBase;
			optHdr.w32.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			offset = newAddr - optHdr.w64.ImageBase;
			optHdr.w64.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

    while (reloc < term) {
        //dbg_log("Relocation Block %08x %08x", reloc->VirtualAddress, reloc->SizeOfBlock);
        WORD *wloc = (WORD *)reloc + 4;
        int wlocCount = (reloc->SizeOfBlock - sizeof(*reloc)) / sizeof(*wloc);

        for (int i = 0; i < wlocCount; ++i) {
            //dbg_log("%x %x;\t", wloc[i] >> 12, wloc[i] & 0x0FFF);
			WORD type = wloc[i] >> 12;
			WORD off = wloc[i] & 0x0FFF;
			
			if ((i % 3) == 0) {
				//dbg_log("\n");
			}
			
			switch (type) {
				case IMAGE_REL_BASED_ABSOLUTE :
					break;
				case IMAGE_REL_BASED_HIGHLOW :
					*((DWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					//dbg_log("%08x -> %08x\t", reloc->VirtualAddress + off, *((DWORD *)RVA(reloc->VirtualAddress + off)));
					break;
				case IMAGE_REL_BASED_DIR64 :
					*((QWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					break;
				default :
					//__asm int 3;
					__debugbreak();
			}
        }
		//dbg_log("\n");
		reloc = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + reloc->SizeOfBlock);
    }


    return true;
}

bool FloatingPE::GetExport(const char *funcName, DWORD &funcRVA) {
	DWORD exportRVA = 0;
	
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			exportRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			exportRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	};
	
	if (0 == exportRVA) {
		return false;
	}

	IMAGE_EXPORT_DIRECTORY *exprt = (IMAGE_EXPORT_DIRECTORY *)RVA(exportRVA);

	dbg_log("Number of functions: %d\n", exprt->NumberOfFunctions);
	dbg_log("Number of names: %d\n", exprt->NumberOfNames);

	DWORD *names = (DWORD *)RVA(exprt->AddressOfNames);
	int found = -1;
	for (DWORD i = 0; i < exprt->NumberOfNames; ++i) {
		char *name = (char *)RVA(names[i]);
		if (0 == strcmp(name, funcName)) {
			found = i;
			break;
		}
	}

	if (-1 == found) {
		return false;
	}

	WORD *ordinals = (WORD *)RVA(exprt->AddressOfNameOrdinals);
	WORD ordinal = ordinals[found] - (WORD)exprt->Base + 1;

	DWORD *exportTable = (DWORD *)RVA(exprt->AddressOfFunctions);
	funcRVA = exportTable[ordinal];

	return true;
}

bool FloatingPE::FixImports(AbstractPEMapper &mapper) {
	DWORD importRVA = 0;
	
	
	switch (peHdr.Machine) {
	case IMAGE_FILE_MACHINE_I386:
		importRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	case IMAGE_FILE_MACHINE_AMD64:
		importRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	default:
		dbg_log("Unsupported machine type\n");
		return false;
	};

	if (0 == importRVA) {
		return true;
	}

    IMAGE_IMPORT_DESCRIPTOR *import = (IMAGE_IMPORT_DESCRIPTOR *)RVA(importRVA);
	if (NULL == import) {
		return false;
	}

    while (import->OriginalFirstThunk != 0) {
		char *name = (char *)RVA(import->Name);
        dbg_log("Directory for: %s\n", name);
		dbg_log("OFT: %08x, FT: %08x\n", import->OriginalFirstThunk, import->FirstThunk);
		DWORD *funcs = (DWORD *)RVA(import->OriginalFirstThunk);
		DWORD *iat = (DWORD *)RVA(import->FirstThunk);
        while (*funcs != 0) {
            if (0x80000000 & *funcs) {
                dbg_log("Import by ordinal %d\n", *funcs & 0x7FFF);
				*iat = mapper.FindImport(name, *funcs & 0x7FFF);
            } else {
				char *funcName = (char *)RVA(*funcs + 2);
                dbg_log("Import by name %s\n", funcName);
				*iat = mapper.FindImport(name, funcName);
            }

            funcs += 1;
			iat += 1;
        }

		import += 1;
    }

    return true;
}

bool FloatingPE::LoadPE(FILE *fModule) {
	if (NULL == fModule) {
		dbg_log("File open error!\n");
		return false;
	}

	if (1 != fread(&dosHdr, sizeof(dosHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (dosHdr.e_magic != DOS_MAGIC) {
		dbg_log("dosHdr.e_magic not valid\n");
		return false;
	}

	fseek(fModule, dosHdr.e_lfanew, SEEK_SET);


	if (1 != fread(&peHdr, sizeof(peHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (PE_MAGIC != peHdr.PeSignature) {
		dbg_log("peHdr.PeSignature not valid\n");
		return false;
	}

	//dbg_log("Machine: %d\n", peHdr.Machine);
	//dbg_log("NumberOfSections: %d\n", peHdr.NumberOfSections);
	//dbg_log("SizeOfOptionalHeader: %d\n", peHdr.SizeOfOptionalHeader);
	//dbg_log("Characteristics: %d\n", peHdr.Characteristics);

	DWORD optSize = 0;
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w32);
			break;
		case IMAGE_FILE_MACHINE_AMD64 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w64);
			break;
		default :
			dbg_log("Unsupported machine type\n");
			return false;
	}

	if (peHdr.SizeOfOptionalHeader != optSize) {
		dbg_log("Unsupported optional header\n");
		return false;
	}

	if (1 != fread(&optHdr, optSize, 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}


	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			if (OPT32_MAGIC != optHdr.c.Magic) {
				dbg_log("opt32Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %08x\n", optHdr.w32.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w32.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w32.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w32.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w32.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w32.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w32.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w32.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w32.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
			);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			if (OPT64_MAGIC != optHdr.c.Magic) {
				dbg_log("opt64Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %016x\n", optHdr.w64.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w64.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w64.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w64.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w64.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w64.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w64.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w64.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w64.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
				); break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

	

	sections.resize(peHdr.NumberOfSections);

	dbg_log("Name\t V.Size\t V.Addr\t R.Size\t R.Addr\t Characteristics\n");
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (1 != fread(&sections[i].header, sizeof(sections[i].header), 1, fModule)) {
			dbg_log("read error\n");
			return false;
		}

		dbg_log("%.8s\t %08x %08x %08x %08x %08x\n",
			sections[i].header.Name,
			sections[i].header.VirtualSize,
			sections[i].header.VirtualAddress,
			sections[i].header.SizeOfRawData,
			sections[i].header.PointerToRawData,
			sections[i].header.Characteristics);
	}

	headersSize = ftell(fModule);
	headers = new unsigned char[headersSize];

	fseek(fModule, 0, SEEK_SET);
	fread(headers, 1, headersSize, fModule);

	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (!sections[i].Load(fModule)) {
			return false;
		}
	}

	return true;
}

FloatingPE::FloatingPE(const wchar_t *moduleName) {
	FILE *fModule; // = _wfopen_s(moduleName, L"rb");

	if (0 != _wfopen_s(&fModule, moduleName, L"rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}

FloatingPE::FloatingPE(const char *moduleName) {
	FILE *fModule; // = fopen(moduleName, "rb");

	if (0 != fopen_s(&fModule, moduleName, "rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}


FloatingPE::~FloatingPE() {
	//TODO: regular cleanup
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		sections[i].Unload();
	}
}

bool FloatingPE::MapPE(AbstractPEMapper &mapr, DWORD &baseAddr) {
	
	
	FixImports(mapr);
    
	
	DWORD maxAddr = 0;
	for (DWORD i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFF) & (~0xFFF);
		if (maxSec > maxAddr) {
			maxAddr = maxSec;
		}
	}
	

	baseAddr = (DWORD)mapr.CreateSection((void *)(baseAddr), maxAddr, PAGE_READWRITE);
	if (0 == baseAddr) {
		return false;
	}


	Relocate(baseAddr);

	//#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
	//#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
	//#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
	static const DWORD pVec[] = {
		PAGE_NOACCESS,
		PAGE_EXECUTE,
		PAGE_READONLY,
		PAGE_EXECUTE_READ,

		PAGE_READWRITE, // should be write only
		PAGE_EXECUTE_READWRITE, // should be execute write
		PAGE_READWRITE,
		PAGE_EXECUTE_READWRITE
	};

	/*if (!mapr.WriteBytes((void *)baseAddr, headers, headersSize)) {
		return false;
	}

	if (!mapr.ChangeProtect((void *)baseAddr, headersSize, PAGE_READONLY)) {
		return false;
	}*/

    for (unsigned int i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		if (sections[i].header.SizeOfRawData) {
			if (!mapr.WriteBytes((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].data, sections[i].header.SizeOfRawData)) {
				return false;
			}
		}

		DWORD protect = pVec[sections[i].header.Characteristics >> 29]; // get the three most significant bytes
		if (!mapr.ChangeProtect((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].header.VirtualSize, protect)) {
			return false;
		}
		
    }

	return true;
}

bool PESection::Load(FILE *fModule) {
    data = new unsigned char[header.SizeOfRawData];

    fseek(fModule, header.PointerToRawData, SEEK_SET);
    if (header.SizeOfRawData != fread(data, 1, header.SizeOfRawData, fModule)) {
        dbg_log("read error, in section %s\n", header.Name);
        return false;
    }

    return true;
}

void PESection::Unload() {
    if (data) {
        delete [] data;
    }
}

#ifdef DONOTPRINT
#undef dbg_log
#endif

















```

`revtracerexe/Loader/PE.ldr.h`:

```h
#ifndef _PE_LDR_H_
#define _PE_LDR_H_

#include <vector>
using namespace std;

#include "Types.h"
#include "Abstract.Mapper.h"


struct ImageSectionHeader {
    BYTE    Name[8];
    DWORD   VirtualSize;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
};

struct ImageDosHeader {  // DOS .EXE header
    USHORT e_magic;         // Magic number
    USHORT e_cblp;          // Bytes on last page of file
    USHORT e_cp;            // Pages in file
    USHORT e_crlc;          // Relocations
    USHORT e_cparhdr;       // Size of header in paragraphs
    USHORT e_minalloc;      // Minimum extra paragraphs needed
    USHORT e_maxalloc;      // Maximum extra paragraphs needed
    USHORT e_ss;            // Initial (relative) SS value
    USHORT e_sp;            // Initial SP value
    USHORT e_csum;          // Checksum
    USHORT e_ip;            // Initial IP value
    USHORT e_cs;            // Initial (relative) CS value
    USHORT e_lfarlc;        // File address of relocation table
    USHORT e_ovno;          // Overlay number
    USHORT e_res[4];        // Reserved words
    USHORT e_oemid;         // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;       // OEM information; e_oemid specific
    USHORT e_res2[10];      // Reserved words
    LONG   e_lfanew;        // File address of new exe header
};

struct ImagePeHeader {
    DWORD   PeSignature;
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
};

struct ImageDataDirectory {
    DWORD   VirtualAddress;
    DWORD   Size;
};

#pragma pack (push, 1)
struct ImageOptionalHeader {
	struct {
		WORD    Magic;
		BYTE    MajorLinkerVersion;
		BYTE    MinorLinkerVersion;
		DWORD   SizeOfCode;
		DWORD   SizeOfInitializedData;
		DWORD   SizeOfUninitializedData;
		DWORD   AddressOfEntryPoint;
		DWORD   BaseOfCode;
	} c;

	union {
		struct {
			DWORD   BaseOfData;
			DWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			DWORD   SizeOfStackReserve;
			DWORD   SizeOfStackCommit;
			DWORD   SizeOfHeapReserve;
			DWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w32;

		struct {
			QWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			QWORD   SizeOfStackReserve;
			QWORD   SizeOfStackCommit;
			QWORD   SizeOfHeapReserve;
			QWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w64;
	};   
};
#pragma pack (pop)

class PESection {
public :
	ImageSectionHeader header;
	unsigned char *data;

	bool Load(FILE *fModule);
	void Unload();
};

class FloatingPE {
private :
	bool isValid;

	ImageDosHeader dosHdr;
	ImagePeHeader peHdr;
	ImageOptionalHeader optHdr;

	unsigned char *headers;
	unsigned int headersSize;

	vector<PESection> sections;

	void *RVA(DWORD rva) const;
	bool LoadPE(FILE *fModule);

public :
	FloatingPE(const char *moduleName);
	FloatingPE(const wchar_t *moduleName);
	~FloatingPE();

	bool Relocate(DWORD newAddr);
	bool FixImports(AbstractPEMapper &mapper);
	bool GetExport(const char *funcName, DWORD &funcRVA);

	bool MapPE(AbstractPEMapper &mapr, DWORD &baseAddr);
	
	bool IsValid() const {
		return isValid;
	}
};

#endif

```

`revtracerexe/Loader/Types.h`:

```h
#ifndef _TYPES_H_
#define _TYPES_H_

typedef unsigned short USHORT;
typedef long LONG;

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned long long QWORD;

#endif

```

`revtracerexe/Main.cpp`:

```cpp
#include <stdio.h>
#include <stdarg.h>

#include <Windows.h>
#include <tlhelp32.h>

#include "../revtracer/revtracer.h"

#include "Loader/Inproc.Mapper.h"
#include "Loader/PE.ldr.h"

//using namespace rev;

DWORD baseAddr = 0x0f000000;
bool isInside = false;
DWORD a = FILE_MAP_EXECUTE;

HANDLE fDbg = INVALID_HANDLE_VALUE;
bool MapPE(DWORD &baseAddr);

struct UserContext {
	DWORD execCount;
};

void DebugPrint(DWORD printMask, const char *fmt, ...) {
	va_list va;
	char tmpBuff[512];

	static char lastChar = '\n';

	char pfxBuff[] = "[___|_____|___|_] ";
	
	const char messageTypes[][4] = {
		"___",
		"ERR",
		"INF",
		"DBG"
	};

	const char executionStages[][6] = {
		"_____",
		"BRHND",
		"DIASM",
		"TRANS",
		"REASM",
		"RUNTM",
		"INSPT",
		"CNTNR"
	};

	const char codeTypes[][4] = {
		"___",
		"NAT",
		"RIV",
		"TRK",
		"SYM"
	};

	const char codeDirections[] = {
		'_', 'F', 'B'
	};

	_snprintf_s(
		pfxBuff,
		sizeof(pfxBuff) - 1,
		"[%3s|%5s|%3s|%c] ",
		messageTypes[(printMask & PRINT_MESSAGE_MASK) >> PRINT_MESSAGE_SHIFT],
		executionStages[(printMask & PRINT_EXECUTION_MASK) >> PRINT_EXECUTION_SHIFT],
		codeTypes[(printMask & PRINT_CODE_TYPE_MASK) >> PRINT_CODE_TYPE_SHIFT],
		codeDirections[(printMask & PRINT_CODE_DIRECTION_MASK) >> PRINT_CODE_DIRECTION_SHIFT]
	);

	va_start(va, fmt);
	int sz = _vsnprintf_s(tmpBuff, sizeof(tmpBuff)-1, fmt, va);
	va_end(va);

	unsigned long wr;
	if ('\n' == lastChar) {
		WriteFile(fDbg, pfxBuff, sizeof(pfxBuff) - 1, &wr, NULL);
	}
	WriteFile(fDbg, tmpBuff, sz * sizeof(tmpBuff[0]), &wr, NULL);
	lastChar = tmpBuff[sz - 1];
}

/*__declspec(dllimport) int vsnprintf_s(
	char *buffer,
	size_t sizeOfBuffer,
	size_t count,
	const char *format,
	va_list argptr
);*/

#pragma warning(disable:4996)
HANDLE fBlocks = CreateFileA("tmp.blk", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
#pragma warning(default:4996)

void TmpPrint(const char *fmt, ...) {
	va_list va;
	char tmpBuff[512];

	va_start(va, fmt);
	int sz = _vsnprintf_s(tmpBuff, sizeof(tmpBuff)-1, fmt, va);
	va_end(va);

	unsigned long wr;
	WriteFile(fBlocks, tmpBuff, sz * sizeof(tmpBuff[0]), &wr, NULL);
	//FlushFileBuffers(fBlocks);
	//FlushFileBuffers(__.fDbg);
}

rev::ExecutionRegs rgs[2];

bool RegCheck(const rev::ExecutionRegs &r1, const rev::ExecutionRegs &r2) {
	if (r1.eax != r2.eax) {
		DebugPrint(0, "EAX inconsistent!\n");
		return false;
	}

	if (r1.ecx != r2.ecx) {
		DebugPrint(0, "ECX inconsistent!\n");
		return false;
	}

	if (r1.edx != r2.edx) {
		DebugPrint(0, "EDX inconsistent!\n");
		return false;
	}

	if (r1.ebx != r2.ebx) {
		DebugPrint(0, "EBX inconsistent!\n");
		return false;
	}

	if (r1.esp != r2.esp) {
		DebugPrint(0, "ESP inconsistent!\n");
		return false;
	}

	if (r1.ebp != r2.ebp) {
		DebugPrint(0, "EBP inconsistent!\n");
		return false;
	}

	if (r1.esi != r2.esi) {
		DebugPrint(0, "ESI inconsistent!\n");
		return false;
	}

	if (r1.edi != r2.edi) {
		DebugPrint(0, "ESI inconsistent!\n");
		return false;
	}

	if (r1.eflags != r2.eflags) {
		DebugPrint(0, "EFLAGS inconsistent!\n");
		return false;
	}
	return true;
}

DWORD CustomExecutionController(void *ctx, rev::ADDR_TYPE addr, void *cbCtx) {
	static HANDLE hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());

	static HMODULE hKernel32Dll = NULL;
	static void *IPFPFunc = NULL;
	UserContext *c = (UserContext *)ctx;
	rev::ExecutionRegs cReg;

	c->execCount++;

	char mf[MAX_PATH];
	char defMf[8] = "??";

	if (baseAddr + 0x101F == (DWORD)addr) {
		isInside = true;
	}

	if (((DWORD)addr & 0xFFFD0000) == baseAddr) {
		strcpy(defMf, "a.exe");
	}

	char *module = defMf;

	/*do {
		MODULEENTRY32 me32;

		// Take a snapshot of all modules in the specified process.
		if (hModuleSnap == INVALID_HANDLE_VALUE)
		{
			break;
		}

		// Set the size of the structure before using it.
		me32.dwSize = sizeof(MODULEENTRY32);

		// Retrieve information about the first module,
		// and exit if unsuccessful
		if (!Module32First(hModuleSnap, &me32))
		{
			CloseHandle(hModuleSnap);           // clean the snapshot object
			break;
		}

		// Now walk the module list of the process,
		// and display information about each module
		do
		{
			if ((me32.modBaseAddr <= addr) && ((me32.modBaseAddr + me32.modBaseSize) > addr)) {
				module = me32.szModule;
				break;
			}

		} while (Module32Next(hModuleSnap, &me32));
	} while (0);

	for (char *t = module; *t != '\0'; ++t) {
		*t = toupper(*t);
	}

	rev::GetCurrentRegisters(cbCtx, &cReg);

	TmpPrint("%-15s+%08X EAX:%08x ECX:%08x EDX:%08x EBX:%08x ESP:%08x EBP:%08x ESI:%08x EDI:%08x\r\n", 
		module, 
		(DWORD)addr,
		cReg.eax,
		cReg.ecx,
		cReg.edx,
		cReg.ebx,
		cReg.esp,
		cReg.ebp,
		cReg.esi,
		cReg.edi
	);*/

	if (NULL == hKernel32Dll) {
		if (NULL != (hKernel32Dll = GetModuleHandle("kernel32.dll"))) {
			IPFPFunc = GetProcAddress(hKernel32Dll, "IsProcessorFeaturePresent");
		}
	}

	/*if (NULL != IPFPFunc) {
		if (addr == IPFPFunc) {
			__asm int 3;
		}
	}*/


	/*if (baseAddr + 0x4463 == (DWORD)addr) {
		rev::MarkMemory((rev::ADDR_TYPE)(baseAddr + 0x30540), 0x0F);
	}*/

	/* some very simple control structure going three times forwards and two times back */
	DWORD ret = EXECUTION_ADVANCE;
	/*if (isInside) {
		if (c->execCount % 3 == 1) {
			ret = EXECUTION_BACKTRACK;
		}
	}*/

	static int blockCount = 1000000;

	blockCount--;
	if (0 == blockCount) {
		return EXECUTION_TERMINATE;
	}

	return ret;
}

void InitializeRevtracer(rev::ADDR_TYPE entryPoint) {
	HMODULE hNtDll = GetModuleHandle("ntdll.dll");
	rev::RevtracerAPI *api = &rev::revtracerAPI;

	api->dbgPrintFunc = DebugPrint;
	
	api->lowLevel.ntAllocateVirtualMemory = GetProcAddress(hNtDll, "NtAllocateVirtualMemory");
	api->lowLevel.ntFreeVirtualMemory = GetProcAddress(hNtDll, "NtFreeVirtualMemory");
	
	api->lowLevel.ntQueryInformationThread = GetProcAddress(hNtDll, "NtQueryInformationThread");
	api->lowLevel.ntTerminateProcess = GetProcAddress(hNtDll, "NtTerminateProcess");

	api->lowLevel.rtlNtStatusToDosError = GetProcAddress(hNtDll, "RtlNtStatusToDosError");
	api->lowLevel.vsnprintf_s = GetProcAddress(hNtDll, "_vsnprintf_s");

	//api->executionControl = CustomExecutionController;


	rev::RevtracerConfig *config = &rev::revtracerConfig;
	config->contextSize = 4;
	config->entryPoint = entryPoint;
	config->featureFlags = TRACER_FEATURE_TRACKING;

	rev::Initialize();
}

int main(unsigned int argc, char *argv[]) {
	if (!MapPE(baseAddr)) {
		return false;
	}

	HMODULE hNtDll = GetModuleHandleW(L"ntdll.dll");
	TmpPrint("ntdll.dll @ 0x%08x\n", (DWORD)hNtDll);

	fDbg = CreateFileA("dbg.log", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
	//fopen_s(&fDbg, "dbg.log", "wt");
	InitializeRevtracer((rev::ADDR_TYPE)(baseAddr + 0x96CE));
	//InitializeRevtracer((rev::ADDR_TYPE)(baseAddr + 0x13A6));
	//InitializeRevtracer((rev::ADDR_TYPE)tmp);

	//rev::MarkMemory((rev::ADDR_TYPE)(baseAddr + 0x2B000), 0x01);
	//rev::MarkMemory((rev::ADDR_TYPE)(baseAddr + 0x2B004), 0x02);
	
	rev::MarkMemoryValue((rev::ADDR_TYPE)(baseAddr + 0x60540), 0x01);
	rev::MarkMemoryValue((rev::ADDR_TYPE)(baseAddr + 0x60544), 0x02);
	rev::MarkMemoryValue((rev::ADDR_TYPE)(baseAddr + 0x60548), 0x04);

	//rev::MarkMemoryName((rev::ADDR_TYPE)(baseAddr + 0x60540), "a");
	//rev::MarkMemoryName((rev::ADDR_TYPE)(baseAddr + 0x60544), "b");
	//rev::MarkMemoryName((rev::ADDR_TYPE)(baseAddr + 0x60548), "c");
	rev::Execute(argc, argv);
	
	CloseHandle(fDbg);
	return 0;
}

```

`revtracerexe/MapPE.cpp`:

```cpp

#include "Loader/PE.ldr.h"
#include "Loader/Inproc.Mapper.h"

int __stdcall MyIsProcessorFeaturePresent(DWORD ProcessorFeature);
void __stdcall MyExitProcess(DWORD retCode);

class HookedMapper : public InprocMapper {
public :
	virtual DWORD FindImport(const char *moduleName, const char *funcName) {
		if (0 == _strcmpi(moduleName, "kernel32.dll")) {
			if (0 == _strcmpi(funcName, "IsProcessorFeaturePresent")) {
				return (DWORD)MyIsProcessorFeaturePresent;
			}

			if (0 == _strcmpi(funcName, "ExitProcess")) {
				return (DWORD)MyExitProcess;
			}
		}
		return InprocMapper::FindImport(moduleName, funcName);

	}
};

bool MapPE(DWORD &baseAddr) {
	HookedMapper mapper;
	FloatingPE pe("..\\lzo\\a.exe");
	//FloatingPE pe("..\\fibonacci\\fib.exe");
	//FloatingPE pe("..\\lzo\\hw.exe");

	if (!pe.MapPE(mapper, baseAddr)) {
		printf("Couldn't map pe!");
		return false;
	}

	return true;
}
```

`revtracerexe/revtracerexe.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Extern.cpp" />
    <ClCompile Include="Loader\Inproc.Mapper.cpp" />
    <ClCompile Include="Loader\PE.ldr.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="MapPE.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Extern.h" />
    <ClInclude Include="Loader\Abstract.Mapper.h" />
    <ClInclude Include="Loader\Inproc.Mapper.h" />
    <ClInclude Include="Loader\PE.ldr.h" />
    <ClInclude Include="Loader\Types.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{37068188-4560-46D5-8ECA-932407A8ED49}</ProjectGuid>
    <RootNamespace>revtracerexe</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <EmbedManifest>false</EmbedManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>$(OutDir)\revtracer.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <Profile>true</Profile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>$(OutDir)\revtracer.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tracer.simple/Main.cpp`:

```cpp
#include "ezOptionParser.h"
#include "../Execution/Execution.h"

#ifdef _WIN32
#include <Windows.h>
#define LIB_EXT ".dll"
#else
#define LIB_EXT ".so"
extern "C" void patch__rtld_global_ro();
#endif

ExecutionController *ctrl = NULL;

class CustomObserver : public ExecutionObserver {
public :
	FILE *fBlocks;
	std::string patchFile;
	ModuleInfo *mInfo;
	int mCount;

	virtual void TerminationNotification(void *ctx) {
		printf("Process Terminated\n");
	}

	unsigned int GetModuleOffset(const std::string &module) const {
		const char *m = module.c_str();
		for (int i = 0; i < mCount; ++i) {
			if (0 == strcmp(mInfo[i].Name, m)) {
				return mInfo[i].ModuleBase;
			}
		}

		return 0;
	}

	bool PatchLibrary(std::ifstream &fPatch) {
		std::string line;
		while (std::getline(fPatch, line)) {
			bool bForce = false;
			int nStart = 0;

			// l-trim equivalent
			while ((line[nStart] == ' ') || (line[nStart] == '\t')) {
				nStart++;
			}

			switch (line[nStart]) {
				case '#' : // comment line
				case '\n' : // empty line
					continue;
				case '!' : // force patch line
					bForce = true;
					nStart++;
					break;
			}

			int sep = line.find(L'+');
			int val = line.find(L'=');
			if ((std::string::npos == sep) || (std::string::npos == val)) {
				return false;
			}

			unsigned int module = GetModuleOffset(line.substr(0, sep));

			if (0 == module) {
				return false;
			}

			unsigned long offset = std::stoul(line.substr(sep + 1, val), nullptr, 16);
			unsigned long value = std::stoul(line.substr(val + 1), nullptr, 16);
			

			// TODO: move this to the controller
			*(unsigned int *)(module + offset) = value;
		}

		return true;
	}

	virtual unsigned int ExecutionBegin(void *ctx, void *address) {
		printf("Process starting\n");
		ctrl->GetModules(mInfo, mCount);

		if (!patchFile.empty()) {
			std::ifstream fPatch;

			fPatch.open(patchFile);
			
			if (!fPatch.good()) {
				std::cout << "Patch file not found" << std::endl;
				return EXECUTION_TERMINATE;
			}

			PatchLibrary(fPatch);
			fPatch.close();

		}

		return EXECUTION_ADVANCE;
	}

	virtual unsigned int ExecutionControl(void *ctx, void *address) {
		const char unkmod[MAX_PATH] = "???";
		unsigned int offset = (DWORD)address;
		int foundModule = -1;

		for (int i = 0; i < mCount; ++i) {
			if ((mInfo[i].ModuleBase <= (DWORD)address) && ((DWORD)address < mInfo[i].ModuleBase + mInfo[i].Size)) {
				offset -= mInfo[i].ModuleBase;
				foundModule = i;
				break;
			}
		}


		const char module[] = "";
		fprintf(fBlocks, "%-15s + %08lX\n",
			(-1 == foundModule) ? unkmod : mInfo[foundModule].Name,
			(DWORD)offset
		);
		return EXECUTION_ADVANCE;
	}

	virtual unsigned int ExecutionEnd(void *ctx) {
		fflush(fBlocks);
		return EXECUTION_TERMINATE;
	}
} observer;

#define MAX_BUFF 4096
typedef int(*PayloadFunc)();
char *payloadBuffer = nullptr;
PayloadFunc Payload = nullptr;

int main(int argc, const char *argv[]) {
	ez::ezOptionParser opt;

	opt.overview = "River simple tracer.";
	opt.syntax = "tracer.simple [OPTIONS]";
	opt.example = "tracer.simple -o<outfile>\n";

	opt.add(
		"",
		0,
		0,
		0,
		"Use inprocess execution.",
		"--inprocess"
	);

	opt.add(
		"",
		0,
		0,
		0,
		"Use extern execution.",
		"--extern"
	);

	opt.add(
		"", // Default.
		0, // Required?
		0, // Number of args expected.
		0, // Delimiter if expecting multiple args.
		"Display usage instructions.", // Help description.
		"-h",     // Flag token. 
		"--help", // Flag token.
		"--usage" // Flag token.
	);

	opt.add(
		"trace.simple.out", // Default.
		0, // Required?
		1, // Number of args expected.
		0, // Delimiter if expecting multiple args.
		"Set the trace output file.", // Help description.
		"-o",			 // Flag token.
		"--outfile"     // Flag token. 
	);

	opt.add(
		"payload" LIB_EXT,
		0,
		1,
		0,
		"Set the payload file. Only applicable for in-process tracing.",
		"-p",
		"--payload"
	);

	opt.add(
		"",
		0,
		1,
		0,
		"Set the memory patching file.",
		"-m",
		"--mem-patch"
	);

	opt.parse(argc, argv);

	uint32_t executionType = EXECUTION_INPROCESS;

	if (opt.isSet("--inprocess") && opt.isSet("--extern")) {
		std::cout << "Conflicting options --inprocess and --extern" << std::endl;
		return 0;
	}

	if (opt.isSet("--extern")) {
		executionType = EXECUTION_EXTERNAL;
	}

	if (executionType != EXECUTION_INPROCESS) {
		std::cout << "Only inprocess execution supported for now! Sorry!" << std::endl;
		return 0;
	}

	ctrl = NewExecutionController(executionType);

	if (opt.isSet("-h")) {
		std::string usage;
		opt.getUsage(usage);
		std::cout << usage;
		return 0;
	}

	std::string fModule;
	opt.get("-p")->getString(fModule);
	std::cout << "Using payload " << fModule << std::endl;
	lib_t hModule = GET_LIB_HANDLER(fModule.c_str());
	if (nullptr == hModule) {
		std::cout << "Payload not found" << std::endl;
		return 0;
	}

	payloadBuffer = (char *)LOAD_PROC(hModule, "payloadBuffer");
	Payload = (PayloadFunc)LOAD_PROC(hModule, "Payload");

	if ((nullptr == payloadBuffer) || (nullptr == Payload)) {
		std::cout << "Payload imports not found" << std::endl;
		return 0;
	}

	std::string fName;
	opt.get("-o")->getString(fName);
	std::cout << "Writing output to " << fName << std::endl;


	char *buff = payloadBuffer;
	unsigned int bSize = MAX_BUFF;
	do {
		fgets(buff, bSize, stdin);
		while (*buff) {
			buff++;
			bSize--;
		}
	} while (!feof(stdin));

	FOPEN(observer.fBlocks, fName.c_str(), "wt");
		
	if (opt.isSet("-m")) {
		opt.get("-m")->getString(observer.patchFile);
	}
#ifdef __linux__
	patch__rtld_global_ro();
#endif

	ctrl->SetEntryPoint((void*)Payload);
	
	ctrl->SetExecutionFeatures(0);

	ctrl->SetExecutionObserver(&observer);
	
	ctrl->Execute();

	ctrl->WaitForTermination();

	DeleteExecutionController(ctrl);
	ctrl = NULL;

	fclose(observer.fBlocks);
	return 0;
}

```

`tracer.simple/Makefile`:

```
mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
makefile_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

simple_tracer := simple_tracer
CC := gcc
CXX := g++
CPP_FILES := Main.cpp
OBJ_FILES := Main.o
LD_PATHS:= -L$(makefile_dir)/../DisableSSE -L$(makefile_dir)/../Execution -L$(makefile_dir)

LD_FLAGS:= -lexecution -lpthread -ldl -ldisablesse
CC_FLAGS_CROSS = -D__cdecl="" -D__stdcall=""
NO_SSE := -mno-mmx -mno-sse -march=i386
CXX_FLAGS += -m32 $(NO_SSE) -std=c++11 $(CC_FLAGS_CROSS)
CC_FLAGS += -m32 $(NO_SSE) $(CC_FLAGS_CROSS)
prefix := /usr/local

all: $(simple_tracer)

install: $(simple_tracer)
	install -m 0755 $(simple_tracer) -t $(prefix)/bin -D

$(simple_tracer): $(OBJ_FILES)
	$(CXX) $(LD_PATHS) $(CXX_FLAGS) -o $@ $(OBJ_FILES) $(LD_FLAGS)

Main.o: Main.cpp
	$(CXX) $(CXX_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(simple_tracer) $(OBJ_FILES_SO) $(OBJ_FILES)

```

`tracer.simple/ezOptionParser.h`:

```h
/*
This file is part of ezOptionParser. See MIT-LICENSE.

Copyright (C) 2011,2012,2014 Remik Ziemlinski <first d0t surname att gmail>

CHANGELOG

v0.0.0 20110505 rsz Created.
v0.1.0 20111006 rsz Added validator.
v0.1.1 20111012 rsz Fixed validation of ulonglong.
v0.1.2 20111126 rsz Allow flag names start with alphanumeric (previously, flag had to start with alpha).
v0.1.3 20120108 rsz Created work-around for unique id generation with IDGenerator that avoids retarded c++ translation unit linker errors with single-header static variables. Forced inline on all methods to please retard compiler and avoid multiple def errors.
v0.1.4 20120629 Enforced MIT license on all files.
v0.2.0 20121120 Added parseIndex to OptionGroup.
v0.2.1 20130506 Allow disabling doublespace of OPTIONS usage descriptions.
v0.2.2 20140504 Jose Santiago added compiler warning fixes.
Bruce Shankle added a crash fix in description printing.
*/
#ifndef EZ_OPTION_PARSER_H
#define EZ_OPTION_PARSER_H

#include <stdlib.h>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <limits>
#include <sstream>
#include <cstring>

#include "../CommonCrossPlatform/Common.h"

namespace ez {
#define DEBUGLINE() printf("%s:%d\n", __FILE__, __LINE__);

	/* ################################################################### */
	template<typename T>
	static T fromString(const std::string* s) {
		std::istringstream stream(s->c_str());
		T t;
		stream >> t;
		return t;
	};
	template<typename T>
	static T fromString(const char* s) {
		std::istringstream stream(s);
		T t;
		stream >> t;
		return t;
	};
	/* ################################################################### */
	static inline bool isdigit(const std::string & s, int i = 0) {
		int n = s.length();
		for (; i < n; ++i)
			switch (s[i]) {
			case '0': case '1': case '2':
			case '3': case '4': case '5':
			case '6': case '7': case '8': case '9': break;
			default: return false;
			}

		return true;
	};
	/* ################################################################### */
	static bool isdigit(const std::string * s, int i = 0) {
		int n = s->length();
		for (; i < n; ++i)
			switch (s->at(i)) {
			case '0': case '1': case '2':
			case '3': case '4': case '5':
			case '6': case '7': case '8': case '9': break;
			default: return false;
			}

		return true;
	};
	/* ################################################################### */
	/*
	Compare strings for opts, so short opt flags come before long format flags.
	For example, -d < --dimension < --dmn, and also lower come before upper. The default STL std::string compare doesn't do that.
	*/
	static bool CmpOptStringPtr(std::string * s1, std::string * s2) {
		int c1, c2;
		const char *s = s1->c_str();
		for (c1 = 0; c1 < (long int)s1->size(); ++c1)
			if (isalnum(s[c1])) // locale sensitive.
				break;

		s = s2->c_str();
		for (c2 = 0; c2 < (long int)s2->size(); ++c2)
			if (isalnum(s[c2]))
				break;

		// Test which has more symbols before its name.
		if (c1 > c2)
			return false;
		else if (c1 < c2)
			return true;

		// Both have same number of symbols, so compare first letter.
		char char1 = s1->at(c1);
		char char2 = s2->at(c2);
		char lo1 = tolower(char1);
		char lo2 = tolower(char2);

		if (lo1 != lo2)
			return lo1 < lo2;

		// Their case doesn't match, so find which is lower.
		char up1 = isupper(char1);
		char up2 = isupper(char2);

		if (up1 && !up2)
			return false;
		else if (!up1 && up2)
			return true;

		return (s1->compare(*s2)<0);
	};
	/* ################################################################### */
	/*
	Makes a vector of strings from one string,
	splitting at (and excluding) delimiter "token".
	*/
	static void SplitDelim(const std::string& s, const char token, std::vector<std::string*> * result) {
		std::string::const_iterator i = s.begin();
		std::string::const_iterator j = s.begin();
		const std::string::const_iterator e = s.end();

		while (i != e) {
			while (i != e && *i++ != token);
			std::string *newstr = new std::string(j, i);
			if (newstr->at(newstr->size() - 1) == token) newstr->erase(newstr->size() - 1);
			result->push_back(newstr);
			j = i;
		}
	};
	/* ################################################################### */
	// Variant that uses deep copies and references instead of pointers (less efficient).
	static void SplitDelim(const std::string& s, const char token, std::vector<std::string> & result) {
		std::string::const_iterator i = s.begin();
		std::string::const_iterator j = s.begin();
		const std::string::const_iterator e = s.end();

		while (i != e) {
			while (i != e && *i++ != token);
			std::string newstr(j, i);
			if (newstr.at(newstr.size() - 1) == token) newstr.erase(newstr.size() - 1);
			result.push_back(newstr);
			j = i;
		}
	};
	/* ################################################################### */
	// Variant that uses list instead of vector for efficient insertion, etc.
	static void SplitDelim(const std::string& s, const char token, std::list<std::string*> & result) {
		std::string::const_iterator i = s.begin();
		std::string::const_iterator j = s.begin();
		const std::string::const_iterator e = s.end();

		while (i != e) {
			while (i != e && *i++ != token);
			std::string *newstr = new std::string(j, i);
			if (newstr->at(newstr->size() - 1) == token) newstr->erase(newstr->size() - 1);
			result.push_back(newstr);
			j = i;
		}
	};
	/* ################################################################### */
	static void ToU1(std::string ** strings, unsigned char * out, int n) {
		for (int i = 0; i < n; ++i) {
			out[i] = (unsigned char)atoi(strings[i]->c_str());
		}
	};
	/* ################################################################### */
	static void ToS1(std::string ** strings, char * out, int n) {
		for (int i = 0; i < n; ++i) {
			out[i] = (char)atoi(strings[i]->c_str());
		}
	};
	/* ################################################################### */
	static void ToU2(std::string ** strings, unsigned short * out, int n) {
		for (int i = 0; i < n; ++i) {
			out[i] = (unsigned short)atoi(strings[i]->c_str());
		}
	};
	/* ################################################################### */
	static void ToS2(std::string ** strings, short * out, int n) {
		for (int i = 0; i < n; ++i) {
			out[i] = (short)atoi(strings[i]->c_str());
		}
	};
	/* ################################################################### */
	static void ToS4(std::string ** strings, int * out, int n) {
		for (int i = 0; i < n; ++i) {
			out[i] = atoi(strings[i]->c_str());
		}
	};
	/* ################################################################### */
	static void ToU4(std::string ** strings, unsigned int * out, int n) {
		for (int i = 0; i < n; ++i) {
			out[i] = (unsigned int)strtoul(strings[i]->c_str(), NULL, 0);
		}
	};
	/* ################################################################### */
	static void ToS8(std::string ** strings, long long * out, int n) {
		for (int i = 0; i < n; ++i) {
			std::stringstream ss(strings[i]->c_str());
			ss >> out[i];
		}
	};
	/* ################################################################### */
	static void ToU8(std::string ** strings, unsigned long long * out, int n) {
		for (int i = 0; i < n; ++i) {
			std::stringstream ss(strings[i]->c_str());
			ss >> out[i];
		}
	};
	/* ################################################################### */
	static void ToF(std::string ** strings, float * out, int n) {
		for (int i = 0; i < n; ++i) {
			out[i] = (float)atof(strings[i]->c_str());
		}
	};
	/* ################################################################### */
	static void ToD(std::string ** strings, double * out, int n) {
		for (int i = 0; i < n; ++i) {
			out[i] = (double)atof(strings[i]->c_str());
		}
	};
	/* ################################################################### */
	static void StringsToInts(std::vector<std::string> & strings, std::vector<int> & out) {
		for (int i = 0; i < (long int)strings.size(); ++i) {
			out.push_back(atoi(strings[i].c_str()));
		}
	};
	/* ################################################################### */
	static void StringsToInts(std::vector<std::string*> * strings, std::vector<int> * out) {
		for (int i = 0; i < (long int)strings->size(); ++i) {
			out->push_back(atoi(strings->at(i)->c_str()));
		}
	};
	/* ################################################################### */
	static void StringsToLongs(std::vector<std::string> & strings, std::vector<long> & out) {
		for (int i = 0; i < (long int)strings.size(); ++i) {
			out.push_back(atol(strings[i].c_str()));
		}
	};
	/* ################################################################### */
	static void StringsToLongs(std::vector<std::string*> * strings, std::vector<long> * out) {
		for (int i = 0; i < (long int)strings->size(); ++i) {
			out->push_back(atol(strings->at(i)->c_str()));
		}
	};
	/* ################################################################### */
	static void StringsToULongs(std::vector<std::string> & strings, std::vector<unsigned long> & out) {
		for (int i = 0; i < (long int)strings.size(); ++i) {
			out.push_back(strtoul(strings[i].c_str(), 0, 0));
		}
	};
	/* ################################################################### */
	static void StringsToULongs(std::vector<std::string*> * strings, std::vector<unsigned long> * out) {
		for (int i = 0; i < (long int)strings->size(); ++i) {
			out->push_back(strtoul(strings->at(i)->c_str(), 0, 0));
		}
	};
	/* ################################################################### */
	static void StringsToFloats(std::vector<std::string> & strings, std::vector<float> & out) {
		for (int i = 0; i < (long int)strings.size(); ++i) {
			out.push_back((float)atof(strings[i].c_str()));
		}
	};
	/* ################################################################### */
	static void StringsToFloats(std::vector<std::string*> * strings, std::vector<float> * out) {
		for (int i = 0; i < (long int)strings->size(); ++i) {
			out->push_back((float)atof(strings->at(i)->c_str()));
		}
	};
	/* ################################################################### */
	static void StringsToDoubles(std::vector<std::string> & strings, std::vector<double> & out) {
		for (int i = 0; i < (long int)strings.size(); ++i) {
			out.push_back(atof(strings[i].c_str()));
		}
	};
	/* ################################################################### */
	static void StringsToDoubles(std::vector<std::string*> * strings, std::vector<double> * out) {
		for (int i = 0; i < (long int)strings->size(); ++i) {
			out->push_back(atof(strings->at(i)->c_str()));
		}
	};
	/* ################################################################### */
	static void StringsToStrings(std::vector<std::string*> * strings, std::vector<std::string> * out) {
		for (int i = 0; i < (long int)strings->size(); ++i) {
			out->push_back(*strings->at(i));
		}
	};
	/* ################################################################### */
	static void ToLowerASCII(std::string & s) {
		int n = s.size();
		int i = 0;
		char c;
		for (; i < n; ++i) {
			c = s[i];
			if (c <= 'Z' && c >= 'A')
				s[i] = c + 32;
		}
	}
	/* ################################################################### */
	static char** CommandLineToArgvA(char* CmdLine, int* _argc) {
		char** argv;
		char*  _argv;
		unsigned long   len;
		unsigned long   argc;
		char   a;
		unsigned long   i, j;

		bool  in_QM;
		bool  in_TEXT;
		bool  in_SPACE;

		len = strlen(CmdLine);
		i = ((len + 2) / 2) * sizeof(void*) + sizeof(void*);

		argv = (char**)malloc(i + (len + 2) * sizeof(char));

		_argv = (char*)(((unsigned char*)argv) + i);

		argc = 0;
		argv[argc] = _argv;
		in_QM = false;
		in_TEXT = false;
		in_SPACE = true;
		i = 0;
		j = 0;

		while ((a = CmdLine[i])) {
			if (in_QM) {
				if ((a == '\"') ||
					(a == '\'')) // rsz. Added single quote.
				{
					in_QM = false;
				}
				else {
					_argv[j] = a;
					j++;
				}
			}
			else {
				switch (a) {
				case '\"':
				case '\'': // rsz. Added single quote.
					in_QM = true;
					in_TEXT = true;
					if (in_SPACE) {
						argv[argc] = _argv + j;
						argc++;
					}
					in_SPACE = false;
					break;
				case ' ':
				case '\t':
				case '\n':
				case '\r':
					if (in_TEXT) {
						_argv[j] = '\0';
						j++;
					}
					in_TEXT = false;
					in_SPACE = true;
					break;
				default:
					in_TEXT = true;
					if (in_SPACE) {
						argv[argc] = _argv + j;
						argc++;
					}
					_argv[j] = a;
					j++;
					in_SPACE = false;
					break;
				}
			}
			i++;
		}
		_argv[j] = '\0';
		argv[argc] = NULL;

		(*_argc) = argc;
		return argv;
	};
	/* ################################################################### */
	// Create unique ids with static and still allow single header that avoids multiple definitions linker error.
	class ezOptionParserIDGenerator {
	public:
		static ezOptionParserIDGenerator& instance() { static ezOptionParserIDGenerator Generator; return Generator; }
		short next() { return ++_id; }
	private:
		ezOptionParserIDGenerator() : _id(-1) {}
		short _id;
	};
	/* ################################################################### */
	/* Validate a value by checking:
	- if as string, see if converted value is within datatype's limits,
	- and see if falls within a desired range,
	- or see if within set of given list of values.

	If comparing with a range, the values list must contain one or two values. One value is required when comparing with <, <=, >, >=. Use two values when requiring a test such as <x<, <=x<, <x<=, <=x<=.
	A regcomp/regexec based class could be created in the future if a need arises.
	*/
	class ezOptionValidator {
	public:
		inline ezOptionValidator(const char* _type, const char* _op = 0, const char* list = 0, bool _insensitive = false);
		inline ezOptionValidator(char _type);
		inline ezOptionValidator(char _type, char _op, const char* list, int _size);
		inline ezOptionValidator(char _type, char _op, const unsigned char* list, int _size);
		inline ezOptionValidator(char _type, char _op, const short* list, int _size);
		inline ezOptionValidator(char _type, char _op, const unsigned short* list, int _size);
		inline ezOptionValidator(char _type, char _op, const int* list, int _size);
		inline ezOptionValidator(char _type, char _op, const unsigned int* list, int _size);
		inline ezOptionValidator(char _type, char _op, const long long* list, int _size);
		inline ezOptionValidator(char _type, char _op, const unsigned long long* list, int _size = 0);
		inline ezOptionValidator(char _type, char _op, const float* list, int _size);
		inline ezOptionValidator(char _type, char _op, const double* list, int _size);
		inline ezOptionValidator(char _type, char _op, const char** list, int _size, bool _insensitive);
		inline ~ezOptionValidator();

		inline bool isValid(const std::string * value);
		inline void print();
		inline void reset();

		/* If value must be in custom range, use these comparison modes. */
		enum OP {
			NOOP = 0,
			LT, /* value < list[0] */
			LE, /* value <= list[0] */
			GT, /* value > list[0] */
			GE, /* value >= list[0] */
			GTLT, /* list[0] < value < list[1] */
			GELT, /* list[0] <= value < list[1] */
			GELE, /* list[0] <= value <= list[1] */
			GTLE, /* list[0] < value <= list[1] */
			IN /* if value is in list */
		};

		enum TYPE { NOTYPE = 0, S1, U1, S2, U2, S4, U4, S8, U8, F, D, T };
		enum TYPE2 { NOTYPE2 = 0, INT8, UINT8, INT16, UINT16, INT32, UINT32, INT64, UINT64, FLOAT, DOUBLE, TEXT };

		union {
			unsigned char *u1;
			char *s1;
			unsigned short *u2;
			short *s2;
			unsigned int *u4;
			int *s4;
			unsigned long long *u8;
			long long *s8;
			float *f;
			double *d;
			std::string** t;
		};

		char op;
		bool quiet;
		short id;
		char type;
		int size;
		bool insensitive;
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::~ezOptionValidator() {
		reset();
	};
	/* ------------------------------------------------------------------- */
	void ezOptionValidator::reset() {
#define CLEAR(TYPE,P) case TYPE: if (P) delete [] P; P = 0; break;
		switch (type) {
			CLEAR(S1, s1);
			CLEAR(U1, u1);
			CLEAR(S2, s2);
			CLEAR(U2, u2);
			CLEAR(S4, s4);
			CLEAR(U4, u4);
			CLEAR(S8, s8);
			CLEAR(U8, u8);
			CLEAR(F, f);
			CLEAR(D, d);
		case T:
			for (int i = 0; i < size; ++i)
				delete t[i];

			delete[] t;
			t = 0;
			break;
		default: break;
		}

		size = 0;
		op = NOOP;
		type = NOTYPE;
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type) : s1(0), op(0), quiet(0), type(_type), size(0), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const char* list, int _size) : s1(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		s1 = new char[size];
		memcpy(s1, list, size);
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const unsigned char* list, int _size) : u1(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		u1 = new unsigned char[size];
		memcpy(u1, list, size);
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const short* list, int _size) : s2(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		s2 = new short[size];
		memcpy(s2, list, size * sizeof(short));
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const unsigned short* list, int _size) : u2(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		u2 = new unsigned short[size];
		memcpy(u2, list, size * sizeof(unsigned short));
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const int* list, int _size) : s4(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		s4 = new int[size];
		memcpy(s4, list, size * sizeof(int));
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const unsigned int* list, int _size) : u4(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		u4 = new unsigned int[size];
		memcpy(u4, list, size * sizeof(unsigned int));
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const long long* list, int _size) : s8(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		s8 = new long long[size];
		memcpy(s8, list, size * sizeof(long long));
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const unsigned long long* list, int _size) : u8(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		u8 = new unsigned long long[size];
		memcpy(u8, list, size * sizeof(unsigned long long));
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const float* list, int _size) : f(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		f = new float[size];
		memcpy(f, list, size * sizeof(float));
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const double* list, int _size) : d(0), op(_op), quiet(0), type(_type), size(_size), insensitive(0) {
		id = ezOptionParserIDGenerator::instance().next();
		d = new double[size];
		memcpy(d, list, size * sizeof(double));
	};
	/* ------------------------------------------------------------------- */
	ezOptionValidator::ezOptionValidator(char _type, char _op, const char** list, int _size, bool _insensitive) : t(0), op(_op), quiet(0), type(_type), size(_size), insensitive(_insensitive) {
		id = ezOptionParserIDGenerator::instance().next();
		t = new std::string*[size];
		int i = 0;

		for (; i < size; ++i) {
			t[i] = new std::string(list[i]);
		}
	};
	/* ------------------------------------------------------------------- */
	/* Less efficient but convenient ctor that parses strings to setup validator.
	_type: s1, u1, s2, u2, ..., f, d, t
	_op: lt, gt, ..., in
	_list: comma-delimited string
	*/
	ezOptionValidator::ezOptionValidator(const char* _type, const char* _op, const char* _list, bool _insensitive) : t(0), quiet(0), type(0), size(0), insensitive(_insensitive) {
		id = ezOptionParserIDGenerator::instance().next();

		switch (_type[0]) {
		case 'u':
			switch (_type[1]) {
			case '1': type = U1; break;
			case '2': type = U2; break;
			case '4': type = U4; break;
			case '8': type = U8; break;
			default: break;
			}
			break;
		case 's':
			switch (_type[1]) {
			case '1': type = S1;
				break;
			case '2': type = S2; break;
			case '4': type = S4; break;
			case '8': type = S8; break;
			default: break;
			}
			break;
		case 'f': type = F; break;
		case 'd': type = D; break;
		case 't': type = T; break;
		default:
			if (!quiet)
				std::cerr << "ERROR: Unknown validator datatype \"" << _type << "\".\n";
			break;
		}

		int nop = 0;
		if (_op != 0)
			nop = strlen(_op);

		switch (nop) {
		case 0: op = NOOP; break;
		case 2:
			switch (_op[0]) {
			case 'g':
				switch (_op[1]) {
				case 'e': op = GE; break;
				default: op = GT; break;
				}
				break;
			case 'i': op = IN;
				break;
			default:
				switch (_op[1]) {
				case 'e': op = LE; break;
				default: op = LT; break;
				}
				break;
			}
			break;
		case 4:
			switch (_op[1]) {
			case 'e':
				switch (_op[3]) {
				case 'e': op = GELE; break;
				default: op = GELT; break;
				}
				break;
			default:
				switch (_op[3]) {
				case 'e': op = GTLE; break;
				default: op = GTLT; break;
				}
				break;
			}
			break;
		default:
			if (!quiet)
				std::cerr << "ERROR: Unknown validator operation \"" << _op << "\".\n";
			break;
		}

		if (_list == 0) return;
		// Create list of strings and then cast to native datatypes.
		std::string unsplit(_list);
		std::list<std::string*> split;
		std::list<std::string*>::iterator it;
		SplitDelim(unsplit, ',', split);
		size = split.size();
		std::string **strings = new std::string*[size];

		int i = 0;
		for (it = split.begin(); it != split.end(); ++it)
			strings[i++] = *it;

		if (insensitive)
			for (i = 0; i < size; ++i)
				ToLowerASCII(*strings[i]);

#define FreeStrings() { \
    for(i=0; i < size; ++i)\
      delete strings[i];\
    delete [] strings;\
  }

#define ToArray(T,P,Y) case T: P = new Y[size]; To##T(strings, P, size); FreeStrings(); break;
		switch (type) {
			ToArray(S1, s1, char);
			ToArray(U1, u1, unsigned char);
			ToArray(S2, s2, short);
			ToArray(U2, u2, unsigned short);
			ToArray(S4, s4, int);
			ToArray(U4, u4, unsigned int);
			ToArray(S8, s8, long long);
			ToArray(U8, u8, unsigned long long);
			ToArray(F, f, float);
			ToArray(D, d, double);
		case T: t = strings; break; /* Don't erase strings array. */
		default: break;
		}
	};
	/* ------------------------------------------------------------------- */
	void ezOptionValidator::print() {
		printf("id=%d, op=%d, type=%d, size=%d, insensitive=%d\n", id, op, type, size, insensitive);
	};
	/* ------------------------------------------------------------------- */
	bool ezOptionValidator::isValid(const std::string * valueAsString) {
		if (valueAsString == 0) return false;

#define CHECKRANGE(E,T) {\
  std::stringstream ss(valueAsString->c_str()); \
  long long E##value; \
  ss >> E##value; \
  long long E##min = static_cast<long long>(std::numeric_limits<T>::min()); \
  if (E##value < E##min) { \
    if (!quiet) \
      std::cerr << "ERROR: Invalid value " << E##value << " is less than datatype min " << E##min << ".\n"; \
    return false; \
  } \
  \
  long long E##max = static_cast<long long>(std::numeric_limits<T>::max()); \
  if (E##value > E##max) { \
    if (!quiet) \
      std::cerr << "ERROR: Invalid value " << E##value << " is greater than datatype max " << E##max << ".\n"; \
    return false; \
  } \
}
		// Check if within datatype limits.
		if (type != T) {
			switch (type) {
			case S1: CHECKRANGE(S1, char); break;
			case U1: CHECKRANGE(U1, unsigned char); break;
			case S2: CHECKRANGE(S2, short); break;
			case U2: CHECKRANGE(U2, unsigned short); break;
			case S4: CHECKRANGE(S4, int); break;
			case U4: CHECKRANGE(U4, unsigned int); break;
			case S8: {
				if ((valueAsString->at(0) == '-') &&
					isdigit(valueAsString, 1) &&
					(valueAsString->size() > 19) &&
					(valueAsString->compare(1, 19, "9223372036854775808") > 0)) {
					if (!quiet)
						std::cerr << "ERROR: Invalid value " << *valueAsString << " is less than datatype min -9223372036854775808.\n";
					return false;
				}

				if (isdigit(valueAsString) &&
					(valueAsString->size() > 18) &&
					valueAsString->compare("9223372036854775807") > 0) {
					if (!quiet)
						std::cerr << "ERROR: Invalid value " << *valueAsString << " is greater than datatype max 9223372036854775807.\n";
					return false;
				}
			} break;
			case U8: {
				if (valueAsString->compare("0") < 0) {
					if (!quiet)
						std::cerr << "ERROR: Invalid value " << *valueAsString << " is less than datatype min 0.\n";
					return false;
				}

				if (isdigit(valueAsString) &&
					(valueAsString->size() > 19) &&
					valueAsString->compare("18446744073709551615") > 0) {
					if (!quiet)
						std::cerr << "ERROR: Invalid value " << *valueAsString << " is greater than datatype max 18446744073709551615.\n";
					return false;
				}
			} break;
			case F: {
				double dmax = static_cast<double>(std::numeric_limits<float>::max());
				double dvalue = atof(valueAsString->c_str());
				double dmin = -dmax;
				if (dvalue < dmin) {
					if (!quiet) {
						fprintf(stderr, "ERROR: Invalid value %g is less than datatype min %g.\n", dvalue, dmin);
					}
					return false;
				}

				if (dvalue > dmax) {
					if (!quiet)
						std::cerr << "ERROR: Invalid value " << dvalue << " is greater than datatype max " << dmax << ".\n";
					return false;
				}
			} break;
			case D: {
				long double ldmax = static_cast<long double>(std::numeric_limits<double>::max());
				std::stringstream ss(valueAsString->c_str());
				long double ldvalue;
				ss >> ldvalue;
				long double ldmin = -ldmax;

				if (ldvalue < ldmin) {
					if (!quiet)
						std::cerr << "ERROR: Invalid value " << ldvalue << " is less than datatype min " << ldmin << ".\n";
					return false;
				}

				if (ldvalue > ldmax) {
					if (!quiet)
						std::cerr << "ERROR: Invalid value " << ldvalue << " is greater than datatype max " << ldmax << ".\n";
					return false;
				}
			} break;
			case NOTYPE: default: break;
			}
		}
		else {
			if (op == IN) {
				int i = 0;
				if (insensitive) {
					std::string valueAsStringLower(*valueAsString);
					ToLowerASCII(valueAsStringLower);
					for (; i < size; ++i) {
						if (valueAsStringLower.compare(t[i]->c_str()) == 0)
							return true;
					}
				}
				else {
					for (; i < size; ++i) {
						if (valueAsString->compare(t[i]->c_str()) == 0)
							return true;
					}
				}
				return false;
			}
		}

		// Only check datatype limits, and return;
		if (op == NOOP) return true;

#define VALIDATE(T, U, LIST) { \
  /* Value string converted to true native type. */ \
  std::stringstream ss(valueAsString->c_str());\
  U v;\
  ss >> v;\
  /* Check if within list. */ \
  if (op == IN) { \
    T * last = LIST + size;\
    return (last != std::find(LIST, last, v)); \
  } \
  \
  /* Check if within user's custom range. */ \
  T v0, v1; \
  if (size > 0) { \
    v0 = LIST[0]; \
  } \
  \
  if (size > 1) { \
    v1 = LIST[1]; \
  } \
  \
  switch (op) {\
    case LT:\
      if (size > 0) {\
        return v < v0;\
      } else {\
        std::cerr << "ERROR: No value given to validate if " << v << " < X.\n";\
        return false;\
      }\
      break;\
    case LE:\
      if (size > 0) {\
        return v <= v0;\
      } else {\
        std::cerr << "ERROR: No value given to validate if " << v << " <= X.\n";\
        return false;\
      }\
      break;\
    case GT:\
      if (size > 0) {\
        return v > v0;\
      } else {\
        std::cerr << "ERROR: No value given to validate if " << v << " > X.\n";\
        return false;\
      }\
      break;\
    case GE:\
      if (size > 0) {\
        return v >= v0;\
      } else {\
        std::cerr << "ERROR: No value given to validate if " << v << " >= X.\n";\
        return false;\
      }\
      break;\
    case GTLT:\
      if (size > 1) {\
        return (v0 < v) && (v < v1);\
      } else {\
        std::cerr << "ERROR: Missing values to validate if X1 < " << v << " < X2.\n";\
        return false;\
      }\
      break;\
    case GELT:\
      if (size > 1) {\
        return (v0 <= v) && (v < v1);\
      } else {\
        std::cerr << "ERROR: Missing values to validate if X1 <= " << v << " < X2.\n";\
        return false;\
      }\
      break;\
    case GELE:\
      if (size > 1) {\
        return (v0 <= v) && (v <= v1);\
      } else {\
        std::cerr << "ERROR: Missing values to validate if X1 <= " << v << " <= X2.\n";\
        return false;\
      }\
      break;\
    case GTLE:\
      if (size > 1) {\
        return (v0 < v) && (v <= v1);\
      } else {\
        std::cerr << "ERROR: Missing values to validate if X1 < " << v << " <= X2.\n";\
        return false;\
      }\
      break;\
      case NOOP: case IN: default: break;\
  } \
  }

		switch (type) {
		case U1: VALIDATE(unsigned char, int, u1); break;
		case S1: VALIDATE(char, int, s1); break;
		case U2: VALIDATE(unsigned short, int, u2); break;
		case S2: VALIDATE(short, int, s2); break;
		case U4: VALIDATE(unsigned int, unsigned int, u4); break;
		case S4: VALIDATE(int, int, s4); break;
		case U8: VALIDATE(unsigned long long, unsigned long long, u8); break;
		case S8: VALIDATE(long long, long long, s8); break;
		case F: VALIDATE(float, float, f); break;
		case D: VALIDATE(double, double, d); break;
		default: break;
		}

		return true;
	};
	/* ################################################################### */
	class OptionGroup {
	public:
		OptionGroup() : delim(0), expectArgs(0), isRequired(false), isSet(false) { }

		~OptionGroup() {
			int i;
			for (i = 0; i < (long int)flags.size(); ++i)
				delete flags[i];

			flags.clear();
			parseIndex.clear();
			clearArgs();
		};

		inline void clearArgs();
		inline void getInt(int&);
		inline void getLong(long&);
		inline void getLongLong(long long&);
		inline void getULong(unsigned long&);
		inline void getULongLong(unsigned long long&);
		inline void getFloat(float&);
		inline void getDouble(double&);
		inline void getString(std::string&);
		inline void getInts(std::vector<int>&);
		inline void getLongs(std::vector<long>&);
		inline void getULongs(std::vector<unsigned long>&);
		inline void getFloats(std::vector<float>&);
		inline void getDoubles(std::vector<double>&);
		inline void getStrings(std::vector<std::string>&);
		inline void getMultiInts(std::vector< std::vector<int> >&);
		inline void getMultiLongs(std::vector< std::vector<long> >&);
		inline void getMultiULongs(std::vector< std::vector<unsigned long> >&);
		inline void getMultiFloats(std::vector< std::vector<float> >&);
		inline void getMultiDoubles(std::vector< std::vector<double> >&);
		inline void getMultiStrings(std::vector< std::vector<std::string> >&);

		// defaults value regardless of being set by user.
		std::string defaults;
		// If expects arguments, this will delimit arg list.
		char delim;
		// If not 0, then number of delimited args. -1 for arbitrary number.
		int expectArgs;
		// Descriptive help message shown in usage instructions for option.
		std::string help;
		// 0 or 1.
		bool isRequired;
		// A list of flags that denote this option, i.e. -d, --dimension.
		std::vector< std::string* > flags;
		// If was set (or found).
		bool isSet;
		// Lists of arguments, per flag instance, after splitting by delimiter.
		std::vector< std::vector< std::string* > * > args;
		// Index where each group was parsed from input stream to track order.
		std::vector<int> parseIndex;
	};
	/* ################################################################### */
	void OptionGroup::clearArgs() {
		int i, j;
		for (i = 0; i < (long int)args.size(); ++i) {
			for (j = 0; j < (long int)args[i]->size(); ++j)
				delete args[i]->at(j);

			delete args[i];
		}

		args.clear();
		isSet = false;
	};
	/* ################################################################### */
	void OptionGroup::getInt(int & out) {
		if (!isSet) {
			if (defaults.empty())
				out = 0;
			else
				out = atoi(defaults.c_str());
		}
		else {
			if (args.empty() || args[0]->empty())
				out = 0;
			else {
				out = atoi(args[0]->at(0)->c_str());
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getLong(long & out) {
		if (!isSet) {
			if (defaults.empty())
				out = 0;
			else
				out = atoi(defaults.c_str());
		}
		else {
			if (args.empty() || args[0]->empty())
				out = 0;
			else {
				out = atol(args[0]->at(0)->c_str());
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getLongLong(long long & out) {
		if (!isSet) {
			if (defaults.empty())
				out = 0;
			else {
				std::stringstream ss(defaults.c_str());
				ss >> out;
			}
		}
		else {
			if (args.empty() || args[0]->empty())
				out = 0;
			else {
				std::stringstream ss(args[0]->at(0)->c_str());
				ss >> out;
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getULong(unsigned long & out) {
		if (!isSet) {
			if (defaults.empty())
				out = 0;
			else
				out = atoi(defaults.c_str());
		}
		else {
			if (args.empty() || args[0]->empty())
				out = 0;
			else {
				out = strtoul(args[0]->at(0)->c_str(), 0, 0);
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getULongLong(unsigned long long & out) {
		if (!isSet) {
			if (defaults.empty())
				out = 0;
			else {
				std::stringstream ss(defaults.c_str());
				ss >> out;
			}
		}
		else {
			if (args.empty() || args[0]->empty())
				out = 0;
			else {
				std::stringstream ss(args[0]->at(0)->c_str());
				ss >> out;
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getFloat(float & out) {
		if (!isSet) {
			if (defaults.empty())
				out = 0.0;
			else
				out = (float)atof(defaults.c_str());
		}
		else {
			if (args.empty() || args[0]->empty())
				out = 0.0;
			else {
				out = (float)atof(args[0]->at(0)->c_str());
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getDouble(double & out) {
		if (!isSet) {
			if (defaults.empty())
				out = 0.0;
			else
				out = atof(defaults.c_str());
		}
		else {
			if (args.empty() || args[0]->empty())
				out = 0.0;
			else {
				out = atof(args[0]->at(0)->c_str());
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getString(std::string & out) {
		if (!isSet) {
			out = defaults;
		}
		else {
			if (args.empty() || args[0]->empty())
				out = "";
			else {
				out = *args[0]->at(0);
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getInts(std::vector<int> & out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				StringsToInts(strings, out);
			}
		}
		else {
			if (!(args.empty() || args[0]->empty()))
				StringsToInts(args[0], &out);
		}
	};
	/* ################################################################### */
	void OptionGroup::getLongs(std::vector<long> & out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				StringsToLongs(strings, out);
			}
		}
		else {
			if (!(args.empty() || args[0]->empty()))
				StringsToLongs(args[0], &out);
		}
	};
	/* ################################################################### */
	void OptionGroup::getULongs(std::vector<unsigned long> & out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				StringsToULongs(strings, out);
			}
		}
		else {
			if (!(args.empty() || args[0]->empty()))
				StringsToULongs(args[0], &out);
		}
	};
	/* ################################################################### */
	void OptionGroup::getFloats(std::vector<float> & out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				StringsToFloats(strings, out);
			}
		}
		else {
			if (!(args.empty() || args[0]->empty()))
				StringsToFloats(args[0], &out);
		}
	};
	/* ################################################################### */
	void OptionGroup::getDoubles(std::vector<double> & out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				StringsToDoubles(strings, out);
			}
		}
		else {
			if (!(args.empty() || args[0]->empty()))
				StringsToDoubles(args[0], &out);
		}
	};
	/* ################################################################### */
	void OptionGroup::getStrings(std::vector<std::string>& out) {
		if (!isSet) {
			if (!defaults.empty()) {
				SplitDelim(defaults, delim, out);
			}
		}
		else {
			if (!(args.empty() || args[0]->empty()))
				StringsToStrings(args[0], &out);
		}
	};
	/* ################################################################### */
	void OptionGroup::getMultiInts(std::vector< std::vector<int> >& out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				if (out.size() < 1) out.resize(1);
				StringsToInts(strings, out[0]);
			}
		}
		else {
			if (!args.empty()) {
				int n = args.size();
				if ((long int)out.size() < n) out.resize(n);
				for (int i = 0; i < n; ++i) {
					StringsToInts(args[i], &out[i]);
				}
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getMultiLongs(std::vector< std::vector<long> >& out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				if (out.size() < 1) out.resize(1);
				StringsToLongs(strings, out[0]);
			}
		}
		else {
			if (!args.empty()) {
				int n = args.size();
				if ((long int)out.size() < n) out.resize(n);
				for (int i = 0; i < n; ++i) {
					StringsToLongs(args[i], &out[i]);
				}
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getMultiULongs(std::vector< std::vector<unsigned long> >& out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				if (out.size() < 1) out.resize(1);
				StringsToULongs(strings, out[0]);
			}
		}
		else {
			if (!args.empty()) {
				int n = args.size();
				if ((long int)out.size() < n) out.resize(n);
				for (int i = 0; i < n; ++i) {
					StringsToULongs(args[i], &out[i]);
				}
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getMultiFloats(std::vector< std::vector<float> >& out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				if (out.size() < 1) out.resize(1);
				StringsToFloats(strings, out[0]);
			}
		}
		else {
			if (!args.empty()) {
				int n = args.size();
				if ((long int)out.size() < n) out.resize(n);
				for (int i = 0; i < n; ++i) {
					StringsToFloats(args[i], &out[i]);
				}
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getMultiDoubles(std::vector< std::vector<double> >& out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				if (out.size() < 1) out.resize(1);
				StringsToDoubles(strings, out[0]);
			}
		}
		else {
			if (!args.empty()) {
				int n = args.size();
				if ((long int)out.size() < n) out.resize(n);
				for (int i = 0; i < n; ++i) {
					StringsToDoubles(args[i], &out[i]);
				}
			}
		}
	};
	/* ################################################################### */
	void OptionGroup::getMultiStrings(std::vector< std::vector<std::string> >& out) {
		if (!isSet) {
			if (!defaults.empty()) {
				std::vector< std::string > strings;
				SplitDelim(defaults, delim, strings);
				if (out.size() < 1) out.resize(1);
				out[0] = strings;
			}
		}
		else {
			if (!args.empty()) {
				int n = args.size();
				if ((long int)out.size() < n) out.resize(n);

				for (int i = 0; i < n; ++i) {
					for (int j = 0; j < (long int)args[i]->size(); ++j)
						out[i].push_back(*args[i]->at(j));
				}
			}
		}
	};
	/* ################################################################### */
	typedef std::map< int, ezOptionValidator* > ValidatorMap;

	class ezOptionParser {
	public:
		// How to layout usage descriptions with the option flags.
		enum Layout { ALIGN, INTERLEAVE, STAGGER };

		inline ~ezOptionParser();

		inline void add(const char * defaults, bool required, int expectArgs, char delim, const char * help, const char * flag1, ezOptionValidator* validator = 0);
		inline void add(const char * defaults, bool required, int expectArgs, char delim, const char * help, const char * flag1, const char * flag2, ezOptionValidator* validator = 0);
		inline void add(const char * defaults, bool required, int expectArgs, char delim, const char * help, const char * flag1, const char * flag2, const char * flag3, ezOptionValidator* validator = 0);
		inline void add(const char * defaults, bool required, int expectArgs, char delim, const char * help, const char * flag1, const char * flag2, const char * flag3, const char * flag4, ezOptionValidator* validator = 0);
		inline bool exportFile(const char * filename, bool all = false);
		inline OptionGroup * get(const char * name);
		inline void getUsage(std::string & usage, int width = 80, Layout layout = ALIGN);
		inline void getUsageDescriptions(std::string & usage, int width = 80, Layout layout = STAGGER);
		inline bool gotExpected(std::vector<std::string> & badOptions);
		inline bool gotRequired(std::vector<std::string> & badOptions);
		inline bool gotValid(std::vector<std::string> & badOptions, std::vector<std::string> & badArgs);
		inline bool importFile(const char * filename, char comment = '#');
		inline int isSet(const char * name);
		inline int isSet(std::string & name);
		inline void parse(int argc, const char * argv[]);
		inline void prettyPrint(std::string & out);
		inline void reset();
		inline void resetArgs();

		// Insert extra empty line betwee each option's usage description.
		char doublespace;
		// General description in human language on what the user's tool does.
		// It's the first section to get printed in the full usage message.
		std::string overview;
		// A synopsis of command and options usage to show expected order of input arguments.
		// It's the second section to get printed in the full usage message.
		std::string syntax;
		// Example (third) section in usage message.
		std::string example;
		// Final section printed in usage message. For contact, copyrights, version info.
		std::string footer;
		// Map from an option to an Id of its parent group.
		std::map< std::string, int > optionGroupIds;
		// Unordered collection of the option groups.
		std::vector< OptionGroup* > groups;
		// Store unexpected args in input.
		std::vector< std::string* > unknownArgs;
		// List of args that occur left-most before first option flag.
		std::vector< std::string* > firstArgs;
		// List of args that occur after last right-most option flag and its args.
		std::vector< std::string* > lastArgs;
		// List of validators.
		ValidatorMap validators;
		// Maps group id to a validator index into vector of validators. Validator index is -1 if there is no validator for group.
		std::map< int, int > groupValidators;
	};
	/* ################################################################### */
	ezOptionParser::~ezOptionParser() {
		reset();
	}
	/* ################################################################### */
	void ezOptionParser::reset() {
		this->doublespace = 1;

		int i;
		for (i = 0; i < (long int)groups.size(); ++i)
			delete groups[i];
		groups.clear();

		for (i = 0; i < (long int)unknownArgs.size(); ++i)
			delete unknownArgs[i];
		unknownArgs.clear();

		for (i = 0; i < (long int)firstArgs.size(); ++i)
			delete firstArgs[i];
		firstArgs.clear();

		for (i = 0; i < (long int)lastArgs.size(); ++i)
			delete lastArgs[i];
		lastArgs.clear();

		ValidatorMap::iterator it;
		for (it = validators.begin(); it != validators.end(); ++it)
			delete it->second;

		validators.clear();
		optionGroupIds.clear();
		groupValidators.clear();
	};
	/* ################################################################### */
	void ezOptionParser::resetArgs() {
		int i;
		for (i = 0; i < (long int)groups.size(); ++i)
			groups[i]->clearArgs();

		for (i = 0; i < (long int)unknownArgs.size(); ++i)
			delete unknownArgs[i];
		unknownArgs.clear();

		for (i = 0; i < (long int)firstArgs.size(); ++i)
			delete firstArgs[i];
		firstArgs.clear();

		for (i = 0; i < (long int)lastArgs.size(); ++i)
			delete lastArgs[i];
		lastArgs.clear();
	};
	/* ################################################################### */
	void ezOptionParser::add(const char * defaults, bool required, int expectArgs, char delim, const char * help, const char * flag1, ezOptionValidator* validator) {
		int id = this->groups.size();
		OptionGroup * g = new OptionGroup;
		g->defaults = defaults;
		g->isRequired = required;
		g->expectArgs = expectArgs;
		g->delim = delim;
		g->isSet = 0;
		g->help = help;
		std::string *f1 = new std::string(flag1);
		g->flags.push_back(f1);
		this->optionGroupIds[flag1] = id;
		this->groups.push_back(g);

		if (validator) {
			int vid = validator->id;
			validators[vid] = validator;
			groupValidators[id] = vid;
		}
		else {
			groupValidators[id] = -1;
		}
	};
	/* ################################################################### */
	void ezOptionParser::add(const char * defaults, bool required, int expectArgs, char delim, const char * help, const char * flag1, const char * flag2, ezOptionValidator* validator) {
		int id = this->groups.size();
		OptionGroup * g = new OptionGroup;
		g->defaults = defaults;
		g->isRequired = required;
		g->expectArgs = expectArgs;
		g->delim = delim;
		g->isSet = 0;
		g->help = help;
		std::string *f1 = new std::string(flag1);
		g->flags.push_back(f1);
		std::string *f2 = new std::string(flag2);
		g->flags.push_back(f2);
		this->optionGroupIds[flag1] = id;
		this->optionGroupIds[flag2] = id;

		this->groups.push_back(g);

		if (validator) {
			int vid = validator->id;
			validators[vid] = validator;
			groupValidators[id] = vid;
		}
		else {
			groupValidators[id] = -1;
		}
	};
	/* ################################################################### */
	void ezOptionParser::add(const char * defaults, bool required, int expectArgs, char delim, const char * help, const char * flag1, const char * flag2, const char * flag3, ezOptionValidator* validator) {
		int id = this->groups.size();
		OptionGroup * g = new OptionGroup;
		g->defaults = defaults;
		g->isRequired = required;
		g->expectArgs = expectArgs;
		g->delim = delim;
		g->isSet = 0;
		g->help = help;
		std::string *f1 = new std::string(flag1);
		g->flags.push_back(f1);
		std::string *f2 = new std::string(flag2);
		g->flags.push_back(f2);
		std::string *f3 = new std::string(flag3);
		g->flags.push_back(f3);
		this->optionGroupIds[flag1] = id;
		this->optionGroupIds[flag2] = id;
		this->optionGroupIds[flag3] = id;

		this->groups.push_back(g);

		if (validator) {
			int vid = validator->id;
			validators[vid] = validator;
			groupValidators[id] = vid;
		}
		else {
			groupValidators[id] = -1;
		}
	};
	/* ################################################################### */
	void ezOptionParser::add(const char * defaults, bool required, int expectArgs, char delim, const char * help, const char * flag1, const char * flag2, const char * flag3, const char * flag4, ezOptionValidator* validator) {
		int id = this->groups.size();
		OptionGroup * g = new OptionGroup;
		g->defaults = defaults;
		g->isRequired = required;
		g->expectArgs = expectArgs;
		g->delim = delim;
		g->isSet = 0;
		g->help = help;
		std::string *f1 = new std::string(flag1);
		g->flags.push_back(f1);
		std::string *f2 = new std::string(flag2);
		g->flags.push_back(f2);
		std::string *f3 = new std::string(flag3);
		g->flags.push_back(f3);
		std::string *f4 = new std::string(flag4);
		g->flags.push_back(f4);
		this->optionGroupIds[flag1] = id;
		this->optionGroupIds[flag2] = id;
		this->optionGroupIds[flag3] = id;
		this->optionGroupIds[flag4] = id;

		this->groups.push_back(g);

		if (validator) {
			int vid = validator->id;
			validators[vid] = validator;
			groupValidators[id] = vid;
		}
		else {
			groupValidators[id] = -1;
		}
	};
	/* ################################################################### */
	bool ezOptionParser::exportFile(const char * filename, bool all) {
		int i;
		std::string out;
		bool quote;

		// Export the first args, except the program name, so start from 1.
		for (i = 1; i < (long int)firstArgs.size(); ++i) {
			quote = ((firstArgs[i]->find_first_of(" \t") != std::string::npos) && (firstArgs[i]->find_first_of("\'\"") == std::string::npos));

			if (quote)
				out.append("\"");

			out.append(*firstArgs[i]);
			if (quote)
				out.append("\"");

			out.append(" ");
		}

		if (firstArgs.size() > 1)
			out.append("\n");

		std::vector<std::string* > stringPtrs(groups.size());
		int m;
		int n = groups.size();
		for (i = 0; i < n; ++i) {
			stringPtrs[i] = groups[i]->flags[0];
		}

		OptionGroup *g;
		// Sort first flag of each group with other groups.
		std::sort(stringPtrs.begin(), stringPtrs.end(), CmpOptStringPtr);
		for (i = 0; i < n; ++i) {
			g = get(stringPtrs[i]->c_str());
			if (g->isSet || all) {
				if (!g->isSet || g->args.empty()) {
					if (!g->defaults.empty()) {
						out.append(*stringPtrs[i]);
						out.append(" ");
						quote = ((g->defaults.find_first_of(" \t") != std::string::npos) && (g->defaults.find_first_of("\'\"") == std::string::npos));
						if (quote)
							out.append("\"");

						out.append(g->defaults);
						if (quote)
							out.append("\"");

						out.append("\n");
					}
				}
				else {
					int n = g->args.size();
					for (int j = 0; j < n; ++j) {
						out.append(*stringPtrs[i]);
						out.append(" ");
						m = g->args[j]->size();

						for (int k = 0; k < m; ++k) {
							quote = ((*g->args[j]->at(k)).find_first_of(" \t") != std::string::npos);
							if (quote)
								out.append("\"");

							out.append(*g->args[j]->at(k));
							if (quote)
								out.append("\"");

							if ((g->delim) && ((k + 1) != m))
								out.append(1, g->delim);
						}
						out.append("\n");
					}
				}
			}
		}

		// Export the last args.
		for (i = 0; i < (long int)lastArgs.size(); ++i) {
			quote = (lastArgs[i]->find_first_of(" \t") != std::string::npos);
			if (quote)
				out.append("\"");

			out.append(*lastArgs[i]);
			if (quote)
				out.append("\"");

			out.append(" ");
		}

		std::ofstream file(filename);
		if (!file.is_open())
			return false;

		file << out;
		file.close();

		return true;
	};
	/* ################################################################### */
	// Does not overwrite current options.
	// Returns true if file was read successfully.
	// So if this is used before parsing CLI, then option values will reflect
	// this file, but if used after parsing CLI, then values will contain
	// both CLI values and file's values.
	//
	// Comment lines are allowed if prefixed with #.
	// Strings should be quoted as usual.
	bool ezOptionParser::importFile(const char * filename, char comment) {
		std::ifstream file(filename, std::ios::in | std::ios::ate);
		if (!file.is_open())
			return false;

		// Read entire file contents.
		std::ifstream::pos_type size = file.tellg();
		char * memblock = new char[(int)size + 1]; // Add one for end of string.
		file.seekg(0, std::ios::beg);
		file.read(memblock, size);
		memblock[(int)size] = '\0';
		file.close();

		// Find comment lines.
		std::list<std::string*> lines;
		std::string memblockstring(memblock);
		delete[] memblock;
		SplitDelim(memblockstring, '\n', lines);
		int i, j, n;
		std::list<std::string*>::iterator iter;
		std::vector<int> sq, dq; // Single and double quote indices.
		std::vector<int>::iterator lo; // For searching quote indices.
		size_t pos;
		const char *str;
		std::string *line;
		// Find all single and double quotes to correctly handle comment tokens.
		for (iter = lines.begin(); iter != lines.end(); ++iter) {
			line = *iter;
			str = line->c_str();
			n = line->size();
			sq.clear();
			dq.clear();
			if (n) {
				// If first char is comment, then erase line and continue.
				pos = line->find_first_not_of(" \t\r");
				if ((pos == std::string::npos) || (line->at(pos) == comment)) {
					line->erase();
					continue;
				}
				else {
					// Erase whitespace prefix.
					line->erase(0, pos);
					n = line->size();
				}

				if (line->at(0) == '"')
					dq.push_back(0);

				if (line->at(0) == '\'')
					sq.push_back(0);
			}
			else { // Empty line.
				continue;
			}

			for (i = 1; i < n; ++i) {
				if ((str[i] == '"') && (str[i - 1] != '\\'))
					dq.push_back(i);
				else if ((str[i] == '\'') && (str[i - 1] != '\\'))
					sq.push_back(i);
			}
			// Scan for comments, and when found, check bounds of quotes.
			// Start with second char because already checked first char.
			for (i = 1; i < n; ++i) {
				if ((line->at(i) == comment) && (line->at(i - 1) != '\\')) {
					// If within open/close quote pair, then not real comment.
					if (sq.size()) {
						lo = std::lower_bound(sq.begin(), sq.end(), i);
						// All start of strings will be even indices, closing quotes is odd indices.
						j = (int)(lo - sq.begin());
						if ((j % 2) == 0) { // Even implies comment char not in quote pair.
											// Erase from comment char to end of line.
							line->erase(i);
							break;
						}
					}
					else if (dq.size()) {
						// Repeat tests for double quotes.
						lo = std::lower_bound(dq.begin(), dq.end(), i);
						j = (int)(lo - dq.begin());
						if ((j % 2) == 0) {
							line->erase(i);
							break;
						}
					}
					else {
						// Not in quotes.
						line->erase(i);
						break;
					}
				}
			}
		}

		std::string cmd;
		// Convert list to string without newlines to simulate commandline.
		for (iter = lines.begin(); iter != lines.end(); ++iter) {
			if (!(*iter)->empty()) {
				cmd.append(**iter);
				cmd.append(" ");
			}
		}

		// Now parse as if from command line. 
		int argc = 0;
		char** argv = CommandLineToArgvA((char*)cmd.c_str(), &argc);

		// Parse.
		parse(argc, (const char**)argv);
		if (argv) free(argv);
		for (iter = lines.begin(); iter != lines.end(); ++iter)
			delete *iter;

		return true;
	};
	/* ################################################################### */
	int ezOptionParser::isSet(const char * name) {
		std::string sname(name);

		if (this->optionGroupIds.count(sname)) {
			return this->groups[this->optionGroupIds[sname]]->isSet;
		}

		return 0;
	};
	/* ################################################################### */
	int ezOptionParser::isSet(std::string & name) {
		if (this->optionGroupIds.count(name)) {
			return this->groups[this->optionGroupIds[name]]->isSet;
		}

		return 0;
	};
	/* ################################################################### */
	OptionGroup * ezOptionParser::get(const char * name) {
		if (optionGroupIds.count(name)) {
			return groups[optionGroupIds[name]];
		}

		return 0;
	};
	/* ################################################################### */
	void ezOptionParser::getUsage(std::string & usage, int width, Layout layout) {

		usage.append(overview);
		usage.append("\n\n");
		usage.append("USAGE: ");
		usage.append(syntax);
		usage.append("\n\nOPTIONS:\n");
		getUsageDescriptions(usage, width, layout);

		if (!example.empty()) {
			usage.append("\n\nEXAMPLES:\n");
			usage.append(example);
		}

		if (!footer.empty()) {
			usage.append(footer);
		}
	};
	/* ################################################################### */
	// Creates 2 column formatted help descriptions for each option flag.
	void ezOptionParser::getUsageDescriptions(std::string & usage, int width, Layout layout) {
		// Sort each flag list amongst each group.
		int i;
		// Store index of flag groups before sort for easy lookup later.
		std::map<std::string*, int> stringPtrToIndexMap;
		std::vector<std::string* > stringPtrs(groups.size());

		for (i = 0; i < (long int)groups.size(); ++i) {
			std::sort(groups[i]->flags.begin(), groups[i]->flags.end(), CmpOptStringPtr);
			stringPtrToIndexMap[groups[i]->flags[0]] = i;
			stringPtrs[i] = groups[i]->flags[0];
		}

		size_t j, k;
		std::string opts;
		std::vector<std::string> sortedOpts;
		// Sort first flag of each group with other groups.
		std::sort(stringPtrs.begin(), stringPtrs.end(), CmpOptStringPtr);
		for (i = 0; i < (long int)groups.size(); ++i) {
			//printf("DEBUG:%d: %d %d %s\n", __LINE__, i, stringPtrToIndexMap[stringPtrs[i]], stringPtrs[i]->c_str());
			k = stringPtrToIndexMap[stringPtrs[i]];
			opts.clear();
			for (j = 0; j < groups[k]->flags.size() - 1; ++j) {
				opts.append(*groups[k]->flags[j]);
				opts.append(", ");

				if ((long int)opts.size() > width)
					opts.append("\n");
			}
			// The last flag. No need to append comma anymore.
			opts.append(*groups[k]->flags[j]);

			if (groups[k]->expectArgs) {
				opts.append(" ARG");

				if (groups[k]->delim) {
					opts.append("1[");
					opts.append(1, groups[k]->delim);
					opts.append("ARGn]");
				}
			}

			sortedOpts.push_back(opts);
		}

		// Each option group will use this to build multiline help description.
		std::list<std::string*> desc;
		// Number of whitespaces from start of line to description (interleave layout) or
		// gap between flag names and description (align, stagger layouts).
		int gutter = 3;

		// Find longest opt flag string to set column start for help usage descriptions.
		int maxlen = 0;
		if (layout == ALIGN) {
			for (i = 0; i < (long int)groups.size(); ++i) {
				if (maxlen < (long int)sortedOpts[i].size())
					maxlen = sortedOpts[i].size();
			}
		}

		// The amount of space remaining on a line for help text after flags.
		int helpwidth;
		std::list<std::string*>::iterator cIter, insertionIter;
		size_t pos;
		for (i = 0; i < (long int)groups.size(); ++i) {
			k = stringPtrToIndexMap[stringPtrs[i]];

			if (layout == STAGGER)
				maxlen = sortedOpts[i].size();

			int pad = gutter + maxlen;
			helpwidth = width - pad;

			// All the following split-fu could be optimized by just using substring (offset, length) tuples, but just to get it done, we'll do some not-too expensive string copying.
			SplitDelim(groups[k]->help, '\n', desc);
			// Split lines longer than allowable help width.

			for (insertionIter = desc.begin(), cIter = insertionIter++;
				cIter != desc.end();
				cIter = (insertionIter == desc.end()) ? insertionIter : (insertionIter++)) {
				if ((long int)((*cIter)->size()) > helpwidth) {
					// Get pointer to next string to insert new strings before it.
					std::string *rem = *cIter;
					// Remove this line and add back in pieces.
					desc.erase(cIter);
					// Loop until remaining string is short enough.
					while ((long int)rem->size() > helpwidth) {
						// Find whitespace to split before helpwidth.
						if (rem->at(helpwidth) == ' ') {
							// If word ends exactly at helpwidth, then split after it.
							pos = helpwidth;
						}
						else {
							// Otherwise, split occurs midword, so find whitespace before this word.
							pos = rem->rfind(" ", helpwidth);
						}
						// Insert split string.
						desc.insert(insertionIter, new std::string(*rem, 0, pos));
						// Now skip any whitespace to start new line.
						pos = rem->find_first_not_of(' ', pos);
						rem->erase(0, pos);
					}

					if (rem->size())
						desc.insert(insertionIter, rem);
					else
						delete rem;
				}
			}

			usage.append(sortedOpts[i]);
			if (layout != INTERLEAVE)
				// Add whitespace between option names and description.
				usage.append(pad - sortedOpts[i].size(), ' ');
			else {
				usage.append("\n");
				usage.append(gutter, ' ');
			}

			if (desc.size() > 0) { // Crash fix by Bruce Shankle.
								   // First line already padded above (before calling SplitDelim) after option flag names.
				cIter = desc.begin();
				usage.append(**cIter);
				usage.append("\n");
				// Now inject the pad for each line.
				for (++cIter; cIter != desc.end(); ++cIter) {
					usage.append(pad, ' ');
					usage.append(**cIter);
					usage.append("\n");
				}

				if (this->doublespace) usage.append("\n");

				for (cIter = desc.begin(); cIter != desc.end(); ++cIter)
					delete *cIter;

				desc.clear();
			}

		}
	};
	/* ################################################################### */
	bool ezOptionParser::gotExpected(std::vector<std::string> & badOptions) {
		int i, j;

		for (i = 0; i < (long int)groups.size(); ++i) {
			OptionGroup *g = groups[i];
			// If was set, ensure number of args is correct.
			if (g->isSet) {
				if ((g->expectArgs != 0) && g->args.empty()) {
					badOptions.push_back(*g->flags[0]);
					continue;
				}

				for (j = 0; j < (long int)g->args.size(); ++j) {
					if ((g->expectArgs != -1) && (g->expectArgs != (long int)g->args[j]->size()))
						badOptions.push_back(*g->flags[0]);
				}
			}
		}

		return badOptions.empty();
	};
	/* ################################################################### */
	bool ezOptionParser::gotRequired(std::vector<std::string> & badOptions) {
		int i;

		for (i = 0; i < (long int)groups.size(); ++i) {
			OptionGroup *g = groups[i];
			// Simple case when required but user never set it.
			if (g->isRequired && (!g->isSet)) {
				badOptions.push_back(*g->flags[0]);
				continue;
			}
		}

		return badOptions.empty();
	};
	/* ################################################################### */
	bool ezOptionParser::gotValid(std::vector<std::string> & badOptions, std::vector<std::string> & badArgs) {
		int groupid, validatorid;
		std::map< int, int >::iterator it;

		for (it = groupValidators.begin(); it != groupValidators.end(); ++it) {
			groupid = it->first;
			validatorid = it->second;
			if (validatorid < 0) continue;

			OptionGroup *g = groups[groupid];
			ezOptionValidator *v = validators[validatorid];
			bool nextgroup = false;

			for (int i = 0; i < (long int)g->args.size(); ++i) {
				if (nextgroup) break;
				std::vector< std::string* > * args = g->args[i];
				for (int j = 0; j < (long int)args->size(); ++j) {
					if (!v->isValid(args->at(j))) {
						badOptions.push_back(*g->flags[0]);
						badArgs.push_back(*args->at(j));
						nextgroup = true;
						break;
					}
				}
			}
		}

		return badOptions.empty();
	};
	/* ################################################################### */
	void ezOptionParser::parse(int argc, const char * argv[]) {
		if (argc < 1) return;

		/*
		std::map<std::string,int>::iterator it;
		for ( it=optionGroupIds.begin() ; it != optionGroupIds.end(); it++ )
		std::cout << (*it).first << " => " << (*it).second << std::endl;
		*/

		int i, k, firstOptIndex = 0, lastOptIndex = 0;
		std::string s;
		OptionGroup *g;

		for (i = 0; i < argc; ++i) {
			s = argv[i];

			if (optionGroupIds.count(s))
				break;
		}

		firstOptIndex = i;

		if (firstOptIndex == argc) {
			// No flags encountered, so set last args.
			this->firstArgs.push_back(new std::string(argv[0]));

			for (k = 1; k < argc; ++k)
				this->lastArgs.push_back(new std::string(argv[k]));

			return;
		}

		// Store initial args before opts appear.
		for (k = 0; k < i; ++k) {
			this->firstArgs.push_back(new std::string(argv[k]));
		}

		for (; i < argc; ++i) {
			s = argv[i];

			if (optionGroupIds.count(s)) {
				k = optionGroupIds[s];
				g = groups[k];
				g->isSet = 1;
				g->parseIndex.push_back(i);

				if (g->expectArgs) {
					// Read ahead to get args.
					++i;
					if (i >= argc) return;
					g->args.push_back(new std::vector<std::string*>);
					SplitDelim(argv[i], g->delim, g->args.back());
				}
				lastOptIndex = i;
			}
		}

		// Scan for unknown opts/arguments.
		for (i = firstOptIndex; i <= lastOptIndex; ++i) {
			s = argv[i];

			if (optionGroupIds.count(s)) {
				k = optionGroupIds[s];
				g = groups[k];
				if (g->expectArgs) {
					// Read ahead for args and skip them.
					++i;
				}
			}
			else {
				unknownArgs.push_back(new std::string(argv[i]));
			}
		}

		if (lastOptIndex >= (argc - 1)) return;

		// Store final args without flags.
		for (k = lastOptIndex + 1; k < argc; ++k) {
			this->lastArgs.push_back(new std::string(argv[k]));
		}
	};
	/* ################################################################### */
	void ezOptionParser::prettyPrint(std::string & out) {
		char tmp[256];
		int i, j, k;

		out += "First Args:\n";
		for (i = 0; i < (long int)firstArgs.size(); ++i) {
			SPRINTF(tmp, "%d: %s\n", i + 1, firstArgs[i]->c_str());
			out += tmp;
		}

		// Sort the option flag names.
		int n = groups.size();
		std::vector<std::string* > stringPtrs(n);
		for (i = 0; i < n; ++i) {
			stringPtrs[i] = groups[i]->flags[0];
		}

		// Sort first flag of each group with other groups.
		std::sort(stringPtrs.begin(), stringPtrs.end(), CmpOptStringPtr);

		out += "\nOptions:\n";
		OptionGroup *g;
		for (i = 0; i < n; ++i) {
			g = get(stringPtrs[i]->c_str());
			out += "\n";
			// The flag names:
			for (j = 0; j < (long int)g->flags.size() - 1; ++j) {
				SPRINTF(tmp, "%s, ", g->flags[j]->c_str());
				out += tmp;
			}
			SPRINTF(tmp, "%s:\n", g->flags.back()->c_str());
			out += tmp;

			if (g->isSet) {
				if (g->expectArgs) {
					if (g->args.empty()) {
						SPRINTF(tmp, "%s (default)\n", g->defaults.c_str());
						out += tmp;
					}
					else {
						for (k = 0; k < (long int)g->args.size(); ++k) {
							for (j = 0; j < (long int)g->args[k]->size() - 1; ++j) {
								SPRINTF(tmp, "%s%c", g->args[k]->at(j)->c_str(), g->delim);
								out += tmp;
							}
							SPRINTF(tmp, "%s\n", g->args[k]->back()->c_str());
							out += tmp;
						}
					}
				}
				else { // Set but no args expected.
					SPRINTF(tmp, "Set\n");
					out += tmp;
				}
			}
			else {
				SPRINTF(tmp, "Not set\n");
				out += tmp;
			}
		}

		out += "\nLast Args:\n";
		for (i = 0; i < (long int)lastArgs.size(); ++i) {
			SPRINTF(tmp, "%d: %s\n", i + 1, lastArgs[i]->c_str());
			out += tmp;
		}

		out += "\nUnknown Args:\n";
		for (i = 0; i < (long int)unknownArgs.size(); ++i) {
			SPRINTF(tmp, "%d: %s\n", i + 1, unknownArgs[i]->c_str());
			out += tmp;
		}
	};
}
/* ################################################################### */
#endif /* EZ_OPTION_PARSER_H */

```

`tracer.simple/tracer.simple.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0D05443D-36CB-44EE-9E5E-0784062E3ECF}</ProjectGuid>
    <RootNamespace>tracersimple</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>execution.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(OutDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>execution.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ezOptionParser.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tracer/Loader/Abstract.Mapper.h`:

```h
#ifndef _ABSTRACT_MAPPER_H_
#define _ABSTRACT_MAPPER_H_

#include "Types.h"

class AbstractPEMapper {
public:
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) = 0;
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) = 0;

	virtual DWORD FindImport(const char *moduleName, const char *funcName) = 0;
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal) = 0;
};

#endif


```

`tracer/Loader/Inproc.Mapper.cpp`:

```cpp
#include <Windows.h>
#include "Inproc.Mapper.h"


void *InprocMapper::CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect) {
	return VirtualAlloc(lpAddress, dwSize, MEM_RESERVE | MEM_COMMIT, flProtect);
}

bool InprocMapper::ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect) {
	DWORD oldProtect;
	return TRUE == VirtualProtect(lpAddress, dwSize, flProtect, &oldProtect);
}

bool InprocMapper::WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize) {
	memcpy(lpAddress, lpBuffer, nSize);
	return true;
}

DWORD InprocMapper::FindImport(const char *moduleName, const char *funcName) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, funcName);
}

DWORD InprocMapper::FindImport(const char *moduleName, const unsigned int funcOrdinal) {
	HMODULE hModule = GetModuleHandleA(moduleName);

	if (NULL == hModule) {
		return 0xFFFFFFFF;
	}

	return (DWORD)GetProcAddress(hModule, (LPCSTR)funcOrdinal);
}
```

`tracer/Loader/Inproc.Mapper.h`:

```h
#ifndef _INPROC_MAPPER_H_
#define _INPROC_MAPPER_H_

#include "Abstract.Mapper.h"

class InprocMapper : public AbstractPEMapper {
public :
	virtual void *CreateSection(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool ChangeProtect(void *lpAddress, size_t dwSize, DWORD flProtect);
	virtual bool WriteBytes(void *lpAddress, void *lpBuffer, size_t nSize);

	virtual DWORD FindImport(const char *moduleName, const char *funcName);
	virtual DWORD FindImport(const char *moduleName, const unsigned int funcOrdinal);
};

#endif
```

`tracer/Loader/PE.ldr.cpp`:

```cpp
#include <stdio.h>

#include <vector>
using namespace std;

//#define DONOTPRINT

#ifdef DONOTPRINT
#define dbg_log(fmt,...) ((void)0)
#endif

#include "PE.ldr.h"

//#include "common/debug-log.h"
#define dbg_log printf

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


#define IMAGE_REL_BASED_ABSOLUTE              0
#define IMAGE_REL_BASED_HIGH                  1
#define IMAGE_REL_BASED_LOW                   2
#define IMAGE_REL_BASED_HIGHLOW               3
#define IMAGE_REL_BASED_HIGHADJ               4
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5
#define IMAGE_REL_BASED_RESERVED              6
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8
#define IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9
#define IMAGE_REL_BASED_DIR64                 10

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     

#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     

#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define PAGE_REVERT_TO_FILE_MAP     0x80000000 

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

const USHORT DOS_MAGIC = 0x5A4D;
const DWORD PE_MAGIC = 0x00004550;
const WORD OPT32_MAGIC = 0x010B;
const WORD OPT64_MAGIC = 0x020B;

const WORD IMAGE_FILE_MACHINE_I386 = 0x14C;
const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Name;
	DWORD Base;
	DWORD NumberOfFunctions;
	DWORD NumberOfNames;
	DWORD AddressOfFunctions; // RVA from base of image
	DWORD AddressOfNames; // RVA from base of image
	DWORD AddressOfNameOrdinals; // RVA from base of image
} IMAGE_EXPORT_DIRECTORY;

void *FloatingPE::RVA(DWORD rva) const {
    for (int i = 0; i < peHdr.NumberOfSections; ++i) {
        if (rva >= sections[i].header.VirtualAddress) {
            DWORD dwOffset = rva - sections[i].header.VirtualAddress;
            if (dwOffset < sections[i].header.VirtualSize) {
                return sections[i].data + dwOffset;
            }
        }
    }
    return (void *)0;
}

bool FloatingPE::Relocate(DWORD newAddr) {
	long long offset = 0;
	IMAGE_BASE_RELOCATION *reloc;
    IMAGE_BASE_RELOCATION *term;

	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			offset = newAddr - optHdr.w32.ImageBase;
			optHdr.w32.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			offset = newAddr - optHdr.w64.ImageBase;
			optHdr.w64.ImageBase = newAddr;

			reloc = (IMAGE_BASE_RELOCATION *)RVA(optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			term = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

    while (reloc < term) {
        //dbg_log("Relocation Block %08x %08x", reloc->VirtualAddress, reloc->SizeOfBlock);
        WORD *wloc = (WORD *)reloc + 4;
        int wlocCount = (reloc->SizeOfBlock - sizeof(*reloc)) / sizeof(*wloc);

        for (int i = 0; i < wlocCount; ++i) {
            //dbg_log("%x %x;\t", wloc[i] >> 12, wloc[i] & 0x0FFF);
			WORD type = wloc[i] >> 12;
			WORD off = wloc[i] & 0x0FFF;
			
			if ((i % 3) == 0) {
				//dbg_log("\n");
			}
			
			switch (type) {
				case IMAGE_REL_BASED_ABSOLUTE :
					break;
				case IMAGE_REL_BASED_HIGHLOW :
					*((DWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					//dbg_log("%08x -> %08x\t", reloc->VirtualAddress + off, *((DWORD *)RVA(reloc->VirtualAddress + off)));
					break;
				case IMAGE_REL_BASED_DIR64 :
					*((QWORD *)RVA(reloc->VirtualAddress + off)) += (long)offset;
					break;
				default :
					//__asm int 3;
					__debugbreak();
			}
        }
		//dbg_log("\n");
		reloc = (IMAGE_BASE_RELOCATION *)((unsigned char *)reloc + reloc->SizeOfBlock);
    }


    return true;
}

bool FloatingPE::GetExport(const char *funcName, DWORD &funcRVA) {
	DWORD exportRVA = 0;
	
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			exportRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			exportRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
			break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	};
	
	if (0 == exportRVA) {
		return false;
	}

	IMAGE_EXPORT_DIRECTORY *exprt = (IMAGE_EXPORT_DIRECTORY *)RVA(exportRVA);

	dbg_log("Number of functions: %d\n", exprt->NumberOfFunctions);
	dbg_log("Number of names: %d\n", exprt->NumberOfNames);

	DWORD *names = (DWORD *)RVA(exprt->AddressOfNames);
	int found = -1;
	for (DWORD i = 0; i < exprt->NumberOfNames; ++i) {
		char *name = (char *)RVA(names[i]);
		if (0 == strcmp(name, funcName)) {
			found = i;
			break;
		}
	}

	if (-1 == found) {
		return false;
	}

	WORD *ordinals = (WORD *)RVA(exprt->AddressOfNameOrdinals);
	WORD ordinal = ordinals[found] - (WORD)exprt->Base + 1;

	DWORD *exportTable = (DWORD *)RVA(exprt->AddressOfFunctions);
	funcRVA = exportTable[ordinal];

	return true;
}

bool FloatingPE::FixImports(AbstractPEMapper &mapper) {
	DWORD importRVA = 0;
	
	
	switch (peHdr.Machine) {
	case IMAGE_FILE_MACHINE_I386:
		importRVA = optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	case IMAGE_FILE_MACHINE_AMD64:
		importRVA = optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
		break;
	default:
		dbg_log("Unsupported machine type\n");
		return false;
	};

	if (0 == importRVA) {
		return true;
	}

    IMAGE_IMPORT_DESCRIPTOR *import = (IMAGE_IMPORT_DESCRIPTOR *)RVA(importRVA);
	if (NULL == import) {
		return false;
	}

    while (import->OriginalFirstThunk != 0) {
		char *name = (char *)RVA(import->Name);
        dbg_log("Directory for: %s\n", name);
		dbg_log("OFT: %08x, FT: %08x\n", import->OriginalFirstThunk, import->FirstThunk);
		DWORD *funcs = (DWORD *)RVA(import->OriginalFirstThunk);
		DWORD *iat = (DWORD *)RVA(import->FirstThunk);
        while (*funcs != 0) {
            if (0x80000000 & *funcs) {
                dbg_log("Import by ordinal %d\n", *funcs & 0x7FFF);
				*iat = mapper.FindImport(name, *funcs & 0x7FFF);
            } else {
				char *funcName = (char *)RVA(*funcs + 2);
                dbg_log("Import by name %s\n", funcName);
				*iat = mapper.FindImport(name, funcName);
            }

            funcs += 1;
			iat += 1;
        }

		import += 1;
    }

    return true;
}

bool FloatingPE::LoadPE(FILE *fModule) {
	if (NULL == fModule) {
		dbg_log("File open error!\n");
		return false;
	}

	if (1 != fread(&dosHdr, sizeof(dosHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (dosHdr.e_magic != DOS_MAGIC) {
		dbg_log("dosHdr.e_magic not valid\n");
		return false;
	}

	fseek(fModule, dosHdr.e_lfanew, SEEK_SET);


	if (1 != fread(&peHdr, sizeof(peHdr), 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}

	if (PE_MAGIC != peHdr.PeSignature) {
		dbg_log("peHdr.PeSignature not valid\n");
		return false;
	}

	//dbg_log("Machine: %d\n", peHdr.Machine);
	//dbg_log("NumberOfSections: %d\n", peHdr.NumberOfSections);
	//dbg_log("SizeOfOptionalHeader: %d\n", peHdr.SizeOfOptionalHeader);
	//dbg_log("Characteristics: %d\n", peHdr.Characteristics);

	DWORD optSize = 0;
	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w32);
			break;
		case IMAGE_FILE_MACHINE_AMD64 :
			optSize = sizeof(optHdr.c) + sizeof(optHdr.w64);
			break;
		default :
			dbg_log("Unsupported machine type\n");
			return false;
	}

	if (peHdr.SizeOfOptionalHeader != optSize) {
		dbg_log("Unsupported optional header\n");
		return false;
	}

	if (1 != fread(&optHdr, optSize, 1, fModule)) {
		dbg_log("Read error\n");
		return false;
	}


	switch (peHdr.Machine) {
		case IMAGE_FILE_MACHINE_I386:
			if (OPT32_MAGIC != optHdr.c.Magic) {
				dbg_log("opt32Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %08x\n", optHdr.w32.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w32.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w32.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w32.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w32.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w32.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w32.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w32.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w32.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w32.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
			);
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			if (OPT64_MAGIC != optHdr.c.Magic) {
				dbg_log("opt64Hdr.Magic not valid\n");
				return false;
			}

			dbg_log("AddressOfEntryPoint: %x\n", optHdr.c.AddressOfEntryPoint);
			dbg_log("ImageBase: %016x\n", optHdr.w64.ImageBase);
			dbg_log("SectionAlignment: %d\n", optHdr.w64.SectionAlignment);
			dbg_log("FileAlignment: %d\n", optHdr.w64.FileAlignment);
			dbg_log("MajorSubsystemVersion: %d\n", optHdr.w64.MajorSubsystemVersion);
			dbg_log("SizeOfImage: %d\n", optHdr.w64.SizeOfImage);
			dbg_log("SizeOfHeaders: %d\n", optHdr.w64.SizeOfHeaders);
			dbg_log("Subsystem: %d\n", optHdr.w64.Subsystem);
			dbg_log("NumberOfRvaAndSizes: %d\n", optHdr.w64.NumberOfRvaAndSizes);
			dbg_log("DllCharacteristics: %04x\n", optHdr.w64.DllCharacteristics);

			dbg_log("Relocations: %08x (%08x)\n",
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
				optHdr.w64.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size
				); break;
		default:
			dbg_log("Unsupported machine type\n");
			return false;
	}

	

	sections.resize(peHdr.NumberOfSections);

	dbg_log("Name\t V.Size\t V.Addr\t R.Size\t R.Addr\t Characteristics\n");
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (1 != fread(&sections[i].header, sizeof(sections[i].header), 1, fModule)) {
			dbg_log("read error\n");
			return false;
		}

		dbg_log("%.8s\t %08x %08x %08x %08x %08x\n",
			sections[i].header.Name,
			sections[i].header.VirtualSize,
			sections[i].header.VirtualAddress,
			sections[i].header.SizeOfRawData,
			sections[i].header.PointerToRawData,
			sections[i].header.Characteristics);
	}

	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		if (!sections[i].Load(fModule)) {
			return false;
		}
	}

	return true;
}

FloatingPE::FloatingPE(const wchar_t *moduleName) {
	FILE *fModule; // = _wfopen_s(moduleName, L"rb");

	if (0 != _wfopen_s(&fModule, moduleName, L"rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}

FloatingPE::FloatingPE(const char *moduleName) {
	FILE *fModule; // = fopen(moduleName, "rb");

	if (0 != fopen_s(&fModule, moduleName, "rb")) {
		isValid = false;
		return;
	}

	isValid = LoadPE(fModule);
	fclose(fModule);
}


FloatingPE::~FloatingPE() {
	//TODO: regular cleanup
	for (int i = 0; i < peHdr.NumberOfSections; ++i) {
		sections[i].Unload();
	}
}

bool FloatingPE::MapPE(AbstractPEMapper &mapr, DWORD &baseAddr) {
	
	
	FixImports(mapr);
    
	
	DWORD maxAddr = 0;
	for (DWORD i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		DWORD maxSec = ((sections[i].header.VirtualAddress + sections[i].header.VirtualSize) + 0xFFF) & (~0xFFF);
		if (maxSec > maxAddr) {
			maxAddr = maxSec;
		}
	}
	

	baseAddr = (DWORD)mapr.CreateSection((void *)(baseAddr), maxAddr, PAGE_READWRITE);
	if (0 == baseAddr) {
		return false;
	}


	Relocate(baseAddr);

	//#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
	//#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
	//#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
	static const DWORD pVec[] = {
		PAGE_NOACCESS,
		PAGE_EXECUTE,
		PAGE_READONLY,
		PAGE_EXECUTE_READ,

		PAGE_READWRITE, // should be write only
		PAGE_EXECUTE_READWRITE, // should be execute write
		PAGE_READWRITE,
		PAGE_EXECUTE_READWRITE
	};

    for (unsigned int i = 0; i < sections.size(); ++i) {
		if (sections[i].header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			continue;
		}

		if (sections[i].header.SizeOfRawData) {
			if (!mapr.WriteBytes((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].data, sections[i].header.SizeOfRawData)) {
				return false;
			}
		}

		DWORD protect = pVec[sections[i].header.Characteristics >> 29]; // get the three most significant bytes
		if (!mapr.ChangeProtect((void *)(baseAddr + sections[i].header.VirtualAddress), sections[i].header.VirtualSize, protect)) {
			return false;
		}
		
    }

	return true;
}

bool PESection::Load(FILE *fModule) {
    data = new unsigned char[header.SizeOfRawData];

    fseek(fModule, header.PointerToRawData, SEEK_SET);
    if (header.SizeOfRawData != fread(data, 1, header.SizeOfRawData, fModule)) {
        dbg_log("read error, in section %s\n", header.Name);
        return false;
    }

    return true;
}

void PESection::Unload() {
    if (data) {
        delete [] data;
    }
}

#ifdef DONOTPRINT
#undef dbg_log
#endif

















```

`tracer/Loader/PE.ldr.h`:

```h
#ifndef _PE_LDR_H_
#define _PE_LDR_H_

#include <vector>
using namespace std;

#include "Types.h"
#include "Abstract.Mapper.h"


struct ImageSectionHeader {
    BYTE    Name[8];
    DWORD   VirtualSize;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
};

struct ImageDosHeader {  // DOS .EXE header
    USHORT e_magic;         // Magic number
    USHORT e_cblp;          // Bytes on last page of file
    USHORT e_cp;            // Pages in file
    USHORT e_crlc;          // Relocations
    USHORT e_cparhdr;       // Size of header in paragraphs
    USHORT e_minalloc;      // Minimum extra paragraphs needed
    USHORT e_maxalloc;      // Maximum extra paragraphs needed
    USHORT e_ss;            // Initial (relative) SS value
    USHORT e_sp;            // Initial SP value
    USHORT e_csum;          // Checksum
    USHORT e_ip;            // Initial IP value
    USHORT e_cs;            // Initial (relative) CS value
    USHORT e_lfarlc;        // File address of relocation table
    USHORT e_ovno;          // Overlay number
    USHORT e_res[4];        // Reserved words
    USHORT e_oemid;         // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;       // OEM information; e_oemid specific
    USHORT e_res2[10];      // Reserved words
    LONG   e_lfanew;        // File address of new exe header
};

struct ImagePeHeader {
    DWORD   PeSignature;
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
};

struct ImageDataDirectory {
    DWORD   VirtualAddress;
    DWORD   Size;
};

#pragma pack (push, 1)
struct ImageOptionalHeader {
	struct {
		WORD    Magic;
		BYTE    MajorLinkerVersion;
		BYTE    MinorLinkerVersion;
		DWORD   SizeOfCode;
		DWORD   SizeOfInitializedData;
		DWORD   SizeOfUninitializedData;
		DWORD   AddressOfEntryPoint;
		DWORD   BaseOfCode;
	} c;

	union {
		struct {
			DWORD   BaseOfData;
			DWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			DWORD   SizeOfStackReserve;
			DWORD   SizeOfStackCommit;
			DWORD   SizeOfHeapReserve;
			DWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w32;

		struct {
			QWORD   ImageBase;
			DWORD   SectionAlignment;
			DWORD   FileAlignment;
			WORD    MajorOperatingSystemVersion;
			WORD    MinorOperatingSystemVersion;
			WORD    MajorImageVersion;
			WORD    MinorImageVersion;
			WORD    MajorSubsystemVersion;
			WORD    MinorSubsystemVersion;
			DWORD   Win32VersionValue;
			DWORD   SizeOfImage;
			DWORD   SizeOfHeaders;
			DWORD   CheckSum;
			WORD    Subsystem;
			WORD    DllCharacteristics;
			QWORD   SizeOfStackReserve;
			QWORD   SizeOfStackCommit;
			QWORD   SizeOfHeapReserve;
			QWORD   SizeOfHeapCommit;
			DWORD   LoaderFlags;
			DWORD   NumberOfRvaAndSizes;
			ImageDataDirectory DataDirectory[16];
		} w64;
	};   
};
#pragma pack (pop)

class PESection {
public :
	ImageSectionHeader header;
	unsigned char *data;

	bool Load(FILE *fModule);
	void Unload();
};

class FloatingPE {
private :
	bool isValid;

	ImageDosHeader dosHdr;
	ImagePeHeader peHdr;
	ImageOptionalHeader optHdr;

	vector<PESection> sections;

	void *RVA(DWORD rva) const;
	bool LoadPE(FILE *fModule);

public :
	FloatingPE(const char *moduleName);
	FloatingPE(const wchar_t *moduleName);
	~FloatingPE();

	bool Relocate(DWORD newAddr);
	bool FixImports(AbstractPEMapper &mapper);
	bool GetExport(const char *funcName, DWORD &funcRVA);

	bool MapPE(AbstractPEMapper &mapr, DWORD &baseAddr);
	
	bool IsValid() const {
		return isValid;
	}
};

#endif

```

`tracer/Loader/Types.h`:

```h
#ifndef _TYPES_H_
#define _TYPES_H_

typedef unsigned short USHORT;
typedef long LONG;

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned long long QWORD;

#endif

```

`tracer/MapPE.cpp`:

```cpp

#include "Loader/PE.ldr.h"
#include "Loader/Inproc.Mapper.h"

extern "C" BYTE MapPE(DWORD *baseAddr) {
	InprocMapper mapper;
	FloatingPE pe("..\\lzo\\a.exe");
	DWORD dwAddr = *baseAddr;

	if (!pe.MapPE(mapper, dwAddr)) {
		printf("Couldn't map pe!");
		return 0;
	}

	*baseAddr = dwAddr;
	return 1;
}
```

`tracer/callgates.c`:

```c
#include "common.h"
#include "callgates.h"
#include "cb.h"
#include "mm.h"
#include "BaseTsd.h"

void Stopper(struct _exec_env *pEnv, BYTE *s) {
	struct _cb_info *pStop;

	// ## STOPPER ##
	DbgPrint("STOPPER: %p.\n", s);
	pStop = NewBlock(pEnv);
	pStop->address = (UINT_PTR) s;
	Translate(pEnv, pStop, 0); // this will fix pStop->CRC and pStop->Size
	SC_HeapFree(pEnv, pStop->pCode);
	pStop->pCode = (BYTE *)s;
	AddBlock(pEnv, pStop);
	// ## STOPPER ##
}


DWORD __declspec(noinline) call_cdecl_0(struct _exec_env *env, _fn_cdecl_0 f) {
	struct _cb_info *pBlock;
	DWORD ret;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate(env, pBlock, 0);
	AddBlock(env, pBlock);
	ret = ((_fn_cdecl_0)(pBlock->pCode))(); //JUMP in TVM

	return ret;
}

DWORD __declspec(noinline) call_cdecl_1(struct _exec_env *env, _fn_cdecl_1 f, void *p1) {
	DWORD ret;
	struct _cb_info *pBlock;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate(env, pBlock, 0);
	AddBlock(env, pBlock);

	ret = ((_fn_cdecl_1)(pBlock->pCode))(p1);

	return ret;
}

DWORD __declspec(noinline) call_cdecl_2(struct _exec_env *env, _fn_cdecl_2 f, void *p1, void *p2) {
	DWORD ret;
	struct _cb_info *pBlock;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate (env, pBlock, 0);
	AddBlock (env, pBlock);

	ret = ((_fn_cdecl_2)(pBlock->pCode))(p1, p2);

	return ret;
}

DWORD __declspec(noinline) call_cdecl_3(struct _exec_env *env, _fn_cdecl_3 f, void *p1, void *p2, void *p3) {
	DWORD ret;
	struct _cb_info *pBlock;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate (env, pBlock, 0);
	AddBlock (env, pBlock);

	ret = ((_fn_cdecl_3)(pBlock->pCode))(p1, p2, p3);

	return ret;
}

DWORD __declspec(noinline) call_cdecl_4(struct _exec_env *env, _fn_cdecl_4 f, void *p1, void *p2, void *p3, void *p4) {
	DWORD ret;
	struct _cb_info *pBlock;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate (env, pBlock, 0);
	AddBlock (env, pBlock);

	ret = ((_fn_cdecl_4)(pBlock->pCode))(p1, p2, p3, p4);
	return ret;
}

DWORD __declspec(noinline) call_stdcall_0(struct _exec_env *env, _fn_stdcall_0 f) {
	struct _cb_info *pBlock;
	DWORD ret;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate (env, pBlock, 0);
	AddBlock (env, pBlock);
	ret = ((_fn_stdcall_0)(pBlock->pCode))(); //JUMP in TVM

	return ret;
}

DWORD __declspec(noinline) call_stdcall_1(struct _exec_env *env, _fn_stdcall_1 f, void *p1) {
	DWORD ret;
	struct _cb_info *pBlock;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate (env, pBlock, 0);
	AddBlock (env, pBlock);

	ret = ((_fn_stdcall_1)(pBlock->pCode))(p1);

	return ret;
}

DWORD __declspec(noinline) call_stdcall_2(struct _exec_env *env, _fn_stdcall_2 f, void *p1, void *p2) {
	DWORD ret;
	struct _cb_info *pBlock;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate (env, pBlock, 0);
	AddBlock (env, pBlock);

	ret = ((_fn_stdcall_2)(pBlock->pCode))(p1, p2);

	return ret;
}

DWORD __declspec(noinline) call_stdcall_3(struct _exec_env *env, _fn_stdcall_3 f, void *p1, void *p2, void *p3) {
	DWORD ret;
	struct _cb_info *pBlock;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate (env, pBlock, 0);
	AddBlock (env, pBlock);

	ret = ((_fn_stdcall_3)(pBlock->pCode))(p1, p2, p3);

	return ret;
}

DWORD __declspec(noinline) call_stdcall_4(struct _exec_env *env, _fn_stdcall_4 f, void *p1, void *p2, void *p3, void *p4) {
	DWORD ret;
	struct _cb_info *pBlock;

	Stopper (env, _ReturnAddress());

	pBlock = NewBlock(env);
	pBlock->address = (DWORD) f;
	Translate(env, pBlock, 0);
	AddBlock(env, pBlock);

	ret = ((_fn_stdcall_4)(pBlock->pCode))(p1, p2, p3, p4);
	return ret;
}
```

`tracer/callgates.h`:

```h
#ifndef _CALL_GATES_H
#define _CALL_GATES_H

#include "environment.h"
#include "execenv.h"

typedef DWORD (_cdecl *_fn_cdecl_0) (void);
typedef DWORD (_cdecl *_fn_cdecl_1) (void *);
typedef DWORD (_cdecl *_fn_cdecl_2) (void *, void *);
typedef DWORD (_cdecl *_fn_cdecl_3) (void *, void *, void *);
typedef DWORD (_cdecl *_fn_cdecl_4) (void *, void *, void *, void *);

typedef DWORD (_stdcall *_fn_stdcall_0) (void);
typedef DWORD (_stdcall *_fn_stdcall_1) (void *);
typedef DWORD (_stdcall *_fn_stdcall_2) (void *, void *);
typedef DWORD (_stdcall *_fn_stdcall_3) (void *, void *, void *);
typedef DWORD (_stdcall *_fn_stdcall_4) (void *, void *, void *, void *);

DWORD __declspec(noinline) call_cdecl_0 (struct _exec_env *env, _fn_cdecl_0 f);
DWORD __declspec(noinline) call_cdecl_1 (struct _exec_env *env, _fn_cdecl_1 f, void *);
DWORD __declspec(noinline) call_cdecl_2 (struct _exec_env *env, _fn_cdecl_2 f, void *, void *);
DWORD __declspec(noinline) call_cdecl_3 (struct _exec_env *env, _fn_cdecl_3 f, void *, void *, void *);
DWORD __declspec(noinline) call_cdecl_4 (struct _exec_env *env, _fn_cdecl_4 f, void *, void *, void *, void *);

DWORD __declspec(noinline) call_stdcall_0 (struct _exec_env *env, _fn_stdcall_0 f);
DWORD __declspec(noinline) call_stdcall_1 (struct _exec_env *env, _fn_stdcall_1 f, void *);
DWORD __declspec(noinline) call_stdcall_2 (struct _exec_env *env, _fn_stdcall_2 f, void *, void *);
DWORD __declspec(noinline) call_stdcall_3 (struct _exec_env *env, _fn_stdcall_3 f, void *, void *, void *);
DWORD __declspec(noinline) call_stdcall_4 (struct _exec_env *env, _fn_stdcall_4 f, void *, void *, void *, void *);



#endif

```

`tracer/cb.c`:

```c
#include "common.h"
#include "extern.h"
#include "cb.h"
#include "sync.h"
#include "crc32.h"
#include "mm.h"

/*#define HASH_TABLE_SIZE 0x10000
#define HISTORY_SIZE 0x10000*/

unsigned long HashFunc(unsigned int logHashSize, unsigned long a) {
	//DbgPrint("Value = %08x\n", a);
	//DbgPrint("logHashSize = %08x\n", logHashSize);
	//DbgPrint("mask = %08x\n", ((1 << logHashSize) - 1));
	return a & ((1 << logHashSize) - 1);
}

struct _cb_info *NewBlock(struct _exec_env *pEnv) {
	struct _cb_info *pNew;
	
	pNew = (struct _cb_info *)SC_HeapAlloc(pEnv, sizeof(*pNew));

	if (pNew) {
		memset (pNew, 0, sizeof (*pNew));
		return pNew;
	}

	//dbg0(">> Memory allocation error!!\n");

	return NULL;
}

struct _cb_info *FindBlock (struct _exec_env *pEnv, unsigned long a) {
	struct _cb_info *pWalk;
	int arr = 0;
	unsigned long hash = HashFunc(pEnv->logHashSize, a);

	DbgPrint("HASH %08x\n", hash);
	TbmMutexLock(&pEnv->cbLock);

	pWalk = pEnv->hashTable[hash];

	while (pWalk) {
		if (pWalk->address == a) {
			if (pWalk->dwCRC == (unsigned long) crc32 (0xEDB88320, (BYTE *) a, pWalk->dwSize)) {
				TbmMutexUnlock(&pEnv->cbLock);
				return pWalk;
			} else {
				//	_asm int 3
				//	dbg1 ("___SMC___ at address %08X.\n", a);

				TbmMutexUnlock(&pEnv->cbLock);
				return NULL;
			}
		}

		pWalk = pWalk->pNext;
		if (++arr > 0x800) {
			TbmMutexUnlock(&pEnv->cbLock);
			__asm int 3
		}
	}

	TbmMutexUnlock(&pEnv->cbLock);

	return NULL;
}

void AddBlock(struct _exec_env *pEnv, struct _cb_info *pCB) {
	unsigned long dwHash;

	TbmMutexLock(&pEnv->cbLock);

	if (pEnv->posHist < (pEnv->historySize - 1)) {
		pEnv->history[pEnv->posHist] = pCB->address;
		pEnv->posHist++;
	}
	pEnv->totHist++;

	dwHash = HashFunc(pEnv->logHashSize, pCB->address); // & 0xFFFF;

	pCB->pNext = pEnv->hashTable[dwHash];
	pEnv->hashTable[dwHash] = pCB;

	TbmMutexUnlock(&pEnv->cbLock);
}

int InitBlock(struct _exec_env *pEnv, unsigned int logHashSize, unsigned int historySize) {
	pEnv->hashTable = (struct _cb_info **)EnvMemoryAlloc((1 << logHashSize) * sizeof (pEnv->hashTable[0]));

	if (!pEnv->hashTable) {
		return 0;
	}

	memset (pEnv->hashTable, 0, (1 << logHashSize) * sizeof (pEnv->hashTable[0]));

	pEnv->history = (UINT_PTR *)EnvMemoryAlloc(historySize * sizeof (pEnv->history[0]));

	if (NULL == pEnv->history) {
		EnvMemoryFree((BYTE *)pEnv->hashTable);
		return 0;
	}

	memset (pEnv->history, 0, historySize * sizeof (pEnv->history[0]));

	DbgPrint("History is at %p.\n", pEnv->history);

	pEnv->posHist = pEnv->totHist = 0;
	pEnv->logHashSize = logHashSize;
	pEnv->historySize = historySize;

	return 1;
}


void CloseBlock(struct _exec_env *pEnv) {
	unsigned long idx, midx;
	struct _cb_info *pWalk, *pAdd;

//	SC_Lock (&dwCBLock);

	midx = 1 << pEnv->logHashSize;
	idx = 0;

	for (idx = 0; idx < midx; ++idx) {
		pWalk = pEnv->hashTable[idx];

		while (pWalk) {
		//	DbgPrint("[%08X] [%08X] %08X -> %p.\n", pWalk, pWalk->dwParses & 0x7FFFFFFF, pWalk->address, pWalk->pCode);

			pAdd = pWalk;
			pWalk = pWalk->pNext;

			if (pAdd->address != (UINT_PTR) pAdd->pCode) {
				SC_HeapFree(pEnv, pAdd->pCode);
			}

			SC_HeapFree(pEnv, (unsigned char *)pAdd);
		}
	}

//	SC_Unlock (&dwCBLock);

	EnvMemoryFree ((BYTE *)pEnv->hashTable);
	pEnv->hashTable = NULL;
	EnvMemoryFree ((BYTE *)pEnv->history);
	pEnv->history = NULL;
}

void PrintHistory(struct _exec_env *pEnv) {
	unsigned long idx;

	for (idx = 0; idx < pEnv->posHist; idx ++) {
		DbgPrint("%08X -> %08X", idx, pEnv->history[idx]);
	}
}

DWORD DumpHistory(struct _exec_env *pEnv, unsigned char *o, unsigned long s, unsigned long *sz) {
	if ((pEnv->posHist * sizeof(pEnv->history[0])) > s) {
		return 0;
	}

	memcpy (o, (BYTE *)pEnv->history, pEnv->posHist * sizeof (pEnv->history[0]));
	*sz = (pEnv->posHist * sizeof (pEnv->history[0]));

	return 1;
}


```

`tracer/cb.h`:

```h
#ifndef _CB_H
#define _CB_H

#include "execenv.h"

//#include <Ntddk.h>
//#include <Basetsd.h>


struct _cb_info {
	UINT_PTR			address;
	unsigned long		dwSize;
	unsigned long		dwCRC;
	unsigned long		dwParses;
	unsigned char		*pCode;
	struct _cb_info		*pNext;
};

struct _cb_info *NewBlock (struct _exec_env *pEnv);
struct _cb_info *FindBlock (struct _exec_env *pEnv, unsigned long);

void AddBlock (struct _exec_env *pEnv, struct _cb_info *);
int InitBlock(struct _exec_env *pEnv, unsigned int logHashSize, unsigned int historySize);
void CloseBlock (struct _exec_env *pEnv);

void PrintHistory (struct _exec_env *pEnv);
DWORD DumpHistory(struct _exec_env *pEnv, unsigned char *o, unsigned long s, unsigned long *sz);

int Translate (struct _exec_env *pEnv, struct _cb_info *pCB, DWORD dwTranslationFlags);


/*
	8 dwords = 32 bytes
*/


#define CB_FLAG_SYSOUT	0x80000000


#endif // _CB_H


```

`tracer/codegen.c`:

```c
#include "execenv.h"

#include "common.h"
#include "cb.h"
#include "mm.h"
#include "modrm32.h"
#include "codetbl.h"
#include "crc32.h"
#include "extern.h"

//static BYTE poutBuffer [0x100000] = { 0 };


/*extern DWORD dwVirtualStack;
extern DWORD dwEaxSave;
extern DWORD dwJmpBuf;*/


DWORD dwTransLock = 0;


DWORD dwSysHandler    = (DWORD) SysHandler;
DWORD dwSysEndHandler = (DWORD) SysEndHandler;
DWORD dwBranchHandler = (DWORD) BranchHandler;

char *DuplicateBuffer(struct _exec_env *pEnv, char *p, unsigned int sz) {
	unsigned int mSz = (sz + 0x0F) & ~0x0F;
	
	char *pBuf = SC_HeapAlloc(pEnv, mSz);
	if (pBuf == NULL) {
		return NULL;
	}

	memcpy(pBuf, p, sz);
	memset(pBuf + sz, 0x90, mSz - sz);
	return pBuf;
}

int Translate(struct _exec_env *pEnv, struct _cb_info *pCB, DWORD dwTranslationFlags) {
	BYTE		*pInstruction;	// pointer catre instructiunea curenta
	BYTE		*pDestination;	// pointer to the destination area

	DWORD		dwI, dwJ, dwFlags, dwResult, dwWritten, i;

	dwResult = 0;

	DbgPrint("Starting analysis from address %08X\n", pCB->address);
	DbgPrint("-------------------------------------------------------------------\n");


	dwI	= 0;
	dwJ = 0; 

	pCB->dwParses  = dwTranslationFlags;
	pCB->pCode     = pEnv->outBuffer;
	
	if ((dwTranslationFlags & FLAG_BRANCH) == FLAG_BRANCH) {
		dwJ = AddSysEndPrefix(pEnv, pEnv->outBuffer);
	}

	do{
		dwFlags 	= FLAG_NONE;

		DbgPrint(".%08X\t", pCB->address + dwI);

		do{
			dwFlags         &= ~FLAG_PFX;

			pInstruction    = (BYTE *) (pCB->address + dwI);
			pDestination    = (BYTE *) (pCB->pCode     + dwJ);


			if (dwFlags & FLAG_EXT) {
				dwResult = Table0F [*pInstruction] (pEnv, pCB, &dwFlags, pInstruction, pDestination, &dwWritten);
			} else {
				dwResult = Table00 [*pInstruction] (pEnv, pCB, &dwFlags, pInstruction, pDestination, &dwWritten);
			}


    		
			for (i = 0; i < dwResult; i ++)
			{
				DbgPrint("%02X ", pInstruction[i]);
			}
		

			if (dwResult == 0) {
				// jumping out!
				pCB->pCode = (BYTE *) pCB->address;
				return 0;
			}

			dwI += dwResult;
			dwJ += dwWritten;

		} while (dwFlags & FLAG_PFX);

		DbgPrint("\n");

	} while ((dwFlags & FLAG_BRANCH) != FLAG_BRANCH);

	pCB->pCode  = DuplicateBuffer(pEnv, pEnv->outBuffer, dwJ);
	pCB->dwCRC  = (DWORD)crc32(0xEDB88320, (BYTE *)pCB->address, dwI);
	pCB->dwSize = dwI;

	if (!pCB->pCode) {
		// jumping out!
		pCB->pCode = (BYTE *) pCB->address;
	}

	return dwJ;
}



```

`tracer/codetbl.c`:

```c
#include "cb.h"
#include "modrm32.h"
#include "codetbl.h"
#include "extern.h"

extern unsigned int dwSysHandler; // = 0; // &SysHandler
extern unsigned int dwSysEndHandler; // = 0; // &SysEndHandler
extern unsigned int dwBranchHandler; // = 0; // &BranchHandler


const char pSysOut[] = {
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large ds:<dwVirtualStack>
	0x9C, 										// 0x06 - pushf
	0x60,										// 0x07 - pusha
	0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
	0x9D,										// 0x0D - popf
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <execution_environment>
	0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,         // 0x13 - call <dwSysEndHandler>
	0x58,										// 0x19 - pop eax // pop the execution environment off the stack
	0x61,                             			// 0x1A - popa
	0x9D,                                       // 0x1B - popf
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00          // 0x1C - xchg esp, large ds:<dwVirtualStack>
};

unsigned int AddSysEndPrefix(struct _exec_env *pEnv, char *pCurr) {
	memcpy(pCurr, pSysOut, sizeof(pSysOut));

	*(unsigned int *)(&pCurr[0x02]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pCurr[0x0F]) = (unsigned int)pEnv;
	*(unsigned int *)(&pCurr[0x15]) = (unsigned int)&dwSysEndHandler;
	*(unsigned int *)(&pCurr[0x1E]) = (unsigned int)&pEnv->virtualStack;

	return sizeof(pSysOut);
}


unsigned int __stdcall HandleSingle(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	return *dwWritten = 1;
}

unsigned int __stdcall HandleDouble(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	pD[1] = pI[1];
	*dwWritten = 2;
	return 0;
}

unsigned int __stdcall FuncImm8(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	pD[1] = pI[1];

	return *dwWritten = 2;
}

unsigned int __stdcall FuncImm32(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	pD[1] = pI[1];
	pD[2] = pI[2];
	
	if ((*dwFlags & FLAG_O16) == 0) {
		pD[3] = pI[3];
		pD[4] = pI[4];
		return *dwWritten = 5;
	}

	return *dwWritten = 3;
}

unsigned int __stdcall FuncExt(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	*dwFlags |= FLAG_EXT | FLAG_PFX;
	return *dwWritten = 1;
}

unsigned int __stdcall FuncSeg(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	*dwFlags |= FLAG_SEG | FLAG_PFX;
	return *dwWritten = 1;
}

unsigned int __stdcall FuncLock(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	*dwFlags |= FLAG_LOCK | FLAG_PFX;
	return *dwWritten = 1;
}

unsigned int __stdcall FuncRep(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	*dwFlags |= FLAG_REP | FLAG_PFX;
	return *dwWritten = 1;
}


unsigned int __stdcall FuncO16(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];

	/*if ((*dwFlags & FLAG_O16) == FLAG_O16) {
		
	}*/
	*dwFlags ^= FLAG_O16;
	*dwFlags |= FLAG_PFX;

	return *dwWritten = 1;
}

unsigned int __stdcall FuncA16(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];

	/*if ((*dwFlags & FLAG_O16) == FLAG_O16) {
		
	}*/
	*dwFlags ^= FLAG_A16;
	*dwFlags |= FLAG_PFX;

	return *dwWritten = 1;
}

unsigned int __stdcall FuncModrm(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned int size;

	pD[0] = pI[0];
	pD[1] = pI[1];

	size = GetModrmSize(*dwFlags, pI);
	if (size) {
		memcpy(pD + 2, pI + 2, size);
	}

	return *dwWritten = size + 2;
}

unsigned int __stdcall ModrmImm8(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned int size;

	pD[0] = pI[0];
	pD[1] = pI[1];

	size = GetModrmSize(*dwFlags, pI);
	if (size) {
		memcpy(pD + 2, pI + 2, size);
	}

	pD[2 + size] = pI[2 + size];
	return *dwWritten = 2 + size + 1;

}

unsigned int __stdcall ModrmImm32(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned int size;

	pD[0] = pI[0];
	pD[1] = pI[1];

	size = GetModrmSize(*dwFlags, pI);
	if (size) {
		memcpy(pD + 2, pI + 2, size);
	}

	
	pI += 2 + size;
	pD += 2 + size;

	pD[0] = pI[0];
	pD[1] = pI[1];
	if ((*dwFlags & FLAG_O16) == 0) {
		pD[2] = pI[2];
		pD[3] = pI[3];
		return *dwWritten = 2 + size + 4;		
	}

	return *dwWritten = 2 + size + 2;

}

const char pBranchJCC[] = {
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large ds:<dwVirtualStack>
	0x9C, 										// 0x06 - pushf
	0x60,										// 0x07 - pusha
	0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
	0x9D,										// 0x0D - popf
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <original_address>
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x13 - push <execution_environment>
	0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x18 - call <branch_handler>
	0x61,										// 0x1E - popa
	0x9D,										// 0x1F - popf
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x20 - xchg esp, large ds:<dwVirtualStack>
	0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x26 - jmp large dword ptr ds:<jumpbuff>

};

unsigned int __stdcall FuncJCC_B(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	char *pCurr = pD;

	unsigned int addrFallThrough = (unsigned int)(pI + 2);
	unsigned int addrJump = (unsigned int)(pI + pI[1] + 2);

	pD[0] = pI[0];
	pD[1] = sizeof(pBranchJCC);

	pCurr += 2;
	memcpy(pCurr, pBranchJCC, sizeof(pBranchJCC));

	*(unsigned int *)(&pCurr[0x02]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pCurr[0x0F]) = addrFallThrough;
	*(unsigned int *)(&pCurr[0x14]) = (unsigned int)pEnv;
	*(unsigned int *)(&pCurr[0x1A]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pCurr[0x22]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pCurr[0x28]) = (unsigned int)&pEnv->jumpBuff;
	pCurr += sizeof(pBranchJCC);

	
	memcpy(pCurr, pBranchJCC, sizeof(pBranchJCC));

	*(unsigned int *)(&pCurr[0x02]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pCurr[0x0F]) = addrJump;
	*(unsigned int *)(&pCurr[0x14]) = (unsigned int)pEnv;
	*(unsigned int *)(&pCurr[0x1A]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pCurr[0x22]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pCurr[0x28]) = (unsigned int)&pEnv->jumpBuff;
	pCurr += sizeof(pBranchJCC);

	*dwWritten = pCurr - pD;
	*dwFlags |= FLAG_BRANCH;
	return 2;
}


unsigned int __stdcall FuncJCC_D(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	char *pCurr = pD;

	unsigned int addrFallThrough = (unsigned int)(pI + 5);
	unsigned int addrJump = (unsigned int)(pI + *(unsigned int *)&pI[1] + 5);

	pD[0] = pI[0];
	*(unsigned int *)(&pD[1]) = sizeof(pBranchJCC);

	pCurr += 5;
	memcpy(pCurr, pBranchJCC, sizeof(pBranchJCC));

	*(unsigned int *)(&pCurr[0x02]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pCurr[0x0F]) = addrFallThrough;
	*(unsigned int *)(&pCurr[0x14]) = (unsigned int)pEnv;
	*(unsigned int *)(&pCurr[0x1A]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pCurr[0x22]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pCurr[0x28]) = (unsigned int)&pEnv->jumpBuff;
	pCurr += sizeof(pBranchJCC);

	
	memcpy(pCurr, pBranchJCC, sizeof(pBranchJCC));

	*(unsigned int *)(&pCurr[0x02]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pCurr[0x0F]) = addrJump;
	*(unsigned int *)(&pCurr[0x14]) = (unsigned int)pEnv;
	*(unsigned int *)(&pCurr[0x1A]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pCurr[0x22]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pCurr[0x28]) = (unsigned int)&pEnv->jumpBuff;
	pCurr += sizeof(pBranchJCC);

	*dwWritten = pCurr - pD;
	*dwFlags |= FLAG_BRANCH;
	return 5;
}

const char pBranchJMP[] = {
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large ds:<dwVirtualStack>
	0x9C, 										// 0x06 - pushf
	0x60,										// 0x07 - pusha
	0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
	0x9D,										// 0x0D - popf
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <jump_addr>
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x13 - push <execution_environment>
	0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x18 - call <dwBranchHandler>
	0x61,										// 0x1E - popa
	0x9D,										// 0x1F - popf
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x20 - xchg esp, large ds:<dwVirtualStack>
	0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x26 - jmp large dword ptr ds:<jumpbuff>	
};

unsigned int __stdcall FuncJMP_B(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned int addrJump = (unsigned int)(pI + pI[1] + 2);

	memcpy(pD, pBranchJMP, sizeof(pBranchJMP));
	*(unsigned int *)(&pD[0x02]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x0F]) = addrJump;
	*(unsigned int *)(&pD[0x14]) = (unsigned int)pEnv;
	*(unsigned int *)(&pD[0x1A]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pD[0x22]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x28]) = (unsigned int)&pEnv->jumpBuff;

	*dwWritten = sizeof(pBranchJMP);
	*dwFlags |= FLAG_BRANCH;
	return 2;
}

unsigned int __stdcall FuncJMP_D(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned int addrJump = (unsigned int)(pI + *(unsigned int *)(&pI[1]) + 5);

	memcpy(pD, pBranchJMP, sizeof(pBranchJMP));
	*(unsigned int *)(&pD[0x02]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x0F]) = addrJump;
	*(unsigned int *)(&pD[0x14]) = (unsigned int)pEnv;
	*(unsigned int *)(&pD[0x1A]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pD[0x22]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x28]) = (unsigned int)&pEnv->jumpBuff;

	*dwWritten = sizeof(pBranchJMP);
	*dwFlags |= FLAG_BRANCH;
	return 5;
}

unsigned int __stdcall FarPointer(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	pD[1] = pI[1];
	pD[2] = pI[2];
	pD[3] = pI[3];
	pD[4] = pI[4];

	if ((*dwFlags & FLAG_A16) == 0) {
		pD[5] = pI[5];
		pD[6] = pI[6];
		return *dwWritten = 7;
	}

	return *dwWritten = 5;
}

unsigned int __stdcall FuncAddr32(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	pD[1] = pI[1];
	pD[2] = pI[2];

	if ((*dwFlags & FLAG_A16) == 0) {
		pD[3] = pI[3];
		pD[4] = pI[4];
		return *dwWritten = 5;
	}

	return *dwWritten = 3;
}

//RetImm - copy the value
//Retn - 0
//RetFar - 4
const char pBranchRet[] = {
	0xA3, 0x00, 0x00, 0x00, 0x00,				// 0x00 - mov [<dwEaxSave>], eax
	0x58,										// 0x05 - pop eax
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x06 - xchg esp, large ds:<dwVirtualStack>
	0x9C,			 							// 0x0C - pushf
	0x60,										// 0x0D - pusha
	0x68, 0x46, 0x02, 0x00, 0x00,				// 0x0E - push 0x00000246 - NEW FLAGS
	0x9D,										// 0x13 - popf
	0x50,										// 0x14 - push eax
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x15 - push <execution_environment>
	0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x1A - call <branch_handler>

	0x61,										// 0x20 - popa
	0x9D,										// 0x21 - popf
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x22 - xchg esp, large ds:<dwVirtualStack>
	0xA1, 0x00, 0x00, 0x00, 0x00,				// 0x28 - mov eax, large ds:<dwEaxSave>
	0x8D, 0xA4, 0x24, 0x00, 0x00, 0x00, 0x00,   // 0x2D - lea esp, [esp + <pI>] // probably sub esp, xxx
	0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x34 - jmp large dword ptr ds:<jumpbuff>
};

unsigned int __stdcall FuncCRetImm(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned short stackSpace = *(unsigned short *)(&pI[1]);
	memcpy(pD, pBranchRet, sizeof(pBranchRet));	

	*(unsigned int *)(&pD[0x01]) = (unsigned int)&pEnv->returnRegister;
	*(unsigned int *)(&pD[0x08]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x16]) = (unsigned int)pEnv;
	*(unsigned int *)(&pD[0x1C]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pD[0x24]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x29]) = (unsigned int)&pEnv->returnRegister;
	*(unsigned int *)(&pD[0x30]) = stackSpace;
	*(unsigned int *)(&pD[0x36]) = (unsigned int)&pEnv->jumpBuff;

	*dwWritten = sizeof(pBranchRet);
	*dwFlags |= FLAG_BRANCH;
	return 3;
}

unsigned int __stdcall FuncCRetn(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned short stackSpace = 0;
	memcpy(pD, pBranchRet, sizeof(pBranchRet));	

	*(unsigned int *)(&pD[0x01]) = (unsigned int)&pEnv->returnRegister;
	*(unsigned int *)(&pD[0x08]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x16]) = (unsigned int)pEnv;
	*(unsigned int *)(&pD[0x1C]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pD[0x24]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x29]) = (unsigned int)&pEnv->returnRegister;
	*(unsigned int *)(&pD[0x30]) = stackSpace;
	*(unsigned int *)(&pD[0x36]) = (unsigned int)&pEnv->jumpBuff;

	*dwWritten = sizeof(pBranchRet);
	*dwFlags |= FLAG_BRANCH;
	return 1;
}

unsigned int __stdcall FuncCRetFar(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned short stackSpace = 4;
	memcpy(pD, pBranchRet, sizeof(pBranchRet));	

	*(unsigned int *)(&pD[0x01]) = (unsigned int)&pEnv->returnRegister;
	*(unsigned int *)(&pD[0x08]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x16]) = (unsigned int)pEnv;
	*(unsigned int *)(&pD[0x1C]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pD[0x24]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x29]) = (unsigned int)&pEnv->returnRegister;
	*(unsigned int *)(&pD[0x30]) = stackSpace;
	*(unsigned int *)(&pD[0x36]) = (unsigned int)&pEnv->jumpBuff;

	*dwWritten = sizeof(pBranchRet);
	*dwFlags |= FLAG_BRANCH;
	return 3;
}

unsigned int __stdcall FuncEnter(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	pD[1] = pI[1];
	pD[2] = pI[2];
	pD[3] = pI[3];
	return *dwWritten = 4;
}

const char pBranchCall[] = {
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x00 - push <retAddr>
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x05 - xchg esp, large ds:<dwVirtualStack>
	0x9C, 										// 0x0B - pushf
	0x60,										// 0x0C - pusha
	0x68, 0x46, 0x02, 0x00, 0x00,				// 0x0D - push 0x00000246 - NEW FLAGS
	0x9D,										// 0x12 - popf
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x13 - push <jumpAddr>
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x18 - push <execution_environment>
	0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,			// 0x1D - call <dwBranchHandler>
		
	0x61,										// 0x23 - popa
	0x9D,										// 0x24 - popf
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x25 - xchg esp, large ds:<dwVirtualStack>
	0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x2B - jmp large dword ptr ds:<jumpbuff>
};

unsigned int __stdcall FuncCall(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned int jumpAddr = (unsigned int)(pI + *(unsigned int *)(&pI[1]) + 5);
	unsigned int retAddr = (unsigned int)(&pI[5]);

	memcpy(pD, pBranchCall, sizeof(pBranchCall));
	*(unsigned int *)(&pD[0x01]) = retAddr;
	*(unsigned int *)(&pD[0x07]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x14]) = jumpAddr;
	*(unsigned int *)(&pD[0x19]) = (unsigned int)pEnv;
	*(unsigned int *)(&pD[0x1F]) = (unsigned int)&dwBranchHandler;
	*(unsigned int *)(&pD[0x27]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x2D]) = (unsigned int)&pEnv->jumpBuff;

	*dwWritten = sizeof(pBranchCall);
	*dwFlags |= FLAG_BRANCH;
	return 5;
}


unsigned int __stdcall DefaultBranch(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	DbgPrint("DefaultBranch: %02X.\n", pI);
	return 0;
}

unsigned int __stdcall DefaultFunc(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	DbgPrint("DefaultFunc: %02X.\n", pI);
	return 0;
}

unsigned int __stdcall FuncVirtualPC(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD[0] = pI[0];
	pD[1] = pI[1];
	pD[2] = pI[2];

	return *dwWritten = 3;
}

unsigned int __stdcall FuncF6(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned int size, test;

	pD[0] = pI[0];
	pD[1] = pI[1];

	size = GetModrmSize(*dwFlags, pI);
	if (size) {
		memcpy(pD + 2, pI + 2, size);
	}

	test = (pI[1] >> 3) & 0x07;
	if ((test == 0) || (test == 1)) {
		pD[2 + size] = pI[2 + size];
		return *dwWritten = 2 + size + 1;	
	}

	return *dwWritten = 2 + size;
}

unsigned int __stdcall FuncF7(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	unsigned int size, test;

	pD[0] = pI[0];
	pD[1] = pI[1];

	size = GetModrmSize(*dwFlags, pI);
	if (size) {
		memcpy(pD + 2, pI + 2, size);
	}

	test = (pI[1] >> 3) & 0x07;
	if ((test == 0) || (test == 1)) {
		//pD[2 + size] = pI[2 + size];
		//return *dwWritten = 2 + size + 1;	

		pD[size + 2] = pI[size + 2];
		pD[size + 3] = pI[size + 3];
		if ((*dwFlags & FLAG_O16) == 0) {
			pD[size + 4] = pI[size + 4];
			pD[size + 5] = pI[size + 5];
			return *dwWritten = 2 + size + 4;
		}

		return *dwWritten = 2 + size + 2;
	}

	return *dwWritten = 2 + size;
}

const char pBranchFF[] = {
	0xA3, 0x00, 0x00, 0x00, 0x00,				// 0x00 - [<dwEaxSave>], eax
	0x8B, 0x00									// 0x05 - mov ...
};

const char pBranchFFCall[] = {
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, large [<dwVirtualStack>]
	0x9C, 										// 0x06 - pushf
	0x60,										// 0x07 - pusha
	0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
	0x9D,										// 0x0D - popf
	0x50,                            			// 0x0E - push eax
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0F - push <execution_environment>
	0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,         // 0x14 - call [<dwBranchHandler>]

	0x61,										// 0x1A - popa
	0x9D,										// 0x1B - popf
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x1C - xchg esp, large ds:<dwVirtualStack>
	0xA1, 0x00, 0x00, 0x00, 0x00,               // 0x22 - mov eax, [<dwEaxSave>]
	0xFF, 0x25, 0x00, 0x00, 0x00, 0x00			// 0x27 - jmp large dword ptr ds:<jumpbuff>
};

unsigned int __stdcall FuncFF(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	char *pCurr;
	unsigned int size, test;

	size = GetModrmSize(*dwFlags, pI);
	/*if (size) {
	memcpy(pBuffer, &pI[2], size);
	}*/
	
	test = (pI[1] >> 3) & 7;
	pCurr = pD;
	if ((test == 2) || (test == 4)) {
		memcpy(pCurr, pBranchFF, sizeof(pBranchFF));
		*(unsigned int *)(&pCurr[1]) = (unsigned int)&pEnv->returnRegister;
		pCurr[6] = pI[1] & 0xC7;
		pCurr += sizeof(pBranchFF);

		if (size) {
			memcpy(pCurr, pI + 2, size);
			pCurr += size;
		}

		if (test == 2) {
			pCurr[0] = 0x68; //push 
			pCurr += 1;
			*(unsigned int *)pCurr = (unsigned int)&pI[2 + size];
			pCurr += 4;
		}

		memcpy(pCurr, pBranchFFCall, sizeof(pBranchFFCall));
		*(unsigned int *)(&pCurr[0x02]) = (unsigned int)&pEnv->virtualStack;
		*(unsigned int *)(&pCurr[0x10]) = (unsigned int)pEnv;		
		*(unsigned int *)(&pCurr[0x16]) = (unsigned int)&dwBranchHandler;		
		*(unsigned int *)(&pCurr[0x1E]) = (unsigned int)&pEnv->virtualStack;
		*(unsigned int *)(&pCurr[0x23]) = (unsigned int)&pEnv->returnRegister;
		*(unsigned int *)(&pCurr[0x29]) = (unsigned int)&pEnv->jumpBuff;
		pCurr += sizeof(pBranchFFCall);

		*dwWritten = pCurr - pD;
		*dwFlags |= FLAG_BRANCH;
		return 2 + size;
	} else {
		memcpy(pD, pI, 2 + size);
		*dwWritten = 2 + size;
		return 2 + size;	
	}	
}

const char pSysEnter[] = {
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x00 - xchg esp, [<dwVirtualStack>]
	0x9C,			 							// 0x06 - pushf
	0x60,										// 0x07 - pusha
	0x68, 0x46, 0x02, 0x00, 0x00,				// 0x08 - push 0x00000246 - NEW FLAGS
	0x9D,										// 0x0D - popf
	0x68, 0x00, 0x00, 0x00, 0x00,				// 0x0E - push <execution_environment>
	0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,         // 0x13 - call [<dwSysHandler>]
	0x58,										// 0x19 - pop eax // pop the execution environment off the stack
	0x61,										// 0x1A - popa
	0x9D,										// 0x1B - popf
	0x87, 0x25, 0x00, 0x00, 0x00, 0x00,			// 0x1C - xchg esp, [<dwVirtualStack>]
	0x0F, 0x34									// 0x22 - sysenter :D

};

unsigned int __stdcall FuncSysEnter(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten) {
	pD -= 1; //back up one byte (probably 0x0F)
	memcpy(pD, pSysEnter, sizeof(pSysEnter));

	*(unsigned int *)(&pD[0x02]) = (unsigned int)&pEnv->virtualStack;
	*(unsigned int *)(&pD[0x0F]) = (unsigned int)pEnv;
	*(unsigned int *)(&pD[0x15]) = (unsigned int)&dwSysHandler;
	*(unsigned int *)(&pD[0x1E]) = (unsigned int)&pEnv->virtualStack;

	*dwWritten = sizeof(pSysEnter) - 1;
	*dwFlags |= FLAG_BRANCH;
	return 1;	
}


OpCopy Table00[] = {
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncImm8, FuncImm32, HandleSingle, HandleSingle,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncImm8, FuncImm32, HandleSingle, FuncExt,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncImm8, FuncImm32, HandleSingle, HandleSingle,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncImm8, FuncImm32, HandleSingle, HandleSingle,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncImm8, FuncImm32, FuncSeg, HandleSingle,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncImm8, FuncImm32, FuncSeg, HandleSingle,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncImm8, FuncImm32, FuncSeg, HandleSingle,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncImm8, FuncImm32, FuncSeg, HandleSingle,
    HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    HandleSingle, HandleSingle, FuncModrm, FuncModrm, FuncSeg, FuncSeg, FuncO16, FuncA16,
    FuncImm32, ModrmImm32, FuncImm8, ModrmImm8, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B,
    FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B,
    ModrmImm8, ModrmImm32, ModrmImm8, ModrmImm8, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    HandleSingle, HandleSingle, FarPointer, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    FuncAddr32, FuncAddr32, FuncAddr32, FuncAddr32, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    FuncImm8, FuncImm32, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    
	FuncImm8, FuncImm8, FuncImm8, FuncImm8, FuncImm8, FuncImm8, FuncImm8, FuncImm8,
    FuncImm32, FuncImm32, FuncImm32, FuncImm32, FuncImm32, FuncImm32, FuncImm32, FuncImm32,
    
	ModrmImm8, ModrmImm8, FuncCRetImm, FuncCRetn, FuncModrm, FuncModrm, ModrmImm8, ModrmImm32,
    FuncEnter, HandleSingle, DefaultBranch, FuncCRetFar, HandleSingle, FuncImm8, HandleSingle, HandleSingle,
    
	FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncImm8, FuncImm8, HandleSingle, HandleSingle,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    
	FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncJCC_B, FuncImm8, FuncImm8, FuncImm8, FuncImm8,
    FuncCall, FuncJMP_D, FarPointer, FuncJMP_B, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    
	FuncLock, HandleSingle, FuncRep, FuncRep, HandleSingle, HandleSingle, FuncF6, FuncF7,
    HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, FuncModrm, FuncFF
};

OpCopy Table0F[] = {
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, DefaultFunc, FuncSysEnter, HandleSingle, HandleSingle,
    HandleSingle, HandleSingle, DefaultFunc, HandleSingle, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, FuncModrm,
    HandleDouble, HandleDouble, HandleDouble, HandleDouble, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    DefaultFunc, HandleSingle, HandleSingle, DefaultFunc, FuncSysEnter, DefaultFunc, DefaultFunc, DefaultFunc,
    DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, FuncVirtualPC,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    ModrmImm8, ModrmImm8, ModrmImm8, ModrmImm8, FuncModrm, FuncModrm, FuncModrm, HandleSingle,
    DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, DefaultFunc, FuncModrm, FuncModrm,
    FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D,
    FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D, FuncJCC_D,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    HandleSingle, HandleSingle, HandleSingle, FuncModrm, ModrmImm8, FuncModrm, DefaultFunc, DefaultFunc,
    HandleSingle, HandleSingle, HandleSingle, FuncModrm, ModrmImm8, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    DefaultFunc, DefaultFunc, ModrmImm8, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, ModrmImm8, FuncModrm, ModrmImm8, ModrmImm8, ModrmImm8, FuncModrm,
    HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle, HandleSingle,
    DefaultFunc, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    DefaultFunc, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm,
    FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, FuncModrm, DefaultFunc
};
```

`tracer/codetbl.h`:

```h
#ifndef _CODETBL_H
#define _CODETBL_H

#include "execenv.h"

typedef unsigned int (__stdcall *OpCopy)(struct _exec_env *pEnv, struct _cb_info *pCB, unsigned int *dwFlags, char *pI, char *pD, unsigned int *dwWritten);

extern OpCopy Table00[], Table0F[];

unsigned int AddSysEndPrefix(struct _exec_env *pEnv, char *p);

#endif

```

`tracer/common.h`:

```h
#ifndef _COMMON_H
#define _COMMON_H

#define NULL ((void *)0)

#endif
```

`tracer/crc32.c`:

```c
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id: crc32.cpp,v 1.1 2005/03/17 10:30:53 mihai Exp $ */

/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */

const unsigned long crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};


/* ========================================================================= */

#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
unsigned long crc32 (unsigned long crc, unsigned char *buf, unsigned long len)
{
    if (!buf) return 0L;

    crc = crc ^ 0xffffffffL;

    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}


```

`tracer/crc32.h`:

```h
#ifndef _CRC32_H
#define _CRC32_H

unsigned long crc32 (unsigned long crc, unsigned char *buf, unsigned long len);

#endif

```

`tracer/environment.h`:

```h
#ifndef _ENVIRONMENT_H
#define _ENVIRONMENT_H

typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;

void *EnvMemoryAlloc (DWORD dwSize);
void EnvMemoryFree (BYTE *b);

void __stdcall BranchHandler(struct _exec_env *, DWORD);
void __cdecl   SysHandler(struct _exec_env *, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
void __cdecl   SysEndHandler(struct _exec_env *, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);

int dbg0(char *pFormat);
int dbg1(char *pFormat, DWORD p1);
int dbg2(char *pFormat, DWORD p1, DWORD p2);

#endif

```

`tracer/execenv.c`:

```c
#include "execenv.h"
#include "mm.h"
#include "cb.h"

//#include "lup.h" //for now
#include "common.h"

struct _exec_env *NewEnv(unsigned int heapSize, unsigned int historySize, unsigned int logHashSize, unsigned int outBufferSize) {
	struct _exec_env *pEnv;

	if (NULL == (pEnv = EnvMemoryAlloc(sizeof(*pEnv)))) {
		return NULL;
	}

	memset(pEnv, 0, sizeof(*pEnv));

	if (0 == SC_HeapInit(pEnv, heapSize)) {
		EnvMemoryFree((BYTE *)pEnv);
		return NULL;
	}

	if (0 == InitBlock(pEnv, logHashSize, historySize)) {
		SC_HeapDestroy(pEnv);
		EnvMemoryFree((BYTE *)pEnv);
		return NULL;
	}

	if (NULL == (pEnv->outBuffer = EnvMemoryAlloc(outBufferSize))) {
		CloseBlock(pEnv);
		SC_HeapDestroy(pEnv);
		EnvMemoryFree((BYTE *)pEnv);
		return NULL;
	}
	pEnv->outBufferSize = outBufferSize;

	if (NULL == (pEnv->pStack = EnvMemoryAlloc (0x100000))) {
		EnvMemoryFree((BYTE *)pEnv->outBuffer);
		CloseBlock(pEnv);
		SC_HeapDestroy(pEnv);
		EnvMemoryFree((BYTE *)pEnv);
		return NULL;
	}

	memset (pEnv->pStack, 0, 0x100000);

	pEnv->virtualStack = (DWORD) pEnv->pStack + 0xFFFF0;

	return pEnv;
}

void DeleteEnv(struct _exec_env *pEnv) {
	if (pEnv != NULL) {
		DeleteUserContext(pEnv);

		CloseBlock(pEnv);
		SC_HeapDestroy(pEnv);

		EnvMemoryFree((BYTE *)pEnv->pStack);
		pEnv->pStack = NULL;

		EnvMemoryFree((BYTE *)pEnv);
		pEnv = NULL;
	}
}

void *AllocUserContext(struct _exec_env *pEnv, unsigned int size) {
	if (NULL != pEnv->userContext) {
		return NULL;
	}

	pEnv->userContext = SC_HeapAlloc(pEnv, size);
	memset(pEnv->userContext, 0, size);
	return pEnv->userContext;
}

void DeleteUserContext(struct _exec_env *pEnv) {
	if (NULL == pEnv->userContext) {
		return;
	}

	SC_HeapFree(pEnv, pEnv->userContext);
	pEnv->userContext = NULL;
}

```

`tracer/execenv.h`:

```h
#ifndef _EXEC_ENV_H
#define _EXEC_ENV_H

//#include <Ntifs.h>
#include <Basetsd.h>
#include "environment.h"
#include "sync.h"


struct _zone;
struct _cb_info;

typedef struct _exec_env {
	UINT_PTR virtualStack; //mandatory first member (used in vm-rm transitions
	UINT_PTR returnRegister; // ax/eax/rax value
	UINT_PTR jumpBuff;

	unsigned int heapSize, historySize, logHashSize, outBufferSize;

	unsigned char *pStack; // = NULL;

	unsigned char *pHeap; //NULL
	struct _zone *pFirstFree; //NULL

	_tbm_mutex cbLock; //  = 0;
	struct _cb_info **hashTable; // = 0

	UINT_PTR *history;
	unsigned long posHist, totHist; // = 0;

	unsigned char *outBuffer; // = NULL;
	void *userContext;
};

struct _exec_env *NewEnv(unsigned int heapSize, unsigned int historySize, unsigned int logHashSize, unsigned int outBufferSize);
void DeleteEnv(struct _exec_env *pEnv);

void *AllocUserContext(struct _exec_env *pEnv, unsigned int size);
void DeleteUserContext(struct _exec_env *pEnv);

#endif

```

`tracer/extern.c`:

```c
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

#include <Windows.h>

#include "extern.h"


void DbgPrint(const char *fmt, ...) {
	va_list va;

	va_start(va, fmt);
	vprintf(fmt, va);
	va_end(va);
}

void *EnvMemoryAlloc(unsigned long dwSize) {
	//return ExAllocatePoolWithTag(NonPagedPool, dwSize, 0x3070754C);
	void *ret = VirtualAlloc(NULL, dwSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	return ret;
}

void EnvMemoryFree(unsigned char *b) {
	//ExFreePoolWithTag(b, 0x3070754C);
	//VirtualFree(b);
}
```

`tracer/extern.h`:

```h
#ifndef _EXTERN_H
#define _EXTERN_H

void DbgPrint(const char *fmt, ...);

void *EnvMemoryAlloc(unsigned long dwSize);
void EnvMemoryFree(unsigned char *b);

#endif
```

`tracer/main.c`:

```c
#include "common.h"
#include "extern.h"
#include "cb.h"
#include "callgates.h"

#include <stdio.h>

FILE *fBlocks;

void __stdcall BranchHandler(struct _exec_env *pEnv, DWORD a) {
	struct _cb_info *pCB;

	DbgPrint("BranchHandler: %08X\n", a);
	fprintf(fBlocks, "0x%04x\n", a & 0xFFFF);
	fflush(fBlocks);
	//DbgPrint("pEnv %08X\n", pEnv);
	//DbgPrint("sizes: %08X, %08X, %08X, %08X\n", pEnv->heapSize, pEnv->historySize, pEnv->logHashSize, pEnv->outBufferSize);

	__try {
		DbgPrint("Looking for block\n");
		pCB = FindBlock(pEnv, a);
		if (pCB) {
			DbgPrint("Block found\n");
			pCB->dwParses++;
			pEnv->jumpBuff = (DWORD)pCB->pCode;
		}
		else {
			DbgPrint("Not Found\n");
			pCB = NewBlock(pEnv);
			pCB->address = a;

			Translate(pEnv, pCB, 0);

			AddBlock(pEnv, pCB);
			pEnv->jumpBuff = (DWORD)pCB->pCode;
		}

	}
	__except (1) { //EXCEPTION_EXECUTE_HANDLER
		pEnv->jumpBuff = a;

		/*if ((pCB != NULL) && (pCB->dwParses > 0x800)) {
		int *a = 0;
		*a = arr;
		}*/
	}

	fflush(stdout);
}


void __cdecl SysHandler(struct _exec_env *pEnv,
	DWORD r7, DWORD r6, DWORD r5, DWORD r4,
	DWORD r3, DWORD r2, DWORD r1, DWORD r0
	)
{
	UINT_PTR a;
	struct _cb_info *pCB;

	a = *(UINT_PTR*)pEnv->virtualStack;
	pEnv->returnRegister = a;

	pCB = FindBlock(pEnv, a);

	if (pCB) {
		if ((pCB->dwParses & CB_FLAG_SYSOUT) == CB_FLAG_SYSOUT) {
			pCB->dwParses++;
			*(UINT_PTR *)pEnv->virtualStack = (UINT_PTR)pCB->pCode;
			return;
		}
		else {
			//	dbg0 ("This CB receives control after a sysexit, but no CB_FLAG_SYSOUT!\n");
			//	_asm int 3
		}
	}

	pCB = NewBlock(pEnv);

	pCB->address = a;
	Translate(pEnv, pCB, CB_FLAG_SYSOUT);
	AddBlock(pEnv, pCB);

	*(UINT_PTR *)pEnv->virtualStack = (UINT_PTR)pCB->pCode;
}


void __cdecl SysEndHandler(struct _exec_env *pEnv,
	DWORD r7, DWORD r6, DWORD r5, DWORD r4,
	DWORD r3, DWORD r2, DWORD r1, DWORD r0,
	DWORD eflags
	)
{
	*(UINT_PTR *)(pEnv->virtualStack - 4) = pEnv->returnRegister;
}


int overlap(unsigned int a1, unsigned int a2, unsigned int b1, unsigned int b2);

BYTE MapPE(DWORD *baseAddr);

int main(unsigned int argc, char *argv[]) {
	/*struct _exec_env *pEnv;
	pEnv = NewEnv(0x100000, 0x10000, 16, 0x10000);

	DWORD ret = call_cdecl_4(pEnv, (_fn_cdecl_4)&overlap, 3, 7, 2, 10);


	printf("Done. ret = %d\n", ret);
	printf("Test %d\n", overlap(3, 7, 2, 10));


	return 0;*/

	fopen_s(&fBlocks, "blocks.log", "wt");

	DWORD baseAddr = 0;
	if (!MapPE(&baseAddr)) {
		return 0;
	}



	struct _exec_env *pEnv;
	struct UserCtx *ctx;
	DWORD dwCount = 0;
	pEnv = NewEnv(0x100000, 0x10000, 16, 0x10000);
	
	//unsigned char *pOverlap = (unsigned char *)*(unsigned int *)((unsigned char *)overlap + 1);
	//pOverlap += (UINT_PTR)overlap + 5;

	/*x86toriver(pEnv, pOverlap, ris, &dwCount);
	rivertox86(pEnv, ris, dwCount, tBuff);*/

	//DWORD ret = call_cdecl_4(pEnv, (_fn_cdecl_4)&overlap, (void *)3, (void *)7, (void *)2, (void *)10);
	unsigned char *pMain = (unsigned char *)baseAddr + 0x96CE;
	DWORD ret = call_cdecl_2(pEnv, (_fn_cdecl_2)pMain, (void *)argc, (void *)argv);
	DbgPrint("Done. ret = %d\n", ret);

	DbgPrint("Test %d\n", overlap(3, 7, 2, 10));

	fclose(fBlocks);

	return 0;
}
```

`tracer/mm.c`:

```c
#include "mm.h"


//#include "lup.h" //for now
//volatile DWORD dwMMLock			= 0;

#include "common.h"
#include "extern.h"

void memcpy(void *dest, const void *src, unsigned int size) {
	for (unsigned int i = 0; i < size; ++i) {
		((char *)dest)[i] = ((char *)src)[i];
	}
}

void memset(void *dest, int val, unsigned int size) {
	for (unsigned int i = 0; i < size; ++i) {
		((char *)dest)[i] = val;
	}
}

struct _zone {
	struct _zone *Prev; // 0xFFFFFFFF if this is the first block
	struct _zone *Next; // 0xFFFFFFFF if this is the last block
	DWORD Size; // size of this block
	DWORD Type; // 0 - free, 1 - allocated
};

int SC_HeapInit(struct _exec_env *pEnv, unsigned int heapSize) {
	struct _zone *fz;
	unsigned char *pHeap;

	pHeap = pEnv->pHeap = EnvMemoryAlloc(heapSize);

	if (!pHeap) {
		return 0;
	}
	
	memset (pHeap, 0, heapSize);

	fz = (struct _zone *) pHeap; 

	fz->Next = (struct _zone *) 0xFFFFFFFF;
	fz->Prev = (struct _zone *) 0xFFFFFFFF;
	fz->Type = 0;
	fz->Size = pEnv->heapSize - sizeof(struct _zone);

	pEnv->pFirstFree = fz;

	pEnv->heapSize = heapSize;
	return 1;
}

int SC_HeapDestroy(struct _exec_env *pEnv) {
	if (pEnv->pHeap) {
		EnvMemoryFree(pEnv->pHeap);
		pEnv->pHeap = NULL;
		pEnv->pFirstFree = NULL;
	}

	return 1;
}


void SC_PrintInfo (struct _exec_env *pEnv, struct _zone *fz) {
	DbgPrint("FirstFree: %08X.\n", (DWORD) pEnv->pFirstFree);
	DbgPrint("fz  Addr : %08X.\n", (DWORD)fz);
	DbgPrint("fz->Next : %08X.\n", (DWORD)fz->Next);
	DbgPrint("fz->Prev : %08X.\n", (DWORD)fz->Prev);
	DbgPrint("fz->Type : %08X.\n", (DWORD)fz->Type);
	DbgPrint("fz->Size : %08X.\n", (DWORD)fz->Size);
	DbgPrint("\n");
}


BYTE *SC_HeapAlloc(struct _exec_env *pEnv, DWORD sz) {
	BYTE *b;
	DWORD first;
	struct _zone *fz, *nfz;

	sz += 3;
	sz &= ~3L;

//	SC_Lock (&dwMMLock);

	first = 1;

	fz = pEnv->pFirstFree;

	do{
	//	SC_PrintInfo (fz);

		if (fz->Type == 0) {// free block
			if (sz + sizeof (struct _zone) <= fz->Size) {
			//	printf("Found a block of %d bytes. We need only %d.\n", fz->Size, sz);

				b = (BYTE *) fz + sizeof (struct _zone);

				nfz = (struct _zone *) ((BYTE *) fz + sizeof (struct _zone) + sz);

				if (fz->Next != (struct _zone *) 0xFFFFFFFF)
				{
					fz->Next->Prev = nfz;
				}

				nfz->Next = fz->Next;
				nfz->Prev = fz;
				nfz->Type = 0;
				nfz->Size = fz->Size - sz - sizeof (struct _zone);

				fz->Next = nfz;
				fz->Type = 1;
				fz->Size = sz;

				if (first) {
					pEnv->pFirstFree = nfz;
				}

			//	SC_Unlock (&dwMMLock);
				
				return b;
			} else {
			//	printf("Free block, but only %d in size!\n", fz->Size);
				first = 0;
			}
		}

		fz = (struct _zone *) fz->Next;

	} while (fz != (struct _zone *) 0xFFFFFFFF);

//	SC_Unlock (&dwMMLock);

	return NULL;
}

int SC_HeapList(struct _exec_env *pEnv) {
	DWORD dwMaxSize;
	struct _zone *fz;

	fz = (struct _zone *)pEnv->pHeap;

//	SC_Lock (&dwMMLock);

	dwMaxSize = 0;

	do{

	//	SC_PrintInfo (fz);

		if (fz->Type == 1)
		{		
		//	printf("fz->addr : %08X, fz->size : %08X.\n", fz, fz->Size);
			dwMaxSize += fz->Size;
		}

		fz = (struct _zone *) fz->Next;

	} while (fz != (struct _zone *) 0xFFFFFFFF);

//	printf("%d bytes of memory are in use.\n", dwMaxSize);

//	SC_Unlock (&dwMMLock);

	return 0;
}

int SC_HeapFree(struct _exec_env *pEnv, BYTE *p) {
	struct _zone *fz, *wfz;

//	SC_Lock (&dwMMLock);

	fz = (struct _zone *) (p - sizeof (struct _zone));

//	SC_PrintInfo (fz);

	fz->Type = 0;

	wfz = fz->Next;

	if (wfz != (struct _zone *) 0xFFFFFFFF) {// present?
		if (wfz->Type == 0) {// free?
			fz->Next = wfz->Next;
			fz->Size = fz->Size + wfz->Size + sizeof (struct _zone);
			fz->Type = 0;
		}
	}

	if (fz < pEnv->pFirstFree) {
		pEnv->pFirstFree = fz;
	}

	wfz = fz->Prev;

	if (wfz != (struct _zone *) 0xFFFFFFFF) {// present?
		if (wfz->Type == 0) {// free?
			wfz->Next = fz->Next;
			wfz->Size = wfz->Size + fz->Size + sizeof (struct _zone);

			if (wfz < pEnv->pFirstFree) {
				pEnv->pFirstFree = wfz;
			}
		}
	}

//	SC_Unlock (&dwMMLock);

	return 1;
}


```

`tracer/mm.h`:

```h
#ifndef __MM_H
#define __MM_H

#include "execenv.h"

#define HEAP_SIZE 0x100000

void memcpy(void *dest, const void *src, unsigned int size);
void memset(void *dest, int val, unsigned int size);

int 	SC_HeapInit 	(struct _exec_env *pEnv, unsigned int heapSize);
int 	SC_HeapDestroy 	(struct _exec_env *pEnv);
void 	SC_PrintInfo 	(struct _exec_env *pEnv, struct _zone *fz);
int 	SC_HeapList 	(struct _exec_env *pEnv);
unsigned char *SC_HeapAlloc 	(struct _exec_env *pEnv, unsigned long sz);
int 	SC_HeapFree 	(struct _exec_env *pEnv, unsigned char *p);


#endif // __MM_H


```

`tracer/modrm32.c`:

```c

#include "execenv.h"
#include "modrm32.h"


BYTE Modrm16 [0x100] = 
			{
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 
				01, 01, 01, 01, 01, 01, 03, 01, 

				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 
				02, 02, 02, 02, 02, 02, 02, 02, 

				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03, 
				03, 03, 03, 03, 03, 03, 03, 03,
 
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01,
				01, 01, 01, 01, 01, 01, 01, 01, 
				01, 01, 01, 01, 01, 01, 01, 01,
				01, 01, 01, 01, 01, 01, 01, 01
			};


DWORD GetModrmSize (DWORD dwFlags, BYTE *pI)
{
	DWORD dwExtra;
	BYTE bModRM, bRM, bMod, bSIB;

	if (dwFlags & FLAG_A16)
	{
		return (DWORD) (Modrm16 [pI[1]] - 1);
	}

	bModRM 		= * (pI + 1);

	bRM    		= bModRM & 0x07;
	bMod   		= bModRM >> 6;

	dwExtra = 0;

	switch (bMod)
	{
		case 0x00:
		{
			switch (bRM)
			{
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				{
					break;
				}
				case 0x04:
				{
					dwExtra = 1;
					bSIB = * (pI + 2);
					if ((bSIB & 0x07) == 0x05) // EBP
					{
						dwExtra += 4;
					}
					break;
				}
				case 0x05:
				{
					// imm32
					dwExtra = 4;
					break;
				}
				case 0x06:
				case 0x07:
				default:
				{
					break;
				}
			}
			break;
		}

		case 0x01:
		{
			switch (bRM)
			{
				case 0x04:
				{
					dwExtra = 2;
					break;
				}
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x05:
				case 0x06:
				case 0x07:
				default:
				{
					dwExtra = 1;
					break;
				}
			}
			break;
		}

		case 0x02:
		{
			switch (bRM)
			{
				case 0x04:
				{
					dwExtra = 5;
					break;
				}
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x05:
				case 0x06:
				case 0x07:
				default:
				{
					dwExtra = 4;
					break;
				}
			}
			break;
		}
		default : break;
	}

	return dwExtra;
}

```

`tracer/modrm32.h`:

```h
#ifndef _MODRM32_H
#define _MODRM32_H

#define FLAG_NONE	0x00000000
#define FLAG_REP	0x00000001
#define FLAG_SEG	0x00000002
#define FLAG_O16	0x00000004
#define FLAG_A16	0x00000008
#define FLAG_LOCK	0x00000010
#define FLAG_EXT	0x00000020
#define FLAG_PFX	0x40000000
#define FLAG_BRANCH	0x80000000

DWORD GetModrmSize (DWORD, BYTE *pI);

#endif //  _MODRM32_H


```

`tracer/nld2msg.h`:

```h


#ifndef _NLD2MSG_H
#define _NLD2MSG_H

#include <windows.h>

#include "mm.h"
#include "tls.h"

// #define _DEBUG 1

#ifdef _DEBUG
#define msg printf
#else
#define msg
#endif


#define FLAG_NONE	0x00000000
#define FLAG_REP	0x00000001
#define FLAG_SEG	0x00000002
#define FLAG_O16	0x00000004
#define FLAG_A16	0x00000008
#define FLAG_LOCK	0x00000010
#define FLAG_EXT	0x00000020
#define FLAG_PFX	0x40000000
#define FLAG_BRANCH	0x80000000

#define FLAG_VOLATILE   0x564F4C41

/*
	8 dwords = 32 bytes
*/

#pragma pack(1)

/*struct _cb_info
{
	DWORD 			address;
	DWORD			dwSize;
	DWORD			dwCRC;
	DWORD			dwParses;
	BYTE			*pCode;
	struct _cb_info		*pNext;
};*/


#define CB_FLAG_SYSOUT	0x80000000


typedef DWORD (__cdecl *_scfn) (struct _cb_info *, DWORD *, BYTE *, BYTE *, DWORD *); 

int Translate (struct _cb_info *pCB, DWORD dwParent, DWORD dwFlags);

struct _msg_conn
{
	unsigned long free;	// 0x00
	unsigned long full;	// 0x04
	unsigned long args;	// 0x08
	unsigned long data[1];	// 0x0C
};

/*
0012FEF0  30 00 32 00 00 FC FD 7F  0.2..亂
*/

struct _unicode_string
{
	unsigned short len;
	unsigned short maxlen;
	wchar_t *name;
};

/*
0012FED8  18 00 00 00 14 00 00 00  ......
0012FEE0  F0 FE 12 00 00 00 00 00  d_.....
0012FEE8  00 00 00 00 00 00 00 00  ........
*/

struct _object_attributes
{
	unsigned long len;		// 0x00 ; 0x18 ; sizeof(struct)
	unsigned long root;		// 0x04 ; 0x14 ; ??? ; will be set to 0
	struct _unicode_string *name; 	// 0x08 ; 
	unsigned long attr;		// 0x0C ; 0x00
	unsigned long security;		// 0x10 ; 0x00
	unsigned long qos;		// 0x14 ; 0x00
};





DWORD WINAPI ZwClose 			(HANDLE);
DWORD WINAPI ZwOpenSection 		(HANDLE *, DWORD, struct _object_attributes *);
DWORD WINAPI ZwOpenDirectoryObject	(HANDLE *, DWORD, struct _object_attributes *);
DWORD WINAPI ZwMapViewOfSection		(HANDLE, HANDLE, DWORD *, DWORD, DWORD, LARGE_INTEGER *, DWORD *, DWORD, DWORD, DWORD);
DWORD WINAPI ZwAllocateVirtualMemory	(HANDLE, DWORD *, DWORD, DWORD *, DWORD, DWORD);
DWORD WINAPI ZwFreeVirtualMemory	(HANDLE, DWORD *, DWORD *, DWORD);
DWORD WINAPI ZwProtectVirtualMemory 	(HANDLE, DWORD *, DWORD *, DWORD, DWORD *);

DWORD WINAPI ZwDelayExecution 		(DWORD, LARGE_INTEGER *);
DWORD WINAPI ZwYieldExecution 		(void);

DWORD WINAPI ZwSetEvent 		(HANDLE, DWORD *);
DWORD WINAPI ZwWaitForSingleObject	(HANDLE *, DWORD, LARGE_INTEGER *);
DWORD WINAPI ZwOpenEvent 		(HANDLE *, DWORD, struct _object_attributes *);

DWORD __inline MyInterlockedCompareExchange (volatile DWORD *p, DWORD v, DWORD c);
void *WINAPI KiUserExceptionDispatcher (DWORD, DWORD);

void *MyMemoryAlloc (DWORD);

#endif // NLD2MSG_H


```

`tracer/src.c`:

```c



int __cdecl overlap(unsigned int a1, unsigned int a2, unsigned int b1, unsigned int b2) {

	if (!(a1 < a2 || b1 < b2)) {
		return -1;
	}

	if (b1 > a2) {
		return 0;
	}

	if (b2 < a1) {
		return 0;
	}

	if (b1 <= a1 && b2 <= a2) {
		return 1;
	}

	return 0;
}


```

`tracer/sync.c`:

```c
//#include <Wdm.h>
#include "extern.h"
#include "sync.h"

void TbmMutexLock(_tbm_mutex *mutex) {
	//DbgPrint("LOCK %08x\n", mutex);
	while (1) {
		if (0 == _InterlockedExchange(mutex, 1)) {
			break;
		}

		//Sleep?
	}
}

void TbmMutexUnlock(_tbm_mutex *mutex) {
	//DbgPrint("UNLOCK %08x\n", mutex);
	_InterlockedExchange(mutex, 0);
}
```

`tracer/sync.h`:

```h
#ifndef _SYNC_H
#define _SYNC_H

typedef volatile long _tbm_mutex;

void TbmMutexLock(_tbm_mutex *mutex);
void TbmMutexUnlock(_tbm_mutex *mutex);

#endif

```

`tracer/tracer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D661AE67-57C6-49FD-A256-E998F11290B4}</ProjectGuid>
    <RootNamespace>tracer</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="callgates.h" />
    <ClInclude Include="cb.h" />
    <ClInclude Include="codetbl.h" />
    <ClInclude Include="common.h" />
    <ClInclude Include="crc32.h" />
    <ClInclude Include="environment.h" />
    <ClInclude Include="execenv.h" />
    <ClInclude Include="extern.h" />
    <ClInclude Include="Loader\Abstract.Mapper.h" />
    <ClInclude Include="Loader\Inproc.Mapper.h" />
    <ClInclude Include="Loader\PE.ldr.h" />
    <ClInclude Include="Loader\Types.h" />
    <ClInclude Include="mm.h" />
    <ClInclude Include="modrm32.h" />
    <ClInclude Include="nld2msg.h" />
    <ClInclude Include="sync.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="callgates.c" />
    <ClCompile Include="cb.c" />
    <ClCompile Include="codegen.c" />
    <ClCompile Include="codetbl.c" />
    <ClCompile Include="crc32.c" />
    <ClCompile Include="execenv.c" />
    <ClCompile Include="extern.c" />
    <ClCompile Include="Loader\Inproc.Mapper.cpp" />
    <ClCompile Include="Loader\PE.ldr.cpp" />
    <ClCompile Include="main.c" />
    <ClCompile Include="MapPE.cpp" />
    <ClCompile Include="mm.c" />
    <ClCompile Include="modrm32.c" />
    <ClCompile Include="src.c">
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Default</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Full</Optimization>
      <DebugInformationFormat Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">None</DebugInformationFormat>
      <BufferSecurityCheck Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</BufferSecurityCheck>
      <MinimalRebuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</MinimalRebuild>
      <SDLCheck Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</SDLCheck>
    </ClCompile>
    <ClCompile Include="sync.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`wrapper.setup/CMakeLists.txt`:

```txt
## wrapper.setup CMakeLists.txt

set(LIBRARY_NAME wrappersetup)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -m32 -std=c++11")

add_library(${LIBRARY_NAME} STATIC
	Setup.Linux.cpp
	Setup.Windows.cpp
	)

install(TARGETS ${LIBRARY_NAME} DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)

```

`wrapper.setup/Makefile`:

```
lib_wrappersetup := libwrappersetup.a
CC := gcc
CXX := g++ 
CPP_FILES := Setup.Linux.cpp Setup.Windows.cpp
OBJ_FILES := $(addprefix ,$(notdir $(CPP_FILES:.cpp=.o)))
LD_FLAGS :=
CXX_FLAGS += -g -m32 -std=c++11
CC_FLAGS += -g -m32 -std=c++11
prefix := /usr/local

all: $(lib_wrappersetup)

install: $(lib_wrappersetup)
	install -m 0755 $(lib_wrappersetup) -t $(prefix)/lib -D

$(lib_wrappersetup): $(OBJ_FILES)
	$(AR) rcs $@ $^

%.o: %.cpp
	   $(CXX) $(CXX_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	$(RM) $(lib_wrappersetup) $(OBJ_FILES) *.o main

```

`wrapper.setup/Setup.Linux.cpp`:

```cpp
#ifdef __linux__

#include "../CommonCrossPlatform/Common.h"
#include "../revtracer-wrapper/RevtracerWrapper.h"

extern "C" bool InitWrapperOffsets(ext::LibraryLayout *libs, revwrapper::WrapperImports *api) {

	LIB_T hlibc = GET_LIB_HANDLER("libc.so");
	LIB_T hlibrt = GET_LIB_HANDLER("librt.so");
	LIB_T hlibpthread = GET_LIB_HANDLER("libpthread.so");

	if (!hlibc || !hlibrt || !hlibpthread) {
		return false;
	}

	DWORD baselibc = GET_LIB_BASE(hlibc);
	DWORD baselibrt = GET_LIB_BASE(hlibrt);
	DWORD baselibpthread = GET_LIB_BASE(hlibpthread);

	libs->linLib.libcBase = baselibc;
	api->functions.linFunc.libc._virtualAlloc = (DWORD)LOAD_PROC(hlibc, "mmap") - baselibc;
	api->functions.linFunc.libc._virtualFree = (DWORD)LOAD_PROC(hlibc, "munmap") - baselibc;
	api->functions.linFunc.libc._terminateProcess = (DWORD)LOAD_PROC(hlibc, "exit") - baselibc;
	api->functions.linFunc.libc._writeFile = (DWORD)LOAD_PROC(hlibc, "write") - baselibc;
	api->functions.linFunc.libc._formatPrint = (DWORD)LOAD_PROC(hlibc, "vsnprintf") - baselibc;
	api->functions.linFunc.libc._print = (DWORD)LOAD_PROC(hlibc, "printf") - baselibc;
	api->functions.linFunc.libc._clockGetTime = (DWORD)LOAD_PROC(hlibc, "clock_gettime") - baselibc;

	libs->linLib.librtBase = baselibrt;
	api->functions.linFunc.librt._shm_open = (DWORD)LOAD_PROC(hlibrt, "shm_open") - baselibrt;
	api->functions.linFunc.librt._shm_unlink = (DWORD)LOAD_PROC(hlibrt, "shm_unlink") - baselibrt;

	libs->linLib.libpthreadBase = baselibpthread;
	api->functions.linFunc.libpthread._yieldExecution = (DWORD)LOAD_PROC(hlibpthread, "pthread_yield") - baselibpthread;
	api->functions.linFunc.libpthread._sem_init = (DWORD)LOAD_PROC(hlibpthread, "sem_init") - baselibpthread;
	api->functions.linFunc.libpthread._sem_wait = (DWORD)LOAD_PROC(hlibpthread, "sem_wait") - baselibpthread;
	api->functions.linFunc.libpthread._sem_timedwait = (DWORD)LOAD_PROC(hlibpthread, "sem_timedwait") - baselibpthread;
	api->functions.linFunc.libpthread._sem_post = (DWORD)LOAD_PROC(hlibpthread, "sem_post") - baselibpthread;
	api->functions.linFunc.libpthread._sem_destroy = (DWORD)LOAD_PROC(hlibpthread, "sem_destroy") - baselibpthread;
	api->functions.linFunc.libpthread._sem_getvalue = (DWORD)LOAD_PROC(hlibpthread, "sem_getvalue") - baselibpthread;

	return true;
}

#endif

```

`wrapper.setup/Setup.Windows.cpp`:

```cpp
#ifndef __linux__

#include "../CommonCrossPlatform/Common.h"
#include "Wrapper.Setup.h"

extern "C" bool InitWrapperOffsets(ext::LibraryLayout *libs, revwrapper::WrapperImports *api) {

	LIB_T hNtDll = GET_LIB_HANDLER(L"ntdll.dll");
	DWORD baseNtDll = GET_LIB_BASE(hNtDll);

	if (!hNtDll) {
		return false;
	}

	libs->winLib.ntdllBase = baseNtDll;

	api->libraries = libs;

	api->functions.winFunc.ntdll._virtualAlloc = (DWORD)LOAD_PROC(hNtDll, "NtAllocateVirtualMemory") - baseNtDll;
	api->functions.winFunc.ntdll._virtualFree = (DWORD)LOAD_PROC(hNtDll, "NtFreeVirtualMemory") - baseNtDll;
	api->functions.winFunc.ntdll._mapMemory = (DWORD)LOAD_PROC(hNtDll, "NtMapViewOfSection") - baseNtDll;
	api->functions.winFunc.ntdll._flushMemoryCache = (DWORD)LOAD_PROC(hNtDll, "RtlFlushSecureMemoryCache") - baseNtDll;
	api->functions.winFunc.ntdll._terminateProcess = (DWORD)LOAD_PROC(hNtDll, "NtTerminateProcess") - baseNtDll;
	api->functions.winFunc.ntdll._writeFile = (DWORD)LOAD_PROC(hNtDll, "NtWriteFile") - baseNtDll;
	api->functions.winFunc.ntdll._waitForSingleObject = (DWORD)LOAD_PROC(hNtDll, "NtWaitForSingleObject") - baseNtDll;
	api->functions.winFunc.ntdll._systemError = (DWORD)LOAD_PROC(hNtDll, "RtlNtStatusToDosError") - baseNtDll;
	api->functions.winFunc.ntdll._formatPrint = (DWORD)LOAD_PROC(hNtDll, "_vsnprintf_s") - baseNtDll;
	api->functions.winFunc.ntdll._ntYieldExecution = (DWORD)LOAD_PROC(hNtDll, "NtYieldExecution") - baseNtDll;
	api->functions.winFunc.ntdll._flushInstructionCache = (DWORD)LOAD_PROC(hNtDll, "NtFlushInstructionCache") - baseNtDll;
	api->functions.winFunc.ntdll._createEvent = (DWORD)LOAD_PROC(hNtDll, "NtCreateEvent") - baseNtDll;
	api->functions.winFunc.ntdll._setEvent = (DWORD)LOAD_PROC(hNtDll, "NtSetEvent") - baseNtDll;

	return true;
}


#endif


```

`wrapper.setup/Wrapper.Setup.h`:

```h
#ifndef _WRAPPER_SETUP_H_
#define _WRAPPER_SETUP_H_

#include "../revtracer-wrapper/RevtracerWrapper.h"

extern "C" bool InitWrapperOffsets(ext::LibraryLayout *libs, revwrapper::WrapperImports *api);

#endif

```

`wrapper.setup/wrapper.setup.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F4898816-F6BE-4EE3-87F2-CE011A8302E6}</ProjectGuid>
    <RootNamespace>wrappersetup</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Setup.Linux.cpp" />
    <ClCompile Include="Setup.Windows.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Wrapper.Setup.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```