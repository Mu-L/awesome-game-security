Project Path: arc_janisslsm_ida-ps4-helper_1d8j0iqr

Source Tree:

```txt
arc_janisslsm_ida-ps4-helper_1d8j0iqr
├── 3rd_party
│   └── pybind11
├── CMakeLists.txt
├── CMakeSettings.json
├── README.md
└── src
    ├── README.md
    ├── extension.cpp
    ├── extension.h
    ├── idasdk.h
    ├── mymodule.py
    └── plugin.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.12 FATAL_ERROR)

project(ps4_helper)

# Specify the C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

if(MSVC)
    # Disable optimization for MSVC
    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "/Od /Zi /DNDEBUG")
else()
    # Disable optimization for GCC and LLVM/Clang
    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O0 -g -DNDEBUG")
endif()

# Find the Python interpreter and development components
find_package(Python COMPONENTS Interpreter Development REQUIRED) #find_package(Python 3.11 COMPONENTS ...)

# Check if Python_LIBRARIES is set and valid
if(NOT Python_LIBRARIES)
    message(FATAL_ERROR "Python libraries not found.")
endif()

# On Windows, always link against python3.lib
# (count on IDAPython/idapyswitch to pick the right Python version)
include($ENV{IDASDK}/ida-cmake/common.cmake)

if (__NT__)
    # Link to Python.lib (it will forward to the proper Python3x.lib/.dll)
    string(REGEX REPLACE "python3([0-9]+)\\.lib" "python3.lib" PYTHON_LIB_DIR "${Python_LIBRARIES}")
endif()

include_directories(${Python_INCLUDE_DIRS})

# Refer to pybind11
add_subdirectory(3rd_party/pybind11 ${CMAKE_CURRENT_BINARY_DIR}/pybind11_build)

set(PLUGIN_NAME           ps4_helper)
set(PLUGIN_SOURCES        src/plugin.cpp src/extension.cpp src/extension.h src/idasdk.h)
set(PLUGIN_LINK_LIBRARIES pybind11::embed ${PYTHON_LIB_DIR})

generate()

```

`CMakeSettings.json`:

```json
{
  "configurations": [
    {
      "name": "x64-RelWithDebInfo",
      "generator": "Ninja",
      "configurationType": "RelWithDebInfo",
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "variables": [
        {
          "name": "EA64",
          "value": "True",
          "type": "BOOL"
        }
      ]
    }
  ]
}
```

`README.md`:

```md
# Archival notice
Archived as a better method has been figured out and is apart of [ps4-module-loader](https://github.com/SocraticBliss/ps4_module_loader) now

# IDA PS4 Helper

This is a helper plugin intended for [ps4-module-loader](https://github.com/SocraticBliss/ps4_module_loader)

# Building

You'll need to set IDASDK in environment variables before running these commands and clone [ida-cmake](https://github.com/allthingsida/ida-cmake) into the idasdk folder. This is for IDA 9.0 specifically, you might have to adapt these commands for older versions.
```
cmake -B build -DEA64=1 -DCMAKE_BUILD_TYPE=RelWithDebInfo  .
cmake --build .
```

# Credits
[allthingsida](https://github.com/allthingsida/allthingsida/) for the [base plugin](https://github.com/allthingsida/allthingsida/) to add functions to IDAPython API via C++.

```

`src/README.md`:

```md
# python_ext

This example shows how to extend Python/IDAPython from your plugin using [pybind11](https://github.com/pybind/pybind11).
It also illustrates how to interface with Python from C++.

Please watch the explanation [video here](https://www.youtube.com/watch?v=jiuF8d8FKO4).

Some important caveats:

- IDA will always initialize IDAPython first on start but it won't fully be initialized yet
- We wait for the `HT_UI`/`ui_initing_database` event and then we extend Python
- When we register our extensions, we pin this plugin DLL so that it won't be unloaded before Python
  - This prevents a crash if someone was holding a reference to our extension methods, classes or objects

- This plugin has only been tested on Windows, with Python 3.11
  - Please feel free to test and make a PR for other platforms

```

`src/extension.cpp`:

```cpp
#include <algorithm>
#include <vector>
#include <string>
#include <functional>

#include "idasdk.h"

static void c_import_module(const char* module, const char* windir, uval_t modnode, const char* ostype)
{
    import_module(module, windir, modnode, nullptr, ostype);
}

namespace py = pybind11;
static std::vector<std::function<void(py::object&)>> EXTENSION_TABLE =
{
    [](auto& obj) 
    { 
        obj.attr("import_module") = py::cpp_function(&c_import_module);
    },
};

void register_extensions()
{
    // Acquire the GIL before working with Python.
    py::gil_scoped_acquire acquire;
    py::module_ idaapi_module = py::module_::import(PY_MODULE_NAME);

    // Check if 'ext' exists in idaapi
    py::object ext;
    if (py::hasattr(idaapi_module, PY_EXT_NAME))
    {
        ext = idaapi_module.attr(PY_EXT_NAME);
    }
    else
    {
        // Use idaapi's special object_t class to create a new object
        ext = py::eval("idaapi.object_t()");
        idaapi_module.add_object(PY_EXT_NAME, ext);
    }

    // Alternatively, to import the builtins module (global scope), just pass in "builtins"
    py::module_ builtins = py::module_::import("builtins");

    // Bind all extensions
    for (auto& binding : EXTENSION_TABLE)
        binding(ext);
}
//! EXTENSIONS END

```

`src/extension.h`:

```h
#pragma once

void register_extensions();


```

`src/idasdk.h`:

```h
#pragma once

// Disable warnings on Windows
#ifdef __NT__
    #pragma warning(push)
    #pragma warning(disable: 4267 4146 4244)
#endif

#include <pybind11/pybind11.h>
#include <pybind11/embed.h>

#include <pro.h>
#include <ida.hpp>
#include <prodir.h>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>

#ifdef __NT__
    #pragma warning(pop)
    #include <Windows.h>

    #ifdef _DEBUG
        #error "Cannot build in Debug mode. Build with RelWithDebInfo or Release."
    #endif
#else
    #warning "This plugin is only tested on Windows."
#endif

// Plugin suffix
#ifdef __EA64__
#  define PLG_SUFFIX "64"
#else
#  define PLG_SUFFIX ""
#endif

// Extensions namespace
#define PY_EXT_NAME "ext"

// Python parent module name
#define PY_MODULE_NAME "idaapi"


```

`src/mymodule.py`:

```py
import idaapi

class MyObject:
    def __init__(self, a, b):
        self.a = a
        self.b = b
        self.o = idaapi.object_t(a=a, b=b)

    def dothis(self, str_arg: str, int_arg1: int, int_arg2: int):
        print(f"String argument: {str_arg}")
        print(f"Integer arguments: {int_arg1}, {int_arg2}")
        return f"Result from dothis(a={self.a})"

    def get_dict(self):
        return {"key1": "value1", "key2": "value2", "key3": "value3"}

```

`src/plugin.cpp`:

```cpp
#include "idasdk.h"
#include "extension.h"

class python_ext_plg_t : public plugmod_t, public event_listener_t
{
public:
    python_ext_plg_t() 
    {
        hook_event_listener(HT_UI, this);
    }

    ssize_t idaapi on_event(ssize_t code, va_list va) override
    {
        if (code == ui_initing_database)
        {
#ifdef __NT__
            LoadLibraryA("python_ext" PLG_SUFFIX);
#else
            dlopen("python_ext" PLG_SUFFIX, RTLD_NOLOAD | RTLD_LAZY);
#endif
            register_extensions();
            remove_event_listener(this);
        }
        return 0;
    }

    bool idaapi run(size_t) override 
    { 
        return true; 
    }

    ~python_ext_plg_t() override 
    {
        unhook_event_listener(HT_UI, this);
    }
};

//--------------------------------------------------------------------------
plugin_t PLUGIN = 
{
    IDP_INTERFACE_VERSION,
    PLUGIN_MULTI | PLUGIN_FIX /* | PLUGIN_HIDE*/,// Plugin flags
    []()->plugmod_t* { return new python_ext_plg_t(); },
    nullptr,                   // Terminate function
    nullptr,                   // Run function
    "Python extension plugin for PS4 module loader", // Long comment about the plugin
    "",                       // Multiline help about the plugin
    "ps4_helper",             // The preferred short name of the plugin
    "Ctrl-4"                  // The preferred hotkey to run the plugin
};

```