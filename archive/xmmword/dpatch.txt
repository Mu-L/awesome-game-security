Project Path: arc_xmmword_dpatch_xlk4fd9g

Source Tree:

```txt
arc_xmmword_dpatch_xlk4fd9g
â”œâ”€â”€ README.md
â”œâ”€â”€ bin
â”‚   â””â”€â”€ dpatchdriver.ko
â”œâ”€â”€ build.sh
â””â”€â”€ src
    â”œâ”€â”€ Makefile
    â”œâ”€â”€ dpatch.c
    â”œâ”€â”€ dpatch.h
    â”œâ”€â”€ kstatus.h
    â””â”€â”€ main.c

```

`README.md`:

```md
# dpatch
An x64 PoC Linux kernel driver that hooks system calls via patching the system call dispatcher.

<div align="center">
    <img src="https://user-images.githubusercontent.com/105472509/195727127-49de8c41-5af5-4b9a-af33-028735e21c98.PNG" width="700px"><br>
</div>

## Description
`dpatch` is a PoC kernel driver which patches the system call dispatcher for x64 Linux. It does this by first making a mutable/writeable copy of the 
system call table, overwriting the function pointers in that table with the function pointers that point to the hook functions, and then patching the first several bytes of the dispatcher to make it jump to a custom system call handler. The custom handler will then index and invoke system calls (or hooks, if the function pointer was overwritten) from the copied (writeable) table.

### Features
- Linux 5.15 - 6.0 Support
- Patches kernel system call dispatcher
- `sys_call_table` isn't touched or modified at all
- Undetected by most, if not all public usermode/kernelmode rootkit scanners

### Bugs
- Decent chance of crashing when the driver gets unloaded (working on fixing this/reducing the chance of crashes) 

### Built with
- C

## Getting started
### Compiling
To compile `dpatch`, simply execute the following script:
- `./build.sh`

### Usage
- `insmod dpatchdriver.ko`

## Credits
```
https://github.com/xmmword
```
### Contributions ðŸŽ‰
###### All contributions are accepted, simply open an Issue / Pull request.

```

`build.sh`:

```sh
cd src
make

find . -name "*.o" -type f -delete
find . -name "*.cmd" -type f -delete
find . -name "*.mod" -type f -delete
find . -name "*.o.d" -type f -delete
find . -name "*.mod.o" -type f -delete
find . -name "*.mod.c" -type f -delete
find . -name "*.order" -type f -delete 
find . -name "*.symvers" -type f -delete

mv dpatchdriver.ko ..
cd ..
```

`src/Makefile`:

```
obj-m += dpatchdriver.o
dpatchdriver-objs := main.o dpatch.o
ccflags-y := -std=gnu99 -Wno-declaration-after-statement -Wframe-larger-than=1596

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

`src/dpatch.c`:

```c
/*
 * Copyright (C) 2022 xmmword
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include "dpatch.h"
#include "kstatus.h"


/*
    *    src/dpatch.c
    *    Date: 10/13/22
    *    Author: @xmmword
*/


dpatch_ctx_t dpatch_ctx = {0}; /* Structure containing important data related to the current dpatch context. */

EXPORT_SYMBOL(dpatch_ctx); /* Exporting [dpatch_ctx] to make it accessible to 'main.c'. */

/**
 * @brief Writes data to the 'cr0' register.
 * @param val The data.
 */

void write_to_cr0(unsigned long val) {
  asm volatile("mov %0, %%cr0":"+r"(val), "+m"((unsigned long){0}));
}

/**
 * @brief Enables memory protections.
 */

void enable_memory_protection(void) {
  write_to_cr0(read_cr0());
}

/**
 * @brief Disables memory protections.
 */

void disable_memory_protection(void) {
  write_to_cr0((read_cr0() & ~0x00010000));
}

/**
 * @brief Outputs a formatted log.
 * @param message The message that will be outputted.
 */

void __visible dpatch_kern_log(const char *message, ...) {
  va_list arguments = {0};
  char buffer[BUFSIZ] = {0};

  snprintf(buffer, sizeof(buffer), "[dpatch]: %s\n", message);
  va_start(arguments, buffer);

  vprintk(buffer, arguments);
  va_end(arguments);
}

/**
 * @brief Resolves the address of a given symbol.
 * @param symbol The name of the symbol.
 * @returns The address of the symbol.
 */

uintptr_t return_symbol_address(const char *symbol) {
  uintptr_t address = 0;

  struct kprobe probe = {
    .symbol_name = (char *)symbol
  };

  if (register_kprobe(&probe) < 0)
    return 0;

  address = (uintptr_t)probe.addr;

  unregister_kprobe(&probe);
  return address;
}

/**
 * @brief Returns a mutable/patchable copy of the system call table.
 * @returns A copy of the system call table.
 */

sys_call_ptr_t *return_syscall_table(void) {
  sys_call_ptr_t *syscall_table = NULL, *resolved_syscall_table = (sys_call_ptr_t *)dpatch_ctx.kallsyms_lookup_name("sys_call_table");
  if (!resolved_syscall_table)
    return NULL;

  if(!(syscall_table = vmalloc((sizeof(sys_call_ptr_t) * NR_syscalls))))
    return NULL;

  memcpy(syscall_table, resolved_syscall_table, (sizeof(sys_call_ptr_t) * NR_syscalls));
  return syscall_table;
}

/**
 * @brief Returns a function pointer associated with a given system call number within the original system call table.
 * @param entry The system call table index.
 * @returns The function pointer associated with the index/system call number.
 */

sys_call_ptr_t return_syscall_table_ptr(const int entry) {
  if (entry < 0 || entry > NR_syscalls)
    return NULL;

  sys_call_ptr_t *original_syscall_table = (sys_call_ptr_t *)dpatch_ctx.kallsyms_lookup_name("sys_call_table");
  if (!original_syscall_table)
    return NULL;

  return original_syscall_table[entry];
}

/**
 * @brief Installs a hook within a given system call table entry.
 * @param hook The pointer to the hook function.
 * @param entry The system call table index.
 * @returns True if the system call could be hooked, false if otherwise.
 */

bool install_table_hook(void *hook, const int entry) {
  if (entry < 0 || entry > NR_syscalls)
    return false;

  dpatch_ctx.syscall_table[entry] = hook;
  return true;
}

/**
 * @brief Uninstalls a hook within a given system call table entry.
 * @param entry The system call table index.
 * @returns True if the system call could be unhooked, false if otherwise.
 */

bool uninstall_table_hook(const int entry) {
  if (entry < 0 || entry > NR_syscalls)
    return false;

  sys_call_ptr_t *original_syscall_table = (sys_call_ptr_t *)dpatch_ctx.kallsyms_lookup_name("sys_call_table");
  if (!original_syscall_table)
    return false;

  dpatch_ctx.syscall_table[entry] = original_syscall_table[entry];
  return true;
}

/**
 * @brief Dispatches a system call for x86-32.
 * @param regs A structure containing register states.
 * @param nr The system call number.
 * @returns True if the system call could be dispatched, false if otherwise.
 */

bool dispatch_syscall_x32(struct pt_regs *regs, int nr) {
  unsigned int temp = (nr - __X32_SYSCALL_BIT);

  if (IS_ENABLED(CONFIG_X86_X32_ABI) && likely(temp < X32_NR_syscalls)) {
    regs->ax = dpatch_ctx.syscall_table[(temp = array_index_nospec(temp, X32_NR_syscalls))](regs);

    return true;
  }

  return false;
}

/**
 * @brief Dispatches a system call for x86-64.
 * @param regs A structure containing register states.
 * @param nr The system call number.
 * @returns True if the system call could be dispatched, false if otherwise.
 */

bool dispatch_syscall_x64(struct pt_regs *regs, int nr) {
  unsigned int entry = nr;

  if (likely(entry < NR_syscalls)) {
    regs->ax = dpatch_ctx.syscall_table[(entry = array_index_nospec(entry, NR_syscalls))](regs);

    return true;
  }

  return false;
}

/**
 * @brief The hook for the system call dispatcher.
 * @param regs A structure containing register states.
 * @param nr The system call number.
 */

void hooked_syscall_dispatcher(struct pt_regs *regs, int nr) {
  nr = dpatch_ctx.syscall_enter_from_user_mode(regs, nr);

  instrumentation_begin();

  if (!dispatch_syscall_x64(regs, nr) && !dispatch_syscall_x32(regs, nr) && nr != -1)
    regs->ax = dpatch_ctx.__x64_sys_ni_syscall(regs);

  instrumentation_end();
  dpatch_ctx.syscall_exit_to_user_mode(regs);
}

/**
 * @brief Patches the bytes of the system call dispatcher.
 * @param hook The pointer to the system call dispatcher hook.
 * @param syscall_dispatcher The pointer to the system call dispatcher.
 */

int dpatch_hook_dispatcher(void *hook, void *syscall_dispatcher) {
  if (!syscall_dispatcher)
    return DPATCH_HOOK_FAILURE;

  disable_memory_protection();
  memcpy(dpatch_ctx.bytes, syscall_dispatcher, sizeof(*(uint64_t *)syscall_dispatcher));

  const uint32_t val = ((uint8_t *)hook - (uint8_t *)syscall_dispatcher - 5);

  const jmp_hook_t jmp_hook = {
    {0xe9, (val >> 0), (val >> 8), (val >> 16), (val >> 24)}
  };

  *(uint64_t *)syscall_dispatcher = jmp_hook.tmp;
  enable_memory_protection();

  return DPATCH_HOOK_SUCCESS;
}
```

`src/dpatch.h`:

```h
/*
 * Copyright (C) 2022 xmmword
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifndef __DPATCH_H
#define __DPATCH_H

#include <asm/ptrace.h>
#include <asm/unistd.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <asm/syscall.h>
#include <linux/nospec.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/printk.h>
#include <linux/kprobes.h>
#include <linux/uaccess.h>
#include <linux/compiler.h>
#include <linux/irqflags.h>
#include <linux/thread_info.h>
#include <linux/stop_machine.h>
#include <linux/entry-common.h>
#include <asm-generic/rwonce.h>
#include <asm/syscall_wrapper.h>
#include <linux/instrumentation.h>
#include <linux/randomize_kstack.h>

#define BUFSIZ 1024 /* Maximum size of buffer. */


/*
    *    src/dpatch.h
    *    Date: 10/13/22
    *    Author: @xmmword
*/


typedef uintptr_t (*kallsyms_ptr_t)(const char *name);

typedef long (*sys_ni_ptr_t)(const struct pt_regs *regs);
typedef long (*syscall_enter_usermode_ptr_t)(struct pt_regs *regs, long syscall);

typedef void (*syscall_exit_usermode_ptr_t)(struct pt_regs *regs);
typedef void (*syscall_dispatcher_ptr_t)(struct pt_regs *regs, int nr);

/* Structure containing JMP-hook data. */
typedef union _jmp_hook {
  uint8_t instr[8]; /* Overwritten instructions. */
  uint64_t tmp; /* Temporary value. */
} jmp_hook_t;

/* Structure containing function pointers and other important data related to the current dpatch context. */
typedef struct _dpatch_ctx {
  uint8_t bytes[8]; /* Original function bytes. (For unpatching..) */
  sys_call_ptr_t *syscall_table; /* sys_call_table pointer. */

  sys_ni_ptr_t __x64_sys_ni_syscall; /* Cached __x64_sys_ni_syscall function pointer. */
  kallsyms_ptr_t kallsyms_lookup_name; /* Cached kallsyms_lookup_name function pointer. */

  syscall_dispatcher_ptr_t do_syscall_64; /* Pointer to the x64 system call dispatcher. */

  syscall_exit_usermode_ptr_t syscall_exit_to_user_mode; /* Cached syscall_exit_to_user_mode function pointer. */
  syscall_enter_usermode_ptr_t syscall_enter_from_user_mode; /* Cached syscall_exit_from_user_mode function pointer. */
} dpatch_ctx_t;

void __visible dpatch_kern_log(const char *message, ...);

inline void write_to_cr0(unsigned long val);
uintptr_t return_symbol_address(const char *symbol);

void enable_memory_protection(void);
void disable_memory_protection(void);

bool uninstall_table_hook(const int entry);
bool install_table_hook(void *hook, const int entry);

sys_call_ptr_t *return_syscall_table(void);
sys_call_ptr_t return_syscall_table_ptr(const int entry);

void hooked_syscall_dispatcher(struct pt_regs *regs, int nr);
int dpatch_hook_dispatcher(void *hook, void *syscall_dispatcher);

#endif
```

`src/kstatus.h`:

```h
/*
 * Copyright (C) 2022 xmmword
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifndef __KSTATUS_H
#define __KSTATUS_H


/*
    *    src/kstatus.h
    *    Date: 10/13/22
    *    Author: @xmmword
*/


#define KERN_SUCCESS 0
#define KERN_FAILURE 1

#define DPATCH_HOOK_SUCCESS 0
#define DPATCH_HOOK_FAILURE -1

#endif
```

`src/main.c`:

```c
/*
 * Copyright (C) 2022 xmmword
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <uapi/linux/utsname.h>

#include "dpatch.h"
#include "kstatus.h"

MODULE_LICENSE("GPL");


/*
    *    src/main.c
    *    Date: 10/13/22
    *    Author: @xmmword
*/


extern dpatch_ctx_t dpatch_ctx; /* Structure containing important data related to the current dpatch context. */

/**
 * @brief A sample 'sys_uname' hook for demonstration.
 * @param buf A structure containing information about the machine/platform.
 * @returns 0 on success, -1 on failure.
 */

int hooked_uname(struct new_utsname *buf) {
  dpatch_kern_log("[sys_uname] hook called!");

  int (*original_uname)(struct new_utsname *buf) = (void *)return_syscall_table_ptr(__NR_uname);
  if (!original_uname)
    return -1;

  return original_uname(buf);
}

/**
 * @brief Entry point for dpatch.
 * @returns KERN_SUCCESS on success, KERN_FAILURE on failure.
 */

static int __init dpatch_main(void) {
  dpatch_kern_log("dpatch driver has been loaded!");

  dpatch_ctx.kallsyms_lookup_name = (kallsyms_ptr_t)return_symbol_address("kallsyms_lookup_name");
  if (!dpatch_ctx.kallsyms_lookup_name)
    return KERN_FAILURE;

  dpatch_kern_log("Resolved [kallsyms_lookup_name] @ 0x%lx", (uintptr_t)dpatch_ctx.kallsyms_lookup_name);

  if (!(dpatch_ctx.do_syscall_64 = (syscall_dispatcher_ptr_t)dpatch_ctx.kallsyms_lookup_name("do_syscall_64")))
    return KERN_FAILURE;

  dpatch_kern_log("Resolved [do_syscall_64] @ 0x%lx", (uintptr_t)dpatch_ctx.do_syscall_64);

  if (!(dpatch_ctx.syscall_enter_from_user_mode = (syscall_enter_usermode_ptr_t)dpatch_ctx.kallsyms_lookup_name("syscall_enter_from_user_mode")))
    return KERN_FAILURE;

  dpatch_kern_log("Resolved [syscall_enter_from_user_mode] @ 0x%lx", (uintptr_t)dpatch_ctx.syscall_enter_from_user_mode);

  if (!(dpatch_ctx.__x64_sys_ni_syscall = (sys_ni_ptr_t)dpatch_ctx.kallsyms_lookup_name("__x64_sys_ni_syscall")))
    return KERN_FAILURE;

  dpatch_kern_log("Resolved [__x64_sys_ni_syscall] @ 0x%lx", (uintptr_t)dpatch_ctx.__x64_sys_ni_syscall);

  if (!(dpatch_ctx.syscall_exit_to_user_mode = (syscall_exit_usermode_ptr_t)dpatch_ctx.kallsyms_lookup_name("syscall_exit_to_user_mode")))
    return KERN_FAILURE;

  dpatch_kern_log("Resolved [syscall_exit_to_user_mode] @ 0x%lx", (uintptr_t)dpatch_ctx.syscall_exit_to_user_mode);

  if (!(dpatch_ctx.syscall_table = return_syscall_table())) {
    dpatch_kern_log("Failed to copy [sys_call_table]!");

    return KERN_FAILURE;
  }

  dpatch_kern_log("Copied the contents of [sys_call_table]");
  dpatch_kern_log("Overwriting [sys_call_table] addresses...");

  if (!install_table_hook(hooked_uname, __NR_uname)) {
    dpatch_kern_log("Failed to overwrite [sys_uname] address!");

    return KERN_FAILURE;
  }

  dpatch_kern_log("Successfully overwritten [sys_uname] address!");

  if (dpatch_hook_dispatcher(hooked_syscall_dispatcher, dpatch_ctx.do_syscall_64) == DPATCH_HOOK_FAILURE) {
    dpatch_kern_log("Failed to patch [do_syscall_64]");

    return KERN_FAILURE;
  }

  dpatch_kern_log("Successfully patched [do_syscall_64]");
  return KERN_SUCCESS;
}

/**
 * @brief Exit point for dpatch.
 */

static void __exit dpatch_exit(void) {
  if (!uninstall_table_hook(__NR_uname))
    return;

  dpatch_kern_log("Successfully unhooked [sys_uname]");

  /*
    Note: After several tests, I have been able to reduce the amount of crashes
          that occur via 'unpatching' the system call dispatcher, but there is
          NO guarantee that your system will be in a stable state once the kernel
          driver has been unloaded. You have been warned. */

  /* Please remember, this is just a PoC. */

  disable_memory_protection();
  memcpy(*(uint64_t *)dpatch_ctx.do_syscall_64, dpatch_ctx.bytes, sizeof(*(uint64_t *)dpatch_ctx.bytes));

  enable_memory_protection();
  dpatch_kern_log("dpatch driver has been unloaded!");
}

module_init(dpatch_main); /* Start-up routine. */
module_exit(dpatch_exit); /* Exit routine. */
```