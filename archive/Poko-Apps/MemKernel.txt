Project Path: arc_Poko-Apps_MemKernel_08px8kjb

Source Tree:

```txt
arc_Poko-Apps_MemKernel_08px8kjb
├── LICENSE
├── README.md
├── kernel
│   ├── Kconfig
│   ├── Makefile
│   ├── comm.h
│   ├── entry.c
│   ├── memory.c
│   ├── memory.h
│   ├── process.c
│   ├── process.h
│   └── setup.sh
└── user
    ├── driver.hpp
    └── main.cpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 JiangNight
Copyright Partially (c) 2024 Poko

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# MemKernel
MemKernel is a kernel driver for Android. Originally created by [Jiang-Night](https://github.com/Jiang-Night/Kernel_driver_hack), it has been modified and fixed according to my personal needs. This driver reads and writes physical memory of the target process, effectively bypassing anti-cheats.

## Integration
2 ways you can integrate this driver to your kernel source (for compilation) using setup script:
* __Y__ : To build the driver as part of the kernel. (statically build within kernel).
```
curl -LSs "https://raw.githubusercontent.com/Poko-Apps/MemKernel/main/kernel/setup.sh" | bash -s Y
```
* __M__ : To build the driver as lkm (loadable kernel module).
```
curl -LSs "https://raw.githubusercontent.com/Poko-Apps/MemKernel/main/kernel/setup.sh" | bash -s M
```

**TIP** : By default the setup script generates random name for the driver (/dev/*randomname*) and as well as for the lkm (*randomname*_memk.ko), this is done to bypass existency check done via [*access(2)*](https://man7.org/linux/man-pages/man2/access.2.html) syscall. But you can override this behaviour by providing 2nd argument to the setup script like this:

```curl -LSs "https://raw.githubusercontent.com/Poko-Apps/MemKernel/main/kernel/setup.sh" | bash -s M myname```

```

`kernel/Kconfig`:

```
config MEMKERNEL
    tristate "Physical Mem Operation Driver"
    default y
    help
      Read-Write physical memory of target process.
      Also retrieves base address of any library within any target process.
      Y to statically build within kernel.
      M to build as loadable kernel module (lkm).

```

`kernel/Makefile`:

```
ifneq ($(KERNELRELEASE),)
# kbuild part of makefile
	obj-$(CONFIG_MEMKERNEL)  := memkernel.o
	memkernel-y := memory.o process.o entry.o
else
# normal makefile
default:
	# Assume kernel source is at KDIR or fail
	ifeq ($(KDIR),)
		$(error KDIR is not set. Please define KDIR to point to the kernel source directory.)
	endif
	make -C $(KDIR) M=$(PWD) modules
clean:
	rm -f *.ko *.o *.mod.o *.mod.c *.symvers .*.cmd
endif
```

`kernel/comm.h`:

```h
#ifndef MEMKERNEL_COMM_H
#define MEMKERNEL_COMM_H

struct CopyMemory
{
	pid_t pid;
	uintptr_t addr;
	void *buffer;
	size_t size;
};

struct ModuleBase
{
	pid_t pid;
	char *name;
	uintptr_t base;
};

enum Operations
{
	OP_READ_MEM = 0x801,
	OP_WRITE_MEM = 0x802,
	OP_MODULE_BASE = 0x803,
};

#endif
```

`kernel/entry.c`:

```c
// MIT License
/*
 * Memory Operation driver for Linux Android
 *
 * Original author:  Jiang-Night
 * Current maintainer: Poko
 *
*/

#include <linux/module.h>
#include <linux/fs.h>
#include <linux/miscdevice.h>
#include <linux/uaccess.h>
#include <linux/mutex.h>
#include "comm.h"
#include "memory.h"
#include "process.h"

#define DEVICE_NAME "phmeop"

static DEFINE_MUTEX(driver_mutex);


static int dispatch_open(struct inode *node, struct file *file) {
	if (!mutex_trylock(&driver_mutex))
		return -EBUSY;
	return 0;
}

static int dispatch_close(struct inode *node, struct file *file) {
	mutex_unlock(&driver_mutex);
	return 0;
}

static long dispatch_ioctl(struct file *const file, unsigned int const cmd, unsigned long const arg)
{
	struct CopyMemory cm;
	struct ModuleBase mb;
	char name[0x100] = {0};

	switch (cmd)
	{
	case OP_READ_MEM:
	{
		if (copy_from_user(&cm, (void __user *)arg, sizeof(cm)) != 0) {
			return -1;
		}
		return readwrite_process_memory(cm.pid, cm.addr, cm.buffer, cm.size, false);
	}
	case OP_WRITE_MEM:
	{
		if (copy_from_user(&cm, (void __user *)arg, sizeof(cm)) != 0) {
			return -1;
		}
		return readwrite_process_memory(cm.pid, cm.addr, cm.buffer, cm.size, true);
	}
	case OP_MODULE_BASE:
	{
		if (copy_from_user(&mb, (void __user *)arg, sizeof(mb)) != 0 || copy_from_user(name, (void __user *)mb.name, sizeof(name) - 1) != 0) {
			return -1;
		}
		mb.base = get_module_base(mb.pid, name);
		if (copy_to_user((void __user *)arg, &mb, sizeof(mb)) != 0) {
			return -1;
		}
		break;
	}
	default:
		break;
	}
	return 0;
}

static struct file_operations dispatch_functions = {
	.owner = THIS_MODULE,
	.open = dispatch_open,
	.release = dispatch_close,
	.unlocked_ioctl = dispatch_ioctl,
};

static struct miscdevice misc = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = DEVICE_NAME,
	.fops = &dispatch_functions,
};

int __init memkernel_entry(void)
{
	int ret;
	printk("[+] memkernel_entry");
	ret = misc_register(&misc);
	return ret;
}

void __exit memkernel_unload(void)
{
	printk("[+] memkernel_unload");
	misc_deregister(&misc);
}

module_init(memkernel_entry);
module_exit(memkernel_unload);

MODULE_DESCRIPTION("Linux Kernel.");
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Linux");

```

`kernel/memory.c`:

```c
#include "memory.h"
#include <linux/fs.h>
#include <linux/io.h>
#include <linux/mm.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>
#include <linux/kernel.h>

#include <asm/cpu.h>
#include <asm/io.h>
#include <asm/page.h>
#include <asm/pgtable.h>

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
#include <linux/sched/mm.h>
#include <linux/sched/task.h>
#endif

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
#include <linux/mmap_lock.h>
#define MM_READ_LOCK(mm) mmap_read_lock(mm);
#define MM_READ_UNLOCK(mm) mmap_read_unlock(mm);
#else
#include <linux/rwsem.h>
#define MM_READ_LOCK(mm) down_read(&(mm)->mmap_sem);
#define MM_READ_UNLOCK(mm) up_read(&(mm)->mmap_sem);
#endif


static phys_addr_t translate_linear_address(struct mm_struct *mm, uintptr_t va)
{
	pgd_t *pgd;
#ifdef __PAGETABLE_P4D_FOLDED
	p4d_t *p4d;
#endif
	pmd_t *pmd;
	pte_t *pte;
	pud_t *pud;

	phys_addr_t page_addr;
	uintptr_t page_offset;

	pgd = pgd_offset(mm, va);
	if (pgd_none(*pgd) || pgd_bad(*pgd)) {
		return 0;
	}
#ifdef __PAGETABLE_P4D_FOLDED
	p4d = p4d_offset(pgd, va);
	if (p4d_none(*p4d) || p4d_bad(*p4d)) {
		return 0;
	}
	pud = pud_offset(p4d, va);
#else
	pud = pud_offset(pgd, va);
#endif
	if (pud_none(*pud) || pud_bad(*pud)) {
		return 0;
	}
	pmd = pmd_offset(pud, va);
	if (pmd_none(*pmd)) {
		return 0;
	}
	pte = pte_offset_kernel(pmd, va);
	if (pte_none(*pte)) {
		return 0;
	}
	if (!pte_present(*pte)) {
		return 0;
	}
	page_addr = (phys_addr_t)(pte_pfn(*pte) << PAGE_SHIFT);
	page_offset = va & (PAGE_SIZE - 1);

	return page_addr + page_offset;
}

#if !defined(ARCH_HAS_VALID_PHYS_ADDR_RANGE) || defined(MODULE)
static inline int memk_valid_phys_addr_range(phys_addr_t addr, size_t size)
{
	return addr + size <= __pa(high_memory);
}
#define IS_VALID_PHYS_ADDR_RANGE(x,y) memk_valid_phys_addr_range(x,y)
#else
#define IS_VALID_PHYS_ADDR_RANGE(x,y) valid_phys_addr_range(x,y)
#endif

static size_t read_physical_address(phys_addr_t pa, void *buffer, size_t size)
{
	void *mapped;

	if (!pfn_valid(__phys_to_pfn(pa))) {
		return 0;
	}
	if (!IS_VALID_PHYS_ADDR_RANGE(pa, size)) {
		return 0;
	}
	mapped = ioremap_cache(pa, size);
	if (!mapped) {
		return 0;
	}
	if (copy_to_user(buffer, mapped, size)) {
		iounmap(mapped);
		return 0;
	}
	iounmap(mapped);
	return size;
}

static size_t write_physical_address(phys_addr_t pa, void *buffer, size_t size)
{
	void *mapped;

	if (!pfn_valid(__phys_to_pfn(pa))) {
		return 0;
	}
	if (!IS_VALID_PHYS_ADDR_RANGE(pa, size)) {
		return 0;
	}
	mapped = ioremap_cache(pa, size);
	if (!mapped) {
		return 0;
	}
	if (copy_from_user(mapped, buffer, size)) {
		iounmap(mapped);
		return 0;
	}
	iounmap(mapped);
	return size;
}

ssize_t readwrite_process_memory(
	pid_t pid,
	uintptr_t addr,
	void *buffer,
	size_t size,
	bool iswrite)
{

	struct task_struct *task;
	struct mm_struct *mm;
	struct pid *pid_struct;
	phys_addr_t pa;
	size_t max_chunk;
	size_t count = 0;

	if (size <= 0 || buffer == NULL) {
		return -1;
	}

	pid_struct = find_get_pid(pid);
	if (!pid_struct) {
		return -1;
	}
	task = get_pid_task(pid_struct, PIDTYPE_PID);
	put_pid(pid_struct);
	if (!task) {
		return -1;
	}
	mm = get_task_mm(task);
	put_task_struct(task);
	if (!mm) {
		return -1;
	}

	MM_READ_LOCK(mm);
	while(size > 0)
	{
		pa = translate_linear_address(mm, addr);
		if (!pa)
			break;

		max_chunk = min(PAGE_SIZE - (addr & (PAGE_SIZE - 1)), min(size, PAGE_SIZE));

		if (iswrite
			? !write_physical_address(pa, buffer, max_chunk)
			: !read_physical_address(pa, buffer, max_chunk))
		{
			break;
		}

		count += max_chunk;
		size -= max_chunk;
		buffer += max_chunk;
		addr += max_chunk;
	}
	MM_READ_UNLOCK(mm);
	mmput(mm);
	return (count > 0 ? count : -1);
}

```

`kernel/memory.h`:

```h
#ifndef MEMKERNEL_MEM_H
#define MEMKERNEL_MEM_H

#include <linux/kernel.h>
#include <linux/sched.h>

ssize_t readwrite_process_memory(pid_t pid, uintptr_t addr, void *buffer, size_t size, bool iswrite);

#endif
```

`kernel/process.c`:

```c
#include "process.h"
#include <linux/sched.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/mm.h>
#include <linux/version.h>

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
#include <linux/sched/mm.h>
#include <linux/sched/task.h>
#endif

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
#include <linux/mmap_lock.h>
#define MM_READ_LOCK(mm) mmap_read_lock(mm);
#define MM_READ_UNLOCK(mm) mmap_read_unlock(mm);
#else
#include <linux/rwsem.h>
#define MM_READ_LOCK(mm) down_read(&(mm)->mmap_sem);
#define MM_READ_UNLOCK(mm) up_read(&(mm)->mmap_sem);
#endif


uintptr_t get_module_base(pid_t pid, char *name)
{
	struct pid *pid_struct;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
	struct vma_iterator vmi;
#endif
	uintptr_t module_base = 0;

	pid_struct = find_get_pid(pid);
	if (!pid_struct) {
		return false;
	}
	task = get_pid_task(pid_struct, PIDTYPE_PID);
	put_pid(pid_struct);
	if (!task) {
		return false;
	}
	mm = get_task_mm(task);
	put_task_struct(task);
	if (!mm) {
		return false;
	}

	MM_READ_LOCK(mm);

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
	vma_iter_init(&vmi, mm, 0);
	for_each_vma(vmi, vma)
#else
	for (vma = mm->mmap; vma; vma = vma->vm_next)
#endif
	{
		char buf[ARC_PATH_MAX];
		char *path_nm = "";

		if (vma->vm_file) {
			path_nm = file_path(vma->vm_file, buf, ARC_PATH_MAX - 1);
			if (!strcmp(kbasename(path_nm), name)) {
				module_base = vma->vm_start;
				break;
			}
		}
	}

	MM_READ_UNLOCK(mm);
	mmput(mm);
	return module_base;
}

```

`kernel/process.h`:

```h
#ifndef MEMKERNEL_PROC_H
#define MEMKERNEL_PROC_H

#include <linux/kernel.h>

#define ARC_PATH_MAX 256

uintptr_t get_module_base(pid_t pid, char *name);

#endif
```

`kernel/setup.sh`:

```sh
#!/bin/sh
# copied from KernelSU repo

set -eu

GKI_ROOT=$(pwd)

display_usage() {
    echo "Usage: $0 [--cleanup | <integration-options>]"
    echo "  --cleanup:              Cleans up previous modifications made by the script."
    echo "  <integration-options>:   Tells us how MemKernel should be integrated into kernel source (Y, M)."
    echo "  <driver-name>:          Optional argument, should be used after <integration-options>. if not mentioned random name will be used."
    echo "  -h, --help:             Displays this usage information."
    echo "  (no args):              Sets up or updates the MemKernel environment to the latest commit (integration as Y)."
}

initialize_variables() {
    if [ -d "$GKI_ROOT/common/drivers" ]; then
         DRIVER_DIR="$GKI_ROOT/common/drivers"
    elif [ -d "$GKI_ROOT/drivers" ]; then
         DRIVER_DIR="$GKI_ROOT/drivers"
    else
        DRIVER_DIR=""
    fi

    DRIVER_MAKEFILE="$DRIVER_DIR/Makefile"
    DRIVER_KCONFIG="$DRIVER_DIR/Kconfig"
}

perform_cleanup() {
    echo "[+] Cleaning up..."
    if [ -n "$DRIVER_DIR" ]; then
        [ -L "$DRIVER_DIR/memkernel" ] && rm "$DRIVER_DIR/memkernel" && echo "[-] Symlink removed."
        grep -q "memkernel" "$DRIVER_MAKEFILE" && sed -i '/memkernel/d' "$DRIVER_MAKEFILE" && echo "[-] Makefile reverted."
        grep -q "drivers/memkernel/Kconfig" "$DRIVER_KCONFIG" && sed -i '/drivers\/memkernel\/Kconfig/d' "$DRIVER_KCONFIG" && echo "[-] Kconfig reverted."
    fi
    [ -d "$GKI_ROOT/MemKernel" ] && rm -rf "$GKI_ROOT/MemKernel" && echo "[-] MemKernel directory deleted."
}

randomize_driver_and_module() {
    local random_name
    if [ -n "${1:-}" ]; then
        random_name="$1"
    else
        random_name=$(tr -dc 'a-z' </dev/urandom | head -c 6)
    fi

    sed -i "s/#define DEVICE_NAME \".*\"/#define DEVICE_NAME \"$random_name\"/" "$GKI_ROOT/MemKernel/kernel/entry.c"
    sed -i "s|#define DEVICE_NAME \"/dev/.*\"|#define DEVICE_NAME \"/dev/$random_name\"|" "$GKI_ROOT/MemKernel/user/driver.hpp"

    if [ "$2" = "M" ]; then
        sed -i "s/memkernel.o/${random_name}_memk.o/" "$GKI_ROOT/MemKernel/kernel/Makefile"
        sed -i "s/memkernel-y/${random_name}_memk-y/" "$GKI_ROOT/MemKernel/kernel/Makefile"
        echo -e "\e[36mModule Name: ${random_name}_memk.ko\e[0m"
    fi

    echo -e "\e[36mDevice Name: $random_name\e[0m"
}

setup_memkernel() {
    if [ -z "$DRIVER_DIR" ]; then
        echo '[ERROR] "drivers/" directory not found.'
        exit 127
    fi
    
    echo "[+] Setting up MemKernel..."
    [ -d "$GKI_ROOT/MemKernel" ] || git clone https://github.com/Poko-Apps/MemKernel && echo "[+] Repository cloned."
    cd "$GKI_ROOT/MemKernel"
    git stash && echo "[-] Stashed current changes."
    git checkout main && git pull && echo "[+] Repository updated."

    if [ "$1" = "M" ]; then
        sed -i 's/default y/default m/' kernel/Kconfig
    elif [ "$1" != "Y" ]; then
        echo "[ERROR] First argument not valid. should be any of these: Y, M"
        exit 128
    fi

    cd "$DRIVER_DIR"
    ln -sf "$(realpath --relative-to="$DRIVER_DIR" "$GKI_ROOT/MemKernel/kernel")" "memkernel" && echo "[+] Symlink created."

    # Add entries in Makefile and Kconfig if not already exists
    grep -q "memkernel" "$DRIVER_MAKEFILE" || printf "\nobj-\$(CONFIG_MEMKERNEL) += memkernel/\n" >> "$DRIVER_MAKEFILE" && echo "[+] Modified Makefile."
    grep -q "source \"drivers/memkernel/Kconfig\"" "$DRIVER_KCONFIG" || sed -i "/endmenu/i\source \"drivers/memkernel/Kconfig\"" "$DRIVER_KCONFIG" && echo "[+] Modified Kconfig."

    if [ "$#" -ge 2 ]; then
        randomize_driver_and_module "$2" "$1"
    else
        randomize_driver_and_module "" "$1"
    fi
    echo '[+] Done.'
}

# Process command-line arguments
if [ "$#" -eq 0 ]; then
    set -- Y
fi

case "$1" in
    -h|--help)
        display_usage
        ;;
    --cleanup)
        initialize_variables
        perform_cleanup
        ;;
    *)
        initialize_variables
        if [ "$#" -eq 0 ]; then
            setup_memkernel Y
        else
            setup_memkernel "$@"
        fi
        ;;
esac

```

`user/driver.hpp`:

```hpp
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <cstring>
#include <cstdio>

#define DEVICE_NAME "/dev/phmeop"

class MemKDriver {
private:
	int fd;
	pid_t pid;

	struct CopyMemory
	{
		pid_t pid;
		uintptr_t addr;
		void *buffer;
		size_t size;
	};

	struct ModuleBase
	{
		pid_t pid;
		char *name;
		uintptr_t base;
	};

	enum Operations {
		OP_READ_MEM = 0x801,
		OP_WRITE_MEM = 0x802,
		OP_MODULE_BASE = 0x803,
	};

public:
	MemKDriver(const char* deviceName) : fd(open(deviceName, O_RDWR)) {
		if (fd == -1) {
			perror("[-] Failed to open driver");
		}
	}

	~MemKDriver() {
		if (fd > 0) {
			close(fd);
		}
	}

	inline void initialize(const pid_t new_pid) {
		pid = new_pid;
	}

	ssize_t read(const uintptr_t addr, void *buffer, const size_t size) const {
		if (!buffer || fd == -1) return -1;

		CopyMemory cm = { pid, addr, buffer, size };
		return ioctl(fd, OP_READ_MEM, &cm);
	}

	ssize_t write(const uintptr_t addr, const void *buffer, const size_t size) const {
		if (!buffer || fd == -1) return -1;

		CopyMemory cm = { pid, addr, const_cast<void *>(buffer), size };
		return ioctl(fd, OP_WRITE_MEM, &cm);
	}

	template <typename T>
	inline T read(const uintptr_t addr) const {
		T result{};
		read(addr, &result, sizeof(T));
		return result;
	}

	template <typename T>
	inline bool write(const uintptr_t addr, const T &value) const {
		return write(addr, &value, sizeof(T)) == sizeof(T);
	}

	inline uintptr_t get_module_base(const char *name) const {
		if (!name || fd == -1) return 0;

		ModuleBase mb = { pid, nullptr, 0 };
		mb.name = const_cast<char *>(name);

		return (ioctl(fd, OP_MODULE_BASE, &mb) == 0) ? mb.base : 0;
	}
};

static MemKDriver *driver = new MemKDriver(DEVICE_NAME);

```

`user/main.cpp`:

```cpp
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include "driver.hpp"

uint64_t get_tick_count64()
{
	struct timespec ts;
	clock_gettime(CLOCK_MONOTONIC, &ts);
	return (ts.tv_sec * 1000 + ts.tv_nsec / (1000 * 1000));
}

pid_t get_name_pid(char *name)
{
	FILE *fp;
	pid_t pid;
	char cmd[0x100] = "pidof ";

	strcat(cmd, name);
	fp = popen(cmd, "r");
	fscanf(fp, "%d", &pid);
	pclose(fp);
	return pid;
}

int main(int argc, char const *argv[])
{

	uintptr_t base = 0;
	uint64_t result = 0;
	char module_name[0x100] = "libunity.so";
	pid_t pid = get_name_pid((char *)"com.tencent.tmgp.sgame");
	printf("pid = %d\n", pid);

	driver->initialize(pid);

	base = driver->get_module_base(module_name);
	printf("base = %lx\n", base);

	{
		size_t number = 1;
		uint64_t now = get_tick_count64();
		for (size_t i = 0; i < number; i++)
		{
			result = driver->read<uint64_t>(base);
		}
		printf("Read %ld times cost = %lfs\n", number,
			   (double)(get_tick_count64() - now) / 1000);
	}
	printf("result = %lx\n", result);

	return 0;
}

```