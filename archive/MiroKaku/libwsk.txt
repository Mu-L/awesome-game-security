Project Path: arc_MiroKaku_libwsk_v3qvtngb

Source Tree:

```txt
arc_MiroKaku_libwsk_v3qvtngb
├── BuildAllTargets.cmd
├── BuildAllTargets.proj
├── Directory.Build.props
├── Directory.Build.targets
├── Directory.Packages.Cpp.props
├── InitializeVisualStudioEnvironment.cmd
├── LICENSE
├── Publish.bat
├── README.md
├── README.zh-CN.md
├── global.json
├── libwsk
│   ├── Precompiled.cpp
│   ├── Precompiled.h
│   ├── berkeley.cpp
│   ├── berkeley.h
│   ├── libwsk.cpp
│   ├── libwsk.h
│   ├── libwsk.vcxproj
│   ├── libwsk.vcxproj.filters
│   ├── socket.cpp
│   └── socket.h
├── libwsk.NuGet
│   ├── Musa.libwsk.nuspec
│   ├── Musa.libwsk.props
│   └── config
│       ├── libwsk.props
│       └── libwsk.targets
├── libwsk.sln
└── libwsk.test
    ├── Program.c
    ├── libwsk.inf
    └── libwsk.test.vcxproj

```

`BuildAllTargets.cmd`:

```cmd
@setlocal
@echo off

rem Change to the current folder.
cd "%~dp0"

rem Remove the output folder for a fresh compile.
rd /s /q Output

rem Initialize Visual Studio environment
call "%~dp0InitializeVisualStudioEnvironment.cmd"

rem Build all targets
MSBuild -binaryLogger:Output\BuildAllTargets.binlog -m BuildAllTargets.proj

@endlocal
```

`BuildAllTargets.proj`:

```proj
<?xml version="1.0" encoding="utf-8"?>
<Project 
  DefaultTargets="Restore;Build"
  xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <SolutionPath>$(MSBuildThisFileDirectory)*.sln</SolutionPath>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="$(SolutionPath)">
      <AdditionalProperties>Configuration=Debug;Platform=x64</AdditionalProperties>   
    </ProjectReference>
    <ProjectReference Include="$(SolutionPath)">
      <AdditionalProperties>Configuration=Release;Platform=x64</AdditionalProperties>   
    </ProjectReference>
    <ProjectReference Include="$(SolutionPath)">
      <AdditionalProperties>Configuration=Debug;Platform=ARM64</AdditionalProperties>   
    </ProjectReference>
    <ProjectReference Include="$(SolutionPath)">
      <AdditionalProperties>Configuration=Release;Platform=ARM64</AdditionalProperties>   
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <!-- <PackagingProjectReference Include="$(MSBuildThisFileDirectory)Mile.Project.Windows\Mile.Project.NuGetPackaging.proj">
      <AdditionalProperties>NuspecFile=$(MSBuildThisFileDirectory)SampleProject\SampleProject.nuspec</AdditionalProperties>   
    </PackagingProjectReference> -->
  </ItemGroup>
  <Target Name="Restore" >
    <MSBuild
      Projects="@(ProjectReference)"
      Targets="Restore"
      StopOnFirstFailure="True"
      Properties="PreferredToolArchitecture=x64" />
    <MSBuild
      Projects="@(PackagingProjectReference)"
      Targets="Restore"
      StopOnFirstFailure="True"
      Properties="PreferredToolArchitecture=x64" />
  </Target>
  <Target Name="Build" >
    <MSBuild
      Projects="@(ProjectReference)"
      Targets="Build"
      BuildInParallel="True"
      StopOnFirstFailure="True"
      Properties="PreferredToolArchitecture=x64" />
    <MSBuild
      Projects="@(PackagingProjectReference)"
      Targets="Build"
      StopOnFirstFailure="True"
      Properties="PreferredToolArchitecture=x64" />
  </Target>
  <Target Name="Rebuild" >
    <MSBuild
      Projects="@(ProjectReference)"
      Targets="Rebuild"
      BuildInParallel="True"
      StopOnFirstFailure="True"
      Properties="PreferredToolArchitecture=x64" />
    <MSBuild
      Projects="@(PackagingProjectReference)"
      Targets="Rebuild"
      StopOnFirstFailure="True"
      Properties="PreferredToolArchitecture=x64" />
  </Target>
</Project>
```

`Directory.Build.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<!-- 
This file allow for customizing your build process.
See: https://learn.microsoft.com/visualstudio/msbuild/customize-your-build
-->
<Project>
  <!--
  Uncomment if you need to enable inclusion of another Directory.Build.props file from a parent directory
  <Import Project="$([MSBuild]::GetPathOfFileAbove('Directory.Build.props', '$(MSBuildThisFileDirectory)../'))" />
  -->
  <PropertyGroup>
    <MileProjectOutputPath>$(MSBuildThisFileDirectory)Output\</MileProjectOutputPath>
  </PropertyGroup>
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Build.props" />

  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory);$(MSBuildProjectDirectory);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>

  <PropertyGroup>
    <ForceImportAfterCppProps>$(MSBuildThisFileDirectory)\Directory.Packages.Cpp.props</ForceImportAfterCppProps>
  </PropertyGroup>
</Project>
```

`Directory.Build.targets`:

```targets
<!-- 
This file allow for customizing your build process.
See: https://learn.microsoft.com/visualstudio/msbuild/customize-your-build
-->
<Project>
  <!-- 
  Uncomment if you need to enable inclusion of another Directory.Build.targets file from a parent directory
  <Import Project="$([MSBuild]::GetPathOfFileAbove('Directory.Build.targets', '$(MSBuildThisFileDirectory)../'))" />
  -->
</Project>
```

`Directory.Packages.Cpp.props`:

```props
<!--
  This enabled central package management. 
  This allows for controling all NuGet packages within the Directory.Packages.props file
  See https://learn.microsoft.com/nuget/consume-packages/Central-Package-Management?WT.mc_id=DT-MVP-5003472
  -->
<Project>
  <!--
  Uncomment if you need to enable inclusion of another Directory.Packages.props file from a parent directory
  <Import Project="$([MSBuild]::GetPathOfFileAbove(Directory.Packages.props, $(MSBuildThisFileDirectory)..))" />
  -->
  <!--
  This defines the set of centrally managed packages.
  This would typically list all NuGet packages used within this solution.
  -->
  <ItemGroup>
    <PackageReference Include="Musa.Veil" Version="1.2.6" />
  </ItemGroup>
</Project>
```

`InitializeVisualStudioEnvironment.cmd`:

```cmd
@rem 
@rem PROJECT:   Mouri Internal Library Essentials
@rem FILE:      InitializeVisualStudioEnvironment.cmd
@rem PURPOSE:   Initialize Visual Studio environment script
@rem 
@rem LICENSE:   The MIT License
@rem 
@rem MAINTAINER: MouriNaruto (Kenji.Mouri@outlook.com)
@rem 

@echo off

set VisualStudioInstallerFolder="%ProgramFiles(x86)%\Microsoft Visual Studio\Installer"
if %PROCESSOR_ARCHITECTURE%==x86 set VisualStudioInstallerFolder="%ProgramFiles%\Microsoft Visual Studio\Installer"

pushd %VisualStudioInstallerFolder%
for /f "usebackq tokens=*" %%i in (`vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do (
  set VisualStudioInstallDir=%%i
)
popd

call "%VisualStudioInstallDir%\VC\Auxiliary\Build\vcvarsall.bat" x64

```

`LICENSE`:

```
# Copyright (c) Microsoft Corporation

All rights reserved.

# MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Publish.bat`:

```bat
@echo off

rem Change to the current folder.
cd "%~dp0"

rem Remove the publish folder for a fresh compile.
rd /s /q Publish

rem Build all targets
call "%~dp0BuildAllTargets.cmd"

rem Copy the output to the publish folder
xcopy /s /y libwsk\*.h Publish\include\libwsk\
del Publish\include\libwsk\Precompiled.h

xcopy /s /y Output\Binaries\*libwsk.lib Publish\lib\
xcopy /s /y Output\Binaries\*libwsk.pdb Publish\lib\

```

`README.md`:

```md
# [libwsk](https://github.com/mirokaku/libwsk)

[![Actions Status](https://github.com/MiroKaku/libwsk/workflows/CodeQL/badge.svg)](https://github.com/MiroKaku/libwsk/actions)
[![LICENSE](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/MiroKaku/libwsk/blob/master/LICENSE)
![Windows](https://img.shields.io/badge/Windows-7+-orange.svg)
![Visual Studio](https://img.shields.io/badge/Visual%20Studio-2022-purple.svg)
[![Downloads](https://img.shields.io/nuget/dt/Musa.libwsk?logo=NuGet&logoColor=blue)](https://www.nuget.org/packages/Musa.libwsk/)

* [简体中文](README.zh-CN.md)

## About

libwsk is a wrapper for the [WSK (Winsock-Kernel)](https://docs.microsoft.com/en-us/windows-hardware/drivers/network/introduction-to-winsock-kernel) interface. With libwsk, kernel-mode software modules can perform network I/O operations using the same socket programming concepts and interface that are supported by user-mode Winsock2.

## Build and used

### Windows 10 or higher

Right click on the project, select "Manage NuGet Packages".
Search for `Musa.libwsk`, choose the version that suits you, and then click "Install".

### Windows 7

1. First modify the settings:

```
libwsk property pages -> Driver Settings -> Target OS Version = Windows 7
libwsk Property pages -> Driver Settings -> Target Platform   = Desktop
```

2. Call BuildAllTargets.cmd

## Supported progress

| BSD sockets   | WSA (Windows Sockets API)    | WSK (Windows Sockets Kernel) | State  
| ---           | ---                          | ---                          | :----: 
| -             | ~~WSAStartup~~               | WSKStartup                   |   √    
| -             | ~~WSACleanup~~               | WSKCleanup                   |   √    
| socket        | ~~WSASocket~~                | WSKSocket                    |   √    
| closesocket   | ~~WSASocket~~                | WSKCloseSocket               |   √    
| bind          | -                            | WSKBind                      |   √    
| listen        | -                            | WSKListen                    |   √    
| connect       | ~~WSAConnect~~               | WSKConnect                   |   √    
| shutdown      | ~~WSA[Recv/Send]Disconnect~~ | WSKDisconnect                |   √    
| accept        | ~~WSAAccept~~                | WSKAccept                    |   √    
| send          | ~~WSASend~~                  | WSKSend                      |   √    
| recv          | ~~WSARecv~~                  | WSKRecv                      |   √    
| sendto        | ~~WSASendTo~~                | WSKSendTo                    |   √    
| recvfrom      | ~~WSARecvFrom~~              | WSKRecvFrom                  |   √    
| ioctlsocket   | ~~WSAIoctl~~                 | WSKIoctl                     |   √    
| setsockopt    | -                            | WSKSetSocketOpt              |   √    
| getsockopt    | -                            | WSKGetSocketOpt              |   √    
| getaddrinfo   | ~~GetAddrInfoEx~~            | WSKGetAddrInfo               |   √    
| freeaddrinfo  | ~~FreeAddrInfoEx~~           | WSKFreeAddrInfo              |   √    
| getnameinfo   | ~~GetNameInfo~~              | WSKGetNameInfo               |   √    
| inet_ntoa     | ~~WSAAddressToString~~       | WSKAddressToString           |   √    
| inet_addr     | ~~WSAStringToAddress~~       | WSKStringToAddress           |   √    
| -             | ~~WSACreateEvent~~           | WSKCreateEvent               |   √    
| -             | ~~WSAGetOverlappedResult~~   | WSKGetOverlappedResult       |   √    
| ...           | ...                          | ...                          |   -    

## Reference

* [wbenny/KSOCKET](https://github.com/wbenny/KSOCKET)
* [microsoft/docs](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/network/introduction-to-winsock-kernel)

```

`README.zh-CN.md`:

```md
# [libwsk](https://github.com/mirokaku/libwsk)

[![Actions Status](https://github.com/MiroKaku/libwsk/workflows/CodeQL/badge.svg)](https://github.com/MiroKaku/libwsk/actions)
[![LICENSE](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/MiroKaku/libwsk/blob/master/LICENSE)
![Windows](https://img.shields.io/badge/Windows-7+-orange.svg)
![Visual Studio](https://img.shields.io/badge/Visual%20Studio-2022-purple.svg)
[![Downloads](https://img.shields.io/nuget/dt/Musa.libwsk?logo=NuGet&logoColor=blue)](https://www.nuget.org/packages/Musa.libwsk/)

* [英文](README.md)

## 关于

libwsk 是对 WSK [(Winsock-Kernel)](https://docs.microsoft.com/en-us/windows-hardware/drivers/network/introduction-to-winsock-kernel) 接口的封装。让内核模式驱动可以使用用户模式的 Winsock2 相同的套接字概念和接口进行网络 I/O 操作。

## 编译和使用

### Windows 10 or higher

右键单击该项目并选择“管理 NuGet 包”，然后搜索`Musa.libwsk`并选择适合你的版本，最后单击“安装”。

### Windows 7

1. 首先修改设置：

```
libwsk 属性页 -> Driver Settings -> Target OS Version = Windows 7
libwsk 属性页 -> Driver Settings -> Target Platform   = Desktop
```

2. 执行 BuildAllTargets.cmd


## 完成度

| BSD sockets   | WSA (Windows Sockets API)    | WSK (Windows Sockets Kernel) | State  
| ---           | ---                          | ---                          | :----: 
| -             | ~~WSAStartup~~               | WSKStartup                   |   √    
| -             | ~~WSACleanup~~               | WSKCleanup                   |   √    
| socket        | ~~WSASocket~~                | WSKSocket                    |   √    
| closesocket   | ~~WSASocket~~                | WSKCloseSocket               |   √    
| bind          | -                            | WSKBind                      |   √    
| listen        | -                            | WSKListen                    |   √    
| connect       | ~~WSAConnect~~               | WSKConnect                   |   √    
| shutdown      | ~~WSA[Recv/Send]Disconnect~~ | WSKDisconnect                |   √    
| accept        | ~~WSAAccept~~                | WSKAccept                    |   √    
| send          | ~~WSASend~~                  | WSKSend                      |   √    
| recv          | ~~WSARecv~~                  | WSKRecv                      |   √    
| sendto        | ~~WSASendTo~~                | WSKSendTo                    |   √    
| recvfrom      | ~~WSARecvFrom~~              | WSKRecvFrom                  |   √    
| ioctlsocket   | ~~WSAIoctl~~                 | WSKIoctl                     |   √    
| setsockopt    | -                            | WSKSetSocketOpt              |   √    
| getsockopt    | -                            | WSKGetSocketOpt              |   √    
| getaddrinfo   | ~~GetAddrInfoEx~~            | WSKGetAddrInfo               |   √    
| freeaddrinfo  | ~~FreeAddrInfoEx~~           | WSKFreeAddrInfo              |   √    
| getnameinfo   | ~~GetNameInfo~~              | WSKGetNameInfo               |   √    
| inet_ntoa     | ~~WSAAddressToString~~       | WSKAddressToString           |   √    
| inet_addr     | ~~WSAStringToAddress~~       | WSKStringToAddress           |   √    
| -             | ~~WSACreateEvent~~           | WSKCreateEvent               |   √    
| -             | ~~WSAGetOverlappedResult~~   | WSKGetOverlappedResult       |   √    
| ...           | ...                          | ...                          |   -    

## 引用参考

* [wbenny/KSOCKET](https://github.com/wbenny/KSOCKET)
* [microsoft/docs](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/network/introduction-to-winsock-kernel)

```

`global.json`:

```json
{
  "msbuild-sdks": {
    "Mile.Project.Configurations": "1.0.1426"
  }
}
```

`libwsk.NuGet/Musa.libwsk.nuspec`:

```nuspec
<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2013/05/nuspec.xsd">
  <metadata minClientVersion="2.5">
    <id>Musa.libwsk</id>
    <version>$version$</version>
    <title>Musa.libwsk</title>
    <authors>MeeSong</authors>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <license type="expression">MIT</license>
    <readme>build\native\README.md</readme>
    <description>libwsk is a wrapper for the WSK (Winsock-Kernel) interface. With libwsk, kernel-mode software modules can perform network I/O operations using the same socket programming concepts and interface that are supported by user-mode Winsock2.
    </description>
    <releaseNotes>$releaseNotes$</releaseNotes>
    <copyright>Copyright© MeeSong</copyright>
    <tags>Musa.libwsk libwsk WDK KMDF Kernel Driver</tags>
    <projectUrl>https://github.com/MiroKaku/libwsk</projectUrl>
    <repository type="git" url="https://github.com/MiroKaku/libwsk.git" branch="main" commit="$commit$" />
    <dependencies>
      <dependency id="YY.NuGet.Import.Helper" version="1.0.1" />
    </dependencies>
  </metadata>
  <files>
    <file src=".\Musa.libwsk.props" target="build\native\" />
    <file src=".\config\**" target="build\native\config\" />
    <file src="..\Publish\**" target="build\native\" />
    <file src="..\LICENSE" target="build\native\" />
    <file src="..\README.md" target="build\native\" />
  </files>
</package>
```

`libwsk.NuGet/Musa.libwsk.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <NuGetImportAfterCppProps Condition="Exists('$(MSBuildThisFileDirectory)config\libwsk.props')">$(NuGetImportAfterCppProps);$(MSBuildThisFileDirectory)config\libwsk.props</NuGetImportAfterCppProps>

    <NuGetImportBeforeCppTargets Condition="Exists('$(MSBuildThisFileDirectory)config\libwsk.targets')">$(NuGetImportBeforeCppTargets);$(MSBuildThisFileDirectory)config\libwsk.targets</NuGetImportBeforeCppTargets>
  </PropertyGroup>
</Project>

```

`libwsk.NuGet/config/libwsk.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup Condition="'$(IsKernelModeToolset)'==''">
    <IsKernelModeToolset Condition="'$(PlatformToolset.Contains(`KernelMode`))' == 'true'">true</IsKernelModeToolset>
  </PropertyGroup>

  <PropertyGroup>
    <!-- \Musa.libwsk\config\..\ -->
    <Musa_libwsk_Root>$([System.IO.Path]::GetFullPath('$(MSBuildThisFileDirectory)\..'))</Musa_libwsk_Root>
  </PropertyGroup>

  <PropertyGroup>
    <Musa_libwsk_Include>$(Musa_libwsk_Root)\include</Musa_libwsk_Include>
    <Musa_libwsk_Library>$(Musa_libwsk_Root)\lib\$(Configuration)\$(PlatformShortName)</Musa_libwsk_Library>
  </PropertyGroup>

  <PropertyGroup>
    <IncludePath>$(Musa_libwsk_Include);$(IncludePath)</IncludePath>
    <LibraryPath>$(Musa_libwsk_Library);$(LibraryPath)</LibraryPath>
  </PropertyGroup>

</Project>
```

`libwsk.NuGet/config/libwsk.targets`:

```targets
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  
  <ItemDefinitionGroup>
    <Link Condition="'$(IsKernelModeToolset)'=='true'">
      <AdditionalDependencies>libwsk.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>

</Project>

```

`libwsk.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35527.113
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libwsk", "libwsk\libwsk.vcxproj", "{66495811-336E-4693-B2EA-3EECBC17545E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libwsk.Test", "libwsk.Test\libwsk.Test.vcxproj", "{3E5181D1-702F-40D0-A8EB-E373C0A380E6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{66495811-336E-4693-B2EA-3EECBC17545E}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Debug|ARM64.Build.0 = Debug|ARM64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Debug|x64.ActiveCfg = Debug|x64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Debug|x64.Build.0 = Debug|x64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Debug|x64.Deploy.0 = Debug|x64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Release|ARM64.ActiveCfg = Release|ARM64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Release|ARM64.Build.0 = Release|ARM64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Release|ARM64.Deploy.0 = Release|ARM64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Release|x64.ActiveCfg = Release|x64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Release|x64.Build.0 = Release|x64
		{66495811-336E-4693-B2EA-3EECBC17545E}.Release|x64.Deploy.0 = Release|x64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Debug|ARM64.Build.0 = Debug|ARM64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Debug|x64.ActiveCfg = Debug|x64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Debug|x64.Build.0 = Debug|x64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Debug|x64.Deploy.0 = Debug|x64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Release|ARM64.ActiveCfg = Release|ARM64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Release|ARM64.Build.0 = Release|ARM64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Release|ARM64.Deploy.0 = Release|ARM64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Release|x64.ActiveCfg = Release|x64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Release|x64.Build.0 = Release|x64
		{3E5181D1-702F-40D0-A8EB-E373C0A380E6}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`libwsk.test/Program.c`:

```c
// unnecessary, fix ReSharper's code analysis.
#pragma warning(suppress: 4117)
#define _KERNEL_MODE 1

#include <Veil.h>
#include <libwsk/libwsk.h>

EXTERN_C_START
DRIVER_INITIALIZE   DriverEntry;
DRIVER_UNLOAD       DriverUnload;
EXTERN_C_END

//////////////////////////////////////////////////////
// Test functions

NTSTATUS StartWSKServer(
    _In_opt_ LPCWSTR NodeName,
    _In_opt_ LPCWSTR ServiceName,
    _In_     ADDRESS_FAMILY AddressFamily,
    _In_     USHORT  SocketType
);

VOID CloseWSKServer();

NTSTATUS StartWSKClient(
    _In_opt_ LPCWSTR NodeName,
    _In_opt_ LPCWSTR ServiceName,
    _In_     ADDRESS_FAMILY AddressFamily,
    _In_     USHORT  SocketType
);

VOID CloseWSKClient(void);

//
//////////////////////////////////////////////////////

NTSTATUS DriverEntry(_In_ DRIVER_OBJECT* DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    NTSTATUS Status = STATUS_SUCCESS;

    do 
    {
        ExInitializeDriverRuntime(DrvRtPoolNxOptIn);
        DriverObject->DriverUnload = DriverUnload;

        WSKDATA WSKData = { 0 };
        Status = WSKStartup(MAKE_WSK_VERSION(1, 0), &WSKData);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = StartWSKServer(nullptr, L"20211", AF_INET, SOCK_STREAM);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = StartWSKClient(nullptr, L"20211", AF_INET, SOCK_STREAM);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

    } while (false);

    if (!NT_SUCCESS(Status))
    {
        DriverUnload(DriverObject);
    }

    return Status;
}

VOID DriverUnload(_In_ DRIVER_OBJECT* DriverObject)
{
    UNREFERENCED_PARAMETER(DriverObject);

    CloseWSKClient();
    CloseWSKServer();

    WSKCleanup();
}

//////////////////////////////////////////////////////
// Test functions

const ULONG  POOL_TAG = 'TSET'; // TEST
const size_t DEFAULT_BUFFER_LEN = PAGE_SIZE;

SIZE_T    SocketCount   = 0u;
SOCKET*   ServerSockets = nullptr;
PETHREAD* ServerThreads = nullptr;

SOCKET    ClientSocket  = WSK_INVALID_SOCKET;
PETHREAD  ClientThread  = nullptr;

VOID WSKServerThread(
    _In_ PVOID Context
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    SOCKET Socket   = (SOCKET)Context;
    PVOID  Buffer   = nullptr;
    LPWSTR HostName = nullptr;
    LPWSTR PortName = nullptr;
    SOCKET SocketClient = WSK_INVALID_SOCKET;

    do 
    {
        SIZE_T Bytes        = 0u;
        INT    SocketType   = 0;

        Bytes  = sizeof SocketType;
        Status = WSKGetSocketOpt(Socket, SOL_SOCKET, SO_TYPE, &SocketType, &Bytes);
        if (!NT_SUCCESS(Status))
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Server] WSKGetSocketOpt(SO_TYPE) failed: 0x%08X.\n",
                Status);

            break;
        }

        Buffer = ExAllocatePoolZero(PagedPool, DEFAULT_BUFFER_LEN, POOL_TAG);
        if (Buffer == nullptr)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Server] ExAllocatePoolZero(Buffer) failed.\n");

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        HostName = (LPWSTR)ExAllocatePoolZero(PagedPool, NI_MAXHOST * sizeof(WCHAR), POOL_TAG);
        PortName = (LPWSTR)ExAllocatePoolZero(PagedPool, NI_MAXSERV * sizeof(WCHAR), POOL_TAG);

        if (HostName == nullptr || PortName == nullptr)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Server] ExAllocatePoolZero(Name) failed.\n");

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        SOCKADDR_STORAGE FromAddress = { 0 };

        do
        {
            // TCP
            if (SocketType == SOCK_STREAM)
            {
                if (SocketClient == WSK_INVALID_SOCKET)
                {
                    Status = WSKAccept(Socket, &SocketClient, nullptr, 0u, (SOCKADDR*)&FromAddress, sizeof FromAddress);
                    if (!NT_SUCCESS(Status))
                    {
                        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                            "[WSK] [Server] WSKAccept failed: 0x%08X.\n",
                            Status);

                        break;
                    }

                    Status = WSKGetNameInfo((SOCKADDR*)&FromAddress, sizeof FromAddress,
                        HostName, NI_MAXHOST, PortName, NI_MAXSERV, NI_NUMERICHOST | NI_NUMERICSERV);
                    if (!NT_SUCCESS(Status))
                    {
                        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                            "[WSK] [Server] WSKGetNameInfo failed: 0x%08X.\n",
                            Status);

                        break;
                    }

                    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                        "[WSK] [Server] Accepted connection from host %ls and port %ls.\n",
                        HostName, PortName);
                }
                else
                {
                    Status = WSKReceive(SocketClient, Buffer, DEFAULT_BUFFER_LEN, &Bytes, 0, nullptr, nullptr);
                    if (!NT_SUCCESS(Status))
                    {
                        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                            "[WSK] [Server] WSKReceive failed: 0x%08X.\n",
                            Status);

                        break;
                    }

                    if (Bytes == 0u)
                    {
                        WSKCloseSocket(SocketClient);
                        SocketClient = WSK_INVALID_SOCKET;
                    }
                    else
                    {
                        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                            "[WSK] [Server] Read  %Id bytes.\n",
                            Bytes);

                        Status = WSKSend(SocketClient, Buffer, Bytes, &Bytes, 0, nullptr, nullptr);
                        if (!NT_SUCCESS(Status))
                        {
                            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                                "[WSK] [Server] WSKSend failed: 0x%08X.\n",
                                Status);

                            break;
                        }

                        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                            "[WSK] [Server] Wrote %Id bytes.\n",
                            Bytes);
                    }
                }
            }

            // UDP
            if (SocketType == SOCK_DGRAM)
            {
                Status = WSKReceiveFrom(Socket, Buffer, DEFAULT_BUFFER_LEN, &Bytes, 0,
                    (SOCKADDR*)&FromAddress, sizeof FromAddress, nullptr, nullptr);
                if (!NT_SUCCESS(Status))
                {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                        "[WSK] [Server] WSKReceiveFrom failed: 0x%08X.\n",
                        Status);

                    break;
                }

                Status = WSKGetNameInfo((SOCKADDR*)&FromAddress, sizeof FromAddress,
                    HostName, NI_MAXHOST, PortName, NI_MAXSERV, NI_NUMERICHOST | NI_NUMERICSERV);
                if (!NT_SUCCESS(Status))
                {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                        "[WSK] [Server] WSKGetNameInfo failed: 0x%08X.\n",
                        Status);

                    break;
                }

                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, 
                    "[WSK] [Server] Read  %Id bytes from host %ls and port %ls.\n",
                    Bytes, HostName, PortName);

                Status = WSKSendTo(Socket, Buffer, Bytes, &Bytes, 0,
                    (SOCKADDR*)&FromAddress, sizeof FromAddress, nullptr, nullptr);
                if (!NT_SUCCESS(Status))
                {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                        "[WSK] [Server] WSKSendTo failed: 0x%08X.\n",
                        Status);

                    break;
                }

                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, 
                    "[WSK] [Server] Wrote %Id bytes to host %ls and port %ls.\n",
                    Bytes, HostName, PortName);
            }

        } while (true);

    } while (false);

    if (SocketClient != WSK_INVALID_SOCKET)
    {
        WSKCloseSocket(SocketClient);
    }

    if (HostName)
    {
        ExFreePoolWithTag(HostName, POOL_TAG);
    }

    if (PortName)
    {
        ExFreePoolWithTag(PortName, POOL_TAG);
    }

    if (Buffer)
    {
        ExFreePoolWithTag(Buffer, POOL_TAG);
    }

    PsTerminateSystemThread(Status);
}

NTSTATUS StartWSKServer(
    _In_opt_ LPCWSTR NodeName,
    _In_opt_ LPCWSTR ServiceName,
    _In_     ADDRESS_FAMILY AddressFamily,
    _In_     USHORT  SocketType
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    LPWSTR HostName = nullptr;
    LPWSTR PortName = nullptr;
    PADDRINFOEXW AddrInfo = nullptr;

    do 
    {
        HostName = (LPWSTR)ExAllocatePoolZero(PagedPool, NI_MAXHOST * sizeof(WCHAR), POOL_TAG);
        PortName = (LPWSTR)ExAllocatePoolZero(PagedPool, NI_MAXSERV * sizeof(WCHAR), POOL_TAG);

        if (HostName == nullptr || PortName == nullptr)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Server] ExAllocatePoolZero(Name) failed.\n");

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ADDRINFOEXW Hints = { 0 };
        Hints.ai_family   = AddressFamily;
        Hints.ai_socktype = SocketType;
        Hints.ai_protocol = ((SocketType == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP);
        Hints.ai_flags    = ((NodeName == NULL) ? AI_PASSIVE : 0);

        Status = WSKGetAddrInfo(NodeName, ServiceName, NS_ALL, nullptr,
            &Hints, &AddrInfo, WSK_INFINITE_WAIT, nullptr, nullptr);
        if (!NT_SUCCESS(Status))
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, 
                "[WSK] [Server] WSKGetAddrInfo failed: 0x%08X.\n",
                Status);
            break;
        }

        // Make sure we got at least one address back
        if (AddrInfo == nullptr)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Server] Unable to resolve node %ls.\n",
                NodeName);

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        // Count how many addresses were returned
        for (PADDRINFOEXW Addr = AddrInfo; Addr; Addr = Addr->ai_next)
        {
            ++SocketCount;
        }

        ServerSockets = (SOCKET*)ExAllocatePoolZero(PagedPool, SocketCount * sizeof(SOCKET), POOL_TAG);
        if (ServerSockets == nullptr)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Server] ExAllocatePoolZero(Sockets) failed.\n");

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        for (size_t i = 0u; i < SocketCount; ++i)
        {
            ServerSockets[i] = WSK_INVALID_SOCKET;
        }

        size_t Index = 0u;
        for (PADDRINFOEXW Addr = AddrInfo; Addr; Addr = Addr->ai_next)
        {
            Status = WSKSocket(&ServerSockets[Index], (ADDRESS_FAMILY)(Addr->ai_family),
                (USHORT)(Addr->ai_socktype), Addr->ai_protocol, nullptr);
            if (!NT_SUCCESS(Status))
            {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Server] WSKSocket failed: 0x%08X.\n",
                    Status);

                break;
            }

            Status = WSKBind(ServerSockets[Index], Addr->ai_addr, Addr->ai_addrlen);
            if (!NT_SUCCESS(Status))
            {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Server] WSKBind failed: 0x%08X.\n",
                    Status);

                break;
            }

            if (Addr->ai_socktype == SOCK_STREAM)
            {
                Status = WSKListen(ServerSockets[Index], 128);
                if (!NT_SUCCESS(Status))
                {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                        "[WSK] [Server] WSKListen failed: 0x%08X.\n",
                        Status);

                    break;
                }
            }

            Status = WSKGetNameInfo(Addr->ai_addr, (ULONG)(Addr->ai_addrlen),
                HostName, NI_MAXHOST, PortName, NI_MAXSERV, NI_NUMERICHOST | NI_NUMERICSERV);
            if (!NT_SUCCESS(Status))
            {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Server] WSKGetNameInfo failed: 0x%08X.\n",
                    Status);

                break;
            }

            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Server] Socket 0x%IX bound to address %ls and port %ls.\n",
                ServerSockets[Index], HostName, PortName);

            ++Index;
        }
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        ServerThreads = (PETHREAD*)ExAllocatePoolZero(PagedPool, SocketCount * sizeof(PETHREAD), POOL_TAG);
        if (ServerThreads == nullptr)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Server] ExAllocatePoolZero(Threads) failed.\n");

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        for (size_t i = 0u; i < SocketCount; ++i)
        {
            HANDLE ThreadHandle = nullptr;

            Status = PsCreateSystemThread(&ThreadHandle, SYNCHRONIZE,
                nullptr, nullptr, nullptr,
                &WSKServerThread,
                (PVOID)ServerSockets[i]);
            if (!NT_SUCCESS(Status))
            {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Server] PsCreateSystemThread(%d) failed: 0x%08X.\n",
                    i, Status);

                break;
            }

            Status = ObReferenceObjectByHandleWithTag(ThreadHandle, SYNCHRONIZE, *PsThreadType, KernelMode,
                POOL_TAG, (PVOID*)&ServerThreads[i], nullptr);

            ZwClose(ThreadHandle);

            if (!NT_SUCCESS(Status))
            {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Server] ObReferenceObjectByHandleWithTag(%d) failed: 0x%08X.\n",
                    i, Status);

                break;
            }
        }

    } while (false);

    if (HostName)
    {
        ExFreePoolWithTag(HostName, POOL_TAG);
    }

    if (PortName)
    {
        ExFreePoolWithTag(PortName, POOL_TAG);
    }

    if (AddrInfo)
    {
        WSKFreeAddrInfo(AddrInfo);
    }

    if (!NT_SUCCESS(Status))
    {
        CloseWSKServer();
    }

    return Status;
}

VOID CloseWSKServer(void)
{
    if (ServerSockets)
    {
        for (size_t i = 0u; i < SocketCount; ++i)
        {
            if (ServerSockets[i] != WSK_INVALID_SOCKET)
            {
                WSKCloseSocket(ServerSockets[i]);
            }
        }

        ExFreePoolWithTag(ServerSockets, POOL_TAG);

        ServerSockets = nullptr;
    }

    if (ServerThreads)
    {
        KeWaitForMultipleObjects((ULONG)SocketCount, (PVOID*)ServerThreads,
            WaitAll, Executive, KernelMode, FALSE, nullptr, nullptr);

        for (size_t i = 0u; i < SocketCount; ++i)
        {
            if (ServerThreads[i])
            {
                ObDereferenceObjectWithTag(ServerThreads[i], POOL_TAG);
            }
        }

        ExFreePoolWithTag((PVOID)ServerThreads, POOL_TAG);

        ServerThreads = nullptr;
    }
}

VOID WSKClientThread(
    _In_ PVOID Context
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    SOCKET   Socket = (SOCKET)Context;
    PVOID    Buffer = nullptr;

    do
    {
        SIZE_T Bytes = 0u;
        INT    SocketType = 0;

        Bytes  = sizeof SocketType;
        Status = WSKGetSocketOpt(Socket, SOL_SOCKET, SO_TYPE, &SocketType, &Bytes);
        if (!NT_SUCCESS(Status))
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] WSKGetSocketOpt(SO_TYPE) failed: 0x%08X.\n",
                Status);

            break;
        }

        ULONG RecvTimeout = 100u; // ms
        Bytes  = sizeof RecvTimeout;
        Status = WSKSetSocketOpt(Socket, SOL_SOCKET, SO_RCVTIMEO, &RecvTimeout, Bytes);
        if (!NT_SUCCESS(Status))
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] WSKSetSocketOpt(SO_RCVTIMEO) failed: 0x%08X.\n",
                Status);

            break;
        }

        Buffer = ExAllocatePoolZero(PagedPool, DEFAULT_BUFFER_LEN, POOL_TAG);
        if (Buffer == nullptr)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] ExAllocatePoolZero(Buffer) failed.\n");

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        SIZE_T BufferLength = DEFAULT_BUFFER_LEN;
        SIZE_T LoopCount = 0u;

        do 
        {
            RtlStringCbPrintfA((LPSTR)Buffer, DEFAULT_BUFFER_LEN,
                "This is a small test message [number %Id]",
                LoopCount++);

            RtlStringCbLengthA((LPSTR)Buffer, DEFAULT_BUFFER_LEN, (size_t*) & BufferLength);

            // TCP
            if (SocketType == SOCK_STREAM)
            {
                Status = WSKSend(Socket, Buffer, BufferLength, &Bytes, 0, nullptr, nullptr);
                if (!NT_SUCCESS(Status))
                {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                        "[WSK] [Client] WSKSend failed: 0x%08X.\n",
                        Status);

                    break;
                }

                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Client] Wrote %Id bytes.\n",
                    Bytes);

                Status = WSKReceive(Socket, Buffer, DEFAULT_BUFFER_LEN, &Bytes, 0, nullptr, nullptr);
                if (!NT_SUCCESS(Status))
                {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                        "[WSK] [Client] WSKReceive failed: 0x%08X.\n",
                        Status);

                    break;
                }

                if (Bytes == 0)
                {
                    continue;
                }

                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Client] Read  %Id bytes, data [%s] from server.\n",
                    Bytes, (LPCSTR)Buffer);
            }

            // UDP
            if (SocketType == SOCK_DGRAM)
            {
                Status = WSKSendTo(Socket, Buffer, BufferLength, &Bytes, 0, nullptr, 0, nullptr, nullptr);
                if (!NT_SUCCESS(Status))
                {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                        "[WSK] [Client] WSKSendTo failed: 0x%08X.\n",
                        Status);

                    break;
                }

                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Client] Wrote %Id bytes.\n",
                    Bytes);

                Status = WSKReceiveFrom(Socket, Buffer, DEFAULT_BUFFER_LEN, &Bytes, 0, nullptr, 0, nullptr, nullptr);
                if (!NT_SUCCESS(Status))
                {
                    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                        "[WSK] [Client] WSKReceiveFrom failed: 0x%08X.\n",
                        Status);

                    break;
                }

                if (Bytes == 0)
                {
                    continue;
                }

                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Client] Read  %Id bytes, data [%s] from server.\n",
                    Bytes, (LPCSTR)Buffer);
            }

        } while (true);

    } while (false);

    if (Buffer)
    {
        ExFreePoolWithTag(Buffer, POOL_TAG);
    }

    PsTerminateSystemThread(Status);
}

NTSTATUS StartWSKClient(
    _In_opt_ LPCWSTR NodeName,
    _In_opt_ LPCWSTR ServiceName,
    _In_     ADDRESS_FAMILY AddressFamily,
    _In_     USHORT  SocketType
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    LPWSTR HostName = nullptr;
    LPWSTR PortName = nullptr;
    PADDRINFOEXW AddrInfo = nullptr;

    do
    {
        HostName = (LPWSTR)ExAllocatePoolZero(PagedPool, NI_MAXHOST * sizeof(WCHAR), POOL_TAG);
        PortName = (LPWSTR)ExAllocatePoolZero(PagedPool, NI_MAXSERV * sizeof(WCHAR), POOL_TAG);

        if (HostName == nullptr || PortName == nullptr)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] ExAllocatePoolZero(Name) failed.\n");

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ADDRINFOEXW Hints = { 0 };
        Hints.ai_family   = AddressFamily;
        Hints.ai_socktype = SocketType;
        Hints.ai_protocol = ((SocketType == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP);

        Status = WSKGetAddrInfo(NodeName, ServiceName, NS_ALL, nullptr,
            &Hints, &AddrInfo, WSK_INFINITE_WAIT, nullptr, nullptr);
        if (!NT_SUCCESS(Status))
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] WSKGetAddrInfo failed: 0x%08X.\n",
                Status);

            break;
        }

        // Make sure we got at least one address back
        if (AddrInfo == nullptr)
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] Server (%ls) name could not be resolved!\n",
                NodeName);

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        for (PADDRINFOEXW Addr = AddrInfo; Addr; Addr = Addr->ai_next)
        {
            Status = WSKSocket(&ClientSocket, (ADDRESS_FAMILY)(Addr->ai_family),
                (USHORT)(Addr->ai_socktype), Addr->ai_protocol, nullptr);
            if (!NT_SUCCESS(Status))
            {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Client] WSKSocket failed: 0x%08X.\n",
                    Status);

                break;
            }

            Status = WSKGetNameInfo(Addr->ai_addr, (ULONG)(Addr->ai_addrlen),
                HostName, NI_MAXHOST, PortName, NI_MAXSERV, NI_NUMERICHOST | NI_NUMERICSERV);
            if (!NT_SUCCESS(Status))
            {
                DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                    "[WSK] [Client] WSKGetNameInfo failed: 0x%08X.\n",
                    Status);

                break;
            }

            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] Client attempting connection to: %ls port: %ls.\n",
                HostName, PortName);

            if (Addr->ai_socktype == SOCK_STREAM)
            {
                Status = WSKConnect(ClientSocket, Addr->ai_addr, Addr->ai_addrlen);
            }

            if (Addr->ai_socktype == SOCK_DGRAM)
            {
                Status = WSKIoctl(ClientSocket, SIO_WSK_SET_SENDTO_ADDRESS,
                    Addr->ai_addr, Addr->ai_addrlen, nullptr, 0, nullptr, nullptr, nullptr);
            }

            if (NT_SUCCESS(Status))
            {
                break;
            }
        }

        if (!NT_SUCCESS(Status))
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] Unable to establish connection... 0x%08X.\n",
                Status);

            break;
        }

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
            "[WSK] [Client] Connection established...\n");

        HANDLE ThreadHandle = nullptr;

        Status = PsCreateSystemThread(&ThreadHandle, SYNCHRONIZE,
            nullptr, nullptr, nullptr,
            &WSKClientThread,
            (PVOID)ClientSocket);
        if (!NT_SUCCESS(Status))
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] PsCreateSystemThread failed: 0x%08X.\n",
                Status);

            break;
        }

        Status = ObReferenceObjectByHandleWithTag(ThreadHandle, SYNCHRONIZE, *PsThreadType, KernelMode,
            POOL_TAG, (PVOID*)&ClientThread, nullptr);

        ZwClose(ThreadHandle);

        if (!NT_SUCCESS(Status))
        {
            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
                "[WSK] [Client] ObReferenceObjectByHandleWithTag failed: 0x%08X.\n",
                Status);

            break;
        }

    } while (false);

    if (HostName)
    {
        ExFreePoolWithTag(HostName, POOL_TAG);
    }

    if (PortName)
    {
        ExFreePoolWithTag(PortName, POOL_TAG);
    }

    if (AddrInfo)
    {
        WSKFreeAddrInfo(AddrInfo);
    }

    if (!NT_SUCCESS(Status))
    {
        CloseWSKClient();
    }

    return Status;
}

VOID CloseWSKClient(void)
{
    if (ClientSocket != WSK_INVALID_SOCKET)
    {
        WSKCloseSocket(ClientSocket);

        ClientSocket = WSK_INVALID_SOCKET;
    }

    if (ClientThread)
    {
        KeWaitForSingleObject(ClientThread, Executive, KernelMode, FALSE, nullptr);
        ObDereferenceObjectWithTag(ClientThread, POOL_TAG);

        ClientThread = nullptr;
    }
}

//
//////////////////////////////////////////////////////

```

`libwsk.test/libwsk.inf`:

```inf
;-------------------------------------------------------------------------
; libwsk.INF -- NT Legacy Driver
;
; Copyright (c) 2019, Microsoft.Com LLC.  All rights reserved.
;------------------------------------------------------------------------


; INF MSDN:
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/roadmap-for-device-and-driver-installation--windows-vista-and-later-
;
; Class And ClassGuid MSDN:
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/file-system-filter-driver-classes-and-class-guids
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/system-defined-device-setup-classes-available-to-vendors
[Version]
Signature   = "$WINDOWS NT$"
Class       = NetService
ClassGuid   = {4d36e974-e325-11ce-bfc1-08002be10318}
Provider    = %ManufacturerName%
CatalogFile = libwsk.cat
DriverVer   =
PnpLockdown = 1


;-------------------------------------------------------------------------
; Installation Section
;-------------------------------------------------------------------------

; DestinationDirs MSDN
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/inf-destinationdirs-section
[DestinationDirs]
DefaultDestDir      = 12


; SourceDisksNames MSDN
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/inf-sourcedisksnames-section
[SourceDisksNames]
1 = %DiskId%,,,""


; SourceDisksFiles MSDN
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/inf-sourcedisksfiles-section
; Each filename entry must specify the exact name of a file on the source disk.
;     You cannot use a %strkey% token to specify the file name.
[SourceDisksFiles]
libwsk.Test.sys        = 1,,


; Copyfiles MSDN:
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/inf-copyfiles-directive
[Install.Drivers]
libwsk.sys,libwsk.Test.sys,,0x00004002 ; COPYFLG_NOSKIP | COPYFLG_IN_USE_RENAME


; Delfiles MSDN:
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/inf-delfiles-directive
[Uninstall.Drivers]
libwsk.sys


;-------------------------------------------------------------------------
; Service installation support
;-------------------------------------------------------------------------


[DefaultInstall.NT$ARCH$]
CopyFiles       = Install.Drivers


; LegacyUninstall MSDN:
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/develop/creating-a-primitive-driver
[DefaultUninstall.NT$ARCH$]
LegacyUninstall = 1
DelFiles        = Uninstall.Drivers


[DefaultInstall.NT$ARCH$.Services]
; You may want to add the SPSVCINST_STARTSERVICE flag, like this:
;     AddService=%ServiceName%,0x800,InstallService.Arch ; SPSVCINST_STARTSERVICE
; AddService MSDN
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/inf-addservice-directive
AddService=%ServiceName%,,InstallService


; DelService MSDN:
;     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/inf-delservice-directive
[DefaultUninstall.NT$ARCH$.Services]
DelService = %ServiceName%,0x200


[InstallService]
DisplayName    = %ServiceName%
Description    = %ServiceDesc%
ServiceBinary  = %12%\libwsk.sys
ServiceType    = 1                  ; SERVICE_KERNEL_DRIVER
StartType      = 3                  ; 0 = SERVICE_BOOT_START
                                    ; 1 = SERVICE_SYSTEM_START
                                    ; 2 = SERVICE_AUTO_START
                                    ; 3 = SERVICE_DEMAND_START
                                    ; 4 = SERVICE_DISABLED
ErrorControl   = 1                  ; SERVICE_ERROR_NORMAL


;-------------------------------------------------------------------------
; Strings section
;-------------------------------------------------------------------------


[Strings]
ManufacturerName        = "MiroKaku"
ServiceName             = "libwsk"
ServiceDesc             = "libwsk Legacy Driver"
DiskId                  = "libwsk Device Installation Disk"

```

`libwsk.test/libwsk.test.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3E5181D1-702F-40D0-A8EB-E373C0A380E6}</ProjectGuid>
    <ProjectName>libwsk.Test</ProjectName>
    <RootNamespace>libwsk.Test</RootNamespace>
    <MileProjectType>WDMDriver</MileProjectType>
  </PropertyGroup>
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Platform.x64.props" />
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Platform.ARM64.props" />
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Cpp.Default.props" />
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Cpp.props" />
  <PropertyGroup>
    <OutDir>$(MileProjectBinariesPath)$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(MileProjectObjectsPath)$(Configuration)\$(MSBuildProjectName)\$(Platform)\</IntDir>
    <GeneratedFilesDir>$(IntDir)Generated Files\</GeneratedFilesDir>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <PreprocessorDefinitions>NO_STRICT;POOL_ZERO_DOWN_LEVEL_SUPPORT;POOL_NX_OPTIN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <Inf Include="libwsk.inf" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Program.c" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\libwsk\libwsk.vcxproj">
      <Project>{66495811-336e-4693-b2ea-3eecbc17545e}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Cpp.targets" />
</Project>
```

`libwsk/Precompiled.cpp`:

```cpp
#include "Precompiled.h"

```

`libwsk/Precompiled.h`:

```h
#pragma once

// unnecessary, fix ReSharper's code analysis.
#pragma warning(suppress: 4117)
#define _KERNEL_MODE 1

#include <Veil.h>

// System
#include <intrin.h>
#include <wsk.h>

// C & C++
#include <stddef.h>
#include <stdlib.h>

// Global
static const ULONG WSK_POOL_TAG = ' KSW'; // 'WSK '

```

`libwsk/berkeley.cpp`:

```cpp
#include "berkeley.h"
#include "libwsk.h"

#ifdef __cplusplus
extern "C" {
#endif

SOCKET WSKAPI socket(
    _In_ int af,
    _In_ int type,
    _In_ int protocol
)
{
    SOCKET   Socket = WSK_INVALID_SOCKET;
    NTSTATUS Status = WSKSocket(&Socket, static_cast<ADDRESS_FAMILY>(af),
        static_cast<USHORT>(type), static_cast<ULONG>(protocol), nullptr);

    return WSKSetLastError(Status), Socket;
}

int WSKAPI closesocket(
    _In_ SOCKET s
)
{
    NTSTATUS Status = WSKCloseSocket(s);
    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : SOCKET_SUCCESS);
}

int WSKAPI bind(
    _In_ SOCKET s,
    _In_reads_bytes_(addrlen) const struct sockaddr* addr,
    _In_ int addrlen
)
{
    NTSTATUS Status = WSKBind(s, (PSOCKADDR)addr, addrlen);
    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : SOCKET_SUCCESS);
}

int WSKAPI listen(
    _In_ SOCKET s,
    _In_ int backlog
)
{
    NTSTATUS Status = WSKListen(s, backlog);
    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : SOCKET_SUCCESS);

}

int WSKAPI connect(
    _In_ SOCKET s,
    _In_reads_bytes_(addrlen) const struct sockaddr* addr,
    _In_ int addrlen
)
{
    NTSTATUS Status = WSKConnect(s, (PSOCKADDR)addr, addrlen);
    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : SOCKET_SUCCESS);
}

int WSKAPI shutdown(
    _In_ SOCKET s,
    _In_ int how
)
{
    UNREFERENCED_PARAMETER(how);

    NTSTATUS Status = WSKDisconnect(s, 0);
    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : SOCKET_SUCCESS);
}

SOCKET WSKAPI accept(
    _In_ SOCKET s,
    _Out_writes_bytes_opt_(*addrlen) struct sockaddr* addr,
    _Inout_opt_ int* addrlen
)
{
    SOCKET   Socket = WSK_INVALID_SOCKET;
    NTSTATUS Status = WSKAccept(s, &Socket, nullptr, 0, addr, addrlen ? *addrlen : 0);
    return WSKSetLastError(Status), Socket;
}

int WSKAPI send(
    _In_ SOCKET s,
    _In_reads_bytes_(len) const char* buf,
    _In_ int len,
    _In_ int flags
)
{
    SIZE_T NumberOfBytesSent = 0u;

    NTSTATUS Status = WSKSend(s, const_cast<char*>(buf), len, &NumberOfBytesSent, flags, nullptr, nullptr);
    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : static_cast<int>(NumberOfBytesSent));
}

int WSKAPI recv(
    _In_ SOCKET s,
    _Out_writes_bytes_to_(len, return) __out_data_source(NETWORK) char* buf,
    _In_ int len,
    _In_ int flags
)
{
    SIZE_T NumberOfBytesRecvd = 0u;

    NTSTATUS Status = WSKReceive(s, buf, len, &NumberOfBytesRecvd, flags, nullptr, nullptr);
    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : static_cast<int>(NumberOfBytesRecvd));
}

int WSKAPI sendto(
    _In_ SOCKET s,
    _In_reads_bytes_(len) const char* buf,
    _In_ int len,
    _In_ int flags,
    _In_reads_bytes_opt_(tolen) const struct sockaddr* to,
    _In_ int tolen
)
{
    SIZE_T NumberOfBytesSent = 0u;

    NTSTATUS Status = WSKSendTo(s, const_cast<char*>(buf), len, &NumberOfBytesSent, flags, const_cast<PSOCKADDR>(to), tolen, nullptr, nullptr);
    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : static_cast<int>(NumberOfBytesSent));
}

int WSKAPI recvfrom(
    _In_ SOCKET s,
    _Out_writes_bytes_to_(len, return) __out_data_source(NETWORK) char* buf,
    _In_ int len,
    _In_ int flags,
    _Out_writes_bytes_to_opt_(*fromlen, *fromlen) struct sockaddr* from,
    _Inout_opt_ int* fromlen
)
{
    SIZE_T NumberOfBytesRecvd = 0u;

    NTSTATUS Status = WSKReceiveFrom(s, buf, len, &NumberOfBytesRecvd, flags, const_cast<PSOCKADDR>(from), fromlen ? *fromlen : 0, nullptr, nullptr);
    if (NT_SUCCESS(Status))
    {
        if (fromlen)
        {
            *fromlen = static_cast<int>(NumberOfBytesRecvd);
        }
    }

    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : static_cast<int>(NumberOfBytesRecvd));
}

int WSKAPI setsockopt(
    _In_ SOCKET s,
    _In_ int level,
    _In_ int optname,
    _In_reads_bytes_opt_(optlen) const char* optval,
    _In_ int optlen
)
{
    NTSTATUS Status = WSKSetSocketOpt(s, level, optname, const_cast<char*>(optval), optlen);
    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : SOCKET_SUCCESS);
}

int WSKAPI getsockopt(
    _In_ SOCKET s,
    _In_ int level,
    _In_ int optname,
    _Out_writes_bytes_(*optlen) char* optval,
    _Inout_ int* optlen
)
{
    SIZE_T OptionLength = *optlen;

    NTSTATUS Status = WSKGetSocketOpt(s, level, optname, optval, &OptionLength);
    if (NT_SUCCESS(Status))
    {
        *optlen = static_cast<int>(OptionLength);
    }

    return WSKSetLastError(Status), (!NT_SUCCESS(Status) ? SOCKET_ERROR : SOCKET_SUCCESS);
}

static NTSTATUS WSKAPI convert_addrinfo_to_addrinfoex(
    _In_ addrinfoexW** target,
    _In_opt_ const addrinfo* source
)
{
    NTSTATUS     Status  = STATUS_SUCCESS;
    addrinfoexW* Result  = nullptr;
    sockaddr*    Address = nullptr;

    ANSI_STRING     CanonicalNameA{};
    UNICODE_STRING  CanonicalNameW{};

    do
    {
        *target = nullptr;

        if (source == nullptr)
        {
            break;
        }

        Result = (addrinfoexW*)ExAllocatePoolZero(PagedPool, sizeof addrinfoexW, WSK_POOL_TAG);
        if (Result == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Result->ai_flags    = (source->ai_flags & ~AI_EXTENDED);
        Result->ai_family   = source->ai_family;
        Result->ai_socktype = source->ai_socktype;
        Result->ai_protocol = source->ai_protocol;
        Result->ai_addrlen  = source->ai_addrlen;

        if (source->ai_canonname)
        {
            RtlInitAnsiString(&CanonicalNameA, source->ai_canonname);

            Status = RtlAnsiStringToUnicodeString(&CanonicalNameW, &CanonicalNameA, TRUE);
            if (!NT_SUCCESS(Status))
            {
                break;
            }

            Result->ai_canonname = CanonicalNameW.Buffer;
        }

        if (source->ai_addr)
        {
            Address = (sockaddr*)ExAllocatePoolZero(PagedPool, source->ai_addrlen, WSK_POOL_TAG);
            if (Address == nullptr)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            memcpy(Address, source->ai_addr, source->ai_addrlen);

            Result->ai_addr = Address;
        }

        Status = convert_addrinfo_to_addrinfoex(&Result->ai_next, source->ai_next);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        *target = Result;

    } while (false);

    if (!NT_SUCCESS(Status))
    {
        RtlFreeUnicodeString(&CanonicalNameW);

        if (Address)
        {
            ExFreePoolWithTag(Address, WSK_POOL_TAG);
        }

        if (Result)
        {
            ExFreePoolWithTag(Result, WSK_POOL_TAG);
        }
    }

    return Status;
}

static NTSTATUS WSKAPI convert_addrinfoex_to_addrinfo(
    _In_ addrinfo**         target,
    _In_opt_ const addrinfoexW* source
)
{
    NTSTATUS        Status  = STATUS_SUCCESS;
    addrinfo*       Result  = nullptr;
    sockaddr*       Address = nullptr;

    ANSI_STRING     CanonicalNameA{};
    UNICODE_STRING  CanonicalNameW{};

    do
    {
        *target = nullptr;

        if (source == nullptr)
        {
            break;
        }

        Result = (addrinfo*)ExAllocatePoolZero(PagedPool, sizeof addrinfo, WSK_POOL_TAG);
        if (Result == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Result->ai_flags    = (source->ai_flags & ~AI_EXTENDED);
        Result->ai_family   = source->ai_family;
        Result->ai_socktype = source->ai_socktype;
        Result->ai_protocol = source->ai_protocol;
        Result->ai_addrlen  = source->ai_addrlen;

        if (source->ai_canonname)
        {
            RtlInitUnicodeString(&CanonicalNameW, source->ai_canonname);

            Status = RtlUnicodeStringToAnsiString(&CanonicalNameA, &CanonicalNameW, TRUE);
            if (!NT_SUCCESS(Status))
            {
                break;
            }

            Result->ai_canonname = CanonicalNameA.Buffer;
        }

        if (source->ai_addr)
        {
            Address = (sockaddr*)ExAllocatePoolZero(PagedPool, source->ai_addrlen, WSK_POOL_TAG);
            if (Address == nullptr)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            memcpy(Address, source->ai_addr, source->ai_addrlen);

            Result->ai_addr = Address;
        }

        Status = convert_addrinfoex_to_addrinfo(&Result->ai_next, source->ai_next);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        *target = Result;

    } while (false);

    if (!NT_SUCCESS(Status))
    {
        RtlFreeAnsiString(&CanonicalNameA);

        if (Address)
        {
            ExFreePoolWithTag(Address, WSK_POOL_TAG);
        }

        if (Result)
        {
            ExFreePoolWithTag(Result, WSK_POOL_TAG);
        }
    }

    return Status;
}

int WSKAPI getaddrinfo(
    _In_opt_ const char* nodename,
    _In_opt_ const char* servname,
    _In_opt_ const struct addrinfo* hints,
    _Outptr_ struct addrinfo** res
)
{
    NTSTATUS        Status  = STATUS_SUCCESS;
    addrinfoexW*    Hints   = nullptr;
    addrinfoexW*    Result  = nullptr;

    UNICODE_STRING  HostNameW{};
    UNICODE_STRING  ServNameW{};

    do
    {
        *res = nullptr;

        if (nodename)
        {
            ANSI_STRING HostNameA{};
            RtlInitAnsiString(&HostNameA, nodename);

            Status = RtlAnsiStringToUnicodeString(&HostNameW, &HostNameA, TRUE);
            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }

        if (servname)
        {
            ANSI_STRING ServNameA{};
            RtlInitAnsiStringEx(&ServNameA, servname);

            Status = RtlAnsiStringToUnicodeString(&ServNameW, &ServNameA, TRUE);
            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }

        Status = convert_addrinfo_to_addrinfoex(&Hints, hints);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = WSKGetAddrInfo(HostNameW.Buffer, ServNameW.Buffer, NS_ALL, nullptr,
            Hints, &Result, WSK_INFINITE_WAIT, nullptr, nullptr);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = convert_addrinfoex_to_addrinfo(res, Result);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

    } while (false);

    RtlFreeUnicodeString(&HostNameW);
    RtlFreeUnicodeString(&ServNameW);

    WSKFreeAddrInfo(Hints);
    WSKFreeAddrInfo(Result);

    return Status;
}

void WSKAPI freeaddrinfo(
    _In_  struct addrinfo* ai
)
{
    if (ai)
    {
        if (ai->ai_next)
        {
            freeaddrinfo(ai->ai_next);
        }

        if (ai->ai_canonname)
        {
            ExFreePool(ai->ai_canonname);
        }

        if (ai->ai_addr)
        {
            ExFreePoolWithTag(ai->ai_addr, WSK_POOL_TAG);
        }

        ExFreePoolWithTag(ai, WSK_POOL_TAG);
    }
}

int WSKAPI getnameinfo(
    _In_reads_bytes_(salen) const struct sockaddr* sa,
    _In_  socklen_t salen,
    _Out_writes_bytes_(hostlen) char* host,
    _In_  size_t hostlen,
    _Out_writes_bytes_(servlen) char* serv,
    _In_  size_t servlen,
    _In_  int flags
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING HostName{};
    UNICODE_STRING ServName{};

    do
    {
        void* NameBuffer = nullptr;

        NameBuffer = ExAllocatePoolZero(PagedPool, NI_MAXHOST * sizeof(wchar_t), WSK_POOL_TAG);
        if (NameBuffer == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlInitEmptyUnicodeString(&HostName, static_cast<PWCH>(NameBuffer),
            static_cast<USHORT>(NI_MAXHOST * sizeof(wchar_t)));

        NameBuffer = ExAllocatePoolZero(PagedPool, NI_MAXSERV * sizeof(wchar_t), WSK_POOL_TAG);
        if (NameBuffer == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlInitEmptyUnicodeString(&ServName, static_cast<PWCH>(NameBuffer),
            static_cast<USHORT>(NI_MAXSERV * sizeof(wchar_t)));

        Status = WSKGetNameInfo(sa, salen,
            HostName.Buffer, HostName.MaximumLength,
            ServName.Buffer, ServName.MaximumLength,
            flags);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        HostName.Length = static_cast<USHORT>(wcslen(HostName.Buffer) * sizeof(wchar_t));
        ServName.Length = static_cast<USHORT>(wcslen(ServName.Buffer) * sizeof(wchar_t));

        if (host)
        {
            ANSI_STRING HostNameA{};
            RtlInitEmptyAnsiString(&HostNameA, host, static_cast<USHORT>(hostlen));

            Status = RtlUnicodeStringToAnsiString(&HostNameA, &HostName, false);
            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }

        if (serv)
        {
            ANSI_STRING ServNameA{};
            RtlInitEmptyAnsiString(&ServNameA, serv, static_cast<USHORT>(servlen));

            Status = RtlUnicodeStringToAnsiString(&ServNameA, &ServName, false);
            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }

    } while (false);

    RtlFreeUnicodeString(&HostName);
    RtlFreeUnicodeString(&ServName);

    return WSKSetLastError(Status), Status;
}

int WSKAPI inet_pton(
    _In_    int         Family,
    _In_    const char* AddressString,
    _When_(Family == AF_INET , _Out_writes_bytes_(sizeof(IN_ADDR)))
    _When_(Family == AF_INET6, _Out_writes_bytes_(sizeof(IN6_ADDR)))
    void*   Address
)
{
    NTSTATUS Status     = STATUS_SUCCESS;
    PCSTR    Terminator = nullptr;

    switch (Family)
    {
    default:
        Status = STATUS_INVALID_PARAMETER;
        break;

    case AF_INET:
        Status = RtlIpv4StringToAddressA(AddressString, true, &Terminator,
            static_cast<in_addr*>(Address));
        break;

    case AF_INET6:
        Status = RtlIpv6StringToAddressA(AddressString, &Terminator,
            static_cast<in6_addr*>(Address));
        break;
    }

    WSKSetLastError(Status);

    if (!NT_SUCCESS(Status))
    {
        if (Status == STATUS_INVALID_PARAMETER)
        {
            return 0;
        }
        else
        {
            return -1;
        }
    }

    return 1;
}

PCSTR WSKAPI inet_ntop(
    _In_    int             Family,
    _In_    const void*     Address,
    _Out_writes_(StringBufSize) char* AddressString,
    _In_    size_t          StringBufSize
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCSTR    Result = nullptr;

    switch (Family)
    {
    default:
    {
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    case AF_INET:
    {
        if (StringBufSize < _countof("255.255.255.255"))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        Result = RtlIpv4AddressToStringA(static_cast<const in_addr*>(Address), AddressString);
        break;
    }
    case AF_INET6:
    {
        if (StringBufSize < _countof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")) // IPv4-mapped IPv6
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        Result = RtlIpv6AddressToStringA(static_cast<const in6_addr*>(Address), AddressString);
        break;
    }
    }

    WSKSetLastError(Status);

    return Result;
}

unsigned long WSKAPI htonl(
    _In_ unsigned long hostlong
)
{
    return RtlUlongByteSwap(hostlong);
}

unsigned long WSKAPI ntohl(
    _In_ unsigned long netlong
)
{
    return RtlUlongByteSwap(netlong);
}

unsigned short WSKAPI htons(
    _In_ unsigned short hostshort
)
{
    return RtlUshortByteSwap(hostshort);
}

unsigned short WSKAPI ntohs(
    _In_ unsigned short netshort
)
{
    return RtlUshortByteSwap(netshort);
}


#ifdef __cplusplus
}
#endif

```

`libwsk/berkeley.h`:

```h
#pragma once
#include <wsk.h>

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */

#ifndef WSK_INVALID_SOCKET
#  define WSK_INVALID_SOCKET        ((SOCKET)(~0))
#endif

#ifndef INVALID_SOCKET
#define INVALID_SOCKET  WSK_INVALID_SOCKET
#endif

#ifndef SOCKET_ERROR
#define SOCKET_ERROR    (-1)
#endif

#ifndef SOCKET_SUCCESS
#define SOCKET_SUCCESS  (0)
#endif

typedef int         socklen_t;
typedef UINT_PTR    SOCKET;

/* Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

SOCKET WSKAPI socket(
    _In_ int af,
    _In_ int type,
    _In_ int protocol
);

int WSKAPI closesocket(
    _In_ SOCKET s
);

int WSKAPI bind(
    _In_ SOCKET s,
    _In_reads_bytes_(addrlen) const struct sockaddr* addr,
    _In_ int addrlen
);

int WSKAPI listen(
    _In_ SOCKET s,
    _In_ int backlog
);

int WSKAPI connect(
    _In_ SOCKET s,
    _In_reads_bytes_(addrlen) const struct sockaddr* addr,
    _In_ int addrlen
);

int WSKAPI shutdown(
    _In_ SOCKET s,
    _In_ int how
);

SOCKET WSKAPI accept(
    _In_ SOCKET s,
    _Out_writes_bytes_opt_(*addrlen) struct sockaddr* addr,
    _Inout_opt_ int* addrlen
);

int WSKAPI send(
    _In_ SOCKET s,
    _In_reads_bytes_(len) const char* buf,
    _In_ int len,
    _In_ int flags
);

int WSKAPI recv(
    _In_ SOCKET s,
    _Out_writes_bytes_to_(len, return) __out_data_source(NETWORK) char* buf,
    _In_ int len,
    _In_ int flags
);

int WSKAPI sendto(
    _In_ SOCKET s,
    _In_reads_bytes_(len) const char* buf,
    _In_ int len,
    _In_ int flags,
    _In_reads_bytes_opt_(tolen) const struct sockaddr* to,
    _In_ int tolen
);

int WSKAPI recvfrom(
    _In_ SOCKET s,
    _Out_writes_bytes_to_(len, return) __out_data_source(NETWORK) char* buf,
    _In_ int len,
    _In_ int flags,
    _Out_writes_bytes_to_opt_(*fromlen, *fromlen) struct sockaddr* from,
    _Inout_opt_ int* fromlen
);

int WSKAPI setsockopt(
    _In_ SOCKET s,
    _In_ int level,
    _In_ int optname,
    _In_reads_bytes_opt_(optlen) const char* optval,
    _In_ int optlen
);

int WSKAPI getsockopt(
    _In_ SOCKET s,
    _In_ int level,
    _In_ int optname,
    _Out_writes_bytes_(*optlen) char* optval,
    _Inout_ int* optlen
);

int WSKAPI getaddrinfo(
    _In_opt_ const char* nodename,
    _In_opt_ const char* servname,
    _In_opt_ const struct addrinfo* hints,
    _Outptr_ struct addrinfo** res
);

void WSKAPI freeaddrinfo(
    _In_  struct addrinfo* ai
);

int WSKAPI getnameinfo(
    _In_reads_bytes_(salen) const struct sockaddr* sa,
    _In_  socklen_t salen,
    _Out_writes_bytes_(hostlen) char* host,
    _In_  size_t hostlen,
    _Out_writes_bytes_(servlen) char* serv,
    _In_  size_t servlen,
    _In_  int flags
);

int WSKAPI inet_pton(
    _In_    int         Family,
    _In_    const char* AddressString,
    _When_(Family == AF_INET, _Out_writes_bytes_(sizeof(IN_ADDR)))
    _When_(Family == AF_INET6, _Out_writes_bytes_(sizeof(IN6_ADDR)))
    void* Address
);

PCSTR WSKAPI inet_ntop(
    _In_    int             Family,
    _In_    const void* Address,
    _Out_writes_(StringBufSize) char* AddressString,
    _In_    size_t          StringBufSize
);

unsigned long WSKAPI htonl(
    _In_ unsigned long hostlong
);

unsigned long WSKAPI ntohl(
    _In_ unsigned long netlong
);

unsigned short WSKAPI htons(
    _In_ unsigned short hostshort
);

unsigned short WSKAPI ntohs(
    _In_ unsigned short netshort
);

#ifdef __cplusplus
}
#endif

```

`libwsk/libwsk.cpp`:

```cpp
#include "libwsk.h"
#include "socket.h"

#pragma comment(lib, "Netio.lib")

//////////////////////////////////////////////////////////////////////////
// Private Struct

using WSK_COMPLETION_ROUTINE = VOID(WSKAPI*)(
    _In_ NTSTATUS  Status,
    _In_ ULONG_PTR Bytes,
    _In_ PVOID     Context
    );

struct WSK_CONTEXT_IRP
{
    PIRP    Irp;
    KEVENT  Event;
    PVOID   Context;
    union {
        PVOID   CompletionRoutine;  // WSK_COMPLETION_ROUTINE
        PVOID   Pointer;            // Other
    } DUMMYUNIONNAME;

    WSK_BUF InputBuffer;
    WSK_BUF OutputBuffer;
};

#if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)
typedef struct _WSK_STREAM_SOCKET_WIN7 {
    BOOLEAN     Mode;   // 0:unknown, 1:listen, 2:connect
    PWSK_SOCKET Listen;
    PWSK_SOCKET Connect;
} WSK_STREAM_SOCKET_WIN7, * PWSK_STREAM_SOCKET_WIN7;
#endif // if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)

//////////////////////////////////////////////////////////////////////////
// Global  Data

static volatile long _Initialized  = false;
static volatile long _LastNtStatus = STATUS_SUCCESS;

static WSK_CLIENT_DISPATCH WSKClientDispatch = {
    MAKE_WSK_VERSION(1, 0), // This default uses WSK version 1.0
    0,                      // Reserved
    nullptr                 // WskClientEvent callback is not required in WSK version 1.0
};

static WSK_REGISTRATION WSKRegistration;
static WSK_PROVIDER_NPI WSKNPIProvider;

//////////////////////////////////////////////////////////////////////////
// Private Function

static PLARGE_INTEGER WSKAPI WSKTimeoutToLargeInteger(
    _In_ UINT32 Milliseconds,
    _In_ PLARGE_INTEGER Timeout
)
{
    if (Milliseconds == WSK_INFINITE_WAIT)
    {
        return nullptr;
    }

    Timeout->QuadPart = Int32x32To64(Milliseconds, -10000);

    return Timeout;
}

static NTSTATUS WSKAPI WSKLockBuffer(
    _In_  PVOID    Buffer,
    _In_  SIZE_T   BufferLength,
    _Out_ PWSK_BUF WSKBuffer,
    _In_  BOOLEAN  ReadOnly
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        WSKBuffer->Offset = 0;
        WSKBuffer->Length = BufferLength;

        WSKBuffer->Mdl = IoAllocateMdl(Buffer, static_cast<ULONG>(BufferLength), FALSE, FALSE, nullptr);
        if (WSKBuffer->Mdl == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        __try
        {
            MmProbeAndLockPages(WSKBuffer->Mdl, KernelMode, ReadOnly ? IoReadAccess : IoWriteAccess);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            Status = GetExceptionCode();

            IoFreeMdl(WSKBuffer->Mdl), WSKBuffer->Mdl = nullptr;
            break;
        }

    } while (false);

    return Status;
}

//NTSTATUS WSKAPI WSKLockBuffer(
//    _In_  PNET_BUFFER_LIST NetBufferList,
//    _In_  ULONG BufferOffset,
//    _Out_ PWSK_BUF WSKBuffer,
//    _In_  BOOLEAN  ReadOnly
//)
//{
//    NTSTATUS Status = STATUS_SUCCESS;
//
//    do
//    {
//        WSKBuffer->Offset = BufferOffset;
//        WSKBuffer->Length = NetBufferList->FirstNetBuffer->DataLength - BufferOffset;
//
//        WSKBuffer->Mdl = NetBufferList->FirstNetBuffer->CurrentMdl;
//        if (WSKBuffer->Mdl == nullptr)
//        {
//            Status = STATUS_INSUFFICIENT_RESOURCES;
//            break;
//        }
//
//        __try
//        {
//            if ((WSKBuffer->Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) != MDL_MAPPED_TO_SYSTEM_VA &&
//                (WSKBuffer->Mdl->MdlFlags & MDL_PAGES_LOCKED) != MDL_PAGES_LOCKED &&
//                (WSKBuffer->Mdl->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL) != MDL_SOURCE_IS_NONPAGED_POOL)
//            {
//                MmProbeAndLockPages(WSKBuffer->Mdl, KernelMode, ReadOnly ? IoReadAccess : IoWriteAccess);
//            }
//        }
//        __except (EXCEPTION_EXECUTE_HANDLER)
//        {
//            IoFreeMdl(WSKBuffer->Mdl), WSKBuffer->Mdl = nullptr;
//
//            Status = GetExceptionCode();
//            break;
//        }
//
//    } while (false);
//
//    return Status;
//}

static VOID WSKAPI WSKUnlockBuffer(
    _In_  PWSK_BUF WSKBuffer
)
{
    if (WSKBuffer)
    {
        if (WSKBuffer->Mdl)
        {
            MmUnlockPages(WSKBuffer->Mdl);
            IoFreeMdl(WSKBuffer->Mdl);
            WSKBuffer->Mdl = nullptr;
        }
    }
}

static NTSTATUS WSKCompletionRoutine(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp,
    _In_reads_opt_(_Inexpressible_("varies")) PVOID Context
);

static VOID WSKAPI WSKFreeContextIRP(
    _In_ WSK_CONTEXT_IRP* WSKContext
)
{
    if (WSKContext)
    {
        if (WSKContext->Irp)
        {
            IoFreeIrp(WSKContext->Irp);
        }

        WSKUnlockBuffer(&WSKContext->InputBuffer);
        WSKUnlockBuffer(&WSKContext->OutputBuffer);

        ExFreePoolWithTag(WSKContext, WSK_POOL_TAG);
    }
}

static WSK_CONTEXT_IRP* WSKAPI WSKAllocContextIRP(
    _In_opt_ PVOID CompletionRoutine,
    _In_opt_ PVOID Context,
    _In_opt_ BOOLEAN OnlyReadInputBuffer = true,
    _In_reads_bytes_opt_(InputSize)     PVOID InputBuffer  = nullptr,
    _In_ SIZE_T         InputSize  = 0,
    _Out_writes_bytes_opt_(OutputSize)  PVOID OutputBuffer = nullptr,
    _In_ SIZE_T         OutputSize = 0
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do 
    {
        WSKContext = static_cast<WSK_CONTEXT_IRP*>(ExAllocatePoolZero(NonPagedPool,
            sizeof(WSK_CONTEXT_IRP), WSK_POOL_TAG));
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        WSKContext->CompletionRoutine = CompletionRoutine;
        WSKContext->Context = Context;

        if (InputBuffer)
        {
            Status = WSKLockBuffer(InputBuffer, InputSize, &WSKContext->InputBuffer, OnlyReadInputBuffer);
            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }

        if (OutputBuffer)
        {
            Status = WSKLockBuffer(OutputBuffer, OutputSize, &WSKContext->OutputBuffer, false);
            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }

        if (Context == nullptr)
        {
            WSKCreateEvent(&WSKContext->Event);
        }

        WSKContext->Irp = IoAllocateIrp(1, FALSE);
        if (WSKContext->Irp == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        IoSetCompletionRoutine(WSKContext->Irp, WSKCompletionRoutine, WSKContext, TRUE, TRUE, TRUE);

    } while (false);

    if (!NT_SUCCESS(Status))
    {
        if (WSKContext)
        {
            WSKFreeContextIRP(WSKContext);
            WSKContext = nullptr;
        }
    }

    return WSKContext;
}

static NTSTATUS WSKCompletionRoutine(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp,
    _In_reads_opt_(_Inexpressible_("varies")) PVOID Context
)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    auto WSKContext = static_cast<WSK_CONTEXT_IRP*>(Context);
    if (WSKContext == nullptr)
    {
        __debugbreak();
        return STATUS_INVALID_ADDRESS;
    }

    auto Overlapped = static_cast<WSKOVERLAPPED*>(WSKContext->Context);
    if (Overlapped)
    {
        Overlapped->Internal     = Irp->IoStatus.Status;
        Overlapped->InternalHigh = Irp->IoStatus.Information;

        auto Routine = static_cast<WSK_COMPLETION_ROUTINE>(WSKContext->CompletionRoutine);
        if (Routine)
        {
            __try
            {
                Routine(Irp->IoStatus.Status, Irp->IoStatus.Information, WSKContext->Context);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                __nop();
            }
        }

        KeSetEvent(&Overlapped->Event, IO_NO_INCREMENT, FALSE);
        WSKFreeContextIRP(WSKContext);
    }
    else
    {
        KeSetEvent(&WSKContext->Event, IO_NO_INCREMENT, FALSE);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

static WSKOVERLAPPED WSKEmptyOverlapped;

//static VOID NTAPI WSKEmptyAsync(
//    _In_ NTSTATUS  Status,
//    _In_ ULONG_PTR Bytes,
//    _In_ PVOID     Context
//)
//{
//    UNREFERENCED_PARAMETER(Status);
//    UNREFERENCED_PARAMETER(Bytes);
//
//    auto Overlapped = static_cast<WSKOVERLAPPED*>(Context);
//    if (Overlapped != nullptr)
//    {
//        __debugbreak();
//    }
//    else
//    {
//        KeResetEvent(&Overlapped->Event);
//    }
//}

static NTSTATUS WSKAPI WSKCloseSocketUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType
);

static NTSTATUS WSKAPI WSKSocketUnsafeDownlevel(
    _Out_ PWSK_SOCKET* Socket,
    _In_  ADDRESS_FAMILY    AddressFamily,
    _In_  USHORT            SocketType,
    _In_  ULONG             Protocol,
    _In_  ULONG             Flags,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        const auto WSKContext = WSKAllocContextIRP(nullptr, nullptr);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        if (Protocol == 0)
        {
            switch (SocketType)
            {
            case SOCK_STREAM:
                Protocol = IPPROTO_TCP;
                break;

            case SOCK_DGRAM:
                Protocol = IPPROTO_UDP;
                break;

            case SOCK_RAW:
                Protocol = IPPROTO_RAW;
                break;
            default:
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
        }
        if (!NT_SUCCESS(Status)) {
            break;
        }

        Status = WSKNPIProvider.Dispatch->WskSocket(
            WSKNPIProvider.Client,
            AddressFamily,
            SocketType,
            Protocol,
            Flags,
            nullptr,
            nullptr,
            nullptr,
            nullptr,
            SecurityDescriptor,
            WSKContext->Irp);

        if (Status == STATUS_PENDING)
        {
            LARGE_INTEGER Timeout{};

            Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                FALSE, WSKTimeoutToLargeInteger(WSK_INFINITE_WAIT, &Timeout));
            if (Status == STATUS_SUCCESS)
            {
                Status = WSKContext->Irp->IoStatus.Status;
            }
        }

        if (NT_SUCCESS(Status))
        {
            *Socket = static_cast<PWSK_SOCKET>(reinterpret_cast<void*>(
                WSKContext->Irp->IoStatus.Information));
        }

        WSKFreeContextIRP(WSKContext);

    } while (false);

    return Status;
}

static NTSTATUS WSKAPI WSKSocketUnsafe(
    _Out_ PWSK_SOCKET*      Socket,
    _In_  ADDRESS_FAMILY    AddressFamily,
    _In_  USHORT            SocketType,
    _In_  ULONG             Protocol,
    _In_  ULONG             Flags,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    *Socket = nullptr;

    if (!InterlockedCompareExchange(&_Initialized, true, true))
    {
        Status = STATUS_NDIS_ADAPTER_NOT_READY;
        return Status;
    }

#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
    Status = WSKSocketUnsafeDownlevel(Socket, AddressFamily, SocketType, Protocol, Flags, SecurityDescriptor);
#else
    WSK_SOCKET* Stream  = nullptr;
    WSK_SOCKET* Listen  = nullptr;
    WSK_SOCKET* Connect = nullptr;

    do
    {
        if (Flags != WSK_FLAG_STREAM_SOCKET)
        {
            Status = WSKSocketUnsafeDownlevel(Socket, AddressFamily, SocketType, Protocol, Flags, SecurityDescriptor);
            break;
        }

        Stream = static_cast<PWSK_SOCKET>(ExAllocatePoolZero(NonPagedPool,
            sizeof(WSK_STREAM_SOCKET_WIN7), WSK_POOL_TAG));
        if (Stream == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = WSKSocketUnsafeDownlevel(&Listen, AddressFamily, SocketType, Protocol, WSK_FLAG_LISTEN_SOCKET, SecurityDescriptor);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = WSKSocketUnsafeDownlevel(&Connect, AddressFamily, SocketType, Protocol, WSK_FLAG_CONNECTION_SOCKET, SecurityDescriptor);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        auto StreamImpl = reinterpret_cast<WSK_STREAM_SOCKET_WIN7*>(Stream);
        StreamImpl->Mode    = 0;
        StreamImpl->Listen  = Listen;
        StreamImpl->Connect = Connect;

        *Socket = Stream;

    } while (false);

    if (!NT_SUCCESS(Status))
    {
        if (Listen)
        {
            WSKCloseSocketUnsafe(Listen, WSK_FLAG_LISTEN_SOCKET);
        }

        if (Connect)
        {
            WSKCloseSocketUnsafe(Connect, WSK_FLAG_CONNECTION_SOCKET);
        }

        if (Stream)
        {
            ExFreePoolWithTag(Stream, WSK_POOL_TAG);
        }
    }
#endif

    return Status;
}

static NTSTATUS WSKAPI WSKCloseSocketUnsafeDownlevel(
    _In_ PWSK_SOCKET Socket
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        const auto WSKContext = WSKAllocContextIRP(nullptr, nullptr);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        auto Dispatch = static_cast<const WSK_PROVIDER_BASIC_DISPATCH*>(Socket->Dispatch);

        Status = Dispatch->WskCloseSocket(Socket, WSKContext->Irp);
        if (Status == STATUS_PENDING)
        {
            LARGE_INTEGER Timeout{};

            Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                FALSE, WSKTimeoutToLargeInteger(WSK_INFINITE_WAIT, &Timeout));
            if (Status == STATUS_SUCCESS)
            {
                Status = WSKContext->Irp->IoStatus.Status;
            }
        }

        WSKFreeContextIRP(WSKContext);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKCloseSocketUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType
)
{
    UNREFERENCED_PARAMETER(WskSocketType);

    NTSTATUS Status = STATUS_SUCCESS;

    if (!InterlockedCompareExchange(&_Initialized, true, true))
    {
        Status = STATUS_NDIS_ADAPTER_NOT_READY;
        return Status;
    }

    if (Socket == nullptr)
    {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
    Status = WSKCloseSocketUnsafeDownlevel(Socket);
#else
    do
    {
        if (WskSocketType != WSK_FLAG_STREAM_SOCKET)
        {
            Status = WSKCloseSocketUnsafeDownlevel(Socket);
            break;
        }

        Status = WSKCloseSocketUnsafeDownlevel(reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Listen);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = WSKCloseSocketUnsafeDownlevel(reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Connect);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        ExFreePoolWithTag(Socket, WSK_POOL_TAG);

    } while (false);
#endif

    return Status;
}

NTSTATUS WSKAPI WSKBindUnsafe(
    _In_ PWSK_SOCKET Socket,
    _In_ ULONG       WskSocketType,
    _In_ PSOCKADDR   LocalAddress,
    _In_ SIZE_T      LocalAddressLength
);

static NTSTATUS WSKAPI WSKControlSocketUnsafeDownlevel(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType,
    _In_ WSK_CONTROL_SOCKET_TYPE RequestType,
    _In_ ULONG          ControlCode,
    _In_ ULONG          OptionLevel,
    _In_reads_bytes_opt_(InputSize)     PVOID InputBuffer,
    _In_ SIZE_T         InputSize,
    _Out_writes_bytes_opt_(OutputSize)  PVOID OutputBuffer,
    _In_ SIZE_T         OutputSize,
    _Out_opt_ SIZE_T*   OutputSizeReturned,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        if (RequestType == WskGetOption && OptionLevel == SOL_SOCKET && ControlCode == SO_TYPE)
        {
            if (OutputSize != sizeof(int) || OutputBuffer == nullptr)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if (OutputSizeReturned)
            {
                *OutputSizeReturned = OutputSize;
            }

            if (WskSocketType == WSK_FLAG_DATAGRAM_SOCKET)
            {
                *static_cast<int*>(OutputBuffer) = SOCK_DGRAM;
            }
            else
            {
                *static_cast<int*>(OutputBuffer) = SOCK_STREAM;
            }

            Status = STATUS_SUCCESS;
            break;
        }

        if (RequestType == WskIoctl)
        {
            if (ControlCode == SIO_WSK_SET_REMOTE_ADDRESS ||
                ControlCode == SIO_WSK_SET_SENDTO_ADDRESS)
            {
                if (WskSocketType != WSK_FLAG_DATAGRAM_SOCKET)
                {
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    break;
                }

                auto RemoteAddress = static_cast<PSOCKADDR>(InputBuffer);
                if (RemoteAddress == nullptr || InputSize < sizeof SOCKADDR)
                {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                SOCKADDR_STORAGE LocalAddress{};
                LocalAddress.ss_family = RemoteAddress->sa_family;

                Status = WSKBindUnsafe(Socket, WskSocketType, reinterpret_cast<PSOCKADDR>(&LocalAddress), sizeof LocalAddress);
                if (!NT_SUCCESS(Status))
                {
                    break;
                }

                // Not break;
            }
        }

        WSKContext = WSKAllocContextIRP((PVOID)CompletionRoutine, Overlapped);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        auto Dispatch = static_cast<const WSK_PROVIDER_BASIC_DISPATCH*>(Socket->Dispatch);

        Status = Dispatch->WskControlSocket(
            Socket,
            RequestType,
            ControlCode,
            OptionLevel,
            InputSize,
            InputBuffer,
            OutputSize,
            OutputBuffer,
            OutputSizeReturned,
            WSKContext->Irp);

        if (Overlapped == nullptr)
        {
            if (Status == STATUS_PENDING)
            {
                LARGE_INTEGER Timeout{};

                Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                    FALSE, WSKTimeoutToLargeInteger(WSK_INFINITE_WAIT, &Timeout));
                if (Status == STATUS_SUCCESS)
                {
                    Status = WSKContext->Irp->IoStatus.Status;
                }
            }

            WSKFreeContextIRP(WSKContext);
        }

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKControlSocketUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType,
    _In_ WSK_CONTROL_SOCKET_TYPE RequestType,
    _In_ ULONG          ControlCode,
    _In_ ULONG          OptionLevel,
    _In_reads_bytes_opt_(InputSize)     PVOID InputBuffer,
    _In_ SIZE_T         InputSize,
    _Out_writes_bytes_opt_(OutputSize)  PVOID OutputBuffer,
    _In_ SIZE_T         OutputSize,
    _Out_opt_ SIZE_T* OutputSizeReturned,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!InterlockedCompareExchange(&_Initialized, true, true))
    {
        Status = STATUS_NDIS_ADAPTER_NOT_READY;
        return Status;
    }

    if (Socket == nullptr)
    {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
    Status = WSKControlSocketUnsafeDownlevel(Socket, WskSocketType, RequestType, ControlCode, OptionLevel,
        InputBuffer, InputSize, OutputBuffer, OutputSize, OutputSizeReturned, Overlapped, CompletionRoutine);
#else
    do
    {
        if (WskSocketType != WSK_FLAG_STREAM_SOCKET)
        {
            Status = WSKControlSocketUnsafeDownlevel(Socket, WskSocketType, RequestType, ControlCode, OptionLevel,
                InputBuffer, InputSize, OutputBuffer, OutputSize, OutputSizeReturned, Overlapped, CompletionRoutine);
            break;
        }

        if (reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Mode == 2)
        {
            Socket        = reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Connect;
            WskSocketType = WSK_FLAG_CONNECTION_SOCKET;
        }
        else
        {
            Socket        = reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Listen;
            WskSocketType = WSK_FLAG_LISTEN_SOCKET;
        }

        Status = WSKControlSocketUnsafeDownlevel(Socket, WskSocketType, RequestType, ControlCode, OptionLevel,
            InputBuffer, InputSize, OutputBuffer, OutputSize, OutputSizeReturned, Overlapped, CompletionRoutine);

    } while (false);
#endif

    return Status;
}

static NTSTATUS WSKAPI WSKBindUnsafeDownlevel(
    _In_ PWSK_SOCKET Socket,
    _In_ ULONG       WskSocketType,
    _In_ PSOCKADDR   LocalAddress,
    _In_ SIZE_T      LocalAddressLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        UNREFERENCED_PARAMETER(LocalAddressLength);

        PFN_WSK_BIND WSKBindRoutine = nullptr;

        switch (WskSocketType)
        {
        case WSK_FLAG_LISTEN_SOCKET:
            WSKBindRoutine = static_cast<const WSK_PROVIDER_LISTEN_DISPATCH*>(Socket->Dispatch)->WskBind;
            break;
        case WSK_FLAG_DATAGRAM_SOCKET:
            WSKBindRoutine = static_cast<const WSK_PROVIDER_DATAGRAM_DISPATCH*>(Socket->Dispatch)->WskBind;
            break;
        case WSK_FLAG_CONNECTION_SOCKET:
            WSKBindRoutine = static_cast<const WSK_PROVIDER_CONNECTION_DISPATCH*>(Socket->Dispatch)->WskBind;
            break;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        case WSK_FLAG_STREAM_SOCKET:
            WSKBindRoutine = static_cast<const WSK_PROVIDER_STREAM_DISPATCH*>(Socket->Dispatch)->WskBind;
            break;
#endif // if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        default:
            break;
        }

        if (WSKBindRoutine == nullptr)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        WSKContext = WSKAllocContextIRP(nullptr, nullptr);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = WSKBindRoutine(
            Socket,
            LocalAddress,
            0,
            WSKContext->Irp);

        if (Status == STATUS_PENDING)
        {
            LARGE_INTEGER Timeout{};

            Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                FALSE, WSKTimeoutToLargeInteger(WSK_INFINITE_WAIT, &Timeout));
            if (Status == STATUS_SUCCESS)
            {
                Status = WSKContext->Irp->IoStatus.Status;
            }
        }

        WSKFreeContextIRP(WSKContext);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKBindUnsafe(
    _In_ PWSK_SOCKET Socket,
    _In_ ULONG       WskSocketType,
    _In_ PSOCKADDR   LocalAddress,
    _In_ SIZE_T      LocalAddressLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!InterlockedCompareExchange(&_Initialized, true, true))
    {
        Status = STATUS_NDIS_ADAPTER_NOT_READY;
        return Status;
    }

    if (Socket == nullptr || LocalAddress == nullptr || (LocalAddressLength < sizeof SOCKADDR))
    {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

    if ((LocalAddress->sa_family == AF_INET  && LocalAddressLength < sizeof SOCKADDR_IN) ||
        (LocalAddress->sa_family == AF_INET6 && LocalAddressLength < sizeof SOCKADDR_IN6))
    {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
    Status = WSKBindUnsafeDownlevel(Socket, WskSocketType, LocalAddress, LocalAddressLength);
#else
    if (WskSocketType == WSK_FLAG_STREAM_SOCKET)
    {
        Socket        = reinterpret_cast<PWSK_STREAM_SOCKET_WIN7>(Socket)->Listen;
        WskSocketType = WSK_FLAG_LISTEN_SOCKET;
    }

    Status = WSKBindUnsafeDownlevel(Socket, WskSocketType, LocalAddress, LocalAddressLength);
#endif

    return Status;
}

NTSTATUS WSKAPI WSKAcceptUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType,
    _Out_ PWSK_SOCKET*  SocketClient,
    _Out_opt_ PSOCKADDR LocalAddress,
    _In_ SIZE_T         LocalAddressLength,
    _Out_opt_ PSOCKADDR RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        *SocketClient = nullptr;

        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == nullptr)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if ((LocalAddress  && (LocalAddressLength  < sizeof SOCKADDR)) ||
            (RemoteAddress && (RemoteAddressLength < sizeof SOCKADDR)))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

#if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)
        if (WskSocketType == WSK_FLAG_STREAM_SOCKET)
        {
            if (reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Mode != 1)
            {
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            Socket        = reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Listen;
            WskSocketType = WSK_FLAG_LISTEN_SOCKET;
        }
#endif // #if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)

        PFN_WSK_ACCEPT WSKAcceptRoutine = nullptr;

        switch (WskSocketType)
        {
        case WSK_FLAG_LISTEN_SOCKET:
            WSKAcceptRoutine = static_cast<const WSK_PROVIDER_LISTEN_DISPATCH*>(Socket->Dispatch)->WskAccept;
            break;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        case WSK_FLAG_STREAM_SOCKET:
            WSKAcceptRoutine = static_cast<const WSK_PROVIDER_STREAM_DISPATCH*>(Socket->Dispatch)->WskAccept;
            break;
#endif // if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        default:
            break;
        }

        if (WSKAcceptRoutine == nullptr)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        WSKContext = WSKAllocContextIRP(nullptr, nullptr);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = WSKAcceptRoutine(
            Socket,
            0,
            nullptr,
            nullptr,
            LocalAddress,
            RemoteAddress,
            WSKContext->Irp);

        if (Status == STATUS_PENDING)
        {
            LARGE_INTEGER Timeout{};

            Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                FALSE, WSKTimeoutToLargeInteger(WSK_INFINITE_WAIT, &Timeout));
            if (Status == STATUS_SUCCESS)
            {
                Status = WSKContext->Irp->IoStatus.Status;
            }
        }

        if (Status == STATUS_SUCCESS)
        {
            *SocketClient = reinterpret_cast<PWSK_SOCKET>(WSKContext->Irp->IoStatus.Information);
        }

        WSKFreeContextIRP(WSKContext);

    } while (false);

    return Status;
}

#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
static NTSTATUS WSKAPI WSKListenUnsafeDownlevel(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        PFN_WSK_LISTEN WSKListenRoutine = nullptr;

        switch (WskSocketType)
        {
        case WSK_FLAG_STREAM_SOCKET:
            WSKListenRoutine = static_cast<const WSK_PROVIDER_STREAM_DISPATCH*>(Socket->Dispatch)->WskListen;
            break;
        default:
            break;
        }

        if (WSKListenRoutine == nullptr)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        WSKContext = WSKAllocContextIRP(nullptr, nullptr);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = WSKListenRoutine(
            Socket,
            WSKContext->Irp);

        if (Status == STATUS_PENDING)
        {
            LARGE_INTEGER Timeout{};

            Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                FALSE, WSKTimeoutToLargeInteger(WSK_INFINITE_WAIT, &Timeout));
            if (Status == STATUS_SUCCESS)
            {
                Status = WSKContext->Irp->IoStatus.Status;
            }
        }

        WSKFreeContextIRP(WSKContext);

    } while (false);

    return Status;
}
#endif

NTSTATUS WSKAPI WSKListenUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!InterlockedCompareExchange(&_Initialized, true, true))
    {
        Status = STATUS_NDIS_ADAPTER_NOT_READY;
        return Status;
}

    if (Socket == nullptr)
    {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
    Status = WSKListenUnsafeDownlevel(Socket, WskSocketType);
#else
    UNREFERENCED_PARAMETER(Socket);
    UNREFERENCED_PARAMETER(WskSocketType);

    if (WskSocketType == WSK_FLAG_STREAM_SOCKET)
    {
        if (reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Mode != 0)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            return Status;
        }
        else
        {
            reinterpret_cast<WSK_STREAM_SOCKET_WIN7*>(Socket)->Mode = 1;
        }
    }
#endif

    return Status;
}

NTSTATUS WSKAPI WSKConnectUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType,
    _In_ PSOCKADDR      RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == nullptr || RemoteAddress == nullptr || (RemoteAddressLength < sizeof SOCKADDR))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if ((RemoteAddress->sa_family == AF_INET  && RemoteAddressLength < sizeof SOCKADDR_IN) ||
            (RemoteAddress->sa_family == AF_INET6 && RemoteAddressLength < sizeof SOCKADDR_IN6))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

#if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)
        if (WskSocketType == WSK_FLAG_STREAM_SOCKET)
        {
            if (reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Mode != 0)
            {
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            else
            {
                reinterpret_cast<WSK_STREAM_SOCKET_WIN7*>(Socket)->Mode = 2;
            }

            Socket        = reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Connect;
            WskSocketType = WSK_FLAG_CONNECTION_SOCKET;
        }
#endif // #if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)

        SOCKADDR_STORAGE LocalAddress{};
        LocalAddress.ss_family = RemoteAddress->sa_family;

        Status = WSKBindUnsafe(Socket, WskSocketType, reinterpret_cast<PSOCKADDR>(&LocalAddress), sizeof LocalAddress);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        PFN_WSK_CONNECT WSKConnectRoutine = nullptr;

        switch (WskSocketType)
        {
        case WSK_FLAG_CONNECTION_SOCKET:
            WSKConnectRoutine = static_cast<const WSK_PROVIDER_CONNECTION_DISPATCH*>(Socket->Dispatch)->WskConnect;
            break;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        case WSK_FLAG_STREAM_SOCKET:
            WSKConnectRoutine = static_cast<const WSK_PROVIDER_STREAM_DISPATCH*>(Socket->Dispatch)->WskConnect;
            break;
#endif // if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        default:
            break;
        }

        if (WSKConnectRoutine == nullptr)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        WSKContext = WSKAllocContextIRP(nullptr, nullptr);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = WSKConnectRoutine(
            Socket,
            RemoteAddress,
            0,
            WSKContext->Irp);

        if (Status == STATUS_PENDING)
        {
            LARGE_INTEGER Timeout{};

            Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                FALSE, WSKTimeoutToLargeInteger(WSK_INFINITE_WAIT, &Timeout));
            if (Status == STATUS_SUCCESS)
            {
                Status = WSKContext->Irp->IoStatus.Status;
            }
        }

        WSKFreeContextIRP(WSKContext);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKDisconnectUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType,
    _In_opt_ PWSK_BUF   Buffer,
    _In_ ULONG          Flags
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == nullptr)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

#if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)
        if (WskSocketType == WSK_FLAG_STREAM_SOCKET)
        {
            if (reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Mode != 2)
            {
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            Socket        = reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Connect;
            WskSocketType = WSK_FLAG_CONNECTION_SOCKET;
        }
#endif // #if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)

        PFN_WSK_DISCONNECT WSKDisconnectRoutine = nullptr;

        switch (WskSocketType)
        {
        case WSK_FLAG_CONNECTION_SOCKET:
            WSKDisconnectRoutine = static_cast<const WSK_PROVIDER_CONNECTION_DISPATCH*>(Socket->Dispatch)->WskDisconnect;
            break;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        case WSK_FLAG_STREAM_SOCKET:
            WSKDisconnectRoutine = static_cast<const WSK_PROVIDER_STREAM_DISPATCH*>(Socket->Dispatch)->WskDisconnect;
            break;
#endif // if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        default:
            break;
        }

        if (WSKDisconnectRoutine == nullptr)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        WSKContext = WSKAllocContextIRP(nullptr, nullptr);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = WSKDisconnectRoutine(
            Socket,
            Buffer,
            Flags,
            WSKContext->Irp);

        if (Status == STATUS_PENDING)
        {
            LARGE_INTEGER Timeout{};

            Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                FALSE, WSKTimeoutToLargeInteger(WSK_INFINITE_WAIT, &Timeout));
            if (Status == STATUS_SUCCESS)
            {
                Status = WSKContext->Irp->IoStatus.Status;
            }
        }

        WSKFreeContextIRP(WSKContext);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKSendUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesSent,
    _In_ ULONG          Flags,
    _In_opt_ ULONG     TimeoutMilliseconds,
    _In_opt_ WSKOVERLAPPED* Overlapped,
    _In_opt_ LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        if (NumberOfBytesSent)
        {
            *NumberOfBytesSent = 0u;
        }

        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == nullptr)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

#if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)
        if (WskSocketType == WSK_FLAG_STREAM_SOCKET)
        {
            if (reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Mode != 2)
            {
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            Socket        = reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Connect;
            WskSocketType = WSK_FLAG_CONNECTION_SOCKET;
        }
#endif // #if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)

        PFN_WSK_SEND WSKSendRoutine = nullptr;

        switch (WskSocketType)
        {
        case WSK_FLAG_CONNECTION_SOCKET:
            WSKSendRoutine = static_cast<const WSK_PROVIDER_CONNECTION_DISPATCH*>(Socket->Dispatch)->WskSend;
            break;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        case WSK_FLAG_STREAM_SOCKET:
            WSKSendRoutine = static_cast<const WSK_PROVIDER_STREAM_DISPATCH*>(Socket->Dispatch)->WskSend;
            break;
#endif // if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        default:
            break;
        }

        if (WSKSendRoutine == nullptr)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        WSKContext = WSKAllocContextIRP((PVOID)CompletionRoutine, Overlapped, true, Buffer, BufferLength);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = WSKSendRoutine(
            Socket,
            &WSKContext->InputBuffer,
            Flags,
            WSKContext->Irp);

        if (Overlapped == nullptr)
        {
            if (Status == STATUS_PENDING)
            {
                LARGE_INTEGER Timeout{};

                Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                    FALSE, WSKTimeoutToLargeInteger(TimeoutMilliseconds, &Timeout));

                if (Status == STATUS_TIMEOUT)
                {
                    IoCancelIrp(WSKContext->Irp);
                    KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode, FALSE, nullptr);
                }

                if (Status == STATUS_SUCCESS)
                {
                    Status = WSKContext->Irp->IoStatus.Status;
                }
            }

            if (NumberOfBytesSent)
            {
                *NumberOfBytesSent = WSKContext->Irp->IoStatus.Information;
            }

            WSKFreeContextIRP(WSKContext);
        }

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKSendToUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesSent,
    _Reserved_ ULONG    Flags,
    _In_opt_ PSOCKADDR  RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength,
    _In_opt_ ULONG      /*TimeoutMilliseconds*/,
    _In_opt_ WSKOVERLAPPED* Overlapped,
    _In_opt_ LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        if (NumberOfBytesSent)
        {
            *NumberOfBytesSent = 0u;
        }

        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == nullptr)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (RemoteAddress)
        {
            if (RemoteAddressLength < sizeof SOCKADDR)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if ((RemoteAddress->sa_family == AF_INET  && RemoteAddressLength < sizeof SOCKADDR_IN) ||
                (RemoteAddress->sa_family == AF_INET6 && RemoteAddressLength < sizeof SOCKADDR_IN6))
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
        }

        PFN_WSK_SEND_TO WSKSendToRoutine = nullptr;

        switch (WskSocketType)
        {
        case WSK_FLAG_DATAGRAM_SOCKET:
            WSKSendToRoutine = static_cast<const WSK_PROVIDER_DATAGRAM_DISPATCH*>(Socket->Dispatch)->WskSendTo;
            break;
        default:
            break;
        }

        if (WSKSendToRoutine == nullptr)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        if (Overlapped == nullptr)
        {
            Overlapped = &WSKEmptyOverlapped;
        }

        WSKContext = WSKAllocContextIRP((PVOID)CompletionRoutine, Overlapped, true, Buffer, BufferLength);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = WSKSendToRoutine(
            Socket,
            &WSKContext->InputBuffer,
            Flags,
            RemoteAddress,
            0,
            nullptr,
            WSKContext->Irp);

        if (NumberOfBytesSent)
        {
            if (Status == STATUS_SUCCESS)
            {
                *NumberOfBytesSent = WSKContext->Irp->IoStatus.Information;
            }
            else
            {
                *NumberOfBytesSent = BufferLength;
            }
        }

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKReceiveUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesRecvd,
    _In_ ULONG          Flags,
    _In_opt_ ULONG      TimeoutMilliseconds,
    _In_opt_ WSKOVERLAPPED* Overlapped,
    _In_opt_ LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        if (NumberOfBytesRecvd)
        {
            *NumberOfBytesRecvd = 0;
        }

        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == nullptr)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

#if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)
        if (WskSocketType == WSK_FLAG_STREAM_SOCKET)
        {
            if (reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Mode != 2)
            {
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            Socket        = reinterpret_cast<const WSK_STREAM_SOCKET_WIN7*>(Socket)->Connect;
            WskSocketType = WSK_FLAG_CONNECTION_SOCKET;
        }
#endif // #if !(NTDDI_VERSION >= NTDDI_WIN10_RS2)

        PFN_WSK_RECEIVE WSKReceiveRoutine = nullptr;

        switch (WskSocketType)
        {
        case WSK_FLAG_CONNECTION_SOCKET:
            WSKReceiveRoutine = static_cast<const WSK_PROVIDER_CONNECTION_DISPATCH*>(Socket->Dispatch)->WskReceive;
            break;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        case WSK_FLAG_STREAM_SOCKET:
            WSKReceiveRoutine = static_cast<const WSK_PROVIDER_STREAM_DISPATCH*>(Socket->Dispatch)->WskReceive;
            break;
#endif // #if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        default:
            break;
        }

        if (WSKReceiveRoutine == nullptr)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        WSKContext = WSKAllocContextIRP((PVOID)CompletionRoutine, Overlapped, true, nullptr, 0, Buffer, BufferLength);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = WSKReceiveRoutine(
            Socket,
            &WSKContext->OutputBuffer,
            Flags,
            WSKContext->Irp);

        if (Overlapped == nullptr)
        {
            if (Status == STATUS_PENDING)
            {
                LARGE_INTEGER Timeout{};

                Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                    FALSE, WSKTimeoutToLargeInteger(TimeoutMilliseconds, &Timeout));

                if (Status == STATUS_TIMEOUT)
                {
                    IoCancelIrp(WSKContext->Irp);
                    KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode, FALSE, nullptr);
                }

                if (Status == STATUS_SUCCESS)
                {
                    Status = WSKContext->Irp->IoStatus.Status;
                }
            }

            if (NumberOfBytesRecvd)
            {
                *NumberOfBytesRecvd = WSKContext->Irp->IoStatus.Information;
            }

            WSKFreeContextIRP(WSKContext);
        }

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKReceiveFromUnsafe(
    _In_ PWSK_SOCKET    Socket,
    _In_ ULONG          WskSocketType,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesRecvd,
    _Reserved_ ULONG    Flags,
    _Out_opt_ PSOCKADDR RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength,
    _In_opt_ ULONG      TimeoutMilliseconds,
    _In_opt_ WSKOVERLAPPED* Overlapped,
    _In_opt_ LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        if (NumberOfBytesRecvd)
        {
            *NumberOfBytesRecvd = 0;
        }

        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == nullptr)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (RemoteAddress)
        {
            if (RemoteAddressLength < sizeof SOCKADDR)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
        }

        PFN_WSK_RECEIVE_FROM WSKReceiveFromRoutine = nullptr;

        switch (WskSocketType)
        {
        case WSK_FLAG_DATAGRAM_SOCKET:
            WSKReceiveFromRoutine = static_cast<const WSK_PROVIDER_DATAGRAM_DISPATCH*>(Socket->Dispatch)->WskReceiveFrom;
            break;
        default:
            break;
        }

        if (WSKReceiveFromRoutine == nullptr)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        WSKContext = WSKAllocContextIRP((PVOID)CompletionRoutine, Overlapped, true, nullptr, 0, Buffer, BufferLength);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ULONG ControlFlags  = 0;
        ULONG ControlLength = 0;

        Status = WSKReceiveFromRoutine(
            Socket,
            &WSKContext->OutputBuffer,
            Flags,
            RemoteAddress,
            &ControlLength,
            nullptr,
            &ControlFlags,
            WSKContext->Irp);

        if (Overlapped == nullptr)
        {
            if (Status == STATUS_PENDING)
            {
                LARGE_INTEGER Timeout{};

                Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                    FALSE, WSKTimeoutToLargeInteger(TimeoutMilliseconds, &Timeout));

                if (Status == STATUS_TIMEOUT)
                {
                    IoCancelIrp(WSKContext->Irp);
                    KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode, FALSE, nullptr);
                }

                if (Status == STATUS_SUCCESS)
                {
                    Status = WSKContext->Irp->IoStatus.Status;
                }
            }

            if (NumberOfBytesRecvd)
            {
                *NumberOfBytesRecvd = WSKContext->Irp->IoStatus.Information;
            }

            WSKFreeContextIRP(WSKContext);
        }

    } while (false);

    return Status;
}

//////////////////////////////////////////////////////////////////////////
// Public  Function

#ifdef __cplusplus
extern "C" {
#endif

VOID WSKAPI WSKSetLastError(
    _In_ NTSTATUS Status
)
{
    _LastNtStatus = Status;
}

NTSTATUS WSKAPI WSKGetLastError()
{
    return _LastNtStatus;
}

NTSTATUS WSKAPI WSKStartup(_In_ UINT16 Version, _Out_ WSKDATA* WSKData)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do 
    {
        *WSKData = {};

        if (InterlockedCompareExchange(&_Initialized, true, true))
        {
            WSK_PROVIDER_CHARACTERISTICS Caps;
            Status = WskQueryProviderCharacteristics(&WSKRegistration, &Caps);
            if (!NT_SUCCESS(Status))
            {
                break;
            }

            WSKData->HighestVersion = Caps.HighestVersion;
            WSKData->LowestVersion  = Caps.LowestVersion;

            break;
        }

        ExInitializeDriverRuntime(DrvRtPoolNxOptIn);

        WSKSocketsAVLTableInitialize();

        WSK_CLIENT_NPI NPIClient{};
        NPIClient.ClientContext = nullptr;
        NPIClient.Dispatch = &WSKClientDispatch;

        WSKClientDispatch.Version = Version;

        Status = WskRegister(&NPIClient, &WSKRegistration);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        WSK_PROVIDER_CHARACTERISTICS Caps;
        Status = WskQueryProviderCharacteristics(&WSKRegistration, &Caps);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        WSKData->HighestVersion = Caps.HighestVersion;
        WSKData->LowestVersion  = Caps.LowestVersion;

        Status = WskCaptureProviderNPI(&WSKRegistration, WSK_INFINITE_WAIT, &WSKNPIProvider);
        if (!NT_SUCCESS(Status))
        {
            WskDeregister(&WSKRegistration);
            break;
        }

        WSKCreateEvent(&WSKEmptyOverlapped.Event);

        InterlockedCompareExchange(&_Initialized, true, false);

    } while (false);

    return Status;
}

VOID WSKAPI WSKCleanup()
{
    if (InterlockedCompareExchange(&_Initialized, false, true))
    {
        WSKSocketsAVLTableCleanup();

        WskReleaseProviderNPI(&WSKRegistration);
        WskDeregister(&WSKRegistration);

        WSKNPIProvider = {};
    }
}

VOID WSKAPI WSKCreateEvent(_Out_ KEVENT* Event)
{
    KeInitializeEvent(Event, NotificationEvent, FALSE);
}

NTSTATUS WSKAPI WSKGetOverlappedResult(
    _In_  SOCKET         Socket,
    _In_  WSKOVERLAPPED* Overlapped,
    _Out_opt_ SIZE_T*    TransferBytes,
    _In_  BOOLEAN        Wait
)
{
    UNREFERENCED_PARAMETER(Socket);

    NTSTATUS Status = STATUS_SUCCESS;

    do 
    {
        if (TransferBytes)
        {
            *TransferBytes = 0u;
        }

        if (Overlapped->Internal == STATUS_PENDING)
        {
            if (!Wait)
            {
                Status = STATUS_TIMEOUT;
                break;
            }

            Status = KeWaitForSingleObject(&Overlapped->Event, Executive, KernelMode, FALSE, nullptr);
            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }

        if (TransferBytes)
        {
            /* Return bytes transferred */
            *TransferBytes = Overlapped->InternalHigh;
        }

        /* Check for failure during I/O */
        if (!NT_SUCCESS(Overlapped->Internal))
        {
            /* Set the error and fail */
            Status = static_cast<NTSTATUS>(Overlapped->Internal);
        }

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKGetAddrInfo(
    _In_opt_ LPCWSTR        NodeName,
    _In_opt_ LPCWSTR        ServiceName,
    _In_     UINT32         Namespace,
    _In_opt_ GUID*          Provider,
    _In_opt_ PADDRINFOEXW   Hints,
    _Outptr_result_maybenull_ PADDRINFOEXW* Result,
    _In_opt_ UINT32         TimeoutMilliseconds,
    _In_opt_ WSKOVERLAPPED* Overlapped,
    _In_opt_ LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        *Result = nullptr;

        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        WSKContext = WSKAllocContextIRP((PVOID)CompletionRoutine, Overlapped);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        // The Context is query result. if block mode.
        auto QueryResult = reinterpret_cast<PADDRINFOEXW*>(&WSKContext->Pointer);
        if (Overlapped != nullptr)
        {
            QueryResult = reinterpret_cast<PADDRINFOEXW*>(&Overlapped->Pointer);
        }

        UNICODE_STRING NodeNameS{};
        UNICODE_STRING ServiceNameS{};

        RtlInitUnicodeString(&NodeNameS, NodeName);
        RtlInitUnicodeString(&ServiceNameS, ServiceName);

        Status = WSKNPIProvider.Dispatch->WskGetAddressInfo(
            WSKNPIProvider.Client,
            NodeName    ? &NodeNameS    : nullptr,
            ServiceName ? &ServiceNameS : nullptr,
            Namespace,
            Provider,
            Hints,
            QueryResult,
            nullptr,
            nullptr,
            WSKContext->Irp);

        if (Overlapped == nullptr)
        {
            if (Status == STATUS_PENDING)
            {
                LARGE_INTEGER Timeout{};

                Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                    FALSE, WSKTimeoutToLargeInteger(TimeoutMilliseconds, &Timeout));

                if (Status == STATUS_TIMEOUT)
                {
                    IoCancelIrp(WSKContext->Irp);
                    KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode, FALSE, nullptr);
                }

                if (Status == STATUS_SUCCESS)
                {
                    Status = WSKContext->Irp->IoStatus.Status;
                }
            }

            *Result = static_cast<PADDRINFOEXW>(WSKContext->Pointer);

            WSKFreeContextIRP(WSKContext);
        }

    } while (false);

    return Status;
}

VOID WSKAPI WSKFreeAddrInfo(
    _In_ PADDRINFOEXW Data
)
{
    if (!InterlockedCompareExchange(&_Initialized, true, true))
    {
        return;
    }

    if (Data)
    {
        WSKNPIProvider.Dispatch->WskFreeAddressInfo(
            WSKNPIProvider.Client,
            Data);
    }
}

NTSTATUS WSKAPI WSKGetNameInfo(
    _In_ const SOCKADDR* Address,
    _In_ ULONG      AddressLength,
    _Out_writes_opt_(NodeNameSize)      LPWSTR  NodeName,
    _In_ ULONG      NodeNameSize,
    _Out_writes_opt_(ServiceNameSize)   LPWSTR  ServiceName,
    _In_ ULONG      ServiceNameSize,
    _In_ ULONG      Flags
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WSK_CONTEXT_IRP* WSKContext = nullptr;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (NodeName == nullptr && ServiceName == nullptr)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        WSKContext = WSKAllocContextIRP(nullptr, nullptr);
        if (WSKContext == nullptr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        UNICODE_STRING NodeNameS{};
        UNICODE_STRING ServiceNameS{};

        if (NodeName)
        {
            RtlInitEmptyUnicodeString(&NodeNameS, NodeName, static_cast<USHORT>(NodeNameSize));
        }
        if (ServiceName)
        {
            RtlInitEmptyUnicodeString(&ServiceNameS, ServiceName, static_cast<USHORT>(ServiceNameSize));
        }

        Status = WSKNPIProvider.Dispatch->WskGetNameInfo(
            WSKNPIProvider.Client,
            const_cast<PSOCKADDR>(Address),
            AddressLength,
            NodeName    ? &NodeNameS    : nullptr,
            ServiceName ? &ServiceNameS : nullptr,
            Flags,
            nullptr,
            nullptr,
            WSKContext->Irp);

        if (Status == STATUS_PENDING)
        {
            LARGE_INTEGER Timeout{};

            Status = KeWaitForSingleObject(&WSKContext->Event, Executive, KernelMode,
                FALSE, WSKTimeoutToLargeInteger(WSK_INFINITE_WAIT, &Timeout));
            if (Status == STATUS_SUCCESS)
            {
                Status = WSKContext->Irp->IoStatus.Status;
            }
        }

        WSKFreeContextIRP(WSKContext);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKAddressToString(
    _In_reads_bytes_(AddressLength) SOCKADDR* SockAddress,
    _In_     UINT32  AddressLength,
    _Out_writes_to_(*AddressStringLength, *AddressStringLength) LPWSTR AddressString,
    _Inout_  UINT32* AddressStringLength
)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    do
    {
        auto Address = reinterpret_cast<SOCKADDR_INET*>(SockAddress);

        if (Address == nullptr || AddressLength < sizeof ADDRESS_FAMILY)
        {
            break;
        }

        if (Address->si_family == AF_INET)
        {
            if (AddressLength < sizeof Address->Ipv4)
            {
                break;
            }

            Status = RtlIpv4AddressToStringEx(&Address->Ipv4.sin_addr, Address->Ipv4.sin_port,
                AddressString, reinterpret_cast<ULONG*>(AddressStringLength));

            break;
        }

        if (Address->si_family == AF_INET6)
        {
            if (AddressLength < sizeof Address->Ipv6)
            {
                break;
            }

            Status = RtlIpv6AddressToStringEx(&Address->Ipv6.sin6_addr, Address->Ipv6.sin6_scope_id,
                Address->Ipv6.sin6_port, AddressString, reinterpret_cast<ULONG*>(AddressStringLength));

            break;
        }

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKStringToAddress(
    _In_    PCWSTR      AddressString,
    _Inout_ SOCKADDR*   SockAddress,
    _Inout_ UINT32*     AddressLength
)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    do
    {
        auto Address = reinterpret_cast<SOCKADDR_INET*>(SockAddress);

        if (Address == nullptr || AddressLength == nullptr || *AddressLength < sizeof ADDRESS_FAMILY)
        {
            break;
        }

        if (Address->si_family == AF_INET)
        {
            if (*AddressLength < sizeof Address->Ipv4)
            {
                break;
            }

            Status = RtlIpv4StringToAddressEx(AddressString, TRUE,
                &Address->Ipv4.sin_addr, &Address->Ipv4.sin_port);
            if (!NT_SUCCESS(Status))
            {
                *AddressLength = 0u;
                break;
            }

            *AddressLength = sizeof Address->Ipv4;
            break;
        }

        if (Address->si_family == AF_INET6)
        {
            if (*AddressLength < sizeof Address->Ipv6)
            {
                break;
            }

            Status = RtlIpv6StringToAddressEx(AddressString, &Address->Ipv6.sin6_addr,
                &Address->Ipv6.sin6_scope_id, &Address->Ipv6.sin6_port);
            if (!NT_SUCCESS(Status))
            {
                *AddressLength = 0u;
                break;
            }

            *AddressLength = sizeof Address->Ipv6;
            break;
        }

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKSocket(
    _Out_ SOCKET*           Socket,
    _In_  ADDRESS_FAMILY    AddressFamily,
    _In_  USHORT            SocketType,
    _In_  ULONG             Protocol,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do 
    {
        *Socket = WSK_INVALID_SOCKET;

        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        ULONG WSKSocketType = WSK_FLAG_BASIC_SOCKET;

        switch (SocketType)
        {
        case SOCK_STREAM:
            WSKSocketType = WSK_FLAG_STREAM_SOCKET;
            break;
        case SOCK_DGRAM:
            WSKSocketType = WSK_FLAG_DATAGRAM_SOCKET;
            break;
        case SOCK_RAW:
            WSKSocketType = WSK_FLAG_DATAGRAM_SOCKET;
            break;
        default:
            break;
        }

        PWSK_SOCKET Socket_ = nullptr;

        Status = WSKSocketUnsafe(&Socket_, AddressFamily, SocketType, Protocol, WSKSocketType, SecurityDescriptor);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        if (!WSKSocketsAVLTableInsert(Socket, Socket_, static_cast<USHORT>(WSKSocketType)))
        {
            WSKCloseSocketUnsafe(Socket_, WSKSocketType);
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKCloseSocket(
    _In_ SOCKET Socket
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKCloseSocketUnsafe(SocketObject.Socket, SocketObject.SocketType);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        WSKSocketsAVLTableDelete(Socket);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKIoctl(
    _In_ SOCKET         Socket,
    _In_ ULONG          ControlCode,
    _In_reads_bytes_opt_(InputSize)     PVOID InputBuffer,
    _In_ SIZE_T         InputSize,
    _Out_writes_bytes_opt_(OutputSize)  PVOID OutputBuffer,
    _In_ SIZE_T         OutputSize,
    _Out_opt_ SIZE_T*   OutputSizeReturned,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (OutputSizeReturned)
        {
            *OutputSizeReturned = 0u;
        }

        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKControlSocketUnsafe(SocketObject.Socket, SocketObject.SocketType, WskIoctl, ControlCode, 0,
            InputBuffer, InputSize, OutputBuffer, OutputSize, OutputSizeReturned, Overlapped, CompletionRoutine);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKSetSocketOpt(
    _In_ SOCKET         Socket,
    _In_ ULONG          OptionLevel,
    _In_ ULONG          OptionName,
    _In_reads_bytes_(InputSize) PVOID InputBuffer,
    _In_ SIZE_T         InputSize
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        if (OptionLevel == SOL_SOCKET && (OptionName == SO_SNDTIMEO || OptionName == SO_RCVTIMEO))
        {
            if (InputSize != sizeof(ULONG) || InputBuffer == nullptr)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            ULONG* Timeout = nullptr;

            if (OptionName == SO_SNDTIMEO)
            {
                Timeout = &SocketObject.SendTimeout;
            }
            if (OptionName == SO_RCVTIMEO)
            {
                Timeout = &SocketObject.RecvTimeout;
            }

            *Timeout = *static_cast<ULONG*>(InputBuffer);

            if (!WSKSocketsAVLTableUpdate(Socket, &SocketObject))
            {
                Status = STATUS_UNSUCCESSFUL;
            }

            break;
        }

        Status = WSKControlSocketUnsafe(SocketObject.Socket, SocketObject.SocketType, WskSetOption,
            OptionName, OptionLevel, InputBuffer, InputSize, nullptr, 0, nullptr, nullptr, nullptr);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKGetSocketOpt(
    _In_ SOCKET         Socket,
    _In_ ULONG          OptionLevel,
    _In_ ULONG          OptionName,
    _Out_writes_bytes_(*OutputSize) PVOID OutputBuffer,
    _Inout_ SIZE_T* OutputSize
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        if (OptionLevel == SOL_SOCKET && (OptionName == SO_SNDTIMEO || OptionName == SO_RCVTIMEO))
        {
            if (*OutputSize != sizeof(ULONG) || OutputBuffer == nullptr)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if (OptionName == SO_SNDTIMEO)
            {
                *static_cast<ULONG*>(OutputBuffer) = SocketObject.SendTimeout;
            }
            if (OptionName == SO_RCVTIMEO)
            {
                *static_cast<ULONG*>(OutputBuffer) = SocketObject.RecvTimeout;
            }

            *OutputSize = sizeof ULONG;
            break;
        }

        Status = WSKControlSocketUnsafe(SocketObject.Socket, SocketObject.SocketType, WskGetOption,
            OptionName, OptionLevel, nullptr, 0, OutputBuffer, *OutputSize, OutputSize, nullptr, nullptr);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKBind(
    _In_ SOCKET         Socket,
    _In_ PSOCKADDR      LocalAddress,
    _In_ SIZE_T         LocalAddressLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKBindUnsafe(SocketObject.Socket, SocketObject.SocketType, LocalAddress, LocalAddressLength);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKAccept(
    _In_  SOCKET        Socket,
    _Out_ SOCKET*       SocketClient,
    _Out_opt_ PSOCKADDR LocalAddress,
    _In_ SIZE_T         LocalAddressLength,
    _Out_opt_ PSOCKADDR RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        PWSK_SOCKET SocketClient_ = nullptr;

        Status = WSKAcceptUnsafe(SocketObject.Socket, SocketObject.SocketType, &SocketClient_,
            LocalAddress, LocalAddressLength, RemoteAddress, RemoteAddressLength);
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        if (!WSKSocketsAVLTableInsert(SocketClient, SocketClient_, static_cast<USHORT>(WSK_FLAG_CONNECTION_SOCKET)))
        {
            WSKCloseSocketUnsafe(SocketClient_, WSK_FLAG_CONNECTION_SOCKET);
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKListen(
    _In_ SOCKET         Socket,
    _In_ INT            BackLog
)
{
    UNREFERENCED_PARAMETER(BackLog);

    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKListenUnsafe(SocketObject.Socket, SocketObject.SocketType);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKConnect(
    _In_ SOCKET         Socket,
    _In_ PSOCKADDR      RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKConnectUnsafe(SocketObject.Socket, SocketObject.SocketType, RemoteAddress, RemoteAddressLength);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKDisconnect(
    _In_ SOCKET         Socket,
    _In_ ULONG          Flags
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKDisconnectUnsafe(SocketObject.Socket, SocketObject.SocketType, nullptr, Flags);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKSend(
    _In_ SOCKET Socket,
    _In_ PVOID  Buffer,
    _In_ SIZE_T BufferLength,
    _Out_opt_ SIZE_T* NumberOfBytesSent,
    _In_ ULONG  Flags,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKSendUnsafe(SocketObject.Socket, SocketObject.SocketType, Buffer, BufferLength,
            NumberOfBytesSent, Flags, SocketObject.SendTimeout, Overlapped, CompletionRoutine);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKSendTo(
    _In_ SOCKET         Socket,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesSent,
    _Reserved_ ULONG    Flags,
    _In_opt_ PSOCKADDR  RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKSendToUnsafe(SocketObject.Socket, SocketObject.SocketType, Buffer, BufferLength,
            NumberOfBytesSent, Flags, RemoteAddress, RemoteAddressLength, SocketObject.SendTimeout,
            Overlapped, CompletionRoutine);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKReceive(
    _In_ SOCKET         Socket,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesRecvd,
    _In_ ULONG          Flags,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKReceiveUnsafe(SocketObject.Socket, SocketObject.SocketType, Buffer, BufferLength,
            NumberOfBytesRecvd, Flags, SocketObject.RecvTimeout, Overlapped, CompletionRoutine);

    } while (false);

    return Status;
}

NTSTATUS WSKAPI WSKReceiveFrom(
    _In_ SOCKET         Socket,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesRecvd,
    _Reserved_ ULONG    Flags,
    _Out_opt_ PSOCKADDR RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    do
    {
        if (!InterlockedCompareExchange(&_Initialized, true, true))
        {
            Status = STATUS_NDIS_ADAPTER_NOT_READY;
            break;
        }

        if (Socket == WSK_INVALID_SOCKET)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SOCKET_OBJECT SocketObject{};

        if (!WSKSocketsAVLTableFind(Socket, &SocketObject))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (SocketObject.SocketType == static_cast<USHORT>(WSK_FLAG_INVALID_SOCKET))
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        Status = WSKReceiveFromUnsafe(SocketObject.Socket, SocketObject.SocketType, Buffer, BufferLength,
            NumberOfBytesRecvd, Flags, RemoteAddress, RemoteAddressLength, SocketObject.RecvTimeout,
            Overlapped, CompletionRoutine);

    } while (false);

    return Status;
}

#ifdef __cplusplus
}
#endif

```

`libwsk/libwsk.h`:

```h
#pragma once
#include <wsk.h>

typedef UINT_PTR SOCKET;

#ifndef WSK_INVALID_SOCKET
#  define WSK_INVALID_SOCKET        ((SOCKET)(~0))
#endif

#ifndef WSK_FLAG_INVALID_SOCKET
#    define WSK_FLAG_INVALID_SOCKET ((ULONG)0xffffffff)
#endif

#ifndef WSK_FLAG_STREAM_SOCKET
#   define WSK_FLAG_STREAM_SOCKET   ((ULONG)0x00000008)
#endif

typedef struct _WSKOVERLAPPED
{
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            ULONG Offset;
            ULONG OffsetHigh;
        } DUMMYSTRUCTNAME;
        PVOID Pointer;
    } DUMMYUNIONNAME;

    KEVENT Event;
}WSKOVERLAPPED, *PWSKOVERLAPPED;
typedef const WSKOVERLAPPED* PCWSKOVERLAPPED;

typedef VOID(WSKAPI* LPWSKOVERLAPPED_COMPLETION_ROUTINE)(
    _In_ NTSTATUS       Status,
    _In_ ULONG_PTR      Bytes,
    _In_ WSKOVERLAPPED* Overlapped
    );

/* WSK Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

VOID WSKAPI WSKSetLastError(
    _In_ NTSTATUS Status
);

NTSTATUS WSKAPI WSKGetLastError();

typedef struct _WSKDATA
{
    UINT16 HighestVersion;
    UINT16 LowestVersion;
}WSKDATA, *PWSKDATA;
typedef const WSKDATA* PCWSKDATA;

NTSTATUS WSKAPI WSKStartup(
    _In_  UINT16   Version,
    _Out_ WSKDATA* WSKData
);

VOID WSKAPI WSKCleanup();

VOID WSKAPI WSKCreateEvent(
    _Out_ KEVENT* Event
);

NTSTATUS WSKAPI WSKGetOverlappedResult(
    _In_  SOCKET         Socket,
    _In_  WSKOVERLAPPED* Overlapped,
    _Out_opt_ SIZE_T*    TransferBytes,
    _In_  BOOLEAN        Wait
);

NTSTATUS WSKAPI WSKGetAddrInfo(
    _In_opt_ LPCWSTR        NodeName,
    _In_opt_ LPCWSTR        ServiceName,
    _In_     UINT32         Namespace,
    _In_opt_ GUID*          Provider,
    _In_opt_ PADDRINFOEXW   Hints,
    _Outptr_result_maybenull_ PADDRINFOEXW*  Result,
    _In_opt_ UINT32         TimeoutMilliseconds,
    _In_opt_ WSKOVERLAPPED* Overlapped,
    _In_opt_ LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

VOID WSKAPI WSKFreeAddrInfo(
    _In_ PADDRINFOEXW Data
);

NTSTATUS WSKAPI WSKGetNameInfo(
    _In_ const SOCKADDR*  Address,
    _In_ ULONG      AddressLength,
    _Out_writes_opt_(NodeNameSize)      LPWSTR  NodeName,
    _In_ ULONG      NodeNameSize,
    _Out_writes_opt_(ServiceNameSize)   LPWSTR  ServiceName,
    _In_ ULONG      ServiceNameSize,
    _In_ ULONG      Flags
);

#define WSK_MAX_ADDRESS_STRING_LENGTH ((UINT32)64u)

NTSTATUS WSKAPI WSKAddressToString(
    _In_reads_bytes_(AddressLength) SOCKADDR* SockAddress,
    _In_    UINT32  AddressLength,
    _Out_writes_to_(*AddressStringLength, *AddressStringLength) LPWSTR AddressString,
    _Inout_ UINT32* AddressStringLength
);

NTSTATUS WSKAPI WSKStringToAddress(
    _In_    PCWSTR      AddressString,
    _Inout_ SOCKADDR*   SockAddress,    // must init Address->si_family
    _Inout_ UINT32*     AddressLength
);

NTSTATUS WSKAPI WSKSocket(
    _Out_ SOCKET*           Socket,
    _In_  ADDRESS_FAMILY    AddressFamily,
    _In_  USHORT            SocketType,
    _In_  ULONG             Protocol,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor
);

NTSTATUS WSKAPI WSKCloseSocket(
    _In_ SOCKET Socket
);

NTSTATUS WSKAPI WSKIoctl(
    _In_ SOCKET         Socket,
    _In_ ULONG          ControlCode,
    _In_reads_bytes_opt_(InputSize)     PVOID InputBuffer,
    _In_ SIZE_T         InputSize,
    _Out_writes_bytes_opt_(OutputSize)  PVOID OutputBuffer,
    _In_ SIZE_T         OutputSize,
    _Out_opt_ SIZE_T*   OutputSizeReturned,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS WSKAPI WSKSetSocketOpt(
    _In_ SOCKET         Socket,
    _In_ ULONG          OptionLevel,    // SOL_xxxx
    _In_ ULONG          OptionName,     // SO_xxxx
    _In_reads_bytes_(InputSize)     PVOID InputBuffer,
    _In_ SIZE_T         InputSize
);

NTSTATUS WSKAPI WSKGetSocketOpt(
    _In_ SOCKET         Socket,
    _In_ ULONG          OptionLevel,    // SOL_xxxx
    _In_ ULONG          OptionName,     // SO_xxxx
    _Out_writes_bytes_(*OutputSize) PVOID OutputBuffer,
    _Inout_ SIZE_T*     OutputSize
);

NTSTATUS WSKAPI WSKBind(
    _In_ SOCKET         Socket,
    _In_ PSOCKADDR      LocalAddress,
    _In_ SIZE_T         LocalAddressLength
);

NTSTATUS WSKAPI WSKAccept(
    _In_  SOCKET        Socket,
    _Out_ SOCKET*       SocketClient,
    _Out_opt_ PSOCKADDR LocalAddress,
    _In_ SIZE_T         LocalAddressLength,
    _Out_opt_ PSOCKADDR RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength
);

NTSTATUS WSKAPI WSKListen(
    _In_ SOCKET         Socket,
    _In_ INT            BackLog
);

NTSTATUS WSKAPI WSKConnect(
    _In_ SOCKET         Socket,
    _In_ PSOCKADDR      RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength
);

NTSTATUS WSKAPI WSKDisconnect(
    _In_ SOCKET         Socket,
    _In_ ULONG          Flags
);

NTSTATUS WSKAPI WSKSend(
    _In_ SOCKET         Socket,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesSent,
    _In_ ULONG          Flags,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS WSKAPI WSKSendTo(
    _In_ SOCKET         Socket,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesSent,
    _Reserved_ ULONG    Flags,
    _In_opt_ PSOCKADDR  RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS WSKAPI WSKReceive(
    _In_ SOCKET         Socket,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesRecvd,
    _In_ ULONG          Flags,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS WSKAPI WSKReceiveFrom(
    _In_ SOCKET         Socket,
    _In_ PVOID          Buffer,
    _In_ SIZE_T         BufferLength,
    _Out_opt_ SIZE_T*   NumberOfBytesRecvd,
    _Reserved_ ULONG    Flags,
    _Out_opt_ PSOCKADDR RemoteAddress,
    _In_ SIZE_T         RemoteAddressLength,
    _In_opt_  WSKOVERLAPPED* Overlapped,
    _In_opt_  LPWSKOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

#ifdef __cplusplus
}
#endif

```

`libwsk/libwsk.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <ProjectGuid>{66495811-336E-4693-B2EA-3EECBC17545E}</ProjectGuid>
    <ProjectName>libwsk</ProjectName>
    <RootNamespace>libwsk</RootNamespace>
    <MileProjectType>StaticLibrary</MileProjectType>
    <MileProjectUseKernelMode>true</MileProjectUseKernelMode>
    <MileProjectUseWindowsDriverKit>true</MileProjectUseWindowsDriverKit>
  </PropertyGroup>
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Platform.x64.props" />
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Platform.ARM64.props" />
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Cpp.Default.props" />
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Cpp.props" />
  <PropertyGroup>
    <OutDir>$(MileProjectBinariesPath)$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(MileProjectObjectsPath)$(Configuration)\$(MSBuildProjectName)\$(Platform)\</IntDir>
    <GeneratedFilesDir>$(IntDir)Generated Files\</GeneratedFilesDir>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>Precompiled.h</PrecompiledHeaderFile>
      <ForcedIncludeFiles>%(PrecompiledHeaderFile);%(ForcedIncludeFiles)</ForcedIncludeFiles>
      <PreprocessorDefinitions>NO_STRICT;POOL_ZERO_DOWN_LEVEL_SUPPORT;POOL_NX_OPTIN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Lib>
      <AdditionalDependencies>Netio.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Precompiled.h" />
    <ClInclude Include="libwsk.h" />
    <ClInclude Include="socket.h" />
    <ClInclude Include="berkeley.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Precompiled.cpp">
      <PrecompiledHeader>Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="libwsk.cpp" />
    <ClCompile Include="socket.cpp" />
    <ClCompile Include="berkeley.cpp" />
  </ItemGroup>
  <Import Sdk="Mile.Project.Configurations" Project="Mile.Project.Cpp.targets" />
</Project>
```

`libwsk/libwsk.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Precompiled.cpp" />
    <ClCompile Include="berkeley.cpp">
      <Filter>libwsk</Filter>
    </ClCompile>
    <ClCompile Include="libwsk.cpp">
      <Filter>libwsk</Filter>
    </ClCompile>
    <ClCompile Include="socket.cpp">
      <Filter>libwsk</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Precompiled.h" />
    <ClInclude Include="berkeley.h">
      <Filter>libwsk</Filter>
    </ClInclude>
    <ClInclude Include="libwsk.h">
      <Filter>libwsk</Filter>
    </ClInclude>
    <ClInclude Include="socket.h">
      <Filter>libwsk</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="libwsk">
      <UniqueIdentifier>{b32961e5-e498-4083-8530-02ebfe13e1c4}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`libwsk/socket.cpp`:

```cpp
#include "socket.h"


//////////////////////////////////////////////////////////////////////////
// Global  Data

static NPAGED_LOOKASIDE_LIST WSKSocketsLookasidePool;
static RTL_AVL_TABLE         WSKSocketsAVLTable;
static FAST_MUTEX            WSKSocketsAVLTableMutex;

//////////////////////////////////////////////////////////////////////////
// Private Function

RTL_GENERIC_COMPARE_RESULTS NTAPI WSKSocketsAVLNodeCompare(
    _In_ RTL_AVL_TABLE* Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
)
{
    UNREFERENCED_PARAMETER(Table);

    auto Socket1 = static_cast<PSOCKET_OBJECT>(FirstStruct);
    auto Socket2 = static_cast<PSOCKET_OBJECT>(SecondStruct);

    return 
        (Socket1->FileDescriptor < Socket2->FileDescriptor) ? GenericLessThan : 
        (Socket1->FileDescriptor > Socket2->FileDescriptor) ? GenericGreaterThan : GenericEqual;
}

PVOID NTAPI WSKSocketsAVLNodeAllocate(
    _In_ RTL_AVL_TABLE* Table,
    _In_ CLONG ByteSize
)
{
    UNREFERENCED_PARAMETER(Table);
    UNREFERENCED_PARAMETER(ByteSize);

    return ExAllocateFromNPagedLookasideList(&WSKSocketsLookasidePool);
}

VOID NTAPI WSKSocketsAVLNodeFree(
    _In_ RTL_AVL_TABLE* Table,
    _In_ __drv_freesMem(Mem) _Post_invalid_ PVOID Buffer
)
{
    UNREFERENCED_PARAMETER(Table);

    return ExFreeToNPagedLookasideList(&WSKSocketsLookasidePool, Buffer);
}

//////////////////////////////////////////////////////////////////////////
// Public Function

VOID WSKAPI WSKSocketsAVLTableInitialize()
{
    ExInitializeNPagedLookasideList(&WSKSocketsLookasidePool, nullptr, nullptr,
#if (NTDDI_VERSION < NTDDI_WIN8)
        0,
#else
        POOL_NX_ALLOCATION,
#endif
        max(sizeof SOCKET_OBJECT + sizeof RTL_BALANCED_LINKS, 64), WSK_POOL_TAG, 0);

    ExInitializeFastMutex(&WSKSocketsAVLTableMutex);

    RtlInitializeGenericTableAvl(&WSKSocketsAVLTable, &WSKSocketsAVLNodeCompare,
        &WSKSocketsAVLNodeAllocate, &WSKSocketsAVLNodeFree, &WSKSocketsLookasidePool);
}

VOID WSKAPI WSKSocketsAVLTableCleanup()
{
    SOCKET_OBJECT* Socket = static_cast<SOCKET_OBJECT*>(RtlGetElementGenericTableAvl(&WSKSocketsAVLTable, 0));

    while (Socket)
    {
        RtlDeleteElementGenericTableAvl(&WSKSocketsAVLTable, Socket);

        Socket = static_cast<SOCKET_OBJECT*>(RtlGetElementGenericTableAvl(&WSKSocketsAVLTable, 0));
    }

    ExDeleteNPagedLookasideList(&WSKSocketsLookasidePool);
}

BOOLEAN WSKAPI WSKSocketsAVLTableInsert(
    _Out_ SOCKET*       SocketFD,
    _In_  PWSK_SOCKET   Socket,
    _In_  USHORT        SocketType
)
{
    PAGED_CODE();

    static volatile short _FD = 4;

    SOCKET_OBJECT SockObject{};
    SockObject.Socket       = Socket;
    SockObject.SocketType   = SocketType;
    SockObject.SendTimeout  = WSK_INFINITE_WAIT;
    SockObject.RecvTimeout  = WSK_INFINITE_WAIT;

    BOOLEAN Inserted = FALSE;

    ExAcquireFastMutex(&WSKSocketsAVLTableMutex);
    {
        do 
        {
            SockObject.FileDescriptor = InterlockedCompareExchange16(&_FD, _FD + 4, _FD);

            if (!RtlInsertElementGenericTableAvl(&WSKSocketsAVLTable, &SockObject, sizeof SockObject, &Inserted))
            {
                break;
            }

        } while (!Inserted);
    }
    ExReleaseFastMutex(&WSKSocketsAVLTableMutex);

    if (Inserted)
    {
        *SocketFD = SockObject.FileDescriptor;
    }
    else
    {
        *SocketFD = WSK_INVALID_SOCKET;
    }

    return Inserted;
}

BOOLEAN WSKAPI WSKSocketsAVLTableDelete(
    _In_  SOCKET SocketFD
)
{
    PAGED_CODE();

    SOCKET_OBJECT SockObject{};
    SockObject.FileDescriptor = static_cast<USHORT>(SocketFD);

    BOOLEAN Deleted = FALSE;

    ExAcquireFastMutex(&WSKSocketsAVLTableMutex);
    {
        Deleted = RtlDeleteElementGenericTableAvl(&WSKSocketsAVLTable, &SockObject);
    }
    ExReleaseFastMutex(&WSKSocketsAVLTableMutex);

    return Deleted;
}

BOOLEAN WSKAPI WSKSocketsAVLTableFind(
    _In_  SOCKET         SocketFD,
    _Out_ SOCKET_OBJECT* SocketObject
)
{
    PAGED_CODE();

    BOOLEAN Found = FALSE;

    SocketObject->FileDescriptor = static_cast<USHORT>(SocketFD);

    ExAcquireFastMutex(&WSKSocketsAVLTableMutex);
    {
        auto Node = static_cast<SOCKET_OBJECT*>(RtlLookupElementGenericTableAvl(&WSKSocketsAVLTable, SocketObject));
        if (Node != nullptr)
        {
            Found = TRUE;

            *SocketObject = *Node;
        }
    }
    ExReleaseFastMutex(&WSKSocketsAVLTableMutex);

    return Found;
}

BOOLEAN WSKAPI WSKSocketsAVLTableUpdate(
    _In_  SOCKET         SocketFD,
    _In_  SOCKET_OBJECT* SocketObject
)
{
    PAGED_CODE();

    BOOLEAN Found = FALSE;

    SocketObject->FileDescriptor = static_cast<USHORT>(SocketFD);

    ExAcquireFastMutex(&WSKSocketsAVLTableMutex);
    {
        auto Node = static_cast<SOCKET_OBJECT*>(RtlLookupElementGenericTableAvl(&WSKSocketsAVLTable, SocketObject));
        if (Node != nullptr)
        {
            Found = TRUE;

            Node->SendTimeout = SocketObject->SendTimeout;
            Node->RecvTimeout = SocketObject->RecvTimeout;
        }
    }
    ExReleaseFastMutex(&WSKSocketsAVLTableMutex);

    return Found;
}

SIZE_T WSKAPI WSKSocketsAVLTableSize()
{
    PAGED_CODE();

    SIZE_T Size = 0u;

    ExAcquireFastMutex(&WSKSocketsAVLTableMutex);
    {
        Size = RtlNumberGenericTableElementsAvl(&WSKSocketsAVLTable);
    }
    ExReleaseFastMutex(&WSKSocketsAVLTableMutex);

    return Size;
}

```

`libwsk/socket.h`:

```h
#pragma once

using SOCKET = UINT_PTR;

#ifndef WSK_INVALID_SOCKET
#  define WSK_INVALID_SOCKET static_cast<SOCKET>(~0)
#endif

#ifndef WSK_FLAG_INVALID_SOCKET
#  define WSK_FLAG_INVALID_SOCKET 0xffffffff
#endif

//////////////////////////////////////////////////////////////////////////
// Private Struct

struct SOCKET_OBJECT
{
    PWSK_SOCKET Socket;
    USHORT      SocketType;     // WSK_FLAG_xxxxxx_SOCKET
    USHORT      FileDescriptor; // SOCKET FD

    ULONG       SendTimeout;
    ULONG       RecvTimeout;

    PVOID       Context;
};
using PSOCKET_OBJECT = SOCKET_OBJECT*;

//////////////////////////////////////////////////////////////////////////
// Public Function

VOID WSKAPI WSKSocketsAVLTableInitialize();

VOID WSKAPI WSKSocketsAVLTableCleanup();

BOOLEAN WSKAPI WSKSocketsAVLTableInsert(
    _Out_ SOCKET*        SocketFD,
    _In_  PWSK_SOCKET    Socket,
    _In_  USHORT         SocketType
);

BOOLEAN WSKAPI WSKSocketsAVLTableDelete(
    _In_  SOCKET         SocketFD
);

BOOLEAN WSKAPI WSKSocketsAVLTableFind(
    _In_  SOCKET         SocketFD,
    _Out_ SOCKET_OBJECT* SocketObject
);

BOOLEAN WSKAPI WSKSocketsAVLTableUpdate(
    _In_  SOCKET         SocketFD,
    _In_  SOCKET_OBJECT* SocketObject
);

SIZE_T WSKAPI WSKSocketsAVLTableSize();

```