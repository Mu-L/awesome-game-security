Project Path: arc_tomlooman_ActionRoguelike_nkox7m7q

Source Tree:

```txt
arc_tomlooman_ActionRoguelike_nkox7m7q
├── ActionRoguelike.uproject
├── Binaries
│   └── Win64
│       └── UnrealEditor-ActionRoguelike.dll
├── CollectedPSOs
│   ├── ++UE5+Release-5.3-CL-28051148-ActionRoguelike_PCD3D_SM6_705508C242CA8002F39BE49951E25C82.rec.upipelinecache
│   ├── Cmd_ConvertPSOs.bat
│   ├── ShaderStableInfo-ActionRoguelike-PCD3D_SM6.shk
│   └── ShaderStableInfo-Global-PCD3D_SM6.shk
├── Config
│   ├── DefaultEditor.ini
│   ├── DefaultEditorPerProjectUserSettings.ini
│   ├── DefaultEngine.ini
│   ├── DefaultGame.ini
│   ├── DefaultGameplayTags.ini
│   ├── DefaultInput.ini
│   └── DefaultScalability.ini
├── Content
│   ├── ActionRoguelike
│   │   ├── AI
│   │   │   ├── Action_Minion_MeleeAttack.uasset
│   │   │   ├── Action_Minion_RangedAttack.uasset
│   │   │   ├── MinionControllerBP.uasset
│   │   │   ├── MinionMeleeOnly.uasset
│   │   │   ├── MinionRangedBB.uasset
│   │   │   ├── MinionRangedBP.uasset
│   │   │   ├── MinionRangedBT.uasset
│   │   │   ├── QueryContext_AllPlayers.uasset
│   │   │   ├── Query_FindBotSpawn.uasset
│   │   │   ├── Query_FindHidingSpot.uasset
│   │   │   ├── Query_FindNearbyLocation.uasset
│   │   │   └── Query_PerceptionTargets.uasset
│   │   ├── Actions
│   │   │   ├── Action_Blackhole.uasset
│   │   │   ├── Action_Dash.uasset
│   │   │   ├── Action_MagicProjectile.uasset
│   │   │   ├── Action_Parry.uasset
│   │   │   ├── Action_Sprint.uasset
│   │   │   ├── Effect_Burning.uasset
│   │   │   └── Effect_Stunned.uasset
│   │   ├── Audio
│   │   │   ├── Blueprints
│   │   │   │   ├── AN_PlayFootstep.uasset
│   │   │   │   ├── BP_MusicManager.uasset
│   │   │   │   ├── Curve_Music_CombatThreat_High.uasset
│   │   │   │   ├── Curve_Music_CombatThreat_Low.uasset
│   │   │   │   ├── Curve_Music_CombatThreat_Medium.uasset
│   │   │   │   ├── Curve_Music_ProximityThreat_High.uasset
│   │   │   │   ├── Curve_Music_ProximityThreat_Low.uasset
│   │   │   │   ├── Curve_Music_ProximityThreat_Medium.uasset
│   │   │   │   ├── E_FootstepTypes.uasset
│   │   │   │   └── S_AM_FootPlantDefinitions.uasset
│   │   │   └── Components
│   │   │       ├── A_FootstepFoleyComponent.uasset
│   │   │       └── A_ThreatComponent.uasset
│   │   ├── BP_ApplyEffectZone.uasset
│   │   ├── BonfireBP.uasset
│   │   ├── Curves
│   │   │   ├── AnimateBlackholeCurve.uasset
│   │   │   ├── ChestOpenAnimation.uasset
│   │   │   └── SpawnCreditsCurve.uasset
│   │   ├── DataAssets
│   │   │   └── PlayerConfigData.uasset
│   │   ├── Effects
│   │   │   ├── DataChannel_Impacts.uasset
│   │   │   ├── NS_Impact_Decal.uasset
│   │   │   └── NS_Impact_Decal_Mesh.uasset
│   │   ├── ExplosiveBarrel_Assignment.uasset
│   │   ├── GameModeBP.uasset
│   │   ├── Input
│   │   │   ├── IA_Dash.uasset
│   │   │   ├── IA_Interact.uasset
│   │   │   ├── IA_Jump.uasset
│   │   │   ├── IA_LookMouse.uasset
│   │   │   ├── IA_LookStick.uasset
│   │   │   ├── IA_Move.uasset
│   │   │   ├── IA_Parry.uasset
│   │   │   ├── IA_PauseMenu.uasset
│   │   │   ├── IA_PrimaryAttack.uasset
│   │   │   ├── IA_SecondaryAttack.uasset
│   │   │   ├── IA_Sprint.uasset
│   │   │   └── IMC_PlayerDefault.uasset
│   │   ├── LeverBP.uasset
│   │   ├── MainMenu_GameMode.uasset
│   │   ├── Maps
│   │   │   ├── MainMenu_Entry.umap
│   │   │   ├── TestLevel.umap
│   │   │   ├── TestLevel_BuiltData.uasset
│   │   │   └── _GENERATED
│   │   │       └── tomlo
│   │   │           └── CubeGridToolOutput_84F011D5.uasset
│   │   ├── Materials
│   │   │   ├── MF_HitFlashDemo.uasset
│   │   │   ├── MI_HitFlashDemo_Inst.uasset
│   │   │   ├── MI_PBRDemo_Inst.uasset
│   │   │   ├── MI_RageBar.uasset
│   │   │   ├── M_3DFont.uasset
│   │   │   ├── M_3DFont_Side.uasset
│   │   │   ├── M_AnimatedHealthBar.uasset
│   │   │   ├── M_BuffIcon.uasset
│   │   │   ├── M_DevZone.uasset
│   │   │   ├── M_DissolveEffect.uasset
│   │   │   ├── M_HealthBar.uasset
│   │   │   ├── M_HitFlashDemo.uasset
│   │   │   ├── M_HitFlash_Overlay.uasset
│   │   │   ├── M_Impact_Decal.uasset
│   │   │   ├── M_PBRDemo.uasset
│   │   │   ├── M_Props.uasset
│   │   │   ├── M_SineWave.uasset
│   │   │   ├── M_SineWaveBP.uasset
│   │   │   └── T_DevPatterns.uasset
│   │   ├── Monsters
│   │   │   ├── DT_Monsters.uasset
│   │   │   ├── Monster_MinionRanged.uasset
│   │   │   └── Monster_MinionRanged_Elite.uasset
│   │   ├── Performance
│   │   │   ├── Maps
│   │   │   │   └── AnimPerfTests.umap
│   │   │   ├── ProjectileSpammer.uasset
│   │   │   └── VFX
│   │   │       ├── World_Impacts_EffectType.uasset
│   │   │       ├── World_Pickups_EffectType.uasset
│   │   │       └── World_Projectiles_EffectType.uasset
│   │   ├── PlayerCharacter.uasset
│   │   ├── PlayerControllerBP.uasset
│   │   ├── Powerup_Credits.uasset
│   │   ├── Powerup_GrantAction.uasset
│   │   ├── Powerup_HealthPotion.uasset
│   │   ├── ProjectileCanon.uasset
│   │   ├── Projectiles
│   │   │   ├── DA_ProjectileConfigAI.uasset
│   │   │   ├── M_MeshImpactDecal.uasset
│   │   │   ├── NS_Projectile_WorldSpace.uasset
│   │   │   ├── Proj_BlackHole.uasset
│   │   │   ├── Proj_Dash.uasset
│   │   │   ├── Proj_MagicProjectile.uasset
│   │   │   └── Proj_MinionRangedAttack.uasset
│   │   ├── QueryContext_PlayerStarts.uasset
│   │   ├── Query_FindPowerupSpawns.uasset
│   │   ├── SineWaveBlueprint.uasset
│   │   ├── TargetDummyBP.uasset
│   │   ├── TreasureChest.uasset
│   │   ├── UI
│   │   │   ├── Credits_Widget.uasset
│   │   │   ├── Crosshair_Widget.uasset
│   │   │   ├── DamagePopup_Widget.uasset
│   │   │   ├── DefaultInteraction_Widget.uasset
│   │   │   ├── EffectContainer_Widget.uasset
│   │   │   ├── EffectSlot_Widget.uasset
│   │   │   ├── GameModeInfo_Widget.uasset
│   │   │   ├── Main_HUD.uasset
│   │   │   ├── Menu
│   │   │   │   ├── MainMenu_Widget.uasset
│   │   │   │   ├── MenuButton_Widget.uasset
│   │   │   │   └── PauseMenu_Widget.uasset
│   │   │   ├── MinionHealth_Widget.uasset
│   │   │   ├── Minion_Spotted_Widget.uasset
│   │   │   ├── NotificationContainer.uasset
│   │   │   ├── Notification_Item.uasset
│   │   │   ├── PlayerHealth_Widget.uasset
│   │   │   ├── PlayerRage_Widget.uasset
│   │   │   └── RogueHUDBP.uasset
│   │   └── World
│   │       ├── STB_BelowMonsterLimit.uasset
│   │       ├── STT_AwardSpawnCredits.uasset
│   │       ├── STT_CheckPlayersReady.uasset
│   │       ├── STT_SelectLoadMonster.uasset
│   │       ├── STT_SpawnMonster.uasset
│   │       ├── ST_CombatDirector.uasset
│   │       └── ST_WorldEvent_Director.uasset
│   ├── Characters
│   │   └── Mannequins
│   │       ├── Materials
│   │       │   ├── M_Mannequin.uasset
│   │       │   └── Manny
│   │       │       ├── MI_Manny_01_New.uasset
│   │       │       └── MI_Manny_02_New.uasset
│   │       └── Textures
│   │           ├── Manny
│   │           │   ├── T_Manny_01_BN.uasset
│   │           │   ├── T_Manny_01_D.uasset
│   │           │   ├── T_Manny_01_MRA.uasset
│   │           │   ├── T_Manny_02_BN.uasset
│   │           │   ├── T_Manny_02_D.uasset
│   │           │   └── T_Manny_02_MRA.uasset
│   │           └── Shared
│   │               └── T_UE_Logo_M.uasset
│   ├── ControlRig
│   │   └── Characters
│   │       └── Mannequins
│   │           ├── Animations
│   │           │   └── Gideon
│   │           │       ├── AO_Blendspace.uasset
│   │           │       ├── AO_CC.uasset
│   │           │       ├── AO_CD.uasset
│   │           │       ├── AO_CU.uasset
│   │           │       ├── AO_LC.uasset
│   │           │       ├── AO_LD.uasset
│   │           │       ├── AO_LU.uasset
│   │           │       ├── AO_RC.uasset
│   │           │       ├── AO_RD.uasset
│   │           │       ├── AO_RU.uasset
│   │           │       ├── Death_Back.uasset
│   │           │       ├── Death_Fwd.uasset
│   │           │       ├── Death_Montage.uasset
│   │           │       ├── GideonManny_AnimBlueprint.uasset
│   │           │       ├── Idle.uasset
│   │           │       ├── IdlePoseAdjustment.uasset
│   │           │       ├── Idle_Additive.uasset
│   │           │       ├── JogFwdSlopeLean.uasset
│   │           │       ├── Jog_Bwd.uasset
│   │           │       ├── Jog_Downhill_Fwd.uasset
│   │           │       ├── Jog_Fwd.uasset
│   │           │       ├── Jog_Fwd_Circle_Left.uasset
│   │           │       ├── Jog_Fwd_Circle_Right.uasset
│   │           │       ├── Jog_Fwd_Start.uasset
│   │           │       ├── Jog_Fwd_Stop.uasset
│   │           │       ├── Jog_Left.uasset
│   │           │       ├── Jog_Right.uasset
│   │           │       ├── Jog_Uphill_Fwd.uasset
│   │           │       ├── Jump_In_Place_Apex.uasset
│   │           │       ├── Jump_In_Place_Land.uasset
│   │           │       ├── Jump_In_Place_Recover.uasset
│   │           │       ├── Jump_In_Place_Start.uasset
│   │           │       ├── LevelStart.uasset
│   │           │       ├── LevelStart_Montage.uasset
│   │           │       ├── Primary_Attack_A_Medium.uasset
│   │           │       ├── Primary_Attack_A_Medium_Montage.uasset
│   │           │       ├── Primary_Attack_B_Medium.uasset
│   │           │       ├── Primary_Attack_B_Medium_Montage.uasset
│   │           │       ├── Primary_Attack_C_Medium.uasset
│   │           │       ├── Primary_Attack_C_Medium_Montage.uasset
│   │           │       ├── RMB_Cast.uasset
│   │           │       ├── RMB_Intro.uasset
│   │           │       ├── RMB_Intro_Additive.uasset
│   │           │       ├── RMB_Targeting_Pose.uasset
│   │           │       ├── RMB_Targeting_Pose_Additive.uasset
│   │           │       ├── Run_Direction.uasset
│   │           │       ├── Sprinting_BS_1D.uasset
│   │           │       ├── Stun_A.uasset
│   │           │       ├── Stun_End.uasset
│   │           │       ├── Stun_Loop.uasset
│   │           │       ├── Stun_Start.uasset
│   │           │       ├── Torn_Space_Outro.uasset
│   │           │       ├── Torn_Space_intro.uasset
│   │           │       ├── TravelMode_Direction_BS.uasset
│   │           │       ├── TravelMode_Hover_Bwd.uasset
│   │           │       ├── TravelMode_Hover_Fwd.uasset
│   │           │       ├── TravelMode_Hover_Idle.uasset
│   │           │       ├── TravelMode_Hover_Left.uasset
│   │           │       ├── TravelMode_Hover_Right.uasset
│   │           │       ├── Turn_Left_180.uasset
│   │           │       ├── Turn_Left_90.uasset
│   │           │       ├── Turn_Right_180.uasset
│   │           │       ├── Turn_Right_90.uasset
│   │           │       ├── Turn_Right_90_Short.uasset
│   │           │       ├── Turn_Right_90_Short_Additive.uasset
│   │           │       └── Turn_Right_90_Short_Grounded.uasset
│   │           ├── Meshes
│   │           │   ├── Mannequin_LODSettings.uasset
│   │           │   ├── SKM_Manny.uasset
│   │           │   ├── SKM_Manny_Simple.uasset
│   │           │   ├── SKM_Quinn.uasset
│   │           │   ├── SKM_Quinn_Simple.uasset
│   │           │   └── SK_Mannequin.uasset
│   │           └── Rigs
│   │               ├── ABP_Manny_PostProcess.uasset
│   │               ├── ABP_Quinn_PostProcess.uasset
│   │               ├── CR_Mannequin_BasicBiped.uasset
│   │               ├── CR_Mannequin_BasicFootIK.uasset
│   │               ├── CR_Mannequin_Body.uasset
│   │               ├── CR_Mannequin_Procedural.uasset
│   │               ├── IK_Mannequin.uasset
│   │               ├── PA_Mannequin.uasset
│   │               ├── Poses
│   │               │   ├── Manny
│   │               │   │   ├── Manny_calf_l_anim.uasset
│   │               │   │   ├── Manny_calf_l_pose.uasset
│   │               │   │   ├── Manny_calf_r_anim.uasset
│   │               │   │   ├── Manny_calf_r_pose.uasset
│   │               │   │   ├── Manny_clavicle_l_anim.uasset
│   │               │   │   ├── Manny_clavicle_l_pose.uasset
│   │               │   │   ├── Manny_clavicle_r_anim.uasset
│   │               │   │   ├── Manny_clavicle_r_pose.uasset
│   │               │   │   ├── Manny_foot_l_anim.uasset
│   │               │   │   ├── Manny_foot_l_pose.uasset
│   │               │   │   ├── Manny_foot_r_anim.uasset
│   │               │   │   ├── Manny_foot_r_pose.uasset
│   │               │   │   ├── Manny_hand_l_anim.uasset
│   │               │   │   ├── Manny_hand_l_pose.uasset
│   │               │   │   ├── Manny_hand_r_anim.uasset
│   │               │   │   ├── Manny_hand_r_pose.uasset
│   │               │   │   ├── Manny_lowerarm_l_anim.uasset
│   │               │   │   ├── Manny_lowerarm_l_pose.uasset
│   │               │   │   ├── Manny_lowerarm_r_anim.uasset
│   │               │   │   ├── Manny_lowerarm_r_pose.uasset
│   │               │   │   ├── Manny_thigh_l_anim.uasset
│   │               │   │   ├── Manny_thigh_l_pose.uasset
│   │               │   │   ├── Manny_thigh_r_anim.uasset
│   │               │   │   ├── Manny_thigh_r_pose.uasset
│   │               │   │   ├── Manny_upperarm_l_anim.uasset
│   │               │   │   ├── Manny_upperarm_l_pose.uasset
│   │               │   │   ├── Manny_upperarm_r_anim.uasset
│   │               │   │   └── Manny_upperarm_r_pose.uasset
│   │               │   └── Quinn
│   │               │       ├── Quinn_calf_l_anim.uasset
│   │               │       ├── Quinn_calf_l_pose.uasset
│   │               │       ├── Quinn_calf_r_anim.uasset
│   │               │       ├── Quinn_calf_r_pose.uasset
│   │               │       ├── Quinn_clavicle_l_anim.uasset
│   │               │       ├── Quinn_clavicle_l_pose.uasset
│   │               │       ├── Quinn_clavicle_r_anim.uasset
│   │               │       ├── Quinn_clavicle_r_pose.uasset
│   │               │       ├── Quinn_foot_l_anim.uasset
│   │               │       ├── Quinn_foot_l_pose.uasset
│   │               │       ├── Quinn_foot_r_anim.uasset
│   │               │       ├── Quinn_foot_r_pose.uasset
│   │               │       ├── Quinn_hand_l_anim.uasset
│   │               │       ├── Quinn_hand_l_pose.uasset
│   │               │       ├── Quinn_hand_r_anim.uasset
│   │               │       ├── Quinn_hand_r_pose.uasset
│   │               │       ├── Quinn_lowerarm_l_anim.uasset
│   │               │       ├── Quinn_lowerarm_l_pose.uasset
│   │               │       ├── Quinn_lowerarm_r_anim.uasset
│   │               │       ├── Quinn_lowerarm_r_pose.uasset
│   │               │       ├── Quinn_thigh_l_anim.uasset
│   │               │       ├── Quinn_thigh_l_pose.uasset
│   │               │       ├── Quinn_thigh_r_anim.uasset
│   │               │       ├── Quinn_thigh_r_pose.uasset
│   │               │       ├── Quinn_upperarm_l_anim.uasset
│   │               │       ├── Quinn_upperarm_l_pose.uasset
│   │               │       ├── Quinn_upperarm_r_anim.uasset
│   │               │       └── Quinn_upperarm_r_pose.uasset
│   │               └── RTG_Mannequin.uasset
│   ├── ExampleContent
│   │   ├── Audio
│   │   │   ├── Abilities
│   │   │   │   ├── A_Ability_FireBallCast01.uasset
│   │   │   │   ├── A_Ability_FireBallCast02.uasset
│   │   │   │   ├── A_Ability_FireWaveCast01.uasset
│   │   │   │   ├── A_Ability_FireWavePowerup_01.uasset
│   │   │   │   ├── A_Ability_FireWavePowerup_02.uasset
│   │   │   │   ├── A_Ability_MeteorCast01.uasset
│   │   │   │   ├── A_Ability_MeteorImpact01.uasset
│   │   │   │   ├── A_Ability_MeteorImpact02.uasset
│   │   │   │   ├── A_Ability_MeteorWhoosh_01.uasset
│   │   │   │   └── A_Ability_TimeSlow01.uasset
│   │   │   ├── Audio
│   │   │   │   └── Sound_Basics
│   │   │   │       ├── Basic_ActorLocation01.uasset
│   │   │   │       └── Basic_AttenuationShape01.uasset
│   │   │   ├── AudioClasses
│   │   │   │   ├── SC_Abilities.uasset
│   │   │   │   ├── SC_Enemy.uasset
│   │   │   │   ├── SC_Hero.uasset
│   │   │   │   ├── SC_Items.uasset
│   │   │   │   ├── SC_Music.uasset
│   │   │   │   ├── SC_Player.uasset
│   │   │   │   ├── SC_RPG_Master.uasset
│   │   │   │   ├── SC_SFX.uasset
│   │   │   │   ├── SC_Slomo.uasset
│   │   │   │   ├── SC_UI.uasset
│   │   │   │   ├── SC_Weapons.uasset
│   │   │   │   ├── SM_Abilities.uasset
│   │   │   │   ├── SM_Enemies.uasset
│   │   │   │   ├── SM_Items.uasset
│   │   │   │   ├── SM_Mixer.uasset
│   │   │   │   └── SM_Slomo.uasset
│   │   │   ├── Character
│   │   │   │   ├── A_Character_Heal01.uasset
│   │   │   │   ├── A_Character_Heal01_Mana.uasset
│   │   │   │   ├── A_Character_Potion01.uasset
│   │   │   │   ├── A_Character_Potion02.uasset
│   │   │   │   ├── A_Character_Powerup01.uasset
│   │   │   │   ├── A_Character_Step01.uasset
│   │   │   │   ├── A_Character_Step02.uasset
│   │   │   │   ├── A_Character_Step03.uasset
│   │   │   │   ├── A_Character_Step04.uasset
│   │   │   │   └── A_Character_Step05.uasset
│   │   │   ├── Concurrency
│   │   │   │   └── Spider_Walk_Loop.uasset
│   │   │   ├── Creatures
│   │   │   │   ├── Guardian
│   │   │   │   │   ├── A_Guardian_Death01.uasset
│   │   │   │   │   ├── A_Guardian_Death02.uasset
│   │   │   │   │   ├── A_Guardian_Impact01.uasset
│   │   │   │   │   ├── A_Guardian_Impact02.uasset
│   │   │   │   │   ├── A_Guardian_Impact03.uasset
│   │   │   │   │   ├── A_Guardian_Impact04.uasset
│   │   │   │   │   ├── A_Guardian_Roar02.uasset
│   │   │   │   │   ├── A_Guardian_Roar03.uasset
│   │   │   │   │   ├── A_Guardian_Spawn01.uasset
│   │   │   │   │   └── A_Guardian_Spawn02.uasset
│   │   │   │   └── Spider
│   │   │   │       ├── A_Spider_Death01.uasset
│   │   │   │       ├── A_Spider_Death_Cue.uasset
│   │   │   │       ├── A_Spider_Land01.uasset
│   │   │   │       ├── A_Spider_Land_Cue.uasset
│   │   │   │       ├── A_Spider_LegLrg01.uasset
│   │   │   │       ├── A_Spider_LegLrg02.uasset
│   │   │   │       ├── A_Spider_LegLrg03.uasset
│   │   │   │       ├── A_Spider_LegLrg04.uasset
│   │   │   │       ├── A_Spider_LegLrg_Cue.uasset
│   │   │   │       ├── A_Spider_React01.uasset
│   │   │   │       ├── A_Spider_React02.uasset
│   │   │   │       ├── A_Spider_React03.uasset
│   │   │   │       ├── A_Spider_React_Cue.uasset
│   │   │   │       ├── A_Spider_Spawn01.uasset
│   │   │   │       ├── A_Spider_Spawn_Cue.uasset
│   │   │   │       ├── A_Spider_Stun01.uasset
│   │   │   │       ├── A_Spider_Stun_Cue.uasset
│   │   │   │       ├── A_Spider_WalkLoop02.uasset
│   │   │   │       └── A_Spider_WalkLoop_Cue.uasset
│   │   │   ├── ITEM
│   │   │   │   ├── ENV_Switch.uasset
│   │   │   │   ├── ITEM_Cloud_Deploy.uasset
│   │   │   │   ├── ITEM_Cloud_Despawn.uasset
│   │   │   │   ├── ITEM_Cloud_Loop_Cooling.uasset
│   │   │   │   ├── ITEM_Cloud_Loop_Cooling02.uasset
│   │   │   │   ├── ITEM_Cloud_Loop_Healing.uasset
│   │   │   │   ├── ITEM_Cloud_Loop_Revealing.uasset
│   │   │   │   ├── ITEM_Cloud_Spawn.uasset
│   │   │   │   ├── ITEM_CoolDown01.uasset
│   │   │   │   ├── ITEM_CoolDown_Expired.uasset
│   │   │   │   ├── ITEM_CoolDown_Loop.uasset
│   │   │   │   ├── ITEM_Fail01.uasset
│   │   │   │   └── ITEM_Power_Fail01.uasset
│   │   │   ├── Sword
│   │   │   │   ├── A_Sword_Swing01.uasset
│   │   │   │   ├── A_Sword_Swing02.uasset
│   │   │   │   └── A_Sword_Swing03.uasset
│   │   │   ├── Textures
│   │   │   │   └── T_Metal_Painted01_N.uasset
│   │   │   └── Weapons
│   │   │       ├── Axe
│   │   │       │   ├── A_Axe_Swing01.uasset
│   │   │       │   ├── A_Axe_Swing02.uasset
│   │   │       │   └── A_Axe_Swing03.uasset
│   │   │       └── Hammer
│   │   │           ├── A_Hammer_Swing01.uasset
│   │   │           ├── A_Hammer_Swing02.uasset
│   │   │           ├── A_Hammer_Swing03.uasset
│   │   │           └── A_Hammer_Swing_Cue.uasset
│   │   ├── CameraShake
│   │   │   ├── Shake_Damage_Heavy.uasset
│   │   │   └── Shake_Damage_Short.uasset
│   │   ├── Enemy_Great_Spider
│   │   │   ├── Animation
│   │   │   │   ├── ABP_SpiderBoss.uasset
│   │   │   │   ├── AM_Spider_Charge.uasset
│   │   │   │   ├── AM_Spider_Firewall.uasset
│   │   │   │   ├── AM_Spider_Hit.uasset
│   │   │   │   ├── AM_Spider_Melee.uasset
│   │   │   │   ├── AM_Spider_Spawn.uasset
│   │   │   │   ├── BS_SpiderBoss.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Attack_Melee.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Attack_Melee_B.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Attack_Melee_C.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Cast_Roar.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Charge_Root.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Death.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Idle.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_React_Heavy_Front.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_React_Stunned.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_React_Stunned_Enter.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_React_Stunned_Exit.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_React_Stunned_Idle.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Teleport.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Walk_Fwd.uasset
│   │   │   │   ├── ExoGame_Greater_Spider_Walk_Left.uasset
│   │   │   │   └── ExoGame_Greater_Spider_Walk_Right.uasset
│   │   │   ├── CharM_Greater_Spider.uasset
│   │   │   ├── SK_Greater_Spider.uasset
│   │   │   ├── SK_Greater_Spider_Skeleton.uasset
│   │   │   ├── T_Enemy_GreaterSpider_Fire_D_01.uasset
│   │   │   ├── T_Enemy_GreaterSpider_Fire_M.uasset
│   │   │   └── T_Enemy_GreaterSpider_Fire_N.uasset
│   │   ├── MaterialFunctions
│   │   │   └── MF_HitFlash.uasset
│   │   ├── Materials
│   │   │   ├── BasicAsset01.uasset
│   │   │   ├── BasicShapeMaterial.uasset
│   │   │   ├── MI_CharacterSimple_Inst.uasset
│   │   │   ├── M_CharacterSimple.uasset
│   │   │   ├── M_Energy_Burst.uasset
│   │   │   ├── M_Gold_Pile.uasset
│   │   │   ├── M_Light_Bulb_Base.uasset
│   │   │   ├── M_Light_Bulb_Glass.uasset
│   │   │   ├── M_Metal_Lighter.uasset
│   │   │   ├── M_Orange_Shiny.uasset
│   │   │   ├── M_Pickup_Coin.uasset
│   │   │   ├── M_Pickup_Health.uasset
│   │   │   ├── M_PotionGlass.uasset
│   │   │   ├── M_Radial_Gradient.uasset
│   │   │   ├── M_Radius_Glow.uasset
│   │   │   ├── M_Toy_Cow.uasset
│   │   │   ├── M_Treasure_Chest.uasset
│   │   │   ├── T_Pixel_Noise.uasset
│   │   │   ├── T_Treasure_Chest_M.uasset
│   │   │   ├── T_Treasure_Chest_N.uasset
│   │   │   ├── T_Treasure_N.uasset
│   │   │   └── T_UnrealEngineDecal.uasset
│   │   ├── Meshes
│   │   │   ├── Cube.uasset
│   │   │   ├── MI_Cave_Rock.uasset
│   │   │   ├── MI_Cave_Rock_Large02_002.uasset
│   │   │   ├── MI_Cave_Rock_Large02_003.uasset
│   │   │   ├── SM_Cave_Rock_01.uasset
│   │   │   ├── SM_Cave_Rock_02.uasset
│   │   │   ├── SM_Cave_Rock_03.uasset
│   │   │   ├── SM_Chest_Bottom.uasset
│   │   │   ├── SM_Chest_Lid.uasset
│   │   │   ├── SM_Coin_Small.uasset
│   │   │   ├── SM_Interactive_Switch.uasset
│   │   │   ├── SM_Interactive_Switch_Handle.uasset
│   │   │   ├── SM_LED.uasset
│   │   │   ├── SM_Lightbulb.uasset
│   │   │   ├── SM_Open_Square.uasset
│   │   │   ├── SM_Pickup_Coin.uasset
│   │   │   ├── SM_Pickup_Health.uasset
│   │   │   ├── SM_PotionBottle.uasset
│   │   │   ├── SM_Radius_Ring.uasset
│   │   │   ├── SM_RedBarrel.uasset
│   │   │   ├── SM_Template_Map_Floor.uasset
│   │   │   ├── SM_Toy_Cow.uasset
│   │   │   ├── SM_Treasure_Pile.uasset
│   │   │   └── Sphere.uasset
│   │   ├── Textures
│   │   │   ├── T_Lightbulb_M.uasset
│   │   │   ├── T_Space.uasset
│   │   │   ├── T_TankMoteNoise.uasset
│   │   │   ├── T_TileNoise.uasset
│   │   │   ├── T_Toy_Cow_M.uasset
│   │   │   ├── T_Toy_Cow_N.uasset
│   │   │   └── T_White.uasset
│   │   └── UI
│   │       ├── Fonts
│   │       │   └── Cinzel
│   │       │       ├── Cinzel-Black.uasset
│   │       │       ├── Cinzel-Bold.uasset
│   │       │       ├── Cinzel-Regular.uasset
│   │       │       └── Cinzel.uasset
│   │       ├── Material
│   │       │   └── M_UI_Shinyness.uasset
│   │       └── Texture
│   │           ├── T_Dissolve_Mob_M.uasset
│   │           ├── T_UI_Add_Button_01.uasset
│   │           ├── T_UI_Border_01.uasset
│   │           ├── T_UI_Border_02.uasset
│   │           ├── T_UI_ButtonGlow01.uasset
│   │           ├── T_UI_ButtonImage_01.uasset
│   │           ├── T_UI_ButtonImage_02.uasset
│   │           ├── T_UI_Change_Icon.uasset
│   │           ├── T_UI_Checkbox_Checked.uasset
│   │           ├── T_UI_Checkbox_Unchecked.uasset
│   │           ├── T_UI_Clear_Icon.uasset
│   │           ├── T_UI_Icon_Settings01.uasset
│   │           ├── T_UI_Icon_Time01.uasset
│   │           ├── T_UI_Potion_Health.uasset
│   │           ├── T_UI_Potion_Mana.uasset
│   │           ├── T_UI_Potion_ManaAndHealth.uasset
│   │           ├── T_UI_Skill_Combust01.uasset
│   │           ├── T_UI_Soul_Icon.uasset
│   │           └── T_Water_N.uasset
│   ├── LevelPrototyping
│   │   ├── Materials
│   │   │   ├── MF_ProcGrid.uasset
│   │   │   ├── MI_PrototypeGrid_Gray.uasset
│   │   │   ├── MI_PrototypeGrid_TopDark.uasset
│   │   │   └── M_PrototypeGrid.uasset
│   │   └── Textures
│   │       └── T_GridChecker_A.uasset
│   ├── ParagonGideon
│   │   └── Audio
│   │       └── Wavs
│   │           ├── Gideon_Ability_LowMana_010.uasset
│   │           ├── Gideon_Ability_LowMana_020.uasset
│   │           ├── Gideon_Ability_LowMana_030.uasset
│   │           ├── Gideon_Ability_LowMana_040.uasset
│   │           ├── Gideon_Ability_No_010.uasset
│   │           ├── Gideon_Ability_No_020.uasset
│   │           ├── Gideon_Ability_No_030.uasset
│   │           ├── Gideon_Ability_No_040.uasset
│   │           ├── Gideon_Ability_Ultimate_Ready_010.uasset
│   │           ├── Gideon_Ability_Ultimate_Self_010.uasset
│   │           ├── Gideon_Effort_Ability_Primary_Cast_010.uasset
│   │           ├── Gideon_Effort_Ability_Primary_Cast_011.uasset
│   │           ├── Gideon_Effort_Attack_010.uasset
│   │           ├── Gideon_Effort_Attack_011.uasset
│   │           ├── Gideon_Effort_Attack_012.uasset
│   │           ├── Gideon_Effort_Attack_013.uasset
│   │           ├── Gideon_Effort_Attack_014.uasset
│   │           ├── Gideon_Effort_Block_010.uasset
│   │           ├── Gideon_Effort_Block_011.uasset
│   │           ├── Gideon_Effort_Block_012.uasset
│   │           ├── Gideon_Effort_Block_013.uasset
│   │           ├── Gideon_Effort_Block_014.uasset
│   │           ├── Gideon_Effort_Block_Cue.uasset
│   │           ├── Gideon_Effort_Death_010.uasset
│   │           ├── Gideon_Effort_Death_011.uasset
│   │           ├── Gideon_Effort_Death_012.uasset
│   │           ├── Gideon_Effort_Death_013.uasset
│   │           ├── Gideon_Effort_Death_014.uasset
│   │           ├── Gideon_Effort_JumpLand_010.uasset
│   │           ├── Gideon_Effort_JumpLand_011.uasset
│   │           ├── Gideon_Effort_JumpLand_012.uasset
│   │           ├── Gideon_Effort_JumpLand_013.uasset
│   │           ├── Gideon_Effort_JumpLand_014.uasset
│   │           ├── Gideon_Effort_Swing_010.uasset
│   │           ├── Gideon_Effort_Swing_011.uasset
│   │           ├── Gideon_Effort_Swing_012.uasset
│   │           ├── Gideon_Effort_Swing_013.uasset
│   │           └── Gideon_Effort_Swing_014.uasset
│   ├── ParagonMinions
│   │   └── Characters
│   │       └── Minions
│   │           └── Down_Minions
│   │               ├── Animations
│   │               │   ├── Ranged
│   │               │   │   ├── Aggro_Transition_A.uasset
│   │               │   │   ├── Blendspaces
│   │               │   │   │   ├── IdleToRun_A_Combat.uasset
│   │               │   │   │   ├── IdleToRun_A_NonCombat.uasset
│   │               │   │   │   └── Jog_NonCombat_A.uasset
│   │               │   │   ├── CoreVibration.uasset
│   │               │   │   ├── Death_Back_A.uasset
│   │               │   │   ├── Death_Front_A.uasset
│   │               │   │   ├── Death_Front_B.uasset
│   │               │   │   ├── Fire_A.uasset
│   │               │   │   ├── Fire_A_1.uasset
│   │               │   │   ├── Fire_A_2.uasset
│   │               │   │   ├── Fire_B.uasset
│   │               │   │   ├── Fire_Montage.uasset
│   │               │   │   ├── HitReact_Back_A.uasset
│   │               │   │   ├── HitReact_Front_A.uasset
│   │               │   │   ├── HitReact_FullBody_A.uasset
│   │               │   │   ├── HitReact_Left_A.uasset
│   │               │   │   ├── HitReact_Right_A.uasset
│   │               │   │   ├── Idle_A.uasset
│   │               │   │   ├── Idle_NonCombat_A.uasset
│   │               │   │   ├── Jog_Fwd_Combat_A.uasset
│   │               │   │   ├── Jog_Fwd_Combat_A_Sliding.uasset
│   │               │   │   ├── Jog_Fwd_Downhill_NonCombat.uasset
│   │               │   │   ├── Jog_Fwd_NonCombat_A.uasset
│   │               │   │   ├── Jog_Fwd_NonCombat_A_Sliding.uasset
│   │               │   │   ├── Jog_Fwd_Uphill_NonCombat.uasset
│   │               │   │   ├── Jog_Left_Combat_A.uasset
│   │               │   │   ├── Jog_Left_NonCombat_A.uasset
│   │               │   │   ├── Jog_Right_Combat_A.uasset
│   │               │   │   ├── Jog_Right_NonCombat_A.uasset
│   │               │   │   ├── KnockUp_A.uasset
│   │               │   │   ├── KnockUp_A_Loop.uasset
│   │               │   │   ├── KnockUp_B.uasset
│   │               │   │   ├── KnockUp_B_Loop.uasset
│   │               │   │   ├── Melee_Combo_A.uasset
│   │               │   │   ├── Melee_Combo_B.uasset
│   │               │   │   ├── Melee_Combo_C.uasset
│   │               │   │   ├── Melee_Combo_D.uasset
│   │               │   │   ├── Melee_Combo_E.uasset
│   │               │   │   ├── Melee_Combo_F.uasset
│   │               │   │   ├── Melee_Montage.uasset
│   │               │   │   ├── Stun.uasset
│   │               │   │   ├── TurnInPlace_Fast_Combat.uasset
│   │               │   │   ├── TurnInPlace_Zero_Combat.uasset
│   │               │   │   ├── Walk_Fwd_Combat_A.uasset
│   │               │   │   └── Walk_Fwd_NonCombat_A.uasset
│   │               │   └── Siege
│   │               │       ├── Blendspaces
│   │               │       │   └── Jog_Combat_BS.uasset
│   │               │       ├── CoreVibration.uasset
│   │               │       ├── Death_A.uasset
│   │               │       ├── Death_B.uasset
│   │               │       ├── Death_C.uasset
│   │               │       ├── Death_D.uasset
│   │               │       ├── Death_H.uasset
│   │               │       ├── Fire_A.uasset
│   │               │       ├── Fire_B.uasset
│   │               │       ├── Fire_C.uasset
│   │               │       ├── Fire_Planted.uasset
│   │               │       ├── Fire_Planted_B.uasset
│   │               │       ├── Fire_Planted_NoAdd.uasset
│   │               │       ├── HitReact_Back.uasset
│   │               │       ├── HitReact_Back_Planted.uasset
│   │               │       ├── HitReact_Front.uasset
│   │               │       ├── HitReact_Front_A.uasset
│   │               │       ├── HitReact_Front_Planted.uasset
│   │               │       ├── HitReact_Left.uasset
│   │               │       ├── HitReact_Left_Planted.uasset
│   │               │       ├── HitReact_Right.uasset
│   │               │       ├── HitReact_Right_Planted.uasset
│   │               │       ├── Idle.uasset
│   │               │       ├── Idle_Planted.uasset
│   │               │       ├── Jog_Bwd_Combat.uasset
│   │               │       ├── Jog_Fwd_Combat.uasset
│   │               │       ├── Jog_Fwd_NonCombat.uasset
│   │               │       ├── Jog_Fwd_NonCombat_Downhill.uasset
│   │               │       ├── Jog_Fwd_NonCombat_Uphill.uasset
│   │               │       ├── Jog_Fwd_Start.uasset
│   │               │       ├── Jog_Fwd_Stop.uasset
│   │               │       ├── Jog_Left_Combat.uasset
│   │               │       ├── Jog_Right_Combat.uasset
│   │               │       ├── KnockUp.uasset
│   │               │       ├── MeleeAttack_A.uasset
│   │               │       ├── PlantedExit.uasset
│   │               │       ├── PlantedIntro.uasset
│   │               │       ├── ShuffleInPlace.uasset
│   │               │       └── Stun.uasset
│   │               ├── Materials
│   │               │   ├── MI_SimpleMinion_Ranged.uasset
│   │               │   ├── MI_SimpleMinion_Siege.uasset
│   │               │   └── M_SimpleLaneMinion.uasset
│   │               ├── Meshes
│   │               │   ├── MinionRanged_AnimBP.uasset
│   │               │   ├── Minion_Lane_Core_Skeleton.uasset
│   │               │   ├── Minion_Lane_Ranged_Dawn.uasset
│   │               │   ├── Minion_Lane_Ranged_Physics.uasset
│   │               │   ├── Minion_Lane_Siege_Dawn.uasset
│   │               │   ├── Minion_Lane_Siege_Physics.uasset
│   │               │   └── Minion_Lane_Siege_Skeleton.uasset
│   │               └── Textures
│   │                   ├── Ranged
│   │                   │   ├── T_Minion_Dawn_Ranged_D.uasset
│   │                   │   └── T_Minion_Dawn_Ranged_N.uasset
│   │                   └── Siege
│   │                       ├── T_Minion_Dawn_Seige_D.uasset
│   │                       └── T_Minion_Dawn_Seige_N.uasset
│   ├── SanderAudio
│   │   ├── AttenuationSettings
│   │   │   ├── Att_010m.uasset
│   │   │   ├── Att_015mBigInner.uasset
│   │   │   ├── Att_020m.uasset
│   │   │   ├── Att_020mBigInner.uasset
│   │   │   ├── Att_020mSharp.uasset
│   │   │   ├── Att_030m.uasset
│   │   │   ├── Att_030mBigInner.uasset
│   │   │   ├── Att_040m.uasset
│   │   │   ├── Att_050m.uasset
│   │   │   ├── Att_060m.uasset
│   │   │   ├── Att_070m.uasset
│   │   │   ├── Att_080m.uasset
│   │   │   ├── Att_090m.uasset
│   │   │   ├── Att_100m.uasset
│   │   │   ├── Att_100m_SmallInner.uasset
│   │   │   └── Att_200m_Large.uasset
│   │   ├── ConcurrencySettings
│   │   │   ├── S_SoundConcurrency_Default_05.uasset
│   │   │   ├── S_SoundConcurrency_EnemyVOFX.uasset
│   │   │   └── S_SoundConcurrency_PlayerVOFX.uasset
│   │   ├── SoundClasses
│   │   │   ├── SC_ActionRoguelike_Amb.uasset
│   │   │   ├── SC_ActionRoguelike_Combat.uasset
│   │   │   ├── SC_ActionRoguelike_Environmental.uasset
│   │   │   ├── SC_ActionRoguelike_Foley.uasset
│   │   │   ├── SC_ActionRoguelike_Items.uasset
│   │   │   ├── SC_ActionRoguelike_Master.uasset
│   │   │   ├── SC_ActionRoguelike_Music.uasset
│   │   │   ├── SC_ActionRoguelike_SFX.uasset
│   │   │   ├── SC_ActionRoguelike_UI.uasset
│   │   │   ├── SC_ActionRoguelike_VO.uasset
│   │   │   ├── SoundSubmixes
│   │   │   │   ├── SS_ActionRoguelike_Amb.uasset
│   │   │   │   ├── SS_ActionRoguelike_Combat.uasset
│   │   │   │   ├── SS_ActionRoguelike_Environmental.uasset
│   │   │   │   ├── SS_ActionRoguelike_Foley.uasset
│   │   │   │   ├── SS_ActionRoguelike_Items.uasset
│   │   │   │   ├── SS_ActionRoguelike_Master.uasset
│   │   │   │   ├── SS_ActionRoguelike_Music.uasset
│   │   │   │   ├── SS_ActionRoguelike_SFX.uasset
│   │   │   │   ├── SS_ActionRoguelike_UI.uasset
│   │   │   │   └── SS_ActionRoguelike_VO.uasset
│   │   │   └── SoundclassMixes
│   │   │       └── SCM_Stunned.uasset
│   │   ├── Sources
│   │   │   ├── DefaultEnemy
│   │   │   │   ├── Combat
│   │   │   │   │   ├── MSS_Enemy_Combat_ProjectileHit.uasset
│   │   │   │   │   ├── MSS_Enemy_Combat_ProjectileLoop.uasset
│   │   │   │   │   ├── MSS_Enemy_Combat_Shoot.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-001.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-002.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-003.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-004.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-005.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-006.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-007.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-008.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-009.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-010.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-011.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-012.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-013.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-014.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-015.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-016.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-017.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-018.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-019.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Impact-020.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-001.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-002.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-003.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-004.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-005.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-006.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-007.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-008.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-009.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-010.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-011.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-012.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-013.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-014.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-015.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-016.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-017.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-018.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-019.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Sizzle-020.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-001.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-002.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-003.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-004.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-005.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-006.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-007.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-008.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-009.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-010.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-011.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-012.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-013.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-014.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-015.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-016.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-017.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-018.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-019.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Proj_Thud-020.uasset
│   │   │   │   │   ├── S_Combat_Enemy_ProjectileLoop.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-001.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-002.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-003.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-004.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-005.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-006.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-007.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-008.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-009.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-010.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-011.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-012.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-013.uasset
│   │   │   │   │   ├── S_Combat_Enemy_Shoot-014.uasset
│   │   │   │   │   └── S_Combat_Enemy_Shoot-015.uasset
│   │   │   │   ├── Locomotion
│   │   │   │   │   ├── MSS_EnemyLocomotion_Footstep.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-001.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-002.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-003.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-004.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-005.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-006.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-007.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-008.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-009.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-010.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-011.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-012.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-013.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-014.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-015.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-016.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-017.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-018.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FoleyArmor-019.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-001.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-002.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-003.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-004.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-005.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-006.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-007.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-008.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-009.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-010.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-011.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-012.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-013.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-014.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-015.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-016.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-017.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-018.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-019.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-020.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-021.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-022.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-023.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-024.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-025.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-026.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-027.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-028.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_FootstepGravel-029.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_LowThud-001.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_LowThud-002.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_LowThud-003.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_LowThud-004.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_LowThud-005.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_LowThud-006.uasset
│   │   │   │   │   ├── S_EnemyLocomotion_LowThud-007.uasset
│   │   │   │   │   └── S_EnemyLocomotion_LowThud-008.uasset
│   │   │   │   └── VOFX
│   │   │   │       ├── MSS_Enemy_VOFX_Death.uasset
│   │   │   │       ├── MSS_Enemy_VOFX_Engage.uasset
│   │   │   │       ├── MSS_Enemy_VOFX_GetHit.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-001.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-002.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-003.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-004.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-005.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-006.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-007.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-008.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-009.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-010.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-011.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-012.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-013.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-014.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-015.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-016.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-017.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-018.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-019.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-020.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-021.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-022.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-023.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-024.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-025.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-026.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-027.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-028.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-029.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-030.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-031.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-032.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-033.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-034.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-035.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-036.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-037.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-038.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-039.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-040.uasset
│   │   │   │       ├── S_Enemy_VOFX_Death-041.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-001.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-002.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-003.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-004.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-005.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-006.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-007.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-008.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-009.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-010.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-011.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-012.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-013.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-014.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-015.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-016.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-017.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-018.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-019.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-020.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-021.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-022.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-023.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-024.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-025.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-026.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-027.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-028.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-029.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-030.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-031.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-032.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-033.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-034.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-035.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-036.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-037.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-038.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-039.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-040.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-041.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-042.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-043.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-044.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-045.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-046.uasset
│   │   │   │       ├── S_Enemy_VOFX_Engage-047.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-001.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-002.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-003.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-004.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-005.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-006.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-007.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-008.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-009.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-010.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-011.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-012.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-013.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-014.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-015.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-016.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-017.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-018.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-019.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-020.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-021.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-022.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-023.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-024.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-025.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-026.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-027.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-028.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-029.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-030.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-031.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-032.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-033.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-034.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-035.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-036.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-037.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-038.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-039.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-040.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-041.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-042.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-043.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-044.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-045.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-046.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-047.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-048.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-049.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-050.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-051.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-052.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-053.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-054.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-055.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-056.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-057.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-058.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-059.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-060.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-061.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-062.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-063.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-064.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-065.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-066.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-067.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-068.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-069.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-070.uasset
│   │   │   │       ├── S_Enemy_VOFX_GetHit-071.uasset
│   │   │   │       └── S_Enemy_VOFX_GetHit-072.uasset
│   │   │   ├── Environment
│   │   │   │   ├── A_Ambience_LoopCut.uasset
│   │   │   │   ├── MSS_Ambience.uasset
│   │   │   │   ├── MSS_Environmental_BarrelAftermath.uasset
│   │   │   │   ├── MSS_Environmental_BarrelExplode.uasset
│   │   │   │   ├── S_Environmental_Barrel_Explosion-001.uasset
│   │   │   │   ├── S_Environmental_Barrel_Explosion-002.uasset
│   │   │   │   ├── S_Environmental_Barrel_Explosion-003.uasset
│   │   │   │   ├── S_Environmental_Barrel_Explosion-004.uasset
│   │   │   │   ├── S_Environmental_Barrel_Explosion-005.uasset
│   │   │   │   ├── S_Environmental_Barrel_Explosion-006.uasset
│   │   │   │   ├── S_Environmental_Barrel_Explosion-007.uasset
│   │   │   │   ├── S_Environmental_Barrel_Explosion-008.uasset
│   │   │   │   ├── S_Environmental_Barrel_Explosion-009.uasset
│   │   │   │   ├── S_Environmental_Barrel_FireAftermath-001.uasset
│   │   │   │   ├── S_Environmental_Barrel_FireAftermath-002.uasset
│   │   │   │   ├── S_Environmental_Barrel_FireAftermath-003.uasset
│   │   │   │   ├── S_Environmental_Barrel_FireAftermath-004.uasset
│   │   │   │   ├── S_Environmental_Barrel_FireAftermath-005.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-001.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-002.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-003.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-004.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-005.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-006.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-007.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-008.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-009.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-010.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-011.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-012.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-013.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-014.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-015.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-016.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-017.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-018.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-019.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-020.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-021.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-022.uasset
│   │   │   │   ├── S_Environmental_Barrel_Impact-023.uasset
│   │   │   │   └── S_Environmental_Barrel_Impact-024.uasset
│   │   │   ├── Interactables
│   │   │   │   ├── MSS_Consumables_HealthPotion.uasset
│   │   │   │   ├── MSS_Interactables_AbilityOrb.uasset
│   │   │   │   ├── MSS_Interactables_CurrencyPickup.uasset
│   │   │   │   ├── MSS_Interactables_TreasureChestOpen.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-001.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-002.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-003.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-004.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-005.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-006.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-007.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-008.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-009.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-010.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-011.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-012.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-013.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-014.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-015.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-016.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-017.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-018.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-019.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-020.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-021.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-022.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-023.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Bubbles-024.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Cork-001.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Cork-002.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Cork-003.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Cork-004.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Cork-005.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Cork-006.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Cork-007.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Cork-008.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Magic-001.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Magic-002.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Magic-003.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Sub-001.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Sub-002.uasset
│   │   │   │   ├── S_Consumables_HealthPotion_Sub-003.uasset
│   │   │   │   ├── S_Interactables_AbilityOrb_Loop.uasset
│   │   │   │   ├── S_Interactables_AbilityOrb_Pickup.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-001.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-002.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-003.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-004.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-005.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-006.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-007.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-008.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-009.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-010.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-011.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-012.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-013.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-014.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-015.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-016.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-017.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-018.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-019.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-020.uasset
│   │   │   │   ├── S_Interactables_Loot_Coin-021.uasset
│   │   │   │   ├── S_Interactables_TreasureChest_Open-001.uasset
│   │   │   │   ├── S_Interactables_TreasureChest_Open-002.uasset
│   │   │   │   ├── S_Interactables_TreasureChest_Open-003.uasset
│   │   │   │   ├── S_Interactables_TreasureChest_Open-004.uasset
│   │   │   │   ├── S_Interactables_TreasureChest_Open-005.uasset
│   │   │   │   ├── S_Interactables_TreasureChest_Open-006.uasset
│   │   │   │   ├── S_Interactables_TreasureChest_Open-007.uasset
│   │   │   │   └── S_Interactables_TreasureChest_Open-008.uasset
│   │   │   ├── Music
│   │   │   │   ├── BuildingBlocks
│   │   │   │   │   ├── S_Music_CombatThreatHigh01_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh01_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh01_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh01_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh02_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh02_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh02_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh02_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh03_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh03_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh03_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh03_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh04_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh04_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh04_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatHigh04_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow01_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow01_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow01_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow01_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow02_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow02_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow02_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow02_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow03_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow03_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow03_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow03_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow04_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow04_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow04_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatLow04_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed01_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed01_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed01_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed01_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed02_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed02_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed02_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed02_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed03_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed03_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed03_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed03_04.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed04_01.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed04_02.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed04_03.uasset
│   │   │   │   │   ├── S_Music_CombatThreatMed04_04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh01_01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh01_02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh01_03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh01_04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh02_01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh02_02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh02_03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh02_04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh03_01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh03_02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh03_03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh03_04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh04_01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh04_02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh04_03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatHigh04_04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_I-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_II-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_A_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_B_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_C_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_I-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_II-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_III-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow01_D_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_I-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_II-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_A_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_B_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_C_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_I-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_II-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_III-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow02_D_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_I-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_II-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_A_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_B_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_C_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_I-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_I-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_I-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_I-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_II-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_II-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_II-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_II-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_III-01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_III-02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_III-03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_III-04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow03_D_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_A_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_A_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_A_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_B_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_B_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_B_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_C_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_C_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_C_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_D_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_D_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow04_D_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_A_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_A_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_A_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_B_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_B_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_B_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_C_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_C_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_C_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_D_I.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_D_II.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatLow05_D_III.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed01_01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed01_02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed01_03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed01_04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed02_01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed02_02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed02_03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed02_04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed03_01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed03_02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed03_03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed03_04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed04_01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed04_02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed04_03.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed04_04.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed05_01.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed05_02.uasset
│   │   │   │   │   ├── S_Music_ProximityThreatMed05_03.uasset
│   │   │   │   │   └── S_Music_ProximityThreatMed05_04.uasset
│   │   │   │   ├── MSS_Music.uasset
│   │   │   │   ├── MSS_Music_CombatThreatHigh.uasset
│   │   │   │   ├── MSS_Music_CombatThreatLow.uasset
│   │   │   │   ├── MSS_Music_CombatThreatMed.uasset
│   │   │   │   ├── MSS_Music_ProximityThreatHigh.uasset
│   │   │   │   ├── MSS_Music_ProximityThreatLow.uasset
│   │   │   │   ├── MSS_Music_ProximityThreatMed.uasset
│   │   │   │   ├── S_Music_CombatThreatHigh.uasset
│   │   │   │   ├── S_Music_CombatThreatLow.uasset
│   │   │   │   ├── S_Music_CombatThreatMedium.uasset
│   │   │   │   ├── S_Music_ProximityThreatHigh.uasset
│   │   │   │   ├── S_Music_ProximityThreatLow.uasset
│   │   │   │   └── S_Music_ProximityThreatMedium.uasset
│   │   │   ├── Player
│   │   │   │   ├── Combat
│   │   │   │   │   ├── MSS_Combat_Abilities_Dash_Cast.uasset
│   │   │   │   │   ├── MSS_Combat_Abilities_Dash_Impact.uasset
│   │   │   │   │   ├── MSS_Combat_Abilities_Primary_Cast.uasset
│   │   │   │   │   ├── MSS_Combat_Abilities_Primary_Impact.uasset
│   │   │   │   │   ├── MSS_Combat_Abilities_Primary_Loop.uasset
│   │   │   │   │   ├── MSS_Combat_Abilities_Secondary_Cast.uasset
│   │   │   │   │   ├── MSS_Combat_Abilities_Secondary_Loop.uasset
│   │   │   │   │   ├── S_Combat_Abilities_DashProj_Cast-001.uasset
│   │   │   │   │   ├── S_Combat_Abilities_DashProj_Cast-002.uasset
│   │   │   │   │   ├── S_Combat_Abilities_DashProj_Cast-003.uasset
│   │   │   │   │   ├── S_Combat_Abilities_DashProj_Cast-004.uasset
│   │   │   │   │   ├── S_Combat_Abilities_DashProj_Impact-001.uasset
│   │   │   │   │   ├── S_Combat_Abilities_DashProj_Impact-002.uasset
│   │   │   │   │   ├── S_Combat_Abilities_DashProj_Impact-003.uasset
│   │   │   │   │   ├── S_Combat_Abilities_DashProj_Impact-004.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-001.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-002.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-003.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-004.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-005.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-006.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-007.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-008.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-009.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-010.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-011.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-012.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-013.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-014.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Cast-015.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-001.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-002.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-003.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-004.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-005.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-006.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-007.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-008.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-009.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-010.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-011.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-012.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-013.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-014.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-015.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Impact-016.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Primary_Loop.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Secondary_Cast-001.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Secondary_Cast.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Secondary_End.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Secondary_Loop.uasset
│   │   │   │   │   ├── S_Combat_Abilities_Secondary_LoopStart.uasset
│   │   │   │   │   └── S_Combat_Abilities_Secondary_TransitionToEnd.uasset
│   │   │   │   ├── Locomotion
│   │   │   │   │   ├── MSS_PlayerLocomotion_Footstep.uasset
│   │   │   │   │   ├── MSS_PlayerLocomotion_Hover.uasset
│   │   │   │   │   ├── MSS_PlayerLocomotion_Jump.uasset
│   │   │   │   │   ├── MSS_PlayerLocomotion_Land.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_AddFoley_Cloth-001.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_AddFoley_Cloth-002.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_AddFoley_Cloth-003.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_AddFoley_Cloth-004.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_AddFoley_Cloth-005.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_AddFoley_Cloth-006.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_AddFoley_Cloth-007.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-001.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-002.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-003.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-004.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-005.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-006.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-007.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-008.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-009.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-010.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-011.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-012.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-013.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-014.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-015.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-016.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-017.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-018.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-019.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-020.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-021.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-022.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-023.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-024.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Footstep_Dirt-025.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Hover_Loop.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Hover_Start.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Hover_Stop-001.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Hover_Stop-002.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Hover_Stop-003.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Hover_Stop-004.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Hover_Stop-005.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Hover_Stop-006.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Jump-001.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Jump-002.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Jump-003.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Jump-004.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Jump-005.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Land-001.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Land-002.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Land-003.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Land-004.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Land-005.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Land-006.uasset
│   │   │   │   │   ├── S_PlayerLocomotion_Land-007.uasset
│   │   │   │   │   └── S_PlayerLocomotion_Land-008.uasset
│   │   │   │   ├── Status_Effects
│   │   │   │   │   ├── MSS_Enemy_StatusEffects_Burning.uasset
│   │   │   │   │   ├── MSS_Player_StatusEffects_Burning.uasset
│   │   │   │   │   ├── MSS_Player_StatusEffects_Stunned.uasset
│   │   │   │   │   ├── S_Player_StatusEffects_BurningLoop.uasset
│   │   │   │   │   ├── S_Player_StatusEffects_Stunned-001.uasset
│   │   │   │   │   ├── S_Player_StatusEffects_Stunned-002.uasset
│   │   │   │   │   └── S_Player_StatusEffects_Stunned-003.uasset
│   │   │   │   └── VOFX
│   │   │   │       ├── Gideon_Ability_LowMana_010.uasset
│   │   │   │       ├── Gideon_Ability_LowMana_020.uasset
│   │   │   │       ├── Gideon_Ability_LowMana_030.uasset
│   │   │   │       ├── Gideon_Ability_LowMana_040.uasset
│   │   │   │       ├── Gideon_Ability_No_010.uasset
│   │   │   │       ├── Gideon_Ability_No_020.uasset
│   │   │   │       ├── Gideon_Ability_No_030.uasset
│   │   │   │       ├── Gideon_Ability_No_040.uasset
│   │   │   │       ├── Gideon_Ability_Ultimate_Ready_010.uasset
│   │   │   │       ├── Gideon_Ability_Ultimate_Self_010.uasset
│   │   │   │       ├── Gideon_Effort_Ability_Primary_Cast_010.uasset
│   │   │   │       ├── Gideon_Effort_Ability_Primary_Cast_011.uasset
│   │   │   │       ├── Gideon_Effort_Attack_010.uasset
│   │   │   │       ├── Gideon_Effort_Attack_011.uasset
│   │   │   │       ├── Gideon_Effort_Attack_012.uasset
│   │   │   │       ├── Gideon_Effort_Attack_013.uasset
│   │   │   │       ├── Gideon_Effort_Attack_014.uasset
│   │   │   │       ├── Gideon_Effort_Block_010.uasset
│   │   │   │       ├── Gideon_Effort_Block_011.uasset
│   │   │   │       ├── Gideon_Effort_Block_012.uasset
│   │   │   │       ├── Gideon_Effort_Block_013.uasset
│   │   │   │       ├── Gideon_Effort_Block_014.uasset
│   │   │   │       ├── Gideon_Effort_Death_010.uasset
│   │   │   │       ├── Gideon_Effort_Death_011.uasset
│   │   │   │       ├── Gideon_Effort_Death_012.uasset
│   │   │   │       ├── Gideon_Effort_Death_013.uasset
│   │   │   │       ├── Gideon_Effort_Death_014.uasset
│   │   │   │       ├── Gideon_Effort_JumpLand_010.uasset
│   │   │   │       ├── Gideon_Effort_JumpLand_011.uasset
│   │   │   │       ├── Gideon_Effort_JumpLand_012.uasset
│   │   │   │       ├── Gideon_Effort_JumpLand_013.uasset
│   │   │   │       ├── Gideon_Effort_JumpLand_014.uasset
│   │   │   │       ├── Gideon_Effort_Swing_010.uasset
│   │   │   │       ├── Gideon_Effort_Swing_011.uasset
│   │   │   │       ├── Gideon_Effort_Swing_012.uasset
│   │   │   │       ├── Gideon_Effort_Swing_013.uasset
│   │   │   │       ├── Gideon_Effort_Swing_014.uasset
│   │   │   │       ├── MSS_Player_VOFX_Death.uasset
│   │   │   │       ├── MSS_Player_VOFX_GetHit.uasset
│   │   │   │       ├── MSS_Player_VOFX_Primary_Cast.uasset
│   │   │   │       ├── MSS_Player_VOFX_Secondary_Cast.uasset
│   │   │   │       └── MSS_Player_VOFX_Stunned.uasset
│   │   │   └── UI
│   │   │       ├── MSS_UI_NonDiegetic_Death.uasset
│   │   │       ├── MSS_UI_NonDiegetic_LowHealth.uasset
│   │   │       ├── MSS_UI_NonDiegetic_Respawn.uasset
│   │   │       ├── S_UI_NonDiegetic_Death.uasset
│   │   │       ├── S_UI_NonDiegetic_LowHealth.uasset
│   │   │       ├── S_UI_NonDiegetic_Respawn-001.uasset
│   │   │       └── S_UI_NonDiegetic_Respawn-002.uasset
│   │   └── _MS_Presets
│   │       ├── MSS_Preset_RandomGet_MONO.uasset
│   │       └── MSS_Preset_RandomGet_STEREO.uasset
│   ├── ShooterGame
│   │   └── Sounds
│   │       ├── Impacts
│   │       │   └── wav
│   │       │       ├── sw_Impt_Launcher_Close_01.uasset
│   │       │       ├── sw_Impt_Launcher_Close_02.uasset
│   │       │       ├── sw_Impt_Launcher_Close_03.uasset
│   │       │       ├── sw_Impt_Launcher_Close_04.uasset
│   │       │       ├── sw_Impt_Launcher_Close_05.uasset
│   │       │       ├── sw_Impt_Launcher_Dist_01.uasset
│   │       │       ├── sw_Impt_Launcher_Dist_02.uasset
│   │       │       ├── sw_Impt_Launcher_Dist_03.uasset
│   │       │       ├── sw_Impt_Launcher_Dist_04.uasset
│   │       │       └── sw_Impt_Launcher_Dist_05.uasset
│   │       ├── Pickups
│   │       │   └── wav
│   │       │       ├── sw_Pickup_Ammo.uasset
│   │       │       └── sw_Pickup_Health.uasset
│   │       ├── Projectiles
│   │       │   └── wav
│   │       │       ├── sw_Proj_Flight_LP_01.uasset
│   │       │       ├── sw_Proj_Flight_LP_02.uasset
│   │       │       ├── sw_Proj_Flight_LP_03.uasset
│   │       │       └── sw_Proj_Flight_LP_04.uasset
│   │       └── Weapons
│   │           └── GrenadeLauncher
│   │               └── wav
│   │                   ├── sw_Wep_Launcher_Shoot_3D_01.uasset
│   │                   ├── sw_Wep_Launcher_Shoot_3D_02.uasset
│   │                   ├── sw_Wep_Launcher_Shoot_3D_03.uasset
│   │                   ├── sw_Wep_Launcher_Shoot_3D_04.uasset
│   │                   ├── sw_Wep_Launcher_Shoot_3D_Dist_01.uasset
│   │                   ├── sw_Wep_Launcher_Shoot_3D_Dist_02.uasset
│   │                   ├── sw_Wep_Launcher_Shoot_3D_Dist_03.uasset
│   │                   └── sw_Wep_Launcher_Shoot_3D_Dist_04.uasset
│   ├── Splash
│   │   ├── EdSplash.bmp
│   │   └── Splash.bmp
│   ├── Troy
│   │   ├── MI_GlobalColor_Emissive.uasset
│   │   ├── MI_GlobalColor_LightGrey.uasset
│   │   ├── MI_GlobalColor_MidGrey.uasset
│   │   ├── MI_GlobalColor_Orange.uasset
│   │   ├── M_GlobalColor_Master.uasset
│   │   ├── SM_CompanionCube.uasset
│   │   ├── SM_GroundButton_Base.uasset
│   │   ├── SM_GroundButton_Button.uasset
│   │   └── SM_OilBarrel.uasset
│   └── tharlevfx_tutorials
│       └── CharacterFX
│           └── ParagonSourceAssets
│               ├── Materials
│               │   ├── Functions
│               │   │   ├── FX_EmissiveModulate.uasset
│               │   │   ├── FadeBasedOnViewAngle.uasset
│               │   │   ├── MF_CameraDistanceFade.uasset
│               │   │   ├── MF_DitheredRefraction.uasset
│               │   │   ├── MF_Eleven_Colors.uasset
│               │   │   ├── MF_FX_EmissiveModulate.uasset
│               │   │   ├── MF_FX_NearCameraFade.uasset
│               │   │   ├── MF_FadeBasedOnViewAngle.uasset
│               │   │   ├── MF_ParticleRandomSize.uasset
│               │   │   ├── MF_ParticleShrinkDistance.uasset
│               │   │   └── MF_RandomSubUV_GPUSprites.uasset
│               │   ├── LensFlare
│               │   │   ├── MF_LensFlare.uasset
│               │   │   ├── MF_LensFlareClipSpaceTransform.uasset
│               │   │   ├── MF_LensFlareOcclusionSample.uasset
│               │   │   └── MF_LensFlareOcclusionSample8.uasset
│               │   ├── MI_CrackedGround_01.uasset
│               │   ├── MI_Liquid_Spray_01_4X6.uasset
│               │   ├── MI_RockDebris_Trans.uasset
│               │   ├── MI_Shockwave_01_ADD.uasset
│               │   ├── MI_Shockwave_03_Add.uasset
│               │   ├── MI_Smoke_01_8X8.uasset
│               │   ├── M_Add_Sprite_Master.uasset
│               │   ├── M_Add_Sprite_SubUV_Master.uasset
│               │   ├── M_Ash_Chunk_Unlit.uasset
│               │   ├── M_BlackHole_Dust.uasset
│               │   ├── M_BlackHole_Mesh.uasset
│               │   ├── M_BlackHole_OuterSmoke.uasset
│               │   ├── M_BlackHole_Pebbles.uasset
│               │   ├── M_BlackHole_Rim.uasset
│               │   ├── M_BlackHole_Sprite.uasset
│               │   ├── M_BlackHole_Vortex.uasset
│               │   ├── M_Boots_Bubble.uasset
│               │   ├── M_Boots_Glow.uasset
│               │   ├── M_Buff_Glow.uasset
│               │   ├── M_Buff_Sphere_Heart.uasset
│               │   ├── M_Burden_Projectile.uasset
│               │   ├── M_Burden_Projectile_Outer.uasset
│               │   ├── M_Burden_Projectile_TwoSided_Inst.uasset
│               │   ├── M_Burst.uasset
│               │   ├── M_CleanseBubble.uasset
│               │   ├── M_DarkFlare_DistShrink.uasset
│               │   ├── M_Energy_Burst.uasset
│               │   ├── M_Explosion_RockChunks.uasset
│               │   ├── M_Explosion_Smoke_Spears.uasset
│               │   ├── M_Fire.uasset
│               │   ├── M_GlowPoint_DistShrink_MASTER.uasset
│               │   ├── M_GlowPoint_MASTER.uasset
│               │   ├── M_Gold_Pile.uasset
│               │   ├── M_Hand_Thrusters.uasset
│               │   ├── M_Hotdog_Spark_VLerp_MASTER.uasset
│               │   ├── M_Hotdog_VLerp_DirectionTint.uasset
│               │   ├── M_Hotdog_VLerp_DirectionTint_Minion_Inst.uasset
│               │   ├── M_Inky_Smoke_Burst.uasset
│               │   ├── M_InvisSmoke_MasterAdditiveWarp_Emissive.uasset
│               │   ├── M_LensFlareMaster.uasset
│               │   ├── M_LensFlare_Particle.uasset
│               │   ├── M_LensFlare_Particle_01.uasset
│               │   ├── M_LensFlare_Particle_Pink_Flicker.uasset
│               │   ├── M_Lensflare_012.uasset
│               │   ├── M_Lensflare_TB_Soft.uasset
│               │   ├── M_Lensflare_TB_Soft_LDR2HDR.uasset
│               │   ├── M_Portal_Open_Burst.uasset
│               │   ├── M_Portal_Space_Mini.uasset
│               │   ├── M_Radial_Blur_Refraction.uasset
│               │   ├── M_Radial_Gradient.uasset
│               │   ├── M_Soft_Spark_Glow.uasset
│               │   ├── M_Spark_VelocityLerp_Pellets_Inst.uasset
│               │   ├── M_Spark_VelocityLerp_TeamColor.uasset
│               │   ├── M_Swirl_Plasma.uasset
│               │   ├── M_Teleport_Refraction.uasset
│               │   ├── M_Trans_Sprite_Lit_SubUV_Master.uasset
│               │   ├── M_Trans_Sprite_Master_DepthFade.uasset
│               │   ├── M_Trans_Sprite_Master_Surface.uasset
│               │   ├── M_Wisp_SplineThicken_Small.uasset
│               │   ├── M_Wispy_Smoke_Trail_Projectile.uasset
│               │   ├── M_explosion_subUV.uasset
│               │   ├── M_radial_ramp.uasset
│               │   ├── M_smoke_subUV.uasset
│               │   ├── OrionGlobalArtCollection.uasset
│               │   ├── m_flare_01.uasset
│               │   └── m_flare_03.uasset
│               ├── Meshes
│               │   ├── SM_1MeterSphere_MultiUVs.uasset
│               │   ├── SM_BigPortal_Torus.uasset
│               │   ├── SM_Black_Hole_Main.uasset
│               │   ├── SM_Black_Hole_Rim.uasset
│               │   ├── SM_Black_Hole_Vortex.uasset
│               │   ├── SM_Buff_Sphere.uasset
│               │   ├── SM_Burden_Projectile.uasset
│               │   ├── SM_Burden_Projectile_Wisps.uasset
│               │   ├── SM_CleanseBubble.uasset
│               │   ├── SM_Coin_Small.uasset
│               │   ├── SM_Hand_Thruster.uasset
│               │   ├── SM_Impact_Warp.uasset
│               │   ├── SM_Open_Square.uasset
│               │   ├── SM_Portal_Flat.uasset
│               │   ├── SM_PriceShield_ProjectionPlane.uasset
│               │   ├── SM_Sphere.uasset
│               │   ├── SM_Spline_X_Aligned.uasset
│               │   └── SM_swirls_polySurface3.uasset
│               ├── Niagara
│               │   ├── NS_Burning.uasset
│               │   ├── NS_CarriedBuff_Received_Black.uasset
│               │   ├── NS_DroppedBuff_Gold.uasset
│               │   ├── NS_DroppedBuff_HealthRegen.uasset
│               │   ├── NS_DroppedBuff_Health_Light.uasset
│               │   ├── NS_Explosion.uasset
│               │   ├── NS_Flames.uasset
│               │   ├── NS_Gideon_Burden_MuzzleFlash.uasset
│               │   ├── NS_Gideon_Burden_Projectile.uasset
│               │   ├── NS_Gideon_Primary_HitWorld.uasset
│               │   ├── NS_Gideon_Primary_MuzzleFlash.uasset
│               │   ├── NS_Gideon_Primary_Projectile.uasset
│               │   ├── NS_Gideon_TravelMode_Hands.uasset
│               │   ├── NS_Gideon_Ultimate.uasset
│               │   ├── NS_Portal_Cast.uasset
│               │   ├── NS_Portal_Entrance_Close.uasset
│               │   ├── NS_Portal_Teleport_Enter.uasset
│               │   ├── NS_Portal_Teleport_Exit.uasset
│               │   ├── NS_Skill_Leap_Base_Velocity_Impact.uasset
│               │   └── NS_Treasure_Burst.uasset
│               ├── Textures
│               │   ├── T_Black_32_D.uasset
│               │   ├── T_BlastWave_D.uasset
│               │   ├── T_Buff_Sphere_E.uasset
│               │   ├── T_Burden_Ribbon_M.uasset
│               │   ├── T_Burst_M.uasset
│               │   ├── T_Concrete_ChunkSubUV_D.uasset
│               │   ├── T_Concrete_ChunkSubUV_N_TGA.uasset
│               │   ├── T_ElectricalBolt_3.uasset
│               │   ├── T_EnergyPlasma_Tile_H_01.uasset
│               │   ├── T_Explosion_SubUV.uasset
│               │   ├── T_FireBall_07D_Depth.uasset
│               │   ├── T_FireBall_07D_N.uasset
│               │   ├── T_Fire_subUV_01.uasset
│               │   ├── T_Fire_tile.uasset
│               │   ├── T_FlareWide_04.uasset
│               │   ├── T_Flare_Spikeball.uasset
│               │   ├── T_FluidSmoke_04.uasset
│               │   ├── T_FluidSmoke_04_Depth.uasset
│               │   ├── T_GlowNoise_01_M.uasset
│               │   ├── T_Glow_Sphere_Soft.uasset
│               │   ├── T_Inky_Smoke.uasset
│               │   ├── T_Inky_Smoke_Tile.uasset
│               │   ├── T_LDR_Flare01.uasset
│               │   ├── T_Lensflare_02.uasset
│               │   ├── T_MinionSmokeMask_Test.uasset
│               │   ├── T_MinionSmokeTile.uasset
│               │   ├── T_Muriel_Corona_D.uasset
│               │   ├── T_Muriel_Prism_03.uasset
│               │   ├── T_NoisyRamp.uasset
│               │   ├── T_Plasma_Aurora_Seamless.uasset
│               │   ├── T_Portal_Gradient_02_D.uasset
│               │   ├── T_Portal_Gradient_02_M.uasset
│               │   ├── T_Portal_Gradient_M.uasset
│               │   ├── T_Portal_SpaceMask_M.uasset
│               │   ├── T_Portal_Space_D.uasset
│               │   ├── T_Radial_Burst.uasset
│               │   ├── T_Radial_Refraction_Blur_N.uasset
│               │   ├── T_Refraction_Depression_N.uasset
│               │   ├── T_Rocks_3_3_D.uasset
│               │   ├── T_Silky_Smoke_Trail.uasset
│               │   ├── T_SmokeBall_01_8_8_M.uasset
│               │   ├── T_SmokeRend_N.uasset
│               │   ├── T_SmokeSubUV_8X8.uasset
│               │   ├── T_Smoke_Tiled_D.uasset
│               │   ├── T_Smoke_Trail_Soft.uasset
│               │   ├── T_Smooth_Gradient_Vertical_A.uasset
│               │   ├── T_SoftEdge_M.uasset
│               │   ├── T_Soft_Noise.uasset
│               │   ├── T_Space.uasset
│               │   ├── T_Spark_Soft.uasset
│               │   ├── T_Sphere_Edge_N.uasset
│               │   ├── T_StretchSpark_01.uasset
│               │   ├── T_Surface_Erosion_M.uasset
│               │   ├── T_TankMoteNoise.uasset
│               │   ├── T_TileNoise.uasset
│               │   ├── T_TilingClouds_01.uasset
│               │   ├── T_TilingClouds_01_N.uasset
│               │   ├── T_Trail_Mask.uasset
│               │   ├── T_Treasure_N.uasset
│               │   ├── T_Turbulence_AdditiveWarp_Linear.uasset
│               │   ├── T_Turret_N.uasset
│               │   ├── T_Turret_Roughness.uasset
│               │   ├── T_Wind_Blur.uasset
│               │   ├── T_bloodTest_4X6_D.uasset
│               │   ├── T_cracks_01_N.uasset
│               │   ├── T_cracks_03_M.uasset
│               │   ├── T_noise_flamy_Tile.uasset
│               │   ├── T_stardots.uasset
│               │   └── T_sunflare.uasset
│               └── VectorFields
│                   ├── Noisy_Turbulence_103.uasset
│                   ├── VF_F60.uasset
│                   └── VF_Vortex_6.uasset
├── README.md
└── Source
    ├── ActionRoguelike
    │   ├── AI
    │   │   ├── RogueAICharacter.cpp
    │   │   ├── RogueAICharacter.h
    │   │   ├── RogueAIController.cpp
    │   │   ├── RogueAIController.h
    │   │   ├── RogueAction_MinionMeleeAttack.cpp
    │   │   ├── RogueAction_MinionMeleeAttack.h
    │   │   ├── RogueAction_MinionRangedAttack.cpp
    │   │   ├── RogueAction_MinionRangedAttack.h
    │   │   ├── RogueBTDecorator_CheckHealth.cpp
    │   │   ├── RogueBTDecorator_CheckHealth.h
    │   │   ├── RogueBTService_CheckAttackRange.cpp
    │   │   ├── RogueBTService_CheckAttackRange.h
    │   │   ├── RogueBTService_StartAction.cpp
    │   │   ├── RogueBTService_StartAction.h
    │   │   ├── RogueBTTask_HealSelf.cpp
    │   │   ├── RogueBTTask_HealSelf.h
    │   │   ├── RogueBTTask_RangedAttack.cpp
    │   │   ├── RogueBTTask_RangedAttack.h
    │   │   ├── RogueBTTask_StartAction.cpp
    │   │   ├── RogueBTTask_StartAction.h
    │   │   ├── RogueQueryContext_TargetActor.cpp
    │   │   └── RogueQueryContext_TargetActor.h
    │   ├── ActionRoguelike.Build.cs
    │   ├── ActionRoguelike.cpp
    │   ├── ActionRoguelike.h
    │   ├── ActionSystem
    │   │   ├── RogueAction.cpp
    │   │   ├── RogueAction.h
    │   │   ├── RogueActionComponent.cpp
    │   │   ├── RogueActionComponent.h
    │   │   ├── RogueActionEffect.cpp
    │   │   ├── RogueActionEffect.h
    │   │   ├── RogueActionEffect_Thorns.cpp
    │   │   ├── RogueActionEffect_Thorns.h
    │   │   ├── RogueActionSystemInterface.cpp
    │   │   ├── RogueActionSystemInterface.h
    │   │   ├── RogueAction_ProjectileAttack.cpp
    │   │   ├── RogueAction_ProjectileAttack.h
    │   │   ├── RogueAttributeSet.cpp
    │   │   └── RogueAttributeSet.h
    │   ├── Animation
    │   │   ├── RogueAnimInstance.cpp
    │   │   ├── RogueAnimInstance.h
    │   │   ├── RogueAnimNotifyState_Melee.cpp
    │   │   ├── RogueAnimNotifyState_Melee.h
    │   │   ├── RogueCurveAnimSubsystem.cpp
    │   │   └── RogueCurveAnimSubsystem.h
    │   ├── Core
    │   │   ├── RogueDeferredTaskSystem.cpp
    │   │   ├── RogueDeferredTaskSystem.h
    │   │   ├── RogueDeveloperSettings.cpp
    │   │   ├── RogueDeveloperSettings.h
    │   │   ├── RogueGameModeBase.cpp
    │   │   ├── RogueGameModeBase.h
    │   │   ├── RogueGameState.cpp
    │   │   ├── RogueGameState.h
    │   │   ├── RogueGameViewportClient.cpp
    │   │   ├── RogueGameViewportClient.h
    │   │   ├── RogueGameplayFunctionLibrary.cpp
    │   │   ├── RogueGameplayFunctionLibrary.h
    │   │   ├── RogueGameplayInterface.cpp
    │   │   ├── RogueGameplayInterface.h
    │   │   ├── RogueLoadingScreenSubsystem.cpp
    │   │   ├── RogueLoadingScreenSubsystem.h
    │   │   ├── RogueMessagingSubsystem.cpp
    │   │   ├── RogueMessagingSubsystem.h
    │   │   ├── RogueMonsterData.cpp
    │   │   └── RogueMonsterData.h
    │   ├── Development
    │   │   ├── RogueCheatManager.cpp
    │   │   ├── RogueCheatManager.h
    │   │   ├── RogueDeveloperLocalSettings.cpp
    │   │   └── RogueDeveloperLocalSettings.h
    │   ├── Performance
    │   │   ├── RogueActorPoolingInterface.cpp
    │   │   ├── RogueActorPoolingInterface.h
    │   │   ├── RogueActorPoolingSubsystem.cpp
    │   │   ├── RogueActorPoolingSubsystem.h
    │   │   ├── RogueSignificanceComponent.cpp
    │   │   ├── RogueSignificanceComponent.h
    │   │   ├── RogueSignificanceInterface.cpp
    │   │   ├── RogueSignificanceInterface.h
    │   │   ├── RogueSignificanceManager.cpp
    │   │   ├── RogueSignificanceManager.h
    │   │   ├── RogueSignificanceSettings.cpp
    │   │   ├── RogueSignificanceSettings.h
    │   │   ├── RogueTickablesSubsystem.cpp
    │   │   └── RogueTickablesSubsystem.h
    │   ├── Pickups
    │   │   ├── RoguePickupActor.cpp
    │   │   ├── RoguePickupActor.h
    │   │   ├── RoguePickupActor_Credits.cpp
    │   │   ├── RoguePickupActor_Credits.h
    │   │   ├── RoguePickupActor_GrantAction.cpp
    │   │   ├── RoguePickupActor_GrantAction.h
    │   │   ├── RoguePickupActor_HealthPotion.cpp
    │   │   ├── RoguePickupActor_HealthPotion.h
    │   │   ├── RoguePickupItemReplication.cpp
    │   │   ├── RoguePickupItemReplication.h
    │   │   ├── RoguePickupSubsystem.cpp
    │   │   └── RoguePickupSubsystem.h
    │   ├── Player
    │   │   ├── RogueInteractionComponent.cpp
    │   │   ├── RogueInteractionComponent.h
    │   │   ├── RoguePlayerCharacter.cpp
    │   │   ├── RoguePlayerCharacter.h
    │   │   ├── RoguePlayerController.cpp
    │   │   ├── RoguePlayerController.h
    │   │   ├── RoguePlayerData.cpp
    │   │   ├── RoguePlayerData.h
    │   │   ├── RoguePlayerState.cpp
    │   │   └── RoguePlayerState.h
    │   ├── Projectiles
    │   │   ├── RogueProjectile.cpp
    │   │   ├── RogueProjectile.h
    │   │   ├── RogueProjectileData.cpp
    │   │   ├── RogueProjectileData.h
    │   │   ├── RogueProjectileMovementComponent.cpp
    │   │   ├── RogueProjectileMovementComponent.h
    │   │   ├── RogueProjectileReplication.cpp
    │   │   ├── RogueProjectileReplication.h
    │   │   ├── RogueProjectile_Blackhole.cpp
    │   │   ├── RogueProjectile_Blackhole.h
    │   │   ├── RogueProjectile_Dash.cpp
    │   │   ├── RogueProjectile_Dash.h
    │   │   ├── RogueProjectile_Magic.cpp
    │   │   ├── RogueProjectile_Magic.h
    │   │   ├── RogueProjectilesSubsystem.cpp
    │   │   └── RogueProjectilesSubsystem.h
    │   ├── SaveSystem
    │   │   ├── RogueSaveGame.cpp
    │   │   ├── RogueSaveGame.h
    │   │   ├── RogueSaveGameSettings.cpp
    │   │   ├── RogueSaveGameSettings.h
    │   │   ├── RogueSaveGameSubsystem.cpp
    │   │   └── RogueSaveGameSubsystem.h
    │   ├── SharedGameplayTags.cpp
    │   ├── SharedGameplayTags.h
    │   ├── StateTrees
    │   │   ├── RogueStateTreeDirectorSchema.cpp
    │   │   ├── RogueStateTreeDirectorSchema.h
    │   │   ├── RogueStateTreeTasks.cpp
    │   │   └── RogueStateTreeTasks.h
    │   ├── Subsystems
    │   │   ├── RogueMonsterCorpseSubsystem.cpp
    │   │   └── RogueMonsterCorpseSubsystem.h
    │   ├── UI
    │   │   ├── RogueEffectSlotWidget.cpp
    │   │   ├── RogueEffectSlotWidget.h
    │   │   ├── RogueHUD.cpp
    │   │   ├── RogueHUD.h
    │   │   ├── RogueWorldUserWidget.cpp
    │   │   └── RogueWorldUserWidget.h
    │   └── World
    │       ├── RogueExplosiveBarrel.cpp
    │       ├── RogueExplosiveBarrel.h
    │       ├── RogueTargetDummy.cpp
    │       ├── RogueTargetDummy.h
    │       ├── RogueTreasureChest.cpp
    │       └── RogueTreasureChest.h
    ├── ActionRoguelike.Target.cs
    ├── ActionRoguelikeEditor.Target.cs
    └── RogueEditor
        ├── RogueEditor.Build.cs
        ├── RogueEditor.cpp
        └── Validators
            ├── EditorValidator_Projectiles.cpp
            └── EditorValidator_Projectiles.h

```

`ActionRoguelike.uproject`:

```uproject
{
	"FileVersion": 3,
	"EngineAssociation": "5.6",
	"Category": "",
	"Description": "",
	"Modules": [
		{
			"Name": "ActionRoguelike",
			"Type": "Runtime",
			"LoadingPhase": "Default",
			"AdditionalDependencies": [
				"Engine",
				"AIModule",
				"UMG",
				"CoreUObject",
				"DeveloperSettings"
			]
		},
		{
			"Name": "RogueEditor",
			"Type": "Editor",
			"LoadingPhase": "Default"
		}
	],
	"Plugins": [
		{
			"Name": "SignificanceManager",
			"Enabled": true
		},
		{
			"Name": "OnlineSubsystemSteam",
			"Enabled": true
		},
		{
			"Name": "Text3D",
			"Enabled": true
		},
		{
			"Name": "ActorLayerUtilities",
			"Enabled": false
		},
		{
			"Name": "AlembicImporter",
			"Enabled": false
		},
		{
			"Name": "AndroidDeviceProfileSelector",
			"Enabled": false
		},
		{
			"Name": "AndroidMedia",
			"Enabled": false
		},
		{
			"Name": "AndroidMoviePlayer",
			"Enabled": false
		},
		{
			"Name": "OnlineSubsystemGooglePlay",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Android"
			]
		},
		{
			"Name": "AndroidPermission",
			"Enabled": false
		},
		{
			"Name": "AnimationSharing",
			"Enabled": false
		},
		{
			"Name": "AppleImageUtils",
			"Enabled": false
		},
		{
			"Name": "AppleMoviePlayer",
			"Enabled": false
		},
		{
			"Name": "ArchVisCharacter",
			"Enabled": false
		},
		{
			"Name": "AudioCapture",
			"Enabled": false
		},
		{
			"Name": "Synthesis",
			"Enabled": false
		},
		{
			"Name": "AutomationUtils",
			"Enabled": false
		},
		{
			"Name": "AvfMedia",
			"Enabled": false
		},
		{
			"Name": "BackChannel",
			"Enabled": false
		},
		{
			"Name": "CableComponent",
			"Enabled": false
		},
		{
			"Name": "ChaosClothEditor",
			"Enabled": false
		},
		{
			"Name": "ChaosCloth",
			"Enabled": false
		},
		{
			"Name": "ChunkDownloader",
			"Enabled": false
		},
		{
			"Name": "CLionSourceCodeAccess",
			"Enabled": false
		},
		{
			"Name": "CodeLiteSourceCodeAccess",
			"Enabled": false
		},
		{
			"Name": "CustomMeshComponent",
			"Enabled": false
		},
		{
			"Name": "DataValidation",
			"Enabled": false
		},
		{
			"Name": "DatasmithContent",
			"Enabled": false
		},
		{
			"Name": "ExampleDeviceProfileSelector",
			"Enabled": false
		},
		{
			"Name": "FacialAnimation",
			"Enabled": false
		},
		{
			"Name": "GeometryCache",
			"Enabled": false
		},
		{
			"Name": "GoogleCloudMessaging",
			"Enabled": false
		},
		{
			"Name": "GooglePAD",
			"Enabled": false
		},
		{
			"Name": "MediaCompositing",
			"Enabled": false
		},
		{
			"Name": "ImgMedia",
			"Enabled": false
		},
		{
			"Name": "IOSDeviceProfileSelector",
			"Enabled": false
		},
		{
			"Name": "KDevelopSourceCodeAccess",
			"Enabled": false
		},
		{
			"Name": "LauncherChunkInstaller",
			"Enabled": false
		},
		{
			"Name": "LinuxDeviceProfileSelector",
			"Enabled": false
		},
		{
			"Name": "OpenXRHandTracking",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win32",
				"Win64",
				"Linux",
				"HoloLens",
				"Android"
			]
		},
		{
			"Name": "MacGraphicsSwitching",
			"Enabled": false
		},
		{
			"Name": "MediaPlayerEditor",
			"Enabled": false
		},
		{
			"Name": "MeshPainting",
			"Enabled": false
		},
		{
			"Name": "LocationServicesBPLibrary",
			"Enabled": false
		},
		{
			"Name": "MotoSynth",
			"Enabled": false
		},
		{
			"Name": "MobilePatchingUtils",
			"Enabled": false
		},
		{
			"Name": "WebMMoviePlayer",
			"Enabled": false
		},
		{
			"Name": "OnlineSubsystemIOS",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"IOS",
				"TVOS"
			]
		},
		{
			"Name": "OpenImageDenoise",
			"Enabled": false
		},
		{
			"Name": "OpenXREyeTracker",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win32",
				"Win64",
				"Linux",
				"HoloLens",
				"Android"
			]
		},
		{
			"Name": "OpenXR",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win32",
				"Win64",
				"Linux",
				"Android",
				"HoloLens"
			]
		},
		{
			"Name": "Paper2D",
			"Enabled": false
		},
		{
			"Name": "PixWinPlugin",
			"Enabled": false
		},
		{
			"Name": "PlasticSourceControl",
			"Enabled": false
		},
		{
			"Name": "ProxyLODPlugin",
			"Enabled": false
		},
		{
			"Name": "SpeedTreeImporter",
			"Enabled": false
		},
		{
			"Name": "SoundFields",
			"Enabled": false
		},
		{
			"Name": "SubversionSourceControl",
			"Enabled": false
		},
		{
			"Name": "UObjectPlugin",
			"Enabled": false
		},
		{
			"Name": "VariantManagerContent",
			"Enabled": false
		},
		{
			"Name": "WindowsMoviePlayer",
			"Enabled": false
		},
		{
			"Name": "MobileLauncherProfileWizard",
			"Enabled": false
		},
		{
			"Name": "WmfMedia",
			"Enabled": false
		},
		{
			"Name": "XGEController",
			"Enabled": false
		},
		{
			"Name": "TcpMessaging",
			"Enabled": false
		},
		{
			"Name": "UdpMessaging",
			"Enabled": false
		},
		{
			"Name": "Bridge",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win64",
				"Mac",
				"Linux"
			]
		},
		{
			"Name": "AndroidFileServer",
			"Enabled": false
		},
		{
			"Name": "InterchangeEditor",
			"Enabled": false
		},
		{
			"Name": "CharacterAI",
			"Enabled": false
		},
		{
			"Name": "WorldPartitionHLODUtilities",
			"Enabled": false
		},
		{
			"Name": "ResonanceAudio",
			"Enabled": false
		},
		{
			"Name": "ModelingToolsEditorMode",
			"Enabled": true
		},
		{
			"Name": "StaticMeshEditorModeling",
			"Enabled": true
		},
		{
			"Name": "StateTree",
			"Enabled": true
		},
		{
			"Name": "SlateInsights",
			"Enabled": true
		},
		{
			"Name": "N10XSourceCodeAccess",
			"Enabled": false
		},
		{
			"Name": "ActorSequence",
			"Enabled": false
		},
		{
			"Name": "ChangelistReview",
			"Enabled": false
		},
		{
			"Name": "ChaosUserDataPT",
			"Enabled": false
		},
		{
			"Name": "CmdLinkServer",
			"Enabled": false
		},
		{
			"Name": "CryptoKeys",
			"Enabled": false
		},
		{
			"Name": "Fab",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win64",
				"Mac",
				"Linux"
			]
		},
		{
			"Name": "GLTFExporter",
			"Enabled": false
		},
		{
			"Name": "MediaPlate",
			"Enabled": false
		},
		{
			"Name": "InterchangeTests",
			"Enabled": false
		},
		{
			"Name": "Interchange",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win64",
				"Linux",
				"Mac"
			]
		},
		{
			"Name": "MsQuic",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win64",
				"Linux",
				"Mac"
			]
		},
		{
			"Name": "PlatformCrypto",
			"Enabled": false
		},
		{
			"Name": "PortableObjectFileDataSource",
			"Enabled": false
		},
		{
			"Name": "StudioTelemetry",
			"Enabled": false
		},
		{
			"Name": "NiagaraSimCaching",
			"Enabled": false
		},
		{
			"Name": "EditorSysConfigAssistant",
			"Enabled": true
		},
		{
			"Name": "GameplayInsights",
			"Enabled": true
		},
		{
			"Name": "TraceSourceFilters",
			"Enabled": true
		},
		{
			"Name": "AnimationBudgetAllocator",
			"Enabled": true
		},
		{
			"Name": "Cascade",
			"Enabled": false
		},
		{
			"Name": "MetaHumanSDK",
			"Enabled": false
		},
		{
			"Name": "ChaosEditor",
			"Enabled": false
		},
		{
			"Name": "Dataflow",
			"Enabled": false
		},
		{
			"Name": "DumpGPUServices",
			"Enabled": false
		},
		{
			"Name": "EditorPerformance",
			"Enabled": false
		},
		{
			"Name": "EditorTelemetry",
			"Enabled": false
		},
		{
			"Name": "RuntimeTelemetry",
			"Enabled": false
		},
		{
			"Name": "EditorDebugTools",
			"Enabled": false
		},
		{
			"Name": "GitSourceControl",
			"Enabled": false
		},
		{
			"Name": "LevelSequenceNavigatorBridge",
			"Enabled": false
		},
		{
			"Name": "NullSourceCodeAccess",
			"Enabled": false
		},
		{
			"Name": "LocalizableMessage",
			"Enabled": false
		},
		{
			"Name": "NFORDenoise",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win64",
				"Linux"
			]
		},
		{
			"Name": "NNEDenoiser",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win64",
				"Linux",
				"Mac"
			]
		},
		{
			"Name": "VisualStudioCodeSourceCodeAccess",
			"Enabled": false
		},
		{
			"Name": "UVEditor",
			"Enabled": false
		},
		{
			"Name": "UbaController",
			"Enabled": false,
			"SupportedTargetPlatforms": [
				"Win64",
				"Mac",
				"Linux"
			]
		},
		{
			"Name": "RenderDocPlugin",
			"Enabled": false
		},
		{
			"Name": "RenderGraphInsights",
			"Enabled": false
		},
		{
			"Name": "Iris",
			"Enabled": true
		},
		{
			"Name": "GameplayStateTree",
			"Enabled": true
		}
	],
	"TargetPlatforms": [
		"Windows"
	]
}
```

`CollectedPSOs/Cmd_ConvertPSOs.bat`:

```bat
:: commandlet to convert all the gathered PSOs (can be multiple files across multiple runs) from a cooked build and inject it into the game to be included the next time its cooked.
:: using full paths here on my local machine...ofc update this to your own paths (was having some issues with relative paths so just used full paths for now)
E:\Epic\UE_5.3\Engine\Binaries\Win64\UnrealEditor-Cmd.exe -run=ShaderPipelineCacheTools expand E:\GitHub\ActionRoguelike\CollectedPSOs\*.rec.upipelinecache E:\GitHub\ActionRoguelike\CollectedPSOs\*.shk E:\GitHub\ActionRoguelike\CollectedPSOs\PSO_ActionRoguelike_PCD3D_SM6.spc
```

`Config/DefaultEditor.ini`:

```ini
[/Script/AdvancedPreviewScene.SharedProfiles]
+Profiles=(ProfileName="Epic Headquarters",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=1.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=1.000000,bRotateLightingRig=False,bShowEnvironment=True,bShowFloor=True,bShowGrid=False,EnvironmentColor=(R=0.200000,G=0.200000,B=0.200000,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/EpicQuadPanorama_CC+EV1.EpicQuadPanorama_CC+EV1",bPostProcessingEnabled=True,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureHighlightThresholdStrength=False,bOverride_LocalExposureShadowThresholdStrength=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldPetzvalBokeh=False,bOverride_DepthOfFieldPetzvalBokehFalloff=False,bOverride_DepthOfFieldPetzvalExclusionBoxExtents=False,bOverride_DepthOfFieldPetzvalExclusionBoxRadius=False,bOverride_DepthOfFieldAspectRatioScalar=False,bOverride_DepthOfFieldMatteBoxFlags=False,bOverride_DepthOfFieldBarrelRadius=False,bOverride_DepthOfFieldBarrelLength=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_RayTracingTranslucencyMaxPrimaryHitEvents=False,bOverride_RayTracingTranslucencyMaxSecondaryHitEvents=False,bOverride_RayTracingTranslucencyUseRayTracedRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenSkylightLeakingTint=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenSkylightLeakingTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureHighlightThresholdStrength=1.000000,LocalExposureShadowThresholdStrength=1.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldPetzvalBokeh=0.000000,DepthOfFieldPetzvalBokehFalloff=1.000000,DepthOfFieldPetzvalExclusionBoxExtents=(X=0.000000,Y=0.000000),DepthOfFieldPetzvalExclusionBoxRadius=0.000000,DepthOfFieldAspectRatioScalar=1.000000,DepthOfFieldBarrelRadius=5.000000,DepthOfFieldBarrelLength=0.000000,DepthOfFieldMatteBoxFlags[0]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[1]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[2]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyMaxPrimaryHitEvents=4,RayTracingTranslucencyMaxSecondaryHitEvents=2,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,RayTracingTranslucencyUseRayTracedRefraction=False,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=True,bShowMeshEdges=False)
+Profiles=(ProfileName="Grey Wireframe",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=1.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=1.000000,bRotateLightingRig=False,bShowEnvironment=False,bShowFloor=False,bShowGrid=True,EnvironmentColor=(R=0.039216,G=0.039216,B=0.039216,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/EpicQuadPanorama_CC+EV1.EpicQuadPanorama_CC+EV1",bPostProcessingEnabled=False,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureHighlightThresholdStrength=False,bOverride_LocalExposureShadowThresholdStrength=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldPetzvalBokeh=False,bOverride_DepthOfFieldPetzvalBokehFalloff=False,bOverride_DepthOfFieldPetzvalExclusionBoxExtents=False,bOverride_DepthOfFieldPetzvalExclusionBoxRadius=False,bOverride_DepthOfFieldAspectRatioScalar=False,bOverride_DepthOfFieldMatteBoxFlags=False,bOverride_DepthOfFieldBarrelRadius=False,bOverride_DepthOfFieldBarrelLength=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_RayTracingTranslucencyMaxPrimaryHitEvents=False,bOverride_RayTracingTranslucencyMaxSecondaryHitEvents=False,bOverride_RayTracingTranslucencyUseRayTracedRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenSkylightLeakingTint=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenSkylightLeakingTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureHighlightThresholdStrength=1.000000,LocalExposureShadowThresholdStrength=1.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldPetzvalBokeh=0.000000,DepthOfFieldPetzvalBokehFalloff=1.000000,DepthOfFieldPetzvalExclusionBoxExtents=(X=0.000000,Y=0.000000),DepthOfFieldPetzvalExclusionBoxRadius=0.000000,DepthOfFieldAspectRatioScalar=1.000000,DepthOfFieldBarrelRadius=5.000000,DepthOfFieldBarrelLength=0.000000,DepthOfFieldMatteBoxFlags[0]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[1]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[2]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyMaxPrimaryHitEvents=4,RayTracingTranslucencyMaxSecondaryHitEvents=2,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,RayTracingTranslucencyUseRayTracedRefraction=False,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=False,bShowMeshEdges=True)
+Profiles=(ProfileName="Grey Ambient",bSharedProfile=True,bIsEngineDefaultProfile=True,bUseSkyLighting=True,DirectionalLightIntensity=4.000000,DirectionalLightColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SkyLightIntensity=2.000000,bRotateLightingRig=False,bShowEnvironment=True,bShowFloor=True,bShowGrid=True,EnvironmentColor=(R=0.200000,G=0.200000,B=0.200000,A=1.000000),EnvironmentIntensity=1.000000,EnvironmentCubeMapPath="/Engine/EditorMaterials/AssetViewer/T_GreyAmbient",bPostProcessingEnabled=False,PostProcessingSettings=(bOverride_TemperatureType=False,bOverride_WhiteTemp=False,bOverride_WhiteTint=False,bOverride_ColorSaturation=False,bOverride_ColorContrast=False,bOverride_ColorGamma=False,bOverride_ColorGain=False,bOverride_ColorOffset=False,bOverride_ColorSaturationShadows=False,bOverride_ColorContrastShadows=False,bOverride_ColorGammaShadows=False,bOverride_ColorGainShadows=False,bOverride_ColorOffsetShadows=False,bOverride_ColorSaturationMidtones=False,bOverride_ColorContrastMidtones=False,bOverride_ColorGammaMidtones=False,bOverride_ColorGainMidtones=False,bOverride_ColorOffsetMidtones=False,bOverride_ColorSaturationHighlights=False,bOverride_ColorContrastHighlights=False,bOverride_ColorGammaHighlights=False,bOverride_ColorGainHighlights=False,bOverride_ColorOffsetHighlights=False,bOverride_ColorCorrectionShadowsMax=False,bOverride_ColorCorrectionHighlightsMin=False,bOverride_ColorCorrectionHighlightsMax=False,bOverride_BlueCorrection=False,bOverride_ExpandGamut=False,bOverride_ToneCurveAmount=False,bOverride_FilmSlope=False,bOverride_FilmToe=False,bOverride_FilmShoulder=False,bOverride_FilmBlackClip=False,bOverride_FilmWhiteClip=False,bOverride_SceneColorTint=False,bOverride_SceneFringeIntensity=False,bOverride_ChromaticAberrationStartOffset=False,bOverride_bMegaLights=False,bOverride_AmbientCubemapTint=False,bOverride_AmbientCubemapIntensity=False,bOverride_BloomMethod=False,bOverride_BloomIntensity=False,bOverride_BloomThreshold=False,bOverride_Bloom1Tint=False,bOverride_Bloom1Size=False,bOverride_Bloom2Size=False,bOverride_Bloom2Tint=False,bOverride_Bloom3Tint=False,bOverride_Bloom3Size=False,bOverride_Bloom4Tint=False,bOverride_Bloom4Size=False,bOverride_Bloom5Tint=False,bOverride_Bloom5Size=False,bOverride_Bloom6Tint=False,bOverride_Bloom6Size=False,bOverride_BloomSizeScale=False,bOverride_BloomConvolutionTexture=False,bOverride_BloomConvolutionScatterDispersion=False,bOverride_BloomConvolutionSize=False,bOverride_BloomConvolutionCenterUV=False,bOverride_BloomConvolutionPreFilterMin=False,bOverride_BloomConvolutionPreFilterMax=False,bOverride_BloomConvolutionPreFilterMult=False,bOverride_BloomConvolutionBufferScale=False,bOverride_BloomDirtMaskIntensity=False,bOverride_BloomDirtMaskTint=False,bOverride_BloomDirtMask=False,bOverride_CameraShutterSpeed=False,bOverride_CameraISO=False,bOverride_AutoExposureMethod=False,bOverride_AutoExposureLowPercent=False,bOverride_AutoExposureHighPercent=False,bOverride_AutoExposureMinBrightness=False,bOverride_AutoExposureMaxBrightness=False,bOverride_AutoExposureSpeedUp=False,bOverride_AutoExposureSpeedDown=False,bOverride_AutoExposureBias=False,bOverride_AutoExposureBiasCurve=False,bOverride_AutoExposureMeterMask=False,bOverride_AutoExposureApplyPhysicalCameraExposure=False,bOverride_HistogramLogMin=False,bOverride_HistogramLogMax=False,bOverride_LocalExposureMethod=False,bOverride_LocalExposureHighlightContrastScale=False,bOverride_LocalExposureShadowContrastScale=False,bOverride_LocalExposureHighlightContrastCurve=False,bOverride_LocalExposureShadowContrastCurve=False,bOverride_LocalExposureHighlightThreshold=False,bOverride_LocalExposureShadowThreshold=False,bOverride_LocalExposureDetailStrength=False,bOverride_LocalExposureBlurredLuminanceBlend=False,bOverride_LocalExposureBlurredLuminanceKernelSizePercent=False,bOverride_LocalExposureHighlightThresholdStrength=False,bOverride_LocalExposureShadowThresholdStrength=False,bOverride_LocalExposureMiddleGreyBias=False,bOverride_LensFlareIntensity=False,bOverride_LensFlareTint=False,bOverride_LensFlareTints=False,bOverride_LensFlareBokehSize=False,bOverride_LensFlareBokehShape=False,bOverride_LensFlareThreshold=False,bOverride_VignetteIntensity=False,bOverride_Sharpen=False,bOverride_FilmGrainIntensity=False,bOverride_FilmGrainIntensityShadows=False,bOverride_FilmGrainIntensityMidtones=False,bOverride_FilmGrainIntensityHighlights=False,bOverride_FilmGrainShadowsMax=False,bOverride_FilmGrainHighlightsMin=False,bOverride_FilmGrainHighlightsMax=False,bOverride_FilmGrainTexelSize=False,bOverride_FilmGrainTexture=False,bOverride_AmbientOcclusionIntensity=False,bOverride_AmbientOcclusionStaticFraction=False,bOverride_AmbientOcclusionRadius=False,bOverride_AmbientOcclusionFadeDistance=False,bOverride_AmbientOcclusionFadeRadius=False,bOverride_AmbientOcclusionRadiusInWS=False,bOverride_AmbientOcclusionPower=False,bOverride_AmbientOcclusionBias=False,bOverride_AmbientOcclusionQuality=False,bOverride_AmbientOcclusionMipBlend=False,bOverride_AmbientOcclusionMipScale=False,bOverride_AmbientOcclusionMipThreshold=False,bOverride_AmbientOcclusionTemporalBlendWeight=False,bOverride_RayTracingAO=False,bOverride_RayTracingAOSamplesPerPixel=False,bOverride_RayTracingAOIntensity=False,bOverride_RayTracingAORadius=False,bOverride_IndirectLightingColor=False,bOverride_IndirectLightingIntensity=False,bOverride_ColorGradingIntensity=False,bOverride_ColorGradingLUT=False,bOverride_DepthOfFieldFocalDistance=False,bOverride_DepthOfFieldFstop=False,bOverride_DepthOfFieldMinFstop=False,bOverride_DepthOfFieldBladeCount=False,bOverride_DepthOfFieldSensorWidth=False,bOverride_DepthOfFieldSqueezeFactor=False,bOverride_DepthOfFieldDepthBlurRadius=False,bOverride_DepthOfFieldUseHairDepth=False,bOverride_DepthOfFieldPetzvalBokeh=False,bOverride_DepthOfFieldPetzvalBokehFalloff=False,bOverride_DepthOfFieldPetzvalExclusionBoxExtents=False,bOverride_DepthOfFieldPetzvalExclusionBoxRadius=False,bOverride_DepthOfFieldAspectRatioScalar=False,bOverride_DepthOfFieldMatteBoxFlags=False,bOverride_DepthOfFieldBarrelRadius=False,bOverride_DepthOfFieldBarrelLength=False,bOverride_DepthOfFieldDepthBlurAmount=False,bOverride_DepthOfFieldFocalRegion=False,bOverride_DepthOfFieldNearTransitionRegion=False,bOverride_DepthOfFieldFarTransitionRegion=False,bOverride_DepthOfFieldScale=False,bOverride_DepthOfFieldNearBlurSize=False,bOverride_DepthOfFieldFarBlurSize=False,bOverride_MobileHQGaussian=False,bOverride_DepthOfFieldOcclusion=False,bOverride_DepthOfFieldSkyFocusDistance=False,bOverride_DepthOfFieldVignetteSize=False,bOverride_MotionBlurAmount=False,bOverride_MotionBlurMax=False,bOverride_MotionBlurTargetFPS=False,bOverride_MotionBlurPerObjectSize=False,bOverride_ReflectionMethod=False,bOverride_LumenReflectionQuality=False,bOverride_ScreenSpaceReflectionIntensity=False,bOverride_ScreenSpaceReflectionQuality=False,bOverride_ScreenSpaceReflectionMaxRoughness=False,bOverride_ScreenSpaceReflectionRoughnessScale=False,bOverride_UserFlags=False,bOverride_RayTracingReflectionsMaxRoughness=False,bOverride_RayTracingReflectionsMaxBounces=False,bOverride_RayTracingReflectionsSamplesPerPixel=False,bOverride_RayTracingReflectionsShadows=False,bOverride_RayTracingReflectionsTranslucency=False,bOverride_TranslucencyType=False,bOverride_RayTracingTranslucencyMaxRoughness=False,bOverride_RayTracingTranslucencyRefractionRays=False,bOverride_RayTracingTranslucencySamplesPerPixel=False,bOverride_RayTracingTranslucencyShadows=False,bOverride_RayTracingTranslucencyRefraction=False,bOverride_RayTracingTranslucencyMaxPrimaryHitEvents=False,bOverride_RayTracingTranslucencyMaxSecondaryHitEvents=False,bOverride_RayTracingTranslucencyUseRayTracedRefraction=False,bOverride_DynamicGlobalIlluminationMethod=False,bOverride_LumenSceneLightingQuality=False,bOverride_LumenSceneDetail=False,bOverride_LumenSceneViewDistance=False,bOverride_LumenSceneLightingUpdateSpeed=False,bOverride_LumenFinalGatherQuality=False,bOverride_LumenFinalGatherLightingUpdateSpeed=False,bOverride_LumenFinalGatherScreenTraces=False,bOverride_LumenMaxTraceDistance=False,bOverride_LumenDiffuseColorBoost=False,bOverride_LumenSkylightLeaking=False,bOverride_LumenSkylightLeakingTint=False,bOverride_LumenFullSkylightLeakingDistance=False,bOverride_LumenRayLightingMode=False,bOverride_LumenReflectionsScreenTraces=False,bOverride_LumenFrontLayerTranslucencyReflections=False,bOverride_LumenMaxRoughnessToTraceReflections=False,bOverride_LumenMaxReflectionBounces=False,bOverride_LumenMaxRefractionBounces=False,bOverride_LumenSurfaceCacheResolution=False,bOverride_RayTracingGI=False,bOverride_RayTracingGIMaxBounces=False,bOverride_RayTracingGISamplesPerPixel=False,bOverride_PathTracingMaxBounces=False,bOverride_PathTracingSamplesPerPixel=False,bOverride_PathTracingMaxPathIntensity=False,bOverride_PathTracingEnableEmissiveMaterials=False,bOverride_PathTracingEnableReferenceDOF=False,bOverride_PathTracingEnableReferenceAtmosphere=False,bOverride_PathTracingEnableDenoiser=False,bOverride_PathTracingIncludeEmissive=False,bOverride_PathTracingIncludeDiffuse=False,bOverride_PathTracingIncludeIndirectDiffuse=False,bOverride_PathTracingIncludeSpecular=False,bOverride_PathTracingIncludeIndirectSpecular=False,bOverride_PathTracingIncludeVolume=False,bOverride_PathTracingIncludeIndirectVolume=False,bMobileHQGaussian=False,BloomMethod=BM_SOG,AutoExposureMethod=AEM_Histogram,TemperatureType=TEMP_WhiteBalance,WhiteTemp=6500.000000,WhiteTint=0.000000,ColorSaturation=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrast=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGamma=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGain=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffset=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainShadows=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetShadows=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainMidtones=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetMidtones=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorSaturationHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorContrastHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGammaHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorGainHighlights=(X=1.000000,Y=1.000000,Z=1.000000,W=1.000000),ColorOffsetHighlights=(X=0.000000,Y=0.000000,Z=0.000000,W=0.000000),ColorCorrectionHighlightsMin=0.500000,ColorCorrectionHighlightsMax=1.000000,ColorCorrectionShadowsMax=0.090000,BlueCorrection=0.600000,ExpandGamut=1.000000,ToneCurveAmount=1.000000,FilmSlope=0.880000,FilmToe=0.550000,FilmShoulder=0.260000,FilmBlackClip=0.000000,FilmWhiteClip=0.040000,SceneColorTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),SceneFringeIntensity=0.000000,ChromaticAberrationStartOffset=0.000000,BloomIntensity=0.675000,BloomThreshold=-1.000000,BloomSizeScale=4.000000,Bloom1Size=0.300000,Bloom2Size=1.000000,Bloom3Size=2.000000,Bloom4Size=10.000000,Bloom5Size=30.000000,Bloom6Size=64.000000,Bloom1Tint=(R=0.346500,G=0.346500,B=0.346500,A=1.000000),Bloom2Tint=(R=0.138000,G=0.138000,B=0.138000,A=1.000000),Bloom3Tint=(R=0.117600,G=0.117600,B=0.117600,A=1.000000),Bloom4Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom5Tint=(R=0.066000,G=0.066000,B=0.066000,A=1.000000),Bloom6Tint=(R=0.061000,G=0.061000,B=0.061000,A=1.000000),BloomConvolutionScatterDispersion=1.000000,BloomConvolutionSize=1.000000,BloomConvolutionTexture=None,BloomConvolutionCenterUV=(X=0.500000,Y=0.500000),BloomConvolutionPreFilterMin=7.000000,BloomConvolutionPreFilterMax=15000.000000,BloomConvolutionPreFilterMult=15.000000,BloomConvolutionBufferScale=0.133000,BloomDirtMask=None,BloomDirtMaskIntensity=0.000000,BloomDirtMaskTint=(R=0.500000,G=0.500000,B=0.500000,A=1.000000),DynamicGlobalIlluminationMethod=Lumen,IndirectLightingColor=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),IndirectLightingIntensity=1.000000,LumenRayLightingMode=Default,LumenSceneLightingQuality=1.000000,LumenSceneDetail=1.000000,LumenSceneViewDistance=20000.000000,LumenSceneLightingUpdateSpeed=1.000000,LumenFinalGatherQuality=1.000000,LumenFinalGatherLightingUpdateSpeed=1.000000,LumenFinalGatherScreenTraces=True,LumenMaxTraceDistance=20000.000000,LumenDiffuseColorBoost=1.000000,LumenSkylightLeaking=0.000000,LumenSkylightLeakingTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LumenFullSkylightLeakingDistance=1000.000000,LumenSurfaceCacheResolution=1.000000,ReflectionMethod=Lumen,LumenReflectionQuality=1.000000,LumenReflectionsScreenTraces=True,LumenFrontLayerTranslucencyReflections=False,LumenMaxRoughnessToTraceReflections=0.400000,LumenMaxReflectionBounces=1,LumenMaxRefractionBounces=0,ScreenSpaceReflectionIntensity=100.000000,ScreenSpaceReflectionQuality=50.000000,ScreenSpaceReflectionMaxRoughness=0.600000,bMegaLights=True,AmbientCubemapTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),AmbientCubemapIntensity=1.000000,AmbientCubemap=None,CameraShutterSpeed=60.000000,CameraISO=100.000000,DepthOfFieldFstop=4.000000,DepthOfFieldMinFstop=1.200000,DepthOfFieldBladeCount=5,AutoExposureBias=1.000000,AutoExposureBiasBackup=0.000000,bOverride_AutoExposureBiasBackup=False,AutoExposureApplyPhysicalCameraExposure=True,AutoExposureBiasCurve=None,AutoExposureMeterMask=None,AutoExposureLowPercent=10.000000,AutoExposureHighPercent=90.000000,AutoExposureMinBrightness=-10.000000,AutoExposureMaxBrightness=20.000000,AutoExposureSpeedUp=3.000000,AutoExposureSpeedDown=1.000000,HistogramLogMin=-10.000000,HistogramLogMax=20.000000,LocalExposureMethod=Bilateral,LocalExposureHighlightContrastScale=1.000000,LocalExposureShadowContrastScale=1.000000,LocalExposureHighlightContrastCurve=None,LocalExposureShadowContrastCurve=None,LocalExposureHighlightThreshold=0.000000,LocalExposureShadowThreshold=0.000000,LocalExposureDetailStrength=1.000000,LocalExposureBlurredLuminanceBlend=0.600000,LocalExposureBlurredLuminanceKernelSizePercent=50.000000,LocalExposureHighlightThresholdStrength=1.000000,LocalExposureShadowThresholdStrength=1.000000,LocalExposureMiddleGreyBias=0.000000,LensFlareIntensity=1.000000,LensFlareTint=(R=1.000000,G=1.000000,B=1.000000,A=1.000000),LensFlareBokehSize=3.000000,LensFlareThreshold=8.000000,LensFlareBokehShape=None,LensFlareTints[0]=(R=1.000000,G=0.800000,B=0.400000,A=0.600000),LensFlareTints[1]=(R=1.000000,G=1.000000,B=0.600000,A=0.530000),LensFlareTints[2]=(R=0.800000,G=0.800000,B=1.000000,A=0.460000),LensFlareTints[3]=(R=0.500000,G=1.000000,B=0.400000,A=0.390000),LensFlareTints[4]=(R=0.500000,G=0.800000,B=1.000000,A=0.310000),LensFlareTints[5]=(R=0.900000,G=1.000000,B=0.800000,A=0.270000),LensFlareTints[6]=(R=1.000000,G=0.800000,B=0.400000,A=0.220000),LensFlareTints[7]=(R=0.900000,G=0.700000,B=0.700000,A=0.150000),VignetteIntensity=0.400000,Sharpen=0.000000,FilmGrainIntensity=0.000000,FilmGrainIntensityShadows=1.000000,FilmGrainIntensityMidtones=1.000000,FilmGrainIntensityHighlights=1.000000,FilmGrainShadowsMax=0.090000,FilmGrainHighlightsMin=0.500000,FilmGrainHighlightsMax=1.000000,FilmGrainTexelSize=1.000000,FilmGrainTexture=None,AmbientOcclusionIntensity=0.500000,AmbientOcclusionStaticFraction=1.000000,AmbientOcclusionRadius=200.000000,AmbientOcclusionRadiusInWS=False,AmbientOcclusionFadeDistance=8000.000000,AmbientOcclusionFadeRadius=5000.000000,AmbientOcclusionPower=2.000000,AmbientOcclusionBias=3.000000,AmbientOcclusionQuality=50.000000,AmbientOcclusionMipBlend=0.600000,AmbientOcclusionMipScale=1.700000,AmbientOcclusionMipThreshold=0.010000,AmbientOcclusionTemporalBlendWeight=0.100000,RayTracingAO=False,RayTracingAOSamplesPerPixel=1,RayTracingAOIntensity=1.000000,RayTracingAORadius=200.000000,ColorGradingIntensity=1.000000,ColorGradingLUT=None,DepthOfFieldSensorWidth=24.576000,DepthOfFieldSqueezeFactor=1.000000,DepthOfFieldFocalDistance=0.000000,DepthOfFieldDepthBlurAmount=1.000000,DepthOfFieldDepthBlurRadius=0.000000,DepthOfFieldUseHairDepth=False,DepthOfFieldPetzvalBokeh=0.000000,DepthOfFieldPetzvalBokehFalloff=1.000000,DepthOfFieldPetzvalExclusionBoxExtents=(X=0.000000,Y=0.000000),DepthOfFieldPetzvalExclusionBoxRadius=0.000000,DepthOfFieldAspectRatioScalar=1.000000,DepthOfFieldBarrelRadius=5.000000,DepthOfFieldBarrelLength=0.000000,DepthOfFieldMatteBoxFlags[0]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[1]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldMatteBoxFlags[2]=(Pitch=0.000000,Roll=0.000000,Length=0.000000),DepthOfFieldFocalRegion=0.000000,DepthOfFieldNearTransitionRegion=300.000000,DepthOfFieldFarTransitionRegion=500.000000,DepthOfFieldScale=0.000000,DepthOfFieldNearBlurSize=15.000000,DepthOfFieldFarBlurSize=15.000000,DepthOfFieldOcclusion=0.400000,DepthOfFieldSkyFocusDistance=0.000000,DepthOfFieldVignetteSize=200.000000,MotionBlurAmount=0.500000,MotionBlurMax=5.000000,MotionBlurTargetFPS=30,MotionBlurPerObjectSize=0.000000,TranslucencyType=Raster,RayTracingTranslucencyMaxRoughness=0.600000,RayTracingTranslucencyRefractionRays=3,RayTracingTranslucencySamplesPerPixel=1,RayTracingTranslucencyMaxPrimaryHitEvents=4,RayTracingTranslucencyMaxSecondaryHitEvents=2,RayTracingTranslucencyShadows=Hard_shadows,RayTracingTranslucencyRefraction=True,RayTracingTranslucencyUseRayTracedRefraction=False,PathTracingMaxBounces=32,PathTracingSamplesPerPixel=2048,PathTracingMaxPathIntensity=24.000000,PathTracingEnableEmissiveMaterials=True,PathTracingEnableReferenceDOF=False,PathTracingEnableReferenceAtmosphere=False,PathTracingEnableDenoiser=True,PathTracingIncludeEmissive=True,PathTracingIncludeDiffuse=True,PathTracingIncludeIndirectDiffuse=True,PathTracingIncludeSpecular=True,PathTracingIncludeIndirectSpecular=True,PathTracingIncludeVolume=True,PathTracingIncludeIndirectVolume=True,UserFlags=0,WeightedBlendables=(Array=)),LightingRigRotation=0.000000,RotationSpeed=2.000000,DirectionalLightRotation=(Pitch=-40.000000,Yaw=-67.500000,Roll=0.000000),bEnableToneMapping=False,bShowMeshEdges=False)


```

`Config/DefaultEditorPerProjectUserSettings.ini`:

```ini
[/Script/ActionRoguelike.RogueDeveloperSettings]
game.DisableBotSpawning=True


```

`Config/DefaultEngine.ini`:

```ini


[/Script/Engine.RendererSettings]
r.DefaultFeature.AutoExposure.ExtendDefaultLuminanceRange=True
r.ReflectionMethod=1
r.GenerateMeshDistanceFields=True
r.DynamicGlobalIlluminationMethod=1
r.Shadow.Virtual.Enable=1
r.AntiAliasingMethod=2
r.ToneMapper.Sharpen=1
; disabled some shader permutations
r.SupportLowQualityLightmaps=False
r.AllowStaticLighting=False
; PSO Caching CVARs
r.PSOPrecaching=1
r.PSOPrecache.ProxyCreationWhenPSOReady=1
; keep this active for validation with 'stat psocache', Insights AND required for r.ShaderPipelineCache.ExcludePrecachePSO
r.PSOPrecache.Validation=2
; settings below for old bundled PSO steps to combine with PSO Precache
r.ShaderPipelineCache.ExcludePrecachePSO=1
; required for bundled PSO gathering
r.ShaderPipelineCache.Enabled=1
; start up background mode so we can run hitchless in a main menu
r.ShaderPipelineCache.StartupMode=2
r.VRS.Enable=1
r.VRS.EnableSoftware=1
r.VRS.ContrastAdaptiveShading=1

[ConsoleVariables]
Slate.EnableGlobalInvalidation=1
tick.AllowBatchedTicks=1
a.Budget.Enabled=1 ; Animation budgeter plugin

[SystemSettings]
net.Iris.UseIrisReplication=1
net.SubObjects.DefaultUseSubObjectReplicationList=1
;Net.IsPushModelEnabled=1 ; this should be on once ready to move to full push model

[DevOptions.Shaders]
NeedsShaderStableKeys=true

[/Script/Engine.Engine]
GameViewportClientClassName=/Script/ActionRoguelike.SGameViewportClient

[/Script/SignificanceManager.SignificanceManager]
SignificanceManagerClassName=/Script/ActionRoguelike.RogueSignificanceManager

[/Script/Engine.SkeletalMeshComponent]
VisibilityBasedAnimTickOption=OnlyTickPoseWhenRendered ; Set new default to do as little as possible, instead we opt-in when needed per skeletal mesh

[/Script/HardwareTargeting.HardwareTargetingSettings]
TargetedHardwareClass=Desktop
AppliedTargetedHardwareClass=Desktop
DefaultGraphicsPerformance=Maximum
AppliedDefaultGraphicsPerformance=Maximum

; STEAM CONFIG START

[/Script/Engine.GameEngine]
+NetDriverDefinitions=(DefName="GameNetDriver",DriverClassName="/Script/OnlineSubsystemSteam.SteamNetDriver",DriverClassNameFallback="/Script/OnlineSubsystemUtils.IpNetDriver")

[OnlineSubsystem]
DefaultPlatformService=Steam

[OnlineSubsystemSteam]
bEnabled=true
SteamDevAppId=480 ; default app id for testing apps (can change to your own AppID if you have one)
;SteamAppId=480 ; this must be changed to your own ID for shipping builds eventually

; STEAM CONFIG END

[/Script/Engine.CollisionProfile]
-Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision",bCanModify=False)
-Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ",bCanModify=False)
-Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ",bCanModify=False)
-Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic",Response=ECR_Block),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.",bCanModify=False)
-Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors",bCanModify=False)
-Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors",bCanModify=False)
-Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.",bCanModify=False)
-Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.",bCanModify=False)
-Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="UI",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Block),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
+Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision")
+Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.")
+Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ")
+Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ")
+Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic"),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.")
+Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.")
+Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors")
+Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors")
+Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.")
+Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.")
+Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.")
+Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.")
+Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.")
+Profiles=(Name="UI",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility"),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="Projectile",CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName="Projectile",CustomResponses=((Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="Projectile",Response=ECR_Ignore)),HelpMessage="Needs description")
+Profiles=(Name="Powerup",CollisionEnabled=QueryOnly,bCanModify=True,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore),(Channel="Projectile",Response=ECR_Ignore),(Channel="Interact",Response=ECR_Overlap)),HelpMessage="Needs description")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel1,DefaultResponse=ECR_Overlap,bTraceType=False,bStaticObject=False,Name="Projectile")
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel2,DefaultResponse=ECR_Ignore,bTraceType=True,bStaticObject=False,Name="Interact")
+EditProfiles=(Name="Pawn",CustomResponses=((Channel="Projectile",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)))
+EditProfiles=(Name="BlockAll",CustomResponses=((Channel="Projectile")))
+EditProfiles=(Name="BlockAllDynamic",CustomResponses=((Channel="Projectile"),(Channel="Interact",Response=ECR_Overlap)))
+EditProfiles=(Name="CharacterMesh",CustomResponses=((Channel="Camera",Response=ECR_Ignore)))
+EditProfiles=(Name="PhysicsActor",CustomResponses=((Channel="Projectile",Response=ECR_Overlap)))
+EditProfiles=(Name="Trigger",CustomResponses=((Channel="Projectile",Response=ECR_Ignore)))
-ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
-ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
-ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
-ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
-ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
+ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
+ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
+ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
+ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
+ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
-CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
-CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
-CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
-CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
+CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
+CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
+CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
+CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")

[/Script/EngineSettings.GameMapsSettings]
GlobalDefaultGameMode=/Game/ActionRoguelike/GameModeBP.GameModeBP_C
GameDefaultMap=/Game/ActionRoguelike/Maps/MainMenu_Entry.MainMenu_Entry
EditorStartupMap=/Game/ActionRoguelike/Maps/TestLevel.TestLevel
; Example of alias for (blueprint) gamemode to use more easily on command line MyLevel?game=MyAlias
; Can define additional GameModes aliases for debugging or benchmarking
+GameModeClassAliases=(Name="Roguelike",GameMode="/Game/ActionRoguelike/GameModeBP.GameModeBP_C")

[/Script/WindowsTargetPlatform.WindowsTargetSettings]
DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
-D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM6
-D3D11TargetedShaderFormats=PCD3D_SM5
+D3D11TargetedShaderFormats=PCD3D_SM5
Compiler=Default
AudioSampleRate=48000
AudioCallbackBufferFrameSize=1024
AudioNumBuffersToEnqueue=1
AudioMaxChannels=0
AudioNumSourceWorkers=4
SpatializationPlugin=
SourceDataOverridePlugin=
ReverbPlugin=
OcclusionPlugin=
CompressionOverrides=(bOverrideCompressionTimes=False,DurationThreshold=5.000000,MaxNumRandomBranches=0,SoundCueQualityIndex=0)
CacheSizeKB=65536
MaxChunkSizeOverrideKB=0
bResampleForDevice=False
MaxSampleRate=48000.000000
HighSampleRate=32000.000000
MedSampleRate=24000.000000
LowSampleRate=12000.000000
MinSampleRate=8000.000000
CompressionQualityModifier=1.000000
AutoStreamingThreshold=0.000000
SoundCueCookQualityIndex=-1


[CoreRedirects]
+ClassRedirects=(OldName="/Script/ActionRoguelike.SSaveGameSettings",NewName="/Script/ActionRoguelike.RogueSaveGameSettings")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SAction",NewName="/Script/ActionRoguelike.RogueAction")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SAction_ProjectileAttack",NewName="/Script/ActionRoguelike.RogueAction_ProjectileAttack")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SActionComponent",NewName="/Script/ActionRoguelike.RogueActionComponent")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SActionEffect",NewName="/Script/ActionRoguelike.RogueActionEffect")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SActionEffect_Thorns",NewName="/Script/ActionRoguelike.RogueActionEffect_Thorns")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SAttributeComponent",NewName="/Script/ActionRoguelike.RogueAttributeComponent")
+ClassRedirects=(OldName="/Script/ActionRoguelike.BTService_StartAction",NewName="/Script/ActionRoguelike.RogueBTService_StartAction")
+ClassRedirects=(OldName="/Script/ActionRoguelike.BTTask_StartAction",NewName="/Script/ActionRoguelike.RogueBTTask_StartAction")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SAction_MinionRangedAttack",NewName="/Script/ActionRoguelike.RogueAction_MinionRangedAttack")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SAICharacter",NewName="/Script/ActionRoguelike.RogueAICharacter")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SAIController",NewName="/Script/ActionRoguelike.RogueAIController")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SBTService_CheckAttackRange",NewName="/Script/ActionRoguelike.RogueBTService_CheckAttackRange")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SBTService_CheckHealth",NewName="/Script/ActionRoguelike.RogueBTService_CheckHealth")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SBTTask_HealSelf",NewName="/Script/ActionRoguelike.RogueBTTask_HealSelf")
+ClassRedirects=(OldName="/Script/ActionRoguelike.DEPRECATED_USBTTask_RangedAttack",NewName="/Script/ActionRoguelike.DEPRECATED_URogueBTTask_RangedAttack")
+ClassRedirects=(OldName="/Script/ActionRoguelike.RogueTweenSubsystem",NewName="/Script/ActionRoguelike.RogueCurveAnimSubsystem")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SAnimInstance",NewName="/Script/ActionRoguelike.RogueAnimInstance")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SGameModeBase",NewName="/Script/ActionRoguelike.RogueGameModeBase")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SGameplayFunctionLibrary",NewName="/Script/ActionRoguelike.RogueGameplayFunctionLibrary")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SGameViewportClient",NewName="/Script/ActionRoguelike.RogueGameViewportClient")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SLoadingScreenSubsystem",NewName="/Script/ActionRoguelike.RogueLoadingScreenSubsystem")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SMonsterData",NewName="/Script/ActionRoguelike.RogueMonsterData")
+ClassRedirects=(OldName="/Script/ActionRoguelike.RoguelikeDeveloperSettings",NewName="/Script/ActionRoguelike.RogueDeveloperSettings")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SActorPoolingSubsystem",NewName="/Script/ActionRoguelike.RogueActorPoolingSubsystem")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SSignificanceComponent",NewName="/Script/ActionRoguelike.RogueSignificanceComponent")
+ClassRedirects=(OldName="/Script/ActionRoguelike.STickablesSubsystem",NewName="/Script/ActionRoguelike.RogueTickablesSubsystem")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SPowerup_Action",NewName="/Script/ActionRoguelike.RoguePickupActor_GrantAction")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SPowerupActor",NewName="/Script/ActionRoguelike.RoguePickupActor")
+ClassRedirects=(OldName="/Script/ActionRoguelike.RoguePickup_GrantAction",NewName="/Script/ActionRoguelike.RoguePickupActor_GrantAction")
+ClassRedirects=(OldName="/Script/ActionRoguelike.PickupActor",NewName="/Script/ActionRoguelike.RoguePickupActor")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SPowerup_Credits",NewName="/Script/ActionRoguelike.RoguePickupActor_Credits")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SPowerup_HealthPotion",NewName="/Script/ActionRoguelike.RoguePickupActor_HealthPotion")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SCharacter",NewName="/Script/ActionRoguelike.RoguePlayerCharacter")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SInteractionComponent",NewName="/Script/ActionRoguelike.RogueInteractionComponent")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SPlayerController",NewName="/Script/ActionRoguelike.RoguePlayerController")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SPlayerState",NewName="/Script/ActionRoguelike.RoguePlayerState")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SDashProjectile",NewName="/Script/ActionRoguelike.RogueProjectile_Dash")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SMagicProjectile",NewName="/Script/ActionRoguelike.RogueProjectile_Magic")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SProjectileBase",NewName="/Script/ActionRoguelike.RogueProjectile")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SProjectileMovementComponent",NewName="/Script/ActionRoguelike.RogueProjectileMovementComponent")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SSaveGame",NewName="/Script/ActionRoguelike.RogueSaveGame")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SSaveGameSubsystem",NewName="/Script/ActionRoguelike.RogueSaveGameSubsystem")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SWorldUserWidget",NewName="/Script/ActionRoguelike.RogueWorldUserWidget")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SExplosiveBarrel",NewName="/Script/ActionRoguelike.RogueExplosiveBarrel")
+ClassRedirects=(OldName="/Script/ActionRoguelike.SItemChest",NewName="/Script/ActionRoguelike.RogueTreasureChest")
+ClassRedirects=(OldName="/Script/ActionRoguelike.STargetDummy",NewName="/Script/ActionRoguelike.RogueTargetDummy")
+ClassRedirects=(OldName="/Script/ActionRoguelike.RogueDashProjectile",NewName="/Script/ActionRoguelike.RogueProjectile_Dash")
+ClassRedirects=(OldName="/Script/ActionRoguelike.RogueMagicProjectile",NewName="/Script/ActionRoguelike.RogueProjectile_Magic")
+ClassRedirects=(OldName="/Script/ActionRoguelike.RogueProjectileBase",NewName="/Script/ActionRoguelike.RogueProjectile")
+EnumRedirects=(OldName="/Script/ActionRoguelike.EAttributeModifyType",ValueChanges=(("AddDelta","AddModifier")))
+PropertyRedirects=(OldName="/Script/ActionRoguelike.RogueAttribute.Delta",NewName="/Script/ActionRoguelike.RogueAttribute.Modifier")


```

`Config/DefaultGame.ini`:

```ini
[/Script/EngineSettings.GeneralProjectSettings]
ProjectID=CB72F7474F73259935E082BE9F8C1595
Description=Professional Game Development in C++ and Unreal Engine
ProjectName=Action Roguelike
CompanyName=Tom Looman
CompanyDistinguishedName=Tom Looman
Homepage="https://tomlooman.com"

[/Script/Engine.AssetManagerSettings]
-PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass=/Script/Engine.World,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/Maps")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
-PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass=/Script/Engine.PrimaryAssetLabel,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
+PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass="/Script/Engine.World",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/Maps")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
+PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass="/Script/Engine.PrimaryAssetLabel",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
+PrimaryAssetTypesToScan=(PrimaryAssetType="Monsters",AssetBaseClass="/Script/ActionRoguelike.SMonsterData",bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="/Game/ActionRoguelike/Monsters")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=AlwaysCook))
bOnlyCookProductionAssets=False
bShouldManagerDetermineTypeAndName=False
bShouldGuessTypeAndNameInEditor=True
bShouldAcquireMissingChunksOnLoad=False
bShouldWarnAboutInvalidAssets=True
MetaDataTagsForAssetRegistry=()

[/Script/UnrealEd.ProjectPackagingSettings]
Build=IfProjectHasCode
BuildConfiguration=PPBC_Development
BuildTarget=
StagingDirectory=(Path="")
FullRebuild=False
ForDistribution=False
IncludeDebugFiles=False
BlueprintNativizationMethod=Disabled
bIncludeNativizedAssetsInProjectGeneration=False
bExcludeMonolithicEngineHeadersInNativizedCode=False
UsePakFile=True
bUseIoStore=True
bGenerateChunks=False
bGenerateNoChunks=False
bChunkHardReferencesOnly=False
bForceOneChunkPerFile=False
MaxChunkSize=0
bBuildHttpChunkInstallData=False
HttpChunkInstallDataDirectory=(Path="")
PakFileCompressionFormats=Oodle
PakFileAdditionalCompressionOptions=
HttpChunkInstallDataVersion=
IncludePrerequisites=False
IncludeAppLocalPrerequisites=False
bShareMaterialShaderCode=True
bSharedMaterialNativeLibraries=True
ApplocalPrerequisitesDirectory=(Path="")
IncludeCrashReporter=False
InternationalizationPreset=English
+CulturesToStage=en
LocalizationTargetCatchAllChunkId=0
bCookAll=False
bCookMapsOnly=False
bCompressed=True
bSkipEditorContent=False
bSkipMovies=False
+IniKeyDenylist=KeyStorePassword
+IniKeyDenylist=KeyPassword
+IniKeyDenylist=rsa.privateexp
+IniKeyDenylist=rsa.modulus
+IniKeyDenylist=rsa.publicexp
+IniKeyDenylist=aes.key
+IniKeyDenylist=SigningPublicExponent
+IniKeyDenylist=SigningModulus
+IniKeyDenylist=SigningPrivateExponent
+IniKeyDenylist=EncryptionKey
+IniKeyDenylist=IniKeyDenylist
+IniKeyDenylist=IniSectionDenylist
+MapsToCook=(FilePath="/Game/ActionRoguelike/Maps/MainMenu_Entry")
+MapsToCook=(FilePath="/Game/ActionRoguelike/Maps/TestLevel")
PakFileCompressionMethod=Kraken
PakFileCompressionLevel_DebugDevelopment=3

[/Script/ActionRoguelike.RogueSaveGameSettings]
SaveSlotName=SaveSlot04
DummyTablePath=/Game/ActionRoguelike/Monsters/DT_Monsters.DT_Monsters

[/Script/ActionRoguelike.RogueSignificanceSettings]
Buckets=(("AICharacter", (BucketSizes=(2,2,2))))

[/Script/ActionRoguelike.RogueDeveloperSettings]
PickupCoinMesh=/Game/ExampleContent/Meshes/SM_Pickup_Coin.SM_Pickup_Coin
PickupCoinSound=/Game/SanderAudio/Sources/Interactables/MSS_Interactables_CurrencyPickup.MSS_Interactables_CurrencyPickup


```

`Config/DefaultGameplayTags.ini`:

```ini
;METADATA=(Diff=true, UseCommands=true)
[/Script/GameplayTags.GameplayTagsSettings]
ImportTagsFromConfig=True
WarnOnInvalidTags=True
ClearInvalidTags=False
AllowEditorTagUnloading=True
AllowGameTagUnloading=False
FastReplication=False
bDynamicReplication=False
InvalidTagCharacters="\"\',"
NumBitsForContainerSize=6
NetIndexFirstBitSegment=16
+GameplayTagRedirects=(OldTagName="Action.Attacking",NewTagName="Status.Attacking")
+GameplayTagRedirects=(OldTagName="Action.Sprinting",NewTagName="Status.Sprinting")
+GameplayTagList=(Tag="Action.Parry",DevComment="")
+GameplayTagList=(Tag="Attribute.MoveSpeed",DevComment="")
+GameplayTagList=(Tag="KeyCard.Blue",DevComment="")
+GameplayTagList=(Tag="KeyCard.Red",DevComment="")
+GameplayTagList=(Tag="KeyCard.Yellow",DevComment="")
+GameplayTagList=(Tag="Status.Attacking",DevComment="")
+GameplayTagList=(Tag="Status.Burning",DevComment="")
+GameplayTagList=(Tag="Status.Parrying",DevComment="")
+GameplayTagList=(Tag="Status.Sprinting",DevComment="")
+GameplayTagList=(Tag="Status.Stunned",DevComment="")


```

`Config/DefaultInput.ini`:

```ini
[/Script/Engine.InputSettings]
-AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Daydream_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Daydream_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Daydream_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Daydream_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusGo_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusGo_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusGo_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusGo_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Touch",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
bAltEnterTogglesFullscreen=True
bF11TogglesFullscreen=True
bUseMouseForTouch=False
bEnableMouseSmoothing=True
bEnableFOVScaling=True
bCaptureMouseOnLaunch=True
bEnableLegacyInputScales=True
bEnableMotionControls=True
bFilterInputByPlatformUser=False
bEnableInputDeviceSubsystem=True
bShouldFlushPressedKeysOnViewportFocusLost=True
bEnableDynamicComponentInputBinding=True
bAlwaysShowTouchInterface=False
bShowConsoleOnFourFingerTap=True
bEnableGestureRecognizer=False
bUseAutocorrect=False
DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
DefaultViewportMouseLockMode=LockOnCapture
FOVScale=0.011110
DoubleClickTime=0.200000
+ActionMappings=(ActionName="AnyKey",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=AnyKey)
DefaultPlayerInputClass=/Script/EnhancedInput.EnhancedPlayerInput
DefaultInputComponentClass=/Script/EnhancedInput.EnhancedInputComponent
DefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks
-ConsoleKeys=Tilde
+ConsoleKeys=Tilde

[/Script/EnhancedInput.EnhancedInputDeveloperSettings]
+DefaultMappingContexts=(InputMappingContext="/Game/ActionRoguelike/Input/IMC_PlayerDefault.IMC_PlayerDefault",Priority=0,bAddImmediately=True,bRegisterWithUserSettings=False)
UserSettingsClass=/Script/EnhancedInput.EnhancedInputUserSettings
DefaultPlayerMappableKeyProfileClass=/Script/EnhancedInput.EnhancedPlayerMappableKeyProfile
InputSettingsSaveSlotName=EnhancedInputUserSettings
DefaultWorldInputClass=/Script/EnhancedInput.EnhancedPlayerInput
bSendTriggeredEventsWhenInputIsFlushed=True
bEnableUserSettings=False
EnhancedInput.EnableDefaultMappingContexts=True
EnhancedInput.OnlyTriggerLastActionInChord=True
bEnableInputModeFiltering=True
bEnableWorldSubsystem=False
DefaultMappingContextInputModeQuery=(TokenStreamVersion=0,TagDictionary=((TagName="EnhancedInput.Modes.Default")),QueryTokenStream=(0,1,2,1,0),UserDescription="",AutoDescription="")
DefaultInputMode=(GameplayTags=((TagName="EnhancedInput.Modes.Default")))


```

`Config/DefaultScalability.ini`:

```ini




[ViewDistanceQuality@0]
SigMan.SignificanceBucketSizeMultiplier=0.5
a.Budget.BudgetMs=1.0

[ViewDistanceQuality@1]
SigMan.SignificanceBucketSizeMultiplier=0.8
a.Budget.BudgetMs=1.0

[ViewDistanceQuality@2]
SigMan.SignificanceBucketSizeMultiplier=1.0
a.Budget.BudgetMs=1.0

[ViewDistanceQuality@3]
SigMan.SignificanceBucketSizeMultiplier=1.5
a.Budget.BudgetMs=1.0
```

`README.md`:

```md
# Action Roguelike C++ Unreal Engine Game

![Course Header](https://tomlooman.com/assets/images/coursecpp_banner_widenarrow-3.png)

**Main Branch Engine Version: 5.6** <br>

The main branch is a bit of a playground for experimentation of new systems that may eventually turn into a blog post or in one of my courses (C++ or Game Optimization). For example, the projectiles have both Object Pooling mechanism AND an experimental Data Oriented Design approach to projectiles using no Actors at all. This may affect stability and is not always supporting multiplayer yet until the systems stabilize over time.

> ### Learn Unreal Engine C++ The Epic Way
> **Want to learn how to build this C++ Game from scratch? Learn more at [Professional Game Development in C++ and Unreal Engine Course](https://courses.tomlooman.com/p/unrealengine-cpp?coupon_code=COMMUNITY15&src=github)**

# Browsing Older Releases

The project has been updated over the years to keep up with the latest Unreal Engine release. Additionally, new features are added to the project, often related to new Articles or Tutorials posted on [tomlooman.com](https://tomlooman.com). These are available on the Main Branch.

**For C++ Course Students:** 
- **For the original UE4 version:** [Lecture29-FinishedProject](https://github.com/tomlooman/ActionRoguelike/tree/Lecture29-FinishedProject) for finished course code without additions all the way back to UE4.25.
- **For the new UE5.6 version of the course:** [UE5.6-CourseProject](https://github.com/tomlooman/ActionRoguelike/tree/UE5.6-CourseProject) which has a commit URL with each lesson of the C++ course for easy reference.

![GitHub Branch Selection Info](https://tomlooman.com/assets/images/github_branchesinfo.jpg)

# Project Features

- Third-person Action Character Movement
- **Enhanced Input**
- **Action System** (similar to Gameplay Ability System in design)
  - Dash Ability (Teleporting via projectile)
  - Blackhole Ability
  - Magic Projectile Attack
  - "Thorns" buff (reflecting damage)
  - Burning Damage-over-time effect
- AttributeComponent (Holding health etc.)
- **SaveGame System** for persisting progress of character and world state.
- Event-based logic to drive UI and gameplay reactions.
- Mix of C++ & Blueprint and how to combine them effectively.
- **GameplayTags** to mark-up Actors, Buffs, Actions.
- **Multiplayer support** for all features
- GameMode Logic
  - EQS for binding bot/powerup spawn locations.
  - Bot spawning system (bots cost points to spawn, gamemode gains points over time to spend)
  - DataTable holds bot information
  - DataAssets to hold enemy configurations
- **Asset Manager:** Async loading of data assets
- Async loading of UI icons
- AI
  - Minion AI with Behavior Trees (Roam, See, Chase, Attack, Flee/Heal)
  - C++ Custom Behavior Trees Nodes
  - EQS for attack/cover locations by AI
- Powerups
  - Powerup pickups to heal, gain credits/actions.
- UI (UMG)
  - Main menu to host/join game
  - UI elements for player attributes and projected widgets for powerups and enemy health.
  - C++ Localized Text
- Experimental / WIP
  - Aggregate Ticking (Projectiles)
  - Actor Pooling (Projectiles)
- Async Line tracing Example
- PSO Precaching & Bundled PSOs Setup for Windows DX12

<br>

# Melee Combat System

The game includes Melee attacks for enemy AI behaviors. The melee system builds on the Action System (similar to GAS) and uses Behavior Trees to initiate the logic to run up and perform the melee attack.

**Walkthrough**
- The Enemy's BehaviorTree checks if target (player) is within certain distance, and initiate melee attack sequence (run closer then attack when in attack range)
- **[RogueAction_MinionMeleeAttack](https://github.com/tomlooman/ActionRoguelike/blob/master/Source/ActionRoguelike/AI/RogueAction_MinionMeleeAttack.cpp)** (Action) handles the start/stop of the attack. Runs an AnimMontage with the attack animation. 
- **[RogueAnimationInstance](https://github.com/tomlooman/ActionRoguelike/blob/master/Source/ActionRoguelike/Animation/RogueAnimInstance.cpp)** (AnimBlueprint) contains *OnMeleeOverlap* which the Melee Attack Action listens for.
- **[RogueAnimNotifyState_Melee](https://github.com/tomlooman/ActionRoguelike/blob/master/Source/ActionRoguelike/Animation/RogueAnimNotifyState_Melee.cpp)** (AnimNotify) broadcasts *OnMeleeOverlap* event when an melee overlap is found by running *OverlapMultiByChannel* colision query while the AnimNotify is active.
  - **game.drawdebugmelee 1** to visualize the overlap shape during melee attack.
  - OnMeleeOverlap is handled by the Melee Attack Action to apply Damage to the hit target.

Note: The AnimMontage holds a Melee Attack animation and requires the custom AnimNotify in order to handle the overlap checks.

# Performance & Optimization

## Animation Budget Allocator
 
Animation Budget Allocator plugin for the enemy AI. Define the allocated animation budget using scalability CVAR (**a.Budget.BudgetMs**) inside **DefaultScalability.ini**. View the budgeting debug and profiling information using **a.Budget.Debug.Enabled** and **stat AnimationBudgetAllocator**. The ARogueAICharacter class includes the optional OnReduceAnimationWork callback to allow custom logic to further throttle anim quality when necessary.

You can get a quick overview by checking out the [initial commit](https://github.com/tomlooman/ActionRoguelike/commit/bbf4ea3f1af05d2b3acdbcc3d2312137015d5789). Read more on the [Animation Budget Allocator Docs Page](https://dev.epicgames.com/documentation/en-us/unreal-engine/animation-budget-allocator-in-unreal-engine) which contains all the steps to implement this in your own projects.

# Credits

Huge thanks to [tharlevfx](https://www.tharlevfx.com/) for converting all the Paragon Cascade effects to Niagara! Check out his [VFX courses here](https://tharlevfx.gumroad.com/)!

Another big thanks to [Sander van Zanten](https://www.sandervanzanten.nl/) for the audio overhaul in the project!


**Game Assets:** Licensed for use with the Unreal Engine only. Without a custom license you cannot use to create sequels, remasters, or otherwise emulate the original game or use the original game’s trademarks, character names, or other IP to advertise or name your game. (Unreal Engine EULA applies) (Please note this applies to the Game Assets that refer to Epic's Paragon, you can still use the project code and content to build your own Unreal Engine game)

```

`Source/ActionRoguelike.Target.cs`:

```cs
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;
using System.Collections.Generic;

public class ActionRoguelikeTarget : TargetRules
{
	public ActionRoguelikeTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.Latest;
		IncludeOrderVersion = EngineIncludeOrderVersion.Latest;

		ExtraModuleNames.AddRange( new string[] { "ActionRoguelike" } );
	}
}

```

`Source/ActionRoguelike/AI/RogueAICharacter.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AI/RogueAICharacter.h"

#include "ActionRoguelike.h"
#include "AIController.h"
#include "DrawDebugHelpers.h"
#include "BrainComponent.h"
#include "NiagaraComponent.h"
#include "SharedGameplayTags.h"
#include "SignificanceManager.h"
#include "SkeletalMeshComponentBudgeted.h"
#include "UI/RogueWorldUserWidget.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "ActionSystem/RogueActionComponent.h"
#include "BehaviorTree/BlackboardComponent.h"
#include "Components/AudioComponent.h"
#include "Components/CanvasPanel.h"
#include "Perception/AISense_Damage.h"
#include "IAnimationBudgetAllocator.h"
#include "NavigationSystem.h"
#include "AnimationBudgetAllocator/Private/AnimationBudgetAllocatorModule.h"
#include "Core/RogueMessagingSubsystem.h"
#include "Pickups/RoguePickupSubsystem.h"
#include "Subsystems/RogueMonsterCorpseSubsystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueAICharacter)


ARogueAICharacter::ARogueAICharacter(const FObjectInitializer& ObjectInitializer)
	// Override the SkelMesh with the Anim Budget variant for balancing anim cost across all AI bots
	:Super(ObjectInitializer.SetDefaultSubobjectClass<USkeletalMeshComponentBudgeted>(ACharacter::MeshComponentName))
{
	ActionComp = CreateDefaultSubobject<URogueActionComponent>(TEXT("ActionComp"));
	ActionComp->SetDefaultAttributeSet(ObjectInitializer, URogueMonsterAttributeSet::StaticClass());

	AttackSoundComp = CreateDefaultSubobject<UAudioComponent>(TEXT("AttackAudioComp"));
	AttackSoundComp->SetupAttachment(RootComponent);
	AttackSoundComp->bAutoManageAttachment = true;
	AttackSoundComp->SetAutoActivate(false);

	AttackParticleComp = CreateDefaultSubobject<UNiagaraComponent>(TEXT("AttackParticleComp"));
	AttackParticleComp->SetupAttachment(GetMesh(), AttackFX_Socket);
	AttackParticleComp->bAutoManageAttachment = true;
	AttackParticleComp->SetAutoActivate(false);

	// Ensures we receive a controlled when spawned in the level by our gamemode
	AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;

	// Enabled on mesh to react to incoming projectiles
	USkeletalMeshComponent* SkelMesh = GetMesh();
	SkelMesh->SetGenerateOverlapEvents(true);
	// Skip performing overlap queries on the Physics Asset after animation (17 queries in case of our MinionRangedBP)
	SkelMesh->bUpdateOverlapsOnAnimationFinalize = false;
	// Skip bones when not visible, may miss anim notifies etc. if animation is skipped so these options must be tested per use case
	SkelMesh->VisibilityBasedAnimTickOption = EVisibilityBasedAnimTickOption::OnlyTickMontagesWhenNotRendered;
}

void ARogueAICharacter::BeginPlay()
{
	Super::BeginPlay();

	// Only needs to enable the module once, placing in beginplay for convenience
	// They didn't expose the blueprint library, so we instead call directly into the module
	FAnimationBudgetAllocatorModule& AnimationBudgetAllocatorModule = FModuleManager::LoadModuleChecked<FAnimationBudgetAllocatorModule>("AnimationBudgetAllocator");
	if(IAnimationBudgetAllocator* AnimationBudgetAllocator = AnimationBudgetAllocatorModule.GetBudgetAllocatorForWorld(GetWorld()))
	{
		AnimationBudgetAllocator->SetEnabled(true);
	}

	// Significance Manager
	{
		USignificanceManager* SigMan = USignificanceManager::Get(GetWorld());
		check(SigMan);

		// This function will run async from the GameThread, so make sure it's threadsafe
		auto SignificanceFunc = [](USignificanceManager::FManagedObjectInfo* ObjectInfo, const FTransform& Viewpoint) -> float
		{
			TRACE_CPUPROFILER_EVENT_SCOPE(CalculateSignificance)

			// Either use the Actor as done below, or scope this more tightly to a specific component, this may benefit from improved cpu caching
			/*AActor* MyActor = CastChecked<AActor>(ObjectInfo->GetObject());
			check(IsValid(MyActor));
			
			float DistanceSqrt = (MyActor->GetActorLocation() - Viewpoint.GetLocation()).SizeSquared();
			
			if (MyActor->WasRecentlyRendered())
			{
				// while using negative sig values, use a <1.0 multiplier
				DistanceSqrt *= 0.5f;
			}*/

			USkeletalMeshComponent* SkelMeshComp = CastChecked<USkeletalMeshComponent>(ObjectInfo->GetObject());
			check(IsValid(SkelMeshComp));
			
			float DistanceSqrt = (SkelMeshComp->GetComponentLocation() - Viewpoint.GetLocation()).SizeSquared();
			
			if (SkelMeshComp->WasRecentlyRendered())
			{
				// while using negative sig values, use a <1.0 multiplier
				DistanceSqrt *= 0.5f;
			}

			// Note: AI could further define significance, for example, while in combat or having the player as a known target we could increase its significance

			// Negative distance to easily have larger distance mean lower significance
			return -DistanceSqrt;
		};

		// Register with post significance function to easily tie-in with the animation budgeter
		// We could also choose to let the budgeter calculate the significance itself instead
		auto PostSignificanceFunc = [&](USignificanceManager::FManagedObjectInfo* ObjectInfo, float OldSignificance, float Significance, bool bFinal)
		{
			USkeletalMeshComponentBudgeted* BudgetMesh = Cast<USkeletalMeshComponentBudgeted>(GetMesh());
			BudgetMesh->SetComponentSignificance(Significance);
		};

		// Additional flag in the budgetter to allow us to 'toggle' and turn off certain animation features custom to the game, this could mean detaching components on our skeletal mesh
		// it's entirely game dependent on what we could throttle here
		USkeletalMeshComponentBudgeted* BudgetMesh = Cast<USkeletalMeshComponentBudgeted>(GetMesh());
		BudgetMesh->OnReduceWork().BindUObject(this, &ARogueAICharacter::OnReduceAnimationWork);

		// If not using Significance Manager already, we could let it calculate automatically instead
		//BudgetMesh->SetAutoCalculateSignificance(true);

		// Instead of passing the entire Actor, we can pass the minimal data, such as the RootComponent, or SkeletalMeshComponent
		// This should allow us to be more cache efficient (from simple testing this does run slightly faster than using the Actor)
		SigMan->RegisterObject(GetMesh(), SignificanceTag, SignificanceFunc, USignificanceManager::EPostSignificanceType::Concurrent, PostSignificanceFunc);
	}
}


void ARogueAICharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	// Remove from SigMan
	{
		USignificanceManager* SigMan = USignificanceManager::Get(GetWorld());
		check(SigMan);
		// Make sure we unregister the same object as during Registration, in our case that's the SkeletalMeshComponent instead of the Actor
		SigMan->UnregisterObject(GetMesh());
	}

	Super::EndPlay(EndPlayReason);
}


void ARogueAICharacter::PostInitializeComponents()
{
	Super::PostInitializeComponents();
	
	// Cheap trick to disable until we need it in the health event
	CachedOverlayMaxDistance = GetMesh()->OverlayMaterialMaxDrawDistance;
	GetMesh()->SetOverlayMaterialMaxDrawDistance(1);

	FAttributeChangedSignature& Delegate = ActionComp->GetAttributeListenerDelegate(SharedGameplayTags::Attribute_Health);
	Delegate.AddUObject(this, &ThisClass::OnHealthAttributeChanged);
}


void ARogueAICharacter::OnHealthAttributeChanged(float NewValue, const FAttributeModification& AttributeModification)
{
	float Delta = AttributeModification.Magnitude;
	AActor* InstigatorActor = AttributeModification.Instigator.Get();
	
	if (Delta < 0.0f)
	{
		// Create once, and skip on instant kill
		if (ActiveHealthBar == nullptr && NewValue > 0.0)
		{
			ActiveHealthBar = CreateWidget<URogueWorldUserWidget>(GetWorld(), HealthBarWidgetClass);
			if (ActiveHealthBar)
			{
				ActiveHealthBar->AttachedActor = this;
				URogueWorldUserWidget::AddToRootCanvasPanel(ActiveHealthBar);
			}
		}

		// Read by the Overlay Material to flash
		GetMesh()->SetCustomPrimitiveDataFloat(HitFlash_CustomPrimitiveIndex, GetWorld()->TimeSeconds);

		// We can skip rendering this at a distance
		GetMesh()->SetOverlayMaterialMaxDrawDistance(CachedOverlayMaxDistance);

		// After 1.0seconds we should be finished with the hitflash (re-use the handle to reset timer if we get hit again)
		GetWorldTimerManager().SetTimer(OverlayTimerHandle, [this]()
		{
			// Cheap trick to skip rendering this all the time unless we are actively hit flashing
			GetMesh()->SetOverlayMaterialMaxDrawDistance(1);
		}, 1.0f, false);

		// Died
		if (NewValue <= 0.0f)
		{
			// stop BT
			if (HasAuthority())
			{
				AAIController* AIC = GetController<AAIController>();
				AIC->GetBrainComponent()->StopLogic("Killed");

				// Clears active actions, and (de)buffs.
				ActionComp->StopAllActions();

#if USE_DOD_CREDIT_PICKUPS
				// spawn credit loot, spawn a ton of them for stress testing
				URoguePickupSubsystem* PickupSubsystem = GetWorld()->GetSubsystem<URoguePickupSubsystem>();
				FVector ActorLoc = GetActorLocation();
				const FVector Offset = FVector(0,0,30);

				const int32 SpawnCount = 100;
				for (int i = 0; i < SpawnCount; ++i)
				{
					FNavLocation OutNavLoc;
					UNavigationSystemV1::GetNavigationSystem(this)->GetRandomPointInNavigableRadius(ActorLoc, 1024, OutNavLoc);

					PickupSubsystem->AddCreditsPickup(OutNavLoc.Location + Offset, 10);
				}
#endif

#if USE_TAGMESSAGING_SYSTEM
				FPayLoadTestMessage MsgPayload;
				MsgPayload.Credits = 25;

				URogueMessagingSubsystem* Msg = UGameInstance::GetSubsystem<URogueMessagingSubsystem>(GetGameInstance());
				Msg->BroadcastTagNative(SharedGameplayTags::Message_MonsterKilled, MsgPayload);
#endif
				
			}

			// ragdoll
			GetMesh()->SetAllBodiesSimulatePhysics(true);
			GetMesh()->SetCollisionProfileName(Collision::Ragdoll_ProfileName);

			GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);
			GetCharacterMovement()->DisableMovement();

			//SetLifeSpan(10.0f);
			URogueMonsterCorpseSubsystem* CorpseSystem = GetWorld()->GetSubsystem<URogueMonsterCorpseSubsystem>();
			CorpseSystem->AddCorpse(this);
			return;
		}

		// Damaged, but not dead yet

		// AI logic only runs on server
		if (HasAuthority())
		{
			// Skip reporting damage event for "Friendly" units. (We could also catch this earlier and prevent friendly-fire between AI units)
			ETeamAttitude::Type Attitude = GetTeamAttitudeTowards(*InstigatorActor);
			if (Attitude != ETeamAttitude::Friendly)
			{
				UAISense_Damage::ReportDamageEvent(this, this, InstigatorActor, FMath::Abs(Delta),
					InstigatorActor->GetActorLocation(), GetActorLocation());
			}
		}
	}
}


AActor* ARogueAICharacter::GetTargetActor() const
{
	AAIController* AIC = GetController<AAIController>();
	// Not guaranteed to be possessed (as we may use this in the AnimBP)
	if (AIC)
	{
		return Cast<AActor>(AIC->GetBlackboardComponent()->GetValueAsObject(NAME_TargetActor));
	}
	return nullptr;
}


void ARogueAICharacter::MulticastPlayAttackFX_Implementation()
{
	AttackSoundComp->Play();

	AttackParticleComp->Activate(true);
	
	PlayAnimMontage(AttackMontage);
}


void ARogueAICharacter::SignificanceLODChanged(int32 NewLOD)
{
	UE_LOG(LogGame, Verbose, TEXT("Actor: %s, NewLOD: %i (Bucket)"), *GetName(), NewLOD);

	EMovementMode MoveMode = NewLOD > 0 ? MOVE_NavWalking : MOVE_Walking;
	// GroundMovementMode won't mess with Flying/Falling modes
	GetCharacterMovement()->SetGroundMovementMode(MoveMode);

	// Example with straight 1:1 mapping, will force the min LOD to be lowered even when they are close to the camera
	GetMesh()->OverrideMinLOD(NewLOD);
}


void ARogueAICharacter::OnReduceAnimationWork(class USkeletalMeshComponentBudgeted* InComponent, bool bReduce)
{
	UE_LOG(LogGame, Log, TEXT("OnReduceAnimWork for bot %s, reducing = %s"), *GetName(), (bReduce ? TEXT("true") : TEXT("false")));

	// @todo: Actually throttle some work, for example, detach certain components on the skeletal mesh IF we had any in the first place
}


FGenericTeamId ARogueAICharacter::GetGenericTeamId() const
{
	// Matches the AIController team ID
	return FGenericTeamId(TEAM_ID_BOTS);
}

```

`Source/ActionRoguelike/AI/RogueAICharacter.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GenericTeamAgentInterface.h"
#include "ActionSystem/RogueActionSystemInterface.h"
#include "ActionSystem/RogueAttributeSet.h"
#include "GameFramework/Character.h"
#include "Performance/RogueSignificanceInterface.h"
#include "RogueAICharacter.generated.h"


class UNiagaraComponent;
class UUserWidget;
class URogueWorldUserWidget;
class URogueActionComponent;

UCLASS()
class ACTIONROGUELIKE_API ARogueAICharacter : public ACharacter, public IGenericTeamAgentInterface, public IRogueSignificanceInterface, public IRogueActionSystemInterface
{
	GENERATED_BODY()

public:
	
	UFUNCTION(BlueprintCallable, Category = "AI")
	AActor* GetTargetActor() const;

	UFUNCTION(NetMulticast, Unreliable)
	void MulticastPlayAttackFX();

protected:

	UPROPERTY(EditDefaultsOnly, Category = "UI")
	TSubclassOf<UUserWidget> HealthBarWidgetClass;

	/* Index must match the CustomPrimitiveData index used in the Overlay material */
	UPROPERTY(VisibleAnywhere, Category = "Effects")
	int32 HitFlash_CustomPrimitiveIndex = 0;

	UPROPERTY(EditDefaultsOnly, Category="Effects")
	FName AttackFX_Socket = FName("Muzzle_Front");

	UPROPERTY(EditDefaultsOnly, Category="Effects")
	TObjectPtr<UAnimMontage> AttackMontage;

	void OnHealthAttributeChanged(float NewValue, const FAttributeModification& AttributeModification);

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<URogueActionComponent> ActionComp;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<UAudioComponent> AttackSoundComp;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<UNiagaraComponent> AttackParticleComp;

	UPROPERTY(Transient)
	TObjectPtr<URogueWorldUserWidget> ActiveHealthBar;

public:

	virtual URogueActionComponent* GetActionComponent() const override
	{
		return ActionComp;
	}

	virtual void SignificanceLODChanged(int32 NewLOD) override;

	void OnReduceAnimationWork(class USkeletalMeshComponentBudgeted* InComponent, bool bReduce);
	
	virtual FGenericTeamId GetGenericTeamId() const override;

	virtual void PostInitializeComponents() override;

	ARogueAICharacter(const FObjectInitializer& ObjectInitializer);

	virtual void BeginPlay() override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

protected:

	/* Specifies a category for Significance Manager. Each unique Tag will have its own set of "Buckets" to sort and assign LODs based on distance etc. */
	UPROPERTY(EditDefaultsOnly, Category="Performance")
	FName SignificanceTag = "AICharacter";

	float CachedOverlayMaxDistance;

	FTimerHandle OverlayTimerHandle;

};
```

`Source/ActionRoguelike/AI/RogueAIController.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AI/RogueAIController.h"

#include "ActionRoguelike.h"
#include "RogueAICharacter.h"
#include "BehaviorTree/BlackboardComponent.h"
#include "Perception/AIPerceptionComponent.h"
#include "Player/RoguePlayerCharacter.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueAIController)


ARogueAIController::ARogueAIController()
{
	PerceptionComp = CreateDefaultSubobject<UAIPerceptionComponent>(TEXT("PerceptionComp"));
}


void ARogueAIController::BeginPlay()
{
	Super::BeginPlay();

	if (ensureMsgf(BehaviorTree, TEXT("Behavior Tree is nullptr! Please assign BehaviorTree in your AI Controller.")))
	{
		RunBehaviorTree(BehaviorTree);
	}

	// Setup a listener to check black board for target getting set so we can notify (clients) via a UI popup that they were spotted	
	UBlackboardComponent* BBComp = GetBlackboardComponent();
	BBComp->RegisterObserver(BBComp->GetKeyID(NAME_TargetActor), this,
		FOnBlackboardChangeNotification::CreateUObject(this, &ThisClass::OnTargetActorChanged));
}

void ARogueAIController::PreRegisterAllComponents()
{
	Super::PreRegisterAllComponents();
	
	// Set default for all AI - must be set before the Pawn is registered as a sense, otherwise we register the wrong team ID with perception system
	SetGenericTeamId(FGenericTeamId(TEAM_ID_BOTS));
}


EBlackboardNotificationResult ARogueAIController::OnTargetActorChanged(const UBlackboardComponent& Comp, FBlackboard::FKey KeyID)
{
	// Filter to only players as something we want to notify
	ARoguePlayerCharacter* TargetPlayer = Cast<ARoguePlayerCharacter>(Comp.GetValueAsObject(NAME_TargetActor));
	if (TargetPlayer)
	{
		// This will be running on the host/server as AI controllers only exist there, therefor we run a Client RPC on the character
		// so the local player will see the notification
		TargetPlayer->ClientOnSeenBy(CastChecked<ARogueAICharacter>(GetPawn()));

		// In our current behavior, we can remove the listener after first successful trigger
		//return EBlackboardNotificationResult::RemoveObserver;
	}

	return EBlackboardNotificationResult::ContinueObserving;
}

```

`Source/ActionRoguelike/AI/RogueAIController.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "AIController.h"
#include "BehaviorTree/BehaviorTreeTypes.h"
#include "BehaviorTree/Blackboard/BlackboardKey.h"
#include "RogueAIController.generated.h"


class UBehaviorTree;
class UAIPerceptionComponent;

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARogueAIController : public AAIController
{
	GENERATED_BODY()
	
protected:

	UPROPERTY(EditDefaultsOnly, Category = "AI")
	TObjectPtr<UBehaviorTree> BehaviorTree;

	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UAIPerceptionComponent> PerceptionComp;

	EBlackboardNotificationResult OnTargetActorChanged(const UBlackboardComponent& Comp, FBlackboard::FKey KeyID);

	virtual void BeginPlay() override;

	virtual void PreRegisterAllComponents() override;

public:

	ARogueAIController();
};

```

`Source/ActionRoguelike/AI/RogueAction_MinionMeleeAttack.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueAction_MinionMeleeAttack.h"

#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Animation/RogueAnimInstance.h"
#include "Core/RogueGameplayFunctionLibrary.h"
#include "Engine/OverlapResult.h"
#include "GameFramework/Character.h"


URogueAction_MinionMeleeAttack::URogueAction_MinionMeleeAttack()
{
	ActivationTag = SharedGameplayTags::Action_Melee;
}


void URogueAction_MinionMeleeAttack::StartAction_Implementation(AActor* Instigator)
{
	Super::StartAction_Implementation(Instigator);

	bDamageApplied = false;

	check(IsInGameThread());
	
	ACharacter* MyPawn = CastChecked<ACharacter>(Instigator);
	URogueAnimInstance* AnimInst = Cast<URogueAnimInstance>(MyPawn->GetMesh()->GetAnimInstance());
	OnOverlapHandle = AnimInst->OnMeleeOverlap.AddUObject(this, &ThisClass::OnMeleeOverlaps);

	float Duration = MyPawn->PlayAnimMontage(MeleeMontage);

	// Stop once the animation has finished
	FTimerHandle AnimCompleteHandle;
	GetWorld()->GetTimerManager().SetTimer(AnimCompleteHandle, [this, Instigator]()
	{
		StopAction(Instigator);
	}, Duration,false);
}

void URogueAction_MinionMeleeAttack::StopAction_Implementation(AActor* Instigator)
{
	Super::StopAction_Implementation(Instigator);

	ACharacter* MyPawn = CastChecked<ACharacter>(Instigator);
	URogueAnimInstance* AnimInst = Cast<URogueAnimInstance>(MyPawn->GetMesh()->GetAnimInstance());
	AnimInst->OnMeleeOverlap.Remove(OnOverlapHandle);
}

void URogueAction_MinionMeleeAttack::OnMeleeOverlaps(const TArray<FOverlapResult>& Overlaps)
{
	if (bDamageApplied)
	{
		// Skip
		// todo: alternatively, we could still allow one damage per actor, so it can melee-hit multiple different actors
		// across multiple "triggers" of a melee animation
		return;
	}
	
	// Find "best" overlap and deal damage to it.
	AActor* BestOverlap = nullptr;
	for (const FOverlapResult& Overlap : Overlaps)
	{
		// todo: check, if enemy, etc.
		if (Overlap.GetActor()->CanBeDamaged())
		{
			BestOverlap = Overlap.GetActor();
			break;
		}
	}

	if (BestOverlap)
	{
		URogueGameplayFunctionLibrary::ApplyDamage(GetOwningComponent()->GetOwner(), BestOverlap, DamageCoefficient);

		// Only allow damage once
		bDamageApplied = true;
	}
}

```

`Source/ActionRoguelike/AI/RogueAction_MinionMeleeAttack.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "ActionSystem/RogueAction.h"
#include "RogueAction_MinionMeleeAttack.generated.h"

/**
 * 
 */
UCLASS(Abstract)
class ACTIONROGUELIKE_API URogueAction_MinionMeleeAttack : public URogueAction
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category=Animation)
	TObjectPtr<UAnimMontage> MeleeMontage;

	UPROPERTY(EditDefaultsOnly, Category="Damage")
	float DamageCoefficient = 80;

public:

	virtual void StartAction_Implementation(AActor* Instigator) override;
	
	virtual void StopAction_Implementation(AActor* Instigator) override;

protected:

	FDelegateHandle OnOverlapHandle;

	/* Have we already applied damage once */
	bool bDamageApplied = false;

	void OnMeleeOverlaps(const TArray<FOverlapResult>& Overlaps);

public:

	URogueAction_MinionMeleeAttack();

};

```

`Source/ActionRoguelike/AI/RogueAction_MinionRangedAttack.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AI/RogueAction_MinionRangedAttack.h"

#include "ActionRoguelike.h"
#include "ActionSystem/RogueActionComponent.h"
#include "AI/RogueAICharacter.h"
#include "Core/RogueGameplayFunctionLibrary.h"
#include "GameFramework/Character.h"
#include "Kismet/GameplayStatics.h"
#include "Projectiles/RogueProjectile.h"
#include "Projectiles/RogueProjectilesSubsystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueAction_MinionRangedAttack)


void URogueAction_MinionRangedAttack::StartAction_Implementation(AActor* Instigator)
{
	ARogueAICharacter* MyPawn = CastChecked<ARogueAICharacter>(GetOwningComponent()->GetOwner());

	Super::StartAction_Implementation(Instigator);

	// Handle the cosmetic parts, push to all clients
	MyPawn->MulticastPlayAttackFX();

	const FVector MuzzleLocation = MyPawn->GetMesh()->GetSocketLocation(MeshSockets::RightHandMuzzle);
	// using TargetLocation instead of ActorLocation we *could* retrieve 'better' aiming location if implemented
	AActor* TargetActor = MyPawn->GetTargetActor();
	check(TargetActor);

	const ARogueProjectile* DefaultProj = Cast<ARogueProjectile>(ProjectileClass->GetDefaultObject());

	// Est. time to target based on distance-to and projectile assumed velocity
	const float ProjectileSpeed = DefaultProj->GetDefaultSpeed();
	float DistanceToTarget = (TargetActor->GetTargetLocation() - MuzzleLocation).Size();
	float TravelTime = DistanceToTarget / ProjectileSpeed;
	

	// Optionally set very small gravity if projectile has scale == 0, otherwise func will use the world default gravity in the calc below when passing in 0.f as override
	const float TinyGravity = 0.01f;
	const float ActualProjectileGravity = GetWorld()->GetGravityZ() * DefaultProj->GetGravityScale();
	const float GravityOverride = FMath::IsNearlyZero(DefaultProj->GetGravityScale()) ? TinyGravity : ActualProjectileGravity;

	FVector LaunchVelocity;
	UGameplayStatics::SuggestProjectileVelocity_MovingTarget(this, LaunchVelocity, MyPawn->GetActorLocation(), TargetActor, FVector::ZeroVector,
		GravityOverride, TravelTime, EDrawDebugTrace::None);
	// Override muzzle...with our approximate launch direction, based on an approx. desired flight time, can still be poorly targetted but thats OK for AI!
	FRotator MuzzleRotation = LaunchVelocity.Rotation();

	// to further improve the feel of enemy targeting, we could use an averaged velocity (taking past 1 second of velocities from TargetActor) in the function above, this adds some stickiness to the velocity on the player's movement
	// I expect this will make the enemy feel like its targetting us slightly better when we just started moving in a certain direction (it'll use a low velocity instead of the max)
	// same for move direction changes, it'll stick to targeting the 'recent' velocity direction instead so that their reflexes don't feel faster than a player could do.
	// Note: We need to replace the function SuggestProjectileVelocity_MovingTarget with a variant that doesn't grab TargetActor->GetVelocity but instead our own averaged velocity over the past 1 second or so.

	// Ignore negative pitch to not hit the floor in front itself
	MuzzleRotation.Pitch += FMath::RandRange(0.0f, MaxBulletSpread);
	MuzzleRotation.Yaw += FMath::RandRange(-MaxBulletSpread, MaxBulletSpread);

	FActorSpawnParameters Params;
	Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
	Params.Instigator = MyPawn;

#if USE_DATA_ORIENTED_PROJECTILES
	// WIP for data oriented projectiles
	URogueProjectilesSubsystem* Subsystem = GetWorld()->GetSubsystem<URogueProjectilesSubsystem>();
	Subsystem->CreateProjectile(MuzzleLocation, MuzzleRotation.Vector(), ProjectileConfig, MyPawn);
#else // Actor based projectiles
	GetWorld()->SpawnActor<AActor>(ProjectileClass, MuzzleLocation, MuzzleRotation, Params);
#endif

	StopAction(Instigator);
}

bool URogueAction_MinionRangedAttack::CanStart_Implementation(AActor* Instigator)
{
	if (Super::CanStart_Implementation(Instigator))
	{
		const ARogueAICharacter* MyPawn = CastChecked<ARogueAICharacter>(GetOwningComponent()->GetOwner());
		AActor* TargetActor = MyPawn->GetTargetActor();
	
		return TargetActor && URogueGameplayFunctionLibrary::IsAlive(TargetActor);
	}

	return false;
}

```

`Source/ActionRoguelike/AI/RogueAction_MinionRangedAttack.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "ActionSystem/RogueAction.h"
#include "RogueAction_MinionRangedAttack.generated.h"

class URogueProjectileData;

/**
 * 
 */
UCLASS(Abstract)
class ACTIONROGUELIKE_API URogueAction_MinionRangedAttack : public URogueAction
{
	GENERATED_BODY()

	/* Max Random Bullet Spread (in Degrees) in positive and negative angle (shared between Yaw and Pitch) */
	UPROPERTY(EditAnywhere, Category = "Attack")
	float MaxBulletSpread = 2.0f;

	UPROPERTY(EditAnywhere, Category = "Attack")
	TSubclassOf<AActor> ProjectileClass;

	UPROPERTY(EditDefaultsOnly)
	URogueProjectileData* ProjectileConfig;

	virtual void StartAction_Implementation(AActor* Instigator) override;

	virtual bool CanStart_Implementation(AActor* Instigator) override;
};

```

`Source/ActionRoguelike/AI/RogueBTDecorator_CheckHealth.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueBTDecorator_CheckHealth.h"

#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Core/RogueGameplayFunctionLibrary.h"


void URogueBTDecorator_CheckHealth::OnBecomeRelevant(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)
{
	Super::OnBecomeRelevant(OwnerComp, NodeMemory);

	// @todo: when using onhealthchanged delegate instead, you need to know:
	// - decorators share an instance, so anything must be stored inside NodeMemory instead (eg. storing the IsLowHealth bool to read inside CalculateRawConditionValue)
	// - add/remove delegate may be difficult on the class since we share this class instance with many others, the "this" param may end up accidentally removing
	// other listeners from other gameplay actors.
}

void URogueBTDecorator_CheckHealth::OnCeaseRelevant(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)
{
	Super::OnCeaseRelevant(OwnerComp, NodeMemory);
}

bool URogueBTDecorator_CheckHealth::CalculateRawConditionValue(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) const
{
	AController* Controller = Cast<AController>(OwnerComp.GetOwner());
	URogueActionComponent* ActionComp = URogueGameplayFunctionLibrary::GetActionComponentFromActor(Controller->GetPawn());
	
	float Health  = ActionComp->GetAttributeValue(SharedGameplayTags::Attribute_Health);
	float HealthMax = ActionComp->GetAttributeValue(SharedGameplayTags::Attribute_HealthMax);

	// Is low health?
	return (Health / HealthMax) < LowHealthFraction;
}

```

`Source/ActionRoguelike/AI/RogueBTDecorator_CheckHealth.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "BehaviorTree/BTDecorator.h"
#include "RogueBTDecorator_CheckHealth.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueBTDecorator_CheckHealth : public UBTDecorator
{
	GENERATED_BODY()

protected:

	/* Threshold that is considered 'low health' (eg. 0.3 is 30% of maximum hitpoints) */
	UPROPERTY(EditAnywhere, Category = "AI", meta = (ClampMin="0.0", ClampMax="1.0"))
	float LowHealthFraction = 0.3f;

public:

	virtual void OnBecomeRelevant(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;

	virtual void OnCeaseRelevant(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;

	virtual bool CalculateRawConditionValue(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) const override;
};

```

`Source/ActionRoguelike/AI/RogueBTService_CheckAttackRange.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AI/RogueBTService_CheckAttackRange.h"

#include "ActionRoguelike.h"
#include "BehaviorTree/BlackboardComponent.h"
#include "AIController.h"
#include "Core/RogueDeferredTaskSystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueBTService_CheckAttackRange)

#if !UE_BUILD_SHIPPING
namespace DevelopmentOnly
{
	static bool GDrawDebugAttackRange = false;
	static FAutoConsoleVariableRef CVarDrawDebug_AttackRangeService(
		TEXT("game.drawdebugattackrange"),
		GDrawDebugAttackRange,
		TEXT("Enable debug rendering of the attack range services.\n"),
		ECVF_Cheat
		);
}
#endif

URogueBTService_CheckAttackRange::URogueBTService_CheckAttackRange()
{
	TargetActorKey.SelectedKeyName = NAME_TargetActor;
}


void URogueBTService_CheckAttackRange::TickNode(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds)
{
	Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);

	// Check distance between ai pawn and target actor
	UBlackboardComponent* BlackBoardComp = OwnerComp.GetBlackboardComponent();
	check(BlackBoardComp);
	
	AActor* TargetActor = Cast<AActor>(BlackBoardComp->GetValueAsObject(TargetActorKey.SelectedKeyName));
	if (TargetActor)
	{
		AAIController* MyController = OwnerComp.GetAIOwner();
		check(MyController);

		FVector Center = MyController->GetPawn()->GetActorLocation();
		
		const float DistanceTo = FVector::Distance(TargetActor->GetActorLocation(), Center);
		const bool bWithinRange = DistanceTo < MaxAttackRange;

#if USE_DEFERRED_TASKS
		// In reality, we can make the LOS check async easily, but for this case we want to test deferring/slicing the task on the GameThread
		// as a test of the deferred task system itself
		URogueDeferredTaskSystem::AddLambda(this, [&]()
			{
				bool bHasLOS = false;
				if (bWithinRange)
				{
					bHasLOS = MyController->LineOfSightTo(TargetActor);
				}
				BlackBoardComp->SetValueAsBool(AttackRangeKey.SelectedKeyName, (bWithinRange && bHasLOS));
			});
#else
		bool bHasLOS = false;
		if (bWithinRange)
		{
			bHasLOS = MyController->LineOfSightTo(TargetActor);
		}
		BlackBoardComp->SetValueAsBool(AttackRangeKey.SelectedKeyName, (bWithinRange && bHasLOS));
#endif

#if !UE_BUILD_SHIPPING
		if (DevelopmentOnly::GDrawDebugAttackRange)
		{
			DrawDebugCircle(GetWorld(), Center, MaxAttackRange, 32.0f, DebugColor, false, DeltaSeconds,
				0, 4, FVector(0,1,0), FVector::ForwardVector);
		}
#endif
	}
}

```

`Source/ActionRoguelike/AI/RogueBTService_CheckAttackRange.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "BehaviorTree/BTService.h"
#include "RogueBTService_CheckAttackRange.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueBTService_CheckAttackRange : public UBTService
{
	GENERATED_BODY()
	
protected:

	UPROPERTY(EditAnywhere, Category = "AI")
	FBlackboardKeySelector AttackRangeKey;

	UPROPERTY(EditAnywhere, Category = "AI")
	FBlackboardKeySelector TargetActorKey;

	/* Max desired attack range of AI pawn */
	UPROPERTY(EditAnywhere, Category = "AI")
	float MaxAttackRange = 2000.f;

//#if WITH_EDITORONLY_DATA
	UPROPERTY(EditAnywhere, Category = Debug)
	FColor DebugColor = FColor::Green;
//#endif
	
	virtual void TickNode(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;

public:

	URogueBTService_CheckAttackRange();
};

```

`Source/ActionRoguelike/AI/RogueBTService_StartAction.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AI/RogueBTService_StartAction.h"
#include "AIController.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Core/RogueGameplayFunctionLibrary.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueBTService_StartAction)

void URogueBTService_StartAction::TickNode(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds)
{
	Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);

	// Assumed AIController and Pawn never nullptr (BT should be disabled if so)
	APawn* MyPawn = OwnerComp.GetAIOwner()->GetPawn();
	check(MyPawn);
	
	URogueActionComponent* ActionComp = URogueGameplayFunctionLibrary::GetActionComponentFromActor(MyPawn);
	check(ActionComp); // If nullptr we haven't properly implemented the enemy with an action component
	
	ActionComp->StartActionByName(MyPawn, ActionName);
}

```

`Source/ActionRoguelike/AI/RogueBTService_StartAction.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "BehaviorTree/BTService.h"
#include "RogueBTService_StartAction.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueBTService_StartAction : public UBTService
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere, Category = "Action")
	FGameplayTag ActionName;
		
	virtual void TickNode(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;

};

```

`Source/ActionRoguelike/AI/RogueBTTask_HealSelf.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AI/RogueBTTask_HealSelf.h"
#include "AIController.h"
#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueBTTask_HealSelf)


EBTNodeResult::Type URogueBTTask_HealSelf::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)
{
	APawn* MyPawn = OwnerComp.GetAIOwner()->GetPawn();

	URogueActionComponent* ActionComp = URogueActionComponent::GetActionComponent(MyPawn);
	check (ActionComp);
	
	const FRogueAttribute* HealthMaxAttribute = ActionComp->GetAttribute(SharedGameplayTags::Attribute_HealthMax);

	ActionComp->ApplyAttributeChange(SharedGameplayTags::Attribute_Health, HealthMaxAttribute->GetValue(),
		MyPawn, EAttributeModifyType::AddBase);

	return EBTNodeResult::Succeeded;
}


```

`Source/ActionRoguelike/AI/RogueBTTask_HealSelf.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "BehaviorTree/BTTaskNode.h"
#include "RogueBTTask_HealSelf.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueBTTask_HealSelf : public UBTTaskNode
{
	GENERATED_BODY()
	
	virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;
};

```

`Source/ActionRoguelike/AI/RogueBTTask_RangedAttack.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AI/RogueBTTask_RangedAttack.h"
#include "AIController.h"
#include "GameFramework/Character.h"
#include "BehaviorTree/BlackboardComponent.h"
#include "Core/RogueGameplayFunctionLibrary.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueBTTask_RangedAttack)


UDEPRECATED_URogueBTTask_RangedAttack::UDEPRECATED_URogueBTTask_RangedAttack()
{
	TargetActorKey.SelectedKeyName = NAME_TargetActor;
}


EBTNodeResult::Type UDEPRECATED_URogueBTTask_RangedAttack::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)
{
	ACharacter* MyPawn = CastChecked<ACharacter>(OwnerComp.GetAIOwner()->GetPawn());

	AActor* TargetActor = Cast<AActor>(OwnerComp.GetBlackboardComponent()->GetValueAsObject(TargetActorKey.SelectedKeyName));
	if (TargetActor == nullptr || !URogueGameplayFunctionLibrary::IsAlive(TargetActor))
	{
		return EBTNodeResult::Failed;
	}

	const FVector MuzzleLocation = MyPawn->GetMesh()->GetSocketLocation(MuzzleSocket);
	const FVector Direction = TargetActor->GetActorLocation() - MuzzleLocation;
	FRotator MuzzleRotation = Direction.Rotation();

	// Ignore negative pitch to not hit the floor in front itself
	MuzzleRotation.Pitch += FMath::RandRange(0.0f, MaxBulletSpread);
	MuzzleRotation.Yaw += FMath::RandRange(-MaxBulletSpread, MaxBulletSpread);

	FActorSpawnParameters Params;
	Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
	Params.Instigator = MyPawn;

	AActor* NewProj = GetWorld()->SpawnActor<AActor>(ProjectileClass, MuzzleLocation, MuzzleRotation, Params);

	return NewProj ? EBTNodeResult::Succeeded : EBTNodeResult::Failed;
	
}
```

`Source/ActionRoguelike/AI/RogueBTTask_RangedAttack.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "ActionRoguelike.h"
#include "BehaviorTree/BTTaskNode.h"
#include "RogueBTTask_RangedAttack.generated.h"

/**
 * Original Ranged Attack class for AI. Replaced with Action System variant
 */
UCLASS(Deprecated) // 
class ACTIONROGUELIKE_API UDEPRECATED_URogueBTTask_RangedAttack : public UBTTaskNode
{
	GENERATED_BODY()
		
	virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;

protected:

	UPROPERTY(EditAnywhere, Category = "AI")
	FBlackboardKeySelector TargetActorKey;

	/* Max Random Bullet Spread (in Degrees) in positive and negative angle (shared between Yaw and Pitch) */
	UPROPERTY(EditAnywhere, Category = "AI")
	float MaxBulletSpread = 2.0f;

	UPROPERTY(EditAnywhere, Category = "AI")
	TSubclassOf<AActor> ProjectileClass;

	UPROPERTY(EditAnywhere, Category= "AI")
	FName MuzzleSocket = MeshSockets::RightHandMuzzle;

public:

	UDEPRECATED_URogueBTTask_RangedAttack();
};

```

`Source/ActionRoguelike/AI/RogueBTTask_StartAction.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "AI/RogueBTTask_StartAction.h"
#include "AIController.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Core/RogueGameplayFunctionLibrary.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueBTTask_StartAction)


EBTNodeResult::Type URogueBTTask_StartAction::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)
{
	// Assumed AIController and Pawn never nullptr (BT should be disabled if so)
	APawn* MyPawn = OwnerComp.GetAIOwner()->GetPawn();
	check(MyPawn);
	
	URogueActionComponent* ActionComp = URogueGameplayFunctionLibrary::GetActionComponentFromActor(MyPawn);
	check(ActionComp); // If nullptr we haven't properly implemented the enemy with an action component
	
	if (ActionComp->StartActionByName(MyPawn, ActionName))
	{
		return EBTNodeResult::Succeeded;
	}
	
	return EBTNodeResult::Failed;
}

```

`Source/ActionRoguelike/AI/RogueBTTask_StartAction.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "BehaviorTree/BTTaskNode.h"
#include "RogueBTTask_StartAction.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueBTTask_StartAction : public UBTTaskNode
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "Action")
	FGameplayTag ActionName;
			
	virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;

};

```

`Source/ActionRoguelike/AI/RogueQueryContext_TargetActor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueQueryContext_TargetActor.h"
#include "AIController.h"
#include "BehaviorTree/BlackboardComponent.h"
#include "EnvironmentQuery/EnvQueryTypes.h"
#include "EnvironmentQuery/Items/EnvQueryItemType_Actor.h"


void URogueQueryContext_TargetActor::ProvideContext(FEnvQueryInstance& QueryInstance, FEnvQueryContextData& ContextData) const
{
	// Expect Pawn/Character as instigator/owner
	APawn* QuerierPawn = Cast<APawn>(QueryInstance.Owner.Get());
	if (ensure(QuerierPawn))
	{
		AAIController* Controller = Cast<AAIController>(QuerierPawn->GetController());
		check(Controller);
		
		AActor* TargetActor = Cast<AActor>(Controller->GetBlackboardComponent()->GetValueAsObject(TargetActorName));

		UEnvQueryItemType_Actor::SetContextHelper(ContextData, TargetActor);		
	}
}

```

`Source/ActionRoguelike/AI/RogueQueryContext_TargetActor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "ActionRoguelike.h"
#include "EnvironmentQuery/EnvQueryContext.h"
#include "RogueQueryContext_TargetActor.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueQueryContext_TargetActor : public UEnvQueryContext
{
	GENERATED_BODY()
	
	virtual void ProvideContext(FEnvQueryInstance& QueryInstance, FEnvQueryContextData& ContextData) const override;

	UPROPERTY(EditDefaultsOnly, Category= "AI")
	FName TargetActorName = NAME_TargetActor;
};

```

`Source/ActionRoguelike/ActionRoguelike.Build.cs`:

```cs
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;

public class ActionRoguelike : ModuleRules
{
	public ActionRoguelike(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
		
		SetupIrisSupport(Target);
		
		// Simplify the include paths in our source files
		PublicIncludePaths.AddRange(
			new string[] {
				"ActionRoguelike"
			}
		);
	
		PublicDependencyModuleNames.AddRange(new string[]
		{
			"Core", 
			"CoreUObject", 
			"Engine", 
			"InputCore", 
			"AIModule", 
			"NavigationSystem",
			"GameplayTasks", 
			"UMG", 
			"GameplayTags", 
			"OnlineSubsystem", 
			"DeveloperSettings",
			"SignificanceManager",
			"EnhancedInput",
			"Niagara",
			"CoreOnline",
			"NetCore", 
			"StateTreeModule", 
			"GameplayStateTreeModule",
			"PropertyBindingUtils" // needed for property binding in state tree
		});

		PrivateDependencyModuleNames.AddRange(new string[]
		{
			"MoviePlayer", // loading screen
			"RenderCore", // for PSO caching code access
			"AnimationBudgetAllocator"
		});
	}
}

```

`Source/ActionRoguelike/ActionRoguelike.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#include "ActionRoguelike.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, ActionRoguelike, "ActionRoguelike" );

DEFINE_LOG_CATEGORY(LogGame);
```

`Source/ActionRoguelike/ActionRoguelike.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
// Added here to more easily include whenever we also use LogGame (structuredlog is new in 5.2)
#include "Logging/StructuredLog.h"

// Define category "LogGame"
ACTIONROGUELIKE_API DECLARE_LOG_CATEGORY_EXTERN(LogGame, Log, All);

#define NAME_TargetActor "TargetActor"

// Define alias to easily keep track of custom channels in C++ (must match what is specified in Project Settings > Collision 
#define COLLISION_PROJECTILE ECC_GameTraceChannel1
#define TRACE_INTERACT ECC_GameTraceChannel2

// Perception System simple Team Numbers
#define TEAM_ID_BOTS 1
#define TEAM_ID_PLAYERS 2

namespace Animation
{
	static FName NAME_Foot_Plant_L = FName(TEXT("l_foot_plant"));
	static FName NAME_Foot_Plant_R = FName(TEXT("r_foot_plant"));
}

namespace Collision
{
	static FName Ragdoll_ProfileName = FName(TEXT("Ragdoll"));
	static FName Projectile_ProfileName = FName(TEXT("Projectile"));
	static FName Powerup_ProfileName = FName(TEXT("Powerup"));
}

namespace MeshSockets
{
	static FName RightHandMuzzle = FName(TEXT("Muzzle_01"));
	static FName LeftHandMuzzle = FName(TEXT("Muzzle_02"));
}


static void LogOnScreen(const UObject* WorldContext, const FString& Msg, FColor Color = FColor::White, float Duration = 5.0f)
{
	const UWorld* World = GEngine->GetWorldFromContextObject(WorldContext, EGetWorldErrorMode::LogAndReturnNull);

	// Net Prefix is helpful during PIE
	FString FullMessage = World->IsNetMode(NM_Client) ? "[CLIENT] " : "[SERVER] " + Msg;
	if (GEngine)
	{
		GEngine->AddOnScreenDebugMessage(-1, Duration, Color, FullMessage);
	}

	UE_LOG(LogGame, Log, TEXT("%s"), *FullMessage);
}
```

`Source/ActionRoguelike/ActionSystem/RogueAction.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ActionSystem/RogueAction.h"
#include "ActionSystem/RogueActionComponent.h"
#include "ActionRoguelike.h"
#include "Net/UnrealNetwork.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueAction)


void URogueAction::Initialize(URogueActionComponent* NewActionComp)
{
	ActionComp = NewActionComp;
}


bool URogueAction::CanStart_Implementation(AActor* Instigator)
{
	if (IsRunning())
	{
		return false;
	}

	if (CooldownTimeRemaining() > 0.0f)
	{
		return false;
	}

	URogueActionComponent* Comp = GetOwningComponent();
	
	if (Comp->ActiveGameplayTags.HasAny(BlockedTags))
	{
		return false;
	}

	return true;
}


void URogueAction::StartAction_Implementation(AActor* Instigator)
{
	UE_LOGFMT(LogGame, Verbose, "Started: {ActionName}", ("ActionName", GetName()));

	URogueActionComponent* Comp = GetOwningComponent();	
	Comp->ActiveGameplayTags.AppendTags(GrantsTags);

	if (GetOwningComponent()->GetOwnerRole() == ROLE_Authority)
	{
		RepData.bIsRunning = true;
		RepData.Instigator = Instigator;

		TimeStarted = GetWorld()->TimeSeconds; 
	}

	GetOwningComponent()->OnActionStarted.Broadcast(GetOwningComponent(), this);
}


void URogueAction::StopAction_Implementation(AActor* Instigator)
{
	UE_LOGFMT(LogGame, Verbose, "Stopped: {ActionName}", ("ActionName", GetName()));

	//ensureAlways(bIsRunning);

	URogueActionComponent* Comp = GetOwningComponent();
	Comp->ActiveGameplayTags.RemoveTags(GrantsTags);

	if (GetOwningComponent()->GetOwnerRole() == ROLE_Authority)
	{
		RepData.bIsRunning = false;
		RepData.Instigator = Instigator;
	}

	if (CooldownTime > 0.0f)
	{
		CooldownUntil = GetWorld()->TimeSeconds + CooldownTime;
	}

	GetOwningComponent()->OnActionStopped.Broadcast(GetOwningComponent(), this);
}


float URogueAction::CooldownTimeRemaining() const
{
	return FMath::Max(0.0f, CooldownUntil - GetWorld()->TimeSeconds);
}

UWorld* URogueAction::GetWorld() const
{
	// Outer is set when creating action via NewObject<T>
	AActor* Actor = Cast<AActor>(GetOuter());
	if (Actor)
	{
		return Actor->GetWorld();
	}

	return nullptr;
}


TSoftObjectPtr<UTexture2D> URogueAction::GetIcon() const
{
	return Icon;
}


URogueActionComponent* URogueAction::GetOwningComponent() const
{
	return ActionComp;
}


void URogueAction::OnRep_RepData()
{
	if (RepData.bIsRunning)
	{
		StartAction(RepData.Instigator);
	}
	else
	{
		StopAction(RepData.Instigator);
	}
}


bool URogueAction::IsRunning() const
{
	return RepData.bIsRunning;
}


void URogueAction::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(URogueAction, RepData);
	DOREPLIFETIME(URogueAction, TimeStarted);
	DOREPLIFETIME(URogueAction, CooldownUntil);
	DOREPLIFETIME(URogueAction, ActionComp);
}
```

`Source/ActionRoguelike/ActionSystem/RogueAction.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "GameplayTagContainer.h"
#include "RogueAction.generated.h"

class UWorld;
class URogueActionComponent;


USTRUCT()
struct FActionRepData
{
	GENERATED_BODY()

public:

	UPROPERTY()
	bool bIsRunning;

	UPROPERTY()
	TObjectPtr<AActor> Instigator;

	FActionRepData()
	{
		bIsRunning = false;
	}
};


/**
 * 
 */
UCLASS(Blueprintable)
class ACTIONROGUELIKE_API URogueAction : public UObject
{
	GENERATED_BODY()

public:

	UFUNCTION(BlueprintCallable, Category = "UI")
	TSoftObjectPtr<UTexture2D> GetIcon() const;

	UFUNCTION(BlueprintCallable, Category = "Action")
	URogueActionComponent* GetOwningComponent() const;

protected:
	
	UPROPERTY(EditDefaultsOnly, Category = "UI")
	TSoftObjectPtr<UTexture2D> Icon;

	UPROPERTY(Transient, Replicated)
	TObjectPtr<URogueActionComponent> ActionComp;

	/* Tags added to owning actor when activated, removed when action stops */
	UPROPERTY(EditDefaultsOnly, Category = "Tags")
	FGameplayTagContainer GrantsTags;

	/* Action can only start if OwningActor has none of these Tags applied */
	UPROPERTY(EditDefaultsOnly, Category = "Tags")
	FGameplayTagContainer BlockedTags;

	UPROPERTY(Transient, ReplicatedUsing="OnRep_RepData")
	FActionRepData RepData;

	UPROPERTY(Transient, Replicated)
	float TimeStarted = 0;

	/* GameTime until the Action is available again */
	UPROPERTY(Transient, Replicated)
	float CooldownUntil = 0;

	UFUNCTION()
	void OnRep_RepData();

	UPROPERTY(EditDefaultsOnly, Category="Cooldown")
	float CooldownTime;

	/* Start immediately when added to an action component */
	UPROPERTY(EditDefaultsOnly, Category = "Action")
	bool bAutoStart;

	/* Action nickname to start/stop without a reference to the object */
	UPROPERTY(EditDefaultsOnly, Category = "Action")
	FGameplayTag ActivationTag;
	
public:

	UFUNCTION(BlueprintPure)
	FGameplayTag GetActivationTag() const
	{
		return ActivationTag;
	}

	UFUNCTION(BlueprintPure)
	bool IsAutoStart() const
	{
		return bAutoStart;
	}

	void Initialize(URogueActionComponent* NewActionComp);

	UFUNCTION(BlueprintCallable, Category = "Action")
	bool IsRunning() const;

	UFUNCTION(BlueprintNativeEvent, Category = "Action")
	bool CanStart(AActor* Instigator);

	UFUNCTION(BlueprintNativeEvent, Category = "Action")
	void StartAction(AActor* Instigator);

	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Action")
	void StopAction(AActor* Instigator);

	UFUNCTION(BlueprintCallable, Category = "Action")
	float CooldownTimeRemaining() const;

	virtual UWorld* GetWorld() const override;

	virtual bool IsSupportedForNetworking() const override
	{
		return true;
	}
};

```

`Source/ActionRoguelike/ActionSystem/RogueActionComponent.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "ActionSystem/RogueActionComponent.h"

#include "ActionSystem/RogueAction.h"
#include "../ActionRoguelike.h"
#include "Core/RogueGameplayFunctionLibrary.h"
#include "Net/UnrealNetwork.h"
#include "Engine/ActorChannel.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueActionComponent)


URogueActionComponent::URogueActionComponent()
{
	PrimaryComponentTick.bCanEverTick = false;
	bWantsInitializeComponent = true;

	SetIsReplicatedByDefault(true);

	// See GDefaultUseSubObjectReplicationList for CVAR to enable by default project-wide
	bReplicateUsingRegisteredSubObjectList = true;
}


void URogueActionComponent::InitializeComponent()
{
	// Call before Super:: as we verify we haven't initialized yet
	if (AttributeSet == nullptr)
	{
		AttributeSet = NewObject<URogueAttributeSet>(this, URogueAttributeSet::StaticClass());
		UE_LOG(LogGame, Warning, TEXT("No default AttributeSet was specified. Set using SetDefaultAttributeSet during Actor construction"
								"or assign in the Blueprint details panel in the ActionComponent of %s"), *GetNameSafe(GetOwner()));
	}

	Super::InitializeComponent();
	
	InitAttributeSet();

	if (GetOwner()->HasAuthority())
	{
		AddReplicatedSubObject(AttributeSet);
	}
}

void URogueActionComponent::BeginPlay()
{
	Super::BeginPlay();

	// Server Only
	if (GetOwner()->HasAuthority())
	{
		for (TSubclassOf<URogueAction> ActionClass : DefaultActions)
		{
			AddAction(GetOwner(), ActionClass);
		}
	}
}


void URogueActionComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	StopAllActions();

	Super::EndPlay(EndPlayReason);
}


FRogueAttribute* URogueActionComponent::GetAttribute(FGameplayTag InAttributeTag)
{
	check(AttributeSet);
		
	FRogueAttribute** FoundAttribute = AttributeSet->AttributeCache.Find(InAttributeTag);
	if (FoundAttribute)
	{
		return *FoundAttribute;
	}

	return nullptr;
}

float URogueActionComponent::GetAttributeValue(FGameplayTag InAttributeTag)
{
	check(AttributeSet);
		
	FRogueAttribute** FoundAttribute = AttributeSet->AttributeCache.Find(InAttributeTag);
	if (FoundAttribute)
	{
		return (*FoundAttribute)->GetValue();
	}

	return 0.0f;
}


bool URogueActionComponent::K2_GetAttribute(FGameplayTag InAttributeTag, float& CurrentValue, float& Base, float& Delta)
{
	if (FRogueAttribute* FoundAttribute = GetAttribute(InAttributeTag))
	{
		CurrentValue = FoundAttribute->GetValue();
		Base = FoundAttribute->Base;
		Delta = FoundAttribute->Modifier;
	}

	return false;
}


bool URogueActionComponent::ApplyAttributeChange(const FAttributeModification& Modification)
{
	if (!GetOwner()->HasAuthority())
	{
		// Skip on clients.
		return false;
	}

	const FGameplayTag AttributeTag = Modification.AttributeTag;
	
	FRogueAttribute* Attribute = GetAttribute(AttributeTag);
	if (Attribute == nullptr)
	{
		UE_LOG(LogGame, Warning, TEXT("Attribute (%s) not found on Actor (%s)."), *AttributeTag.ToString(), *GetNameSafe(GetOwner()));
		return false;
	}

	float OriginalValue = Attribute->GetValue();

	switch (Modification.ModifyType)
	{
		case EAttributeModifyType::AddBase:
			{
				Attribute->Base += Modification.Magnitude;
				break;
			}
		case EAttributeModifyType::AddModifier:
			{
				Attribute->Modifier += Modification.Magnitude;
				break;
			}
		case EAttributeModifyType::OverrideBase:
			{
				Attribute->Base = Modification.Magnitude;
				break;
			}
		default:
			// Always fail here so we can address it
			check(false);
	}
	
	// Allow further modification here for the attribute set
	AttributeSet->PostAttributeChanged();

	// With clamping inside the attribute (or a zero delta) no real change might have occured
	if (!FMath::IsNearlyEqual(OriginalValue, Attribute->GetValue()))
	{
		BroadcastAttributeChanged(AttributeTag, Attribute->GetValue(), Modification);
		
		return true;
	}
	
	// no actual change occured
	return false;
}


void URogueActionComponent::RemoveDynamicAttributeListener(FAttributeChangedDynamicSignature Event)
{
	// Iterates all tags and arrays, could be faster if we specify the Tag in the function to know where to remove it.
	for (TPair<FGameplayTag, TArray<FAttributeChangedDynamicSignature>>& Listener : AttributeBlueprintListeners)
	{
		if (Listener.Value.RemoveSingle(Event) > 0)
		{
			// found it, skip checking the rest
			
			// Temp to verify this is all working
			UE_LOG(LogTemp, Log, TEXT("Successfully Removed binding from a blueprint"));
			break;
		}
	}
}


bool URogueActionComponent::ApplyAttributeChange(FGameplayTag InAttributeTag, float InMagnitude, AActor* Instigator, EAttributeModifyType ModType, FGameplayTagContainer InContextTags)
{
	FAttributeModification AttriMod = FAttributeModification(
		InAttributeTag,
		InMagnitude,
		this,
		Instigator,
		ModType,
		InContextTags);

	return ApplyAttributeChange(AttriMod);
}


void URogueActionComponent::OnRep_AttributeSet()
{
	InitAttributeSet();
}


void URogueActionComponent::InitAttributeSet()
{
	AttributeSet->InitializeAttributes(this);
}


FAttributeChangedSignature& URogueActionComponent::GetAttributeListenerDelegate(FGameplayTag InTag)
{
	return AttributeListenerMap.FindOrAdd(InTag);
}

void URogueActionComponent::AddDynamicAttributeListener(FAttributeChangedDynamicSignature Event, FGameplayTag InTag, bool bCallImmediately /*= false*/)
{
	TArray<FAttributeChangedDynamicSignature>& Events = AttributeBlueprintListeners.FindOrAdd(InTag);
	Events.Add(Event);

	if (bCallImmediately)
	{
		// Fill with minimal info available, useful for setting up initial states in UI etc.
		const FAttributeModification AttriMod = FAttributeModification(InTag,
			0.0f,
			this,
			GetOwner(),
			EAttributeModifyType::Invalid,
			FGameplayTagContainer());

		Event.Execute(GetAttributeValue(InTag), AttriMod);
	}
}

void URogueActionComponent::BroadcastAttributeChanged(FGameplayTag InTag, float InNewValue, FAttributeModification InModification)
{
	// Broadcast for all native listeners
	if (FAttributeChangedSignature* Event = AttributeListenerMap.Find(InTag))
	{
		Event->Broadcast(InNewValue, InModification);
	}
		
	// Broadcast any Blueprint listeners
	if (TArray<FAttributeChangedDynamicSignature>* Events = AttributeBlueprintListeners.Find(InTag))
	{
		// Reverse-for to allow cleanup for any events no longer bound to blueprint instances
		for (int i = Events->Num() - 1; i >= 0; --i)
		{
			FAttributeChangedDynamicSignature& Event = (*Events)[i];
			bool bIsBound = Event.ExecuteIfBound(InNewValue, InModification);
			if (!bIsBound)
			{
				Events->RemoveAt(i);
				UE_LOG(LogGame, Log, TEXT("Cleaned up expired attribute delegate for %s"), *GetNameSafe(GetOwner()));
			}
		}
	}
}


void URogueActionComponent::SetDefaultAttributeSet(const FObjectInitializer& ObjectInitializer, const TSubclassOf<URogueAttributeSet>& InNewClass)
{
	// Only allow during init
	check(!HasBeenInitialized());

	AttributeSet = Cast<URogueAttributeSet>(ObjectInitializer.CreateDefaultSubobject(this, TEXT("Attributes"), InNewClass, InNewClass));
}


URogueActionComponent* URogueActionComponent::GetActionComponent(AActor* FromActor)
{
	return URogueGameplayFunctionLibrary::GetActionComponentFromActor(FromActor);
}


void URogueActionComponent::AddAction(AActor* Instigator, TSubclassOf<URogueAction> ActionClass)
{
	// @todo: instead warn earlier about a poorly configured array
	/*if (!ensure(ActionClass))
	{
		return;
	}*/

	// Skip for clients
	if (!GetOwner()->HasAuthority())
	{
		UE_LOGFMT(LogGame, Warning, "Client attempting to AddAction. [Class: {Class}]", GetNameSafe(ActionClass));
		return;
	}

	URogueAction* NewAction = NewObject<URogueAction>(GetOwner(), ActionClass);
	check(NewAction);

	NewAction->Initialize(this);

	Actions.Add(NewAction);

	// New Replicated Objects list (for networking)
	AddReplicatedSubObject(NewAction);

	if (NewAction->IsAutoStart() && ensure(NewAction->CanStart(Instigator)))
	{
		NewAction->StartAction(Instigator);
	}

	// For this mechanism to work, we cant have multiple actions with the same activation tag
	// Only for actions with activation tag, buffs wont have those set
	if (NewAction->GetActivationTag().IsValid())
	{
		check(!CachedActions.Contains(NewAction->GetActivationTag()));
		CachedActions.Add(NewAction->GetActivationTag(), NewAction);
	}
}


void URogueActionComponent::RemoveAction(URogueAction* ActionToRemove)
{
	if (!ensure(ActionToRemove && !ActionToRemove->IsRunning()))
	{
		return;
	}

	RemoveReplicatedSubObject(ActionToRemove);

	Actions.Remove(ActionToRemove);

	CachedActions.Remove(ActionToRemove->GetActivationTag());
}


URogueAction* URogueActionComponent::GetAction(TSubclassOf<URogueAction> ActionClass) const
{
	for (URogueAction* Action : Actions)
	{
		if (Action->IsA(ActionClass))
		{
			return Action;
		}
	}

	return nullptr;
}


bool URogueActionComponent::StartActionByName(AActor* Instigator, FGameplayTag ActionName)
{
	//SCOPED_NAMED_EVENT(StartActionName, FColor::Green); // Visible in Unreal Insights with namedevents enabled
	TRACE_CPUPROFILER_EVENT_SCOPE(StartActionByName); // Alternative, available when Insights "CPU" channel is specified
	
	check(CachedActions.Num() > 0);
	if (TObjectPtr<URogueAction>* ActionPtr = CachedActions.Find(ActionName))
	{
		URogueAction* Action = ActionPtr->Get();
		
		if (!Action->CanStart(Instigator))
		{
			FString OwnerName = GetOwner()->GetName();
			FString FailedMsg = FString::Printf(TEXT("%s - Failed to run: %s"), *OwnerName, *ActionName.ToString());

			// Limits display in viewport to one per actor instance
			uint64 Key = GetTypeHash(OwnerName);

			GEngine->AddOnScreenDebugMessage(Key, 2.0f, FColor::Red, FailedMsg);
			return false;
		}

		// Bookmark for Unreal Insights
		//TRACE_BOOKMARK(TEXT("StartAction::%s"), *GetNameSafe(Action));

		// Is Client?
		if (!GetOwner()->HasAuthority())
		{
			// Request on the server
			ServerStartAction(Instigator, ActionName);
		}
		else
		{
			// Scoped within the curly braces. the _FSTRING variant adds additional tracing overhead due to grabbing the class name every time
			SCOPED_NAMED_EVENT_FSTRING(Action->GetClass()->GetName(), FColor::White);

			Action->StartAction(Instigator);
		}
		
		return true;
	}

	return false;
}


bool URogueActionComponent::StopActionByName(AActor* Instigator, FGameplayTag ActionName)
{
	for (URogueAction* Action : Actions)
	{
		if (Action->GetActivationTag() == ActionName)
		{
			if (Action->IsRunning())
			{
				// Is Client?
				if (!GetOwner()->HasAuthority())
				{
					ServerStopAction(Instigator, ActionName);
				}
				else
				{
					Action->StopAction(Instigator);
				}

				return true;
			}
		}
	}

	return false;
}

void URogueActionComponent::StopAllActions()
{
	// Stop all
	TArray<URogueAction*> ActionsCopy = Actions;
	for (URogueAction* Action : ActionsCopy)
	{
		if (Action->IsRunning())
		{
			Action->StopAction(GetOwner());
		}
	}
}


void URogueActionComponent::ServerStartAction_Implementation(AActor* Instigator, FGameplayTag ActionName)
{
	StartActionByName(Instigator, ActionName);
}


void URogueActionComponent::ServerStopAction_Implementation(AActor* Instigator, FGameplayTag ActionName)
{
	StopActionByName(Instigator, ActionName);
}


void URogueActionComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(URogueActionComponent, Actions);
	DOREPLIFETIME(URogueActionComponent, AttributeSet);
}


void URogueActionComponent::OnRep_Actions()
{
	// Expect this only for clients, host does it during add/remove action
	check(IsNetMode(NM_Client));
	
	// Reset
	CachedActions.Empty(Actions.Num());

	for (URogueAction* Action : Actions)
	{
		CachedActions.Add(Action->GetActivationTag(), Action);
	}
}

```

`Source/ActionRoguelike/ActionSystem/RogueActionComponent.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "GameplayTagContainer.h"
#include "RogueAttributeSet.h"
#include "RogueActionComponent.generated.h"

class URogueActionComponent;
class URogueAction;



DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnActionStateChanged, URogueActionComponent*, OwningComp, URogueAction*, Action);


UCLASS(ClassGroup=(RogueGame), meta=(BlueprintSpawnableComponent))
class ACTIONROGUELIKE_API URogueActionComponent : public UActorComponent
{
	GENERATED_BODY()

public:

	static URogueActionComponent* GetActionComponent(AActor* FromActor);

	UPROPERTY(Transient, EditAnywhere, BlueprintReadWrite, Category = "Tags")
	FGameplayTagContainer ActiveGameplayTags;

	UFUNCTION(BlueprintCallable, Category = "Actions")
	void AddAction(AActor* Instigator, TSubclassOf<URogueAction> ActionClass);

	UFUNCTION(BlueprintCallable, Category = "Actions")
	void RemoveAction(URogueAction* ActionToRemove);

	/* Returns first occurrence of action matching the class provided */
	UFUNCTION(BlueprintCallable, Category = "Actions")
	URogueAction* GetAction(TSubclassOf<URogueAction> ActionClass) const;

	UFUNCTION(BlueprintCallable, Category = "Actions")
	bool StartActionByName(AActor* Instigator, FGameplayTag ActionName);

	UFUNCTION(BlueprintCallable, Category = "Actions")
	bool StopActionByName(AActor* Instigator, FGameplayTag ActionName);

	/* Stop every action, for example during death */
	void StopAllActions();

	FRogueAttribute* GetAttribute(FGameplayTag InAttributeTag);

	float GetAttributeValue(FGameplayTag InAttributeTag);

	//UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = Attributes, meta = (Keywords = "Add, Set"))
	bool ApplyAttributeChange(const FAttributeModification& Modification);

	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = Attributes, meta = (Keywords = "Add, Set"))
	bool ApplyAttributeChange(FGameplayTag InAttributeTag, float InMagnitude, AActor* Instigator, EAttributeModifyType ModType, FGameplayTagContainer InContextTags = FGameplayTagContainer());

	/* Provide a default attribute set type for (base) classes, blueprint can set this via the details panel instead */
	void SetDefaultAttributeSet(const FObjectInitializer& ObjectInitializer, const TSubclassOf<URogueAttributeSet>& InNewClass);

	/*
	 * Retrieve the delegate to bind attribute change events, will create new entry in the Map if not currently present
	 */
	FAttributeChangedSignature& GetAttributeListenerDelegate(FGameplayTag InTag);

	UFUNCTION(BlueprintCallable, DisplayName="Add Attribute Listener", meta = (Keywords="event,delegate"))
	void AddDynamicAttributeListener(FAttributeChangedDynamicSignature Event, FGameplayTag InTag, bool bCallImmediately = false);

	void BroadcastAttributeChanged(FGameplayTag InTag, float InNewValue, FAttributeModification InModification);

protected:

	UFUNCTION(BlueprintCallable, Category=Attributes, DisplayName="GetAttribute")
	bool K2_GetAttribute(FGameplayTag InAttributeTag, float& CurrentValue, float& Base, float& Delta);

	UFUNCTION(BlueprintCallable, DisplayName="Remove Attribute Listener", meta = (Keywords="event,delegate"))
	void RemoveDynamicAttributeListener(FAttributeChangedDynamicSignature Event);

	/* Interchangeable set of attributes such as Health, BaseDamage, Strength, Stamina, MoveSpeed, etc. */
	UPROPERTY(EditAnywhere, Instanced, NoClear, ReplicatedUsing=OnRep_AttributeSet)
	TObjectPtr<URogueAttributeSet> AttributeSet;

	UFUNCTION()
	void OnRep_AttributeSet();

	UFUNCTION()
	void OnRep_Actions();

	void InitAttributeSet();

	/* List of delegates that came from Blueprint to ensure we can clean up "dead" hooks */
	TMap<FAttributeChangedDynamicSignature, FDelegateHandle> DynamicDelegateHandles;

	TMap<FGameplayTag, FAttributeChangedSignature> AttributeListenerMap;
	
	TMap<FGameplayTag, TArray<FAttributeChangedDynamicSignature>> AttributeBlueprintListeners;
	
	UFUNCTION(Server, Reliable)
	void ServerStartAction(AActor* Instigator, FGameplayTag ActionName);

	UFUNCTION(Server, Reliable)
	void ServerStopAction(AActor* Instigator, FGameplayTag ActionName);

	/* Granted abilities at game start */
	UPROPERTY(EditAnywhere, Category = "Actions")
	TArray<TSubclassOf<URogueAction>> DefaultActions;

	UPROPERTY(Transient, BlueprintReadOnly, ReplicatedUsing=OnRep_Actions)
	TArray<TObjectPtr<URogueAction>> Actions;

	/* Non-replicated map for quick lookups to Actions. */
	UPROPERTY(Transient)
	TMap<FGameplayTag, TObjectPtr<URogueAction>> CachedActions;

	virtual void InitializeComponent() override;

	virtual void BeginPlay() override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

public:	

	URogueActionComponent();

	UPROPERTY(BlueprintAssignable)
	FOnActionStateChanged OnActionStarted;

	UPROPERTY(BlueprintAssignable)
	FOnActionStateChanged OnActionStopped;

};

```

`Source/ActionRoguelike/ActionSystem/RogueActionEffect.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueActionEffect.h"
#include "ActionSystem/RogueActionComponent.h"
#include "GameFramework/GameStateBase.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueActionEffect)




URogueActionEffect::URogueActionEffect()
{
	bAutoStart = true;
}


void URogueActionEffect::StartAction_Implementation(AActor* Instigator)
{
	Super::StartAction_Implementation(Instigator);

	if (Duration > 0.0f)
	{
		FTimerDelegate Delegate;
		Delegate.BindUObject(this, &ThisClass::StopAction, Instigator);

		GetWorld()->GetTimerManager().SetTimer(DurationHandle, Delegate, Duration, false);
	}

	if (Period > 0.0f)
	{
		// Can bind in-line using FTimerDelegate::CreateUObject instead
		GetWorld()->GetTimerManager().SetTimer(
			PeriodHandle,
			FTimerDelegate::CreateUObject(this, &ThisClass::ExecutePeriodicEffect, Instigator),
			Period,
			true);
	}
}


void URogueActionEffect::StopAction_Implementation(AActor* Instigator)
{
	Super::StopAction_Implementation(Instigator);

	if (GetWorld()->GetTimerManager().GetTimerRemaining(PeriodHandle) < KINDA_SMALL_NUMBER)
	{
		ExecutePeriodicEffect(Instigator);
	}

	GetWorld()->GetTimerManager().ClearTimer(PeriodHandle);
	GetWorld()->GetTimerManager().ClearTimer(DurationHandle);

	URogueActionComponent* Comp = GetOwningComponent();
	Comp->RemoveAction(this);
}


float URogueActionEffect::GetTimeRemaining() const
{
	// Possibly nullptr early on if joining as a client in multiplayer (server spawns GameState and replicates the actor instance to clients)
	if (AGameStateBase* GS = GetWorld()->GetGameState<AGameStateBase>())
	{
		float EndTime = TimeStarted + Duration;
		return EndTime - GS->GetServerWorldTimeSeconds();
	}

	return Duration;
}


void URogueActionEffect::ExecutePeriodicEffect_Implementation(AActor* Instigator) {}

```

`Source/ActionRoguelike/ActionSystem/RogueActionEffect.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "ActionSystem/RogueAction.h"
#include "RogueActionEffect.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueActionEffect : public URogueAction
{
	GENERATED_BODY()

public:
	virtual void StartAction_Implementation(AActor* Instigator) override;

	virtual void StopAction_Implementation(AActor* Instigator) override;
	
protected:

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Effect")
	float Duration = 0.0f;

	/* Time between 'ticks' to apply effect */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Effect")
	float Period = 0.0f;

	FTimerHandle PeriodHandle;
	FTimerHandle DurationHandle;

	UFUNCTION(BlueprintNativeEvent, Category = "Effect")
	void ExecutePeriodicEffect(AActor* Instigator);

public:

	UFUNCTION(BlueprintCallable, Category = "Action")
	float GetTimeRemaining() const;

	URogueActionEffect();
};

```

`Source/ActionRoguelike/ActionSystem/RogueActionEffect_Thorns.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueActionEffect_Thorns.h"

#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Core/RogueGameplayFunctionLibrary.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueActionEffect_Thorns)


void URogueActionEffect_Thorns::StartAction_Implementation(AActor* Instigator)
{
	Super::StartAction_Implementation(Instigator);

	// Start listening
	AttriChangedHandle = ActionComp->GetAttributeListenerDelegate(SharedGameplayTags::Attribute_Health).AddUObject(this, &ThisClass::OnHealthChanged);
}


void URogueActionEffect_Thorns::StopAction_Implementation(AActor* Instigator)
{
	Super::StopAction_Implementation(Instigator);

	// Stop listening
	ActionComp->GetAttributeListenerDelegate(SharedGameplayTags::Attribute_Health).Remove(AttriChangedHandle);
}


void URogueActionEffect_Thorns::OnHealthChanged(float NewValue, const FAttributeModification& AttributeModification)
{
	AActor* OwningActor = GetOwningComponent()->GetOwner();

	// Damage Only
	if (AttributeModification.Magnitude < 0.0f && OwningActor != AttributeModification.Instigator)
	{
		if (AttributeModification.ContextTags.HasTag(SharedGameplayTags::Context_Reflected))
		{
			// Skip reflected damage to avoid ping-ponging reflected damage between two actors until someone dies
			return;
		}
		
		/*
		// Round to nearest to avoid decimal damage numbers and tiny reflections
		int32 ReflectedAmount = FMath::RoundToInt(AttributeModification.Magnitude * ReflectFraction);
		if (ReflectedAmount == 0)
		{
			return;
		}

		// Flip to positive, so we don't end up healing ourselves when passed into damage
		ReflectedAmount = FMath::Abs(ReflectedAmount);*/

		// @todo: maybe thorns can still base DMG on base dmg from hit rather than using player baseDmg attribute as with all normal damage
		float DmgCoefficient = 5.0f;

		FGameplayTagContainer Tags;
		Tags.AddTag(SharedGameplayTags::Context_Reflected);

		// Return damage to sender...
		URogueGameplayFunctionLibrary::ApplyDamage(OwningActor, AttributeModification.Instigator.Get(), DmgCoefficient, Tags);
	}
}

```

`Source/ActionRoguelike/ActionSystem/RogueActionEffect_Thorns.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "RogueActionEffect.h"
#include "RogueActionEffect_Thorns.generated.h"


struct FAttributeModification;

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueActionEffect_Thorns : public URogueActionEffect
{
	GENERATED_BODY()

protected:

	UPROPERTY(EditDefaultsOnly, Category = "Thorns")
	float ReflectFraction = 0.2f;

	void OnHealthChanged(float NewValue, const FAttributeModification& AttributeModification);

	FDelegateHandle AttriChangedHandle;

public:
	virtual void StartAction_Implementation(AActor* Instigator) override;

	virtual void StopAction_Implementation(AActor* Instigator) override;
};

```

`Source/ActionRoguelike/ActionSystem/RogueActionSystemInterface.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueActionSystemInterface.h"


// Add default functionality here for any IRogueActionSystemInterface functions that are not pure virtual.

```

`Source/ActionRoguelike/ActionSystem/RogueActionSystemInterface.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "RogueActionSystemInterface.generated.h"

class URogueActionComponent;

// This class does not need to be modified.
UINTERFACE()
class URogueActionSystemInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class ACTIONROGUELIKE_API IRogueActionSystemInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
public:
	
	virtual URogueActionComponent* GetActionComponent() const = 0;
};

```

`Source/ActionRoguelike/ActionSystem/RogueAction_ProjectileAttack.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueAction_ProjectileAttack.h"
#include "ActionRoguelike.h"
#include "NiagaraFunctionLibrary.h"
#include "Sound/SoundBase.h"
#include "GameFramework/Character.h"
#include "Performance/RogueActorPoolingSubsystem.h"
#include "Player/RoguePlayerCharacter.h"
#include "Projectiles/RogueProjectilesSubsystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueAction_ProjectileAttack)




void URogueAction_ProjectileAttack::StartAction_Implementation(AActor* Instigator)
{
	Super::StartAction_Implementation(Instigator);

	ARoguePlayerCharacter* Character = CastChecked<ARoguePlayerCharacter>(Instigator);
	Character->PlayAnimMontage(AttackAnim);

	// Auto-released particle pooling
	UNiagaraFunctionLibrary::SpawnSystemAttached(CastingEffect, Character->GetMesh(), HandSocketName, FVector::ZeroVector, FRotator::ZeroRotator,
		EAttachLocation::SnapToTarget, true, true, ENCPoolMethod::AutoRelease);

	//UGameplayStatics::SpawnSoundAttached(CastingSound, Character->GetMesh());
	// Alternative to spawning fresh instances for short-lived attacks every time (via SpawnSoundAttached above)
	// we use a single audio component on the player, which uses AutoManageAttachment to detach itself when not active
	Character->PlayAttackSound(CastingSound);

#if USE_DATA_ORIENTED_PROJECTILES
	// For projectile spawn only run locally
	// @fixme: verify local prediction for these projectiles works as expected
	if (Character->IsLocallyControlled())
#else
	if (Character->HasAuthority())
#endif
	{
		FTimerHandle TimerHandle_AttackDelay;
		FTimerDelegate Delegate;
		Delegate.BindUObject(this, &ThisClass::AttackDelay_Elapsed, Character);

		GetWorld()->GetTimerManager().SetTimer(TimerHandle_AttackDelay, Delegate, AttackAnimDelay, false);
	}
}


void URogueAction_ProjectileAttack::AttackDelay_Elapsed(ARoguePlayerCharacter* InstigatorCharacter)
{
	// Blueprint has not been properly configured yet if this fails
	if (ensureAlways(ProjectileClass))
	{
		FVector HandLocation = InstigatorCharacter->GetMesh()->GetSocketLocation(HandSocketName);

		// We trace against the environment first to find whats under the player crosshair.
		// We use the hit location to adjust the projectile launch direction so it will hit what is under the crosshair rather than shoot straight forward from the player hands.

		FActorSpawnParameters SpawnParams;
		SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
		SpawnParams.Instigator = InstigatorCharacter;

		FCollisionShape Shape;
		Shape.SetSphere(SweepRadius);

		// Ignore Player
		FCollisionQueryParams Params;
		Params.AddIgnoredActor(InstigatorCharacter);

		FVector TraceDirection = InstigatorCharacter->GetControlRotation().Vector();

		// Add sweep radius onto start to avoid the sphere clipping into floor/walls the camera is directly against.
		const FVector TraceStart = InstigatorCharacter->GetPawnViewLocation() + (TraceDirection * SweepRadius);
		// endpoint far into the look-at distance (not too far, still adjust somewhat towards crosshair on a miss)
		const FVector TraceEnd = TraceStart + (TraceDirection * SweepDistanceFallback);
		FVector AdjustedTraceEnd = TraceEnd;

		TArray<FHitResult> Hits;
		// Enemies are using Overlap response to Projectiles, we cant look for single Blocking hits and instead look for all overlaps and filter after
		if (GetWorld()->SweepMultiByChannel(Hits, TraceStart, TraceEnd, FQuat::Identity, COLLISION_PROJECTILE, Shape, Params))
		{
			// Overwrite trace end with impact point in world
			// First entry must exist and first entry will be first overlap or block
			// Could filter further, eg. ignoring friendly players between us and the enemy
			AdjustedTraceEnd = Hits[0].ImpactPoint;
		}

// Removes debug code from shipping builds		
#if !UE_BUILD_SHIPPING
		//const float DrawDuration = 5.0f;
		// Start
		//DrawDebugPoint(GetWorld(), TraceStart, 8, FColor::Green, false, DrawDuration);
		// End - possibly adjusted based on hit
		//DrawDebugPoint(GetWorld(), AdjustedTraceEnd, 8, FColor::Green, false, DrawDuration);
		//DrawDebugLine(GetWorld(), TraceStart, AdjustedTraceEnd, FColor::Green, false, DrawDuration);
		// End - Original
		//DrawDebugPoint(GetWorld(), TraceEnd, 8, FColor::Red, false, DrawDuration);
		//DrawDebugLine(GetWorld(), TraceStart, TraceEnd, FColor::Red, false, DrawDuration);
#endif

		// find new direction/rotation from Hand pointing to impact point in world.
		FRotator ProjRotation = (AdjustedTraceEnd - HandLocation).Rotation();

#if USE_DATA_ORIENTED_PROJECTILES
			// WIP for data oriented projectiles
			URogueProjectilesSubsystem* Subsystem = GetWorld()->GetSubsystem<URogueProjectilesSubsystem>();
			// @todo: move this spawn request to StartAction, in HIDDEN mode, until we reach here, ready to unhide.
			int32 NewProjectileID = Subsystem->CreateProjectile(HandLocation, ProjRotation.Vector(), ProjectileConfig, InstigatorCharacter);
#else // Actor-based projectiles
			FTransform SpawnTM = FTransform(ProjRotation, HandLocation);

			// Standard spawning, replaced by pooling system below
			//GetWorld()->SpawnActor<AActor>(ProjectileClass, SpawnTM, SpawnParams);

			// re-use a pooled actor instead of always spawning new Actors
			URogueActorPoolingSubsystem::AcquireFromPool(this, ProjectileClass, SpawnTM, SpawnParams);	
#endif
	}

	StopAction(InstigatorCharacter);
}

```

`Source/ActionRoguelike/ActionSystem/RogueAction_ProjectileAttack.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "ActionRoguelike.h"
#include "ActionSystem/RogueAction.h"
#include "RogueAction_ProjectileAttack.generated.h"

class UNiagaraSystem;
class UAnimMontage;
class USoundBase;
class URogueProjectileData;

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueAction_ProjectileAttack : public URogueAction
{
	GENERATED_BODY()
	
public:

	virtual void StartAction_Implementation(AActor* Instigator) override;
	
protected:

	UPROPERTY(EditDefaultsOnly)
	URogueProjectileData* ProjectileConfig;

	/* Sphere radius of the sweep to find desired target under crosshair. Adjusts final projectile direction */
	UPROPERTY(EditAnywhere, Category="Targeting")
	float SweepRadius = 20.0f;

	/* Fallback distance when sweep finds no collision under crosshair. Adjusts final projectile direction */
	UPROPERTY(EditAnywhere, Category="Targeting")
	float SweepDistanceFallback = 5000.f;

	UPROPERTY(EditAnywhere, Category = "Attack")
	TSubclassOf<AActor> ProjectileClass;

	UPROPERTY(EditAnywhere, Category = "Effects")
	FName HandSocketName = MeshSockets::RightHandMuzzle;

	UPROPERTY(EditDefaultsOnly, Category = "Attack")
	float AttackAnimDelay = 0.2f;

	UPROPERTY(EditAnywhere, Category = "Attack")
	TObjectPtr<UAnimMontage> AttackAnim;

	/* Particle System played during attack animation */
	UPROPERTY(EditAnywhere, Category = "Attack")
	TObjectPtr<UNiagaraSystem> CastingEffect;

	/* Sound Effect to play (Can be Wave or Cue) */
	UPROPERTY(EditAnywhere, Category = "Attack")
	TObjectPtr<USoundBase> CastingSound;
	
	void AttackDelay_Elapsed(class ARoguePlayerCharacter* InstigatorCharacter);
};

```

`Source/ActionRoguelike/ActionSystem/RogueAttributeSet.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueAttributeSet.h"

#include "RogueActionComponent.h"
#include "SharedGameplayTags.h"
#include "GameFramework/Character.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Net/UnrealNetwork.h"


URogueMonsterAttributeSet::URogueMonsterAttributeSet()
{
	// Override with lower default attack damage than players
	AttackDamage = FRogueAttribute(10);
		
	MoveSpeed = FRogueAttribute(450);
}

// -- Health Attribute Set -- //

void URogueHealthAttributeSet::OnRep_Health(FRogueAttribute OldValue)
{
	float NewValue = Health.GetValue();

	FAttributeModification Modification;
	Modification.AttributeTag = SharedGameplayTags::Attribute_Health;
	Modification.Magnitude = Health.GetValue() - OldValue.GetValue();
	Modification.TargetComp = OwningComp;

	OwningComp->BroadcastAttributeChanged(SharedGameplayTags::Attribute_Health, NewValue, Modification);
}


void URogueHealthAttributeSet::GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(URogueHealthAttributeSet, Health);
}

// -- Pawn Attribute Set -- //

void URoguePawnAttributeSet::ApplyMovementSpeed()
{
	// Assume all Pawns are Characters with CMC (may change with Mover 2.0)
	ACharacter* OwningCharacter = CastChecked<ACharacter>(OwningComp->GetOwner());
	OwningCharacter->GetCharacterMovement()->MaxWalkSpeed = MoveSpeed.GetValue();
}

```

`Source/ActionRoguelike/ActionSystem/RogueAttributeSet.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "UObject/Object.h"
#include "RogueAttributeSet.generated.h"


class URogueActionComponent;

UENUM(BlueprintType)
enum class EAttributeModifyType: uint8
{
	AddModifier,

	AddBase,

	OverrideBase,

	Invalid
};

/*
 * Short-lived collection of params (so we shouldn't need to keep weakobjptr's to the components)
 */
USTRUCT(BlueprintType)
struct FAttributeModification
{
	GENERATED_BODY()

	FAttributeModification() {}

	FAttributeModification(FGameplayTag InAttribute,
		float InMagnitude)
	{
		AttributeTag = InAttribute;
		Magnitude = InMagnitude;
	}

	FAttributeModification(FGameplayTag InAttribute,
		float InMagnitude,
		URogueActionComponent* InTargetComp,
		AActor* InInstigator,
		EAttributeModifyType InModificationType,
		const FGameplayTagContainer& InContextTags) :
			AttributeTag(InAttribute),
			TargetComp(InTargetComp),
			Instigator(InInstigator),
			Magnitude(InMagnitude),
			ModifyType(InModificationType),
			ContextTags(InContextTags) {}

	UPROPERTY(BlueprintReadOnly)
	FGameplayTag AttributeTag;

	/* Attribute change Applies to this component */
	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<URogueActionComponent> TargetComp = nullptr;

	/* The actor causing the attribute change, eg. the damage dealer */
	UPROPERTY(BlueprintReadOnly)
	TWeakObjectPtr<AActor> Instigator = nullptr;

	/* The "Delta" to apply to attribute */
	UPROPERTY(BlueprintReadOnly)
	float Magnitude = 0.0f;

	UPROPERTY(BlueprintReadOnly)
	EAttributeModifyType ModifyType = EAttributeModifyType::AddModifier;

	UPROPERTY(BlueprintReadOnly)
	FGameplayTagContainer ContextTags;
};


// Blueprint accessible delegate (this is how we "bind" indirectly in blueprint)
DECLARE_DYNAMIC_DELEGATE_TwoParams(FAttributeChangedDynamicSignature, float, NewValue, FAttributeModification, AppliedModification);
// The C++ delegate that is actually broadcast, and may itself call the above dynamic delegate by wrapping it in a lamdba
DECLARE_MULTICAST_DELEGATE_TwoParams(FAttributeChangedSignature, float /*NewValue*/, const FAttributeModification&);

/* Represents a single "float" Attribute which gives us greater flexibility in how its calculated due to buffs, items and permanent upgrades */
USTRUCT(BlueprintType)
struct FRogueAttribute
{
	GENERATED_BODY()

	FRogueAttribute() {}

	FRogueAttribute(float InBase) : Base(InBase) {}

	/* The base value, such as 'Strength' that was granted by the RPG class you picked, and modified permanently during gameplay (eg. +1 Str for a Level Up or a +1 permanent boost by consuming an item). This would be 'saved to disk'. */
	UPROPERTY(EditDefaultsOnly)
	float Base = 0.0f;

	/* Temporary modifier from buffs/debuffs, equipped items. This would not be 'saved to disk' as items would re-apply themselves on load */
	UPROPERTY(Transient)
	float Modifier = 0.0f;

	/* All game logic should get the value through here */
	float GetValue() const
	{
		// always clamp public value to zero, you could opt to make this a bool per attribute
		return FMath::Max(Base + Modifier, 0.0f);
	}
};

UCLASS(/*DefaultToInstanced,*/ EditInlineNew)
class URogueAttributeSet : public UObject
{
	GENERATED_BODY()

public:

	virtual void InitializeAttributes(URogueActionComponent* InNewOwningComponent)
	{
		OwningComp = InNewOwningComponent;

		FillAttributeCache();
	}
	
	/* Allow additional work such as clamping Attributes based on another (eg. Health vs. HealthMax) */
	virtual void PostAttributeChanged() {};

	/* Fill local cache for quick access on each Attribute in the Set */
	void FillAttributeCache()
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(ActionComponent::CacheAttributes);

		AttributeCache.Empty();

		for (TFieldIterator<FStructProperty> PropertyIt(GetClass()); PropertyIt; ++PropertyIt)
		{
			FRogueAttribute* FoundAttribute = PropertyIt->ContainerPtrToValuePtr<FRogueAttribute>(this);

			// Build the tag "Attribute.Health" where "Health" is the variable name of the RogueAttribute we just iterated
			FString TagName = TEXT("Attribute." + PropertyIt->GetName());
			FGameplayTag AttributeTag = FGameplayTag::RequestGameplayTag(FName(TagName));

			AttributeCache.Add(AttributeTag, FoundAttribute);
		}
	}
	
	virtual bool IsSupportedForNetworking() const override
	{
		return true;
	}

	/* Fetch from properties stored inside the AttributeSet for quick access */
	TMap<FGameplayTag, FRogueAttribute*> AttributeCache;

	UPROPERTY(Transient)
	URogueActionComponent* OwningComp;
};


/**
 * Base set containing Health/HealthMax, useful for world gameplay actors
 */
UCLASS()
class URogueHealthAttributeSet : public URogueAttributeSet
{
	GENERATED_BODY()

public:
	
	URogueHealthAttributeSet()
	{
		Health = FRogueAttribute(100);
		HealthMax = FRogueAttribute(Health.GetValue());
	}

protected:
	
	UPROPERTY(ReplicatedUsing=OnRep_Health, EditDefaultsOnly, BlueprintReadOnly, Category=Attributes)
	FRogueAttribute Health;
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Attributes)
	FRogueAttribute HealthMax;

	virtual void PostAttributeChanged() override
	{
		Health.Base = FMath::Clamp(Health.Base, 0.0f, HealthMax.GetValue());
		
		// @todo: reduce Health when HealthMax is updated by triggering another attribute change
	}

	UFUNCTION()
	void OnRep_Health(FRogueAttribute OldValue);

	virtual void GetLifetimeReplicatedProps(TArray<class FLifetimeProperty>& OutLifetimeProps) const override;
};

UCLASS()
class URoguePawnAttributeSet : public URogueHealthAttributeSet
{
	GENERATED_BODY()

public:
	
	URoguePawnAttributeSet() : Super()
	{
		AttackDamage = FRogueAttribute(25);
		MoveSpeed = FRogueAttribute(550);
	}

	virtual void InitializeAttributes(URogueActionComponent* InNewOwningComponent) override
	{
		Super::InitializeAttributes(InNewOwningComponent);

		ApplyMovementSpeed();
	}

protected:
	
	/* Base Damage value, all skills and damage use this multiplied by a damage coefficient
	 * (a percentage defaulting to 100%) to simplify balancing and scaling during play */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Attributes)
	FRogueAttribute AttackDamage;

	/*
	 * Walking speed directly linked with Character Movement Component
	 */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FRogueAttribute MoveSpeed;
	
	virtual void PostAttributeChanged() override
	{
		Super::PostAttributeChanged();

		ApplyMovementSpeed();
	}

	void ApplyMovementSpeed();
};

UCLASS()
class URogueSurvivorAttributeSet : public URoguePawnAttributeSet
{
	GENERATED_BODY()

protected:
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Attributes)
	FRogueAttribute Rage;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category=Attributes)
	FRogueAttribute Credits;
	/*
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category= "Attributes")
	FRogueAttribute Level;
	
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category= "Attributes")
	FRogueAttribute ExperiencePoints;*/
};


UCLASS()
class URogueMonsterAttributeSet : public URoguePawnAttributeSet
{
	GENERATED_BODY()

public:
	
	URogueMonsterAttributeSet();
};


```

`Source/ActionRoguelike/Animation/RogueAnimInstance.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueAnimInstance.h"

#include "ActionRoguelike.h"
#include "GameplayTagContainer.h"
#include "ActionSystem/RogueActionComponent.h"
#include "SharedGameplayTags.h"
#include "Core/RogueGameplayFunctionLibrary.h"
#include "Kismet/GameplayStatics.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueAnimInstance)



void URogueAnimInstance::NativeInitializeAnimation()
{
	Super::NativeInitializeAnimation();

	AActor* OwningActor = GetOwningActor();
	check(OwningActor);

	ActionComp = URogueGameplayFunctionLibrary::GetActionComponentFromActor(OwningActor);
}



void URogueAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);

	if (ActionComp)
	{
		bIsStunned = ActionComp->ActiveGameplayTags.HasTag(SharedGameplayTags::Status_Stunned);
	}
}

bool URogueAnimInstance::HandleNotify(const FAnimNotifyEvent& AnimNotifyEvent)
{
	if (AnimNotifyEvent.NotifyName == Animation::NAME_Foot_Plant_R || AnimNotifyEvent.NotifyName == Animation::NAME_Foot_Plant_L)
	{
		// Foot SFX (non-attached sounds will automatically cull if out of audible range)
		// You could choose to route this to the character classes instead to handle SFX playback
		UGameplayStatics::PlaySoundAtLocation(this, FootstepSound, GetOwningComponent()->GetComponentLocation());

		//UE_LOG(LogTemp, Log, TEXT("foot planted!"));
		return true;
	}

	// let the regular code path handle the notify
	return false;
}

```

`Source/ActionRoguelike/Animation/RogueAnimInstance.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimInstance.h"
#include "RogueAnimInstance.generated.h"

class URogueActionComponent;
class USoundBase;


DECLARE_MULTICAST_DELEGATE_OneParam(FOnAnimNofify_MeleeOverlap, const TArray<FOverlapResult>&);


/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueAnimInstance : public UAnimInstance
{
	GENERATED_BODY()

public:

	/* Broadcast by AnimNotify_Melee anytime a melee successfully finds overlaps  */
	FOnAnimNofify_MeleeOverlap OnMeleeOverlap;

	/* Footsteps triggered via anim notifies */
	UPROPERTY(EditDefaultsOnly, Category=Audio)
	TObjectPtr<USoundBase> FootstepSound;
	
protected:

	/* Is Pawn Stunned based on GameplayTag data */
	UPROPERTY(Transient, EditAnywhere, BlueprintReadOnly, Category = "Animation")
	bool bIsStunned;

	UPROPERTY(Transient, BlueprintReadOnly, Category = "Animation")
	TObjectPtr<URogueActionComponent> ActionComp;

	virtual void NativeInitializeAnimation() override;

	virtual void NativeUpdateAnimation(float DeltaSeconds) override;

	virtual bool HandleNotify(const FAnimNotifyEvent& AnimNotifyEvent) override;

};

```

`Source/ActionRoguelike/Animation/RogueAnimNotifyState_Melee.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueAnimNotifyState_Melee.h"

#include "RogueAnimInstance.h"
#include "Engine/OverlapResult.h"

#if !UE_BUILD_SHIPPING
namespace DevelopmentOnly
{
	static bool GDrawDebugMelee = false;
	static FAutoConsoleVariableRef CVarDrawDebug_MeleeNotifies(
		TEXT("game.drawdebugmelee"),
		GDrawDebugMelee,
		TEXT("Enable debug rendering on the melee system.\n"),
		ECVF_Cheat
		);
}
#endif


void URogueAnimNotifyState_Melee::NotifyTick(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation, float FrameDeltaTime, const FAnimNotifyEventReference& EventReference)
{
	// We could run async requests here continuously any time we have new results to fetch, could stop request after the first successful 'hit'

	if (!MeshComp->GetOwner()->HasAuthority())
	{
		// We can skip both overlaps and callbacks for clients
		// unless we want to do some kind of empty callback anyway on clients
		return;
	}

	FVector StartLoc = MeshComp->GetSocketLocation(SocketName);
	// assert on invalid bone name, or some other type of error throwing

	UWorld* World = MeshComp->GetWorld();

	FCollisionShape Shape;
	Shape.SetSphere(Radius);

	// Ignore self from melee options
	FCollisionQueryParams QueryParams;
	QueryParams.AddIgnoredActor(MeshComp->GetOwner());

	// todo: make this async
	TArray<FOverlapResult> Overlaps;
	World->OverlapMultiByChannel(Overlaps, StartLoc, FQuat::Identity, TraceChannel, Shape, QueryParams);
	
#if !UE_BUILD_SHIPPING
	if (DevelopmentOnly::GDrawDebugMelee)
	{
		DrawDebugSphere(World, StartLoc, Radius, 32.f, FColor::Cyan, false, 0.0f);
		
		for (FOverlapResult& Result : Overlaps)
		{
			DrawDebugBox(World, Result.GetComponent()->GetComponentLocation(), FVector(32.f), FColor::Green, false, 5.0f);
		}
	}
#endif

	// Report to be handled by anyone listening (should be the Action that triggered the animation)
	if (Overlaps.Num() > 0)
	{
		URogueAnimInstance* AnimInst = CastChecked<URogueAnimInstance>(MeshComp->GetAnimInstance());
		AnimInst->OnMeleeOverlap.Broadcast(Overlaps);
	}
}

```

`Source/ActionRoguelike/Animation/RogueAnimNotifyState_Melee.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Animation/AnimNotifies/AnimNotifyState.h"
#include "RogueAnimNotifyState_Melee.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueAnimNotifyState_Melee : public UAnimNotifyState
{
	GENERATED_BODY()

protected:

	UPROPERTY(EditAnywhere)
	TEnumAsByte<ECollisionChannel> TraceChannel = ECC_Pawn;

	/* Bone to center the (Sphere) Overlap around */
	UPROPERTY(EditAnywhere)
	FName SocketName;

	UPROPERTY(EditAnywhere)
	float Radius = 128.0f;

public:
	
	virtual void NotifyTick(USkeletalMeshComponent * MeshComp, UAnimSequenceBase * Animation, float FrameDeltaTime, const FAnimNotifyEventReference& EventReference) override;

};

```

`Source/ActionRoguelike/Animation/RogueCurveAnimSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Animation/RogueCurveAnimSubsystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueCurveAnimSubsystem)


void URogueCurveAnimSubsystem::Tick(float DeltaTime)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(CurveAnimationsTick)
	
	// Curve Based Anims - Reverse to easily remove completed anims during iteration
	for (int i = ActiveAnims.Num() - 1; i >= 0; --i)
	{
		ActiveAnims[i].Tick(DeltaTime);

		if (ActiveAnims[i].IsFinished())
		{
			ActiveAnims.RemoveAtSwap(i);
		}
	}

	// Easing Functions
	for (int i = ActiveEasingFuncs.Num() - 1; i >= 0; --i)
	{
		ActiveEasingFuncs[i].Tick(DeltaTime);

		if (ActiveEasingFuncs[i].IsFinished())
		{
			ActiveEasingFuncs.RemoveAtSwap(i);
		}
	}
}


void URogueCurveAnimSubsystem::PlayCurveAnim(UCurveFloat* InCurveAsset, float InPlayRate, const TFunction<void (float CurrentValue)>& Func)
{
	check(InCurveAsset);

	ActiveAnims.Add(FActiveCurveAnim(InCurveAsset, Func, InPlayRate));
}


void URogueCurveAnimSubsystem::PlayEasingFunc(EEasingFunc::Type EasingType, float EasingExp, float InPlayRate, const TFunction<void(float)>& Func)
{
	// In prototype only supporting this one type...
	check(EasingType == EEasingFunc::EaseInOut);

	ActiveEasingFuncs.Add(FActiveEasingFunc(EasingExp, InPlayRate, Func));
}


TStatId URogueCurveAnimSubsystem::GetStatId() const
{
	RETURN_QUICK_DECLARE_CYCLE_STAT(RogueTweenSubsystem, STATGROUP_Tickables);
}

```

`Source/ActionRoguelike/Animation/RogueCurveAnimSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/KismetMathLibrary.h"
#include "Subsystems/WorldSubsystem.h"
#include "RogueCurveAnimSubsystem.generated.h"


USTRUCT()
struct FActiveCurveAnim
{
	GENERATED_BODY()

	FActiveCurveAnim() {}

	FActiveCurveAnim(UCurveFloat* InCurve, TFunction<void (float)> InCallback, float InRate = 1.0f)
	{
		Curve = InCurve;
		Callback = InCallback;
		PlayRate = InRate;

		// We use first keyframe as start time, you could choose to always start at 0.0f
		Curve->GetTimeRange(CurrentTime, MaxTime);
	}

	UPROPERTY()
	UCurveFloat* Curve = nullptr;

	float PlayRate = 1.0f;

	/* Current time along curve */
	float CurrentTime = 0.0f;

	/* Cached max time to know when we finished */
	float MaxTime = 0.0f;

	TFunction<void(float)> Callback;

	void Tick(float DeltaTime)
	{
		CurrentTime += (DeltaTime*PlayRate);

		float CurrentValue = Curve->GetFloatValue(CurrentTime);

		Callback(CurrentValue);

		if (CurrentTime >= MaxTime)
		{
			// Mark as "Finished", will be cleaned up by subsystem
			Curve = nullptr;
		}
	}

	bool IsFinished() const
	{
		return Curve == nullptr;
	}
};


USTRUCT()
struct FActiveEasingFunc
{
	GENERATED_BODY()

	FActiveEasingFunc() {}

	FActiveEasingFunc(float InEasingExp, float InPlayRate, TFunction<void (float)> InCallback)
		: EasingExp(InEasingExp), PlayRate(InPlayRate), Callback(InCallback) 	{}

	float EasingExp = 2.0f;
	
	float PlayRate = 1.0f;
	
	float Time = 0.0f;

	TFunction<void(float)> Callback;

	void Tick(float DeltaTime)
	{
		Time += (DeltaTime*PlayRate);

		// Clamp
		Time = FMath::Min(Time, 1.0f);

		float CurrentValue = FMath::InterpEaseInOut(0.0f, 1.0f, Time, EasingExp);

		Callback(CurrentValue);
	}

	bool IsFinished()
	{
		return Time >= 1.0f;;
	}
};


/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueCurveAnimSubsystem : public UTickableWorldSubsystem
{
	GENERATED_BODY()

	// This could be a FInstancedStruct array if we want a variety of struct options with different sets of data
	TArray<FActiveCurveAnim> ActiveAnims;

	TArray<FActiveEasingFunc> ActiveEasingFuncs;

	virtual void Tick(float DeltaTime) override;

	virtual TStatId GetStatId() const override;

public:

	/* Start animation based on curve */
	void PlayCurveAnim(UCurveFloat* InCurveAsset, float InPlayRate, const TFunction<void(float)>& Func);

	/* Play easing function with output between 0.0 - 1.0 */
	void PlayEasingFunc(EEasingFunc::Type EasingType, float EasingExp, float InPlayRate, const TFunction<void(float)>& Func);
};

```

`Source/ActionRoguelike/Core/RogueDeferredTaskSystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueDeferredTaskSystem.h"
#include "Containers/Queue.h"


void URogueDeferredTaskSystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	// Track the frame start time to know if we have budget to process more this frame
	FCoreDelegates::OnBeginFrame.AddLambda([&]
	{
		FrameStartTime = FPlatformTime::Seconds();
	});
}

void URogueDeferredTaskSystem::AddLambda(const UObject* WorldContextObject, TFunction<void()> InFunctionPtr)
{
	URogueDeferredTaskSystem* TaskSystem = WorldContextObject->GetWorld()->GetSubsystem<URogueDeferredTaskSystem>();
	TaskSystem->AddFunction(MoveTemp(InFunctionPtr));
}


void URogueDeferredTaskSystem::AddFunction(TFunction<void()> InFunctionPtr)
{
	FDeferredTask NewTask = FDeferredTask();
	NewTask.FunctionPtr = MoveTemp(InFunctionPtr);
	
	FunctionPointers.Enqueue(NewTask);
}


void URogueDeferredTaskSystem::AddDelegate(FDeferredTaskDelegate InDelegate)
{
	FDeferredTask NewTask = FDeferredTask();
	NewTask.Delegate = InDelegate;
	
	FunctionPointers.Enqueue(NewTask);
}


void URogueDeferredTaskSystem::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

#if USE_DEFERRED_TASKS
	
	TRACE_CPUPROFILER_EVENT_SCOPE(RogueDeferredTaskSystem::ProcessQueue);

	double QueueStartTime = FPlatformTime::Seconds();
	// Allow at least this much time to be spent during a frame to avoid stalling the queue
	const double MinBudgetSeconds = 0.001f; // 1ms
	// Target budget to stay under each frame
	constexpr float TargetFPS = 120;
	constexpr float MaxFrameBudget = 1.0f / TargetFPS;
	
	//UE_LOG(LogTemp, Log, TEXT("Frame time so far: %f"), (QueueStartTime - FrameStartTime));

	while (!FunctionPointers.IsEmpty())
	{
		// @todo: issue remains that we don't process this subsystem at the end of the frame so we need to
		// keep time available for other systems including Slate to still take up more GameThread time.
		// this is experimental, the primary element of simply having a per-frame budget is the simplest and flattest approach to handling this.
		double TotalFrameTime = FPlatformTime::Seconds() - FrameStartTime;

		if (TotalFrameTime >= MaxFrameBudget)
		{
			// Exceeded out budget but forcefully continue until we hit the min time per frame to spend.
			if (FPlatformTime::Seconds() - QueueStartTime > MinBudgetSeconds)
			{
				// Exceeded frame budget
				break;
			}
		}
		
		FDeferredTask Task;
		if (FunctionPointers.Dequeue(Task))
		{
			TRACE_CPUPROFILER_EVENT_SCOPE(RogueDeferredTaskSystem::ProcessTask);
			// Run the lambda
			if (Task.FunctionPtr.IsSet())
			{
				Task.FunctionPtr();
			}
			// Run optional delegate (for blueprint)
			Task.Delegate.ExecuteIfBound();
		}
	}

#endif
}

```

`Source/ActionRoguelike/Core/RogueDeferredTaskSystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "RogueDeferredTaskSystem.generated.h"

/*
 * Toggle between the testing code and experimental use cases easily
 */
#define USE_DEFERRED_TASKS 0


DECLARE_DYNAMIC_DELEGATE(FDeferredTaskDelegate);


USTRUCT()
struct FDeferredTask
{
	GENERATED_BODY()

	TFunction<void()> FunctionPtr;

	FDeferredTaskDelegate Delegate;
};

/**
 * Allow functions or "tasks" to be delayed to later in the frame or a follow game frame when "budget" is available.
 * Goal is to improve frame pacing by spreading out non-critical functionality that can be safely delayed across multiple frames
 * without complex bookkeeping.
 *
 * Delegate hook is added as an example of letting Blueprint make use of this in a very straightforward way.
 * With C++ you instead pass lambdas into the system.
 *
 * The system ticks after most TickGroups, before TG_PostUpdateWork.
 */
UCLASS()
class ACTIONROGUELIKE_API URogueDeferredTaskSystem : public UTickableWorldSubsystem
{
	GENERATED_BODY()

public:

	static void AddLambda(const UObject* WorldContextObject, TFunction<void()> InFunctionPtr);

	void AddFunction(TFunction<void()> InFunctionPtr);
	
	/* Blueprint-way of delaying some task while budget is available */
	UFUNCTION(BlueprintCallable)
	void AddDelegate(FDeferredTaskDelegate InDelegate);

	virtual void Tick(float DeltaTime) override;

	virtual TStatId GetStatId() const override
	{
		RETURN_QUICK_DECLARE_CYCLE_STAT(URogueDeferredTaskSystem, STATGROUP_Tickables);
	}

protected:

	double FrameStartTime;

	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	
	TQueue<FDeferredTask> FunctionPointers;
};

```

`Source/ActionRoguelike/Core/RogueDeveloperSettings.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueDeveloperSettings.h"





FName URogueDeveloperSettings::GetCategoryName() const
{
	return FApp::GetProjectName();
}

```

`Source/ActionRoguelike/Core/RogueDeveloperSettings.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DeveloperSettings.h"
#include "RogueDeveloperSettings.generated.h"

/**
 * 
 */
UCLASS(Config=Game, DefaultConfig)
class ACTIONROGUELIKE_API URogueDeveloperSettings : public UDeveloperSettings
{
	GENERATED_BODY()

public:
	
	/* Pickup Subsystem - Coin Mesh used in ISMs */
	UPROPERTY(Config, EditDefaultsOnly, Category = "PickupSubsystem")
	TSoftObjectPtr<UStaticMesh> PickupCoinMesh;

	UPROPERTY(Config, EditDefaultsOnly, Category = "PickupSubsystem")
	TSoftObjectPtr<USoundBase> PickupCoinSound;
	
	virtual FName GetCategoryName() const override;
};

```

`Source/ActionRoguelike/Core/RogueGameModeBase.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueGameModeBase.h"
#include "EnvironmentQuery/EnvQueryManager.h"
#include "EnvironmentQuery/EnvQueryTypes.h"
#include "AI/RogueAICharacter.h"
#include "EngineUtils.h"
#include "DrawDebugHelpers.h"
#include "Player/RoguePlayerCharacter.h"
#include "Player/RoguePlayerState.h"
#include "Kismet/GameplayStatics.h"
#include "GameFramework/GameStateBase.h"
#include "RogueMonsterData.h"
#include "ActionRoguelike.h"
#include "RogueDeferredTaskSystem.h"
#include "RogueGameplayFunctionLibrary.h"
#include "RogueGameState.h"
#include "ActionSystem/RogueActionComponent.h"
#include "SaveSystem/RogueSaveGameSubsystem.h"
#include "Development/RogueDeveloperLocalSettings.h"
#include "Engine/AssetManager.h"
#include "Performance/RogueActorPoolingSubsystem.h"
#include "UI/RogueHUD.h"
#include "Windows/WindowsPlatformPerfCounters.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueGameModeBase)



ARogueGameModeBase::ARogueGameModeBase()
{
	PlayerStateClass = ARoguePlayerState::StaticClass();
	HUDClass = ARogueHUD::StaticClass();
	GameStateClass = ARogueGameState::StaticClass();
}


void ARogueGameModeBase::InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage)
{
	Super::InitGame(MapName, Options, ErrorMessage);

	// (Save/Load logic moved into new SaveGameSubsystem)
	URogueSaveGameSubsystem* SG = GetGameInstance()->GetSubsystem<URogueSaveGameSubsystem>();

	// Optional slot name (Falls back to slot specified in SaveGameSettings class/INI otherwise)
	FString SelectedSaveSlot = UGameplayStatics::ParseOption(Options, "SaveGame");
	SG->LoadSaveGame(SelectedSaveSlot);
}


void ARogueGameModeBase::StartPlay()
{
	Super::StartPlay();

	AvailableSpawnCredit = InitialSpawnCredit;

	StartSpawningBots();
	
	// Make sure we have assigned at least one power-up class
	if (ensure(PowerupClasses.Num() > 0))
	{
		// Skip the Blueprint wrapper and use the direct C++ option which the Wrapper uses as well
		FEnvQueryRequest Request(PowerupSpawnQuery, this);
		Request.Execute(EEnvQueryRunMode::AllMatching, this, &ARogueGameModeBase::OnPowerupSpawnQueryCompleted);
	}
	
	// We run the prime logic after the BeginPlay call to avoid accidentally running that on stored/primed actors
	RequestPrimedActors();
}


void ARogueGameModeBase::RequestPrimedActors()
{
	URogueActorPoolingSubsystem* PoolingSystem = GetWorld()->GetSubsystem<URogueActorPoolingSubsystem>();
	if (PoolingSystem->IsPoolingEnabled(this))
	{
		for (auto& Entry : ActorPoolClasses)
		{
			PoolingSystem->PrimeActorPool(Entry.Key, Entry.Value);
		}
	}
}


void ARogueGameModeBase::HandleStartingNewPlayer_Implementation(APlayerController* NewPlayer)
{
	// Calling Before Super:: so we set variables before 'beginplayingstate' is called in PlayerController (which is where we instantiate UI)
	URogueSaveGameSubsystem* SG = GetGameInstance()->GetSubsystem<URogueSaveGameSubsystem>();
	SG->HandleStartingNewPlayer(NewPlayer);

	Super::HandleStartingNewPlayer_Implementation(NewPlayer);

	// Now we're ready to override spawn location
	// Alternatively we could override core spawn location to use store locations immediately (skipping the whole 'find player start' logic)
	SG->OverrideSpawnTransform(NewPlayer);
}


void ARogueGameModeBase::StartSpawningBots()
{
	// Continuous timer to spawn in more bots.
	// Actual amount of bots and whether it's allowed to spawn determined by spawn logic later in the chain...
	GetWorldTimerManager().SetTimer(TimerHandle_SpawnBots, this, &ARogueGameModeBase::SpawnBotTimerElapsed, SpawnTimerInterval, true);
}


void ARogueGameModeBase::SpawnBotTimerElapsed()
{
#if !UE_BUILD_SHIPPING
    // disabled as we now use big button in level for debugging, but in normal gameplay something like this is useful
    // does require some code update on how it handles this as 'override' currently not properly set up.
	if (GetDefault<URogueDeveloperLocalSettings>()->bDisableSpawnBotsOverride)
	{
		return;
	}
#endif

	// Give points to spend
	if (SpawnCreditCurve)
	{
		AvailableSpawnCredit += SpawnCreditCurve->GetFloatValue(GetWorld()->TimeSeconds);
	}

	if (CooldownBotSpawnUntil > GetWorld()->TimeSeconds)
	{
		// Still cooling down
		return;
	}

	LogOnScreen(this, FString::Printf(TEXT("Available SpawnCredits: %f"), AvailableSpawnCredit));

	// Count alive bots before spawning
	int32 NrOfAliveBots = 0;
	for (ARogueAICharacter* Bot : TActorRange<ARogueAICharacter>(GetWorld()))
	{
		if (URogueGameplayFunctionLibrary::IsAlive(Bot))
		{
			NrOfAliveBots++;
		}
	}

	UE_LOGFMT(LogGame, Log, "Found {number} alive bots.", NrOfAliveBots);

	const float MaxBotCount = 10.0f;
	if (NrOfAliveBots >= MaxBotCount)
	{
		UE_LOGFMT(LogGame, Log, "At maximum bot capacity. Skipping bot spawn.");
		return;
	}

	// Row to pass along with EQS delegate
	FMonsterInfoRow* SelectedRow = nullptr;

	// @todo: warn about no monsterrow much earlier in the game and don't even bother arriving here if not set.
	// Use either DataValidation, asserts, or combination to prevent this from crashing here.
	//if (MonsterTable)
	
	TArray<FMonsterInfoRow*> Rows;
	MonsterTable->GetAllRows("", Rows);

	// Get total weight
	float TotalWeight = 0;
	for (FMonsterInfoRow* Entry : Rows)
	{
		TotalWeight += Entry->Weight;
	}

	// Random number within total random
	int32 RandomWeight = FMath::RandRange(0.0f, TotalWeight);

	//Reset
	TotalWeight = 0;

	// Get monster based on random weight
	for (FMonsterInfoRow* Entry : Rows)
	{
		TotalWeight += Entry->Weight;

		if (RandomWeight <= TotalWeight)
		{
			SelectedRow = Entry;
			break;
		}
	}

	if (SelectedRow && SelectedRow->SpawnCost >= AvailableSpawnCredit)
	{
		// Too expensive to spawn, try again soon
		CooldownBotSpawnUntil = GetWorld()->TimeSeconds + CooldownTimeBetweenFailures;

		LogOnScreen(this, FString::Printf(TEXT("Cooling down until: %f"), CooldownBotSpawnUntil), FColor::Red);
		return;
	}

	// Skip the Blueprint wrapper and use the direct C++ option which the Wrapper uses as well
	FEnvQueryRequest Request(SpawnBotQuery, this);

	FQueryFinishedSignature FinishedDelegate = FQueryFinishedSignature::CreateUObject(this, &ARogueGameModeBase::OnBotSpawnQueryCompleted, SelectedRow);
	
	Request.Execute(EEnvQueryRunMode::RandomBest5Pct, FinishedDelegate);
}


void ARogueGameModeBase::OnBotSpawnQueryCompleted(TSharedPtr<FEnvQueryResult> Result, FMonsterInfoRow* SelectedRow)
{
	FEnvQueryResult* QueryResult = Result.Get();
	if (!QueryResult->IsSuccessful())
	{
		UE_LOGFMT(LogGame, Warning, "Spawn bot EQS Query Failed!");
		return;
	}

	// Retrieve all possible locations that passed the query
	TArray<FVector> Locations;
	QueryResult->GetAllAsLocations(Locations);

	if (Locations.IsValidIndex(0) && MonsterTable)
	{
		UAssetManager& Manager = UAssetManager::Get();
		
		// Apply spawn cost
		AvailableSpawnCredit -= SelectedRow->SpawnCost;

		FPrimaryAssetId MonsterId = SelectedRow->MonsterId;

		TArray<FName> Bundles;
		FStreamableDelegate Delegate = FStreamableDelegate::CreateUObject(this, &ARogueGameModeBase::OnMonsterLoaded, MonsterId, Locations[0]);
		Manager.LoadPrimaryAsset(MonsterId, Bundles, Delegate);
	}
}


void ARogueGameModeBase::OnMonsterLoaded(FPrimaryAssetId LoadedId, FVector SpawnLocation)
{
	UAssetManager& Manager = UAssetManager::Get();

	URogueMonsterData* MonsterData = CastChecked<URogueMonsterData>(Manager.GetPrimaryAssetObject(LoadedId));
	
	AActor* NewBot = GetWorld()->SpawnActor<AActor>(MonsterData->MonsterClass, SpawnLocation, FRotator::ZeroRotator);
	// Spawn might fail if colliding with environment
	if (NewBot)
	{
		LogOnScreen(this, FString::Printf(TEXT("Spawned enemy: %s (%s)"), *GetNameSafe(NewBot), *GetNameSafe(MonsterData)));

		// Grant special actions, buffs etc.
		URogueActionComponent* ActionComp = URogueGameplayFunctionLibrary::GetActionComponentFromActor(NewBot);
		check(ActionComp);
		
		for (TSubclassOf<URogueAction> ActionClass : MonsterData->Actions)
		{
			ActionComp->AddAction(NewBot, ActionClass);
		}
	}
}


void ARogueGameModeBase::OnPowerupSpawnQueryCompleted(TSharedPtr<FEnvQueryResult> Result)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(OnPowerupSpawnQueryCompleted);
	
	FEnvQueryResult* QueryResult = Result.Get();
	if (!QueryResult->IsSuccessful())
	{
		UE_LOGFMT(LogGame, Warning, "Spawn bot EQS Query Failed!");
		return;
	}
	

	uint64 CyclesStart = FPlatformTime::Cycles64();

	// Retrieve all possible locations that passed the query
	TArray<FVector> Locations;
	QueryResult->GetAllAsLocations(Locations);

	// Keep used locations to easily check distance between points
	TArray<FVector> UsedLocations;

	int32 SpawnCounter = 0;
	// Break out if we reached the desired count or if we have no more potential positions remaining
	while (SpawnCounter < DesiredPowerupCount && Locations.Num() > 0)
	{
		// Pick a random location from remaining points.
		int32 RandomLocationIndex = FMath::RandRange(0, Locations.Num() - 1);

		FVector PickedLocation = Locations[RandomLocationIndex];
		// Remove to avoid picking again
		Locations.RemoveAtSwap(RandomLocationIndex);

		// Check minimum distance requirement
		bool bValidLocation = true;
		for (FVector OtherLocation : UsedLocations)
		{
			float DistanceTo = (PickedLocation - OtherLocation).Size();

			if (DistanceTo < RequiredPowerupDistance)
			{
				// Show skipped locations due to distance
				//DrawDebugSphere(GetWorld(), PickedLocation, 50.0f, 20, FColor::Red, false, 10.0f);

				// too close, skip to next attempt
				bValidLocation = false;
				break;
			}
		}

		// Failed the distance test
		if (!bValidLocation)
		{
			continue;
		}

		// Pick a random powerup-class
		int32 RandomClassIndex = FMath::RandRange(0, PowerupClasses.Num() - 1);
		TSubclassOf<AActor> RandomPowerupClass = PowerupClasses[RandomClassIndex];

#if USE_DEFERRED_TASKS
		UWorld* World = GetWorld();

		// Defer the spawning across multiple frames (depending on available budget)
		URogueDeferredTaskSystem::AddLambda(this,[World,RandomPowerupClass,PickedLocation]()
			{
				FActorSpawnParameters SpawnParams;
				SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
				
				World->SpawnActor<AActor>(RandomPowerupClass, PickedLocation, FRotator::ZeroRotator, SpawnParams);
			});
#else
		GetWorld()->SpawnActor<AActor>(RandomPowerupClass, PickedLocation, FRotator::ZeroRotator);
#endif
		

		// Keep for distance checks
		UsedLocations.Add(PickedLocation);
		SpawnCounter++;
	}

	uint64 CyclesEnd = FPlatformTime::Cycles64();

	UE_LOG(LogGame, Log, TEXT("OnPowerupSpawnQueryCompleted: %llu Cycles"), (CyclesEnd - CyclesStart));
}


void ARogueGameModeBase::RespawnPlayerElapsed(AController* Controller)
{
	Controller->UnPossess();
	RestartPlayer(Controller);
}


void ARogueGameModeBase::OnActorKilled(AActor* VictimActor, AActor* Killer)
{
	UE_LOGFMT(LogGame, Log, "OnActorKilled: Victim: {victim}, Killer: {killer}", GetNameSafe(VictimActor), GetNameSafe(Killer));

	// Handle Player death
	ARoguePlayerCharacter* Player = Cast<ARoguePlayerCharacter>(VictimActor);
	if (Player)
	{
		// Auto-respawn
		if (bAutoRespawnPlayer)
		{
			FTimerHandle TimerHandle_RespawnDelay;
			FTimerDelegate Delegate;
			Delegate.BindUObject(this, &ThisClass::RespawnPlayerElapsed, Player->GetController());
 
			const float RespawnDelay = 2.0f;
			GetWorldTimerManager().SetTimer(TimerHandle_RespawnDelay, Delegate, RespawnDelay, false);
		}

		// Store time if it was better than previous record
		ARoguePlayerState* PS = Player->GetPlayerState<ARoguePlayerState>();
		if (PS)
		{
			PS->UpdatePersonalRecord(GetWorld()->TimeSeconds);
		}

		URogueSaveGameSubsystem* SG = GetGameInstance()->GetSubsystem<URogueSaveGameSubsystem>();
		// Immediately auto save on death
		SG->WriteSaveGame();
	}

	// Give Credits for kill
	APawn* KillerPawn = Cast<APawn>(Killer);
	// Don't credit kills of self
	if (KillerPawn && KillerPawn != VictimActor)
	{
		// Only Players will have a 'PlayerState' instance, bots have nullptr
		ARoguePlayerState* PS = KillerPawn->GetPlayerState<ARoguePlayerState>();
		if (PS) 
		{
			PS->AddCredits(CreditsPerKill);
		}
	}
}

```

`Source/ActionRoguelike/Core/RogueGameModeBase.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "EnvironmentQuery/EnvQueryTypes.h"
#include "Engine/DataTable.h"
#include "RogueGameModeBase.generated.h"

class UEnvQuery;
class UEnvQueryInstanceBlueprintWrapper;
class UCurveFloat;
class UDataTable;
class URogueMonsterData;


/* DataTable Row for spawning monsters in game mode  */
USTRUCT(BlueprintType)
struct FMonsterInfoRow : public FTableRowBase
{
	GENERATED_BODY()

public:

	FMonsterInfoRow()
	{
		Weight = 1.0f;
		SpawnCost = 5.0f;
		KillReward = 20.0f;
	}

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FPrimaryAssetId MonsterId;

	/* Relative chance to pick this monster */
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	float Weight;

	/* Points required by gamemode to spawn this unit. */
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	float SpawnCost;

	/* Amount of credits awarded to killer of this unit.  */
	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	float KillReward;
};

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARogueGameModeBase : public AGameModeBase
{
	GENERATED_BODY()

protected:

	/* All available monsters */
	UPROPERTY(EditDefaultsOnly, Category = "AI")
	TObjectPtr<UDataTable> MonsterTable;

	UPROPERTY(EditDefaultsOnly, Category = "AI")
	TObjectPtr<UEnvQuery> SpawnBotQuery;

	/* Curve to grant credits to spend on spawning monsters */
	UPROPERTY(EditDefaultsOnly, Category = "AI")
	TObjectPtr<UCurveFloat> SpawnCreditCurve;
	
	/* Time to wait between failed attempts to spawn/buy monster to give some time to build up credits. */
	UPROPERTY(EditDefaultsOnly, Category = "AI")
	float CooldownTimeBetweenFailures = 8.0f;

	FTimerHandle TimerHandle_SpawnBots;

	UPROPERTY(EditDefaultsOnly, Category = "AI")
	float SpawnTimerInterval = 2.0f;

	// Read/write access as we could change this as our difficulty increases via Blueprint
	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "AI")
	int32 CreditsPerKill = 20.0f;

	/* Amount available to start spawning some bots immediately */
	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "AI")
	int32 InitialSpawnCredit = 50.0f;

	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Ruleset")
	bool bAutoRespawnPlayer = false;

	UPROPERTY(EditDefaultsOnly, Category = "Powerups")
	TObjectPtr<UEnvQuery> PowerupSpawnQuery;

	/* All power-up classes used to spawn with EQS at match start */
	UPROPERTY(EditDefaultsOnly, Category = "Powerups")
	TArray<TSubclassOf<AActor>> PowerupClasses;

	/* Distance required between power-up spawn locations */
	UPROPERTY(EditDefaultsOnly, Category = "Powerups")
	float RequiredPowerupDistance = 2000.f;

	/* Amount of powerups to spawn during match start */
	UPROPERTY(EditDefaultsOnly, Category = "Powerups")
	int32 DesiredPowerupCount = 10.0f;

	void StartSpawningBots();
	
	void SpawnBotTimerElapsed();
	
	void OnBotSpawnQueryCompleted(TSharedPtr<FEnvQueryResult> Result, FMonsterInfoRow* SelectedRow);

	void OnMonsterLoaded(FPrimaryAssetId LoadedId, FVector SpawnLocation);
	
	void OnPowerupSpawnQueryCompleted(TSharedPtr<FEnvQueryResult> Result);

	UFUNCTION()
	void RespawnPlayerElapsed(AController* Controller);

	// Points available to spend on spawning monsters
	float AvailableSpawnCredit = 0;

	/* GameTime cooldown to give spawner some time to build up credits */
	float CooldownBotSpawnUntil = 0;

	/* Allow per game mode actor pools and custom amount of primed instances */
	UPROPERTY(EditDefaultsOnly, Category= "Actor Pooling")
	TMap<TSubclassOf<AActor>, int32> ActorPoolClasses;

	void RequestPrimedActors();

public:

	virtual void OnActorKilled(AActor* VictimActor, AActor* Killer);

	ARogueGameModeBase();

	virtual void InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage) override;

	virtual void StartPlay() override;

	virtual void HandleStartingNewPlayer_Implementation(APlayerController* NewPlayer) override;
};

```

`Source/ActionRoguelike/Core/RogueGameState.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueGameState.h"
#include "Net/UnrealNetwork.h"
#include "Projectiles/RogueProjectilesSubsystem.h"


void ARogueGameState::ServerCreateProjectile_Implementation(FVector InPosition, FVector InDirection, URogueProjectileData* ProjectileConfig, AActor* InstigatorActor, uint32 NewID)
{
	URogueProjectilesSubsystem* Subsystem = GetWorld()->GetSubsystem<URogueProjectilesSubsystem>();
	Subsystem->InternalCreateProjectile(InPosition, InDirection, ProjectileConfig, InstigatorActor, NewID);
}


void ARogueGameState::BeginPlay()
{
	Super::BeginPlay();

	// Init with subsystem so we can access the world and subsystem within the struct during replication
	ProjectileData.OwningSubsystem = GetWorld()->GetSubsystem<URogueProjectilesSubsystem>();

	CoinPickupData.OwningSubsystem = GetWorld()->GetSubsystem<URoguePickupSubsystem>();
}

void ARogueGameState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ARogueGameState, ProjectileData);
	DOREPLIFETIME(ARogueGameState, CoinPickupData);
}

```

`Source/ActionRoguelike/Core/RogueGameState.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameStateBase.h"
#include "Pickups/RoguePickupItemReplication.h"
#include "Projectiles/RogueProjectileReplication.h"
#include "RogueGameState.generated.h"


/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARogueGameState : public AGameStateBase
{
	GENERATED_BODY()

public:

	/* Client requests a new projectile, client will already spawn this locally and it will be kept in sync
	 * rather than waiting for the server to tell them to spawn it
	 */
	UFUNCTION(Server, reliable)
	void ServerCreateProjectile(FVector InPosition, FVector InDirection, URogueProjectileData* ProjectileConfig,
		AActor* InstigatorActor, uint32 NewID);

	virtual void BeginPlay() override;

	/*
	 * Holds all replicated "data oriented" projectiles. No Actors, just data handling all movement, cosmetics and overlaps
	 */
	UPROPERTY(Replicated)
	FProjectileArray ProjectileData;

	/* Holds the cosmetic information for clients to show pickup locations
	 * The subsystem holds the internal data to handle actual distance and pickup checks 
	 */
	UPROPERTY(Replicated)
	FPickupLocationsArray CoinPickupData;

	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

};

```

`Source/ActionRoguelike/Core/RogueGameViewportClient.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueGameViewportClient.h"

#include "SignificanceManager.h"
#include "Kismet/GameplayStatics.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueGameViewportClient)

void URogueGameViewportClient::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	if (USignificanceManager* SignificanceManager = USignificanceManager::Get(World))
	{
		// Iterate all playercontrollers, for hosting player this means all clients too
		// Helps keeping significance in sync between each client and server
		// ** Main desync issue right now could be WasRecentlyRendered which isn't going to be replicated on the host **
		ViewpointsArray.Empty(GetWorld()->GetNumPlayerControllers());
		for( FConstPlayerControllerIterator Iterator = GetWorld()->GetPlayerControllerIterator(); Iterator; ++Iterator)
		{
			APlayerController* PlayerController = Iterator->Get();

			FVector ViewLocation;
			FRotator ViewRotation;
			PlayerController->GetPlayerViewPoint(ViewLocation, ViewRotation);

			ViewpointsArray.Add(FTransform(ViewRotation, ViewLocation, FVector::OneVector));
		}
		
		SignificanceManager->Update(ViewpointsArray);
	}
}

```

`Source/ActionRoguelike/Core/RogueGameViewportClient.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/GameViewportClient.h"
#include "RogueGameViewportClient.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueGameViewportClient : public UGameViewportClient
{
	GENERATED_BODY()
	
	virtual void Tick(float DeltaTime) override;

	TArray<FTransform> ViewpointsArray;
	
};

```

`Source/ActionRoguelike/Core/RogueGameplayFunctionLibrary.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Core/RogueGameplayFunctionLibrary.h"

#include "ActionRoguelike.h"
#include "ShaderPipelineCache.h"
#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"
#include "ActionSystem/RogueActionSystemInterface.h"
#include "Engine/OverlapResult.h"
#include "Kismet/GameplayStatics.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueGameplayFunctionLibrary)


URogueActionComponent* URogueGameplayFunctionLibrary::GetActionComponentFromActor(AActor* FromActor)
{
	if (FromActor == nullptr)
	{
		// ...could easily pass in nullptr from Blueprint
		UE_LOG(LogGame, Warning, TEXT("Attempting to get Action Component from nullptr Actor."));
		return nullptr;
	}
	
	// Note: Cast<T> on interface only works if the interface was implemented on the Actor in C++
	// For BP implemented we should change this code to call Execute_GetActionComponent instead...
	const IRogueActionSystemInterface* ASI = Cast<IRogueActionSystemInterface>(FromActor);
	if (ASI)
	{
		return ASI->GetActionComponent();
	}
	/*if (InActor && InActor->Implements<URogueGameplayInterface>()) // example reference for a BP interface
	{
		URogueActionComponent* ActionComp = nullptr;
		if (IRogueGameplayInterface::Execute_GetActionComponent(InActor, ActionComp))
		{
			return ActionComp;
		}
	}*/

	// Fallback when interface is missing
	return FromActor->FindComponentByClass<URogueActionComponent>();
}

bool URogueGameplayFunctionLibrary::IsAlive(AActor* InActor)
{
	// Allow nullptr as BP may pass in non exist
	if (!IsValid(InActor))
	{
		UE_LOG(LogGame, Warning, TEXT("Checking IsAlive on invalid or nullptr Actor: %s"), *GetNameSafe(InActor));
		return false;
	}
	
	URogueActionComponent* ActionComp = GetActionComponentFromActor(InActor);
	check(ActionComp);

	FRogueAttribute* FoundAttribute = ActionComp->GetAttribute(SharedGameplayTags::Attribute_Health);
	check(FoundAttribute);
		
	return FoundAttribute->GetValue() > 0.0f;
}


bool URogueGameplayFunctionLibrary::KillActor(AActor* InActor)
{
	URogueActionComponent* ActionComp = URogueActionComponent::GetActionComponent(InActor);
	const FRogueAttribute* HealthMaxAttribute = ActionComp->GetAttribute(SharedGameplayTags::Attribute_HealthMax);
	
	return ActionComp->ApplyAttributeChange(SharedGameplayTags::Attribute_Health, -HealthMaxAttribute->GetValue(),
		InActor, EAttributeModifyType::AddBase);
}


bool URogueGameplayFunctionLibrary::IsFullHealth(AActor* InActor)
{
	URogueActionComponent* ActionComp = URogueActionComponent::GetActionComponent(InActor);

	const FRogueAttribute* HealthAttribute = ActionComp->GetAttribute(SharedGameplayTags::Attribute_Health);
	const FRogueAttribute* HealthMaxAttribute = ActionComp->GetAttribute(SharedGameplayTags::Attribute_HealthMax);

	return HealthAttribute->GetValue() >= HealthMaxAttribute->GetValue();
}


bool URogueGameplayFunctionLibrary::ApplyDamage(AActor* DamageCauser, AActor* TargetActor, float DamageCoefficient, FGameplayTagContainer InContextTags)
{
	if (!CanApplyDamage(DamageCauser, TargetActor))
	{
		return false;
	}
	
	URogueActionComponent* InstigatorComp = GetActionComponentFromActor(DamageCauser);
	// Blueprint might be missing the component for now
	if (InstigatorComp == nullptr)
	{
		UE_LOG(LogGame, Warning, TEXT("Actor (%s) has no ActionComponent."), *DamageCauser->GetName());
		return false;
	}

	FRogueAttribute* FoundAttribute = InstigatorComp->GetAttribute(SharedGameplayTags::Attribute_AttackDamage);
	// We might not have implemented the new attributes on every actor yet.
	if (FoundAttribute == nullptr)
	{
		// "LOGFMT" example
		UE_LOGFMT(LogGame, Warning, "Actor ({DamageCauser}) has no AttackDamage attribute.",
			("DamageCauser", DamageCauser->GetName()));
		return false;
	}

	// Coefficient is a %, to scale all out damage off the instigator's base attack damage
	float TotalDamage = FoundAttribute->GetValue() * (DamageCoefficient*0.01f);

	URogueActionComponent* VictimComp = GetActionComponentFromActor(TargetActor);
	if (VictimComp == nullptr)
	{
		UE_LOG(LogGame, Warning, TEXT("ApplyDamage Victim (%s) does not contain an ActionComponent."), *GetNameSafe(TargetActor));
		return false;
	}

	FAttributeModification AttriMod = FAttributeModification(
		SharedGameplayTags::Attribute_Health,
		-TotalDamage, // Make sure we apply a negative amount to the Health
		VictimComp,
		DamageCauser,
		EAttributeModifyType::AddBase,
		InContextTags);

	VictimComp->ApplyAttributeChange(AttriMod);
	return true;
}


bool URogueGameplayFunctionLibrary::ApplyDirectionalDamage(AActor* DamageCauser, AActor* TargetActor, float DamageCoefficient, const FHitResult& HitResult, FGameplayTagContainer InContextTags)
{
	if (!CanApplyDamage(DamageCauser, TargetActor))
	{
		return false;
	}
	
	if (ApplyDamage(DamageCauser, TargetActor, DamageCoefficient, InContextTags))
	{
		UPrimitiveComponent* HitComp = HitResult.GetComponent();
		if (HitComp->bApplyImpulseOnDamage && HitComp->IsSimulatingPhysics(HitResult.BoneName))
		{
			// Direction = Target - Origin
			FVector Direction = HitResult.TraceEnd - HitResult.TraceStart;
			Direction.Normalize();

			// @todo: allow configuration for impulse strength
			HitComp->AddImpulseAtLocation(Direction * 30000.f, HitResult.ImpactPoint, HitResult.BoneName);
		}
		return true;
	}

	return false;
}

bool URogueGameplayFunctionLibrary::CanApplyDamage(AActor* DamageCauser, AActor* TargetActor, FGameplayTagContainer InContextTags)
{
	// @todo: verify if damagecauser (aka instigator on projectiles) isnt sometimes nullptr on clients
	check(DamageCauser);
	check(IsValid(TargetActor));
	
	return TargetActor->CanBeDamaged();
}

/*
bool URogueGameplayFunctionLibrary::ApplyRadialDamage(AActor* DamageCauser, FVector Origin, float DamageRadius, float DamageCoefficient)
{
	UWorld* World = DamageCauser->GetWorld();
	// do async overlap to find list of potential victims
	// only test for actors with action component / or gameobject interface
	// 2nd pass is another async trace for occlusion tests (optional)
	// GameObject interface: GetDamageTraceLocations(TArray<FVector>& OutLocations);
	// allow objects or pawns to specify which locations they want to use for occlusion tests, for example
	// head, spine, hands, legs on a character
	// for large and oddly shapes objects, it can also use "nearest collision point" from origin rather than the actor location

	FCollisionShape Shape;
	Shape.SetSphere(DamageRadius);

	FCollisionQueryParams Params;
	//Params.MobilityType = EQueryMobilityType::Dynamic;

	FCollisionResponseParams ResponseParams;
*/
	/*
	FOverlapDelegate* Delegate;
	Delegate->BindLambda([](const FTraceHandle& Handle, FOverlapDatum& Datum)
		{
			// ... called when ready
		});*/

	//FTraceHandle Handle; // @todo: can pass in additional params here if needed for multi-pass stuff
	// @todo:need to pass "this", which wont work in static function
/*
	// Fill any useful dmg info
	FDamageInfo Info;
	Info.DamageInstigator = DamageCauser;
	Info.AttackDamage = 0.0f; // InstigatorDmg * (DamageCoefficient*0.01f)
	
	FOverlapDelegate Delegate = FOverlapDelegate::CreateUObject(this, &URogueGameplayFunctionLibrary::OnDamageOverlapComplete, Info);

	World->AsyncOverlapByChannel(Origin, FQuat::Identity, COLLISION_PROJECTILE,
		Shape, Params, ResponseParams, &Delegate);



	return false;
}
*/

/*	
void URogueGameplayFunctionLibrary::OnDamageOverlapComplete(const FTraceHandle& TraceHandle, FOverlapDatum& OverlapDatum, FDamageInfo DamageInfo)
{
	// if second pass w/ line traces is async too, we are two frames 'behind' the initial request for damage.

	// @todo: iterate the victims to apply damage: OverlapDatum.OutOverlaps

	check(DamageInfo.DamageInstigator.Get());

	for (FOverlapResult& Overlap : OverlapDatum.OutOverlaps)
	{
		ApplyDamage(DamageInfo.DamageInstigator.Get(), Overlap.GetActor(), DamageInfo.AttackDamage);
	}
}
*/

int32 URogueGameplayFunctionLibrary::GetRemainingBundledPSOs()
{
	// Counts Bundled PSOs remaining, exposed for UI access
	return FShaderPipelineCache::NumPrecompilesRemaining();
}

```

`Source/ActionRoguelike/Core/RogueGameplayFunctionLibrary.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "RogueGameplayFunctionLibrary.generated.h"


class URogueActionComponent;

USTRUCT()
struct FDamageInfo
{
	GENERATED_BODY()

	TWeakObjectPtr<AActor> DamageInstigator;

	float AttackDamage;
};

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueGameplayFunctionLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
	
public:

	UFUNCTION(BlueprintCallable, Category=Gameplay)
	static URogueActionComponent* GetActionComponentFromActor(AActor* FromActor);

	UFUNCTION(BlueprintCallable, Category=Gameplay)
	static bool IsAlive(AActor* InActor);

	UFUNCTION(BlueprintCallable, Category=Gameplay)
	static bool KillActor(AActor* InActor);

	static bool IsFullHealth(AActor* InActor);

	UFUNCTION(BlueprintCallable, Category=Gameplay)
	static bool ApplyDamage(AActor* DamageCauser, AActor* TargetActor, float DamageCoefficient, FGameplayTagContainer InContextTags = FGameplayTagContainer());

	UFUNCTION(BlueprintCallable, Category=Gameplay)
	static bool ApplyDirectionalDamage(AActor* DamageCauser, AActor* TargetActor, float DamageCoefficient, const FHitResult& HitResult, FGameplayTagContainer InContextTags = FGameplayTagContainer());

	UFUNCTION(BlueprintCallable, Category=Gameplay)
	static bool CanApplyDamage(AActor* DamageCauser, AActor* TargetActor, FGameplayTagContainer InContextTags = FGameplayTagContainer());

	//static bool ApplyRadialDamage(AActor* DamageCauser, FVector Origin, float DamageRadius, float DamageCoefficient);

	//void OnDamageOverlapComplete(const FTraceHandle& TraceHandle, FOverlapDatum& OverlapDatum, FDamageInfo DamageInfo);
	
	UFUNCTION(BlueprintPure, Category = "PSO Caching")
	static int32 GetRemainingBundledPSOs();
};

```

`Source/ActionRoguelike/Core/RogueGameplayInterface.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueGameplayInterface.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueGameplayInterface)

// Add default functionality here for any IRogueGameplayInterface functions that are not pure virtual.

```

`Source/ActionRoguelike/Core/RogueGameplayInterface.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "RogueGameplayInterface.generated.h"

class URogueActionComponent;
// This class does not need to be modified.
UINTERFACE(MinimalAPI)
class URogueGameplayInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class ACTIONROGUELIKE_API IRogueGameplayInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
public:

	/* Called after the Actor state was restored from a SaveGame file. */
	UFUNCTION(BlueprintNativeEvent)
	void OnActorLoaded();

	UFUNCTION(BlueprintCallable, BlueprintNativeEvent)
	FText GetInteractText(AController* InstigatorController);

	UFUNCTION(BlueprintCallable, BlueprintNativeEvent)
	void Interact(AController* InstigatorController);
};

```

`Source/ActionRoguelike/Core/RogueLoadingScreenSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Core/RogueLoadingScreenSubsystem.h"
#include "MoviePlayer.h"


void URogueLoadingScreenSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	// Show simple loading screen when transitioning between maps
	if (!IsRunningDedicatedServer())
	{
		FCoreUObjectDelegates::PreLoadMap.AddUObject(this, &URogueLoadingScreenSubsystem::BeginLoadingScreen);
		FCoreUObjectDelegates::PostLoadMapWithWorld.AddUObject(this, &URogueLoadingScreenSubsystem::EndLoadingScreen);
	}
}


void URogueLoadingScreenSubsystem::BeginLoadingScreen(const FString& MapName)
{
	FLoadingScreenAttributes LoadingScreen;
	//LoadingScreen.bAutoCompleteWhenLoadingCompletes = false;
	//LoadingScreen.bWaitForManualStop = true;
	LoadingScreen.WidgetLoadingScreen = FLoadingScreenAttributes::NewTestLoadingScreenWidget();

	GetMoviePlayer()->SetupLoadingScreen(LoadingScreen);
}


void URogueLoadingScreenSubsystem::EndLoadingScreen(UWorld* InLoadedWorld)
{
	
}

```

`Source/ActionRoguelike/Core/RogueLoadingScreenSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "RogueLoadingScreenSubsystem.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueLoadingScreenSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()

	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

protected:

	void BeginLoadingScreen(const FString& MapName);

	void EndLoadingScreen(UWorld* InLoadedWorld);
};

```

`Source/ActionRoguelike/Core/RogueMessagingSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueMessagingSubsystem.h"



void URogueMessagingSubsystem::AddTagListener(FGameplayTag InTag, FOnMessageReceived InEventHook)
{
	FMessageTagListener& Value = TagListeners.FindOrAdd(InTag);
	Value.Listeners.Add(InEventHook);
}


void URogueMessagingSubsystem::BroadcastTag(FGameplayTag InTag, FInstancedStruct InPayload)
{
	if (FMessageTagListener* Value = TagListeners.Find(InTag))
	{
		for (FOnMessageReceived Delegate : Value->Listeners)
		{
			bool bBound = Delegate.ExecuteIfBound(InTag, InPayload);

			// Needs cleanup if no longer bound
			check(bBound);
		}
	}
}

template <typename FMessageStructType>
void URogueMessagingSubsystem::BroadcastTagNative(FGameplayTag InTag, const FMessageStructType& Message)
{
	FInstancedStruct InstStruct;
	InstStruct.InitializeAs<FMessageStructType>(Message);

	BroadcastTag(InTag, InstStruct);
}
```

`Source/ActionRoguelike/Core/RogueMessagingSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameplayTagContainer.h"
#include "StructUtils/InstancedStruct.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "RogueMessagingSubsystem.generated.h"


#define USE_TAGMESSAGING_SYSTEM 0

DECLARE_DYNAMIC_DELEGATE_TwoParams(FOnMessageReceived, FGameplayTag, InMessageTag, FInstancedStruct, Payload);

/*
 * Wrapper - to support array inside TMap
 */
USTRUCT()
struct FMessageTagListener
{
	GENERATED_BODY()

	//FGameplayTag Tag;
	TArray<FOnMessageReceived> Listeners;
};


USTRUCT(BlueprintType)
struct FPayLoadTestMessage
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	float Credits = 0.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	AActor* VictimActor = nullptr;
};

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueMessagingSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()

public:
	
	UFUNCTION(BlueprintCallable)
	void AddTagListener(FGameplayTag InTag, FOnMessageReceived InEventHook);

	// @todo: RemoveTagListener()

	/* 
	 * Broadcast Message using whatever struct payload we may need.
	 * Look at UBlueprintInstancedStructLibrary::MakeInstancedStruct to implement this with CustomThunk to simplify its usage in blueprint.
	 */
	UFUNCTION(BlueprintCallable)
	void BroadcastTag(FGameplayTag InTag, FInstancedStruct InPayload);

	template <typename FMessageStructType>
	void BroadcastTagNative(FGameplayTag InTag, const FMessageStructType& Message);
	//void BroadcastTagNative(FGameplayTag InTag, const FPayLoadTestMessage& Message);

protected:
	
	TMap<FGameplayTag, FMessageTagListener> TagListeners;
};


```

`Source/ActionRoguelike/Core/RogueMonsterData.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueMonsterData.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueMonsterData)
```

`Source/ActionRoguelike/Core/RogueMonsterData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "RogueMonsterData.generated.h"

class URogueAction;

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueMonsterData : public UPrimaryDataAsset
{
	GENERATED_BODY()
	
public:

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Spawn Info")
	TSubclassOf<AActor> MonsterClass;

	/* Actions/buffs to grant this Monster */
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Spawn Info")
	TArray<TSubclassOf<URogueAction>> Actions;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "UI")
	TObjectPtr<UTexture2D> Icon;

	virtual FPrimaryAssetId GetPrimaryAssetId() const override
	{
		return FPrimaryAssetId("Monsters", GetFName());
	}
};

```

`Source/ActionRoguelike/Development/RogueCheatManager.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Development/RogueCheatManager.h"

#include "EngineUtils.h"
#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"
#include "SaveSystem/RogueSaveGameSettings.h"
#include "AI/RogueAICharacter.h"
#include "Core/RogueGameplayFunctionLibrary.h"
#include "Kismet/GameplayStatics.h"


void URogueCheatManager::HealSelf(float Amount /* = 100 */)
{
	APlayerController* MyPC = GetOuterAPlayerController();

	if (APawn* MyPawn = MyPC->GetPawn())
	{
		URogueActionComponent* ActionComp = URogueActionComponent::GetActionComponent(MyPawn);
		ActionComp->ApplyAttributeChange(SharedGameplayTags::Attribute_Health, Amount, MyPawn, EAttributeModifyType::AddBase);
	}
}


void URogueCheatManager::KillAll()
{
	for (ARogueAICharacter* Bot : TActorRange<ARogueAICharacter>(GetWorld()))
	{
		URogueGameplayFunctionLibrary::KillActor(Bot);
	}
}


void URogueCheatManager::DeleteSaveGame()
{
	const URogueSaveGameSettings* SGSettings = GetDefault<URogueSaveGameSettings>();
	UGameplayStatics::DeleteGameInSlot(SGSettings->SaveSlotName, 0);
}

```

`Source/ActionRoguelike/Development/RogueCheatManager.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/CheatManager.h"
#include "RogueCheatManager.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueCheatManager : public UCheatManager
{
	GENERATED_BODY()

	
	UFUNCTION(Exec, BlueprintAuthorityOnly)
	void HealSelf(float Amount = 100);
	
	UFUNCTION(Exec, BlueprintAuthorityOnly)
	void KillAll();
	
	UFUNCTION(Exec)
	void DeleteSaveGame();

};

```

`Source/ActionRoguelike/Development/RogueDeveloperLocalSettings.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Development/RogueDeveloperLocalSettings.h"

#include "Misc/ConfigUtilities.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueDeveloperSettings)

#if !UE_BUILD_SHIPPING
namespace DevelopmentOnly
{
	static bool bDisableSpawnBotsOverride = false;
	static FAutoConsoleVariableRef CVarSpawnBotsOverride(
	TEXT("game.DisableBotSpawning"),
	bDisableSpawnBotsOverride,
	TEXT("Disable spawning of bots for development only."));

}

#endif


FName URogueDeveloperLocalSettings::GetCategoryName() const
{
	return FApp::GetProjectName();
}


void URogueDeveloperLocalSettings::PostInitProperties()
{
#if WITH_EDITOR
	if (IsTemplate())
	{
		// We want the .ini file to have precedence over the CVar constructor, so we apply the ini to the CVar before following the regular UDeveloperSettingsBackedByCVars flow
		UE::ConfigUtilities::ApplyCVarSettingsFromIni(TEXT("/Script/ActionRoguelike.RogueDeveloperSettings"), *GEditorPerProjectIni, ECVF_SetByProjectSetting);
	}
#endif // WITH_EDITOR

	Super::PostInitProperties();
}
```

`Source/ActionRoguelike/Development/RogueDeveloperLocalSettings.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DeveloperSettingsBackedByCVars.h"
#include "RogueDeveloperLocalSettings.generated.h"


/**
 * Place for Development Only configuration AND only stored via local INI files.
 */
UCLASS(Config=EditorPerProjectUserSettings)
class ACTIONROGUELIKE_API URogueDeveloperLocalSettings : public UDeveloperSettingsBackedByCVars
{
	GENERATED_BODY()

public:

	UPROPERTY(config, EditDefaultsOnly, Category = ActionRoguelike, meta = (ConsoleVariable = "game.DisableBotSpawning"))
	bool bDisableSpawnBotsOverride;

	virtual void PostInitProperties() override;
	
	virtual FName GetCategoryName() const override;
};

```

`Source/ActionRoguelike/Performance/RogueActorPoolingInterface.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueActorPoolingInterface.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueActorPoolingInterface)

// Add default functionality here for any IRogueActorPoolingInterface functions that are not pure virtual.

```

`Source/ActionRoguelike/Performance/RogueActorPoolingInterface.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "RogueActorPoolingInterface.generated.h"

// This class does not need to be modified.
UINTERFACE(MinimalAPI)
class URogueActorPoolingInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class ACTIONROGUELIKE_API IRogueActorPoolingInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
public:

	UFUNCTION(BlueprintNativeEvent)
	void PoolBeginPlay();

	UFUNCTION(BlueprintNativeEvent)
	void PoolEndPlay();
};

```

`Source/ActionRoguelike/Performance/RogueActorPoolingSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Performance/RogueActorPoolingSubsystem.h"

#include "ActionRoguelike.h"
#include "RogueActorPoolingInterface.h"
#include "Logging/StructuredLog.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueActorPoolingSubsystem)


static TAutoConsoleVariable CVarActorPoolingEnabled(
	TEXT("game.ActorPooling"),
	false, // Disabled by default in sample project. Has some issues to work out (such as properly resetting all VFX like the black hole projectile)
	TEXT("Enable actor pooling for selected objects."),
	ECVF_Default);


AActor* URogueActorPoolingSubsystem::SpawnActorPooled(const UObject* WorldContextObject, TSubclassOf<AActor> ActorClass, const FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod SpawnHandling)
{
	FActorSpawnParameters Params;
	Params.SpawnCollisionHandlingOverride = SpawnHandling;
	
	return AcquireFromPool(WorldContextObject, ActorClass, SpawnTransform, Params);
}

bool URogueActorPoolingSubsystem::ReleaseToPool(AActor* Actor)
{
	if (IsPoolingEnabled(Actor))
	{
		URogueActorPoolingSubsystem* PoolingSubsystem = Actor->GetWorld()->GetSubsystem<URogueActorPoolingSubsystem>();
		return PoolingSubsystem->ReleaseToPool_Internal(Actor);
	}

	SCOPED_NAMED_EVENT(DestroyActorNoPool, FColor::Red);
	Actor->Destroy();
	return false;
}


AActor* URogueActorPoolingSubsystem::AcquireFromPool(const UObject* WorldContextObject, TSubclassOf<AActor> ActorClass, const FTransform& SpawnTransform, FActorSpawnParameters SpawnParams)
{
	if (IsPoolingEnabled(WorldContextObject))
	{
		URogueActorPoolingSubsystem* PoolingSystem = WorldContextObject->GetWorld()->GetSubsystem<URogueActorPoolingSubsystem>();
		return PoolingSystem->AcquireFromPool_Internal(ActorClass, SpawnTransform, SpawnParams);
	}
	
	SCOPED_NAMED_EVENT(SpawnActorNoPool, FColor::Red);
	// Fallback to standard spawning when not enabled
	return WorldContextObject->GetWorld()->SpawnActor<AActor>(ActorClass, SpawnTransform, SpawnParams);
}


bool URogueActorPoolingSubsystem::IsPoolingEnabled(const UObject* WorldContextObject)
{
	return CVarActorPoolingEnabled.GetValueOnAnyThread() && WorldContextObject->GetWorld()->IsNetMode(NM_Standalone);
}

void URogueActorPoolingSubsystem::PrimeActorPool(TSubclassOf<AActor> ActorClass, int32 Amount)
{
	UE_LOGFMT(LogGame, Log, "Priming Pool for {actorclass} ({amount})", GetNameSafe(ActorClass), Amount);
	SCOPED_NAMED_EVENT(PrimeActorPool, FColor::Blue);
	
	// Prime a set number of pooled actors, this reduces memory fragmentation and any potential initial hitches during gameplay
	for (int i = 0; i < Amount; ++i)
	{
		FActorSpawnParameters Params;
		Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

		// @fixme: this can trigger an overlap when spawned, for example in empty level it may overlap SpectatorPawn in world zero
		// ideally we can prevent the projectile from fully activating to avoid this overlap
		AActor* NewActor = GetWorld()->SpawnActor<AActor>(ActorClass, FTransform::Identity, Params);

		ReleaseToPool(NewActor);
	}
}


bool URogueActorPoolingSubsystem::ReleaseToPool_Internal(AActor* Actor)
{
	SCOPED_NAMED_EVENT(ReleaseActorToPool, FColor::White);
	check(IsValid(Actor));

	// These are assumed not used by game code
	Actor->SetActorEnableCollision(false);
	Actor->SetActorHiddenInGame(true);

	Actor->RouteEndPlay(EEndPlayReason::Destroyed);

	IRogueActorPoolingInterface::Execute_PoolEndPlay(Actor);

	// Place in the pool for later use
	FActorPool* ActorPool = &AvailableActorPool.FindOrAdd(Actor->GetClass());
	ActorPool->FreeActors.Add(Actor);

	return true;
}


AActor* URogueActorPoolingSubsystem::AcquireFromPool_Internal(TSubclassOf<AActor> ActorClass, const FTransform& SpawnTransform, FActorSpawnParameters SpawnParams)
{
	SCOPED_NAMED_EVENT(AcquireActorFromPool, FColor::White);
	
	AActor* AcquiredActor = nullptr;

	FActorPool* ActorPool = &AvailableActorPool.FindOrAdd(ActorClass);
	// Grab first available
	if (ActorPool->FreeActors.IsValidIndex(0))
	{
		UE_LOGFMT(LogGame, Log, "Acquired Actor for {actorclass} from pool", GetNameSafe(ActorClass));
		
		AcquiredActor = ActorPool->FreeActors[0];

		// Remove from pool
		// @todo: keep in pool but mark as in-use
		ActorPool->FreeActors.RemoveAtSwap(0, 1, EAllowShrinking::No);
	}

	// Failed to find actor
	if (AcquiredActor == nullptr)
	{
		UE_LOGFMT(LogGame, Log, "Actor Pool empty, spawning new Actor for {actorclass}", GetNameSafe(ActorClass));
		
		// Spawn fresh instance that can eventually be release to the pool
		return GetWorld()->SpawnActor<AActor>(ActorClass, SpawnTransform, SpawnParams);
	}
	
	AcquiredActor->SetActorTransform(SpawnTransform);
	AcquiredActor->SetInstigator(SpawnParams.Instigator);
	AcquiredActor->SetOwner(SpawnParams.Owner);

	// These are assumed not used by game code
	AcquiredActor->SetActorEnableCollision(true);
	AcquiredActor->SetActorHiddenInGame(false);

	AcquiredActor->DispatchBeginPlay();
	
	IRogueActorPoolingInterface::Execute_PoolBeginPlay(AcquiredActor);

	return AcquiredActor;
}

```

`Source/ActionRoguelike/Performance/RogueActorPoolingSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "RogueActorPoolingSubsystem.generated.h"

USTRUCT()
struct FActorPool
{
	GENERATED_BODY()

	UPROPERTY()
	TArray<TObjectPtr<AActor>> FreeActors;
};

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueActorPoolingSubsystem : public UWorldSubsystem
{
	GENERATED_BODY()

public:

	UFUNCTION(BlueprintCallable, Category= "Actor Pooling", meta = (WorldContext="WorldContextObject"))
	static AActor* SpawnActorPooled(const UObject* WorldContextObject, TSubclassOf<AActor> ActorClass, const FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod SpawnHandling);

	static bool ReleaseToPool(AActor* Actor);
	
	static AActor* AcquireFromPool(const UObject* WorldContextObject, TSubclassOf<AActor> ActorClass, const FTransform& SpawnTransform, FActorSpawnParameters SpawnParams);

	static bool IsPoolingEnabled(const UObject* WorldContextObject);

	void PrimeActorPool(TSubclassOf<AActor> ActorClass, int32 Amount);

protected:
	
	AActor* AcquireFromPool_Internal(TSubclassOf<AActor> ActorClass, const FTransform& SpawnTransform, FActorSpawnParameters SpawnParams);

	bool ReleaseToPool_Internal(AActor* Actor);

protected:

	/* Holds collection of available Actors, stored per class */
	UPROPERTY(Transient)
	TMap<TSubclassOf<AActor>, FActorPool> AvailableActorPool;
};

```

`Source/ActionRoguelike/Performance/RogueSignificanceComponent.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Performance/RogueSignificanceComponent.h"
#include "ActionRoguelike.h"
#include "NiagaraComponent.h"
#include "RogueSignificanceInterface.h"
#include "ParticleHelper.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueSignificanceComponent)

/* Allows us to force significance on all classes to quickly compare the performance differences as if the system was disabled */
static float GForcedSignificance = -1;
static FAutoConsoleVariableRef CVarSignificanceManager_ForceSignificance(
	TEXT("SigMan.ForceSignificance"),
	GForcedSignificance,
	TEXT("Force significance on all managed objects. -1 is default, 0-4 is hidden, lowest, medium, highest.\n"),
	ECVF_Cheat
	);


URogueSignificanceComponent::URogueSignificanceComponent()
{
	PrimaryComponentTick.bCanEverTick = false;
	
	bWaitOneFrame = true;
	bManageSignificance = true;
	bHasImplementedInterface = false;
	bInsignificantWhenOwnerIsHidden = true;
	bManageOwnerParticleSignificance = true;
	CurrentSignificance = ESignificanceValue::Invalid;

	// Adding 0.0/Lowest is optional, anything beyond last entry distance will fallback to Lowest significance
	Thresholds.Emplace(ESignificanceValue::Highest, 5000.f);
}


void URogueSignificanceComponent::BeginPlay()
{
	Super::BeginPlay();

	// Register
	if (bManageSignificance)
	{
		bHasImplementedInterface = GetOwner()->Implements<URogueSignificanceInterface>();

		// Optionally wait one frame
		if (bWaitOneFrame)
		{
			GetWorld()->GetTimerManager().SetTimerForNextTick(this, &URogueSignificanceComponent::RegisterWithManager);
		}
		else
		{
			RegisterWithManager();
		}

		// Manage particle components
		if (bManageOwnerParticleSignificance)
		{
			// @todo: implement niagara FX
		}
	}
}


void URogueSignificanceComponent::RegisterWithManager()
{
	if (USignificanceManager* SignificanceManager = USignificanceManager::Get(GetWorld()))
	{
		auto SignificanceFunc = [&](USignificanceManager::FManagedObjectInfo* ObjectInfo, const FTransform& Viewpoint) -> float
		{
			return CalcSignificance(ObjectInfo, Viewpoint);
		};
		
		auto PostSignificanceFunc = [&](USignificanceManager::FManagedObjectInfo* ObjectInfo, float OldSignificance, float Significance, bool bFinal)
		{
			PostSignificanceUpdate(ObjectInfo, OldSignificance, Significance, bFinal);
		};

		// Register
		// for 'EPostSignificanceType::Concurrent' you need 'thread safe' post significance function
		// our sigman update runs during the game viewport update tick, so it should *probably* be ok so long as no other non-GT logic is interacting with the objects.
		FName Tag = GetOwner()->GetClass()->GetFName();
		SignificanceManager->RegisterObject(this, Tag, SignificanceFunc, USignificanceManager::EPostSignificanceType::Concurrent, PostSignificanceFunc);
	}
}


void URogueSignificanceComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	if (bManageSignificance)
	{
		// Unregister
		if (USignificanceManager* SignificanceManager = USignificanceManager::Get(GetWorld()))
		{
			SignificanceManager->UnregisterObject(this);
		}
	}
	
	Super::EndPlay(EndPlayReason);
}


float URogueSignificanceComponent::CalcSignificance(USignificanceManager::FManagedObjectInfo* ObjectInfo,	const FTransform& Viewpoint) const
{
	if (GForcedSignificance >= 0.0f)
	{
		return GForcedSignificance;
	}
	
	if (bInsignificantWhenOwnerIsHidden && GetOwner()->IsHidden())
	{
		return static_cast<float>(ESignificanceValue::Hidden);
	}

	// Use Actor implemented override if present
	if (bHasImplementedInterface)
	{
		float Significance = 0.0f;
		if (IRogueSignificanceInterface::Execute_CalcSignificanceOverride(GetOwner(), Significance))
		{
			return Significance;
		}
	}

	FVector OriginLocation = GetOwner()->GetActorLocation();
	if (bHasImplementedInterface)
	{
		FVector OverriddenOrigin = FVector::ZeroVector;
		if (IRogueSignificanceInterface::Execute_GetSignificanceLocation(GetOwner(), Viewpoint, OverriddenOrigin))
		{
			OriginLocation = OverriddenOrigin;
		}
	}
	
	const float DistanceSqrd = (OriginLocation - Viewpoint.GetLocation()).SizeSquared();
	return GetSignificanceByDistance(DistanceSqrd);
}


void URogueSignificanceComponent::PostSignificanceUpdate(USignificanceManager::FManagedObjectInfo* ObjectInfo, float OldSignificance, float Significance, bool bFinal)
{
	if (OldSignificance == Significance)
	{
		// disabled to run cascade update every frame (for now)
		//return;
	}

	if (Significance != OldSignificance || CurrentSignificance == ESignificanceValue::Invalid)
	{
		CurrentSignificance = static_cast<ESignificanceValue>(Significance);
		UE_LOGFMT(LogGame, Log, "Significance for {owner} changed to {significance}", GetNameSafe(GetOwner()), UEnum::GetValueAsString(CurrentSignificance));
		OnSignificanceChanged.Broadcast(CurrentSignificance);
	}

	// Running this every frame for now (commented out the above early out) as otherwise we can't properly cull the cascade VFX (to be re-worked later)
	if (!bManageOwnerParticleSignificance)
	{
		UpdateParticleSignificance(Significance);
	}
}


float URogueSignificanceComponent::GetSignificanceByDistance(float DistanceSqrd) const
{
	const int32 NumThresholds = Thresholds.Num();
	if (NumThresholds == 0)
	{
		UE_LOGFMT(LogGame, Warning, "SignificanceManager: No distance thresholds set in {owner}.", GetNameSafe(GetOwner()));
		return static_cast<float>(ESignificanceValue::Highest);
	}

	// @todo: implement dist multiplier for even better tweaking
	if (DistanceSqrd >= Thresholds[NumThresholds-1].GetMaxDistSqrd())
	{
		// Max distance reached assume lowest significance
		return static_cast<float>(ESignificanceValue::Lowest);
	}

	for (int32 Idx = 0; Idx < NumThresholds; Idx++)
	{
		const FSignificanceDistance& Item = Thresholds[Idx];
		if (DistanceSqrd <= (Item.GetMaxDistSqrd()))
		{
			return static_cast<float>(Item.Significance);
		}
	}
	
	return static_cast<float>(ESignificanceValue::Highest);
}


void URogueSignificanceComponent::UpdateParticleSignificance(float NewSignificance)
{
	// Niagara Particle Systems
	// @todo: we don't need to call into niagara, the EffectType significance handler can do this for us...
	/*TArray<UNiagaraComponent*> NiagaraSystems;
	GetOwner()->GetComponents<UNiagaraComponent>(NiagaraSystems);

	for (UNiagaraComponent* Comp : NiagaraSystems)
	{
		// Niagara uses 'int32 index' to set significance, you should map this with the input "float NewSignificance" (eg. not something between 0.0-1.0 as it gets rounded)
		
		Comp->SetSystemSignificanceIndex(NewSignificance);
	}*/
}

```

`Source/ActionRoguelike/Performance/RogueSignificanceComponent.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "SignificanceManager.h"
#include "Components/ActorComponent.h"
#include "RogueSignificanceComponent.generated.h"


UENUM(BlueprintType)
enum class ESignificanceValue : uint8
{
	// Special tier while owning Actor is hidden
	Hidden = 0, 
	// Assumed very far away
	Lowest = 1, 
	// no longer critical
	Medium = 2,
	// Max fidelity, No throttling/culling
	Highest = 3,
	// not yet defined, good starting position
	Invalid = UINT8_MAX 
};

// Trigger only when significance has changed
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPostSignificanceChanged, ESignificanceValue, Significance);

/* Configure mapping between Significance and Distance to. While distance from viewpoint is within "MaxDistance" the specified "Significance" will be used. */
USTRUCT(BlueprintType)
struct FSignificanceDistance
{
	GENERATED_BODY()

	FSignificanceDistance()
	{
		Significance = ESignificanceValue::Highest;
		MaxDistance = 1000.f;
	}
	
	FSignificanceDistance(ESignificanceValue InSignificance, float InMaxDistance) :
		Significance(InSignificance),
		MaxDistance(InMaxDistance) {}

	UPROPERTY(EditAnywhere)
	ESignificanceValue Significance;

	UPROPERTY(EditAnywhere, meta = (UIMin=1000.0, UIMax=50000))
	float MaxDistance;

	float GetMaxDistSqrd() const { return MaxDistance*MaxDistance; }
};

/*
 * Significance Component made entirely for convenience and classes that don't have a C++ Actor base class.
 * To squeeze max. perf out of signifance you may want to skip this component and directly implement the Significance directly as this component essentially demonstrates how.
 * See: RegisterWithManager() on which functions are required to hook yourself up with SignifanceManager.
 */
UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent), HideCategories=("Collision", "Tags", "ComponentTick", "ComponentReplication", "Cooking", "Activation", "AssetUserData") )
class ACTIONROGUELIKE_API URogueSignificanceComponent : public UActorComponent
{
	GENERATED_BODY()
	
	virtual void BeginPlay() override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

public:
	
	/* Register with Significance Manager to optimize ticks/logic (Allows per (child)class / instance opt-out) */
	UPROPERTY(EditAnywhere, Category = "Optimization")
	bool bManageSignificance;
	
	/* MaxDistance per Significance, defaults to 0.0 (lowest) Significance if outside bounds of distances specified here  */
	UPROPERTY(EditAnywhere, meta = (TitleProperty="MaxDistance"))
	TArray<FSignificanceDistance> Thresholds;

	UPROPERTY(Transient, BlueprintReadOnly, Category= "Optimization")
	ESignificanceValue CurrentSignificance;

protected:
	
	/* Considered insignificant (-1.0) while owning Actor is HiddenInGame */
	UPROPERTY(EditAnywhere, Category = "Optimization")
	bool bInsignificantWhenOwnerIsHidden;
	
	/* Delay registration by one tick to allow actors/components to tick once, this may be useful to have them setup VFX beams etc. before pausing them due to low significance */
	UPROPERTY(EditDefaultsOnly, Category = "Optimization")
	bool bWaitOneFrame;

	UPROPERTY(EditDefaultsOnly, Category = "Optimization")
	bool bManageOwnerParticleSignificance;

	bool bHasImplementedInterface;

	UFUNCTION()
	void RegisterWithManager();

	float CalcSignificance(USignificanceManager::FManagedObjectInfo* ObjectInfo, const FTransform& Viewpoint) const;
	
	void PostSignificanceUpdate(USignificanceManager::FManagedObjectInfo* ObjectInfo, float OldSignificance, float Significance, bool bFinal);

	float GetSignificanceByDistance(float DistanceSqrd) const;

	void UpdateParticleSignificance(float NewSignificance);

public:
	
	UPROPERTY(BlueprintAssignable)
	FOnPostSignificanceChanged OnSignificanceChanged;

	URogueSignificanceComponent();
};

```

`Source/ActionRoguelike/Performance/RogueSignificanceInterface.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueSignificanceInterface.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueSignificanceInterface)

// Add default functionality here for any IRogueSignificanceInterface functions that are not pure virtual.

```

`Source/ActionRoguelike/Performance/RogueSignificanceInterface.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "RogueSignificanceInterface.generated.h"

// Marked not blueprintable, this lets us use it more easily and hopefully more performant. All usage simply need a base class in C++
UINTERFACE(MinimalAPI/*, meta=(CannotImplementInterfaceInBlueprint)*/)
class URogueSignificanceInterface : public UInterface
{
	GENERATED_BODY()
};

/**
 * 
 */
class ACTIONROGUELIKE_API IRogueSignificanceInterface
{
	GENERATED_BODY()

	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
public:

	virtual void SignificanceLODChanged(int32 NewLOD) = 0;
	
	
	UFUNCTION(BlueprintNativeEvent, Category = "Significance")
	bool GetSignificanceLocation(FTransform Viewpoint, FVector& OutLocation);

	UFUNCTION(BlueprintNativeEvent, Category = "Significance")
	bool CalcSignificanceOverride(float& OutSignificance);
	
};

```

`Source/ActionRoguelike/Performance/RogueSignificanceManager.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueSignificanceManager.h"
#include "RogueSignificanceInterface.h"
#include "RogueSignificanceSettings.h"


void URogueSignificanceManager::Update(TArrayView<const FTransform> InViewpoints)
{
	// Base calculates and sorts the significance
	Super::Update(InViewpoints);

	// Fetch Buckets
	const URogueSignificanceSettings* Settings = GetDefault<URogueSignificanceSettings>();

	// Keep the objects that changed LODs this update
	ChangedLODs.Empty(ChangedLODs.Num());

	for (int TagIndex = 0; TagIndex < RegisteredTags.Num(); ++TagIndex)
	{
		const TArray<USignificanceManager::FManagedObjectInfo*>& SortedObjects = GetManagedObjects(RegisteredTags[TagIndex]);
		for (int Index = 0; Index < SortedObjects.Num(); ++Index)
		{
			int32 NewLOD = Settings->GetBucketIndex(RegisteredTags[TagIndex], Index);

			FExtendedManagedObject* ExtObj = static_cast<FExtendedManagedObject*>(SortedObjects[Index]);
			if (ExtObj->LOD != NewLOD)
			{
				ChangedLODs.Add(ExtObj);
				ExtObj->LOD = NewLOD;
			}
		}

		// We can now broadcast LOD changes to individual Actors
		for (FManagedObjectInfo* ObjectInfo : ChangedLODs)
		{
			FExtendedManagedObject* ExtObj = static_cast<FExtendedManagedObject*>(ObjectInfo);

			// We could register components for cache performance, in that case the interface should still be called on the Owning Actor
			UObject* ObjectInst = ObjectInfo->GetObject();
			if (ObjectInfo->GetObject()->IsA(UActorComponent::StaticClass()))
			{
				ObjectInst = CastChecked<UActorComponent>(ObjectInfo->GetObject())->GetOwner();
			}

			IRogueSignificanceInterface* ObjInterface = Cast<IRogueSignificanceInterface>(ObjectInst);
			ObjInterface->SignificanceLODChanged(ExtObj->LOD);
		}
	}
}


void URogueSignificanceManager::RegisterObject(UObject* Object, FName Tag, FManagedObjectSignificanceFunction SignificanceFunction, EPostSignificanceType InPostSignificanceType,
	FManagedObjectPostSignificanceFunction InPostSignificanceFunction)
{
	Super::RegisterObject(Object, Tag, SignificanceFunction, InPostSignificanceType, InPostSignificanceFunction);

	// Bookkeeping for iterating the sorted lists easily
	RegisteredTags.AddUnique(Tag);

	// @todo: verify that there is a bucket available for this "Tag"
	// const URogueSignificanceSettings* Settings = GetDefault<URogueSignificanceSettings>();
}


void URogueSignificanceManager::UnregisterObject(UObject* Object)
{
	Super::UnregisterObject(Object);

	// @todo: Cleanup the RegisteredTags array
}

```

`Source/ActionRoguelike/Performance/RogueSignificanceManager.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "SignificanceManager.h"
#include "RogueSignificanceManager.generated.h"



struct FExtendedManagedObject : USignificanceManager::FManagedObjectInfo
{
public:
	int32 LOD;
};



/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueSignificanceManager : public USignificanceManager
{
	GENERATED_BODY()
	
public:

	virtual void Update(TArrayView<const FTransform> InViewpoints) override;

	virtual void RegisterObject(UObject* Object, FName Tag, FManagedObjectSignificanceFunction SignificanceFunction, EPostSignificanceType InPostSignificanceType = EPostSignificanceType::None,
		FManagedObjectPostSignificanceFunction InPostSignificanceFunction = nullptr) override;

	virtual void UnregisterObject(UObject* Object) override;


protected:

	TArray<FManagedObjectInfo*> ChangedLODs;
	
	TArray<FName> RegisteredTags;
};

```

`Source/ActionRoguelike/Performance/RogueSignificanceSettings.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueSignificanceSettings.h"


namespace SignificanceManager
{
	/* Force significance on all classes to quickly compare the performance differences as if the system was disabled */
	static float ForcedSignificanceBucket = -1;
	static FAutoConsoleVariableRef CVarSignificanceManager_ForceBucket(
		TEXT("SigMan.ForceLOD"),
		ForcedSignificanceBucket,
		TEXT("Force bucket on all managed objects. -1 is default and means disabled, 0 is lowest bucket and means highest fidelity.\n"),
		ECVF_Cheat
		);

	/* Experimental: Resize the buckets based on Scalability setting. Could fit either in ViewDistance or Effect ScalabilityGroups */
	static float SignifanceBucketSizeMultiplier = 1.0;
	static FAutoConsoleVariableRef CVarSignificanceManager_BucketSizeMultiplier(
		TEXT("SigMan.SignificanceBucketSizeMultiplier"),
		SignifanceBucketSizeMultiplier,
		TEXT("Scalability multiplier to change the maximum number of Actors per Bucket.\n"),
		ECVF_Scalability
		);
}


int32 URogueSignificanceSettings::GetBucketIndex(FName InTag, int32 InIndex) const
{
	int32 TotalIndex = 0;

	// Development Only
	if (SignificanceManager::ForcedSignificanceBucket >= 0)
	{
		return SignificanceManager::ForcedSignificanceBucket;
	}

	const FSignificanceBucketInfo* BucketInfo = Buckets.Find(InTag);
	for (int BucketIndex = 0; BucketIndex < BucketInfo->BucketSizes.Num(); ++BucketIndex)
	{
		// Rounding down, not sure which option is best, requires more testing
		TotalIndex += FMath::Floor(BucketInfo->BucketSizes[BucketIndex] * SignificanceManager::SignifanceBucketSizeMultiplier);
		if (InIndex < TotalIndex)
		{
			return BucketIndex;
		}
	}

	// Returns the 'next' bucket (count from zero). With 4 buckets defined in Settings, this is bucket 5 with unlimited size.
	return BucketInfo->BucketSizes.Num();
}

FName URogueSignificanceSettings::GetCategoryName() const
{
	return FApp::GetProjectName();
}

```

`Source/ActionRoguelike/Performance/RogueSignificanceSettings.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DeveloperSettingsBackedByCVars.h"
#include "RogueSignificanceSettings.generated.h"


USTRUCT()
struct FSignificanceBucketInfo
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere)
	TArray<int32> BucketSizes;
};

/**
 * 
 */
UCLASS(Config=Game, defaultconfig, meta = (DisplayName="Rogue Significance Manager")) // 'defaultconfig' = "Save object config only to Default INIs, never to local INIs."
class ACTIONROGUELIKE_API URogueSignificanceSettings : public UDeveloperSettingsBackedByCVars
{
	GENERATED_BODY()

public:

	/*
	 * Return Current Bucket index based on the sorted significance index we pass in and the maximum bucket sizes specified in the Settings. 
	 */
	int32 GetBucketIndex(FName InTag, int32 InIndex) const;

	//~UDeveloperSettings interface
	//virtual void PostInitProperties() override;

	virtual FName GetCategoryName() const override;
	//~End of UDeveloperSettings interface

protected:
	
	UPROPERTY(EditAnywhere, Config)
	TMap<FName, FSignificanceBucketInfo> Buckets;

};

```

`Source/ActionRoguelike/Performance/RogueTickablesSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Performance/RogueTickablesSubsystem.h"

#include "ActionRoguelike.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueTickablesSubsystem)


static TAutoConsoleVariable CVarAggregateTicks(
	TEXT("game.AggregateTicks"),
	true,
	TEXT("Enable aggregate ticking for selected objects. Takes effect on next level load."),
	ECVF_Default);



void FTickablesTickFunction::ExecuteTick(float DeltaTime, ELevelTick TickType, ENamedThreads::Type CurrentThread,
                                         const FGraphEventRef& MyCompletionGraphEvent)
{
	Target->ExecuteTick(TickGroup, DeltaTime, TickType, CurrentThread, MyCompletionGraphEvent);
}


void URogueTickablesSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	// Register for once to tick all components
	// @todo: expand to have one option per tick group


	if (CVarAggregateTicks.GetValueOnGameThread())
	{
		ComponentsTick.bCanEverTick = true;
        ComponentsTick.Target = this;
		ComponentsTick.TickGroup = TG_PrePhysics;
        
        // interesting to try async logic
        ComponentsTick.bRunOnAnyThread = false;
        	
        ComponentsTick.RegisterTickFunction(GetWorld()->PersistentLevel);
	}
}


void URogueTickablesSubsystem::RegisterComponent(FActorComponentTickFunction* TickFunction)
{
	if (CVarAggregateTicks.GetValueOnGameThread())
	{
		// Remove from the standard system
		TickFunction->UnRegisterTickFunction();

		check(!TickableComponents.Contains(TickFunction));
		TickableComponents.Add(TickFunction);
	}
}

void URogueTickablesSubsystem::DeRegisterComponent(FActorComponentTickFunction* TickFunction)
{
	if (CVarAggregateTicks.GetValueOnGameThread())
	{
		// Cleanup
		CleanupQueue.Add(TickFunction);
	}
}


void URogueTickablesSubsystem::ExecuteTick(ETickingGroup TickGroup, float DeltaTime, ELevelTick TickType, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(AggregateComponentTick)
	
	{
		SCOPED_NAMED_EVENT(TickManagedComponents, FColor::Orange);
	
		// @todo: want one of these loops for every class to keep them sorted (otherwise this entire concept of "aggregating ticks" fails)
		// In the example only 1 type of components is ticked here. For multiple types you should store them as discrete lists or sorted
		for (FActorComponentTickFunction* Func : TickableComponents)
		{
			Func->ExecuteTick(DeltaTime, TickType, CurrentThread, MyCompletionGraphEvent);
		}
	}

	// Cleanup after ticking all components
	for (FActorComponentTickFunction* Func : CleanupQueue)
	{
		TickableComponents.Remove(Func);
	}
	CleanupQueue.Empty();
}

```

`Source/ActionRoguelike/Performance/RogueTickablesSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "RogueTickablesSubsystem.generated.h"


/* Registered tick of the subsystem with the standard tick task graph */
USTRUCT()
struct FTickablesTickFunction : public FTickFunction
{
	GENERATED_BODY()

	UPROPERTY(Transient)
	URogueTickablesSubsystem* Target = nullptr;

	virtual void ExecuteTick(float DeltaTime, ELevelTick TickType, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent) override;

	virtual FString DiagnosticMessage() override {return TEXT("FAggregateTickFunction"); }
};

template <>
struct TStructOpsTypeTraits<FTickablesTickFunction> : TStructOpsTypeTraitsBase2<FTickablesTickFunction>
{
	enum
	{
		WithCopy = false
	};
};


/**
 * 
 */
UCLASS() // @todo: rename to clear be TickManager
class ACTIONROGUELIKE_API URogueTickablesSubsystem : public UWorldSubsystem
{
	GENERATED_BODY()

public:
	
	void RegisterComponent(FActorComponentTickFunction* TickFunction);
	
	void DeRegisterComponent(FActorComponentTickFunction* TickFunction);
	
	void ExecuteTick(ETickingGroup TickGroup, float DeltaTime, ELevelTick TickType, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent);

protected:

	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

	TArray<FActorComponentTickFunction*> TickableComponents;

	FTickablesTickFunction ComponentsTick;

	/* Cleanup after tick to avoid asserts when we get destroyed during iteration */
	TArray<FActorComponentTickFunction*> CleanupQueue;
};

```

`Source/ActionRoguelike/Pickups/RoguePickupActor.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RoguePickupActor.h"

#include "ActionRoguelike.h"
#include "Components/SphereComponent.h"
#include "Components/StaticMeshComponent.h"
#include "Net/UnrealNetwork.h"
#include "Player/RoguePlayerCharacter.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RoguePickupActor)


ARoguePickupActor::ARoguePickupActor()
{
	SphereComp = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComp"));
	SphereComp->SetCollisionProfileName(Collision::Powerup_ProfileName);
	SphereComp->SetSphereRadius(100.0f);
	RootComponent = SphereComp;

	MeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("MeshComp"));
	// Disable collision, instead we use SphereComp to handle interaction queries
	MeshComp->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	MeshComp->SetupAttachment(RootComponent);

	// Directly set bool instead of going through SetReplicates(true) within constructor,
	// Only use SetReplicates() outside constructor
	bReplicates = true;
}


void ARoguePickupActor::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	// Some pickups should auto pickup on overlap rather than a choice through player input
	if (bCanAutoPickup)
	{
		SphereComp->OnComponentBeginOverlap.AddDynamic(this, &ThisClass::OnSphereOverlap);
	}
}

void ARoguePickupActor::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	GetWorldTimerManager().ClearAllTimersForObject(this);
}


void ARoguePickupActor::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,
                                     int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	ARoguePlayerCharacter* MyPawn = Cast<ARoguePlayerCharacter>(OtherActor);
	// Skip for non-local pawns
	if (MyPawn && MyPawn->IsLocallyControlled())
	{
		Execute_Interact(this, CastChecked<AController>(MyPawn->GetController()));
	}
}


void ARoguePickupActor::Interact_Implementation(AController* InstigatorController)
{
	// logic in derived classes...
}


FText ARoguePickupActor::GetInteractText_Implementation(AController* InstigatorController)
{
	return FText::GetEmpty();
}


void ARoguePickupActor::ShowPickup()
{
	SetPickupState(true);
}


void ARoguePickupActor::HideAndCooldown()
{
	SetPickupState(false);

	FTimerHandle TimerHandle_RespawnTimer;
	GetWorldTimerManager().SetTimer(TimerHandle_RespawnTimer, this, &ARoguePickupActor::ShowPickup, RespawnTime);
}

void ARoguePickupActor::SetPickupState(bool bNewIsActive)
{
	bIsActive = bNewIsActive;
	OnRep_IsActive();
}


void ARoguePickupActor::OnRep_IsActive()
{
	SetActorEnableCollision(bIsActive);
	// Set visibility on root and all children
	RootComponent->SetVisibility(bIsActive, true);
}


void ARoguePickupActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ARoguePickupActor, bIsActive);
}
```

`Source/ActionRoguelike/Pickups/RoguePickupActor.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Core/RogueGameplayInterface.h"
#include "RoguePickupActor.generated.h"


class USphereComponent;
class UStaticMeshComponent;


UCLASS(ABSTRACT)
class ACTIONROGUELIKE_API ARoguePickupActor : public AActor, public IRogueGameplayInterface
{
	GENERATED_BODY()

protected:

	UPROPERTY(Transient, ReplicatedUsing=OnRep_IsActive)
	bool bIsActive = true;

	/* Overlap sphere to automatically pickup on walkover */
	UPROPERTY(EditDefaultsOnly, Category=Powerup)
	bool bCanAutoPickup = false;

	UFUNCTION()
	void OnRep_IsActive();

	UPROPERTY(EditAnywhere, Category = Powerup)
	float RespawnTime = 10.0f;

	void ShowPickup();

	void HideAndCooldown();

	void SetPickupState(bool bNewIsActive);

	UPROPERTY(VisibleAnywhere, Category = Components)
	TObjectPtr<USphereComponent> SphereComp;

	UPROPERTY(VisibleAnywhere, Category = Components)
	TObjectPtr<UStaticMeshComponent> MeshComp;

public:

	virtual void PostInitializeComponents() override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

	UFUNCTION()
	void OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,
		int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
	
	virtual void Interact_Implementation(AController* InstigatorController) override;

	virtual FText GetInteractText_Implementation(AController* InstigatorController) override;

	ARoguePickupActor();

};

```

`Source/ActionRoguelike/Pickups/RoguePickupActor_Credits.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RoguePickupActor_Credits.h"
#include "Player/RoguePlayerState.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RoguePickupActor_Credits)


ARoguePickupActor_Credits::ARoguePickupActor_Credits()
{
	bCanAutoPickup = true;
	CreditsAmount = 80;
}


void ARoguePickupActor_Credits::Interact_Implementation(AController* InstigatorController)
{
	if (ARoguePlayerState* PS = InstigatorController->GetPlayerState<ARoguePlayerState>())
	{
		PS->AddCredits(CreditsAmount);
		HideAndCooldown();
	}
}


```

`Source/ActionRoguelike/Pickups/RoguePickupActor_Credits.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "RoguePickupActor.h"
#include "RoguePickupActor_Credits.generated.h"


/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARoguePickupActor_Credits : public ARoguePickupActor
{
	GENERATED_BODY()

protected:

	UPROPERTY(EditAnywhere, Category = "Credits")
	int32 CreditsAmount;

public:
	virtual void Interact_Implementation(AController* InstigatorController) override;

	ARoguePickupActor_Credits();
};

```

`Source/ActionRoguelike/Pickups/RoguePickupActor_GrantAction.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RoguePickupActor_GrantAction.h"
#include "ActionSystem/RogueActionComponent.h"
#include "ActionSystem/RogueAction.h"
#include "Core/RogueGameplayFunctionLibrary.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RoguePickupActor_GrantAction)




void ARoguePickupActor_GrantAction::Interact_Implementation(AController* InstigatorController)
{
	// Make sure an action class was set up
	if (!ensureAlways(ActionToGrant))
	{
		return;
	}

	URogueActionComponent* ActionComp = URogueGameplayFunctionLibrary::GetActionComponentFromActor(InstigatorController->GetPawn());
	check(ActionComp);
	
	// Check if Player already has action class
	if (ActionComp->GetAction(ActionToGrant))
	{
		const FString DebugMsg = FString::Printf(TEXT("Action '%s' already known."), *GetNameSafe(ActionToGrant));
		GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, DebugMsg);
		return;
	}

	// Give new Ability
	ActionComp->AddAction(InstigatorController->GetPawn(), ActionToGrant);	
	HideAndCooldown();
}

```

`Source/ActionRoguelike/Pickups/RoguePickupActor_GrantAction.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "RoguePickupActor.h"
#include "RoguePickupActor_GrantAction.generated.h"

class URogueAction;

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARoguePickupActor_GrantAction : public ARoguePickupActor
{
	GENERATED_BODY()

protected:

	UPROPERTY(EditAnywhere, Category = "Powerup")
	TSubclassOf<URogueAction> ActionToGrant;

public:
	virtual void Interact_Implementation(AController* InstigatorController) override;

};

```

`Source/ActionRoguelike/Pickups/RoguePickupActor_HealthPotion.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RoguePickupActor_HealthPotion.h"

#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Core/RogueGameplayFunctionLibrary.h"
#include "Player/RoguePlayerState.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RoguePickupActor_HealthPotion)


#define LOCTEXT_NAMESPACE "InteractableActors"



void ARoguePickupActor_HealthPotion::Interact_Implementation(AController* InstigatorController)
{
	APawn* MyPawn = InstigatorController->GetPawn();
	
	URogueActionComponent* ActionComp = URogueActionComponent::GetActionComponent(MyPawn);
	// Check if not already at max health
	if (ensure(ActionComp) && !URogueGameplayFunctionLibrary::IsFullHealth(MyPawn))
	{
		if (ARoguePlayerState* PS = InstigatorController->GetPlayerState<ARoguePlayerState>())
		{
			if (PS->TryRemoveCredits(CreditCost))
			{
				// Heal back to full
				float MaxHealing = ActionComp->GetAttribute(SharedGameplayTags::Attribute_HealthMax)->GetValue();

				if (ActionComp->ApplyAttributeChange(
					SharedGameplayTags::Attribute_Health,
					MaxHealing,
					this,
					EAttributeModifyType::AddBase))
				{
					// Only activate if healed successfully
					HideAndCooldown();
				}
			}
		}
	}
}


FText ARoguePickupActor_HealthPotion::GetInteractText_Implementation(AController* InstigatorController)
{
	// May be nullptr when dead
	APawn* MyPawn = InstigatorController->GetPawn();
	
	if (MyPawn && URogueGameplayFunctionLibrary::IsFullHealth(MyPawn))
	{
		return LOCTEXT("HealthPotion_FullHealthWarning", "Already at full health.");
	}

	return FText::Format(LOCTEXT("HealthPotion_InteractMessage", "Cost {0} Credits. Restores health to maximum."), CreditCost);
}


#undef LOCTEXT_NAMESPACE
```

`Source/ActionRoguelike/Pickups/RoguePickupActor_HealthPotion.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "RoguePickupActor.h"
#include "RoguePickupActor_HealthPotion.generated.h"


class UStaticMeshComponent;


/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARoguePickupActor_HealthPotion : public ARoguePickupActor
{
	GENERATED_BODY()
	
protected:

	UPROPERTY(EditAnywhere, Category = "HealthPotion")
	int32 CreditCost = 50.0f;

public:
	virtual void Interact_Implementation(AController* InstigatorController) override;

	virtual FText GetInteractText_Implementation(AController* InstigatorController) override;
};

```

`Source/ActionRoguelike/Pickups/RoguePickupItemReplication.cpp`:

```cpp



#include "RoguePickupItemReplication.h"
#include "RoguePickupSubsystem.h"
#include "Components/InstancedStaticMeshComponent.h"


void FPickupLocationsArray::PostReplicatedAdd(const TArrayView<int32>& AddedIndices, int32 FinalSize)
{
	if (AddedIndices.Num() == 0)
	{
		return;
	}
	
	TArray<FTransform> NewCoinsTMs;
	NewCoinsTMs.Reserve(AddedIndices.Num());
	
	for (int Index = 0; Index < AddedIndices.Num(); ++Index)
	{
		const FPickupLocationItem Item = Items[AddedIndices[Index]];
		NewCoinsTMs.Add(FTransform(Item.CoinLocation));
	}

	TArray<FPrimitiveInstanceId> NewIDs = OwningSubsystem->AddMeshInstances(NewCoinsTMs);

	// Map all new IDs back into the matching items, to delete them later
	for (int i = 0; i < AddedIndices.Num(); ++i)
	{
		FPickupLocationItem& Item = Items[AddedIndices[i]];
		Item.ID = NewIDs[i];
	}
}

void FPickupLocationsArray::PreReplicatedRemove(const TArrayView<int32>& RemovedIndices, int32 FinalSize)
{
	if (RemovedIndices.Num() == 0)
	{
		return;
	}
	
	TArray<FPrimitiveInstanceId> IDsToRemove;
	IDsToRemove.Reserve(RemovedIndices.Num());
	
	for (int32& RemovedIndex : RemovedIndices)
	{
		IDsToRemove.Add(Items[RemovedIndex].ID);
	}

	OwningSubsystem->RemoveMeshInstances(IDsToRemove);
}
```

`Source/ActionRoguelike/Pickups/RoguePickupItemReplication.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "Net/Serialization/FastArraySerializer.h"
#include "RoguePickupItemReplication.generated.h"


class URoguePickupSubsystem;

USTRUCT()
struct FPickupLocationItem : public FFastArraySerializerItem
{
	GENERATED_BODY()

public:

	FPickupLocationItem()
	{
		CoinLocation = FVector::ZeroVector;
		ID = FPrimitiveInstanceId();
	}

	/*FPickupLocationItem(FVector InLocation)
		: CoinLocation(InLocation), ID(INDEX_NONE)
	{
		
	}*/

	FPickupLocationItem(FVector InLocation, FPrimitiveInstanceId InID) :
		CoinLocation(InLocation),
		ID(InID) {}
	
	UPROPERTY()
	FVector_NetQuantize CoinLocation;

	/* Local ID matching the Instanced Mesh Component */
	UPROPERTY(NotReplicated)
	FPrimitiveInstanceId ID;
	
	bool operator==(const FPickupLocationItem& OtherConfig) const
	{
		return OtherConfig.ID == ID;
	}
};

USTRUCT()
struct FPickupLocationsArray: public FFastArraySerializer
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(NotReplicated)
	URoguePickupSubsystem* OwningSubsystem = nullptr;

	UPROPERTY()
	TArray<FPickupLocationItem> Items;

	void PostReplicatedAdd(const TArrayView<int32>& AddedIndices, int32 FinalSize);

	void PreReplicatedRemove(const TArrayView<int32>& RemovedIndices, int32 FinalSize);

	bool NetDeltaSerialize(FNetDeltaSerializeInfo & DeltaParms)
	{
		return FFastArraySerializer::FastArrayDeltaSerialize<FPickupLocationItem, FPickupLocationsArray>( Items, DeltaParms, *this );
	}
};

template<>
struct TStructOpsTypeTraits<FPickupLocationsArray> : public TStructOpsTypeTraitsBase2<FPickupLocationsArray>
{
	enum 
	{
		WithNetDeltaSerializer = true,
   };
};

```

`Source/ActionRoguelike/Pickups/RoguePickupSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RoguePickupSubsystem.h"

#include "EngineUtils.h"
#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Components/AudioComponent.h"
#include "Components/InstancedStaticMeshComponent.h"
#include "Core/RogueDeveloperSettings.h"
#include "Core/RogueGameState.h"
#include "Player/RoguePlayerCharacter.h"



void URoguePickupSubsystem::AddCreditsPickup(FVector Origin, int32 CreditAmount)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(RoguePickupSubsystem::AddCreditsPickup)
	
	ENetMode NetMode = GetWorld()->GetNetMode();
	// Clients only react to data received from host
	check(GetWorld()->GetNetMode() != NM_Client);

	CreditPickupLocations.Add(Origin);
	CreditPickupAmount.Add(CreditAmount);
	
	// Add locally (unbatched)
	const FPrimitiveInstanceId& Id = AddMeshInstance(Origin);
	MeshIDs.Add(Id);
	
	// Are we playing a networked game
	if (NetMode > NM_Standalone)
	{
		ARogueGameState* GS = GetWorld()->GetGameState<ARogueGameState>();

		FPickupLocationItem NewItem = FPickupLocationItem(Origin, Id);
		GS->CoinPickupData.Items.Add(NewItem);
		GS->CoinPickupData.MarkItemDirty(NewItem);
	}

}

void URoguePickupSubsystem::RemoveCreditsPickup(int32 InIndex)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(RoguePickupSubsystem::RemoveCreditsPickup)
	
	ENetMode NetMode = GetWorld()->GetNetMode();
	check(NetMode != NM_Client);
	
	CreditPickupLocations.RemoveAt(InIndex);
	CreditPickupAmount.RemoveAt(InIndex);

	// Playing any networked game, clients should not reach here in the first place
	if (NetMode > NM_Standalone)
	{
		ARogueGameState* GS = GetWorld()->GetGameState<ARogueGameState>();

		// Find match based on local ID again
		FPrimitiveInstanceId IdToFind = MeshIDs[InIndex];
		GS->CoinPickupData.Items.Remove(FPickupLocationItem(FVector::ZeroVector, IdToFind));
		GS->CoinPickupData.MarkArrayDirty();
	}

	WorldISM->RemoveInstanceById(MeshIDs[InIndex]);
	MeshIDs.RemoveAt(InIndex);
}

FPrimitiveInstanceId URoguePickupSubsystem::AddMeshInstance(FVector InLocation)
{
	// Lazy init
	if (!IsValid(WorldISM))
	{
		CreateWorldISM();
	}
	
	return WorldISM->AddInstanceById(FTransform(InLocation), true);
}

TArray<FPrimitiveInstanceId> URoguePickupSubsystem::AddMeshInstances(const TArray<FTransform>& InAdded)
{
	// Lazy init
	if (!IsValid(WorldISM))
	{
		CreateWorldISM();
	}
	
	// Batch-add
	return WorldISM->AddInstancesById(InAdded, true, false);
}

void URoguePickupSubsystem::RemoveMeshInstances(const TArray<FPrimitiveInstanceId>& IdsToRemove)
{
	check(WorldISM);
	WorldISM->RemoveInstancesById(IdsToRemove, false);
}


void URoguePickupSubsystem::CreateWorldISM()
{
	UWorld* World = GetWorld();

	// Temp sync loading of the mesh, can hitch
	UStaticMesh* Mesh = GetDefault<URogueDeveloperSettings>()->PickupCoinMesh.LoadSynchronous();
		
	WorldISM = NewObject<UInstancedStaticMeshComponent>(World, NAME_None, RF_Transient);
	WorldISM->SetStaticMesh(Mesh);
	WorldISM->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	WorldISM->RegisterComponentWithWorld(World);
}


void URoguePickupSubsystem::PlayPickupSound()
{
	if (!CoinPickupAudioComp->IsPlaying())
	{
		CoinPickupAudioComp->Play();
	}

	// by repeatedly triggering this event we play a sequence of higher pitched pickups
	// The metasound handles "resetting" the pitch of the pickup sequence automatically
	CoinPickupAudioComp->SetTriggerParameter("CoinPickedUp");
}

void URoguePickupSubsystem::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	UWorld* World = GetWorld();
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(RoguePickupSubsystem::Tick)

		// Performance Note: This processing is laid out to move around and touch as few things per iteration
		// Therefor we first process all the possible coin pickups and count the total credits before we
		// award any of the players which may end up triggering a bunch of other delegates and pulling classes/data into memory
		
		// Note multiplayer: Even clients may run the logic locally to trigger cosmetic pickup events
		
		TArray<FVector> Players;
		TArray<ARoguePlayerCharacter*> PlayerPawns;
		TArray<int32> TotalCreditsPerPlayer;
		
		for (ARoguePlayerCharacter* PlayerPawn : TActorRange<ARoguePlayerCharacter>(World))
		{
			Players.Add(PlayerPawn->GetActorLocation());
			PlayerPawns.Add(PlayerPawn);
		}

		// @todo: make this a player configured stat or attribute
		const float PickupRadius = 200.f;
		const float PickupRadiusSqrd = PickupRadius * PickupRadius;

		// Find pickups and track credits to grant
		for (FVector& PlayerLocation : Players)
		{
			// Track all pickups that need to be picked up.
			TArray<int32> ProcessList;

			for (int Index = 0; Index < CreditPickupLocations.Num(); ++Index)
			{
				float DistSqrd = FVector::DistSquared(CreditPickupLocations[Index], PlayerLocation);
				if (DistSqrd < PickupRadiusSqrd)
				{
					// Bookkeep all pickups that need processing for later
					ProcessList.Add(Index);
				}
			}

			int32 TotalCredits = 0;
			for (int i = ProcessList.Num() - 1; i >= 0; --i)
			{
				TotalCredits += CreditPickupAmount[ProcessList[i]];
				
				RemoveCreditsPickup(ProcessList[i]);
			}

			TotalCreditsPerPlayer.Add(TotalCredits);
		}

		// Award each player
		for (int i = 0; i < PlayerPawns.Num(); ++i)
		{
			int32 AwardAmount = TotalCreditsPerPlayer[i];
			if (AwardAmount == 0)
			{
				continue;
			}
			
			FAttributeModification Mod = FAttributeModification(SharedGameplayTags::Attribute_Credits, AwardAmount);

			PlayerPawns[i]->GetActionComponent()->ApplyAttributeChange(Mod);

			// @todo: play sound properly for networked players...eg. they receive these credits w/ a pickup contextTag
			PlayPickupSound();
		}
	}

	// Debug Rendering
	//for (int Index = 0; Index < CreditPickupLocations.Num(); ++Index)
	{
		//DrawDebugBox(World, CreditPickupLocations[Index], FVector(5.0f), FColor::Blue);
	}
}

bool URoguePickupSubsystem::IsTickable() const
{
	// Run everywhere except clients. Only standalone/host will check for "overlaps" during tick
	return GetWorld()->GetNetMode() < NM_Client;
}

void URoguePickupSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	UWorld* World = GetWorld();

	// Temp sync loading of the sound, can hitch
	USoundBase* SoundAsset = GetDefault<URogueDeveloperSettings>()->PickupCoinSound.LoadSynchronous();
		
	CoinPickupAudioComp = NewObject<UAudioComponent>(World, NAME_None, RF_Transient);
	CoinPickupAudioComp->SetSound(SoundAsset);
	CoinPickupAudioComp->bAutoActivate = false;
	CoinPickupAudioComp->RegisterComponentWithWorld(World);
}

```

`Source/ActionRoguelike/Pickups/RoguePickupSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "RoguePickupSubsystem.generated.h"

class UInstancedStaticMeshComponent;

// Easy toggle to remove the use case testing from game code
#define USE_DOD_CREDIT_PICKUPS 1

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URoguePickupSubsystem : public UTickableWorldSubsystem
{
	GENERATED_BODY()

public:
	
	void AddCreditsPickup(FVector Origin, int32 CreditAmount);

	TArray<FPrimitiveInstanceId> AddMeshInstances(const TArray<FTransform>& InAdded);

	void RemoveMeshInstances(const TArray<FPrimitiveInstanceId>& IdsToRemove);

protected:
	
	void RemoveCreditsPickup(int32 InIndex);

	// -- These arrays are in sync
	TArray<FVector> CreditPickupLocations;
	TArray<int32> CreditPickupAmount;
	TArray<FPrimitiveInstanceId> MeshIDs;
	// -- end

	FPrimitiveInstanceId AddMeshInstance(FVector InLocation);

	void CreateWorldISM();

	void PlayPickupSound();

	/* Single ISM that holds all coins, registered directly with the world instead of Actor wrapper */
	UPROPERTY()
	TObjectPtr<UInstancedStaticMeshComponent> WorldISM;
	
	UPROPERTY()
	TObjectPtr<UAudioComponent> CoinPickupAudioComp;

	virtual void Tick(float DeltaTime) override;

	virtual TStatId GetStatId() const override
	{
		RETURN_QUICK_DECLARE_CYCLE_STAT(URoguePickupSubsystem, STATGROUP_Tickables);
	}

	virtual bool IsTickable() const override;

	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
};

```

`Source/ActionRoguelike/Player/RogueInteractionComponent.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueInteractionComponent.h"

#include "ActionRoguelike.h"
#include "Core/RogueGameplayInterface.h"
#include "DrawDebugHelpers.h"
#include "Core/RogueGameplayFunctionLibrary.h"
#include "UI/RogueWorldUserWidget.h"
#include "Engine/OverlapResult.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueInteractionComponent)


static TAutoConsoleVariable CVarInteractionDebugDrawing(TEXT("game.Interaction.DebugDraw"),
	false,
	TEXT("Enable Debug Helper Rendering for Interaction Component. (0 = Disabled, 1 = Enabled)"),
	ECVF_Cheat);


URogueInteractionComponent::URogueInteractionComponent()
{
	PrimaryComponentTick.bCanEverTick = true;
	// Since we use Camera info in Tick we want the most up-to-date camera position for tracing
	PrimaryComponentTick.TickGroup = TG_PostUpdateWork;

	TraceRadius = 250.f;
	TraceChannel = TRACE_INTERACT;
}


void URogueInteractionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
	
	// Cast checked acts like static_cast in shipping builds. Less overhead compared to regular Cast<T> which does have safety nets.
	// Can use this in places where the cast object should never be nullptr by design, and we know exactly the base class it is.
	const AController* MyController = CastChecked<AController>(GetOwner());
	if (MyController->IsLocalController())
	{
		FindBestInteractable();
	}
}


void URogueInteractionComponent::FindBestInteractable()
{
	AController* OwningController = Cast<AController>(GetOwner());
	check(OwningController); // Only allow this to exist on (player)controllers
	
	APawn* OwningPawn = OwningController->GetPawn();
	if (OwningPawn == nullptr || !URogueGameplayFunctionLibrary::IsAlive(OwningPawn))
	{
		// We do not always have a pawn, or we died
		FocusedActor = nullptr;
		return;
	}

	UWorld* World = GetWorld();
	const FVector TraceOrigin = OwningPawn->GetActorLocation();
	const FColor DebugLineColor = FColor::Green;
	
	// Find all potential interactable around the player
	TArray<FOverlapResult> Overlaps;
	World->OverlapMultiByChannel(
		Overlaps,
		TraceOrigin,
		FQuat::Identity,
		TraceChannel,
		FCollisionShape::MakeSphere(TraceRadius));

	const bool bEnableDebugDrawing = CVarInteractionDebugDrawing.GetValueOnGameThread(); 

	// Reset
	FocusedActor = nullptr;
	float HighestWeight = -MAX_flt;

	// Calc 'weights' to find the best interactable which the player most likely intends to focus
	for (const FOverlapResult& Overlap : Overlaps)
	{
		if (AActor* HitActor = Overlap.GetActor())
		{
			if (bEnableDebugDrawing)
			{
				DrawDebugSphere(World, HitActor->GetActorLocation(),
					64.0f, 16, DebugLineColor, false, 0.0f);
			}
			
			if (HitActor->Implements<URogueGameplayInterface>())
			{
				// When not recently rendered, the player is unlikely to want to interact with this object
				// it might be hidden behind walls (shadow rendering might mess with this boolean)
				//if (!HitActor->WasRecentlyRendered(0.1f))
				{
					// Won't work for Nanite meshes which don't report this recently rendered
					// - Extra: if recently rendered, then perform line trace from camera to obj pivot
					//				to know if we are actually behind some type of wall
					//continue;
				}

				FVector ObjectDir = (HitActor->GetActorLocation() - TraceOrigin).GetUnsafeNormal();

				// Prefer actors that our 'control rotation' (eg. camera) is pointing to
				float DotResult = FVector::DotProduct(ObjectDir, OwningController->GetControlRotation().Vector());
				float Weight = DotResult * 10.f;
				
				if (HighestWeight < Weight)
				{
					FocusedActor = HitActor;
					HighestWeight = Weight;
				}
			}
		}
	}

	if (FocusedActor)
	{
		if (WidgetInst == nullptr && ensureMsgf(DefaultWidgetClass, TEXT("DefaultWidgetClass for the interaction component is not specified in %s. Please update the Blueprint."), *GetNameSafe(OwningController)))
		{
			WidgetInst = CreateWidget<URogueWorldUserWidget>(World, DefaultWidgetClass);
		}

		if (WidgetInst)
		{
			WidgetInst->AttachedActor = FocusedActor;

			if (!WidgetInst->GetParent())
			{
				URogueWorldUserWidget::AddToRootCanvasPanel(WidgetInst);
			}
		}
	}
	else
	{
		if (WidgetInst)
		{
			WidgetInst->RemoveFromParent();
		}
	}

	if (bEnableDebugDrawing)
	{
		// Outer radius of interaction
		DrawDebugSphere(World, TraceOrigin, TraceRadius, 32, DebugLineColor, false, 0.0f);
		
		if (FocusedActor)
		{
			DrawDebugBox(World, FocusedActor->GetActorLocation(), FVector(20.f),
				DebugLineColor, false, 0.0f);
		}
		//DrawDebugLine(World, TraceOrigin, TraceEnd, LineColor, false, 2.0f, 0, 0.0f);
	}
}


void URogueInteractionComponent::PrimaryInteract()
{
	ServerInteract(FocusedActor);
}


void URogueInteractionComponent::ServerInteract_Implementation(AActor* InFocus)
{
	if (InFocus == nullptr)
	{
		GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Red, "No Focus Actor to interact.");
		return;
	}

	AController* MyController = CastChecked<AController>(GetOwner());
	IRogueGameplayInterface::Execute_Interact(InFocus, MyController);
}


```

`Source/ActionRoguelike/Player/RogueInteractionComponent.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "RogueInteractionComponent.generated.h"

class URogueWorldUserWidget;

UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class ACTIONROGUELIKE_API URogueInteractionComponent : public UActorComponent
{
	GENERATED_BODY()

public:

	void PrimaryInteract();

protected:

	// Reliable - Will always arrive, eventually. Request will be re-sent unless an acknowledgment was received.
	// Unreliable - Not guaranteed, packet can get lost and won't retry.

	UFUNCTION(Server, Reliable)
	void ServerInteract(AActor* InFocus);

	void FindBestInteractable();

	UPROPERTY(Transient)
	TObjectPtr<AActor> FocusedActor;

	UPROPERTY(EditDefaultsOnly, Category = "Trace")
	float TraceRadius;

	UPROPERTY(EditDefaultsOnly, Category = "Trace")
	TEnumAsByte<ECollisionChannel> TraceChannel;

	UPROPERTY(EditDefaultsOnly, Category = "UI")
	TSubclassOf<URogueWorldUserWidget> DefaultWidgetClass;

	UPROPERTY(Transient)
	TObjectPtr<URogueWorldUserWidget> WidgetInst;

public:	

	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

	URogueInteractionComponent();
	
};

```

`Source/ActionRoguelike/Player/RoguePlayerCharacter.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Player/RoguePlayerCharacter.h"
#include "GameFramework/SpringArmComponent.h"
#include "Camera/CameraComponent.h"
#include "DrawDebugHelpers.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Components/CapsuleComponent.h"
#include "SharedGameplayTags.h"
#include "ActionRoguelike.h"
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#include "RoguePlayerController.h"
#include "RoguePlayerData.h"
#include "AI/RogueAICharacter.h"
#include "Blueprint/UserWidget.h"
#include "Components/AudioComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Perception/AIPerceptionStimuliSourceComponent.h"
#include "UI/RogueWorldUserWidget.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RoguePlayerCharacter)



ARoguePlayerCharacter::ARoguePlayerCharacter(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	PrimaryActorTick.bCanEverTick = true;

	SpringArmComp = CreateDefaultSubobject<USpringArmComponent>(TEXT("SpringArmComp"));
	SpringArmComp->bUsePawnControlRotation = true;
	SpringArmComp->SetupAttachment(RootComponent);
	// We control the rotation of spring arm with pawn control rotation already, this disables a subtle side effect
	// where rotating our CapsuleComponent (eg. caused by bOrientRotationToMovement in Character Movement) will rotate our spring arm until it self corrects later in the update
	// This may cause unwanted effects when using CameraLocation during Tick as it may be slightly offset from our final camera position.
	SpringArmComp->SetUsingAbsoluteRotation(true);

	CameraComp = CreateDefaultSubobject<UCameraComponent>(TEXT("CameraComp"));
	CameraComp->SetupAttachment(SpringArmComp);

	ActionComp = CreateDefaultSubobject<URogueActionComponent>(TEXT("ActionComp"));
	ActionComp->SetDefaultAttributeSet(ObjectInitializer, URogueSurvivorAttributeSet::StaticClass());

	PerceptionStimuliComp = CreateDefaultSubobject<UAIPerceptionStimuliSourceComponent>(TEXT("PerceptionStimuliComp"));

	AttackSoundsComp = CreateDefaultSubobject<UAudioComponent>(TEXT("AttackSoundsComp"));
	AttackSoundsComp->SetupAttachment(RootComponent);
	AttackSoundsComp->bAutoActivate = false;
	// Don't follow player unless actively playing a sound
	AttackSoundsComp->bAutoManageAttachment = true;

	UCharacterMovementComponent* CharMoveComp = GetCharacterMovement();
	CharMoveComp->bUseControllerDesiredRotation = true;

	CharMoveComp->MaxWalkSpeed = 550.0f;
	// Attempt to make the jump feel less floaty
	CharMoveComp->JumpZVelocity = 550;
	CharMoveComp->GravityScale = 1.35f;
	CharMoveComp->BrakingDecelerationFalling = 200.f;

	// Skip performing overlap queries on the Physics Asset after animation (7 queries in case of our Gideon mesh)
	GetMesh()->bUpdateOverlapsOnAnimationFinalize = false;
	
	// Enabled on mesh to react to incoming projectiles
	GetMesh()->SetGenerateOverlapEvents(true);
	// Disable on capsule collision to avoid double-dipping and receiving 2 overlaps when entering trigger zones etc.
	// Once from the mesh, and 2nd time from capsule
	GetCapsuleComponent()->SetGenerateOverlapEvents(false);
}


void ARoguePlayerCharacter::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	// Cheap trick to disable until we need it in the health event
	CachedOverlayMaxDistance = GetMesh()->OverlayMaterialMaxDrawDistance;
	GetMesh()->SetOverlayMaterialMaxDrawDistance(1);

	ActionComp->GetAttributeListenerDelegate(SharedGameplayTags::Attribute_Health).AddUObject(this, &ThisClass::OnHealthAttributeChanged);
}


void ARoguePlayerCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	// Must be configured in the Blueprint
	check(PlayerConfig);

	// Enhanced Input
	UEnhancedInputComponent* InputComp = CastChecked<UEnhancedInputComponent>(PlayerInputComponent);

	// General
	InputComp->BindAction(PlayerConfig->Input_Move, ETriggerEvent::Triggered, this, &ARoguePlayerCharacter::Move);
	InputComp->BindAction(PlayerConfig->Input_Jump, ETriggerEvent::Triggered, this, &ACharacter::Jump);

	// Sprint while key is held
	InputComp->BindAction(PlayerConfig->Input_Sprint, ETriggerEvent::Started, this, &ARoguePlayerCharacter::StartActionByTag, SharedGameplayTags::Action_Sprint.GetTag());
	InputComp->BindAction(PlayerConfig->Input_Sprint, ETriggerEvent::Completed, this, &ARoguePlayerCharacter::StopActionByTag, SharedGameplayTags::Action_Sprint.GetTag());

	// MKB
	InputComp->BindAction(PlayerConfig->Input_LookMouse, ETriggerEvent::Triggered, this, &ARoguePlayerCharacter::LookMouse);
	// Gamepad
	InputComp->BindAction(PlayerConfig->Input_LookStick, ETriggerEvent::Triggered, this, &ARoguePlayerCharacter::LookStick);

	// Abilities
	InputComp->BindAction(PlayerConfig->Input_PrimaryAttack, ETriggerEvent::Triggered, this, &ARoguePlayerCharacter::StartActionByTag, SharedGameplayTags::Action_PrimaryAttack.GetTag());
	InputComp->BindAction(PlayerConfig->Input_SecondaryAttack, ETriggerEvent::Triggered, this, &ARoguePlayerCharacter::StartActionByTag, SharedGameplayTags::Action_Blackhole.GetTag());
	InputComp->BindAction(PlayerConfig->Input_Dash, ETriggerEvent::Triggered, this, &ARoguePlayerCharacter::StartActionByTag, SharedGameplayTags::Action_Dash.GetTag());
}

void ARoguePlayerCharacter::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	FindCrosshairTarget();
}


void ARoguePlayerCharacter::FindCrosshairTarget()
{
	// Ignore if not using GamePad
	ARoguePlayerController* PC = GetController<ARoguePlayerController>();

	// Only use aim assist when currently controlled and using gamepad
	// Note: you *may* always want to line trace if using this result for other things like coloring crosshair or re-using this hit data for aim adjusting during projectile attacks
	if (PC == nullptr || !PC->IsUsingGamepad())
	{
		bHasPawnTarget = false;
		return;
	}

	FVector EyeLocation;
	FRotator EyeRotation;
	GetActorEyesViewPoint(EyeLocation, EyeRotation);

	const float AimAssistDistance = 5000.f;
	const FVector TraceEnd = EyeLocation + (EyeRotation.Vector() * AimAssistDistance);

	FCollisionQueryParams Params;
	Params.AddIgnoredActor(this);

	FCollisionShape Shape;
	Shape.SetSphere(50.f);

	// Called next frame when the trace has completed
	FTraceDelegate Delegate = FTraceDelegate::CreateUObject(this, &ARoguePlayerCharacter::CrosshairTraceComplete);
	
	TraceHandle = GetWorld()->AsyncSweepByChannel(EAsyncTraceType::Single, EyeLocation, TraceEnd, FQuat::Identity, ECC_Pawn, Shape, Params, FCollisionResponseParams::DefaultResponseParam, &Delegate);
}


void ARoguePlayerCharacter::CrosshairTraceComplete(const FTraceHandle& InTraceHandle, FTraceDatum& InTraceDatum)
{
	// at most expect one hit
	if (InTraceDatum.OutHits.IsValidIndex(0))
	{
		FHitResult Hit = InTraceDatum.OutHits[0];
		// Figure out if dealing with a Pawn, may want aim assist on other 'things', which requires a different check
		bHasPawnTarget = Hit.IsValidBlockingHit() && Hit.GetActor()->IsA(APawn::StaticClass());

		//UE_LOG(LogGame, Log, TEXT("has pawn target: %s"), bHasPawnTarget ? TEXT("true") : TEXT("false"));
	}
}


void ARoguePlayerCharacter::ClientOnSeenBy_Implementation(ARogueAICharacter* SeenByPawn)
{
	URogueWorldUserWidget* NewWidget = CreateWidget<URogueWorldUserWidget>(GetWorld(), SpottedWidgetClass);
	// Can be nullptr if we do not specify a class to use in Blueprint
	if (NewWidget)
	{
		NewWidget->AttachedActor = SeenByPawn;
		URogueWorldUserWidget::AddToRootCanvasPanel(NewWidget);
	}
}

void ARoguePlayerCharacter::PlayAttackSound(USoundBase* InSound)
{
	// This may interrupt previously playing sounds, so you'd want to test for this
	AttackSoundsComp->SetSound(InSound);
	AttackSoundsComp->Play();
}

void ARoguePlayerCharacter::Move(const FInputActionInstance& Instance)
{
	FRotator ControlRot = GetControlRotation();
	ControlRot.Pitch = 0.0f;
	ControlRot.Roll = 0.0f;

	// Get value from input (combined value from WASD keys or single Gamepad stick) and convert to Vector (x,y)
	const FVector2D AxisValue = Instance.GetValue().Get<FVector2D>();

	// Move forward/back
	AddMovementInput(ControlRot.Vector(), AxisValue.X);

	// Move Right/Left strafe
	const FVector RightVector = ControlRot.RotateVector(FVector::RightVector);
	AddMovementInput(RightVector, AxisValue.Y);
}

void ARoguePlayerCharacter::LookMouse(const FInputActionValue& InputValue)
{
	const FVector2D Value = InputValue.Get<FVector2D>();
	
	AddControllerYawInput(Value.X);
	AddControllerPitchInput(Value.Y);
}


void ARoguePlayerCharacter::LookStick(const FInputActionValue& InputValue)
{
	FVector2D Value = InputValue.Get<FVector2D>();

	// Track negative as we'll lose this during the conversion
	bool XNegative = Value.X < 0.f;
	bool YNegative = Value.Y < 0.f;

	// Can further modify with 'sensitivity' settings
	const float LookYawRate = 100.0f;
	const float LookPitchRate = 50.0f;

	// non-linear to make aiming a little easier
	Value = Value * Value;

	if (XNegative)
	{
		Value.X *= -1.f;
	}
	if (YNegative)
	{
		Value.Y *= -1.f;
	}

	// Aim assist
	// todo: may need to ease this out and/or change strength based on distance to target
	float RateMultiplier = 1.0f;
	if (bHasPawnTarget)
	{
		RateMultiplier = 0.5f;
	}

	AddControllerYawInput(Value.X * (LookYawRate * RateMultiplier) * GetWorld()->GetDeltaSeconds());
	AddControllerPitchInput(Value.Y * (LookPitchRate * RateMultiplier) * GetWorld()->GetDeltaSeconds());
}


void ARoguePlayerCharacter::StartActionByTag(const FInputActionValue& Instance, const FGameplayTag InActionTag)
{
	ActionComp->StartActionByName(this, InActionTag);
}


void ARoguePlayerCharacter::StopActionByTag(const FInputActionValue& Instance, const FGameplayTag InActionTag)
{
	ActionComp->StopActionByName(this, InActionTag);
}


void ARoguePlayerCharacter::OnHealthAttributeChanged(float NewValue, const FAttributeModification& AttributeModification)
{
	// Damaged
	if (AttributeModification.Magnitude < 0.0f)
	{
		// Materials, including the mesh "OverlayMaterial" can get their data via the component
		GetMesh()->SetCustomPrimitiveDataFloat(HitFlash_CustomPrimitiveIndex, GetWorld()->TimeSeconds);

		// Activate, we can skip rendering this at a distance
		GetMesh()->SetOverlayMaterialMaxDrawDistance(CachedOverlayMaxDistance);

		// After 1.0seconds we should be finished with the hitflash (re-use the handle to reset timer if we get hit again)
		GetWorldTimerManager().SetTimer(OverlayTimerHandle, [this]()
		{
			// Cheap trick to skip rendering this all the time unless we are actively hit flashing
			GetMesh()->SetOverlayMaterialMaxDrawDistance(1);
		}, 1.0f, false);

		// Rage added equal to damage received (Abs to turn into positive rage number)
		// @TODO: change behavior of RAGE mechanic
		const float RageDelta = FMath::Abs(AttributeModification.Magnitude);
		ActionComp->ApplyAttributeChange(SharedGameplayTags::Attribute_Rage, RageDelta, this, EAttributeModifyType::AddModifier);

		UGameplayStatics::PlaySoundAtLocation(this, TakeDamageVOSound, GetActorLocation(), FRotator::ZeroRotator);
	}

	// Died
	if (NewValue <= 0.0f && AttributeModification.Magnitude < 0.0f)
	{
		UGameplayStatics::PlaySoundAtLocation(this, DeathVOSound, GetActorLocation(), FRotator::ZeroRotator);

		PlayAnimMontage(DeathMontage);

		SetLifeSpan(5.0f);

		// Prevent bots from seeing us as a threat
		PerceptionStimuliComp->UnregisterFromPerceptionSystem();
		
		APlayerController* PC = GetController<ARoguePlayerController>();
		if (PC && PC->IsLocalController())
		{
			// for local player, play a "UI" sound on death
			UGameplayStatics::PlaySound2D(this, DeathUISound);

			DisableInput(PC);
		}
	}
}


FGenericTeamId ARoguePlayerCharacter::GetGenericTeamId() const
{
	// We have no team switching support during gameplay
	return FGenericTeamId(TEAM_ID_PLAYERS);
}

FVector ARoguePlayerCharacter::GetPawnViewLocation() const
{
	return CameraComp->GetComponentLocation();
}

```

`Source/ActionRoguelike/Player/RoguePlayerCharacter.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"

#include "GenericTeamAgentInterface.h"
// Included for struct FInputActionInstance (Enhanced Input)
#include "GameplayTagContainer.h"
#include "InputAction.h"
#include "ActionSystem/RogueActionSystemInterface.h"
#include "RoguePlayerCharacter.generated.h"

struct FAttributeModification;
class URoguePlayerData;
class ARogueAIController;
class UAIPerceptionStimuliSourceComponent;
class UInputMappingContext;
class UCameraComponent;
class USpringArmComponent;
class UAnimMontage;
class URogueActionComponent;

UCLASS(Abstract)
class ACTIONROGUELIKE_API ARoguePlayerCharacter : public ACharacter, public IGenericTeamAgentInterface, public IRogueActionSystemInterface
{
	GENERATED_BODY()

public:

	void PlayAttackSound(USoundBase* InSound);

protected:

	/* Contains most config data for the player including abilities and inputs */
	UPROPERTY(EditDefaultsOnly, Category="Config")
	TObjectPtr<URoguePlayerData> PlayerConfig;

	/* Index must match the CustomPrimitiveData index used in the Overlay material */
	UPROPERTY(VisibleAnywhere, Category = "Effects")
	int32 HitFlash_CustomPrimitiveIndex = 0;

	UPROPERTY(EditDefaultsOnly, Category= Effects)
	TObjectPtr<USoundBase> TakeDamageVOSound;
	
	UPROPERTY(EditDefaultsOnly, Category= Effects)
	TObjectPtr<USoundBase> DeathVOSound;

	UPROPERTY(EditDefaultsOnly, Category= Effects)
	TObjectPtr<USoundBase> DeathUISound;

	UPROPERTY(EditDefaultsOnly, Category= Effects)
	TObjectPtr<USoundBase> FootPlantSound;

	/* Plays on DefaultSlot, make sure the "auto blendout" is disabled on the AnimSequence to keep the final pose  */
	UPROPERTY(EditDefaultsOnly, Category= Effects)
	TObjectPtr<UAnimMontage> DeathMontage;

	/* Widget to display when bot first sees a player. */
	UPROPERTY(EditDefaultsOnly, Category = UI)
	TSubclassOf<UUserWidget> SpottedWidgetClass;

	UPROPERTY(VisibleAnywhere)
	TObjectPtr<USpringArmComponent> SpringArmComp;

	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UCameraComponent> CameraComp;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<URogueActionComponent> ActionComp;

	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UAIPerceptionStimuliSourceComponent> PerceptionStimuliComp;

	/* Re-usable audio component for all (attached) attack sounds such as casting sound from the magic projectile attack */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<UAudioComponent> AttackSoundsComp;

	// Enhanced Input
	// Three parameter options available (FInputActionInstance, FInputActionValue, or none)
	void Move(const FInputActionInstance& Instance);

	void LookMouse(const FInputActionValue& InputValue);
	
	void LookStick(const FInputActionValue& InputValue);

	void StartActionByTag(const FInputActionValue& Instance, const FGameplayTag InActionTag);
	
	void StopActionByTag(const FInputActionValue& Instance, const FGameplayTag InActionTag);

	void OnHealthAttributeChanged(float NewValue, const FAttributeModification& AttributeModification);

	virtual void PostInitializeComponents() override;

	void FindCrosshairTarget();

	void CrosshairTraceComplete(const FTraceHandle& InTraceHandle, FTraceDatum& InTraceDatum);

public:	

	ARoguePlayerCharacter(const FObjectInitializer& ObjectInitializer);

	virtual FVector GetPawnViewLocation() const override;

	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	virtual void Tick(float DeltaSeconds) override;

	virtual FGenericTeamId GetGenericTeamId() const override;

	UFUNCTION(Client, Unreliable)
	void ClientOnSeenBy(ARogueAICharacter* SeenByPawn);

	virtual URogueActionComponent* GetActionComponent() const override
	{
		return ActionComp;
	}

protected:

	float CachedOverlayMaxDistance;

	FTimerHandle OverlayTimerHandle;

	FTraceHandle TraceHandle;
	
	bool bHasPawnTarget;
};

```

`Source/ActionRoguelike/Player/RoguePlayerController.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RoguePlayerController.h"

#include "EnhancedInputComponent.h"
#include "RogueInteractionComponent.h"
#include "Development/RogueCheatManager.h"
#include "UI/RogueHUD.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RoguePlayerController)



ARoguePlayerController::ARoguePlayerController()
{
	CheatClass = URogueCheatManager::StaticClass();

	// For multiplayer, its better to have this here so it only runs on the owning client (and the server, which can disable the tick)
	InteractionComp = CreateDefaultSubobject<URogueInteractionComponent>(TEXT("InteractionComp"));
}


void ARoguePlayerController::PrimaryInteract()
{
	InteractionComp->PrimaryInteract();
}


void ARoguePlayerController::SetupInputComponent()
{
	Super::SetupInputComponent();
	
	UEnhancedInputComponent* EnhInputComp = CastChecked<UEnhancedInputComponent>(InputComponent);
	EnhInputComp->BindAction(Input_Interact, ETriggerEvent::Triggered, this, &ARoguePlayerController::PrimaryInteract);

	// @todo: replace with Enhanced Input
	FInputActionBinding PauseBinding( "PauseMenu", IE_Pressed );
	PauseBinding.ActionDelegate.GetDelegateForManualSet().BindLambda( [this]()
	{
		Cast<ARogueHUD>(GetHUD())->TogglePauseMenu();
	});

	// Keeping as 'old' input for now until we figure out how to do this easily in Enhanced input
	InputComponent->BindAction("AnyKey", IE_Pressed, this, &ARoguePlayerController::AnyKeyInput);
}


void ARoguePlayerController::AnyKeyInput(FKey PressedKey)
{
	bIsUsingGamepad = PressedKey.IsGamepadKey();
}


void ARoguePlayerController::BeginPlayingState()
{
	Super::BeginPlayingState();
	
	BlueprintBeginPlayingState();
}

void ARoguePlayerController::OnRep_PlayerState()
{
	Super::OnRep_PlayerState();

	OnPlayerStateReceived.Broadcast(PlayerState);
}

void ARoguePlayerController::BeginPlay()
{
	Super::BeginPlay();
	
	if (HasAuthority())
	{
		check(PlayerState);
		// Broadcast locally, the host/standalone won't trigger the OnRep_PlayerState, only clients
		OnPlayerStateReceived.Broadcast(PlayerState);
	}
}

```

`Source/ActionRoguelike/Player/RoguePlayerController.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "RoguePlayerController.generated.h"

class URogueInteractionComponent;
class UInputAction;


DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnPlayerStateChanged, APlayerState*, NewPlayerState);


/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARoguePlayerController : public APlayerController
{
	GENERATED_BODY()

public:

	UFUNCTION(BlueprintPure, Category= "Input")
	bool IsUsingGamepad() const
	{
		return bIsUsingGamepad;
	}

protected:
	
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<URogueInteractionComponent> InteractionComp;
		
	UPROPERTY(EditDefaultsOnly, Category="Input")
	TObjectPtr<UInputAction> Input_Interact;

	void PrimaryInteract();

	virtual void SetupInputComponent() override;

	void AnyKeyInput(FKey PressedKey);
	
	// Listen for incoming player state (for clients this may be nullptr when initially joining a game, 
	// afterwards player state will not change again as PlayerControllers maintain the same player state throughout the level)
	UPROPERTY(BlueprintAssignable)
	FOnPlayerStateChanged OnPlayerStateReceived;

	/* Called when player controller is ready to begin playing, good moment to initialize things like UI which might be too early in BeginPlay 
		(esp. in multiplayer clients where not all data such as PlayerState may have been received yet) */
	virtual void BeginPlayingState() override;

	UFUNCTION(BlueprintImplementableEvent)
	void BlueprintBeginPlayingState();

	virtual void OnRep_PlayerState() override;

	virtual void BeginPlay() override;
	
private:

	/* Was any input recently using GamePad */
	bool bIsUsingGamepad = false;

public:

	ARoguePlayerController();
};

```

`Source/ActionRoguelike/Player/RoguePlayerData.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RoguePlayerData.h"

```

`Source/ActionRoguelike/Player/RoguePlayerData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "RoguePlayerData.generated.h"

class URogueAction;
class UInputAction;
class ARoguePlayerCharacter;
class UInputMappingContext;


/**
 * Data Configuration for Player including pawn class, abilities and input classes
 */
UCLASS()
class ACTIONROGUELIKE_API URoguePlayerData : public UDataAsset
{
	GENERATED_BODY()

public:
	
	//UPROPERTY(EditDefaultsOnly, Category="CharacterClass")
	//TSubclassOf<ARoguePlayerCharacter> CharacterClass; 
	
	//UPROPERTY(EditDefaultsOnly, Category="Actions")
	//TArray<TSubclassOf<URogueAction>> DefaultActions;

	// -- Input Actions -- //

	UPROPERTY(EditDefaultsOnly, Category="Input")
	TObjectPtr<UInputAction> Input_Move;

	UPROPERTY(EditDefaultsOnly, Category="Input")
	TObjectPtr<UInputAction> Input_LookMouse;

	UPROPERTY(EditDefaultsOnly, Category="Input")
	TObjectPtr<UInputAction> Input_LookStick;
	
	UPROPERTY(EditDefaultsOnly, Category="Input")
	TObjectPtr<UInputAction> Input_Jump;

	UPROPERTY(EditDefaultsOnly, Category="Input")
	TObjectPtr<UInputAction> Input_Sprint;
	
	UPROPERTY(EditDefaultsOnly, Category="Input")
	TObjectPtr<UInputAction> Input_Dash;
	
	UPROPERTY(EditDefaultsOnly, Category="Input")
	TObjectPtr<UInputAction> Input_PrimaryAttack;
	
	UPROPERTY(EditDefaultsOnly, Category="Input")
	TObjectPtr<UInputAction> Input_SecondaryAttack;

};

```

`Source/ActionRoguelike/Player/RoguePlayerState.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Player/RoguePlayerState.h"

#include "ActionRoguelike.h"
#include "SaveSystem/RogueSaveGame.h"
#include "Net/UnrealNetwork.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RoguePlayerState)


void ARoguePlayerState::AddCredits(int32 Delta)
{
	// Avoid user-error of adding a negative amount
	if (!ensure(Delta >= 0.0f))
	{
		return;
	}

	Credits += Delta;

	OnCreditsChanged.Broadcast(this, Credits, Delta);
}


bool ARoguePlayerState::TryRemoveCredits(int32 Delta)
{
	// Avoid user-error of adding a subtracting negative amount
	if (!ensure(Delta >= 0.0f))
	{
		return false;
	}

	if (Credits < Delta)
	{
		// Not enough credits available
		return false;
	}

	Credits -= Delta;

	OnCreditsChanged.Broadcast(this, Credits, -Delta);

	return true;
}


bool ARoguePlayerState::UpdatePersonalRecord(float NewTime)
{
	// Higher time is better
	if (NewTime > PersonalRecordTime)
	{
		float OldRecord = PersonalRecordTime;

		PersonalRecordTime = NewTime;

		OnRecordTimeChanged.Broadcast(this, PersonalRecordTime, OldRecord);

		return true;
	}

	return false;
}


void ARoguePlayerState::SavePlayerState_Implementation(URogueSaveGame* SaveObject)
{
	if (SaveObject)
	{
		// Gather all relevant data for player
		FPlayerSaveData SaveData;
		SaveData.Credits = Credits;
		SaveData.PersonalRecordTime = PersonalRecordTime;
		// Stored as FString for simplicity (original Steam ID is uint64)
		SaveData.PlayerID = GetUniqueId().ToString();

		// May not be alive while we save
		if (APawn* MyPawn = GetPawn())
		{
			SaveData.Location = MyPawn->GetActorLocation();
			SaveData.Rotation = MyPawn->GetActorRotation();
			SaveData.bResumeAtTransform = true;
		}
		
		SaveObject->SavedPlayers.Add(SaveData);
	}
}


void ARoguePlayerState::LoadPlayerState_Implementation(URogueSaveGame* SaveObject)
{
	if (SaveObject)
	{
		FPlayerSaveData* FoundData = SaveObject->GetPlayerData(this);
		if (FoundData)
		{
			// Makes sure we trigger credits changed event
			AddCredits(FoundData->Credits);

			PersonalRecordTime = FoundData->PersonalRecordTime;
		}
		else
		{
			UE_LOGFMT(LogGame, Warning, "Could not find SaveGame data for player id: {playerid}.", GetPlayerId());
		}
	}
}


void ARoguePlayerState::OnRep_Credits(int32 OldCredits)
{
	OnCreditsChanged.Broadcast(this, Credits, Credits - OldCredits);
}


int32 ARoguePlayerState::GetCredits() const
{
	return Credits;
}


void ARoguePlayerState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ARoguePlayerState, Credits);
}
```

`Source/ActionRoguelike/Player/RoguePlayerState.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerState.h"
#include "RoguePlayerState.generated.h"

class ARoguePlayerState; // Forward declared to satisfy the delegate macros below
class URogueSaveGame;

// Event Handler for Credits
DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(FOnCreditsChanged, ARoguePlayerState*, PlayerState, int32, NewCredits, int32, Delta);
// Event Handler for Personal Record Time
DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(FOnRecordTimeChanged, ARoguePlayerState*, PlayerState, float, NewTime, float, OldRecord);

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARoguePlayerState : public APlayerState
{
	GENERATED_BODY()
	
protected:

	UPROPERTY(Transient, EditDefaultsOnly, ReplicatedUsing="OnRep_Credits", Category = "Credits")
	int32 Credits;

	UPROPERTY(Transient, BlueprintReadOnly)
	float PersonalRecordTime;

	// OnRep_ can use a parameter containing the 'old value' of the variable it is bound to. Very useful in this case to figure out the 'delta'.
	UFUNCTION()
	void OnRep_Credits(int32 OldCredits);

public:

	/* Checks current record and only sets if better time was passed in. */
	UFUNCTION(BlueprintCallable)
	bool UpdatePersonalRecord(float NewTime);

	UFUNCTION(BlueprintCallable, Category = "Credits")
	int32 GetCredits() const;

	UFUNCTION(BlueprintCallable, Category = "Credits")
	void AddCredits(int32 Delta);

	UFUNCTION(BlueprintCallable, Category = "Credits")
	bool TryRemoveCredits(int32 Delta);

	UPROPERTY(BlueprintAssignable, Category = "Events")
	FOnCreditsChanged OnCreditsChanged;

	UPROPERTY(BlueprintAssignable, Category = "Events")
	FOnRecordTimeChanged OnRecordTimeChanged;

	UFUNCTION(BlueprintNativeEvent)
	void SavePlayerState(URogueSaveGame* SaveObject);

	UFUNCTION(BlueprintNativeEvent)
	void LoadPlayerState(URogueSaveGame* SaveObject);

};

```

`Source/ActionRoguelike/Projectiles/RogueProjectile.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueProjectile.h"
#include "Components/SphereComponent.h"
#include "Projectiles/RogueProjectileMovementComponent.h"
#include "NiagaraComponent.h"
#include "NiagaraFunctionLibrary.h"
#include "Kismet/GameplayStatics.h"
#include "Components/AudioComponent.h"
#include "ProfilingDebugging/CountersTrace.h"
#include "Performance/RogueActorPoolingSubsystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueProjectile)

TRACE_DECLARE_INT_COUNTER(COUNTER_GAME_ActiveProjectiles, TEXT("Game/ActiveProjectiles"));

ARogueProjectile::ARogueProjectile()
{
	SphereComp = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComp"));
	SphereComp->SetCollisionProfileName("Projectile");
	// Dont bother telling the nav system whenever we move
	SphereComp->SetCanEverAffectNavigation(false);
	RootComponent = SphereComp;

	NiagaraLoopComp = CreateDefaultSubobject<UNiagaraComponent>(TEXT("EffectComp"));
	//NiagaraLoopComp->PoolingMethod = ENCPoolMethod::AutoRelease;
	NiagaraLoopComp->SetupAttachment(RootComponent);

	AudioComp = CreateDefaultSubobject<UAudioComponent>(TEXT("AudioComp"));
	AudioComp->SetupAttachment(RootComponent);

	// Custom Projectile Component (for tick management & better homing)
	MoveComp = CreateDefaultSubobject<URogueProjectileMovementComponent>(TEXT("ProjectileMoveComp"));
	MoveComp->bRotationFollowsVelocity = true;
	MoveComp->bInitialVelocityInLocalSpace = true;
	MoveComp->ProjectileGravityScale = 0.0f;
	MoveComp->InitialSpeed = 8000;

	// Directly set bool instead of going through SetReplicates(true) within constructor,
	// Only use SetReplicates() outside constructor
	bReplicates = true;
}


void ARogueProjectile::PostInitializeComponents()
{
	Super::PostInitializeComponents();
	
	// More consistent to bind here compared to Constructor which may fail to bind if Blueprint was created before adding this binding (or when using hotreload)
	// PostInitializeComponent is the preferred way of binding any events.
	SphereComp->OnComponentHit.AddDynamic(this, &ARogueProjectile::OnActorHit);
}


void ARogueProjectile::BeginPlay()
{
	Super::BeginPlay();

	// Can use to fine-tune the pre allocated actor pool by checking how many projectiles are alive during gameplay
	TRACE_COUNTER_INCREMENT(COUNTER_GAME_ActiveProjectiles);
}

void ARogueProjectile::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);
	TRACE_COUNTER_DECREMENT(COUNTER_GAME_ActiveProjectiles);
}


void ARogueProjectile::PoolBeginPlay_Implementation()
{
	MoveComp->Reset();
	
	//NiagaraLoopComp->Activate();
	//AudioComp->Play();
	
	// Unpausing is significantly faster than re-creating renderstates due to Deactivate()
	// Does keep its state around which is OK for our loopable VFX that will mostly be active/in-use
	NiagaraLoopComp->SetPaused(false);
	// Reset to fix ribbon positions
	//NiagaraLoopComp->ResetSystem();
	AudioComp->SetPaused(false);

}


void ARogueProjectile::PoolEndPlay_Implementation()
{
	//NiagaraLoopComp->Deactivate();
	//AudioComp->Stop();
	NiagaraLoopComp->SetPaused(true);
	AudioComp->SetPaused(true);
}

float ARogueProjectile::GetDefaultSpeed() const
{
	return MoveComp->InitialSpeed;
}

float ARogueProjectile::GetGravityScale() const
{
	return MoveComp->ProjectileGravityScale;
}


void ARogueProjectile::LifeSpanExpired()
{
	// Skip destroy and instead release to pool
	URogueActorPoolingSubsystem::ReleaseToPool(this);
}


void ARogueProjectile::OnActorHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)
{
	Explode();
}


// _Implementation from it being marked as BlueprintNativeEvent
void ARogueProjectile::Explode_Implementation()
{
	// Auto-managed particle pooling
	UNiagaraFunctionLibrary::SpawnSystemAtLocation(this, ImpactVFX, GetActorLocation(), GetActorRotation(), FVector(1), true, true, ENCPoolMethod::AutoRelease);

	UGameplayStatics::PlaySoundAtLocation(this, ImpactSound, GetActorLocation());

	UGameplayStatics::PlayWorldCameraShake(this, ImpactShake, GetActorLocation(), ImpactShakeInnerRadius, ImpactShakeOuterRadius);

	// @todo: only destroy on host. the client should only make itself dormant.
	//Destroy();
	
	// Release back to pool instead of destroying
	URogueActorPoolingSubsystem* PoolingSubsystem = GetWorld()->GetSubsystem<URogueActorPoolingSubsystem>();
	PoolingSubsystem->ReleaseToPool(this);
}


```

`Source/ActionRoguelike/Projectiles/RogueProjectile.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Performance/RogueActorPoolingInterface.h"
#include "GameFramework/Actor.h"
#include "RogueProjectile.generated.h"

class UNiagaraSystem;
class USphereComponent;
class URogueProjectileMovementComponent;
class UNiagaraComponent;
class UAudioComponent;
class USoundBase;
class UCameraShakeBase;

/*
 * 
 */
UCLASS(ABSTRACT) // 'ABSTRACT' marks this class as incomplete, keeping this out of certain dropdowns windows like SpawnActor in Unreal Editor
class ACTIONROGUELIKE_API ARogueProjectile : public AActor, public IRogueActorPoolingInterface
{
	GENERATED_BODY()

protected:
		
	UPROPERTY(EditDefaultsOnly, Category = "Effects|Shake")
	float ImpactShakeInnerRadius;

	UPROPERTY(EditDefaultsOnly, Category = "Effects|Shake")
	float ImpactShakeOuterRadius;

	UPROPERTY(EditDefaultsOnly, Category = "Effects|Shake")
	TSubclassOf<UCameraShakeBase> ImpactShake;

	UPROPERTY(EditDefaultsOnly, Category = "Effects")
	TObjectPtr<UNiagaraSystem> ImpactVFX;

	UPROPERTY(EditDefaultsOnly, Category = "Effects")
	TObjectPtr<USoundBase> ImpactSound;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<USphereComponent> SphereComp;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<URogueProjectileMovementComponent> MoveComp;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<UNiagaraComponent> NiagaraLoopComp;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
	TObjectPtr<UAudioComponent> AudioComp;

	// 'virtual' so we can override this in child-classes
	UFUNCTION()
	virtual void OnActorHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);

	// BlueprintNativeEvent = C++ base implementation, can be expanded in Blueprints
	// BlueprintCallable to allow child classes to trigger explosions
	// Not required for assignment, useful for expanding in Blueprint later on
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent)
	void Explode();

	virtual void PostInitializeComponents() override;

public:	
	ARogueProjectile();

	virtual void BeginPlay() override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

	virtual void LifeSpanExpired() override;

	virtual void PoolBeginPlay_Implementation() override;

	virtual void PoolEndPlay_Implementation() override;

	float GetDefaultSpeed() const;

	float GetGravityScale() const;

};

```

`Source/ActionRoguelike/Projectiles/RogueProjectileData.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueProjectileData.h"

```

`Source/ActionRoguelike/Projectiles/RogueProjectileData.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "RogueProjectileData.generated.h"

class UNiagaraDataChannelAsset;
class UNiagaraSystem;

/**
 * Projectile Configuration for Data-oriented implementation of Projectiles
 * (Actorless) purely handled through simple data arrays in RogueProjectileSubsystem
 */
UCLASS()
class ACTIONROGUELIKE_API URogueProjectileData : public UDataAsset
{
	GENERATED_BODY()

public:
	
	UPROPERTY(EditDefaultsOnly, Category= "Projectile")
	TObjectPtr<UNiagaraSystem> ProjectileEffect;

	/* Note: Usually this would have multiple options based on hit PhysicsMaterial such as blood impact for hitting enemies */
	UPROPERTY(EditDefaultsOnly, Category= "Projectile")
	TObjectPtr<UNiagaraSystem> ImpactEffect;

	UPROPERTY(EditDefaultsOnly, Category= "Projectile")
	TObjectPtr<UNiagaraDataChannelAsset> ImpactDecal_DataChannel;

	UPROPERTY(EditDefaultsOnly, Category= "Projectile")
	float InitialSpeed = 2000.0f;

	//UPROPERTY(EditDefaultsOnly, Category= "Projectile")
	//float GravityScale = 0.0f;

	UPROPERTY(EditDefaultsOnly, Category= "Projectile")
	float Lifespan = 10.0f;

	/* Use Instigator's AttackDamage attribute multiplied by this coefficient as a percentage */
	UPROPERTY(EditDefaultsOnly, Category= "Projectile", meta=(Units="Percent"))
	float DamageCoefficient = 100;
};

```

`Source/ActionRoguelike/Projectiles/RogueProjectileMovementComponent.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Projectiles/RogueProjectileMovementComponent.h"
#include "Performance/RogueTickablesSubsystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueProjectileMovementComponent)


void URogueProjectileMovementComponent::BeginPlay()
{
	Super::BeginPlay();
	
	// BeginPlay on the component will be called after the tick has been registered via the owning Actor
	URogueTickablesSubsystem* Tickables = GetWorld()->GetSubsystem<URogueTickablesSubsystem>();
	Tickables->RegisterComponent(&PrimaryComponentTick);
}


void URogueProjectileMovementComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);
	
	URogueTickablesSubsystem* Tickables = GetWorld()->GetSubsystem<URogueTickablesSubsystem>();
	Tickables->DeRegisterComponent(&PrimaryComponentTick);
}


void URogueProjectileMovementComponent::Reset()
{
	// Reset to default for object pooling support
	Velocity = FVector(1,0,0);

	// Properly resets velocities and rotations
	InitializeComponent();
}
```

`Source/ActionRoguelike/Projectiles/RogueProjectileMovementComponent.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/ProjectileMovementComponent.h"
#include "RogueProjectileMovementComponent.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueProjectileMovementComponent : public UProjectileMovementComponent
{
	GENERATED_BODY()
	
	virtual void BeginPlay() override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

public:
	
	void Reset();

};

```

`Source/ActionRoguelike/Projectiles/RogueProjectileReplication.cpp`:

```cpp
#include "RogueProjectileReplication.h"

#include "RogueProjectilesSubsystem.h"


void FProjectileItem::PostReplicatedAdd(const FProjectileArray& InArraySerializer)
{
	InArraySerializer.OwningSubsystem->InternalCreateProjectile(this->InitialPosition, InitialDirection, ConfigDataAsset, InstigatorActor, ID);
}


void FProjectileItem::PreReplicatedRemove(const FProjectileArray& InArraySerializer)
{
	// It can happen that clients already removed the projectile ID locally from its local collision checks
	InArraySerializer.OwningSubsystem->RemoveProjectileID(ID);
}


void FProjectileItem::PostReplicatedChange(const FProjectileArray& InArraySerializer)
{
	// Check if hit was set
	if (Hit.GetActor() && !bHasPlayedImpact)
	{
		bHasPlayedImpact = true;
		
		FRotator ImpactRotation = (Hit.TraceEnd - Hit.TraceStart).GetSafeNormal().Rotation();
		UWorld* World = InArraySerializer.OwningSubsystem->GetWorld();

		InArraySerializer.OwningSubsystem->SpawnImpactFX(World, *this, Hit.Location, ImpactRotation);
	}
		
	//DrawDebugDirectionalArrow(World, Hit.Location, (Hit.Location + (ImpactRotation.Vector() * 50.0f)), 20.0f, FColor::Green, false, 5.0f);
	//DrawDebugSphere(World, Hit.Location, 32.0f, 32, FColor::Orange, false, 5.f);
}
```

`Source/ActionRoguelike/Projectiles/RogueProjectileReplication.h`:

```h
#pragma once

#include "RogueProjectileData.h"
#include "Net/Serialization/FastArraySerializer.h"
#include "RogueProjectileReplication.generated.h"


class URogueProjectilesSubsystem;
struct FProjectileArray;
class UNiagaraComponent;

/*
 * Data oriented projectile data to replicate and bookkeeping for all data which we dont need every frame
 * The other array handles the per-frame data such as current position and velocity
 */
USTRUCT()
struct FProjectileItem : public FFastArraySerializerItem
{
	GENERATED_BODY()

	FProjectileItem(FVector InPosition, FVector InDirection, URogueProjectileData* InDataAsset, AActor* InActor, uint32 InstanceID, float InExpirationTime):
		InitialPosition(InPosition),
		InitialDirection(InDirection),
		ConfigDataAsset(InDataAsset),
		InstigatorActor(InActor),
		ID(InstanceID),
		ExpirationGameTime(InExpirationTime)
	{
	}

	FProjectileItem() :
		InitialPosition(FVector::ZeroVector),
		InitialDirection(FVector::ForwardVector),
		ConfigDataAsset(nullptr),
		InstigatorActor(nullptr),
		ID(-1)
	{
	}

	FProjectileItem(uint32 InID) :
		InitialPosition(FVector::ZeroVector),
		InitialDirection(FVector::ZeroVector),
		ConfigDataAsset(nullptr),
		InstigatorActor(nullptr),
		ID(InID)
	{
	}

	UPROPERTY()
	FVector InitialPosition;

	UPROPERTY()
	FVector InitialDirection;

	UPROPERTY() // @todo: can we replicate this asset pointer?
	URogueProjectileData* ConfigDataAsset;

	UPROPERTY()
	AActor* InstigatorActor;
		
	/* ID for tracking with the instance data */
	UPROPERTY()
	uint32 ID;

	/* Replicated once we have hit something @todo: does this happen in time as we also remove the item directly upon hit, maybe first we disable the projectile and delete it slightly later?? */
	UPROPERTY()
	FHitResult Hit;

	/* Check to avoid double playback of impact VFX as we can locally predict impacts and also later receive HitResult from server via replication. if we already played VFX we can skip */
	UPROPERTY(NotReplicated)
	bool bHasPlayedImpact = false;

	/* Server-side lifespan check, built from current game time + initial lifespan = expiration time */
	UPROPERTY(NotReplicated)
	float ExpirationGameTime = 0;

	UPROPERTY(NotReplicated)
	UNiagaraComponent* TracerEffectComp = nullptr;
	
	void PostReplicatedAdd(const FProjectileArray& InArraySerializer);
	void PreReplicatedRemove(const FProjectileArray& InArraySerializer);
	void PostReplicatedChange(const FProjectileArray& InArraySerializer);
	
	bool operator==(const FProjectileItem& OtherConfig) const
	{
		return OtherConfig.ID == ID;
	}
};

/*
 * 
 */
USTRUCT()
struct FProjectileArray: public FFastArraySerializer
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(NotReplicated)
	URogueProjectilesSubsystem* OwningSubsystem = nullptr;

	UPROPERTY()
	TArray<FProjectileItem> Items;

	bool NetDeltaSerialize(FNetDeltaSerializeInfo & DeltaParms)
	{
		return FFastArraySerializer::FastArrayDeltaSerialize<FProjectileItem, FProjectileArray>( Items, DeltaParms, *this );
	}
};

template<>
struct TStructOpsTypeTraits<FProjectileArray> : public TStructOpsTypeTraitsBase2<FProjectileArray>
{
	enum 
	{
		WithNetDeltaSerializer = true,
   };
};


```

`Source/ActionRoguelike/Projectiles/RogueProjectile_Blackhole.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueProjectile_Blackhole.h"

#include "Animation/RogueCurveAnimSubsystem.h"
#include "Components/SphereComponent.h"
#include "PhysicsEngine/RadialForceComponent.h"


ARogueProjectile_Blackhole::ARogueProjectile_Blackhole()
{
	RadialForceComp = CreateDefaultSubobject<URadialForceComponent>(TEXT("RadialForceComp"));
	RadialForceComp->SetupAttachment(RootComponent);
	// Roundabout way of removing the object type...
	RadialForceComp->RemoveObjectTypeToAffect(UEngineTypes::ConvertToObjectType(ECC_Pawn));
	//RadialForceComp->Radius = 1000.f;
	RadialForceComp->ForceStrength = -2000000.f;

	MaxRadius = 1000.f;

	// Match with VFX
	InitialLifeSpan = 4.8f;

	// Skip any collision for this projectile
	// Only look for "PhysicsBody" (we are looking to "Absorb" only physics simulating actors) 
	SphereComp->SetCollisionResponseToAllChannels(ECR_Ignore);
	SphereComp->SetCollisionResponseToChannel(ECC_PhysicsBody, ECR_Overlap);
}

void ARogueProjectile_Blackhole::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	SphereComp->OnComponentBeginOverlap.AddDynamic(this, &ARogueProjectile_Blackhole::OnOverlappedPhysicsActor);
}


void ARogueProjectile_Blackhole::OnOverlappedPhysicsActor(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,
	int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (OtherComp->IsSimulatingPhysics())
	{
		OtherActor->Destroy();
	}
}


void ARogueProjectile_Blackhole::BeginPlay()
{
	Super::BeginPlay();

	// Fun little bonus, grow and shrink the influence radius of the radial force over time.
	if (AnimRadiusCurve)
	{
		URogueCurveAnimSubsystem* AnimSubsystem = GetWorld()->GetSubsystem<URogueCurveAnimSubsystem>();

		// Figure out the playrate to match the lifespan
		float MinTime;
		float MaxTime;
		AnimRadiusCurve->FloatCurve.GetTimeRange(MinTime, MaxTime);

		float Duration = MaxTime - MinTime;

		// Match the animation length with the lifespan of the actor
		float PlayRate = Duration / GetLifeSpan();

		AnimSubsystem->PlayCurveAnim(AnimRadiusCurve, PlayRate, [&](float CurrentValue)
		{
			RadialForceComp->Radius = MaxRadius * CurrentValue;

			DrawDebugSphere(GetWorld(), GetActorLocation(), RadialForceComp->Radius, 32, FColor::Blue, false, 0.f);
		});
	}
}

```

`Source/ActionRoguelike/Projectiles/RogueProjectile_Blackhole.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "RogueProjectile.h"
#include "RogueProjectile_Blackhole.generated.h"

class URadialForceComponent;

UCLASS(Abstract)
class ACTIONROGUELIKE_API ARogueProjectile_Blackhole : public ARogueProjectile
{
	GENERATED_BODY()

protected:

	UPROPERTY(VisibleDefaultsOnly, Category=Components)
	TObjectPtr<URadialForceComponent> RadialForceComp;

	UPROPERTY(EditDefaultsOnly, Category=Animation)
	UCurveFloat* AnimRadiusCurve;

	UPROPERTY(EditDefaultsOnly, Category=Animation)
	float MaxRadius;

	UFUNCTION()
	void OnOverlappedPhysicsActor(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,
		int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

public:

	virtual void PostInitializeComponents() override;

	virtual void BeginPlay() override;

	ARogueProjectile_Blackhole();
};

```

`Source/ActionRoguelike/Projectiles/RogueProjectile_Dash.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueProjectile_Dash.h"
#include "Kismet/GameplayStatics.h"
#include "NiagaraComponent.h"
#include "NiagaraFunctionLibrary.h"
#include "Player/RoguePlayerController.h"
#include "Projectiles/RogueProjectileMovementComponent.h"
#include "Sound/SoundCue.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueProjectile_Dash)




ARogueProjectile_Dash::ARogueProjectile_Dash()
{
	TeleportDelay = 0.2f;
	DetonateDelay = 0.2f;

	MoveComp->InitialSpeed = 6000.f;
}


void ARogueProjectile_Dash::BeginPlay()
{
	Super::BeginPlay();

	GetWorldTimerManager().SetTimer(TimerHandle_DelayedDetonate, this, &ARogueProjectile_Dash::Explode, DetonateDelay);
}


void ARogueProjectile_Dash::Explode_Implementation()
{
	// Clear timer if the Explode was already called through another source like OnActorHit
	GetWorldTimerManager().ClearTimer(TimerHandle_DelayedDetonate);

	UNiagaraFunctionLibrary::SpawnSystemAtLocation(this, ImpactVFX, GetActorLocation(), GetActorRotation());

	UGameplayStatics::PlaySoundAtLocation(this, ImpactSound, GetActorLocation());

	NiagaraLoopComp->Deactivate();

	MoveComp->StopMovementImmediately();
	SetActorEnableCollision(false);

	FTimerHandle TimerHandle_DelayedTeleport;
	GetWorldTimerManager().SetTimer(TimerHandle_DelayedTeleport, this, &ARogueProjectile_Dash::TeleportInstigator, TeleportDelay);

	// Skip base implementation as it will destroy actor (we need to stay alive a bit longer to finish the 2nd timer)
	//Super::Explode_Implementation();
}


void ARogueProjectile_Dash::TeleportInstigator()
{
	AActor* ActorToTeleport = GetInstigator();
	// Must be set in spawning code (also good for things like knowing who caused the damage)
	check(ActorToTeleport);

	// Keep instigator rotation or it may end up jarring
	ActorToTeleport->TeleportTo(GetActorLocation(), ActorToTeleport->GetActorRotation(), false, false);

	// Play shake on the player we teleported
	const APawn* InstigatorPawn = CastChecked<APawn>(ActorToTeleport);
	APlayerController* PC = InstigatorPawn->GetController<ARoguePlayerController>();
	// Controller can be nullptr if we died (and detached the pawn) just after launching the dash projectile
	if (PC && PC->IsLocalController())
	{
		PC->PlayerCameraManager->StartCameraShake(ImpactShake);
	}

	// Now we're ready to destroy self
	Destroy();
}

```

`Source/ActionRoguelike/Projectiles/RogueProjectile_Dash.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "RogueProjectile.h"
#include "RogueProjectile_Dash.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARogueProjectile_Dash : public ARogueProjectile
{
	GENERATED_BODY()

protected:

	UPROPERTY(EditDefaultsOnly, Category = "Teleport")
	float TeleportDelay;

	UPROPERTY(EditDefaultsOnly, Category = "Teleport")
	float DetonateDelay;

	// Handle to cancel timer if we already hit something
	FTimerHandle TimerHandle_DelayedDetonate;

	// Base class using BlueprintNativeEvent, we must override the _Implementation not the Explode()
	virtual void Explode_Implementation() override;

	void TeleportInstigator();

	virtual void BeginPlay() override;

public:

	ARogueProjectile_Dash();
};

```

`Source/ActionRoguelike/Projectiles/RogueProjectile_Magic.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueProjectile_Magic.h"
#include "Components/SphereComponent.h"
#include "Core/RogueGameplayFunctionLibrary.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Projectiles/RogueProjectileMovementComponent.h"
#include "ActionSystem/RogueActionEffect.h"
#include "Core/RogueDeferredTaskSystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueProjectile_Magic)


ARogueProjectile_Magic::ARogueProjectile_Magic()
{
	SphereComp->SetSphereRadius(20.0f);
	InitialLifeSpan = 10.0f;
	DamageCoefficient = 100.0f;
}


void ARogueProjectile_Magic::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	// More consistent to bind here compared to Constructor which may fail to bind if Blueprint was created before adding this binding (or when using hotreload)
	// PostInitializeComponent is the preferred way of binding any events.
	SphereComp->OnComponentBeginOverlap.AddDynamic(this, &ARogueProjectile_Magic::OnActorOverlap);
}


void ARogueProjectile_Magic::OnActorOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,
	int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (OtherActor && OtherActor != GetInstigator())
	{
		// Parry Ability (GameplayTag Example)
		URogueActionComponent* OtherActionComp = URogueGameplayFunctionLibrary::GetActionComponentFromActor(OtherActor);
		if (OtherActionComp && OtherActionComp->ActiveGameplayTags.HasTag(ParryTag))
		{
			MoveComp->Velocity = -MoveComp->Velocity;

			// The reflector now becomes the 'instigator' of the damage from the reflected projectile
			SetInstigator(Cast<APawn>(OtherActor));
			return;
		}

		// This could contain things such as CriticalHit, Blocked etc. to tell other systems what special damage handling should be done
		FGameplayTagContainer ContextTags;

		// Overlaps will happen on clients too, and clients only should respond immediately cosmetically
		// letting the server deal the actual damage. eg. we can "Explode" but only the server will ApplyDamage
		if (URogueGameplayFunctionLibrary::CanApplyDamage(GetInstigator(), OtherActor, ContextTags))
		{
			// We only explode if the target can be damaged, it ignores anything it Overlaps that it cannot Damage
			Explode();

			if (HasAuthority())
			{
				// Apply Damage & Impulse
				URogueGameplayFunctionLibrary::ApplyDirectionalDamage(GetInstigator(), OtherActor, DamageCoefficient, SweepResult, ContextTags);
				
				APawn* MyInstigator = GetInstigator();
				if (OtherActionComp && BurningActionClass)
				{
#if USE_DEFERRED_TASKS
					// Delay adding the burning FX if necessary
					URogueDeferredTaskSystem::AddLambda(this, [OtherActionComp,MyInstigator,this]()
						{
							OtherActionComp->AddAction(MyInstigator, BurningActionClass);
						});
#else
					OtherActionComp->AddAction(MyInstigator, BurningActionClass);
#endif
				}
			}
		}
	}
}
```

`Source/ActionRoguelike/Projectiles/RogueProjectile_Magic.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "RogueProjectile.h"
#include "GameplayTagContainer.h"
#include "RogueProjectile_Magic.generated.h"

class URogueActionEffect;


UCLASS(Abstract)
class ACTIONROGUELIKE_API ARogueProjectile_Magic : public ARogueProjectile
{
	GENERATED_BODY()

public:

	ARogueProjectile_Magic();
	
	UPROPERTY(EditDefaultsOnly, Category = "Damage", meta=(Units="Percent"))
	float DamageCoefficient;

	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	FGameplayTag ParryTag;

	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	TSubclassOf<URogueActionEffect> BurningActionClass;
	
protected:

	UFUNCTION()
	void OnActorOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);

	virtual void PostInitializeComponents() override;

};

```

`Source/ActionRoguelike/Projectiles/RogueProjectilesSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueProjectilesSubsystem.h"

#include "ActionRoguelike.h"
#include "GenericTeamAgentInterface.h"
#include "NiagaraComponent.h"
#include "NiagaraDataChannel.h"
#include "NiagaraDataChannelAccessor.h"
#include "NiagaraFunctionLibrary.h"
#include "RogueProjectileData.h"
#include "Core/RogueGameState.h"
#include "ProfilingDebugging/CountersTrace.h"

TRACE_DECLARE_INT_COUNTER(LightweightProjectilesCount, TEXT("Game/DataOnlyProjectileCount"));


int32 URogueProjectilesSubsystem::CreateProjectile(FVector InPosition, FVector InDirection, URogueProjectileData* ProjectileConfig, AActor* InstigatorActor)
{
	UWorld* World = GetWorld();
		
	uint32 InstanceID = GetUniqueProjID(InPosition, World->TimeSeconds);
	
	if (HasAuthority())
	{
		InternalCreateProjectile(InPosition, InDirection, ProjectileConfig, InstigatorActor, InstanceID);
	}
	else // Client
	{
		// Push to server, locally we also create the pojectile immediately to avoid any latency
		ARogueGameState* GS = World->GetGameState<ARogueGameState>();
		GS->ServerCreateProjectile(InPosition, InDirection, ProjectileConfig, InstigatorActor, InstanceID);
		
		InternalCreateProjectile(InPosition, InDirection, ProjectileConfig, InstigatorActor, InstanceID);
	}

	return InstanceID;
}

// @todo: rename as this is used 'outside' this class too
void URogueProjectilesSubsystem::InternalCreateProjectile(FVector InPosition, FVector InDirection, URogueProjectileData* ProjectileConfig, AActor* InstigatorActor, uint32 NewID)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(CreateProjectile);

	check(ProjectileConfig);

	// for clients, we first locate an existing projectile inst as we might have spawned it ourselves
	FProjectileInstance* ExistingInst = ProjectileInstances.FindByPredicate([NewID](FProjectileInstance& Item){ return NewID == Item.ID;  });
	if (ExistingInst)
	{
		// Everything is setup if we already created the projectile earlier als client.
		// @todo-test: what happens if we hit immediately after spawning, even before the server received and send back the info...
		return;	
	}
		
	UWorld* World = GetWorld();
	// Now assign the FX Comp to the ProjectileConfig already in the local array
	FProjectileArray& ProjectileConfigs = World->GetGameState<ARogueGameState>()->ProjectileData;
	
	// Active data that represents the moving projectile
	FProjectileInstance ProjInfo = FProjectileInstance(InPosition, InDirection * ProjectileConfig->InitialSpeed, NewID);
	ProjectileInstances.Add(ProjInfo);

	UNiagaraComponent* EffectComp = UNiagaraFunctionLibrary::SpawnSystemAtLocation(
		World, ProjectileConfig->ProjectileEffect, InPosition,
		InDirection.Rotation(), FVector(1), true, true, ENCPoolMethod::AutoRelease);

	// The component stays in world space, the emitters themselves move along the axis of the projectile to match
	// the collision query locations
	const FName UserParamName = "ProjectileVelocity";
	FVector LocalVelocity = FVector::ForwardVector * ProjectileConfig->InitialSpeed;
	EffectComp->SetVariablePosition(UserParamName, LocalVelocity);

	// May exist on the client that spawned this through "prediction"
	FProjectileItem* Data = ProjectileConfigs.Items.FindByPredicate(
	[NewID](FProjectileItem& Item){ return NewID == Item.ID;  });

	// Expected on server or when a client spawns his own projectile before calling the server (RPC)
	if (Data)
	{
		Data->TracerEffectComp = EffectComp;
	}
	else 
	{
		float ExpirationGameTime = World->TimeSeconds + ProjectileConfig->Lifespan;
		// Full data of the projectile instance, used for bookkeeping and replication, not constantly updated
		FProjectileItem Info = FProjectileItem(InPosition, InDirection, ProjectileConfig, InstigatorActor, NewID, ExpirationGameTime);
		
		Info.TracerEffectComp = EffectComp;

		// @todo: unclear if this is OK to add to array on clients, as we may desync the array between server/client
		// if not, I may need to keep a local array as temp lookup until the server updates his array.
		ProjectileConfigs.Items.Add(Info);
		ProjectileConfigs.MarkItemDirty(Info);

	}
}


void URogueProjectilesSubsystem::RemoveProjectileID(uint32 IdToRemove)
{
	UWorld* World = GetWorld();

	FProjectileArray& DataArray = World->GetGameState<ARogueGameState>()->ProjectileData;

	// @todo: faster lookup available like a local TMap cache
	FProjectileItem& ProjConfig = *DataArray.Items.FindByPredicate([IdToRemove](FProjectileItem& Item){ return IdToRemove == Item.ID;  });
	
	if (ProjConfig.TracerEffectComp)
	{
		ProjConfig.TracerEffectComp->Deactivate();
		//FXComp->ReleaseToPool();
		ProjConfig.TracerEffectComp = nullptr;
	}

	if (ProjConfig.Hit.GetActor() && !ProjConfig.bHasPlayedImpact)
	{
		ProjConfig.bHasPlayedImpact = true;

		// Projectile direction, good for orienting the VFX, decal will use surface normal instead
		FRotator ImpactRotation = (ProjConfig.Hit.TraceEnd - ProjConfig.Hit.TraceStart).GetSafeNormal().Rotation();
		
		SpawnImpactFX(World, ProjConfig, ProjConfig.Hit.Location, ImpactRotation);
	}
	
	//DrawDebugBox(World, ProjConfig.Hit.Location, FVector(40.0f), FColor::Red, false, 2.0f);

	FProjectileInstance TempInst = FProjectileInstance(IdToRemove);
	// Perhaps hacky to use a temp struct to 'find' it by ID in the array
	ProjectileInstances.Remove(TempInst);
}


void URogueProjectilesSubsystem::Tick(float DeltaTime)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(UpdateProjectiles);

	const UWorld* World = GetWorld();

	ECollisionChannel CollisionChannel = COLLISION_PROJECTILE;

	FCollisionShape Shape;
	Shape.SetSphere(20.0f);

	// Track projectiles to end this frame for batched update
	TArray<int32> ProjectileHitIDs;

	ARogueGameState* GS = World->GetGameState<ARogueGameState>();
	if (GS == nullptr)
	{
		// While joining we may not have the gamestate yet on clients
		return;
	}

	FProjectileArray& ProjectileConfigs = World->GetGameState<ARogueGameState>()->ProjectileData;

	TRACE_COUNTER_SET(LightweightProjectilesCount, ProjectileInstances.Num());
	
	// @TODO & Notes
	// We could cache a collision params to ignore instigator during the sweep, now I dont want to fetch instigator from the metadata every time
	//		so instead we end up only filtering against this when any overlap is found, which currently works well enough
	
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(MoveProjectiles);
		
		for (int32 ProjIndex = 0; ProjIndex < ProjectileInstances.Num(); ProjIndex++)
		{
			FProjectileInstance& Proj = ProjectileInstances[ProjIndex];

			// Where we want to end up "next frame" (once we move to async queries)
			FVector NextPosition = Proj.Position + (Proj.Velocity * DeltaTime);

			{
				// Debug Only
				//FProjectileConfig& ProjConfig = *ProjectileConfigs.Items.FindByPredicate([Proj](const FProjectileConfig& OtherProj){ return Proj.ID == OtherProj.ID;  });

				// We are somehow not seeing consistent tracer lifetimes
				//check(ProjConfig.TracerEffectComp && ProjConfig.TracerEffectComp->IsActive());

				//DrawDebugPoint(World, Proj.Position, 10.0f, FColor::Green, false, 2.0f);
			}
			
			TArray<FHitResult> HitResults;		
			// True only blocking hit
			if (World->SweepMultiByChannel(HitResults, Proj.Position, NextPosition, FQuat::Identity, CollisionChannel, Shape))
			{
				// As far as we can move till hit
				Proj.Position = HitResults.Last().Location;
				
				FProjectileItem& ProjConfig = *ProjectileConfigs.Items.FindByPredicate([Proj](const FProjectileItem& OtherProj){ return Proj.ID == OtherProj.ID;  });
		
				//DrawDebugSphere(World, Proj.Position, Shape.GetSphereRadius(), 20, FColor::Green, false, 2.0f);
		
				// (Blocking) Hit!
				ProjConfig.Hit = HitResults[0];
				
				ProjectileHitIDs.Add(Proj.ID);


				// @todo: is auth check required?
				//if (HasAuthority())
				{
					// Give a bit of time before deletion for clients to rep the Hit
					ProjConfig.ExpirationGameTime = (World->TimeSeconds + 1.0);
					// Push hit to clients
					ProjectileConfigs.MarkItemDirty(ProjConfig);
				}
				continue;
			}
			// Any overlaps?
			for (int32 HitIndex = 0; HitIndex < HitResults.Num(); HitIndex++)
			{
				FHitResult& Hit = HitResults[HitIndex];
				AActor* HitActor = Hit.GetActor();

				FProjectileItem& ProjConfig = *ProjectileConfigs.Items.FindByPredicate([Proj](const FProjectileItem& OtherProj){ return Proj.ID == OtherProj.ID;  });
			
				if (HitActor->CanBeDamaged())
				{
					if (ProjConfig.InstigatorActor == HitActor)
					{
						// Skip the owner of the bullet
						continue;
					}

					// Check for friendly fire, eg. skip hitting other AI agents
					if (IGenericTeamAgentInterface* TeamInterface = Cast<IGenericTeamAgentInterface>(ProjConfig.InstigatorActor))
					{
						ETeamAttitude::Type Attitude = TeamInterface->GetTeamAttitudeTowards(*HitActor);
						if (Attitude == ETeamAttitude::Friendly)
						{
							// Show we ignored a friendly unit
							//DrawDebugBox(World, Hit.Location, FVector(40.0f), FColor::Red, false, 2.0f);
							continue;
						}
					}

					// We only use the first non-friendly overlap as our expected hit
					// at this point we know it can be damaged and if it has TeamInterface, it will not be "friendly" to projectile instigator
					ProjConfig.Hit = Hit;
					
					ProjectileHitIDs.AddUnique(Proj.ID);
					
					// @todo: is auth check required?
					//if (HasAuthority())
					{
						// Give a bit of time before deletion for clients to rep the Hit
						ProjConfig.ExpirationGameTime = (World->TimeSeconds + 1.0);
						// Push hit to clients
						ProjectileConfigs.MarkItemDirty(ProjConfig);
					}
					break;
				}
			}
			
			// no hit found, Move forward
			// for overlaps, the impactPosition should be used for things like VFX playback instead of the projectile location
			Proj.Position = NextPosition;
		}
	}
	
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(ProcessProjectileHits);

		for (int i = ProjectileHitIDs.Num() - 1; i >= 0; --i)
		{
			int32 HitID = ProjectileHitIDs[i];
			
			FProjectileItem& ProjConfig = *ProjectileConfigs.Items.FindByPredicate([HitID](const FProjectileItem& OtherProj){ return HitID == OtherProj.ID;  });

			// Apply Damage (server-only, misc. stuff like impulses still runs on clients too)
			// @todo-fixme: disabled damage to make things much easier to test
			/*FGameplayTagContainer ContextTags;
			URogueGameplayFunctionLibrary::ApplyDirectionalDamage(ProjConfig.InstigatorActor, ProjConfig.Hit.GetActor(),
				ProjConfig.ConfigDataAsset->DamageCoefficient, ProjConfig.Hit, ContextTags);*/
			// @todo: should clients be allowed to tell server we hit something IF that client spawned it? For co-op this could help with gamefeel as projectiles you "see" hitting
			// might not register as hits on server if the latency is big enough and objects are moving.
			
			// Will play any impact vfx during removal
			RemoveProjectileID(HitID);
		}
	}

	if (HasAuthority())
	{
		// Cleanup of old projectiles
		float CurrGameTime = GetWorld()->TimeSeconds;
		for (int Index = ProjectileConfigs.Items.Num() - 1; Index >= 0; --Index)
		{
			FProjectileItem& Item = ProjectileConfigs.Items[Index];
			// Is the projectile older than MaxLifespan seconds into the past
			if (Item.ExpirationGameTime < CurrGameTime)
			{
				RemoveProjectileID(Item.ID);

				// The only place we actually delete the data, we expire projectiles slightly after a hit/overlap to give replication some time to finish
				ProjectileConfigs.Items.RemoveSingle(Item);
				ProjectileConfigs.MarkArrayDirty();
			}
		}
	}
}


void URogueProjectilesSubsystem::SpawnImpactFX(const UWorld* World, const FProjectileItem& ProjConfig, FVector ImpactPosition, FRotator ImpactRotation)
{
	// Impact Explosion
	UNiagaraFunctionLibrary::SpawnSystemAtLocation(World, ProjConfig.ConfigDataAsset->ImpactEffect, ImpactPosition, ImpactRotation,
		FVector(1), true, true, ENCPoolMethod::AutoRelease, true);
	
	// Skip on movables and non-receivers
	UPrimitiveComponent* HitComp = ProjConfig.Hit.GetComponent();

#if !UE_BUILD_SHIPPING
	if (HitComp == nullptr)
	{
		UE_LOG(LogGame, Warning, TEXT("Hit something without component, reconsider the collision profiles to skip this Actor (%s)."), *GetNameSafe(ProjConfig.Hit.GetActor()));
	}
#endif

	TRACE_CPUPROFILER_EVENT_SCOPE(InitImpactDecalParticle);
	
	if (HitComp && HitComp->bReceivesDecals && HitComp->GetMobility() != EComponentMobility::Type::Movable)
	{
		// Helps find the correct island to inject this particle into
		FNiagaraDataChannelSearchParameters Params = FNiagaraDataChannelSearchParameters(ImpactPosition);

		// DECAL, using the Data Channels rather than relying on individual particle systems
		// only visible to CPU, for GPU particles we probably need "GPU" to be true instead 
		UNiagaraDataChannelWriter* Writer = UNiagaraDataChannelLibrary::WriteToNiagaraDataChannel(World, ProjConfig.ConfigDataAsset->ImpactDecal_DataChannel,
			Params, 1, false, true, false, "ImpactDecals");

		Writer->WriteVector("ImpactLocation", 0, ImpactPosition);
		Writer->WriteVector("ImpactNormal", 0, ProjConfig.Hit.ImpactNormal);
	}
}

/* Get unique ID so that client and servers can both generate an ID that will be unique when using this in replication
 * Clients may spawn a projectile locally and send it to the server along with the ID. 
 */
uint32 URogueProjectilesSubsystem::GetUniqueProjID(FVector InPos, float InGameTime)
{
	uint32 HashA = GetTypeHash(InPos);
	uint32 HashC = GetTypeHash(InGameTime);

	return HashCombine(HashA, HashC);
}


TStatId URogueProjectilesSubsystem::GetStatId() const
{
	RETURN_QUICK_DECLARE_CYCLE_STAT(URogueProjectilesSubsystem, STATGROUP_Tickables);
}


bool URogueProjectilesSubsystem::HasAuthority() const
{
	const UWorld* World = GetWorld();
	return World->GetNetMode() != (NM_Client);
}

```

`Source/ActionRoguelike/Projectiles/RogueProjectilesSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "RogueProjectilesSubsystem.generated.h"


#define USE_DATA_ORIENTED_PROJECTILES 0


class URogueProjectileData;
class UNiagaraComponent;
class UNiagaraSystem;
struct FProjectileItem;

USTRUCT()
struct FProjectileInstance
{
	GENERATED_BODY()

	FProjectileInstance(FVector InPos, FVector InVelocity, uint32 InstanceID)
		: Position(InPos), Velocity(InVelocity), ID(InstanceID)
	{
	}

	FProjectileInstance(uint32 InID)
		: Position(FVector::ZeroVector), Velocity(FVector::ZeroVector), ID(InID)
	{
	}

	FProjectileInstance()
		: Position(FVector::ZeroVector), Velocity(FVector::ZeroVector), ID(0)
	{
	}

	UPROPERTY()
	FVector Position;

	UPROPERTY()
	FVector Velocity;

	/* ID for tracking with the Config data */
	UPROPERTY()
	uint32 ID;

	bool operator==(const FProjectileInstance& OtherInfo) const
	{
		return OtherInfo.ID == ID;
	}

};

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueProjectilesSubsystem : public UTickableWorldSubsystem
{
	GENERATED_BODY()

public:

	/*
	 * Spawn a new projectile immediately, on clients we send RPC to server to also spawn projectile
	 * Returns ID for client side prediction
	 */
	UFUNCTION(BlueprintCallable)
	int32 CreateProjectile(FVector InPosition, FVector InDirection, URogueProjectileData* ProjectileConfig, AActor* InstigatorActor);

	void InternalCreateProjectile(FVector InPosition, FVector InDirection, URogueProjectileData* ProjectileConfig,
		AActor* InstigatorActor, uint32 NewID);
	
	void RemoveProjectileID(uint32 IdToRemove);
	
	virtual void Tick(float DeltaTime) override;

	virtual TStatId GetStatId() const override;

	void SpawnImpactFX(const UWorld* World, const FProjectileItem& ProjConfig, FVector ImpactPosition, FRotator ImpactRotation);
	
	uint32 GetUniqueProjID(FVector InPos, float InGameTime);
	
protected:

	bool HasAuthority() const;

	//UPROPERTY()
	TArray<FProjectileInstance> ProjectileInstances;
};

```

`Source/ActionRoguelike/SaveSystem/RogueSaveGame.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueSaveGame.h"

#include "ActionRoguelike.h"
#include "GameFramework/PlayerState.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueSaveGame)


FPlayerSaveData* URogueSaveGame::GetPlayerData(APlayerState* PlayerState)
{
	check(PlayerState);

	// Will not give unique ID while PIE so we skip that step while testing in editor.
	// UObjects don't have access to UWorld, so we grab it via PlayerState instead
	if (PlayerState->GetWorld()->IsPlayInEditor())
	{
		UE_LOGFMT(LogGame, Log, "During PIE we cannot use PlayerID to retrieve Saved Player data. Using first entry in array if available.");

		if (SavedPlayers.IsValidIndex(0))
		{
			return &SavedPlayers[0];
		}

		// No saved player data available
		return nullptr;
	}

	// Easiest way to deal with the different IDs is as FString (original Steam id is uint64)
	// Keep in mind that GetUniqueId() returns the online id, where GetUniqueID() is a function from UObject (very confusing...)
	FString PlayerID = PlayerState->GetUniqueId().ToString();
	// Iterate the array and match by PlayerID (eg. unique ID provided by Steam)
	return SavedPlayers.FindByPredicate([&](const FPlayerSaveData& Data) { return Data.PlayerID == PlayerID; });
}

```

`Source/ActionRoguelike/SaveSystem/RogueSaveGame.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/SaveGame.h"
#include "RogueSaveGame.generated.h"


USTRUCT()
struct FActorSaveData
{
	GENERATED_BODY()

public:

	/* Identifier for which Actor this belongs to */
	UPROPERTY()
	FName ActorName;

	/* For movable Actors, keep location,rotation,scale. */
	UPROPERTY()
	FTransform Transform;

	/* Contains all 'SaveGame' marked variables of the Actor */
	UPROPERTY()
	TArray<uint8> ByteData;
};

USTRUCT()
struct FPlayerSaveData
{
	GENERATED_BODY()

public:

	FPlayerSaveData()
	{
		Credits = 0;
		PersonalRecordTime = 0.0f;
		Location = FVector::ZeroVector;
		Rotation = FRotator::ZeroRotator;
		bResumeAtTransform = true;
	}

	/* Player Id defined by the online sub system (such as Steam) converted to FString for simplicity  */ 
	UPROPERTY()
	FString PlayerID;

	UPROPERTY()
    int32 Credits;

	/* Longest survival time */
	UPROPERTY()
    float PersonalRecordTime;

	/* Location if player was alive during save */
	UPROPERTY()
	FVector Location;

	/* Orientation if player was alive during save */ 
	UPROPERTY()
	FRotator Rotation;

	/* We don't always want to restore location, and may just resume player at specific respawn point in world. */
	UPROPERTY()
	bool bResumeAtTransform;
};


/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueSaveGame : public USaveGame
{
	GENERATED_BODY()
	
public:

	UPROPERTY()
	TArray<FPlayerSaveData> SavedPlayers;

	/* Actors stored from a level (currently does not support a specific level and just assumes the demo map) */
	UPROPERTY()
	TMap<FName, FActorSaveData> SavedActorMap;

	FPlayerSaveData* GetPlayerData(APlayerState* PlayerState);
};

```

`Source/ActionRoguelike/SaveSystem/RogueSaveGameSettings.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "SaveSystem/RogueSaveGameSettings.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueSaveGameSettings)


```

`Source/ActionRoguelike/SaveSystem/RogueSaveGameSettings.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Engine/DataTable.h"
#include "Engine/DeveloperSettings.h"
#include "RogueSaveGameSettings.generated.h"

class UDataTable;

/**
 * 
 */
UCLASS(Config=Game, defaultconfig, meta = (DisplayName="Save Game Settings")) // 'defaultconfig' = "Save object config only to Default INIs, never to local INIs."
class ACTIONROGUELIKE_API URogueSaveGameSettings : public UDeveloperSettings
{
	GENERATED_BODY()

public:
	/* Default slot name if UI doesn't specify any */ 
	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category = "General")
	FString SaveSlotName = "SaveGame_01";
	
	/* Soft path must be converted to asset before use */
	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category = "General", AdvancedDisplay)
	TSoftObjectPtr<UDataTable> DummyTablePath;
};

```

`Source/ActionRoguelike/SaveSystem/RogueSaveGameSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "SaveSystem/RogueSaveGameSubsystem.h"

#include "ActionRoguelike.h"
#include "EngineUtils.h"
#include "Core/RogueGameplayInterface.h"
#include "Player/RoguePlayerState.h"
#include "RogueSaveGame.h"
#include "SaveSystem/RogueSaveGameSettings.h"
#include "GameFramework/GameStateBase.h"
#include "Kismet/GameplayStatics.h"
#include "Serialization/ObjectAndNameAsStringProxyArchive.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueSaveGameSubsystem)



void URogueSaveGameSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	const URogueSaveGameSettings* SGSettings = GetDefault<URogueSaveGameSettings>();
	// Access defaults from DefaultGame.ini
	CurrentSlotName = SGSettings->SaveSlotName;

	// Make sure it's loaded into memory .Get() only resolves if already loaded previously elsewhere in code
	UDataTable* DummyTable = SGSettings->DummyTablePath.LoadSynchronous();
	//DummyTable->GetAllRows() // We don't need this table for anything, just an content reference example
}


void URogueSaveGameSubsystem::HandleStartingNewPlayer(AController* NewPlayer)
{
	ARoguePlayerState* PS = NewPlayer->GetPlayerState<ARoguePlayerState>();
	if (ensure(PS))
	{
		PS->LoadPlayerState(CurrentSaveGame);
	}
}


bool URogueSaveGameSubsystem::OverrideSpawnTransform(AController* NewPlayer)
{
	check(NewPlayer);

	APlayerState* PS = NewPlayer->GetPlayerState<APlayerState>();
	check(PS);

	if (APawn* MyPawn = PS->GetPawn())
	{
		FPlayerSaveData* FoundData = CurrentSaveGame->GetPlayerData(PS);
		if (FoundData && FoundData->bResumeAtTransform)
		{		
			MyPawn->SetActorLocation(FoundData->Location);
			MyPawn->SetActorRotation(FoundData->Rotation);

			// PlayerState owner is a (Player)Controller
			AController* PC = CastChecked<AController>(PS->GetOwner());
			// Set control rotation to change camera direction, setting Pawn rotation is not enough
			PC->SetControlRotation(FoundData->Rotation);
			
			return true;
		}
	}

	return false;
}


void URogueSaveGameSubsystem::SetSlotName(FString NewSlotName)
{
	// Ignore empty name
	if (NewSlotName.Len() == 0)
	{
		return;
	}
	
	CurrentSlotName = NewSlotName;
}


void URogueSaveGameSubsystem::WriteSaveGame()
{
	TRACE_CPUPROFILER_EVENT_SCOPE(WriteSaveGame);
	
	// Clear arrays, may contain data from previously loaded SaveGame
	CurrentSaveGame->SavedPlayers.Empty();
	CurrentSaveGame->SavedActorMap.Empty();

	AGameStateBase* GS = GetWorld()->GetGameState();
	check(GS);
	
	// Iterate all player states, we don't have proper ID to match yet (requires Steam or EOS)
	for (int32 i = 0; i < GS->PlayerArray.Num(); i++)
	{
		ARoguePlayerState* PS = CastChecked<ARoguePlayerState>(GS->PlayerArray[i]);
		if (PS)
		{
			PS->SavePlayerState(CurrentSaveGame);
			break; // single player only supported at this point
		}
	}

	// Iterate the entire world of actors
	for (AActor* Actor : TActorRange<AActor>(GetWorld()))
	{
		// Only interested in our 'gameplay actors', skip actors that are being destroyed
		// Note: You might instead use a dedicated SavableObject interface for Actors you want to save instead of re-using GameplayInterface
		if (!IsValid(Actor) || !Actor->Implements<URogueGameplayInterface>())
		{
			continue;
		}

		FActorSaveData ActorData;
		ActorData.ActorName = Actor->GetFName();
		ActorData.Transform = Actor->GetActorTransform();
		
		// Pass the array to fill with data from Actor
		FMemoryWriter MemWriter(ActorData.ByteData);

		FObjectAndNameAsStringProxyArchive Ar(MemWriter, true);
		// Find only variables with UPROPERTY(SaveGame)
		Ar.ArIsSaveGame = true;
		// Converts Actor's SaveGame UPROPERTIES into binary array
		Actor->Serialize(Ar);

		CurrentSaveGame->SavedActorMap.Add(Actor->GetFName(), ActorData);
	}

	UGameplayStatics::SaveGameToSlot(CurrentSaveGame, CurrentSlotName, 0);

	OnSaveGameWritten.Broadcast(CurrentSaveGame);
}


void URogueSaveGameSubsystem::LoadSaveGame(FString InSlotName /*= ""*/)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(LoadSaveGame);
	
	// Update slot name first if specified, otherwise keeps default name
	SetSlotName(InSlotName);
	
	if (UGameplayStatics::DoesSaveGameExist(CurrentSlotName, 0))
	{
		CurrentSaveGame = Cast<URogueSaveGame>(UGameplayStatics::LoadGameFromSlot(CurrentSlotName, 0));
		if (CurrentSaveGame == nullptr)
		{
			UE_LOGFMT(LogGame, Warning, "Failed to load SaveGame Data.");
			return;
		}

		UE_LOGFMT(LogGame, Log, "Loaded SaveGame Data.");


		// Iterate the entire world of actors
		for (AActor* Actor : TActorRange<AActor>(GetWorld()))
		{
			// Only interested in our 'gameplay actors'
			if (!Actor->Implements<URogueGameplayInterface>())
			{
				continue;
			}

			if (FActorSaveData* FoundData = CurrentSaveGame->SavedActorMap.Find(Actor->GetFName()))
			{
				Actor->SetActorTransform(FoundData->Transform);

				FMemoryReader MemReader(FoundData->ByteData);

				FObjectAndNameAsStringProxyArchive Ar(MemReader, true);
				Ar.ArIsSaveGame = true;
				// Convert binary array back into actor's variables
				Actor->Serialize(Ar);

				IRogueGameplayInterface::Execute_OnActorLoaded(Actor);
			}
		}

		OnSaveGameLoaded.Broadcast(CurrentSaveGame);
	}
	else
	{
		CurrentSaveGame = CastChecked<URogueSaveGame>(UGameplayStatics::CreateSaveGameObject(URogueSaveGame::StaticClass()));

		UE_LOGFMT(LogGame, Log, "Created New SaveGame Data.");
	}
}
```

`Source/ActionRoguelike/SaveSystem/RogueSaveGameSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "RogueSaveGameSubsystem.generated.h"

class URogueSaveGame;

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnSaveGameSignature, class URogueSaveGame*, SaveObject);

/**
 * Handles all saving/loading of game state and player data including transform
 */
UCLASS(meta=(DisplayName="SaveGame System")) // DisplayName creates prettier Blueprint node
class ACTIONROGUELIKE_API URogueSaveGameSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()

protected:
	
	/* Name of slot to save/load to disk. Filled by SaveGameSettings (can be overriden from GameMode's InitGame()) */
	FString CurrentSlotName;

	UPROPERTY(Transient)
	TObjectPtr<URogueSaveGame> CurrentSaveGame;

public:

	/* Restore serialized data from PlayerState into player */
	void HandleStartingNewPlayer(AController* NewPlayer);

	/* Restore spawn transform using stored data per PlayerState after being fully initialized. */
	UFUNCTION(BlueprintCallable)
	bool OverrideSpawnTransform(AController* NewPlayer);

	/* Change slot name, will be used next time we load/save data */
	UFUNCTION(BlueprintCallable)
	void SetSlotName(FString NewSlotName);
	
	UFUNCTION(BlueprintCallable, Category = "SaveGame")
	void WriteSaveGame();

	/* Load from disk, optional slot name */
	void LoadSaveGame(FString InSlotName = "");

	UPROPERTY(BlueprintAssignable)
	FOnSaveGameSignature OnSaveGameLoaded;

	UPROPERTY(BlueprintAssignable)
	FOnSaveGameSignature OnSaveGameWritten;

	/* Initialize Subsystem, good moment to load in SaveGameSettings variables */
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

};

```

`Source/ActionRoguelike/SharedGameplayTags.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "SharedGameplayTags.h"

namespace SharedGameplayTags
{
	// Actions
	UE_DEFINE_GAMEPLAY_TAG(Action_Sprint, "Action.Sprint");
	UE_DEFINE_GAMEPLAY_TAG(Action_PrimaryAttack, "Action.PrimaryAttack");
	UE_DEFINE_GAMEPLAY_TAG(Action_Blackhole, "Action.Blackhole");
	UE_DEFINE_GAMEPLAY_TAG(Action_Dash, "Action.Dash");
	UE_DEFINE_GAMEPLAY_TAG(Action_Melee, "Action.Melee");
	
	// Status
	UE_DEFINE_GAMEPLAY_TAG(Status_Stunned, "Status.Stunned");

	// Damage Context
	UE_DEFINE_GAMEPLAY_TAG(Context_Reflected, "Context.Reflected");

	// Attributes
	UE_DEFINE_GAMEPLAY_TAG(Attribute_Health, "Attribute.Health");
	UE_DEFINE_GAMEPLAY_TAG(Attribute_HealthMax, "Attribute.HealthMax");
	UE_DEFINE_GAMEPLAY_TAG(Attribute_AttackDamage, "Attribute.AttackDamage");
	UE_DEFINE_GAMEPLAY_TAG(Attribute_Rage, "Attribute.Rage");
	UE_DEFINE_GAMEPLAY_TAG(Attribute_Credits, "Attribute.Credits");
	UE_DEFINE_GAMEPLAY_TAG(Attribute_MoveSpeed, "Attribute.MoveSpeed");

	// Messaging
	UE_DEFINE_GAMEPLAY_TAG(Message_MonsterKilled, "Message.MonsterKilled");
	
	// UE_DEFINE_GAMEPLAY_TAG_COMMENT()
}

```

`Source/ActionRoguelike/SharedGameplayTags.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "NativeGameplayTags.h"

namespace SharedGameplayTags
{
	// Actions
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Action_Sprint);
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Action_PrimaryAttack);
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Action_Blackhole);
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Action_Dash);
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Action_Melee);
	// Status
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Status_Stunned);
	// Damage Context
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Context_Reflected);

	// Attributes
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Attribute_Health);
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Attribute_HealthMax);
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Attribute_AttackDamage);
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Attribute_Rage);
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Attribute_Credits);
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Attribute_MoveSpeed);

	// Messaging
	UE_DECLARE_GAMEPLAY_TAG_EXTERN(Message_MonsterKilled);
}
```

`Source/ActionRoguelike/StateTrees/RogueStateTreeDirectorSchema.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueStateTreeDirectorSchema.h"

#include "RogueStateTreeTasks.h"


bool URogueStateTreeDirectorSchema::IsStructAllowed(const UScriptStruct* InScriptStruct) const
{
	return Super::IsStructAllowed(InScriptStruct) ||
		InScriptStruct->IsChildOf(FRogueStateTreeDirectorTask::StaticStruct());
}
```

`Source/ActionRoguelike/StateTrees/RogueStateTreeDirectorSchema.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Components/StateTreeComponentSchema.h"

#include "RogueStateTreeDirectorSchema.generated.h"

/**
 * 
 */
UCLASS(meta = (DisplayName = "StateTree Director Schema"))
class ACTIONROGUELIKE_API URogueStateTreeDirectorSchema : public UStateTreeComponentSchema
{
	GENERATED_BODY()

	virtual bool IsStructAllowed(const UScriptStruct* InScriptStruct) const override;
};

```

`Source/ActionRoguelike/StateTrees/RogueStateTreeTasks.cpp`:

```cpp


#include "RogueStateTreeTasks.h"

#include "StateTreeExecutionContext.h"
#include "StateTreeLinker.h"
#include "Core/RogueGameModeBase.h"
#include "StateTreePropertyRef.h"


FRogueSTTask_SelectMonster::FRogueSTTask_SelectMonster()
{
	bConsideredForScheduling = false;
}


EStateTreeRunStatus FRogueSTTask_SelectMonster::EnterState(FStateTreeExecutionContext& Context,	const FStateTreeTransitionResult& Transition) const
{
	FInstanceDataType& InstanceData = Context.GetInstanceData(*this);

	int32 AvailableSpawnCredit = *InstanceData.AvailableCreditsRef.GetMutablePtr(Context);

	TArray<FMonsterInfoRow*> Rows;
	InstanceData.MonsterTable->GetAllRows("", Rows);

	// Get total weight
	float TotalWeight = 0;
	for (FMonsterInfoRow* Entry : Rows)
	{
		TotalWeight += Entry->Weight;
	}

	// Random number within total random
	int32 RandomWeight = FMath::RandRange(0.0f, TotalWeight);
	// @todo: make it seeded?

	//Reset
	TotalWeight = 0;

	FMonsterInfoRow* SelectedRow = nullptr;
	// Get monster based on random weight
	for (FMonsterInfoRow* Entry : Rows)
	{
		TotalWeight += Entry->Weight;

		if (RandomWeight <= TotalWeight)
		{
			SelectedRow = Entry;
			break;
		}
	}

	check(SelectedRow);
	/*if (SelectedRow == nullptr)
	{
		return EStateTreeRunStatus::Failed;
	}*/

	if (SelectedRow->SpawnCost >= AvailableSpawnCredit)
	{
		// Too expensive to spawn
		return EStateTreeRunStatus::Failed;
	}


	UClass** SelectedMonsterClass = InstanceData.SelectedMonsterRef.GetMutablePtr(Context);
	// Store it back into state tree memory
	*SelectedMonsterClass = AActor::StaticClass();

	return EStateTreeRunStatus::Running;
}

```

`Source/ActionRoguelike/StateTrees/RogueStateTreeTasks.h`:

```h
#pragma once

#include "StateTreePropertyRef.h"
#include "StateTreeTaskBase.h"
#include "RogueStateTreeTasks.generated.h"

/**
 * Configurable Vars in the State Tree in Select Monster Task
 */
USTRUCT()
struct FRogueST_SelectMonsterInstanceData
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category=Parameter)
	UDataTable* MonsterTable = nullptr;
	
	UPROPERTY(EditAnywhere)
	TStateTreePropertyRef<int32> AvailableCreditsRef;
	
	UPROPERTY(EditAnywhere)
	TStateTreePropertyRef<UClass*> SelectedMonsterRef;
};


/**
 * Base struct to simplify exposing other Tasks to Director Schema
 */
USTRUCT(meta = (Hidden))
struct FRogueStateTreeDirectorTask : public FStateTreeTaskBase
{
	GENERATED_BODY()
};

/**
 * Select Monster to spawn from available DataTable based on available Spawn Credits
 */
USTRUCT(meta = (DisplayName = "Select Monster for Spawning"))
struct FRogueSTTask_SelectMonster : public FRogueStateTreeDirectorTask
{
	GENERATED_BODY()

	using FInstanceDataType = FRogueST_SelectMonsterInstanceData;

	virtual const UStruct* GetInstanceDataType() const override { return FInstanceDataType::StaticStruct(); }
	
	virtual EStateTreeRunStatus EnterState(FStateTreeExecutionContext& Context, const FStateTreeTransitionResult& Transition) const override;

	FRogueSTTask_SelectMonster();
};

```

`Source/ActionRoguelike/Subsystems/RogueMonsterCorpseSubsystem.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueMonsterCorpseSubsystem.h"



void URogueMonsterCorpseSubsystem::AddCorpse(AActor* InActor)
{
	Corpses.Enqueue(FMonsterCorpseInfo(InActor, GetWorld()->TimeSeconds));

	CurrentCorpseCount++;
}


void URogueMonsterCorpseSubsystem::CleanupNextAvailableCorpse()
{
	if (Corpses.IsEmpty())
	{
		return;
	}
	
	FMonsterCorpseInfo* NextCorpse = Corpses.Peek();

	// Check if we reached the minimum age yet
	const float ExpiresAt = NextCorpse->TimeAdded + MinimumAge;
	if (GetWorld()->TimeSeconds < ExpiresAt)
	{
		return;
	}

	// If off-screen we can safely hide/delete - include fallback when above hard-limit, we always delete first even if potentially on-screen.
	if (CurrentCorpseCount > MaxCorpses || !NextCorpse->Actor->WasRecentlyRendered())
	{
		// Alternatively we could hide the corpse and apply pooling on "corpses", simple actors containing only a skeletalmesh for ragdolling 
		NextCorpse->Actor->Destroy();

		Corpses.Dequeue();
		CurrentCorpseCount--;
	}
}


void URogueMonsterCorpseSubsystem::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	// Cleanup at most one per frame by peeking the queue
	CleanupNextAvailableCorpse();
}
```

`Source/ActionRoguelike/Subsystems/RogueMonsterCorpseSubsystem.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/WorldSubsystem.h"
#include "Containers/SpscQueue.h"
#include "RogueMonsterCorpseSubsystem.generated.h"


USTRUCT()
struct FMonsterCorpseInfo
{
	GENERATED_BODY()

	FMonsterCorpseInfo() {}

	FMonsterCorpseInfo(AActor* InActor, float TimeOfDeath)
		: Actor(InActor), TimeAdded(TimeOfDeath)
	{}

	TWeakObjectPtr<AActor> Actor = nullptr;
	
	float TimeAdded = 0.0f;
};


/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueMonsterCorpseSubsystem : public UTickableWorldSubsystem
{
	GENERATED_BODY()

	virtual void Tick(float DeltaTime) override;

	virtual TStatId GetStatId() const override
	{
		RETURN_QUICK_DECLARE_CYCLE_STAT(URogueMonsterCorpseSubsystem, STATGROUP_Tickables);
	}

public:
	
	void AddCorpse(AActor* InActor);

protected:

	/*
	 * Look at the next in line and see if they are offscreen, ready to be removed
	 */
	void CleanupNextAvailableCorpse();
	
	/* Corpes stay around for at least this long */
	float MinimumAge = 10;

	int32 MaxCorpses = 5;

	int32 CurrentCorpseCount = 0;
	
	//UPROPERTY()
	TSpscQueue<FMonsterCorpseInfo> Corpses;

};

```

`Source/ActionRoguelike/UI/RogueEffectSlotWidget.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueEffectSlotWidget.h"
#include "ActionRoguelike/ActionSystem/RogueActionEffect.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Components/Image.h"

void URogueEffectSlotWidget::NativeConstruct()
{
	Super::NativeConstruct();

	check(EffectInst);
	EffectInst->GetOwningComponent()->OnActionStopped.AddDynamic(this, &URogueEffectSlotWidget::OnEffectEnded);
	
	// Icons may not be specified yet, the widget should continue using a placeholder
	FSoftObjectPath IconPath = EffectInst->GetIcon().ToSoftObjectPath();
	if (IconPath.IsValid())
	{
		FLoadAssetAsyncDelegate Delegate;
		Delegate.BindUObject(this, &URogueEffectSlotWidget::OnLoadIconCompleted);

		LoadAssetAsync(IconPath.GetAssetPath(), Delegate);
	}
}

void URogueEffectSlotWidget::OnLoadIconCompleted(const FTopLevelAssetPath& AssetPath, UObject* LoadedObject, EAsyncLoadingResult::Type Result)
{
	UMaterialInstanceDynamic* MID = EffectImage->GetDynamicMaterial();
	
	// "Icon" param name must match the param name in the Material asset
	MID->SetTextureParameterValue("Icon", CastChecked<UTexture2D>(LoadedObject));
}

void URogueEffectSlotWidget::OnEffectEnded(URogueActionComponent* OwningComp, URogueAction* Action)
{
	// Only remove if the relevant effect stopped not something else
	if (Action == EffectInst)
	{
		RemoveFromParent();
	}
}

```

`Source/ActionRoguelike/UI/RogueEffectSlotWidget.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "RogueEffectSlotWidget.generated.h"

class URogueActionEffect;
class UImage;
class URogueAction;

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueEffectSlotWidget : public UUserWidget
{
	GENERATED_BODY()

protected:
	
	UPROPERTY(BlueprintReadOnly, meta = (BindWidget))
	TObjectPtr<UImage> EffectImage;
	
	UPROPERTY(BlueprintReadOnly, Category="Rogue|Effects", meta = (ExposeOnSpawn=true))
	TObjectPtr<URogueActionEffect> EffectInst;

	virtual void NativeConstruct() override;

	void OnLoadIconCompleted(const FTopLevelAssetPath& AssetPath, UObject* LoadedObject, EAsyncLoadingResult::Type Result);

	UFUNCTION()
	void OnEffectEnded(URogueActionComponent* OwningComp, URogueAction* Action);
};

```

`Source/ActionRoguelike/UI/RogueHUD.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/RogueHUD.h"
#include "Blueprint/UserWidget.h"
#include "Kismet/GameplayStatics.h"


void ARogueHUD::TogglePauseMenu()
{
	APlayerController* MyPC = GetOwningPlayerController();
	
	if (PauseMenuInstance && PauseMenuInstance->IsInViewport())
	{
		PauseMenuInstance->RemoveFromParent();
		PauseMenuInstance = nullptr;

		MyPC->bShowMouseCursor = false;
		MyPC->SetInputMode(FInputModeGameOnly());

		// Single-player only
		if (GetWorld()->IsNetMode(NM_Standalone))
		{
			UGameplayStatics::SetGamePaused(this, false);
		}

		return;
	}

	PauseMenuInstance = CreateWidget<UUserWidget>(MyPC, PauseMenuClass);
	if (PauseMenuInstance)
	{
		PauseMenuInstance->AddToViewport(100);

		MyPC->bShowMouseCursor = true;
		MyPC->SetInputMode(FInputModeUIOnly());

		// Single-player only
		if (GetWorld()->IsNetMode(NM_Standalone))
		{
			UGameplayStatics::SetGamePaused(this, true);
		}
	}
}

```

`Source/ActionRoguelike/UI/RogueHUD.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/HUD.h"
#include "RogueHUD.generated.h"

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API ARogueHUD : public AHUD
{
	GENERATED_BODY()

public:

	UFUNCTION(BlueprintCallable)
	void TogglePauseMenu();
	
protected:
	
	UPROPERTY(EditDefaultsOnly, Category = "UI")
	TSubclassOf<UUserWidget> PauseMenuClass;

	UPROPERTY(Transient)
	TObjectPtr<UUserWidget> PauseMenuInstance;

};

```

`Source/ActionRoguelike/UI/RogueWorldUserWidget.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "UI/RogueWorldUserWidget.h"

#include "ActionRoguelike.h"
#include "Blueprint/WidgetBlueprintLibrary.h"
#include "Kismet/GameplayStatics.h"
#include "Blueprint/WidgetLayoutLibrary.h"
#include "Components/CanvasPanel.h"
#include "Components/CanvasPanelSlot.h"
#include "Components/Overlay.h"
#include "Components/SizeBox.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueWorldUserWidget)



void URogueWorldUserWidget::NativeTick(const FGeometry& MyGeometry, float InDeltaTime)
{
	Super::NativeTick(MyGeometry, InDeltaTime);

	if (!IsValid(AttachedActor))
	{
		RemoveFromParent();

		UE_LOGFMT(LogGame, Warning, "AttachedActor no longer valid, removing Health Widget.");
		return;
	}

	FVector2D ScreenPosition;
	bool bIsOnScreen = UGameplayStatics::ProjectWorldToScreen(GetOwningPlayer(), AttachedActor->GetActorLocation() + WorldOffset, ScreenPosition);

	if (bIsOnScreen)
	{
		float Scale = UWidgetLayoutLibrary::GetViewportScale(this);

		ScreenPosition /= Scale;

		ParentOverlay->SetRenderTranslation(ScreenPosition);
	}

	// Avoid unnecessary invalidation in Slate
	if (bWasOnScreen != bIsOnScreen)
	{
		ParentOverlay->SetVisibility(bIsOnScreen ? ESlateVisibility::HitTestInvisible : ESlateVisibility::Collapsed);
	}

	bWasOnScreen = bIsOnScreen;
}

void URogueWorldUserWidget::NativeConstruct()
{
	Super::NativeConstruct();

	// Assumes we are directly added to a CanvasPanel rather than direct to viewport.
	UCanvasPanelSlot* CanvasSlot = static_cast<UCanvasPanelSlot*>(Slot);
	// Might be nullptr during init
	if (CanvasSlot)
	{
		CanvasSlot->SetAlignment(FVector2d(0.5f,1.0f));
		CanvasSlot->SetAutoSize(true);
	}
}

void URogueWorldUserWidget::AddToRootCanvasPanel(UUserWidget* InNewWidget)
{
	// Grab the 'main hud' which will have a Canvas Panel to use.
	TArray<UUserWidget*> Widgets;
	UWidgetBlueprintLibrary::GetAllWidgetsOfClass(InNewWidget, Widgets, UUserWidget::StaticClass(), true);
	// Expect only one main hud, other menus etc. might mess with this and requires slight change (eg. adding a pause menu to the root)
	//check(Widgets.Num() == 1)

	// We might be testing without a HUD...
	if (Widgets.Num() > 0)
	{
		UUserWidget* MainHUD = Widgets[0];
		UCanvasPanel* CanvasPanel = Cast<UCanvasPanel>(MainHUD->GetRootWidget());
		CanvasPanel->AddChild(InNewWidget);
	}
}

```

`Source/ActionRoguelike/UI/RogueWorldUserWidget.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "RogueWorldUserWidget.generated.h"


class UOverlay;

/**
 * 
 */
UCLASS()
class ACTIONROGUELIKE_API URogueWorldUserWidget : public UUserWidget
{
	GENERATED_BODY()
	
protected:

	UPROPERTY(meta = (BindWidget))
	TObjectPtr<UOverlay> ParentOverlay;

	virtual void NativeTick(const FGeometry& MyGeometry, float InDeltaTime) override;

	virtual void NativeConstruct() override;

	bool bWasOnScreen = true;

public:

	/* Find the root canvas panel (expected in a 'main hud' style widget) and add new widget as child. */
	UFUNCTION(BlueprintCallable, Category= UI)
	static void AddToRootCanvasPanel(UUserWidget* InNewWidget);

	UPROPERTY(EditAnywhere, Category = "UI")
	FVector WorldOffset;

	UPROPERTY(BlueprintReadWrite, Transient, Category = "UI", meta = (ExposeOnSpawn=true))
	TObjectPtr<AActor> AttachedActor;
};

```

`Source/ActionRoguelike/World/RogueExplosiveBarrel.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueExplosiveBarrel.h"
#include "ActionRoguelike.h"
#include "PhysicsEngine/RadialForceComponent.h"
#include "Components/StaticMeshComponent.h"
#include "DrawDebugHelpers.h"
#include "NiagaraComponent.h"
#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueExplosiveBarrel)


ARogueExplosiveBarrel::ARogueExplosiveBarrel(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	ActionComp = CreateDefaultSubobject<URogueActionComponent>(TEXT("ActionComp"));
	ActionComp->SetDefaultAttributeSet(ObjectInitializer, URogueHealthAttributeSet::StaticClass());
	
	MeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("MeshComp"));
	MeshComp->SetSimulatePhysics(true);
	// Enabling Simulate physics automatically changes the Profile to PhysicsActor in Blueprint, in C++ we need to change this manually.
	MeshComp->SetCollisionProfileName(UCollisionProfile::PhysicsActor_ProfileName); 
	RootComponent = MeshComp;

	ForceComp = CreateDefaultSubobject<URadialForceComponent>(TEXT("ForceComp"));
	ForceComp->SetupAttachment(MeshComp);

	// Leaving this on applies small constant force via component 'tick' (Optional)
	ForceComp->SetAutoActivate(false);

	ForceComp->Radius = 750.0f;
	ForceComp->ImpulseStrength = 2500.0f; // Alternative: 200000.0 if bImpulseVelChange = false
	// Optional, ignores 'Mass' of other objects (if false, the impulse strength will be much higher to push most objects depending on Mass)
	ForceComp->bImpulseVelChange = true;

	// Optional, default constructor of component already adds 4 object types to affect, excluding WorldDynamic
	ForceComp->AddCollisionChannelToAffect(ECC_WorldDynamic);

	ExplosionComp = CreateDefaultSubobject<UNiagaraComponent>(TEXT("ExplosionComp"));
	ExplosionComp->bAutoActivate = false;
	ExplosionComp->SetupAttachment(MeshComp);

	FlamesFXComp = CreateDefaultSubobject<UNiagaraComponent>(TEXT("FlamesFXComp"));
	FlamesFXComp->bAutoActivate = false;
	FlamesFXComp->SetupAttachment(MeshComp);

	ExplosionDelayTime = 2.0f;
}

void ARogueExplosiveBarrel::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	FAttributeChangedSignature& Delegate = ActionComp->GetAttributeListenerDelegate(SharedGameplayTags::Attribute_Health);
	Delegate.AddUObject(this, &ThisClass::OnHealthAttributeChanged);
}


void ARogueExplosiveBarrel::OnHealthAttributeChanged(float NewValue, const FAttributeModification& AttributeModification)
{
	if (bExploded)
	{
		return;
	}
	
	// Either use a hit counter or 'hitpoints' (For early assignment, we don't have any kind of attributes yet)
	HitCounter++;

	if (HitCounter == 1)
	{
		GetWorldTimerManager().SetTimer(DelayedExplosionHandle, this, &ThisClass::Explode, ExplosionDelayTime);

		FlamesFXComp->Activate();
	}
	else if (HitCounter == 2)
	{
		// Avoid second explosion later
		GetWorldTimerManager().ClearTimer(DelayedExplosionHandle);
		
		Explode();
	}
	
	UE_LOG(LogGame, Log, TEXT("OnActorHit in Explosive Barrel"));
	// Structured Logging Example
	UE_LOGFMT(LogGame, Warning, "OnActorHit, OtherActor: {name}, at game time: {timeseconds}",
		("name", GetNameSafe(AttributeModification.Instigator->GetOwner())),
		("timeseconds", GetWorld()->TimeSeconds));
}


void ARogueExplosiveBarrel::Explode()
{
	if (bExploded)
	{
		// Nothing to do here
		return;
	}

	bExploded = true;

	FlamesFXComp->Deactivate();
	
	ForceComp->FireImpulse();

	ExplosionComp->Activate();

	// @todo: cause damage to other stuff around it

	//FString CombinedString = FString::Printf(TEXT("Hit at location: %s"), *Hit.ImpactPoint.ToString());
	//DrawDebugString(GetWorld(), Hit.ImpactPoint, CombinedString, nullptr, FColor::Green, 2.0f, true);
}


```

`Source/ActionRoguelike/World/RogueExplosiveBarrel.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "ActionSystem/RogueActionSystemInterface.h"
#include "ActionSystem/RogueAttributeSet.h"
#include "GameFramework/Actor.h"
#include "RogueExplosiveBarrel.generated.h"


class URogueActionComponent;
class UNiagaraComponent;
class UStaticMeshComponent;
class URadialForceComponent;


UCLASS()
class ACTIONROGUELIKE_API ARogueExplosiveBarrel : public AActor, public IRogueActionSystemInterface
{
	GENERATED_BODY()

protected:
	
	int32 HitCounter = 0;

	FTimerHandle DelayedExplosionHandle;

	float ExplosionDelayTime = 2.0f;

	bool bExploded = false;
	
	UPROPERTY(VisibleAnywhere, Category = Components)
	TObjectPtr<URogueActionComponent> ActionComp;

	UPROPERTY(VisibleAnywhere, Category = Components)
	TObjectPtr<UStaticMeshComponent> MeshComp;

	UPROPERTY(VisibleAnywhere, Category = Components)
	TObjectPtr<URadialForceComponent> ForceComp;

	UPROPERTY(VisibleAnywhere, Category = Components)
	TObjectPtr<UNiagaraComponent> ExplosionComp;

	UPROPERTY(VisibleAnywhere, Category = Components)
	TObjectPtr<UNiagaraComponent> FlamesFXComp;

	void Explode();

	void OnHealthAttributeChanged(float NewValue, const FAttributeModification& AttributeModification);
	
public:

	virtual URogueActionComponent* GetActionComponent() const override
	{
		return ActionComp;
	}
	
	ARogueExplosiveBarrel(const FObjectInitializer& ObjectInitializer);

	virtual void PostInitializeComponents() override;
};

```

`Source/ActionRoguelike/World/RogueTargetDummy.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueTargetDummy.h"

#include "SharedGameplayTags.h"
#include "ActionSystem/RogueActionComponent.h"
#include "Components/StaticMeshComponent.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueTargetDummy)


ARogueTargetDummy::ARogueTargetDummy(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	SkelMeshComp = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("MeshComp"));
	RootComponent = SkelMeshComp;

	ActionComp = CreateDefaultSubobject<URogueActionComponent>(TEXT("ActionComp"));
	ActionComp->SetDefaultAttributeSet(ObjectInitializer, URogueHealthAttributeSet::StaticClass());
}


void ARogueTargetDummy::PostInitializeComponents()
{
	Super::PostInitializeComponents();
	
	ActionComp->GetAttributeListenerDelegate(SharedGameplayTags::Attribute_Health).AddUObject(this, &ThisClass::OnHealthChanged);
}


void ARogueTargetDummy::OnHealthChanged(float NewValue, const FAttributeModification& AttributeMod)
{
	if (AttributeMod.Magnitude < 0.0f)
	{
		SkelMeshComp->SetScalarParameterValueOnMaterials("TimeToHit", GetWorld()->TimeSeconds);
	}
}

```

`Source/ActionRoguelike/World/RogueTargetDummy.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "ActionSystem/RogueActionSystemInterface.h"
#include "GameFramework/Actor.h"
#include "RogueTargetDummy.generated.h"

struct FAttributeModification;
class URogueActionComponent;


UCLASS()
class ACTIONROGUELIKE_API ARogueTargetDummy : public APawn, public IRogueActionSystemInterface
{
	GENERATED_BODY()

protected:

	UPROPERTY(VisibleAnywhere)
	TObjectPtr<URogueActionComponent> ActionComp;
	
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<USkeletalMeshComponent> SkelMeshComp;

	void OnHealthChanged(float NewValue,  const FAttributeModification& AttributeMod);
	
public:	

	ARogueTargetDummy(const FObjectInitializer& ObjectInitializer);

	virtual void PostInitializeComponents() override;

	virtual URogueActionComponent* GetActionComponent() const override
	{
		return ActionComp;
	}

};

```

`Source/ActionRoguelike/World/RogueTreasureChest.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "RogueTreasureChest.h"

#include "NiagaraComponent.h"
#include "Components/StaticMeshComponent.h"
#include "Net/UnrealNetwork.h"
#include "Animation/RogueCurveAnimSubsystem.h"
#include "Components/AudioComponent.h"
#include "Core/RogueDeferredTaskSystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(RogueTreasureChest)



ARogueTreasureChest::ARogueTreasureChest()
{
	BaseMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("BaseMesh"));
	RootComponent = BaseMesh;
	BaseMesh->SetSimulatePhysics(true);

	LidMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("LidMesh"));
	LidMesh->SetupAttachment(BaseMesh);

	OpenChestEffect = CreateDefaultSubobject<UNiagaraComponent>(TEXT("OpeningEffectComp"));
	OpenChestEffect->SetupAttachment(RootComponent);
	OpenChestEffect->bAutoActivate = false;
	// only attach while playing the VFX, this skips transform updates when the chests moves around the world
	// while the VFX is not active
	OpenChestEffect->bAutoManageAttachment = true;

	// If the chest was non-movable we could just call "playsoundatlocation" and skip creating a component during spawn
	OpenChestSound = CreateDefaultSubobject<UAudioComponent>(TEXT("OpenChestSFX"));
	OpenChestSound->SetupAttachment(RootComponent);
	OpenChestSound->SetAutoActivate(false);
	OpenChestSound->bAutoManageAttachment = true;

	// Directly set bool instead of going through SetReplicates(true) within constructor,
	// Only use SetReplicates() outside constructor
	bReplicates = true;

	//PrimaryActorTick.bCanEverTick = true;
}


void ARogueTreasureChest::Interact_Implementation(AController* InstigatorController)
{
	bLidOpened = true;

#if USE_DEFERRED_TASKS
	// Experimenting with the deferred tasks, no need to actually do this for the chest
	URogueDeferredTaskSystem::AddLambda(this,[&]()
		{
			ConditionalOpenChest();
		});

	// Some random numbers to "process"
	IntTestArray = { 4, 5, 7, 574, 4737, 4837, 3726 };

	URogueDeferredTaskSystem::AddLambda(this,[&]()
		{
			UpdateTestArray(4, 8);
		});
#else
	ConditionalOpenChest();
#endif
}

void ARogueTreasureChest::UpdateTestArray(int32 StartIndex, int32 MaxCount)
{
#if USE_DEFERRED_TASKS
	// Process partial array, so it can be split across multiple frames easily
	int32 CurrentCount = 0;
	for (int32 i = StartIndex; i < IntTestArray.Num(); i++)
	{
		IntTestArray[i] = IntTestArray[i] + 1;
		CurrentCount++;
		if (CurrentCount >= MaxCount)
		{
			break;
		}
	}
#endif
}


void ARogueTreasureChest::OnActorLoaded_Implementation()
{
	ConditionalOpenChest();
}


void ARogueTreasureChest::ConditionalOpenChest()
{
	if (bLidOpened)
	{
		URogueCurveAnimSubsystem* AnimSubsystem = GetWorld()->GetSubsystem<URogueCurveAnimSubsystem>();

		// Several ways to trigger and manage these animations (curve-based automatic ticking, manual ticking, and easing functions)
		
		AnimSubsystem->PlayCurveAnim(LidAnimCurve, 1.f, [&](float CurrValue)
		{
			LidMesh->SetRelativeRotation(FRotator(CurrValue, 0, 0));
		});
		
		// manually handled variation to tick yourself
		/*CurveAnimInst = new FActiveCurveAnim(LidAnimCurve, [&](float CurrValue)
		{
			LidMesh->SetRelativeRotation(FRotator(CurrValue, 0, 0));
		}, 1.0f);*/

		/*
		AnimSubsystem->PlayEasingFunc(EEasingFunc::EaseInOut, 2.0f, 2.0f, [&](float CurrValue)
		{
			LidMesh->SetRelativeRotation(FRotator(CurrValue * 100.f, 0, 0));
		});*/

		OpenChestEffect->Activate(true);

		OpenChestSound->Play();

	}
}

/*
void ARogueTreasureChest::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	// Example of manually ticking the animation, may be useful if you need the control and/or manually batch the anims
	if (CurveAnimInst && CurveAnimInst->IsValid())
	{
		CurveAnimInst->Tick(DeltaSeconds);
	}
}*/


void ARogueTreasureChest::OnRep_LidOpened()
{
	ConditionalOpenChest();
}


void ARogueTreasureChest::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ARogueTreasureChest, bLidOpened);
}

```

`Source/ActionRoguelike/World/RogueTreasureChest.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
//#include "Animation/RogueCurveAnimSubsystem.h"
#include "GameFramework/Actor.h"
#include "Core/RogueGameplayInterface.h"
#include "RogueTreasureChest.generated.h"

class UNiagaraComponent;
class UStaticMeshComponent;

UCLASS()
class ACTIONROGUELIKE_API ARogueTreasureChest : public AActor, public IRogueGameplayInterface
{
	GENERATED_BODY()

public:

	virtual void Interact_Implementation(AController* InstigatorController) override;

	virtual void OnActorLoaded_Implementation() override;

protected:

	UPROPERTY(EditDefaultsOnly, Category= "Animation")
	UCurveFloat* LidAnimCurve;

	UPROPERTY(ReplicatedUsing="OnRep_LidOpened", BlueprintReadOnly, SaveGame)
	bool bLidOpened;

	void ConditionalOpenChest();

	UFUNCTION()
	void OnRep_LidOpened();

	//virtual void Tick(float DeltaSeconds) override;

	//FActiveCurveAnim* CurveAnimInst;

	UPROPERTY(VisibleAnywhere, Category=Components)
	TObjectPtr<UStaticMeshComponent> BaseMesh;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category=Components)
	TObjectPtr<UStaticMeshComponent> LidMesh;

	UPROPERTY(VisibleAnywhere, Category=Components)
	TObjectPtr<UNiagaraComponent> OpenChestEffect;

	UPROPERTY(VisibleAnywhere, Category=Components)
	TObjectPtr<UAudioComponent> OpenChestSound;

	TArray<int32> IntTestArray;
	void UpdateTestArray(int32 StartIndex, int32 MaxCount);

public:	

	ARogueTreasureChest();
};

```

`Source/ActionRoguelikeEditor.Target.cs`:

```cs
// Fill out your copyright notice in the Description page of Project Settings.

using UnrealBuildTool;
using System.Collections.Generic;

public class ActionRoguelikeEditorTarget : TargetRules
{
	public ActionRoguelikeEditorTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.Latest;
		IncludeOrderVersion = EngineIncludeOrderVersion.Latest;

		ExtraModuleNames.AddRange( new string[] { "ActionRoguelike" } );
	}
}

```

`Source/RogueEditor/RogueEditor.Build.cs`:

```cs
using UnrealBuildTool;

public class RogueEditor : ModuleRules
{
	public RogueEditor(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

		PrivateDependencyModuleNames.AddRange(new string[] {
			"Core",
			"CoreUObject",
			"Engine",
			"DataValidation",
			"BlueprintGraph",
			"ActionRoguelike"
		});
	}
}
```

`Source/RogueEditor/RogueEditor.cpp`:

```cpp
#include "Modules/ModuleManager.h"

IMPLEMENT_MODULE(FDefaultModuleImpl, RogueEditor)
```

`Source/RogueEditor/Validators/EditorValidator_Projectiles.cpp`:

```cpp
#include "EditorValidator_Projectiles.h"

#include "Misc/DataValidation.h"
#include "Projectiles/RogueProjectile.h"


bool UEditorValidator_Projectiles::CanValidateAsset_Implementation(const FAssetData& InAssetData, UObject* InObject, FDataValidationContext& InContext) const
{
	if (const UBlueprint* BP = Cast<UBlueprint>(InObject))
	{
		return BP->GeneratedClass.GetDefaultObject()->IsA<ARogueProjectile>();
	}

	return false;
}


EDataValidationResult UEditorValidator_Projectiles::ValidateLoadedAsset_Implementation(const FAssetData& InAssetData, UObject* InAsset, FDataValidationContext& Context)
{
	const UBlueprint* BP = CastChecked<UBlueprint>(InAsset);
	check(BP);
	
	ARogueProjectile* Projectile = Cast<ARogueProjectile>(BP->GeneratedClass.GetDefaultObject());
	check(Projectile);

	// Basic example, require this to be set to avoid infinite projectiles
	if (Projectile->InitialLifeSpan <= 0.0f)
	{
		FText Output = FText::Join(FText::FromString(" "), FText::FromName(Projectile->GetFName()),
			FText::FromString(TEXT("Projectile has no InitialLifespan span and may exist forever.")));
		Context.AddError(Output);
		return EDataValidationResult::Invalid;
	}

	return EDataValidationResult::Valid;
}
```

`Source/RogueEditor/Validators/EditorValidator_Projectiles.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "EditorValidatorBase.h"
#include "EditorValidator_Projectiles.generated.h"

/**
 * 
 * 
 */
UCLASS()
class ROGUEEDITOR_API UEditorValidator_Projectiles : public UEditorValidatorBase
{
	GENERATED_BODY()

	virtual bool CanValidateAsset_Implementation(const FAssetData& InAssetData, UObject* InObject, FDataValidationContext& InContext) const override;

	virtual EDataValidationResult ValidateLoadedAsset_Implementation(const FAssetData& InAssetData, UObject* InAsset, FDataValidationContext& Context) override;
	
};
```