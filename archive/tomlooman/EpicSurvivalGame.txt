Project Path: arc_tomlooman_EpicSurvivalGame_r0g6xy66

Source Tree:

```txt
arc_tomlooman_EpicSurvivalGame_r0g6xy66
├── LICENSE
├── README.md
└── SurvivalGame
    ├── Binaries
    │   └── Win64
    │       ├── UE4Editor-SurvivalGame.dll
    │       └── UnrealEditor-SurvivalGame.dll
    ├── Config
    │   ├── DefaultEditor.ini
    │   ├── DefaultEngine.ini
    │   ├── DefaultGame.ini
    │   └── DefaultInput.ini
    ├── Content
    │   ├── AI
    │   │   ├── NewZombieBT.uasset
    │   │   ├── NewZombieBlackboard.uasset
    │   │   ├── NoiseEmitterTest.uasset
    │   │   ├── Task_AttackMelee.uasset
    │   │   ├── Zombie
    │   │   │   ├── Animations
    │   │   │   │   ├── ThirdPersonIdle.uasset
    │   │   │   │   ├── ThirdPersonIdleRun.uasset
    │   │   │   │   ├── ThirdPersonJump_End.uasset
    │   │   │   │   ├── ThirdPersonJump_Loop.uasset
    │   │   │   │   ├── ThirdPersonJump_Start.uasset
    │   │   │   │   ├── ThirdPersonRun.uasset
    │   │   │   │   ├── ThirdPersonWalk.uasset
    │   │   │   │   ├── Zombie_MeleeStrike.uasset
    │   │   │   │   └── Zombie_MeleeStrike_Montage.uasset
    │   │   │   ├── Materials
    │   │   │   │   ├── MI_Zombie_Body.uasset
    │   │   │   │   ├── MI_Zombie_Body_TweakTest.uasset
    │   │   │   │   ├── MI_Zombie_Body_TweakTest_3.uasset
    │   │   │   │   ├── MI_Zombie_ChestLogo.uasset
    │   │   │   │   ├── M_UE4Man_Body.uasset
    │   │   │   │   ├── M_Zombie_Body.uasset
    │   │   │   │   ├── M_Zombie_Body_Inst.uasset
    │   │   │   │   ├── M_Zombie_Body_TweakTest2.uasset
    │   │   │   │   └── MaterialLayers
    │   │   │   │       ├── ML_BasicTestMaterial.uasset
    │   │   │   │       ├── ML_GlossyBlack_Latex_UE4.uasset
    │   │   │   │       ├── ML_Plastic_Shiny_Beige.uasset
    │   │   │   │       ├── ML_Plastic_Shiny_Beige_LOGO.uasset
    │   │   │   │       ├── ML_SoftMetal_UE4.uasset
    │   │   │   │       ├── ML_ZombieRust.uasset
    │   │   │   │       ├── T_ML_Aluminum01.uasset
    │   │   │   │       ├── T_ML_Aluminum01_N.uasset
    │   │   │   │       ├── T_ML_Rubber_Blue_01_D.uasset
    │   │   │   │       └── T_ML_Rubber_Blue_01_N.uasset
    │   │   │   ├── SK_Mannequin.uasset
    │   │   │   ├── SK_Mannequin_PhysicsAsset.uasset
    │   │   │   ├── Textures
    │   │   │   │   ├── UE4Man_Logo_N.uasset
    │   │   │   │   ├── UE4_LOGO_CARD.uasset
    │   │   │   │   ├── UE4_Mannequin_MAT_MASKA.uasset
    │   │   │   │   ├── UE4_Mannequin__normals.uasset
    │   │   │   │   └── UE4_Mannequin_occlusion.uasset
    │   │   │   ├── ThirdPersonAnimBlueprint.uasset
    │   │   │   └── UE4_Mannequin_Skeleton.uasset
    │   │   ├── ZombieBT.uasset
    │   │   ├── ZombieBlackboard.uasset
    │   │   ├── ZombieCharacter.uasset
    │   │   └── ZombieController.uasset
    │   ├── AnimStarterPack
    │   │   ├── AimOffset_Hip.uasset
    │   │   ├── AimOffset_Ironsight.uasset
    │   │   ├── AimOffsets
    │   │   │   ├── AimOffset_Hip_Center.uasset
    │   │   │   ├── AimOffset_Hip_Down.uasset
    │   │   │   ├── AimOffset_Hip_Up.uasset
    │   │   │   ├── AimOffset_Ironsight_Center.uasset
    │   │   │   ├── AimOffset_Ironsight_Up.uasset
    │   │   │   ├── Aim_Offset_Center_2.uasset
    │   │   │   ├── Aim_Offset_Down_2.uasset
    │   │   │   └── Aim_Offset_Up_2.uasset
    │   │   ├── Animations
    │   │   │   ├── Aim_Space_Hip.uasset
    │   │   │   ├── Aim_Space_Ironsights.uasset
    │   │   │   ├── Crouch_Idle_Rifle_Hip.uasset
    │   │   │   ├── Crouch_Idle_Rifle_Ironsights.uasset
    │   │   │   ├── Crouch_Walk_Bwd_Rifle_Hip.uasset
    │   │   │   ├── Crouch_Walk_Bwd_Rifle_Ironsights.uasset
    │   │   │   ├── Crouch_Walk_Fwd_Rifle_Hip.uasset
    │   │   │   ├── Crouch_Walk_Fwd_Rifle_Ironsights.uasset
    │   │   │   ├── Crouch_Walk_Lt_Rifle_Hip.uasset
    │   │   │   ├── Crouch_Walk_Lt_Rifle_Ironsights.uasset
    │   │   │   ├── Crouch_Walk_Rt_Rifle_Hip.uasset
    │   │   │   ├── Crouch_Walk_Rt_Rifle_Ironsights.uasset
    │   │   │   ├── Crouch_to_Stand_Rifle_Hip.uasset
    │   │   │   ├── Crouch_to_Stand_Rifle_Ironsights.uasset
    │   │   │   ├── Death_1.uasset
    │   │   │   ├── Death_2.uasset
    │   │   │   ├── Death_3.uasset
    │   │   │   ├── Death_Ironsights_1.uasset
    │   │   │   ├── Death_Ironsights_2.uasset
    │   │   │   ├── Equip_Pistol_Standing.uasset
    │   │   │   ├── Equip_Rifle_Standing.uasset
    │   │   │   ├── Equip_Rifle_Standing_Montage.uasset
    │   │   │   ├── Fire_Rifle_Hip.uasset
    │   │   │   ├── Fire_Rifle_Ironsights.uasset
    │   │   │   ├── Fire_Shotgun_Hip.uasset
    │   │   │   ├── Fire_Shotgun_Ironsights.uasset
    │   │   │   ├── Hit_React_1.uasset
    │   │   │   ├── Hit_React_2.uasset
    │   │   │   ├── Hit_React_3.uasset
    │   │   │   ├── Hit_React_4.uasset
    │   │   │   ├── Idle_Pistol.uasset
    │   │   │   ├── Idle_Rifle_Hip.uasset
    │   │   │   ├── Idle_Rifle_Hip_Break1.uasset
    │   │   │   ├── Idle_Rifle_Hip_Break2.uasset
    │   │   │   ├── Idle_Rifle_Ironsights.uasset
    │   │   │   ├── Jog_Bwd_Rifle.uasset
    │   │   │   ├── Jog_Fwd_Rifle.uasset
    │   │   │   ├── Jog_Lt_Rifle.uasset
    │   │   │   ├── Jog_Rt_Rifle.uasset
    │   │   │   ├── Jump_From_Jog.uasset
    │   │   │   ├── Jump_From_Stand.uasset
    │   │   │   ├── Jump_From_Stand_Ironsights.uasset
    │   │   │   ├── Prone_Death_1.uasset
    │   │   │   ├── Prone_Death_2.uasset
    │   │   │   ├── Prone_Fire_1.uasset
    │   │   │   ├── Prone_Fire_2.uasset
    │   │   │   ├── Prone_Idle.uasset
    │   │   │   ├── Prone_Reload_Rifle.uasset
    │   │   │   ├── Prone_Reload_Shotgun.uasset
    │   │   │   ├── Prone_To_Stand.uasset
    │   │   │   ├── Reload_Pistol.uasset
    │   │   │   ├── Reload_Rifle_Hip.uasset
    │   │   │   ├── Reload_Rifle_Hip_Montage.uasset
    │   │   │   ├── Reload_Rifle_Ironsights.uasset
    │   │   │   ├── Reload_Shotgun_Hip.uasset
    │   │   │   ├── Reload_Shotgun_Ironsights.uasset
    │   │   │   ├── Sprint_Fwd_Rifle.uasset
    │   │   │   ├── Stand_To_Prone.uasset
    │   │   │   ├── Stand_to_Crouch_Rifle_Hip.uasset
    │   │   │   ├── Stand_to_Crouch_Rifle_Ironsights.uasset
    │   │   │   ├── Walk_Bwd_Rifle_Ironsights.uasset
    │   │   │   ├── Walk_Fwd_Rifle_Ironsights.uasset
    │   │   │   ├── Walk_Lt_Rifle_Ironsights.uasset
    │   │   │   └── Walk_Rt_Rifle_Ironsights.uasset
    │   │   ├── BS_CrouchWalk.uasset
    │   │   ├── BS_Crouch_Targeting.uasset
    │   │   ├── BS_Jog.uasset
    │   │   ├── BS_Walk_Targeting.uasset
    │   │   ├── Character
    │   │   │   └── Aim_Offset_Center.uasset
    │   │   ├── Hip_Offset_Up.uasset
    │   │   ├── Player_AnimBP.uasset
    │   │   ├── Reload_Rifle_Hip_Montage.uasset
    │   │   └── UE4_Mannequin
    │   │       ├── Materials
    │   │       │   ├── M_UE4Man_Body.uasset
    │   │       │   ├── M_UE4Man_ChestLogo.uasset
    │   │       │   └── MaterialLayers
    │   │       │       ├── ML_GlossyBlack_Latex_UE4.uasset
    │   │       │       ├── ML_Plastic_Shiny_Beige.uasset
    │   │       │       ├── ML_Plastic_Shiny_Beige_LOGO.uasset
    │   │       │       ├── ML_SoftMetal_UE4.uasset
    │   │       │       ├── T_ML_Aluminum01.uasset
    │   │       │       ├── T_ML_Aluminum01_N.uasset
    │   │       │       ├── T_ML_Rubber_Blue_01_D.uasset
    │   │       │       └── T_ML_Rubber_Blue_01_N.uasset
    │   │       ├── Mesh
    │   │       │   ├── AimOffset_Ironsight_Down.uasset
    │   │       │   ├── SK_Mannequin.uasset
    │   │       │   ├── SK_Mannequin_PhysicsAsset.uasset
    │   │       │   └── UE4_Mannequin_Skeleton.uasset
    │   │       └── Textures
    │   │           ├── UE4Man_Logo_N.uasset
    │   │           ├── UE4_LOGO_CARD.uasset
    │   │           ├── UE4_Mannequin_MAT_MASKA.uasset
    │   │           ├── UE4_Mannequin__normals.uasset
    │   │           └── UE4_Mannequin_occlusion_Mobile.uasset
    │   ├── Base
    │   │   ├── BP_TimeOfDayManager.uasset
    │   │   ├── DefaultGameModeSetup.uasset
    │   │   ├── DmgType_AssaultRifle.uasset
    │   │   ├── DmgType_Hunger.uasset
    │   │   ├── DmgType_InstantWeapon.uasset
    │   │   ├── DmgType_ZombieMelee.uasset
    │   │   ├── MF_MaterialHighlight.uasset
    │   │   ├── MI_Dev_Mockup_01.uasset
    │   │   ├── MI_Dev_Mockup_02.uasset
    │   │   ├── OpenWorldGameModeSetup.uasset
    │   │   ├── PP_OutlineCustomDepthOcclusion.uasset
    │   │   ├── PP_OutlineCustomDepthOcclusion_Inst.uasset
    │   │   ├── PhysMat_PlayerBody.uasset
    │   │   ├── PhysMat_ZombieBody.uasset
    │   │   ├── PhysMat_ZombieHead.uasset
    │   │   ├── PhysMat_ZombieLimb.uasset
    │   │   ├── PhysMat_ZombieLimbs.uasset
    │   │   ├── SurvivalCoopGameModeSetup.uasset
    │   │   ├── SurvivalGameModeSetup.uasset
    │   │   └── T_DEV_Floor_D.uasset
    │   ├── Effects
    │   │   ├── Materials
    │   │   │   ├── Gameplay
    │   │   │   │   └── M_impact_splash_subUV.uasset
    │   │   │   ├── LensFlare
    │   │   │   │   ├── M_LensFlare_02.uasset
    │   │   │   │   └── M_Lensflare_01.uasset
    │   │   │   ├── M_Burst.uasset
    │   │   │   ├── M_Spark_Basic.uasset
    │   │   │   ├── M_explosion_subUV.uasset
    │   │   │   ├── M_radial_ramp.uasset
    │   │   │   ├── M_smoke_subUV.uasset
    │   │   │   ├── Ramp
    │   │   │   │   ├── M_SoftGradient_Muzzle.uasset
    │   │   │   │   └── M_radial_ramp_soft.uasset
    │   │   │   ├── Smoke
    │   │   │   │   ├── M_ImpactSmoke.uasset
    │   │   │   │   ├── M_MuzzleSmokeDetail_GPU.uasset
    │   │   │   │   └── M_SmokeBall.uasset
    │   │   │   ├── Snow
    │   │   │   │   └── M_Snow_Blowing_Lit.uasset
    │   │   │   ├── Weapon
    │   │   │   │   ├── M_Impact_Decal.uasset
    │   │   │   │   ├── M_MuzzleGlow.uasset
    │   │   │   │   ├── M_WP_Linkgun_Connection.uasset
    │   │   │   │   ├── M_WP_ShockRifle_Panning_Beam.uasset
    │   │   │   │   └── M_muzzle_flash_subUV.uasset
    │   │   │   ├── m_flare_01.uasset
    │   │   │   └── spark
    │   │   │       └── M_spark_subUV.uasset
    │   │   ├── Meshes
    │   │   │   └── Weapon
    │   │   │       └── SM_MuzzleCone.uasset
    │   │   ├── P_AssaultRifle_IH.uasset
    │   │   ├── P_AssaultRifle_MF.uasset
    │   │   ├── P_AssaultRifle_Trail.uasset
    │   │   ├── P_Bomb_Fuse.uasset
    │   │   ├── P_Explosion_Large.uasset
    │   │   ├── P_Explosion_Small.uasset
    │   │   ├── P_Mist_Lit_Still.uasset
    │   │   ├── P_ZombieBody_Bullet_Impact.uasset
    │   │   ├── P_body_bullet_impact.uasset
    │   │   └── Textures
    │   │       ├── Energy
    │   │       │   └── T_EFX_Beam_Electricity_02.uasset
    │   │       ├── LensFlare
    │   │       │   ├── Flare_02.uasset
    │   │       │   └── T_Lensflare_01.uasset
    │   │       ├── Mask
    │   │       │   └── T_SquareMaskTightEdge.uasset
    │   │       ├── Noise
    │   │       │   ├── T_TileNoise.uasset
    │   │       │   └── T_TilingNoise03.uasset
    │   │       ├── Ramp
    │   │       │   ├── T_FX_CameraDistort.uasset
    │   │       │   └── T_FX_ColorDistort.uasset
    │   │       ├── Smoke
    │   │       │   ├── T_Clouds_01.uasset
    │   │       │   ├── T_SmokeBall_01_8_8.uasset
    │   │       │   ├── T_SmokeSubUV_8X8_02.uasset
    │   │       │   └── T_TilingClouds_01.uasset
    │   │       ├── Spark
    │   │       │   └── T_SparkCore_2X2.uasset
    │   │       ├── T_Burst_M.uasset
    │   │       ├── T_Explosion_SubUV.uasset
    │   │       ├── T_SmokeSubUV_8X8.uasset
    │   │       ├── T_Smoke_SubUV.uasset
    │   │       ├── T_Smoke_Tiled_D.uasset
    │   │       ├── T_Spark_Core.uasset
    │   │       ├── T_blood_various.uasset
    │   │       ├── T_blood_various_N.uasset
    │   │       ├── T_explo_SubUV.uasset
    │   │       ├── Water
    │   │       │   ├── T_Caustics_2.uasset
    │   │       │   ├── T_Distortion_01.uasset
    │   │       │   └── T_Steam_02_Packed.uasset
    │   │       └── Weapon
    │   │           ├── T_bullet_hole_2.uasset
    │   │           └── T_muzzle_flashes.uasset
    │   ├── Environment
    │   │   ├── Decals
    │   │   │   ├── Damage_Leaks_01_C.uasset
    │   │   │   ├── Damage_Leaks_01_M.uasset
    │   │   │   ├── Damage_Patches_01_C.uasset
    │   │   │   ├── Damage_Patches_01_M.uasset
    │   │   │   ├── Damage_Patches_01_N.uasset
    │   │   │   ├── Graffiti_Basic_01_M.uasset
    │   │   │   └── Graffiti_Lodzero_01_c.uasset
    │   │   ├── Foliage
    │   │   │   ├── Grasses
    │   │   │   │   ├── Grass_Basic_01_C.uasset
    │   │   │   │   ├── Grass_Basic_01_FoliageType.uasset
    │   │   │   │   ├── Grass_Basic_01_M.uasset
    │   │   │   │   ├── Grass_Basic_01_M_Inst.uasset
    │   │   │   │   ├── Grass_Basic_01_N.uasset
    │   │   │   │   ├── Grass_Basic_01_SM.uasset
    │   │   │   │   ├── Grass_Basic_02_M_Inst.uasset
    │   │   │   │   ├── Heather_Branch_02_N.uasset
    │   │   │   │   ├── PlaceholderWorldUV_Mat_Func.uasset
    │   │   │   │   ├── ProcMap_Bumps_01_N.uasset
    │   │   │   │   ├── ProcMap_Noise_01_C.uasset
    │   │   │   │   ├── ProcMap_Waves_01_N.uasset
    │   │   │   │   ├── Reed_Basic_01_C.uasset
    │   │   │   │   ├── Reeds_Basic_01_C.uasset
    │   │   │   │   ├── Reeds_Basic_01_M.uasset
    │   │   │   │   ├── Reeds_Basic_01_SM.uasset
    │   │   │   │   ├── Reeds_Flowers_01_M_Inst.uasset
    │   │   │   │   ├── Reeds_Grass_01_M_Inst.uasset
    │   │   │   │   ├── Reeds_Tall_01_C.uasset
    │   │   │   │   ├── Reeds_Tall_01_N.uasset
    │   │   │   │   └── arrow_BLACK.uasset
    │   │   │   ├── HillTreeBush_01
    │   │   │   │   ├── HillTree_01_Atlas_Tex.uasset
    │   │   │   │   ├── HillTree_01_Leaves_Mat.uasset
    │   │   │   │   ├── HillTree_01_Leaves_Mat2.uasset
    │   │   │   │   ├── HillTree_Bush_01_Atlas_Billboards_Tex.uasset
    │   │   │   │   ├── HillTree_Bush_01_Atlas_Normal_Tex.uasset
    │   │   │   │   ├── HillTree_Bush_01_Atlas_Specular_Tex.uasset
    │   │   │   │   ├── HillTree_Bush_01_Atlas_Tex.uasset
    │   │   │   │   ├── M_CustomDepthBillboard.uasset
    │   │   │   │   ├── M_CustomDepthBillboard_Inst.uasset
    │   │   │   │   ├── M_HillTree_Bush_Billboard.uasset
    │   │   │   │   ├── M_HillTree_Bush_Fronds.uasset
    │   │   │   │   ├── M_HillTree_Bush_Fronds_Inst.uasset
    │   │   │   │   ├── SM_HillTree_Bush_001.uasset
    │   │   │   │   └── SM_HillTree_Bush_002.uasset
    │   │   │   ├── HillTree_01
    │   │   │   │   ├── HillTree_01_Branches_2_Mat.uasset
    │   │   │   │   ├── HillTree_01_Branches_Mat.uasset
    │   │   │   │   ├── HillTree_01_Fronds_Mat.uasset
    │   │   │   │   ├── HillTree_02.uasset
    │   │   │   │   ├── T_Craghead_Oak_LimbTile_02_D_Tex.uasset
    │   │   │   │   ├── T_Craghead_Oak_LimbTile_02_N_Tex.uasset
    │   │   │   │   ├── T_Craghead_Oak_TileMoss_01_D_Tex.uasset
    │   │   │   │   ├── T_Craghead_Oak_Tile_01_D_Tex.uasset
    │   │   │   │   ├── T_Craghead_Oak_Tile_01_N_Tex.uasset
    │   │   │   │   ├── T_HillTreeBillboard_01.uasset
    │   │   │   │   ├── T_HillTreeBillboard_01_Depth.uasset
    │   │   │   │   ├── T_HillTreeBillboard_01_N.uasset
    │   │   │   │   ├── T_HillTreeBillboard_01_SSS.uasset
    │   │   │   │   └── T_HillTreeBillboard_01_S_R.uasset
    │   │   │   └── HillTree_Tall_02
    │   │   │       ├── HillTree_Tall_01_Atlas_Billboards_Normal_Tex.uasset
    │   │   │       ├── HillTree_Tall_01_Atlas_Billboards_Tex.uasset
    │   │   │       ├── HillTree_Tall_01_Billboard_Mat.uasset
    │   │   │       └── HillTree_Tall_02.uasset
    │   │   ├── Kits
    │   │   │   ├── Houses
    │   │   │   │   ├── Basic_Window_01A_M.uasset
    │   │   │   │   ├── Basic_Window_01A_M_Inst.uasset
    │   │   │   │   ├── Basic_Window_01B_M_Inst.uasset
    │   │   │   │   ├── Doors_Basic_01_SM.uasset
    │   │   │   │   ├── House_Basic_01_SM.uasset
    │   │   │   │   ├── T_Door_D.uasset
    │   │   │   │   ├── T_Door_D_Mat.uasset
    │   │   │   │   ├── T_Door_N.uasset
    │   │   │   │   ├── T_Door_RMAH.uasset
    │   │   │   │   ├── T_Window_D.uasset
    │   │   │   │   ├── T_Window_N.uasset
    │   │   │   │   ├── T_Windows_RMO.uasset
    │   │   │   │   ├── Vents_Basic_01_C.uasset
    │   │   │   │   ├── Vents_Basic_01_M.uasset
    │   │   │   │   ├── Vents_Basic_01_N.uasset
    │   │   │   │   ├── Vents_Basic_01_RMAH.uasset
    │   │   │   │   ├── Vents_Basic_01_SM.uasset
    │   │   │   │   ├── Vents_Basic_02_SM.uasset
    │   │   │   │   ├── Window_Basic_01_M.uasset
    │   │   │   │   ├── Window_Basic_01_SM.uasset
    │   │   │   │   ├── Window_Basic_02_SM.uasset
    │   │   │   │   ├── Windows_Basic_01A_C.uasset
    │   │   │   │   └── Windows_Basic_01A_E.uasset
    │   │   │   └── Street
    │   │   │       ├── Fence_Basic_01.uasset
    │   │   │       ├── Fence_Basic_01_C.uasset
    │   │   │       ├── Fence_Basic_01_M.uasset
    │   │   │       ├── Fence_Basic_01_N.uasset
    │   │   │       ├── Fence_Basic_01_ORM.uasset
    │   │   │       ├── Wall_Concrete_01_C.uasset
    │   │   │       ├── Wall_Concrete_01_C_M.uasset
    │   │   │       ├── Wall_Concrete_01_R.uasset
    │   │   │       └── Wall_Concrete_01_SM.uasset
    │   │   ├── Landscape
    │   │   │   ├── LayerInfoObject_Grass01.uasset
    │   │   │   ├── LayerInfoObject_RiverRocks.uasset
    │   │   │   ├── LayerInfoObject_Snow01.uasset
    │   │   │   ├── MI_LandscapeExt_Inst.uasset
    │   │   │   └── M_LandscapeExt_Master.uasset
    │   │   ├── MI_BlockoutSimple_Inst.uasset
    │   │   ├── M_BlockoutSimple.uasset
    │   │   ├── Material_Layers
    │   │   │   ├── ML_MacroVariation.uasset
    │   │   │   ├── ML_RiverRocks.uasset
    │   │   │   └── NewMaterial.uasset
    │   │   ├── Materials
    │   │   │   ├── MF_CheapContrast.uasset
    │   │   │   ├── MF_RB_Land_LayerSample_02.uasset
    │   │   │   ├── MF_RB_Land_TexCoords_01.uasset
    │   │   │   ├── MF_RB_Land_TwoLayerBlend_02Grass.uasset
    │   │   │   ├── MF_WorldAlignedTexture_Normal.uasset
    │   │   │   ├── MI_Rock_Grassy_Inst.uasset
    │   │   │   └── M_Rock_Snowy.uasset
    │   │   ├── Meshes
    │   │   │   ├── SM_Cliffs.uasset
    │   │   │   ├── SM_RockGravel.uasset
    │   │   │   ├── SM_RockGravel_02.uasset
    │   │   │   └── SM_RockGravel_Foliage.uasset
    │   │   ├── Props
    │   │   │   ├── Sheds
    │   │   │   │   └── WoodenShed
    │   │   │   │       └── SM_WoodenShed_001.uasset
    │   │   │   └── Street
    │   │   │       ├── ElectricityCable_Basic_01_C.uasset
    │   │   │       ├── ElectricityCable_Basic_01_M.uasset
    │   │   │       ├── ElectricityCable_Basic_01_N.uasset
    │   │   │       ├── ElectricityCable_Basic_01_SM.uasset
    │   │   │       ├── ElectricityCable_Basic_02_SM.uasset
    │   │   │       ├── ElectricityCable_Basic_03_SM.uasset
    │   │   │       ├── ElectricityPole_Basic_01_C.uasset
    │   │   │       ├── ElectricityPole_Basic_01_M.uasset
    │   │   │       ├── ElectricityPole_Basic_01_N.uasset
    │   │   │       ├── ElectricityPole_Basic_01_ORM.uasset
    │   │   │       ├── ElectricityPole_Basic_01_SM.uasset
    │   │   │       ├── ElectricityPole_Basic_02_SM.uasset
    │   │   │       ├── ElectricityPole_Cable_01_SM.uasset
    │   │   │       └── ElectricityPole_Cable_02_SM.uasset
    │   │   ├── Skylight_TimeOfDayColor.uasset
    │   │   ├── Skylight_TimeOfDayIntensity.uasset
    │   │   ├── Textures
    │   │   │   ├── KiteDownsampled
    │   │   │   │   ├── T_GDC_Grass01_D_NoisyAlpha.uasset
    │   │   │   │   ├── T_Ground_Grass_N.uasset
    │   │   │   │   ├── T_Tile_PebblyRiverbank_D.uasset
    │   │   │   │   ├── T_Tile_PebblyRiverbank_N.uasset
    │   │   │   │   └── T_ground_Moss_D.uasset
    │   │   │   ├── T_COG_Base_Dirt.uasset
    │   │   │   ├── T_Canyon_Stripes_02.uasset
    │   │   │   ├── T_Cliff_M.uasset
    │   │   │   ├── T_FullGrass_D.uasset
    │   │   │   ├── T_FullGrass_N.uasset
    │   │   │   ├── T_GDC_Rocktest_01_N.uasset
    │   │   │   ├── T_LS_Dirt_01_N.uasset
    │   │   │   ├── T_MacroVariation.uasset
    │   │   │   ├── T_Metal_Rust_D.uasset
    │   │   │   ├── T_Perlin_Noise_M.uasset
    │   │   │   ├── T_RB_LS_Dirt_01_DispAlpha02.uasset
    │   │   │   └── T_RB_LS_Dirt_01_DispAlpha03.uasset
    │   │   └── Tiling
    │   │       ├── Houses
    │   │       │   ├── Chainlink_Basic_01_M.uasset
    │   │       │   ├── Chainlink_Basic_01_N.uasset
    │   │       │   ├── Chainlink_Basic_01_O.uasset
    │   │       │   ├── RoofTiles_Basic_01.uasset
    │   │       │   ├── RoofTiles_Basic_01_M.uasset
    │   │       │   ├── RoofTiles_Basic_01_N.uasset
    │   │       │   ├── WoodPlanks_Basic_01.uasset
    │   │       │   ├── WoodPlanks_Basic_01_M.uasset
    │   │       │   ├── WoodPlanks_Basic_01_N.uasset
    │   │       │   ├── WoodPlanks_Beams_01.uasset
    │   │       │   └── WoodPlanks_Beams_01_M.uasset
    │   │       └── Street
    │   │           └── Asphalt_Basic_01_N.uasset
    │   ├── Items
    │   │   ├── ClassicBomb.uasset
    │   │   ├── Cupcake.uasset
    │   │   ├── FlashlightPickup.uasset
    │   │   ├── Materials
    │   │   │   ├── MI_FlashLight_Lit.uasset
    │   │   │   ├── MI_FlashLight_Unlit.uasset
    │   │   │   ├── MI_LightCone.uasset
    │   │   │   ├── M_Barriers_01.uasset
    │   │   │   ├── M_Barriers_02.uasset
    │   │   │   ├── M_Black_Metal.uasset
    │   │   │   ├── M_Bomb_Fuse.uasset
    │   │   │   ├── M_DemoWall.uasset
    │   │   │   ├── M_DemoWall_Inst2.uasset
    │   │   │   ├── M_Flashlight_01.uasset
    │   │   │   ├── M_LightCone.uasset
    │   │   │   ├── M_LightSculpture.uasset
    │   │   │   └── M_Pickup_Cupcake.uasset
    │   │   ├── Meshes
    │   │   │   ├── SM_Barrier_01.uasset
    │   │   │   ├── SM_Barrier_02.uasset
    │   │   │   ├── SM_Bomb.uasset
    │   │   │   ├── SM_FlashLight.uasset
    │   │   │   ├── SM_Pickup_Cupcake.uasset
    │   │   │   └── SM_Rifle.uasset
    │   │   ├── Movable_Barrier01.uasset
    │   │   ├── RiflePickup.uasset
    │   │   └── Textures
    │   │       ├── T_Barriers_01_D.uasset
    │   │       ├── T_Cupcake.uasset
    │   │       ├── T_DustParticles_M.uasset
    │   │       ├── T_FlashLight_AO.uasset
    │   │       ├── T_FlashLight_M.uasset
    │   │       └── T_FlashLight_N.uasset
    │   ├── Maps
    │   │   ├── Landscape_Map.umap
    │   │   └── MainMenu_Entry.umap
    │   ├── Player
    │   │   ├── CamShake_TakeDamage.uasset
    │   │   ├── Materials
    │   │   │   └── M_PlayerSkin_01.uasset
    │   │   └── PlayerPawn.uasset
    │   ├── Sound
    │   │   ├── Ambient
    │   │   │   ├── AMB_Night_Drone_01.uasset
    │   │   │   ├── AMB_Night_Drone_Cue.uasset
    │   │   │   ├── A_Birds.uasset
    │   │   │   ├── Landscape_Birds.uasset
    │   │   │   ├── Landscape_WindAnimals01.uasset
    │   │   │   ├── ambient_summer.uasset
    │   │   │   ├── ambient_summer_Cue.uasset
    │   │   │   └── dryair.uasset
    │   │   ├── Attenuation
    │   │   │   ├── BodyMove_Att.uasset
    │   │   │   ├── Footstep_Att.uasset
    │   │   │   ├── ItemHit_Att.uasset
    │   │   │   ├── ObjectImpact_Att.uasset
    │   │   │   ├── PlayerVocal_Att.uasset
    │   │   │   ├── Weapon_Att.uasset
    │   │   │   └── Zombie_Att.uasset
    │   │   ├── Bodyfall_Mid05.uasset
    │   │   ├── Bodyfall_Mid06.uasset
    │   │   ├── Bodyfall_Mid07.uasset
    │   │   ├── Bodyfall_Mid08.uasset
    │   │   ├── Bodyfall_TumbleSoft_Cue.uasset
    │   │   ├── Explosion01.uasset
    │   │   ├── Explosion02.uasset
    │   │   ├── Explosion_Cue.uasset
    │   │   ├── Fire_Sparks01.uasset
    │   │   ├── Fire_Sparks_Cue.uasset
    │   │   ├── Footstep01.uasset
    │   │   ├── Footstep02.uasset
    │   │   ├── Footstep03.uasset
    │   │   ├── Footstep04.uasset
    │   │   ├── Footstep05.uasset
    │   │   ├── Footstep06.uasset
    │   │   ├── Footstep07.uasset
    │   │   ├── Footstep08.uasset
    │   │   ├── Footstep09.uasset
    │   │   ├── Footstep_Dry_Cue.uasset
    │   │   ├── Gameplay
    │   │   │   ├── Gamestate_NightEnded.uasset
    │   │   │   ├── Gamestate_NightEnded.wav
    │   │   │   ├── Gamestate_NightEnded_Cue.uasset
    │   │   │   ├── Gamestate_NightStarted.uasset
    │   │   │   ├── Gamestate_NightStarted.wav
    │   │   │   └── Gamestate_NightStarted_Cue.uasset
    │   │   ├── Items
    │   │   │   ├── Barrier_Hit_01.uasset
    │   │   │   ├── Barrier_Hit_01.wav
    │   │   │   ├── Barrier_Hit_02.uasset
    │   │   │   ├── Barrier_Hit_02.wav
    │   │   │   ├── Barrier_Hit_03.uasset
    │   │   │   ├── Barrier_Hit_03.wav
    │   │   │   ├── Barrier_Hit_04.uasset
    │   │   │   ├── Barrier_Hit_04.wav
    │   │   │   ├── Barrier_Hit_Cue.uasset
    │   │   │   ├── Bomb_Impact_01.uasset
    │   │   │   ├── Bomb_Impact_02.uasset
    │   │   │   ├── Bomb_Impact_03.uasset
    │   │   │   ├── Bomb_Impact_04.uasset
    │   │   │   ├── Bomb_Impact_Cue.uasset
    │   │   │   ├── Flashlight_Toggle.uasset
    │   │   │   ├── Flashlight_Toggle.wav
    │   │   │   └── Flashlight_Toggle_Cue.uasset
    │   │   ├── OpenValleyReverb.uasset
    │   │   ├── Player
    │   │   │   ├── Player_Death_01.uasset
    │   │   │   ├── Player_Death_02.uasset
    │   │   │   ├── Player_Death_03.uasset
    │   │   │   ├── Player_Death_04.uasset
    │   │   │   ├── Player_Death_05.uasset
    │   │   │   ├── Player_Death_06.uasset
    │   │   │   ├── Player_Death_Cue.uasset
    │   │   │   ├── Player_GetHit_01.uasset
    │   │   │   ├── Player_GetHit_02.uasset
    │   │   │   ├── Player_GetHit_03.uasset
    │   │   │   ├── Player_GetHit_04.uasset
    │   │   │   ├── Player_GetHit_05.uasset
    │   │   │   ├── Player_GetHit_06.uasset
    │   │   │   ├── Player_GetHit_07.uasset
    │   │   │   ├── Player_GetHit_08.uasset
    │   │   │   ├── Player_GetHit_09.uasset
    │   │   │   └── Player_GetHit_Cue.uasset
    │   │   ├── Swish_PunchSwing01.uasset
    │   │   ├── Swish_PunchSwing02.uasset
    │   │   ├── Swish_PunchSwing03.uasset
    │   │   ├── Swish_PunchSwing04.uasset
    │   │   ├── Swish_PunchSwing_Cue.uasset
    │   │   ├── Weapons
    │   │   │   ├── AssaultRifle_Equip_Cue.uasset
    │   │   │   ├── AssaultRifle_Reload.wav
    │   │   │   ├── AssaultRifle_Reload_Cue.uasset
    │   │   │   ├── AssaultRifle_Shot_Cue.uasset
    │   │   │   ├── Mono
    │   │   │   │   ├── AssaultRifle_Shot01.uasset
    │   │   │   │   ├── AssaultRifle_Shot02.uasset
    │   │   │   │   ├── AssaultRifle_Shot03.uasset
    │   │   │   │   ├── AssaultRifle_Shot04.uasset
    │   │   │   │   ├── AssaultRifle_Shot05.uasset
    │   │   │   │   ├── AssaultRifle_Shot06.uasset
    │   │   │   │   ├── Weapon_AssaultRifle_ImpactConcrete03.uasset
    │   │   │   │   ├── Weapon_AssaultRifle_ImpactConcrete04.uasset
    │   │   │   │   ├── Weapon_AssaultRifle_ImpactConcrete06.uasset
    │   │   │   │   ├── Weapon_AssaultRifle_ImpactConcrete_Cue.uasset
    │   │   │   │   ├── Weapon_AssaultRifle_Swap01.uasset
    │   │   │   │   ├── Weapon_AssaultRifle_Swap02.uasset
    │   │   │   │   └── Weapon_AssaultRifle_Swap03.uasset
    │   │   │   ├── SMG_Thompson
    │   │   │   │   ├── Cue_Thompson_Shot.uasset
    │   │   │   │   ├── WPN_Thompson_Bullet_Eject_01.uasset
    │   │   │   │   ├── WPN_Thompson_Bullet_Eject_02.uasset
    │   │   │   │   ├── WPN_Thompson_Bullet_Eject_03.uasset
    │   │   │   │   ├── WPN_Thompson_Bullet_Eject_04.uasset
    │   │   │   │   ├── WPN_Thompson_Pin_01.uasset
    │   │   │   │   ├── WPN_Thompson_Pin_02.uasset
    │   │   │   │   ├── WPN_Thompson_Pin_03.uasset
    │   │   │   │   ├── WPN_Thompson_Shot_01.uasset
    │   │   │   │   ├── WPN_Thompson_Shot_02.uasset
    │   │   │   │   ├── WPN_Thompson_Shot_03.uasset
    │   │   │   │   ├── WPN_Thompson_Shot_04.uasset
    │   │   │   │   ├── WPN_Thompson_Shot_05.uasset
    │   │   │   │   ├── WPN_Thompson_Shot_06.uasset
    │   │   │   │   ├── WPN_Thompson_Thud_01.uasset
    │   │   │   │   ├── WPN_Thompson_Thud_02.uasset
    │   │   │   │   ├── WPN_Thompson_Thud_03.uasset
    │   │   │   │   ├── WPN_Thompson_Thud_04.uasset
    │   │   │   │   ├── WPN_Thompson_Thud_05.uasset
    │   │   │   │   ├── WPN_Thompson_Thud_06.uasset
    │   │   │   │   ├── WPN_Thompson_Trigger_01.uasset
    │   │   │   │   ├── WPN_Thompson_Trigger_02.uasset
    │   │   │   │   ├── WPN_Thompson_Trigger_03.uasset
    │   │   │   │   └── WPN_Thompson_Trigger_04.uasset
    │   │   │   ├── Stereo
    │   │   │   │   ├── AssaultRifle_Shot01_Stereo.uasset
    │   │   │   │   ├── AssaultRifle_Shot02_Stereo.uasset
    │   │   │   │   ├── AssaultRifle_Shot03_Stereo.uasset
    │   │   │   │   ├── AssaultRifle_Shot04_Stereo.uasset
    │   │   │   │   ├── AssaultRifle_Shot05_Stereo.uasset
    │   │   │   │   └── AssaultRifle_Shot06_Stereo.uasset
    │   │   │   ├── Weapon_AssaultRifle_ImpactConcrete_Cue.uasset
    │   │   │   └── Weapon_AssaultRifle_Reload.uasset
    │   │   └── Zombie
    │   │       ├── Zombie_LimbImpact_Base_01.uasset
    │   │       ├── Zombie_LimbImpact_Base_02.uasset
    │   │       ├── Zombie_LimbImpact_Base_03.uasset
    │   │       ├── Zombie_LimbImpact_Base_04.uasset
    │   │       ├── Zombie_LimbImpact_Splat_01.uasset
    │   │       ├── Zombie_LimbImpact_Splat_02.uasset
    │   │       ├── Zombie_LimbImpact_Splat_03.uasset
    │   │       ├── Zombie_LimbImpact_Splat_04.uasset
    │   │       ├── Zombie_Vox_Attack_01.uasset
    │   │       ├── Zombie_Vox_Attack_02.uasset
    │   │       ├── Zombie_Vox_Attack_03.uasset
    │   │       ├── Zombie_Vox_Attack_Cue.uasset
    │   │       ├── Zombie_Vox_Death_01.uasset
    │   │       ├── Zombie_Vox_Death_02.uasset
    │   │       ├── Zombie_Vox_Death_03.uasset
    │   │       ├── Zombie_Vox_Death_Cue.uasset
    │   │       ├── Zombie_Vox_Detect_01.uasset
    │   │       ├── Zombie_Vox_Detect_02.uasset
    │   │       ├── Zombie_Vox_Detect_03.uasset
    │   │       ├── Zombie_Vox_Detect_04.uasset
    │   │       ├── Zombie_Vox_Detect_Cue.uasset
    │   │       ├── Zombie_Vox_Hunting_01.uasset
    │   │       ├── Zombie_Vox_Hunting_02.uasset
    │   │       ├── Zombie_Vox_Hunting_03.uasset
    │   │       ├── Zombie_Vox_Hunting_04.uasset
    │   │       ├── Zombie_Vox_Hunting_Cue.uasset
    │   │       ├── Zombie_Vox_Hurt_01.uasset
    │   │       ├── Zombie_Vox_Hurt_02.uasset
    │   │       ├── Zombie_Vox_Hurt_03.uasset
    │   │       ├── Zombie_Vox_Hurt_Cue.uasset
    │   │       ├── Zombie_Vox_Idle_01.uasset
    │   │       ├── Zombie_Vox_Idle_02.uasset
    │   │       ├── Zombie_Vox_Idle_03.uasset
    │   │       ├── Zombie_Vox_Idle_04.uasset
    │   │       ├── Zombie_Vox_Idle_05.uasset
    │   │       ├── Zombie_Vox_Idle_Cue.uasset
    │   │       ├── Zombie_Vox_Wander_01.uasset
    │   │       ├── Zombie_Vox_Wander_02.uasset
    │   │       ├── Zombie_Vox_Wander_03.uasset
    │   │       ├── Zombie_Vox_Wander_04.uasset
    │   │       ├── Zombie_Vox_Wander_05.uasset
    │   │       ├── Zombie_Vox_Wander_06.uasset
    │   │       ├── Zombie_Vox_Wander_07.uasset
    │   │       ├── Zombie_Vox_Wander_08.uasset
    │   │       ├── Zombie_Vox_Wander_10.uasset
    │   │       ├── Zombie_Vox_Wander_11.uasset
    │   │       ├── Zombie_Vox_Wander_12.uasset
    │   │       ├── Zombie_Vox_Wander_13.uasset
    │   │       └── Zombie_Vox_Wander_Cue.uasset
    │   ├── Splash
    │   │   ├── EdSplash.bmp
    │   │   └── Splash.bmp
    │   ├── UI
    │   │   ├── HUD
    │   │   │   ├── Chat
    │   │   │   │   ├── ChatItem_Default.uasset
    │   │   │   │   └── WBP_Chat.uasset
    │   │   │   ├── MF_ProceduralCircle.uasset
    │   │   │   ├── MI_ProgressCircle.uasset
    │   │   │   ├── MI_ResourceBar_Health.uasset
    │   │   │   ├── MI_ResourceBar_Hunger.uasset
    │   │   │   ├── M_HealthBar.uasset
    │   │   │   ├── M_ProgressCircle.uasset
    │   │   │   ├── M_ResourceBar_01.uasset
    │   │   │   ├── M_ResourceBar_Noise.uasset
    │   │   │   ├── PlayerList
    │   │   │   │   ├── WBP_PlayerList.uasset
    │   │   │   │   └── WBP_PlayerList_Item.uasset
    │   │   │   ├── T_CenterDot_M.uasset
    │   │   │   ├── T_HealthBar_RoundedTile.uasset
    │   │   │   ├── T_Hunger.uasset
    │   │   │   ├── T_Noise.uasset
    │   │   │   ├── Widget_AmmoCount.uasset
    │   │   │   ├── Widget_EndGameScreen.uasset
    │   │   │   ├── Widget_HUDLayout.uasset
    │   │   │   ├── Widget_MessageStream.uasset
    │   │   │   ├── Widget_NetInfo.uasset
    │   │   │   ├── Widget_PlayerHealth.uasset
    │   │   │   ├── Widget_PlayerResources.uasset
    │   │   │   ├── Widget_SpectatorHUD.uasset
    │   │   │   └── Widget_TimeOfDay.uasset
    │   │   ├── Menu
    │   │   │   ├── Widget_IngameMenu.uasset
    │   │   │   └── Widget_MainMenu.uasset
    │   │   ├── ProjectOverviewWidget.uasset
    │   │   ├── Roboto_Font.uasset
    │   │   └── SurvivalHUD.uasset
    │   └── Weapons
    │       ├── AssaultRifle.uasset
    │       ├── Crosshairs
    │       │   ├── M_Crosshairs_MultiHolo.uasset
    │       │   ├── M_Crosshairs_MultiHolo_Charge.uasset
    │       │   ├── M_Crosshairs_MultiHolo_ChargeStaggered.uasset
    │       │   ├── M_Crosshairs_MultiHolo_Scanline.uasset
    │       │   ├── M_Crosshairs_SimpleHolo.uasset
    │       │   ├── T_Crosshair_Horizontal_M.uasset
    │       │   ├── T_Crosshair_Scanline_M.uasset
    │       │   └── T_Crosshair_Simple_M.uasset
    │       ├── FlashLight.uasset
    │       ├── M_RifleTracer_01.uasset
    │       ├── Materials
    │       │   ├── MI_Rifle01.uasset
    │       │   ├── MI_Rifle02.uasset
    │       │   ├── M_Weapon01.uasset
    │       │   ├── MagGun_01_N.uasset
    │       │   ├── MagGun_02_N.uasset
    │       │   └── MagGun_SightLens_Mat.uasset
    │       ├── P_RifleTracer_01.uasset
    │       ├── RifleImpactEffects.uasset
    │       ├── SK_FlashLight.uasset
    │       ├── SK_FlashLight_PhysicsAsset.uasset
    │       ├── SK_FlashLight_Skeleton.uasset
    │       ├── SK_Rifle.uasset
    │       ├── SK_Rifle_Skeleton.uasset
    │       └── SM_FlashLight_LightCone.uasset
    ├── Platforms
    │   └── HoloLens
    │       └── Config
    │           └── HoloLensEngine.ini
    ├── Plugins
    │   ├── ExtendedRifleMod
    │   │   ├── Content
    │   │   │   ├── AssaultRifle_Pink.uasset
    │   │   │   ├── Effects
    │   │   │   │   ├── MI_RifleTracer_Pink.uasset
    │   │   │   │   ├── P_AssaultRifle_MF_Pink.uasset
    │   │   │   │   ├── P_RifleTracer_01.uasset
    │   │   │   │   └── P_RifleTracer_Pink.uasset
    │   │   │   ├── Maps
    │   │   │   │   └── RifleMod_Map.umap
    │   │   │   ├── Materials
    │   │   │   │   ├── MI_Crosshairs_MultiHolo_Pink.uasset
    │   │   │   │   ├── MI_MagGun01_Pink.uasset
    │   │   │   │   └── MI_MagGun02_Pink.uasset
    │   │   │   ├── Meshes
    │   │   │   │   ├── SK_Rifle_Pink.uasset
    │   │   │   │   ├── SK_Rifle_Pink_Skeleton.uasset
    │   │   │   │   └── SM_Rifle_Pink.uasset
    │   │   │   ├── RiflePickup_Pink.uasset
    │   │   │   ├── SK_Rifle_Skeleton.uasset
    │   │   │   └── SurvivalGameMode_PinkRifle.uasset
    │   │   └── ExtendedRifleMod.uplugin
    │   └── MyFlashlightMod
    │       ├── Content
    │       │   ├── FlashLight_Red.uasset
    │       │   ├── ReplaceWeaponExampleMutator.uasset
    │       │   ├── SurvivalCoopGameModeSetup_Mutated.uasset
    │       │   └── TestMutation_Map.umap
    │       └── MyFlashlightMod.uplugin
    ├── Source
    │   ├── SurvivalGame
    │   │   ├── Private
    │   │   │   ├── AI
    │   │   │   │   ├── BTTask_FindBotWaypoint.cpp
    │   │   │   │   ├── BTTask_FindPatrolLocation.cpp
    │   │   │   │   ├── SBotWaypoint.cpp
    │   │   │   │   ├── SZombieAIController.cpp
    │   │   │   │   └── SZombieCharacter.cpp
    │   │   │   ├── Components
    │   │   │   │   ├── SCarryObjectComponent.cpp
    │   │   │   │   └── SCharacterMovementComponent.cpp
    │   │   │   ├── Core
    │   │   │   │   └── SGameplayStatics.cpp
    │   │   │   ├── Editor
    │   │   │   │   └── SoundNodeLocalPlayer.cpp
    │   │   │   ├── Items
    │   │   │   │   ├── SBombActor.cpp
    │   │   │   │   ├── SConsumableActor.cpp
    │   │   │   │   ├── SDamageType.cpp
    │   │   │   │   ├── SFlashlight.cpp
    │   │   │   │   ├── SImpactEffect.cpp
    │   │   │   │   ├── SPickupActor.cpp
    │   │   │   │   ├── SUsableActor.cpp
    │   │   │   │   ├── SWeapon.cpp
    │   │   │   │   ├── SWeaponInstant.cpp
    │   │   │   │   └── SWeaponPickup.cpp
    │   │   │   ├── Mutators
    │   │   │   │   ├── SMutator.cpp
    │   │   │   │   └── SMutator_WeaponReplacement.cpp
    │   │   │   ├── Player
    │   │   │   │   ├── SBaseCharacter.cpp
    │   │   │   │   ├── SCharacter.cpp
    │   │   │   │   ├── SLocalPlayer.cpp
    │   │   │   │   ├── SPlayerCameraManager.cpp
    │   │   │   │   ├── SPlayerController.cpp
    │   │   │   │   ├── SPlayerState.cpp
    │   │   │   │   └── SSpectatorPawn.cpp
    │   │   │   ├── UI
    │   │   │   │   └── SHUD.cpp
    │   │   │   └── World
    │   │   │       ├── SCoopGameMode.cpp
    │   │   │       ├── SGameInstance.cpp
    │   │   │       ├── SGameMode.cpp
    │   │   │       ├── SGameState.cpp
    │   │   │       ├── SOpenWorldGameMode.cpp
    │   │   │       ├── SPlayerStart.cpp
    │   │   │       └── STimeOfDayManager.cpp
    │   │   ├── Public
    │   │   │   ├── AI
    │   │   │   │   ├── BTTask_FindBotWaypoint.h
    │   │   │   │   ├── BTTask_FindPatrolLocation.h
    │   │   │   │   ├── SBotWaypoint.h
    │   │   │   │   ├── SZombieAIController.h
    │   │   │   │   └── SZombieCharacter.h
    │   │   │   ├── Components
    │   │   │   │   ├── SCarryObjectComponent.h
    │   │   │   │   └── SCharacterMovementComponent.h
    │   │   │   ├── Core
    │   │   │   │   └── SGameplayStatics.h
    │   │   │   ├── Editor
    │   │   │   │   └── SoundNodeLocalPlayer.h
    │   │   │   ├── Items
    │   │   │   │   ├── SBombActor.h
    │   │   │   │   ├── SConsumableActor.h
    │   │   │   │   ├── SDamageType.h
    │   │   │   │   ├── SFlashlight.h
    │   │   │   │   ├── SImpactEffect.h
    │   │   │   │   ├── SPickupActor.h
    │   │   │   │   ├── SUsableActor.h
    │   │   │   │   ├── SWeapon.h
    │   │   │   │   ├── SWeaponInstant.h
    │   │   │   │   └── SWeaponPickup.h
    │   │   │   ├── Mutators
    │   │   │   │   ├── SMutator.h
    │   │   │   │   └── SMutator_WeaponReplacement.h
    │   │   │   ├── Player
    │   │   │   │   ├── SBaseCharacter.h
    │   │   │   │   ├── SCharacter.h
    │   │   │   │   ├── SLocalPlayer.h
    │   │   │   │   ├── SPlayerCameraManager.h
    │   │   │   │   ├── SPlayerController.h
    │   │   │   │   ├── SPlayerState.h
    │   │   │   │   └── SSpectatorPawn.h
    │   │   │   ├── UI
    │   │   │   │   └── SHUD.h
    │   │   │   └── World
    │   │   │       ├── SCoopGameMode.h
    │   │   │       ├── SGameInstance.h
    │   │   │       ├── SGameMode.h
    │   │   │       ├── SGameState.h
    │   │   │       ├── SOpenWorldGameMode.h
    │   │   │       ├── SPlayerStart.h
    │   │   │       └── STimeOfDayManager.h
    │   │   ├── STypes.h
    │   │   ├── SurvivalGame.Build.cs
    │   │   ├── SurvivalGame.cpp
    │   │   └── SurvivalGame.h
    │   ├── SurvivalGame.Target.cs
    │   ├── SurvivalGameEditor.Target.cs
    │   └── SurvivalGameServer.Target.cs
    └── SurvivalGame.uproject

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Tom Looman

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Notice: This project started back in 2015 and therefor uses *very old* standards and conventions. For an up-to-date Sample project I recommend my [Action Roguelike project](https://github.com/tomlooman/ActionRoguelike) instead!

Survival Game (Example Project)
-------------------------

Third-person survival game for Unreal Engine made entirely in C++. Originally built as a 6 section tutorial series for Epic Games, now available as open-source C++ sample project. 

**Looking for a step-by-step Unreal Engine C++ Course?** Check out the **[Professional Game Development in C++ and Unreal Engine](https://courses.tomlooman.com/p/unrealengine-cpp?coupon_code=COMMUNITY15&src=github)** to learn all about C++ Game Programming with Unreal Engine! 

The C++ Course features include building of a C++ game framework including an "action system" and event-driven code for flexible and re-usable game code the "unreal way". Multiplayer features, AI bots, SaveGame system, async loading of content, UMG menus and UI and so much more!

## Project Overview

The C++ Course features include building of a C++ game framework including an "action system" and event-driven code for flexible and re-usable game code the "unreal way". Multiplayer features, AI bots, SaveGame system, async loading of content, UMG menus and UI and so much more!

You can browse different Engine Versions by using the Branch Selection drop-down.

![GitHub Branch Selection Info](https://www.tomlooman.com/assets/images/github_branchesinfo.jpg)

```

`SurvivalGame/Config/DefaultEditor.ini`:

```ini
[EditoronlyBP]
bAllowClassAndBlueprintPinMatching=true
bReplaceBlueprintWithClass=true
bDontLoadBlueprintOutsideEditor=true
bBlueprintIsNotBlueprintType=true

[/Script/AdvancedPreviewScene.SharedProfiles]


```

`SurvivalGame/Config/DefaultEngine.ini`:

```ini
[URL]

[/Script/HardwareTargeting.HardwareTargetingSettings]
TargetedHardwareClass=Desktop
AppliedTargetedHardwareClass=Desktop
DefaultGraphicsPerformance=Maximum
AppliedDefaultGraphicsPerformance=Maximum

[/Script/Engine.Engine]
; Our custom LocalPlayer class
LocalPlayerClassName=/Script/SurvivalGame.SLocalPlayer

; STEAM CONFIG START

[/Script/Engine.GameEngine]
+NetDriverDefinitions=(DefName="GameNetDriver",DriverClassName="/Script/OnlineSubsystemSteam.SteamNetDriver",DriverClassNameFallback="/Script/OnlineSubsystemUtils.IpNetDriver")

[OnlineSubsystem]
DefaultPlatformService=Steam

[OnlineSubsystemSteam]
bEnabled=true
SteamDevAppId=480 ; default app id for testing apps (can change to your own AppID if you have one)
;SteamAppId=480 ; this must be changed to your own ID for shipping builds eventually

; STEAM CONFIG END

[/Script/Engine.UserInterfaceSettings]
RenderFocusRule=NavigationOnly
DefaultCursor=None
TextEditBeamCursor=None
CrosshairsCursor=None
GrabHandCursor=None
GrabHandClosedCursor=None
SlashedCircleCursor=None
UIScaleRule=ShortestSide
UIScaleCurve=(EditorCurveData=(Keys=((Time=480.000000,Value=0.444000),(Time=720.000000,Value=0.666000),(Time=1080.000000,Value=1.000000),(Time=8640.000000,Value=8.000000))),ExternalCurve=None)

[/Script/Engine.RendererSettings]
r.MobileHDR=True
r.AllowOcclusionQueries=True
r.MinScreenRadiusForLights=0.030000
r.MinScreenRadiusForDepthPrepass=0.030000
r.PrecomputedVisibilityWarning=False
r.TextureStreaming=True
Compat.UseDXT5NormalMaps=False
r.AllowStaticLighting=True
r.NormalMapsForStaticLighting=False
r.GBuffer=True
r.GenerateMeshDistanceFields=True
r.Shadow.DistanceFieldPenumbraSize=0.050000
r.TessellationAdaptivePixelsPerTriangle=48.000000
r.SeparateTranslucency=True
r.TranslucentSortPolicy=0
TranslucentSortAxis=(X=0.000000,Y=-1.000000,Z=0.000000)
r.CustomDepth=1
r.DefaultFeature.Bloom=True
r.DefaultFeature.AmbientOcclusion=True
r.DefaultFeature.AmbientOcclusionStaticFraction=True
r.DefaultFeature.AutoExposure=True
r.DefaultFeature.MotionBlur=False
r.DefaultFeature.LensFlare=False
r.DefaultFeature.AntiAliasing=2
r.EarlyZPass=3
r.EarlyZPassMovable=False
;r.DBuffer=False // Required for Decals
r.ClearSceneMethod=1
r.WireframeCullThreshold=5.000000
UIScaleRule=ShortestSide
UIScaleCurve=(EditorCurveData=(Keys=),ExternalCurve=None)
r.SupportLowQualityLightmaps=False
r.Shadow.Virtual.Enable=1
r.ReflectionMethod=1

[/Script/NavigationSystem.RecastNavMesh]
bDistinctlyDrawTilesBeingBuilt=True
DrawOffset=10.000000
bFixedTilePoolSize=False
TilePoolSize=1024
TileSizeUU=1000.000000
CellSize=19.000000
CellHeight=10.000000
AgentRadius=34.000000
AgentHeight=144.000000
AgentMaxHeight=160.000000
AgentMaxSlope=44.000000
AgentMaxStepHeight=35.000000
MinRegionArea=0.000000
MergeRegionSize=400.000000
MaxSimplificationError=1.300000
DefaultDrawDistance=5000.000000
DefaultMaxSearchNodes=2048.000000
DefaultMaxHierarchicalSearchNodes=2048.000000
RegionPartitioning=Watershed
LayerPartitioning=Watershed
RegionChunkSplits=2
LayerChunkSplits=2
bSortNavigationAreasByCost=False
bPerformVoxelFiltering=True
bMarkLowHeightAreas=False
bUseBetterOffsetsFromCorners=True
bUseVirtualFilters=True
bUseVoxelCache=False
TileSetUpdateInterval=1.000000
HeuristicScale=0.999000
bRebuildAtRuntime=True

[/Script/Engine.CollisionProfile]
+EditProfiles=(Name="OverlapAllDynamic",CustomResponses=((Channel="Weapon",Response=ECR_Overlap)))
+EditProfiles=(Name="OverlapOnlyPawn",CustomResponses=((Channel="Weapon",Response=ECR_Ignore)))
+EditProfiles=(Name="OverlapAll",CustomResponses=((Channel="Weapon",Response=ECR_Overlap)))
+EditProfiles=(Name="Trigger",CustomResponses=((Channel="Weapon",Response=ECR_Ignore)))
+EditProfiles=(Name="UI",CustomResponses=((Channel="Weapon",Response=ECR_Ignore)))
+EditProfiles=(Name="NoCollision",CustomResponses=((Channel="Weapon",Response=ECR_Ignore)))

; customized game channel
; if you do this, make sure you define in native for convenience
+DefaultChannelResponses=(Channel=ECC_GameTraceChannel1, Name=Weapon, bTraceType=true)

[/Script/EngineSettings.GameMapsSettings]
EditorStartupMap=/Game/Maps/Landscape_Map.Landscape_Map
LocalMapOptions=
TransitionMap=
bUseSplitscreen=True
TwoPlayerSplitscreenLayout=Horizontal
ThreePlayerSplitscreenLayout=FavorTop
GameInstanceClass=/Script/SurvivalGame.SGameInstance
GameDefaultMap=/Game/Maps/MainMenu_Entry.MainMenu_Entry
ServerDefaultMap=/Game/Maps/CoopLandscape_Map.CoopLandscape_Map
GlobalDefaultGameMode=/Game/Base/SurvivalCoopGameModeSetup.SurvivalCoopGameModeSetup_C
GlobalDefaultServerGameMode=None

[/Script/IOSRuntimeSettings.IOSRuntimeSettings]
bSupportsPortraitOrientation=False
bSupportsUpsideDownOrientation=False
bSupportsLandscapeLeftOrientation=True
PreferredLandscapeOrientation=LandscapeLeft

[/Script/Engine.PhysicsSettings]
DefaultGravityZ=-980.000000
DefaultTerminalVelocity=4000.000000
DefaultFluidFriction=0.300000
SimulateScratchMemorySize=262144
RagdollAggregateThreshold=4
TriangleMeshTriangleMinAreaThreshold=5.000000
bEnableShapeSharing=False
bEnablePCM=True
bEnableStabilization=False
bWarnMissingLocks=True
bEnable2DPhysics=False
PhysicErrorCorrection=(PingExtrapolation=0.100000,PingLimit=100.000000,ErrorPerLinearDifference=1.000000,ErrorPerAngularDifference=1.000000,MaxRestoredStateError=1.000000,MaxLinearHardSnapDistance=400.000000,PositionLerp=0.000000,AngleLerp=0.400000,LinearVelocityCoefficient=100.000000,AngularVelocityCoefficient=10.000000,ErrorAccumulationSeconds=0.500000,ErrorAccumulationDistanceSq=15.000000,ErrorAccumulationSimilarity=100.000000)
LockedAxis=Invalid
DefaultDegreesOfFreedom=Full3D
BounceThresholdVelocity=200.000000
FrictionCombineMode=Average
RestitutionCombineMode=Average
MaxAngularVelocity=3600.000000
MaxDepenetrationVelocity=0.000000
ContactOffsetMultiplier=0.020000
MinContactOffset=2.000000
MaxContactOffset=8.000000
bSimulateSkeletalMeshOnDedicatedServer=True
DefaultShapeComplexity=CTF_UseSimpleAndComplex
bDefaultHasComplexCollision=True
bSuppressFaceRemapTable=False
bSupportUVFromHitResults=False
bDisableActiveActors=False
bDisableKinematicStaticPairs=False
bDisableKinematicKinematicPairs=False
bDisableCCD=False
bEnableEnhancedDeterminism=False
AnimPhysicsMinDeltaTime=0.000000
bSimulateAnimPhysicsAfterReset=False
MaxPhysicsDeltaTime=0.033333
bSubstepping=False
bSubsteppingAsync=False
MaxSubstepDeltaTime=0.016667
MaxSubsteps=6
SyncSceneSmoothingFactor=0.000000
InitialAverageFrameRate=0.016667
PhysXTreeRebuildRate=10
+PhysicalSurfaces=(Type=SurfaceType1,Name="PlayerBody")
+PhysicalSurfaces=(Type=SurfaceType2,Name="ZombieBody")
+PhysicalSurfaces=(Type=SurfaceType3,Name="ZombieHead")
+PhysicalSurfaces=(Type=SurfaceType4,Name="ZombieLimb")
DefaultBroadphaseSettings=(bUseMBPOnClient=False,bUseMBPOnServer=False,bUseMBPOuterBounds=False,MBPBounds=(Min=(X=0.000000,Y=0.000000,Z=0.000000),Max=(X=0.000000,Y=0.000000,Z=0.000000),IsValid=0),MBPOuterBounds=(Min=(X=0.000000,Y=0.000000,Z=0.000000),Max=(X=0.000000,Y=0.000000,Z=0.000000),IsValid=0),MBPNumSubdivs=2)
ChaosSettings=(DefaultThreadingModel=DedicatedThread,DedicatedThreadTickMode=VariableCappedWithTarget,DedicatedThreadBufferMode=Double)

[/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]
bEnablePlugin=True
bAllowNetworkConnection=True
SecurityToken=9495D50D45F39ABAB3DBC1AEAAF6486B
bIncludeInShipping=False
bAllowExternalStartInShipping=False
bCompileAFSProject=False
bUseCompression=False
bLogFiles=False
bReportStats=False
ConnectionType=USBOnly
bUseManualIPAddress=False
ManualIPAddress=

[/Script/WindowsTargetPlatform.WindowsTargetSettings]
DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
-D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM6
-D3D11TargetedShaderFormats=PCD3D_SM5
+D3D11TargetedShaderFormats=PCD3D_SM5
Compiler=Default
AudioSampleRate=48000
AudioCallbackBufferFrameSize=1024
AudioNumBuffersToEnqueue=1
AudioMaxChannels=0
AudioNumSourceWorkers=4
SpatializationPlugin=
SourceDataOverridePlugin=
ReverbPlugin=
OcclusionPlugin=
CompressionOverrides=(bOverrideCompressionTimes=False,DurationThreshold=5.000000,MaxNumRandomBranches=0,SoundCueQualityIndex=0)
CacheSizeKB=65536
MaxChunkSizeOverrideKB=0
bResampleForDevice=False
MaxSampleRate=48000.000000
HighSampleRate=32000.000000
MedSampleRate=24000.000000
LowSampleRate=12000.000000
MinSampleRate=8000.000000
CompressionQualityModifier=1.000000
AutoStreamingThreshold=0.000000
SoundCueCookQualityIndex=-1


```

`SurvivalGame/Config/DefaultGame.ini`:

```ini
[/Script/EngineSettings.GeneralProjectSettings]
CompanyName=Epic Games
CopyrightNotice=Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.
Description=Survival Sample game in C++.
Homepage="https://tomlooman.com"
ProjectID=00000000000000000000000000000000
ProjectName=Survival Game
ProjectDisplayedTitle=Survival Game

[/Script/UnrealEd.ProjectPackagingSettings]
Build=IfProjectHasCode
BuildConfiguration=PPBC_Development
StagingDirectory=(Path="")
FullRebuild=False
ForDistribution=False
IncludeDebugFiles=False
BlueprintNativizationMethod=Disabled
bIncludeNativizedAssetsInProjectGeneration=False
bExcludeMonolithicEngineHeadersInNativizedCode=False
UsePakFile=True
bGenerateChunks=False
bGenerateNoChunks=False
bChunkHardReferencesOnly=False
bForceOneChunkPerFile=False
MaxChunkSize=0
bBuildHttpChunkInstallData=False
HttpChunkInstallDataDirectory=(Path="")
PakFileCompressionFormats=
PakFileAdditionalCompressionOptions=
HttpChunkInstallDataVersion=
IncludePrerequisites=True
IncludeAppLocalPrerequisites=False
bShareMaterialShaderCode=False
bSharedMaterialNativeLibraries=False
ApplocalPrerequisitesDirectory=(Path="")
IncludeCrashReporter=False
InternationalizationPreset=English
-CulturesToStage=en
+CulturesToStage=en
bCookAll=False
bCookMapsOnly=False
bCompressed=False
bEncryptIniFiles=False
bEncryptPakIndex=False
GenerateEarlyDownloaderPakFile=False
bSkipEditorContent=False
bSkipMovies=False
+MapsToCook=(FilePath="/Game/Maps/MainMenu_Entry")
+MapsToCook=(FilePath="/Game/Maps/CoopLandscape_Map")
bNativizeBlueprintAssets=False
bNativizeOnlySelectedBlueprints=False



```

`SurvivalGame/Config/DefaultInput.ini`:

```ini


[/Script/Engine.InputSettings]
-AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Left_TriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Left_Grip1Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Left_Grip2Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Right_TriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Right_Grip1Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MotionController_Right_Grip2Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
bAltEnterTogglesFullscreen=True
bF11TogglesFullscreen=True
bUseMouseForTouch=False
bEnableMouseSmoothing=True
bEnableFOVScaling=True
bCaptureMouseOnLaunch=True
bEnableLegacyInputScales=True
bEnableMotionControls=True
bFilterInputByPlatformUser=False
bEnableInputDeviceSubsystem=True
bShouldFlushPressedKeysOnViewportFocusLost=True
bEnableDynamicComponentInputBinding=True
bAlwaysShowTouchInterface=False
bShowConsoleOnFourFingerTap=True
bEnableGestureRecognizer=False
bUseAutocorrect=False
DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
DefaultViewportMouseLockMode=LockOnCapture
FOVScale=0.011110
DoubleClickTime=0.200000
+ActionMappings=(ActionName="Use",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=E)
+ActionMappings=(ActionName="Jump",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=SpaceBar)
+ActionMappings=(ActionName="Fire",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftMouseButton)
+ActionMappings=(ActionName="Targeting",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=RightMouseButton)
+ActionMappings=(ActionName="SprintHold",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftShift)
+ActionMappings=(ActionName="CrouchToggle",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftControl)
+ActionMappings=(ActionName="CrouchToggle",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=C)
+ActionMappings=(ActionName="NextWeapon",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=MouseScrollUp)
+ActionMappings=(ActionName="NextWeapon",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Q)
+ActionMappings=(ActionName="PrevWeapon",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=MouseScrollDown)
+ActionMappings=(ActionName="DropWeapon",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=F)
+ActionMappings=(ActionName="EquipPrimaryWeapon",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=One)
+ActionMappings=(ActionName="EquipSecondaryWeapon",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Two)
+ActionMappings=(ActionName="PickupObject",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=MiddleMouseButton)
+ActionMappings=(ActionName="Reload",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=R)
+ActionMappings=(ActionName="ShowIntroHelp",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Tab)
+ActionMappings=(ActionName="Use",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Left)
+ActionMappings=(ActionName="Jump",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Bottom)
+ActionMappings=(ActionName="Fire",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_RightTrigger)
+ActionMappings=(ActionName="Targeting",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_LeftTrigger)
+ActionMappings=(ActionName="SprintHold",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_LeftThumbstick)
+ActionMappings=(ActionName="CrouchToggle",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_RightThumbstick)
+ActionMappings=(ActionName="NextWeapon",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Top)
+ActionMappings=(ActionName="DropWeapon",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Right)
+ActionMappings=(ActionName="PickupObject",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_RightShoulder)
+ActionMappings=(ActionName="Reload",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Left)
+ActionMappings=(ActionName="InGameMenu",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Escape)
+ActionMappings=(ActionName="Chat",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Y)
+AxisMappings=(AxisName="MoveForward",Scale=1.000000,Key=W)
+AxisMappings=(AxisName="MoveRight",Scale=1.000000,Key=D)
+AxisMappings=(AxisName="MoveForward",Scale=-1.000000,Key=S)
+AxisMappings=(AxisName="MoveRight",Scale=-1.000000,Key=A)
+AxisMappings=(AxisName="Turn",Scale=1.000000,Key=MouseX)
+AxisMappings=(AxisName="Lookup",Scale=-1.000000,Key=MouseY)
+AxisMappings=(AxisName="MoveForward",Scale=1.000000,Key=Gamepad_LeftY)
+AxisMappings=(AxisName="MoveForward",Scale=-1.000000,Key=Gamepad_LeftY)
+AxisMappings=(AxisName="MoveRight",Scale=1.000000,Key=Gamepad_LeftX)
+AxisMappings=(AxisName="MoveRight",Scale=-1.000000,Key=Gamepad_LeftX)
+AxisMappings=(AxisName="Turn",Scale=1.000000,Key=Gamepad_RightX)
+AxisMappings=(AxisName="Lookup",Scale=1.000000,Key=Gamepad_RightY)
DefaultPlayerInputClass=/Script/EnhancedInput.EnhancedPlayerInput
DefaultInputComponentClass=/Script/EnhancedInput.EnhancedInputComponent
DefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks
-ConsoleKeys=Tilde
+ConsoleKeys=Tilde


```

`SurvivalGame/Platforms/HoloLens/Config/HoloLensEngine.ini`:

```ini


[/Script/HoloLensPlatformEditor.HoloLensTargetSettings]
bBuildForEmulation=False
bBuildForDevice=True
bUseNameForLogo=True
bBuildForRetailWindowsStore=False
bAutoIncrementVersion=False
bShouldCreateAppInstaller=False
AppInstallerInstallationURL=
HoursBetweenUpdateChecks=0
bEnablePIXProfiling=False
TileBackgroundColor=(B=64,G=0,R=0,A=255)
SplashScreenBackgroundColor=(B=64,G=0,R=0,A=255)
+PerCultureResources=(CultureId="",Strings=(PackageDisplayName="",PublisherDisplayName="",PackageDescription="",ApplicationDisplayName="",ApplicationDescription=""),Images=())
TargetDeviceFamily=Windows.Holographic
MinimumPlatformVersion=10.0.18362.0
MaximumPlatformVersionTested=10.0.19041.0
MaxTrianglesPerCubicMeter=500.000000
SpatialMeshingVolumeSize=20.000000
CompilerVersion=Default
Windows10SDKVersion=10.0.18362.0
+CapabilityList=internetClientServer
+CapabilityList=privateNetworkClientServer
+Uap2CapabilityList=spatialPerception
bSetDefaultCapabilities=False
SpatializationPlugin=
SourceDataOverridePlugin=
ReverbPlugin=
OcclusionPlugin=
SoundCueCookQualityIndex=-1


```

`SurvivalGame/Plugins/ExtendedRifleMod/ExtendedRifleMod.uplugin`:

```uplugin
{
	"FileVersion" : 3,
	
	"FriendlyName" : "ExtendedRifleMod",
	"Version" : 1,
	"VersionName" : "1.0",
	"CreatedBy" : "Tom Looman",
	"CreatedByURL" : "https://www.tomlooman.com",
	"Description" : "My Extend Rifle Mod",
	"EngineVersion" : "5.2",
	"Category" : "User Mod",
	"EnabledByDefault" : true,

	"Modules" :
	[
	],

	"CanContainContent" : true
}
```

`SurvivalGame/Plugins/MyFlashlightMod/MyFlashlightMod.uplugin`:

```uplugin
{
	"FileVersion" : 3,
	
	"FriendlyName" : "MyFlashlightMod",
	"Version" : 1,
	"VersionName" : "1.0",
	"CreatedBy" : "Tom Looman",
	"CreatedByURL" : "https://www.tomlooman.com",
	"Description" : "My Flashlight Mod",
	"EngineVersion" : "5.2",
	"Category" : "User Mod",
	"EnabledByDefault" : true,

	"Modules" :
	[
	],

	"CanContainContent" : true
}
```

`SurvivalGame/Source/SurvivalGame.Target.cs`:

```cs
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class SurvivalGameTarget : TargetRules
{
	public SurvivalGameTarget(TargetInfo Target) : base(Target)
    {
        DefaultBuildSettings = BuildSettingsVersion.V2;
        Type = TargetType.Game;
        ExtraModuleNames.AddRange(new string[] { "SurvivalGame" });
    }
}

```

`SurvivalGame/Source/SurvivalGame/Private/AI/BTTask_FindBotWaypoint.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#include "AI/BTTask_FindBotWaypoint.h"
#include "AI/SBotWaypoint.h"
#include "AI/SZombieAIController.h"
/* AI Module includes */
#include "BehaviorTree/BehaviorTreeComponent.h"
#include "BehaviorTree/BlackboardComponent.h"
/* This contains includes all key types like UBlackboardKeyType_Vector used below. */
#include "BehaviorTree/Blackboard/BlackboardKeyAllTypes.h"
#include "Kismet/GameplayStatics.h"


EBTNodeResult::Type UBTTask_FindBotWaypoint::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)
{
	ASZombieAIController* MyController = Cast<ASZombieAIController>(OwnerComp.GetAIOwner());
	if (MyController == nullptr)
	{
		return EBTNodeResult::Failed;
	}

	/* Iterate all the bot waypoints in the current level and find a new random waypoint to set as destination */
	TArray<AActor*> AllWaypoints;
	UGameplayStatics::GetAllActorsOfClass(MyController, ASBotWaypoint::StaticClass(), AllWaypoints);

	if (AllWaypoints.Num() == 0)
		return EBTNodeResult::Failed;

	/* Find a new waypoint randomly by index (this can include the current waypoint) */
	/* For more complex or human AI you could add some weights based on distance and other environmental conditions here */
	AActor* NewWaypoint = AllWaypoints[FMath::RandRange(0, AllWaypoints.Num() - 1)];

	/* Assign the new waypoint to the Blackboard */
	if (NewWaypoint)
	{
		/* The selected key should be "CurrentWaypoint" in the BehaviorTree setup */
		OwnerComp.GetBlackboardComponent()->SetValue<UBlackboardKeyType_Object>(BlackboardKey.GetSelectedKeyID(), NewWaypoint);
		return EBTNodeResult::Succeeded;
	}

	return EBTNodeResult::Failed;
}

```

`SurvivalGame/Source/SurvivalGame/Private/AI/BTTask_FindPatrolLocation.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "AI/BTTask_FindPatrolLocation.h"
#include "AI/SBotWaypoint.h"
#include "AI/SZombieAIController.h"

/* AI Module includes */
#include "BehaviorTree/BehaviorTreeComponent.h"
#include "BehaviorTree/BlackboardComponent.h"
/* This contains includes all key types like UBlackboardKeyType_Vector used below. */
#include "BehaviorTree/Blackboard/BlackboardKeyAllTypes.h"
#include "NavigationSystem.h"



EBTNodeResult::Type UBTTask_FindPatrolLocation::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)
{
	ASZombieAIController* MyController = Cast<ASZombieAIController>(OwnerComp.GetAIOwner());
	if (MyController == nullptr)
	{
		return EBTNodeResult::Failed;
	}

	AActor* MyWaypoint = MyController->GetWaypoint();
	if (MyWaypoint)
	{
		/* Find a position that is close to the waypoint. We add a small random to this position to give build predictable patrol patterns  */
		const float SearchRadius = 200.0f;
		const FVector SearchOrigin = MyWaypoint->GetActorLocation();

		FNavLocation ResultLocation;
		UNavigationSystemV1* NavSystem = UNavigationSystemV1::GetNavigationSystem(MyController);
		if (NavSystem && NavSystem->GetRandomPointInNavigableRadius(SearchOrigin, SearchRadius, ResultLocation))
		{
			/* The selected key should be "PatrolLocation" in the BehaviorTree setup */
			OwnerComp.GetBlackboardComponent()->SetValue<UBlackboardKeyType_Vector>(BlackboardKey.GetSelectedKeyID(), ResultLocation.Location);
			return EBTNodeResult::Succeeded;
		}
	}

	return EBTNodeResult::Failed;
}

```

`SurvivalGame/Source/SurvivalGame/Private/AI/SBotWaypoint.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "AI/SBotWaypoint.h"





```

`SurvivalGame/Source/SurvivalGame/Private/AI/SZombieAIController.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "AI/SZombieAIController.h"
#include "AI/SZombieCharacter.h"

/* AI Specific includes */
#include "BehaviorTree/BehaviorTree.h"
#include "BehaviorTree/BehaviorTreeComponent.h"
#include "BehaviorTree/BlackboardComponent.h"


ASZombieAIController::ASZombieAIController()
{
	BehaviorComp = CreateDefaultSubobject<UBehaviorTreeComponent>(TEXT("BehaviorComp"));
	BlackboardComp = CreateDefaultSubobject<UBlackboardComponent>(TEXT("BlackboardComp"));

	/* Match with the AI/ZombieBlackboard */
	PatrolLocationKeyName = "PatrolLocation";
	CurrentWaypointKeyName = "CurrentWaypoint";
	BotTypeKeyName = "BotType";
	TargetEnemyKeyName = "TargetEnemy";

	/* Initializes PlayerState so we can assign a team index to AI */
	bWantsPlayerState = true;
}


void ASZombieAIController::OnPossess(class APawn* InPawn)
{
	Super::OnPossess(InPawn);

	ASZombieCharacter* ZombieBot = Cast<ASZombieCharacter>(InPawn);
	if (ZombieBot)
	{
		if (ensure(ZombieBot->BehaviorTree->BlackboardAsset))
		{
			BlackboardComp->InitializeBlackboard(*ZombieBot->BehaviorTree->BlackboardAsset);
		}

		BehaviorComp->StartTree(*ZombieBot->BehaviorTree);

		/* Make sure the Blackboard has the type of bot we possessed */
		SetBlackboardBotType(ZombieBot->BotType);
	}
}


void ASZombieAIController::OnUnPossess()
{
	Super::OnUnPossess();

	/* Stop any behavior running as we no longer have a pawn to control */
	BehaviorComp->StopTree();
}


void ASZombieAIController::SetWaypoint(AActor* NewWaypoint)
{
	if (BlackboardComp)
	{
		BlackboardComp->SetValueAsObject(CurrentWaypointKeyName, NewWaypoint);
	}
}


void ASZombieAIController::SetTargetEnemy(APawn* NewTarget)
{
	if (BlackboardComp)
	{
		BlackboardComp->SetValueAsObject(TargetEnemyKeyName, NewTarget);
	}
}


AActor* ASZombieAIController::GetWaypoint() const
{
	if (BlackboardComp)
	{
		return Cast<AActor>(BlackboardComp->GetValueAsObject(CurrentWaypointKeyName));
	}

	return nullptr;
}


ASBaseCharacter* ASZombieAIController::GetTargetEnemy() const
{
	if (BlackboardComp)
	{
		return Cast<ASBaseCharacter>(BlackboardComp->GetValueAsObject(TargetEnemyKeyName));
	}

	return nullptr;
}


void ASZombieAIController::SetBlackboardBotType(EBotBehaviorType NewType)
{
	if (BlackboardComp)
	{
		BlackboardComp->SetValueAsEnum(BotTypeKeyName, (uint8)NewType);
	}
}

```

`SurvivalGame/Source/SurvivalGame/Private/AI/SZombieCharacter.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "AI/SZombieCharacter.h"
#include "AI/SZombieAIController.h"
#include "Player/SCharacter.h"
#include "Player/SBaseCharacter.h"
#include "AI/SBotWaypoint.h"
#include "Player/SPlayerState.h"
/* AI Include */
#include "Perception/PawnSensingComponent.h"
#include "GameFramework/Character.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/NavMovementComponent.h"
#include "Components/AudioComponent.h"
#include "SurvivalGame/SurvivalGame.h"
#include "GameFramework/PawnMovementComponent.h"
#include "Components/AudioComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Sound/SoundCue.h"


// Sets default values
ASZombieCharacter::ASZombieCharacter(const class FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)
{
	/* Note: We assign the Controller class in the Blueprint extension of this class 
		Because the zombie AIController is a blueprint in content and it's better to avoid content references in code.  */
	/*AIControllerClass = ASZombieAIController::StaticClass();*/

	/* Our sensing component to detect players by visibility and noise checks. */
	PawnSensingComp = CreateDefaultSubobject<UPawnSensingComponent>(TEXT("PawnSensingComp"));
	PawnSensingComp->SetPeripheralVisionAngle(60.0f);
	PawnSensingComp->SightRadius = 2000;
	PawnSensingComp->HearingThreshold = 600;
	PawnSensingComp->LOSHearingThreshold = 1200;

	/* Ignore this channel or it will absorb the trace impacts instead of the skeletal mesh */
	GetCapsuleComponent()->SetCollisionResponseToChannel(COLLISION_WEAPON, ECR_Ignore);
	GetCapsuleComponent()->SetCapsuleHalfHeight(96.0f, false);
	GetCapsuleComponent()->SetCapsuleRadius(42.0f);

	/* These values are matched up to the CapsuleComponent above and are used to find navigation paths */
	GetMovementComponent()->NavAgentProps.AgentRadius = 42;
	GetMovementComponent()->NavAgentProps.AgentHeight = 192;

	AudioLoopComp = CreateDefaultSubobject<UAudioComponent>(TEXT("ZombieLoopedSoundComp"));
	AudioLoopComp->bAutoActivate = false;
	AudioLoopComp->bAutoDestroy = false;
	AudioLoopComp->SetupAttachment(RootComponent);

	Health = 100;
	MeleeDamage = 24.0f;
	SprintingSpeedModifier = 3.0f;

	/* By default we will not let the AI patrol, we can override this value per-instance. */
	BotType = EBotBehaviorType::Passive;
	SenseTimeOut = 2.5f;

	/* Note: Visual Setup is done in the AI/ZombieCharacter Blueprint file */
}


void ASZombieCharacter::BeginPlay()
{
	Super::BeginPlay();

	/* This is the earliest moment we can bind our delegates to the component */
	if (PawnSensingComp)
	{
		PawnSensingComp->OnSeePawn.AddDynamic(this, &ASZombieCharacter::OnSeePlayer);
		PawnSensingComp->OnHearNoise.AddDynamic(this, &ASZombieCharacter::OnHearNoise);
	}

	BroadcastUpdateAudioLoop(bSensedTarget);

	/* Assign a basic name to identify the bots in the HUD. */
	ASPlayerState* PS = Cast<ASPlayerState>(GetPlayerState());
	if (PS)
	{
		PS->SetPlayerName("Bot");
		PS->SetIsABot(true);
	}
}


void ASZombieCharacter::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	/* Check if the last time we sensed a player is beyond the time out value to prevent bot from endlessly following a player. */
	if (bSensedTarget && (GetWorld()->TimeSeconds - LastSeenTime) > SenseTimeOut 
		&& (GetWorld()->TimeSeconds - LastHeardTime) > SenseTimeOut)
	{
		ASZombieAIController* AIController = Cast<ASZombieAIController>(GetController());
		if (AIController)
		{
			bSensedTarget = false;
			/* Reset */
			AIController->SetTargetEnemy(nullptr);

			/* Stop playing the hunting sound */
			BroadcastUpdateAudioLoop(false);
		}
	}
}


void ASZombieCharacter::OnSeePlayer(APawn* Pawn)
{
	if (!IsAlive())
	{
		return;
	}

	if (!bSensedTarget)
	{
		BroadcastUpdateAudioLoop(true);
	}

	/* Keep track of the time the player was last sensed in order to clear the target */
	LastSeenTime = GetWorld()->GetTimeSeconds();
	bSensedTarget = true;

	ASZombieAIController* AIController = Cast<ASZombieAIController>(GetController());
	ASBaseCharacter* SensedPawn = Cast<ASBaseCharacter>(Pawn);
	if (AIController && SensedPawn->IsAlive())
	{
		AIController->SetTargetEnemy(SensedPawn);
	}
}


void ASZombieCharacter::OnHearNoise(APawn* PawnInstigator, const FVector& Location, float Volume)
{
	if (!IsAlive())
	{
		return;
	}

	if (!bSensedTarget)
	{
		BroadcastUpdateAudioLoop(true);
	}

	bSensedTarget = true;
	LastHeardTime = GetWorld()->GetTimeSeconds();

	ASZombieAIController* AIController = Cast<ASZombieAIController>(GetController());
	if (AIController)
	{
		AIController->SetTargetEnemy(PawnInstigator);
	}
}


void ASZombieCharacter::PerformMeleeStrike(AActor* HitActor)
{
	if (HitActor && HitActor != this && IsAlive())
	{
		ACharacter* OtherPawn = Cast<ACharacter>(HitActor);
		if (OtherPawn)
		{
			ASPlayerState* MyPS = Cast<ASPlayerState>(GetPlayerState());
			ASPlayerState* OtherPS = Cast<ASPlayerState>(OtherPawn->GetPlayerState());

			if (MyPS && OtherPS)
			{
				if (MyPS->GetTeamNumber() == OtherPS->GetTeamNumber())
				{
					/* Do not attack other zombies. */
					return;
				}

				/* Set to prevent a zombie to attack multiple times in a very short time */
				LastMeleeAttackTime = GetWorld()->GetTimeSeconds();

				FPointDamageEvent DmgEvent;
				DmgEvent.DamageTypeClass = PunchDamageType;
				DmgEvent.Damage = MeleeDamage;

				HitActor->TakeDamage(DmgEvent.Damage, DmgEvent, GetController(), this);
			}
		}
	}
}


void ASZombieCharacter::SetBotType(EBotBehaviorType NewType)
{
	BotType = NewType;
	
	ASZombieAIController* AIController = Cast<ASZombieAIController>(GetController());
	if (AIController)
	{
		AIController->SetBlackboardBotType(NewType);
	}

	BroadcastUpdateAudioLoop(bSensedTarget);
}


UAudioComponent* ASZombieCharacter::PlayCharacterSound(USoundCue* CueToPlay)
{
	if (CueToPlay)
	{
		return UGameplayStatics::SpawnSoundAttached(CueToPlay, RootComponent, NAME_None, FVector::ZeroVector, EAttachLocation::SnapToTarget, true);
	}

	return nullptr;
}


void ASZombieCharacter::PlayHit(float DamageTaken, struct FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser, bool bKilled)
{
	Super::PlayHit(DamageTaken, DamageEvent, PawnInstigator, DamageCauser, bKilled);

	/* Stop playing the hunting sound */
	if (AudioLoopComp && bKilled)
	{
		AudioLoopComp->Stop();
	}
}


void ASZombieCharacter::SimulateMeleeStrike_Implementation()
{
	PlayAnimMontage(MeleeAnimMontage);
	PlayCharacterSound(SoundAttackMelee);
}


bool ASZombieCharacter::IsSprinting() const
{
	/* Allow a zombie to sprint when he has seen a player */
	return bSensedTarget && !GetVelocity().IsZero();
}


void ASZombieCharacter::BroadcastUpdateAudioLoop_Implementation(bool bNewSensedTarget)
{
	/* Start playing the hunting sound and the "noticed player" sound if the state is about to change */
	if (bNewSensedTarget && !bSensedTarget)
	{
		PlayCharacterSound(SoundPlayerNoticed);

		AudioLoopComp->SetSound(SoundHunting);
		AudioLoopComp->Play();
	}
	else
	{
		if (BotType == EBotBehaviorType::Patrolling)
		{
			AudioLoopComp->SetSound(SoundWandering);
			AudioLoopComp->Play();
		}
		else
		{
			AudioLoopComp->SetSound(SoundIdle);
			AudioLoopComp->Play();
		}
	}
}
```

`SurvivalGame/Source/SurvivalGame/Private/Components/SCarryObjectComponent.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Components/SCarryObjectComponent.h"


USCarryObjectComponent::USCarryObjectComponent()
{
	MaxPickupDistance = 600;
	RotateSpeed = 10.0f;

	bUsePawnControlRotation = true;
	bDoCollisionTest = false;

	SetIsReplicatedByDefault(true);
}


void USCarryObjectComponent::TickComponent(float DeltaSeconds, enum ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)
{
	if (APawn* OwningPawn = Cast<APawn>(GetOwner()))
	{
		if (OwningPawn->IsLocallyControlled())
		{
			Super::TickComponent(DeltaSeconds, TickType, ThisTickFunction);
		}
		else
		{
			/* NOTE: Slightly changed code from base implementation (USpringArmComponent) to use RemoteViewPitch instead of non-replicated ControlRotation */
			if (bUsePawnControlRotation)
			{
				{
					/* Re-map uint8 to 360 degrees */
					const float PawnViewPitch = (OwningPawn->RemoteViewPitch / 255.f)*360.f;
					if (PawnViewPitch != GetComponentRotation().Pitch)
					{
						FRotator NewRotation = GetComponentRotation();
						NewRotation.Pitch = PawnViewPitch;
						SetWorldRotation(NewRotation);
					}
				}
			}

			UpdateDesiredArmLocation(bDoCollisionTest, bEnableCameraLag, bEnableCameraRotationLag, DeltaSeconds);
		}
	}
}


void USCarryObjectComponent::Pickup()
{
	/* Drop if we are already carrying an Actor */
	if (GetIsCarryingActor())
	{
		Drop();
		return;
	} 

	if (!GetOwner()->HasAuthority())
	{
		ServerPickup();
		return;
	}

	AActor* FocusActor = GetActorInView();
	OnPickupMulticast(FocusActor);
}


void USCarryObjectComponent::Drop()
{
	if (!GetOwner()->HasAuthority())
	{
		ServerDrop();
	}

	OnDropMulticast();
}


AActor* USCarryObjectComponent::GetActorInView()
{
	APawn* PawnOwner = Cast<APawn>(GetOwner());
	AController* Controller = PawnOwner->Controller;
	if (Controller == nullptr)
	{
		return nullptr;
	}

	FVector CamLoc;
	FRotator CamRot;
	Controller->GetPlayerViewPoint(CamLoc, CamRot);

	const FVector TraceStart = CamLoc;
	const FVector Direction = CamRot.Vector();
	const FVector TraceEnd = TraceStart + (Direction * MaxPickupDistance);

	FCollisionQueryParams TraceParams(TEXT("TraceActor"), true, PawnOwner);
	TraceParams.bReturnPhysicalMaterial = false;
	TraceParams.bTraceComplex = false;

	FHitResult Hit(ForceInit);
	GetWorld()->LineTraceSingleByChannel(Hit, TraceStart, TraceEnd, ECC_Visibility, TraceParams);

	/* Check to see if we hit a staticmesh component that has physics simulation enabled */
	UStaticMeshComponent* MeshComp = Cast<UStaticMeshComponent>(Hit.GetComponent());
	if (MeshComp && MeshComp->IsSimulatingPhysics())
	{
		return Hit.GetActor();
	}

	return nullptr;
}


AActor* USCarryObjectComponent::GetCarriedActor()
{
	USceneComponent* ChildComp = GetChildComponent(0);
	if (ChildComp)
	{
		return ChildComp->GetOwner();
	}

	return nullptr;
}


UStaticMeshComponent* USCarryObjectComponent::GetCarriedMeshComp()
{
	USceneComponent* ChildComp = GetChildComponent(0);
	if (ChildComp)
	{
		AActor* OwningActor = ChildComp->GetOwner();
		if (OwningActor)
		{
			return Cast<UStaticMeshComponent>(OwningActor->GetComponentByClass(UStaticMeshComponent::StaticClass()));
		}
	}

	return nullptr;
}


void USCarryObjectComponent::Throw()
{
	if (!GetIsCarryingActor())
		return;

	if (!GetOwner()->HasAuthority())
	{
		ServerThrow();
		return;
	}

	/* Grab a reference to the MeshComp before dropping the object */
	UStaticMeshComponent* MeshComp = GetCarriedMeshComp();
	if (MeshComp)
	{
		/* Detach and re-enable collision */
		OnDropMulticast();

		APawn* OwningPawn = Cast<APawn>(GetOwner());
		if (OwningPawn)
		{
			/* Re-map uint8 to 360 degrees */
			const float PawnViewPitch = (OwningPawn->RemoteViewPitch / 255.f)*360.f;

			FRotator NewRotation = GetComponentRotation();
			NewRotation.Pitch = PawnViewPitch;

			/* Apply physics impulse, ignores mass */
			MeshComp->AddImpulse(NewRotation.Vector() * 1000, NAME_None, true);
		}
	}
}


bool USCarryObjectComponent::GetIsCarryingActor()
{
	return GetChildComponent(0) != nullptr;
}


void USCarryObjectComponent::Rotate(float DirectionYaw, float DirectionRoll)
{
	if (!GetOwner()->HasAuthority())
	{
		ServerRotate(DirectionYaw, DirectionRoll);
	}

	OnRotateMulticast(DirectionYaw, DirectionRoll);
}


void USCarryObjectComponent::RotateActorAroundPoint(AActor* RotateActor, FVector RotationPoint, FRotator AddRotation)
{
	FVector Loc = RotateActor->GetActorLocation() - RotationPoint;
	FVector RotatedLoc = AddRotation.RotateVector(Loc);

	FVector NewLoc = RotationPoint + RotatedLoc;
	
	/* Compose the rotators, use Quats to avoid gimbal lock */
	FQuat AQuat = FQuat(RotateActor->GetActorRotation());
	FQuat BQuat = FQuat(AddRotation);

	FRotator NewRot = FRotator(BQuat*AQuat);

	RotateActor->SetActorLocationAndRotation(NewLoc, NewRot);
}


void USCarryObjectComponent::OnPickupMulticast_Implementation(AActor* FocusActor)
{
	if (FocusActor && FocusActor->IsRootComponentMovable())
	{
		/* Find the static mesh (if any) to disable physics simulation while carried
		Filter by objects that are physically simulated and can therefor be picked up */
		UStaticMeshComponent* MeshComp = Cast<UStaticMeshComponent>(FocusActor->GetComponentByClass(UStaticMeshComponent::StaticClass()));
		if (MeshComp && MeshComp->IsSimulatingPhysics())
		{
			MeshComp->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
			MeshComp->SetSimulatePhysics(false);
		}

		FocusActor->AttachToComponent(this, FAttachmentTransformRules::KeepWorldTransform);
	}
}


void USCarryObjectComponent::OnDropMulticast_Implementation()
{
	AActor* CarriedActor = GetCarriedActor();
	if (CarriedActor)
	{
		/* Find the static mesh (if any) to re-enable physics simulation */
		UStaticMeshComponent* MeshComp = Cast<UStaticMeshComponent>(CarriedActor->GetComponentByClass(UStaticMeshComponent::StaticClass()));
		if (MeshComp)
		{
			MeshComp->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
			MeshComp->SetSimulatePhysics(true);
		}

		CarriedActor->GetRootComponent()->DetachFromComponent(FDetachmentTransformRules::KeepWorldTransform);
	}
}


void USCarryObjectComponent::OnRotateMulticast_Implementation(float DirectionYaw, float DirectionRoll)
{
	AActor* CarriedActor = GetCarriedActor();
	if (CarriedActor)
	{
		/* Retrieve the object center */
		FVector RootOrigin = GetCarriedActor()->GetRootComponent()->Bounds.Origin;
		FRotator DeltaRot = FRotator(0, DirectionYaw * RotateSpeed, DirectionRoll * RotateSpeed);

		RotateActorAroundPoint(CarriedActor, RootOrigin, DeltaRot);
	}
}


void USCarryObjectComponent::ServerDrop_Implementation()
{
	Drop();
}


bool USCarryObjectComponent::ServerDrop_Validate()
{
	return true;
}


void USCarryObjectComponent::ServerThrow_Implementation()
{
	Throw();
}


bool USCarryObjectComponent::ServerThrow_Validate()
{
	return true;
}


void USCarryObjectComponent::ServerPickup_Implementation()
{
	Pickup();
}


bool USCarryObjectComponent::ServerPickup_Validate()
{
	return true;
}


void USCarryObjectComponent::ServerRotate_Implementation(float DirectionYaw, float DirectionRoll)
{
	Rotate(DirectionYaw, DirectionRoll);
}


bool USCarryObjectComponent::ServerRotate_Validate(float DirectionYaw, float DirectionRoll)
{
	return true;
}
```

`SurvivalGame/Source/SurvivalGame/Private/Components/SCharacterMovementComponent.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Components/SCharacterMovementComponent.h"
#include "Player/SBaseCharacter.h"



float USCharacterMovementComponent::GetMaxSpeed() const
{
	float MaxSpeed = Super::GetMaxSpeed();

	const ASBaseCharacter* CharOwner = Cast<ASBaseCharacter>(PawnOwner);
	if (CharOwner)
	{
		// Slow down during targeting or crouching
		if (CharOwner->IsTargeting() && !IsCrouching())
		{
			MaxSpeed *= CharOwner->GetTargetingSpeedModifier();
		}
		else if (CharOwner->IsSprinting())
		{
			MaxSpeed *= CharOwner->GetSprintingSpeedModifier();
		}
	}

	return MaxSpeed;
}
```

`SurvivalGame/Source/SurvivalGame/Private/Core/SGameplayStatics.cpp`:

```cpp
// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.


#include "Core/SGameplayStatics.h"
#include "SceneView.h"
#include "Engine/LocalPlayer.h"





bool USGameplayStatics::ProjectWorldToScreenBidirectional(APlayerController const* Player, const FVector& WorldPosition, FVector2D& ScreenPosition, 
	bool& bTargetBehindCamera, bool bPlayerViewportRelative /*= false*/)
{
	bTargetBehindCamera = false;

	ULocalPlayer* const LP = Player ? Player->GetLocalPlayer() : nullptr;
	if (LP && LP->ViewportClient)
	{
		// get the projection data
		FSceneViewProjectionData ProjectionData;
		if (LP->GetProjectionData(LP->ViewportClient->Viewport, /*out*/ ProjectionData))
		{
			const FMatrix ViewProjectionMatrix = ProjectionData.ComputeViewProjectionMatrix();
			const FIntRect ViewRectangle = ProjectionData.GetConstrainedViewRect();

			FPlane Result = ViewProjectionMatrix.TransformFVector4(FVector4(WorldPosition, 1.f));
			if (Result.W < 0.f)
			{
				bTargetBehindCamera = true;
			}
			else if (Result.W == 0.f)
			{
				Result.W = 1.f; // Prevent Divide By Zero
			}

			const float RHW = 1.f / FMath::Abs(Result.W);
			FVector Projected = FVector(Result.X, Result.Y, Result.Z) * RHW;

			// Normalize to 0..1 UI Space
			const float NormX = (Projected.X / 2.f) + 0.5f;
			const float NormY = 1.f - (Projected.Y / 2.f) - 0.5f;

			Projected.X = (float)ViewRectangle.Min.X + (NormX * (float)ViewRectangle.Width());
			Projected.Y = (float)ViewRectangle.Min.Y + (NormY * (float)ViewRectangle.Height());

			ScreenPosition = FVector2D(Projected.X, Projected.Y);

			if (bPlayerViewportRelative)
			{
				ScreenPosition -= FVector2D(ProjectionData.GetConstrainedViewRect().Min);
			}

			return true;
		}
	}

	ScreenPosition = FVector2D::ZeroVector;
	return false;
}

```

`SurvivalGame/Source/SurvivalGame/Private/Editor/SoundNodeLocalPlayer.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Editor/SoundNodeLocalPlayer.h"
#include "SoundDefinitions.h"


void USoundNodeLocalPlayer::ParseNodes(FAudioDevice* AudioDevice, const UPTRINT NodeWaveInstanceHash, FActiveSound& ActiveSound, const FSoundParseParameters& ParseParams, TArray<FWaveInstance*>& WaveInstances)
{
	// The accesses to the Pawn will be unsafe once we thread audio, deal with this at that point
	check(IsInGameThread());

	AActor* SoundOwner = ActiveSound.GetAudioComponentID() ? UAudioComponent::GetAudioComponentFromID(ActiveSound.GetAudioComponentID())->GetOwner() : nullptr;
	APlayerController* PCOwner = Cast<APlayerController>(SoundOwner);
	APawn* PawnOwner = (PCOwner ? PCOwner->GetPawn() : Cast<APawn>(SoundOwner));

	const bool bLocallyControlled = PawnOwner && PawnOwner->IsLocallyControlled() && Cast<APlayerController>(PawnOwner->Controller);
	const int32 PlayIndex = bLocallyControlled ? 0 : 1;

	if (PlayIndex < ChildNodes.Num() && ChildNodes[PlayIndex])
	{
		ChildNodes[PlayIndex]->ParseNodes(AudioDevice, GetNodeWaveInstanceHash(NodeWaveInstanceHash, ChildNodes[PlayIndex], PlayIndex), ActiveSound, ParseParams, WaveInstances);
	}
}


void USoundNodeLocalPlayer::CreateStartingConnectors()
{
	InsertChildNode(ChildNodes.Num());
	InsertChildNode(ChildNodes.Num());
}


#if WITH_EDITOR
FText USoundNodeLocalPlayer::GetInputPinName(int32 PinIndex) const
{
	return (PinIndex == 0) ? NSLOCTEXT("Survival", "InputPinName", "Local") : NSLOCTEXT("Survival", "InputPinName", "Remote");
}
#endif


int32 USoundNodeLocalPlayer::GetMaxChildNodes() const
{
	return 2;
}


int32 USoundNodeLocalPlayer::GetMinChildNodes() const
{
	return 2;
}



```

`SurvivalGame/Source/SurvivalGame/Private/Items/SBombActor.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Items/SBombActor.h"
#include "TimerManager.h"
#include "Particles/ParticleSystemComponent.h"
#include "Components/AudioComponent.h"
#include "GameFramework/Actor.h"
#include "Kismet/GameplayStatics.h"
#include "Sound/SoundCue.h"


ASBombActor::ASBombActor()
{
	FuzePCS = CreateDefaultSubobject<UParticleSystemComponent>(TEXT("Fuze"));
	FuzePCS->bAutoActivate = false;
	FuzePCS->bAutoDestroy = false;
	FuzePCS->SetupAttachment(RootComponent);

	ExplosionPCS = CreateDefaultSubobject<UParticleSystemComponent>(TEXT("Explosion"));
	ExplosionPCS->bAutoActivate = false;
	ExplosionPCS->bAutoDestroy = false;
	ExplosionPCS->SetupAttachment(RootComponent);

	AudioComp = CreateDefaultSubobject<UAudioComponent>(TEXT("AudioComp"));
	AudioComp->bAutoActivate = false;
	AudioComp->bAutoDestroy = false;
	AudioComp->SetupAttachment(RootComponent);

	// Let the bomb be thrown and roll around
	MeshComp->SetSimulatePhysics(true);

	MaxFuzeTime = 3.0f;
	ExplosionDamage = 200;
	ExplosionRadius = 600;

	SetReplicates(true);
	SetReplicatingMovement(true);
}


void ASBombActor::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	// Ensure the fuze timer is cleared
	GetWorld()->GetTimerManager().ClearTimer(FuzeTimerHandle);

	// Alternatively you can clear ALL timers.
	/*GetWorld()->GetTimerManager().ClearAllTimersForObject(this);*/
}


void ASBombActor::OnUsed(APawn* InstigatorPawn)
{
	if (bIsFuzeActive)
	{
		return;
	}

	Super::OnUsed(InstigatorPawn);

	bIsFuzeActive = true;
	// Runs on all clients (NetMulticast)
	SimulateFuzeFX();

	// Activate the fuze to explode the bomb after several seconds
	GetWorldTimerManager().SetTimer(FuzeTimerHandle, this, &ASBombActor::Explode, MaxFuzeTime, false);

}


void ASBombActor::Explode()
{
	if (bExploded)
	{
		return;
	}

	bExploded = true;
	// Runs on all clients (NetMulticast)
	SimulateExplosion();

	// Apply damage to player, enemies and environmental objects
	TArray<AActor*> IgnoreActors;
	UGameplayStatics::ApplyRadialDamage(this, ExplosionDamage, GetActorLocation(), ExplosionRadius, DamageType, IgnoreActors, this, nullptr);

	//DrawDebugSphere(GetWorld(), GetActorLocation(), ExplosionRadius, 32, FColor::Red, false, 1.5f);

	/* Allow clients to show FX before deleting */
	SetLifeSpan(2.0f);
}


void ASBombActor::SimulateFuzeFX_Implementation()
{
	if (FuzeSound)
	{
		AudioComp->SetSound(FuzeSound);
		AudioComp->FadeIn(0.25f);
	}
	if (FuzeFX)
	{
		FuzePCS->SetTemplate(FuzeFX);
		FuzePCS->ActivateSystem();
	}
}


void ASBombActor::SimulateExplosion_Implementation()
{
	// First deactivate all running fuze effects
	FuzePCS->DeactivateSystem();
	AudioComp->Stop();

	MeshComp->SetVisibility(false, false);

	// Activate all explosion effects
	if (ExplosionSound)
	{
		AudioComp->SetSound(ExplosionSound);
		AudioComp->Play();
	}
	if (ExplosionFX)
	{
		ExplosionPCS->SetTemplate(ExplosionFX);
		ExplosionPCS->ActivateSystem();
	}

	// For Blueprint
	K2_SimulateExplosion();
}

float ASBombActor::TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
{
	Explode();

	return Super::TakeDamage(Damage, DamageEvent, EventInstigator, DamageCauser);
}

```

`SurvivalGame/Source/SurvivalGame/Private/Items/SConsumableActor.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Items/SConsumableActor.h"
#include "Player/SCharacter.h"


ASConsumableActor::ASConsumableActor()
{
	/* A default to tweak per food variation in Blueprint */
	Nutrition = 20;

	bAllowRespawn = true;
	RespawnDelay = 60.0f;
	RespawnDelayRange = 20.0f;
}


void ASConsumableActor::OnUsed(APawn* InstigatorPawn)
{
	ASCharacter* Pawn = Cast<ASCharacter>(InstigatorPawn);
	if (Pawn)
	{
		/* Restore some hitpoints and energy (hunger) */
		Pawn->RestoreCondition(Nutrition * 0.5f, Nutrition);
	}

	Super::OnUsed(InstigatorPawn);
}

```

`SurvivalGame/Source/SurvivalGame/Private/Items/SDamageType.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Items/SDamageType.h"



USDamageType::USDamageType()
{
	/* We apply this modifier based on the physics material setup to the head of the enemy PhysAsset */
	HeadDmgModifier = 2.0f;
	LimbDmgModifier = 0.5f;

	bCanDieFrom = true;
}


bool USDamageType::GetCanDieFrom() const
{
	return bCanDieFrom;
}


float USDamageType::GetHeadDamageModifier() const
{
	return HeadDmgModifier;
}

float USDamageType::GetLimbDamageModifier() const
{
	return LimbDmgModifier;
}

```

`SurvivalGame/Source/SurvivalGame/Private/Items/SFlashlight.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Items/SFlashlight.h"
#include "Components/StaticMeshComponent.h"
#include "Components/SpotLightComponent.h"
#include "Components/SkeletalMeshComponent.h"
#include "Net/UnrealNetwork.h"
#include "Materials/MaterialInstanceDynamic.h"



ASFlashlight::ASFlashlight()
{
	StorageSlot = EInventorySlot::Secondary;
	LightAttachPoint = TEXT("LightSocket");

	GetWeaponMesh()->AddLocalRotation(FRotator(0, 0, -90));

	LightConeComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("LightConeComp"));
	LightConeComp->SetCollisionResponseToAllChannels(ECR_Ignore);
	LightConeComp->SetupAttachment(GetWeaponMesh(), LightAttachPoint);

	SpotLightComp = CreateDefaultSubobject<USpotLightComponent>(TEXT("SpotLightComp"));
	SpotLightComp->SetupAttachment(GetWeaponMesh(), LightAttachPoint);
	/*SpotLightComp->SetCastShadows(false);*/
	SpotLightComp->AddLocalRotation(FRotator(0, -90, 0));

	bIsActive = true;
	LastEmissiveStrength = -1.0f;

	EmissiveParamName = TEXT("Brightness");
	MaxEmissiveIntensity = 5.0f;

	/* Doesn't consume "Ammo" */
	StartAmmo = 0;
}


void ASFlashlight::BeginPlay()
{
	Super::BeginPlay();

	/* Create an instance unique to this actor instance to manipulate emissive intensity */
	USkeletalMeshComponent* MeshComp = GetWeaponMesh();
	if (MeshComp)
	{
		MatDynamic = MeshComp->CreateAndSetMaterialInstanceDynamic(0);
	}
}


void ASFlashlight::HandleFiring()
{
	if (HasAuthority()) 
	{
		/* Toggle light,cone and material when Fired */
		bIsActive = !bIsActive;

		UpdateLight(bIsActive);
	}
}


void ASFlashlight::OnEnterInventory(ASCharacter* NewOwner)
{
	if (HasAuthority())
	{
		bIsActive = false;

		/* Turn off light while carried on belt  */
		UpdateLight(bIsActive);
	}

	Super::OnEnterInventory(NewOwner);
}



void ASFlashlight::OnEquipFinished()
{
	Super::OnEquipFinished();

	if (HasAuthority())
	{
		bIsActive = true;

		/* Turn off light while carried on belt  */
		UpdateLight(bIsActive);
	}
}


void ASFlashlight::OnUnEquip()
{
	Super::OnUnEquip();

	if (HasAuthority())
	{
		bIsActive = false;

		/* Turn off light while carried on belt  */
		UpdateLight(bIsActive);
	}
}


void ASFlashlight::UpdateLight(bool Enabled)
{
	/* Turn off light while  */
	SpotLightComp->SetVisibility(Enabled);
	LightConeComp->SetVisibility(Enabled);

	/* Update material parameter */
	if (MatDynamic)
	{		
		/* " Enabled ? MaxEmissiveIntensity : 0.0f " picks between first or second value based on "Enabled" boolean */
		MatDynamic->SetScalarParameterValue(EmissiveParamName, Enabled ? MaxEmissiveIntensity : 0.0f);	
	}
}


void ASFlashlight::OnRep_IsActive()
{
	UpdateLight(bIsActive);
}


void ASFlashlight::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ASFlashlight, bIsActive);
}
```

`SurvivalGame/Source/SurvivalGame/Private/Items/SImpactEffect.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Items/SImpactEffect.h"
#include "PhysicalMaterials/PhysicalMaterial.h"
#include "Kismet/GameplayStatics.h"
#include "Sound/SoundCue.h"
#include "Components/DecalComponent.h"
#include "SurvivalGame/SurvivalGame.h"



ASImpactEffect::ASImpactEffect()
{
	SetAutoDestroyWhenFinished(true);
	/* Can ever tick is required to trigger bAutoDestroyWhenFinished, which is checked in AActor::Tick */
	PrimaryActorTick.bCanEverTick = true;

	DecalLifeSpan = 10.0f;
	DecalSize = 16.0f;
}


void ASImpactEffect::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	/* Figure out what we hit (SurfaceHit is setting during actor instantiation in weapon class) */
	UPhysicalMaterial* HitPhysMat = SurfaceHit.PhysMaterial.Get();
	EPhysicalSurface HitSurfaceType = UPhysicalMaterial::DetermineSurfaceType(HitPhysMat);

	UParticleSystem* ImpactFX = GetImpactFX(HitSurfaceType);
	if (ImpactFX)
	{
		UGameplayStatics::SpawnEmitterAtLocation(this, ImpactFX, GetActorLocation(), GetActorRotation());
	}

	USoundCue* ImpactSound = GetImpactSound(HitSurfaceType);
	if (ImpactSound)
	{
		UGameplayStatics::PlaySoundAtLocation(this, ImpactSound, GetActorLocation());
	}

	if (DecalMaterial)
	{
		FVector ImpactNormal = SurfaceHit.ImpactNormal;
		ImpactNormal.Normalize();
		/* Inverse to point towards the wall. Invert to get the correct orientation of the decal (pointing into the surface instead of away, messing with the normals, and lighting) */
		ImpactNormal = -ImpactNormal;

		FRotator RandomDecalRotation = ImpactNormal.ToOrientationRotator();
		RandomDecalRotation.Roll = FMath::FRandRange(-180.0f, 180.0f);

		UDecalComponent* DecalComp = UGameplayStatics::SpawnDecalAttached(DecalMaterial, FVector(DecalSize, DecalSize, DecalSize),
			SurfaceHit.Component.Get(), SurfaceHit.BoneName,
			SurfaceHit.ImpactPoint, RandomDecalRotation, EAttachLocation::KeepWorldPosition,
			DecalLifeSpan);

		if (DecalComp)
		{
			DecalComp->SetFadeOut(DecalLifeSpan, 0.5f, false);
		}
	}
}


UParticleSystem* ASImpactEffect::GetImpactFX(EPhysicalSurface SurfaceType) const
{
	switch (SurfaceType)
	{
	case SURFACE_DEFAULT:
		return DefaultFX;
	case SURFACE_FLESH:
		return PlayerFleshFX;
	case SURFACE_ZOMBIEBODY:
	case SURFACE_ZOMBIEHEAD:
	case SURFACE_ZOMBIELIMB:
		return ZombieFleshFX;
	default:
		return nullptr;
	}
}


USoundCue* ASImpactEffect::GetImpactSound(EPhysicalSurface SurfaceType) const
{
	switch (SurfaceType)
	{
	case SURFACE_DEFAULT:
		return DefaultSound;
	case SURFACE_FLESH:
		return PlayerFleshSound;
	case SURFACE_ZOMBIEBODY:
	case SURFACE_ZOMBIEHEAD:
	case SURFACE_ZOMBIELIMB:
		return ZombieFleshSound;
	default:
		return nullptr;
	}
}

```

`SurvivalGame/Source/SurvivalGame/Private/Items/SPickupActor.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Items/SPickupActor.h"
#include "Components/StaticMeshComponent.h"
#include "Net/UnrealNetwork.h"
#include "Kismet/GameplayStatics.h"
#include "Engine/Engine.h"



ASPickupActor::ASPickupActor()
{
	/* Ignore Pawn - this is to prevent objects shooting through the level or pawns glitching on top of small items. */
	MeshComp->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore);

	bIsActive = false;
	bStartActive = true;
	bAllowRespawn = true;
	RespawnDelay = 5.0f;
	RespawnDelayRange = 5.0f;

	SetReplicates(true);
}


void ASPickupActor::BeginPlay()
{
	Super::BeginPlay();

	//if (bStartActive)
	{
		RespawnPickup();
	}
}


void ASPickupActor::OnUsed(APawn* InstigatorPawn)
{
	Super::OnUsed(InstigatorPawn);

	UGameplayStatics::PlaySoundAtLocation(this, PickupSound, GetActorLocation());

	bIsActive = false;
	OnPickedUp();

	if (bAllowRespawn)
	{
		FTimerHandle RespawnTimerHandle;
		GetWorld()->GetTimerManager().SetTimer(RespawnTimerHandle, this, &ASPickupActor::RespawnPickup, RespawnDelay + FMath::RandHelper(RespawnDelayRange), false);
	}
	else
	{
		/* Delete from level if respawn is not allowed */
		Destroy();
	}
}


void ASPickupActor::OnPickedUp()
{
	if (MeshComp)
	{
		MeshComp->SetVisibility(false);
		MeshComp->SetSimulatePhysics(false);
		MeshComp->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	}
}


void ASPickupActor::RespawnPickup()
{
	bIsActive = true;
	OnRespawned();
}


void ASPickupActor::OnRespawned()
{
	if (MeshComp)
	{
		MeshComp->SetVisibility(true);
		MeshComp->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
	}
}


void ASPickupActor::OnRep_IsActive()
{
	if (bIsActive)
	{
		OnRespawned();
	}
	else
	{
		OnPickedUp();
	}
}


void ASPickupActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty> & OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ASPickupActor, bIsActive);
}

```

`SurvivalGame/Source/SurvivalGame/Private/Items/SUsableActor.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Items/SUsableActor.h"
#include "Components/StaticMeshComponent.h"


ASUsableActor::ASUsableActor()
{
	MeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));
	RootComponent = MeshComp;
} 


void ASUsableActor::OnUsed(APawn* InstigatorPawn)
{
	// Nothing to do here...
}


void ASUsableActor::OnBeginFocus()
{
	// Used by custom PostProcess to render outlines
	MeshComp->SetRenderCustomDepth(true);
}


void ASUsableActor::OnEndFocus()
{
	// Used by custom PostProcess to render outlines
	MeshComp->SetRenderCustomDepth(false);
}


```

`SurvivalGame/Source/SurvivalGame/Private/Items/SWeapon.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Items/SWeapon.h"
#include "Player/SCharacter.h"
#include "SurvivalGame/STypes.h"
#include "Items/SWeaponPickup.h"
#include "Player/SPlayerController.h"
#include "Components/SkeletalMeshComponent.h"
#include "TimerManager.h"


ASWeapon::ASWeapon()
{
	Mesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("WeaponMesh3P"));
	Mesh->VisibilityBasedAnimTickOption = EVisibilityBasedAnimTickOption::OnlyTickPoseWhenRendered;
	Mesh->bReceivesDecals = true;
	Mesh->CastShadow = true;
	Mesh->SetCollisionObjectType(ECC_WorldDynamic);
	Mesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	Mesh->SetCollisionResponseToAllChannels(ECR_Ignore);
	Mesh->SetCollisionResponseToChannel(ECC_Visibility, ECR_Block);
	RootComponent = Mesh;

	bIsEquipped = false;
	CurrentState = EWeaponState::Idle;

	PrimaryActorTick.bCanEverTick = true;
	PrimaryActorTick.TickGroup = TG_PrePhysics;

	SetReplicates(true);
	bNetUseOwnerRelevancy = true;

	MuzzleAttachPoint = TEXT("MuzzleFlashSocket");
	StorageSlot = EInventorySlot::Primary;

	ShotsPerMinute = 700;
	StartAmmo = 999;
	MaxAmmo = 999;
	MaxAmmoPerClip = 30;
	NoAnimReloadDuration = 1.5f;
	NoEquipAnimDuration = 0.5f;
}


void ASWeapon::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	/* Setup configuration */
	TimeBetweenShots = 60.0f / ShotsPerMinute;
	CurrentAmmo = FMath::Min(StartAmmo, MaxAmmo);
	CurrentAmmoInClip = FMath::Min(MaxAmmoPerClip, StartAmmo);
}


void ASWeapon::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);

	DetachMeshFromPawn();
	StopSimulatingWeaponFire();
}


/*
	Return Mesh of Weapon
*/
USkeletalMeshComponent* ASWeapon::GetWeaponMesh() const
{
	return Mesh;
}


class ASCharacter* ASWeapon::GetPawnOwner() const
{
	return MyPawn;
}


void ASWeapon::SetOwningPawn(ASCharacter* NewOwner)
{
	if (MyPawn != NewOwner)
	{
		SetInstigator(NewOwner);
		MyPawn = NewOwner;
		// Net owner for RPC calls.
		SetOwner(NewOwner);
	}
}


void ASWeapon::OnRep_MyPawn()
{
	if (MyPawn)
	{
		OnEnterInventory(MyPawn);
	}
	else
	{
		OnLeaveInventory();

	}
}


void ASWeapon::AttachMeshToPawn(EInventorySlot Slot)
{
	if (MyPawn)
	{
		// Remove and hide
		DetachMeshFromPawn();

		USkeletalMeshComponent* PawnMesh = MyPawn->GetMesh();
		FName AttachPoint = MyPawn->GetInventoryAttachPoint(Slot);
		Mesh->SetHiddenInGame(false);
		Mesh->AttachToComponent(PawnMesh, FAttachmentTransformRules::SnapToTargetNotIncludingScale, AttachPoint);
	}
}


void ASWeapon::DetachMeshFromPawn()
{
	Mesh->DetachFromComponent(FDetachmentTransformRules::KeepWorldTransform);
	Mesh->SetHiddenInGame(true);
}


void ASWeapon::OnEquip(bool bPlayAnimation)
{
	bPendingEquip = true;
	DetermineWeaponState();

	if (bPlayAnimation)
	{
		float Duration = PlayWeaponAnimation(EquipAnim);
		if (Duration <= 0.0f)
		{
			// Failsafe in case animation is missing
			Duration = NoEquipAnimDuration;
		}
		EquipStartedTime = GetWorld()->TimeSeconds;
		EquipDuration = Duration;

		GetWorldTimerManager().SetTimer(EquipFinishedTimerHandle, this, &ASWeapon::OnEquipFinished, Duration, false);
	}
	else
	{
		/* Immediately finish equipping */
		OnEquipFinished();
	}

	if (MyPawn && MyPawn->IsLocallyControlled())
	{
		PlayWeaponSound(EquipSound);
	}
}


void ASWeapon::OnUnEquip()
{
	bIsEquipped = false;
	StopFire();

	if (bPendingEquip)
	{
		StopWeaponAnimation(EquipAnim);
		bPendingEquip = false;

		GetWorldTimerManager().ClearTimer(EquipFinishedTimerHandle);
	}
	if (bPendingReload)
	{
		StopWeaponAnimation(ReloadAnim);
		bPendingReload = false;

		GetWorldTimerManager().ClearTimer(TimerHandle_ReloadWeapon);
	}

	DetermineWeaponState();
}


void ASWeapon::OnEnterInventory(ASCharacter* NewOwner)
{
	SetOwningPawn(NewOwner);
	AttachMeshToPawn(StorageSlot);
}


void ASWeapon::OnLeaveInventory()
{
	if (HasAuthority())
	{
		SetOwningPawn(nullptr);
	}

	if (IsAttachedToPawn())
	{
		OnUnEquip();
	}

	DetachMeshFromPawn();
}


bool ASWeapon::IsEquipped() const
{
	return bIsEquipped;
}


bool ASWeapon::IsAttachedToPawn() const // TODO: Review name to more accurately specify meaning.
{
	return bIsEquipped || bPendingEquip;
}


void ASWeapon::StartFire()
{
	if (!HasAuthority())
	{
		ServerStartFire();
	}

	if (!bWantsToFire)
	{
		bWantsToFire = true;
		DetermineWeaponState();
	}
}


void ASWeapon::StopFire()
{
	if (!HasAuthority())
	{
		ServerStopFire();
	}

	if (bWantsToFire)
	{
		bWantsToFire = false;
		DetermineWeaponState();
	}
}


bool ASWeapon::ServerStartFire_Validate()
{
	return true;
}


void ASWeapon::ServerStartFire_Implementation()
{
	StartFire();
}


bool ASWeapon::ServerStopFire_Validate()
{
	return true;
}


void ASWeapon::ServerStopFire_Implementation()
{
	StopFire();
}


bool ASWeapon::CanFire() const
{
	bool bPawnCanFire = MyPawn && MyPawn->CanFire();
	bool bStateOK = CurrentState == EWeaponState::Idle || CurrentState == EWeaponState::Firing;
	return bPawnCanFire && bStateOK && !bPendingReload;
}


FVector ASWeapon::GetAdjustedAim() const
{
	APawn* MyInstigator = GetInstigator();

	ASPlayerController* const PC = MyInstigator ? Cast<ASPlayerController>(MyInstigator->Controller) : nullptr;
	FVector FinalAim = FVector::ZeroVector;

	if (PC)
	{
		FVector CamLoc;
		FRotator CamRot;
		PC->GetPlayerViewPoint(CamLoc, CamRot);

		FinalAim = CamRot.Vector();
	}
	else if (MyInstigator)
	{
		FinalAim = MyInstigator->GetBaseAimRotation().Vector();
	}

	return FinalAim;
}


FVector ASWeapon::GetCameraDamageStartLocation(const FVector& AimDir) const
{
	ASPlayerController* PC = MyPawn ? Cast<ASPlayerController>(MyPawn->Controller) : nullptr;
	FVector OutStartTrace = FVector::ZeroVector;

	if (PC)
	{
		FRotator DummyRot;
		PC->GetPlayerViewPoint(OutStartTrace, DummyRot);

		// Adjust trace so there is nothing blocking the ray between the camera and the pawn, and calculate distance from adjusted start
		OutStartTrace = OutStartTrace + AimDir * (FVector::DotProduct((GetInstigator()->GetActorLocation() - OutStartTrace), AimDir));
	}

	return OutStartTrace;
}


FHitResult ASWeapon::WeaponTrace(const FVector& TraceFrom, const FVector& TraceTo) const
{
	FCollisionQueryParams TraceParams(TEXT("WeaponTrace"), true, GetInstigator());
	TraceParams.bReturnPhysicalMaterial = true;

	FHitResult Hit(ForceInit);
	GetWorld()->LineTraceSingleByChannel(Hit, TraceFrom, TraceTo, COLLISION_WEAPON, TraceParams);

	return Hit;
}



void ASWeapon::HandleFiring()
{
	if (CurrentAmmoInClip > 0 && CanFire())
	{
		if (GetNetMode() != NM_DedicatedServer)
		{
			SimulateWeaponFire();
		}

		if (MyPawn && MyPawn->IsLocallyControlled())
		{
			FireWeapon();

			UseAmmo();

			// Update firing FX on remote clients if this is called on server
			BurstCounter++;
		}
	}
	else if (CanReload())
	{
		StartReload();
	}
	else if (MyPawn && MyPawn->IsLocallyControlled())
	{
		if (GetCurrentAmmo() == 0 && !bRefiring)
		{
			PlayWeaponSound(OutOfAmmoSound);
		}

		/* Reload after firing last round */
		if (CurrentAmmoInClip <= 0 && CanReload())
		{
			StartReload();
		}

		/* Stop weapon fire FX, but stay in firing state */
		if (BurstCounter > 0)
		{
			OnBurstFinished();
		}
	}

	if (MyPawn && MyPawn->IsLocallyControlled())
	{
		if (!HasAuthority())
		{
			ServerHandleFiring();
		}

		/* Retrigger HandleFiring on a delay for automatic weapons */
		bRefiring = (CurrentState == EWeaponState::Firing && TimeBetweenShots > 0.0f);
		if (bRefiring)
		{
			GetWorldTimerManager().SetTimer(TimerHandle_HandleFiring, this, &ASWeapon::HandleFiring, TimeBetweenShots, false);
		}
	}

	/* Make Noise on every shot. The data is managed by the PawnNoiseEmitterComponent created in SBaseCharacter and used by PawnSensingComponent in SZombieCharacter */
	if (MyPawn)
	{
		MyPawn->MakePawnNoise(1.0f);
	}

	LastFireTime = GetWorld()->GetTimeSeconds();
}


void ASWeapon::SimulateWeaponFire()
{
	if (MuzzleFX)
	{
		MuzzlePSC = UGameplayStatics::SpawnEmitterAttached(MuzzleFX, Mesh, MuzzleAttachPoint);	
	}

	if (!bPlayingFireAnim)
	{
		PlayWeaponAnimation(FireAnim);
		bPlayingFireAnim = true;
	}

	PlayWeaponSound(FireSound);
}


void ASWeapon::StopSimulatingWeaponFire()
{
	if (bPlayingFireAnim)
	{
		StopWeaponAnimation(FireAnim);
		bPlayingFireAnim = false;
	}
}



void ASWeapon::OnRep_BurstCounter()
{
	if (BurstCounter > 0)
	{
		SimulateWeaponFire();
	}
	else
	{
		StopSimulatingWeaponFire();
	}
}



bool ASWeapon::ServerHandleFiring_Validate()
{
	return true;
}


void ASWeapon::ServerHandleFiring_Implementation()
{
	const bool bShouldUpdateAmmo = (CurrentAmmoInClip > 0 && CanFire());

	HandleFiring();

	if (bShouldUpdateAmmo)
	{
		UseAmmo();

		// Update firing FX on remote clients
		BurstCounter++;
	}
}


void ASWeapon::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ASWeapon, MyPawn);

	DOREPLIFETIME_CONDITION(ASWeapon, CurrentAmmo, COND_OwnerOnly);
	DOREPLIFETIME_CONDITION(ASWeapon, CurrentAmmoInClip, COND_OwnerOnly);
	DOREPLIFETIME_CONDITION(ASWeapon, BurstCounter, COND_SkipOwner);
	DOREPLIFETIME_CONDITION(ASWeapon, bPendingReload, COND_SkipOwner);
}


FVector ASWeapon::GetMuzzleLocation() const
{
	return Mesh->GetSocketLocation(MuzzleAttachPoint);
}


FVector ASWeapon::GetMuzzleDirection() const
{
	return Mesh->GetSocketRotation(MuzzleAttachPoint).Vector();
}


UAudioComponent* ASWeapon::PlayWeaponSound(USoundCue* SoundToPlay)
{
	UAudioComponent* AC = nullptr;
	if (SoundToPlay && MyPawn)
	{
		AC = UGameplayStatics::SpawnSoundAttached(SoundToPlay, MyPawn->GetRootComponent());
	}

	return AC;
}


EWeaponState ASWeapon::GetCurrentState() const
{
	return CurrentState;
}


void ASWeapon::SetWeaponState(EWeaponState NewState)
{
	const EWeaponState PrevState = CurrentState;

	if (PrevState == EWeaponState::Firing && NewState != EWeaponState::Firing)
	{
		OnBurstFinished();
	}

	CurrentState = NewState;

	if (PrevState != EWeaponState::Firing && NewState == EWeaponState::Firing)
	{
		OnBurstStarted();
	}
}


void ASWeapon::OnBurstStarted()
{
	// Start firing, can be delayed to satisfy TimeBetweenShots
	const float GameTime = GetWorld()->GetTimeSeconds();
	if (LastFireTime > 0 && TimeBetweenShots > 0.0f &&
		LastFireTime + TimeBetweenShots > GameTime)
	{
		GetWorldTimerManager().SetTimer(TimerHandle_HandleFiring, this, &ASWeapon::HandleFiring, LastFireTime + TimeBetweenShots - GameTime, false);
	}
	else
	{
		HandleFiring();
	}
}


void ASWeapon::OnBurstFinished()
{
	BurstCounter = 0;

	if (GetNetMode() != NM_DedicatedServer)
	{
		StopSimulatingWeaponFire();
	}

	GetWorldTimerManager().ClearTimer(TimerHandle_HandleFiring);
	bRefiring = false;
}


void ASWeapon::DetermineWeaponState()
{
	EWeaponState NewState = EWeaponState::Idle;

	if (bIsEquipped)
	{
		if (bPendingReload)
		{
			if (CanReload())
			{
				NewState = EWeaponState::Reloading;
			}
			else
			{
				NewState = CurrentState;
			}
		}
		else if (!bPendingReload && bWantsToFire && CanFire())
		{
			NewState = EWeaponState::Firing;
		}
	}
	else if (bPendingEquip)
	{
		NewState = EWeaponState::Equipping;
	}

	SetWeaponState(NewState);
}


float ASWeapon::GetEquipStartedTime() const
{
	return EquipStartedTime;
}


float ASWeapon::GetEquipDuration() const
{
	return EquipDuration;
}


float ASWeapon::PlayWeaponAnimation(UAnimMontage* Animation, float InPlayRate, FName StartSectionName)
{
	float Duration = 0.0f;
	if (MyPawn)
	{
		if (Animation)
		{
			Duration = MyPawn->PlayAnimMontage(Animation, InPlayRate, StartSectionName);
		}
	}

	return Duration;
}


void ASWeapon::StopWeaponAnimation(UAnimMontage* Animation)
{
	if (MyPawn)
	{
		if (Animation)
		{
			MyPawn->StopAnimMontage(Animation);
		}
	}
}


void ASWeapon::OnEquipFinished()
{
	AttachMeshToPawn();

	bIsEquipped = true;
	bPendingEquip = false;

	DetermineWeaponState();

	if (MyPawn)
	{
		// Try to reload empty clip
		if (MyPawn->IsLocallyControlled() &&
			CurrentAmmoInClip <= 0 &&
			CanReload())
		{
			StartReload();
		}
	}
}



void ASWeapon::UseAmmo()
{
	CurrentAmmoInClip--;
	CurrentAmmo--;
}


int32 ASWeapon::GiveAmmo(int32 AddAmount)
{
	const int32 MissingAmmo = FMath::Max(0, MaxAmmo - CurrentAmmo);
	AddAmount = FMath::Min(AddAmount, MissingAmmo);
	CurrentAmmo += AddAmount;

	/* Push reload request to client */
	if (GetCurrentAmmoInClip() <= 0 && CanReload() &&
		MyPawn->GetCurrentWeapon() == this)
	{
		ClientStartReload();
	}

	/* Return the unused ammo when weapon is filled up */
	return FMath::Max(0, AddAmount - MissingAmmo);
}


void ASWeapon::SetAmmoCount(int32 NewTotalAmount)
{
	CurrentAmmo = FMath::Min(MaxAmmo, NewTotalAmount);
	CurrentAmmoInClip = FMath::Min(MaxAmmoPerClip, CurrentAmmo);
}


int32 ASWeapon::GetCurrentAmmo() const
{
	return CurrentAmmo;
}


int32 ASWeapon::GetCurrentAmmoInClip() const
{
	return CurrentAmmoInClip;
}


int32 ASWeapon::GetMaxAmmoPerClip() const
{
	return MaxAmmoPerClip;
}


int32 ASWeapon::GetMaxAmmo() const
{
	return MaxAmmo;
}


void ASWeapon::StartReload(bool bFromReplication)
{
	/* Push the request to server */
	if (!bFromReplication && !HasAuthority())
	{
		ServerStartReload();
	}

	/* If local execute requested or we are running on the server */
	if (bFromReplication || CanReload())
	{
		bPendingReload = true;
		DetermineWeaponState();

		float AnimDuration = PlayWeaponAnimation(ReloadAnim);
		if (AnimDuration <= 0.0f)
		{
			AnimDuration = NoAnimReloadDuration;
		}

		GetWorldTimerManager().SetTimer(TimerHandle_StopReload, this, &ASWeapon::StopSimulateReload, AnimDuration, false);
		if (HasAuthority())
		{
			GetWorldTimerManager().SetTimer(TimerHandle_ReloadWeapon, this, &ASWeapon::ReloadWeapon, FMath::Max(0.1f, AnimDuration - 0.1f), false);
		}

		if (MyPawn && MyPawn->IsLocallyControlled())
		{
			PlayWeaponSound(ReloadSound);
		}
	}
}


void ASWeapon::StopSimulateReload()
{
	if (CurrentState == EWeaponState::Reloading)
	{
		bPendingReload = false;
		DetermineWeaponState();
		StopWeaponAnimation(ReloadAnim);
	}
}


void ASWeapon::ReloadWeapon()
{
	int32 ClipDelta = FMath::Min(MaxAmmoPerClip - CurrentAmmoInClip, CurrentAmmo - CurrentAmmoInClip);

	if (ClipDelta > 0)
	{
		CurrentAmmoInClip += ClipDelta;
	}
}


bool ASWeapon::CanReload()
{
	bool bCanReload = (!MyPawn || MyPawn->CanReload());
	bool bGotAmmo = (CurrentAmmoInClip < MaxAmmoPerClip) && ((CurrentAmmo - CurrentAmmoInClip) > 0);
	bool bStateOKToReload = ((CurrentState == EWeaponState::Idle) || (CurrentState == EWeaponState::Firing));
	return (bCanReload && bGotAmmo && bStateOKToReload);
}


void ASWeapon::OnRep_Reload()
{
	if (bPendingReload)
	{
		/* By passing true we do not push back to server and execute it locally */
		StartReload(true);
	}
	else
	{
		StopSimulateReload();
	}
}


void ASWeapon::ServerStartReload_Implementation()
{
	StartReload();
}


bool ASWeapon::ServerStartReload_Validate()
{
	return true;
}


void ASWeapon::ServerStopReload_Implementation()
{
	StopSimulateReload();
}


bool ASWeapon::ServerStopReload_Validate()
{
	return true;
}


void ASWeapon::ClientStartReload_Implementation()
{
	StartReload();
}
```

`SurvivalGame/Source/SurvivalGame/Private/Items/SWeaponInstant.cpp`:

```cpp
// Fill out your copyright notice in the Description page of Project Settings.


#include "Items/SWeaponInstant.h"
#include "Items/SImpactEffect.h"
#include "Player/SPlayerController.h"
#include "Items/SDamageType.h"
#include "SurvivalGame/SurvivalGame.h"
#include "PhysicalMaterials/PhysicalMaterial.h"
#include "Net/UnrealNetwork.h"
#include "Particles/ParticleSystemComponent.h"
#include "Kismet/GameplayStatics.h"



ASWeaponInstant::ASWeaponInstant()
{
	HitDamage = 26;
	WeaponRange = 15000;

	AllowedViewDotHitDir = -1.0f;
	ClientSideHitLeeway = 200.0f;
	MinimumProjectileSpawnDistance = 800;
	TracerRoundInterval = 3;
}


void ASWeaponInstant::FireWeapon()
{	
	const FVector AimDir = GetAdjustedAim();
	const FVector CameraPos = GetCameraDamageStartLocation(AimDir);
	const FVector EndPos = CameraPos + (AimDir * WeaponRange);

	/* Check for impact by tracing from the camera position */
	FHitResult Impact = WeaponTrace(CameraPos, EndPos);

	const FVector MuzzleOrigin = GetMuzzleLocation();

	FVector AdjustedAimDir = AimDir;
	if (Impact.bBlockingHit)
	{
		/* Adjust the shoot direction to hit at the crosshair. */
		AdjustedAimDir = (Impact.ImpactPoint - MuzzleOrigin).GetSafeNormal();

		/* Re-trace with the new aim direction coming out of the weapon muzzle */
		Impact = WeaponTrace(MuzzleOrigin, MuzzleOrigin + (AdjustedAimDir * WeaponRange));
	}
	else
	{
		/* Use the maximum distance as the adjust direction */
		Impact.ImpactPoint = FVector_NetQuantize(EndPos);
	}

	ProcessInstantHit(Impact, MuzzleOrigin, AdjustedAimDir);
}


bool ASWeaponInstant::ShouldDealDamage(AActor* TestActor) const
{
	// If we are an actor on the server, or the local client has authoritative control over actor, we should register damage.
	if (TestActor)
	{
		if (GetNetMode() != NM_Client ||
			TestActor->HasAuthority() ||
			TestActor->GetTearOff())
		{
			return true;
		}
	}

	return false;
}


void ASWeaponInstant::DealDamage(const FHitResult& Impact, const FVector& ShootDir)
{
	float ActualHitDamage = HitDamage;

	/* Handle special damage location on the zombie body (types are setup in the Physics Asset of the zombie */
	USDamageType* DmgType = Cast<USDamageType>(DamageType->GetDefaultObject());
	UPhysicalMaterial * PhysMat = Impact.PhysMaterial.Get();
	if (PhysMat && DmgType)
	{
		if (PhysMat->SurfaceType == SURFACE_ZOMBIEHEAD)
		{		
			ActualHitDamage *= DmgType->GetHeadDamageModifier();	
		}
		else if (PhysMat->SurfaceType == SURFACE_ZOMBIELIMB)
		{
			ActualHitDamage *= DmgType->GetLimbDamageModifier();		
		}
	}

	FPointDamageEvent PointDmg;
	PointDmg.DamageTypeClass = DamageType;
	PointDmg.HitInfo = Impact;
	PointDmg.ShotDirection = ShootDir;
	PointDmg.Damage = ActualHitDamage;

	Impact.GetActor()->TakeDamage(PointDmg.Damage, PointDmg, MyPawn->Controller, this);
}


void ASWeaponInstant::ProcessInstantHit(const FHitResult& Impact, const FVector& Origin, const FVector& ShootDir)
{
	if (MyPawn && MyPawn->IsLocallyControlled() && GetNetMode() == NM_Client)
	{
		// If we are a client and hit something that is controlled by server
		if (Impact.GetActor() && Impact.GetActor()->GetRemoteRole() == ROLE_Authority)
		{
			// Notify the server of our local hit to validate and apply actual hit damage.
			ServerNotifyHit(Impact, ShootDir);
		}
		else if (Impact.GetActor() == nullptr)
		{
			if (Impact.bBlockingHit)
			{
				ServerNotifyHit(Impact, ShootDir);
			}
			else
			{
				ServerNotifyMiss(ShootDir);
			}
		}
	}

	// Process a confirmed hit.
	ProcessInstantHitConfirmed(Impact, Origin, ShootDir);
}


void ASWeaponInstant::ProcessInstantHitConfirmed(const FHitResult& Impact, const FVector& Origin, const FVector& ShootDir)
{
	// Handle damage
	if (ShouldDealDamage(Impact.GetActor()))
	{
		DealDamage(Impact, ShootDir);
	}

	// Play FX on remote clients
	if (HasAuthority())
	{
		HitImpactNotify = Impact.ImpactPoint;
	}

	// Play FX locally
	if (GetNetMode() != NM_DedicatedServer)
	{
		SimulateInstantHit(Impact.ImpactPoint);
	}
}


void ASWeaponInstant::SimulateInstantHit(const FVector& ImpactPoint)
{
	const FVector MuzzleOrigin = GetMuzzleLocation();

	/* Adjust direction based on desired crosshair impact point and muzzle location */
	const FVector AimDir = (ImpactPoint - MuzzleOrigin).GetSafeNormal();
	
	const FVector EndTrace = MuzzleOrigin + (AimDir * WeaponRange);
 	const FHitResult Impact = WeaponTrace(MuzzleOrigin, EndTrace);

	if (Impact.bBlockingHit)
	{
		SpawnImpactEffects(Impact);
		SpawnTrailEffects(Impact.ImpactPoint);
	}
	else
	{
		SpawnTrailEffects(EndTrace);
	}
}


bool ASWeaponInstant::ServerNotifyHit_Validate(const FHitResult Impact, FVector_NetQuantizeNormal ShootDir)
{
	return true;
}


void ASWeaponInstant::ServerNotifyHit_Implementation(const FHitResult Impact, FVector_NetQuantizeNormal ShootDir)
{
	// If we have an instigator, calculate the dot between the view and the shot
	if (GetInstigator() && (Impact.GetActor() || Impact.bBlockingHit))
	{
		const FVector Origin = GetMuzzleLocation();
		const FVector ViewDir = (Impact.Location - Origin).GetSafeNormal();

		const float ViewDotHitDir = FVector::DotProduct(GetInstigator()->GetViewRotation().Vector(), ViewDir);
		if (ViewDotHitDir > AllowedViewDotHitDir)
		{
			// TODO: Check for weapon state

			if (Impact.GetActor() == nullptr)
			{
				if (Impact.bBlockingHit)
				{
					ProcessInstantHitConfirmed(Impact, Origin, ShootDir);
				}
			}
			// Assume it told the truth about static things because we don't move and the hit
			// usually doesn't have significant gameplay implications
			else if (Impact.GetActor()->IsRootComponentStatic() || Impact.GetActor()->IsRootComponentStationary())
			{
				ProcessInstantHitConfirmed(Impact, Origin, ShootDir);
			}
			else
			{
				const FBox HitBox = Impact.GetActor()->GetComponentsBoundingBox();

				FVector BoxExtent = 0.5 * (HitBox.Max - HitBox.Min);
				BoxExtent *= ClientSideHitLeeway;

				BoxExtent.X = FMath::Max(20.0f, BoxExtent.X);
				BoxExtent.Y = FMath::Max(20.0f, BoxExtent.Y);
				BoxExtent.Z = FMath::Max(20.0f, BoxExtent.Z);

				const FVector BoxCenter = (HitBox.Min + HitBox.Max) * 0.5;

				// If we are within client tolerance
				if (FMath::Abs(Impact.Location.Z - BoxCenter.Z) < BoxExtent.Z &&
					FMath::Abs(Impact.Location.X - BoxCenter.X) < BoxExtent.X &&
					FMath::Abs(Impact.Location.Y - BoxCenter.Y) < BoxExtent.Y)
				{
					ProcessInstantHitConfirmed(Impact, Origin, ShootDir);
				}
			}
		}
	}

	// TODO: UE_LOG on failures & rejection
}


bool ASWeaponInstant::ServerNotifyMiss_Validate(FVector_NetQuantizeNormal ShootDir)
{
	return true;
}


void ASWeaponInstant::ServerNotifyMiss_Implementation(FVector_NetQuantizeNormal ShootDir)
{
	const FVector Origin = GetMuzzleLocation();
	const FVector EndTrace = Origin + (ShootDir * WeaponRange);

	// Play on remote clients
	HitImpactNotify = EndTrace;

	if (GetNetMode() != NM_DedicatedServer)
	{
		SpawnTrailEffects(EndTrace);
	}
}


void ASWeaponInstant::SpawnImpactEffects(const FHitResult& Impact)
{
	if (ImpactTemplate && Impact.bBlockingHit)
	{
		// TODO: Possible re-trace to get hit component that is lost during replication.

		/* This function prepares an actor to spawn, but requires another call to finish the actual spawn progress. This allows manipulation of properties before entering into the level */
		ASImpactEffect* EffectActor = GetWorld()->SpawnActorDeferred<ASImpactEffect>(ImpactTemplate, FTransform(Impact.ImpactPoint.Rotation(), Impact.ImpactPoint));
		if (EffectActor)
		{
			EffectActor->SurfaceHit = Impact;
			UGameplayStatics::FinishSpawningActor(EffectActor, FTransform(Impact.ImpactNormal.Rotation(), Impact.ImpactPoint));
		}
	}
}


void ASWeaponInstant::SpawnTrailEffects(const FVector& EndPoint)
{
	// Keep local count for effects
	BulletsShotCount++;

	const FVector Origin = GetMuzzleLocation();
	FVector ShootDir = EndPoint - Origin;

	// Only spawn if a minimum distance is satisfied.
	if (ShootDir.Size() < MinimumProjectileSpawnDistance)
	{
		return;
	}

	if (BulletsShotCount % TracerRoundInterval == 0)
	{
		if (TracerFX)
		{
			ShootDir.Normalize();
			UGameplayStatics::SpawnEmitterAtLocation(this, TracerFX, Origin, ShootDir.Rotation());
		}
	}
	else 
	{
		// Only create trails FX by other players.
		ASCharacter* OwningPawn = GetPawnOwner();
		if (OwningPawn && OwningPawn->IsLocallyControlled())
		{
			return;
		}

		if (TrailFX)
		{
			UParticleSystemComponent* TrailPSC = UGameplayStatics::SpawnEmitterAtLocation(this, TrailFX, Origin);
			if (TrailPSC)
			{
				TrailPSC->SetVectorParameter(TrailTargetParam, EndPoint);
			}
		}
	}
}


void ASWeaponInstant::OnRep_HitLocation()
{
	// Played on all remote clients
	SimulateInstantHit(HitImpactNotify);
}


void ASWeaponInstant::GetLifetimeReplicatedProps(TArray< FLifetimeProperty > & OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME_CONDITION(ASWeaponInstant, HitImpactNotify, COND_SkipOwner);
}
```

`SurvivalGame/Source/SurvivalGame/Private/Items/SWeaponPickup.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Items/SWeaponPickup.h"
#include "Player/SCharacter.h"
#include "Items/SWeapon.h"
#include "Player/SPlayerController.h"


ASWeaponPickup::ASWeaponPickup()
{
	bAllowRespawn = false;

	/* Enabled to support simulated physics movement when weapons are dropped by a player */
	SetReplicateMovement(true);
}


void ASWeaponPickup::OnUsed(APawn* InstigatorPawn)
{
	ASCharacter* MyPawn = Cast<ASCharacter>(InstigatorPawn);
	if (MyPawn)
	{
		/* Fetch the default variables of the class we are about to pick up and check if the storage slot is available on the pawn. */
		if (MyPawn->WeaponSlotAvailable(WeaponClass->GetDefaultObject<ASWeapon>()->GetStorageSlot()))
		{
			FActorSpawnParameters SpawnInfo;
			SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
			ASWeapon* NewWeapon = GetWorld()->SpawnActor<ASWeapon>(WeaponClass, SpawnInfo);

			MyPawn->AddWeapon(NewWeapon);

			Super::OnUsed(InstigatorPawn);
		}
		else
		{
			ASPlayerController* PC = Cast<ASPlayerController>(MyPawn->GetController());
			if (PC)
			{
				PC->ClientHUDMessage(EHUDMessage::Weapon_SlotTaken);
			}
		}
	}
}



```

`SurvivalGame/Source/SurvivalGame/Private/Mutators/SMutator.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Mutators/SMutator.h"





bool ASMutator::CheckRelevance_Implementation(AActor* Other)
{
	if (NextMutator)
	{
		return NextMutator->CheckRelevance(Other);
	}

	return true;
}


void ASMutator::InitGame_Implementation(const FString& MapName, const FString& Options, FString& ErrorMessage)
{
	if (NextMutator)
	{
		NextMutator->InitGame(MapName, Options, ErrorMessage);
	}
}

```

`SurvivalGame/Source/SurvivalGame/Private/Mutators/SMutator_WeaponReplacement.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#include "Mutators/SMutator_WeaponReplacement.h"
#include "World/SGameMode.h"
#include "Items/SWeaponPickup.h"



bool ASMutator_WeaponReplacement::CheckRelevance_Implementation(AActor* Other)
{
	ASWeaponPickup* WeaponPickup = Cast<ASWeaponPickup>(Other);
	if (WeaponPickup)
	{
		for (int32 i = 0; i < WeaponsToReplace.Num(); i++)
		{
			const FReplacementInfo& Info = WeaponsToReplace[i];

			if (Info.FromWeapon == WeaponPickup->WeaponClass)
			{
				WeaponPickup->WeaponClass = Info.ToWeapon;
			}
		}
	}

	/* Always call Super so we can run the entire chain of linked Mutators. */
	return Super::CheckRelevance_Implementation(Other);
}


void ASMutator_WeaponReplacement::InitGame_Implementation(const FString& MapName, const FString& Options, FString& ErrorMessage)
{
	/* Update default inventory weapons for current gamemode. */
	ASGameMode* GameMode = Cast<ASGameMode>(GetWorld()->GetAuthGameMode());
	if (GameMode != nullptr)
	{
		for (int32 i = 0; i < GameMode->DefaultInventoryClasses.Num(); i++)
		{
			for (int32 j = 0; j < WeaponsToReplace.Num(); j++)
			{
				FReplacementInfo Info = WeaponsToReplace[j];
				if (GameMode->DefaultInventoryClasses[i] == Info.FromWeapon)
				{
					GameMode->DefaultInventoryClasses[i] = Info.ToWeapon;
				}
			}
		}
	}

	Super::InitGame_Implementation(MapName, Options, ErrorMessage);
}

```

`SurvivalGame/Source/SurvivalGame/Private/Player/SBaseCharacter.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Player/SBaseCharacter.h"
#include "World/SGameMode.h"
#include "Components/SCharacterMovementComponent.h"
#include "Items/SDamageType.h"
#include "GameFramework/Character.h"
#include "Components/SkeletalMeshComponent.h"
#include "Components/CapsuleComponent.h"
#include "Net/UnrealNetwork.h"
#include "Components/PawnNoiseEmitterComponent.h"
#include "Engine/DamageEvents.h"
#include "Kismet/GameplayStatics.h"
#include "Sound/SoundCue.h"


ASBaseCharacter::ASBaseCharacter(const class FObjectInitializer& ObjectInitializer)
	/* Override the movement class from the base class to our own to support multiple speeds (eg. sprinting) */
	: Super(ObjectInitializer.SetDefaultSubobjectClass<USCharacterMovementComponent>(ACharacter::CharacterMovementComponentName))
{
	Health = 100;

	TargetingSpeedModifier = 0.5f;
	SprintingSpeedModifier = 2.0f;

	/* Noise emitter for both players and enemies. This keeps track of MakeNoise data and is used by the pawnsensing component in our SZombieCharacter class */
	NoiseEmitterComp = CreateDefaultSubobject<UPawnNoiseEmitterComponent>(TEXT("NoiseEmitterComp"));

	/* Don't collide with camera checks to keep 3rd person camera at position when zombies or other players are standing behind us */
	GetMesh()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
	GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Camera, ECR_Ignore);
}


float ASBaseCharacter::GetHealth() const
{
	return Health;
}


float ASBaseCharacter::GetMaxHealth() const
{
	// Retrieve the default value of the health property that is assigned on instantiation.
	return GetClass()->GetDefaultObject<ASBaseCharacter>()->Health;
}


bool ASBaseCharacter::IsAlive() const
{
	return Health > 0;
}



float ASBaseCharacter::TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
{
	if (Health <= 0.f)
	{
		return 0.f;
	}

	/* Modify based based on gametype rules */
	ASGameMode* MyGameMode = Cast<ASGameMode>(GetWorld()->GetAuthGameMode());
	Damage = MyGameMode ? MyGameMode->ModifyDamage(Damage, this, DamageEvent, EventInstigator, DamageCauser) : Damage;

	const float ActualDamage = Super::TakeDamage(Damage, DamageEvent, EventInstigator, DamageCauser);
	if (ActualDamage > 0.f)
	{
		Health -= ActualDamage;
		if (Health <= 0)
		{
			bool bCanDie = true;

			/* Check the damagetype, always allow dying if the cast fails, otherwise check the property if player can die from damagetype */
			if (DamageEvent.DamageTypeClass)
			{
				USDamageType* DmgType = Cast<USDamageType>(DamageEvent.DamageTypeClass->GetDefaultObject());
				bCanDie = (DmgType == nullptr || (DmgType && DmgType->GetCanDieFrom()));
			}

			if (bCanDie)
			{
				Die(ActualDamage, DamageEvent, EventInstigator, DamageCauser);
			}
			else
			{
				/* Player cannot die from this damage type, set hitpoints to 1.0 */
				Health = 1.0f;
			}
		}
		else
		{
			/* Shorthand for - if x != null pick1 else pick2 */
			APawn* Pawn = EventInstigator ? EventInstigator->GetPawn() : nullptr;
			PlayHit(ActualDamage, DamageEvent, Pawn, DamageCauser, false);
		}
	}

	return ActualDamage;
}


bool ASBaseCharacter::CanDie(float KillingDamage, FDamageEvent const& DamageEvent, AController* Killer, AActor* DamageCauser) const
{
	/* Check if character is already dying, destroyed or if we have authority */
	if (bIsDying || !IsValid(this) || !HasAuthority() || GetWorld()->GetAuthGameMode() == nullptr)
	{
		return false;
	}

	return true;
}


void ASBaseCharacter::FellOutOfWorld(const class UDamageType& DmgType)
{
	Die(Health, FDamageEvent(DmgType.GetClass()), nullptr, nullptr);
}


bool ASBaseCharacter::Die(float KillingDamage, FDamageEvent const& DamageEvent, AController* Killer, AActor* DamageCauser)
{
	if (!CanDie(KillingDamage, DamageEvent, Killer, DamageCauser))
	{
		return false;
	}

	Health = FMath::Min(0.0f, Health);

	/* Fallback to default DamageType if none is specified */
	UDamageType const* const DamageType = DamageEvent.DamageTypeClass ? DamageEvent.DamageTypeClass->GetDefaultObject<UDamageType>() : GetDefault<UDamageType>();
	Killer = GetDamageInstigator(Killer, *DamageType);

	/* Notify the gamemode we got killed for scoring and game over state */
	AController* KilledPlayer = Controller ? Controller : Cast<AController>(GetOwner());
	GetWorld()->GetAuthGameMode<ASGameMode>()->Killed(Killer, KilledPlayer, this, DamageType);

	OnDeath(KillingDamage, DamageEvent, Killer ? Killer->GetPawn() : NULL, DamageCauser);
	return true;
}


void ASBaseCharacter::OnDeath(float KillingDamage, FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser)
{
	if (bIsDying)
	{
		return;
	}

	SetReplicateMovement(true);
	TearOff();
	bIsDying = true;

	PlayHit(KillingDamage, DamageEvent, PawnInstigator, DamageCauser, true);

	DetachFromControllerPendingDestroy();

	/* Disable all collision on capsule */
	UCapsuleComponent* CapsuleComp = GetCapsuleComponent();
	CapsuleComp->SetCollisionEnabled(ECollisionEnabled::NoCollision);
	CapsuleComp->SetCollisionResponseToAllChannels(ECR_Ignore);

	USkeletalMeshComponent* Mesh3P = GetMesh();
	if (Mesh3P)
	{
		Mesh3P->SetCollisionProfileName(TEXT("Ragdoll"));
	}
	SetActorEnableCollision(true);

	SetRagdollPhysics();

	/* Apply physics impulse on the bone of the enemy skeleton mesh we hit (ray-trace damage only) */
	if (DamageEvent.IsOfType(FPointDamageEvent::ClassID))
	{
		FPointDamageEvent PointDmg = *((FPointDamageEvent*)(&DamageEvent));
		{
			// TODO: Use DamageTypeClass->DamageImpulse
			Mesh3P->AddImpulseAtLocation(PointDmg.ShotDirection * 12000, PointDmg.HitInfo.ImpactPoint, PointDmg.HitInfo.BoneName);
		}
	}
	if (DamageEvent.IsOfType(FRadialDamageEvent::ClassID))
	{
		FRadialDamageEvent RadialDmg = *((FRadialDamageEvent const*)(&DamageEvent));
		{
			Mesh3P->AddRadialImpulse(RadialDmg.Origin, RadialDmg.Params.GetMaxRadius(), 100000 /*RadialDmg.DamageTypeClass->DamageImpulse*/, ERadialImpulseFalloff::RIF_Linear);
		}
	}
}


void ASBaseCharacter::SetRagdollPhysics()
{
	bool bInRagdoll;
	USkeletalMeshComponent* Mesh3P = GetMesh();

	if (!IsValid(this))
	{
		bInRagdoll = false;
	}
	else if (!Mesh3P || !Mesh3P->GetPhysicsAsset())
	{
		bInRagdoll = false;
	}
	else
	{
		Mesh3P->SetAllBodiesSimulatePhysics(true);
		Mesh3P->SetSimulatePhysics(true);
		Mesh3P->WakeAllRigidBodies();
		Mesh3P->bBlendPhysics = true;

		bInRagdoll = true;
	}

	UCharacterMovementComponent* CharacterComp = Cast<UCharacterMovementComponent>(GetMovementComponent());
	if (CharacterComp)
	{
		CharacterComp->StopMovementImmediately();
		CharacterComp->DisableMovement();
		CharacterComp->SetComponentTickEnabled(false);
	}

	if (!bInRagdoll)
	{
		// Immediately hide the pawn
		TurnOff();
		SetActorHiddenInGame(true);
		SetLifeSpan(1.0f);
	}
	else
	{
		SetLifeSpan(10.0f);
	}
}


void ASBaseCharacter::PlayHit(float DamageTaken, struct FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser, bool bKilled)
{
	if (HasAuthority())
	{
		ReplicateHit(DamageTaken, DamageEvent, PawnInstigator, DamageCauser, bKilled);
	}

	if (GetNetMode() != NM_DedicatedServer)
	{
		if (bKilled && SoundDeath)
		{
			UGameplayStatics::SpawnSoundAttached(SoundDeath, RootComponent, NAME_None, FVector::ZeroVector, EAttachLocation::SnapToTarget, true);
		}
		else if (SoundTakeHit)
		{
			UGameplayStatics::SpawnSoundAttached(SoundTakeHit, RootComponent, NAME_None, FVector::ZeroVector, EAttachLocation::SnapToTarget, true);
		}
	}
}


void ASBaseCharacter::ReplicateHit(float DamageTaken, struct FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser, bool bKilled)
{
	const float TimeoutTime = GetWorld()->GetTimeSeconds() + 0.5f;

	FDamageEvent const& LastDamageEvent = LastTakeHitInfo.GetDamageEvent();
	if (PawnInstigator == LastTakeHitInfo.PawnInstigator.Get() && LastDamageEvent.DamageTypeClass == LastTakeHitInfo.DamageTypeClass)
	{
		// Same frame damage
		if (bKilled && LastTakeHitInfo.bKilled)
		{
			// Redundant death take hit, ignore it
			return;
		}

		DamageTaken += LastTakeHitInfo.ActualDamage;
	}

	LastTakeHitInfo.ActualDamage = DamageTaken;
	LastTakeHitInfo.PawnInstigator = Cast<ASBaseCharacter>(PawnInstigator);
	LastTakeHitInfo.DamageCauser = DamageCauser;
	LastTakeHitInfo.SetDamageEvent(DamageEvent);
	LastTakeHitInfo.bKilled = bKilled;
	LastTakeHitInfo.EnsureReplication();
}


void ASBaseCharacter::OnRep_LastTakeHitInfo()
{
	if (LastTakeHitInfo.bKilled)
	{
		OnDeath(LastTakeHitInfo.ActualDamage, LastTakeHitInfo.GetDamageEvent(), LastTakeHitInfo.PawnInstigator.Get(), LastTakeHitInfo.DamageCauser.Get());
	}
	else
	{
		PlayHit(LastTakeHitInfo.ActualDamage, LastTakeHitInfo.GetDamageEvent(), LastTakeHitInfo.PawnInstigator.Get(), LastTakeHitInfo.DamageCauser.Get(), LastTakeHitInfo.bKilled);
	}
}


void ASBaseCharacter::SetSprinting(bool NewSprinting)
{
	bWantsToRun = NewSprinting;

	if (bIsCrouched)
	{
		UnCrouch();
	}

	if (!HasAuthority())
	{
		ServerSetSprinting(NewSprinting);
	}
}


void ASBaseCharacter::ServerSetSprinting_Implementation(bool NewSprinting)
{
	SetSprinting(NewSprinting);
}


bool ASBaseCharacter::ServerSetSprinting_Validate(bool NewSprinting)
{
	return true;
}


bool ASBaseCharacter::IsSprinting() const
{
	if (!GetCharacterMovement())
	{
		return false;
	}

	return bWantsToRun && !IsTargeting() && !GetVelocity().IsZero()
		// Don't allow sprint while strafing sideways or standing still (1.0 is straight forward, -1.0 is backward while near 0 is sideways or standing still)
		&& (FVector::DotProduct(GetVelocity().GetSafeNormal2D(), GetActorRotation().Vector()) > 0.8); // Changing this value to 0.1 allows for diagonal sprinting. (holding W+A or W+D keys)
}


float ASBaseCharacter::GetSprintingSpeedModifier() const
{
	return SprintingSpeedModifier;
}



void ASBaseCharacter::SetTargeting(bool NewTargeting)
{
	bIsTargeting = NewTargeting;

	if (!HasAuthority())
	{
		ServerSetTargeting(NewTargeting);
	}
}


void ASBaseCharacter::ServerSetTargeting_Implementation(bool NewTargeting)
{
	SetTargeting(NewTargeting);
}


bool ASBaseCharacter::ServerSetTargeting_Validate(bool NewTargeting)
{
	return true;
}



bool ASBaseCharacter::IsTargeting() const
{
	return bIsTargeting;
}


float ASBaseCharacter::GetTargetingSpeedModifier() const
{
	return TargetingSpeedModifier;
}


FRotator ASBaseCharacter::GetAimOffsets() const
{
	const FVector AimDirWS = GetBaseAimRotation().Vector();
	const FVector AimDirLS = ActorToWorld().InverseTransformVectorNoScale(AimDirWS);
	const FRotator AimRotLS = AimDirLS.Rotation();

	return AimRotLS;
}

void ASBaseCharacter::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	// Value is already updated locally, skip in replication step
	DOREPLIFETIME_CONDITION(ASBaseCharacter, bWantsToRun, COND_SkipOwner);
	DOREPLIFETIME_CONDITION(ASBaseCharacter, bIsTargeting, COND_SkipOwner);

	// Replicate to every client, no special condition required
	DOREPLIFETIME(ASBaseCharacter, Health);
	DOREPLIFETIME(ASBaseCharacter, LastTakeHitInfo);
}

```

`SurvivalGame/Source/SurvivalGame/Private/Player/SCharacter.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Player/SCharacter.h"

#include "TimerManager.h"
#include "Items/SUsableActor.h"
#include "Items/SWeapon.h"
#include "Items/SWeaponPickup.h"
#include "Components/SCharacterMovementComponent.h"
#include "Components/SCarryObjectComponent.h"
#include "Player/SBaseCharacter.h"
#include "Player/SPlayerController.h"
#include "Animation/AnimInstance.h"
#include "Components/CapsuleComponent.h"
#include "SurvivalGame/SurvivalGame.h"
#include "GameFramework/DamageType.h"
#include "Camera/CameraComponent.h"


// Sets default values
ASCharacter::ASCharacter(const class FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	UCharacterMovementComponent* MoveComp = GetCharacterMovement();
	// Adjust jump to make it less floaty
	MoveComp->GravityScale = 1.5f;
	MoveComp->JumpZVelocity = 620;
	MoveComp->bCanWalkOffLedgesWhenCrouching = true;
	MoveComp->MaxWalkSpeedCrouched = 200;

	/* Ignore this channel or it will absorb the trace impacts instead of the skeletal mesh */
	GetCapsuleComponent()->SetCollisionResponseToChannel(COLLISION_WEAPON, ECR_Ignore);

	// Enable crouching
	MoveComp->GetNavAgentPropertiesRef().bCanCrouch = true;

	CameraBoomComp = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraBoom"));
	CameraBoomComp->SocketOffset = FVector(0, 35, 0);
	CameraBoomComp->TargetOffset = FVector(0, 0, 55);
	CameraBoomComp->bUsePawnControlRotation = true;
	CameraBoomComp->SetupAttachment(GetRootComponent());

	CameraComp = CreateDefaultSubobject<UCameraComponent>(TEXT("Camera"));
	CameraComp->SetupAttachment(CameraBoomComp);

	CarriedObjectComp = CreateDefaultSubobject<USCarryObjectComponent>(TEXT("CarriedObjectComp"));
	CarriedObjectComp->SetupAttachment(GetRootComponent());

	MaxUseDistance = 500;
	DropWeaponMaxDistance = 100;
	bHasNewFocus = true;
	TargetingSpeedModifier = 0.5f;
	SprintingSpeedModifier = 2.5f;

	Health = 100;

	IncrementHungerAmount = 5.0f;
	IncrementHungerInterval = 5.0f;
	CriticalHungerThreshold = 90;
	HungerDamagePerInterval = 1.0f;
	MaxHunger = 100;
	Hunger = 0;

	/* Names as specified in the character skeleton */
	WeaponAttachPoint = TEXT("WeaponSocket");
	PelvisAttachPoint = TEXT("PelvisSocket");
	SpineAttachPoint = TEXT("SpineSocket");
}


void ASCharacter::BeginPlay()
{
	Super::BeginPlay();

	if (HasAuthority())
	{
		// Set a timer to increment hunger every interval
		FTimerHandle Handle;
		GetWorldTimerManager().SetTimer(Handle, this, &ASCharacter::IncrementHunger, IncrementHungerInterval, true);
	}
}


void ASCharacter::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	if (bWantsToRun && !IsSprinting())
	{
		SetSprinting(true);
	}

	if (Controller && Controller->IsLocalController())
	{
		ASUsableActor* Usable = GetUsableInView();

		// End Focus
		if (FocusedUsableActor != Usable)
		{
			if (FocusedUsableActor)
			{
				FocusedUsableActor->OnEndFocus();
			}

			bHasNewFocus = true;
		}

		// Assign new Focus
		FocusedUsableActor = Usable;

		// Start Focus.
		if (Usable)
		{
			if (bHasNewFocus)
			{
				Usable->OnBeginFocus();
				bHasNewFocus = false;
			}
		}
	}
}

void ASCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	Super::EndPlay(EndPlayReason);
	DestroyInventory();
}


// Called to bind functionality to input
void ASCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	// Movement
	PlayerInputComponent->BindAxis("MoveForward", this, &ASCharacter::MoveForward);
	PlayerInputComponent->BindAxis("MoveRight", this, &ASCharacter::MoveRight);
	PlayerInputComponent->BindAxis("Turn", this, &APawn::AddControllerYawInput);
	PlayerInputComponent->BindAxis("LookUp", this, &APawn::AddControllerPitchInput);

	PlayerInputComponent->BindAction("SprintHold", IE_Pressed, this, &ASCharacter::OnStartSprinting);
	PlayerInputComponent->BindAction("SprintHold", IE_Released, this, &ASCharacter::OnStopSprinting);

	PlayerInputComponent->BindAction("CrouchToggle", IE_Released, this, &ASCharacter::OnCrouchToggle);

	PlayerInputComponent->BindAction("Jump", IE_Pressed, this, &ASCharacter::OnJump);

	// Interaction
	PlayerInputComponent->BindAction("Use", IE_Pressed, this, &ASCharacter::Use);
	PlayerInputComponent->BindAction("DropWeapon", IE_Pressed, this, &ASCharacter::DropWeapon);

	// Weapons
	PlayerInputComponent->BindAction("Targeting", IE_Pressed, this, &ASCharacter::OnStartTargeting);
	PlayerInputComponent->BindAction("Targeting", IE_Released, this, &ASCharacter::OnEndTargeting);

	PlayerInputComponent->BindAction("Fire", IE_Pressed, this, &ASCharacter::OnStartFire);
	PlayerInputComponent->BindAction("Fire", IE_Released, this, &ASCharacter::OnStopFire);

	PlayerInputComponent->BindAction("Reload", IE_Pressed, this, &ASCharacter::OnReload);

	PlayerInputComponent->BindAction("NextWeapon", IE_Pressed, this, &ASCharacter::OnNextWeapon);
	PlayerInputComponent->BindAction("PrevWeapon", IE_Pressed, this, &ASCharacter::OnPrevWeapon);

	PlayerInputComponent->BindAction("EquipPrimaryWeapon", IE_Pressed, this, &ASCharacter::OnEquipPrimaryWeapon);
	PlayerInputComponent->BindAction("EquipSecondaryWeapon", IE_Pressed, this, &ASCharacter::OnEquipSecondaryWeapon);

	/* Input binding for the carry object component */
	PlayerInputComponent->BindAction("PickupObject", IE_Pressed, this, &ASCharacter::OnToggleCarryActor);
}


void ASCharacter::MoveForward(float Val)
{
	if (Controller && Val != 0.f)
	{
		// Limit pitch when walking or falling
		const bool bLimitRotation = (GetCharacterMovement()->IsMovingOnGround() || GetCharacterMovement()->IsFalling());
		const FRotator Rotation = bLimitRotation ? GetActorRotation() : Controller->GetControlRotation();
		const FVector Direction = FRotationMatrix(Rotation).GetScaledAxis(EAxis::X);

		AddMovementInput(Direction, Val);
	}
}


void ASCharacter::MoveRight(float Val)
{
	if (Val != 0.f)
	{
		const FRotator Rotation = GetActorRotation();
		const FVector Direction = FRotationMatrix(Rotation).GetScaledAxis(EAxis::Y);
		AddMovementInput(Direction, Val);
	}
}


/*
Performs ray-trace to find closest looked-at UsableActor.
*/
ASUsableActor* ASCharacter::GetUsableInView() const
{
	FVector CamLoc;
	FRotator CamRot;

	if (Controller == nullptr)
		return nullptr;

	Controller->GetPlayerViewPoint(CamLoc, CamRot);
	const FVector TraceStart = CamLoc;
	const FVector Direction = CamRot.Vector();
	const FVector TraceEnd = TraceStart + (Direction * MaxUseDistance);

	FCollisionQueryParams TraceParams(TEXT("TraceUsableActor"), true, this);
	TraceParams.bReturnPhysicalMaterial = false;

	/* Not tracing complex uses the rough collision instead making tiny objects easier to select. */
	TraceParams.bTraceComplex = false;

	FHitResult Hit(ForceInit);
	GetWorld()->LineTraceSingleByChannel(Hit, TraceStart, TraceEnd, ECC_Visibility, TraceParams);

	return Cast<ASUsableActor>(Hit.GetActor());
}


void ASCharacter::Use()
{
	// Only allow on server. If called on client push this request to the server
	if (HasAuthority())
	{
		ASUsableActor* Usable = GetUsableInView();
		if (Usable)
		{
			Usable->OnUsed(this);
		}
	}
	else
	{
		ServerUse();
	}
}


void ASCharacter::ServerUse_Implementation()
{
	Use();
}


bool ASCharacter::ServerUse_Validate()
{
	return true;
}


void ASCharacter::OnStartTargeting()
{
	if (CarriedObjectComp->GetIsCarryingActor())
	{
		CarriedObjectComp->Drop();
	}

	SetTargeting(true);
}


void ASCharacter::OnEndTargeting()
{
	SetTargeting(false);
}


void ASCharacter::OnJump()
{
	SetIsJumping(true);
}


bool ASCharacter::IsInitiatedJump() const
{
	return bIsJumping;
}


void ASCharacter::SetIsJumping(bool NewJumping)
{
	// Go to standing pose if trying to jump while crouched
	if (bIsCrouched && NewJumping)
	{
		UnCrouch();
	}
	else if (NewJumping != bIsJumping)
	{
		bIsJumping = NewJumping;

		if (bIsJumping)
		{
			/* Perform the built-in Jump on the character */
			Jump();
		}
	}

	if (!HasAuthority())
	{
		ServerSetIsJumping(NewJumping);
	}
}


void ASCharacter::OnMovementModeChanged(EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	Super::OnMovementModeChanged(PrevMovementMode, PreviousCustomMode);

	/* Check if we are no longer falling/jumping */
	if (PrevMovementMode == EMovementMode::MOVE_Falling && 
		GetCharacterMovement()->MovementMode != EMovementMode::MOVE_Falling)
	{
		SetIsJumping(false);
	}
}



void ASCharacter::ServerSetIsJumping_Implementation(bool NewJumping)
{
	SetIsJumping(NewJumping);
}


bool ASCharacter::ServerSetIsJumping_Validate(bool NewJumping)
{
	return true;
}


void ASCharacter::OnStartSprinting()
{
	if (CarriedObjectComp->GetIsCarryingActor())
	{
		CarriedObjectComp->Drop();
	}

	SetSprinting(true);
}


void ASCharacter::OnStopSprinting()
{
	SetSprinting(false);
}


void ASCharacter::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	// Value is already updated locally, skip in replication step
	DOREPLIFETIME_CONDITION(ASCharacter, bIsJumping, COND_SkipOwner);

	// Replicate to every client, no special condition required
	DOREPLIFETIME(ASCharacter, Hunger);

	DOREPLIFETIME(ASCharacter, LastTakeHitInfo);

	DOREPLIFETIME(ASCharacter, CurrentWeapon);
	DOREPLIFETIME(ASCharacter, Inventory);
	/* If we did not display the current inventory on the player mesh we could optimize replication by using this replication condition. */
	/* DOREPLIFETIME_CONDITION(ASCharacter, Inventory, COND_OwnerOnly);*/
}

void ASCharacter::OnCrouchToggle()
{
	if (IsSprinting())
	{
		SetSprinting(false);
	}

	// If we are crouching then CanCrouch will return false. If we cannot crouch then calling Crouch() wont do anything
	if (CanCrouch())
	{
		Crouch();
	}
	else
	{
		UnCrouch();
	}
}


float ASCharacter::GetHunger() const
{
	return Hunger;
}


float ASCharacter::GetMaxHunger() const
{
	return MaxHunger;
}


void ASCharacter::RestoreCondition(float HealthRestored, float HungerRestored)
{
	// Reduce Hunger, ensure we do not go outside of our bounds
	Hunger = FMath::Clamp(Hunger - HungerRestored, 0.0f, GetMaxHunger());

	// Restore Hitpoints
	Health = FMath::Clamp(Health + HealthRestored, 0.0f, GetMaxHealth());

	ASPlayerController* PC = Cast<ASPlayerController>(Controller);
	if (PC)
	{
		PC->ClientHUDMessage(EHUDMessage::Character_EnergyRestored);
	}
}


void ASCharacter::IncrementHunger()
{
	Hunger = FMath::Clamp(Hunger + IncrementHungerAmount, 0.0f, GetMaxHunger());

	if (Hunger > CriticalHungerThreshold)
	{
		FDamageEvent DmgEvent;
		DmgEvent.DamageTypeClass = HungerDamageType;

		// Apply damage to self.
		TakeDamage(HungerDamagePerInterval, DmgEvent, GetController(), this);
	}
}


void ASCharacter::OnDeath(float KillingDamage, FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser)
{
	if (bIsDying)
	{
		return;
	}

	DestroyInventory();
	StopAllAnimMontages();

	Super::OnDeath(KillingDamage, DamageEvent, PawnInstigator, DamageCauser);
}


bool ASCharacter::CanFire() const
{
	/* Add your own checks here, for example non-shooting areas or checking if player is in an NPC dialogue etc. */
	return IsAlive();
}


bool ASCharacter::CanReload() const
{
	return IsAlive();
}


bool ASCharacter::IsFiring() const
{
	return CurrentWeapon && CurrentWeapon->GetCurrentState() == EWeaponState::Firing;
}


FName ASCharacter::GetInventoryAttachPoint(EInventorySlot Slot) const
{
	/* Return the socket name for the specified storage slot */
	switch (Slot)
	{
	case EInventorySlot::Hands:
		return WeaponAttachPoint;
	case EInventorySlot::Primary:
		return SpineAttachPoint;
	case EInventorySlot::Secondary:
		return PelvisAttachPoint;
	default:
		// Not implemented.
		return "";
	}
}


void ASCharacter::DestroyInventory()
{
	if (!HasAuthority())
	{	
		return;
	}

	for (int32 i = Inventory.Num() - 1; i >= 0; i--)
	{
		ASWeapon* Weapon = Inventory[i];
		if (Weapon)
		{
			RemoveWeapon(Weapon, true);
		}
	}
}


void ASCharacter::SetCurrentWeapon(class ASWeapon* NewWeapon, class ASWeapon* LastWeapon)
{
	/* Maintain a reference for visual weapon swapping */
	PreviousWeapon = LastWeapon;

	ASWeapon* LocalLastWeapon = nullptr;
	if (LastWeapon)
	{
		LocalLastWeapon = LastWeapon;
	}
	else if (NewWeapon != CurrentWeapon)
	{
		LocalLastWeapon = CurrentWeapon;
	}

	// UnEquip the current
	bool bHasPreviousWeapon = false;
	if (LocalLastWeapon)
	{
		LocalLastWeapon->OnUnEquip();
		bHasPreviousWeapon = true;
	}

	CurrentWeapon = NewWeapon;

	if (NewWeapon)
	{
		NewWeapon->SetOwningPawn(this);
		/* Only play equip animation when we already hold an item in hands */
		NewWeapon->OnEquip(bHasPreviousWeapon);
	}

	/* NOTE: If you don't have an equip animation w/ animnotify to swap the meshes halfway through, then uncomment this to immediately swap instead */
	//SwapToNewWeaponMesh();
}


void ASCharacter::OnRep_CurrentWeapon(ASWeapon* LastWeapon)
{
	SetCurrentWeapon(CurrentWeapon, LastWeapon);
}


ASWeapon* ASCharacter::GetCurrentWeapon() const
{
	return CurrentWeapon;
}


void ASCharacter::EquipWeapon(ASWeapon* Weapon)
{
	if (Weapon)
	{
		/* Ignore if trying to equip already equipped weapon */
		if (Weapon == CurrentWeapon)
			return;

		if (HasAuthority())
		{
			SetCurrentWeapon(Weapon, CurrentWeapon);
		}
		else
		{
			ServerEquipWeapon(Weapon);
		}
	}
}


bool ASCharacter::ServerEquipWeapon_Validate(ASWeapon* Weapon)
{
	return true;
}


void ASCharacter::ServerEquipWeapon_Implementation(ASWeapon* Weapon)
{
	EquipWeapon(Weapon);
}


void ASCharacter::AddWeapon(class ASWeapon* Weapon)
{
	if (Weapon && HasAuthority())
	{
		Weapon->OnEnterInventory(this);
		Inventory.AddUnique(Weapon);

		// Equip first weapon in inventory
		if (Inventory.Num() > 0 && CurrentWeapon == nullptr)
		{
			EquipWeapon(Inventory[0]);
		}
	}
}


void ASCharacter::RemoveWeapon(class ASWeapon* Weapon, bool bDestroy)
{
	if (Weapon && HasAuthority())
	{
		bool bIsCurrent = CurrentWeapon == Weapon;

		if (Inventory.Contains(Weapon))
		{
			Weapon->OnLeaveInventory();
		}
		Inventory.RemoveSingle(Weapon);

		/* Replace weapon if we removed our current weapon */
		if (bIsCurrent && Inventory.Num() > 0)
		{
			SetCurrentWeapon(Inventory[0]);
		}			

		/* Clear reference to weapon if we have no items left in inventory */
		if (Inventory.Num() == 0)
		{
			SetCurrentWeapon(nullptr);
		}

		if (bDestroy)
		{
			Weapon->Destroy();
		}
	}
}


void ASCharacter::PawnClientRestart()
{
	Super::PawnClientRestart();

	/* Equip the weapon on the client side. */
	SetCurrentWeapon(CurrentWeapon);
}


void ASCharacter::OnReload()
{
	if (CurrentWeapon)
	{
		CurrentWeapon->StartReload();
	}
}


void ASCharacter::OnStartFire()
{
	if (IsSprinting())
	{
		SetSprinting(false);
	}

	if (CarriedObjectComp->GetIsCarryingActor())
	{
		StopWeaponFire();

		CarriedObjectComp->Throw();
		return;
	}

	StartWeaponFire();
}


void ASCharacter::OnStopFire()
{
	StopWeaponFire();
}


void ASCharacter::StartWeaponFire()
{
	if (!bWantsToFire)
	{
		bWantsToFire = true;
		if (CurrentWeapon)
		{
			CurrentWeapon->StartFire();
		}
	}
}


void ASCharacter::StopWeaponFire()
{
	if (bWantsToFire)
	{
		bWantsToFire = false;
		if (CurrentWeapon)
		{
			CurrentWeapon->StopFire();
		}
	}
}


void ASCharacter::OnNextWeapon()
{
	if (CarriedObjectComp->GetIsCarryingActor())
	{
		CarriedObjectComp->Rotate(0.0f, 1.0f);
		return;
	}

	if (Inventory.Num() >= 2) // TODO: Check for weaponstate.
	{
		const int32 CurrentWeaponIndex = Inventory.IndexOfByKey(CurrentWeapon);
		ASWeapon* NextWeapon = Inventory[(CurrentWeaponIndex + 1) % Inventory.Num()];
		EquipWeapon(NextWeapon);
	}
}


void ASCharacter::OnPrevWeapon()
{
	if (CarriedObjectComp->GetIsCarryingActor())
	{
		CarriedObjectComp->Rotate(0.0f, -1.0f);
		return;
	}

	if (Inventory.Num() >= 2) // TODO: Check for weaponstate.
	{
		const int32 CurrentWeaponIndex = Inventory.IndexOfByKey(CurrentWeapon);
		ASWeapon* PrevWeapon = Inventory[(CurrentWeaponIndex - 1 + Inventory.Num()) % Inventory.Num()];
		EquipWeapon(PrevWeapon);
	}
}


void ASCharacter::DropWeapon()
{
	if (!HasAuthority())
	{
		ServerDropWeapon();
		return;
	}

	if (CurrentWeapon)
	{
		FVector CamLoc;
		FRotator CamRot;

		if (Controller == nullptr)
		{
			return;
		}		
		
		/* Find a location to drop the item, slightly in front of the player.
			Perform ray trace to check for blocking objects or walls and to make sure we don't drop any item through the level mesh */
		Controller->GetPlayerViewPoint(CamLoc, CamRot);
		FVector SpawnLocation;
		FRotator SpawnRotation = CamRot;

		const FVector Direction = CamRot.Vector();
		const FVector TraceStart = GetActorLocation();
		const FVector TraceEnd = GetActorLocation() + (Direction * DropWeaponMaxDistance);

		/* Setup the trace params, we are only interested in finding a valid drop position */
		FCollisionQueryParams TraceParams;
		TraceParams.bTraceComplex = false;
		TraceParams.bReturnPhysicalMaterial = false;
		TraceParams.AddIgnoredActor(this);

		FHitResult Hit;
		GetWorld()->LineTraceSingleByChannel(Hit, TraceStart, TraceEnd, ECC_WorldDynamic, TraceParams);

		/* Find farthest valid spawn location */
		if (Hit.bBlockingHit)
		{
			/* Slightly move away from impacted object */
			SpawnLocation = Hit.ImpactPoint + (Hit.ImpactNormal * 20);
		}
		else
		{
			SpawnLocation = TraceEnd;
		}

		/* Spawn the "dropped" weapon */
		FActorSpawnParameters SpawnInfo;
		SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
		ASWeaponPickup* NewWeaponPickup = GetWorld()->SpawnActor<ASWeaponPickup>(CurrentWeapon->WeaponPickupClass, SpawnLocation, FRotator::ZeroRotator, SpawnInfo);

		if (NewWeaponPickup)
		{
			/* Apply torque to make it spin when dropped. */
			UStaticMeshComponent* MeshComp = NewWeaponPickup->GetMeshComponent();
			if (MeshComp)
			{
				MeshComp->SetSimulatePhysics(true);
				MeshComp->AddTorqueInRadians(FVector(1, 1, 1) * 4000000);
			}
		}

		RemoveWeapon(CurrentWeapon, true);
	}
}


void ASCharacter::ServerDropWeapon_Implementation()
{
	DropWeapon();
}


bool ASCharacter::ServerDropWeapon_Validate()
{
	return true;
}


void ASCharacter::OnEquipPrimaryWeapon()
{
	if (CarriedObjectComp->GetIsCarryingActor())
	{
		CarriedObjectComp->Rotate(1.0f, 0.0f);
		return;
	}

	if (Inventory.Num() >= 1)
	{
		/* Find first weapon that uses primary slot. */
		for (int32 i = 0; i < Inventory.Num(); i++)
		{
			ASWeapon* Weapon = Inventory[i];
			if (Weapon->GetStorageSlot() == EInventorySlot::Primary)
			{
				EquipWeapon(Weapon);
			}
		}
	}
}


void ASCharacter::OnEquipSecondaryWeapon()
{
	if (CarriedObjectComp->GetIsCarryingActor())
	{
		CarriedObjectComp->Rotate(-1.0f, 0.0f);
		return;
	}

	if (Inventory.Num() >= 2)
	{
		/* Find first weapon that uses secondary slot. */
		for (int32 i = 0; i < Inventory.Num(); i++)
		{
			ASWeapon* Weapon = Inventory[i];
			if (Weapon->GetStorageSlot() == EInventorySlot::Secondary)
			{
				EquipWeapon(Weapon);
			}
		}
	}
}

bool ASCharacter::WeaponSlotAvailable(EInventorySlot CheckSlot)
{
	/* Iterate all weapons to see if requested slot is occupied */
	for (int32 i = 0; i < Inventory.Num(); i++)
	{
		ASWeapon* Weapon = Inventory[i];
		if (Weapon)
		{
			if (Weapon->GetStorageSlot() == CheckSlot)
				return false;
		}
	}

	return true;

	/* Special find function as alternative to looping the array and performing if statements 
		the [=] prefix means "capture by value", other options include [] "capture nothing" and [&] "capture by reference" */
	//return nullptr == Inventory.FindByPredicate([=](ASWeapon* W){ return W->GetStorageSlot() == CheckSlot; });
}


void ASCharacter::StopAllAnimMontages()
{
	USkeletalMeshComponent* UseMesh = GetMesh();
	if (UseMesh && UseMesh->AnimScriptInstance)
	{
		UseMesh->AnimScriptInstance->Montage_Stop(0.0f);
	}
}


void ASCharacter::MakePawnNoise(float Loudness)
{
	if (HasAuthority())
	{
		/* Make noise to be picked up by PawnSensingComponent by the enemy pawns */
		MakeNoise(Loudness, this, GetActorLocation());
	}

	LastNoiseLoudness = Loudness;
	LastMakeNoiseTime = GetWorld()->GetTimeSeconds();
}


float ASCharacter::GetLastNoiseLoudness()
{
	return LastNoiseLoudness;
}


float ASCharacter::GetLastMakeNoiseTime()
{
	return LastMakeNoiseTime;
}


void ASCharacter::Suicide()
{
	KilledBy(this);
}


void ASCharacter::KilledBy(class APawn* EventInstigator)
{
	if (HasAuthority() && !bIsDying)
	{
		AController* Killer = nullptr;
		if (EventInstigator != nullptr)
		{
			Killer = EventInstigator->Controller;
			LastHitBy = nullptr;
		}

		Die(Health, FDamageEvent(UDamageType::StaticClass()), Killer, nullptr);
	}
}


void ASCharacter::OnToggleCarryActor()
{
	CarriedObjectComp->Pickup();
}


void ASCharacter::SwapToNewWeaponMesh()
{
	if (PreviousWeapon)
	{
		PreviousWeapon->AttachMeshToPawn(PreviousWeapon->GetStorageSlot());
	}

	if (CurrentWeapon)
	{
		CurrentWeapon->AttachMeshToPawn(EInventorySlot::Hands);
	}
}


void ASCharacter::SetSprinting(bool NewSprinting)
{
	if (bWantsToRun)
	{
		StopWeaponFire();
	}

	Super::SetSprinting(NewSprinting);
}

```

`SurvivalGame/Source/SurvivalGame/Private/Player/SLocalPlayer.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Player/SLocalPlayer.h"






FString USLocalPlayer::GetNickname() const
{
	/* Try to fetch a nickname from the online subsystem (eg. Steam) if available */
	FString NickName = Super::GetNickname();

	// Fall back if no nickname was available through the online subsystem.
	if (NickName.IsEmpty())
	{
		const FString Suffix = FString::FromInt(FMath::RandRange(0, 999));
		NickName = FPlatformProcess::ComputerName() + Suffix;
	}

	return NickName;
}

```

`SurvivalGame/Source/SurvivalGame/Private/Player/SPlayerCameraManager.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Player/SPlayerCameraManager.h"
#include "Player/SCharacter.h"
#include "GameFramework/PlayerController.h"
#include "GameFramework/Pawn.h"
#include "Camera/CameraComponent.h"


ASPlayerCameraManager::ASPlayerCameraManager()
{
	NormalFOV = 90.0f;
	TargetingFOV = 65.0f;

	ViewPitchMin = -80.0f;
	ViewPitchMax = 87.0f;
	bAlwaysApplyModifiers = true;

	/* The camera delta between standing and crouched */
	MaxCrouchOffsetZ = 46.0f;

	/* HACK. Mirrored from the 3rd person camera offset from SCharacter */
	DefaultCameraOffsetZ = 20.0f;

	/* Ideally matches the transition speed of the character animation (crouch to stand and vice versa) */
	CrouchLerpVelocity = 12.0f;
}


void ASPlayerCameraManager::UpdateCamera(float DeltaTime)
{
	ASCharacter* MyPawn = PCOwner ? Cast<ASCharacter>(PCOwner->GetPawn()) : nullptr;
	if (MyPawn)
	{
		const float TargetFOV = MyPawn->IsTargeting() ? TargetingFOV : NormalFOV;
		DefaultFOV = FMath::FInterpTo(DefaultFOV, TargetFOV, DeltaTime, 20.0f);
		SetFOV(DefaultFOV);
	}

	/* Apply smooth camera lerp between crouch toggling */
	if (MyPawn)
	{
		if (MyPawn->bIsCrouched && !bWasCrouched)
		{
			CurrentCrouchOffset = MaxCrouchOffsetZ;
		}
		else if (!MyPawn->bIsCrouched && bWasCrouched)
		{
			CurrentCrouchOffset = -MaxCrouchOffsetZ;
		}

		bWasCrouched = MyPawn->bIsCrouched;
		/* Clamp the lerp to 0-1.0 range and interpolate to our new crouch offset */
		CurrentCrouchOffset = FMath::Lerp(CurrentCrouchOffset, 0.0f, FMath::Clamp(CrouchLerpVelocity * DeltaTime, 0.0f, 1.0f));

		FVector CurrentCameraOffset = MyPawn->GetCameraComponent()->GetRelativeTransform().GetLocation();
		FVector NewCameraOffset = FVector(CurrentCameraOffset.X, CurrentCameraOffset.Y, DefaultCameraOffsetZ + CurrentCrouchOffset);
		MyPawn->GetCameraComponent()->SetRelativeLocation(NewCameraOffset);
	}

	Super::UpdateCamera(DeltaTime);
}
```

`SurvivalGame/Source/SurvivalGame/Private/Player/SPlayerController.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Player/SPlayerController.h"
#include "Player/SPlayerCameraManager.h"
#include "Player/SCharacter.h"
#include "UI/SHUD.h"
#include "World/SGameState.h"
#include "GameFramework/PlayerState.h"
#include "SurvivalGame/SurvivalGame.h"



ASPlayerController::ASPlayerController()
{
	/* Assign the class types we wish to use */
	PlayerCameraManagerClass = ASPlayerCameraManager::StaticClass();

	/* Example - Can be set to true for debugging, generally a value like this would exist in the GameMode instead */
	bRespawnImmediately = false;
}


void ASPlayerController::UnFreeze()
{
	Super::UnFreeze();

	// Check if match is ending or has ended.
	ASGameState* MyGameState = GetWorld()->GetGameState<ASGameState>();
	if (MyGameState && MyGameState->HasMatchEnded())
	{
		/* Don't allow spectating or respawns */
		return;
	}

	/* Respawn or spectate */
	if (bRespawnImmediately)
	{
		ServerRestartPlayer();
	}
	else
	{
		StartSpectating();
	}
}


void ASPlayerController::StartSpectating()
{
	/* Update the state on server */
	PlayerState->SetIsSpectator(true);
	/* Waiting to respawn */
	bPlayerIsWaiting = true;
	ChangeState(NAME_Spectating);
	/* Push the state update to the client */
	ClientGotoState(NAME_Spectating);

	/* Focus on the remaining alive player */
	ViewAPlayer(1);

	/* Update the HUD to show the spectator screen */
	ClientHUDStateChanged(EHUDState::Spectating);
}


void ASPlayerController::Suicide()
{
	if (IsInState(NAME_Playing))
	{
		ServerSuicide();
	}
}

void ASPlayerController::ServerSuicide_Implementation()
{
	ASCharacter* MyPawn = Cast<ASCharacter>(GetPawn());
	if (MyPawn && ((GetWorld()->TimeSeconds - MyPawn->CreationTime > 1) || (GetNetMode() == NM_Standalone)))
	{
		MyPawn->Suicide();
	}
}


bool ASPlayerController::ServerSuicide_Validate()
{
	return true;
}


void ASPlayerController::ClientHUDStateChanged_Implementation(EHUDState NewState)
{
	ASHUD* HUD = Cast<ASHUD>(GetHUD());
	if (HUD)
	{
		HUD->OnStateChanged(NewState);
	}
}


void ASPlayerController::ClientHUDMessage_Implementation(EHUDMessage MessageID)
{
	/* Turn the ID into a message for the HUD to display */
	const FText TextMessage = GetText(MessageID);

	ASHUD* HUD = Cast<ASHUD>(GetHUD());
	if (HUD)
	{
		/* Implemented in SurvivalHUD Blueprint */
		HUD->MessageReceived(TextMessage);
	}
}


void ASPlayerController::ServerSendChatMessage_Implementation(class APlayerState* Sender, const FString& Message)
{
	for (FConstPlayerControllerIterator Iterator = GetWorld()->GetPlayerControllerIterator(); Iterator; ++Iterator)
	{
		ASPlayerController* PC = Cast<ASPlayerController>(Iterator->Get());
		if (PC)
		{
			PC->ClientReceiveChatMessage(Sender, Message);
		}
	}
}


void ASPlayerController::ClientReceiveChatMessage_Implementation(class APlayerState* Sender, const FString& Message)
{
	OnChatMessageReceived.Broadcast(Sender, Message);
}


bool ASPlayerController::ServerSendChatMessage_Validate(class APlayerState* Sender, const FString& Message)
{
	return true;
}


/* Temporarily set the namespace. If this was omitted, we should call NSLOCTEXT(Namespace, x, y) instead */
#define LOCTEXT_NAMESPACE "HUDMESSAGES"

FText ASPlayerController::GetText(EHUDMessage MsgID) const
{
	switch (MsgID)
	{
	case EHUDMessage::Weapon_SlotTaken:
		return LOCTEXT("WeaponSlotTaken", "Weapon slot already taken.");
	case EHUDMessage::Character_EnergyRestored:
		return LOCTEXT("CharacterEnergyRestored", "Energy Restored");
	case EHUDMessage::Game_SurviveStart:
		return LOCTEXT("GameNightStart", "SURVIVE THE NIGHT");
	case EHUDMessage::Game_SurviveEnded:
		return LOCTEXT("GameNightEnd", "Night survived! Prepare for the coming night.");
	default:
		UE_LOG(LogGame, Warning, TEXT("No Message set for enum value in SPlayerContoller::GetText(). "))
		return FText::FromString("No Message Set");
	}
}

/* Remove the namespace definition so it doesn't exist in other files compiled after this one. */
#undef LOCTEXT_NAMESPACE
```

`SurvivalGame/Source/SurvivalGame/Private/Player/SPlayerState.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Player/SPlayerState.h"
#include "World/SGameState.h"
#include "Engine/Engine.h"
#include "Net/UnrealNetwork.h"



ASPlayerState::ASPlayerState()
{
	/* AI will remain in team 0, players are updated to team 1 through the GameMode::InitNewPlayer */
	TeamNumber = 0;
}


void ASPlayerState::Reset()
{
	Super::Reset();

	NumKills = 0;
	NumDeaths = 0;
}

void ASPlayerState::AddKill()
{
	NumKills++;
}

void ASPlayerState::AddDeath()
{
	NumDeaths++;
}

void ASPlayerState::ScorePoints(int32 Points)
{
	SetScore(GetScore() + Points);

	/* Add the score to the global score count */
	ASGameState* GS = GetWorld()->GetGameState<ASGameState>();
	if (GS)
	{
		GS->AddScore(Points);
	}
}


void ASPlayerState::SetTeamNumber(int32 NewTeamNumber)
{
	TeamNumber = NewTeamNumber;
}


int32 ASPlayerState::GetTeamNumber() const
{
	return TeamNumber;
}

int32 ASPlayerState::GetKills() const
{
	return NumKills;
}

int32 ASPlayerState::GetDeaths() const
{
	return NumDeaths;
}


void ASPlayerState::GetLifetimeReplicatedProps(TArray< class FLifetimeProperty > & OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ASPlayerState, NumKills);
	DOREPLIFETIME(ASPlayerState, NumDeaths);
	DOREPLIFETIME(ASPlayerState, TeamNumber);
}
```

`SurvivalGame/Source/SurvivalGame/Private/Player/SSpectatorPawn.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "Player/SSpectatorPawn.h"




ASSpectatorPawn::ASSpectatorPawn()
{
	bAddDefaultMovementBindings = true;
}

```

`SurvivalGame/Source/SurvivalGame/Private/UI/SHUD.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "UI/SHUD.h"
#include "Player/SCharacter.h"
#include "Items/SUsableActor.h"
#include "UObject/ConstructorHelpers.h"
#include "Engine/Texture2D.h"


ASHUD::ASHUD()
{
	/* You can use the FObjectFinder in C++ to reference content directly in code. Although it's advisable to avoid this and instead assign content through Blueprint child classes. */
	static ConstructorHelpers::FObjectFinder<UTexture2D> HUDCenterDotObj(TEXT("/Game/UI/HUD/T_CenterDot_M.T_CenterDot_M"));
	CenterDotIcon = UCanvas::MakeIcon(HUDCenterDotObj.Object);
}


void ASHUD::DrawHUD()
{
	Super::DrawHUD();

	DrawCenterDot();
}


void ASHUD::DrawCenterDot()
{
	float CenterX = Canvas->ClipX / 2;
	float CenterY = Canvas->ClipY / 2;
	float CenterDotScale = 0.07f;

	ASCharacter* Pawn = Cast<ASCharacter>(GetOwningPawn());
	if (Pawn && Pawn->IsAlive())
	{
		// Boost size when hovering over a usable object.
		ASUsableActor* Usable = Pawn->GetUsableInView();
		if (Usable)
		{
			CenterDotScale *= 1.5f;
		}

		Canvas->SetDrawColor(255, 255, 255, 255);
		Canvas->DrawIcon(CenterDotIcon,
			CenterX - CenterDotIcon.UL*CenterDotScale / 2.0f,
			CenterY - CenterDotIcon.VL*CenterDotScale / 2.0f, CenterDotScale);
	}
}



void ASHUD::OnStateChanged_Implementation(EHUDState NewState)
{
	CurrentState = NewState;
}


EHUDState ASHUD::GetCurrentState() const
{
	return CurrentState;
}

```

`SurvivalGame/Source/SurvivalGame/Private/World/SCoopGameMode.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "World/SCoopGameMode.h"
#include "NavigationSystem.h"
#include "Player/SPlayerState.h"
#include "Player/SCharacter.h"
#include "World/SGameState.h"
#include "EngineUtils.h"
#include "Player/SPlayerController.h"



ASCoopGameMode::ASCoopGameMode()
{
	/* Disable damage to coop buddies  */
	bAllowFriendlyFireDamage = false;
	bSpawnAtTeamPlayer = true;
	
	ScoreNightSurvived = 1000;
}


/*
	RestartPlayer - Spawn the player next to his living coop buddy instead of a PlayerStart
*/
void ASCoopGameMode::RestartPlayer(class AController* NewPlayer)
{
	/* Fallback to PlayerStart picking if team spawning is disabled or we're trying to spawn a bot. */
	if (!bSpawnAtTeamPlayer || (NewPlayer->PlayerState && NewPlayer->PlayerState->IsABot()))
	{
		Super::RestartPlayer(NewPlayer);
		return;
	}

	/* Look for a live player to spawn next to */
	FVector SpawnOrigin = FVector::ZeroVector;
	FRotator StartRotation = FRotator::ZeroRotator;
	for (TActorIterator<APawn> It(GetWorld()); It; ++It)
	{
		ASCharacter* MyCharacter = Cast<ASCharacter>(*It);
		if (MyCharacter && MyCharacter->IsAlive())
		{
			/* Get the origin of the first player we can find */
			SpawnOrigin = MyCharacter->GetActorLocation();
			StartRotation = MyCharacter->GetActorRotation();
			break;
		}
	}

	/* No player is alive (yet) - spawn using one of the PlayerStarts */
	if (SpawnOrigin == FVector::ZeroVector)
	{
		Super::RestartPlayer(NewPlayer);
		return;
	}

	/* Get a point on the nav mesh near the other player */
	FNavLocation StartLocation;
	UNavigationSystemV1* NavSystem = UNavigationSystemV1::GetNavigationSystem(this);
	if (NavSystem && NavSystem->GetRandomPointInNavigableRadius(SpawnOrigin, 250.0f, StartLocation))
	{
		// Try to create a pawn to use of the default class for this player
		if (NewPlayer->GetPawn() == nullptr && GetDefaultPawnClassForController(NewPlayer) != nullptr)
		{
			FActorSpawnParameters SpawnInfo;
			SpawnInfo.Instigator = GetInstigator();
			APawn* ResultPawn = GetWorld()->SpawnActor<APawn>(GetDefaultPawnClassForController(NewPlayer), StartLocation.Location, StartRotation, SpawnInfo);
			if (ResultPawn == nullptr)
			{
				UE_LOG(LogGameMode, Warning, TEXT("Couldn't spawn Pawn of type %s at %s"), *GetNameSafe(DefaultPawnClass), &StartLocation.Location);
			}
			NewPlayer->SetPawn(ResultPawn);
		}

		if (NewPlayer->GetPawn() == nullptr)
		{
			NewPlayer->FailedToSpawnPawn();
		}
		else
		{
			NewPlayer->Possess(NewPlayer->GetPawn());

			// If the Pawn is destroyed as part of possession we have to abort
			if (NewPlayer->GetPawn() == nullptr)
			{
				NewPlayer->FailedToSpawnPawn();
			}
			else
			{
				// Set initial control rotation to player start's rotation
				NewPlayer->ClientSetRotation(NewPlayer->GetPawn()->GetActorRotation(), true);

				FRotator NewControllerRot = StartRotation;
				NewControllerRot.Roll = 0.f;
				NewPlayer->SetControlRotation(NewControllerRot);

				SetPlayerDefaults(NewPlayer->GetPawn());
			}
		}
	}
}


void ASCoopGameMode::OnNightEnded()
{
	/* Respawn spectating players that died during the night */
	for (FConstPlayerControllerIterator It = GetWorld()->GetPlayerControllerIterator(); It; It++)
	{
		/* Look for all players that are spectating */
		ASPlayerController* MyController = Cast<ASPlayerController>(*It);
		if (MyController)
		{
			if (MyController->PlayerState->IsSpectator())
			{
				RestartPlayer(MyController);
				MyController->ClientHUDStateChanged(EHUDState::Playing);
			}
			else
			{
				/* Player still alive, award him some points */
				ASCharacter* MyPawn = Cast<ASCharacter>(MyController->GetPawn());
				if (MyPawn && MyPawn->IsAlive())
				{
					ASPlayerState* PS = Cast<ASPlayerState>(MyController->PlayerState);
					if (PS)
					{
						PS->ScorePoints(ScoreNightSurvived);
					}
				}
			}
		}
	}
}


void ASCoopGameMode::Killed(AController* Killer, AController* VictimPlayer, APawn* VictimPawn, const UDamageType* DamageType)
{
	ASPlayerState* KillerPS = Killer ? Cast<ASPlayerState>(Killer->PlayerState) : nullptr;
	ASPlayerState* VictimPS = VictimPlayer ? Cast<ASPlayerState>(VictimPlayer->PlayerState) : nullptr;

	if (KillerPS && KillerPS != VictimPS && !KillerPS->IsABot())
	{
		KillerPS->AddKill();
		KillerPS->ScorePoints(10);
	}

	if (VictimPS && !VictimPS->IsABot())
	{
		VictimPS->AddDeath();
	}

	/* End match is all players died */
	CheckMatchEnd();
}


void ASCoopGameMode::CheckMatchEnd()
{
	bool bHasAlivePlayer = false;
	for (TActorIterator<APawn> It(GetWorld()); It; ++It)
	{
		ASCharacter* MyPawn = Cast<ASCharacter>(*It);
		if (MyPawn && MyPawn->IsAlive())
		{
			ASPlayerState* PS = Cast<ASPlayerState>(MyPawn->GetPlayerState());
			if (PS)
			{
				if (!PS->IsABot())
				{
					/* Found one player that is still alive, game will continue */
					bHasAlivePlayer = true;
					break;
				}
			}
		}
	}

	/* End game is all players died */
	if (!bHasAlivePlayer)
	{
		FinishMatch();
	}
}


void ASCoopGameMode::FinishMatch()
{
	if (IsMatchInProgress())
	{
		EndMatch();

		/* Stop spawning bots */
		GetWorldTimerManager().ClearTimer(TimerHandle_BotSpawns);

		for (FConstPlayerControllerIterator It = GetWorld()->GetPlayerControllerIterator(); It; It++)
		{
			ASPlayerController* MyController = Cast<ASPlayerController>(*It);
			if (MyController)
			{
				MyController->ClientHUDStateChanged(EHUDState::MatchEnd);
			}
		}
	}
}

```

`SurvivalGame/Source/SurvivalGame/Private/World/SGameInstance.cpp`:

```cpp
// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.


#include "World/SGameInstance.h"


```

`SurvivalGame/Source/SurvivalGame/Private/World/SGameMode.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "World/SGameMode.h"
#include "Player/SPlayerController.h"
#include "Player/SPlayerState.h"
#include "World/SGameState.h"
#include "Player/SCharacter.h"
#include "UI/SHUD.h"
#include "SurvivalGame/STypes.h"
#include "Player/SSpectatorPawn.h"
#include "AI/SZombieAIController.h"
#include "AI/SZombieCharacter.h"
#include "World/SPlayerStart.h"
#include "Mutators/SMutator.h"
#include "Items/SWeapon.h"
#include "TimerManager.h"
#include "Engine/Engine.h"
#include "Kismet/GameplayStatics.h"
#include "EngineUtils.h"
#include "Components/CapsuleComponent.h"
#include "Engine/LevelScriptActor.h"
#include "SurvivalGame/SurvivalGame.h"


ASGameMode::ASGameMode()
{
	/* Assign the class types used by this gamemode */
	PlayerControllerClass = ASPlayerController::StaticClass();
	PlayerStateClass = ASPlayerState::StaticClass();
	GameStateClass = ASGameState::StaticClass();
	SpectatorClass = ASSpectatorPawn::StaticClass();

	BotPawnClass = ASZombieCharacter::StaticClass();

	bAllowFriendlyFireDamage = false;
	bSpawnZombiesAtNight = true;

	/* Start the game at 16:00 */
	TimeOfDayStart = 16 * 60;
	BotSpawnInterval = 5.0f;

	/* Default team is 1 for players and 0 for enemies */
	PlayerTeamNum = 1;

	// You may want to make this number dynamic as players survived multiple nights
	MaxPawnsInZone = 20;
}


void ASGameMode::InitGameState()
{
	Super::InitGameState();

	ASGameState* MyGameState = Cast<ASGameState>(GameState);
	if (MyGameState)
	{
		MyGameState->ElapsedGameMinutes = TimeOfDayStart;
	}
}


void ASGameMode::PreInitializeComponents()
{
	Super::PreInitializeComponents();

	/* Set timer to run every second */
	GetWorldTimerManager().SetTimer(TimerHandle_DefaultTimer, this, &ASGameMode::DefaultTimer, GetWorldSettings()->GetEffectiveTimeDilation(), true);
}


void ASGameMode::StartMatch()
{
	if (!HasMatchStarted())
	{
		/* Spawn a new bot every 5 seconds (bothandler will opt-out based on his own rules for example to only spawn during night time) */
		GetWorldTimerManager().SetTimer(TimerHandle_BotSpawns, this, &ASGameMode::SpawnBotHandler, BotSpawnInterval, true);
	}

	Super::StartMatch();
}


void ASGameMode::DefaultTimer()
{
	/* Immediately start the match while playing in editor */
	//if (GetWorld()->IsPlayInEditor())
	{
		if (GetMatchState() == MatchState::WaitingToStart)
		{
			StartMatch();
		}
	}

	/* Only increment time of day while game is active */
	if (IsMatchInProgress())
	{
		ASGameState* MyGameState = Cast<ASGameState>(GameState);
		if (MyGameState)
		{
			/* Increment our time of day */
			MyGameState->ElapsedGameMinutes += MyGameState->GetTimeOfDayIncrement();

			/* Determine our state */
			MyGameState->GetAndUpdateIsNight();

			/* Trigger events when night starts or ends */
			bool CurrentIsNight = MyGameState->GetIsNight();
			if (CurrentIsNight != LastIsNight)
			{
				EHUDMessage MessageID = CurrentIsNight ? EHUDMessage::Game_SurviveStart : EHUDMessage::Game_SurviveEnded;
				MyGameState->BroadcastGameMessage(MessageID);

				/* The night just ended, respawn all dead players */
				if (!CurrentIsNight)
				{
					OnNightEnded();
				}

				/* Update bot states */
// 				if (CurrentIsNight)
// 				{
// 					WakeAllBots();
// 				}
// 				else
// 				{
// 					PassifyAllBots();
// 				}
			}

			LastIsNight = MyGameState->bIsNight;
		}
	}
}


bool ASGameMode::CanDealDamage(class ASPlayerState* DamageCauser, class ASPlayerState* DamagedPlayer) const
{
	if (bAllowFriendlyFireDamage)
	{
		return true;
	}

	/* Allow damage to self */
	if (DamagedPlayer == DamageCauser)
	{
		return true;
	}

	// Compare Team Numbers
	return DamageCauser && DamagedPlayer && (DamageCauser->GetTeamNumber() != DamagedPlayer->GetTeamNumber());
}


FString ASGameMode::InitNewPlayer(class APlayerController* NewPlayerController, const FUniqueNetIdRepl& UniqueId, const FString& Options, const FString& Portal)
{
	FString Result = Super::InitNewPlayer(NewPlayerController, UniqueId, Options, Portal);

	ASPlayerState* NewPlayerState = Cast<ASPlayerState>(NewPlayerController->PlayerState);
	if (NewPlayerState)
	{
		NewPlayerState->SetTeamNumber(PlayerTeamNum);
	}

	return Result;
}


float ASGameMode::ModifyDamage(float Damage, AActor* DamagedActor, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser) const
{
	float ActualDamage = Damage;

	ASBaseCharacter* DamagedPawn = Cast<ASBaseCharacter>(DamagedActor);
	if (DamagedPawn && EventInstigator)
	{
		ASPlayerState* DamagedPlayerState = Cast<ASPlayerState>(DamagedPawn->GetPlayerState());
		ASPlayerState* InstigatorPlayerState = Cast<ASPlayerState>(EventInstigator->PlayerState);

		// Check for friendly fire
		if (!CanDealDamage(InstigatorPlayerState, DamagedPlayerState))
		{
			ActualDamage = 0.f;
		}
	}

	return ActualDamage;
}


bool ASGameMode::ShouldSpawnAtStartSpot(AController* Player)
{
	/* Always pick a random location */
	return false;
}


AActor* ASGameMode::ChoosePlayerStart_Implementation(AController* Player)
{
	TArray<APlayerStart*> PreferredSpawns;
	TArray<APlayerStart*> FallbackSpawns;

	/* Get all playerstart objects in level */
	TArray<AActor*> PlayerStarts;
	UGameplayStatics::GetAllActorsOfClass(this, APlayerStart::StaticClass(), PlayerStarts);

	/* Split the player starts into two arrays for preferred and fallback spawns */
	for (int32 i = 0; i < PlayerStarts.Num(); i++)
	{
		APlayerStart* TestStart = Cast<APlayerStart>(PlayerStarts[i]);

		if (TestStart && IsSpawnpointAllowed(TestStart, Player))
		{
			if (IsSpawnpointPreferred(TestStart, Player))
			{
				PreferredSpawns.Add(TestStart);
			}
			else
			{
				FallbackSpawns.Add(TestStart);
			}
		}

	}

	/* Pick a random spawnpoint from the filtered spawn points */
	APlayerStart* BestStart = nullptr;
	if (PreferredSpawns.Num() > 0)
	{
		BestStart = PreferredSpawns[FMath::RandHelper(PreferredSpawns.Num())];
	}
	else if (FallbackSpawns.Num() > 0)
	{
		BestStart = FallbackSpawns[FMath::RandHelper(FallbackSpawns.Num())];
	}

	/* If we failed to find any (so BestStart is nullptr) fall back to the base code */
	return BestStart ? BestStart : Super::ChoosePlayerStart_Implementation(Player);
}


bool ASGameMode::IsSpawnpointAllowed(APlayerStart* SpawnPoint, AController* Controller)
{
	if (Controller == nullptr || Controller->PlayerState == nullptr)
		return true;

	/* Check for extended playerstart class */
	ASPlayerStart* MyPlayerStart = Cast<ASPlayerStart>(SpawnPoint);
	if (MyPlayerStart)
	{
		return MyPlayerStart->GetIsPlayerOnly() && !Controller->PlayerState->IsABot();
	}

	/* Cast failed, Anyone can spawn at the base playerstart class */
	return true;
}


bool ASGameMode::IsSpawnpointPreferred(APlayerStart* SpawnPoint, AController* Controller)
{
	if (SpawnPoint)
	{
		/* Iterate all pawns to check for collision overlaps with the spawn point */
		const FVector SpawnLocation = SpawnPoint->GetActorLocation();
		for (TActorIterator<APawn> It(GetWorld()); It; ++It)
		{
			ACharacter* OtherPawn = Cast<ACharacter>(*It);
			if (OtherPawn)
			{
				const float CombinedHeight = (SpawnPoint->GetCapsuleComponent()->GetScaledCapsuleHalfHeight() + OtherPawn->GetCapsuleComponent()->GetScaledCapsuleHalfHeight()) * 2.0f;
				const float CombinedWidth = SpawnPoint->GetCapsuleComponent()->GetScaledCapsuleRadius() + OtherPawn->GetCapsuleComponent()->GetScaledCapsuleRadius();
				const FVector OtherLocation = OtherPawn->GetActorLocation();

				// Check if player overlaps the playerstart
				if (FMath::Abs(SpawnLocation.Z - OtherLocation.Z) < CombinedHeight && (SpawnLocation - OtherLocation).Size2D() < CombinedWidth)
				{
					return false;
				}
			}
		}

		/* Check if spawnpoint is exclusive to players */
		ASPlayerStart* MyPlayerStart = Cast<ASPlayerStart>(SpawnPoint);
		if (MyPlayerStart)
		{
			return MyPlayerStart->GetIsPlayerOnly() && !Controller->PlayerState->IsABot();
		}
	}

	return false;
}


void ASGameMode::SpawnNewBot()
{
	// Chance for Blueprint to pick a location (for example implementation see BP: SurvivalCoopGameMode asset)
	FTransform SpawnTransform;
	if (!FindBotSpawnTransform(SpawnTransform))
	{
		// This will fail unless blueprint has implemented this function to handle spawn locations
		UE_LOG(LogGame, Warning, TEXT("Failed to find bot spawn transform for SpawnNewBot."));
		return;
	}

	GetWorld()->SpawnActor<APawn>(BotPawnClass, SpawnTransform);
}

/* Used by RestartPlayer() to determine the pawn to create and possess when a bot or player spawns */
UClass* ASGameMode::GetDefaultPawnClassForController_Implementation(AController* InController)
{
	if (Cast<ASZombieAIController>(InController))
	{
		return BotPawnClass;
	}

	return Super::GetDefaultPawnClassForController_Implementation(InController);
}


bool ASGameMode::CanSpectate_Implementation(APlayerController* Viewer, APlayerState* ViewTarget)
{
	/* Don't allow spectating of other non-player bots */
	return (ViewTarget && !ViewTarget->IsABot());
}


void ASGameMode::PassifyAllBots()
{
	for (TActorIterator<APawn> It(GetWorld()); It; ++It)
	{
		ASZombieCharacter* AIPawn = Cast<ASZombieCharacter>(*It);
		if (AIPawn)
		{
			AIPawn->SetBotType(EBotBehaviorType::Passive);
		}
	}
}


void ASGameMode::WakeAllBots()
{
	for (TActorIterator<APawn> It(GetWorld()); It; ++It)
	{
		ASZombieCharacter* AIPawn = Cast<ASZombieCharacter>(*It);
		if (AIPawn)
		{
			AIPawn->SetBotType(EBotBehaviorType::Patrolling);
		}
	}
}


void ASGameMode::SpawnBotHandler()
{
	if (!bSpawnZombiesAtNight)
	{
		return;
	}
		

	ASGameState* MyGameState = Cast<ASGameState>(GameState);
	if (MyGameState)
	{
		/* Only spawn bots during night time */
		if (MyGameState->GetIsNight())
		{
			int32 PawnsInWorld = 0;
			for (TActorIterator<APawn> It(GetWorld()); It; ++It)
			{
				++PawnsInWorld;
			}

			/* Check number of available pawns (players included) */
			if (PawnsInWorld < MaxPawnsInZone)
			{
				SpawnNewBot();
			}

		}
	}
}


void ASGameMode::OnNightEnded()
{
	// Do nothing (can be used to apply score or trigger other time of day events)
}

void ASGameMode::Killed(AController* Killer, AController* VictimPlayer, APawn* VictimPawn, const UDamageType* DamageType)
{
	// Do nothing (can we used to apply score or keep track of kill count)
}


void ASGameMode::SetPlayerDefaults(APawn* PlayerPawn)
{
	Super::SetPlayerDefaults(PlayerPawn);

	SpawnDefaultInventory(PlayerPawn);
}


void ASGameMode::SpawnDefaultInventory(APawn* PlayerPawn)
{
	ASCharacter* MyPawn = Cast<ASCharacter>(PlayerPawn);
	if (MyPawn)
	{
		for (int32 i = 0; i < DefaultInventoryClasses.Num(); i++)
		{
			if (DefaultInventoryClasses[i])
			{
				FActorSpawnParameters SpawnInfo;
				SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
				ASWeapon* NewWeapon = GetWorld()->SpawnActor<ASWeapon>(DefaultInventoryClasses[i], SpawnInfo);

				MyPawn->AddWeapon(NewWeapon);
			}
		}
	}
}


/************************************************************************/
/* Modding & Mutators                                                   */
/************************************************************************/


void ASGameMode::InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage)
{
	/* Spawn all mutators. */
	for (int32 i = 0; i < MutatorClasses.Num(); i++)
	{
		AddMutator(MutatorClasses[i]);
	}

	if (BaseMutator)
	{
		BaseMutator->InitGame(MapName, Options, ErrorMessage);
	}


	for (TActorIterator<AActor> It(GetWorld(), AActor::StaticClass()); It; ++It)
	{
		AActor* Actor = *It;
		
		// Some classes can't be removed via mutators
		bool bIsValidClass = !Actor->IsA(ALevelScriptActor::StaticClass()) && !Actor->IsA(ASMutator::StaticClass());
		// Static actors can't be removed.
		bool bIsRemovable = Actor->GetRootComponent() && Actor->GetRootComponent()->Mobility != EComponentMobility::Static;

		if (bIsValidClass && bIsRemovable)
		{
			// a few type checks being AFTER the CheckRelevance() call is intentional; want mutators to be able to modify, but not outright destroy
			if (!CheckRelevance(Actor) && !Actor->IsA(APlayerController::StaticClass()))
			{
				/* Actors are destroyed if they fail the relevance checks */
				Actor->Destroy();
			}
		}
	}

	Super::InitGame(MapName, Options, ErrorMessage);
}


bool ASGameMode::CheckRelevance_Implementation(AActor* Other)
{
	/* Execute the first in the mutator chain */
	if (BaseMutator)
	{
		return BaseMutator->CheckRelevance(Other);
	}

	return true;
}


void ASGameMode::AddMutator(TSubclassOf<ASMutator> MutClass)
{
	ASMutator* NewMut = GetWorld()->SpawnActor<ASMutator>(MutClass);
	if (NewMut)
	{
		if (BaseMutator == nullptr)
		{
			BaseMutator = NewMut;
		}
		else
		{
			// Add as child in chain
			BaseMutator->NextMutator = NewMut;
		}
	}
}

```

`SurvivalGame/Source/SurvivalGame/Private/World/SGameState.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "World/SGameState.h"
#include "Player/SPlayerController.h"
#include "World/SGameInstance.h"
#include "Net/UnrealNetwork.h"


ASGameState::ASGameState()
{
	/* 1 SECOND real time is 1*TimeScale MINUTES game time */
	TimeScale = 10.0f;
	bIsNight = false;

	SunriseTimeMark = 6.0f;
	SunsetTimeMark = 18.0f;
}


void ASGameState::SetTimeOfDay(float NewHourOfDay)
{
	ElapsedGameMinutes = NewHourOfDay * 60;
}


bool ASGameState::GetIsNight()
{
	return bIsNight;
}


float ASGameState::GetTimeOfDayIncrement()
{
	return (GetWorldSettings()->GetEffectiveTimeDilation() * TimeScale);
}


int32 ASGameState::GetElapsedDays()
{
	const float MinutesInDay = 24 * 60;
	const float ElapsedDays = ElapsedGameMinutes / MinutesInDay;
	return FMath::FloorToInt(ElapsedDays);
}


int32 ASGameState::GetElapsedFullDaysInMinutes()
{
	const int32 MinutesInDay = 24 * 60;
	return GetElapsedDays() * MinutesInDay;
}


bool ASGameState::GetAndUpdateIsNight()
{
	const float TimeOfDay = ElapsedGameMinutes - GetElapsedFullDaysInMinutes();
	if (TimeOfDay > (SunriseTimeMark * 60) && TimeOfDay < (SunsetTimeMark * 60))
	{
		bIsNight = false;
	}
	else
	{
		bIsNight = true;
	}

	return bIsNight;
}


int32 ASGameState::GetRealSecondsTillSunrise()
{
	float SunRiseMinutes = (SunriseTimeMark * 60);
	const int32 MinutesInDay = 24 * 60;

	float ElapsedTimeToday = GetElapsedMinutesCurrentDay();
	if (ElapsedTimeToday < SunRiseMinutes)
	{
		/* Still early in day cycle, so easy to get remaining time */
		return (SunRiseMinutes - ElapsedTimeToday) / TimeScale;
	}
	else
	{
		/* Sunrise will happen "tomorrow" so we need to add another full day to get remaining time */
		float MaxTimeTillNextSunrise = MinutesInDay + SunRiseMinutes;
		return (MaxTimeTillNextSunrise - ElapsedTimeToday) / TimeScale;
	}
}


int32 ASGameState::GetElapsedMinutesCurrentDay()
{
	return ElapsedGameMinutes - GetElapsedFullDaysInMinutes();
}


/* As with Server side functions, NetMulticast functions have a _Implementation body */
void ASGameState::BroadcastGameMessage_Implementation(EHUDMessage MessageID)
{
	for (FConstPlayerControllerIterator It = GetWorld()->GetPlayerControllerIterator(); It; It++)
	{
		ASPlayerController* MyController = Cast<ASPlayerController>(*It);
		if (MyController && MyController->IsLocalController())
		{
			MyController->ClientHUDMessage(MessageID);
		}
	}
}


void ASGameState::AddPlayerState(APlayerState* PlayerState)
{
	Super::AddPlayerState(PlayerState);

	USGameInstance* GI = GetWorld()->GetGameInstance<USGameInstance>();
	if (ensure(GI))
	{
		GI->OnPlayerStateAdded.Broadcast(PlayerState);
	}
}


void ASGameState::RemovePlayerState(APlayerState* PlayerState)
{
	Super::RemovePlayerState(PlayerState);

	USGameInstance* GI = GetWorld()->GetGameInstance<USGameInstance>();
	if (ensure(GI))
	{
		GI->OnPlayerStateRemoved.Broadcast(PlayerState);
	}
}


int32 ASGameState::GetTotalScore()
{
	return TotalScore;
}


void ASGameState::AddScore(int32 Score)
{
	TotalScore += Score;
}


void ASGameState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ASGameState, ElapsedGameMinutes);
	DOREPLIFETIME(ASGameState, bIsNight);
	DOREPLIFETIME(ASGameState, TotalScore);
}
```

`SurvivalGame/Source/SurvivalGame/Private/World/SOpenWorldGameMode.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "World/SOpenWorldGameMode.h"





ASOpenWorldGameMode::ASOpenWorldGameMode()
{
	/* Open world content is free-for-all */
	bAllowFriendlyFireDamage = true;
}


bool ASOpenWorldGameMode::CanSpectate_Implementation(APlayerController* Viewer, APlayerState* ViewTarget)
{
	return false;
}

```

`SurvivalGame/Source/SurvivalGame/Private/World/SPlayerStart.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "World/SPlayerStart.h"





ASPlayerStart::ASPlayerStart(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	bPlayerOnly = true;
}

```

`SurvivalGame/Source/SurvivalGame/Private/World/STimeOfDayManager.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.


#include "World/STimeOfDayManager.h"
#include "World/SGameState.h"
#include "Components/AudioComponent.h"
#include "Engine/DirectionalLight.h"
#include "Engine/SkyLight.h"
#include "Kismet/GameplayStatics.h"
#include "Sound/SoundCue.h"
#include "Components/SkyLightComponent.h"
#include "Curves/CurveVector.h"


ASTimeOfDayManager::ASTimeOfDayManager()
{
	AmbientAudioComp = CreateDefaultSubobject<UAudioComponent>(TEXT("AmbientAudioComp"));
	AmbientAudioComp->bAutoActivate = false;

	/*
	
	Content/Base/BP_TimeOfDayManager extends this class and fetches all required object references from the current level.

	SkyLight, DirectionalLight (& BP_SkySphere which is controlled in Blueprint only to update sun direction in the skybox)
	
	*/
}


void ASTimeOfDayManager::BeginPlay()
{
	Super::BeginPlay();

	if (PrimarySunLight)
	{
		OriginalSunBrightness = PrimarySunLight->GetBrightness();
		TargetSunBrightness = OriginalSunBrightness;
	}

	PlayAmbientLoop();
}


void ASTimeOfDayManager::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	ASGameState* MyGameState = Cast<ASGameState>(GetWorld()->GetGameState());
	if (MyGameState)
	{
		/* Update the position of the sun. */
		if (PrimarySunLight)
		{
			if (LastTimeOfDay == MyGameState->ElapsedGameMinutes)
			{
				TimeSinceLastIncrement += DeltaSeconds;
			}
			else
			{
				/* Reset prediction */
				TimeSinceLastIncrement = 0;
			}

			/* Predict the movement of the sun to smooth out the rotations between replication updates of the actual time of day */
			const float PredictedIncrement = MyGameState->GetTimeOfDayIncrement() * TimeSinceLastIncrement;

			/* TimeOfDay is expressed in minutes, we need to convert this into a pitch rotation */
			const float MinutesInDay = 24 * 60;
			const float PitchOffset = 90; // The offset to account for time of day 0 should equal midnight
			const float PitchRotation = 360 * ((MyGameState->ElapsedGameMinutes + PredictedIncrement) / MinutesInDay);

			FRotator NewSunRotation = FRotator(PitchRotation + PitchOffset, 45.0f, 0);
			PrimarySunLight->SetActorRelativeRotation(NewSunRotation);

			LastTimeOfDay = MyGameState->ElapsedGameMinutes;
		}

		bool CurrentNightState = MyGameState->GetIsNight();
		if (CurrentNightState != LastNightState)
		{
			if (CurrentNightState)
			{
				UGameplayStatics::PlaySound2D(this, SoundNightStarted);
				TargetSunBrightness = 0.01f;
			}
			else
			{
				UGameplayStatics::PlaySound2D(this, SoundNightEnded);
				TargetSunBrightness = OriginalSunBrightness;
			}

			/* Change to a new ambient loop */
			PlayAmbientLoop();
		}

		/* Update sun brightness to transition between day and night
			(Note: We cannot disable the sunlight because BP_SkySphere depends on an enabled light to update the skydome) */
		const float LerpSpeed = 0.1f * GetWorldSettings()->GetEffectiveTimeDilation();
		float CurrentSunBrightness = PrimarySunLight->GetBrightness();
		float NewSunBrightness = FMath::Lerp(CurrentSunBrightness, TargetSunBrightness, LerpSpeed);
		PrimarySunLight->SetBrightness(NewSunBrightness);

		LastNightState = CurrentNightState;
	}

	UpdateSkylight();
}


void ASTimeOfDayManager::UpdateSkylight()
{
	if (SkyLightActor)
	{
		ASGameState* MyGameState = Cast<ASGameState>(GetWorld()->GetGameState());
		if (MyGameState)
		{
			const float MinutesInDay = 24 * 60;
			const float PredictedIncrement = MyGameState->GetTimeOfDayIncrement() * TimeSinceLastIncrement;

			float CurrentTime = MyGameState->GetElapsedMinutesCurrentDay() + PredictedIncrement;

			/* Map the intensity from 0 - 12 - 24 hours into 0 - 1 - 0 alpha */
			const float Alpha = FMath::Sin((CurrentTime / MinutesInDay) * 3.14);

			/* Update Intensity */
			float NewIntensity = FMath::Lerp(0.1, 1.0, Alpha);
			if (SkylightIntensityCurve)
			{
				// If curve is specified, override the basic interp from above
				NewIntensity = SkylightIntensityCurve->GetFloatValue(Alpha);
			}
			SkyLightActor->GetLightComponent()->SetIntensity(NewIntensity);

			//UE_LOG(LogTemp, Warning, TEXT("Time of day alpha: %s"), *FString::SanitizeFloat(Alpha));

			FLinearColor LightColor = SkyLightActor->GetLightComponent()->GetLightColor();
			if (SkylightColorCurve)
			{
				LightColor = SkylightColorCurve->GetLinearColorValue(Alpha);
			}
			SkyLightActor->GetLightComponent()->SetLightColor(LightColor);
		}
	}
}


void ASTimeOfDayManager::PlayAmbientLoop()
{
	AmbientAudioComp->Stop();

	ASGameState* MyGameState = Cast<ASGameState>(GetWorld()->GetGameState());
	if (MyGameState)
	{
		if (MyGameState->GetIsNight())
		{
			AmbientAudioComp->SetSound(AmbientNight);
		}
		else
		{
			AmbientAudioComp->SetSound(AmbientDaytime);
		}
	}

	AmbientAudioComp->Play();
}

```

`SurvivalGame/Source/SurvivalGame/Public/AI/BTTask_FindBotWaypoint.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "BehaviorTree/Tasks/BTTask_BlackboardBase.h"
#include "BTTask_FindBotWaypoint.generated.h"

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API UBTTask_FindBotWaypoint : public UBTTask_BlackboardBase
{
	GENERATED_BODY()

	virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;
	
};

```

`SurvivalGame/Source/SurvivalGame/Public/AI/BTTask_FindPatrolLocation.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "BehaviorTree/Tasks/BTTask_BlackboardBase.h"
#include "BTTask_FindPatrolLocation.generated.h"

/**
* Blackboard Task - Finds a position to a nearby waypoint
*/
UCLASS()
class SURVIVALGAME_API UBTTask_FindPatrolLocation : public UBTTask_BlackboardBase
{
	GENERATED_BODY()	

	virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;

};

```

`SurvivalGame/Source/SurvivalGame/Public/AI/SBotWaypoint.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Engine/TargetPoint.h"
#include "SBotWaypoint.generated.h"

/**
 * Waypoint helper for bots to generate waypoints during patrols. Object is placed in level to specify a potential patrol target location.
 */
UCLASS()
class SURVIVALGAME_API ASBotWaypoint : public ATargetPoint
{
	GENERATED_BODY()
	
	
	
	
};

```

`SurvivalGame/Source/SurvivalGame/Public/AI/SZombieAIController.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "AIController.h"
#include "SurvivalGame/STypes.h"
#include "SZombieAIController.generated.h"

class UBehaviorTreeComponent;
class ASBaseCharacter;

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASZombieAIController : public AAIController
{
	GENERATED_BODY()

	ASZombieAIController();

	/* Called whenever the controller possesses a character bot */
	virtual void OnPossess(class APawn* InPawn) override;

	virtual void OnUnPossess() override;

	UBehaviorTreeComponent* BehaviorComp;

	UBlackboardComponent* BlackboardComp;

	UPROPERTY(EditDefaultsOnly, Category = "AI")
	FName TargetEnemyKeyName;

	UPROPERTY(EditDefaultsOnly, Category = "AI")
	FName PatrolLocationKeyName;

	UPROPERTY(EditDefaultsOnly, Category = "AI")
	FName CurrentWaypointKeyName;

	UPROPERTY(EditDefaultsOnly, Category = "AI")
	FName BotTypeKeyName;

public:

	AActor* GetWaypoint() const;

	ASBaseCharacter* GetTargetEnemy() const;

	void SetWaypoint(AActor* NewWaypoint);

	void SetTargetEnemy(APawn* NewTarget);

	void SetBlackboardBotType(EBotBehaviorType NewType);

	/** Returns BehaviorComp subobject **/
	FORCEINLINE UBehaviorTreeComponent* GetBehaviorComp() const { return BehaviorComp; }

	FORCEINLINE UBlackboardComponent* GetBlackboardComp() const { return BlackboardComp; }
};

```

`SurvivalGame/Source/SurvivalGame/Public/AI/SZombieCharacter.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Player/SBaseCharacter.h"
#include "SZombieCharacter.generated.h"

class USoundCue;

UCLASS(ABSTRACT)
class SURVIVALGAME_API ASZombieCharacter : public ASBaseCharacter
{
	GENERATED_BODY()

	/* Last time the player was spotted */
	float LastSeenTime;

	/* Last time the player was heard */
	float LastHeardTime;

	/* Last time we attacked something */
	float LastMeleeAttackTime;

	/* Time-out value to clear the sensed position of the player. Should be higher than Sense interval in the PawnSense component not never miss sense ticks. */
	UPROPERTY(EditDefaultsOnly, Category = "AI")
	float SenseTimeOut;

	/* Resets after sense time-out to avoid unnecessary clearing of target each tick */
	bool bSensedTarget;

	UPROPERTY(VisibleAnywhere, Category = "AI")
	class UPawnSensingComponent* PawnSensingComp;

	virtual void BeginPlay() override;

	virtual void Tick(float DeltaSeconds) override;

protected:

	virtual bool IsSprinting() const override;

	/* Triggered by pawn sensing component when a pawn is spotted */
	/* When using functions as delegates they need to be marked with UFUNCTION(). We assign this function to FSeePawnDelegate */
	UFUNCTION()
	void OnSeePlayer(APawn* Pawn);
	
	UFUNCTION()
	void OnHearNoise(APawn* PawnInstigator, const FVector& Location, float Volume);

	/* Deal damage to the Actor that was hit by the punch animation */
	UFUNCTION(BlueprintCallable, Category = "Attacking")
	void PerformMeleeStrike(AActor* HitActor);

	UFUNCTION(BlueprintCallable, Reliable, NetMulticast)
	void SimulateMeleeStrike();

	void SimulateMeleeStrike_Implementation();

	UPROPERTY(EditDefaultsOnly, Category = "Attacking")
	TSubclassOf<UDamageType> PunchDamageType;

	UPROPERTY(EditDefaultsOnly, Category = "Attacking")
	float MeleeDamage;

	UPROPERTY(EditDefaultsOnly, Category = "Attacking")
	UAnimMontage* MeleeAnimMontage;

	/* Update the vocal loop of the zombie (idle, wandering, hunting) */
	UFUNCTION(Reliable, NetMulticast)
	void BroadcastUpdateAudioLoop(bool bNewSensedTarget);

	void BroadcastUpdateAudioLoop_Implementation(bool bNewSensedTarget);

	UAudioComponent* PlayCharacterSound(USoundCue* CueToPlay);

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* SoundPlayerNoticed;

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* SoundHunting;

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* SoundIdle;

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* SoundWandering;

	UPROPERTY(EditDefaultsOnly, Category = "Sound") 
	USoundCue* SoundAttackMelee;

	/* Plays the idle, wandering or hunting sound */
	UPROPERTY(VisibleAnywhere, Category = "Sound")
	UAudioComponent* AudioLoopComp;

	virtual void PlayHit(float DamageTaken, struct FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser, bool bKilled) override;

public:

	ASZombieCharacter(const class FObjectInitializer& ObjectInitializer);

	UPROPERTY(BlueprintReadWrite, Category = "Attacking")
	bool bIsPunching;
	
	/* The bot behavior we want this bot to execute, (passive/patrol) by specifying EditAnywhere we can edit this value per-instance when placed on the map. */
	UPROPERTY(EditAnywhere, Category = "AI")
	EBotBehaviorType BotType;

	/* The thinking part of the brain, steers our zombie and makes decisions based on the data we feed it from the Blackboard */
	/* Assigned at the Character level (instead of Controller) so we may use different zombie behaviors while re-using one controller. */
	UPROPERTY(EditDefaultsOnly, Category = "AI")
	class UBehaviorTree* BehaviorTree;

	/* Change default bot type during gameplay */
	void SetBotType(EBotBehaviorType NewType);
};

```

`SurvivalGame/Source/SurvivalGame/Public/Components/SCarryObjectComponent.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/SpringArmComponent.h"
#include "SCarryObjectComponent.generated.h"

/**
 * 
 */
UCLASS(ClassGroup = (Survival), meta = (BlueprintSpawnableComponent))
class SURVIVALGAME_API USCarryObjectComponent : public USpringArmComponent
{
	GENERATED_BODY()

	USCarryObjectComponent();

private:

	AActor* GetActorInView();

	AActor* GetCarriedActor();

	/* Return the StaticMeshComponent of the carried Actor */
	UStaticMeshComponent* GetCarriedMeshComp();

protected:

	void TickComponent(float DeltaSeconds, enum ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction) override;

	/* Rotation speed */
	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	float RotateSpeed;

	void RotateActorAroundPoint(AActor* RotateActor, FVector RotationPoint, FRotator AddRotation);

public:

	UPROPERTY(EditDefaultsOnly, Category = "Pickup")
	float MaxPickupDistance;

	/* Attach the current view focus object that is allowed to be picked up to the spring arm */
	void Pickup();

	UFUNCTION(Server, Reliable, WithValidation)
	void ServerPickup();

	void ServerPickup_Implementation();

	bool ServerPickup_Validate();

	UFUNCTION(Reliable, NetMulticast)
	void OnPickupMulticast(AActor* FocusActor);

	void OnPickupMulticast_Implementation(AActor* FocusActor);

	/* Release the currently attached object, if not blocked by environment */
	void Drop();

	UFUNCTION(Server, Reliable, WithValidation)
	void ServerDrop();

	void ServerDrop_Implementation();

	bool ServerDrop_Validate();

	UFUNCTION(Reliable, NetMulticast)
	void OnDropMulticast();

	void OnDropMulticast_Implementation();

	/* Throw any currently carried Actor in the current view direction */
	void Throw();

	UFUNCTION(Server, Reliable, WithValidation)
	void ServerThrow();

	void ServerThrow_Implementation();

	bool ServerThrow_Validate();

	/* Is currently holding an Actor */
	bool GetIsCarryingActor();

	/* Rotate the carried Actor */
	void Rotate(float DirectionYaw, float DirectionRoll);

	UFUNCTION(Server, Reliable, WithValidation)
	void ServerRotate(float DirectionYaw, float DirectionRoll);

	void ServerRotate_Implementation(float DirectionYaw, float DirectionRoll);

	bool ServerRotate_Validate(float DirectionYaw, float DirectionRoll);

	UFUNCTION(Reliable, NetMulticast)
	void OnRotateMulticast(float DirectionYaw, float DirectionRoll);

	void OnRotateMulticast_Implementation(float DirectionYaw, float DirectionRoll);
};

```

`SurvivalGame/Source/SurvivalGame/Public/Components/SCharacterMovementComponent.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "SCharacterMovementComponent.generated.h"

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API USCharacterMovementComponent : public UCharacterMovementComponent
{
	GENERATED_BODY()

	virtual float GetMaxSpeed() const override;

};
```

`SurvivalGame/Source/SurvivalGame/Public/Core/SGameplayStatics.h`:

```h
// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "SGameplayStatics.generated.h"

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API USGameplayStatics : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
	
public:


	/* Project 3D to UI variation (of engine function) that adds bTargetBehindCamera. Does NOT account for viewport DPI  */
	UFUNCTION(BlueprintPure, Category = "UI")
	static bool ProjectWorldToScreenBidirectional(APlayerController const* Player, const FVector& WorldPosition, FVector2D& ScreenPosition,
			bool& bTargetBehindCamera, bool bPlayerViewportRelative = false);

};

```

`SurvivalGame/Source/SurvivalGame/Public/Editor/SoundNodeLocalPlayer.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Sound/SoundNode.h"
#include "SoundNodeLocalPlayer.generated.h"

/**
* Choose different branch for sounds attached to locally controlled player
*
* Originates from ShooterGame project by Epic Games.
*/
UCLASS(hidecategories = Object, editinlinenew)
class SURVIVALGAME_API USoundNodeLocalPlayer : public USoundNode
{
	GENERATED_BODY()

	virtual void ParseNodes(FAudioDevice* AudioDevice, const UPTRINT NodeWaveInstanceHash, FActiveSound& ActiveSound, const FSoundParseParameters& ParseParams, TArray<FWaveInstance*>& WaveInstances) override;

	virtual void CreateStartingConnectors(void) override;

	virtual int32 GetMaxChildNodes() const override;

	virtual int32 GetMinChildNodes() const override;

#if WITH_EDITOR

	virtual FText GetInputPinName(int32 PinIndex) const override;

#endif

};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SBombActor.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "SUsableActor.h"
#include "SBombActor.generated.h"

class USoundCue;
class UParticleSystem;
class UAudioComponent;
class UParticleSystemComponent;

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASBombActor : public ASUsableActor
{
	GENERATED_BODY()

public:

	ASBombActor();

protected:

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

	/* Explode when taking damage*/
	virtual float TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser) override;

	UPROPERTY(VisibleDefaultsOnly)
	UParticleSystemComponent* ExplosionPCS;

	UPROPERTY(VisibleDefaultsOnly)
	UParticleSystemComponent* FuzePCS;

	UPROPERTY(VisibleDefaultsOnly)
	UAudioComponent* AudioComp;

	UPROPERTY(EditDefaultsOnly, Category = "Bomb|Effects")
	UParticleSystem* ExplosionFX;

	UPROPERTY(EditDefaultsOnly, Category = "Bomb|Effects")
	UParticleSystem* FuzeFX;

	UPROPERTY(EditDefaultsOnly, Category = "Bomb|Effects")
	USoundCue* ExplosionSound;

	UPROPERTY(EditDefaultsOnly, Category = "Bomb|Effects")
	USoundCue* FuzeSound;

	/* Is fuze lit and counting down */
	bool bIsFuzeActive;

	bool bExploded;

	/* Initial time on the fuze */
	UPROPERTY(EditDefaultsOnly, Category = "Bomb|Settings")
	float MaxFuzeTime;
	
	UPROPERTY(EditDefaultsOnly, Category = "Bomb|Settings")
	float ExplosionDamage;
	
	UPROPERTY(EditDefaultsOnly, Category = "Bomb|Settings")
	float ExplosionRadius;

	UPROPERTY(EditDefaultsOnly, Category = "Bomb|Settings")
	TSubclassOf<UDamageType> DamageType;

	/* Handle to manage the timer */
	FTimerHandle FuzeTimerHandle;

	/* Activates the bomb fuze */
	virtual void OnUsed(APawn* InstigatorPawn) override;
	
	/* Explode the bomb */
	void Explode();

	/* Blueprint function */
	UFUNCTION(BlueprintImplementableEvent)
	void K2_SimulateExplosion();

	/* Note: Marked unreliable as its non-gameplay VFX only */
	UFUNCTION(Unreliable, NetMulticast)
	void SimulateFuzeFX();

	/* Note: Marked unreliable as its non-gameplay VFX only */
	UFUNCTION(Unreliable, NetMulticast)
	void SimulateExplosion();
};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SConsumableActor.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Items/SPickupActor.h"
#include "SConsumableActor.generated.h"

/**
 * Base class for consumable (food) items. Consumable by players to restore energy
 */
UCLASS(ABSTRACT)
class SURVIVALGAME_API ASConsumableActor : public ASPickupActor
{
	GENERATED_BODY()

	ASConsumableActor();

protected:

	/* Consume item, restoring energy to player */
	virtual void OnUsed(APawn* InstigatorPawn) override;

	/* Amount of hitpoints restored and hunger reduced when consumed. */
	UPROPERTY(EditDefaultsOnly, Category = "Consumable")
	float Nutrition;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SDamageType.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/DamageType.h"
#include "SDamageType.generated.h"

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API USDamageType : public UDamageType
{
	GENERATED_BODY()

	USDamageType();

	/* Can player die from this damage type (eg. players don't die from hunger) */
	UPROPERTY(EditDefaultsOnly)
	bool bCanDieFrom;

	/* Damage modifier for headshot damage */
	UPROPERTY(EditDefaultsOnly)
	float HeadDmgModifier;

	UPROPERTY(EditDefaultsOnly)
	float LimbDmgModifier;

public:

	bool GetCanDieFrom() const;

	float GetHeadDamageModifier() const;

	float GetLimbDamageModifier() const;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SFlashlight.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Items/SWeapon.h"
#include "SFlashlight.generated.h"

/**
 * 
 */
UCLASS(ABSTRACT)
class SURVIVALGAME_API ASFlashlight : public ASWeapon
{
	GENERATED_BODY()

	ASFlashlight();

	virtual void BeginPlay() override;

private:

	/* Material instance to manipulate emissive on the flashlight instance  */
	class UMaterialInstanceDynamic* MatDynamic;
	
	UPROPERTY(EditDefaultsOnly, Category = "Material")
	FName EmissiveParamName;

	UPROPERTY(EditDefaultsOnly, Category = "Material")
	float MaxEmissiveIntensity;

	/* Last frame's emissive intensity for performance purposes */
	float LastEmissiveStrength;

public:

	UPROPERTY(EditDefaultsOnly)
	FName LightAttachPoint;

	UPROPERTY(Transient, ReplicatedUsing = OnRep_IsActive)
	bool bIsActive;

	UPROPERTY(VisibleDefaultsOnly)
	class UStaticMeshComponent* LightConeComp;

	UPROPERTY(VisibleDefaultsOnly)
	class USpotLightComponent* SpotLightComp;

	virtual void HandleFiring() override;

	virtual void OnEquipFinished() override;
	
	virtual void OnUnEquip() override;
	
	virtual void OnEnterInventory(ASCharacter* NewOwner);

	void UpdateLight(bool Enabled);

	UFUNCTION()
	void OnRep_IsActive();
};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SImpactEffect.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "SImpactEffect.generated.h"

UCLASS(ABSTRACT, Blueprintable)
class SURVIVALGAME_API ASImpactEffect : public AActor
{
	GENERATED_BODY()

protected:

	UParticleSystem* GetImpactFX(EPhysicalSurface SurfaceType) const;

	USoundCue* GetImpactSound(EPhysicalSurface SurfaceType) const;
	
public:	

	ASImpactEffect();

	virtual void PostInitializeComponents() override;

	/* FX spawned on standard materials */
	UPROPERTY(EditDefaultsOnly)
	UParticleSystem* DefaultFX;

	UPROPERTY(EditDefaultsOnly)
	UParticleSystem* PlayerFleshFX;

	UPROPERTY(EditDefaultsOnly)
	UParticleSystem* ZombieFleshFX;

	UPROPERTY(EditDefaultsOnly)
	USoundCue* DefaultSound;

	UPROPERTY(EditDefaultsOnly)
	USoundCue* PlayerFleshSound;

	UPROPERTY(EditDefaultsOnly)
	USoundCue* ZombieFleshSound;

	UPROPERTY(EditDefaultsOnly, Category = "Decal")
	UMaterial* DecalMaterial;

	UPROPERTY(EditDefaultsOnly, Category = "Decal")
	float DecalSize;

	UPROPERTY(EditDefaultsOnly, Category = "Decal")
	float DecalLifeSpan;

	FHitResult SurfaceHit;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SPickupActor.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "SUsableActor.h"
#include "SPickupActor.generated.h"

/**
 * 
 */
UCLASS(ABSTRACT)
class SURVIVALGAME_API ASPickupActor : public ASUsableActor
{
	GENERATED_BODY()

	void BeginPlay() override;

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* PickupSound;

	UFUNCTION()
	void OnRep_IsActive();

protected:

	ASPickupActor();

	UPROPERTY(Transient, ReplicatedUsing = OnRep_IsActive)
	bool bIsActive;

	virtual void RespawnPickup();

	virtual void OnPickedUp();

	virtual void OnRespawned();

public:

	virtual void OnUsed(APawn* InstigatorPawn) override;

	/* Immediately spawn on begin play */
	UPROPERTY(EditDefaultsOnly, Category = "Pickup")
	bool bStartActive;

	/* Will this item ever respawn */
	UPROPERTY(EditDefaultsOnly, Category = "Pickup")
	bool bAllowRespawn;

	UPROPERTY(EditDefaultsOnly, Category = "Pickup")
	float RespawnDelay;

	/* Extra delay randomly applied on the respawn timer */
	UPROPERTY(EditDefaultsOnly, Category = "Pickup")
	float RespawnDelayRange;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SUsableActor.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "SUsableActor.generated.h"

UCLASS(ABSTRACT)
class SURVIVALGAME_API ASUsableActor : public AActor
{
	GENERATED_BODY()

protected:

	ASUsableActor();

	UPROPERTY(VisibleAnywhere, Category = "Mesh")
	UStaticMeshComponent* MeshComp;

public:

	/* Player is looking at */
	virtual void OnBeginFocus();

	/* Player is no longer looking at */
	virtual void OnEndFocus();

	/* Called when player interacts with object */
	virtual void OnUsed(APawn* InstigatorPawn);
	
	/* Public accessor to the mesh component. With FORCEINLINE we are allowed to define the function in the header, use this only for simple accessors! */
	FORCEINLINE UStaticMeshComponent* GetMeshComponent() const
	{
		return MeshComp;
	}
};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SWeapon.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Player/SCharacter.h"
#include "SWeapon.generated.h"

UENUM()
enum class EWeaponState
{
	Idle,
	Firing,
	Equipping,
	Reloading
};

/**
 * 
 */
UCLASS(ABSTRACT, Blueprintable)
class SURVIVALGAME_API ASWeapon : public AActor
{
	GENERATED_BODY()

	virtual void PostInitializeComponents() override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

	float GetEquipStartedTime() const;

	float GetEquipDuration() const;

	/** last time when this weapon was switched to */
	float EquipStartedTime;

	/** how much time weapon needs to be equipped */
	float EquipDuration;

	bool bIsEquipped;

	bool bPendingEquip;

	FTimerHandle TimerHandle_HandleFiring;

	FTimerHandle EquipFinishedTimerHandle;

	UPROPERTY(EditDefaultsOnly, Category = "Weapon")
	float ShotsPerMinute;

protected:

	ASWeapon();

	/* The character socket to store this item at. */
	UPROPERTY(EditDefaultsOnly, Category = "Weapon")
	EInventorySlot StorageSlot;

	/** pawn owner */
	UPROPERTY(Transient, ReplicatedUsing = OnRep_MyPawn)
	class ASCharacter* MyPawn;

	/** weapon mesh: 3rd person view */
	UPROPERTY(VisibleDefaultsOnly, Category = Mesh)
	USkeletalMeshComponent* Mesh;

	UFUNCTION()
	void OnRep_MyPawn();

	/** detaches weapon mesh from pawn */
	void DetachMeshFromPawn();

	virtual void OnEquipFinished();

	bool IsEquipped() const;

	bool IsAttachedToPawn() const;

public:

	/** get weapon mesh (needs pawn owner to determine variant) */
	UFUNCTION(BlueprintCallable, Category = "Weapon")
	USkeletalMeshComponent* GetWeaponMesh() const;

	virtual void OnUnEquip();

	void OnEquip(bool bPlayAnimation);

	/* Set the weapon's owning pawn */
	void SetOwningPawn(ASCharacter* NewOwner);

	/* Get pawn owner */
	UFUNCTION(BlueprintCallable, Category = "Weapon")
	class ASCharacter* GetPawnOwner() const;

	virtual void OnEnterInventory(ASCharacter* NewOwner);

	virtual void OnLeaveInventory();

	FORCEINLINE EInventorySlot GetStorageSlot()
	{
		return StorageSlot;
	}

	/* The class to spawn in the level when dropped */
	UPROPERTY(EditDefaultsOnly, Category = "Weapon")
	TSubclassOf<class ASWeaponPickup> WeaponPickupClass;

	/************************************************************************/
	/* Fire & Damage Handling                                               */
	/************************************************************************/

public:

	void StartFire();

	void StopFire();

	EWeaponState GetCurrentState() const;

	/* You can assign default values to function parameters, these are then optional to specify/override when calling the function. */
	void AttachMeshToPawn(EInventorySlot Slot = EInventorySlot::Hands);

protected:

	bool CanFire() const;

	FVector GetAdjustedAim() const;

	FVector GetCameraDamageStartLocation(const FVector& AimDir) const;

	FHitResult WeaponTrace(const FVector& TraceFrom, const FVector& TraceTo) const;

	/* With PURE_VIRTUAL we skip implementing the function in SWeapon.cpp and can do this in SWeaponInstant.cpp / SFlashlight.cpp instead */
	virtual void FireWeapon() PURE_VIRTUAL(ASWeapon::FireWeapon, );

private:

	void SetWeaponState(EWeaponState NewState);

	void DetermineWeaponState();

	virtual void HandleFiring();

	UFUNCTION(Reliable, Server, WithValidation)
	void ServerStartFire();

	void ServerStartFire_Implementation();

	bool ServerStartFire_Validate();

	UFUNCTION(Reliable, Server, WithValidation)
	void ServerStopFire();

	void ServerStopFire_Implementation();

	bool ServerStopFire_Validate();

	UFUNCTION(Reliable, Server, WithValidation)
	void ServerHandleFiring();

	void ServerHandleFiring_Implementation();

	bool ServerHandleFiring_Validate();

	void OnBurstStarted();

	void OnBurstFinished();

	bool bWantsToFire;

	EWeaponState CurrentState;

	bool bRefiring;

	float LastFireTime;

	/* Time between shots for repeating fire */
	float TimeBetweenShots;

	/************************************************************************/
	/* Simulation & FX                                                      */
	/************************************************************************/

private:

	UFUNCTION()
	void OnRep_BurstCounter();

	UPROPERTY(EditDefaultsOnly, Category = "Sounds")
	USoundCue* FireSound;

	UPROPERTY(EditDefaultsOnly, Category = "Sounds")
	USoundCue* EquipSound;

	UPROPERTY(EditDefaultsOnly)
	UParticleSystem* MuzzleFX;

	UPROPERTY(EditDefaultsOnly)
	UAnimMontage* EquipAnim;

	UPROPERTY(EditDefaultsOnly)
	UAnimMontage* FireAnim;

	UPROPERTY(Transient)
	UParticleSystemComponent* MuzzlePSC;

	UPROPERTY(EditDefaultsOnly)
	FName MuzzleAttachPoint;

	bool bPlayingFireAnim;

	UPROPERTY(Transient, ReplicatedUsing=OnRep_BurstCounter)
	int32 BurstCounter;

protected:

	virtual void SimulateWeaponFire();

	virtual void StopSimulatingWeaponFire();

	FVector GetMuzzleLocation() const;

	FVector GetMuzzleDirection() const;

	UAudioComponent* PlayWeaponSound(USoundCue* SoundToPlay);

	float PlayWeaponAnimation(UAnimMontage* Animation, float InPlayRate = 1.f, FName StartSectionName = NAME_None);

	void StopWeaponAnimation(UAnimMontage* Animation);

	/************************************************************************/
	/* Ammo & Reloading                                                     */
	/************************************************************************/

private:

	UPROPERTY(EditDefaultsOnly, Category = "Sounds")
	USoundCue* OutOfAmmoSound;

	FTimerHandle TimerHandle_ReloadWeapon;

	FTimerHandle TimerHandle_StopReload;

protected:

	/* Time to assign on reload when no animation is found */
	UPROPERTY(EditDefaultsOnly, Category = "Animation")
	float NoAnimReloadDuration;

	/* Time to assign on equip when no animation is found */
	UPROPERTY(EditDefaultsOnly, Category = "Animation")
	float NoEquipAnimDuration;

	UPROPERTY(Transient, ReplicatedUsing = OnRep_Reload)
	bool bPendingReload;

	void UseAmmo();

	UPROPERTY(Transient, Replicated)
	int32 CurrentAmmo;

	UPROPERTY(Transient, Replicated)
	int32 CurrentAmmoInClip;

	/* Weapon ammo on spawn */
	UPROPERTY(EditDefaultsOnly)
	int32 StartAmmo;

	UPROPERTY(EditDefaultsOnly)
	int32 MaxAmmo;

	UPROPERTY(EditDefaultsOnly)
	int32 MaxAmmoPerClip;

	UPROPERTY(EditDefaultsOnly, Category = "Sounds")
	USoundCue* ReloadSound;

	UPROPERTY(EditDefaultsOnly, Category = "Animation")
	UAnimMontage* ReloadAnim;

	virtual void ReloadWeapon();

	/* Trigger reload from server */
	UFUNCTION(Reliable, Client)
	void ClientStartReload();

	void ClientStartReload_Implementation();

	/* Is weapon and character currently capable of starting a reload */
	bool CanReload();

	UFUNCTION()
	void OnRep_Reload();

	UFUNCTION(reliable, server, WithValidation)
	void ServerStartReload();

	void ServerStartReload_Implementation();

	bool ServerStartReload_Validate();

	UFUNCTION(reliable, server, WithValidation)
	void ServerStopReload();

	void ServerStopReload_Implementation();

	bool ServerStopReload_Validate();

public:

	virtual void StartReload(bool bFromReplication = false);

	virtual void StopSimulateReload();

	/* Give ammo to weapon and return the amount that was not 'consumed' beyond the max count */
	int32 GiveAmmo(int32 AddAmount);

	/* Set a new total amount of ammo of weapon */
	void SetAmmoCount(int32 NewTotalAmount);

	UFUNCTION(BlueprintCallable, Category = "Ammo")
	int32 GetCurrentAmmo() const;

	UFUNCTION(BlueprintCallable, Category = "Ammo")
	int32 GetCurrentAmmoInClip() const;

	UFUNCTION(BlueprintCallable, Category = "Ammo")
	int32 GetMaxAmmoPerClip() const;

	UFUNCTION(BlueprintCallable, Category = "Ammo")
	int32 GetMaxAmmo() const;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SWeaponInstant.h`:

```h
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Items/SWeapon.h"
#include "SWeaponInstant.generated.h"

/**
 * 
 */
UCLASS(Abstract)
class SURVIVALGAME_API ASWeaponInstant : public ASWeapon
{
	GENERATED_BODY()

private:

	/************************************************************************/
	/* Visual Handlers                                                      */
	/************************************************************************/

	void SimulateInstantHit(const FVector& ImpactPoint);

	void SpawnImpactEffects(const FHitResult& Impact);

	void SpawnTrailEffects(const FVector& EndPoint);

	/* Particle FX played when a surface is hit. */
 	UPROPERTY(EditDefaultsOnly)
 	TSubclassOf<class ASImpactEffect> ImpactTemplate;

	UPROPERTY(EditDefaultsOnly)
	FName TrailTargetParam;

	UPROPERTY(EditDefaultsOnly)
	UParticleSystem* TrailFX;

	UPROPERTY(EditDefaultsOnly)
	UParticleSystem* TracerFX;

	/* Minimum firing distance before spawning tracers or trails. */
	UPROPERTY(EditDefaultsOnly)
	float MinimumProjectileSpawnDistance;

	UPROPERTY(EditDefaultsOnly)
	int32 TracerRoundInterval;

	/* Keeps track of number of shots fired */
	int32 BulletsShotCount;

protected:

	ASWeaponInstant();

	/************************************************************************/
	/* Damage Processing                                                    */
	/************************************************************************/

	virtual void FireWeapon() override;

	void DealDamage(const FHitResult& Impact, const FVector& ShootDir);

	bool ShouldDealDamage(AActor* TestActor) const;

	void ProcessInstantHit(const FHitResult& Impact, const FVector& Origin, const FVector& ShootDir);

	void ProcessInstantHitConfirmed(const FHitResult& Impact, const FVector& Origin, const FVector& ShootDir);

	UFUNCTION(Reliable, Server, WithValidation)
	void ServerNotifyHit(const FHitResult Impact, FVector_NetQuantizeNormal ShootDir);

	void ServerNotifyHit_Implementation(const FHitResult Impact, FVector_NetQuantizeNormal ShootDir);

	bool ServerNotifyHit_Validate(const FHitResult Impact, FVector_NetQuantizeNormal ShootDir);

	UFUNCTION(Reliable, Server, WithValidation)
	void ServerNotifyMiss(FVector_NetQuantizeNormal ShootDir);

	void ServerNotifyMiss_Implementation(FVector_NetQuantizeNormal ShootDir);

	bool ServerNotifyMiss_Validate(FVector_NetQuantizeNormal ShootDir);

	UPROPERTY(Transient, ReplicatedUsing=OnRep_HitLocation)
	FVector HitImpactNotify;

	UFUNCTION()
	void OnRep_HitLocation();

	/************************************************************************/
	/* Weapon Configuration                                                 */
	/************************************************************************/

	UPROPERTY(EditDefaultsOnly)
	float HitDamage;

	UPROPERTY(EditDefaultsOnly)
	TSubclassOf<class UDamageType> DamageType;

	UPROPERTY(EditDefaultsOnly)
	float WeaponRange;

	/* Hit verification: threshold for dot product between view direction and hit direction */
	UPROPERTY(EditDefaultsOnly)
	float AllowedViewDotHitDir;

	/* Hit verification: scale for bounding box of hit actor */
	UPROPERTY(EditDefaultsOnly)
	float ClientSideHitLeeway;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Items/SWeaponPickup.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Items/SPickupActor.h"
#include "SWeaponPickup.generated.h"

/**
 * 
 */
UCLASS(Abstract)
class SURVIVALGAME_API ASWeaponPickup : public ASPickupActor
{
	GENERATED_BODY()

	ASWeaponPickup();

public:

	/* Class to add to inventory when picked up */
	UPROPERTY(EditDefaultsOnly, Category = "WeaponClass")
	TSubclassOf<class ASWeapon> WeaponClass;

	virtual void OnUsed(APawn* InstigatorPawn) override;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Mutators/SMutator.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Info.h"
#include "SMutator.generated.h"

/**
 * Base Mutator. Can add/modify/remove Actors in a level. Called in a chain by the GameMode class on each Actor during Begin Play of each Actor.
 */
UCLASS(Blueprintable, Abstract, Meta = (ChildCanTick))
class SURVIVALGAME_API ASMutator : public AInfo
{
	GENERATED_BODY()

public:

	UFUNCTION(BlueprintNativeEvent, BlueprintAuthorityOnly)
	void InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage);

	virtual void InitGame_Implementation(const FString& MapName, const FString& Options, FString& ErrorMessage);

	/* Next mutator in the chain */
	ASMutator* NextMutator;
	
	/** From UT: entry point for mutators modifying, replacing, or destroying Actors
	* return false to destroy Other
	* note that certain critical Actors such as PlayerControllers can't be destroyed, but we'll still call this code path to allow mutators
	* to change properties on them
	* MAKE SURE TO CALL SUPER TO PROCESS ADDITIONAL MUTATORS
	*/
	UFUNCTION(BlueprintNativeEvent, BlueprintAuthorityOnly)
	bool CheckRelevance(AActor* Other);

	/* Note: Functions flagged with BlueprintNativeEvent like above require _Implementation for a C++ implementation */
	virtual bool CheckRelevance_Implementation(AActor* Other);
	
};

```

`SurvivalGame/Source/SurvivalGame/Public/Mutators/SMutator_WeaponReplacement.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Mutators/SMutator.h"
#include "Items/SWeapon.h"
#include "SMutator_WeaponReplacement.generated.h"


USTRUCT(BlueprintType)
struct FReplacementInfo
{
	GENERATED_BODY()

public:

	/** class name of the weapon we want to get rid of */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weapon")
	TSubclassOf<ASWeapon> FromWeapon;
	/** fully qualified path of the class to replace it with */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weapon")
	TSubclassOf<ASWeapon> ToWeapon;

	FReplacementInfo()
		:FromWeapon(nullptr)
		, ToWeapon(nullptr)
	{
	}

	FReplacementInfo(TSubclassOf<ASWeapon> inOldClass, TSubclassOf<ASWeapon> inNewClass)
		: FromWeapon(inOldClass)
		, ToWeapon(inNewClass)
	{
	}

};

/**
 * Allows mutators to replace weapon pickups in the active level
 */
UCLASS(ABSTRACT)
class SURVIVALGAME_API ASMutator_WeaponReplacement : public ASMutator
{
	GENERATED_BODY()

public:

	virtual void InitGame_Implementation(const FString& MapName, const FString& Options, FString& ErrorMessage) override;

	virtual bool CheckRelevance_Implementation(AActor* Other) override;

	UPROPERTY(EditDefaultsOnly, Category = "WeaponReplacement")
	TArray<FReplacementInfo> WeaponsToReplace;
	
};

```

`SurvivalGame/Source/SurvivalGame/Public/Player/SBaseCharacter.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "SurvivalGame/STypes.h"
#include "SBaseCharacter.generated.h"

class USoundCue;

UCLASS(ABSTRACT)
class SURVIVALGAME_API ASBaseCharacter : public ACharacter
{
	GENERATED_BODY()

	/* Tracks noise data used by the pawn sensing component */
	UPawnNoiseEmitterComponent* NoiseEmitterComp;

public:
	// Sets default values for this character's properties
	ASBaseCharacter(const class FObjectInitializer& ObjectInitializer);

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* SoundTakeHit;

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* SoundDeath;

	/************************************************************************/
	/* Health                                                               */
	/************************************************************************/

	UFUNCTION(BlueprintCallable, Category = "PlayerCondition")
	float GetMaxHealth() const;

	UFUNCTION(BlueprintCallable, Category = "PlayerCondition")
	float GetHealth() const;

	UFUNCTION(BlueprintCallable, Category = "PlayerCondition")
	bool IsAlive() const;

	UFUNCTION(BlueprintCallable, Category = "Movement")
	virtual bool IsSprinting() const;

	/* Client/local call to update sprint state  */
	virtual void SetSprinting(bool NewSprinting);

	float GetSprintingSpeedModifier() const;

protected:

	UPROPERTY(EditDefaultsOnly, Category = "Movement")
	float SprintingSpeedModifier;

	/* Character wants to run, checked during Tick to see if allowed */
	UPROPERTY(Transient, Replicated)
	bool bWantsToRun;

	/* Server side call to update actual sprint state */
	UFUNCTION(Server, Reliable, WithValidation)
	void ServerSetSprinting(bool NewSprinting);

	void ServerSetSprinting_Implementation(bool NewSprinting);

	bool ServerSetSprinting_Validate(bool NewSprinting);

	/************************************************************************/
	/* Targeting                                                            */
	/************************************************************************/

	void SetTargeting(bool NewTargeting);

	UFUNCTION(Server, Reliable, WithValidation)
	void ServerSetTargeting(bool NewTargeting);

	void ServerSetTargeting_Implementation(bool NewTargeting);

	bool ServerSetTargeting_Validate(bool NewTargeting);

	UPROPERTY(Transient, Replicated)
	bool bIsTargeting;

	UPROPERTY(EditDefaultsOnly, Category = "Targeting")
	float TargetingSpeedModifier;

public:

	/* Is player aiming down sights */
	UFUNCTION(BlueprintCallable, Category = "Targeting")
	bool IsTargeting() const;

	float GetTargetingSpeedModifier() const;

	/* Retrieve Pitch/Yaw from current camera */
	UFUNCTION(BlueprintCallable, Category = "Targeting")
	FRotator GetAimOffsets() const;

	/************************************************************************/
	/* Damage & Death                                                       */
	/************************************************************************/

protected:

	UPROPERTY(EditDefaultsOnly, Category = "PlayerCondition", Replicated)
	float Health;

	/* Take damage & handle death */
	virtual float TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser) override;

	virtual bool CanDie(float KillingDamage, FDamageEvent const& DamageEvent, AController* Killer, AActor* DamageCauser) const;

	virtual bool Die(float KillingDamage, FDamageEvent const& DamageEvent, AController* Killer, AActor* DamageCauser);

	virtual void OnDeath(float KillingDamage, FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser);

	virtual void FellOutOfWorld(const class UDamageType& DmgType) override;

	void SetRagdollPhysics();

	virtual void PlayHit(float DamageTaken, struct FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser, bool bKilled);

	void ReplicateHit(float DamageTaken, struct FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser, bool bKilled);

	/* Holds hit data to replicate hits and death to clients */
	UPROPERTY(Transient, ReplicatedUsing = OnRep_LastTakeHitInfo)
	struct FTakeHitInfo LastTakeHitInfo;

	UFUNCTION()
	void OnRep_LastTakeHitInfo();

	bool bIsDying;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Player/SCharacter.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Player/SBaseCharacter.h"
#include "SCharacter.generated.h"

class UCameraComponent;
class USpringArmComponent;

UCLASS()
class SURVIVALGAME_API ASCharacter : public ASBaseCharacter
{
	GENERATED_BODY()

	ASCharacter(const class FObjectInitializer& ObjectInitializer);

	virtual void BeginPlay() override;

	/* Called every frame */
	virtual void Tick(float DeltaSeconds) override;

	/* Called to bind functionality to input */
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

	virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

	virtual void PawnClientRestart() override;

	/* Stop playing all montages */
	void StopAllAnimMontages();

	float LastNoiseLoudness;

	float LastMakeNoiseTime;

private:

	/* Boom to handle distance to player mesh. */
	UPROPERTY(VisibleAnywhere, Category = "Camera")
	USpringArmComponent* CameraBoomComp;

	/* Primary camera of the player*/
	UPROPERTY(VisibleAnywhere, Category = "Camera")
	UCameraComponent* CameraComp;

	UPROPERTY(VisibleAnywhere, Category = "Camera")
	class USCarryObjectComponent* CarriedObjectComp;

public:

	UFUNCTION(BlueprintCallable, Category = "AI")
	float GetLastNoiseLoudness();

	UFUNCTION(BlueprintCallable, Category = "AI")
	float GetLastMakeNoiseTime();

	FORCEINLINE UCameraComponent* GetCameraComponent()
	{
		return CameraComp;
	}

	/* MakeNoise hook to trigger AI noise emitting (Loudness between 0.0-1.0)  */
	UFUNCTION(BlueprintCallable, Category = "AI")
	void MakePawnNoise(float Loudness);

	/************************************************************************/
	/* Movement                                                             */
	/************************************************************************/

	virtual void MoveForward(float Val);

	virtual void MoveRight(float Val);

	/* Client mapped to Input */
	void OnCrouchToggle();

	/* Client mapped to Input */
	void OnJump();

	/* Client mapped to Input */
	void OnStartSprinting();

	/* Client mapped to Input */
	void OnStopSprinting();

	virtual void SetSprinting(bool NewSprinting) override;

	/* Is character currently performing a jump action. Resets on landed.  */
	UPROPERTY(Transient, Replicated)
	bool bIsJumping;

	UFUNCTION(BlueprintCallable, Category = "Movement")
	bool IsInitiatedJump() const;

	void SetIsJumping(bool NewJumping);

	UFUNCTION(Reliable, Server, WithValidation)
	void ServerSetIsJumping(bool NewJumping);

	void ServerSetIsJumping_Implementation(bool NewJumping);

	bool ServerSetIsJumping_Validate(bool NewJumping);

	virtual void OnMovementModeChanged(EMovementMode PrevMovementMode, uint8 PreviousCustomMode = 0) override;

	/************************************************************************/
	/* Object Interaction                                                   */
	/************************************************************************/

	/* Input mapped function for carry object component */
	void OnToggleCarryActor();

	/* Use the usable actor currently in focus, if any */
	virtual void Use();

	UFUNCTION(Server, Reliable, WithValidation)
	void ServerUse();

	void ServerUse_Implementation();

	bool ServerUse_Validate();

	class ASUsableActor* GetUsableInView() const;

	/*Max distance to use/focus on actors. */
	UPROPERTY(EditDefaultsOnly, Category = "ObjectInteraction")
	float MaxUseDistance;

	/* True only in first frame when focused on a new usable actor. */
	bool bHasNewFocus;

	class ASUsableActor* FocusedUsableActor;

	/************************************************************************/
	/* Targeting                                                            */
	/************************************************************************/

	void OnStartTargeting();

	void OnEndTargeting();

	/************************************************************************/
	/* Hunger                                                               */
	/************************************************************************/

	UFUNCTION(BlueprintCallable, Category = "PlayerCondition")
	float GetHunger() const;

	UFUNCTION(BlueprintCallable, Category = "PlayerCondition")
	float GetMaxHunger() const;

	UFUNCTION(BlueprintCallable, Category = "PlayerCondition")
	void RestoreCondition(float HealthRestored, float HungerRestored);

	/* Increments hunger, used by timer. */
	void IncrementHunger();

	UPROPERTY(EditDefaultsOnly, Category = "PlayerCondition")
	float IncrementHungerInterval;

	UPROPERTY(EditDefaultsOnly, Category = "PlayerCondition")
	float IncrementHungerAmount;

	/* Limit when player suffers Hitpoints from extreme hunger */
	UPROPERTY(BlueprintReadOnly, Category = "PlayerCondition")
	float CriticalHungerThreshold;

	UPROPERTY(EditDefaultsOnly, Category = "PlayerCondition", Replicated)
	float Hunger;

	// Documentation Note: MaxHunger does not need to be replicated, only values that change and are displayed or used by clients should ever be replicated.
	UPROPERTY(EditDefaultsOnly, Category = "PlayerCondition")
	float MaxHunger;
	
	UPROPERTY(EditDefaultsOnly, Category = "PlayerCondition")
	float HungerDamagePerInterval;

	/* Damage type applied when player suffers critical hunger */
	UPROPERTY(EditDefaultsOnly, Category = "PlayerCondition")
	TSubclassOf<UDamageType> HungerDamageType;

	/************************************************************************/
	/* Damage & Death                                                       */
	/************************************************************************/

	virtual void OnDeath(float KillingDamage, FDamageEvent const& DamageEvent, APawn* PawnInstigator, AActor* DamageCauser) override;

	virtual void Suicide();

	virtual void KilledBy(class APawn* EventInstigator);

	/************************************************************************/
	/* Weapons & Inventory                                                  */
	/************************************************************************/

private:

	/* Attachpoint for active weapon/item in hands */
	UPROPERTY(EditDefaultsOnly, Category = "Sockets")
	FName WeaponAttachPoint;

	/* Attachpoint for items carried on the belt/pelvis. */
	UPROPERTY(EditDefaultsOnly, Category = "Sockets")
	FName PelvisAttachPoint;

	/* Attachpoint for primary weapons */
	UPROPERTY(EditDefaultsOnly, Category = "Sockets")
	FName SpineAttachPoint;

	bool bWantsToFire;

	/* Distance away from character when dropping inventory items. */
	UPROPERTY(EditDefaultsOnly, Category = "Inventory")
	float DropWeaponMaxDistance;

	void OnReload();

	/* Mapped to input */
	void OnStartFire();

	/* Mapped to input */
	void OnStopFire();

	/* Mapped to input */
	void OnNextWeapon();

	/* Mapped to input */
	void OnPrevWeapon();

	/* Mapped to input */
	void OnEquipPrimaryWeapon();

	/* Mapped to input */
	void OnEquipSecondaryWeapon();

	void StartWeaponFire();

	void StopWeaponFire();

	void DestroyInventory();

	/* Mapped to input. Drops current weapon */
	void DropWeapon();

	UFUNCTION(Reliable, Server, WithValidation)
	void ServerDropWeapon();

	void ServerDropWeapon_Implementation();

	bool ServerDropWeapon_Validate();

public:

	UFUNCTION(BlueprintCallable, Category = "Weapon")
	ASWeapon* GetCurrentWeapon() const;

	/* Check if the specified slot is available, limited to one item per type (primary, secondary) */
	bool WeaponSlotAvailable(EInventorySlot CheckSlot);

	/* Check if pawn is allowed to fire weapon */
	bool CanFire() const;

	bool CanReload() const;

	UFUNCTION(BlueprintCallable, Category = "Weapon")
	bool IsFiring() const;

	/* Return socket name for attachments (to match the socket in the character skeleton) */
	FName GetInventoryAttachPoint(EInventorySlot Slot) const;

	/* All weapons/items the player currently holds */
	UPROPERTY(Transient, Replicated)
	TArray<ASWeapon*> Inventory;

	void SetCurrentWeapon(class ASWeapon* newWeapon, class ASWeapon* LastWeapon = nullptr);

	void EquipWeapon(ASWeapon* Weapon);

	UFUNCTION(Reliable, Server, WithValidation)
	void ServerEquipWeapon(ASWeapon* Weapon);

	void ServerEquipWeapon_Implementation(ASWeapon* Weapon);

	bool ServerEquipWeapon_Validate(ASWeapon* Weapon);

	/* OnRep functions can use a parameter to hold the previous value of the variable. Very useful when you need to handle UnEquip etc. */
	UFUNCTION()
	void OnRep_CurrentWeapon(ASWeapon* LastWeapon);

	void AddWeapon(class ASWeapon* Weapon);

	void RemoveWeapon(class ASWeapon* Weapon, bool bDestroy);

	UPROPERTY(Transient, ReplicatedUsing = OnRep_CurrentWeapon)
	class ASWeapon* CurrentWeapon;

	UPROPERTY()
	class ASWeapon* PreviousWeapon;

	/* Update the weapon mesh to the newly equipped weapon, this is triggered during an anim montage.
		NOTE: Requires an AnimNotify created in the Equip animation to tell us when to swap the meshes. */
	UFUNCTION(BlueprintCallable, Category = "Animation")
	void SwapToNewWeaponMesh();
};

```

`SurvivalGame/Source/SurvivalGame/Public/Player/SLocalPlayer.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Engine/LocalPlayer.h"
#include "SLocalPlayer.generated.h"

/**
 * LocalPlayer defines a specific user when dealing with multiple players on a single machine (eg. local split-screen)
 */
UCLASS()
class SURVIVALGAME_API USLocalPlayer : public ULocalPlayer
{
	GENERATED_BODY()

	/* Set a player name if no online system like Steam is available */
	virtual FString GetNickname() const override;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Player/SPlayerCameraManager.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Camera/PlayerCameraManager.h"
#include "SPlayerCameraManager.generated.h"

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASPlayerCameraManager : public APlayerCameraManager
{
	GENERATED_BODY()

	ASPlayerCameraManager();

	/* Update the FOV */
	virtual void UpdateCamera(float DeltaTime) override;

	float CurrentCrouchOffset;

	/* Maximum camera offset applied when crouch is initiated. Always lerps back to zero */
	float MaxCrouchOffsetZ;

	float CrouchLerpVelocity;

	bool bWasCrouched;

	/* Default relative Z offset of the player camera */
	float DefaultCameraOffsetZ;

	/* default, hip fire FOV */
	float NormalFOV;

	/* aiming down sight / zoomed FOV */
	float TargetingFOV;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Player/SPlayerController.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerController.h"
#include "UI/SHUD.h"
#include "SPlayerController.generated.h"

UENUM()
enum class EHUDMessage : uint8
{
	/* Weapons */
	Weapon_SlotTaken,

	/* Character */
	Character_EnergyRestored,

	/* Gamemode */
	Game_SurviveStart,
	Game_SurviveEnded,

	/* No category specified */
	None,
};


DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FChatMessageReceived, class APlayerState*, Sender, const FString&, Message);

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASPlayerController : public APlayerController
{
	GENERATED_BODY()

	ASPlayerController();

	/* Flag to respawn or start spectating upon death */
	UPROPERTY(EditDefaultsOnly, Category = "Spawning")
	bool bRespawnImmediately;
	
	/* Respawn or start spectating after dying */
	virtual void UnFreeze() override;

	UFUNCTION(Reliable, Server, WithValidation)
	void ServerSuicide();

	void ServerSuicide_Implementation();

	bool ServerSuicide_Validate();

public:

	UFUNCTION(Reliable, Client)
	void ClientHUDStateChanged(EHUDState NewState);

	void ClientHUDStateChanged_Implementation(EHUDState NewState);

	/* Enum is remapped to localized text before sending it to the HUD */
	UFUNCTION(Reliable, Client)
	void ClientHUDMessage(EHUDMessage MessageID);

	void ClientHUDMessage_Implementation(EHUDMessage MessageID);

	FText GetText(EHUDMessage MsgID) const;

	/* Kill the current pawn */
	UFUNCTION(exec)
	virtual void Suicide();

	/* Start spectating. Should be called only on server */
	void StartSpectating();

public:

	// -- CHAT -- //

	UFUNCTION(BlueprintCallable, Server, Reliable, WithValidation)
	void ServerSendChatMessage(class APlayerState* Sender, const FString& Message);

	UFUNCTION(Client, Reliable)
	void ClientReceiveChatMessage(class APlayerState* Sender, const FString& Message);

	UPROPERTY(BlueprintAssignable)
	FChatMessageReceived OnChatMessageReceived;

};

```

`SurvivalGame/Source/SurvivalGame/Public/Player/SPlayerState.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerState.h"
#include "SPlayerState.generated.h"

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASPlayerState : public APlayerState
{
	GENERATED_BODY()

	ASPlayerState();

	UPROPERTY(Transient, Replicated)
	int32 NumKills;

	UPROPERTY(Transient, Replicated)
	int32 NumDeaths;

	/* Team number assigned to player */
	UPROPERTY(Transient, Replicated)
	int32 TeamNumber;

	virtual void Reset() override;

public: 

	void AddKill();

	void AddDeath();

	void ScorePoints(int32 Points);

	void SetTeamNumber(int32 NewTeamNumber);

	UFUNCTION(BlueprintCallable, Category = "Teams")
	int32 GetTeamNumber() const;

	UFUNCTION(BlueprintCallable, Category = "Score")
	int32 GetKills() const;

	UFUNCTION(BlueprintCallable, Category = "Score")
	int32 GetDeaths() const;
};

```

`SurvivalGame/Source/SurvivalGame/Public/Player/SSpectatorPawn.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/SpectatorPawn.h"
#include "SSpectatorPawn.generated.h"

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASSpectatorPawn : public ASpectatorPawn
{
	GENERATED_BODY()

	ASSpectatorPawn();
	
};

```

`SurvivalGame/Source/SurvivalGame/Public/UI/SHUD.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/HUD.h"
#include "Engine/Canvas.h"
#include "SHUD.generated.h"


/* Expose it to Blueprint using this tag */
UENUM(BlueprintType)
enum class EHUDState : uint8
{
	Playing,
	Spectating,
	MatchEnd
};


/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASHUD : public AHUD
{
	GENERATED_BODY()

	ASHUD();

	FCanvasIcon CenterDotIcon;

	/* Current HUD state */
	EHUDState CurrentState;

	/** Main HUD update loop. */
	virtual void DrawHUD() override;
	
	void DrawCenterDot();

public:

	UFUNCTION(BlueprintCallable, Category = "HUD")
	EHUDState GetCurrentState() const;

	/* An event hook to call HUD text events to display in the HUD. Blueprint HUD class must implement how to deal with this event. */
	UFUNCTION(BlueprintImplementableEvent, Category = "HUDEvents")
	void MessageReceived(const FText& TextMessage);

	/* Event hook to update HUD state (eg. to determine visibility of widgets) */
	UFUNCTION(BlueprintNativeEvent, Category = "HUDEvents")
	void OnStateChanged(EHUDState NewState);
};

```

`SurvivalGame/Source/SurvivalGame/Public/World/SCoopGameMode.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "SGameMode.h"
#include "SCoopGameMode.generated.h"

/**
 * 
 */
UCLASS(ABSTRACT)
class SURVIVALGAME_API ASCoopGameMode : public ASGameMode
{
	GENERATED_BODY()

	ASCoopGameMode();

	/* End the match when all players are dead */
	void CheckMatchEnd();

	/* End the match, with a delay before returning to the main menu */
	void FinishMatch();

	/* Spawn the player next to his living coop buddy instead of a PlayerStart */
	virtual void RestartPlayer(class AController* NewPlayer) override;

	virtual void OnNightEnded() override;

	/* Spawn at team player if any are alive */
	UPROPERTY(EditDefaultsOnly, Category = "Rules")
	bool bSpawnAtTeamPlayer;

	virtual void Killed(AController* Killer, AController* VictimPlayer, APawn* VictimPawn, const UDamageType* DamageType) override;

	/************************************************************************/
	/* Scoring                                                              */
	/************************************************************************/

	/* Points awarded for surviving a night */
	UPROPERTY(EditDefaultsOnly, Category = "Scoring")
	int32 ScoreNightSurvived;

};

```

`SurvivalGame/Source/SurvivalGame/Public/World/SGameInstance.h`:

```h
// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Engine/GameInstance.h"
#include "SGameInstance.generated.h"

class APlayerState;

// Event hook for any time a player is added/removed (triggers via GameState)
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FPlayerArrayChanged, APlayerState*, PlayerState);

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API USGameInstance : public UGameInstance
{
	GENERATED_BODY()
	
public:


	// Note: Added event hooks here since GameState is spawned 'late' on clients via replication 
	// (making it hard to know when you can hook onto it in widgets) and GameInstance always exists.

	/* New Player joined (runs on clients and server) */
	UPROPERTY(BlueprintAssignable, Category = "Game|Events")
	FPlayerArrayChanged OnPlayerStateAdded;

	/* Existing Player left (runs on clients and server) */
	UPROPERTY(BlueprintAssignable, Category = "Game|Events")
	FPlayerArrayChanged OnPlayerStateRemoved;


};

```

`SurvivalGame/Source/SurvivalGame/Public/World/SGameMode.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameMode.h"
#include "Mutators/SMutator.h"
#include "SGameMode.generated.h"

class ASPlayerState;
class APlayerStart;

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASGameMode : public AGameMode
{
	GENERATED_BODY()

protected:

	ASGameMode();

	virtual void PreInitializeComponents() override;

	virtual void InitGameState();

	virtual void DefaultTimer();
	
	virtual void StartMatch();

	virtual void OnNightEnded();

	virtual void SpawnDefaultInventory(APawn* PlayerPawn);
	
	/**
	* Make sure pawn properties are back to default
	* Also a good place to modify them on spawn
	*/
	virtual void SetPlayerDefaults(APawn* PlayerPawn) override;

	/* Handle for efficient management of DefaultTimer timer */
	FTimerHandle TimerHandle_DefaultTimer;

	/* Can we deal damage to players in the same team */
	UPROPERTY(EditDefaultsOnly, Category = "Rules")
	bool bAllowFriendlyFireDamage;

	/* Allow zombie spawns to be disabled (for debugging) */
	UPROPERTY(EditDefaultsOnly, Category = "Debug")
	bool bSpawnZombiesAtNight;

	/* Limit the amount of zombies to have at one point in the world (includes players) */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Debug")
	int32 MaxPawnsInZone;

	float BotSpawnInterval;

	/* Called once on every new player that enters the gamemode */
	virtual FString InitNewPlayer(class APlayerController* NewPlayerController, const FUniqueNetIdRepl& UniqueId, const FString& Options, const FString& Portal = TEXT("")) override;

	/* The teamnumber assigned to Players */
	int32 PlayerTeamNum;

	/* Keep reference to the night state of the previous frame */
	bool LastIsNight;

	/* The start time for the gamemode */
	int32 TimeOfDayStart;

	/* The enemy pawn class */
	UPROPERTY(EditDefaultsOnly, Category = "AI")
	TSubclassOf<class APawn> BotPawnClass;

	/* Handle for nightly bot spawning */
	FTimerHandle TimerHandle_BotSpawns;

	/* Handles bot spawning (during nighttime) */
	void SpawnBotHandler();

	/************************************************************************/
	/* Player Spawning                                                      */
	/************************************************************************/

	/* Don't allow spectating of bots */
	virtual bool CanSpectate_Implementation(APlayerController* Viewer, APlayerState* ViewTarget) override;

	virtual AActor* ChoosePlayerStart_Implementation(AController* Player) override;

	/* Always pick a random location */
	virtual bool ShouldSpawnAtStartSpot(AController* Player) override;

	virtual bool IsSpawnpointAllowed(APlayerStart* SpawnPoint, AController* Controller);

	virtual bool IsSpawnpointPreferred(APlayerStart* SpawnPoint, AController* Controller);

	/** returns default pawn class for given controller */
	virtual UClass* GetDefaultPawnClassForController_Implementation(AController* InController) override;

	/************************************************************************/
	/* Damage & Killing                                                     */
	/************************************************************************/

public: 

	virtual void Killed(AController* Killer, AController* VictimPlayer, APawn* VictimPawn, const UDamageType* DamageType);

	/* Can the player deal damage according to gamemode rules (eg. friendly-fire disabled) */
	virtual bool CanDealDamage(class ASPlayerState* DamageCauser, class ASPlayerState* DamagedPlayer) const;

	virtual float ModifyDamage(float Damage, AActor* DamagedActor, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser) const;

	/************************************************************************/
	/* Bots                                                                 */
	/************************************************************************/

protected:

	/* (Exec only valid when testing in Singleplayer) */
	UFUNCTION(BlueprintCallable, Exec, Category = "GameMode")
	void SpawnNewBot();

	/* Blueprint hook to find a good spawn location for BOTS (Eg. via EQS queries) */
	UFUNCTION(BlueprintImplementableEvent, Category = "GameMode")
	bool FindBotSpawnTransform(FTransform& Transform);

	/* Set all bots back to idle mode */
	void PassifyAllBots();

	/* Set all bots to active patrolling state */
	void WakeAllBots();

public:

	/* Primary sun of the level. Assigned in Blueprint during BeginPlay (BlueprintReadWrite is required as tag instead of EditDefaultsOnly) */
	UPROPERTY(BlueprintReadWrite, Category = "DayNight")
	class ADirectionalLight* PrimarySunLight;

	/* The default weapons to spawn with */
	UPROPERTY(EditDefaultsOnly, Category = "Player")
	TArray<TSubclassOf<class ASWeapon>> DefaultInventoryClasses;

	/************************************************************************/
	/* Modding & Mutators                                                   */
	/************************************************************************/

protected:

	/* Mutators to create when game starts */
 	UPROPERTY(EditAnywhere, Category = "Mutators")
 	TArray<TSubclassOf<class ASMutator>> MutatorClasses;

	/* First mutator in the execution chain */
	ASMutator* BaseMutator;

	void AddMutator(TSubclassOf<ASMutator> MutClass);

	virtual void InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage) override;

	/** From UT Source: Used to modify, remove, and replace Actors. Return false to destroy the passed in Actor. Default implementation queries mutators.
	* note that certain critical Actors such as PlayerControllers can't be destroyed, but we'll still call this code path to allow mutators
	* to change properties on them
	*/
	UFUNCTION(BlueprintNativeEvent)
	bool CheckRelevance(AActor* Other);

	/* Note: Functions flagged with BlueprintNativeEvent like above require _Implementation for a C++ implementation */
	virtual bool CheckRelevance_Implementation(AActor* Other);
};

```

`SurvivalGame/Source/SurvivalGame/Public/World/SGameState.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameState.h"
#include "SGameState.generated.h"

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASGameState : public AGameState
{
	GENERATED_BODY()

	/* Total accumulated score from all players  */
	UPROPERTY(Replicated)
	int32 TotalScore;

public:

	UFUNCTION(BlueprintCallable, Category = "Score")
	int32 GetTotalScore();

	void AddScore(int32 Score);

	ASGameState();

	UPROPERTY(Replicated)
	bool bIsNight;

	/* Time in wallclock hours the day begins */
	float SunriseTimeMark;

	/* Time in wallclock hours the night begins */
	float SunsetTimeMark;

	bool GetIsNight();

	bool GetAndUpdateIsNight();

	/* Current time of day in the gamemode represented in full minutes */
	UPROPERTY(BlueprintReadOnly, Replicated, Category = "TimeOfDay")
	int32 ElapsedGameMinutes;

	/* Conversion of 1 second real time to X seconds gametime of the day/night cycle */
	UPROPERTY(EditDefaultsOnly, Category = "TimeOfDay")
	float TimeScale;

	/* Returns the time of day increment every real second (converted to accelerated game time, eg. 1 real second is 1 minute in time of day increment) */
	float GetTimeOfDayIncrement();

	UFUNCTION(BlueprintCallable, Category = "TimeOfDay")
	int32 GetElapsedDays();

	/* Returns whole days elapsed, represented in minutes */
	UFUNCTION(BlueprintCallable, Category = "TimeOfDay")
	int32 GetElapsedFullDaysInMinutes();

	/* Return the time in real seconds till next sunrise */
	UFUNCTION(BlueprintCallable, Category = "TimeOfDay")
	int32 GetRealSecondsTillSunrise();

	int32 GetElapsedMinutesCurrentDay();

	/* By passing in "exec" we expose it as a command line (press ~ to open) */
	UFUNCTION(exec)
	void SetTimeOfDay(float NewHourOfDay);

	/* NetMulticast will send this event to all clients that know about this object, in the case of GameState that means every client. */
	UFUNCTION(Reliable, NetMulticast)
	void BroadcastGameMessage(EHUDMessage NewMessage);

	void BroadcastGameMessage_Implementation(EHUDMessage MessageID);

public:

	virtual void AddPlayerState(APlayerState* PlayerState) override;

	virtual void RemovePlayerState(APlayerState* PlayerState) override;

};

```

`SurvivalGame/Source/SurvivalGame/Public/World/SOpenWorldGameMode.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "World/SGameMode.h"
#include "SOpenWorldGameMode.generated.h"

/**
 * 
 */
UCLASS(ABSTRACT)
class SURVIVALGAME_API ASOpenWorldGameMode : public ASGameMode
{
	GENERATED_BODY()

	ASOpenWorldGameMode();
	
	/* Don't allow spectating of other players or bots */
	virtual bool CanSpectate_Implementation(APlayerController* Viewer, APlayerState* ViewTarget) override;
};

```

`SurvivalGame/Source/SurvivalGame/Public/World/SPlayerStart.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/PlayerStart.h"
#include "SPlayerStart.generated.h"

/**
 * 
 */
UCLASS()
class SURVIVALGAME_API ASPlayerStart : public APlayerStart
{
	GENERATED_BODY()

public:

	ASPlayerStart(const FObjectInitializer& ObjectInitializer);

	/* Is only useable by players - automatically a preferred spawn for players */
	UPROPERTY(EditAnywhere, Category = "PlayerStart")
	bool bPlayerOnly;

public:

	UFUNCTION(BlueprintCallable, Category = "PlayerStart")
	bool GetIsPlayerOnly() const { return bPlayerOnly; }

};

```

`SurvivalGame/Source/SurvivalGame/Public/World/STimeOfDayManager.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "STimeOfDayManager.generated.h"

class USoundCue;

UCLASS(ABSTRACT)
class SURVIVALGAME_API ASTimeOfDayManager : public AActor
{
	GENERATED_BODY()

protected:

	ASTimeOfDayManager();

	/* Cached bool of bIsNight to determine when we entered/left the night */
	bool LastNightState;

	/* Sunbrightness as specified in the level (considered as daytime sun) */
	float OriginalSunBrightness;

	/* Target brightness to lerp towards */
	float TargetSunBrightness;

	/* Last skylight intensity that was captured */
	float LastCapturedIntensity;

	/* Maps intensity to time of day */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DayNight")
	class UCurveFloat* SkylightIntensityCurve;

	/* Maps skylight color to time of day */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DayNight")
	class UCurveVector* SkylightColorCurve;

public:	

	virtual void BeginPlay() override;

	virtual void Tick(float DeltaSeconds) override;	

	void UpdateSkylight();

	/* Play the ambient loop for the current time state */
	void PlayAmbientLoop();

	UPROPERTY(EditDefaultsOnly, Category = "Components")
	class UAudioComponent* AmbientAudioComp;

	/* Primary sun of the level. Assigned in Blueprint during BeginPlay (BlueprintReadWrite is required as tag instead of EditDefaultsOnly) */
	UPROPERTY(BlueprintReadWrite, Category = "DayNight")
	class ADirectionalLight* PrimarySunLight;
	
	UPROPERTY(BlueprintReadWrite, Category = "DayNight")
	class ASkyLight* SkyLightActor;

	/* Last local time of day to apply sun movement prediction */
	float LastTimeOfDay;

	/* Delta seconds since the time of day was last updated */
	float TimeSinceLastIncrement;

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* SoundNightStarted;

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* SoundNightEnded;

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* AmbientDaytime;

	UPROPERTY(EditDefaultsOnly, Category = "Sound")
	USoundCue* AmbientNight;
};

```

`SurvivalGame/Source/SurvivalGame/STypes.h`:

```h

#include "STypes.generated.h"
#pragma once



UENUM()
enum class EInventorySlot : uint8
{
	/* For currently equipped items/weapons */
	Hands,

	/* For primary weapons on spine bone */
	Primary,

	/* Storage for small items like flashlight on pelvis */
	Secondary,
};


UENUM()
enum class EBotBehaviorType : uint8
{
	/* Does not move, remains in place until a player is spotted */
	Passive,

	/* Patrols a region until a player is spotted */
	Patrolling,
};


USTRUCT()
struct FTakeHitInfo
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY()
	float ActualDamage;

	UPROPERTY()
	UClass* DamageTypeClass;

	UPROPERTY()
	TWeakObjectPtr<class ASBaseCharacter> PawnInstigator;

	UPROPERTY()
	TWeakObjectPtr<class AActor> DamageCauser;

	UPROPERTY()
	uint8 DamageEventClassID;

	UPROPERTY()
	bool bKilled;

private:

	UPROPERTY()
	uint8 EnsureReplicationByte;

	UPROPERTY()
	FDamageEvent GeneralDamageEvent;

	UPROPERTY()
	FPointDamageEvent PointDamageEvent;

	UPROPERTY()
	FRadialDamageEvent RadialDamageEvent;

public:
	FTakeHitInfo()
		: ActualDamage(0),
		DamageTypeClass(nullptr),
		PawnInstigator(nullptr),
		DamageCauser(nullptr),
		DamageEventClassID(0),
		bKilled(false),
		EnsureReplicationByte(0)
	{}

	FDamageEvent& GetDamageEvent()
	{
		switch (DamageEventClassID)
		{
		case FPointDamageEvent::ClassID:
			if (PointDamageEvent.DamageTypeClass == nullptr)
			{
				PointDamageEvent.DamageTypeClass = DamageTypeClass ? DamageTypeClass : UDamageType::StaticClass();
			}
			return PointDamageEvent;

		case FRadialDamageEvent::ClassID:
				if (RadialDamageEvent.DamageTypeClass == nullptr)
				{
					RadialDamageEvent.DamageTypeClass = DamageTypeClass ? DamageTypeClass : UDamageType::StaticClass();
				}
				return RadialDamageEvent;

		default:
			if (GeneralDamageEvent.DamageTypeClass == nullptr)
			{
				GeneralDamageEvent.DamageTypeClass = DamageTypeClass ? DamageTypeClass : UDamageType::StaticClass();
			}
			return GeneralDamageEvent;
		}
	}


	void SetDamageEvent(const FDamageEvent& DamageEvent)
	{
		DamageEventClassID = DamageEvent.GetTypeID();
		switch (DamageEventClassID)
		{
		case FPointDamageEvent::ClassID:
			PointDamageEvent = *((FPointDamageEvent const*)(&DamageEvent));
			break;
		case FRadialDamageEvent::ClassID:
			RadialDamageEvent = *((FRadialDamageEvent const*)(&DamageEvent));
			break;
		default:
			GeneralDamageEvent = DamageEvent;
		}
	}


	void EnsureReplication()
	{
		EnsureReplicationByte++;
	}
};
```

`SurvivalGame/Source/SurvivalGame/SurvivalGame.Build.cs`:

```cs
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class SurvivalGame : ModuleRules
{
	public SurvivalGame(ReadOnlyTargetRules Target) : base(Target)
    {
        /* AIModule is not assigned by default, must be added when dealing with AI in your project */
        PublicDependencyModuleNames.AddRange(new string[] {
            "Core",
            "CoreUObject",
            "Engine",
            "InputCore",
            "AIModule",
            /* Temporarily added GameplayTasks to workaround 4.12 compilation bug. */
            "GameplayTasks",
            "NavigationSystem",
            "OnlineSubsystem", // For Steam
            "PhysicsCore" // PhysicalMaterials
        });

        PrivateDependencyModuleNames.AddRange(new string[] {  });
	}
}

```

`SurvivalGame/Source/SurvivalGame/SurvivalGame.cpp`:

```cpp
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.



IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, SurvivalGame, "SurvivalGame" );

```

`SurvivalGame/Source/SurvivalGame/SurvivalGame.h`:

```h
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Engine/Engine.h"

// This is NOT included by default in an empty project! It's required for replication and setting of the GetLifetimeReplicatedProps
#include "Net/UnrealNetwork.h"


/* Define a log category for error messages */
DEFINE_LOG_CATEGORY_STATIC(LogGame, Log, All);

/** when you modify this, please note that this information can be saved with instances
* also DefaultEngine.ini [/Script/Engine.CollisionProfile] should match with this list **/
#define COLLISION_WEAPON				ECC_GameTraceChannel1


/** when you modify this, please note that this information can be saved with instances
* also DefaultEngine.ini [/Script/Engine.PhysicsSettings] should match with this list **/
#define SURFACE_DEFAULT				SurfaceType_Default
#define SURFACE_FLESH				SurfaceType1
#define SURFACE_ZOMBIEBODY			SurfaceType2
#define SURFACE_ZOMBIEHEAD			SurfaceType3
#define SURFACE_ZOMBIELIMB			SurfaceType4
```

`SurvivalGame/Source/SurvivalGameEditor.Target.cs`:

```cs
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class SurvivalGameEditorTarget : TargetRules
{
	public SurvivalGameEditorTarget(TargetInfo Target) : base(Target)
    {
        DefaultBuildSettings = BuildSettingsVersion.V2;
        Type = TargetType.Editor;
        ExtraModuleNames.AddRange(new string[] { "SurvivalGame" });
    }
}

```

`SurvivalGame/Source/SurvivalGameServer.Target.cs`:

```cs
// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class SurvivalGameServerTarget : TargetRules
{
	public SurvivalGameServerTarget(TargetInfo Target) : base(Target)
    {
        DefaultBuildSettings = BuildSettingsVersion.V2;
        Type = TargetType.Server;
        ExtraModuleNames.AddRange(new string[] { "SurvivalGame" });
    }
}

```

`SurvivalGame/SurvivalGame.uproject`:

```uproject
{
	"FileVersion": 3,
	"EngineAssociation": "5.2",
	"Category": "",
	"Description": "",
	"Modules": [
		{
			"Name": "SurvivalGame",
			"Type": "Runtime",
			"LoadingPhase": "Default",
			"AdditionalDependencies": [
				"Engine",
				"UMG"
			]
		}
	],
	"Plugins": [
		{
			"Name": "OnlineSubsystemSteam",
			"Enabled": true
		}
	]
}
```