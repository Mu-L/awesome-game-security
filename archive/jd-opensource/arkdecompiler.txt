Project Path: arc_jd-opensource_arkdecompiler_9ukoy81c

Source Tree:

```txt
arc_jd-opensource_arkdecompiler_9ukoy81c
├── BUILD.gn
├── LICENSE
├── README.md
├── algos.cpp
├── algos.h
├── arkts.cpp
├── arkts.h
├── ast.h
├── astgen.cpp
├── astgen.h
├── astgen_auxiins.cpp
├── astgen_ecma.inl
├── autotests
│   ├── blacklist.txt
│   ├── clean_build_fail_file.py
│   ├── count_json_members.py
│   ├── scantstests.py
│   ├── test262
│   └── third_party_typescript
├── base.cpp
├── base.h
├── build.sh
├── classconstruction.cpp
├── classconstruction.h
├── complexstmt2body.h
├── demo.png
├── docker
│   └── Dockerfile
├── fundepscan.cpp
├── fundepscan.h
├── genlogs.sh
├── hot.sh
├── intrinsicid2name.h
├── intrinsicid2token.h
├── lexicalenv.cpp
├── lexicalenv.h
├── loopconstruction.cpp
├── loopconstruction.h
├── modulevar.cpp
├── modulevar.h
├── patches
│   ├── arkcompiler_ets_frontend_09e1955c6.patch
│   ├── arkcompiler_runtime_core_a94c360.patch
│   └── third_party_protobuf_0e4c27.patch
├── run.sh
├── scripts
│   ├── draw_cfg.py
│   ├── intrinsic_list.txt
│   ├── pickintrinsics.py
│   ├── picktokens.py
│   ├── prepare.sh
│   ├── removebc.py
│   └── tokens.txt
├── tests
│   ├── 1.normal.ts
│   ├── 10.module.ts
│   ├── 11.generator.ts
│   ├── 12.iterator.ts
│   ├── 13.differentbranchcases.ts
│   ├── 14.phi.ts
│   ├── 15.sendable.ts
│   ├── 16.async.ts
│   ├── 17.template.ts
│   ├── 2.array_obj.ts
│   ├── 3.func.ts
│   ├── 4.if.ts
│   ├── 5.trycatch.ts
│   ├── 6.loop.ts
│   ├── 7.lexical.ts
│   ├── 8.class.ts
│   ├── 9.hotcompile.ts
│   └── misc.ts
└── xabc.cpp

```

`BUILD.gn`:

```gn
import("//arkcompiler/ets_frontend/es2panda/es2abc_config.gni")
import("//arkcompiler/runtime_core/ark_config.gni")
import("$ark_root/tests/test_helper.gni")

ohos_shared_library("libarkdecompiler") {
  stack_protector_ret = false
  sources = ["decompiler.cpp"]

  #cflags_cc = [ "-std=c++17", "-frtti" ]
  
  configs = [
    "$ark_root:ark_config",
    "$ark_root/libpandabase:arkbase_public_config",
    "$ark_root/libpandafile:arkfile_public_config",
    "$ark_root/assembler:arkassembler_public_config",
    "$ark_root/bytecode_optimizer:bytecodeopt_public_config",
    "$ark_root/compiler:arkcompiler_public_config",
  ]

  deps = [
    "$ark_root/disassembler:arkdisassembler",
    "$ark_root/assembler:libarkassembler",
    "$ark_root/bytecode_optimizer:libarkbytecodeopt",
    "$ark_root/compiler:libarkcompiler",
    "$ark_root/libpandabase:libarkbase",
    "$ark_root/libpandafile:libarkfile",
  ]

  external_deps = [ sdk_libc_secshared_dep ]

  include_dirs = [ "$ark_root/compiler/optimizer" ]

  output_extension = "so"
  relative_install_dir = "ark"
  part_name = "runtime_core"
  subsystem_name = "arkcompiler"
}

ohos_executable("xabc") {
  #cflags_cc -= [ "-fno-rtti" ]
  #cflags_cc += [ "-frtti" ]
  #cflags_cc += ["-std=c++17"]
  
  sources = [
    "xabc.cpp",
    "astgen.cpp",
    "arkts.cpp",
    "lexicalenv.cpp",
    "algos.cpp",
    "modulevar.cpp",
    "base.cpp",
    "fundepscan.cpp",
    "classconstruction.cpp",
    "loopconstruction.cpp"
  ]
  
  configs =  [
    "$ark_root:ark_config",
    "$ark_root/assembler:arkassembler_public_config",
    "$ark_root/bytecode_optimizer:bytecodeopt_public_config",
    "$ark_root/compiler:arkcompiler_public_config",
    "$ark_root/libpandabase:arkbase_public_config",
    "$ark_root/libpandafile:arkfile_public_config",
    "$ark_root/../ets_frontend/es2panda:es2abc_config_src",
    "$ark_root/../ets_frontend/es2panda:es2abc_config_common",
    "$ark_root/../ets_frontend/merge_abc:panda_assembly_proto_public_config",
    "$ark_root/../ets_frontend/merge_abc:proto_file_cpp_config",
    "$ark_root/../../third_party/protobuf:protobuf_config",
  ]

  deps = [
    "$ark_root/disassembler:arkdisassembler",
    "$ark_root/assembler:libarkassembler",
    "$ark_root/bytecode_optimizer:libarkbytecodeopt",
    "$ark_root/compiler:libarkcompiler",
    "$ark_root/libpandabase:libarkbase",
    "$ark_root/libpandafile:libarkfile",
    "$ark_root/libpandafile:libarkfile",
    "$ark_root/../ets_frontend/es2panda:es2panda_lib",
  ]
  
  external_deps = [ sdk_libc_secshared_dep ]

}


```

`LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# arkdecompiler

arkdecompiler is the decompiler for HarmonyOS Next(纯血鸿蒙反编译器), which takes Panda Binary File as input, parses Panda Bytecode, and then translates it into Panda IR. After having IR, we can do various analyses. Based on IR, we reversely construct the native arkTS AST tree, and then we traverse the AST tree and translate it into native arkTS source code.

- [2025 Black Hat, USA](https://www.blackhat.com/us-25/arsenal/schedule/index.html#decompiler-for-harmonyos-next-45569)
- [2026 Black Hat, ASIA](https://blackhat.com/asia-26/arsenal/schedule/index.html)
- 2026.Q1: Support all instructions and program structures

# Installation
## Tested platform
Ubuntu 22.04

In the future we will adapt to other development platforms such as (windows, macOS) and add a GUI.
## Prepare environment
```bash
./prepare.sh(It will create the root directory **harmonyos**)
```

## Clone `arkdecompiler` in `harmonyos`
```bash
cd harmonyos && git clone https://github.com/jd-opensource/arkdecompiler.git
```
- directory structure
```
➜  harmonyos ls
ark.py  arkcompiler  arkdecompiler  build  developtools  docs  foundation  kernel  out  prebuilts  prebuilts_download.sh  third_party
```

## Apply patches to arkcompiler and third_party
Apply patches to `harmonyos/arkcompiler/runtime_core`, `harmonyos/arkcompiler/ets_frontend`, and `harmonyos/third_party/protobuf` according to the `patches`.


# Usage
## Build the decompilation main program `xabc`
```bash
./build.sh
```

## Prepare the source code file
Create `demo.ts`(refer `tests` directory)

## Compilation && Decompilation
./run.sh(It will invoke `genlogs.sh`)

### detailed description
- The compilation result is：**demo.abc**(generated by `genlogs.sh`)
- The decompilation result is：**arkdemo.ts**


# Demo
## Decompile bytecode to arkTS
![demo](demo.png)

## AST
```
{
  "type": "Program",
  "statements": [
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "Identifier",
          "name": "undefined",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "c",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "v0",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "NumberLiteral",
          "value": 1,
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "BinaryExpression",
          "operator": "+",
          "left": {
            "type": "NumberLiteral",
            "value": 1,
            "loc": {
              "start": {
                "line": 1,
                "column": 1
              },
              "end": {
                "line": 1,
                "column": 1
              }
            }
          },
          "right": {
            "type": "Identifier",
            "name": "v0",
            "loc": {
              "start": {
                "line": 1,
                "column": 1
              },
              "end": {
                "line": 1,
                "column": 1
              }
            }
          },
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "c",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "v254",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "right": {
          "type": "Identifier",
          "name": "undefined",
          "loc": {
            "start": {
              "line": 1,
              "column": 1
            },
            "end": {
              "line": 1,
              "column": 1
            }
          }
        },
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    },
    {
      "type": "ReturnStatement",
      "argument": {
        "type": "Identifier",
        "name": "undefined",
        "loc": {
          "start": {
            "line": 1,
            "column": 1
          },
          "end": {
            "line": 1,
            "column": 1
          }
        }
      },
      "loc": {
        "start": {
          "line": 1,
          "column": 1
        },
        "end": {
          "line": 1,
          "column": 1
        }
      }
    }
  ],
  "loc": {
    "start": {
      "line": 1,
      "column": 1
    },
    "end": {
      "line": 1,
      "column": 1
    }
  }
}

```

```

`algos.cpp`:

```cpp
#include "algos.h"
#include "base.h"

LCAFinder::LCAFinder(panda::compiler::Graph* graph) : graph(graph) {
        Initialize();
}

panda::compiler::BasicBlock* LCAFinder::FindLCA(panda::compiler::BasicBlock* u, panda::compiler::BasicBlock* v) {
    std::unordered_set<panda::compiler::BasicBlock*> commonAncestors;
    const auto& ancestorsU = ancestors[u];
    const auto& ancestorsV = ancestors[v];

    for (auto ancestor : ancestorsU) {
        if (ancestorsV.count(ancestor)) {
            commonAncestors.insert(ancestor);
        }
    }

    panda::compiler::BasicBlock* lca = nullptr;
    int maxDepth = -1;
    for (auto ancestor : commonAncestors) {
        int depth = ancestors[ancestor].size();
        if (depth > maxDepth) {
            maxDepth = depth;
            lca = ancestor;
        }
    }
    return lca;
}

void LCAFinder::Initialize() {
    for (auto node : graph->GetBlocksRPO()) {
        std::unordered_set<panda::compiler::BasicBlock*> nodeAncestors;
        for (auto parent : node->GetPredsBlocks()) {
            nodeAncestors.insert(parent);
            nodeAncestors.insert(ancestors[parent].begin(), ancestors[parent].end());
        }
        ancestors[node] = nodeAncestors;
    }
}


std::vector<uint32_t> TopologicalSort(const std::vector<std::pair<uint32_t, uint32_t>>& edges) {
    if (edges.empty()) {
        return {};
    }
    
    std::unordered_set<uint32_t> allNodes;
    for (const auto& edge : edges) {
        allNodes.insert(edge.first);
        allNodes.insert(edge.second);
    }
    
    if (allNodes.empty()) {
        return {};
    }
    
    std::unordered_map<uint32_t, std::vector<uint32_t>> graph;
    std::unordered_map<uint32_t, uint32_t> indegree;
    
    for (uint32_t node : allNodes) {
        indegree[node] = 0;
    }
    
    for (const auto& edge : edges) {
        graph[edge.first].push_back(edge.second);
        indegree[edge.second]++;
    }
    
    std::queue<uint32_t> q;
    for (uint32_t node : allNodes) {
        if (indegree[node] == 0) {
            q.push(node);
        }
    }
    
    std::vector<uint32_t> result;
    while (!q.empty()) {
        uint32_t node = q.front();
        q.pop();
        result.push_back(node);
        
        for (uint32_t neighbor : graph[node]) {
            indegree[neighbor]--;
            if (indegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }
    
    if (result.size() != allNodes.size()) {
        HandleError("#TopologicalSort: search failed");
        return {}; 
    }
    
    return result;
}
```

`algos.h`:

```h
#ifndef DECOMPILER_LCA
#define DECOMPILER_LCA

#include "base.h"

class LCAFinder {
public:
    LCAFinder(panda::compiler::Graph* graph);
    panda::compiler::BasicBlock* FindLCA(panda::compiler::BasicBlock* u, panda::compiler::BasicBlock* v);

private:
    panda::compiler::Graph* graph;
    std::unordered_map<panda::compiler::BasicBlock*, std::unordered_set<panda::compiler::BasicBlock*>> ancestors;

    void Initialize();
};

std::vector<uint32_t> TopologicalSort(const std::vector<std::pair<uint32_t, uint32_t>>& edges);
#endif
```

`arkts.cpp`:

```cpp
#include "arkts.h"

namespace panda::es2panda::ir {

ArkTSGen::ArkTSGen(const BlockStatement *program, util::StringView sourceCode) : index_(sourceCode), indent_(0)
{
    SerializeObject(reinterpret_cast<const ir::AstNode *>(program));
}

ArkTSGen::ArkTSGen(const ir::AstNode *node) : indent_(0), dumpNodeOnly_(true)
{
    EmitStatement(node);
}

void ArkTSGen::EmitBlockStatement(const ir::AstNode *node){
    auto tmp = const_cast<ir::AstNode*>(node);
    auto blockstatement = tmp->AsBlockStatement();

    const auto &statements = blockstatement->Statements();
    
    if(statements.size() == 0){
       // this->WriteNewLine();
    }

    for (const auto *stmt : statements) {
        this->EmitStatement(stmt);
    }
}

void ArkTSGen::WriteTrailingSemicolon(){
    ss_ << ";" << std::endl;
}

void ArkTSGen::WriteSpace(){
    ss_ << " ";
}

void ArkTSGen::WriteLeftBrace(){
    ss_ << "{";
}

void ArkTSGen::WriteRightBrace(){
    ss_ << "}";
}

void ArkTSGen::WriteLeftBracket(){
    ss_ << "[";
}

void ArkTSGen::WriteRightBracket(){
    ss_ << "]";
}

void ArkTSGen::WriteLeftParentheses(){
    ss_ << "(";
}

void ArkTSGen::WriteRightParentheses(){
    ss_ << ")";
}

void ArkTSGen::WriteColon(){
    ss_ << " : ";
}

void ArkTSGen::WriteEqual(){
    ss_ << " = ";
}

void ArkTSGen::WriteComma(){
    ss_ << ", ";
}

void ArkTSGen::WriteDot(){
    ss_ << ".";
}

void ArkTSGen::WriteKeyWords(std::string keyword){
    ss_ << keyword ;
}

void ArkTSGen::WriteSpreadDot(){
    ss_ << "...";
}

void ArkTSGen::WriteNewLine(){
    ss_ << "\n";
}

void ArkTSGen::WriteIndent(){
    for (int i = 0; i < this->indent_; ++i) {
        ss_ << " ";
    } 
}

void ArkTSGen::EmitExpression(const ir::AstNode *node){
    if(node == nullptr){
        HandleError("#EmitExpression: emitExpression for null astnode");
    }

    switch(node->Type()){ 
        case AstNodeType::BINARY_EXPRESSION:{
            std::cout << "enter BINARY_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            auto binexpression = node->AsBinaryExpression();

            this->EmitExpression(binexpression->Left());
            WriteSpace();
            ss_ << TokenToString(binexpression->OperatorType());
            WriteSpace();
            this->EmitExpression(binexpression->Right());
            break;
        }

        case AstNodeType::UNARY_EXPRESSION:{
            std::cout << "enter UNARY_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            auto unaryexpression = node->AsUnaryExpression();
            ss_ << TokenToString(unaryexpression->OperatorType());
            WriteSpace();
            this->EmitExpression(unaryexpression->Argument());
            break;
        }

        case AstNodeType::ASSIGNMENT_EXPRESSION:{
            auto assignexpression = node->AsAssignmentExpression();
            std::cout << "enter ASSIGNMENT_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            
            this->EmitExpression(assignexpression->Left());
            WriteSpace();
            ss_ << TokenToString(assignexpression->OperatorType());
            WriteSpace();
            this->EmitExpression(assignexpression->Right());
            break;
        }
        case AstNodeType::IDENTIFIER:{
            auto identifier = node->AsIdentifier();
            ss_ << identifier->Name();
            break;
        }

        case AstNodeType::NUMBER_LITERAL:{
            auto number_literal = node->AsNumberLiteral();
            this->SerializeNumber(number_literal->Number());
            break;
        } 

        case AstNodeType::BIGINT_LITERAL:{
            auto bigint_literal = node->AsBigIntLiteral();
            this->SerializeString(bigint_literal->Str());
            break;
        } 

        case AstNodeType::NULL_LITERAL:{
            this->SerializeConstant(Property::Constant::PROP_NULL);
            break;
        }

        case AstNodeType::STRING_LITERAL:{
            auto string_literal = node->AsStringLiteral();
            this->SerializeString(string_literal->Str());
            break;
        }
        
        case AstNodeType::BOOLEAN_LITERAL:{
            auto bool_literal = node->AsBooleanLiteral();
            this->SerializeBoolean(bool_literal->Value());
            break;
        }
        case AstNodeType::MEMBER_EXPRESSION:{
            auto member_expression = node->AsMemberExpression();
            this->EmitExpression(member_expression->Object());
            if(member_expression->IsComputed()){
                this->WriteLeftBracket();
                this->EmitExpression(member_expression->Property());
                this->WriteRightBracket();
            }else{
                this->WriteDot();
                this->EmitExpression(member_expression->Property());
            }
            break;
        }

        case AstNodeType::OBJECT_EXPRESSION:{
            std::cout << "enter OBJECT_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            auto objexpression = node->AsObjectExpression();
            
            WriteLeftBrace();
            size_t properties_size = objexpression->Properties().size();
            size_t count = 1;
            for (auto *it : objexpression->Properties()) {
                switch (it->Type()) {
                    case AstNodeType::PROPERTY: {
                        this->EmitExpression(it);
                        
                        if(count++ < properties_size)
                            this->WriteComma();
                        
                        break;
                    }
                    case AstNodeType::SPREAD_ELEMENT:{
                        this->EmitExpression(it);
                        
                        if(count++ < properties_size)
                            this->WriteComma();
                        
                        break;
                    }
                    default: {
                        this->EmitExpression(it);
                        if(count++ < properties_size)
                            this->WriteComma();
                        break;
                    }
                }
            }
            WriteRightBrace();

            break;

        }

        case AstNodeType::ARRAY_EXPRESSION:{
            std::cout << "enter OBJECT_EXPRESSION >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            auto arrayexpression = node->AsArrayExpression();
            
            WriteLeftBracket();
            int count = 0;
            int array_size = arrayexpression->Elements().size();
            for (auto *it : arrayexpression->Elements()) {
                this->EmitExpression(it);
                if(++count < array_size ){
                    this->WriteComma();
                }
            }
            WriteRightBracket();

            break;

        }

        case AstNodeType::PROPERTY:{
            auto propertyexpression = node->AsProperty();

            this->EmitExpression(propertyexpression->Key());
            this->WriteColon();
            this->EmitExpression(propertyexpression->Value());
            

            break;
        }

        case AstNodeType::CALL_EXPRESSION:{
            auto callexpression = node->AsCallExpression();

            this->EmitExpression(callexpression->Callee());
            this->WriteLeftParentheses();

            int count = 1;
            int argumentsize = callexpression->Arguments().size();
            for (const auto *it : callexpression->Arguments()) {
                this->EmitExpression(it);
                if(count ++ < argumentsize){
                    this->WriteComma();
                }
            }

            this->WriteRightParentheses();

            break;
        }

        case AstNodeType::NEW_EXPRESSION:{
            auto newexpression = node->AsNewExpression();

            this->WriteKeyWords("new");
            this->WriteSpace();
            this->EmitExpression(newexpression->Callee());
            this->WriteLeftParentheses();

            int count = 1;
            int argumentsize = newexpression->Arguments().size();
            for (const auto *it : newexpression->Arguments()) {
                this->EmitExpression(it);
                if(count ++ < argumentsize){
                    this->WriteComma();
                }
            }

            this->WriteRightParentheses();

            break;
        }

        case AstNodeType::SPREAD_ELEMENT:{
            this->WriteSpreadDot();
            auto spreadarg = node->AsSpreadElement();
            this->EmitExpression(spreadarg->Argument());
            break;
        }

        case AstNodeType::AWAIT_EXPRESSION:{
            auto awaitexpression = node->AsAwaitExpression();
            this->WriteKeyWords("await");
            this->WriteSpace();
            this->EmitExpression(awaitexpression->Argument());
            break;
        }

        case AstNodeType::YIELD_EXPRESSION:{
            auto awaitexpression = node->AsYieldExpression();
            this->WriteKeyWords("yield");
            this->WriteSpace();
            this->EmitExpression(awaitexpression->Argument());
            break;
        }

        case AstNodeType::OMITTED_EXPRESSION:{
            this->WriteSpace();
            break;
        }

        default:
            HandleError("#EmitExpression : unsupport expression");;

    }
}

void ArkTSGen::EmitExpressionStatement(const ir::AstNode *node){
    auto expressionstatement = node->AsExpressionStatement();
    this->EmitExpression(expressionstatement->GetExpression());
    this->WriteTrailingSemicolon();
}

void ArkTSGen::EmitVariableDeclarationStatement(const ir::AstNode *node){
     auto vardeclstatement = node->AsVariableDeclaration();
    
    int size = vardeclstatement->Declarators().size();
    int count = 1;
    
    if(vardeclstatement->Kind() == es2panda::ir::VariableDeclaration::VariableDeclarationKind::CONST){
        this->WriteKeyWords("const");
        this->WriteSpace();
    }else if(vardeclstatement->Kind() == es2panda::ir::VariableDeclaration::VariableDeclarationKind::LET){
        this->WriteKeyWords("let");
        this->WriteSpace();
    }else {
        this->WriteKeyWords("var");
        this->WriteSpace();
    }

    for (const auto *it : vardeclstatement->Declarators()) {
        this->EmitStatement(it);
        if(++count < size ){
            this->WriteColon();
        }
    }
    this->WriteTrailingSemicolon();
}

void ArkTSGen::EmitVariableDeclaratorStatement(const ir::AstNode *node){
    auto vardeclstatement = node->AsVariableDeclarator();

    this->EmitExpression(vardeclstatement->Id());
    this->WriteEqual();
    this->EmitExpression(vardeclstatement->Init());
}


void ArkTSGen::EmitReturnStatement(const ir::AstNode *node){
    auto returnstatement = node->AsReturnStatement();
    this->WriteKeyWords("return");
    this->WriteSpace();
    this->EmitExpression(returnstatement->Argument());
    this->WriteTrailingSemicolon();
}

void ArkTSGen::EmitBreakStatement(const ir::AstNode *node){
    this->WriteKeyWords("break");
    this->WriteTrailingSemicolon();
}

void  ArkTSGen::EmitDebuggerStatement(const ir::AstNode *node){
    this->WriteKeyWords("debugger");
    this->WriteTrailingSemicolon();
}

void  ArkTSGen::EmitThrowStatement(const ir::AstNode *node){
    auto throwstatement = node->AsThrowStatement();

    this->WriteKeyWords("throw");
    this->WriteSpace();
    this->EmitExpression(throwstatement->Argument());
    this->WriteTrailingSemicolon();
}


void  ArkTSGen::EmitFunctionDeclaration(const ir::AstNode *node){
    auto fundeclare = node->AsFunctionDeclaration();
    auto scriptfunction =  fundeclare->Function();

    if(scriptfunction->IsAsync()){
        this->WriteKeyWords("async");
        this->WriteSpace();    
    }
    this->WriteKeyWords("function");
    this->WriteSpace();
    this->EmitExpression(scriptfunction->Id());
    this->WriteLeftParentheses();

    int count = 1;
    int argumentsize = scriptfunction->Params().size();
    for (const auto *param : scriptfunction->Params()) {
        // if(count > 3){
        //     this->EmitExpression(param);
        // }else{
        //     count++;
        //     continue;
        // }
        this->EmitExpression(param);
        if(count ++ < argumentsize){
            this->WriteComma();
        }
    }
    this->WriteRightParentheses();
    this->WriteLeftBrace();
    this->WriteNewLine();
    this->indent_ = this->indent_ + this->singleindent_;

    this->EmitStatement(scriptfunction->Body());

    this->indent_ = this->indent_ - this->singleindent_;
    this->WriteRightBrace();
    this->WriteNewLine();
}

void ArkTSGen::EmitTryStatement(const ir::AstNode *node){
    auto trystatement = node->AsTryStatement();
    
    // if(test)
    this->WriteKeyWords("try");
    this->WriteLeftBrace();
    this->WriteNewLine();

    //  statements
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(trystatement->Block());
    this->indent_ = this->indent_ - this->singleindent_;
    this->WriteIndent();
    this->WriteRightBrace();

    // }catch(error){
    this->WriteKeyWords("catch");
    this->WriteLeftParentheses();
    this->EmitExpression(trystatement->GetCatchClause()->Param());
    this->WriteRightParentheses();
    this->WriteLeftBrace();
    this->WriteNewLine();

    // catch body
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(trystatement->GetCatchClause()->Body());
    this->indent_ = this->indent_ - this->singleindent_;

    // }
    this->WriteIndent();
    this->WriteRightBrace();
    this->WriteNewLine();
}

void ArkTSGen::EmitIfStatement(const ir::AstNode *node){
    std::cout << "[+] start EmitIfStatement"  << std::endl;
    auto ifstatement = node->AsIfStatement();
    if(ifstatement->Consequent() == nullptr ||  ifstatement->Consequent()->AsBlockStatement()->Statements().size() == 0){
        return;
    }

    // if(test)
    this->WriteKeyWords("if");
    this->WriteLeftParentheses();
    this->EmitExpression(ifstatement->Test());
    this->WriteRightParentheses();
    this->WriteLeftBrace();
    this->WriteNewLine();

    // if statements
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(ifstatement->Consequent());
    this->indent_ = this->indent_ - this->singleindent_;
    this->WriteIndent();
    this->WriteRightBrace();

    if(ifstatement->Alternate() != nullptr && ifstatement->Alternate()->AsBlockStatement()->Statements().size() > 0){
        // }else{
        this->WriteKeyWords("else");
        this->WriteLeftBrace();
        this->WriteNewLine();

        // else statements
        this->indent_ = this->indent_ + this->singleindent_;
        this->EmitStatement(ifstatement->Alternate());
        this->indent_ = this->indent_ - this->singleindent_;

        // }
        this->WriteIndent();
        this->WriteRightBrace();
    }
    this->WriteNewLine();
    
    std::cout << "[-] end EmitIfStatement"  << std::endl;
}

void ArkTSGen::EmitWhileStatement(const ir::AstNode *node){
    std::cout << "[+] start emit while statement"  << std::endl;
    auto whilestatement = node->AsWhileStatement();

    // while(test){
    this->WriteKeyWords("while");
    this->WriteLeftParentheses();
    this->EmitExpression(whilestatement->Test());
    this->WriteRightParentheses();
    this->WriteLeftBrace();
    this->WriteNewLine();

    // while statement
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(whilestatement->Body());
    this->indent_ = this->indent_ - this->singleindent_;

    // }
    this->WriteIndent();
    this->WriteRightBrace();
    this->WriteNewLine();
        
    std::cout << "[-] end emit while statement"  << std::endl;
}

void ArkTSGen::EmitDoWhileStatement(const ir::AstNode *node){
    std::cout << "[+] start emit dowhile statement"  << std::endl;
    auto dowhilestatement = node->AsDoWhileStatement();
    
    // do {
    this->WriteKeyWords("do");
    this->WriteLeftBrace();
    this->WriteNewLine();

    // while statement
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(dowhilestatement->Body());
    this->indent_ = this->indent_ - this->singleindent_;

    // }while(test)
    this->WriteIndent();
    this->WriteRightBrace();
    this->WriteKeyWords("while");
    this->WriteLeftParentheses();
    this->EmitExpression(dowhilestatement->Test());
    this->WriteRightParentheses();
    this->WriteTrailingSemicolon();        
    std::cout << "[-] end emit dowhile statement"  << std::endl;
}


void ArkTSGen::EmitImportSpecifier(const ir::AstNode *node){
    std::cout << "[+] start emit import specifier statement"  << std::endl;
    auto importspecifier = node->AsImportSpecifier();
    
    this->WriteKeyWords("import");

    this->WriteSpace();
    this->EmitExpression(importspecifier->Imported());

    if(importspecifier->Local() != importspecifier->Imported()){
        this->WriteSpace();
        this->WriteKeyWords("as");
        this->WriteSpace();
        this->EmitExpression(importspecifier->Local());
    }
    this->WriteTrailingSemicolon();
}

void ArkTSGen::EmitImportDeclaration(const ir::AstNode *node){
    std::cout << "[+] start emit import declaration statement"  << std::endl;
    auto importdeclaration = node->AsImportDeclaration();
    
    for (const auto *astnode : importdeclaration->Specifiers()) {
        auto importspecifier = astnode->AsImportSpecifier();
        this->WriteKeyWords("import");

        this->WriteSpace();
        this->EmitExpression(importspecifier->Imported());

        if(importspecifier->Local() != importspecifier->Imported()){
            this->WriteSpace();
            this->WriteKeyWords("as");
            this->WriteSpace();
            this->EmitExpression(importspecifier->Local());
        }

        this->WriteSpace();
        this->WriteKeyWords("from");
        this->WriteSpace();

        this->EmitExpression(importdeclaration->Source());
    }
    this->WriteTrailingSemicolon();
}

void ArkTSGen::EmitExportAllDeclaration(const ir::AstNode *node){
    std::cout << "[+] start emit export all declaration statement"  << std::endl;
    auto exportdeclaration = node->AsExportAllDeclaration();
    
    this->WriteKeyWords("export");
    this->WriteSpace();
    this->WriteKeyWords("*");
    this->WriteSpace();
    this->WriteKeyWords("from");
    this->WriteSpace();
    this->EmitExpression(exportdeclaration->Source());
    this->WriteTrailingSemicolon();
}

void ArkTSGen::EmitExportSpecifier(const ir::AstNode *node){
    std::cout << "[+] start emit export specifier statement"  << std::endl;
    auto exportspecifier = node->AsExportSpecifier();
    
    this->WriteKeyWords("export");
    this->WriteSpace();
    this->EmitExpression(exportspecifier->Local());
    this->WriteSpace();
    this->WriteKeyWords("as");
    this->WriteSpace();
    this->EmitExpression(exportspecifier->Exported());
    this->WriteTrailingSemicolon();
}

void ArkTSGen::EmitExportNamedDeclaration(const ir::AstNode *node){
    std::cout << "[+] start emit export named declaration statement"  << std::endl;
    auto exportnameddeclaration = node->AsExportNamedDeclaration();
    
    for (const auto *astnode : exportnameddeclaration->Specifiers()) {
        auto exportspecifier = astnode->AsExportSpecifier();
        this->WriteKeyWords("export");

        this->WriteSpace();
        this->EmitExpression(exportspecifier->Local());

        if(exportspecifier->Local() != exportspecifier->Exported()){
            this->WriteSpace();
            this->WriteKeyWords("as");
            this->WriteSpace();
            this->EmitExpression(exportspecifier->Exported());
        }

        this->WriteSpace();
        this->WriteKeyWords("from");
        this->WriteSpace();

        this->EmitExpression(exportnameddeclaration->Source());
    }
    this->WriteTrailingSemicolon();
}

void ArkTSGen::EmitClassDeclaration(const ir::AstNode *node){
    std::cout << "[+] start emit class declaration statement"  << std::endl;
    auto classdeclaration = node->AsClassDeclaration();
    auto classdefinition = const_cast<ir::ClassDefinition*>(classdeclaration->Definition());

    this->WriteKeyWords("class");
    this->WriteSpace();
    std::cout << classdefinition->Ident()->Name().Mutf8()  << std::endl;
    this->EmitExpression(classdefinition->Ident());
    this->WriteSpace();

    if(classdefinition->Super()){
        this->WriteKeyWords("extends");
        this->WriteSpace();
        this->EmitExpression(classdefinition->Super());
        this->WriteSpace();
    }

    this->WriteLeftBrace();
    this->WriteNewLine();

    // constructor
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(classdefinition->Ctor());

    
    // member function
    const ArenaVector<es2panda::ir::Statement *> &statements = classdefinition->Body();
    for (es2panda::ir::Statement *stmt : statements) {
        this->EmitStatement(stmt);
    }

    this->indent_ = this->indent_ - this->singleindent_;

    this->WriteRightBrace();
    this->WriteTrailingSemicolon();
    this->WriteNewLine();
}

void ArkTSGen::EmitMethodDefinition(const ir::AstNode *node){
    std::cout << "[+] start emit method definition statement"  << std::endl;
    auto methoddefinition = node->AsMethodDefinition();
    
    this->EmitExpression(methoddefinition->Key());
    this->WriteLeftParentheses();

    auto scriptfunction = methoddefinition->Value()->Function()->AsScriptFunction();

    int count = 1;
    int argumentsize = scriptfunction->Params().size();
    for (const auto *param : scriptfunction->Params()) {
        // if(count > 3){
        //     this->EmitExpression(param);
        // }else{
        //     count++;
        //     continue;
        // }
        this->EmitExpression(param);
        if(count ++ < argumentsize){
            this->WriteComma();
        }
    }
    this->WriteRightParentheses();
    this->WriteLeftBrace();
    this->WriteNewLine();
    this->indent_ = this->indent_ + this->singleindent_;
    this->EmitStatement(scriptfunction->Body());
    this->indent_ = this->indent_ - this->singleindent_;
    this->WriteIndent();
    this->WriteRightBrace();
    this->WriteNewLine();
}


void ArkTSGen::EmitStatement(const ir::AstNode *node)
{
    if(node == nullptr){
        HandleError("#EmitStatement: emitStatement for null astnode");
    }

    if(node->Type() != AstNodeType::BLOCK_STATEMENT && node->Type() != AstNodeType::VARIABLE_DECLARATOR ){
        this->WriteIndent();
    }

    std::cout << "emit statement start " << std::endl;
    switch(node->Type()){
        case AstNodeType::EXPRESSION_STATEMENT:
            std::cout << "enter EXPRESSION_STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            this->EmitExpressionStatement(node); 
            break;
        case AstNodeType::BLOCK_STATEMENT:
            std::cout << "enter BLOCK_STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitBlockStatement(node);
            break;

        case AstNodeType::VARIABLE_DECLARATION:
            std::cout << "enter VARIABLE_DECLARATION >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitVariableDeclarationStatement(node);
            break;

        case AstNodeType::VARIABLE_DECLARATOR:
            std::cout << "enter VARIABLE_DECLARATO >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitVariableDeclaratorStatement(node);
            break;

        case AstNodeType::RETURN_STATEMENT:
            std::cout << "enter RETURN STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitReturnStatement(node);
            break;

        case AstNodeType::DEBUGGER_STATEMENT:
            std::cout << "enter DEBUGGER STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitDebuggerStatement(node);
            break;

        case AstNodeType::FUNCTION_DECLARATION:
            std::cout << "enter FUNCTION_DECLARATION STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitFunctionDeclaration(node);
            break;

        case AstNodeType::IF_STATEMENT:
            std::cout << "enter IF_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitIfStatement(node);
            break;
        
        case AstNodeType::TRY_STATEMENT:
            std::cout << "enter TRY_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitTryStatement(node);
            break;

        case AstNodeType::THROW_STATEMENT:
            std::cout << "enter THROW_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitThrowStatement(node);
            break;

        case AstNodeType::WHILE_STATEMENT:
            std::cout << "enter WHILE_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitWhileStatement(node);
            break;
        
        case AstNodeType::DO_WHILE_STATEMENT:
            std::cout << "enter DOWHILE_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitDoWhileStatement(node);
            break;

        case AstNodeType::BREAK_STATEMENT:
            std::cout << "enter BREAK_STATEMENT STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl; 
            this->EmitBreakStatement(node);
            break;

        case AstNodeType::IMPORT_SPECIFIER:{
            std::cout << "enter ImportSpecifier STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            this->EmitImportSpecifier(node);
            break;
        }

        case AstNodeType::IMPORT_DECLARATION:{
            std::cout << "enter IMPORT_DECLARATION STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            this->EmitImportDeclaration(node);
            break;
        }

        case AstNodeType::EXPORT_ALL_DECLARATION:{
            std::cout << "enter EXPORT_ALL_DECLARATION STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            this->EmitExportAllDeclaration(node);
            break;
        }

        case AstNodeType::EXPORT_SPECIFIER:{
            std::cout << "enter EXPORT_SPECIFIER STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            this->EmitExportSpecifier(node);
            break;
        }

        case AstNodeType::EXPORT_NAMED_DECLARATION:{
            std::cout << "enter EXPORT_NAMED_DECLARATION STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            this->EmitExportNamedDeclaration(node);
            break;
        }

        case AstNodeType::CLASS_DECLARATION: {
            std::cout << "enter CLASS_DECLARATION STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            this->EmitClassDeclaration(node);
            break;
        }

        case AstNodeType::METHOD_DEFINITION:{
            std::cout << "enter METHOD_DEFINITION STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            this->EmitMethodDefinition(node);
            break;
        }

        case AstNodeType::FUNCTION_EXPRESSION:{
            std::cout << "enter FUNCTION_EXPRESSION STATEMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            break;
        }

        default:
            std::cout << "--------------------------------------------------------------------" << std::endl;
            HandleError("#EmitStatement : unsupport statement");
    }



    // Wrap(
    //     [this, node]() -> void {
    //         node->Dump(this);
    //     }
    // );
}




void ArkTSGen::Add(std::initializer_list<ArkTSGen::Property> props){
    AddList<std::initializer_list<ArkTSGen::Property>>(props);
}

void ArkTSGen::Add(const ArkTSGen::Property &prop){
    Serialize(prop);
}

const char *ArkTSGen::ModifierToString(ModifierFlags flags){
    if (flags & ModifierFlags::PRIVATE) {
        return "private";
    }

    if (flags & ModifierFlags::PROTECTED) {
        return "protected";
    }

    if (flags & ModifierFlags::PUBLIC) {
        return "public";
    }

    return nullptr;
}

const char *ArkTSGen::TypeOperatorToString(TSOperatorType operatorType)
{
    if (operatorType == TSOperatorType::KEYOF) {
        return "keyof";
    }

    if (operatorType == TSOperatorType::READONLY) {
        return "readonly";
    }

    if (operatorType == TSOperatorType::UNIQUE) {
        return "unique";
    }

    return nullptr;
}

void ArkTSGen::Serialize(const ArkTSGen::Property &prop)
{
    SerializePropKey(prop.Key());
    const auto &value = prop.Value();

    if (std::holds_alternative<const char *>(value)) {
        SerializeString(std::get<const char *>(value));
    } else if (std::holds_alternative<util::StringView>(value)) {
        SerializeString(std::get<util::StringView>(value));
    } else if (std::holds_alternative<bool>(value)) {
        SerializeBoolean(std::get<bool>(value));
    } else if (std::holds_alternative<double>(value)) {
        SerializeNumber(std::get<double>(value));
    } else if (std::holds_alternative<const ir::AstNode *>(value)) {
        if (dumpNodeOnly_) {
            EmitStatement(std::get<const ir::AstNode *>(value));
        } else {
            SerializeObject(std::get<const ir::AstNode *>(value));
        }
    } else if (std::holds_alternative<std::vector<const ir::AstNode *>>(value)) {
        SerializeArray(std::get<std::vector<const ir::AstNode *>>(value));
    } else if (std::holds_alternative<lexer::TokenType>(value)) {
        SerializeToken(std::get<lexer::TokenType>(value));
    } else if (std::holds_alternative<std::initializer_list<Property>>(value)) {
        SerializePropList(std::get<std::initializer_list<Property>>(value));
    } else if (std::holds_alternative<Property::Constant>(value)) {
        SerializeConstant(std::get<Property::Constant>(value));
    }
}

void ArkTSGen::SerializeToken(lexer::TokenType token)
{
    ss_ << "\"" << lexer::TokenToString(token) << "\"";
}

void ArkTSGen::SerializePropKey(const char *str)
{
    if (dumpNodeOnly_) {
        return;
    }
    ss_ << std::endl;
    Indent();
    SerializeString(str);
    ss_ << ": ";
}

void ArkTSGen::SerializeString(const char *str)
{
    ss_ << "\"" << str << "\"";
}

void ArkTSGen::SerializeString(const util::StringView &str)
{
    ss_ << "\"" << str.Utf8() << "\"";
}

void ArkTSGen::SerializeNumber(size_t number)
{
    ss_ << number;
}

void ArkTSGen::SerializeNumber(double number)
{
    if (std::isinf(number)) {
        ss_ << "\"Infinity\"";
    } else {
        ss_ << number;
    }
}

void ArkTSGen::SerializeBoolean(bool boolean)
{
    ss_ << (boolean ? "true" : "false");
}

void ArkTSGen::SerializeConstant(Property::Constant constant)
{
    switch (constant) {
        case Property::Constant::PROP_NULL: {
            ss_ << "null";
            break;
        }
        case Property::Constant::EMPTY_ARRAY: {
            ss_ << "[]";
            break;
        }
        case Property::Constant::PROP_UNDEFINED: {
            ss_ << "undefined";
            break;
        }
        default: {
            std::cout << "S1" << std::endl;
            UNREACHABLE();
        }
    }
}

void ArkTSGen::SerializePropList(std::initializer_list<ArkTSGen::Property> props)
{
    Wrap(
        [this, &props]() -> void {
            for (const auto *it = props.begin(); it != props.end(); ++it) {
                Serialize(*it);
                if (std::next(it) != props.end()) {
                    ss_ << ',';
                }
            }
        }
    );
}

void ArkTSGen::SerializeArray(std::vector<const ir::AstNode *> array)
{
    Wrap(
        [this, &array]() -> void {
            for (auto it = array.begin(); it != array.end(); ++it) {
                if (dumpNodeOnly_) {
                    EmitStatement(*it);
                } else {
                    ss_ << std::endl;
                    Indent();
                    SerializeObject(*it);
                }

                if (std::next(it) != array.end()) {
                    ss_ << ',';
                }
            }
        },
        '[', ']');
}

void ArkTSGen::SerializeObject(const ir::AstNode *object)
{
    // Wrap(   
    //     [this, object]() -> void {
    //         object->Dump(this);
    //         SerializeLoc(object->Range());
    //     }
    // );
}

void ArkTSGen::Wrap(const WrapperCb &cb, char delimStart, char delimEnd)
{
    ss_ << delimStart;

    if (dumpNodeOnly_) {
        cb();
    } else {
        indent_++;
        cb();
        ss_ << std::endl;
        indent_--;
        Indent();
    }

    ss_ << delimEnd;
}


void ArkTSGen::Indent()
{
    for (int32_t i = 0; i < indent_; i++) {
        ss_ << "  ";
    }
}

}  // namespace panda::es2panda::ir

```

`arkts.h`:

```h
#ifndef DECOMPILER_ARKTS
#define DECOMPILER_ARKTS

#include "base.h"

namespace panda::es2panda::ir {

class ArkTSGen {
public:
    class Nullable {
    public:
        explicit Nullable(const ir::AstNode *node) : node_(node) {}

        const ir::AstNode *Node() const
        {
            return node_;
        }

    private:
        const ir::AstNode *node_;
    };

    class Optional {
    public:
        using Val = std::variant<const char *, const ir::AstNode *, bool>;
        explicit Optional(const ir::AstNode *node) : value_(node) {}
        explicit Optional(const char *string) : value_(const_cast<char *>(string)) {}
        explicit Optional(bool boolean) : value_(boolean) {}

        const Val &Value() const
        {
            return value_;
        }

    private:
        Val value_;
    };

    class Property {
    public:
        class Ignore {
        public:
            Ignore() = default;
        };

        enum class Constant {
            PROP_NULL,
            EMPTY_ARRAY,
            PROP_UNDEFINED
        };

        using Val =
            std::variant<const char *, lexer::TokenType, std::initializer_list<Property>, util::StringView, bool,
                         double, const ir::AstNode *, std::vector<const ir::AstNode *>, Constant, Nullable, Ignore>;

        Property(const char *string) : value_(string) {}
        Property(util::StringView str) : value_(str) {}
        Property(bool boolean) : value_(boolean) {}
        Property(double number) : value_(number) {}
        Property(lexer::TokenType token) : value_(token) {}
        Property(std::initializer_list<Property> props) : value_(props) {}
        Property(const ir::AstNode *node) : value_(const_cast<ir::AstNode *>(node)) {}

        Property(Constant constant) : value_(constant) {}
        Property(Nullable nullable) 
        {
            if (nullable.Node()) {
                value_ = nullable.Node();
            } else {
                value_ = Property::Constant::PROP_NULL;
            }
        }

        Property(Optional optional)
        {
            const auto &value = optional.Value();
            if (std::holds_alternative<const ir::AstNode *>(value) && std::get<const ir::AstNode *>(value)) {
                value_ = std::get<const ir::AstNode *>(value);
                return;
            }

            if (std::holds_alternative<const char *>(value) && std::get<const char *>(value)) {
                value_ = std::get<const char *>(value);
                return;
            }

            if (std::holds_alternative<bool>(value) && std::get<bool>(value)) {
                value_ = std::get<bool>(value);
                return;
            }

            value_ = Ignore();
        }

        template <typename T>
        Property(const ArenaVector<T> &array)
        {
            if (array.empty()) {
                value_ = Constant::EMPTY_ARRAY;
                return;
            }

            std::vector<const ir::AstNode *> nodes;
            nodes.reserve(array.size());

            for (auto &it : array) {
                nodes.push_back(it);
            }

            value_ = std::move(nodes);
        }

        const char *Key() const
        {
            return key_;
        }

        const Val &Value() const
        {
            return value_;
        }

    private:
        const char *key_;
        Val value_ {false};
    };

    explicit ArkTSGen(const BlockStatement *program, util::StringView sourceCode);
    explicit ArkTSGen(const ir::AstNode *node);

    void EmitStatement(const ir::AstNode *node);

    void Add(std::initializer_list<Property> props);
    void Add(const ArkTSGen::Property &prop);

    static const char *ModifierToString(ModifierFlags flags);
    static const char *TypeOperatorToString(TSOperatorType operatorType);

    std::string Str() const
    {
        return ss_.str();
    }

private:
    using WrapperCb = std::function<void()>;

    template <typename T>
    void AddList(T props)
    {
        for (auto it = props.begin(); it != props.end();) {
            Serialize(*it);

            do {
                if (++it == props.end()) {
                    return;
                }
            } while (std::holds_alternative<Property::Ignore>((*it).Value()));

            ss_ << ',';
        }
    }

    void Indent();

    void EmitBlockStatement(const ir::AstNode *node);

    void WriteTrailingSemicolon(); //;
    void WriteSpace();
    void WriteLeftBrace();    // {
    void WriteRightBrace();   // }
    void WriteLeftBracket();  // [
    void WriteRightBracket(); // ]

    void WriteLeftParentheses(); // (
    void WriteRightParentheses(); // )
    

    void WriteColon();// :
    void WriteEqual();// =
    void WriteComma();// ,
    void WriteDot(); // .
    void WriteSpreadDot(); // ...
    void WriteKeyWords(std::string keyword); 
    void WriteNewLine();
    void WriteIndent();

    void EmitExpression(const ir::AstNode *node);
    void EmitExpressionStatement(const ir::AstNode *node);
    void EmitVariableDeclarationStatement(const ir::AstNode *node);
    void EmitVariableDeclaratorStatement(const ir::AstNode *node);
    void EmitReturnStatement(const ir::AstNode *node);
    void EmitBreakStatement(const ir::AstNode *node);

    void EmitDebuggerStatement(const ir::AstNode *node);
    void EmitIfStatement(const ir::AstNode *node);
    void EmitTryStatement(const ir::AstNode *node);
    void EmitThrowStatement(const ir::AstNode *node);
    void EmitWhileStatement(const ir::AstNode *node);
    void EmitDoWhileStatement(const ir::AstNode *node);

    void EmitImportSpecifier(const ir::AstNode *node);
    void EmitImportDeclaration(const ir::AstNode *node);

    void EmitExportAllDeclaration(const ir::AstNode *node);
    void EmitExportSpecifier(const ir::AstNode *node);
    void EmitExportNamedDeclaration(const ir::AstNode *node);

    void EmitClassDeclaration(const ir::AstNode *node);
    void EmitMethodDefinition(const ir::AstNode *node);

    void EmitFunctionDeclaration(const ir::AstNode *node);

    void Serialize(const ArkTSGen::Property &prop);
    void SerializePropKey(const char *str);
    void SerializeString(const char *str);
    void SerializeString(const util::StringView &str);
    void SerializeNumber(size_t number);
    void SerializeNumber(double number);
    void SerializeBoolean(bool boolean);
    void SerializeObject(const ir::AstNode *object);
    void SerializeToken(lexer::TokenType token);
    void SerializePropList(std::initializer_list<ArkTSGen::Property> props);
    void SerializeConstant(Property::Constant constant);
    void Wrap(const WrapperCb &cb, char delimStart = '{', char delimEnd = '}');

    void SerializeArray(std::vector<const ir::AstNode *> array);

    lexer::LineIndex index_;
    std::stringstream ss_;
    int32_t indent_;
    int32_t singleindent_ = 2;
    bool dumpNodeOnly_ = true;





};
}  // namespace panda::es2panda::ir

#endif  // ASTDUMP_H

```

`ast.h`:

```h
#ifndef DECOMPILER_AST
#define DECOMPILER_AST

#include "../ets_frontend/es2panda/es2panda.h"
#include "../ets_frontend/es2panda/parser/program/program.h"

/////////////////////////////////////////////////////
#include "../ets_frontend/es2panda/ir/base/catchClause.h"
#include "../ets_frontend/es2panda/ir/base/classStaticBlock.h"
#include "../ets_frontend/es2panda/ir/base/decorator.h"
#include "../ets_frontend/es2panda/ir/base/scriptFunction.h"


#include "../ets_frontend/es2panda/ir/expressions/assignmentExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/binaryExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/callExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/classExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/functionExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/memberExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/objectExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/sequenceExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/templateLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/thisExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/unaryExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/arrayExpression.h"


#include "../ets_frontend/es2panda/ir/base/property.h"
#include "../ets_frontend/es2panda/ir/base/spreadElement.h"


#include "../ets_frontend/es2panda/ir/expressions/literals/bigIntLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/numberLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/stringLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/booleanLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/nullLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/regExpLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/literals/taggedLiteral.h"


#include "../ets_frontend/es2panda/ir/expressions/memberExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/objectExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/sequenceExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/templateLiteral.h"
#include "../ets_frontend/es2panda/ir/expressions/thisExpression.h"

#include "../ets_frontend/es2panda/ir/expressions/newExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/awaitExpression.h"
#include "../ets_frontend/es2panda/ir/expressions/yieldExpression.h"

#include "../ets_frontend/es2panda/ir/expressions/omittedExpression.h"

#include "../ets_frontend/es2panda/ir/module/exportDefaultDeclaration.h"
#include "../ets_frontend/es2panda/ir/module/exportNamedDeclaration.h"

#include "../ets_frontend/es2panda/ir/statements/blockStatement.h"
#include "../ets_frontend/es2panda/ir/statements/classDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/expressionStatement.h"
#include "../ets_frontend/es2panda/ir/statements/forInStatement.h"
#include "../ets_frontend/es2panda/ir/statements/forOfStatement.h"
#include "../ets_frontend/es2panda/ir/statements/forUpdateStatement.h"
#include "../ets_frontend/es2panda/ir/statements/functionDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/returnStatement.h"
#include "../ets_frontend/es2panda/ir/statements/switchStatement.h"
#include "../ets_frontend/es2panda/ir/statements/variableDeclaration.h"
#include "../ets_frontend/es2panda/ir/statements/variableDeclarator.h"
#include "../ets_frontend/es2panda/ir/statements/debuggerStatement.h"
#include "../ets_frontend/es2panda/ir/statements/ifStatement.h"
#include "../ets_frontend/es2panda/ir/statements/tryStatement.h"
#include "../ets_frontend/es2panda/ir/statements/throwStatement.h"


#include "../ets_frontend/es2panda/ir/statements/whileStatement.h"
#include "../ets_frontend/es2panda/ir/statements/doWhileStatement.h"

#include "../ets_frontend/es2panda/ir/statements/breakStatement.h"

#include "../ets_frontend/es2panda/ir/ts/tsConstructorType.h"
#include "../ets_frontend/es2panda/ir/ts/tsEnumDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsEnumMember.h"
#include "../ets_frontend/es2panda/ir/ts/tsFunctionType.h"
#include "../ets_frontend/es2panda/ir/ts/tsImportEqualsDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsInterfaceDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsMethodSignature.h"
#include "../ets_frontend/es2panda/ir/ts/tsModuleBlock.h"
#include "../ets_frontend/es2panda/ir/ts/tsModuleDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsParameterProperty.h"
#include "../ets_frontend/es2panda/ir/ts/tsPrivateIdentifier.h"
#include "../ets_frontend/es2panda/ir/ts/tsQualifiedName.h"
#include "../ets_frontend/es2panda/ir/ts/tsSignatureDeclaration.h"
#include "../ets_frontend/es2panda/ir/ts/tsTypeParameterDeclaration.h"

#include "../ets_frontend/es2panda/ir/module/importSpecifier.h"
#include "../ets_frontend/es2panda/ir/module/importDeclaration.h"
#include "../ets_frontend/es2panda/ir/module/exportAllDeclaration.h"
#include "../ets_frontend/es2panda/ir/module/exportNamedDeclaration.h"
#include "../ets_frontend/es2panda/ir/module/exportSpecifier.h"

#include "../ets_frontend/es2panda/ir/astNode.h"

#include "../ets_frontend/es2panda/parser/parserImpl.h"

#include "../ets_frontend/es2panda/lexer/token/sourceLocation.h"
#include "../ets_frontend/es2panda/lexer/token/tokenType.h"

#include "../ets_frontend/es2panda/util/ustring.h"



template <typename T, typename... Args>
static T *AllocNode(panda::es2panda::parser::Program *parser_program_, Args &&... args)
{
    auto ret = parser_program_->Allocator()->New<T>(std::forward<Args>(args)...);
    if (ret == nullptr) {
        std::cout << "Unsuccessful allocation during parsing" << std::endl;;
    }
    return ret;
}

#endif

```

`astgen.cpp`:

```cpp
#include "astgen.h"

#include "astgen_ecma.inl"

namespace panda::bytecodeopt {

using panda_file::LiteralTag;


void AstGen::VisitTryBegin(const compiler::BasicBlock *bb)
{
    std::cout << "[+] VisitTryBegin  >>>>>>>>>>>>>>>>>" << std::endl;
    std::cout << "[-] VisitTryBegin  >>>>>>>>>>>>>>>>>" << std::endl;
}


BasicBlock* AstGen::FindNearestVisitedPred(const std::vector<BasicBlock*>& visited, BasicBlock* block) {
    if (visited.empty()) return nullptr;
    
    ArenaVector<BasicBlock*> preds = block->GetPredsBlocks();
    if (preds.empty()) return nullptr;
    
    std::unordered_set<BasicBlock*> pred_set(preds.begin(), preds.end());
    

    for (auto it = visited.rbegin(); it != visited.rend(); ++it) {
        if (pred_set.find(*it) != pred_set.end()) {
            return *it;  
        }
    }
    
    return nullptr; 
}

bool AstGen::RunImpl()
{
    
    for (auto *bb : GetGraph()->GetBlocksRPO()) {
        std::cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ visit bbid: " << bb->GetId() << std::endl;
        //if(bb->IsLoopValid() && !bb->GetLoop()->IsRoot() ){
        if(bb->IsLoopValid()  ){
            auto loop = bb->GetLoop();
            auto backedges = loop->GetBackEdges();
            auto innerloop = loop->GetInnerLoops();
            auto blocks = loop->GetBlocks();
            std::cout << "Loop Size: " << backedges.size()  << " , innerloop: " << innerloop.size()  << " , block: " << blocks.size() << std::endl;

        }


        if(bb->IsLoopValid() && bb->IsLoopHeader() ){
            JudgeLoopType(bb, this->loop2type, this->loop2exit, this->backedge2dowhileloop);
            /////////////////////////////////////////////////////////////////
            ArenaVector<panda::es2panda::ir::Statement *> statements(this->parser_program_->Allocator()->Adapter());
            auto new_block_statement =  AllocNode<es2panda::ir::BlockStatement>(this, nullptr, std::move(statements));
            
            this->whileheader2redundant[bb] = new_block_statement;
        }

        

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        auto nearestpre = this->FindNearestVisitedPred(this->visited, bb);

        if(bb != this->GetGraph()->GetStartBlock()) {
            if(nearestpre != nullptr && this->bb2lexicalenvstack_[nearestpre] != nullptr){
                std::cout << "!!!!!!!!!!!!!!!!!!!! found pre id for bb2lexicalenvstack_: " << nearestpre->GetId() << std::endl;
                this->bb2lexicalenvstack_[bb] = new LexicalEnvStack(*this->bb2lexicalenvstack_[nearestpre]);
                this->bb2sendablelexicalenvstack_[bb] = new LexicalEnvStack(*this->bb2sendablelexicalenvstack_[nearestpre]);

                std::cout << "size: " << (*this->bb2lexicalenvstack_[nearestpre]).Size()  << std::endl;
                std::cout << "sendable size: " << (*this->bb2sendablelexicalenvstack_[nearestpre]).Size()  << std::endl;
            }else{
                std::cout << "!!!!!!!!!!!!!!!!!!!! not found pre id for bb2lexicalenvstack_: "<< "curid: " << bb->GetId()  << std::endl;
                this->bb2lexicalenvstack_[bb] = new LexicalEnvStack();
                this->bb2sendablelexicalenvstack_[bb] = new LexicalEnvStack();
            }
        }
        
        this->visited.push_back(bb);        
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        this->GetBlockStatementById(bb);

        for (const auto &inst : bb->AllInsts()) {
            VisitInstruction(inst);
            if (!GetStatus()) {
                return false;
            }
        }

        // check whehter add break statement
        if(!bb->IsStartBlock()){
            BasicBlock* father = bb->GetPredecessor(0);
            if(father->IsLoopValid() && !father->GetLoop()->IsRoot()){
                if(bb->GetLoop() != father->GetLoop()  ){
                    if(bb->GetSuccsBlocks().size() == 1){
                        //std::cout << "truesucc: " << bb->GetTrueSuccessor()->GetId() << ", falsesucc: " <<  loop2exit[father->GetLoop()]->GetId() << std::endl;
                        if(bb->GetTrueSuccessor() == loop2exit[father->GetLoop()]){ 

                            this->GetBlockStatementById(bb);
                            auto breakstatement = AllocNode<es2panda::ir::BreakStatement>(this);

                            this->AddInstAst2BlockStatemntByBlock(bb, breakstatement);

                        }
                    }

                }
            }
        }


        uint32_t offset = 0;
        if(bb->IsIfBlock()){
            offset = 1;
        }
        //check if add redundant block
        if(this->whilebody2redundant.find(bb) != this->whilebody2redundant.end()){
            this->inserted_statements.erase(this->whilebody2redundant[bb]);

            this->AddInstAst2BlockStatemntByBlock(bb, this->whilebody2redundant[bb], 1);
            this->whilebody2redundant.erase(bb);
        }
    
        if(this->phiref2pendingredundant.find(bb) != this->phiref2pendingredundant.end()){
            this->inserted_statements.erase(this->phiref2pendingredundant[bb]);

            this->AddInstAst2BlockStatemntByBlock(bb, this->phiref2pendingredundant[bb], 1);
            this->phiref2pendingredundant.erase(bb);
        }
        
    }

    if (!GetStatus()) {
        return false;
    }
    // Visit try-blocks in order they were declared
    for (auto *bb : GetGraph()->GetTryBeginBlocks()) {
        VisitTryBegin(bb);
    }

    return true;
}


void AstGen::VisitSpillFill(GraphVisitor *visitor, Inst *inst_base)
{
    std::cout << "[+] VisitSpillFill  >>>>>>>>>>>>>>>>>" << std::endl;
    auto *enc = static_cast<AstGen *>(visitor);
    auto inst = inst_base->CastToSpillFill();

    for (auto sf : inst->GetSpillFills()) {
        if(sf.SrcType() != compiler::LocationType::REGISTER || sf.DstType() != compiler::LocationType::REGISTER ){
            HandleError("VisitSpillFill # unsupoort SpillFill type");
        }
        auto it = enc->reg2expression.find(sf.SrcValue());
        if (it == enc->reg2expression.end()) {
            std::cout << "VisitSpillFill # SpillFill none register"  << std::endl; 
        }else{
            enc->SetExpressionByRegister(inst, sf.DstValue(), *enc->GetExpressionByRegister(inst, sf.SrcValue()));
        }
    }
    std::cout << "[-] VisitSpillFill  >>>>>>>>>>>>>>>>>" << std::endl;
}


void AstGen::VisitConstant(GraphVisitor *visitor, Inst *inst_base)
{
    std::cout << "[+] VisitConstant  >>>>>>>>>>>>>>>>>" << std::endl;
    auto *enc = static_cast<AstGen *>(visitor);
    auto inst = inst_base->CastToConstant();
    auto type = inst->GetType();
   
    es2panda::ir::Expression* number;
    switch (type) {
        case compiler::DataType::INT64:
        case compiler::DataType::UINT64:
            number = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                            inst->GetInt64Value()
                                                        );
            break;
        case compiler::DataType::FLOAT64:
            number = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                            inst->GetDoubleValue()
                                                        );
            break;
        case compiler::DataType::INT32:
        case compiler::DataType::UINT32:
            number = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                            inst->GetInt32Value()
                                                        );
            break;
        default:
            std::cout << "S3" << std::endl;
            UNREACHABLE();
            LOG(ERROR, BYTECODE_OPTIMIZER) << "VisitConstant with unknown type" << type;
            enc->success_ = false;
    }

    enc->SetExpressionByRegister(inst, inst->GetDstReg(), number);
    
    std::cout << "[-] VisitConstant  >>>>>>>>>>>>>>>>>" << std::endl;
}


void AstGen::VisitIf(GraphVisitor *v, Inst *inst_base)
{
    std::cout << "[+] VisitIf  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToIf();

    auto left_expression = *enc->GetExpressionByRegIndex(inst, 0);
    auto right_expression = *enc->GetExpressionByRegIndex(inst, 1);

    panda::es2panda::ir::Expression* test_expression;

    switch (inst->GetCc()) {
        case compiler::CC_EQ:
            test_expression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                        left_expression,
                                                        right_expression,
                                                        BinIntrinsicIdToToken(compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8));
            break;
        case compiler::CC_NE:
            test_expression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                        left_expression,
                                                        right_expression,
                                                        BinIntrinsicIdToToken(compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8));
            break;
        default:
            std::cout << "S5" << std::endl;
            UNREACHABLE();
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////
    /// deal with while/do-while
    auto block = inst->GetBasicBlock();
    auto block_statement = enc->GetBlockStatementById(block);

    if(block->IsLoopValid() && block->IsLoopHeader()){
        std::cout << "1%%%%%%%%%%%%%%%%%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
        if(enc->loop2type[block->GetLoop()] == 1){
            std::cout << "[+] do-while ===" << std::endl;

            std::cout << "[-] do-while ===" << std::endl;
        }else{
            std::cout << "[+] while ===" << std::endl;

            auto true_statements =   enc->GetBlockStatementById(inst->GetBasicBlock()->GetTrueSuccessor());
            auto false_statements =  enc->GetBlockStatementById(inst->GetBasicBlock()->GetFalseSuccessor());
    
            if(enc->loop2exit[inst->GetBasicBlock()->GetLoop() ] == inst->GetBasicBlock()->GetTrueSuccessor() ){
                std::swap(true_statements, false_statements);
            }

            auto whilestatement = AllocNode<es2panda::ir::WhileStatement>(enc,
                                    nullptr,
                                    test_expression, 
                                    true_statements);

            enc->AddInstAst2BlockStatemntByInst(inst, whilestatement);
            enc->AddInstAst2BlockStatemntByInst(inst, false_statements);

            std::cout << "[-] while ===" << std::endl;
        }
    }else{
        std::cout << "2%%%%%%%%%%%%%%%%%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
        auto true_statements =   enc->GetBlockStatementById(inst->GetBasicBlock()->GetTrueSuccessor());
        auto false_statements =  enc->GetBlockStatementById(inst->GetBasicBlock()->GetFalseSuccessor());

        auto ifStatement = AllocNode<es2panda::ir::IfStatement>(enc, test_expression, true_statements, false_statements);
        true_statements->SetParent(block_statement);
        false_statements->SetParent(block_statement);
        
        enc->AddInstAst2BlockStatemntByInst(inst, ifStatement);

    }

    /////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////

    std::cout << "[-] VisitIf  >>>>>>>>>>>>>>>>>" << std::endl;
}

uint32_t onlyOneBranch(BasicBlock* father, AstGen * enc){
    //std::cout << "if block: " << std::to_string(father->GetId()) << std::endl;
    auto true_branch = father->GetTrueSuccessor();
    auto false_branch = father->GetFalseSuccessor();

    // 0: if-and-else

    // 1: only if

    // 2: only else

    // loop-header === 0
    if(father->IsLoopValid() && father->IsLoopHeader()){
        return 0;
    }

    BasicBlock* analysis_block = nullptr;
    if(true_branch->GetPredsBlocks().size() >= 2){
        analysis_block = true_branch;
    }else if(false_branch->GetPredsBlocks().size() >= 2){
        analysis_block = false_branch;
    }else if(true_branch->GetPredsBlocks().size() == 1 && false_branch->GetPredsBlocks().size() == 1){
        return 0;
    }else{
        HandleError("onlyOneBranch# not consider this case");
    }

    BasicBlock* other_father = nullptr;
    BasicBlock* start_block = father->GetGraph()->GetStartBlock();
    if(analysis_block->GetPredecessor(0) == father){
        other_father = analysis_block->GetPredecessor(1);
    }else{
        other_father = analysis_block->GetPredecessor(0);
    }
    std::cout << "true branch: " << std::to_string(true_branch->GetId()) << std::endl;
    std::cout << "false_branch: " << std::to_string(false_branch->GetId()) << std::endl;
    std::cout << "other_fater: " << std::to_string(other_father->GetId()) << std::endl;

    std::cout << "111111111111111111111111111111111111111111111111111111111" << std::endl;
    while(other_father != father && other_father != start_block){
        other_father = other_father->GetPredecessor(0);
    }
    
    std::cout << "222222222222222222222222222222222222222222222222222222222" << std::endl;
    if(other_father == father ){
        if(analysis_block == true_branch){
            return 2;
        }else{
            return 1;
        }
    }else if(other_father == start_block){
        return 0;
    }else{
        //std::cout << "end other_father: " << std::to_string(other_father->GetId()) << std::endl;
        HandleError("onlyOneBranch# found method is bad");
    }
    
    return 0;
}

panda::es2panda::ir::Expression* AstGen::InverseTestExpression(AstGen *enc, Inst* inst_base, uint32_t ret, panda::es2panda::ir::Expression* src_expression, bool swap_truefalse){
    [[maybe_unused]] auto inst = inst_base->CastToIfImm();
    auto new_src_expression = src_expression->AsBinaryExpression();
    auto raw_opeator = new_src_expression->OperatorType();
    auto new_operator = BinInverseToken2Token(raw_opeator);

    if(raw_opeator != new_operator){
        if(swap_truefalse == false && inst->GetCc() == compiler::CC_EQ){
            std::cout << "@ AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" << std::endl;
            new_src_expression->SetOperator(new_operator);
            return new_src_expression;
        }else if(swap_truefalse == true && inst->GetCc() == compiler::CC_NE){
            std::cout << "@ BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" << std::endl;
            new_src_expression->SetOperator(new_operator);
            return new_src_expression;
        }else{
            return src_expression;
        }
    }else{
        std::cout << "@ CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC" << std::endl;
        panda::compiler::RuntimeInterface::IntrinsicId cmpid;
        if(swap_truefalse == true){
            if(inst->GetCc() == compiler::CC_EQ){
                cmpid = compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8;
            }else{
                cmpid = compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8;
            }   
        }else{
            if(inst->GetCc() == compiler::CC_EQ){
                cmpid = compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8;
            }else{
                cmpid = compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8;
            }       
        }

        new_src_expression = AllocNode<es2panda::ir::BinaryExpression>(enc,
                                                    src_expression,
                                                    enc->constant_zero,
                                                    BinIntrinsicIdToToken(cmpid));
        return new_src_expression;
    }
}


void AstGen::VisitIfImm(GraphVisitor *v, Inst *inst_base)
{
    std::cout << "[+] VisitIfImm  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToIfImm();
    auto imm = inst->GetImm();
    panda::es2panda::ir::Expression* test_expression;
    if (imm == 0) {
        auto src_expression = *enc->GetExpressionByRegIndex(inst, 0);

        auto ret = onlyOneBranch(inst->GetBasicBlock(), enc);

        es2panda::ir::Statement* true_statements = nullptr;
        es2panda::ir::Statement* false_statements = nullptr;
        
        if(ret == 0){
            std::cout << "#VisitIfImm ret case: " << ret << std::endl;
            enc->specialblockid.insert(inst->GetBasicBlock()->GetTrueSuccessor()->GetId());
            enc->specialblockid.insert(inst->GetBasicBlock()->GetFalseSuccessor()->GetId());
            true_statements =   enc->GetBlockStatementById(inst->GetBasicBlock()->GetTrueSuccessor());
            false_statements =  enc->GetBlockStatementById(inst->GetBasicBlock()->GetFalseSuccessor());
        }else if(ret == 1){
            std::cout << "#VisitIfImm ret case: " << ret << std::endl;
            enc->specialblockid.insert(inst->GetBasicBlock()->GetTrueSuccessor()->GetId());
            true_statements =   enc->GetBlockStatementById(inst->GetBasicBlock()->GetTrueSuccessor());
        }else{
            std::cout << "#VisitIfImm ret case: " << ret << std::endl;
            enc->specialblockid.insert(inst->GetBasicBlock()->GetFalseSuccessor()->GetId());
            false_statements =   enc->GetBlockStatementById(inst->GetBasicBlock()->GetFalseSuccessor());
        }
        
        /*
            // 0: if-and-else
            // 1: only if
            // 2: only else
        */
       

        /////////////////////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////////////////////////
        /// deal with while/do-while
        auto block = inst->GetBasicBlock();

        if(enc->backedge2dowhileloop.find(block) != enc->backedge2dowhileloop.end()){
            std::cout << "[+] do-while =====" << std::endl;
            compiler::Loop* loop = block->GetLoop();
            auto back_edges = loop->GetBackEdges();
            LogBackEdgeId(back_edges);
            
            es2panda::ir::DoWhileStatement* dowhilestatement;
            
            test_expression =  enc->InverseTestExpression(enc, inst_base, ret, src_expression, false);

            std::cout << "true_statements size: " << true_statements->AsBlockStatement()->Statements().size() << std::endl;
            //HandleError("hault");
            auto dowhilebody = enc->CopyAndCreateNewBlockStatement(true_statements);
            if(block->GetTrueSuccessor() == loop->GetHeader()){
                std::cout << "do while case 1" << std::endl;
                dowhilestatement = AllocNode<es2panda::ir::DoWhileStatement>(enc,
                    nullptr,
                    dowhilebody,
                    test_expression
                );
            }else{
                std::cout << "do while case 2" << std::endl;
                dowhilestatement = AllocNode<es2panda::ir::DoWhileStatement>(enc,
                        nullptr,
                        dowhilebody,
                        test_expression
                        );
            }
            
            true_statements->AsBlockStatement()->statements_.clear(); 
            enc->AddInstAst2BlockStatemntByBlock(inst->GetBasicBlock()->GetTrueSuccessor(), dowhilestatement);
            enc->AddInstAst2BlockStatemntByBlock(inst->GetBasicBlock()->GetTrueSuccessor(), false_statements);
            enc->AddInstAst2BlockStatemntByBlock(loop->GetPreHeader(), enc->GetBlockStatementById(block)); 

            // if(AnotherBackEdgeAnalysed(block, enc->visited) || block->GetId() ==13 ){
            //     enc->AddInstAst2BlockStatemntByBlock(inst->GetBasicBlock()->GetTrueSuccessor(), dowhilestatement);
            //     enc->AddInstAst2BlockStatemntByBlock(inst->GetBasicBlock()->GetTrueSuccessor(), false_statements);
            // }else{
            //     //if(block->GetId() !=13 ){
            //     //    enc->AddInstAst2BlockStatemntByBlock(block, dowhilestatement);
            //     //}
            //     enc->AddInstAst2BlockStatemntByBlock(block, dowhilestatement);
            //     enc->AddInstAst2BlockStatemntByBlock(block, false_statements); 
            //     enc->AddInstAst2BlockStatemntByBlock(loop->GetPreHeader(), enc->GetBlockStatementById(block));           
            // }
            std::cout << "[-] do-while =====" << std::endl;
        }else if(block->IsLoopValid() && block->IsLoopHeader() && enc->loop2type[block->GetLoop()] == 0 ){
            std::cout << "[+] while ===" << std::endl;
            compiler::Loop* loop = block->GetLoop();
            auto back_edges = loop->GetBackEdges();
            LogBackEdgeId(back_edges);

            es2panda::ir::WhileStatement* whilestatement;
            if( LoopContainBlock(loop, block->GetFalseSuccessor()) ){
                std::cout << "while case 1" << std::endl;
                if(enc->whileheader2redundant[block]->Statements().size() != 0){
                    // add redundant statement in while-header

                    enc->whilebody2redundant[block->GetFalseSuccessor()] = enc->whileheader2redundant[block];
                    // adjust to RunImpl in the end of basickblock
                    // enc->AddInstAst2BlockStatemntByBlock(block->GetFalseSuccessor(), enc->whileheader2redundant[block] );
                }

                std::swap(true_statements, false_statements);
                test_expression =  enc->InverseTestExpression(enc, inst_base, ret, src_expression, true);
                whilestatement = AllocNode<es2panda::ir::WhileStatement>(enc,
                        nullptr,
                        test_expression, 
                        true_statements
                        );

                
            }else{
                std::cout << "while case 2" << std::endl;
                if(enc->whileheader2redundant[block]->Statements().size() != 0){
                    // add redundant statement in while-header
                    enc->whilebody2redundant[block->GetTrueSuccessor()] = enc->whileheader2redundant[block];
                }
                test_expression = enc->InverseTestExpression(enc, inst_base, ret, src_expression,false);
                whilestatement = AllocNode<es2panda::ir::WhileStatement>(enc,
                        nullptr,
                        test_expression, 
                        true_statements
                        );
            }

            if(true_statements != nullptr){
                enc->inserted_statements.insert(true_statements);
            }

            enc->AddInstAst2BlockStatemntByInst(inst, whilestatement);
            enc->AddInstAst2BlockStatemntByBlock(loop->GetPreHeader(), enc->GetBlockStatementById(block));
            enc->AddInstAst2BlockStatemntByInst(inst, false_statements);
            
            std::cout << "[-] while ===" << std::endl;
        }else{
            std::cout << "[+] if ===" << std::endl;
            es2panda::ir::IfStatement* ifStatement;

            if(ret == 2){
                std::cout << "if case 1" << std::endl;
                std::swap(true_statements, false_statements);
                test_expression = enc->InverseTestExpression(enc, inst_base, ret, src_expression, true);
                ifStatement = AllocNode<es2panda::ir::IfStatement>(enc, test_expression, true_statements, false_statements);
            }else{
                if(inst->GetCc() == compiler::CC_EQ){
                    std::cout << "if case 2" << std::endl;
                    std::swap(true_statements, false_statements);
                    test_expression = enc->InverseTestExpression(enc, inst_base, ret, src_expression, true);
                }else{
                    std::cout << "if case 3" << std::endl;
                    test_expression = enc->InverseTestExpression(enc, inst_base, ret, src_expression, false);
                }
                ifStatement = AllocNode<es2panda::ir::IfStatement>(enc, test_expression, true_statements, false_statements);
            }

            if(true_statements != nullptr){
                 enc->inserted_statements.insert(true_statements);
            }

            if(false_statements != nullptr){
                enc->inserted_statements.insert(false_statements);
            }

            if(true_statements != nullptr){
                enc->AddInstAst2BlockStatemntByInst(inst, ifStatement);
            }
            std::cout << "[-] if ===" << std::endl;

        }
        /////////////////////////////////////////////////////////////////////////////////////////////////

        //true_statements->SetParent(block);
        //false_statements->SetParent(block);
    }else{
        HandleError("#VisitIfImm: unhandle case");
    }
    std::cout << "[-] VisitIfImm  >>>>>>>>>>>>>>>>>" << std::endl;
}


void AstGen::VisitLoadString(GraphVisitor *v, Inst *inst_base)
{
    std::cout << "[+] VisitLoadString  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToLoadString();

    std::string source_str = enc->ir_interface_->GetStringIdByOffset(inst->GetTypeId()); 
    panda::es2panda::util::StringView name_view = panda::es2panda::util::StringView(*new std::string(source_str));
    
    auto src_expression  = AllocNode<es2panda::ir::StringLiteral>(enc, name_view);

    enc->SetExpressionByRegister(inst, inst->GetDstReg(), src_expression);
   

    std::cout << "[-] VisitLoadString  >>>>>>>>>>>>>>>>>" << std::endl;
}

void AstGen::VisitReturn(GraphVisitor *v, Inst *inst_base)
{
    std::cout << "[+] VisitReturn  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToReturn();
    switch (inst->GetType()) {
        default:
            LOG(ERROR, BYTECODE_OPTIMIZER)
                << "Codegen for " << compiler::GetOpcodeString(inst->GetOpcode()) << " failed";
            enc->success_ = false;
    }
    std::cout << "[-] VisitReturn  >>>>>>>>>>>>>>>>>" << std::endl;
}

void AstGen::VisitCastValueToAnyType(GraphVisitor *visitor, Inst *inst)
{
    std::cout << "[+] VisitCastValueToAnyType  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(visitor);

    auto cvat = inst->CastToCastValueToAnyType();
    auto input = cvat->GetInput(0).GetInst()->CastToConstant();

    es2panda::ir::Expression* source = nullptr;
    switch (cvat->GetAnyType()) {
        case compiler::AnyBaseType::ECMASCRIPT_NULL_TYPE:
            source = enc->constant_null;
            break;

        case compiler::AnyBaseType::ECMASCRIPT_UNDEFINED_TYPE: {
            source = enc->constant_undefined;
            break;
        }

        case compiler::AnyBaseType::ECMASCRIPT_INT_TYPE: {
            source = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                                input->CastToConstant()->GetIntValue()
                                            );
            break;
        }

        case compiler::AnyBaseType::ECMASCRIPT_DOUBLE_TYPE: {
            source = AllocNode<es2panda::ir::NumberLiteral>(enc, 
                                                                input->CastToConstant()->GetDoubleValue()
                                                        );
            break;
        }

        case compiler::AnyBaseType::ECMASCRIPT_BOOLEAN_TYPE: {
            uint64_t val = input->GetInt64Value();
            if (val != 0) {
                source = enc->constant_true;
            } else {
                source = enc->constant_false;
            }
            break;
        }

        case compiler::AnyBaseType::ECMASCRIPT_STRING_TYPE: {
            auto ls = cvat->GetInput(0).GetInst()->CastToLoadString();
            source = enc->id2expression[ls->GetId()];           
            break;
        }

        default:
           // UNREACHABLE();
            LOG(ERROR, BYTECODE_OPTIMIZER) << "VisitConstant with unknown type" ;
            enc->success_ = false;
    }

    enc->SetExpressionByRegister(inst, cvat->GetDstReg(), source);

    std::cout << "[-] VisitCastValueToAnyType  >>>>>>>>>>>>>>>>>" << std::endl;
}


void AstGen::VisitIntrinsic(GraphVisitor *visitor, Inst *inst_base)
{
    std::cout << "[+] VisitIntrinsic  >>>>>>>>>>>>>>>>>" << std::endl;
    ASSERT(inst_base->IsIntrinsic());
    VisitEcma(visitor, inst_base);
    std::cout << "[-] VisitIntrinsic  >>>>>>>>>>>>>>>>>" << std::endl;
}

void AstGen::VisitCatchPhi(GraphVisitor *visitor, Inst *inst)
{
    std::cout << "[+] VisitCatchPhi  >>>>>>>>>>>>>>>>>" << std::endl;
    // The Acc register stores the exception object.
    // Create an STA instruction if the exception is used later in virtual registers.
    
    if (inst->CastToCatchPhi()->IsAcc()) {
        std::cout << "cast to catchphi" << std::endl;
        auto enc = static_cast<AstGen *>(visitor);
        enc->SetExpressionByRegister(inst, inst->GetDstReg(), enc->constant_catcherror);
        bool hasRealUsers = false;
        for (auto &user : inst->GetUsers()) {
            if (!user.GetInst()->IsSaveState()) {
                hasRealUsers = true;
                break;
            }
        }
        if (hasRealUsers) {
            enc->SetExpressionByRegister(inst, inst->GetDstReg(), enc->constant_catcherror);
        }
    }
    std::cout << "[-] VisitCatchPhi  >>>>>>>>>>>>>>>>>" << std::endl;
}

#include "astgen_auxiins.cpp"
}  // namespace panda::bytecodeopt

```

`astgen.h`:

```h
#ifndef DECOMPILER_ASTGEN
#define DECOMPILER_ASTGEN

#include "base.h"
#include "lexicalenv.h"
#include "algos.h"
#include "loopconstruction.h"

namespace panda::bytecodeopt {

using compiler::BasicBlock;
using compiler::Inst;
using compiler::Opcode;


class AstGen : public compiler::Optimization, public compiler::GraphVisitor {
public:
    explicit AstGen(compiler::Graph *graph, pandasm::Function *function, 
        const BytecodeOptIrInterface *iface, pandasm::Program *prog,  es2panda::parser::Program* parser_program, 
        uint32_t methodoffset, std::map<uint32_t, LexicalEnvStack*>* method2lexicalenvstack,
        std::map<uint32_t, LexicalEnvStack*>* method2sendablelexicalenvstack, 
        std::map<uint32_t, std::string*> *patchvarspace,
        std::map<size_t, std::vector<std::string>> index2namespaces, std::vector<std::string> localnamespaces,
        std::map<uint32_t, std::set<uint32_t>> *class2memberfuns, 
        std::map<uint32_t, panda::es2panda::ir::ScriptFunction *> *method2scriptfunast, 
        std::map<uint32_t, panda::es2panda::ir::ClassDeclaration *>* ctor2classdeclast, std::set<uint32_t> *memberfuncs, 
        std::map<uint32_t, panda::es2panda::ir::Expression*> *class2father, 
        std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap,
        std::vector<LexicalEnvStack*> *globallexical_waitlist,
        std::vector<LexicalEnvStack*> *globalsendablelexical_waitlist,
        std::map<std::string, std::string> *raw2newname,
        std::map<std::string, uint32_t> *methodname2offset,
        std::string fun_name)
        : compiler::Optimization(graph), function_(function), ir_interface_(iface), program_(prog), methodoffset_(methodoffset),
        method2lexicalenvstack_(method2lexicalenvstack), method2sendablelexicalenvstack_(method2sendablelexicalenvstack), 
        patchvarspace_(patchvarspace), parser_program_(parser_program), 
        index2namespaces_(index2namespaces), localnamespaces_(localnamespaces), class2memberfuns_(class2memberfuns),
        method2scriptfunast_(method2scriptfunast), ctor2classdeclast_(ctor2classdeclast), memberfuncs_(memberfuncs), class2father_(class2father),
        method2lexicalmap_(method2lexicalmap), globallexical_waitlist_(globallexical_waitlist), globalsendablelexical_waitlist_(globalsendablelexical_waitlist), 
        raw2newname_(raw2newname), methodname2offset_(methodname2offset), fun_name_(fun_name)
    {

        this->closure_count = 0;
        this->privatevar_count = 0;

        ArenaVector<es2panda::ir::Expression*> arguments(parser_program->Allocator()->Adapter());

        if(this->method2lexicalenvstack_->find(methodoffset) != this->method2lexicalenvstack_->end()){
            //std::cout << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX found lexicalenvstack " << std::endl;
            //auto x = (*this->method2lexicalenvstack_)[methodoffset];
            //std::cout << "lexicalenvstack size: " << x->Size() << std::endl;
        }else{
            //std::cout << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX not found lexicalenvstack " << std::endl;
            (*this->method2lexicalenvstack_)[methodoffset] = new LexicalEnvStack();
        }

        if(this->method2sendablelexicalenvstack_->find(methodoffset) != this->method2sendablelexicalenvstack_->end()){
            std::cout << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX found lexicalenvstack " << std::endl;
            auto x = (*this->method2sendablelexicalenvstack_)[methodoffset];
            std::cout << "sendablelexicalenvstack size: " << x->Size() << std::endl;
        }else{
            //std::cout << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX not found lexicalenvstack " << std::endl;
            (*this->method2sendablelexicalenvstack_)[methodoffset] = new LexicalEnvStack();
        }


        this->bb2lexicalenvstack_[graph->GetStartBlock()] = (*this->method2lexicalenvstack_)[methodoffset];
        this->bb2sendablelexicalenvstack_[graph->GetStartBlock()] = (*this->method2sendablelexicalenvstack_)[methodoffset];
        
        for (size_t i = 0; i < function->GetParamsNum(); ++i) {
            if(i <= 2){
                continue;
            }
            //std::string* argname = ;
            //panda::es2panda::util::StringView tmp_name_view = panda::es2panda::util::StringView(*argname);
            arguments.push_back(this->getParameterName(i));
        }

        ArenaVector<panda::es2panda::ir::Statement *> func_statements(parser_program->Allocator()->Adapter());
        auto body = parser_program->Allocator()->New<panda::es2panda::ir::BlockStatement>(nullptr, std::move(func_statements));
        panda::es2panda::ir::ScriptFunctionFlags flags_ {panda::es2panda::ir::ScriptFunctionFlags::NONE};
        auto funcNode = parser_program->Allocator()->New<panda::es2panda::ir::ScriptFunction>(nullptr, std::move(arguments), nullptr, body, nullptr, flags_, true, false);
        
        
        (*this->method2scriptfunast_)[methodoffset] = funcNode;

        auto newfunname = this->RemovePrefixOfFunc(fun_name);
        (*this->raw2newname_)[fun_name] = newfunname;
        panda::es2panda::util::StringView name_view = panda::es2panda::util::StringView(*new std::string(newfunname));
        auto funname_id = AllocNode<panda::es2panda::ir::Identifier>(this, name_view);
                

        funcNode->SetIdent(funname_id);

        this->id2block[graph->GetStartBlock()->GetId()] = body;

        //this->lcaFinder = std::make_unique<LCAFinder>(graph);

    }

    ~AstGen() override = default;
    bool RunImpl() override;

    const char *GetPassName() const override
    {
        return "AstGen";
    }

    bool GetStatus() const
    {
        return success_;
    }

    const ArenaVector<BasicBlock *> &GetBlocksToVisit() const override
    {
        return GetGraph()->GetBlocksRPO();
    }
    
    static void VisitSpillFill(GraphVisitor *visitor, Inst *inst);
    static void VisitConstant(GraphVisitor *visitor, Inst *inst);
    static void VisitCatchPhi(GraphVisitor *visitor, Inst *inst);

    static void VisitIf(GraphVisitor *v, Inst *inst_base);
    static void VisitIfImm(GraphVisitor *v, Inst *inst_base);
    static void IfImmZero(GraphVisitor *v, Inst *inst_base);
    static void VisitIntrinsic(GraphVisitor *visitor, Inst *inst_base);
    static void VisitLoadString(GraphVisitor *v, Inst *inst_base);
    static void VisitReturn(GraphVisitor *v, Inst *inst_base);

    static void VisitCastValueToAnyType(GraphVisitor *v, Inst *inst_base);

    static void VisitEcma(GraphVisitor *v, Inst *inst_base);
    static void IfEcma(GraphVisitor *v, compiler::IfInst *inst);

    static void VisitPhi(GraphVisitor* v, Inst* inst_base);
    static void VisitTry(GraphVisitor* v, Inst* inst_base);
    static void VisitSaveState(GraphVisitor* v, Inst* inst_base);
    static void VisitParameter(GraphVisitor* v, Inst* inst_base);
    
    BasicBlock* FindNearestVisitedPred(const std::vector<BasicBlock*>& visited, BasicBlock* block);
    panda::es2panda::ir::Expression* InverseTestExpression(AstGen *enc, Inst* inst_base, uint32_t ret, panda::es2panda::ir::Expression* src_expression, bool swap_truefalse);

    template <typename T, typename... Args>
    static T *AllocNode(AstGen * astgen, Args &&... args)
    {
        auto ret = astgen->parser_program_->Allocator()->New<T>(std::forward<Args>(args)...);
        if (ret == nullptr) {
            std::cout << "Unsuccessful allocation during parsing" << std::endl;;
        }
        return ret;
    }

    void VisitDefault(Inst *inst) override
    {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Opcode " << compiler::GetOpcodeString(inst->GetOpcode())
                                       << " not yet implemented in codegen";
        success_ = false;
    }

    panda::es2panda::ir::Expression* getParameterName(int argnum){
        // if(enc->memberfuncs_->find(enc->methodoffset_) != enc->memberfuncs_->end() && inst->GetArgNumber() < 3){
        //     arg = enc->GetIdentifierByName("this");
        // }else{
        //      arg = enc->GetIdentifierByName("arg" + std::to_string(inst->GetArgNumber()-3));
        // }

        panda::es2panda::ir::Expression* arg = nullptr;
        if(argnum == 0){
            arg = this->GetIdentifierByName("FunctionObject");
        }else if(argnum == 1){
            arg = this->GetIdentifierByName("NewTarget");
        }else if(argnum == 2){
            arg = this->GetIdentifierByName("this");
        }else{
            arg = this->GetIdentifierByName("arg" + std::to_string(argnum - 3));
        }
        return arg;
    }

    void MarkAsync(){
        auto funcNode = (*this->method2scriptfunast_)[this->methodoffset_];
        funcNode->AddFlag(es2panda::ir::ScriptFunctionFlags::ASYNC);  
    }

    es2panda::ir::BlockStatement* CopyAndCreateNewBlockStatement(es2panda::ir::Statement* rawblockstatement){
        ArenaVector<panda::es2panda::ir::Statement *> statements(this->parser_program_->Allocator()->Adapter());
        auto new_block_statement = AllocNode<es2panda::ir::BlockStatement>(this, nullptr, std::move(statements));

        int insertpos = statements.size();
        for(auto rawstatement : rawblockstatement->AsBlockStatement()->Statements()){
            new_block_statement->AddStatementAtPos(insertpos , rawstatement);
            insertpos++;
        }
        std::cout <<  "#CopyAndCreateNewBlockStatement: " << new_block_statement->Statements().size() << std::endl;;

        return new_block_statement;
    }

    void LocateAndRmoveStatement(const std::vector<BasicBlock*>& visited, panda::es2panda::ir::Statement *blockstatement, panda::es2panda::ir::Statement *statement){
        std::cout << "#LocateAndRmoveStatement search:  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
        auto& statements = blockstatement->AsBlockStatement()->statements_;
        std::cout << "@@@@@@ pre blocksize: " <<  statements.size() << std::endl;
    
        auto it = statements.begin();
        while (it != statements.end()) {
            if (*it == statement) {
                it = statements.erase(it);
                this->inserted_statements.erase(statement);;
            } else {
                ++it;
            }
        }
        
    }


    void LocateAndReplaceAST(const std::vector<BasicBlock*>& visited, compiler::BasicBlock* block, panda::es2panda::ir::Statement *oldstatement, panda::es2panda::ir::Statement *newstatement){
        if (visited.empty()){
            HandleError("#LocateAndReplaceAST: locate block failed1");
        }

        ArenaVector<BasicBlock*> preds = block->GetPredsBlocks();
        if(preds.empty()){
            HandleError("#LocateAndReplaceAST: locate block failed2");
        }

        std::cout << "#LocateAndReplaceAST search >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
        for (BasicBlock* pre : preds) {
            if (pre == nullptr || pre == block || !contains(visited, pre)) {
                continue;
            }

            ArenaVector<panda::es2panda::ir::Statement *> statements(this->parser_program_->Allocator()->Adapter());
            auto new_block_statement = AllocNode<es2panda::ir::BlockStatement>(this, nullptr, std::move(statements));

            for(auto pre_singlestatement : this->GetBlockStatementById(pre)->AsBlockStatement()->Statements()){
                // locate branch ins: while/dowhile/if/try
                if(pre_singlestatement->IsWhileStatement() && pre_singlestatement->AsWhileStatement()->Body() == oldstatement){
                    this->id2block[block->GetId()] = new_block_statement;
                    this->AddInstAst2BlockStatemntByBlock(block, newstatement);
                    pre_singlestatement->AsWhileStatement()->body_ = new_block_statement;
                }else if(pre_singlestatement->IsIfStatement() ){

                }else if(pre_singlestatement->IsDoWhileStatement()){

                }else if(pre_singlestatement->IsTryStatement()){

                }

            }    
            
        }


        // for (BasicBlock* block : preds) {
        //     if (block != nullptr && ) {
        //         block->PrintInfo();
        //     }
        // }

        // std::unordered_set<BasicBlock*> pred_set(preds.begin(), preds.end());
        // for (auto it = visited.rbegin(); it != visited.rend(); ++it) {
        //     if (pred_set.find(*it) != pred_set.end()) {
        //         return *it;  
        //     }
        // }

        // auto fatherstatement = this->GetBlockStatementById(nearestpre);



    }


    std::string RemovePrefixOfFunc(const std::string& input) {
        if(this->raw2newname_->find(input) != this->raw2newname_->end()){
            return (*this->raw2newname_)[input];
        }

        auto coarsename = RemoveArgumentsOfFunc(input);

        size_t hashPos = coarsename.find_last_of('#');
        std::string result;
        if (hashPos != std::string::npos) {
            result = coarsename.substr(hashPos + 1);
        } else {
            result = coarsename;
        }
        
        if(result == "" || result.rfind("^", 0) == 0){
            result =  "func_" + std::to_string(count++);
        }

        if (result.rfind("#~@0>#", 0) == 0){
            result = input.substr(6);
            if(result == "" || result.rfind("^", 0) == 0){
                result = "func_" + std::to_string(count++);
            }
        }

        (*this->raw2newname_)[input] = result;

        return result;
        
    }

    panda::es2panda::ir::NumberLiteral* GetLiteralByNum(uint32_t index){
        panda::es2panda::ir::NumberLiteral* literal;
        if (this->num2literals.find(index)  != this->num2literals.end()) {
            literal = this->num2literals[index];
        } else {
            literal = AllocNode<panda::es2panda::ir::NumberLiteral>(this, index);
            this->num2literals[index] = literal;
        }
        return literal;
    }

    panda::es2panda::ir::Identifier* GetIdentifierByReg(compiler::Register reg){
        panda::es2panda::ir::Identifier* identifier;
        if (this->identifers.find(reg)  != this->identifers.end()) {
            identifier =  this->identifers[reg];
        } else {
            std::string* raw_name =  new std::string("v" + std::to_string(reg));

            panda::es2panda::util::StringView reg_name = panda::es2panda::util::StringView( *raw_name);
            identifier = AllocNode<panda::es2panda::ir::Identifier>(this, reg_name);
            this->identifers[reg] = identifier;
            this->str2identifers[*raw_name ] = identifier;
        }
        return identifier;
    }

    panda::es2panda::ir::Identifier* GetIdentifierByName(std::string raw_name){
        panda::es2panda::ir::Identifier* identifier;
        if (this->str2identifers.find(raw_name)  != this->str2identifers.end()) {
            identifier = this->str2identifers[raw_name];
        } else {
            panda::es2panda::util::StringView name_view = panda::es2panda::util::StringView(*new std::string(raw_name));
            identifier = AllocNode<panda::es2panda::ir::Identifier>(this, name_view);
            this->str2identifers[raw_name] = identifier;
        }
        return identifier;
    }


    panda::es2panda::ir::Identifier* GetIdentifierByName(std::string* raw_name){
        return this->GetIdentifierByName(*raw_name);
    }

    // uint32_t DetectDepthOfAST(es2panda::ir::Expression* expression){
    //     uint32_t astdepth = 0;
    //     expression->Iterate([&astdepth](const es2panda::ir::AstNode *astNode) -> void {
    //         std::cout << "astdepth: " << astdepth++ << std::endl;
    //     });

    //     return astdepth;
    // }


    uint32_t DetectComplexOfAST(es2panda::ir::Expression* expression){
        if (expression == nullptr) return 0;

        uint32_t astcomplex = 0;
        
        std::function<void(const es2panda::ir::AstNode*)> analyzeNode = 
            [&](const es2panda::ir::AstNode* node) {
            if (node == nullptr) return;

            std::cout << "astcomplex: " << astcomplex++ << std::endl;
            switch (node->Type()) {
                case es2panda::ir::AstNodeType::BINARY_EXPRESSION: {
                    auto binaryExpr = node->AsBinaryExpression();
                    analyzeNode(binaryExpr->Left());
                    analyzeNode(binaryExpr->Right());
                    return;
                }
                default:
                    return;
            }
            return;
        };


        analyzeNode(expression);

        return astcomplex;
    }

    void HandleNewCreatedExpression(Inst* inst, es2panda::ir::Expression* expression){
        if(inst->HasUsers()){
            
            this->SetExpressionByRegister(inst, inst->GetDstReg(), expression);

            auto curtargetid = inst->GetId();
            auto astcomplex = this->DetectComplexOfAST(expression);
                        
            if(astcomplex>5 || expression->IsCallExpression() || this->undefinedregids.find(curtargetid) != this->undefinedregids.end()){
                // dealwith untraved_reference
                auto dst_reg_identifier = this->GetIdentifierByReg(curtargetid);
                auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(this, 
                                                                                    dst_reg_identifier,
                                                                                    expression,
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );
                auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(this, assignexpression);
                this->AddInstAst2BlockStatemntByInst(inst, assignstatement);

                this->SetExpressionByRegister(inst, inst->GetDstReg(), dst_reg_identifier);
            }
        }else{
            if(expression->IsCallExpression()){
                auto callstatement = AllocNode<es2panda::ir::ExpressionStatement>(this, expression);
                this->AddInstAst2BlockStatemntByInst(inst, callstatement);
            }

        }
    }

    std::optional<panda::es2panda::ir::Expression*> GetExpressionByAcc(Inst* inst){
        return this->GetExpressionByRegIndex(inst, inst->GetInputsCount() - 2);
    }

    std::optional<panda::es2panda::ir::Expression*> GetExpressionByRegIndex(Inst* inst, uint32_t index){
        auto id = inst->GetInput(index).GetInst()->GetId();
        
        auto it = this->id2expression.find(id);
        if (it != this->id2expression.end()) {
            std::cout << "#GetExpressionByRegister: " << std::to_string(id) << std::endl;
            return it->second;  
        }
        

        auto untraveled_var =  this->GetIdentifierByReg(id); 
        this->SetExpressionById(id, untraveled_var);

        this->undefinedregids.insert(id);

        return untraveled_var;
        //HandleError("can't find expression in reg2expression: " + std::to_string(id));
        //return std::nullopt;
    }

    void SetExpressionById(uint32_t id, panda::es2panda::ir::Expression* value){
        if(value == nullptr){
            HandleError("#SetExpressionByRegister: can't set null expression in reg2expression");
        }
        this->id2expression[id] = value;
    }


    std::optional<panda::es2panda::ir::Expression*> GetExpressionByRegister(Inst* inst, compiler::Register key){
        auto it = this->reg2expression.find(key);
        if (it != this->reg2expression.end()) {
            std::cout << "#GetExpressionByRegister: " << std::to_string(key) << std::endl;
            return it->second;  
        }

        HandleError("can't find expression in reg2expression: " + std::to_string(key));
        
        return std::nullopt;
    }


    void SetExpressionByRegister(Inst* inst, compiler::Register key, panda::es2panda::ir::Expression* value){
        if(value == nullptr){
            HandleError("#SetExpressionByRegister: can't set null expression in reg2expression");
        }
        this->SetExpressionById(inst->GetId(), value);

        std::cout << "#SetExpressionByRegister: " << std::to_string(key) << std::endl;
        
        this->reg2expression[key] = value;
    }

    void Logid2BlockKeys(){
        std::cout << "id2block keys: ";
        for (const auto& pair : this->id2block) {
            std::cout << pair.first << ", ";
        }
        std::cout << std::endl;
    }

    void LogCurLexicalIndexes(Inst* inst){
        if(this->bb2lexicalenvstack_[inst->GetBasicBlock()]->Empty()){
            return;
        }
        this->bb2lexicalenvstack_[inst->GetBasicBlock()]->GetLexicalEnv(0).LogIndexes();
    }

    void LogSpecialBlockId(){
        std::cout << "specialblockid: ";
        for (auto it = this->specialblockid.begin(); it != this->specialblockid.end(); ++it) {
            std::cout << *it;
            if (std::next(it) != this->specialblockid.end()) {
                std::cout << ", ";
            }
        }
        std::cout << std::endl;
    }
 
    void AddInstAst2BlockStatemntByInst(Inst *inst, es2panda::ir::Statement *statement){
        BasicBlock* block = inst->GetBasicBlock();
        this->AddInstAst2BlockStatemntByBlock(block, statement);

        if(block->IsLoopValid() && block->IsLoopHeader() && inst->GetOpcode()!= Opcode::If   && inst->GetOpcode()!= Opcode::IfImm ){
            auto headerblockstatements = this->whileheader2redundant[block];
            const auto &statements = headerblockstatements->Statements();
            headerblockstatements->AddStatementAtPos(statements.size(), statement);
        }
    }

    panda::es2panda::ir::Expression *GetExpressionByLiteral(panda::pandasm::LiteralArray::Literal literal){
        /*
            std::variant<bool, uint8_t, uint16_t, uint32_t, uint64_t, float, double, std::string> value_;

        */
        panda::es2panda::ir::Expression *tmp = nullptr;
        if(literal.IsBoolValue()){
            tmp = AllocNode<panda::es2panda::ir::BooleanLiteral>(this, std::get<bool>(literal.value_));
        }else if(literal.IsByteValue()){
            tmp = AllocNode<panda::es2panda::ir::NumberLiteral>(this, std::get<uint8_t>(literal.value_));
        }else if(literal.IsShortValue() || literal.tag_ == panda::panda_file::LiteralTag::METHODAFFILIATE){
            tmp = AllocNode<panda::es2panda::ir::NumberLiteral>(this, std::get<uint16_t>(literal.value_));
        }else if(literal.IsIntegerValue()){
            tmp = AllocNode<panda::es2panda::ir::NumberLiteral>(this, std::get<uint32_t>(literal.value_));
        }else if(literal.IsLongValue()){
            tmp = AllocNode<panda::es2panda::ir::NumberLiteral>(this, std::get<uint64_t>(literal.value_));
        }else if(literal.IsFloatValue()){
            tmp = AllocNode<panda::es2panda::ir::NumberLiteral>(this, std::get<float>(literal.value_));
        }else if(literal.IsDoubleValue()){
            tmp = AllocNode<panda::es2panda::ir::NumberLiteral>(this, std::get<double>(literal.value_));
        }else if(literal.IsStringValue() || literal.tag_ == panda::panda_file::LiteralTag::LITERALARRAY ){
            panda::es2panda::util::StringView literal_strview(* new std::string(std::get<std::string>(literal.value_)));
            tmp = AllocNode<panda::es2panda::ir::StringLiteral>(this, literal_strview);
        }else{
            // METHODAFFILIATE = 0x0a  
            // ASYNCMETHOD = 0x18
            // LITERALARRAY = 0x19
            std::cout << "value tag: " << static_cast<int>(literal.tag_) << std::endl;
            HandleError("unsupport literal type error");
        }
        return tmp;
    }

    void AddInstAst2BlockStatemntByBlock(BasicBlock* block, es2panda::ir::Statement *statement, uint32_t offset = 0){
        if(this->inserted_statements.find(statement ) == this->inserted_statements.end() ){
            this->inserted_statements.insert(statement);
        }else{
            return;
        }

        es2panda::ir::BlockStatement* block_statements = this->GetBlockStatementById(block);

        const auto &statements = block_statements->Statements();
        if(statements.size() > offset) {
            block_statements->AddStatementAtPos(statements.size() - offset, statement);
        }else{
            block_statements->AddStatementAtPos(statements.size() , statement);
        }        
    }

    bool father_visited(BasicBlock *block){
        if(block->IsStartBlock()) {
            return true;
        }
        
        for(uint32_t index = 0; index < block->GetPredsBlocks().size(); index ++){
            auto father = block->GetPredecessor(index);

            if(std::find(visited.begin(), visited.end(), father) != visited.end()){
                return true;
            }
        }

        return false;
    }

    std::optional<std::string> GetNameFromExpression(es2panda::ir::Expression* rawexpression){
        if(rawexpression->IsIdentifier()){
            auto objname = rawexpression->AsIdentifier()->Name().Mutf8();
            return objname;
        }else if(rawexpression->IsStringLiteral()){
            auto idname = rawexpression->AsStringLiteral()->Str().Mutf8();
            return idname;
        }else if(rawexpression->IsMemberExpression()){
            auto rawobj = rawexpression->AsMemberExpression()->Object();
            auto rawprop = rawexpression->AsMemberExpression()->Property();

            auto objname = GetNameFromExpression(rawobj);
            auto propname = GetNameFromExpression(rawprop);

            if(objname && propname){
                return *objname + "." + *propname;
            }else{
                return nullptr;
                HandleError("#GetNameFromExpression: not support this case 1"); 
            }    
        }else if(rawexpression->IsNumberLiteral()){
            auto idname = rawexpression->AsNumberLiteral()->Str().Mutf8();
            return idname;
        }else if(rawexpression->IsCallExpression()){
            auto callee = rawexpression->AsCallExpression()->Callee();
            if(callee->IsFunctionExpression()){
                auto id = callee->AsFunctionExpression()->Function()->Id();
                return GetNameFromExpression(id);
            }else if(callee->IsIdentifier()){
                return GetNameFromExpression(callee);
            }else{
                std::cout << "###: " << std::to_string(static_cast<int>(callee->Type())) << std::endl;
                HandleError("#GetNameFromExpression: not support this case 2"); 
            }
        }else if(rawexpression->IsNullLiteral() ){
            return "null";
        }else if(rawexpression->IsBooleanLiteral()){
            return rawexpression->AsBooleanLiteral()->Value() == true ? "true" : "false";;
        }else if(rawexpression->IsStringLiteral()){
            return rawexpression->AsStringLiteral()->Str().Mutf8();
        }else if(rawexpression->IsBigIntLiteral()){
            return rawexpression->AsBigIntLiteral()->Str().Mutf8();
        }else if(rawexpression->IsNumberLiteral()){
            return rawexpression->AsNumberLiteral()->Str().Mutf8();
        }else if(rawexpression->IsNewExpression()){
            auto callee = rawexpression->AsNewExpression()->Callee();
            return GetNameFromExpression(const_cast<es2panda::ir::Expression*>(callee));
        }else if(rawexpression->IsBinaryExpression()){
            auto binexpression = rawexpression->AsBinaryExpression();
            auto tokentype = es2panda::lexer::TokenToString(binexpression->OperatorType());

            auto left = GetNameFromExpression(binexpression->Left());
            auto right = GetNameFromExpression(binexpression->Right());

            if(left && right){
                return *left + " " + tokentype + " " +  *right;
            }else{
                return nullptr;
                HandleError("#GetNameFromExpression: not support this case 3"); 
            }
        }else{
            std::cout << "###: " << std::to_string(static_cast<int>(rawexpression->Type())) << std::endl;
            HandleError("#GetNameFromExpression: not support this case 4"); 
        }
        return nullptr;
    }

    es2panda::ir::BlockStatement* GetBlockStatementById(BasicBlock *block){
        auto block_id = block->GetId();
        std::cout << "[*] GetBlockStatementById bbid: " << block_id << ", ";


        if(!father_visited(block)){
            HandleError("#GetBlockStatementById : cann't find father except for root" );
        }

        // case1: found blockstatment
        if (this->id2block.find(block_id) != this->id2block.end()) {
            std::cout << "@@ case 1" << std::endl;
            return this->id2block[block_id];
        }
        
        // case2: found loop
        if(block->IsLoopValid() && block->IsLoopHeader() ){
            std::cout << "@@ case 2" << std::endl;
            JudgeLoopType(block, this->loop2type, this->loop2exit, this->backedge2dowhileloop);

            //////////////////////////////////////////////////////////////////////////////////////
            ArenaVector<panda::es2panda::ir::Statement *> statements(this->parser_program_->Allocator()->Adapter());
            auto new_block_statement = AllocNode<es2panda::ir::BlockStatement>(this, nullptr, std::move(statements));
            
            this->id2block[block_id] = new_block_statement;
            return this->id2block[block_id];
        }

        ///////////////////////////////////////////////////////////////////////////////////////////

        // case3: found unique predecessor with unique successor
        if(block->GetPredsBlocks().size() == 1 && !block->IsStartBlock() && block->GetPredecessor(0)->GetSuccsBlocks().size() == 1){
            std::cout << "@@ case 3" << std::endl;
            BasicBlock* ancestor_block = block->GetPredecessor(0);

            if(this->id2block.find(ancestor_block->GetId()) != this->id2block.end()){
                this->id2block[block_id] =  this->id2block[ancestor_block->GetId()];
            }else{
                this->Logid2BlockKeys();
                HandleError("#GetBlockStatementById: find ancestor error: ", block_id);
            }
            

            return this->id2block[block_id];
        }
        
        // case4: found multi predecessor with onlyif
        if(block->GetPredsBlocks().size() == 2 && block_id != 0 && ( block->GetPredecessor(0)->IsIfBlock() || block->GetPredecessor(1)->IsIfBlock() )){
            if(block->GetPredecessor(0)->IsIfBlock()){
                this->id2block[block_id] =  this->id2block[block->GetPredecessor(0)->GetId()];
            }else{
                this->id2block[block_id] =  this->id2block[block->GetPredecessor(1)->GetId()];
            }
        }

        // case5:create new statements
        std::cout << "@@ case 5" << std::endl;
        ArenaVector<panda::es2panda::ir::Statement *> statements(this->parser_program_->Allocator()->Adapter());
        auto new_block_statement = AllocNode<es2panda::ir::BlockStatement>(this, nullptr, std::move(statements));

        this->id2block[block_id] = new_block_statement;

        LogSpecialBlockId();

        // nested if-else
        if(this->specialblockid.find(block_id) == this->specialblockid.end() ){
            BasicBlock* ancestor_block = nullptr;

            ancestor_block = block->GetDominator();

            if(ancestor_block == nullptr){
                HandleError("GetBlockStatementById# find ancestor is nullptr");
            }
            std::cout << "@ ancestor_block: " <<  std::to_string(ancestor_block->GetId()) <<  std::endl;

            auto ancestor_block_statements = this->GetBlockStatementById(ancestor_block);
            this->id2block[block_id] =  ancestor_block_statements;

            this->AddInstAst2BlockStatemntByBlock(ancestor_block, new_block_statement);
            

            return this->id2block[block_id];
        }else{
            //HandleError("GetBlockStatementById# unsupported case, blockid: ", block_id);
            /**
             * add statement in special statements
             * a) if
             * b) try-catch 
             * c) ...
            */

        }
        
        es2panda::ir::BlockStatement* curstatement = nullptr;
        if(this->id2block.find(block_id) != this->id2block.end()){
            curstatement = this->id2block[block_id];
        }else{
            HandleError("GetBlockStatementById# unsupported case, blockid: ", block_id);
        }
        return curstatement;
    }

#include "compiler/optimizer/ir/visitor.inc"

private:
    void VisitTryBegin(const compiler::BasicBlock *bb);

public:
    pandasm::Function *function_;
    const BytecodeOptIrInterface *ir_interface_;
    pandasm::Program *program_;

    uint32_t methodoffset_;
    uint32_t closure_count;

    uint32_t privatevar_count;

    std::set<es2panda::ir::Statement*> inserted_statements;

    std::map<uint32_t, LexicalEnvStack*>* method2lexicalenvstack_;
    std::map<uint32_t, LexicalEnvStack*>* method2sendablelexicalenvstack_;

    std::map<uint32_t, std::string*> *patchvarspace_;

    es2panda::parser::Program* parser_program_;

    std::map<size_t, std::vector<std::string>> index2namespaces_;
    std::vector<std::string> localnamespaces_;
    std::map<uint32_t, std::set<uint32_t>> *class2memberfuns_;
    std::map<uint32_t, panda::es2panda::ir::ScriptFunction *> *method2scriptfunast_;
    std::map<uint32_t, panda::es2panda::ir::ClassDeclaration *>* ctor2classdeclast_;

    std::set<uint32_t> *memberfuncs_;

    std::map<uint32_t, panda::es2panda::ir::Expression*> *class2father_;

    std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap_;

    std::vector<LexicalEnvStack*> *globallexical_waitlist_;
    std::vector<LexicalEnvStack*> *globalsendablelexical_waitlist_;

    std::map<std::string, std::string> *raw2newname_;

    std::map<std::string, uint32_t> *methodname2offset_;

    std::string fun_name_;

    
    ///////////////////////////////////////////////////////////////////////////////////////
    uint32_t current_constructor_offset;

    std::unique_ptr<LCAFinder> lcaFinder;

    bool success_ {true};

    std::string* acc_global_str = NULL;

    panda::es2panda::ir::Expression* acc = NULL;

    panda::es2panda::ir::Expression* thisptr= NULL;

    std::map<compiler::Loop *, uint32_t> loop2type; // 0-while, 1-dowhile
    std::map<compiler::Loop *, BasicBlock*> loop2exit; 
    std::map<compiler::BasicBlock*, compiler::Loop *> backedge2dowhileloop;

    std::map<compiler::BasicBlock*, es2panda::ir::BlockStatement*> whileheader2redundant;
    std::map<compiler::BasicBlock*, es2panda::ir::BlockStatement*> whilebody2redundant;

    std::map<compiler::BasicBlock*, es2panda::ir::BlockStatement*> phiref2pendingredundant;

    std::map<uint32_t, es2panda::ir::BlockStatement*> id2block;

    std::set<uint32_t> specialblockid;

    std::map<compiler::Register, panda::es2panda::ir::Identifier*> identifers;
    

    std::map<std::string, panda::es2panda::ir::Identifier*> str2identifers;
    std::map<uint32_t, panda::es2panda::ir::NumberLiteral*> num2literals;

    std::map<compiler::Register, panda::es2panda::ir::Expression*> reg2expression;

    LexicalEnv* acc_lexicalenv = NULL;

    std::map<compiler::BasicBlock*, LexicalEnvStack*> bb2lexicalenvstack_;

    std::map<compiler::BasicBlock*, LexicalEnvStack*> bb2sendablelexicalenvstack_;

    std::map<uint32_t, panda::es2panda::ir::Expression*> id2expression;
    std::set<uint32_t> undefinedregids;

    std::vector<BasicBlock *> visited;
    
    std::map<uint32_t, es2panda::ir::BlockStatement*> tyrid2block;
    std::map<uint32_t, panda::es2panda::ir::TryStatement*> tyridtrystatement;
    std::map<uint32_t, panda::es2panda::ir::CatchClause*> tyrid2catchclause;


    std::map<panda::es2panda::ir::Identifier*, panda::es2panda::ir::Expression*> globalname2expression_;

    std::set<panda::es2panda::ir::Expression*> not_add_assgin_for_stlexvar; // class and instance_initializer

    panda::es2panda::ir::Identifier* constant_undefined = AllocNode<panda::es2panda::ir::Identifier>(this, "undefined");
    panda::es2panda::ir::Identifier* constant_hole = AllocNode<panda::es2panda::ir::Identifier>(this, "hole");

    panda::es2panda::ir::Identifier* constant_nan = AllocNode<panda::es2panda::ir::Identifier>(this, "NaN");
    panda::es2panda::ir::Identifier* constant_infinity = AllocNode<panda::es2panda::ir::Identifier>(this, "infinity");
    panda::es2panda::ir::Identifier* constant_catcherror = AllocNode<panda::es2panda::ir::Identifier>(this, "error");
    panda::es2panda::ir::Identifier* constant_symbol = AllocNode<panda::es2panda::ir::Identifier>(this, "Symbol");
    panda::es2panda::ir::Identifier* constant_this = AllocNode<panda::es2panda::ir::Identifier>(this, "this");
    panda::es2panda::ir::Identifier* constant_global = AllocNode<panda::es2panda::ir::Identifier>(this, "global");
    panda::es2panda::ir::Identifier* constant_newtarget = AllocNode<panda::es2panda::ir::Identifier>(this, "new.target");
    panda::es2panda::ir::Identifier* constant_restargs = AllocNode<panda::es2panda::ir::Identifier>(this, "args");
    panda::es2panda::ir::Identifier* constant_arguments = AllocNode<panda::es2panda::ir::Identifier>(this, "arguments"); 

    panda::es2panda::ir::Identifier* constant_asyncfuncmark = AllocNode<panda::es2panda::ir::Identifier>(this, "asyncfunc");

    panda::es2panda::ir::Identifier* constant_genratorcmark = AllocNode<panda::es2panda::ir::Identifier>(this, "generatorobj");

    panda::es2panda::ir::Identifier* constant_itercmark = AllocNode<panda::es2panda::ir::Identifier>(this, "iterresultobj");


    panda::es2panda::ir::Identifier* constant_resumemode = AllocNode<panda::es2panda::ir::Identifier>(this, "whether_resume_generator");

    panda::es2panda::ir::Identifier* constant_rejectmode = AllocNode<panda::es2panda::ir::Identifier>(this, "reject_resume_generator");


    panda::es2panda::ir::Expression* suspendobj = nullptr;


    panda::es2panda::ir::BooleanLiteral* constant_true = AllocNode<panda::es2panda::ir::BooleanLiteral>(this, true);
    panda::es2panda::ir::BooleanLiteral* constant_false = AllocNode<panda::es2panda::ir::BooleanLiteral>(this, false);
    panda::es2panda::ir::NullLiteral* constant_null = AllocNode<panda::es2panda::ir::NullLiteral>(this);

    panda::es2panda::ir::NumberLiteral* constant_one = AllocNode<panda::es2panda::ir::NumberLiteral>(this, 1);
    panda::es2panda::ir::NumberLiteral* constant_zero = AllocNode<panda::es2panda::ir::NumberLiteral>(this, 0);


};

}

#endif

```

`astgen_auxiins.cpp`:

```cpp
void AstGen::VisitPhi(GraphVisitor* v, Inst* inst_base) {
    std::cout << "[+] VisitPhi  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen*>(v);
    auto inst = inst_base->CastToPhi();
    ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

    auto dst_reg_identifier = enc->GetIdentifierByReg(inst->GetId());
    enc->SetExpressionByRegister(inst, inst->GetDstReg(), dst_reg_identifier);

    for (size_t i = 0; i < inst->GetInputsCount(); i++) {
        auto bb = inst->GetPhiInputBb(i);
        auto sourceexpression = *enc->GetExpressionByRegIndex(inst, i);
        auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            dst_reg_identifier,
                                                                            sourceexpression,
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        );
        auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);

        if(std::find(enc->visited.begin(), enc->visited.end(), bb) != enc->visited.end()){
            enc->AddInstAst2BlockStatemntByBlock(bb, assignstatement);
        }else{
            if(enc->phiref2pendingredundant.find(bb) != enc->phiref2pendingredundant.end()){
                auto found_block_statement = enc->phiref2pendingredundant[bb];
                const auto &statements = found_block_statement->Statements();
                found_block_statement->AddStatementAtPos(statements.size(), assignstatement);
            }else{
                ArenaVector<panda::es2panda::ir::Statement *> statements(enc->parser_program_->Allocator()->Adapter());
                auto new_block_statement = AllocNode<es2panda::ir::BlockStatement>(enc, nullptr, std::move(statements));
                new_block_statement->AddStatementAtPos(statements.size(), assignstatement);
            }
        }
    }

    std::cout << "[-] VisitPhi  <<<<<<<<<<<<<<<" << std::endl;
}

void AstGen::VisitSaveState(GraphVisitor* v, Inst* inst_base) {
    std::cout << "[+] VisitSaveState  >>>>>>>>>>>>>>>>>" << std::endl;
    std::cout << "[-] VisitSaveState  >>>>>>>>>>>>>>>>>" << std::endl;
}
void AstGen::VisitParameter(GraphVisitor* v, Inst* inst_base) {
    std::cout << "[+] VisitParameter  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen *>(v);
    auto inst = inst_base->CastToParameter();

    panda::es2panda::ir::Expression* arg = enc->getParameterName(inst->GetArgNumber());    
    enc->SetExpressionByRegister(inst, inst->GetDstReg(), arg);
    std::cout << "[-] VisitParameter  >>>>>>>>>>>>>>>>>" << std::endl;
}

void AstGen::VisitTry(GraphVisitor* v, Inst* inst_base) {
    std::cout << "[+] VisitTry  >>>>>>>>>>>>>>>>>" << std::endl;
    auto enc = static_cast<AstGen*>(v);
    auto inst = inst_base->CastToTry();

    // find tryblock
    BasicBlock* tryblock = nullptr;
    if(inst->GetBasicBlock()->GetSuccessor(0)->IsCatchBegin()){
        tryblock = inst->GetBasicBlock()->GetSuccessor(1);
    }else if(inst->GetBasicBlock()->GetSuccessor(1)->IsCatchBegin()){
        tryblock = inst->GetBasicBlock()->GetSuccessor(0);
    }else{
        HandleError("can't handle this case  in visitTry for finding try block");
    }

    enc->specialblockid.insert(tryblock->GetId());
    
    panda::es2panda::ir::BlockStatement* tryblock_statement = enc->GetBlockStatementById(tryblock);

    if(inst->GetBasicBlock()->GetTryId() !=  panda::compiler::INVALID_ID){
        enc->tyrid2block[inst->GetBasicBlock()->GetTryId()] = tryblock_statement;
    }
    

    /// find case block
    auto type_ids = inst->GetCatchTypeIds();
    auto catch_indexes = inst->GetCatchEdgeIndexes();

    panda::es2panda::ir::CatchClause *catchClause = nullptr;
    for (size_t idx = 0; idx < type_ids->size(); idx++) {
        auto succ =  inst->GetBasicBlock()->GetSuccessor(catch_indexes->at(idx));
        
        while (!succ->IsCatchBegin()) {
            succ = succ->GetSuccessor(0);
        }

        enc->specialblockid.insert(succ->GetId());
        auto catch_block = enc->GetBlockStatementById(succ);
   
        panda::es2panda::ir::Expression *param = enc->constant_catcherror;
        

        catchClause =  AllocNode<panda::es2panda::ir::CatchClause>(enc, nullptr, param, catch_block);
        enc->tyrid2catchclause[inst->GetBasicBlock()->GetTryId()] = catchClause;
    }

    
    // if(inst->GetBasicBlock()->GetPredsBlocks().size() > 2){
    //     HandleError("analysis try-catch error for more than one predecessor");
    // }
    
    // create null finally case
    ArenaVector<panda::es2panda::ir::Statement *> finally_statements(enc->parser_program_->Allocator()->Adapter());
    auto finnalyClause = AllocNode<es2panda::ir::BlockStatement>(enc, nullptr, std::move(finally_statements));
    
    // create try-catch statement
    enc->GetBlockStatementById(inst->GetBasicBlock());

    auto tryStatement = AllocNode<panda::es2panda::ir::TryStatement>(enc, tryblock_statement, catchClause, finnalyClause);
    enc->tyridtrystatement[inst->GetBasicBlock()->GetTryId()] = tryStatement;
    
    enc->AddInstAst2BlockStatemntByInst(inst_base, tryStatement);

    std::cout << "[-] VisitTry  >>>>>>>>>>>>>>>>>" << std::endl;

}

```

`astgen_ecma.inl`:

```inl
#include "intrinsicid2token.h"

void panda::bytecodeopt::AstGen::VisitEcma(panda::compiler::GraphVisitor *visitor, Inst *inst_base)
{
    ASSERT(inst_base->IsIntrinsic());
    auto inst = inst_base->CastToIntrinsic();
    auto enc = static_cast<AstGen *>(visitor);

    std::ostringstream oss;
    inst->DumpOpcode(&oss);
    std::cout << "VisitIntrinsicInst: " << oss.str() << std::endl;

    switch (inst->GetIntrinsicId()) {
       case compiler::RuntimeInterface::IntrinsicId::RETURNUNDEFINED:
       {
            auto returnstatement = AllocNode<es2panda::ir::ReturnStatement>(enc,  enc->constant_undefined);
            enc->AddInstAst2BlockStatemntByInst(inst, returnstatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDINFINITY:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_infinity);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDTHIS:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_this);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDFUNCTION:
       {
            enc->HandleNewCreatedExpression(inst, enc->GetIdentifierByName(enc->fun_name_));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDGLOBAL:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_global);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDNEWTARGET:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_newtarget);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDSYMBOL:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_symbol);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::GETUNMAPPEDARGS:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_arguments);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDBIGINT_ID16:
       {
            panda::es2panda::ir::Identifier* funname = enc->GetIdentifierByName("BigInt");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            auto stroffset = static_cast<uint32_t>(inst->GetImms()[0]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            es2panda::util::StringView literal_strview(*new std::string(str));

            arguments.push_back( AllocNode<es2panda::ir::StringLiteral>(enc, literal_strview));

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                            funname,
                                                                            std::move(arguments),
                                                                            nullptr,
                                                                            false
                                                                            );
            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDHOLE:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_hole);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDUNDEFINED:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_undefined);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDNULL:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_null);
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDTRUE:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_true);
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDFALSE:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_false);
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::LDNAN:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_nan);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::COPYRESTARGS_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::WIDE_COPYRESTARGS_PREF_IMM16:
       {
            enc->HandleNewCreatedExpression(inst, enc->constant_restargs);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::INSTANCEOF_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::ISIN_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::ADD2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::SUB2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::MUL2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::DIV2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::MOD2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::LESS_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::LESSEQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::GREATER_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::GREATEREQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::SHL2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::SHR2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::ASHR2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::AND2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::OR2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::XOR2_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STRICTNOTEQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STRICTEQ_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::EXP_IMM8_V8:{
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);  
            auto binexpression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                            *enc->GetExpressionByRegIndex(inst, 0),
                                                            source_expression,
                                                            BinIntrinsicIdToToken(inst->GetIntrinsicId())
            );
            enc->HandleNewCreatedExpression(inst, binexpression);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::INC_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::DEC_IMM8:
       {
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);
            auto binexpression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                            source_expression,
                                                            enc->constant_one,
                                                            IncDecIntrinsicIdToToken(inst->GetIntrinsicId())
            );
            enc->HandleNewCreatedExpression(inst, binexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::ISTRUE:{
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);
            auto binexpression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                            source_expression,
                                                            enc->constant_true,
                                                            BinIntrinsicIdToToken(inst->GetIntrinsicId())
            );
            enc->HandleNewCreatedExpression(inst, binexpression);
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::ISFALSE:{
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);
            auto binexpression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                            source_expression,
                                                            enc->constant_false,
                                                            BinIntrinsicIdToToken(inst->GetIntrinsicId())
            );

            enc->HandleNewCreatedExpression(inst, binexpression);
            break;

        }

       case compiler::RuntimeInterface::IntrinsicId::NOT_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::NEG_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM16: {
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);        

            auto unaryexpression = AllocNode<es2panda::ir::UnaryExpression>(enc, 
                                                            source_expression,
                                                            UnaryPrefixIntrinsicIdToToken(inst->GetIntrinsicId())
            );

            enc->HandleNewCreatedExpression(inst, unaryexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::TONUMBER_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::TONUMERIC_IMM8:
       {
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);
            panda::es2panda::ir::Identifier* funname = enc->GetIdentifierByName("Number");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            arguments.push_back(source_expression);

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                            funname,
                                                                            std::move(arguments),
                                                                            nullptr,
                                                                            false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STGLOBALVAR_IMM16_ID16:
       case compiler::RuntimeInterface::IntrinsicId::TRYSTGLOBALBYNAME_IMM8_ID16:
       case compiler::RuntimeInterface::IntrinsicId::TRYSTGLOBALBYNAME_IMM16_ID16:
       {
            panda::es2panda::ir::Expression* src_reg_identifier = *enc->GetExpressionByAcc(inst); 
            
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);
            auto dst_reg_identifier = enc->GetIdentifierByName(str); 
            enc->globalname2expression_[dst_reg_identifier] = src_reg_identifier;

            if(enc->not_add_assgin_for_stlexvar.find(src_reg_identifier) == enc->not_add_assgin_for_stlexvar.end()){
                auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                    dst_reg_identifier,
                                                                                    src_reg_identifier,
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );
                auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);

            }
            break;
           
        }

        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYOBJECT:
        {
            ArenaVector<es2panda::ir::Expression *> properties(enc->parser_program_->Allocator()->Adapter());
            auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                std::move(properties),
                                                                                false
                                                                            );

            ArenaVector<es2panda::ir::VariableDeclarator *> declarators(enc->parser_program_->Allocator()->Adapter());

            enc->HandleNewCreatedExpression(inst, objectexpression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYARRAY_IMM16:
        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYARRAY_IMM8:
        {
            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());
            auto arrayexpression = AllocNode<es2panda::ir::ArrayExpression>(enc, 
                                                                            es2panda::ir::AstNodeType::ARRAY_EXPRESSION,
                                                                            std::move(elements),
                                                                            false
                                                                            );
            ArenaVector<es2panda::ir::VariableDeclarator *> declarators(enc->parser_program_->Allocator()->Adapter());

            enc->HandleNewCreatedExpression(inst, arrayexpression);
            break;
        }


        case compiler::RuntimeInterface::IntrinsicId::CREATEARRAYWITHBUFFER_IMM8_ID16:
        case compiler::RuntimeInterface::IntrinsicId::CREATEARRAYWITHBUFFER_IMM16_ID16:
        {
            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());
            auto literalarray_offset = static_cast<uint32_t>(inst->GetImms()[1]);

            auto literalarray = FindLiteralArrayByOffset(enc->program_, literalarray_offset);
            if(!literalarray){
                HandleError("get literalarray error");
            }

            for (const auto& literal : literalarray->literals_) {
                es2panda::ir::Expression *retvalue = enc->GetExpressionByLiteral(literal);
                if(retvalue != nullptr){
                    elements.push_back(retvalue);
                }
            }

            auto arrayexpression = AllocNode<es2panda::ir::ArrayExpression>(enc, 
                                                                            es2panda::ir::AstNodeType::ARRAY_EXPRESSION,
                                                                            std::move(elements),
                                                                            false
                                                                            );

            enc->HandleNewCreatedExpression(inst, arrayexpression);
            break;
        }


        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM8_ID16:
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM16_ID16:
        {
            ArenaVector<es2panda::ir::Expression *> properties(enc->parser_program_->Allocator()->Adapter());
            
            auto literalarray_offset = static_cast<uint32_t>(inst->GetImms()[1]); 
            auto literalarray = FindLiteralArrayByOffset(enc->program_ , literalarray_offset);

            int count = 0;
            es2panda::ir::Expression* key;
            es2panda::ir::Expression* value;
            for (const auto& literal : literalarray->literals_) {
                es2panda::ir::Expression *retvalue = enc->GetExpressionByLiteral(literal);
                if(retvalue == nullptr){
                    continue;
                }

                if(literal.tag_ == panda_file::LiteralTag::METHODAFFILIATE){
                    // methodname2offset_
                    auto raw_func_name = enc->GetNameFromExpression(key);
                    if(raw_func_name){
                        std::cout << "###: " << *raw_func_name << std::endl;
                        for (const auto& pair : *enc->methodname2offset_) {
                            if(pair.first.find(*raw_func_name) != std::string::npos){
                                uint32_t target_offset = pair.second;
                                CopyLexicalenvStack(target_offset, inst, enc->method2lexicalenvstack_, enc->bb2lexicalenvstack_, enc->globallexical_waitlist_);
                                CopyLexicalenvStack(target_offset, inst, enc->method2sendablelexicalenvstack_, enc->bb2sendablelexicalenvstack_, enc->globalsendablelexical_waitlist_);
                            }
                        }
                    }
                    continue;
                }

                if(count++ % 2==0){
                    key = retvalue;    
                }else{
                    value = retvalue;
                    properties.push_back(  AllocNode<es2panda::ir::Property>(enc, key, value) );

                }
            }

            auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                std::move(properties),
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, objectexpression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::LDGLOBALVAR_IMM16_ID16:
        case compiler::RuntimeInterface::IntrinsicId::TRYLDGLOBALBYNAME_IMM8_ID16:
        case compiler::RuntimeInterface::IntrinsicId::TRYLDGLOBALBYNAME_IMM16_ID16:
       {
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            es2panda::ir::Expression* sourceexpression = enc->GetIdentifierByName(str);

            enc->HandleNewCreatedExpression(inst, sourceexpression);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDOBJBYNAME_IMM8_ID16:
       case compiler::RuntimeInterface::IntrinsicId::LDOBJBYNAME_IMM16_ID16:
       {
            panda::es2panda::ir::Expression* obj_expression = *enc->GetExpressionByAcc(inst);
            
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            panda::es2panda::ir::Expression* attr_expression = enc->GetIdentifierByName(str);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_expression,
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        false, 
                                                        false);

            enc->HandleNewCreatedExpression(inst, objattrexpression);
            break;
       }

       case compiler::RuntimeInterface::IntrinsicId::LDOBJBYVALUE_IMM16_V8:
       case compiler::RuntimeInterface::IntrinsicId::LDOBJBYVALUE_IMM8_V8:
       {
            panda::es2panda::ir::Expression* attr_expression = *enc->GetExpressionByAcc(inst);
            panda::es2panda::ir::Expression* obj_expression = *enc->GetExpressionByRegIndex(inst, 0);
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_expression,
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);
            enc->HandleNewCreatedExpression(inst, objattrexpression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::STTOGLOBALRECORD_IMM16_ID16:
        case compiler::RuntimeInterface::IntrinsicId::STCONSTTOGLOBALRECORD_IMM16_ID16:
        {
            panda::es2panda::ir::Expression* src_expression = *enc->GetExpressionByAcc(inst);
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            auto dst_identifier = enc->GetIdentifierByName(str);

            enc->globalname2expression_[dst_identifier] = src_expression;

            if(enc->not_add_assgin_for_stlexvar.find(src_expression) != enc->not_add_assgin_for_stlexvar.end()){
                break;
            }
            
            ArenaVector<es2panda::ir::VariableDeclarator *> declarators(enc->parser_program_->Allocator()->Adapter());
            auto *declarator = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                dst_identifier, 
                                                                                src_expression);
            declarators.push_back(declarator);

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::STTOGLOBALRECORD_IMM16_ID16){
                auto variadeclaration = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::CONST,
                                                                                    std::move(declarators),
                                                                                    true
                                                                                );
                enc->AddInstAst2BlockStatemntByInst(inst, variadeclaration);
            }else{
                auto variadeclaration = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::LET,
                                                                                    std::move(declarators),
                                                                                    true
                                                                                );
                enc->AddInstAst2BlockStatemntByInst(inst, variadeclaration);
            }

            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::CALLARG0_IMM8:
        {
            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::CALLARG1_IMM8_V8:
        {
            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);


            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            auto v0 = *enc->GetExpressionByRegIndex(inst, 0);
            
            arguments.push_back(v0);
            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLARGS2_IMM8_V8_V8:
       {

            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 0));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 1));


            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);

            break;

        }
       case compiler::RuntimeInterface::IntrinsicId::CALLARGS3_IMM8_V8_V8_V8:
       {
            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);


            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 0));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 1));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 2));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }
       
       case compiler::RuntimeInterface::IntrinsicId::CALLTHIS0_IMM8_V8:
       {
            
            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);
            enc->thisptr = *enc->GetExpressionByRegIndex(inst, 0);

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            
            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLTHIS1_IMM8_V8_V8:
       {
            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            enc->thisptr = *enc->GetExpressionByRegIndex(inst, 0);
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 1));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);

            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLTHIS2_IMM8_V8_V8_V8:
       {

            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            enc->thisptr = *enc->GetExpressionByRegIndex(inst, 0);
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 1));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 2));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLTHIS3_IMM8_V8_V8_V8_V8:
       {

            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            enc->thisptr = *enc->GetExpressionByRegIndex(inst, 0);
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 1));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 2));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 3));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);

            break;
        }
       
       case compiler::RuntimeInterface::IntrinsicId::STOBJBYVALUE_IMM8_V8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOBJBYVALUE_IMM16_V8_V8:
       {
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        *enc->GetExpressionByRegIndex(inst, 0),
                                                        *enc->GetExpressionByRegIndex(inst, 1), 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);
            panda::es2panda::ir::Expression* assignexpression =   AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->GetExpressionByAcc(inst),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;

        }


       case compiler::RuntimeInterface::IntrinsicId::STOBJBYNAME_IMM16_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOBJBYNAME_IMM8_ID16_V8:
       {
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        *enc->GetExpressionByRegIndex(inst, 0),
                                                        enc->GetIdentifierByName(str),
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        false, 
                                                        false);


            panda::es2panda::ir::Expression* assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->GetExpressionByAcc(inst),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
                                                                        
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::NEWOBJRANGE_IMM8_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::NEWOBJRANGE_IMM16_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWOBJRANGE_PREF_IMM16_V8:
       {
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            es2panda::ir::Expression *callee = *enc->GetExpressionByRegIndex(inst, 0);

            uint32_t argsum;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_NEWOBJRANGE_PREF_IMM16_V8){
                argsum = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                argsum = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            for (uint32_t i = 1; i < argsum; ++i) {
                arguments.push_back(*enc->GetExpressionByRegIndex(inst, i));
            }

            es2panda::ir::Expression *newExprNode = AllocNode<es2panda::ir::NewExpression>(enc, callee, nullptr, std::move(arguments));

            enc->HandleNewCreatedExpression(inst, newExprNode);
            break;

        }

       case compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM16_V8:
       {
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);
            auto arrayexpression = source_expression->AsArrayExpression();
            es2panda::ir::Expression *callee = *enc->GetExpressionByRegIndex(inst, 0);


            auto constElements = arrayexpression->Elements();
            auto &nonConstElements = const_cast<ArenaVector<es2panda::ir::Expression *> &>(constElements);

            es2panda::ir::Expression *newExprNode = AllocNode<es2panda::ir::NewExpression>(enc, callee, nullptr, std::move(nonConstElements));
            enc->HandleNewCreatedExpression(inst, newExprNode);
            
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::COPYDATAPROPERTIES_V8:
       {
            auto src_obj = *enc->GetExpressionByAcc(inst);
            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());
            auto v0 = inst->GetSrcReg(0);

            auto target_obj = *enc->GetExpressionByRegIndex(inst, 0);
            auto target_objexpression = target_obj->AsObjectExpression();

            auto target_properties = target_objexpression->Properties();
            for (auto *it : target_properties) {
                elements.push_back(it);
            }

            elements.push_back( AllocNode<es2panda::ir::SpreadElement>(enc, es2panda::ir::AstNodeType::SPREAD_ELEMENT, src_obj));
            auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                std::move(elements),
                                                                                false
                                                                            );

            enc->SetExpressionByRegister(inst, inst->GetDstReg(), objectexpression);
            enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), v0, objectexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::APPLY_IMM8_V8_V8:
       {
            auto fun = *enc->GetExpressionByAcc(inst);
            auto raw_expression = *enc->GetExpressionByRegIndex(inst, 1);

            auto raw_array_expression = raw_expression->AsArrayExpression();

            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());

            for (auto *it :raw_array_expression->Elements()) {
                elements.push_back(it);
            }

            auto this_expression = *enc->GetExpressionByRegIndex(inst, 0);
            enc->thisptr = this_expression;
            
            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                            fun,
                                                                            std::move(elements),
                                                                            nullptr,
                                                                            false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STARRAYSPREAD_V8_V8:
       {
            auto element = *enc->GetExpressionByAcc(inst);
            es2panda::ir::Expression* spreadelement = AllocNode<es2panda::ir::SpreadElement>(enc, es2panda::ir::AstNodeType::SPREAD_ELEMENT, element);
            auto raw_obj = *enc->GetExpressionByRegIndex(inst, 0);

            if(!raw_obj->IsArrayExpression()){
                std::cout << "###: " << std::to_string(static_cast<int>(raw_obj->Type())) << std::endl;
                HandleError("#STARRAYSPREAD: cann't deal expression except ArrayExpression");
            }

            auto raw_arrayexpression = raw_obj->AsArrayExpression();
            ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());
            auto index_expression = *enc->GetExpressionByRegIndex(inst, 1);
            auto index_literal = index_expression->AsNumberLiteral();
            uint32_t index = index_literal->Number();

            uint32_t count = 0;
            bool inserted = false;
            for (auto *it : raw_arrayexpression->Elements()) {
                if(count == index){
                    elements.push_back(spreadelement);
                    inserted = true;
                }
                elements.push_back(it);
                count++;
            }
            if(!inserted) {
                if(index == raw_arrayexpression->Elements().size()){
                    elements.push_back(spreadelement);
                }else if(index > raw_arrayexpression->Elements().size() ){
                    while(count < index){
                        auto omittedexpression = AllocNode<es2panda::ir::OmittedExpression>(enc);
                        elements.push_back(omittedexpression);
                        count++;
                    }
                    elements.push_back(spreadelement);
                }else{
                    std::cout << "element size: " << raw_arrayexpression->Elements().size() << " , index: " << index << std::endl;
                    HandleError("#STARRAYSPREAD inset element error");
                }
            }

            auto arrayexpression = AllocNode<es2panda::ir::ArrayExpression>(enc, 
                                                                            es2panda::ir::AstNodeType::ARRAY_EXPRESSION,
                                                                            std::move(elements),
                                                                            false
                                                                            );

            enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), arrayexpression);
            uint32_t size = elements.size();
            enc->SetExpressionByRegister(inst, inst->GetDstReg(), enc->GetLiteralByNum(size));


            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::DEBUGGER:
       {
            auto debuggerstatement = AllocNode<es2panda::ir::DebuggerStatement>(enc );
            enc->AddInstAst2BlockStatemntByInst(inst, debuggerstatement);
            break;
       }

       case compiler::RuntimeInterface::IntrinsicId::CALLRANGE_IMM8_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_CALLRANGE_PREF_IMM16_V8:
       {

            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);
            uint32_t argsum;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_CALLRANGE_PREF_IMM16_V8){
                argsum = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                argsum = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            for (uint32_t i = 0; i < argsum; ++i) {
                arguments.push_back(*enc->GetExpressionByRegIndex(inst, i));
            }

            
            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::WIDE_CALLTHISRANGE_PREF_IMM16_V8:
        case compiler::RuntimeInterface::IntrinsicId::CALLTHISRANGE_IMM8_IMM8_V8:
        {
            panda::es2panda::ir::Expression* funname = *enc->GetExpressionByAcc(inst);
            enc->thisptr =  *enc->GetExpressionByRegIndex(inst, 0);

            uint32_t argsum;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_CALLTHISRANGE_PREF_IMM16_V8){
                argsum = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                argsum = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            for (uint32_t i = 1; i <= argsum; ++i) {
                arguments.push_back(*enc->GetExpressionByRegIndex(inst, i));
            }

            
            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::SUPERCALLTHISRANGE_IMM8_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLTHISRANGE_PREF_IMM16_V8:
       case compiler::RuntimeInterface::IntrinsicId::SUPERCALLARROWRANGE_IMM8_IMM8_V8:  // array function hard trigger
       case compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLARROWRANGE_PREF_IMM16_V8:
       {
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("super");
            enc->thisptr =  *enc->GetExpressionByRegIndex(inst, 0);

            uint32_t argsum;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLTHISRANGE_PREF_IMM16_V8 ||
                inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLARROWRANGE_PREF_IMM16_V8
            ){
                argsum = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                argsum = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            for (uint32_t i = 1; i <= argsum; ++i) {
                arguments.push_back(*enc->GetExpressionByRegIndex(inst, i-1));
            }
            
            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::DELOBJPROP_V8:
       {
            panda::es2panda::ir::Expression* obj_expression = *enc->GetExpressionByRegIndex(inst, 0);
            panda::es2panda::ir::Expression* attr_expression = *enc->GetExpressionByAcc(inst);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_expression,
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);



            auto unaryexpression = AllocNode<es2panda::ir::UnaryExpression>(enc, 
                                                            objattrexpression,
                                                            UnaryPrefixIntrinsicIdToToken(inst->GetIntrinsicId())
            );

            enc->HandleNewCreatedExpression(inst, unaryexpression);
            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_ISFALSE_PREF_IMM8:
       {
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("runtime.isfalse");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByAcc(inst));

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                funname,
                                                                std::move(arguments),
                                                                nullptr,
                                                                false
                                                                );

            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_ISTRUE_PREF_IMM8:
       {
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("runtime.istrue");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            arguments.push_back(*enc->GetExpressionByAcc(inst));

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                funname,
                                                                std::move(arguments),
                                                                nullptr,
                                                                false
                                                                );

            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }


        case compiler::RuntimeInterface::IntrinsicId::RETURN:
        {
            auto returnexpression = *enc->GetExpressionByAcc(inst); 
            auto returnstatement = AllocNode<es2panda::ir::ReturnStatement>(enc,  returnexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, returnstatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::THROW_PREF_NONE:
       {
            auto argument = *enc->GetExpressionByAcc(inst);

            auto throwStatement = AllocNode<es2panda::ir::ThrowStatement>(enc, argument);
            enc->AddInstAst2BlockStatemntByInst(inst, throwStatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUEWITHNAMESET_IMM16_V8_V8: 
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUEWITHNAMESET_IMM8_V8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUE_IMM16_V8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUE_IMM8_V8_V8:
       {
            panda::es2panda::ir::Identifier* value_reg_identifier = enc->GetIdentifierByReg(inst->GetSrcReg(1));
            /////////////////////////////////////////////////////////////////////////////////////////////////////////
            auto raw_obj = *enc->GetExpressionByRegIndex(inst, 0);
            if(raw_obj->IsObjectExpression()){
                auto expression2 = *enc->GetExpressionByRegIndex(inst, 1);

                enc->SetExpressionByRegister(inst->GetInput(1).GetInst(), inst->GetSrcReg(0), value_reg_identifier);

                ArenaVector<es2panda::ir::VariableDeclarator *> declarators2(enc->parser_program_->Allocator()->Adapter());
                auto *declarator2 = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                value_reg_identifier, 
                                                                                expression2
                                                                            );
                declarators2.push_back(declarator2);
                auto variadeclaration2 = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::VAR,
                                                                                    std::move(declarators2),
                                                                                    true);
                enc->AddInstAst2BlockStatemntByInst(inst, variadeclaration2);
                ////////////////////////////////////////////////////////////////////////////////////////////////////////
                
                auto objexpression = raw_obj->AsObjectExpression();
                ////////////////////////////////////////////////////////////////////////////////////////////////////////
                ArenaVector<es2panda::ir::Expression *> new_properties(enc->parser_program_->Allocator()->Adapter());
                for (auto *it : objexpression->Properties()) {
                    new_properties.push_back(it);
                }
                new_properties.push_back(  AllocNode<es2panda::ir::Property>(enc, value_reg_identifier, *enc->GetExpressionByAcc(inst)) );
                auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                    es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                    std::move(new_properties),
                                                                                    false
                                                                                );
                enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), objectexpression);

            }else if(raw_obj->IsArrayExpression()){
                auto raw_arrayexpression = raw_obj->AsArrayExpression();
                ArenaVector<es2panda::ir::Expression *> new_elements(enc->parser_program_->Allocator()->Adapter());
                
                for (auto *it : raw_arrayexpression->Elements()) {
                    new_elements.push_back(it);
                }
                new_elements.push_back(*enc->GetExpressionByAcc(inst));
                auto arrayexpression = AllocNode<es2panda::ir::ArrayExpression>(enc, 
                                                                                es2panda::ir::AstNodeType::ARRAY_EXPRESSION,
                                                                                std::move(new_elements),
                                                                                false
                                                                                );
                enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), arrayexpression);
            }else if(raw_obj->IsMemberExpression() || raw_obj->IsIdentifier() || raw_obj->IsStringLiteral() ){
                auto obj_reg_identifier = *enc->GetExpressionByRegIndex(inst, 0);
                auto index_reg_identifier = *enc->GetExpressionByRegIndex(inst, 1);
                auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                                    obj_reg_identifier,
                                                                                    index_reg_identifier, 
                                                                                    es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                                    true, 
                                                                                    false
                                                                                );
                auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                    objattrexpression,
                                                                                    *enc->GetExpressionByAcc(inst),
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );

                auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);

            }else{
                panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByReg(inst->GetSrcReg(0));
                auto expression1 = *enc->GetExpressionByRegIndex(inst, 0);

                enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), obj_reg_identifier);
                ArenaVector<es2panda::ir::VariableDeclarator *> declarators1(enc->parser_program_->Allocator()->Adapter());
                auto *declarator1 = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                obj_reg_identifier, 
                                                                                expression1);
                declarators1.push_back(declarator1);
                auto variadeclaration1 = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::VAR,
                                                                                    std::move(declarators1),
                                                                                    true
                                                                                    );
                enc->AddInstAst2BlockStatemntByInst(inst, variadeclaration1);
                
                
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                panda::es2panda::ir::Identifier* index_reg_identifier = enc->GetIdentifierByReg(inst->GetSrcReg(1));
                auto expression2 = *enc->GetExpressionByRegIndex(inst, 1);

                enc->SetExpressionByRegister(inst->GetInput(1).GetInst(), inst->GetSrcReg(0), index_reg_identifier);

                ArenaVector<es2panda::ir::VariableDeclarator *> declarators2(enc->parser_program_->Allocator()->Adapter());
                auto *declarator2 = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                index_reg_identifier, 
                                                                                expression2
                                                                            );
                declarators2.push_back(declarator2);
                auto variadeclaration2 = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::VAR,
                                                                                    std::move(declarators2),
                                                                                    true
                                                                                    );
                enc->AddInstAst2BlockStatemntByInst(inst, variadeclaration2);

                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                                    obj_reg_identifier,
                                                                                    index_reg_identifier, 
                                                                                    es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                                    true, 
                                                                                    false
                                                                                );

                auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                    objattrexpression,
                                                                                    *enc->GetExpressionByAcc(inst),
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );

                auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);


            }
            
            // else{
            //     std::cout << "###: " << std::to_string(static_cast<int>(raw_obj->Type())) << std::endl;
            //     HandleError("#STARRAYSPREAD1: cann't deal expression except ObjectExpression");
            // }

            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::STOWNBYINDEX_IMM8_V8_IMM16: 
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYINDEX_IMM16_V8_IMM16:
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STOWNBYINDEX_PREF_V8_IMM32:
       {
            uint32_t index;
            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_STOWNBYINDEX_PREF_V8_IMM32){
                index = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                index = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            auto raw_obj = *enc->GetExpressionByRegIndex(inst, 0);
            if(raw_obj->IsArrayExpression()){            
                auto raw_arrayexpression = raw_obj->AsArrayExpression();
                ArenaVector<es2panda::ir::Expression *> elements(enc->parser_program_->Allocator()->Adapter());

                uint32_t count = 0;
                bool inserted = false;
                for (auto *it :raw_arrayexpression->Elements()) {
                    if(count++ == index){
                        inserted = true;
                        elements.push_back(*enc->GetExpressionByAcc(inst));
                    }
                    elements.push_back(it);
                }

                if(!inserted) {
                    if(index == raw_arrayexpression->Elements().size()){
                        elements.push_back(*enc->GetExpressionByAcc(inst));
                    }else if(index > raw_arrayexpression->Elements().size() ){
                        while(count < index){
                            auto omittedexpression = AllocNode<es2panda::ir::OmittedExpression>(enc);
                            elements.push_back(omittedexpression);
                            count++;
                        }
                        elements.push_back(*enc->GetExpressionByAcc(inst));
                    }else{
                        std::cout << "element size: " << raw_arrayexpression->Elements().size() << " , index: " << index << std::endl;
                        HandleError("#STOWNBYINDEX: 1 inset element error");
                    }
                }
                
                auto arrayexpression = AllocNode<es2panda::ir::ArrayExpression>(enc, 
                                                                                es2panda::ir::AstNodeType::ARRAY_EXPRESSION,
                                                                                std::move(elements),
                                                                                false
                                                                                );
                
                enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), arrayexpression);
            }else if(raw_obj->IsMemberExpression() || raw_obj->IsIdentifier()  ){
                auto valueexpression = *enc->GetExpressionByAcc(inst);

                if(enc->methodname2offset_->find(*enc->GetNameFromExpression(valueexpression) ) == enc->methodname2offset_->end()){
                    auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                raw_obj,
                                                                enc->GetLiteralByNum(index), 
                                                                es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                true, 
                                                                false);

                    panda::es2panda::ir::Expression* assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                objattrexpression,
                                                                                *enc->GetExpressionByAcc(inst),
                                                                                es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 

                    auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                    enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
                }
            }else{
                std::cout << "###: " << std::to_string(static_cast<int>(raw_obj->Type())) << std::endl;
                HandleError("#STOWNBYINDEX: 2 cann't deal expression except ArrayExpression");
            }
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAME_IMM8_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAME_IMM16_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAMEWITHNAMESET_IMM8_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAMEWITHNAMESET_IMM16_ID16_V8:
       {
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);
            auto value_reg_identifier = enc->GetIdentifierByName(str);

            auto raw_obj = *enc->GetExpressionByRegIndex(inst, 0);
            if(raw_obj->IsObjectExpression()){                
                auto objexpression = raw_obj->AsObjectExpression();
                ////////////////////////////////////////////////////////////////////////////////////////////////////////
                ArenaVector<es2panda::ir::Expression *> new_properties(enc->parser_program_->Allocator()->Adapter());
                for (auto *it : objexpression->Properties()) {
                    new_properties.push_back(it);
                }
                new_properties.push_back(  AllocNode<es2panda::ir::Property>(enc, value_reg_identifier, *enc->GetExpressionByAcc(inst)) );
                auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                    es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                    std::move(new_properties),
                                                                                    false
                                                                                );
                enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), objectexpression);

            }else if(raw_obj->IsMemberExpression() || raw_obj->IsIdentifier() || raw_obj->IsStringLiteral() ){
                auto obj_reg_identifier = *enc->GetExpressionByRegIndex(inst, 0);
                auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                                    obj_reg_identifier,
                                                                                    value_reg_identifier, 
                                                                                    es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                                    false, 
                                                                                    false
                                                                                );
                auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                    objattrexpression,
                                                                                    *enc->GetExpressionByAcc(inst),
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );

                auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);

            }else{
                panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByReg(inst->GetSrcReg(0));
                auto expression1 = *enc->GetExpressionByRegIndex(inst, 0);

                enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), obj_reg_identifier);
                ArenaVector<es2panda::ir::VariableDeclarator *> declarators1(enc->parser_program_->Allocator()->Adapter());
                auto *declarator1 = AllocNode<es2panda::ir::VariableDeclarator>(enc, obj_reg_identifier, expression1);
                declarators1.push_back(declarator1);
                auto variadeclaration1 = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                    es2panda::ir::VariableDeclaration::VariableDeclarationKind::VAR,
                                                                                    std::move(declarators1),
                                                                                    true
                                                                                    );
                enc->AddInstAst2BlockStatemntByInst(inst, variadeclaration1);
                
                auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                            obj_reg_identifier,
                                                            value_reg_identifier,
                                                            es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                            false, 
                                                            false);   
                auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                    objattrexpression,
                                                                                    *enc->GetExpressionByAcc(inst),
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );

                auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            }
            break;
        }
 
        case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM8_ID16_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM16_ID16_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM8_ID16_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM16_ID16_IMM8:
        {
            std::cout << "define function >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            auto method_offset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto method_name = enc->ir_interface_->GetMethodIdByOffset(method_offset);
            
            CopyLexicalenvStack(method_offset, inst, enc->method2lexicalenvstack_, enc->bb2lexicalenvstack_, enc->globallexical_waitlist_);
            CopyLexicalenvStack(method_offset, inst, enc->method2sendablelexicalenvstack_, enc->bb2sendablelexicalenvstack_, enc->globalsendablelexical_waitlist_);

            std::string newname;

            //if(contains(*enc->memberfuncs_, method_offset)){
                newname = enc->RemovePrefixOfFunc(RemoveArgumentsOfFunc(method_name));
            //}else{
            //    newname = method_name;
            //}

            (*enc->methodname2offset_)[newname] = method_offset;
            auto new_expression = enc->GetIdentifierByName(newname);        
            enc->not_add_assgin_for_stlexvar.insert(new_expression);
            enc->SetExpressionByRegister(inst, inst->GetDstReg(), new_expression);

            enc->LogCurLexicalIndexes(inst);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWLEXENVWITHNAME_PREF_IMM16_ID16:// current no use default name
        case compiler::RuntimeInterface::IntrinsicId::NEWLEXENVWITHNAME_IMM8_ID16: // current no use default name
        case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWLEXENV_PREF_IMM16:
        case compiler::RuntimeInterface::IntrinsicId::NEWLEXENV_IMM8:
        {
            auto lexenv_size = static_cast<uint32_t>(inst->GetImms()[0]);
            std::cout << "lexenv_size: " << lexenv_size << std::endl;
            auto lexicalenvstack = enc->bb2lexicalenvstack_[inst->GetBasicBlock()];
            std::cout << "size: " << lexicalenvstack->Size() << std::endl; 
            lexicalenvstack->Push(lexenv_size);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM4_IMM4:
       case compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM8_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_STLEXVAR_PREF_IMM16_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_STSENDABLEVAR_PREF_IMM4_IMM4:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_STSENDABLEVAR_PREF_IMM8_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDESTSENDABLEVAR_PREF_IMM16_IMM16:
       {
            std::cout << "@@@ stlevar >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            std::cout << enc->methodoffset_ << std::endl;

            auto tier = static_cast<uint32_t>(inst->GetImms()[0]);
            auto index = static_cast<uint32_t>(inst->GetImms()[1]);

            std::cout << "tier: " << std::to_string(tier) << ", index: " << std::to_string(index) << std::endl;

            LexicalEnvStack* lexicalenvstack;
            if(inst->GetIntrinsicId() ==  compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM4_IMM4 || 
                inst->GetIntrinsicId() ==  compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM8_IMM8 || 
                inst->GetIntrinsicId() ==  compiler::RuntimeInterface::IntrinsicId::WIDE_STLEXVAR_PREF_IMM16_IMM16){
                lexicalenvstack = enc->bb2lexicalenvstack_[inst->GetBasicBlock()];
            }else{
                lexicalenvstack = enc->bb2sendablelexicalenvstack_[inst->GetBasicBlock()];
            }
            
            enc->LogCurLexicalIndexes(inst);
            std::cout << "[+] lexical stack size: " << lexicalenvstack->Size() << " , captity_: " << lexicalenvstack->GetLexicalEnv(0).capacity_  << " , top lexical size: " << lexicalenvstack->GetLexicalEnv(0).Size()   << std::endl;

            auto raw_expression  = *enc->GetExpressionByAcc(inst);
            std::string closure_name;
            
            if(enc->not_add_assgin_for_stlexvar.find(raw_expression) == enc->not_add_assgin_for_stlexvar.end()){
                std::cout << "+++ @ not_add_assgin_for_stlexvar" << std::endl;
                closure_name =  "closure_" + std::to_string(enc->methodoffset_) + "_" + std::to_string(enc->closure_count);
                enc->closure_count++;

                auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                      enc->GetIdentifierByName(closure_name),
                                                                                      raw_expression,
                                                                                      es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
                lexicalenvstack->Set(tier, index, new std::string(closure_name));
            }else{
                std::cout << "--- @ not_add_assgin_for_stlexvar" << std::endl;
                auto idname = enc->GetNameFromExpression(raw_expression);
                if(idname){
                    closure_name = *idname;
                }else{
                    HandleError("#STLEXVAR: not deal this case for find expression string name");
                }
                lexicalenvstack->Set(tier, index, new std::string(*idname));
            }

            enc->LogCurLexicalIndexes(inst);

            std::cout << "[-] lexical stack size: " << lexicalenvstack->Size() << " , captity_: " << lexicalenvstack->GetLexicalEnv(0).capacity_  << " , top lexical size: " << lexicalenvstack->GetLexicalEnv(0).Size()   << std::endl;

            ////////////////////////////////////////////////////////////////////////////////
            /// support forward reference stack
            if(inst->GetIntrinsicId() ==  compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM4_IMM4 
                || inst->GetIntrinsicId() ==  compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM8_IMM8 
                || inst->GetIntrinsicId() ==  compiler::RuntimeInterface::IntrinsicId::WIDE_STLEXVAR_PREF_IMM16_IMM16){
                DealWithGlobalLexicalWaitlist(tier, index, closure_name, enc->globallexical_waitlist_);
            }else{
                DealWithGlobalLexicalWaitlist(tier, index, closure_name, enc->globalsendablelexical_waitlist_);
            }
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM4_IMM4:
        case compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM8_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDLEXVAR_PREF_IMM16_IMM16:
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEVAR_PREF_IMM4_IMM4:
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEVAR_PREF_IMM8_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLEVAR_PREF_IMM16_IMM16:
       {
            std::cout << "@@@ ldlexvar >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            std::cout << enc->methodoffset_ << std::endl;
            auto tier = static_cast<uint32_t>(inst->GetImms()[0]);
            auto index = static_cast<uint32_t>(inst->GetImms()[1]);

            std::cout << "tier: " << std::to_string(tier) << ", index: " << std::to_string(index) << std::endl;

            LexicalEnvStack* lexicalenvstack;
            if(inst->GetIntrinsicId() ==  compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM4_IMM4 || 
                inst->GetIntrinsicId() ==  compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM8_IMM8 || 
                inst->GetIntrinsicId() ==  compiler::RuntimeInterface::IntrinsicId::WIDE_LDLEXVAR_PREF_IMM16_IMM16){

                lexicalenvstack = enc->bb2lexicalenvstack_[inst->GetBasicBlock()];
            }else{

                lexicalenvstack = enc->bb2sendablelexicalenvstack_[inst->GetBasicBlock()];
            }
            
            std::cout << "size: " << lexicalenvstack->Size() << std::endl;

            if(lexicalenvstack->GetLexicalEnv(tier)[index] == nullptr){
                HandleError("#LDLEXVAR: lexicalenv is null");
            }

            auto identifier_name = lexicalenvstack->Get(tier, index);
            enc->SetExpressionByRegister(inst, inst->GetDstReg(), enc->GetIdentifierByName(identifier_name));

            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::POPLEXENV:
        {
            auto lexicalenvstack = enc->bb2lexicalenvstack_[inst->GetBasicBlock()];
            lexicalenvstack->Pop();
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STMODULEVAR_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_STMODULEVAR_PREF_IMM16:
       {
            auto moudlevar_offset = static_cast<uint32_t>(inst->GetImms()[0]);
            if(moudlevar_offset < enc->localnamespaces_.size()){
                auto moudlevar_rawname = enc->localnamespaces_[moudlevar_offset];
                auto source_expression = enc->GetExpressionByAcc(inst); 
                if(source_expression){
                    panda::es2panda::ir::Identifier* moudlevar = enc->GetIdentifierByName(moudlevar_rawname);
                    auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                        moudlevar,
                                                                                        *source_expression,
                                                                                        es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                    );
                    auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                    enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
                }
            }

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDLOCALMODULEVAR_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::LDEXTERNALMODULEVAR_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_LDLOCALMODULEVAR_PREF_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_LDEXTERNALMODULEVAR_PREF_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDLAZYMODULEVAR_PREF_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDLAZYMODULEVAR_PREF_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEEXTERNALMODULEVAR_PREF_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLEEXTERNALMODULEVAR_PREF_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDLAZYSENDABLEMODULEVAR_PREF_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDLAZYSENDABLEMODULEVAR_PREF_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLELOCALMODULEVAR_PREF_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLELOCALMODULEVAR_PREF_IMM16:
       {
            auto moudlevar_offset = static_cast<uint32_t>(inst->GetImms()[0]);
            if(moudlevar_offset < enc->localnamespaces_.size()){
                auto moudlevar_rawname = enc->localnamespaces_[moudlevar_offset];
                panda::es2panda::ir::Identifier* moudlevar = enc->GetIdentifierByName(moudlevar_rawname);
                enc->SetExpressionByRegister(inst, inst->GetDstReg(), moudlevar);
            }else{
                HandleError("#LDLOCALMODULEVAR: module slot not in localnamespaces_");
            }

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::TESTIN_IMM8_IMM16_IMM16:
       {
            std::cout << enc->methodoffset_ << std::endl;
            auto tier = static_cast<uint32_t>(inst->GetImms()[0]);
            auto index = static_cast<uint32_t>(inst->GetImms()[1]);

            std::cout << "tier: " << std::to_string(tier) << ", index: " << std::to_string(index) << std::endl;
            auto lexicalenvstack = enc->bb2lexicalenvstack_[inst->GetBasicBlock()];
            std::cout << "size: " << lexicalenvstack->Size() << std::endl;

            if(lexicalenvstack->GetLexicalEnv(tier)[index] == nullptr){
                HandleError("#TESTIN: lexicalenv is null");
            }

            auto identifier_name = lexicalenvstack->Get(tier, index);
            auto identifier_name_expression =  enc->GetIdentifierByName(identifier_name);
            
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);
            auto binexpression = AllocNode<es2panda::ir::BinaryExpression>(enc, 
                                                                            identifier_name_expression,
                                                                            source_expression,
                                                                            BinIntrinsicIdToToken(compiler::RuntimeInterface::IntrinsicId::ISIN_IMM8_V8)
                                                                        );

            enc->SetExpressionByRegister(inst, inst->GetDstReg(), binexpression);
            break;
            
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_LDPATCHVAR_PREF_IMM16:
       {
            auto patchvar_offset = static_cast<uint32_t>(inst->GetImms()[0]);
            if (enc->patchvarspace_->find(patchvar_offset) != enc->patchvarspace_->end()) {
                std::string *identifier_name =  (*enc->patchvarspace_)[patchvar_offset];
                enc->SetExpressionByRegister(inst, inst->GetDstReg(), enc->GetIdentifierByName(identifier_name));

            } else {
                HandleError("load patchvar Index does not exist in the map");
            }
            
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::WIDE_STPATCHVAR_PREF_IMM16:
       {
            auto raw_expression  = *enc->GetExpressionByAcc(inst);
            auto patchvar_offset = static_cast<uint32_t>(inst->GetImms()[0]);
            std::string closure_name =  "closure_" + std::to_string(enc->methodoffset_) + "_" + std::to_string(enc->closure_count);
            enc->closure_count++;

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                enc->GetIdentifierByName(closure_name),
                                                                                raw_expression,
                                                                                es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            ); 

            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);

            (*enc->patchvarspace_)[patchvar_offset] = new std::string(closure_name);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::THROW_IFSUPERNOTCORRECTCALL_PREF_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::THROW_IFSUPERNOTCORRECTCALL_PREF_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::THROW_UNDEFINEDIFHOLE_PREF_V8_V8:
       case compiler::RuntimeInterface::IntrinsicId::THROW_UNDEFINEDIFHOLEWITHNAME_PREF_ID16:
       case compiler::RuntimeInterface::IntrinsicId::THROW_NOTEXISTS_PREF_NONE:
       case compiler::RuntimeInterface::IntrinsicId::THROW_PATTERNNONCOERCIBLE_PREF_NONE:
       case compiler::RuntimeInterface::IntrinsicId::THROW_DELETESUPERPROPERTY_PREF_NONE:
       case compiler::RuntimeInterface::IntrinsicId::THROW_CONSTASSIGNMENT_PREF_V8:
       case compiler::RuntimeInterface::IntrinsicId::THROW_IFNOTOBJECT_PREF_V8:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_NOTIFYCONCURRENTRESULT_PREF_NONE:
       case compiler::RuntimeInterface::IntrinsicId::GETMODULENAMESPACE_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_GETMODULENAMESPACE_PREF_IMM16:
       {
           // nothing todo
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM8_ID16_ID16_IMM16_V8:
       case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM16_ID16_ID16_IMM16_V8:
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINESENDABLECLASS_PREF_IMM16_ID16_ID16_IMM16_V8:
       {
            //////////////////////////////////////////////////////////////////////////////////////////////////////
            auto constructor_offset = static_cast<uint32_t>(inst->GetImms()[1]);
            enc->current_constructor_offset = constructor_offset;
            auto constructor_offset_name = enc->ir_interface_->GetMethodIdByOffset(constructor_offset);

            MergeMethod2LexicalMap(inst, enc->bb2lexicalenvstack_, constructor_offset, enc->methodoffset_, enc->method2lexicalmap_);

            CopyLexicalenvStack(constructor_offset, inst, enc->method2lexicalenvstack_, enc->bb2lexicalenvstack_, enc->globallexical_waitlist_);
            CopyLexicalenvStack(constructor_offset, inst, enc->method2sendablelexicalenvstack_, enc->bb2sendablelexicalenvstack_, enc->globalsendablelexical_waitlist_);

            if (enc->class2memberfuns_->find(constructor_offset) != enc->class2memberfuns_->end()) {
                auto& member_funcs = (*enc->class2memberfuns_)[constructor_offset];
                for (const auto& member_func_offset : member_funcs) {
                    CopyLexicalenvStack(member_func_offset, inst, enc->method2lexicalenvstack_, enc->bb2lexicalenvstack_, enc->globallexical_waitlist_);
                    CopyLexicalenvStack(member_func_offset, inst, enc->method2sendablelexicalenvstack_, enc->bb2sendablelexicalenvstack_, enc->globalsendablelexical_waitlist_);
                }
            }
            
            auto father = *enc->GetExpressionByRegIndex(inst, 0);
            
            if(father != enc->constant_hole){
                auto fathername = enc->GetNameFromExpression(father);
                if(fathername){
                    std::cout << "father is " << *fathername << std::endl;
                }
            }else{
                father = nullptr;
                std::cout << "father is object" << std::endl;
            }

            (*enc->class2father_)[constructor_offset] = father;
       
            auto newname = RemoveArgumentsOfFunc(constructor_offset_name);
            auto newexpression = enc->GetIdentifierByName(newname);
            
            enc->not_add_assgin_for_stlexvar.insert(newexpression);
            enc->SetExpressionByRegister(inst, inst->GetDstReg(), newexpression);
            
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_CREATEPRIVATEPROPERTY_PREF_IMM16_ID16:
       {
            auto literalarray_offset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto member_functions = GetLiteralArrayByOffset(enc->program_, literalarray_offset);
            if(member_functions){
                int32_t startpos = -1;
                for(const auto &member_function: *member_functions){
                    if(startpos == -1){
                        startpos = SearchStartposForCreatePrivateproperty(inst, enc->bb2lexicalenvstack_, enc->method2lexicalmap_, enc->methodoffset_);
                    }
                    std::cout << "startpos: " << startpos << std::endl;
                    auto lexicalenvstack = enc->bb2lexicalenvstack_[inst->GetBasicBlock()];
                    auto &lexicalenv = lexicalenvstack->Top();
                    
                    // std::cout << "[+] size: " << lexicalenvstack->Size() << std::endl;
                    // std::cout << "[+] env size: " << lexicalenvstack->GetLexicalEnv(0).Size() << std::endl;
                    // std::cout << "[+] capacity_: " << lexicalenv.capacity_ << std::endl;

                    uint32_t member_offset = 0;
                    if (enc->methodname2offset_->find(member_function) != enc->methodname2offset_->end()) {
                        member_offset = (*enc->methodname2offset_)[member_function];
                    }else{
                        std::cout << "##name: " << member_function << std::endl;
                        HandleError("#DEFINEMETHOD: find constructor_offset error");
                    }


                    auto newname = enc->RemovePrefixOfFunc(member_function);
                    auto memfun_str = new std::string(newname);

                    // std::cout << "@@@: " << member_function << std::endl;
                    // std::cout << *memfun_str << std::endl;

                    lexicalenv.Set(startpos, memfun_str);
                    DealWithGlobalLexicalWaitlist(0, startpos++, *memfun_str, enc->globallexical_waitlist_);

                    CopyLexicalenvStack(member_offset, inst, enc->method2lexicalenvstack_, enc->bb2lexicalenvstack_, enc->globallexical_waitlist_);

                    // std::cout << "-----------------------------------------------------------------------------" << std::endl;
                    // std::cout << "[-] size: " << lexicalenvstack->Size() << std::endl;
                    // std::cout << "[-] env size: " << lexicalenvstack->GetLexicalEnv(0).Size() << std::endl;
                    // std::cout << "[-] capacity_: " << lexicalenv.capacity_ << std::endl;
                }
            }

            PrintInnerMethod2LexicalMap(enc->method2lexicalmap_, enc->methodoffset_);
            break;
        }
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEPRIVATEPROPERTY_PREF_IMM8_IMM16_IMM16_V8:
       {
            auto tier = static_cast<uint32_t>(inst->GetImms()[1]);
            auto index = static_cast<uint32_t>(inst->GetImms()[2]);
            auto lexicalenvstack = enc->bb2lexicalenvstack_[inst->GetBasicBlock()];

            std::string* privatevar = new std::string("p" + std::to_string(enc->privatevar_count++));
            auto privateid = enc->GetIdentifierByName(privatevar);

            auto obj_reg_identifier = *enc->GetExpressionByRegIndex(inst, 0);
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                                obj_reg_identifier,
                                                                                privateid,
                                                                                es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS,
                                                                                false,
                                                                                false
                                                                            );

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  objattrexpression,
                                                                                  *enc->GetExpressionByAcc(inst),
                                                                                  es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );

            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);

            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);

            lexicalenvstack->Set(tier, index, privatevar);
            DealWithGlobalLexicalWaitlist(tier, index, *privatevar, enc->globallexical_waitlist_);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDPRIVATEPROPERTY_IMM8_IMM16_IMM16:
       {
            auto tier = static_cast<uint32_t>(inst->GetImms()[1]);
            auto index = static_cast<uint32_t>(inst->GetImms()[2]);
            auto lexicalenvstack = enc->bb2lexicalenvstack_[inst->GetBasicBlock()];
            if(lexicalenvstack->GetLexicalEnv(tier)[index] != nullptr){
                auto attr_name = lexicalenvstack->Get(tier, index);
                auto attr_expression = enc->GetIdentifierByName(attr_name);

                auto obj_expression = *enc->GetExpressionByAcc(inst);

                auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                                    obj_expression,
                                                                                    attr_expression,
                                                                                    es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                                    false, 
                                                                                    false);
                enc->HandleNewCreatedExpression(inst, objattrexpression);
            }else{
                std::cout << "tier: " << tier << " , index: " << index << std::endl;
            }

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STPRIVATEPROPERTY_IMM8_IMM16_IMM16_V8:
       {
            auto tier = static_cast<uint32_t>(inst->GetImms()[1]);
            auto index = static_cast<uint32_t>(inst->GetImms()[2]);
            auto lexicalenvstack = enc->bb2lexicalenvstack_[inst->GetBasicBlock()];
            if(lexicalenvstack->GetLexicalEnv(tier)[index] == nullptr){
                HandleError("#LDLEXVAR: lexicalenv is null");
            }
            auto attr_name = lexicalenvstack->Get(tier, index);
            auto attr_expression = enc->GetIdentifierByName(attr_name);

            auto obj_expression = *enc->GetExpressionByRegIndex(inst, 0);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                                obj_expression,
                                                                                attr_expression,
                                                                                es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                                false, 
                                                                                false
                                                                            );   

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  objattrexpression,
                                                                                  *enc->GetExpressionByAcc(inst),
                                                                                  es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc,
                                                                                assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;
        }
        
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_CALLINIT_PREF_IMM8_V8:
       {
            auto funobj = *enc->GetExpressionByAcc(inst);
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funobj,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);

            enc->thisptr = *enc->GetExpressionByRegIndex(inst, 0);
            break;
        }
        
       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_SUPERCALLFORWARDALLARGS_PREF_V8:
       {
            enc->HandleNewCreatedExpression(inst, *enc->GetExpressionByRegIndex(inst, 0));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYNAME_IMM8_ID16:
       case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYNAME_IMM16_ID16:
       {
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            auto attr_expression = enc->GetIdentifierByName(str);
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        enc->GetIdentifierByName("super"),
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        false, 
                                                        false);
            enc->HandleNewCreatedExpression(inst, objattrexpression);
            break;
        }
        
       case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYVALUE_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYVALUE_IMM16_V8:
       {
            auto attr_expression = *enc->GetExpressionByAcc(inst);
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        enc->GetIdentifierByName("super"),
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);

            enc->HandleNewCreatedExpression(inst, objattrexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STSUPERBYNAME_IMM8_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::STSUPERBYNAME_IMM16_ID16_V8:
       {
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        enc->GetIdentifierByName("super"),
                                                        enc->GetIdentifierByName(str),
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        false, 
                                                        false);  
            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->GetExpressionByAcc(inst),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;
        }
       

       case compiler::RuntimeInterface::IntrinsicId::STSUPERBYVALUE_IMM8_V8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STSUPERBYVALUE_IMM16_V8_V8:
       {
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        enc->GetIdentifierByName("super"),
                                                        *enc->GetExpressionByRegIndex(inst, 1),
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);  
            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->GetExpressionByAcc(inst),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;
        }

        
       case compiler::RuntimeInterface::IntrinsicId::LDTHISBYNAME_IMM8_ID16: // hard to trigger
       case compiler::RuntimeInterface::IntrinsicId::LDTHISBYNAME_IMM16_ID16:
       {
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            auto attr_expression = enc->GetIdentifierByName(str);
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        enc->GetIdentifierByName("this"),
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        false, 
                                                        false);

            enc->HandleNewCreatedExpression(inst, objattrexpression);
            break;
        } 
       
       case compiler::RuntimeInterface::IntrinsicId::LDTHISBYVALUE_IMM8: // hard to trigger
       case compiler::RuntimeInterface::IntrinsicId::LDTHISBYVALUE_IMM16:
       {
            auto attr_expression = *enc->GetExpressionByAcc(inst);
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        enc->GetIdentifierByName("this"),
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);

            enc->HandleNewCreatedExpression(inst, objattrexpression);
            break;

        }
       
       case compiler::RuntimeInterface::IntrinsicId::STTHISBYNAME_IMM8_ID16:
       case compiler::RuntimeInterface::IntrinsicId::STTHISBYNAME_IMM16_ID16:
       {
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                                enc->GetIdentifierByName("this"),
                                                                                enc->GetIdentifierByName(str),
                                                                                es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                                false, 
                                                                                false);

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                    objattrexpression,
                                                                                    *enc->GetExpressionByAcc(inst),
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );

            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::STTHISBYVALUE_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::STTHISBYVALUE_IMM16_V8:
       {
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                                enc->GetIdentifierByName("this"),
                                                                                *enc->GetExpressionByRegIndex(inst, 1),
                                                                                es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                                true, 
                                                                                false); 

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                    objattrexpression,
                                                                                    *enc->GetExpressionByAcc(inst),
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                ); 

            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;
        }
       
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_NEWSENDABLEENV_PREF_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDENEWSENDABLEENV_PREF_IMM16:
        {
            auto lexenv_size = static_cast<uint32_t>(inst->GetImms()[0]);

            auto lexicalenvstack = enc->bb2sendablelexicalenvstack_[inst->GetBasicBlock()];
            
            if(lexicalenvstack){
                std::cout << "not null" << std::endl;
            }else{
                std::cout << "null" << std::endl;
            }
        
            lexicalenvstack->Push(lexenv_size);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLECLASS_PREF_IMM16:
       {
            std::cout << "@@@ ldsendableclass >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
            std::cout << enc->methodoffset_ << std::endl;
            auto tier = static_cast<uint32_t>(inst->GetImms()[0]);
            auto index = 0;

            std::cout << "tier: " << std::to_string(tier) << ", index: " << std::to_string(index) << std::endl;

            LexicalEnvStack* lexicalenvstack;
            lexicalenvstack = enc->bb2sendablelexicalenvstack_[inst->GetBasicBlock()];
            std::cout << "size: " << lexicalenvstack->Size() << std::endl;

            if(lexicalenvstack->GetLexicalEnv(tier)[index] == nullptr){
                HandleError("#LDLEXVAR: lexicalenv is null");
            }

            auto identifier_name = lexicalenvstack->Get(tier, index);
            enc->SetExpressionByRegister(inst, inst->GetDstReg(), enc->GetIdentifierByName(enc->RemovePrefixOfFunc(*identifier_name)));
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::DEFINEPROPERTYBYNAME_IMM8_ID16_V8:
       case compiler::RuntimeInterface::IntrinsicId::DEFINEFIELDBYNAME_IMM8_ID16_V8:
       {
            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);

            ArenaVector<es2panda::ir::Expression *> new_properties(enc->parser_program_->Allocator()->Adapter());
            auto raw_obj = *enc->GetExpressionByRegIndex(inst, 0);
            if(raw_obj->IsObjectExpression()){
                auto objexpression = raw_obj->AsObjectExpression();
                for (auto *it : objexpression->Properties()) {
                    switch (it->Type()) {
                        case es2panda::ir::AstNodeType::PROPERTY: {
                            auto props = it->AsProperty();
                            auto key = props->Key();
                            auto keyname = enc->GetNameFromExpression(key);
                            if(keyname && *keyname == str){
                                new_properties.push_back(AllocNode<es2panda::ir::Property>(enc, key, *enc->GetExpressionByAcc(inst)));
                            }else{
                                new_properties.push_back(it);
                            }
                            
                            break;
                        }
                        default: {
                            new_properties.push_back(it);
                            break;
                        }
                    }
                }
                auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                    es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                    std::move(new_properties),
                                                                                    false);
                enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), objectexpression);
            }else if(raw_obj->IsIdentifier()){
                auto attr_expression = enc->GetIdentifierByName(str);
                auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                            raw_obj,
                                                            attr_expression, 
                                                            es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                            false, 
                                                            false);
                auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                    objattrexpression,
                                                                                    *enc->GetExpressionByAcc(inst),
                                                                                    es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );

                auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
                enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);

            }else{
                std::cout << "###: " << std::to_string(static_cast<int>(raw_obj->Type())) << std::endl;
                HandleError("#STARRAYSPREAD2: cann't deal expression except ObjectExpression");

            }
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::DYNAMICIMPORT:
       {
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);
            panda::es2panda::ir::Identifier* funname = enc->GetIdentifierByName("import");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            arguments.push_back(source_expression);

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                            funname,
                                                                            std::move(arguments),
                                                                            nullptr,
                                                                            false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEFIELDBYINDEX_PREF_IMM8_IMM32_V8:
       {
            auto imm = static_cast<uint32_t>(inst->GetImms()[1]);
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByReg(inst->GetSrcReg(0));
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                               obj_reg_identifier,
                                                                               enc->GetLiteralByNum(imm),  
                                                                               es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                               true, 
                                                                               false);

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->GetExpressionByAcc(inst),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        );

            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);

            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEFIELDBYVALUE_PREF_IMM8_V8_V8:
       {
            panda::es2panda::ir::Expression* attr_expression = *enc->GetExpressionByRegIndex(inst, 0);
            panda::es2panda::ir::Expression* obj_expression = *enc->GetExpressionByRegIndex(inst, 1);
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_expression,
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->GetExpressionByAcc(inst),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        );

            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);

            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::SUPERCALLSPREAD_IMM8_V8:
       {
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("super");
            auto source_expression =  *enc->GetExpressionByRegIndex(inst, 0);
            auto arrayexpression = source_expression->AsArrayExpression();
            auto constElements = arrayexpression->Elements();
            auto &nonConstElements = const_cast<ArenaVector<es2panda::ir::Expression *> &>(constElements);

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(nonConstElements),
                                                                                nullptr,
                                                                                false
                                                                            );

            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CREATEREGEXPWITHLITERAL_IMM8_ID16_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::CREATEREGEXPWITHLITERAL_IMM16_ID16_IMM8:
       {
           // 0（none），1（g），2（i），4（m），8（s），16（u），32（y）；3 -> gi。

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            es2panda::ir::Expression *callee = *enc->GetExpressionByRegIndex(inst, 0);

            auto stroffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto str = enc->ir_interface_->GetStringIdByOffset(stroffset);
            arguments.push_back(enc->GetIdentifierByName(str));

            auto imm = static_cast<uint32_t>(inst->GetImms()[2]);
            arguments.push_back(enc->GetLiteralByNum(imm));

            es2panda::ir::Expression *newExprNode = AllocNode<es2panda::ir::NewExpression>(enc, callee, nullptr, std::move(arguments));

            enc->HandleNewCreatedExpression(inst, newExprNode);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHEXCLUDEDKEYS_IMM8_V8_V8:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_CREATEOBJECTWITHEXCLUDEDKEYS_PREF_IMM16_V8_V8:
       {
            uint32_t argsum = static_cast<uint32_t>(inst->GetImms()[0]);
            auto rawobj = *enc->GetExpressionByRegIndex(inst, 0);
            ArenaVector<es2panda::ir::Expression *> properties(enc->parser_program_->Allocator()->Adapter());

            for (uint32_t i = 1; i <= argsum+1; ++i) {
                auto rawattr = *enc->GetExpressionByRegIndex(inst, i);
                // properties.push_back(  AllocNode<es2panda::ir::Property>(enc, rawattr, rawattr) );
                properties.push_back(rawattr);


            }

            auto closure_name =  "closure_" + std::to_string(enc->methodoffset_) + "_" + std::to_string(enc->closure_count);
            enc->closure_count++;

            auto rest = enc->GetIdentifierByName(closure_name);
             enc->HandleNewCreatedExpression(inst, rest);

            properties.push_back(  AllocNode<es2panda::ir::SpreadElement>(enc, es2panda::ir::AstNodeType::SPREAD_ELEMENT, rest));
            auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                std::move(properties),
                                                                                false
                                                                            );

            ArenaVector<es2panda::ir::VariableDeclarator *> declarators(enc->parser_program_->Allocator()->Adapter());
            auto *declarator = AllocNode<es2panda::ir::VariableDeclarator>(enc,
                                                                                objectexpression, 
                                                                                rawobj);
            declarators.push_back(declarator);
            auto variadeclaration = AllocNode<es2panda::ir::VariableDeclaration>(enc, 
                                                                                es2panda::ir::VariableDeclaration::VariableDeclarationKind::CONST,
                                                                                std::move(declarators),
                                                                                true
                                                                            );
            enc->AddInstAst2BlockStatemntByInst(inst, variadeclaration);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::GETTEMPLATEOBJECT_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::GETTEMPLATEOBJECT_IMM16:
       {
            panda::es2panda::ir::Expression* acc = *enc->GetExpressionByAcc(inst);
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("GetTemplateObject");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            arguments.push_back(acc);

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::SETOBJECTWITHPROTO_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::SETOBJECTWITHPROTO_IMM16_V8:
       {
            panda::es2panda::ir::Expression* obj_expression = *enc->GetExpressionByAcc(inst);
            auto value = *enc->GetExpressionByRegIndex(inst, 0);

            auto attr_expression = enc->GetIdentifierByName("__proto__");
            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                                                obj_expression,
                                                                                attr_expression,
                                                                                es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                                                false, 
                                                                                false
                                                                            );   
            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  objattrexpression,
                                                                                  value,
                                                                                  es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                                );
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc,
                                                                                assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_TOPROPERTYKEY_PREF_NONE:
       {
            panda::es2panda::ir::Expression* obj_expression = *enc->GetExpressionByAcc(inst);
            enc->HandleNewCreatedExpression(inst, obj_expression);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::DEFINEGETTERSETTERBYVALUE_V8_V8_V8_V8:
       {
            es2panda::ir::Expression *rawmember = *enc->GetExpressionByRegIndex(inst, 0);
            es2panda::ir::Expression *rawcallee1 = *enc->GetExpressionByRegIndex(inst, 2);
            auto rawcalleename1 = enc->GetNameFromExpression(rawcallee1);
            
            es2panda::ir::Expression *rawcallee2 = *enc->GetExpressionByRegIndex(inst, 3);
            auto rawcalleename2 = enc->GetNameFromExpression(rawcallee2);

            if(rawmember->IsObjectExpression()){
                auto objexpression =  rawmember->AsObjectExpression();
                auto attrexpression = *enc->GetExpressionByRegIndex(inst, 1);
                auto attrname = enc->GetNameFromExpression(attrexpression);
                ArenaVector<es2panda::ir::Expression *> new_properties(enc->parser_program_->Allocator()->Adapter());
                for (auto *it : objexpression->Properties()) {
                    if(it->IsProperty()){
                        auto curpropname = enc->GetNameFromExpression(it->AsProperty()->Key());
                        if(curpropname && attrname && *attrname == *curpropname){
                            continue;
                        }
                    }
                    new_properties.push_back(it);
                }
                
                if(rawcalleename1 && *rawcalleename1 != "undefined"){
                    auto newexpression = enc->GetIdentifierByName(RemoveArgumentsOfFunc(*rawcalleename1));
                    new_properties.push_back(  AllocNode<es2panda::ir::Property>(enc, attrexpression, newexpression));
                }
                if(rawcalleename2 && *rawcalleename2 != "undefined"){
                    auto newexpression = enc->GetIdentifierByName(RemoveArgumentsOfFunc(*rawcalleename2));
                    new_properties.push_back(  AllocNode<es2panda::ir::Property>(enc, attrexpression, newexpression ));
                }

                auto objectexpression = AllocNode<es2panda::ir::ObjectExpression>(enc, 
                                                                                    es2panda::ir::AstNodeType::OBJECT_EXPRESSION,
                                                                                    std::move(new_properties),
                                                                                    false
                                                                                );
                enc->SetExpressionByRegister(inst->GetInput(0).GetInst(), inst->GetSrcReg(0), objectexpression);
            }else{
                uint32_t constructor_offset;
                std::optional<std::string> objname;
                if(rawmember->IsMemberExpression()){
                    auto rawobj = rawmember->AsMemberExpression()->Object();
                    objname = enc->GetNameFromExpression(rawobj);
                }else{
                    objname = enc->GetNameFromExpression(rawmember);
                }
                ////////////////////////////////////////////////////////////////////////////////////////////
                if(objname){
                    if(enc->methodname2offset_->find(*objname) != enc->methodname2offset_->end()){
                        constructor_offset = (*enc->methodname2offset_)[*objname];
                    }else{
                        std::cout << "objname: " << *objname << std::endl;
                        HandleError("#DEFINEGETTERSETTERBYVALUE: not support this case1"); 
                    }
                }else{
                    HandleError("#DEFINEGETTERSETTERBYVALUE: not support this case2"); 
                }
                ////////////////////////////////////////////////////////////////////////////////////////////
                if(rawcalleename1 && *rawcalleename1 != "undefined"){
                    auto tmp = RemoveArgumentsOfFunc(*rawcalleename1);
                    if(enc->methodname2offset_->find(tmp) != enc->methodname2offset_->end()  ){
                        auto methodoffset = (*enc->methodname2offset_)[tmp];
                        (*enc->class2memberfuns_)[constructor_offset].insert(methodoffset);
                        enc->memberfuncs_->insert(methodoffset);
                    }
                }
                //////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if(rawcalleename2 && *rawcalleename2 != "undefined"){
                    auto tmp = RemoveArgumentsOfFunc(*rawcalleename2);
                    if(enc->methodname2offset_->find(tmp) != enc->methodname2offset_->end()){
                        auto methodoffset = (*enc->methodname2offset_)[tmp];
                        (*enc->class2memberfuns_)[constructor_offset].insert(methodoffset);
                        enc->memberfuncs_->insert(methodoffset);
                    }   
                }      
            }
            
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONENTER:
        {
            enc->MarkAsync();

            enc->HandleNewCreatedExpression(inst, enc->constant_asyncfuncmark);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONAWAITUNCAUGHT_V8:
        {
            // panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);
            // auto awaitexpression = AllocNode<es2panda::ir::AwaitExpression>(enc,  source_expression);
            // enc->HandleNewCreatedExpression(inst, awaitexpression);

            enc->MarkAsync();

            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_await") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;
            
            panda::es2panda::ir::Expression* source_expression = *enc->GetExpressionByAcc(inst);
            auto awaitexpression = AllocNode<es2panda::ir::AwaitExpression>(enc,  source_expression);
            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  awaitexpression,
                                                                                  es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);

            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::SUSPENDGENERATOR_V8:
        {
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("suspendgenerator");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByAcc(inst));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 0));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            enc->HandleNewCreatedExpression(inst, callexpression);

            auto obj_expression = *enc->GetExpressionByAcc(inst);
            enc->HandleNewCreatedExpression(inst, obj_expression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::RESUMEGENERATOR:{
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_resumegenerator") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;

            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("GeneratorResume");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByAcc(inst));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );


            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                   es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);
            
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONRESOLVE_V8:
        {
            enc->MarkAsync();
            panda::es2panda::ir::Expression* obj_expression = *enc->GetExpressionByAcc(inst);
            enc->HandleNewCreatedExpression(inst, obj_expression);
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONREJECT_V8:{
            enc->MarkAsync();
            enc->HandleNewCreatedExpression(inst, enc->constant_rejectmode); 
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::GETRESUMEMODE:
        {
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_getresumemode") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;

            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("GetResumeMode");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByAcc(inst));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );


            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                   es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            
            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CREATEGENERATOROBJ_V8:
       {
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("CreateGeneratorObj");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 0));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_generatorobj") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                   es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CREATEITERRESULTOBJ_V8_V8:
       {
            es2panda::ir::Expression *obj_expression = *enc->GetExpressionByRegIndex(inst, 0);
            auto yieldrexpression = AllocNode<es2panda::ir::YieldExpression>(enc, obj_expression, false);

            auto yieldstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, yieldrexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, yieldstatement);
            ////////////////////////////////////////////////////////////////////////////////////////////////
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_createresultobj") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;

            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("CreateIterResultObject");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 0));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 1));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );


            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                   es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            
            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);
            
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::ASYNCGENERATORRESOLVE_V8_V8_V8:
       {
            enc->MarkAsync();
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("AsyncGeneratorResolve");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 0));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 1));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 2));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_asyncgeneratorresolve") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                  es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::SETGENERATORSTATE_IMM8:
       {
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("setgeneratorstate");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByAcc(inst));

            auto statevalue = static_cast<uint32_t>(inst->GetImms()[0]);
            arguments.push_back(AllocNode<es2panda::ir::NumberLiteral>(enc, statevalue));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            enc->HandleNewCreatedExpression(inst, callexpression);

            auto obj_expression = *enc->GetExpressionByAcc(inst);
            enc->HandleNewCreatedExpression(inst, obj_expression);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CREATEASYNCGENERATOROBJ_V8:
       {
            enc->MarkAsync();
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("CreateAsyncGeneratorObj");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 0));
            // arguments.push_back(*enc->GetExpressionByRegIndex(inst, 1));
            // arguments.push_back(*enc->GetExpressionByRegIndex(inst, 2));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_asyncgeneratorobj") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                   es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::ASYNCGENERATORREJECT_V8:
       {
            enc->MarkAsync();
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("AsyncGeneratorReject");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByAcc(inst));
            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 0));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_asyncgeneratorreject") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                   es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);

            break;
        }


       case compiler::RuntimeInterface::IntrinsicId::GETNEXTPROPNAME_V8:
       {
            auto memberfuncname = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        *enc->GetExpressionByRegIndex(inst, 0),
                                                        enc->GetIdentifierByName("next"), 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        false, 
                                                        false);
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());
            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                memberfuncname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );
            enc->HandleNewCreatedExpression(inst, callexpression);

            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_asyncgeneratorobj") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;
            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                   es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);

            

            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::GETPROPITERATOR:
       {
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("GetPropIterator");
            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByAcc(inst));

            es2panda::ir::CallExpression* callexpression = AllocNode<es2panda::ir::CallExpression>(enc,
                                                                                funname,
                                                                                std::move(arguments),
                                                                                nullptr,
                                                                                false
                                                                            );

            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_iterator") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;
            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                   es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);


            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::GETITERATOR_IMM8:
       case compiler::RuntimeInterface::IntrinsicId::GETITERATOR_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::GETASYNCITERATOR_IMM8:
       {
            panda::es2panda::ir::Expression* funname = nullptr;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::GETASYNCITERATOR_IMM8){
                funname = enc->GetIdentifierByName("GetAsyncIterator");
            }else{
                funname = enc->GetIdentifierByName("GetIterator");
            }

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByAcc(inst));

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                funname,
                                                                std::move(arguments),
                                                                nullptr,
                                                                false
                                                                );

            panda::es2panda::ir::Identifier* obj_reg_identifier = enc->GetIdentifierByName(std::string("ret_iterator") + "_" + std::to_string(enc->closure_count));
            enc->closure_count++;

            auto assignexpression = AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                                  obj_reg_identifier,
                                                                                  callexpression,
                                                                                   es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                            );
                                                                            
            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);

            enc->HandleNewCreatedExpression(inst, obj_reg_identifier);
            break;
        }

       case compiler::RuntimeInterface::IntrinsicId::CLOSEITERATOR_IMM8_V8:
       case compiler::RuntimeInterface::IntrinsicId::CLOSEITERATOR_IMM16_V8:
       {
            panda::es2panda::ir::Expression* funname = enc->GetIdentifierByName("IteratorClose");

            ArenaVector<es2panda::ir::Expression *> arguments(enc->parser_program_->Allocator()->Adapter());

            arguments.push_back(*enc->GetExpressionByRegIndex(inst, 0));

            auto callexpression = AllocNode<es2panda::ir::CallExpression>(enc, 
                                                                funname,
                                                                std::move(arguments),
                                                                nullptr,
                                                                false
                                                                );
            enc->HandleNewCreatedExpression(inst, callexpression);
            break;
        }
              
       
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYINDEX_IMM8_IMM16:
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYINDEX_IMM16_IMM16:
        {
            panda::es2panda::ir::Expression* obj_expression = *enc->GetExpressionByAcc(inst);
            
            uint32_t imm;

            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_LDOBJBYINDEX_PREF_IMM32){
                imm = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                imm = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            panda::es2panda::ir::Expression* attr_expression = enc->GetLiteralByNum(imm);

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        obj_expression,
                                                        attr_expression, 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);

            enc->SetExpressionByRegister(inst, inst->GetDstReg(), objattrexpression);
            break;

        }

       case compiler::RuntimeInterface::IntrinsicId::STOBJBYINDEX_IMM8_V8_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::STOBJBYINDEX_IMM16_V8_IMM16:
       case compiler::RuntimeInterface::IntrinsicId::WIDE_STOBJBYINDEX_PREF_V8_IMM32:
       {
            uint32_t imm;
            if(inst->GetIntrinsicId() == compiler::RuntimeInterface::IntrinsicId::WIDE_STOBJBYINDEX_PREF_V8_IMM32){
                imm = static_cast<uint32_t>(inst->GetImms()[0]);
            }else{
                imm = static_cast<uint32_t>(inst->GetImms()[1]);
            }

            auto objattrexpression = AllocNode<es2panda::ir::MemberExpression>(enc,
                                                        *enc->GetExpressionByRegIndex(inst, 0),
                                                        enc->GetLiteralByNum(imm), 
                                                        es2panda::ir::MemberExpression::MemberExpressionKind::PROPERTY_ACCESS, 
                                                        true, 
                                                        false);

             panda::es2panda::ir::Expression* assignexpression =   AllocNode<es2panda::ir::AssignmentExpression>(enc, 
                                                                            objattrexpression,
                                                                            *enc->GetExpressionByAcc(inst),
                                                                            es2panda::lexer::TokenType::PUNCTUATOR_SUBSTITUTION
                                                                        ); 

            auto assignstatement = AllocNode<es2panda::ir::ExpressionStatement>(enc, 
                                                                                assignexpression);
            enc->AddInstAst2BlockStatemntByInst(inst, assignstatement);
            break;        
        
        }
       
        default:
            enc->success_ = false;
            HandleError("Unsupported ecma opcode");
    }
}

```

`autotests/blacklist.txt`:

```txt
../autotests/third_party_typescript/tests/cases/conformance/expressions/thisKeyword/thisInInvalidContextsExternalModule.ts
../autotests/third_party_typescript/tests/cases/conformance/classes/members/privateNames/privateStaticNameShadowing.ts
../autotests/third_party_typescript/tests/cases/conformance/emitter/es5/asyncGenerators/emitter.asyncGenerators.objectLiteralMethods.es5.ts
../autotests/third_party_typescript/tests/cases/conformance/emitter/es2018/asyncGenerators/emitter.asyncGenerators.objectLiteralMethods.es2018.ts
../autotests/third_party_typescript/tests/cases/conformance/emitter/es2015/asyncGenerators/emitter.asyncGenerators.objectLiteralMethods.es2015.ts
../autotests/third_party_typescript/tests/cases/conformance/types/uniqueSymbol/uniqueSymbolsDeclarations.ts
../autotests/third_party_typescript/tests/cases/conformance/types/uniqueSymbol/uniqueSymbols.ts
../autotests/third_party_typescript/tests/cases/conformance/controlFlow/dependentDestructuredVariables.ts

```

`autotests/clean_build_fail_file.py`:

```py
import json
import os
from pathlib import Path

def clean_files_from_json(json_file_path, root_search_dir="."):
    if not os.path.exists(json_file_path):
        print(f"Error: JSON file not found at {json_file_path}")
        return

    with open(json_file_path, 'r', encoding='utf-8') as f:
        try:
            data = json.load(f)
        except json.JSONDecodeError:
            print(f"Error: {json_file_path} is not a valid JSON file")
            return

    print(f"Successfully loaded {len(data)} records, starting cleanup...")

    success_count = 0
    fail_count = 0
    skip_count = 0

    for item in data:
        relative_path = item.get("file")
        if not relative_path:
            continue
        
        target_file = Path(root_search_dir) / relative_path

        if target_file.exists() and target_file.is_file():
            try:
                target_file.unlink()  # Execute deletion
                print(f"[Deleted] {relative_path}")
                success_count += 1
            except Exception as e:
                print(f"[Failed] {relative_path} : {e}")
                fail_count += 1
        else:
            # print(f"[Skipped] File does not exist: {relative_path}")
            skip_count += 1

    print("\n" + "="*30)
    print(f"Cleanup Summary:")
    print(f" - Successfully deleted: {success_count}")
    print(f" - Failed to delete: {fail_count}")
    print(f" - Files already missing: {skip_count}")
    print("="*30)

if __name__ == "__main__":
    clean_files_from_json("status_outputs/2.json")

```

`autotests/count_json_members.py`:

```py
import argparse
import json
from pathlib import Path
import sys

# --- Configuration ---
# Default directory for categorized outputs
DEFAULT_CATEGORY_DIR = "status_outputs"
# Name of the global result file located within the default directory
DEFAULT_GLOBAL_RESULT_FILE_NAME = "res.json" 

def count_members_in_json_file(filepath):
    """
    Reads a JSON file and counts the number of members (list items or dict keys).
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
            if isinstance(data, list) or isinstance(data, dict):
                count = len(data)
                return count, "valid"
            else:
                return 1, type(data).__name__

    except (FileNotFoundError, json.JSONDecodeError, Exception) as e:
        # print(f"Error reading {filepath}: {e}") # Keep quiet for cleaner output
        return 0, "N/A"

def main():
    parser = argparse.ArgumentParser(description="Read JSON files in a directory and count members/items, calculating percentages.")
    
    # Directory argument, optional with default value
    parser.add_argument("-D", "--directory", type=str, default=DEFAULT_CATEGORY_DIR,
                        help=f"The directory containing all JSON files (including res.json) (default: '{DEFAULT_CATEGORY_DIR}').")
    
    # Global file name argument for overriding the default name
    parser.add_argument("-G", "--global_file_name", type=str, default=DEFAULT_GLOBAL_RESULT_FILE_NAME,
                        help=f"The name of the global JSON file (must be inside the directory) (default: '{DEFAULT_GLOBAL_RESULT_FILE_NAME}').")
    
    args = parser.parse_args()

    input_dir = Path(args.directory)
    global_file_path = input_dir / args.global_file_name # Construct full path

    if not input_dir.is_dir():
        print(f"Error: '{args.directory}' is not a valid directory.")
        sys.exit(1)
    if not global_file_path.is_file():
        print(f"Error: Global result file not found at '{global_file_path}'. Please ensure '{args.global_file_name}' exists within the '{args.directory}' directory.")
        sys.exit(1)

    # 1. Get the total count
    total_count, _ = count_members_in_json_file(global_file_path)
    
    if total_count == 0:
        print("Error: Global result file is empty, cannot calculate proportions.")
        sys.exit(1)

    print("-" * 45)
    print(f"Total file count (from {global_file_path.name}): {total_count}")
    print(f"Scanning directory: {input_dir.resolve()}")
    print("-" * 45)

    # 2. Scan categorized JSON files and count members
    # Find all JSON files in the directory
    json_files = sorted(list(input_dir.glob('*.json'))) 
    
    if not json_files:
        print("No categorized JSON files found in the specified directory.")
        return

    processed_count = 0

    print("File Name             | Count | Proportion")
    print("-" * 45)
    for file_path in json_files:
        # Exclude the global file itself from the categorized list
        if file_path.name == args.global_file_name:
            continue

        count, data_type = count_members_in_json_file(file_path)
        if count > 0:
            percentage = (count / total_count) * 100
            # Use formatted output to align columns
            print(f"{file_path.name:<20} | {count:^4} | {percentage:8.2f}%")
            processed_count += count
        
    print("-" * 45)
    print(f"Processed category total: {processed_count} (Should ideally equal total count {total_count})")
    if processed_count != total_count:
         print(f"Warning: Total counts do not match, there might be uncategorized records or JSON parsing errors.")


if __name__ == "__main__":
    main()

```

`autotests/scantstests.py`:

```py
import argparse
import os
import shutil
import subprocess
import json
import sys
import signal
import copy
import ipdb
from pathlib import Path
from itertools import chain

env_vars = copy.deepcopy(os.environ)
env_vars['LD_LIBRARY_PATH'] = '../out/arkcompiler/runtime_core:../out/thirdparty/zlib'

def load_skip_list(skip_file_path):
    if not skip_file_path or not os.path.exists(skip_file_path):
        return set()
    try:
        with open(skip_file_path, 'r', encoding='utf-8') as f:
            return {line.strip() for line in f if line.strip()}
    except Exception as e:
        print(f"Warning: Could not read skip file {skip_file_path}: {e}")
        return set()

def execute_cmd(cmd):
    status_detail = ""
    return_code = None

    try:
        result = subprocess.run(
            cmd,
            check=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=False,
            start_new_session=True,
            timeout=10,
            env=env_vars,
            #shell=True
        )

        return_code = result.returncode
        
        stdout_text = result.stdout.decode('utf-8', errors='backslashreplace')
        stderr_text = result.stderr.decode('utf-8', errors='backslashreplace')

        if result.returncode == 0:
            print(f"✅ Success (Exit Code 0)")
            status_detail = "Success"
        elif result.returncode == 1:
            print(f"❌ Warning: failure (std::exit(EXIT_FAILURE), Exit Code 1)!")
            status_detail = "Error (EXIT_FAILURE)"
        elif result.returncode < 0:
            # Negative return codes indicate termination by signal on Linux
            signal_value = abs(result.returncode)
            signal_name = signal.Signals(signal_value).name if 1 <= signal_value <= 64 else f"Signal {signal_value}"
            
            if signal_value == signal.SIGSEGV.value:
                 print(f"❌ Severe Error: Segmentation Fault ({signal_name})!")
                 status_detail = "Segmentation Fault"
            elif signal_value == getattr(signal, 'SIGABRT', 6):
                 print(f"❌ Severe Error: Process Aborted ({signal_name})!")
                 return_code = -6
                 status_detail = "Aborted (SIGABRT)"
            else:
                 print(f"❌ Warning: terminated by signal ({signal_name})!")
                 status_detail = f"Error (Signal: {signal_name})"
        else:
            # Other non-zero return codes
            print(f"❌ Warning: exited abnormally (Exit Code {result.returncode})!")
            status_detail = f"Error (Exit Code {result.returncode})"

    except subprocess.TimeoutExpired as e:
        print(f"❌ Timeout Error: Process timed out.")
        status_detail = "Timeout Expired"
        return_code = -1
    except FileNotFoundError:
        print(f"Error: Executable not found. Please check the path configuration.")
        status_detail = "Error (Executable Not Found)"
        return_code = -2
    except Exception as e:
        print(f"An error occurred during execution : {e}")
        status_detail = f"Error (Execution Exception: {str(e)})"
        return_code = -3
    finally:
        os.system("pkill -f -9 xabc")
    
    res = {
        "status": status_detail,
        "return_code": return_code
    }
    return res

def load_results(results_path):
    if os.path.exists(results_path):
        try:
            with open(results_path, 'r', encoding='utf-8') as f:
                results_list = json.load(f)
                analyzed_paths = {item.get("file") for item in results_list if item.get("file")}
                return results_list, analyzed_paths
        except json.JSONDecodeError:
            print(f"Warning: Could not parse {results_path}, creating new results.")
    return [], set()

def analysis_onefile(analysis_file):
    # Status Codes Explanation:
    # ret=1: File copy failed. Precondition error, subsequent flow not started.
    # ret=2: Compilation failed. Both attempts (with/without --module) failed to generate a valid .abc file.
    # ret=3: Decompilation failed. At least one compilation succeeded (produced .abc), but all generated .abc files failed the decompilation check.
    # ret=0: Success. Found a mode (module or script) that passed the full link from compilation to decompilation.

    # --- Summary of All Cases ---
    # | First Compile Result (--module) | First Decompile Result | Second Compile Result (No Args) | Second Decompile Result | ret | Status Explanation            |
    # |---------------------------------|------------------------|---------------------------------|-------------------------|-----|-------------------------------|
    # | Fail                            | N/A                    | Fail                            | N/A                     | 2   | Both Compiles Failed          |
    # | Fail                            | N/A                    | Success                         | Fail                    | 3   | Compile OK, Decompile Fail    |
    # | Fail                            | N/A                    | Success                         | Success                 | 0   | Script Mode Success           |
    # | Success                         | Fail                   | Fail                            | N/A                     | 3   | Compile OK, Decompile Fail    |
    # | Success                         | Fail                   | Success                         | Fail                    | 3   | Compile OK, Decompile Fail    |
    # | Success                         | Fail                   | Success                         | Success                 | 0   | Script Mode Success           |
    # | Success                         | Success                | N/A                             | N/A                     | 0   | Module Mode Success (Early Exit)|
    # | N/A                             | N/A                    | N/A                             | N/A                     | 1   | Copy Failed (Precondition Error)|

    es2abc_path = "../../out/x64.release/arkcompiler/ets_frontend/es2abc"
    decompile_exe = "../out/arkcompiler/common/xabc"
    res = {"file": analysis_file}

    if execute_cmd(["cp", analysis_file, "demo.ts"])["return_code"] != 0:
        res["status"] = 1
        return res

    file_path = Path(analysis_file)
    suffix = file_path.suffix.lower()
    ext_flag = "js" if suffix == ".js" else "ts"

    plans = [
        [es2abc_path, "--module", "--extension", ext_flag, "demo.ts", "--output", "demo.abc"],
        [es2abc_path, "--extension", ext_flag, "demo.ts", "--output", "demo.abc"]
    ]

    has_any_compile_success = False

    for cmd in plans:
        if os.path.exists("demo.abc"):
            os.remove("demo.abc")

        compile_res = execute_cmd(cmd)
        if compile_res["return_code"] == 0:
            has_any_compile_success = True

            decompile_res = execute_cmd([decompile_exe])
            if decompile_res["return_code"] == 0:
                res["status"] = 0
                return res
            elif decompile_res["return_code"] == -6:
                res["status"] = 2
                return res
        else:
            continue

    if has_any_compile_success:
        res["status"] = 3
    else:
        res["status"] = 2

    return res

def save_results(results_list, output_dir):
    results_path = Path(output_dir) / "res.json"
    with open(results_path, 'w', encoding='utf-8') as f:
        json.dump(results_list, f, ensure_ascii=False, indent=4)

    grouped_results = {}
    for result_entry in results_list:
        status_code = result_entry.get("status")
        if status_code is not None:
            if status_code not in grouped_results:
                grouped_results[status_code] = []
            grouped_results[status_code].append(result_entry)
        else:
            # Handle entries that somehow lack a status code
            if "unknown_status" not in grouped_results:
                grouped_results["unknown_status"] = []
            grouped_results["unknown_status"].append(result_entry)

    print(f"Distributing results into files based on status code:")
    for status_code, records in grouped_results.items():
        # Ensure the filename is valid (e.g., status 0 -> 0.json, status -11 -> negative_11.json)
        filename = f"{status_code}.json"
        if isinstance(status_code, int) and status_code < 0:
             filename = f"negative_{abs(status_code)}.json"

        filepath = Path(output_dir) / filename
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(records, f, ensure_ascii=False, indent=4)
            
        print(f"  - Status {status_code}: Saved {len(records)} records to {filepath}")

def analysis_files(root_dir, output_dir, skip_list, file_type):
    files_to_analyze = []
    
    if file_type == 'js':
        patterns = ['*.js']
    elif file_type == 'ts':
        patterns = ['*.ts']
    else:
        patterns = ['*.js', '*.ts']

    ts_files = []
    for pattern in patterns:
        ts_files.extend([f for f in root_dir.rglob(pattern) if f.is_file()])

    total_files = len(ts_files)
    results_path = Path(output_dir) / "res.json"

    results_list, analyzed_paths = load_results(str(results_path.resolve()))
    print(f"Loaded {len(analyzed_paths)} historical analysis records.")

    for i, ts_file in enumerate(ts_files):
        file_str = str(ts_file)
        if file_str in analyzed_paths:
            continue

        if file_str in skip_list:
            print(f"Skipping (listed in skip file): {file_str}")
            continue

        print(f"\n[{i+1}/{len(ts_files)}] Analyzing: {file_str}")
        res = analysis_onefile(file_str)
        results_list.append(res)

        if (i + 1) % 1000 == 0:
            save_results(results_list, output_dir)

    save_results(results_list, output_dir)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Recursively analyze TS files using the abc tool.")
    parser.add_argument("-i", "--input_dir", type=str, default="../autotests/third_party_typescript/tests",
                        help=f"Root directory to scan for TS files (default: '../autotests/third_party_typescript/tests')")
    
    parser.add_argument("-o", "--output_dir", type=str, default="status_outputs",
                        help=f"Directory to save status-specific JSON files (default: 'status_outputs')")
    
    parser.add_argument("-s", "--skip-file", type=str, default="blacklist.txt",
                        help="Path to a file containing a list of files to skip (one per line)")

    parser.add_argument("-d", "--record_file", type=str, default="res.json",
                        help=f"JSON file path for analyzed file records (default: res.json)")

    parser.add_argument("-t", "--type", type=str, choices=['ts', 'js', 'all'], default='ts',
                        help="FileType to analyze: ts, js, or all (default: ts)")

    args = parser.parse_args()
    root_dir = Path(args.input_dir)
    if not root_dir.is_dir():
        print(f"Error: '{args.input_dir}' is not a valid directory.")
        sys.exit(1)

    if not os.path.exists(args.output_dir):
        os.makedirs(args.output_dir)
        print(f"\nCreated output directory: {args.output_dir}")

    skip_list = load_skip_list(args.skip_file)
    analysis_files(root_dir, args.output_dir, skip_list, args.type)

    #test_file = "../autotests/third_party_typescript/tests/cases/conformance/emitter/es2015/asyncGenerators/emitter.asyncGenerators.classMethods.es2015.ts"
    #analysis_onefile(test_file)


    

```

`base.cpp`:

```cpp
#include "base.h"

// void HandleError(const std::string& errorMessage) {
//     std::cerr << "Error: " << errorMessage << std::endl;
//     std::exit(EXIT_FAILURE); 
// }


std::string RemoveArgumentsOfFunc(const std::string& input) {
    std::string result;
    size_t endPos = input.find('(');
    if (endPos != std::string::npos) {
        std::string beforeParen = input.substr(0, endPos);
        size_t colonPos = beforeParen.find_last_not_of(':');
        if (colonPos != std::string::npos) {
            beforeParen = beforeParen.substr(0, colonPos+1);
            return beforeParen;
        }
    }

    return input;
}

bool IsArray(const panda::panda_file::LiteralTag &tag)
{
    switch (tag) {
        case panda::panda_file::LiteralTag::ARRAY_U1:
        case panda::panda_file::LiteralTag::ARRAY_U8:
        case panda::panda_file::LiteralTag::ARRAY_I8:
        case panda::panda_file::LiteralTag::ARRAY_U16:
        case panda::panda_file::LiteralTag::ARRAY_I16:
        case panda::panda_file::LiteralTag::ARRAY_U32:
        case panda::panda_file::LiteralTag::ARRAY_I32:
        case panda::panda_file::LiteralTag::ARRAY_U64:
        case panda::panda_file::LiteralTag::ARRAY_I64:
        case panda::panda_file::LiteralTag::ARRAY_F32:
        case panda::panda_file::LiteralTag::ARRAY_F64:
        case panda::panda_file::LiteralTag::ARRAY_STRING:
            return true;
        default:
            return false;
    }
}

std::optional<std::vector<std::string>> GetLiteralArrayByOffset(panda::pandasm::Program* program, uint32_t offset){
    std::vector<std::string> res;
    std::stringstream hexStream;
    hexStream << "0x" << std::hex << offset;
    std::string offsetString = hexStream.str();
    
    for (const auto &[key, lit_array] :  program->literalarray_table) {
        const auto &tag = lit_array.literals_[0].tag_;
                
        if (key.find(offsetString) == std::string::npos || IsArray(tag)) {
            continue;
        }
        
        for (size_t i = 0; i < lit_array.literals_.size(); i++) {
            const auto &tag = lit_array.literals_[i].tag_;
            const auto &val = lit_array.literals_[i].value_;
            if(tag == panda::panda_file::LiteralTag::METHOD || tag == panda::panda_file::LiteralTag::GETTER || 
                tag == panda::panda_file::LiteralTag::SETTER || tag == panda::panda_file::LiteralTag::GENERATORMETHOD){
                res.push_back(std::get<std::string>(val));
            }
        }
        return res;
    }

    return std::nullopt;
}


std::optional<std::string> FindKeyByValue(const std::map<std::string, uint32_t>& myMap, const uint32_t& value) {
    for (const auto& pair : myMap) {
        if (pair.second == value) {
            return pair.first;
        }
    }
    return std::nullopt;
}

std::optional<panda::pandasm::LiteralArray> FindLiteralArrayByOffset(panda::pandasm::Program *program_, uint32_t offset) {
    for (const auto& [key, value] : program_->literalarray_table) {
        if (ParseHexFromKey(key) == offset) {
            return value;
        }
    }
    return std::nullopt;
}


uint32_t ParseHexFromKey(const std::string& key) {
    std::istringstream iss(key);
    std::string temp;
    std::string hexString;

    while (iss >> temp) {
        if (temp.find("0x") == 0 || temp.find("0X") == 0) {
            hexString = temp;
            break;
        }
    }

    uint32_t hexNumber = 0;
    if (!hexString.empty()) {
        std::istringstream(hexString) >> std::hex >> hexNumber;
    }

    return hexNumber;
}


```

`base.h`:

```h
#ifndef DECOMPILER_BASE
#define DECOMPILER_BASE

#include "libpandabase/mem/arena_allocator.h"
#include "libpandabase/mem/pool_manager.h"

#include "libpandafile/class_data_accessor.h"
#include "libpandafile/class_data_accessor-inl.h"
#include "libpandafile/method_data_accessor.h"
#include "libpandafile/module_data_accessor-inl.h"

#include "libpandafile/file.h"
#include "libpandafile/util/collect_util.h"

#include "libpandabase/utils/logger.h"


/////////////////////////////////////////////////////////////
#include "compiler/optimizer/ir/graph.h"
#include "compiler/optimizer/pass.h"
#include "compiler/optimizer/ir_builder/ir_builder.h"
#include "compiler/optimizer/analysis/loop_analyzer.h"

#include "compiler/optimizer/optimizations/branch_elimination.h"
#include "compiler/optimizer/optimizations/cleanup.h"
#include "compiler/optimizer/optimizations/lowering.h"
#include "compiler/optimizer/optimizations/move_constants.h"
#include "compiler/optimizer/optimizations/regalloc/reg_alloc.h"
#include "compiler/optimizer/optimizations/vn.h"
#include "constant_propagation/constant_propagation.h"
#include "compiler/optimizer/ir/basicblock.h"
#include "compiler/optimizer/ir/graph_visitor.h"
#include "compiler/optimizer/ir/inst.h"
#include "compiler/optimizer/ir/runtime_interface.h"

/////////////////////////////////////////////////////////////

#include "bytecode_optimizer/ir_interface.h"
#include "bytecode_optimizer/runtime_adapter.h"
#include "bytecode_optimizer/bytecode_analysis_results.h"
#include "bytecode_optimizer/bytecodeopt_options.h"
#include "bytecode_optimizer/optimize_bytecode.h"
#include "bytecode_optimizer/reg_acc_alloc.h"
#include "bytecode_optimizer/reg_encoder.h"
#include "bytecode_optimizer/tagged_value.h"
#include "bytecode_optimizer/codegen.h"
#include "bytecode_optimizer/common.h"

/////////////////////////////////////////////////////////////
#include "assembler/annotation.h"
#include "assembler/assembly-function.h"
#include "assembly-parser.h"
#include "assembler/assembly-parser.h"

#include "disassembler/disassembler.h"

#include "ast.h"

#include <string>
#include <typeinfo>
#include <sstream>
#include <variant>

#include <vector>
#include <memory>
#include <stdexcept>

static int count = 0;

inline void HandleInnerError(const std::string& message) {
    std::cerr << "Error: " << message << std::endl;
    std::exit(EXIT_FAILURE);
}

template<typename... Args>
std::string formatString(Args... args) {
    std::ostringstream oss;
    int unpack[] = {0, ((void)(oss << args), 0)...};
    static_cast<void>(unpack);
    return oss.str();
}

template<typename... Args>
void HandleError(Args... args) {
    std::ostringstream oss;
    oss << formatString(args...);
    HandleInnerError(oss.str());
}

template <typename Container, typename T>
bool contains(const Container& container, const T& value) {
    if constexpr (std::is_same_v<Container, std::set<T>> || std::is_same_v<Container, std::unordered_set<T>>) {
        return container.find(value) != container.end();
    } else {
        return std::find(container.begin(), container.end(), value) != container.end();
    }
}

std::string RemoveArgumentsOfFunc(const std::string& input);
std::optional<std::vector<std::string>> GetLiteralArrayByOffset(panda::pandasm::Program* program, uint32_t offset);
std::optional<std::string> FindKeyByValue(const std::map<std::string, uint32_t>& myMap, const uint32_t& value);

uint32_t ParseHexFromKey(const std::string& key);
std::optional<panda::pandasm::LiteralArray> FindLiteralArrayByOffset(panda::pandasm::Program *program_, uint32_t offset) ;
#endif

```

`build.sh`:

```sh
../prebuilts/build-tools/linux-x86/bin/gn gen out --args='target_os="linux" target_cpu="x64" is_debug=false '
ninja -C out -w dupbuild=warn xabc

```

`classconstruction.cpp`:

```cpp
#include "classconstruction.h"


std::string ExtractPrefix(const std::string& input){
    size_t firstPos = input.find('#'); 
    if (firstPos != std::string::npos) {
        size_t secondPos = input.find('#', firstPos + 1); 
        if (secondPos != std::string::npos) {
            return input.substr(firstPos + 1, secondPos - firstPos - 1);
        }
    }
    return ""; 
}

bool IsInstanceMethod(std::string func_name){
    auto prefix = ExtractPrefix(func_name);
    return prefix.find('~') != std::string::npos && prefix.find('>') != std::string::npos;
}

bool ConstructClasses(std::map<uint32_t, std::set<uint32_t>> &class2memberfuns, panda::es2panda::parser::Program *parser_program,  BytecodeOptIrInterface *ir_interface,
        std::map<uint32_t, panda::es2panda::ir::Expression*> &class2father, std::map<uint32_t, panda::es2panda::ir::ScriptFunction *> &method2scriptfunast,
        std::map<uint32_t, panda::es2panda::ir::ClassDeclaration *> &ctor2classdeclast, std::map<std::string, std::string>& raw2newname
        ){
    for(const auto & pair : class2memberfuns){
        auto constructor_offset = pair.first;

        std::cout << constructor_offset << std::endl;
        auto member_funcs = pair.second;
        //std::cout << "constructor_offset: " << constructor_offset << std::endl;
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        auto methodid = ir_interface->GetMethodIdByOffset(constructor_offset);
        auto constructor_offset_name = RemoveArgumentsOfFunc(methodid);
        std::string newname_constructor_offset_name;
        
        if(raw2newname.find(constructor_offset_name) != raw2newname.end()){
            newname_constructor_offset_name =  raw2newname[constructor_offset_name];
        }else{
            HandleError("#ConstructClasses: find constructor_offset_name newname error");
        }
        panda::es2panda::util::StringView name_view1 = panda::es2panda::util::StringView(*(new std::string(RemoveArgumentsOfFunc(newname_constructor_offset_name))));

        auto identNode = AllocNode<panda::es2panda::ir::Identifier>(parser_program, name_view1);


        ArenaVector<es2panda::ir::TSClassImplements *> implements(parser_program->Allocator()->Adapter());
        ArenaVector<es2panda::ir::TSIndexSignature *> indexSignatures(parser_program->Allocator()->Adapter());
        ArenaVector<es2panda::ir::Statement *> properties(parser_program->Allocator()->Adapter());
        
        //////////////////////////////////////////////////////////////////////////////////////////////
        ArenaVector<es2panda::ir::Decorator *> decorators(parser_program->Allocator()->Adapter());
        ArenaVector<es2panda::ir::Annotation *> annotations(parser_program->Allocator()->Adapter());
        ArenaVector<es2panda::ir::ParamDecorators> paramDecorators(parser_program->Allocator()->Adapter());

        panda::es2panda::util::StringView name_view2 = panda::es2panda::util::StringView("constructor");
        auto keyNode = AllocNode<panda::es2panda::ir::Identifier>(parser_program, name_view2);

        auto func = method2scriptfunast[constructor_offset];
        method2scriptfunast.erase(constructor_offset);

        if(func == nullptr){
            HandleError("#DecompilePandaFile: find constructor function fail!");
        }

        auto funcExpr = AllocNode<panda::es2panda::ir::FunctionExpression>(parser_program, func);


        auto ctor = AllocNode<es2panda::ir::MethodDefinition>(parser_program, es2panda::ir::MethodDefinitionKind::CONSTRUCTOR, keyNode, funcExpr,
                                                        es2panda::ir::ModifierFlags::PUBLIC, parser_program->Allocator(), 
                                                    std::move(decorators), std::move(annotations), 
                                                    std::move(paramDecorators), false);
        
        ///////////////////////////////////////////////////////////////////////////////////////////////

        auto father = class2father[constructor_offset];                          
        auto classDefinition = AllocNode<es2panda::ir::ClassDefinition>(parser_program, nullptr, identNode, nullptr, nullptr,
                                                                       std::move(implements), ctor, nullptr,
                                                                       nullptr, father, std::move(properties), 
                                                                       std::move(indexSignatures), false, false);
        
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        for (const auto& member_func_offset : member_funcs) {
            if(constructor_offset == member_func_offset){
                continue;
            }
            
            auto func = method2scriptfunast[member_func_offset];
            method2scriptfunast.erase(member_func_offset);

            if(func == nullptr){
                std::cout << "member function offset: " << member_func_offset << std::endl;
                HandleError("#ConstructClasses: find member function fail!");
            }

            auto funcExpr = AllocNode<es2panda::ir::FunctionExpression>(parser_program, func);


            auto raw_member_name  = RemoveArgumentsOfFunc(ir_interface->GetMethodIdByOffset(member_func_offset));
            std::string new_member_name;
            if(raw2newname.find(raw_member_name) != raw2newname.end()){
                new_member_name =  raw2newname[raw_member_name];
            }else{
                HandleError("#ConstructClasses: find new_member_name newname error");
            }

            panda::es2panda::util::StringView name_view3 = panda::es2panda::util::StringView(*(new std::string(new_member_name)));
            auto keyNode =  AllocNode<es2panda::ir::Identifier>(parser_program, name_view3);

            ArenaVector<es2panda::ir::Decorator *> decorators(parser_program->Allocator()->Adapter());
            ArenaVector<es2panda::ir::Annotation *> annotations(parser_program->Allocator()->Adapter());
            ArenaVector<es2panda::ir::ParamDecorators> paramDecorators(parser_program->Allocator()->Adapter());

            

            auto method = AllocNode<es2panda::ir::MethodDefinition>(parser_program, es2panda::ir::MethodDefinitionKind::METHOD, keyNode, funcExpr,
                                                            es2panda::ir::ModifierFlags::PUBLIC, parser_program->Allocator(), 
                                                        std::move(decorators), std::move(annotations), 
                                                        std::move(paramDecorators), false);                                              
            classDefinition->AddToBody(method);

        }
  
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ArenaVector<es2panda::ir::Decorator *> decorators1(parser_program->Allocator()->Adapter());
        ArenaVector<es2panda::ir::Annotation *> annotations1(parser_program->Allocator()->Adapter());

       
        auto classDecl =  AllocNode<es2panda::ir::ClassDeclaration>(parser_program, classDefinition, 
                                                std::move(decorators1), std::move(annotations1), false);
        
        ctor2classdeclast[constructor_offset] = classDecl;
    }
    return true;
}

```

`classconstruction.h`:

```h
#ifndef DECOMPILER_CLASSCONSTRUCTION
#define DECOMPILER_CLASSCONSTRUCTION


#include "base.h"
using namespace panda;
using namespace bytecodeopt;

bool IsInstanceMethod(std::string func_name);

bool ConstructClasses(std::map<uint32_t, std::set<uint32_t>> &class2memberfuns, panda::es2panda::parser::Program *parser_program,  BytecodeOptIrInterface *ir_interface,
        std::map<uint32_t, panda::es2panda::ir::Expression*> &class2father, std::map<uint32_t, panda::es2panda::ir::ScriptFunction *> &method2scriptfunast,
        std::map<uint32_t, panda::es2panda::ir::ClassDeclaration *> &ctor2classdeclast, std::map<std::string, std::string>& raw2newname
        );

#endif
```

`complexstmt2body.h`:

```h
#ifndef DECOMPILER_COMPLEX2BODY
#define DECOMPILER_COMPLEX2BODY

#include "base.h"

es2panda::ir::BlockStatement* ComplexStmt2Body(panda::es2panda::compiler::ir *astnode){
    switch(astnode->Type()){
        case AstNodeType::DO_WHILE_STATEMENT:
            return astnode->AsDoWhileStatement()->Body();
            break;
        case AstNodeType::FOR_IN_STATEMENT:
            return astnode->AsForInStatement()->Body();
            break;
        case AstNodeType::FOR_OF_STATEMENT:
            return astnode->AsForOfStatement()->Body();
            break;

        default :;
    }
}

#endif
```

`docker/Dockerfile`:

```
FROM ubuntu:20.04

# 设置环境变量
ENV DEBIAN_FRONTEND=noninteractive \
    LANG=C.UTF-8 \
    ROOT_PATH=/root \
    DIRECTORY_NAME=harmonyos \
    GIT_REPO=https://github.com/jd-opensource/arkdecompiler.git \
    PATH=/root/bin:/root/harmonyos/prebuilts/build-tools/linux-x86/bin:$PATH

# 安装依赖
RUN apt-get update && apt-get install -y \
    python3 python3-pip ruby git-lfs gcc-multilib g++-multilib \
    zlib1g-dev libc++1 curl nodejs \
    && rm -rf /var/lib/apt/lists/*
RUN ln -s /usr/bin/python3 /usr/bin/python
# 配置 git 信息
RUN git config --global user.email "you@example.com" \
    && git config --global user.name "Your Name"

# 安装 repo 工具
RUN mkdir -p /root/bin \
    && curl -L https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 -o /root/bin/repo \
    && chmod a+x /root/bin/repo \
    && pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple requests

# 创建源码目录并进入
WORKDIR /root/${DIRECTORY_NAME}

# 初始化并同步 OpenHarmony 源码
# 分支使用OpenHarmony-5.1.0-Release master分支有部分依赖的头文件被删除
RUN repo init -u https://gitee.com/ark-standalone-build/manifest.git -b OpenHarmony-5.1.0-Release \
    && repo sync -c -j8 \
    && repo forall -c 'git lfs pull' \
    && ./prebuilts_download.sh

# 克隆 arkdecompiler
RUN if [ ! -d arkdecompiler ]; then \
        git clone ${GIT_REPO}; \
    else \
        cd arkdecompiler && git pull; \
    fi

# 打 patch 添加xabc进入构建目标,修改BUILD.gn
RUN cp ./arkdecompiler/patches/arkcompiler_runtime_core_a94c360.patch ./arkcompiler/runtime_core/ \
    && cp ./arkdecompiler/patches/third_party_protobuf_0e4c27.patch ./third_party/protobuf/ \
    && cp ./arkdecompiler/patches/arkcompiler_ets_frontend_09e1955c6.patch ./arkcompiler/ets_frontend/ \
    && cd /root/harmonyos/arkcompiler/runtime_core \
    && git apply arkcompiler_runtime_core_a94c360.patch \
    && cd /root/harmonyos/third_party/protobuf \
    && git apply third_party_protobuf_0e4c27.patch \
    && cd /root/harmonyos/arkcompiler/ets_frontend \
    && git apply arkcompiler_ets_frontend_09e1955c6.patch

# 修改 run_command.py默认使用python3
RUN sed -i '1s|.*|#!/usr/bin/env python3|' /root/harmonyos/third_party/openssl/run_command.py

CMD ["/bin/bash"]

```

`fundepscan.cpp`:

```cpp
#include "fundepscan.h"

namespace panda::bytecodeopt {

bool FunDepScan::RunImpl(){
    //std::cout << "[+] @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" << std::endl;
    if(GetGraph()->GetVectorBlocks().size() != 0 && GetGraph()->GetAliveBlocksCount() < GetGraph()->GetVectorBlocks().size()){
        //std::cout << "GetGraph()->GetVectorBlocks().size(): " << GetGraph()->GetVectorBlocks().size() << std::endl;
        //std::cout << "GetGraph()->GetAliveBlocksCount(): " << GetGraph()->GetAliveBlocksCount() << std::endl;
        return false;
    }
    //std::cout << "[-] @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" << std::endl;
    for (auto *bb : GetGraph()->GetBlocksLinearOrder()) {
        for (const auto &inst : bb->AllInsts()) {
            VisitInstruction(inst);
        }
    }

    this->UpdateMemberDepConstructor();
    return true;
}

void FunDepScan::VisitIntrinsic(GraphVisitor *visitor, Inst *inst_base)
{
    ASSERT(inst_base->IsIntrinsic());
    VisitEcma(visitor, inst_base);
}

void FunDepScan::VisitEcma(panda::compiler::GraphVisitor *visitor, Inst *inst_base){
    
    ASSERT(inst_base->IsIntrinsic());
    auto inst = inst_base->CastToIntrinsic();
    auto enc = static_cast<FunDepScan *>(visitor);
    
    switch(inst->GetIntrinsicId()){
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM8_ID16:
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM16_ID16:
        {
            auto literalarray_offset = static_cast<uint32_t>(inst->GetImms()[1]); 
            auto literalarray = FindLiteralArrayByOffset(enc->program_, literalarray_offset);

            for (const auto& literal : literalarray->literals_) {
                if(literal.tag_ == panda_file::LiteralTag::METHOD){
                    auto methodname = std::string(std::get<std::string>(literal.value_));
                    for (const auto& pair : *enc->methodname2offset_) {
                        if(pair.first.find(methodname) != std::string::npos){
                            uint32_t methodoffset = pair.second;
                            enc->depedges_->push_back(std::make_pair(enc->methodoffset_, methodoffset));
                        }
                    }
                }
            }
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM8_ID16_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM16_ID16_IMM8:
        {
            
            uint32_t methodoffset = static_cast<uint32_t>(inst->GetImms()[1]);
            enc->depedges_->push_back(std::make_pair(enc->methodoffset_, methodoffset));

            if(contains(*enc->memberfuncs_, enc->methodoffset_)){
                if(enc->current_constructor_offset){
                    (*enc->class2memberfuns_)[enc->current_constructor_offset].insert(methodoffset);
                    enc->depedges_->push_back(std::make_pair(enc->methodoffset_, methodoffset));
                    enc->memberfuncs_->insert(methodoffset);
                }
            }
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM8_ID16_IMM8:
        case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM16_ID16_IMM8:
        {
            auto methodoffset = static_cast<uint32_t>(inst->GetImms()[1]);
            auto method_name = enc->ir_interface_->GetMethodIdByOffset(methodoffset);
            
            if(!enc->current_constructor_offset){
                enc->depedges_->push_back(std::make_pair(enc->methodoffset_, methodoffset));
            }else{
                (*enc->class2memberfuns_)[enc->current_constructor_offset].insert(methodoffset);
                if(method_name.find("instance_initializer") != std::string::npos){
                    std::cout << "set construct2initializer: " << enc->current_constructor_offset << " : " << methodoffset << std::endl;
                    enc->construct2initializer_[enc->current_constructor_offset] = methodoffset;
                    enc->current_instance_initializer = methodoffset;
                    
                }else if(method_name.find("static_initializer") != std::string::npos){
                    std::cout << "set construct2staticinitializer: " << enc->current_constructor_offset << " : " << methodoffset << std::endl;
                    enc->construct2staticinitializer_[enc->current_constructor_offset] = methodoffset;
                    enc->current_static_initializer = methodoffset;
                
                }
            }
            
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM8_ID16_ID16_IMM16_V8:
        case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM16_ID16_ID16_IMM16_V8:
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINESENDABLECLASS_PREF_IMM16_ID16_ID16_IMM16_V8:
        {
            auto constructor_offset = static_cast<uint32_t>(inst->GetImms()[1]);
            enc->current_constructor_offset = constructor_offset;

            enc->inserted_construct_order_.push_back(enc->current_constructor_offset);

             (*enc->class2memberfuns_)[constructor_offset].insert(constructor_offset);

            auto literalarray_offset = static_cast<uint32_t>(inst->GetImms()[2]);
            auto member_functions = GetLiteralArrayByOffset(enc->program_, literalarray_offset);
            if(member_functions){
                for(auto const& member_function : *member_functions){
                    if (enc->methodname2offset_->find(member_function) != enc->methodname2offset_->end()) {
                        auto memeber_offset = (*enc->methodname2offset_)[member_function];
                        (*enc->class2memberfuns_)[constructor_offset].insert(memeber_offset);
                    }else{
                        HandleError("#function dep scan: DEFINECLASSWITHBUFFER");
                    }
                }
            }
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_CREATEPRIVATEPROPERTY_PREF_IMM16_ID16:{
            auto ir_id0 = static_cast<uint32_t>(inst->GetImms()[1]);
            auto member_functions = GetLiteralArrayByOffset(enc->program_, ir_id0);
            if(member_functions){
                for(const auto& member_function : *member_functions){
                    auto memeber_offset = (*enc->methodname2offset_)[member_function];
                    (*enc->class2memberfuns_)[enc->current_constructor_offset].insert(memeber_offset);
                }
            }else{
                HandleError("#function dep scan: CALLRUNTIME_CREATEPRIVATEPROPERTY");
            }
            break;
        }

        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEPRIVATEPROPERTY_PREF_IMM8_IMM16_IMM16_V8:{
            auto tier = static_cast<uint32_t>(inst->GetImms()[1]);
            auto index = static_cast<uint32_t>(inst->GetImms()[2]);

            //(*enc->method2lexicalmap_)[enc->methodoffset_][tier].insert(index);
            (*enc->method2lexicalmap_)[enc->current_constructor_offset][tier].insert(index);
            break;
        }

        default:;
    }
}

};

```

`fundepscan.h`:

```h
#ifndef DECOMPILER_FUNDEPSCAN
#define DECOMPILER_FUNDEPSCAN

#include "base.h"

namespace panda::bytecodeopt {

using compiler::BasicBlock;
using compiler::Inst;
using compiler::Opcode;

class FunDepScan : public compiler::Optimization, public compiler::GraphVisitor {
public:
    explicit FunDepScan(compiler::Graph *graph,  const BytecodeOptIrInterface *iface, panda::pandasm::Program* program, 
        panda::disasm::Disassembler& disasm, uint32_t methodoffset,
        std::vector<std::pair<uint32_t, uint32_t>>* depedges,
        std::map<uint32_t, std::set<uint32_t>> *class2memberfuns,
        std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap,
        std::set<uint32_t>* memberfuncs,
        std::map<std::string, std::string> *raw2newname,
        std::map<std::string, uint32_t> *methodname2offset
        )
        : compiler::Optimization(graph), ir_interface_(iface), program_(program), disasm_(disasm), methodoffset_(methodoffset), 
        depedges_(depedges), class2memberfuns_(class2memberfuns), method2lexicalmap_(method2lexicalmap),
        memberfuncs_(memberfuncs), raw2newname_(raw2newname), methodname2offset_(methodname2offset)
    {
        this->current_function_initializer = 0;
        this->current_constructor_offset = 0;

        auto construct_offset = this->FindKeyWithFunction(methodoffset);
        if(construct_offset){
            this->current_constructor_offset = *construct_offset;
        }
    }

    ~FunDepScan() override = default;
    bool RunImpl() override;

    const char *GetPassName() const override
    {
        return "FunDepScan";
    }

    const ArenaVector<BasicBlock *> &GetBlocksToVisit() const override
    {
        return GetGraph()->GetBlocksRPO();
    }

    std::optional<uint32_t> FindKeyWithFunction(uint32_t functionId) const {
        for (const auto& [key, funcSet] : *class2memberfuns_) {
            if (funcSet.find(functionId) != funcSet.end()) {
                return key;
            }
        }
        return {};
    }

    void UpdateMemberDepConstructor(){
        // method define class > static_initializer > instance_initializer > member functions
  
        uint32_t last_class_member = 0; // multiple class analysis sequence
        for(const auto& constructor_offset : this->inserted_construct_order_){
            if(this->class2memberfuns_->find(constructor_offset) == this->class2memberfuns_->end()){
                continue;
            }
            
            auto member_funcs = (*this->class2memberfuns_)[constructor_offset];
            this->memberfuncs_->insert(constructor_offset);

            uint32_t function_initializer = 0;
            uint32_t static_function_initializer = 0;
            uint32_t predecessor_of_memeber = 0;

            if(this->construct2initializer_.find(constructor_offset) != this->construct2initializer_.end()){
                function_initializer = this->construct2initializer_[constructor_offset];
            }

            if(this->construct2staticinitializer_.find(constructor_offset) != this->construct2staticinitializer_.end()){
                static_function_initializer = this->construct2staticinitializer_[constructor_offset];
            }

            uint32_t predecessor_of_initializer;
            if(last_class_member){
                predecessor_of_initializer = last_class_member;
            }else{
                predecessor_of_initializer = this->methodoffset_;
            }

            if(static_function_initializer && function_initializer){
                this->depedges_->push_back(std::make_pair(predecessor_of_initializer, static_function_initializer));
                this->depedges_->push_back(std::make_pair(static_function_initializer, function_initializer));
                predecessor_of_memeber = function_initializer;
            }else if(static_function_initializer && !function_initializer){
                this->depedges_->push_back(std::make_pair(predecessor_of_initializer, static_function_initializer));
                predecessor_of_memeber = static_function_initializer;
            }else if(!static_function_initializer && function_initializer){
                this->depedges_->push_back(std::make_pair(predecessor_of_initializer, function_initializer));
                predecessor_of_memeber = function_initializer;
            }else{
                predecessor_of_memeber = predecessor_of_initializer;
            }

            for (const auto& memeber_offset : member_funcs) {
                this->memberfuncs_->insert(memeber_offset);
                last_class_member = memeber_offset;
                if(memeber_offset == predecessor_of_memeber){
                    continue;
                }

                if(static_function_initializer && memeber_offset == static_function_initializer ){
                    continue;
                }

                if(function_initializer && memeber_offset == function_initializer ){
                    continue;
                }

                this->depedges_->push_back(std::make_pair(predecessor_of_memeber, memeber_offset));
            }
        }
    }

    static void VisitIntrinsic(GraphVisitor *visitor, Inst *inst_base);
    static void VisitEcma(panda::compiler::GraphVisitor *visitor, Inst *inst_base);

#include "compiler/optimizer/ir/visitor.inc"

    const BytecodeOptIrInterface *ir_interface_;
    panda::pandasm::Program* program_;
    [[maybe_unused]] panda::disasm::Disassembler& disasm_;
    uint32_t methodoffset_;

    std::vector<std::pair<uint32_t, uint32_t>>* depedges_; // left depends on right
    std::map<uint32_t, std::set<uint32_t>> *class2memberfuns_;

    std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>> *method2lexicalmap_;

    std::set<uint32_t>* memberfuncs_;

    [[maybe_unused]] std::map<std::string, std::string> *raw2newname_;

    std::map<std::string, uint32_t> *methodname2offset_;

    std::map<uint32_t, uint32_t> construct2initializer_;
    std::map<uint32_t, uint32_t> construct2staticinitializer_;

    std::vector<uint32_t> inserted_construct_order_;

    uint32_t current_constructor_offset;
    uint32_t current_function_initializer;
    uint32_t current_instance_initializer;
    uint32_t current_static_initializer;
};

}
#endif

```

`genlogs.sh`:

```sh
#!/bin/bash
MODULE_OPTION=$2

if [ "$MODULE_OPTION" = "module" ]; then
    ../out/x64.release/arkcompiler/ets_frontend/es2abc --module --dump-assembly  demo.ts  --output demo.abc > $1/demo.pa.raw
    ../out/x64.release/arkcompiler/ets_frontend/es2abc --module --dump-ast demo.ts --output demo.abc > $1/demo.ast
    ../out/x64.release/arkcompiler/runtime_core/ark_disasm demo.abc demo.pa
else
    ../out/x64.release/arkcompiler/ets_frontend/es2abc --dump-assembly  demo.ts  --output demo.abc > $1/demo.pa.raw
    ../out/x64.release/arkcompiler/ets_frontend/es2abc --dump-ast demo.ts --output demo.abc > $1/demo.ast
    ../out/x64.release/arkcompiler/runtime_core/ark_disasm demo.abc demo.pa
fi

```

`hot.sh`:

```sh
../out/x64.debug/arkcompiler/ets_frontend/es2abc --module --dump-symbol-table base.map --output  1.abc 1.ts
../out/x64.debug/arkcompiler/ets_frontend/es2abc --module --hot-reload  --input-symbol-table base.map --output demo.abc 2.ts
../out/x64.debug/arkcompiler/runtime_core/ark_disasm demo.abc demo.pa
rm 1.abc
```

`intrinsicid2name.h`:

```h
#ifndef DECOMPILER_INTRINSIC2NAME
#define DECOMPILER_INTRINSIC2NAME

namespace panda::compiler {
std::string GetIntrinsicOpcodeName(compiler::RuntimeInterface::IntrinsicId id) {
    switch(id) {
        case compiler::RuntimeInterface::IntrinsicId::LDUNDEFINED: {
            return "ldundefined";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDNULL: {
            return "ldnull";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTRUE: {
            return "ldtrue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDFALSE: {
            return "ldfalse";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYOBJECT: {
            return "createemptyobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYARRAY_IMM8: {
            return "createemptyarray";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEARRAYWITHBUFFER_IMM8_ID16: {
            return "createarraywithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM8_ID16: {
            return "createobjectwithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWOBJRANGE_IMM8_IMM8_V8: {
            return "newobjrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWLEXENV_IMM8: {
            return "newlexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::ADD2_IMM8_V8: {
            return "add2";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUB2_IMM8_V8: {
            return "sub2";
        }
        case compiler::RuntimeInterface::IntrinsicId::MUL2_IMM8_V8: {
            return "mul2";
        }
        case compiler::RuntimeInterface::IntrinsicId::DIV2_IMM8_V8: {
            return "div2";
        }
        case compiler::RuntimeInterface::IntrinsicId::MOD2_IMM8_V8: {
            return "mod2";
        }
        case compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8: {
            return "eq";
        }
        case compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8: {
            return "noteq";
        }
        case compiler::RuntimeInterface::IntrinsicId::LESS_IMM8_V8: {
            return "less";
        }
        case compiler::RuntimeInterface::IntrinsicId::LESSEQ_IMM8_V8: {
            return "lesseq";
        }
        case compiler::RuntimeInterface::IntrinsicId::GREATER_IMM8_V8: {
            return "greater";
        }
        case compiler::RuntimeInterface::IntrinsicId::GREATEREQ_IMM8_V8: {
            return "greatereq";
        }
        case compiler::RuntimeInterface::IntrinsicId::SHL2_IMM8_V8: {
            return "shl2";
        }
        case compiler::RuntimeInterface::IntrinsicId::SHR2_IMM8_V8: {
            return "shr2";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASHR2_IMM8_V8: {
            return "ashr2";
        }
        case compiler::RuntimeInterface::IntrinsicId::AND2_IMM8_V8: {
            return "and2";
        }
        case compiler::RuntimeInterface::IntrinsicId::OR2_IMM8_V8: {
            return "or2";
        }
        case compiler::RuntimeInterface::IntrinsicId::XOR2_IMM8_V8: {
            return "xor2";
        }
        case compiler::RuntimeInterface::IntrinsicId::EXP_IMM8_V8: {
            return "exp";
        }
        case compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM8: {
            return "typeof";
        }
        case compiler::RuntimeInterface::IntrinsicId::TONUMBER_IMM8: {
            return "tonumber";
        }
        case compiler::RuntimeInterface::IntrinsicId::TONUMERIC_IMM8: {
            return "tonumeric";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEG_IMM8: {
            return "neg";
        }
        case compiler::RuntimeInterface::IntrinsicId::NOT_IMM8: {
            return "not";
        }
        case compiler::RuntimeInterface::IntrinsicId::INC_IMM8: {
            return "inc";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEC_IMM8: {
            return "dec";
        }
        case compiler::RuntimeInterface::IntrinsicId::ISTRUE: {
            return "istrue";
        }
        case compiler::RuntimeInterface::IntrinsicId::ISFALSE: {
            return "isfalse";
        }
        case compiler::RuntimeInterface::IntrinsicId::ISIN_IMM8_V8: {
            return "isin";
        }
        case compiler::RuntimeInterface::IntrinsicId::INSTANCEOF_IMM8_V8: {
            return "instanceof";
        }
        case compiler::RuntimeInterface::IntrinsicId::STRICTNOTEQ_IMM8_V8: {
            return "strictnoteq";
        }
        case compiler::RuntimeInterface::IntrinsicId::STRICTEQ_IMM8_V8: {
            return "stricteq";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLARG0_IMM8: {
            return "callarg0";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLARG1_IMM8_V8: {
            return "callarg1";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLARGS2_IMM8_V8_V8: {
            return "callargs2";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLARGS3_IMM8_V8_V8_V8: {
            return "callargs3";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHIS0_IMM8_V8: {
            return "callthis0";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHIS1_IMM8_V8_V8: {
            return "callthis1";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHIS2_IMM8_V8_V8_V8: {
            return "callthis2";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHIS3_IMM8_V8_V8_V8_V8: {
            return "callthis3";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLTHISRANGE_IMM8_IMM8_V8: {
            return "callthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUPERCALLTHISRANGE_IMM8_IMM8_V8: {
            return "supercallthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM8_ID16_IMM8: {
            return "definefunc";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM8_ID16_IMM8: {
            return "definemethod";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM8_ID16_ID16_IMM16_V8: {
            return "defineclasswithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETNEXTPROPNAME_V8: {
            return "getnextpropname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYVALUE_IMM8_V8: {
            return "ldobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYVALUE_IMM8_V8_V8: {
            return "stobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYVALUE_IMM8_V8: {
            return "ldsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYINDEX_IMM8_IMM16: {
            return "ldobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYINDEX_IMM8_V8_IMM16: {
            return "stobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM4_IMM4: {
            return "ldlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM4_IMM4: {
            return "stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::TRYLDGLOBALBYNAME_IMM8_ID16: {
            return "tryldglobalbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::TRYSTGLOBALBYNAME_IMM8_ID16: {
            return "trystglobalbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDGLOBALVAR_IMM16_ID16: {
            return "ldglobalvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYNAME_IMM8_ID16: {
            return "ldobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYNAME_IMM8_ID16_V8: {
            return "stobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYNAME_IMM8_ID16: {
            return "ldsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STCONSTTOGLOBALRECORD_IMM16_ID16: {
            return "stconsttoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTOGLOBALRECORD_IMM16_ID16: {
            return "sttoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHISBYNAME_IMM8_ID16: {
            return "ldthisbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTHISBYNAME_IMM8_ID16: {
            return "stthisbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHISBYVALUE_IMM8: {
            return "ldthisbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTHISBYVALUE_IMM8_V8: {
            return "stthisbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::RETURN: {
            return "return";
        }
        case compiler::RuntimeInterface::IntrinsicId::RETURNUNDEFINED: {
            return "returnundefined";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETPROPITERATOR: {
            return "getpropiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETITERATOR_IMM8: {
            return "getiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::CLOSEITERATOR_IMM8_V8: {
            return "closeiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::POPLEXENV: {
            return "poplexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDNAN: {
            return "ldnan";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDINFINITY: {
            return "ldinfinity";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETUNMAPPEDARGS: {
            return "getunmappedargs";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDGLOBAL: {
            return "ldglobal";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDNEWTARGET: {
            return "ldnewtarget";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHIS: {
            return "ldthis";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDHOLE: {
            return "ldhole";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEREGEXPWITHLITERAL_IMM8_ID16_IMM8: {
            return "createregexpwithliteral";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEREGEXPWITHLITERAL_IMM16_ID16_IMM8: {
            return "createregexpwithliteral";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRANGE_IMM8_IMM8_V8: {
            return "callrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFUNC_IMM16_ID16_IMM8: {
            return "definefunc";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINECLASSWITHBUFFER_IMM16_ID16_ID16_IMM16_V8: {
            return "defineclasswithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETTEMPLATEOBJECT_IMM8: {
            return "gettemplateobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::SETOBJECTWITHPROTO_IMM8_V8: {
            return "setobjectwithproto";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUE_IMM8_V8_V8: {
            return "stownbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYINDEX_IMM8_V8_IMM16: {
            return "stownbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAME_IMM8_ID16_V8: {
            return "stownbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETMODULENAMESPACE_IMM8: {
            return "getmodulenamespace";
        }
        case compiler::RuntimeInterface::IntrinsicId::STMODULEVAR_IMM8: {
            return "stmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDLOCALMODULEVAR_IMM8: {
            return "ldlocalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDEXTERNALMODULEVAR_IMM8: {
            return "ldexternalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::STGLOBALVAR_IMM16_ID16: {
            return "stglobalvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEEMPTYARRAY_IMM16: {
            return "createemptyarray";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEARRAYWITHBUFFER_IMM16_ID16: {
            return "createarraywithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHBUFFER_IMM16_ID16: {
            return "createobjectwithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWOBJRANGE_IMM16_IMM8_V8: {
            return "newobjrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM16: {
            return "typeof";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYVALUE_IMM16_V8: {
            return "ldobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYVALUE_IMM16_V8_V8: {
            return "stobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYVALUE_IMM16_V8: {
            return "ldsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYINDEX_IMM16_IMM16: {
            return "ldobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYINDEX_IMM16_V8_IMM16: {
            return "stobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDLEXVAR_IMM8_IMM8: {
            return "ldlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::STLEXVAR_IMM8_IMM8: {
            return "stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::TRYLDGLOBALBYNAME_IMM16_ID16: {
            return "tryldglobalbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::TRYSTGLOBALBYNAME_IMM16_ID16: {
            return "trystglobalbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAMEWITHNAMESET_IMM8_ID16_V8: {
            return "stownbynamewithnameset";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDOBJBYNAME_IMM16_ID16: {
            return "ldobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOBJBYNAME_IMM16_ID16_V8: {
            return "stobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSUPERBYNAME_IMM16_ID16: {
            return "ldsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHISBYNAME_IMM16_ID16: {
            return "ldthisbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTHISBYNAME_IMM16_ID16: {
            return "stthisbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDTHISBYVALUE_IMM16: {
            return "ldthisbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STTHISBYVALUE_IMM16_V8: {
            return "stthisbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCGENERATORREJECT_V8: {
            return "asyncgeneratorreject";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUEWITHNAMESET_IMM8_V8_V8: {
            return "stownbyvaluewithnameset";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETITERATOR_IMM16: {
            return "getiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::CLOSEITERATOR_IMM16_V8: {
            return "closeiterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDSYMBOL: {
            return "ldsymbol";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONENTER: {
            return "asyncfunctionenter";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDFUNCTION: {
            return "ldfunction";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEBUGGER: {
            return "debugger";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEGENERATOROBJ_V8: {
            return "creategeneratorobj";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEITERRESULTOBJ_V8_V8: {
            return "createiterresultobj";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEOBJECTWITHEXCLUDEDKEYS_IMM8_V8_V8: {
            return "createobjectwithexcludedkeys";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM8_V8: {
            return "newobjapply";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWOBJAPPLY_IMM16_V8: {
            return "newobjapply";
        }
        case compiler::RuntimeInterface::IntrinsicId::NEWLEXENVWITHNAME_IMM8_ID16: {
            return "newlexenvwithname";
        }
        case compiler::RuntimeInterface::IntrinsicId::CREATEASYNCGENERATOROBJ_V8: {
            return "createasyncgeneratorobj";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCGENERATORRESOLVE_V8_V8_V8: {
            return "asyncgeneratorresolve";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUPERCALLSPREAD_IMM8_V8: {
            return "supercallspread";
        }
        case compiler::RuntimeInterface::IntrinsicId::APPLY_IMM8_V8_V8: {
            return "apply";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUPERCALLARROWRANGE_IMM8_IMM8_V8: {
            return "supercallarrowrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEGETTERSETTERBYVALUE_V8_V8_V8_V8: {
            return "definegettersetterbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DYNAMICIMPORT: {
            return "dynamicimport";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEMETHOD_IMM16_ID16_IMM8: {
            return "definemethod";
        }
        case compiler::RuntimeInterface::IntrinsicId::RESUMEGENERATOR: {
            return "resumegenerator";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETRESUMEMODE: {
            return "getresumemode";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETTEMPLATEOBJECT_IMM16: {
            return "gettemplateobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::DELOBJPROP_V8: {
            return "delobjprop";
        }
        case compiler::RuntimeInterface::IntrinsicId::SUSPENDGENERATOR_V8: {
            return "suspendgenerator";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONAWAITUNCAUGHT_V8: {
            return "asyncfunctionawaituncaught";
        }
        case compiler::RuntimeInterface::IntrinsicId::COPYDATAPROPERTIES_V8: {
            return "copydataproperties";
        }
        case compiler::RuntimeInterface::IntrinsicId::STARRAYSPREAD_V8_V8: {
            return "starrayspread";
        }
        case compiler::RuntimeInterface::IntrinsicId::SETOBJECTWITHPROTO_IMM16_V8: {
            return "setobjectwithproto";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUE_IMM16_V8_V8: {
            return "stownbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STSUPERBYVALUE_IMM8_V8_V8: {
            return "stsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STSUPERBYVALUE_IMM16_V8_V8: {
            return "stsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYINDEX_IMM16_V8_IMM16: {
            return "stownbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAME_IMM16_ID16_V8: {
            return "stownbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONRESOLVE_V8: {
            return "asyncfunctionresolve";
        }
        case compiler::RuntimeInterface::IntrinsicId::ASYNCFUNCTIONREJECT_V8: {
            return "asyncfunctionreject";
        }
        case compiler::RuntimeInterface::IntrinsicId::COPYRESTARGS_IMM8: {
            return "copyrestargs";
        }
        case compiler::RuntimeInterface::IntrinsicId::STSUPERBYNAME_IMM8_ID16_V8: {
            return "stsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STSUPERBYNAME_IMM16_ID16_V8: {
            return "stsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYVALUEWITHNAMESET_IMM16_V8_V8: {
            return "stownbyvaluewithnameset";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDBIGINT_ID16: {
            return "ldbigint";
        }
        case compiler::RuntimeInterface::IntrinsicId::STOWNBYNAMEWITHNAMESET_IMM16_ID16_V8: {
            return "stownbynamewithnameset";
        }
        case compiler::RuntimeInterface::IntrinsicId::SETGENERATORSTATE_IMM8: {
            return "setgeneratorstate";
        }
        case compiler::RuntimeInterface::IntrinsicId::GETASYNCITERATOR_IMM8: {
            return "getasynciterator";
        }
        case compiler::RuntimeInterface::IntrinsicId::LDPRIVATEPROPERTY_IMM8_IMM16_IMM16: {
            return "ldprivateproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::STPRIVATEPROPERTY_IMM8_IMM16_IMM16_V8: {
            return "stprivateproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::TESTIN_IMM8_IMM16_IMM16: {
            return "testin";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEFIELDBYNAME_IMM8_ID16_V8: {
            return "definefieldbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEFINEPROPERTYBYNAME_IMM8_ID16_V8: {
            return "definepropertybyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_NOTIFYCONCURRENTRESULT_PREF_NONE: {
            return "callruntime.notifyconcurrentresult";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDLEXENV_PREF_NONE: {
            return "deprecated.ldlexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_CREATEOBJECTWITHEXCLUDEDKEYS_PREF_IMM16_V8_V8: {
            return "wide.createobjectwithexcludedkeys";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_PREF_NONE: {
            return "throw";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEFIELDBYVALUE_PREF_IMM8_V8_V8: {
            return "callruntime.definefieldbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_POPLEXENV_PREF_NONE: {
            return "deprecated.poplexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWOBJRANGE_PREF_IMM16_V8: {
            return "wide.newobjrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_NOTEXISTS_PREF_NONE: {
            return "throw.notexists";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEFIELDBYINDEX_PREF_IMM8_IMM32_V8: {
            return "callruntime.definefieldbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_GETITERATORNEXT_PREF_V8_V8: {
            return "deprecated.getiteratornext";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWLEXENV_PREF_IMM16: {
            return "wide.newlexenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_PATTERNNONCOERCIBLE_PREF_NONE: {
            return "throw.patternnoncoercible";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_TOPROPERTYKEY_PREF_NONE: {
            return "callruntime.topropertykey";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CREATEARRAYWITHBUFFER_PREF_IMM16: {
            return "deprecated.createarraywithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_NEWLEXENVWITHNAME_PREF_IMM16_ID16: {
            return "wide.newlexenvwithname";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_DELETESUPERPROPERTY_PREF_NONE: {
            return "throw.deletesuperproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_CREATEPRIVATEPROPERTY_PREF_IMM16_ID16: {
            return "callruntime.createprivateproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CREATEOBJECTWITHBUFFER_PREF_IMM16: {
            return "deprecated.createobjectwithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_CALLRANGE_PREF_IMM16_V8: {
            return "wide.callrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_CONSTASSIGNMENT_PREF_V8: {
            return "throw.constassignment";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINEPRIVATEPROPERTY_PREF_IMM8_IMM16_IMM16_V8: {
            return "callruntime.defineprivateproperty";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_TONUMBER_PREF_V8: {
            return "deprecated.tonumber";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_CALLTHISRANGE_PREF_IMM16_V8: {
            return "wide.callthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_IFNOTOBJECT_PREF_V8: {
            return "throw.ifnotobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_CALLINIT_PREF_IMM8_V8: {
            return "callruntime.callinit";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_TONUMERIC_PREF_V8: {
            return "deprecated.tonumeric";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLTHISRANGE_PREF_IMM16_V8: {
            return "wide.supercallthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_UNDEFINEDIFHOLE_PREF_V8_V8: {
            return "throw.undefinedifhole";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_DEFINESENDABLECLASS_PREF_IMM16_ID16_ID16_IMM16_V8: {
            return "callruntime.definesendableclass";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_NEG_PREF_V8: {
            return "deprecated.neg";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_SUPERCALLARROWRANGE_PREF_IMM16_V8: {
            return "wide.supercallarrowrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_IFSUPERNOTCORRECTCALL_PREF_IMM8: {
            return "throw.ifsupernotcorrectcall";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLECLASS_PREF_IMM16: {
            return "callruntime.ldsendableclass";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_NOT_PREF_V8: {
            return "deprecated.not";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDOBJBYINDEX_PREF_IMM32: {
            return "wide.ldobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_IFSUPERNOTCORRECTCALL_PREF_IMM16: {
            return "throw.ifsupernotcorrectcall";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEEXTERNALMODULEVAR_PREF_IMM8: {
            return "callruntime.ldsendableexternalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_INC_PREF_V8: {
            return "deprecated.inc";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STOBJBYINDEX_PREF_V8_IMM32: {
            return "wide.stobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::THROW_UNDEFINEDIFHOLEWITHNAME_PREF_ID16: {
            return "throw.undefinedifholewithname";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLEEXTERNALMODULEVAR_PREF_IMM16: {
            return "callruntime.wideldsendableexternalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_DEC_PREF_V8: {
            return "deprecated.dec";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STOWNBYINDEX_PREF_V8_IMM32: {
            return "wide.stownbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_NEWSENDABLEENV_PREF_IMM8: {
            return "callruntime.newsendableenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLARG0_PREF_V8: {
            return "deprecated.callarg0";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_COPYRESTARGS_PREF_IMM16: {
            return "wide.copyrestargs";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDENEWSENDABLEENV_PREF_IMM16: {
            return "callruntime.widenewsendableenv";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLARG1_PREF_V8_V8: {
            return "deprecated.callarg1";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDLEXVAR_PREF_IMM16_IMM16: {
            return "wide.ldlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_STSENDABLEVAR_PREF_IMM4_IMM4: {
            return "callruntime.stsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLARGS2_PREF_V8_V8_V8: {
            return "deprecated.callargs2";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STLEXVAR_PREF_IMM16_IMM16: {
            return "wide.stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_STSENDABLEVAR_PREF_IMM8_IMM8: {
            return "callruntime.stsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLARGS3_PREF_V8_V8_V8_V8: {
            return "deprecated.callargs3";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_GETMODULENAMESPACE_PREF_IMM16: {
            return "wide.getmodulenamespace";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDESTSENDABLEVAR_PREF_IMM16_IMM16: {
            return "callruntime.widestsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLRANGE_PREF_IMM16_V8: {
            return "deprecated.callrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STMODULEVAR_PREF_IMM16: {
            return "wide.stmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEVAR_PREF_IMM4_IMM4: {
            return "callruntime.ldsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLSPREAD_PREF_V8_V8_V8: {
            return "deprecated.callspread";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDLOCALMODULEVAR_PREF_IMM16: {
            return "wide.ldlocalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLEVAR_PREF_IMM8_IMM8: {
            return "callruntime.ldsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CALLTHISRANGE_PREF_IMM16_V8: {
            return "deprecated.callthisrange";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDEXTERNALMODULEVAR_PREF_IMM16: {
            return "wide.ldexternalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLEVAR_PREF_IMM16_IMM16: {
            return "callruntime.wideldsendablevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_DEFINECLASSWITHBUFFER_PREF_ID16_IMM16_IMM16_V8_V8: {
            return "deprecated.defineclasswithbuffer";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_LDPATCHVAR_PREF_IMM16: {
            return "wide.ldpatchvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_ISTRUE_PREF_IMM8: {
            return "callruntime.istrue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_RESUMEGENERATOR_PREF_V8: {
            return "deprecated.resumegenerator";
        }
        case compiler::RuntimeInterface::IntrinsicId::WIDE_STPATCHVAR_PREF_IMM16: {
            return "wide.stpatchvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_ISFALSE_PREF_IMM8: {
            return "callruntime.isfalse";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_GETRESUMEMODE_PREF_V8: {
            return "deprecated.getresumemode";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDLAZYMODULEVAR_PREF_IMM8: {
            return "callruntime.ldlazymodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_GETTEMPLATEOBJECT_PREF_V8: {
            return "deprecated.gettemplateobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDLAZYMODULEVAR_PREF_IMM16: {
            return "callruntime.wideldlazymodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_DELOBJPROP_PREF_V8_V8: {
            return "deprecated.delobjprop";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDLAZYSENDABLEMODULEVAR_PREF_IMM8: {
            return "callruntime.ldlazysendablemodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_SUSPENDGENERATOR_PREF_V8_V8: {
            return "deprecated.suspendgenerator";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDLAZYSENDABLEMODULEVAR_PREF_IMM16: {
            return "callruntime.wideldlazysendablemodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_ASYNCFUNCTIONAWAITUNCAUGHT_PREF_V8_V8: {
            return "deprecated.asyncfunctionawaituncaught";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_SUPERCALLFORWARDALLARGS_PREF_V8: {
            return "callruntime.supercallforwardallargs";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_COPYDATAPROPERTIES_PREF_V8_V8: {
            return "deprecated.copydataproperties";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_LDSENDABLELOCALMODULEVAR_PREF_IMM8: {
            return "callruntime.ldsendablelocalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_SETOBJECTWITHPROTO_PREF_V8_V8: {
            return "deprecated.setobjectwithproto";
        }
        case compiler::RuntimeInterface::IntrinsicId::CALLRUNTIME_WIDELDSENDABLELOCALMODULEVAR_PREF_IMM16: {
            return "callruntime.wideldsendablelocalmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDOBJBYVALUE_PREF_V8_V8: {
            return "deprecated.ldobjbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDSUPERBYVALUE_PREF_V8_V8: {
            return "deprecated.ldsuperbyvalue";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDOBJBYINDEX_PREF_V8_IMM32: {
            return "deprecated.ldobjbyindex";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_ASYNCFUNCTIONRESOLVE_PREF_V8_V8_V8: {
            return "deprecated.asyncfunctionresolve";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_ASYNCFUNCTIONREJECT_PREF_V8_V8_V8: {
            return "deprecated.asyncfunctionreject";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STLEXVAR_PREF_IMM4_IMM4_V8: {
            return "deprecated.stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STLEXVAR_PREF_IMM8_IMM8_V8: {
            return "deprecated.stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STLEXVAR_PREF_IMM16_IMM16_V8: {
            return "deprecated.stlexvar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_GETMODULENAMESPACE_PREF_ID32: {
            return "deprecated.getmodulenamespace";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STMODULEVAR_PREF_ID32: {
            return "deprecated.stmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDOBJBYNAME_PREF_ID32_V8: {
            return "deprecated.ldobjbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDSUPERBYNAME_PREF_ID32_V8: {
            return "deprecated.ldsuperbyname";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDMODULEVAR_PREF_ID32_IMM8: {
            return "deprecated.ldmodulevar";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STCONSTTOGLOBALRECORD_PREF_ID32: {
            return "deprecated.stconsttoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STLETTOGLOBALRECORD_PREF_ID32: {
            return "deprecated.stlettoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_STCLASSTOGLOBALRECORD_PREF_ID32: {
            return "deprecated.stclasstoglobalrecord";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_LDHOMEOBJECT_PREF_NONE: {
            return "deprecated.ldhomeobject";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_CREATEOBJECTHAVINGMETHOD_PREF_IMM16: {
            return "deprecated.createobjecthavingmethod";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_DYNAMICIMPORT_PREF_V8: {
            return "deprecated.dynamicimport";
        }
        case compiler::RuntimeInterface::IntrinsicId::DEPRECATED_ASYNCGENERATORREJECT_PREF_V8_V8: {
            return "deprecated.asyncgeneratorreject";
        }
        default: {
            return "";
        }
    }
}
}

#endif
```

`intrinsicid2token.h`:

```h
#ifndef DECOMPILER_INTRINSIC2TOKEN
#define DECOMPILER_INTRINSIC2TOKEN

#include "intrinsicid2name.h"

panda::es2panda::lexer::TokenType BinIntrinsicIdToToken(panda::compiler::RuntimeInterface::IntrinsicId id){

    switch (id) {
        case panda::compiler::RuntimeInterface::IntrinsicId::AND2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_BITWISE_AND;
        case panda::compiler::RuntimeInterface::IntrinsicId::OR2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_BITWISE_OR;
        case panda::compiler::RuntimeInterface::IntrinsicId::MUL2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MULTIPLY;
        case panda::compiler::RuntimeInterface::IntrinsicId::DIV2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_DIVIDE;
        case panda::compiler::RuntimeInterface::IntrinsicId::SUB2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MINUS;
        case panda::compiler::RuntimeInterface::IntrinsicId::NOT_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_TILDE;
        case panda::compiler::RuntimeInterface::IntrinsicId::SHL2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LEFT_SHIFT;
        case panda::compiler::RuntimeInterface::IntrinsicId::ASHR2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_RIGHT_SHIFT;
        case panda::compiler::RuntimeInterface::IntrinsicId::LESSEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN_EQUAL;
        case panda::compiler::RuntimeInterface::IntrinsicId::GREATEREQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN_EQUAL;
        case panda::compiler::RuntimeInterface::IntrinsicId::MOD2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MOD;
        case panda::compiler::RuntimeInterface::IntrinsicId::XOR2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_BITWISE_XOR;

        case panda::compiler::RuntimeInterface::IntrinsicId::EXP_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_EXPONENTIATION;

        case panda::compiler::RuntimeInterface::IntrinsicId::SHR2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_UNSIGNED_RIGHT_SHIFT;

        case panda::compiler::RuntimeInterface::IntrinsicId::ADD2_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_PLUS;

        /////////////////////////
        
        case panda::compiler::RuntimeInterface::IntrinsicId::LESS_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN;

        case panda::compiler::RuntimeInterface::IntrinsicId::GREATER_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN;

        case panda::compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::STRICTEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_STRICT_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::STRICTNOTEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_STRICT_EQUAL;


        case panda::compiler::RuntimeInterface::IntrinsicId::INSTANCEOF_IMM8_V8: 
            return panda::es2panda::lexer::TokenType::KEYW_INSTANCEOF;
        case panda::compiler::RuntimeInterface::IntrinsicId::ISIN_IMM8_V8:
            return panda::es2panda::lexer::TokenType::KEYW_IN;
            
        default:
            std::cout << "S6" << std::endl;
            HandleError("#BinIntrinsicIdToToken");
            return panda::es2panda::lexer::TokenType::EOS;
    }
}

panda::es2panda::lexer::TokenType BinInverseToken2Token(panda::es2panda::lexer::TokenType id){
    switch (id) {
        case panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN_EQUAL:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN;

        case panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN_EQUAL:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN;


        case panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN_EQUAL;

        case panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN_EQUAL;

        case panda::es2panda::lexer::TokenType::PUNCTUATOR_EQUAL:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_EQUAL;

        case panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_EQUAL:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_EQUAL;

        case panda::es2panda::lexer::TokenType::PUNCTUATOR_STRICT_EQUAL:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_STRICT_EQUAL;

        case panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_STRICT_EQUAL:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_STRICT_EQUAL;
  
        default:
            return id;
    }
}


panda::es2panda::lexer::TokenType BinInverseIntrinsicIdToToken(panda::compiler::RuntimeInterface::IntrinsicId id){

    switch (id) {
        case panda::compiler::RuntimeInterface::IntrinsicId::LESSEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN;

        case panda::compiler::RuntimeInterface::IntrinsicId::GREATEREQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN;


        case panda::compiler::RuntimeInterface::IntrinsicId::LESS_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_GREATER_THAN_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::GREATER_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_LESS_THAN_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::EQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::NOTEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::STRICTEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_NOT_STRICT_EQUAL;

        case panda::compiler::RuntimeInterface::IntrinsicId::STRICTNOTEQ_IMM8_V8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_STRICT_EQUAL;
  
        default:
            std::cout << "S7" << std::endl;
            HandleError("#BinInverseIntrinsicIdToToken");
            return panda::es2panda::lexer::TokenType::EOS;
    }
}


panda::es2panda::lexer::TokenType UnaryPrefixIntrinsicIdToToken(panda::compiler::RuntimeInterface::IntrinsicId id){

    switch (id) {
        case panda::compiler::RuntimeInterface::IntrinsicId::NEG_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MINUS;
        case panda::compiler::RuntimeInterface::IntrinsicId::NOT_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_TILDE;
        case panda::compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM8:
        case panda::compiler::RuntimeInterface::IntrinsicId::TYPEOF_IMM16:
            return panda::es2panda::lexer::TokenType::KEYW_TYPEOF;
        case panda::compiler::RuntimeInterface::IntrinsicId::DELOBJPROP_V8:
            return panda::es2panda::lexer::TokenType::KEYW_DELETE;
        default:
            std::cout << "S8: " << GetIntrinsicOpcodeName(id) << std::endl;
            HandleError("#UnaryPrefixIntrinsicIdToToken");
            return panda::es2panda::lexer::TokenType::EOS;
    }
}


panda::es2panda::lexer::TokenType IncDecIntrinsicIdToToken(panda::compiler::RuntimeInterface::IntrinsicId id){
    switch (id) {
        case panda::compiler::RuntimeInterface::IntrinsicId::DEC_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_MINUS;

        case panda::compiler::RuntimeInterface::IntrinsicId::INC_IMM8:
            return panda::es2panda::lexer::TokenType::PUNCTUATOR_PLUS;
        default:
            std::cout << "S9" << std::endl;
            HandleError("#IncDecIntrinsicIdToToken");
            return panda::es2panda::lexer::TokenType::EOS;
    }
}
#endif
```

`lexicalenv.cpp`:

```cpp
#include "lexicalenv.h"
#include <algorithm>
#include <utility>



LexicalEnv::LexicalEnv(size_t capacity) 
    : expressions_(capacity, nullptr), capacity_(capacity), full_size_(0) {
}

void LexicalEnv::AddIndexes(size_t index){
    indexes_.insert(index);
}

void LexicalEnv::LogIndexes() {
    std::cout << "[*] index >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" << std::endl;
    for (const auto& value : indexes_) {
        std::cout << value << " ";
    }
    std::cout << std::endl;
}


bool LexicalEnv::IsFull() const {
    for (size_t i = 0; i < capacity_; ++i) {
        if(expressions_[i] == nullptr){
            //HandleError("#LexicalEnv::IsFull : " + std::to_string(i));
            return false;
        }
    }
    return true;
}

LexicalEnv::LexicalEnv(const LexicalEnv& other) 
    : expressions_(other.capacity_), capacity_(other.capacity_), full_size_(other.full_size_){
    
    for (size_t i = 0; i < capacity_; ++i) {
        if(other.expressions_[i] == nullptr){
        }else{
            expressions_[i] = new std::string(*(other.expressions_[i]));
        }
    }

    indexes_.insert(other.indexes_.begin(), other.indexes_.end());
}

std::string*& LexicalEnv::operator[](size_t index) {
    CheckIndex(index);
    return expressions_[index];
}

const std::string* LexicalEnv::operator[](size_t index) const {
    CheckIndex(index);
    return expressions_[index];
}

std::string* LexicalEnv::Get(size_t index) const {
    CheckIndex(index);
    return expressions_[index];
}

void LexicalEnv::Set(size_t index, std::string* expr) {
    CheckIndex(index);
    if(expr == nullptr){
        HandleError("expr is nullptr");
    }
    expressions_[index] = expr;
    AddIndexes(index); /// support callruntime.createprivateproperty
}

size_t LexicalEnv::Size() const {
    size_t cout = 0;
    for (size_t i = 0; i < capacity_; ++i) {
        if(expressions_[i] != nullptr){
            full_size_ = i;
            cout++;
        }
    }
    return cout;
}

bool LexicalEnv::IsValidIndex(size_t index) const {
    return index < capacity_;
}

void LexicalEnv::CheckIndex(size_t index) const {
    if (index >= capacity_) {
        HandleError("#LexicalEnv::CheckIndex: LexicalEnv index out of range");
    }
}

LexicalEnvStack::LexicalEnvStack() {
}

LexicalEnvStack::LexicalEnvStack(const LexicalEnvStack& other) 
    : stack_(other.stack_) {
}

bool LexicalEnvStack::IsFull() const {
    for(auto const &lexicalenv : stack_){
        if(!lexicalenv.IsFull()){
            return false;
        }
    }
    return true;
}

LexicalEnvStack::~LexicalEnvStack() {
}

LexicalEnv* LexicalEnvStack::Push(size_t capacity) {
    stack_.emplace_back(capacity);
    return &stack_.back();
}

void LexicalEnvStack::Pop() {
    if (stack_.empty()) {
        HandleError("#LexicalEnvStack::Pop: Cannot pop from empty stack");
    }
    stack_.pop_back();
}

size_t LexicalEnvStack::Size() const {
    return stack_.size();
}

bool LexicalEnvStack::Empty() const {
    return stack_.empty();
}

std::string* LexicalEnvStack::Get(size_t A, size_t B) const {
    CheckIndex(A, B);
    
    size_t actualIndex = stack_.size() - 1 - A;
    return stack_[actualIndex].Get(B);
}

bool LexicalEnvStack::IsSetSafe(size_t A, size_t B) {
    if (stack_.empty()) {
        return false;
    }
    
    if (A >= stack_.size()) {
        return false;
    }

    size_t actualIndex = stack_.size() - 1 - A;
    if (!stack_[actualIndex].IsValidIndex(B)) {
       return false;
    }
    return true;
}

void LexicalEnvStack::Set(size_t A, size_t B, std::string* expr) {
    CheckIndex(A, B);
    
    size_t actualIndex = stack_.size() - 1 - A;
    stack_[actualIndex].Set(B, expr);
}

void LexicalEnvStack::SetIndexes(size_t A, std::set<size_t> indexes) {
    if (stack_.empty() || A >= stack_.size()) {
        return;
    }
    
    size_t actualIndex = stack_.size() - 1 - A;
    stack_[actualIndex].indexes_.insert(indexes.begin(), indexes.end());
}


LexicalEnv& LexicalEnvStack::GetLexicalEnv(size_t A) {
    CheckStackIndex(A);
    
    size_t actualIndex = stack_.size() - 1 - A;
    return stack_[actualIndex];
}

LexicalEnv& LexicalEnvStack::Top() {
    if (stack_.empty()) {
        HandleError("#LexicalEnvStack::Top: Stack is empty");
    }
    return stack_.back();
}

void LexicalEnvStack::Clear() {
    stack_.clear();
}

void LexicalEnvStack::CheckIndex(size_t A, size_t B) const {
    CheckStackIndex(A);
    
    size_t actualIndex = stack_.size() - 1 - A;
    if (!stack_[actualIndex].IsValidIndex(B)) {
        HandleError("#LexicalEnvStack::CheckIndex: LexicalEnv index B out of range");
    }
}

void LexicalEnvStack::CheckStackIndex(size_t A) const {
    if (stack_.empty()) {
        HandleError("#LexicalEnvStack::CheckStackIndex: Stack is empty");
    }
    
    if (A >= stack_.size()) {
        HandleError("#LexicalEnvStack::CheckStackIndex: Stack index A out of range");
    }
}


void DealWithGlobalLexicalWaitlist(uint32_t tier, uint32_t index, std::string closure_name, std::vector<LexicalEnvStack*> *globallexical_waitlist){
    for (auto it = globallexical_waitlist->begin(); it != globallexical_waitlist->end(); ) {
        auto* waitelement = *it;

        std::cout << "DealWithGlobalLexicalWaitlist: tier: " << tier << " , index: " << index << std::endl; 
        
        if(waitelement->IsSetSafe(tier, index)){
            waitelement->Set(tier, index, new std::string(closure_name));
        }
       
        if(waitelement->IsFull()){
            it = globallexical_waitlist->erase(it);
        }else{
            ++it;
        }
    }
}

void MergeMethod2LexicalMap(Inst* inst, std::map<panda::compiler::BasicBlock*, LexicalEnvStack*> bb2lexicalenvstack,
                  uint32_t source_methodoffset, uint32_t target_methodoffset, std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap) {
    // merge instance_initializer lexical to current 
    auto& tmpmethod2lexicalmap = *(method2lexicalmap);

    auto source_lexicalmap = tmpmethod2lexicalmap.find(source_methodoffset);
    if (source_lexicalmap == tmpmethod2lexicalmap.end()) {
        return;
    }
    auto lexicalenvstack = bb2lexicalenvstack[inst->GetBasicBlock()];
    std::cout << "lexicalenvstack size: " << lexicalenvstack->Size() << std::endl;
    for (const auto& [tier, source_indexes] : source_lexicalmap->second) {
        // std::cout << "source_indexes: ";
        // for(const auto&v : source_indexes){
        //     std::cout << " , " << v;
        // }
        // std::cout << std::endl;
        std::cout << "tier: " << tier << std::endl;
        lexicalenvstack->SetIndexes(tier, source_indexes);
    }
}

void PrintInnerMethod2LexicalMap(std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap, uint32_t methodoffset){
    auto outerIt = method2lexicalmap->find(methodoffset);
    if (outerIt == method2lexicalmap->end()) {
        std::cerr << "Method offset not found in the map." << std::endl;
        return;
    }

    const std::map<uint32_t, std::set<size_t>>& innerMap = outerIt->second;

    for (const auto& pair : innerMap) {
        uint32_t key = pair.first;
        const std::set<size_t>& vec = pair.second;

        std::cout << "Key: " << key << " Values: ";
        for (const auto& value : vec) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
    }
}


uint32_t SearchStartposForCreatePrivateproperty(Inst *inst, std::map<panda::compiler::BasicBlock*, LexicalEnvStack*> bb2lexicalenvstack,
        std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap, uint32_t methodoffset){
    
    auto lexicalenvstack = bb2lexicalenvstack[inst->GetBasicBlock()];
    auto &toplexicalenv = lexicalenvstack->Top();
    std::set<size_t> vec(toplexicalenv.indexes_);

    std::vector<size_t> sorted(vec.begin(), vec.end());
    std::sort(sorted.begin(), sorted.end());

    std::cout << "lexicalenvstack size: " << lexicalenvstack->Size() << std::endl;
    std::cout << "sorted size: " << sorted.size() << std::endl;
    
    for(const auto & i: vec){
        std::cout << "X - #: " << i << std::endl;
    }

    std::cout << ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;

    ////////////////////////////////////////////////////////////
    if(lexicalenvstack->Size() > 2){
        auto aa = lexicalenvstack->stack_[lexicalenvstack->Size() - 2];
        for(const auto & i: aa.indexes_){
            std::cout << "Y - #: " << i << std::endl;
        }
    }
    ////////////////////////////////////////////////////////////

    for (size_t i = 0; i < sorted.size(); ++i) {
        std::cout << "i: " << i << " , sorted[i]: " <<  sorted[i] << std::endl;
        if (i != sorted[i]) {
            return i;
        }
    } 

    HandleError("#SearchStartposForCreatePrivateproperty: not found !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");

    return -1;
}


void CopyLexicalenvStack(uint32_t methodoffset_, Inst* inst, std::map<uint32_t, LexicalEnvStack*>* method2lexicalenvstack, 
        std::map<panda::compiler::BasicBlock*, LexicalEnvStack*> bb2lexicalenvstack, std::vector<LexicalEnvStack*> *globallexical_waitlist){
            
    if(bb2lexicalenvstack[inst->GetBasicBlock()]->Empty()){
        return;
        //HandleError("#CopyLexicalenvStack: source bb2lexicalenvstack is empty");
    }
    auto wait_method = new LexicalEnvStack(*(bb2lexicalenvstack[inst->GetBasicBlock()]));
    (*method2lexicalenvstack)[methodoffset_] = wait_method;
    globallexical_waitlist->push_back(wait_method);
}
```

`lexicalenv.h`:

```h
#ifndef DECOMPILER_LEXICAL_ENV_STACK
#define DECOMPILER_LEXICAL_ENV_STACK

#include "base.h"

using panda::compiler::BasicBlock;
using panda::compiler::Inst;
using panda::compiler::Opcode;


class LexicalEnv {
public:
    std::vector<std::string*> expressions_;
    std::set<size_t> indexes_;

    size_t capacity_;
    mutable size_t full_size_;

public:
    explicit LexicalEnv(size_t capacity = 256);
    
    LexicalEnv(const LexicalEnv& other);
    
    std::string *& operator[](size_t index);
    const std::string* operator[](size_t index) const;
    
    bool IsFull() const;
    std::string* Get(size_t index) const;
    void Set(size_t index, std::string* expr);
    
    size_t Size() const;

    void AddIndexes(size_t index);
    void LogIndexes();
    bool IsValidIndex(size_t index) const;

private:
    void CheckIndex(size_t index) const;
};


class LexicalEnvStack {
public:
    std::vector<LexicalEnv> stack_;

public:
    LexicalEnvStack();
    LexicalEnvStack(const LexicalEnvStack& other);
    
    bool IsFull() const;
    
    ~LexicalEnvStack();
    LexicalEnv* Push(size_t capacity);
    
    void Pop();
    
    size_t Size() const;
    
    bool Empty() const;
    
    std::string* Get(size_t A, size_t B) const;

    bool IsSetSafe(size_t A, size_t B);
    void Set(size_t A, size_t B, std::string* expr);
    void SetIndexes(size_t A, std::set<size_t> indexes);
    
    LexicalEnv& GetLexicalEnv(size_t A);
    
    const LexicalEnv& Top() const;
    
    LexicalEnv& Top();
    void Clear();

private:
    void CheckIndex(size_t A, size_t B) const;
    void CheckStackIndex(size_t A) const;
};

void DealWithGlobalLexicalWaitlist(uint32_t tier, uint32_t index, std::string closure_name, std::vector<LexicalEnvStack*> *globallexical_waitlist);

void MergeMethod2LexicalMap(Inst* inst, std::map<panda::compiler::BasicBlock*, LexicalEnvStack*> bb2lexicalenvstack,
                  uint32_t source_methodoffset, uint32_t target_methodoffset, std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap);

void PrintInnerMethod2LexicalMap(std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap, uint32_t methodoffset);

uint32_t SearchStartposForCreatePrivateproperty(Inst *inst, std::map<panda::compiler::BasicBlock*, LexicalEnvStack*> bb2lexicalenvstack,
                   std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap, uint32_t methodoffset);


void CopyLexicalenvStack(uint32_t methodoffset_, Inst* inst, std::map<uint32_t, LexicalEnvStack*>* method2lexicalenvstack, 
        std::map<panda::compiler::BasicBlock*, LexicalEnvStack*> bb2lexicalenvstack, std::vector<LexicalEnvStack*> *globallexical_waitlist);

#endif // LEXICAL_ENV_STACK_H
```

`loopconstruction.cpp`:

```cpp
#include "loopconstruction.h"

namespace panda::compiler {

void LogLoopBBs(BasicBlock* header){
    ArenaVector<BasicBlock *> bbs = header->GetLoop()->GetBlocks();
    std::cout << "[+] loop list >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> " << std::endl;
    for (size_t i = 0; i < bbs.size(); i++) {
        panda::compiler::BasicBlock * bb = bbs[i];
        std::cout << bb->GetId() << " ";
        if(bb->IsLoopValid() && bb->GetLoop()->IsRoot()){
            std::cout << "bbi@ " << bb->GetId() << std::endl;
        }
    } 

    std::cout << std::endl;
    std::cout << "[-] loop list >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> " << std::endl;
}

bool AnotherBackEdgeAnalysed(BasicBlock* block, std::vector<BasicBlock *>& visited){
    Loop* loop = block->GetLoop();
    if(!loop){
        return false;
    }

    if(loop->GetBackEdges().size() < 2 ){
        return false;
    }

    for(auto backedge : loop->GetBackEdges()){
        if(block != backedge && contains(visited, backedge)){
            std::cout << "curblock: " << block->GetId() << std::endl;
            std::cout << "another backedge: " << backedge->GetId() << std::endl;
            //HandleError("hault");
            return true;
        }
    }
    
    // for(auto backedge : loop->GetBackEdges()){
    //     if(contains(visited, backedge)){
    //         return true;
    //     }
    // }
    return false;
}

bool AnotherSuccOfEdgeIsExit(BasicBlock* header, BasicBlock* backedge){
    if(backedge->GetSuccsBlocks().size() <= 1){
        return false;
    }
    if(!backedge->IsIfBlock()){
        return false;
    }

    auto loop = header->GetLoop();
    for(auto edge : backedge->GetSuccsBlocks()){
        if(edge == backedge){
            continue;
        }
        
        if(edge->GetLoop() != loop  &&  edge->GetLoop()->IsInside(loop) ){
            /* this case      
                var m = 0;
                var n = 0;
                while(m < 5){
                    m++;
                    while(n < 6){
                        n++;
                    }
                } 
            */
            return false;
        }
    }
    return true;
}

void JudgeLoopType(BasicBlock* header, std::map<Loop *, uint32_t>& loop2type, 
    std::map<Loop *, BasicBlock*> &loop2exit, 
    std::map<BasicBlock*, Loop *> &backedge2dowhileloop){

    std::cout << "[+] judge loop type >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
    if(header->GetLoop()->IsIrreducible()){
        HandleError("IrreducibleLoop");
    }

    auto &back_edges = header->GetLoop()->GetBackEdges();
    int count = 0;
    for (auto back_edge : back_edges) {
        std::cout << "[*] " << count++ << " : " << back_edge->GetId() <<  std::endl;
        if(AnotherSuccOfEdgeIsExit(header, back_edge) ){
            loop2type[header->GetLoop()] = 1;  // do-whle
            std::cout << "#JudgeLoopType : dowhile" << std::endl;
            backedge2dowhileloop[back_edge] = header->GetLoop();

            if(back_edge->GetTrueSuccessor()->GetLoop() == header->GetLoop()){
                loop2exit[header->GetLoop()] = back_edge->GetFalseSuccessor();
            }else{
                loop2exit[header->GetLoop()] = back_edge->GetTrueSuccessor();
            }
        }else{
            loop2type[header->GetLoop()] = 0;  // while
            std::cout << "#JudgeLoopType : while" << std::endl;
            if(header->GetTrueSuccessor()->GetLoop() == header->GetLoop()){
                loop2exit[header->GetLoop()] = header->GetFalseSuccessor();
            }else{
                loop2exit[header->GetLoop()] = header->GetTrueSuccessor();
            }
        }
    }

    std::cout << "[-] judge loop type >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;

    //LogLoopBBs(header);
}

bool LoopContainBlock(Loop* loop, BasicBlock *bb){
    if(std::find(loop->GetBlocks().begin(), loop->GetBlocks().end(), bb) != loop->GetBlocks().end()){
        return true;
    }

    for(auto inner_loop : loop->GetInnerLoops()){
        if(LoopContainBlock(inner_loop, bb)){
            return true;
        }
    }

    return false;
}



void LogBackEdgeId(ArenaVector<BasicBlock *> backedges){
    std::cout << "backedgeid: ";
    for (auto it = backedges.begin(); it != backedges.end(); ++it) {
        std::cout << (*it)->GetId();
        if (std::next(it) != backedges.end()) {
            std::cout << ", ";
        }
    }
    std::cout << std::endl;
}

BasicBlock* SearchPreHeader(BasicBlock* header){
    for (auto pred : header->GetPredsBlocks()) {
        if(pred->IsLoopPreHeader()){
            return pred;
        }
    }
    return nullptr;
}

}
```

`loopconstruction.h`:

```h
#ifndef DECOMPILER_LOOPCONSTRUCTION
#define DECOMPILER_LOOPCONSTRUCTION

#include "base.h"

namespace panda::compiler {

void LogLoopBBs(BasicBlock* header);

void JudgeLoopType(BasicBlock* header, std::map<Loop *, uint32_t>& loop2type, 
    std::map<Loop *, BasicBlock*> &loop2exit, 
    std::map<BasicBlock*, Loop *> &backedge2dowhileloop);

void LogBackEdgeId(ArenaVector<BasicBlock *> backedges);

BasicBlock* SearchPreHeader(BasicBlock* header);

bool LoopContainBlock(Loop* loop, BasicBlock *bb);

bool AnotherBackEdgeAnalysed(BasicBlock* block, std::vector<BasicBlock *>& visited);
}
#endif
```

`modulevar.cpp`:

```cpp
#include "modulevar.h"

std::string GetStringByOffset(std::unique_ptr<const panda_file::File>& file_, uint32_t offset) 
{
    const auto sd = file_->GetStringData(panda_file::File::EntityId(offset));
    return std::string(utf::Mutf8AsCString(sd.data));
}

bool IsValidOffset(std::unique_ptr<const panda_file::File>& file_, uint32_t offset) 
{
    return panda_file::File::EntityId(offset).IsValid() && offset < file_->GetHeader()->file_size;
}

void AddImportAst(panda::es2panda::parser::Program *parser_program, std::string imported_name, std::string local_name, std::string module_name){
    auto program_ast = parser_program->Ast();
    auto program_statements = program_ast->Statements();

    panda::es2panda::util::StringView imported_name_view = panda::es2panda::util::StringView(*new std::string(imported_name));
    auto imported_nameid = AllocNode<panda::es2panda::ir::Identifier>(parser_program, imported_name_view);

    panda::es2panda::util::StringView local_name_strview = panda::es2panda::util::StringView(*new std::string(local_name));
    auto local_nameid = AllocNode<panda::es2panda::ir::Identifier>(parser_program, local_name_strview);  

    auto importspefic = AllocNode<panda::es2panda::ir::ImportSpecifier>(parser_program, imported_nameid, local_nameid, false, false);

    ArenaVector<panda::es2panda::ir::AstNode *> specifiers(parser_program->Allocator()->Adapter());
    specifiers.push_back(importspefic);


    std::string* source_str_ptr = new std::string(module_name);
    es2panda::util::StringView literal_strview(*source_str_ptr);
    auto source = AllocNode<panda::es2panda::ir::StringLiteral>(parser_program, literal_strview);
    auto *importDeclaration = AllocNode<panda::es2panda::ir::ImportDeclaration>(parser_program, source, std::move(specifiers), nullptr, false, false);
    program_ast->AddStatementAtPos(program_statements.size(), importDeclaration);
}

void AddExportAstAll(panda::es2panda::parser::Program *parser_program,  std::string module_name){
    auto program_ast = parser_program->Ast();
    auto program_statements = program_ast->Statements();

    panda::es2panda::util::StringView local_name_strview = panda::es2panda::util::StringView(*new std::string("*"));
    auto local_nameid = AllocNode<panda::es2panda::ir::Identifier>(parser_program, local_name_strview);

    
    std::string* source_str_ptr = new std::string(module_name);
    es2panda::util::StringView literal_strview(*source_str_ptr);
    auto source = AllocNode<panda::es2panda::ir::StringLiteral>(parser_program, literal_strview);

    auto *export_all = AllocNode<panda::es2panda::ir::ExportAllDeclaration>(parser_program, source, local_nameid, nullptr);
    program_ast->AddStatementAtPos(program_statements.size(), export_all);
}

void AddExportAstNamed(panda::es2panda::parser::Program *parser_program, std::string import_name, std::string export_name, std::string module_name){
    auto program_ast = parser_program->Ast();
    auto program_statements = program_ast->Statements();

    panda::es2panda::util::StringView import_name_view = panda::es2panda::util::StringView(*new std::string(import_name));
    auto import_nameid = AllocNode<panda::es2panda::ir::Identifier>(parser_program, import_name_view);

    panda::es2panda::util::StringView export_name_strview = panda::es2panda::util::StringView(*new std::string(export_name));
    auto export_nameid = AllocNode<panda::es2panda::ir::Identifier>(parser_program, export_name_strview);

    auto exportspefic = AllocNode<panda::es2panda::ir::ExportSpecifier>(parser_program, import_nameid, export_nameid, false);

    ArenaVector<panda::es2panda::ir::ExportSpecifier  *> specifiers(parser_program->Allocator()->Adapter());
    specifiers.push_back(exportspefic);


    std::string* source_str_ptr = new std::string(module_name);
    es2panda::util::StringView literal_strview(*source_str_ptr);
    auto source = AllocNode<panda::es2panda::ir::StringLiteral>(parser_program, literal_strview);
    auto *exportDeclaration = AllocNode<panda::es2panda::ir::ExportNamedDeclaration>(parser_program, source, std::move(specifiers), nullptr, false);
    program_ast->AddStatementAtPos(program_statements.size(), exportDeclaration);
}

void AddExportAst(panda::es2panda::parser::Program *parser_program,  std::string local_name, std::string export_name){
    auto program_ast = parser_program->Ast();
    auto program_statements = program_ast->Statements();

    panda::es2panda::util::StringView local_name_strview = panda::es2panda::util::StringView(*new std::string(local_name));
    auto local_nameid = AllocNode<panda::es2panda::ir::Identifier>(parser_program, local_name_strview);

    panda::es2panda::util::StringView export_name_strview = panda::es2panda::util::StringView(*new std::string(export_name));
    auto export_nameid = AllocNode<panda::es2panda::ir::Identifier>(parser_program, export_name_strview);

    auto *exportast = AllocNode<panda::es2panda::ir::ExportSpecifier >(parser_program, local_nameid, export_nameid, false);
    program_ast->AddStatementAtPos(program_statements.size(), exportast);

}

void GetModuleLiteralArray(std::unique_ptr<const panda_file::File>& file_, panda_file::File::EntityId &module_id, panda::disasm::Disassembler& disasm,
            panda::es2panda::parser::Program *parser_program, std::map<size_t, std::vector<std::string>> &index2namespaces, 
            std::vector<std::string>& localnamespaces)
{
    // AddImportAst(parser_program, "a", "b", "./module_foo1"); // mock refs

    std::map<size_t, std::string> index2importmodule;
    std::map<std::string, size_t> importmodule2index;

    std::map<size_t, std::map<std::string, std::string>> index2importmaps;
    std::vector<std::map<std::string, std::string>> exportmaps_arrays;

    panda_file::ModuleDataAccessor mda(*file_, module_id);
    const std::vector<uint32_t> &request_modules_offset = mda.getRequestModules();
    std::vector<std::string> module_literal_array;

    for (size_t index = 0; index < request_modules_offset.size(); ++index) {
        index2importmodule[index] = GetStringByOffset(file_, request_modules_offset[index]);
        importmodule2index[GetStringByOffset(file_, request_modules_offset[index])] = index;

        index2namespaces[index] = std::vector<std::string>();
    }

    mda.EnumerateModuleRecord([&](panda_file::ModuleTag tag, uint32_t export_name_offset, uint32_t request_module_idx,
                                  uint32_t import_name_offset, uint32_t local_name_offset) {

        std::map<std::string, std::string> curmaps;

        std::stringstream ss;
        if (tag == panda_file::ModuleTag::REGULAR_IMPORT ||
            tag == panda_file::ModuleTag::NAMESPACE_IMPORT || tag == panda_file::ModuleTag::LOCAL_EXPORT) {
            if (!disasm.IsValidOffset(local_name_offset)) {
                LOG(ERROR, DISASSEMBLER) << "Get invalid local name offset!" << std::endl;
                return;
            }
            curmaps["local_name"] = GetStringByOffset(file_, local_name_offset);

            ss << ", local_name: " << GetStringByOffset(file_, local_name_offset);
        }
        if (tag == panda_file::ModuleTag::LOCAL_EXPORT || tag == panda_file::ModuleTag::INDIRECT_EXPORT) {
            if (!IsValidOffset(file_, export_name_offset)) {
                LOG(ERROR, DISASSEMBLER) << "Get invalid export name offset!" << std::endl;
                return;
            }
            curmaps["export_name"] = GetStringByOffset(file_, export_name_offset);

            ss << ", export_name: " << GetStringByOffset(file_, export_name_offset);
        }
        if (tag == panda_file::ModuleTag::REGULAR_IMPORT || tag == panda_file::ModuleTag::INDIRECT_EXPORT) {
            if (!IsValidOffset(file_, import_name_offset)) {
                LOG(ERROR, DISASSEMBLER) << "Get invalid import name offset!" << std::endl;
                return;
            }
            curmaps["import_name"] = GetStringByOffset(file_, import_name_offset);

            ss << ", import_name: " << GetStringByOffset(file_, import_name_offset);
        }
        if (tag != panda_file::ModuleTag::LOCAL_EXPORT) {
            if (request_module_idx >= request_modules_offset.size() ||
                !IsValidOffset(file_, request_modules_offset[request_module_idx])) {
                LOG(ERROR, DISASSEMBLER) << "Get invalid request module offset!" << std::endl;
                return;
            }
            curmaps["module_request"] = GetStringByOffset(file_, request_modules_offset[request_module_idx]);

            ss << ", module_request: " << GetStringByOffset(file_, request_modules_offset[request_module_idx]);
        }


        if(tag == panda_file::ModuleTag::REGULAR_IMPORT  || tag == panda_file::ModuleTag::NAMESPACE_IMPORT){
            ss << ", IMPORT ";
            auto module_request_name = curmaps["module_request"];
            auto index = importmodule2index[module_request_name];

            index2importmaps[index] = curmaps;
            if(curmaps.count("import_name") > 0){
                AddImportAst(parser_program, curmaps["import_name"], curmaps["local_name"], curmaps["module_request"]);
            }else{
                AddImportAst(parser_program, "*", curmaps["local_name"], curmaps["module_request"]);
            }
            index2namespaces[importmodule2index[curmaps["module_request"]]].push_back(curmaps["local_name"]);

            localnamespaces.push_back(curmaps["local_name"]);
        }else{
            ss << ", EXPORT ";
            exportmaps_arrays.push_back(curmaps);
            // std::cout << curmaps.count("export_name") << " , " << curmaps.count("import_name") << " , " << curmaps.count("local_name") << " , " << curmaps.count("module_request") << std::endl;
            if(curmaps.count("export_name") == 0 && curmaps.count("local_name") == 0){
                // ExportAllDeclaration
                AddExportAstAll(parser_program, curmaps["module_request"]);

            }else if(curmaps.count("module_request") == 0){
                // ExportSpecifier
                AddExportAst(parser_program, curmaps["local_name"], curmaps["export_name"]);
                localnamespaces.push_back(curmaps["local_name"]);
            }else{
                // ExportNamedDeclaration
                AddExportAstNamed(parser_program, curmaps["import_name"], curmaps["export_name"], curmaps["module_request"]);
                localnamespaces.push_back(curmaps["import_name"]);
            }
        }

        std::cout << ss.str() << std::endl;;
    });

}

void ParseModuleVars(std::unique_ptr<const panda_file::File>& file_, pandasm::Program *prog, panda::disasm::Disassembler& disasm, 
            panda::es2panda::parser::Program *parser_program, std::map<size_t, std::vector<std::string>>& index2namespaces, 
            std::vector<std::string>& localnamespaces){
    
    
    
    if (panda_file::ContainsLiteralArrayInHeader(file_->GetHeader()->version)) {
        const auto lit_arrays_id = file_->GetLiteralArraysId();

        panda_file::LiteralDataAccessor lda(*file_, lit_arrays_id);
        size_t num_litarrays = lda.GetLiteralNum();

        for (size_t index = 0; index < num_litarrays; index++) {
            
            auto id = lda.GetLiteralArrayId(index);
            if (disasm.module_request_phase_literals_.count(id.GetOffset())) {
                continue;
            }

            if (disasm.IsModuleLiteralOffset(id)) {
                GetModuleLiteralArray(file_, id, disasm, parser_program, index2namespaces, localnamespaces);
            }
        }
    }else{
        // release mode
        for (const auto &r : prog->record_table) {
            auto& record = r.second;
            for (const auto &f : record.field_list) {
                if (!f.metadata->GetValue().has_value()) {
                    continue;
                }
                if (f.type.GetId() == panda_file::Type::TypeId::U32) {
                    panda_file::File::EntityId module_entity_id(f.metadata->GetValue().value().GetValue<uint32_t>());
                        if (disasm.IsModuleLiteralOffset(module_entity_id)) {
                            GetModuleLiteralArray(file_, module_entity_id, disasm, parser_program, index2namespaces, localnamespaces);
                    }
                }
            }

        }

        // debug mode       
        // panda::libpandafile::CollectUtil collect_util;
        // std::unordered_set<uint32_t> literal_array_ids;
        // collect_util.CollectLiteralArray(*file_, literal_array_ids);
        // for (uint32_t literal_array_id : literal_array_ids) {
        //     panda_file::File::EntityId id {literal_array_id};
        //     if (disasm.IsModuleLiteralOffset(id)) {
        //         GetModuleLiteralArray(file_, id, disasm, parser_program, index2namespaces, localnamespaces);
        //     } 
        // }
    }

}
```

`modulevar.h`:

```h
#ifndef DECOMPILER_MODULEVAR
#define DECOMPILER_MODULEVAR

#include "base.h"

using namespace panda;

std::string GetStringByOffset(std::unique_ptr<const panda_file::File>& file_, uint32_t offset);

bool IsValidOffset(std::unique_ptr<const panda_file::File>& file_, uint32_t offset);

void AddImportAst(panda::es2panda::parser::Program *parser_program, std::string imported_name, std::string local_name, std::string module_name);

void AddExportAstAll(panda::es2panda::parser::Program *parser_program,  std::string module_name);

void AddExportAstNamed(panda::es2panda::parser::Program *parser_program, std::string import_name, std::string export_name, std::string module_name);

void AddExportAst(panda::es2panda::parser::Program *parser_program,  std::string local_name, std::string export_name);

void GetModuleLiteralArray(std::unique_ptr<const panda_file::File>& file_, panda_file::File::EntityId &module_id, panda::disasm::Disassembler& disasm,
            panda::es2panda::parser::Program *parser_program, std::map<size_t, std::vector<std::string>>& index2namespaces, std::vector<std::string>& localnamespaces);

void ParseModuleVars(std::unique_ptr<const panda_file::File>& file_, pandasm::Program *prog, panda::disasm::Disassembler& disasm, 
            panda::es2panda::parser::Program *parser_program, std::map<size_t, std::vector<std::string>>& index2namespaces, std::vector<std::string>& localnamespaces);

#endif
```

`patches/arkcompiler_ets_frontend_09e1955c6.patch`:

```patch
diff --git a/es2panda/ir/statements/blockStatement.h b/es2panda/ir/statements/blockStatement.h
index 8b4a9c21e..151cc088d 100644
--- a/es2panda/ir/statements/blockStatement.h
+++ b/es2panda/ir/statements/blockStatement.h
@@ -58,7 +58,6 @@ public:
     checker::Type *Check(checker::Checker *checker) const override;
     void UpdateSelf(const NodeUpdater &cb, binder::Binder *binder) override;
 
-protected:
     binder::Scope *scope_;
     ArenaVector<Statement *> statements_;
 };
diff --git a/es2panda/ir/statements/doWhileStatement.h b/es2panda/ir/statements/doWhileStatement.h
index 73f64a78d..6b07e4fae 100644
--- a/es2panda/ir/statements/doWhileStatement.h
+++ b/es2panda/ir/statements/doWhileStatement.h
@@ -68,7 +68,6 @@ public:
     checker::Type *Check(checker::Checker *checker) const override;
     void UpdateSelf(const NodeUpdater &cb, binder::Binder *binder) override;
 
-protected:
     Statement *body_;
     Expression *test_;
 };
diff --git a/es2panda/ir/statements/whileStatement.h b/es2panda/ir/statements/whileStatement.h
index e77f97a63..53d6bcbf0 100644
--- a/es2panda/ir/statements/whileStatement.h
+++ b/es2panda/ir/statements/whileStatement.h
@@ -68,7 +68,6 @@ public:
     checker::Type *Check(checker::Checker *checker) const override;
     void UpdateSelf(const NodeUpdater &cb, binder::Binder *binder) override;
 
-protected:
     Expression *test_;
     Statement *body_;
 };

```

`patches/arkcompiler_runtime_core_a94c360.patch`:

```patch
diff --git a/BUILD.gn b/BUILD.gn
index dfffd707e..8099f59ea 100755
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -120,6 +120,7 @@ if (!ark_standalone_build) {
 # Common config for ark source
 config("ark_config") {
   visibility = [
+    "*",
     "./*",
     "//arkcompiler/ets_frontend/*",
   ]
@@ -364,6 +365,14 @@ group("ark_host_mac_defectscanaux_unittest") {
   }
 }
 
+group("xabc") {
+  testonly = true
+  deps = [
+    "//arkdecompiler:xabc",
+  ]
+}
+
+
 group("runtime_core_host_unittest") {
   testonly = true
   deps = [
diff --git a/compiler/optimizer/ir/inst.h b/compiler/optimizer/ir/inst.h
index 197195776..62627b14e 100644
--- a/compiler/optimizer/ir/inst.h
+++ b/compiler/optimizer/ir/inst.h
@@ -1929,6 +1929,8 @@ public:
     }
 };
 
+
+
 /**
  * CastAnyTypeValueInst instruction
  */
diff --git a/disassembler/disassembler.h b/disassembler/disassembler.h
index e96089bdb..3cd125540 100644
--- a/disassembler/disassembler.h
+++ b/disassembler/disassembler.h
@@ -87,7 +87,7 @@ public:
     std::vector<size_t> GetColumnNumber();
     std::vector<size_t> GetLineNumber();
 
-private:
+public:
     void GetLiteralArrays();
     void FillLiteralArrayTable(panda_file::File::EntityId &id, size_t index);
     void FillLiteralData(pandasm::LiteralArray *lit_array, const panda_file::LiteralDataAccessor::LiteralValue &value,
@@ -233,8 +233,9 @@ private:
     bool quiet_;
     bool skip_strings_;
     std::unordered_set<uint32_t> module_literals_;
+    public:
     std::unordered_set<uint32_t> module_request_phase_literals_;
-#include "disasm_plugins.inc"
+//#include "disasm_plugins.inc"
 };
 }  // namespace panda::disasm
 

```

`patches/third_party_protobuf_0e4c27.patch`:

```patch
diff --git a/BUILD.gn b/BUILD.gn
index 212ac82..6864bc1 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -11,7 +11,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import("//build/ohos.gni")
+import("//arkcompiler/runtime_core/gn/build/ohos.gni")
+
 
 THIRDPARTY_PROTOBUF_SUBSYS_NAME = "thirdparty"
 THIRDPARTY_PROTOBUF_PART_NAME = "protobuf"
@@ -50,9 +51,9 @@ ohos_shared_library("protobuf_lite") {
     "src/google/protobuf/stubs/time.cc",
     "src/google/protobuf/wire_format_lite.cc",
   ]
-  if (!is_asan && !is_debug) {
-    version_script = "libprotobuf_lite.map"
-  }
+  #if (!is_asan && !is_debug) {
+  #  version_script = "libprotobuf_lite.map"
+  #}
   include_dirs = [
     "src/google/protobuf/**/*.h",
     "src/google/protobuf/**/*.inc",
@@ -74,10 +75,10 @@ ohos_shared_library("protobuf_lite") {
 
   public_configs = [ ":protobuf_config" ]
   install_enable = true
-  innerapi_tags = [
-    "platformsdk_indirect",
-    "chipsetsdk",
-  ]
+  #innerapi_tags = [
+  #  "platformsdk_indirect",
+  #  "chipsetsdk",
+  #]
   subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
   part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
 }
@@ -121,7 +122,7 @@ ohos_static_library("protobuf_lite_static") {
     if (default_toolchain == current_toolchain) {
       # target build, not host build
       defines = [ "HAVE_HILOG" ]
-      external_deps = [ "hilog:libhilog" ]
+      #external_deps = [ "hilog:libhilog" ]
     }
   } else {
     defines = [ "_FILE_OFFSET_BITS_SET_LSEEK" ]
@@ -142,7 +143,7 @@ ohos_static_library("protobuf_lite_static") {
   }
   public_configs = [ ":protobuf_config" ]
   subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
-  part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
+  #part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
 }
 
 ohos_shared_library("protobuf") {
@@ -216,9 +217,9 @@ ohos_shared_library("protobuf") {
   ]
 
   deps = [ ":protobuf_lite" ]
-  if (!is_asan && !is_debug) {
-    version_script = "libprotobuf.map"
-  }
+  #if (!is_asan && !is_debug) {
+  #  version_script = "libprotobuf.map"
+  #}
 
   public_configs = [ ":protobuf_config" ]
   install_enable = true
@@ -300,7 +301,7 @@ ohos_static_library("protobuf_static") {
 
   public_configs = [ ":protobuf_config" ]
   subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
-  part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
+  #part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
 }
 
 if (current_toolchain == host_toolchain) {
@@ -525,7 +526,7 @@ if (current_toolchain == host_toolchain) {
 
     public_configs = [ ":protobuf_config" ]
     subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
-    part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
+    #part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
   }
 }
 
@@ -549,6 +550,6 @@ if (current_toolchain == host_toolchain) {
       "-Wno-deprecated-declarations",
     ]
     subsystem_name = "${THIRDPARTY_PROTOBUF_SUBSYS_NAME}"
-    part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
+    #part_name = "${THIRDPARTY_PROTOBUF_PART_NAME}"
   }
 }

```

`run.sh`:

```sh
#!/bin/bash
rm demo.abc

logdir=logs 

if [ "$1" = "module" ]; then
    ./genlogs.sh $logdir $1
elif [ "$1" = "hot" ]; then
    ./hot.sh
else
    ./genlogs.sh $logdir
fi

ninja -w dupbuild=warn xabc -C out
LD_LIBRARY_PATH=./out/arkcompiler/runtime_core:./out/thirdparty/zlib  ./out/arkcompiler/common/xabc
python3 scripts/removebc.py
```

`scripts/draw_cfg.py`:

```py
#!/usr/bin/env python3
# -- coding: utf-8 --

from typing import List
import graphviz as gv
import sys
import os
import argparse


class BasicBlock:
    def __init__(self, ident: int) -> None:
        self.id = ident
        self.insts = []
        self.preds = []
        self.succs = []
        self.props = []

    def text(self, no_insts=False) -> str:
        s = 'BB ' + str(self.id) + '\n'
        s += 'props: '
        for i, prop in enumerate(self.props):
            if i > 0:
                s += ', '
            s += prop
        s += '\n'

        if not no_insts:
            for inst in self.insts:
                s += inst + '\n'
        return s


class Function:
    def __init__(self, method: str, blocks: List[BasicBlock]) -> None:
        self.method = method
        self.blocks = blocks


class GraphDumpParser:
    def __init__(self) -> None:
        self.method = None
        self.block = None
        self.blocks = []
        self.functions = []

    def finish_block(self):
        if self.block:
            self.blocks.append(self.block)
            self.block = None

    def finish_function(self):
        self.finish_block()
        if self.method:
            self.functions.append(Function(self.method, self.blocks))
            self.blocks = []

    def begin_block(self, line: str):
        self.finish_block()

        preds_start = line.find('preds:')
        block_id = int(line[len('BB'):preds_start].strip())
        self.block = BasicBlock(block_id)
        if preds_start != -1:
            self.parse_block_preds(line, preds_start)

    def begin_function(self, line: str):
        self.finish_function()
        self.method = line[len('method:'):].strip()

    def parse_block_preds(self, line: str, preds_start: int):
        preds = line[preds_start+len('preds:'):].strip().strip('[]')
        for pred in preds.split(','):
            pred = pred.strip()
            self.block.preds.append(int(pred[len('bb'):].strip()))

    def parse_block_props(self, line: str):
        for s in line[len('prop:'):].strip().split(','):
            s = s.strip()
            if not s.startswith('bc'):
                self.block.props.append(s)

    def parse_block_succs(self, line: str):
        succs = line[len('succs:'):].strip().strip('[]')
        for succ in succs.split(','):
            succ = succ.strip()
            self.block.succs.append(int(succ[len('bb'):].strip()))
        self.finish_block()

    def parse(self, lines: List[str]) -> List[Function]:
        for line in lines:
            if line.startswith('Method:'):
                self.begin_function(line)
            elif line.startswith('BB'):
                self.begin_block(line)
            elif self.block:
                if line.startswith('prop:'):
                    self.parse_block_props(line)
                elif line.startswith('succs:'):
                    self.parse_block_succs(line)
                else:
                    self.block.insts.append(line)
        self.finish_function()
        return self.functions


def draw_function(function: Function, out_dir=None, no_insts=False):
    dot = gv.Digraph(format='png')
    for block in function.blocks:
        dot.node(str(block.id), block.text(no_insts), shape='box')
    for block in function.blocks:
        for succ in block.succs:
            dot.edge(str(block.id), str(succ))
    basename = 'cfg_' + function.method
    dotfile_path = os.path.join(out_dir, basename)
    dot.render(basename, out_dir, format="png")
    os.rename(dotfile_path, dotfile_path + '.dot')


def main():
    parser = argparse.ArgumentParser(description="A tool for drawing CFGs by reading ir dump from stdin")
    parser.add_argument("-i", "--input", type=str, default="input.ir", help="the file containing the IR dump (default: 'input.ir')")
    parser.add_argument("--no-insts", action="store_true", help="drawing without IR instructions")
    parser.add_argument("-o", "--output", type=str, default="./out", help="output directory, default to './out'")
    args = parser.parse_args()

    with open(args.input, 'r') as file:
        lines = file.readlines()

    functions = GraphDumpParser().parse(lines)
    for function in functions:
        draw_function(function, args.output, no_insts=args.no_insts)


if __name__ == "__main__":
    main()

```

`scripts/intrinsic_list.txt`:

```txt
LDUNDEFINED
LDNULL
LDTRUE
LDFALSE
CREATEEMPTYOBJECT
CREATEEMPTYARRAY_IMM8
CREATEARRAYWITHBUFFER_IMM8_ID16
CREATEOBJECTWITHBUFFER_IMM8_ID16
NEWOBJRANGE_IMM8_IMM8_V8
NEWLEXENV_IMM8
ADD2_IMM8_V8
SUB2_IMM8_V8
MUL2_IMM8_V8
DIV2_IMM8_V8
MOD2_IMM8_V8
EQ_IMM8_V8
NOTEQ_IMM8_V8
LESS_IMM8_V8
LESSEQ_IMM8_V8
GREATER_IMM8_V8
GREATEREQ_IMM8_V8
SHL2_IMM8_V8
SHR2_IMM8_V8
ASHR2_IMM8_V8
AND2_IMM8_V8
OR2_IMM8_V8
XOR2_IMM8_V8
EXP_IMM8_V8
TYPEOF_IMM8
TONUMBER_IMM8
TONUMERIC_IMM8
NEG_IMM8
NOT_IMM8
INC_IMM8
DEC_IMM8
ISTRUE
ISFALSE
ISIN_IMM8_V8
INSTANCEOF_IMM8_V8
STRICTNOTEQ_IMM8_V8
STRICTEQ_IMM8_V8
CALLARG0_IMM8
CALLARG1_IMM8_V8
CALLARGS2_IMM8_V8_V8
CALLARGS3_IMM8_V8_V8_V8
CALLTHIS0_IMM8_V8
CALLTHIS1_IMM8_V8_V8
CALLTHIS2_IMM8_V8_V8_V8
CALLTHIS3_IMM8_V8_V8_V8_V8
CALLTHISRANGE_IMM8_IMM8_V8
SUPERCALLTHISRANGE_IMM8_IMM8_V8
DEFINEFUNC_IMM8_ID16_IMM8
DEFINEMETHOD_IMM8_ID16_IMM8
DEFINECLASSWITHBUFFER_IMM8_ID16_ID16_IMM16_V8
GETNEXTPROPNAME_V8
LDOBJBYVALUE_IMM8_V8
STOBJBYVALUE_IMM8_V8_V8
LDSUPERBYVALUE_IMM8_V8
LDOBJBYINDEX_IMM8_IMM16
STOBJBYINDEX_IMM8_V8_IMM16
LDLEXVAR_IMM4_IMM4
STLEXVAR_IMM4_IMM4
LDA_STR_ID16
TRYLDGLOBALBYNAME_IMM8_ID16
TRYSTGLOBALBYNAME_IMM8_ID16
LDGLOBALVAR_IMM16_ID16
LDOBJBYNAME_IMM8_ID16
STOBJBYNAME_IMM8_ID16_V8
MOV_V4_V4
MOV_V8_V8
LDSUPERBYNAME_IMM8_ID16
STCONSTTOGLOBALRECORD_IMM16_ID16
STTOGLOBALRECORD_IMM16_ID16
LDTHISBYNAME_IMM8_ID16
STTHISBYNAME_IMM8_ID16
LDTHISBYVALUE_IMM8
STTHISBYVALUE_IMM8_V8
JMP_IMM8
JMP_IMM16
JEQZ_IMM8
JEQZ_IMM16
JNEZ_IMM8
JSTRICTEQZ_IMM8
JNSTRICTEQZ_IMM8
JEQNULL_IMM8
JNENULL_IMM8
JSTRICTEQNULL_IMM8
JNSTRICTEQNULL_IMM8
JEQUNDEFINED_IMM8
JNEUNDEFINED_IMM8
JSTRICTEQUNDEFINED_IMM8
JNSTRICTEQUNDEFINED_IMM8
JEQ_V8_IMM8
JNE_V8_IMM8
JSTRICTEQ_V8_IMM8
JNSTRICTEQ_V8_IMM8
LDA_V8
STA_V8
LDAI_IMM32
FLDAI_IMM64
RETURN
RETURNUNDEFINED
GETPROPITERATOR
GETITERATOR_IMM8
CLOSEITERATOR_IMM8_V8
POPLEXENV
LDNAN
LDINFINITY
GETUNMAPPEDARGS
LDGLOBAL
LDNEWTARGET
LDTHIS
LDHOLE
CREATEREGEXPWITHLITERAL_IMM8_ID16_IMM8
CREATEREGEXPWITHLITERAL_IMM16_ID16_IMM8
CALLRANGE_IMM8_IMM8_V8
DEFINEFUNC_IMM16_ID16_IMM8
DEFINECLASSWITHBUFFER_IMM16_ID16_ID16_IMM16_V8
GETTEMPLATEOBJECT_IMM8
SETOBJECTWITHPROTO_IMM8_V8
STOWNBYVALUE_IMM8_V8_V8
STOWNBYINDEX_IMM8_V8_IMM16
STOWNBYNAME_IMM8_ID16_V8
GETMODULENAMESPACE_IMM8
STMODULEVAR_IMM8
LDLOCALMODULEVAR_IMM8
LDEXTERNALMODULEVAR_IMM8
STGLOBALVAR_IMM16_ID16
CREATEEMPTYARRAY_IMM16
CREATEARRAYWITHBUFFER_IMM16_ID16
CREATEOBJECTWITHBUFFER_IMM16_ID16
NEWOBJRANGE_IMM16_IMM8_V8
TYPEOF_IMM16
LDOBJBYVALUE_IMM16_V8
STOBJBYVALUE_IMM16_V8_V8
LDSUPERBYVALUE_IMM16_V8
LDOBJBYINDEX_IMM16_IMM16
STOBJBYINDEX_IMM16_V8_IMM16
LDLEXVAR_IMM8_IMM8
STLEXVAR_IMM8_IMM8
TRYLDGLOBALBYNAME_IMM16_ID16
TRYSTGLOBALBYNAME_IMM16_ID16
STOWNBYNAMEWITHNAMESET_IMM8_ID16_V8
MOV_V16_V16
LDOBJBYNAME_IMM16_ID16
STOBJBYNAME_IMM16_ID16_V8
LDSUPERBYNAME_IMM16_ID16
LDTHISBYNAME_IMM16_ID16
STTHISBYNAME_IMM16_ID16
LDTHISBYVALUE_IMM16
STTHISBYVALUE_IMM16_V8
ASYNCGENERATORREJECT_V8
JMP_IMM32
STOWNBYVALUEWITHNAMESET_IMM8_V8_V8
JEQZ_IMM32
JNEZ_IMM16
JNEZ_IMM32
JSTRICTEQZ_IMM16
JNSTRICTEQZ_IMM16
JEQNULL_IMM16
JNENULL_IMM16
JSTRICTEQNULL_IMM16
JNSTRICTEQNULL_IMM16
JEQUNDEFINED_IMM16
JNEUNDEFINED_IMM16
JSTRICTEQUNDEFINED_IMM16
JNSTRICTEQUNDEFINED_IMM16
JEQ_V8_IMM16
JNE_V8_IMM16
JSTRICTEQ_V8_IMM16
JNSTRICTEQ_V8_IMM16
GETITERATOR_IMM16
CLOSEITERATOR_IMM16_V8
LDSYMBOL
ASYNCFUNCTIONENTER
LDFUNCTION
DEBUGGER
CREATEGENERATOROBJ_V8
CREATEITERRESULTOBJ_V8_V8
CREATEOBJECTWITHEXCLUDEDKEYS_IMM8_V8_V8
NEWOBJAPPLY_IMM8_V8
NEWOBJAPPLY_IMM16_V8
NEWLEXENVWITHNAME_IMM8_ID16
CREATEASYNCGENERATOROBJ_V8
ASYNCGENERATORRESOLVE_V8_V8_V8
SUPERCALLSPREAD_IMM8_V8
APPLY_IMM8_V8_V8
SUPERCALLARROWRANGE_IMM8_IMM8_V8
DEFINEGETTERSETTERBYVALUE_V8_V8_V8_V8
DYNAMICIMPORT
DEFINEMETHOD_IMM16_ID16_IMM8
RESUMEGENERATOR
GETRESUMEMODE
GETTEMPLATEOBJECT_IMM16
DELOBJPROP_V8
SUSPENDGENERATOR_V8
ASYNCFUNCTIONAWAITUNCAUGHT_V8
COPYDATAPROPERTIES_V8
STARRAYSPREAD_V8_V8
SETOBJECTWITHPROTO_IMM16_V8
STOWNBYVALUE_IMM16_V8_V8
STSUPERBYVALUE_IMM8_V8_V8
STSUPERBYVALUE_IMM16_V8_V8
STOWNBYINDEX_IMM16_V8_IMM16
STOWNBYNAME_IMM16_ID16_V8
ASYNCFUNCTIONRESOLVE_V8
ASYNCFUNCTIONREJECT_V8
COPYRESTARGS_IMM8
STSUPERBYNAME_IMM8_ID16_V8
STSUPERBYNAME_IMM16_ID16_V8
STOWNBYVALUEWITHNAMESET_IMM16_V8_V8
LDBIGINT_ID16
STOWNBYNAMEWITHNAMESET_IMM16_ID16_V8
NOP
SETGENERATORSTATE_IMM8
GETASYNCITERATOR_IMM8
LDPRIVATEPROPERTY_IMM8_IMM16_IMM16
STPRIVATEPROPERTY_IMM8_IMM16_IMM16_V8
TESTIN_IMM8_IMM16_IMM16
DEFINEFIELDBYNAME_IMM8_ID16_V8
DEFINEPROPERTYBYNAME_IMM8_ID16_V8
CALLRUNTIME_NOTIFYCONCURRENTRESULT_PREF_NONE
WIDE_CREATEOBJECTWITHEXCLUDEDKEYS_PREF_IMM16_V8_V8
THROW_PREF_NONE
CALLRUNTIME_DEFINEFIELDBYVALUE_PREF_IMM8_V8_V8
WIDE_NEWOBJRANGE_PREF_IMM16_V8
THROW_NOTEXISTS_PREF_NONE
CALLRUNTIME_DEFINEFIELDBYINDEX_PREF_IMM8_IMM32_V8
WIDE_NEWLEXENV_PREF_IMM16
THROW_PATTERNNONCOERCIBLE_PREF_NONE
CALLRUNTIME_TOPROPERTYKEY_PREF_NONE
WIDE_NEWLEXENVWITHNAME_PREF_IMM16_ID16
THROW_DELETESUPERPROPERTY_PREF_NONE
CALLRUNTIME_CREATEPRIVATEPROPERTY_PREF_IMM16_ID16
WIDE_CALLRANGE_PREF_IMM16_V8
THROW_CONSTASSIGNMENT_PREF_V8
CALLRUNTIME_DEFINEPRIVATEPROPERTY_PREF_IMM8_IMM16_IMM16_V8
WIDE_CALLTHISRANGE_PREF_IMM16_V8
THROW_IFNOTOBJECT_PREF_V8
CALLRUNTIME_CALLINIT_PREF_IMM8_V8
WIDE_SUPERCALLTHISRANGE_PREF_IMM16_V8
THROW_UNDEFINEDIFHOLE_PREF_V8_V8
CALLRUNTIME_DEFINESENDABLECLASS_PREF_IMM16_ID16_ID16_IMM16_V8
WIDE_SUPERCALLARROWRANGE_PREF_IMM16_V8
THROW_IFSUPERNOTCORRECTCALL_PREF_IMM8
CALLRUNTIME_LDSENDABLECLASS_PREF_IMM16
WIDE_LDOBJBYINDEX_PREF_IMM32
THROW_IFSUPERNOTCORRECTCALL_PREF_IMM16
CALLRUNTIME_LDSENDABLEEXTERNALMODULEVAR_PREF_IMM8
WIDE_STOBJBYINDEX_PREF_V8_IMM32
THROW_UNDEFINEDIFHOLEWITHNAME_PREF_ID16
CALLRUNTIME_WIDELDSENDABLEEXTERNALMODULEVAR_PREF_IMM16
WIDE_STOWNBYINDEX_PREF_V8_IMM32
CALLRUNTIME_NEWSENDABLEENV_PREF_IMM8
WIDE_COPYRESTARGS_PREF_IMM16
CALLRUNTIME_WIDENEWSENDABLEENV_PREF_IMM16
WIDE_LDLEXVAR_PREF_IMM16_IMM16
CALLRUNTIME_STSENDABLEVAR_PREF_IMM4_IMM4
WIDE_STLEXVAR_PREF_IMM16_IMM16
CALLRUNTIME_STSENDABLEVAR_PREF_IMM8_IMM8
WIDE_GETMODULENAMESPACE_PREF_IMM16
CALLRUNTIME_WIDESTSENDABLEVAR_PREF_IMM16_IMM16
WIDE_STMODULEVAR_PREF_IMM16
CALLRUNTIME_LDSENDABLEVAR_PREF_IMM4_IMM4
WIDE_LDLOCALMODULEVAR_PREF_IMM16
CALLRUNTIME_LDSENDABLEVAR_PREF_IMM8_IMM8
WIDE_LDEXTERNALMODULEVAR_PREF_IMM16
CALLRUNTIME_WIDELDSENDABLEVAR_PREF_IMM16_IMM16
WIDE_LDPATCHVAR_PREF_IMM16
CALLRUNTIME_ISTRUE_PREF_IMM8
WIDE_STPATCHVAR_PREF_IMM16
CALLRUNTIME_ISFALSE_PREF_IMM8
CALLRUNTIME_LDLAZYMODULEVAR_PREF_IMM8
CALLRUNTIME_WIDELDLAZYMODULEVAR_PREF_IMM16
CALLRUNTIME_LDLAZYSENDABLEMODULEVAR_PREF_IMM8
CALLRUNTIME_WIDELDLAZYSENDABLEMODULEVAR_PREF_IMM16
CALLRUNTIME_SUPERCALLFORWARDALLARGS_PREF_V8
CALLRUNTIME_LDSENDABLELOCALMODULEVAR_PREF_IMM8
CALLRUNTIME_WIDELDSENDABLELOCALMODULEVAR_PREF_IMM16
DEPRECATED_LDLEXENV_PREF_NONE
DEPRECATED_POPLEXENV_PREF_NONE
DEPRECATED_GETITERATORNEXT_PREF_V8_V8
DEPRECATED_CREATEARRAYWITHBUFFER_PREF_IMM16
DEPRECATED_CREATEOBJECTWITHBUFFER_PREF_IMM16
DEPRECATED_TONUMBER_PREF_V8
DEPRECATED_TONUMERIC_PREF_V8
DEPRECATED_NEG_PREF_V8
DEPRECATED_NOT_PREF_V8
DEPRECATED_INC_PREF_V8
DEPRECATED_DEC_PREF_V8
DEPRECATED_CALLARG0_PREF_V8
DEPRECATED_CALLARG1_PREF_V8_V8
DEPRECATED_CALLARGS2_PREF_V8_V8_V8
DEPRECATED_CALLARGS3_PREF_V8_V8_V8_V8
DEPRECATED_CALLRANGE_PREF_IMM16_V8
DEPRECATED_CALLSPREAD_PREF_V8_V8_V8
DEPRECATED_CALLTHISRANGE_PREF_IMM16_V8
DEPRECATED_DEFINECLASSWITHBUFFER_PREF_ID16_IMM16_IMM16_V8_V8
DEPRECATED_RESUMEGENERATOR_PREF_V8
DEPRECATED_GETRESUMEMODE_PREF_V8
DEPRECATED_GETTEMPLATEOBJECT_PREF_V8
DEPRECATED_DELOBJPROP_PREF_V8_V8
DEPRECATED_SUSPENDGENERATOR_PREF_V8_V8
DEPRECATED_ASYNCFUNCTIONAWAITUNCAUGHT_PREF_V8_V8
DEPRECATED_COPYDATAPROPERTIES_PREF_V8_V8
DEPRECATED_SETOBJECTWITHPROTO_PREF_V8_V8
DEPRECATED_LDOBJBYVALUE_PREF_V8_V8
DEPRECATED_LDSUPERBYVALUE_PREF_V8_V8
DEPRECATED_LDOBJBYINDEX_PREF_V8_IMM32
DEPRECATED_ASYNCFUNCTIONRESOLVE_PREF_V8_V8_V8
DEPRECATED_ASYNCFUNCTIONREJECT_PREF_V8_V8_V8
DEPRECATED_STLEXVAR_PREF_IMM4_IMM4_V8
DEPRECATED_STLEXVAR_PREF_IMM8_IMM8_V8
DEPRECATED_STLEXVAR_PREF_IMM16_IMM16_V8
DEPRECATED_GETMODULENAMESPACE_PREF_ID32
DEPRECATED_STMODULEVAR_PREF_ID32
DEPRECATED_LDOBJBYNAME_PREF_ID32_V8
DEPRECATED_LDSUPERBYNAME_PREF_ID32_V8
DEPRECATED_LDMODULEVAR_PREF_ID32_IMM8
DEPRECATED_STCONSTTOGLOBALRECORD_PREF_ID32
DEPRECATED_STLETTOGLOBALRECORD_PREF_ID32
DEPRECATED_STCLASSTOGLOBALRECORD_PREF_ID32
DEPRECATED_LDHOMEOBJECT_PREF_NONE
DEPRECATED_CREATEOBJECTHAVINGMETHOD_PREF_IMM16
DEPRECATED_DYNAMICIMPORT_PREF_V8
DEPRECATED_ASYNCGENERATORREJECT_PREF_V8_V8

```

`scripts/pickintrinsics.py`:

```py
import re
import argparse
from collections import OrderedDict
import ipdb

def process_intrinsic_cases(input_file, output_file):
    with open(input_file, 'r') as file:
        content = file.read()

    # Regular expression to match case statements
    case_pattern = re.compile(r'case\s+BytecodeInstruction::Opcode::(\w+):')

    # Find all matches and store them in an OrderedDict to maintain order and ensure uniqueness
    matches = list(OrderedDict.fromkeys(case_pattern.findall(content)))

    # Separate matches into regular and deprecated
    regular_matches = [match for match in matches if not match.startswith('DEPRECATED')]
    deprecated_matches = [match for match in matches if match.startswith('DEPRECATED')]

    # Combine lists with regular matches first
    sorted_matches = regular_matches + deprecated_matches

    with open(output_file, 'w') as file:
        for match in sorted_matches:
            file.write(match + '\n')

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Process compiler intrinsic case statements with default file paths',
        formatter_class=argparse.RawTextHelpFormatter)
    
    parser.add_argument('input', 
                        nargs='?', 
                        default='../out/gen/arkcompiler/runtime_core/compiler/generated/inst_builder_gen.cpp',
                        help='Input file path (default: %(default)s)')
    
    parser.add_argument('output', 
                        nargs='?', 
                        default='intrinsic_list.txt',
                        help='Output file path (default: %(default)s)')
    
    args = parser.parse_args()
    process_intrinsic_cases(args.input, args.output)


```

`scripts/picktokens.py`:

```py
import re
import argparse
from collections import OrderedDict
import ipdb

def process_intrinsic_cases(input_file, output_file):
    with open(input_file, 'r') as file:
        content = file.read()

    pattern = r'case\s+TokenType::(\w+):\s*return\s*"([^"]+)";'
    matches = re.findall(pattern, content)
 
    with open(output_file, 'w') as file:
        for match in matches:
            file.write(f"{match[0]}, {match[1]}\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Process compiler intrinsic case statements with default file paths',
        formatter_class=argparse.RawTextHelpFormatter)
    

    #es2panda/lexer/token/token.cpp
    parser.add_argument('input', 
                        nargs='?', 
                        default='../../arkcompiler/ets_frontend/es2panda/lexer/token/token.cpp',
                        help='Input file path (default: %(default)s)')
    
    parser.add_argument('output', 
                        nargs='?', 
                        default='tokens.txt',
                        help='Output file path (default: %(default)s)')
    
    args = parser.parse_args()
    process_intrinsic_cases(args.input, args.output)


```

`scripts/prepare.sh`:

```sh

# Tested on Ununtu22.04
# https://gitcode.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-arkcompiler-guide.md

install_deps(){
    sudo apt-get update && sudo apt-get install python ruby python3-pip git-lfs gcc-multilib g++-multilib zlib1g-dev libc++1 curl nodejs
}

install_repo(){
    mkdir ~/bin/
    curl https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 > ~/bin/repo
    chmod a+x ~/bin/repo
    export PATH=~/bin:$PATH
    pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple requests
}

download_source(){
    repo init -u https://gitee.com/ark-standalone-build/manifest.git -b master
    repo sync -c -j8
    repo forall -c 'git lfs pull'

    ./prebuilts_download.sh
}

create_rootdir(){
    mkdir -p harmonyos && cd harmonyos
}

switch_to_OpenHarmony_v6_0_0_1_Release(){
    cd arkcompiler
    cd ets_frontend && git checkout OpenHarmony-v6.0.0.1-Release && cd ..
    cd ets_runtime && git checkout OpenHarmony-v6.0.0.1-Release && cd ..
    cd runtime_core && git checkout OpenHarmony-v6.0.0.1-Release && cd ..
    cd toolchain && git checkout OpenHarmony-v6.0.0.1-Release && cd ..
    cd ..

    cd build
    git checkout d9fd910
    cd ..
}

create_rootdir
install_deps
install_repo
download_source
switch_to_OpenHarmony_v6_0_0_1_Release

python3 ark.py x64.release

```

`scripts/removebc.py`:

```py
import argparse
import os
import shutil

def remove_bc_data(input_file):
    temp_file = input_file + '.tmp'
    
    with open(input_file, 'r') as infile, open(temp_file, 'w') as outfile:
        for line in infile:
            bc_index = line.find('bc:')
            if bc_index != -1:
                line = line[:bc_index]
            line = line.rstrip() + '\n'
            outfile.write(line)
    
    shutil.move(temp_file, input_file)

def main():
    parser = argparse.ArgumentParser(description='Remove data after "bc:" in each line of a file and strip trailing whitespace.')
    parser.add_argument('-f', '--file', type=str, help='Input file name', default='logs/func_main_0:(any,any,any).ir')

    args = parser.parse_args()
    
    input_filename = args.file

    if not os.path.exists(input_filename):
        print(f"Error: The file '{input_filename}' does not exist.")
        return

    remove_bc_data(input_filename)
    print(f"Processing complete. Changes applied to '{input_filename}'.")

if __name__ == '__main__':
    main()

```

`scripts/tokens.txt`:

```txt
PUNCTUATOR_BITWISE_AND, &
PUNCTUATOR_BITWISE_OR, |
PUNCTUATOR_MULTIPLY, *
PUNCTUATOR_DIVIDE, /
PUNCTUATOR_MINUS, -
PUNCTUATOR_EXCLAMATION_MARK, !
PUNCTUATOR_TILDE, ~
PUNCTUATOR_MINUS_MINUS, --
PUNCTUATOR_LEFT_SHIFT, <<
PUNCTUATOR_RIGHT_SHIFT, >>
PUNCTUATOR_LESS_THAN_EQUAL, <=
PUNCTUATOR_GREATER_THAN_EQUAL, >=
PUNCTUATOR_MOD, %
PUNCTUATOR_BITWISE_XOR, ^
PUNCTUATOR_EXPONENTIATION, **
PUNCTUATOR_MULTIPLY_EQUAL, *=
PUNCTUATOR_EXPONENTIATION_EQUAL, **=
PUNCTUATOR_DIVIDE_EQUAL, /=
PUNCTUATOR_MOD_EQUAL, %=
PUNCTUATOR_MINUS_EQUAL, -=
PUNCTUATOR_LEFT_SHIFT_EQUAL, <<=
PUNCTUATOR_RIGHT_SHIFT_EQUAL, >>=
PUNCTUATOR_UNSIGNED_RIGHT_SHIFT, >>>
PUNCTUATOR_UNSIGNED_RIGHT_SHIFT_EQUAL, >>>=
PUNCTUATOR_BITWISE_AND_EQUAL, &=
PUNCTUATOR_BITWISE_OR_EQUAL, |=
PUNCTUATOR_LOGICAL_AND_EQUAL, &&=
PUNCTUATOR_NULLISH_COALESCING, ??
PUNCTUATOR_LOGICAL_OR_EQUAL, ||=
PUNCTUATOR_LOGICAL_NULLISH_EQUAL, \?\?=
PUNCTUATOR_BITWISE_XOR_EQUAL, ^=
PUNCTUATOR_PLUS, +
PUNCTUATOR_PLUS_PLUS, ++
PUNCTUATOR_PLUS_EQUAL, +=
PUNCTUATOR_LESS_THAN, <
PUNCTUATOR_GREATER_THAN, >
PUNCTUATOR_EQUAL, ==
PUNCTUATOR_NOT_EQUAL, !=
PUNCTUATOR_STRICT_EQUAL, ===
PUNCTUATOR_NOT_STRICT_EQUAL, !==
KEYW_INSTANCEOF, instanceof
KEYW_IN, in
PUNCTUATOR_LOGICAL_AND, &&
PUNCTUATOR_LOGICAL_OR, ||
PUNCTUATOR_SUBSTITUTION, =
PUNCTUATOR_QUESTION_MARK, ?
PUNCTUATOR_AT, @
KEYW_ANY, any
KEYW_UNKNOWN, unknown
KEYW_NEVER, never
KEYW_NUMBER, number
KEYW_BIGINT, bigint
KEYW_BOOLEAN, boolean
KEYW_STRING, string
KEYW_VOID, void
KEYW_OBJECT, object
KEYW_TYPEOF, typeof
KEYW_DELETE, delete
KEYW_OUT, out

```

`tests/1.normal.ts`:

```ts
// #1. CONST
// const pi: number = 3.14159;

// #2. Bin and Unary
// let c;
// c = 1 + 1;
// let d = true;
// let e = false;
// let f = null;
// let g = undefined;
// var obj9 = NaN;
// var obj10 = Infinity;
// c = 3 * 9;
// let h = ~ 1;
// let i = 2;
// i--;
// i++;

// #3. typeof
// let j = 3;
// let h = typeof j;

// #4. instanceof
// var str = "Hello, World!";
// var b = str instanceof Number;


// #17. enum
// enum Role {
//     A,
//     B,
//     C
// }
```

`tests/10.module.ts`:

```ts
// run.sh module

// # 26. module var: import and export clause
// import { a, b } from "./module_foo"
// import * as c from "./module_bar"

// import add from './math'; 

// # 26.1 other imports
// import { a, b } from "./module_foo1"
// import * as c from "./module_bar"
// import { d, e } from "./module_foo2"
// import { PI as Pi, add as sum } from './math';
// import { namedExport as h } from 'module-path' assert { type: 'int' };

// # 26.2 exports
// export let i: number = 3;
// export function add(a: number, b: number): number {
//     return a + b;
// }
// export default api;

// export *  from './utils';
// export * as UserService from './userService';
// export { a as b , d as d} from './logger';


// # 26. module: LDLOCALMODULEVAR_IMM8, STMODULEVAR_IMM8, LDEXTERNALMODULEVAR_IMM8, WIDE_LDLOCALMODULEVAR_PREF_IMM16, WIDE_STMODULEVAR_PREF_IMM16, WIDE_LDEXTERNALMODULEVAR_PREF_IMM16
// import { a, b } from "./module_foo1"
// import { d, e } from "./module_foo2"
// export { a as b , d as d} from './logger';

// export let i: number = 3;
// export let f: number = 3;
// export let g: number = 4;
// export *  from './utils';
// export * as UserService from './userService';

// var x = a + b + d + e + f + Pi + sum;


// 33. ldlazymodulevar
// import lazy {a} from './a'
// import {b} from './b'
// import c from './a'
// import lazy d from './c'
// import lazy from './b'


// console.log(b);
// console.log(c);
// console.log(d);

// 34. ldsendablelocalmodulevar, ldlazysendablemodulevar and ldsendableexternalmodulevar
// import lazy {a} from './a'
// import {b} from './b'
// import c from './c'
// import lazy d from './d'
// import e from './e'

// import f from "./f"

// class B {
//   constructor() {
//       "use sendable";
//   }

//   foo() {
//       console.log(a);
//       console.log(b);
//       new f();
//       console.log(c);
//       console.log(d);
//   }
// }

// console.log(e);

// 35. DYNAMICIMPORT

// import('./moduleName').then(module => {
//   module.someFunction();
// }).catch(error => {
//   console.error("Error loading module:", error);
// });


// export interface Foo {
//     a: string;
//     b: number;
//     c: boolean;
// }

// export const obj = {
//     m(): this is Foo {
//         let dis = this as {} as Foo;
//         return dis.a != null && dis.b != null && dis.c != null;
//     }
// }

// #1 corner case
// namespace M {
//    var x;
// }

// export = M;
```

`tests/11.generator.ts`:

```ts
// 43. asyncfunctionenter asyncfunctionresolve asyncfunctionreject  asyncfunctionawaituncaught

// async function asyncFoo() {
//     const result = await myPromise;
//     console.log(result);
// }
  

// 44. creategeneratorobj suspendgenerator resumegenerator getresumemode createiterresultobj
// function* generateFunc() {
//     yield 'hello';
//     yield 'world';
//     return 'done';
// }

// const generator = generateFunc();
// console.log(generator.next());


// 45. createasyncgeneratorobj asyncgeneratorresolve asyncgeneratorreject setgeneratorstate
// async function* asyncGenerateFunc(){
//     yield 'hello';
//     //return await "hello";
// }



```

`tests/12.iterator.ts`:

```ts
// 46. iterator
// let [a, b] = [1, 2];

// es2panda\test\parser\binder\loop-scope-name-js.js
// while ((() => {return true})()) {
//     function foo() {}
// }

// for (let i = (() => {return 1})(); i < 5; i++) {
//     function foo1() {}
// }


// 47. getpropiterator getnextpropname
// const list = []
// for(let x in list) {
//     console.log(x);
// }


// 48. getiterator
// var list = []
// for(var x of list) {
//     console.log("hi");
// }

```

`tests/13.differentbranchcases.ts`:

```ts
// while case 1 a
// const list = []
// for(let x in list) {
//     console.log(x);
// }

// while case 1
// var x = 0;
// var i = 0;
// while (i < 5) {
//     x = i;
//     i = i + 1;
// }
// x = 10;

// while case 2
// var x = 0
// var i = 0;
// while (true) {
//     i++;
//     if (i === 5) {
//         x = i;
//         break;
//     }
//     x = 1;
// }
// x = 3;

// if case 1
// var x;
// var y;
// if(x){
//     y = console.log("true");
//     y = console.log("1");
// }

// if case 2
// var x;
// var y;
// if(x == undefined){
//     y = console.log("1");
// }else{
//     y = console.log("2");
// }

// if case 3
// var x;
// var y;
// if(x){
//     y = console.log("true");
//     y = console.log("1");
// }else{
//     y = console.log("false");
// }


// do while case 1
// var i = 0;
// var x = 1;
// do {
//     x = 1
//     i++;
// } while (i < 5);
// x = 2;
```

`tests/14.phi.ts`:

```ts
// #21. phi
// function add(a, b, c) {
//   var x;
//   var y;
//   if(c){
//      x = a;
//   }else{
//      x = b;
//   }
//   y = x;
//   return y;
// }


// phi in loop
// var x = 0;
// for (let i = 0; i < 5; i++) {
//     if (i === 2) {
//         x = 1;
//         continue; 
//     }
//     x = 2;
// }
// x = 3;
```

`tests/15.sendable.ts`:

```ts
// 31. sendable
// class SendableB {
//     constructor() {
//         "use sendable";
//     }

//     hello(){
//         this.name = "hello";
//         console.log("11");
//     }
// }

// function test2() {
//     var a = new SendableB();
//     var b = 1;
//     function hi() {
//         var m = a;
//         console.log(m);
//         var n = b;
//         console.log(n);
//     }
// }

// 32. ldsendableclass DEFINEPROPERTYBYNAME
// class B {
//     constructor() {
//       "use sendable";
//     }
//     static b: number = 1;
//     b: number = B.b;
//     //c: number = B["b"];
// }
```

`tests/16.async.ts`:

```ts
// 43. asyncfunctionenter asyncfunctionresolve asyncfunctionreject  asyncfunctionawaituncaught

// async function asyncFoo() {
//     const result = await myPromise;
//     console.log(result);
// }

// 44. creategeneratorobj suspendgenerator resumegenerator getresumemode createiterresultobj
// function* generateFunc() {
//     yield 'hello';
//     yield 'world';
//     return 'done';
// }

// const generator = generateFunc();
// console.log(generator.next());

// 45. createasyncgeneratorobj asyncgeneratorresolve asyncgeneratorreject setgeneratorstate
// async function* asyncGenerateFunc(){
//     yield 'hello';
//     //return await "hello";
// }

// 46.1 iterator delegation
// class C4 {
//   async * f() {
//       const x = yield* [1];
//   }
// }

// 46.2 iterator delegation
// async function* f() {
//    const x = yield *[1];
// }
  
```

`tests/17.template.ts`:

```ts
// case 1
// interface Mixin1 {
//     mixinMethod(): void;
// }

// abstract class AbstractBase {
//     abstract abstractBaseMethod(): void;
// }

// function Mixin2<TBase extends abstract new (...args: any[]) => any>(baseClass: TBase) {
//     // must be `abstract` because we cannot know *all* of the possible abstract members that need to be
//     // implemented for this to be concrete.
//     abstract class MixinClass extends baseClass implements Mixin1 {
//         mixinMethod(): void {}
//         static staticMixinMethod(): void {}
//     }
//     return MixinClass;
// }

// class DerivedFromAbstract2 extends Mixin2(AbstractBase) {
//     abstractBaseMethod() {}
// }

// case 2
// interface IData {
//   bar: boolean
// }

// declare function test<TDependencies>(
//   getter: (deps: TDependencies, data: IData) => any,
//   deps: TDependencies,
// ): any 

// const DEPS = {
//   foo: 1
// }

// test(
//   (deps, data) => {
//       return {
//          fn1(a) { return deps.foo + a },
//       }
//   },
//   DEPS
// );
```

`tests/2.array_obj.ts`:

```ts
// 5. createemptyarray  createarraywithbuffer  createemptyobject createobjectwithbuffer
// var obj2 = {}; 
// var obj3 = []; 
// var obj4 = [1, 2, 3];
// var obj5 = {"a":1, "b":2, "c":3};


// #7. stobjbyvalue ldobjbyvalue
// var obj6 = {"a":1, "b":2, "c":3};
// var c = obj6["a"];
// obj6["d"] = 4;


// 8. isin stobjbyname 
// var obj7 = {"a":1, "b":2, "c":3};
// var obj8 = "a" in obj7;
// obj7.a = 5


// #15. DELOBJPROP
// let obj = { a: 1, b: 2 };
// let result = delete obj.c; 

// #10. NEWOBJRANGE
// const regex = new RegExp('pattern', 'flags');

// 11. COPYDATAPROPERTIES
// const obj1 = { a: 1, b: 2, c: 3 };
// const obj2 = { b: 4, d: 5 };
// var merged = { e: 6, ...obj1, ...obj2 };


// 12. createarraywithbuffer
// const numbers = [5, 6, 2, 3, 7];
// const max = Math.max.apply(null, numbers);


// #13. starrayspread apply
// const numbers = [10, 20, 30, 5, 15];
// const maxNumber = Math.max(1,2,3,...numbers); 

// # 24. stownbyvalue
// const arr1 = [1, 2, 3];
// const arr2 = [...arr1, 4, 5]; 

// # 25. stownbyindex
// var r1;
// var r2;
// var r3 = [1, r1, ...r2];

// 36. NEWOBJAPPLY_
// const countryInfo = ['USA', 'The Star-Spangled Banner', 'John Stafford Smith'];
// const usa = new Country(...countryInfo);


// 39. CREATEOBJECTWITHEXCLUDEDKEYS
// function foo()
// {
//     let {a, b, c, ...d} = {a:1, b:2, c:3, f:4, e:5}
// }

// const sourceObject = { a: 1, b: 2, c: 3, f: 4, e: 5 };

// let { a: alpha, b: beta, c: gamma, ...rest } = sourceObject;


// console.log(alpha); 
// console.log(beta); 
// console.log(gamma);


// 38. CREATEREGEXPWITHLITERAL
// var x = 0x1; 
// var y = new RegExp("hello", x);


// 36. NEWOBJAPPLY_
// const countryInfo = ['USA', 'The Star-Spangled Banner', 'John Stafford Smith'];
// const usa = new Country(...countryInfo);

// 38. CREATEREGEXPWITHLITERAL
// var x = 0x1; 
// var y = new RegExp("hello", x);

// 39. CREATEOBJECTWITHEXCLUDEDKEYS
// function foo()
// {
//     let {a, b, c, ...d} = {a:1, b:2, c:3, f:4, e:5}
// }

// const sourceObject = { a: 1, b: 2, c: 3, f: 4, e: 5 };

// let { a: alpha, b: beta, c: gamma, ...rest } = sourceObject;


// console.log(alpha); 
// console.log(beta); 
// console.log(gamma); 


// corner case 1
// declare function dec<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T>;

// class C {
//     @dec ["1"]() { }
//     @dec ["b"]() { }
// }

// corner case 2
// var a0 = [,, 2, 3, 4];

// corner case 3
// var a0 = [,, 2, 3, 4]
// var a2 = [, , , ...a0, "hello"];

// corner case 4
// const membersOfI = [];
// const membersOfI2 = [];
// const membersOfIAndI2 = [...membersOfI, ...membersOfI2];

// corner case 5
// let x;
// [x = 0xaa] = [91];
// [x = 0xaa] = [99];

// corner case 6
// class C {
//     method(other: C) {
//         const { id, secret, ...rest } = other;
//         console.log(rest);
//     }
// }

```

`tests/3.func.ts`:

```ts
// #6. callargs callthis
// var x1 = clearTimeout();
// var x2 = parseInt("42");
// var x3 = parseInt("1010", 2); 
// var x4 = parseInt("10", 10, 0);
// var x5 = Math.random();
// var x6 = console.log("hello");

// #9. callarg1 tLoadString
// var obj11 = BigInt("1234567890123456789012345678901234567890");

// 14. callthisrange callrange
// var x= setInterval(Math.max, 2000, "Bob", "Hi");
// const maxNumber = Math.max(1,2,3,4,5,6,7);

// #16. function declaration and DEFINEFUNC
// function add(a: number, b: number): number {
//     return a + b;
// }
// var x = add(2, 3);


// #23. function call def-use detection
// console.log("hi");
// var x6 = console.log("hello");


// # 28. DEFINECLASSWITHBUFFER_IMM16_ID16_ID16_IMM16_V8
// function hello(){
//     var x = 1;
// }


// 40. getunmappedargs
// function exampleFunction(a, b) {
//     console.log(arguments.length); 
//     console.log(arguments[0]); 
//     console.log(arguments[1]);
// }


// 40. SUPERCALLARROWRANGE
// function exampleFunction(a, b) {
//     console.log(arguments.length); 
//     console.log(arguments[0]); 
//     console.log(arguments[1]);
// }



// #1 corner case: recursive calls and recursive references
// function md5(string:string): void {

//     function FF(a,b,c,d,x,s,ac) {
//         return 0;
//     };

//     function GG(a,b,c,d,x,s,ac) {
//         return 0;
//     };

//     function HH(a,b,c,d,x,s,ac) {
//         return 0;
//     };

//     function II(a,b,c,d,x,s,ac) {
//         return 0;
//     };

//     var x=Array();
//     var k,AA,BB,CC,DD,a,b,c,d;
//     var S11=7, S12=12, S13=17, S14=22;
//     var S21=5, S22=9 , S23=14, S24=20;
//     var S31=4, S32=11, S33=16, S34=23;
//     var S41=6, S42=10, S43=15, S44=21;

//     x = [1];

//     a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;

//     for (k=0;k<x.length;k+=16) {
//         AA=a; BB=b; CC=c; DD=d;
//         a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
//         d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
//         c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
//         b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
//         a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
//         d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
//         c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
//         b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
//         a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
//         d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
//     }
// }
```

`tests/4.if.ts`:

```ts
// #18. IfImm
// var x;
// var y;
// if(x){
//     y = console.log("true");
//     y = console.log("1");
// }else{
//     y = console.log("false");
// }


// #19. nested struct
// var x;
// var y;
// var k;
// if(x){
//     y = 1;
//     if(k){
//         y = 2;
//         y = 3;
//     }else{
//         y = 4;
//     }
//     y = 5;
// }else{
//     if(k){
//         y = 6;
//         y = 7;
//     }else{
//         y = 8;
//     }
//     y = 9;
// }
// y = 10;

```

`tests/5.trycatch.ts`:

```ts
// #20.1 try-catch
// var x;
// try {
//   x = 1;
// } catch (error) {
//   x = 2;
// }  
// x= 5;

// #20.2 try-catch with catchphi
// var x;
// try {
//   x = 1;
// } catch (error) {
//   x = console.log(error);
// }  
// x= 5;

// #20.3 try-catch with if-else
// var k;
// var x;
// try {
//     x = 1;
// } catch (error1) {
//     if(k){
//         x = 2;
//     }else{
//         x = 3;
//     }
//     x = 4;
// }
// x= 5;

// #20.4 try-catch
// var x;
// try {
//     x = 1;
// } catch (error) {
//     x = 2;
// }
// finally{
//   x = 3;
// }
// x= 4;


// #20.5 try-catch 
// var k;
// var x;
// try {
//     x = 1;
// } catch (error1) {
//     if(k){
//         x = 2;
//     }else{
//         x = 3;
//     }
//     x = 4;
// }
// finally{
//     x = 5;
// }
// x= 6;


// corner case 1: The try basic block contains many predecessors.
// declare const g1: Generator<number, void, string>;
// [..._] = g1; // error
// for (_ of g1); // error
```

`tests/6.loop.ts`:

```ts
// #22. for 
// const array = [10, 20, 30];
// var x;
// for (const value of array.values()) {
//     x = console.log(value); 
// }

// const array = [10, 20, 30];
// var x;
// for (const value of array.values()) {
//     x = console.log(value); 
// }

// #22. for - normal
// var x = 1;
// for (var i = 0; i < 5; i++) {
//     x = i;
// }
// x = 10;

// #22. for - continue
// var x = 0;
// for (var i = 0; i < 5; i++) {
//     if (i === 2) {
//         x = 1;
//         continue; 
//     }
//     x = 2;
// }
// x = 3;

// #22. for - break
// var x = 0;
// for (var i = 0; i < 10; i++) {
//     x = 1;
//     if (i === 5) {
//         x = 2;
//         break; 
//     }else{
//         x = 4;
//     }
//     x = 3;
// }
// x = 5;


// #22. for - return
// function findNumber() {
//     var x = 5;
//     var i = 0;
//     for (i = 0; i < 10; i++) {
//         if (i = x) {
//             return i; 
//         }
//     }
//     return -1;
// }


// #22. for - break-throw
// for (var i = 0; i < 10; i++) {
//     if (i === 5) {
//         throw new Error('exit');
//     }
// }

// #22. for - break-to-label
// loop1:{

// loop2:{
//     var x = 0;
//     console.log("hello");
//     for (let i = 0; i < 5; i++) {
//         if (i === 3) {
//             x = 1;
//             console.log(x);
//             break loop1;
//         }
//         x = 2;
//     }
// }
// }




// # 22. while - normal
// var x = 0;
// var i = 0;
// while (i < 5) {
//     x = i;
//     i = i + 1;
// }
// x = 10;

// # 22. while - continue
// var x = 0;
// var i = 0;
// while (i < 5) {
//     i++;
//     if (i === 3) {
//         x = i;
//         continue; 
//     }
//     x = 4;
// }
// x = 5;

// # 22. while - break
// var x = 0
// var i = 0;
// while (true) {
//     i++;
//     if (i === 5) {
//         x = i;
//         break;
//     }
//     x = 1;
// }
// x = 3;


// # 22. while - return
// function processData() {
//     var i = 0;
//     var x = 0;
//     while (i < 10) {
//         x = i + 1;
//         if (i === 5) {
//             x = 2;
//             return; 
//         }
//         i++;
//     }
//     x = 7;
// }

// # 22. while - throw
// var i = 0;
// var x = 0;
// while (i < 10) {
//     x = 1;
//     if (i === 5) {
//         x = 2;
//         throw new Error('1');
//     }
//     i++;
//     x = 3;
// }
// x = 4;

//# 22. dowhile - normal
// var i = 0;
// var x = 1;
// do {
//     x = 1
//     i++;
// } while (i < 5);
// x = 2;

//# 22. dowhile - continue
// var i = 0; 
// var x = 1; 
// do {     
//     i++;
//     if (i === 3) {
//         x = 2;
//         continue; 
//     }
//     x = i; 
// } while (i < 5); 
// x = 3;

// # 22. dowhile - break
// var i = 0; 
// var x = 1; 
// do {     
//     i++;
//     x = 2;
//     if (x >= 8) {
//         x = 3;
//         break;
//     }
// } while (i < 5); 
// x = 4;

// # 22. dowhile - return
// function example2() {
//     var i = 0; 
//     var x = 1; 
//     do {     
//         i++;
//         x = i * 10; 
        
//         if (x >= 30) {
//             x = 888; 
//             return;
//         }
//     } while (i < 5); 
    
//     x = 2;
//     return;
// }

// # 22. dowhile - throw
// var i = 0; 
// var x = 1; 
// do {     
//     i++;
//     x = i;
    
//     if (i === 3) {
//         x = 99; 
//         throw new Error("z");
//     }
// } while (i < 5); 
// x = 2; 

// while-catch
// const list = []
// for(let x of list) {
//     console.log("hi");
// }


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// var m = 0;
// do {
//   m++;
// }while(m < 1);

// dowhile-dowhile
// var m = 0;
// var n = 0;
// do {
//     do {
//         m++;
//     }while(m < 1);

//     n++;
// } while (n < 2);


// dowhile-while
// var m = 0;
// var n = 0;
// do {
//    while(m < 3){
//      m++;
//    }
//   n++;
// } while (n < 4);

// whilie-dowhile
// var m = 0;
// var n = 0;
// while(n < 5){
//   do{
//     m++;
//   }while(m < 6);
//   n++;
// }


// while-while
// var m = 0;
// var n = 0;
// while(n < 7){
//    while(m < 8){
//       m++;
//    }
//   n++;
// }

```

`tests/7.lexical.ts`:

```ts
// # 25.1 newlexenv/poplexenv/stlexvar/ldlexvar
// function hello() {
//     function hi() {
//         //for (var i = 0; i++ < 10;) {
//             var x1 = 21;
//             let x2 = function () {
//                 return x1;
//             };
//        //}
//     }
// }

// # 25.2 newlexenv/poplexenv/stlexvar/ldlexvar
// (function () {
//     function f1() {
//       f3();
//     }
//     function f3() {
//     }
//     function f5() {}
//     function f6(a) {
//         let v31 = a ;

//         function f19() {
//             let v36 = 21;
//             let v37 = function () {
//                 return v36;
//             };
//             for (var v33 = 0; v33++ < 10;) {
//                 let v38 = 22;
//                 let v39 = function () { 
//                     let v40 = v31;
//                     f1();
//                     return v38;
//                 };
//             }         
//         }

//         f19();
//     }
//     for (var v1 = 0; v1 < 10; v1++) {
//       f6();
//     }
//     f1();
// })();
```

`tests/8.class.ts`:

```ts
// class Animal {
//     name: string;

//     constructor(name: string) {
//         this.name = name;
//     }

//     move(): void {
//         console.log(`${this.name} is moving`);
//     }
// }

// interface Flyable {
//     fly(): void;
// }

// interface Swimmable {
//     swim(): void;
// }

// class Bird extends Animal implements Flyable {
//     constructor(name: string) {
//         super(name);
//     }

//     fly(): void {
//         console.log(`${this.name} is flying`);
//     }

//     move(): void {
//         console.log(`${this.name} is hopping and flying`);
//     }
// }

// class Fish extends Animal implements Swimmable {
//     constructor(name: string) {
//         super(name);
//     }

//     swim(): void {
//         console.log(`${this.name} is swimming`);
//     }

//     move(): void {
//         console.log(`${this.name} is swimming gracefully`);
//     }
// }

// class Duck extends Animal implements Flyable, Swimmable {
//     constructor(name: string) {
//         super(name);
//     }

//     fly(): void {
//         console.log(`${this.name} is flying`);
//     }

//     swim(): void {
//         console.log(`${this.name} is swimming`);
//     }

//     move(): void {
//         console.log(`${this.name} is waddling, swimming, and flying`);
//     }
// }

// const sparrow = new Bird("Sparrow");
// sparrow.move();
// sparrow.fly();

// const goldfish = new Fish("Goldfish");
// goldfish.move();
// goldfish.swim();

// const donald = new Duck("Donald");
// donald.move();
// donald.fly();
// donald.swim();


// # 28. LDPRIVATEPROPERTY createprivateproperty  defineprivateproperty 
// class XXX {
//     #yyy: number = 8;
//     #zzz: number = 9;
//     #add1() {
//       this.#yyy += 1;
//     }

//     #add2() {
//         this.#zzz += 2;
//     }

//     sub() {
//         this.#yyy -= 3;
//         this.#add1();
//         this.#add2();
//     }
// }
// var xxx = new XXX();

// class YYY {
//     #yyy1: number = 8;
//     #zzz1: number = 9;
//     #adda() {
//       this.#yyy1 += 1;
//     }

//     #addb() {
//         this.#zzz1 += 2;
//     }

//     sub() {
//         this.#yyy1 -= 3;
//         this.#adda();
//         this.#addb();
//     }
// }

// var yyy = new YYY();
// function hello() {
//     function hi() {
//         var x1 = 21;
//         let x2 = function () {
//             return x1;
//         };
//     }
// }


// 29. ldsuperbyvalue ldsuperbyname stsuperbyname stsuperbyvalue supercallforwardallargs
// class Animal {
//     constructor(name: string) {
//         this.name = name;
//     }

//     makeSound() {
//         console.log(this.name);
//     }
// }

// class Dog extends Animal {
//     makeSound() {
//         super.makeSound(); 
//         var x = super["name"];
//         console.log(x);
//     }

//     makeDance(){
//         super.name = "dance";
//         super["name"] = "dog";
//     }
// }

// const myDog = new Dog("Buddy", "Golden Retriever");
// myDog.makeSound();

// 30. ldthisbyname ldthisbyvalue stthisbyname stthisbyvalue
// class Animal {
//     constructor(name: string) {
//         this.name = name;
//     }

//     makeDance(){
//         console.log(this["hello"]);
//     }
// }

// 31. sendable
// class SendableB {
//     constructor() {
//         "use sendable";
//     }

//     hello(){
//         this.name = "hello";
//         console.log("11");
//     }
// }

// function test2() {
//     var a = new SendableB();
//     var b = 1;
//     function hi() {
//         var m = a;
//         console.log(m);
//         var n = b;
//         console.log(n);
//     }
// }

// 32. ldsendableclass DEFINEPROPERTYBYNAME
// class B {
//     constructor() {
//       "use sendable";
//     }
//     static b: number = 1;
//     b: number = B.b;
//     //c: number = B["b"];
// }

// 37. COPYRESTARGS SUPERCALLSPREAD
// class A {}
// class B extends A {
//     constructor(...args) {
//        super(1, ...args)
//     }
// }


// 42. definegettersetterbyvalue
// class Example {
//     constructor(value) {
//       this._value = value;
//     }
  
//     // Getter
//     get value() {
//       console.log('Getting value');
//       return this._value;
//     }
  
//     // Setter
//     set value(newValue) {
//       console.log('Setting value');
//       this._value = newValue;
//     }
// }
  
// const example = new Example(10);


// 41. getunmappedargs  stownbyvaluewithnameset topropertykey
// class A5 {
//     [a5]() {}
// }

// #1. corner case
// export class C {
//     m(): this is D {
//         return this instanceof D;
//     }
// }

// class D extends C {
// }

// #2. corner case
// declare var decorator: any;
// class C1 {
//     #x
//     @decorator(  (x: C1) => x.#x  )
//     y() {}
// }

// #3. corner case
// class A {
//     a?: A
//     #b?: A;
//     getA(): A {
//         return new A();
//     }
//     constructor() {
//         this?.#b;           // Error
//         this?.a.#b;         // Error
//         this?.getA().#b;    // Error
//     }
// }

// #4. corner case
// class C {
//     static #x = 123;
  
//     static {
//       console.log(C.#x)
//     }
  
//     foo () {
//       return C.#x;
//     }
// }

// #5. corner case
// class A {
//     m() { }
// }
// class B extends A {
//     get m() { return () => 1 }
// }

// #6. corner case 
// declare function foo<T, U>(x: T, fun: () => Iterable<(x: T) => U>, fun2: (y: U) => T): T;

// foo("", function* () {
//     yield* {
//         *[Symbol.iterator]() {
//             yield x => x.length
//         }
//     }
// }, p => undefined); // T is fixed, should be string


// #7. corner case 
// class A {
//     a?: A
//     #b?: A;
//     getA(): A {
//         return new A();
//     }
//     constructor() {
//         this?.#b;           // Error
//         this?.a.#b;         // Error
//         this?.getA().#b;    // Error
//     }
// }

// #8. corner case
// class SomeDerivedClass{
//     static get a() {
//         console.log("hello");
//     }
// }

// #9. corner case
// class SomeDerivedClass{
//     set a(n) {
        
//     }

//     static fn() {
        
//     }

//     static get a() {
//     }
// }

// #10. corner case
// var sameName1a = { set a(n) { console.log('a')} };

// #11. corner case: private function
// class C {
//     #something = () => 1234;
// }

// #11. corner case
// class C {
//    static s = new C().#method();
//    #method() { return 42; }
// }

// console.log(C.s);

// #12. corner case
// class ExtendsNull extends null {
// }

// #13. corner case
// class C1 extends undefined { }
// class C2 extends true { }
// class C3 extends false { }
// class C4 extends 42 { }
// class C5 extends "hello" { }
// class C6 extends x { }
// class C7 extends foo { }

// #14. corner case
// class A<T> {
//     genericVar: T
// }

// class B2<V> {
//     anon = class extends A<V> { }
// }

// class C extends (new B2<number>().anon) {
//     name: string;
// }


// #15. corner case
// class TestClass {
//     set 2(v) { }
//     3() { }
//     static set 5(x) { }
//     static 6() { }
// }
```

`tests/9.hotcompile.ts`:

```ts
// ./hot.sh && ./run.sh hot
// 1. ts
// incremental compile: base.ts
// let a = 1;
// let b = 1;
// let c = 1;
// function A() {
//     let d = a + b;
//     let e = 3;
//     let m = d + e;
//     return m;
// }


// 2.ts
// let a = 1;
// let b = 2;
// let c = 3;
// let n = 4;
// function A() {
//     let d = a + b + c;
//     let e = 5;
//     let m = d + e + n;
//     return m;
// }


```

`tests/misc.ts`:

```ts
// #1 ir construction fail
// while (1 === 1) {
// }

// do {
//     let x;
//     (function() { return x;});
// } while (1 === 1)

// #2 recursive case
// const foo = function (this: any) {
//     var a, b, c, d, ab, bc, cd, da, blocks = this.blocks;

//     if (this.first) {
//         a = blocks[0] - 1;
//         a = (a << 3) | (a >>> 29);
//         d = ((a & 0xefcdab89) | (~a & 0x98badcfe)) + blocks[1] + 271733878;
//         d = (d << 7) | (d >>> 25);
//         c = ((d & a) | (~d & 0xefcdab89)) + blocks[2] - 1732584194;
//         c = (c << 11) | (c >>> 21);
//         b = ((c & d) | (~c & a)) + blocks[3] - 271733879;
//         b = (b << 19) | (b >>> 13);
//     } else {
//         a = this.h0;
//         b = this.h1;
//         c = this.h2;
//         d = this.h3;
//         a += ((b & c) | (~b & d)) + blocks[0];
//         a = (a << 3) | (a >>> 29);
//         d += ((a & b) | (~a & c)) + blocks[1];
//         d = (d << 7) | (d >>> 25);
//         c += ((d & a) | (~d & b)) + blocks[2];
//         c = (c << 11) | (c >>> 21);
//         b += ((c & d) | (~c & a)) + blocks[3];
//         b = (b << 19) | (b >>> 13);
//     }

//     a += ((b & c) | (~b & d)) + blocks[4];
//     a = (a << 3) | (a >>> 29);
//     d += ((a & b) | (~a & c)) + blocks[5];
//     d = (d << 7) | (d >>> 25);
//     c += ((d & a) | (~d & b)) + blocks[6];
//     c = (c << 11) | (c >>> 21);
//     b += ((c & d) | (~c & a)) + blocks[7];
//     b = (b << 19) | (b >>> 13);
//     a += ((b & c) | (~b & d)) + blocks[8];
//     a = (a << 3) | (a >>> 29);
//     d += ((a & b) | (~a & c)) + blocks[9];
//     d = (d << 7) | (d >>> 25);
//     c += ((d & a) | (~d & b)) + blocks[10];
//     c = (c << 11) | (c >>> 21);
//     b += ((c & d) | (~c & a)) + blocks[11];
//     b = (b << 19) | (b >>> 13);
//     a += ((b & c) | (~b & d)) + blocks[12];
//     a = (a << 3) | (a >>> 29);
//     d += ((a & b) | (~a & c)) + blocks[13];
//     d = (d << 7) | (d >>> 25);
//     c += ((d & a) | (~d & b)) + blocks[14];
//     c = (c << 11) | (c >>> 21);
//     b += ((c & d) | (~c & a)) + blocks[15];
//     b = (b << 19) | (b >>> 13);

//     bc = b & c;
//     a += (bc | (b & d) | (c & d)) + blocks[0] + 1518500249;
//     a = (a << 3) | (a >>> 29);
//     ab = a & b;
//     d += (ab | (a & c) | bc) + blocks[4] + 1518500249;
//     d = (d << 5) | (d >>> 27);
//     da = d & a;
//     c += (da | (d & b) | ab) + blocks[8] + 1518500249;
//     c = (c << 9) | (c >>> 23);
//     cd = c & d;
//     b += (cd | (c & a) | da) + blocks[12] + 1518500249;
//     b = (b << 13) | (b >>> 19);
//     bc = b & c;
//     a += (bc | (b & d) | cd) + blocks[1] + 1518500249;
//     a = (a << 3) | (a >>> 29);
//     ab = a & b;
//     d += (ab | (a & c) | bc) + blocks[5] + 1518500249;
//     d = (d << 5) | (d >>> 27);
//     da = d & a;
//     c += (da | (d & b) | ab) + blocks[9] + 1518500249;
//     c = (c << 9) | (c >>> 23);
//     cd = c & d;
//     b += (cd | (c & a) | da) + blocks[13] + 1518500249;
//     b = (b << 13) | (b >>> 19);
//     bc = b & c;
//     a += (bc | (b & d) | cd) + blocks[2] + 1518500249;
//     a = (a << 3) | (a >>> 29);
//     ab = a & b;
//     d += (ab | (a & c) | bc) + blocks[6] + 1518500249;
//     d = (d << 5) | (d >>> 27);
//     da = d & a;
//     c += (da | (d & b) | ab) + blocks[10] + 1518500249;
//     c = (c << 9) | (c >>> 23);
//     cd = c & d;
//     b += (cd | (c & a) | da) + blocks[14] + 1518500249;
//     b = (b << 13) | (b >>> 19);
//     bc = b & c;
//     a += (bc | (b & d) | cd) + blocks[3] + 1518500249;
//     a = (a << 3) | (a >>> 29);
//     ab = a & b;
//     d += (ab | (a & c) | bc) + blocks[7] + 1518500249;
//     d = (d << 5) | (d >>> 27);
//     da = d & a;
//     c += (da | (d & b) | ab) + blocks[11] + 1518500249;
//     c = (c << 9) | (c >>> 23);
//     b += ((c & d) | (c & a) | da) + blocks[15] + 1518500249;
//     b = (b << 13) | (b >>> 19);

//     bc = b ^ c;
//     a += (bc ^ d) + blocks[0] + 1859775393;
//     a = (a << 3) | (a >>> 29);
//     d += (bc ^ a) + blocks[8] + 1859775393;
//     d = (d << 9) | (d >>> 23);
//     da = d ^ a;
//     c += (da ^ b) + blocks[4] + 1859775393;
//     c = (c << 11) | (c >>> 21);
//     b += (da ^ c) + blocks[12] + 1859775393;
//     b = (b << 15) | (b >>> 17);
//     bc = b ^ c;
//     a += (bc ^ d) + blocks[2] + 1859775393;
//     a = (a << 3) | (a >>> 29);
//     d += (bc ^ a) + blocks[10] + 1859775393;
//     d = (d << 9) | (d >>> 23);
//     da = d ^ a;
//     c += (da ^ b) + blocks[6] + 1859775393;
//     c = (c << 11) | (c >>> 21);
//     b += (da ^ c) + blocks[14] + 1859775393;
//     b = (b << 15) | (b >>> 17);
//     bc = b ^ c;
//     a += (bc ^ d) + blocks[1] + 1859775393;
//     a = (a << 3) | (a >>> 29);
//     d += (bc ^ a) + blocks[9] + 1859775393;
//     d = (d << 9) | (d >>> 23);
//     da = d ^ a;
//     c += (da ^ b) + blocks[5] + 1859775393;
//     c = (c << 11) | (c >>> 21);
//     b += (da ^ c) + blocks[13] + 1859775393;
//     b = (b << 15) | (b >>> 17);
//     bc = b ^ c;
//     a += (bc ^ d) + blocks[3] + 1859775393;
//     a = (a << 3) | (a >>> 29);
//     d += (bc ^ a) + blocks[11] + 1859775393;
//     d = (d << 9) | (d >>> 23);
//     da = d ^ a;
//     c += (da ^ b) + blocks[7] + 1859775393;
//     c = (c << 11) | (c >>> 21);
//     b += (da ^ c) + blocks[15] + 1859775393;
//     b = (b << 15) | (b >>> 17);

//     a += ((b & c) | (~b & d)) + blocks[4];
//     a = (a << 3) | (a >>> 29);
//     d += ((a & b) | (~a & c)) + blocks[5];
//     d = (d << 7) | (d >>> 25);
//     c += ((d & a) | (~d & b)) + blocks[6];
//     c = (c << 11) | (c >>> 21);
//     b += ((c & d) | (~c & a)) + blocks[7];
//     b = (b << 19) | (b >>> 13);
//     a += ((b & c) | (~b & d)) + blocks[8];
//     a = (a << 3) | (a >>> 29);
//     d += ((a & b) | (~a & c)) + blocks[9];
//     d = (d << 7) | (d >>> 25);
//     c += ((d & a) | (~d & b)) + blocks[10];
//     c = (c << 11) | (c >>> 21);
//     b += ((c & d) | (~c & a)) + blocks[11];
//     b = (b << 19) | (b >>> 13);
//     a += ((b & c) | (~b & d)) + blocks[12];
//     a = (a << 3) | (a >>> 29);
//     d += ((a & b) | (~a & c)) + blocks[13];
//     d = (d << 7) | (d >>> 25);
//     c += ((d & a) | (~d & b)) + blocks[14];
//     c = (c << 11) | (c >>> 21);
//     b += ((c & d) | (~c & a)) + blocks[15];
//     b = (b << 19) | (b >>> 13);

//     bc = b & c;
//     a += (bc | (b & d) | (c & d)) + blocks[0] + 1518500249;
//     a = (a << 3) | (a >>> 29);
//     ab = a & b;
//     d += (ab | (a & c) | bc) + blocks[4] + 1518500249;
//     d = (d << 5) | (d >>> 27);
//     da = d & a;
//     c += (da | (d & b) | ab) + blocks[8] + 1518500249;
//     c = (c << 9) | (c >>> 23);
//     cd = c & d;
//     b += (cd | (c & a) | da) + blocks[12] + 1518500249;
//     b = (b << 13) | (b >>> 19);
//     bc = b & c;
//     a += (bc | (b & d) | cd) + blocks[1] + 1518500249;
//     a = (a << 3) | (a >>> 29);
//     ab = a & b;
//     d += (ab | (a & c) | bc) + blocks[5] + 1518500249;
//     d = (d << 5) | (d >>> 27);
//     da = d & a;
//     c += (da | (d & b) | ab) + blocks[9] + 1518500249;
//     c = (c << 9) | (c >>> 23);
//     cd = c & d;
//     b += (cd | (c & a) | da) + blocks[13] + 1518500249;
//     b = (b << 13) | (b >>> 19);
//     bc = b & c;
//     a += (bc | (b & d) | cd) + blocks[2] + 1518500249;
//     a = (a << 3) | (a >>> 29);
//     ab = a & b;
//     d += (ab | (a & c) | bc) + blocks[6] + 1518500249;
//     d = (d << 5) | (d >>> 27);
//     da = d & a;
//     c += (da | (d & b) | ab) + blocks[10] + 1518500249;
//     c = (c << 9) | (c >>> 23);
//     cd = c & d;
//     b += (cd | (c & a) | da) + blocks[14] + 1518500249;
//     b = (b << 13) | (b >>> 19);
//     bc = b & c;
//     a += (bc | (b & d) | cd) + blocks[3] + 1518500249;
//     a = (a << 3) | (a >>> 29);
//     ab = a & b;
//     d += (ab | (a & c) | bc) + blocks[7] + 1518500249;
//     d = (d << 5) | (d >>> 27);
//     da = d & a;
//     c += (da | (d & b) | ab) + blocks[11] + 1518500249;
//     c = (c << 9) | (c >>> 23);
//     b += ((c & d) | (c & a) | da) + blocks[15] + 1518500249;
//     b = (b << 13) | (b >>> 19);

//     bc = b ^ c;
//     a += (bc ^ d) + blocks[0] + 1859775393;
//     a = (a << 3) | (a >>> 29);
//     d += (bc ^ a) + blocks[8] + 1859775393;
//     d = (d << 9) | (d >>> 23);
//     da = d ^ a;
//     c += (da ^ b) + blocks[4] + 1859775393;
//     c = (c << 11) | (c >>> 21);
//     b += (da ^ c) + blocks[12] + 1859775393;
//     b = (b << 15) | (b >>> 17);
//     bc = b ^ c;
//     a += (bc ^ d) + blocks[2] + 1859775393;
//     a = (a << 3) | (a >>> 29);
//     d += (bc ^ a) + blocks[10] + 1859775393;
//     d = (d << 9) | (d >>> 23);
//     da = d ^ a;
//     c += (da ^ b) + blocks[6] + 1859775393;
//     c = (c << 11) | (c >>> 21);
//     b += (da ^ c) + blocks[14] + 1859775393;
//     b = (b << 15) | (b >>> 17);
//     bc = b ^ c;
//     a += (bc ^ d) + blocks[1] + 1859775393;
//     a = (a << 3) | (a >>> 29);
//     d += (bc ^ a) + blocks[9] + 1859775393;
//     d = (d << 9) | (d >>> 23);
//     da = d ^ a;
//     c += (da ^ b) + blocks[5] + 1859775393;
//     c = (c << 11) | (c >>> 21);
//     b += (da ^ c) + blocks[13] + 1859775393;
//     b = (b << 15) | (b >>> 17);
//     bc = b ^ c;
//     a += (bc ^ d) + blocks[3] + 1859775393;
//     a = (a << 3) | (a >>> 29);
//     d += (bc ^ a) + blocks[11] + 1859775393;
//     d = (d << 9) | (d >>> 23);
//     da = d ^ a;
//     c += (da ^ b) + blocks[7] + 1859775393;
//     c = (c << 11) | (c >>> 21);
//     b += (da ^ c) + blocks[15] + 1859775393;
//     b = (b << 15) | (b >>> 17);

//     a += ((b & c) | (~b & d)) + blocks[4];
//     a = (a << 3) | (a >>> 29);
//     d += ((a & b) | (~a & c)) + blocks[5];
//     d = (d << 7) | (d >>> 25);
//     c += ((d & a) | (~d & b)) + blocks[6];
//     c = (c << 11) | (c >>> 21);
//     b += ((c & d) | (~c & a)) + blocks[7];
//     b = (b << 19) | (b >>> 13);
//     a += ((b & c) | (~b & d)) + blocks[8];
//     a = (a << 3) | (a >>> 29);
//     d += ((a & b) | (~a & c)) + blocks[9];
//     d = (d << 7) | (d >>> 25);
//     c += ((d & a) | (~d & b)) + blocks[10];
//     c = (c << 11) | (c >>> 21);
//     b += ((c & d) | (~c & a)) + blocks[11];
//     b = (b << 19) | (b >>> 13);
//     a += ((b & c) | (~b & d)) + blocks[12];
//     a = (a << 3) | (a >>> 29);
//     d += ((a & b) | (~a & c)) + blocks[13];
//     d = (d << 7) | (d >>> 25);
//     c += ((d & a) | (~d & b)) + blocks[14];
//     c = (c << 11) | (c >>> 21);
//     b += ((c & d) | (~c & a)) + blocks[15];
//     b = (b << 19) | (b >>> 13);
// };

// #3. obtaining the name of the binary expression
// var v = {
//     get ["" + ""]() { return 0; },
// }

// #4. hidden scanning dependencies in the CREATEOBJECTWITHBUFFER
// {
//     let result: { velocity: number; } = {
//         velocity: 1
//     };

//     let point = {
//         getS(){
//             return result;
//         }
//     };

// };

// #5. UTF encoding error
// /\00/.exec('\x00');



```

`xabc.cpp`:

```cpp

#define PANDA_USE_FUTEX 1
#define PANDA_TARGET_UNIX 1

#include "astgen.h"
#include "base.h"
#include "arkts.h"
#include "lexicalenv.h"
#include "modulevar.h"
#include "fundepscan.h"
#include "algos.h"
#include "classconstruction.h"

using namespace std;
using namespace panda;
using namespace bytecodeopt;

std::string inputFileName = "demo.abc";
std::string outputFileName = "arkdemo.ts";
std::string outputAstFileName = "arkdemo.ast";

template <typename T>
constexpr void RunOpts(compiler::Graph *graph)
{
    graph->RunPass<compiler::Cleanup>();
    graph->RunPass<T>();
}

template <typename First, typename Second, typename... Rest>
constexpr void RunOpts(compiler::Graph *graph)
{
    RunOpts<First>(graph);
    RunOpts<Second, Rest...>(graph);
}


static void SetCompilerOptions()
{
    compiler::options.SetCompilerUseSafepoint(false);
    compiler::options.SetCompilerSupportInitObjectInst(true);
    if (!compiler::options.WasSetCompilerMaxBytecodeSize()) {
        compiler::options.SetCompilerMaxBytecodeSize(MAX_BYTECODE_SIZE);
    }
}


static bool SkipFunction(const pandasm::Function &function, const std::string &func_name)
{
    if (panda::bytecodeopt::options.WasSetMethodRegex()) {
        static std::regex rgx(panda::bytecodeopt::options.GetMethodRegex());
        if (!std::regex_match(func_name, rgx)) {
            LOG(INFO, BYTECODE_OPTIMIZER) << "Skip Function " << func_name << ": Function's name doesn't match regex";
            return true;
        }
    }

    if (panda::bytecodeopt::options.IsSkipMethodsWithEh() && !function.catch_blocks.empty()) {
        LOG(INFO, BYTECODE_OPTIMIZER) << "Was not optimized " << func_name << ": Function has catch blocks";
        return true;
    }

    if ((function.regs_num + function.GetParamsNum()) > compiler::VIRTUAL_FRAME_SIZE) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Unable to optimize " << func_name
                                       << ": Function frame size is larger than allowed one";
        return true;
    }
    return false;
}

bool DecompileRunOptimizations(compiler::Graph *graph, BytecodeOptIrInterface *iface)
{
    constexpr int OPT_LEVEL_0 = 0;
    if (panda::bytecodeopt::options.GetOptLevel() == OPT_LEVEL_0) {
        return false;
    }

    graph->RunPass<compiler::Cleanup>();
    ASSERT(graph->IsDynamicMethod());
    if (compiler::options.IsCompilerBranchElimination()) {
       graph->RunPass<ConstantPropagation>(iface);
       RunOpts<compiler::BranchElimination>(graph);
    }
    
    RunOpts<compiler::ValNum, compiler::Lowering, compiler::MoveConstants>(graph);

    graph->RunPass<compiler::Cleanup>();
    graph->RunPass<RegAccAlloc>();

    graph->RunPass<compiler::Cleanup>();
    if (!RegAlloc(graph)) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Failed compiler::RegAlloc";
        return false;
    }

    graph->RunPass<compiler::Cleanup>();
    if (!graph->RunPass<RegEncoder>()) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Failed RegEncoder";
        return false;
    }

    return true;
}

bool DecompileFunction(pandasm::Program *prog, panda::es2panda::parser::Program *parser_program, 
                        BytecodeOptIrInterface *ir_interface,
                        const panda_file::MethodDataAccessor &mda, bool is_dynamic,
                        std::map<uint32_t, LexicalEnvStack*>* method2lexicalenvstack,
                        std::map<uint32_t, LexicalEnvStack*>* method2sendablelexicalenvstack, 
                        std::map<uint32_t, std::string*>* patchvarspace,
                        std::map<size_t, std::vector<std::string>>& index2namespaces, 
                        std::vector<std::string>& localnamespaces,
                        std::map<uint32_t, std::set<uint32_t>> *class2memberfuns,
                        std::map<uint32_t, panda::es2panda::ir::ScriptFunction *> *method2scriptfunast,
                        std::map<uint32_t, panda::es2panda::ir::ClassDeclaration *>* ctor2classdeclast,
                        std::set<uint32_t>* memberfuncs,
                        std::map<uint32_t, panda::es2panda::ir::Expression*> *class2father,
                        std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>> *method2lexicalmap,
                        std::vector<LexicalEnvStack*>* globallexical_waitlist,
                        std::vector<LexicalEnvStack*>* globalsendablelexical_waitlist,
                        std::map<std::string, std::string> *raw2newname,
                        std::map<std::string, uint32_t> *methodname2offset
                        )
{

    ArenaAllocator allocator {SpaceType::SPACE_TYPE_COMPILER};
    ArenaAllocator local_allocator {SpaceType::SPACE_TYPE_COMPILER, nullptr, true};

    SetCompilerOptions();

    auto func_name = ir_interface->GetMethodIdByOffset(mda.GetMethodId().GetOffset() );
    std::cout << std::endl << "[+] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Decompile "  << func_name << " <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< [+]" << std::endl << std::endl;

    auto it = prog->function_table.find(func_name);
    if (it == prog->function_table.end()) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Cannot find function: " << func_name;
        return false;
    }

    LOG(INFO, BYTECODE_OPTIMIZER) << "Optimizing function: " << func_name;

    if(IsInstanceMethod(func_name) && !contains(*memberfuncs, mda.GetMethodId().GetOffset())){
        
        return true;
    }
    
    auto method_ptr = reinterpret_cast<compiler::RuntimeInterface::MethodPtr>(mda.GetMethodId().GetOffset());
    panda::BytecodeOptimizerRuntimeAdapter adapter(mda.GetPandaFile());
    auto graph = allocator.New<compiler::Graph>(&allocator, &local_allocator, Arch::NONE, method_ptr, &adapter, false,
                                                nullptr, is_dynamic, true);
    

    panda::pandasm::Function &function = it->second;

    if (SkipFunction(function, func_name)) {
        return false;
    }


    if ((graph == nullptr) || !graph->RunPass<panda::compiler::IrBuilder>()) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": IR builder failed!";
        std::cout << "Optimizing " << func_name << ": IR builder failed!" << std::endl;
        return false;
    }

    if (graph->HasIrreducibleLoop()) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": Graph has irreducible loop!";
        std::cout << "Optimizing " << func_name << ": Graph has irreducible loop!" << std::endl;
        return false;
    }

    if (!DecompileRunOptimizations(graph, ir_interface)) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": Running optimizations failed!";
        std::cout << "Optimizing " << func_name << ": Running optimizations failed!" << std::endl;
        return false;
    }
    
    std::ofstream dump_out("logs/" + func_name+ ".ir");
    graph->Dump(&dump_out);

    
    if (!graph->RunPass<AstGen>(&function, ir_interface, prog, parser_program, mda.GetMethodId().GetOffset(), method2lexicalenvstack, 
            method2sendablelexicalenvstack,  patchvarspace, std::ref(index2namespaces),
            std::ref(localnamespaces), std::ref(class2memberfuns), std::ref(method2scriptfunast), std::ref(ctor2classdeclast), std::ref(memberfuncs), 
            std::ref(class2father), std::ref(method2lexicalmap), std::ref(globallexical_waitlist), std::ref(globalsendablelexical_waitlist), 
            std::ref(raw2newname), std::ref(methodname2offset),
            RemoveArgumentsOfFunc(func_name))) {

        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": Code generation failed!";

        std::cout << "Decompiling " << func_name << ": Code generation failed!" << std::endl;

        return false;
    }

    std::cout << std::endl << "[-] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Decompile "  << func_name << " <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< [-]" << std::endl << std::endl;

    return true;
}

void LogAst(panda::es2panda::parser::Program *parser_program, std::string outputFileName){
    std::cout << "[+] log raw ast start >>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
    std::string res = parser_program->Dump();
    //std::cout << res << std::endl;
    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
    std::ofstream outputFile(outputFileName);
    if (!outputFile.is_open()) {
        std::cerr << "can't open output file: " << outputFileName << std::endl;
    }else{
        outputFile << res;
        outputFile.close();
    }
    std::cout << "[-] log raw ast end >>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
}

void LogArkTS2File(panda::es2panda::parser::Program *parser_program, std::string outputFileName){
    std::cout << "[+] log arkTS  start >>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
    auto astsgen = panda::es2panda::ir::ArkTSGen(parser_program->Ast());
    
    std::cout << astsgen.Str() << std::endl;
    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
    std::ofstream outputFile(outputFileName);
    if (!outputFile.is_open()) {
        std::cerr << "can't open output file: " << outputFileName << std::endl;
    }else{
        outputFile << astsgen.Str();
        outputFile.close();
    }
    std::cout << "[-] log arkTS  end >>>>>>>>>>>>>>>>>>>>>>>>>>>" << std::endl;
}


int32_t ScanFunDep(pandasm::Program *prog, panda::disasm::Disassembler& disasm,
                BytecodeOptIrInterface *ir_interface,
                std::vector<std::pair<uint32_t, uint32_t>>* depedges,
                std::map<uint32_t, std::set<uint32_t>> *class2memberfuns,
                std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>>* method2lexicalmap,
                std::set<uint32_t>* memberfuncs,
                std::map<std::string, std::string> *raw2newname,
                std::map<std::string, uint32_t> *methodname2offset,
                const panda_file::MethodDataAccessor &mda, bool is_dynamic)
{
    
    ArenaAllocator allocator {SpaceType::SPACE_TYPE_COMPILER};
    ArenaAllocator local_allocator {SpaceType::SPACE_TYPE_COMPILER, nullptr, true};

    SetCompilerOptions();

    auto func_name = ir_interface->GetMethodIdByOffset(mda.GetMethodId().GetOffset() );
    std::cout << ">>>>>>>>>>>>>>>>>>>>>>>>>>>> "  << func_name << " <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<" << std::endl;
    auto it = prog->function_table.find(func_name);
    if (it == prog->function_table.end()) {   
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Cannot find function: " << func_name;
        return 1;
    }

    LOG(INFO, BYTECODE_OPTIMIZER) << "Optimizing function: " << func_name;

    auto method_ptr = reinterpret_cast<compiler::RuntimeInterface::MethodPtr>(mda.GetMethodId().GetOffset());
    
    panda::BytecodeOptimizerRuntimeAdapter adapter(mda.GetPandaFile());
    auto graph = allocator.New<compiler::Graph>(&allocator, &local_allocator, Arch::NONE, method_ptr, &adapter, false,
                                                nullptr, is_dynamic, true);
    

    panda::pandasm::Function &function = it->second;

    if (SkipFunction(function, func_name)) {
        return 2;
    }
    
    if ((graph == nullptr) || !graph->RunPass<panda::compiler::IrBuilder>()) {
        //LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": IR builder failed!";
        std::cout << "Optimizing " << func_name << ": IR builder failed!" << std::endl;
        return 3;
    }

    if (graph->HasIrreducibleLoop()) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": Graph has irreducible loop!";
        std::cout << "Optimizing " << func_name << ": Graph has irreducible loop!" << std::endl;
        return 4;
    }

    if (!DecompileRunOptimizations(graph, ir_interface)) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": Running optimizations failed!";
        std::cout << "Optimizing " << func_name << ": Running optimizations failed!" << std::endl;
        return 5;
    }
    
    if (!graph->RunPass<FunDepScan>(ir_interface, prog, std::ref(disasm), mda.GetMethodId().GetOffset(), depedges, class2memberfuns, method2lexicalmap, memberfuncs, raw2newname, methodname2offset)) {
        LOG(ERROR, BYTECODE_OPTIMIZER) << "Optimizing " << func_name << ": FuncDep scanning failed!";
        std::cout << "FuncDep Scanning " << func_name << ": failed!" << std::endl;
        
        return 6;
    }

    return 0;
}

void ConstructMethodname2offset(panda::disasm::Disassembler& disasm, std::map<std::string, uint32_t> *methodname2offset){
    for (const auto& pair : disasm.method_name_to_id_) {
        std::cout << "##########################################################" << std::endl;
        std::cout << "first: " << pair.first << std::endl;
        std::cout << "second: " << pair.second << std::endl;
        
        std::size_t pos = pair.first.find(':');
        if (pos != std::string::npos) {
            std::string result = RemoveArgumentsOfFunc(pair.first);
            (*methodname2offset)[result] = pair.second.GetOffset();
        }
    }
}

bool DecompilePandaFile(pandasm::Program *prog, BytecodeOptIrInterface *ir_interface,
                       const std::string &pfile_name, panda::disasm::Disassembler& disasm, bool is_dynamic)
{
    auto pfile = panda_file::OpenPandaFile(pfile_name);
    if (!pfile) {
        LOG(FATAL, BYTECODE_OPTIMIZER) << "Can not open binary file: " << pfile_name;
    }


    bool result = true;
    panda::es2panda::parser::Program *parser_program = new panda::es2panda::parser::Program(panda::es2panda::ScriptExtension::TS);
    
    ArenaVector<panda::es2panda::ir::Statement *> program_statements(parser_program->Allocator()->Adapter());
    
    auto program_ast = AllocNode<panda::es2panda::ir::BlockStatement>(parser_program, nullptr, std::move(program_statements));

    parser_program->SetAst(program_ast);

    std::map<uint32_t, LexicalEnvStack*> method2lexicalenvstack;
    std::map<uint32_t, LexicalEnvStack*> method2sendablelexicalenvstack;

    std::map<size_t, std::vector<std::string>> index2importnamespaces; 

    std::map<uint32_t, std::set<uint32_t>> class2memberfuns;
    std::map<uint32_t, panda::es2panda::ir::Expression*> class2father;

    std::map<uint32_t, panda::es2panda::ir::ScriptFunction *> method2scriptfunast;

    std::map<uint32_t, panda::es2panda::ir::ClassDeclaration *> ctor2classdeclast;

    std::set<uint32_t> memberfuncs; // all member functions(all classes)
    
    std::vector<std::string> localnamespaces; 

    std::map<std::string, std::string> raw2newname;

    std::map<uint32_t, std::map<uint32_t,  std::set<size_t>>> method2lexicalmap; // methodoffset, tier, <full index>

    std::vector<LexicalEnvStack*> globallexical_waitlist;

    std::vector<LexicalEnvStack*> globalsendablelexical_waitlist;

    std::map<std::string, uint32_t> methodname2offset;

    ParseModuleVars(pfile, prog, disasm, parser_program, index2importnamespaces, localnamespaces);

    ConstructMethodname2offset(disasm, &methodname2offset);
     
    for (uint32_t id : pfile->GetClasses()) {
        panda_file::File::EntityId record_id {id};
        if (pfile->IsExternal(record_id)) {
            continue;
        }

        panda_file::ClassDataAccessor cda {*pfile, record_id};
        std::cout << "classname: " << std::left << std::setw(40) <<   cda.GetName().data  << " , fileds: " << cda.GetFieldsNumber() << " , method: " << cda.GetMethodsNumber() << " interface: " << cda.GetIfacesNumber() << " superclass: " <<  cda.GetSuperClassId()   << std::endl;
    }
    
    for (uint32_t id : pfile->GetClasses()) {
        
        panda_file::File::EntityId record_id {id};

        if (pfile->IsExternal(record_id)) {
            continue;
        }

        panda_file::ClassDataAccessor cda {*pfile, record_id};
        std::vector<std::pair<uint32_t, uint32_t>> depedges;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::set<uint32_t> skipfailfuns; // skip ir build functions
        bool has_error = false;
        cda.EnumerateMethods([prog, &has_error, &disasm, ir_interface, is_dynamic, &depedges, &class2memberfuns, &method2lexicalmap, &memberfuncs, &raw2newname, &methodname2offset, &skipfailfuns](panda_file::MethodDataAccessor &mda){
            if (!mda.IsExternal()) {
                
                int32_t res = ScanFunDep(prog, disasm, ir_interface, &depedges, &class2memberfuns, &method2lexicalmap, &memberfuncs, &raw2newname, &methodname2offset, mda, is_dynamic);
                if(res == 3 || res == 4){
                    skipfailfuns.insert(mda.GetMethodId().GetOffset());
                    return;
                }

                if(res != 0){
                    has_error = true;
                }

            }
        });
        
        if(has_error){
            return false;
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        auto sorted_methodoffsets = TopologicalSort(depedges);

        std::cout << "@@@ topological order start @@@" << std::endl;
        for(auto methodoffset : sorted_methodoffsets){
            auto res = FindKeyByValue(methodname2offset, methodoffset);
            std::cout << "offset: " << methodoffset << " , name: " << *res << std::endl;
        }
        std::cout << "@@@ topological order end @@@" << std::endl;

        std::map<uint32_t, std::string*> patchvarspace;

        for(const auto & methodoffset : sorted_methodoffsets ){
            panda_file::MethodDataAccessor mda(*pfile, panda_file::File::EntityId(methodoffset));
            
            uint32_t cur_method = mda.GetMethodId().GetOffset();
            if(skipfailfuns.find(cur_method) != skipfailfuns.end()){
                continue;
            }

            result = DecompileFunction(prog, parser_program, ir_interface, mda, is_dynamic, &method2lexicalenvstack, &method2sendablelexicalenvstack, &patchvarspace, index2importnamespaces, localnamespaces, &class2memberfuns, &method2scriptfunast, &ctor2classdeclast, &memberfuncs, &class2father, &method2lexicalmap, &globallexical_waitlist, &globalsendablelexical_waitlist, &raw2newname, &methodname2offset);
            
            if(!result){
                HandleError("#DecompilePandaFile: decomiple case 1 failed!");
            }
        }

        
        cda.EnumerateMethods([prog, parser_program, ir_interface, is_dynamic, &result, &method2lexicalenvstack, &method2sendablelexicalenvstack, &patchvarspace, &index2importnamespaces, &localnamespaces, &class2memberfuns, &method2scriptfunast, &ctor2classdeclast, &memberfuncs, &class2father, &method2lexicalmap, &globallexical_waitlist, &globalsendablelexical_waitlist, &raw2newname, &methodname2offset, sorted_methodoffsets, &skipfailfuns](panda_file::MethodDataAccessor &mda){           
            if (!mda.IsExternal() && std::find(sorted_methodoffsets.begin(), sorted_methodoffsets.end(), mda.GetMethodId().GetOffset()) == sorted_methodoffsets.end() ){
                            uint32_t cur_method = mda.GetMethodId().GetOffset();
                if(skipfailfuns.find(cur_method) != skipfailfuns.end()){
                    
                    return;
                }
                
                result = DecompileFunction(prog, parser_program, ir_interface, mda, is_dynamic, &method2lexicalenvstack, &method2sendablelexicalenvstack, &patchvarspace, index2importnamespaces, localnamespaces, &class2memberfuns, &method2scriptfunast, &ctor2classdeclast, &memberfuncs, &class2father, &method2lexicalmap, &globallexical_waitlist, &globalsendablelexical_waitlist, &raw2newname, &methodname2offset);
                if(!result){
                    HandleError("#DecompilePandaFile: decomiple case 2 failed!");
                }
            }
        });
    } 

    std::cout <<  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB" << std::endl;

    ConstructClasses(class2memberfuns, parser_program, ir_interface, class2father, method2scriptfunast, ctor2classdeclast, raw2newname);

    std::cout <<  "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD" << std::endl;

    for (auto it = method2scriptfunast.begin(); it != method2scriptfunast.end(); ++it) {
        auto funcDecl = AllocNode<panda::es2panda::ir::FunctionDeclaration>(parser_program, it->second);

        program_ast->AddStatementAtPos(program_ast->Statements().size(), funcDecl);
        std::cout << "size:::: "<< program_statements.size() << std::endl;

        //std::cout << it->first << " MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM" << std::endl;
        //LogAst(parser_program, outputAstFileName);
    }

    for (auto it = ctor2classdeclast.begin(); it != ctor2classdeclast.end(); ++it) {
        program_ast->AddStatementAtPos(program_ast->Statements().size(), it->second);
        
        //std::cout << it->first << " MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM" << std::endl;
        //LogAst(parser_program, outputAstFileName);
    }

    //LogAst(parser_program, outputAstFileName);
    LogArkTS2File(parser_program, outputFileName);

    std::cout << "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE" << std::endl;

    return result;
}

void ConstructPandaFile2PandaAsmMaps(panda::disasm::Disassembler& disas, pandasm::AsmEmitter::PandaFileToPandaAsmMaps* maps){
    for (const auto &[offset, name_value] : disas.string_offset_to_name_) {
        maps->strings[offset.GetOffset()] = std::string(name_value);
    }

    for (const auto &[name_value, offset] : disas.method_name_to_id_) {
        maps->methods[offset.GetOffset()] = std::string(name_value);
    }
    
    for (const auto &[name_value, offset] : disas.record_name_to_id_) {
        maps->classes[offset.GetOffset()] = std::string(name_value);
    }


}

bool DecompileBytecode(const std::string &pandafile_name, panda::disasm::Disassembler& disasm, 
                       bool is_dynamic, bool has_memory_pool)
{

    if (!has_memory_pool) {
        PoolManager::Initialize(PoolType::MALLOC);
    }
    
    panda::pandasm::Program* prog = &disasm.prog_;
    pandasm::AsmEmitter::PandaFileToPandaAsmMaps maps;

    ConstructPandaFile2PandaAsmMaps(disasm, &maps);

    auto ir_interface = BytecodeOptIrInterface(&maps, prog);

    auto res = DecompilePandaFile(prog, &ir_interface, pandafile_name, disasm, is_dynamic);
    
    if (!has_memory_pool) {
        PoolManager::Finalize();
    }

    return res;
}


int main(int argc, char* argv[]) {
    
    if (argc > 1) {
        inputFileName = argv[1]; 
    }
    if (argc > 2) {
        outputFileName = argv[2]; 
    }
    
    panda::disasm::Disassembler disasm {};
    disasm.Disassemble(inputFileName, true, false);
    disasm.CollectInfo();
    
    DecompileBytecode(inputFileName, disasm, true, false);
    
    return 0;
}

```