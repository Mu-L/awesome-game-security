Project Path: arc_droidrun_droidrun_hcau710g

Source Tree:

```txt
arc_droidrun_droidrun_hcau710g
‚îú‚îÄ‚îÄ .github
‚îÇ   ‚îî‚îÄ‚îÄ workflows
‚îÇ       ‚îú‚îÄ‚îÄ black.yml
‚îÇ       ‚îú‚îÄ‚îÄ bounty.yml
‚îÇ       ‚îú‚îÄ‚îÄ claude-code-review.yml
‚îÇ       ‚îú‚îÄ‚îÄ claude.yml
‚îÇ       ‚îú‚îÄ‚îÄ docker.yml
‚îÇ       ‚îî‚îÄ‚îÄ publish.yml
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ CHANGELOG.md
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ MANIFEST.in
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ docs
‚îÇ   ‚îú‚îÄ‚îÄ  favicon.svg
‚îÇ   ‚îú‚îÄ‚îÄ custom.css
‚îÇ   ‚îú‚îÄ‚îÄ docs.json
‚îÇ   ‚îú‚îÄ‚îÄ favicon-dark.png
‚îÇ   ‚îú‚îÄ‚îÄ favicon.png
‚îÇ   ‚îú‚îÄ‚îÄ logo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dark.png
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ light.png
‚îÇ   ‚îú‚îÄ‚îÄ v3
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ concepts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ agent.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ android-tools.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ portal-app.mdx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ guides
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cli.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gemini.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ollama.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ openailike.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ overview.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ telemetry.mdx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ images
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ portal_apk.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ overview.mdx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ quickstart.mdx
‚îÇ   ‚îú‚îÄ‚îÄ v4
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ concepts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ architecture.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events-and-workflows.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prompts.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scripter-agent.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ shared-state.mdx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ features
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app-cards.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ credentials.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom-tools.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom-variables.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ structured-output.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ telemetry.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tracing.mdx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ guides
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cli.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ device-setup.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ docker.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migration-v3-to-v4.mdx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ overview.mdx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ overview.mdx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ quickstart.mdx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sdk
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ adb-tools.mdx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ base-tools.mdx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ configuration.mdx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ droid-agent.mdx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ios-tools.mdx
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ reference.mdx
‚îÇ   ‚îî‚îÄ‚îÄ v5
‚îÇ       ‚îú‚îÄ‚îÄ concepts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ architecture.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ events-and-workflows.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ prompts.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ scripter-agent.mdx
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ shared-state.mdx
‚îÇ       ‚îú‚îÄ‚îÄ features
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ app-cards.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ credentials.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ custom-tools.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ custom-variables.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ structured-output.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ telemetry.mdx
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ tracing.mdx
‚îÇ       ‚îú‚îÄ‚îÄ guides
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ cli.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ device-setup.mdx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ docker.mdx
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ overview.mdx
‚îÇ       ‚îú‚îÄ‚îÄ overview.mdx
‚îÇ       ‚îú‚îÄ‚îÄ quickstart.mdx
‚îÇ       ‚îî‚îÄ‚îÄ sdk
‚îÇ           ‚îú‚îÄ‚îÄ adb-tools.mdx
‚îÇ           ‚îú‚îÄ‚îÄ base-tools.mdx
‚îÇ           ‚îú‚îÄ‚îÄ configuration.mdx
‚îÇ           ‚îú‚îÄ‚îÄ droid-agent.mdx
‚îÇ           ‚îú‚îÄ‚îÄ ios-tools.mdx
‚îÇ           ‚îî‚îÄ‚îÄ reference.mdx
‚îú‚îÄ‚îÄ droidrun
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ __main__.py
‚îÇ   ‚îú‚îÄ‚îÄ agent
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ action_context.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ action_result.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ codeact
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ codeact_agent.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tools_agent.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ xml_parser.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constants.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ events.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ droid
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ droid_agent.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ state.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ executor
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ executor_agent.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompts.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ external
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ autoglm.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mai_ui.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager_agent.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prompts.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stateless_manager_agent.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ oneflows
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_starter_workflow.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ structured_output_agent.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ text_manipulator.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scripter
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scripter_agent.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tool_registry.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trajectory
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ writer.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ usage.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ actions.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ chat_utils.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ code_checker.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ executer.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ inference.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ llm_loader.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ llm_picker.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ prompt_resolver.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ signatures.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ tracing_setup.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ trajectory.py
‚îÇ   ‚îú‚îÄ‚îÄ app_cards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_card_provider.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ providers
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ composite_provider.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ local_provider.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ server_provider.py
‚îÇ   ‚îú‚îÄ‚îÄ cli
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ doctor.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event_handler.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logs.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tui
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ app.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ commands.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ css
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ advanced_tab.tcss
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ app.tcss
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ models_tab.tcss
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ settings_screen.tcss
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ settings
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ advanced_tab.py
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ agent_tab.py
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ data.py
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ models_tab.py
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ section.py
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ settings_screen.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ widgets
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ command_dropdown.py
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ device_picker.py
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ input_bar.py
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ log_view.py
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ status_bar.py
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_cards
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_cards.json
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gmail.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ credentials_example.yaml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ codeact
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ system.jinja2
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ tools_system.jinja2
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ tools_user.jinja2
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ user.jinja2
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ executor
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ rev1.jinja2
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ system.jinja2
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ manager
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ rev1.jinja2
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ stateless.jinja2
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ system.jinja2
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ trained.jinja2
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ scripter
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ system.jinja2
‚îÇ   ‚îú‚îÄ‚îÄ config_example.yaml
‚îÇ   ‚îú‚îÄ‚îÄ config_manager
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config_manager.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ env_keys.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loader.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migrations
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ v002_add_code_exec.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ path_resolver.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prompt_loader.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ safe_execution.py
‚îÇ   ‚îú‚îÄ‚îÄ credential_manager
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ credential_manager.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ file_credential_manager.py
‚îÇ   ‚îú‚îÄ‚îÄ log_handlers.py
‚îÇ   ‚îú‚îÄ‚îÄ macro
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __main__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cli.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ replay.py
‚îÇ   ‚îú‚îÄ‚îÄ mcp
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.py
‚îÇ   ‚îú‚îÄ‚îÄ portal.py
‚îÇ   ‚îú‚îÄ‚îÄ telemetry
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ langfuse_processor.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phoenix.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tracker.py
‚îÇ   ‚îî‚îÄ‚îÄ tools
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ android
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ portal_client.py
‚îÇ       ‚îú‚îÄ‚îÄ driver
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ android.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ cloud.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ios.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ recording.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ stealth.py
‚îÇ       ‚îú‚îÄ‚îÄ filters
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ concise_filter.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ detailed_filter.py
‚îÇ       ‚îú‚îÄ‚îÄ formatters
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ indexed_formatter.py
‚îÇ       ‚îú‚îÄ‚îÄ helpers
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ coordinate.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ element_search.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ geometry.py
‚îÇ       ‚îú‚îÄ‚îÄ ios
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ       ‚îî‚îÄ‚îÄ ui
‚îÇ           ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îú‚îÄ‚îÄ ios_provider.py
‚îÇ           ‚îú‚îÄ‚îÄ provider.py
‚îÇ           ‚îú‚îÄ‚îÄ state.py
‚îÇ           ‚îî‚îÄ‚îÄ stealth_state.py
‚îú‚îÄ‚îÄ gen-docs-sdk-ref.sh
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ setup.py
‚îú‚îÄ‚îÄ static
‚îÇ   ‚îú‚îÄ‚îÄ droidrun-dark.png
‚îÇ   ‚îî‚îÄ‚îÄ droidrun.png
‚îî‚îÄ‚îÄ uv.lock

```

`.github/workflows/black.yml`:

```yml
name: Lint

on: [push, pull_request]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v5
        with:
          python-version: "3.13"
      
      - uses: psf/black@stable
        with:
          options: "--check --diff --verbose"
          src: "."
          version: "25.9.0"
```

`.github/workflows/bounty.yml`:

```yml
name: "Project V2: Status ‚Üê issue label"

on:
  issues:
    types: [labeled]

env:
  ORG: droidrun
  PROJECT_NUMBER: 2
  PROJECT_TOKEN: ${{ secrets.BOUNTY_SECRET }}

jobs:
  update_status:
    runs-on: ubuntu-latest
    steps:

      - name: Fetch project & field metadata
        id: metadata
        env:
          GH_TOKEN: ${{ env.PROJECT_TOKEN }}
        run: |
          # 1) Query projectV2 ID and the Status field + its options
          gh api graphql -f query='
            query($org:String!,$num:Int!){
              organization(login:$org){
                projectV2(number:$num){
                  id
                  fields(first:20){
                    nodes{
                      ... on ProjectV2SingleSelectField{
                        id
                        name
                        options { id name }
                      }
                    }
                  }
                }
              }
            }' \
            -f org="${ORG}" -F num=${PROJECT_NUMBER} \
            --jq '
              .data.organization.projectV2 as $p |
              ($p.id) as $projId |
              ($p.fields.nodes[] | select(.name=="Status")) as $f |
              {
                projectId: $projId,
                statusFieldId: $f.id,
                options: ($f.options | map({(.name): .id}) | add)
              }
            ' > meta.json

          # expose to GH env
          echo "PROJECT_ID=$(jq -r .projectId meta.json)" >> $GITHUB_ENV
          echo "STATUS_FIELD_ID=$(jq -r .statusFieldId meta.json)" >> $GITHUB_ENV
          # options is an object like {"Eligible":"ID1","Bounty Posted":"ID2",...}
          echo "STATUS_OPTIONS=$(jq -c .options meta.json)" >> $GITHUB_ENV

      - name: Determine target option ID
        id: pick
        run: |
          LABEL="${{ github.event.label.name }}"
          # map label‚Üí field option name
          case "$LABEL" in
            eligible)      OPT_NAME="üìù Eligible"      ;;
            bounty-official) OPT_NAME="üí∞ Bounty" ;;
            claimed)       OPT_NAME="üõ†Ô∏è In Progress"   ;;
            *) echo "No matching status for $LABEL"; exit 78 ;;
          esac

          # extract from JSON map
          OPT_ID=$(echo "$STATUS_OPTIONS" | jq -r --arg name "$OPT_NAME" '.[$name]')
          echo "OPTION_ID=$OPT_ID" >> $GITHUB_ENV

      - name: Ensure issue is in the project
        id: add_if_missing
        env:
          GH_TOKEN: ${{ env.PROJECT_TOKEN }}
        run: |
          ISSUE_NODE_ID=$(gh api graphql -f query='
          query($owner:String!,$repo:String!,$number:Int!){
            repository(owner:$owner, name:$repo){
              issue(number:$number){
                id
                projectItems(first:1){
                  nodes{ id }
                }
              }
            }
          }' \
          -f owner="droidrun" \
          -f repo="droidrun" \
          -F number=104 \
          --jq '.data.repository.issue as $i |
          { issueId: $i.id,
            itemId: ($i.projectItems.nodes[0]?.id // "") }' )

          # Save to file
          echo "$ISSUE_NODE_ID" > issue.json
          ISSUE_ID=$(jq -r .issueId issue.json)
          ITEM_ID=$(jq -r .itemId issue.json)

          if [ -z "$ITEM_ID" ]; then
            ITEM_ID=$(gh api graphql -f query='
              mutation($proj:ID!,$content:ID!){
                addProjectV2ItemById(input:{projectId:$proj, contentId:$content}){
                  item { id }
                }
              }' \
              -f proj="${PROJECT_ID}" -f content="$ISSUE_ID" \
              --jq '.data.addProjectV2ItemById.item.id')
          fi
          echo "ITEM_ID=$ITEM_ID" >> $GITHUB_ENV

      - name: Update Status field
        env:
          GH_TOKEN: ${{ env.PROJECT_TOKEN }}
        run: |
          gh api graphql -f query='
          mutation($proj:ID!,$item:ID!,$field:ID!,$opt:String!){
            updateProjectV2ItemFieldValue(input:{
              projectId: $proj,
              itemId: $item,
              fieldId: $field,
              value: {
                singleSelectOptionId: $opt
              }
            }) {
              projectV2Item { id }
            }
          }' \
          -f proj="${PROJECT_ID}" \
          -f item="${ITEM_ID}" \
          -f field="${STATUS_FIELD_ID}" \
          -f opt="${OPTION_ID}"

```

`.github/workflows/claude-code-review.yml`:

```yml
name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize]
    # Optional: Only run on specific file changes
    # paths:
    #   - "src/**/*.ts"
    #   - "src/**/*.tsx"
    #   - "src/**/*.js"
    #   - "src/**/*.jsx"

jobs:
  claude-review:
    # Optional: Filter by PR author
    # if: |
    #   github.event.pull_request.user.login == 'external-contributor' ||
    #   github.event.pull_request.user.login == 'new-developer' ||
    #   github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR'

    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            REPO: ${{ github.repository }}
            PR NUMBER: ${{ github.event.pull_request.number }}

            Please review this pull request and provide feedback on:
            - Code quality and best practices
            - Potential bugs or issues
            - Performance considerations
            - Security concerns
            - Test coverage

            Use the repository's CLAUDE.md for guidance on style and conventions. Be constructive and helpful in your feedback.

            Use `gh pr comment` with your Bash tool to leave your review as a comment on the PR.

          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://docs.claude.com/en/docs/claude-code/cli-reference for available options
          claude_args: '--allowed-tools "Bash(gh issue view:*),Bash(gh search:*),Bash(gh issue list:*),Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Bash(gh pr list:*)"'

```

`.github/workflows/claude.yml`:

```yml
name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
      actions: read # Required for Claude to read CI results on PRs
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

          # This is an optional setting that allows Claude to read CI results on PRs
          additional_permissions: |
            actions: read

          # Optional: Give a custom prompt to Claude. If this is not specified, Claude will perform the instructions specified in the comment that tagged it.
          # prompt: 'Update the pull request description to include a summary of changes.'

          # Optional: Add claude_args to customize behavior and configuration
          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://docs.claude.com/en/docs/claude-code/cli-reference for available options
          # claude_args: '--allowed-tools Bash(gh pr:*)'


```

`.github/workflows/docker.yml`:

```yml
name: Publish Docker Image üê≥

on:
  push:
    tags:
      - "v*"

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  push-image:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      - name: Build and push multi-arch Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

```

`.github/workflows/publish.yml`:

```yml
name: Publish Python üêç distribution üì¶ to PyPI and TestPyPI
on: push

jobs:
  version-check:
    name: Check version matches tag
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Compare tag to pyproject.toml version
      run: |
        TAG="${GITHUB_REF#refs/tags/v}"
        VERSION=$(sed -n 's/^version = "\(.*\)"/\1/p' pyproject.toml)
        if [ "$TAG" != "$VERSION" ]; then
          echo "::error::Tag v$TAG does not match pyproject.toml version $VERSION"
          exit 1
        fi
        echo "Version check passed: v$VERSION"

  build:
    name: Build distribution üì¶
    needs:
    - version-check
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        persist-credentials: false
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.x"
    - name: Install pypa/build
      run: >-
        python3 -m
        pip install
        build
        --user
    - name: Build a binary wheel and a source tarball
      run: python3 -m build
    - name: Store the distribution packages
      uses: actions/upload-artifact@v4
      with:
        name: python-package-distributions
        path: dist/

  publish-to-testpypi:
    name: Publish Python üêç distribution üì¶ to TestPyPI
    if: startsWith(github.ref, 'refs/tags/v')
    needs:
    - build
    runs-on: ubuntu-latest
    environment:
      name: testpypi
      url: https://test.pypi.org/p/droidrun
    permissions:
      id-token: write
    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/
    - name: Publish distribution üì¶ to TestPyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        repository-url: https://test.pypi.org/legacy/

  publish-to-pypi:
    name: >-
      Publish Python üêç distribution üì¶ to PyPI
    if: startsWith(github.ref, 'refs/tags/v')
    needs:
    - build
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/droidrun
    permissions:
      id-token: write
    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/
    - name: Publish distribution üì¶ to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1

```

`.gitignore`:

```
dist/
build/
# Python bytecode files
__pycache__/
*.py[cod]
*$py.class
trajectories/
*.class

test.py
test.ipynb
*.log

messages_log.json

.idea
.vscode
.vscode-test
.vscode-test-*
.idea/*
.vscode/*
patch_apis.py
.git
.arize-phoenix

todo.txt

config.yaml

credentials.yaml
**/credentials.yaml
!**/credentials_example.yaml

.*/
!.gitignore
!.github/

backend/
frontend/

reddit_python_posts.json

test/
```

`CHANGELOG.md`:

```md
# Changelog

All notable changes to the Droidrun project will be documented in this file.

## [0.2.0] - 2025-05-21

### Added
- **New LLM Providers**
  - Added support for Ollama (local LLM models)
  - Added support for DeepSeek models
  - Case-sensitive provider names: OpenAI, Anthropic, Gemini, Ollama, DeepSeek

- **Planning System**
  - Added DroidAgent with planning capabilities for complex tasks
  - Introduced task decomposition for multi-step operations

- **LlamaIndex Integration**
  - Replaced custom LLM wrapper with LlamaIndex integration
  - Added direct support for LlamaIndex LLM classes

- **Tracing and Debugging**
  - Added integration with Arize Phoenix for execution tracing
  - Added token usage analysis
  - Added execution time metrics

- **CLI Enhancements**
  - Added `--reasoning` flag to enable planning capabilities
  - Added `--tracing` flag for execution tracing with Phoenix

- **Documentation**
  - Added comprehensive documentation for new features
  - Created dedicated pages for planning and tracing
  - Updated all examples to reflect new API patterns

### Changed
- **Agent Architecture**
  - Replaced ReActAgent with the new DroidAgent system
  - Refactored agent initialization to use tools_instance and tool_list
  - Changed API from `task` parameter to `goal` parameter

### Deprecated
- Old agent initialization pattern with `device_serial` parameter
- Direct LLM provider initialization (replaced by LlamaIndex)
- Non-case-sensitive provider names

### Removed
- ReActAgent class (replaced by DroidAgent)
- LLMReasoner class (replaced by LlamaIndex)
- Some previously documented tools that were not fully implemented

### Fixed
- Various UI interaction issues
- Improved error handling in device connections
- More reliable Android element detection

```

`CONTRIBUTING.md`:

```md
# Contributing to Droidrun

Thank you for your interest in contributing to Droidrun! This document provides guidelines and instructions for contributing to the project.

## Getting Started

1. Fork the repository on GitHub
2. Clone your fork:
   ```bash
   git clone https://github.com/YOUR_USERNAME/droidrun.git
   cd droidrun
   ```
3. Set up your development environment as described below

## Development Setup

1. Create and activate a virtual environment:
   ```bash
   python -m venv .venv
   source .venv/bin/activate  # On Windows: .venv\Scripts\activate
   ```

2. Install development dependencies:
   ```bash
   pip install -e ".[dev]"
   ```

## Making Contributions

1. Create a new branch for your feature:
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. Make your changes following our coding standards:
   - Use type hints for Python functions
   - Follow PEP 8 style guidelines
   - Write descriptive commit messages
   - Update documentation as needed

3. Commit your changes:
   ```bash
   git add .
   git commit -m "feat: add your feature description"
   ```

4. Push to your fork:
   ```bash
   git push origin feature/your-feature-name
   ```

5. Open a Pull Request

## Documentation

- Update the README.md if you change functionality
- Add docstrings to new functions and classes
- Update the documentation in the `docs/` directory

## Community

- Join our [Discord server](https://discord.gg/ZZbKEZZkwK) for discussions
- Follow us on [Twitter/X](https://x.com/droid_run)
- Check our [Documentation](https://docs.droidrun.ai)
- Report bugs and request features through [GitHub Issues](https://github.com/droidrun/droidrun/issues)

## Security Checks

To ensure the security of the codebase, we have integrated security checks using `bandit` and `safety`. These tools help identify potential security issues in the code and dependencies.

### Running Security Checks

Before submitting any code, please run the following security checks:

1. **Bandit**: A tool to find common security issues in Python code.
   ```bash
   bandit -r droidrun
   ```

2. **Safety**: A tool to check your installed dependencies for known security vulnerabilities.
   ```bash
   safety scan
   ```

## Pull Request Process

1. Update documentation for any modified functionality
2. Update the changelog if applicable
3. Get at least one code review from a maintainer
4. Once approved, a maintainer will merge your PR

## Release Process

Releases are handled by the maintainers. Version numbers follow [Semantic Versioning](https://semver.org/).

## Questions?

If you have questions about contributing:
1. Check existing GitHub issues
2. Ask in our Discord server
3. Open a new GitHub issue for complex questions

Thank you for contributing to Droidrun! üöÄ

## Language

English is the preferred language for all contributions, including:
- Code comments
- Documentation
- Commit messages
- Pull requests
- Issue reports
- Community discussions

```

`Dockerfile`:

```
FROM python:3.12-slim

RUN groupadd -g 1000 droidrun \
    && useradd -m -u 1000 -g 1000 -s /bin/bash droidrun

RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    curl \
    android-tools-adb \
    && rm -rf /var/lib/apt/lists/*

USER droidrun

WORKDIR /droidrun

RUN curl -LsSf https://astral.sh/uv/install.sh | sh

ENV PATH="/home/droidrun/.local/bin:${PATH}"

COPY . .

RUN uv venv && \
    uv pip --no-cache-dir install .[google,anthropic,openai,deepseek,ollama,openrouter]

ENTRYPOINT [".venv/bin/droidrun"]

CMD ["setup"]
```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Niels Schmidt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`MANIFEST.in`:

```in
include LICENSE
include README.md
include pyproject.toml

recursive-include droidrun *
recursive-exclude * __pycache__
recursive-exclude * *.py[cod] 
```

`README.md`:

```md
<picture align="center">
  <source media="(prefers-color-scheme: dark)" srcset="./static/droidrun-dark.png">
  <source media="(prefers-color-scheme: light)" srcset="./static/droidrun.png">
  <img src="./static/droidrun.png"  width="full">
</picture>

<div align="center">

[![Docs](https://img.shields.io/badge/Docs-üìï-0D9373?style=for-the-badge)](https://docs.droidrun.ai)
[![Cloud](https://img.shields.io/badge/Cloud-‚òÅÔ∏è-0D9373?style=for-the-badge)](https://cloud.droidrun.ai/sign-in?waitlist=true)


[![GitHub stars](https://img.shields.io/github/stars/droidrun/droidrun?style=social)](https://github.com/droidrun/droidrun/stargazers)
[![droidrun.ai](https://img.shields.io/badge/droidrun.ai-white)](https://droidrun.ai)
[![Twitter Follow](https://img.shields.io/twitter/follow/droid_run?style=social)](https://x.com/droid_run)
[![Discord](https://img.shields.io/discord/1360219330318696488?color=white&label=Discord&logo=discord&logoColor=white)](https://discord.gg/ZZbKEZZkwK)
[![Benchmark](https://img.shields.io/badge/Benchmark-91.4Ôπ™-white)](https://droidrun.ai/benchmark)



<picture>
  <source media="(prefers-color-scheme: dark)" srcset="https://api.producthunt.com/widgets/embed-image/v1/top-post-badge.svg?post_id=983810&theme=dark&period=daily&t=1753948032207">
  <source media="(prefers-color-scheme: light)" srcset="https://api.producthunt.com/widgets/embed-image/v1/top-post-badge.svg?post_id=983810&theme=neutral&period=daily&t=1753948125523">
  <a href="https://www.producthunt.com/products/droidrun-framework-for-mobile-agent?embed=true&utm_source=badge-top-post-badge&utm_medium=badge&utm_source=badge-droidrun" target="_blank"><img src="https://api.producthunt.com/widgets/embed-image/v1/top-post-badge.svg?post_id=983810&theme=neutral&period=daily&t=1753948125523" alt="Droidrun - Give&#0032;AI&#0032;native&#0032;control&#0032;of&#0032;physical&#0032;&#0038;&#0032;virtual&#0032;phones&#0046; | Product Hunt" style="width: 200px; height: 54px;" width="200" height="54" /></a>
</picture>


[Deutsch](https://zdoc.app/de/droidrun/droidrun) | 
[Espa√±ol](https://zdoc.app/es/droidrun/droidrun) | 
[fran√ßais](https://zdoc.app/fr/droidrun/droidrun) | 
[Êó•Êú¨Ë™û](https://zdoc.app/ja/droidrun/droidrun) | 
[ÌïúÍµ≠Ïñ¥](https://zdoc.app/ko/droidrun/droidrun) | 
[Portugu√™s](https://zdoc.app/pt/droidrun/droidrun) | 
[–†—É—Å—Å–∫–∏–π](https://zdoc.app/ru/droidrun/droidrun) | 
[‰∏≠Êñá](https://zdoc.app/zh/droidrun/droidrun)

</div>



DroidRun is a powerful framework for controlling Android and iOS devices through LLM agents. It allows you to automate device interactions using natural language commands. [Checkout our benchmark results](https://droidrun.ai/benchmark)

## Why Droidrun?

- ü§ñ Control Android and iOS devices with natural language commands
- üîÄ Supports multiple LLM providers (OpenAI, Anthropic, Gemini, Ollama, DeepSeek)
- üß† Planning capabilities for complex multi-step tasks
- üíª Easy to use CLI with enhanced debugging features
- üêç Extendable Python API for custom automations
- üì∏ Screenshot analysis for visual understanding of the device
- ü´Ü Execution tracing with Arize Phoenix

## üì¶ Installation

> **Note:** Python 3.14 is not currently supported. Please use Python 3.11 ‚Äì 3.13.

```bash
pip install droidrun
```

## üöÄ Quickstart
Read on how to get droidrun up and running within seconds in [our docs](https://docs.droidrun.ai/v3/quickstart)!   

[![Quickstart Video](https://img.youtube.com/vi/4WT7FXJah2I/0.jpg)](https://www.youtube.com/watch?v=4WT7FXJah2I)

## üé¨ Demo Videos

1. **Accommodation booking**: Let Droidrun search for an apartment for you

   [![Droidrun Accommodation Booking Demo](https://img.youtube.com/vi/VUpCyq1PSXw/0.jpg)](https://youtu.be/VUpCyq1PSXw)

<br>

2. **Trend Hunter**: Let Droidrun hunt down trending posts

   [![Droidrun Trend Hunter Demo](https://img.youtube.com/vi/7V8S2f8PnkQ/0.jpg)](https://youtu.be/7V8S2f8PnkQ)

<br>

3. **Streak Saver**: Let Droidrun save your streak on your favorite language learning app

   [![Droidrun Streak Saver Demo](https://img.youtube.com/vi/B5q2B467HKw/0.jpg)](https://youtu.be/B5q2B467HKw)


## üí° Example Use Cases

- Automated UI testing of mobile applications
- Creating guided workflows for non-technical users
- Automating repetitive tasks on mobile devices
- Remote assistance for less technical users
- Exploring mobile UI with natural language commands

## üë• Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## üìÑ License

This project is licensed under the MIT License - see the LICENSE file for details. 

## Security Checks

To ensure the security of the codebase, we have integrated security checks using `bandit` and `safety`. These tools help identify potential security issues in the code and dependencies.

### Running Security Checks

Before submitting any code, please run the following security checks:

1. **Bandit**: A tool to find common security issues in Python code.
   ```bash
   bandit -r droidrun
   ```

2. **Safety**: A tool to check your installed dependencies for known security vulnerabilities.
   ```bash
   safety scan
   ```

```

`SKILL.md`:

```md
---
name: droidrun-docs
description: DroidRun documentation reference. Use when users ask about DroidRun setup, configuration, SDK usage, CLI commands, device setup, agents, architecture, app cards, credentials, tracing, Docker, migration, structured output, or any DroidRun "how do I..." questions.
---

# DroidRun

DroidRun is an open-source (MIT) framework for controlling Android and iOS devices through LLM agents.
It enables mobile automation using natural language commands.

- **GitHub**: https://github.com/droidrun/droidrun
- **Docs site**: https://docs.droidrun.ai
- **License**: MIT
- **Install**: `uv tool install droidrun` (Google Gemini, OpenAI, Ollama, OpenRouter included by default)
- **Optional extras**: `anthropic`, `deepseek`, `langfuse`
- **Requires**: Python 3.11+, ADB, Portal APK on device

## Architecture

DroidRun uses a multi-agent architecture coordinated by `DroidAgent`:

- **Reasoning mode** (`reasoning=True`): Manager plans ‚Üí Executor acts ‚Üí loop until done
- **Direct mode** (`reasoning=False`): CodeActAgent generates and executes Python code directly

Key agents: ManagerAgent (planning), ExecutorAgent (actions), CodeActAgent (direct execution),
ScripterAgent (off-device computation), StructuredOutputAgent (typed data extraction).

Atomic actions available to agents: `click`, `long_press`, `type`, `system_button`, `swipe`,
`open_app`, `get_state`, `take_screenshot`, `remember`, `complete`.

## Repository Structure

Source code is at `droidrun/` (Python package). Key locations:

| Path | Description |
|------|-------------|
| `droidrun/agent/droid/` | DroidAgent orchestrator |
| `droidrun/agent/codeact/` | CodeActAgent (direct mode) |
| `droidrun/agent/scripter/` | ScripterAgent (off-device scripts) |
| `droidrun/agent/oneflows/` | StructuredOutputAgent |
| `droidrun/agent/utils/` | Tools, executor, tracing, async utils |
| `droidrun/tools/` | Device tools (ADB, iOS, portal client) |
| `droidrun/cli/` | CLI entry point (click-based) |
| `droidrun/config/prompts/` | Jinja2 prompt templates per agent |
| `droidrun/config/app_cards/` | App-specific instruction cards |
| `droidrun/credential_manager/` | YAML-based credential storage |
| `droidrun/telemetry/` | Phoenix tracing integration |

## Documentation

Read the relevant file(s) from `docs/v5/` based on the user's question. Do not guess ‚Äî always
read the doc before answering.

| Topic | File |
|-------|------|
| Overview | docs/v5/overview.mdx |
| Quickstart | docs/v5/quickstart.mdx |
| **Concepts** | |
| Architecture & agents | docs/v5/concepts/architecture.mdx |
| Events & workflows | docs/v5/concepts/events-and-workflows.mdx |
| Prompts | docs/v5/concepts/prompts.mdx |
| Scripter agent | docs/v5/concepts/scripter-agent.mdx |
| Shared state | docs/v5/concepts/shared-state.mdx |
| **Features** | |
| App cards | docs/v5/features/app-cards.mdx |
| Credentials | docs/v5/features/credentials.mdx |
| Custom tools | docs/v5/features/custom-tools.mdx |
| Custom variables | docs/v5/features/custom-variables.mdx |
| Structured output | docs/v5/features/structured-output.mdx |
| Telemetry | docs/v5/features/telemetry.mdx |
| Tracing | docs/v5/features/tracing.mdx |
| **Guides** | |
| CLI usage | docs/v5/guides/cli.mdx |
| Device setup | docs/v5/guides/device-setup.mdx |
| Docker | docs/v5/guides/docker.mdx |
| Migration v3‚Üív4 | docs/v5/guides/migration-v3-to-v4.mdx |
| **SDK** | |
| DroidAgent | docs/v5/sdk/droid-agent.mdx |
| ADB tools | docs/v5/sdk/adb-tools.mdx |
| iOS tools | docs/v5/sdk/ios-tools.mdx |
| Base tools | docs/v5/sdk/base-tools.mdx |
| Configuration | docs/v5/sdk/configuration.mdx |
| API reference | docs/v5/sdk/reference.mdx |

For deeper implementation details, check the source code directly in `droidrun/`.

```

`docs/ favicon.svg`:

```svg
<svg width="447" height="447" viewBox="0 0 447 447" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="447" height="447" fill="black"/>
<path d="M237.275 280.157H169.707L169.72 231.845H237.275V280.157L280.79 235.371C282.498 233.612 283.454 231.257 283.454 228.806V181.088V93.7789C283.454 89.3915 277.983 87.3868 275.148 90.7352L237.275 135.469V181.088H213.44L128.108 280.157V322.5C128.108 325.969 130.92 328.781 134.388 328.781H189.794C192.483 328.781 195.045 327.631 196.833 325.621L237.275 280.157Z" fill="white"/>
<path d="M237.275 328.781H283.454V280.157H237.275V328.781Z" fill="white"/>
</svg>

```

`docs/custom.css`:

```css
/* Custom styles for better layout on large screens */

/* Increase Logo Size */
a[href="https://mobilerun.ai"] {
  height: auto !important;
  max-height: none !important;
}


/* Override Mintlify's max-w-xl on content-area */
#content-area {
  max-width: none !important;
}

/* Increase max-width for main content area on large screens */
@media (min-width: 1280px) {
  #content-area,
  .mdx-content,
  .docs-content,
  .prose {
    max-width: 900px !important;
  }
}

@media (min-width: 1536px) {
  #content-area,
  .mdx-content,
  .docs-content,
  .prose {
    max-width: 1000px !important;
  }
}

@media (min-width: 1920px) {
  #content-area,
  .mdx-content,
  .docs-content,
  .prose {
    max-width: 1200px !important;
  }
}

/* For ultrawide displays (21:9) */
@media (min-width: 2560px) {
  #content-area,
  .mdx-content,
  .docs-content,
  .prose {
    max-width: 1600px !important;
  }
}

/* Adjust the main container to utilize more space */
@media (min-width: 1280px) {
  main {
    max-width: none !important;
  }

  .container {
    max-width: 1400px !important;
  }
}

@media (min-width: 1920px) {
  .container {
    max-width: 1600px !important;
  }
}

@media (min-width: 2560px) {
  .container {
    max-width: 1800px !important;
  }
}

```

`docs/docs.json`:

```json
{
  "$schema": "https://mintlify.com/docs.json",
  "theme": "almond",
  "name": "DroidRun",
  "colors": {
    "primary": "#0D9373",
    "light": "#07C983",
    "dark": "#0D9373"
  },
  "favicon": {
    "light": "/favicon.png",
    "dark": "/favicon-dark.png"
  },
  "icons": {
    "library": "lucide"
  },
  "styles": [
    "/custom.css"
  ],
  "integrations": {
    "posthog": {
      "apiKey": "phc_3BmiVdnS2Wvlm007eHGZLBPwRFCVVWzIZXbB0u3ZH1d",
      "apiHost": "https://pineapple.droidrun.ai"
    }
  },
  "navigation": {
    "versions": [
      {
        "version": "v4",
        "tabs": [
          {
            "tab": "Docs",
            "icon": "book",
            "groups": [
              {
                "group": "Introduction",
                "pages": [
                  "/v4/overview",
                  "/v4/quickstart"
                ]
              },
              {
                "group": "Features",
                "pages": [
                  "/v4/features/structured-output",
                  "/v4/features/credentials",
                  "/v4/features/app-cards",
                  "/v4/features/custom-tools",
                  "/v4/features/custom-variables",
                  "/v4/features/tracing",
                  "/v4/features/telemetry"
                ]
              },
              {
                "group": "Guides",
                "pages": [
                  "/v4/guides/overview",
                  "/v4/guides/device-setup",
                  "/v4/guides/cli",
                  "/v4/guides/docker",
                  "/v4/guides/migration-v3-to-v4"
                ]
              },
              {
                "group": "Concepts",
                "pages": [
                  "/v4/concepts/architecture",
                  "/v4/concepts/scripter-agent",
                  "/v4/concepts/shared-state",
                  "/v4/concepts/events-and-workflows",
                  "/v4/concepts/prompts"
                ]
              },
              {
                "group": "SDK Reference",
                "pages": [
                  "/v4/sdk/reference",
                  "/v4/sdk/droid-agent",
                  "/v4/sdk/adb-tools",
                  "/v4/sdk/ios-tools",
                  "/v4/sdk/base-tools",
                  "/v4/sdk/configuration"
                ]
              }
            ]
          },
          {
            "tab": "Cloud",
            "icon": "cloud",
            "href": "https://docs.mobilerun.ai"
          },
          {
            "tab": "GitHub",
            "icon": "github",
            "href": "https://github.com/droidrun/droidrun"
          }
        ]
      },
      {
        "version": "v5",
        "tabs": [
          {
            "tab": "Docs",
            "icon": "book",
            "groups": [
              {
                "group": "Introduction",
                "pages": [
                  "/v5/overview",
                  "/v5/quickstart"
                ]
              },
              {
                "group": "Features",
                "pages": [
                  "/v5/features/structured-output",
                  "/v5/features/credentials",
                  "/v5/features/app-cards",
                  "/v5/features/custom-tools",
                  "/v5/features/custom-variables",
                  "/v5/features/tracing",
                  "/v5/features/telemetry"
                ]
              },
              {
                "group": "Guides",
                "pages": [
                  "/v5/guides/overview",
                  "/v5/guides/device-setup",
                  "/v5/guides/cli",
                  "/v5/guides/docker"
                ]
              },
              {
                "group": "Concepts",
                "pages": [
                  "/v5/concepts/architecture",
                  "/v5/concepts/scripter-agent",
                  "/v5/concepts/shared-state",
                  "/v5/concepts/events-and-workflows",
                  "/v5/concepts/prompts"
                ]
              },
              {
                "group": "SDK Reference",
                "pages": [
                  "/v5/sdk/reference",
                  "/v5/sdk/droid-agent",
                  "/v5/sdk/adb-tools",
                  "/v5/sdk/ios-tools",
                  "/v5/sdk/base-tools",
                  "/v5/sdk/configuration"
                ]
              }
            ]
          },
          {
            "tab": "Cloud",
            "icon": "cloud",
            "href": "https://docs.mobilerun.ai"
          },
          {
            "tab": "GitHub",
            "icon": "github",
            "href": "https://github.com/droidrun/droidrun"
          }
        ]
      },
      {
        "version": "v3",
        "tabs": [
          {
            "tab": "Docs",
            "icon": "book",
            "groups": [
              {
                "group": "Introduction",
                "pages": [
                  "/v3/overview",
                  "/v3/quickstart"
                ]
              },
              {
                "group": "Guides",
                "pages": [
                  "/v3/guides/overview",
                  "/v3/guides/cli",
                  "/v3/guides/telemetry",
                  "/v3/guides/openailike",
                  "/v3/guides/ollama",
                  "/v3/guides/gemini"
                ]
              },
              {
                "group": "Concepts",
                "pages": [
                  "/v3/concepts/agent",
                  "/v3/concepts/portal-app",
                  "/v3/concepts/models",
                  "/v3/concepts/android-tools"
                ]
              }
            ]
          },
          {
            "tab": "Cloud",
            "icon": "cloud",
            "href": "https://docs.mobilerun.ai"
          },
          {
            "tab": "GitHub",
            "icon": "github",
            "href": "https://github.com/droidrun/droidrun"
          }
        ]
      }
    ]
  },
  "logo": {
    "light": "/logo/light.png",
    "dark": "/logo/dark.png",
    "href": "https://droidrun.ai"
  },
  "navbar": {
    "primary": {
      "type": "button",
      "label": "Join Discord",
      "href": "https://discord.gg/gdekvkJFvn"
    }
  },
  "footer": {
    "socials": {
      "github": "https://github.com/droidrun/droidrun",
      "x": "https://x.com/droid_run",
      "discord": "https://discord.gg/gdekvkJFvn",
      "website": "https://droidrun.ai"
    }
  },
  "errors": {
    "404": {
      "redirect": false
    }
  }
}

```

`docs/v3/concepts/agent.mdx`:

```mdx
---
title: 'Agent & Execution Modes'
description: 'Understanding the DroidAgent system in DroidRun'
---


## Configuration

```python
# The parameters for the DroidAgent
def __init__(
    self, 
    goal: str,                                  # The goal for the agent to reach
    llm: LLM,                                   # Language model to use
    tools: Tools,                               # Loaded tools
    personas: List[AgentPersona] = [DEFAULT],   # Experimental: custom system prompt for agent
    max_steps: int = 15,                        # Maximum steps the agent takes
    timeout: int = 1000,                        # Global Timeout
    vision: bool = False,                       # Whether the agent shall also utilize screenshots
    reasoning: bool = False,                    # Enable reasoning
    reflection: bool = False,                   # Enable reflection
    enable_tracing: bool = False,               # Enable tracing (this requires arize phoenix)
    debug: bool = False,                        # Enable additional debug logs
    save_trajectories: str = "none",            # Trajectory saving level: "none" (no saving), "step" (save per step), "action" (save per action)
    *args,
    **kwargs
)
```

## Execution Modes

The agent operates in three distinct modes, each optimized for different complexity levels and use cases.

### Direct Execution
<div style={{display: 'flex', gap: '8px', marginBottom: '16px'}}>
  <span style={{background: 'rgba(107, 114, 128, 0.2)', color: '#6b7280', padding: '4px 8px', borderRadius: '8px', fontSize: '12px', fontWeight: 'bold'}}>REASONING: LOW</span>
  <span style={{background: 'rgba(13, 147, 115, 0.2)', color: '#0D9373', padding: '4px 8px', borderRadius: '8px', fontSize: '12px', fontWeight: 'bold'}}>SPEED: HIGH</span>
</div>

```python
# Simple tasks
agent = DroidAgent(
    goal="Take a screenshot of the current screen",
    llm=llm,
    tools=tools,
    reasoning=False
)
```
**Flow:** Goal ‚Üí Direct Execution ‚Üí Result

**Best Practices:**
- Use for single-action tasks (1-15 steps)
- Keep goals specific and atomic
- Faster execution with no planning overhead

### Planning Mode
<div style={{display: 'flex', gap: '8px', marginBottom: '16px'}}>
  <span style={{background: 'rgba(217, 119, 6, 0.2)', color: '#d97706', padding: '4px 8px', borderRadius: '8px', fontSize: '12px', fontWeight: 'bold'}}>REASONING: MEDIUM</span>
  <span style={{background: 'rgba(217, 119, 6, 0.2)', color: '#d97706', padding: '4px 8px', borderRadius: '8px', fontSize: '12px', fontWeight: 'bold'}}>SPEED: MEDIUM</span>
</div>

```python
# Multi-step tasks requiring navigation and decision-making
agent = DroidAgent(
    goal="Set up a new alarm for 7 AM with custom ringtone and label 'Work'",
    llm=llm,
    tools=tools,
    reasoning=True
)
```
**Flow:** Goal ‚Üí Planning ‚Üí Step-by-step Execution ‚Üí Result

**Best Practices:**
- Use for multi-step tasks (15-50 steps)
- Ideal for navigation between apps/screens
- Good for tasks requiring step-by-step breakdown


### Reflection Mode
<div style={{display: 'flex', gap: '8px', marginBottom: '16px'}}>
  <span style={{background: 'rgba(13, 147, 115, 0.2)', color: '#0D9373', padding: '4px 8px', borderRadius: '8px', fontSize: '12px', fontWeight: 'bold'}}>REASONING: HIGH</span>
  <span style={{background: 'rgba(107, 114, 128, 0.2)', color: '#6b7280', padding: '4px 8px', borderRadius: '8px', fontSize: '12px', fontWeight: 'bold'}}>SPEED: LOW</span>
</div>

```python
# Complex, multi-app workflows requiring verification and adaptive planning
agent = DroidAgent(
    goal="Find the cheapest hotel in Manhattan for next weekend, compare prices across multiple booking apps, and share the best option with my team on Slack",
    llm=llm,
    tools=tools,
    reasoning=True,
    reflection=True
)
```
<Warning>Reflection is based on screenshots. Use it alongside an LLM model with vision capabilities (e.g., GPT-4o, Gemini-2.5-Flash etc.).</Warning>
**Flow:** Goal ‚Üí Planning ‚Üí Execution ‚Üí Reflection ‚Üí Re-planning (if needed) ‚Üí Result

**Best Practice:**
- Use for complex workflows (50+ steps)
- Essential for quality control and verification
- Best when context preservation is critical

## Vision capabilities
<Warning>Vision capabilities are deactivated for the DeepSeek provider and require an LLM model with vision capabilities (e.g., GPT-4o, Gemini-2.5-Flash etc.).</Warning>

By default, DroidAgent operates entirely without vision by leveraging Android's Accessibility API to extract the UI hierarchy as XML. This approach is efficient and works well for most automation tasks.

However, enabling vision capabilities allows the agent to take screenshots and visually analyze the device screen, which can be beneficial in specific scenarios:
```python
# To enable vision capabilities, set `vision=True` in your agent configuration. 
agent = DroidAgent(
    goal="Open up TikTok and describe the content of the video you are seeing",
    llm=llm,
    tools=tools,
    vision=True
)
```


- **Content-heavy applications**: When apps contain complex visual elements, images, or layouts that aren't fully captured by the XML hierarchy
- **Visual verification**: For tasks requiring confirmation of visual elements or layouts
- **Enhanced context understanding**: When UI structure alone doesn't provide sufficient information for decision-making


```

`docs/v3/concepts/android-tools.mdx`:

```mdx
---
title: 'Android Control'
description: 'Learn how to control Android devices in DroidRun using the comprehensive tools API.
Tools provide the bridge between your AI agents and Android devices, enabling UI interaction, app management, and state analysis. Use tools directly or through DroidAgent for automated Android testing and control.'
---

```python
from droidrun import DroidAgent, AdbTools

# Load tools for a device
tools = AdbTools(serial="device_serial")

# Create agent with tools
agent = DroidAgent(
    goal="Your task",
    llm=llm,
    tools=tools
)
```

## UI Interaction Tools

**`tap_by_index(index: int) -> str`**  
Tap on a UI element by its index from cached elements. Must call `get_state()` first.

**`swipe(start_x: int, start_y: int, end_x: int, end_y: int, duration_ms: int = 300) -> bool`**  
Perform swipe gesture. For long press, use same start/end coordinates with longer duration.

**`input_text(text: str) -> str`**  
Input text into focused element. Supports special characters and non-ASCII text.

**`press_key(keycode: int) -> str`**  
Press Android keys using keycodes. Common: HOME (3), BACK (4), ENTER (66), DELETE (67).

**`back() -> str`**  
Convenience method to press the Android back button.

```python
# UI interaction examples
await tools.get_state()  # Cache elements first
await tools.tap_by_index(2)  # Tap element
await tools.swipe(500, 200, 500, 800, 400)  # Swipe down
await tools.input_text("Hello, World!")
await tools.press_key(66)  # Enter key
await tools.back()
```

## App Management Tools

**`start_app(package: str, activity: str = "") -> str`**  
Start application by package name and optional activity.

**`list_packages(include_system_apps: bool = False) -> List[str]`**  
List installed packages. Optionally include system apps.

**`install_app(apk_path: str, reinstall: bool = False, grant_permissions: bool = True) -> str`**  
Install APK file with optional reinstall and permission granting.

```python
# App management examples
await tools.start_app("com.android.settings")
packages = await tools.list_packages()
all_packages = await tools.list_packages(include_system_apps=True)
await tools.install_app("/path/to/app.apk", reinstall=True)
```

## State Analysis Tools

**`get_state(serial: Optional[str] = None) -> Dict[str, Any]`**  
Get comprehensive device state including accessibility tree and phone state. Caches UI elements.

**`take_screenshot() -> Tuple[str, bytes]`**  
Capture device screen and return format and image data. Stores screenshots for GIF creation.

```python
# State analysis examples
state = await tools.get_state()
a11y_tree = state["a11y_tree"]
phone_state = state["phone_state"]

format, image_data = await tools.take_screenshot()
```

## Quick Reference

| Function | Purpose | Returns |
|----------|---------|---------|
| `tap_by_index(index)` | Tap UI element by index | Status message |
| `swipe(x1, y1, x2, y2, duration)` | Swipe gesture | Success boolean |
| `input_text(text)` | Type text | Status message |
| `press_key(keycode)` | Press Android key | Status message |
| `back()` | Press back button | Status message |
| `start_app(package, activity)` | Launch application | Status message |
| `list_packages(include_system)` | List installed apps | Package list |
| `install_app(path, reinstall, permissions)` | Install APK | Status message |
| `get_state(serial)` | Get device state | State dictionary |
| `take_screenshot()` | Capture screen | Format and image data |
| `remember(info)` | Store information | Confirmation message |
| `get_memory()` | Retrieve stored info | Memory list |
| `complete(success, reason)` | Finish task | None |

## Dive Deeper
SDK reference documentation is available in the v4 documentation.
```

`docs/v3/concepts/models.mdx`:

```mdx
---
title: 'Supported Models'
description: 'DroidRun is **LLM agnostic**, which means you can use every LLM provider there is.

Under the hood, DroidRun leverages [LlamaIndex LLM providers](https://docs.llamaindex.ai/en/stable/api_reference/llms/) to provide seamless integration with all major language model providers. This means you can easily switch between different providers or use multiple providers simultaneously depending on your needs.
'
---

## Install LLM Provider
```bash
# Install the package for your preferred LLM Provider
pip install llama-index-llms-[PROVIDER]
```

## Supported Providers

DroidRun supports all major LLM providers through LlamaIndex, including but not limited to:

- **OpenAI** (GPT-4o, GPT-o3, etc.)
- **Anthropic** (Claude models)
- **GoogleGenAI** (Gemini)
- **OpenAILike** (OpenAI-compatible APIs such as OpenRouter, Azure OpenAI, local LM Studio)
- **DeepSeek** (DeepSeek LLM integrations)
- **Azure OpenAI Service**
- **AWS Bedrock**
- **Cohere**
- **Hugging Face**
- **Local models** (Ollama, vLLM, etc.)
- And many more...

This flexibility allows you to choose the best model for your specific use case, budget, and performance requirements while maintaining the same DroidRun interface across all providers.

```

`docs/v3/concepts/portal-app.mdx`:

```mdx
---
title: 'Android Portal APK'
description: 'The DroidRun Portal App is a critical component of the DroidRun framework that runs directly on your Android device. It acts as a bridge between the DroidRun framework running on your computer and the Android operating system.'
---

<img src="../images/portal_apk.png" alt="DroidRun Portal App" width="300" />




## What is the DroidRun Portal App?

The DroidRun Portal App is an Android application that:

1. Extracts the current UI state of your Android device
2. Communicates this information to the DroidRun framework via ADB
3. Executes commands sent from the DroidRun framework
4. Provides visual feedback about identified UI elements

## How It Works

The Portal App utilizes [Android's Accessibility Services](https://developer.android.com/reference/android/accessibilityservice/AccessibilityService) to:

- Monitor UI changes on your device
- Identify interactive elements (buttons, text fields, etc.)
- Extract text, element positions, and other UI metadata

This information is communicated to the DroidRun framework running on your computer via ADB (Android Debug Bridge), allowing the LLM agent to understand what's on the screen and make informed decisions about how to complete tasks.

### Element Highlighting

You can enable/disable visual highlighting of detected UI elements:

- **Rectangle Overlay**: Draws colored rectangles around UI elements
- **Element Labels**: Shows element IDs or descriptions

These visual indicators help you understand:
- Which elements DroidRun can "see"
- How elements are being categorized
- What information is being sent to the LLM agent


## Privacy and Security

The DroidRun Portal App:

- Only communicates with the DroidRun framework via ADB
- Does not send data to any external servers
- Only activates when being used by the DroidRun framework
- Can be easily disabled through Android settings when not in use

## Installation

The DroidRun Portal App is available from the [DroidRun Portal repository](https://github.com/droidrun/droidrun-portal). For installation instructions, see the [Quickstart](/v3/quickstart) guide.

```

`docs/v3/guides/cli.mdx`:

```mdx
---
title: CLI Usage
---

# DroidRun CLI Guide: Using OpenAILike, Ollama, and Gemini Providers

DroidRun lets you control Android devices using natural language and LLM agents. This guide explains how to use the CLI with three popular LLM providers: **OpenAILike**, **Ollama**, and **Gemini**.

---

## Prerequisites

<Steps>
    <Step title="Install DroidRun and its dependencies. Choose which ever provider you'd like to use.">
       ```sh 
       pip install 'droidrun[google,anthropic,openai,deepseek,ollama,dev]'
       ```
    </Step>
    <Step title="Ensure your Android device is connected and the DroidRun Portal is installed">
       Download & Install the Droidrun Portal APK     
       ```sh 
       droidrun setup
       ```   

       Check if everything is set up correctly  
       ```sh
       droidrun ping
       ```
    </Step>
    <Step title="If you want to use a provider thats not included with our extras, install the required LlamaIndex LLM integrations">
      ```sh
      pip install llama-index-llms-openrouter
      ```
    </Step>
</Steps>
---

## General CLI Usage

The main command to run is:

```sh
droidrun run "<your natural language command>" [OPTIONS]
```

Key options:
- `--provider/-p`: LLM provider (`OpenAILike`, `Ollama`, `GoogleGenAI`, etc.)
- `--model/-m`: Model name (varies by provider)
- `--base_url/-u`: Base URL for API (for Ollama/OpenAILike)
- `--api_base`: API base URL (for OpenAI/OpenAILike)
- `--temperature`: LLM temperature (default: 0.2)
- `--vision`: Enable screenshot-based vision (flag)
- `--reasoning`: Enable planning with reasoning (flag)
- `--reflection`: Enable reflection step (flag)
- `--tracing`: Enable tracing (flag)
- `--debug`: Verbose logging (flag)

---

## Provider specific examples 
Here you can see a bunch of provider specific droidrun cli usage examples

<Expandable title="Using the OpenAILike Provider"> 
### Using the **OpenAILike** Provider

OpenAILike is for OpenAI-compatible APIs (e.g., OpenRouter, local OpenAI-compatible servers).

**Required Arguments:**
- `--provider OpenAILike`
- `--model <model-name>` (e.g., `gpt-3.5-turbo`)
- `--api_base <API endpoint>` (e.g., `https://openrouter.ai/api/v1`)

**Example:**
```sh
export OPENAI_API_KEY=<your-api-key>
droidrun run \
  --provider OpenAILike \
  --model qwen/qwen2.5-vl-72b-instruct:free \
  --api_base https://openrouter.ai/api/v1 \
  "Open the settings app"
```
</Expandable>
<Expandable title="Using the Ollama Provider">
### Using the **Ollama** Provider

Ollama is for running open-source models locally via the [Ollama server](https://ollama.com/).

**Required Arguments:**
- `--provider Ollama`
- `--model <model-name>` (e.g., `llama4`, `gemma3`)
- `--base_url <Ollama server URL>` (default: `http://localhost:11434`)

**Example:**
```sh
droidrun run \
  --provider Ollama \
  --model qwen2.5vl:3b \
  --base_url http://localhost:11434 \
  "Open the settings app"
```

No API key is required for local Ollama by default.
</Expandable>
<Expandable title="Using the Gemini Provider">
### Using the **Gemini** Provider

Gemini uses Google's Gemini models via the GoogleGenAI provider.

**Required Arguments:**
- `--provider GoogleGenAI`
- `--model <model-name>` (e.g., `gemini-2.5-flash`)
- Google API credentials (set `GOOGLE_API_KEY` env var or pass as CLI option)

**Example:**
```sh
export GOOGLE_API_KEY=<your-google-api-key>
droidrun run \
  --provider GoogleGenAI \
  --model gemini-2.5-flash \
  "Open the settings app" 
```
</Expandable>
<Expandable title="Using the DeepSeek Provider">
### Using the **DeepSeek** Provider

DeepSeek is a powerful LLM provider that can be used with DroidRun for natural language Android automation.

**Required Arguments:**
- `--provider DeepSeek`
- `--model <model-name>` (e.g., `deepseek-chat`, `deepseek-coder`, `deepseek-moe`, etc.)
- DeepSeek API credentials (set `DEEPSEEK_API_KEY` env var or pass as CLI option)

<Warning>Vision capabilities are not supported with DeepSeek models. Do not use the `--vision` flag.</Warning>

**Example:**
```sh
export DEEPSEEK_API_KEY=<your-deepseek-api-key>
droidrun run \
  --provider DeepSeek \
  --model deepseek-chat \
  "Open the settings app"
```
</Expandable>

## Additional Tips

- Use `droidrun devices` to list connected devices.
- Use `--vision` to enable screenshot-based vision for more complex tasks.
- Use `--debug` for detailed logs if troubleshooting.
- For iOS, add `--ios` and specify the device URL.

---

## Troubleshooting

- **No devices found:** Ensure your device is connected and authorized for ADB.
- **Provider errors:** Check that you have installed the correct LlamaIndex integration and set the required API keys.
- **Model not found:** Double-check the model name for your provider.

---

## References

- [DroidRun GitHub](https://github.com/droidrun/droidrun)
- [LlamaIndex Docs](https://docs.llamaindex.ai/)
- [Ollama](https://ollama.com/)
- [Google Gemini](https://ai.google.dev/)

---

**Happy automating!**

```

`docs/v3/guides/gemini.mdx`:

```mdx
---
title: Using Droidrun with Gemini
---

This guide explains how to use the Droidrun framework with [Gemini](https://ai.google.dev/gemini-api/docs/), Google's family of advanced large language models. By integrating Gemini with Droidrun, you can leverage powerful cloud-based LLMs to automate Android devices, build intelligent agents, and experiment with advanced workflows.

## What is Gemini?

Gemini is a suite of state-of-the-art language models developed by Google, available via the Gemini API. It supports text, code, and multimodal (vision) capabilities, and is accessible through a simple HTTP API.

## Why Use Gemini with Droidrun?

- **Accuracy:** Access to Google's latest, high-quality LLMs.
- **Multimodal:** Supports both text and vision (image) inputs.
- **Scalability:** Cloud-based, no local hardware requirements.

## Prerequisites

- **Google Cloud account** with access to the Gemini API.
- **Python 3.10+**
- **droidrun** framework installed (see [Droidrun Quickstart](../quickstart.mdx)).
<Warning>
Make sure you've set up and enabled the Droidrun Portal.
</Warning>


## 1. Set Up Gemini API Access

1. Go to the [Gemini API Console](https://ai.google.dev/gemini-api/docs/get-api-key) and create an API key.
2. Save your API key securely. You will use it in your Python code.

## 2. Install Required Python Packages

```sh
pip install droidrun
```

GoogleGenAI is included by default.

## 3. Example: Using Droidrun with Gemini LLM

Here is a minimal example of using Droidrun with Gemini as the LLM backend:

```python
import asyncio
from llama_index.llms.google_genai import GoogleGenAI
from droidrun import DroidAgent, AdbTools

async def main():
    # load adb tools for the first connected device
    tools = AdbTools()

    # Set up the Gemini LLM
    llm = GoogleGenAI(
        api_key="YOUR_GEMINI_API_KEY",  # Replace with your Gemini API key
        model="gemini-2.5-flash",       # or "gemini-2.5-pro" for enhanced reasoning
    )

    # Create the DroidAgent
    agent = DroidAgent(
        goal="Open Settings and check battery level",
        llms=llm,
        tools=tools,
        # vision=True,        # Optional: enable if using multimodal models
        # reasoning=False,    # Optional: enable planning/reasoning
    )

    # Run the agent
    result = await agent.run()
    print(f"Success: {result['success']}")
    if result.get('output'):
        print(f"Output: {result['output']}")

if __name__ == "__main__":
    asyncio.run(main())
```

## 4. Troubleshooting

- **Invalid API key:** Double-check your Gemini API key and permissions.
- **Model not found:** Use the correct model name, e.g., `"gemini-2.5-flash"` or `"gemini-2.5-pro"`.
- **Quota exceeded:** Check your Google Cloud usage and quotas.
- **Connection errors:** Ensure your network allows outbound HTTPS requests to the Gemini API.

## 5. Tips

- For advanced configuration, see the [DroidAgent documentation](../concepts/agent) and [Gemini API docs](https://ai.google.dev/gemini-api/docs/).
- Store your API key securely (e.g., use environment variables or a secrets manager).

---

With this setup, you can harness the power of Google's Gemini models for Android automation and agent-based workflows using Droidrun!

```

`docs/v3/guides/ollama.mdx`:

```mdx
---
title: Using Droidrun with Ollama
---

This guide explains how to use the Droidrun framework with [Ollama](https://ollama.com/), an open-source platform for running large language models (LLMs) locally. By integrating Ollama with Droidrun, you can leverage powerful local LLMs to automate Android devices, build intelligent agents, and experiment with advanced workflows.

## What is Ollama?

Ollama lets you run, manage, and interact with LLMs on your own machine. It supports a variety of modern models (e.g., Qwen2.5vl, Gemma3, DeepSeek, Llama 4, etc.) and provides a simple HTTP API for integration.

## Why Use Ollama with Droidrun?

- **Privacy:** Run LLMs locally without sending data to the cloud.
- **Performance:** Low-latency inference on your own hardware.
- **Flexibility:** Choose and switch between different models easily.
- **Cost:** No API usage fees.

## Prerequisites

- **Ollama** installed and running on your machine ([installation guide](https://ollama.com/download)).
- **Python 3.10+**
- **droidrun** framework installed (see [Droidrun Quickstart](../quickstart.mdx)).
<Warning>
Make sure you've set up and enabled the Droidrun Portal.
</Warning>


## 1. Install and Start Ollama

Download and install Ollama from the [official website](https://ollama.com/download). Once installed, start the Ollama server:

```sh
ollama serve
```

Pull a modern model you want to use (e.g., Qwen2.5vl, Gemma3, DeepSeek, Llama 4):

```sh
ollama pull qwen2.5vl
ollama pull gemma3
ollama pull deepseek-r1 # no vision capabilities. can only be used with vision disabled
ollama pull llama4
```

## 2. Install Required Python Packages

Make sure you have the required Python packages:

```sh
pip install droidrun
```

Ollama is included by default.

## 3. Example: Using Droidrun with Ollama LLM

Here is a minimal example of using Droidrun with Ollama as the LLM backend (using a modern model, e.g., Qwen2.5vl):

```python
import asyncio
from llama_index.llms.ollama import Ollama
from droidrun import DroidAgent, AdbTools

async def main():
    # load adb tools for the first connected device
    tools = AdbTools()

    # Set up the Ollama LLM with a modern model
    llm = Ollama(
        model="qwen2.5vl",                  # or "gemma3", "deepseek", "llama4", etc.
        base_url="http://localhost:11434",  # default Ollama endpoint
        context_window=8192,                # limit the max context window to prevent running out of memory. 
        request_timeout=120.0               # increase the request timeout
    )

    # Create the DroidAgent
    agent = DroidAgent(
        goal="Open Settings and check battery level",
        llm=llm,
        tools=tools,
        vision=False,         # Optional: enable vision. use vision=True only in conjunction with a vision model
        reasoning=True,       # Optional: enable planning/reasoning. Read more about the agent configuration in Core-Concepts/Agent
    )

    # Run the agent
    result = await agent.run()
    print(f"Success: {result['success']}")
    if result.get('output'):
        print(f"Output: {result['output']}")

if __name__ == "__main__":
    asyncio.run(main())
```

<Note>Limiting the llm's context_window reduces memory usage, but degrades the agent's performance too. For the best results try extending it as much as possible.</Note>

## 4. Troubleshooting

- **Ollama not running:** Make sure `ollama serve` is running and accessible at `http://localhost:11434`.
- **Model not found:** Ensure you have pulled the desired model with `ollama pull <model>`.
- **Connection errors:** Check firewall settings and that the endpoint URL is correct.
- **Timeout:** If Ollama is running behind a proxy like Cloudflare, make sure the request timeout is configured high enough
- **Performance:** Some models require significant RAM/CPU. Try smaller models if you encounter issues.
- **Compatibility:** Vision models do not run correctly on apple silicon chips. Check [issue #55 (droidrun)](https://github.com/droidrun/droidrun/issues/55#issuecomment-2959912711), [issue @ ollama](https://github.com/ollama/ollama/issues/10986)

## 5. Tips

- You can switch models by changing the `model` parameter in the `Ollama` constructor.
- Explore different models available via `ollama list`.
- For advanced configuration, see the [DroidAgent documentation](../concepts/agent) and [Ollama API docs](https://github.com/jmorganca/ollama/blob/main/docs/README.md).

---

With this setup, you can harness the power of local, state-of-the-art LLMs for Android automation and agent-based workflows using Droidrun and Ollama!

```

`docs/v3/guides/openailike.mdx`:

```mdx
---
title: Using Droidrun with OpenAI-like
---

This guide explains how to use the Droidrun framework with OpenAI-compatible APIs (such as OpenAI, Azure OpenAI, OpenRouter, LM Studio, etc.). By integrating these LLMs with Droidrun, you can automate Android devices, build intelligent agents, and experiment with advanced workflows using any OpenAI-like endpoint.

## What is OpenAI-like?

"OpenAI-like" refers to any API that implements the OpenAI REST API standard. This includes:
- **OpenAI** (api.openai.com)
- **Azure OpenAI**
- **OpenRouter** (https://openrouter.ai)
- **LM Studio** (local, https://lmstudio.ai)
- **Other local or cloud endpoints** that mimic the OpenAI API

## Why Use OpenAI-like with Droidrun?

- **Flexibility:** Use cloud or local LLMs interchangeably.
- **Wide Model Support:** Access GPT-3.5, GPT-4, and many community models.
- **Easy Integration:** Droidrun supports OpenAI-compatible LLMs out of the box.

## Prerequisites

- **Python 3.10+**
- **An API key** for your chosen provider (e.g., OpenAI, OpenRouter, Azure, or local server)
- **droidrun** framework installed (see [Droidrun Quickstart](../quickstart))
<Warning>
Make sure you've set up and enabled the Droidrun Portal.
</Warning>


## 1. Set Up Your API Key

Get your API key for the provider you've choosen

## 2. Install the required Python packages:

```sh
pip install droidrun
```

OpenAI and OpenAI-like providers are included by default.

## 3. Example: Using Droidrun with OpenAI-like LLM

Here is a minimal example of using Droidrun with an OpenAI-compatible LLM backend:

```python
import asyncio
from llama_index.llms.openai_like import OpenAILike
from droidrun import DroidAgent, AdbTools

async def main():
    # Load adb tools for the first connected device
    tools = AdbTools()

    # Set up the OpenAI-like LLM (uses env vars for API key and base by default)
    llm = OpenAILike(
        model="gpt-3.5-turbo",  # or "gpt-4o", "gpt-4", etc.
        api_base="http://localhost:1234/v1",  # For local endpoints
        is_chat_model=True, # droidrun requires chat model support
        api_key="YOUR API KEY"
    )

    # Create the DroidAgent
    agent = DroidAgent(
        goal="Open Settings and check battery level",
        llm=llm,
        tools=tools,
        vision=False,        # Set to True if your model supports vision
        reasoning=False,     # Optional: enable planning/reasoning
    )

    # Run the agent
    result = await agent.run()
    print(f"Success: {result['success']}")
    if result.get('output'):
        print(f"Output: {result['output']}")

if __name__ == "__main__":
    asyncio.run(main())
```

### Tips for Local and Alternative Endpoints

- **OpenRouter:** Set `api_base` to `https://openrouter.ai/api/v1` and use your OpenRouter API key.
- **LM Studio:** Set `api_base` to your local server URL (e.g., `http://localhost:1234/v1`).
- **Azure OpenAI:** Use the Azure-specific API base and deployment name as the model.
- **Custom headers:** Some endpoints require extra headers; see their docs.

## 4. Troubleshooting

- **Authentication errors:** Double-check your API key and endpoint.
- **Model not found:** Ensure the model name matches what your provider supports.
- **Connection errors:** If using a local server, make sure it is running and accessible.
- **Vision:** Most OpenAI-like endpoints do not support image input. Set `vision=False` unless you know your model supports it.

## 5. Further Reading

- [OpenRouter Docs](https://openrouter.ai/docs)
- [LM Studio Docs](https://lmstudio.ai/docs)
- [llama-index OpenAI Like LLM Docs](https://docs.llamaindex.ai/en/stable/api_reference/llms/openai_like/)

---

With this setup, you can use any OpenAI-compatible LLM for Android automation and agent-based workflows using Droidrun!

```

`docs/v3/guides/overview.mdx`:

```mdx
---
title: Overview
---

Welcome to the DroidRun Guides! Here you'll find step-by-step instructions and best practices for using DroidRun with different LLM providers, configuring telemetry, and more. Each guide is designed to help you get the most out of DroidRun, whether you're just getting started or looking to leverage advanced features.

---

## [CLI Usage Guide](./cli)
Learn how to control Android devices using natural language and LLM agents via the DroidRun command-line interface. This guide covers:
- Installing DroidRun and dependencies
- Connecting your Android device
- Using the CLI with different LLM providers (OpenAILike, Ollama, Gemini)
- Key CLI options and flags
- Troubleshooting common issues

---

## [Using DroidRun with Gemini](./gemini)
Learn to use DroidRun with [Gemini](https://ai.google.dev/gemini-api/docs/), Google's advanced cloud-based LLMs. This guide covers:
- What Gemini is and its capabilities
- Setting up Gemini API access
- Installing required Python packages
- Example: Automating Android with Gemini
- Troubleshooting and advanced configuration tips

---

## [Using DroidRun with OpenAILike](./openailike)
Learn to use DroidRun with OpenAILike-compatible LLMs (such as OpenAI's GPT models and compatible APIs). This guide covers:
- What OpenAILike means and supported providers
- Setting up API keys and access
- Installing required Python packages
- Example: Automating Android with OpenAILike LLMs
- Troubleshooting and advanced configuration tips

---

## [Using DroidRun with Ollama](./ollama)
Discover how to integrate DroidRun with [Ollama](https://ollama.com/), an open-source platform for running large language models locally. This guide explains:
- What Ollama is and why use it
- Setting up Ollama and pulling models
- Installing required Python packages
- Example: Automating Android with local LLMs
- Troubleshooting and tips for best performance

---

## [Telemetry Guide](./telemetry.mdx)
Understand how DroidRun uses anonymized telemetry to improve the framework. This guide explains:
- Why telemetry is important
- What data is (and isn't) collected
- How to disable or enable telemetry
- Our commitment to privacy

---

Need more help? Check out the [Quickstart](../quickstart) or [Core Concepts](../concepts/agent) for deeper dives into DroidRun's architecture and features.

```

`docs/v3/guides/telemetry.mdx`:

```mdx
# Why We Need Telemetry

Telemetry helps us:
- Identify which features are most used and need improvement
- Prioritize bug fixes and new features based on real usage
- Ensure DroidRun works well across different environments

<b>We do not collect any personal or sensitive data.</b> All telemetry is strictly anonymized and used only to improve the framework for everyone.

If you have questions or concerns, please reach out on [GitHub](https://github.com/droidrun/droidrun) or review our privacy policy.

---

# Toggling Telemetry

DroidRun collects <b>anonymized</b> usage data to help us understand which features are most valuable and where improvements are needed. This data is <b>never</b> used for advertising or tracking individuals, and is only used to make DroidRun better for the community.

## How to Disable Telemetry

You can disable telemetry at any time by setting the following environment variable:

```bash
export DROIDRUN_TELEMETRY_ENABLED=false
```

Add this line to your shell profile (e.g., `.bashrc`, `.zshrc`, or `.profile`) to make it persistent across sessions.

## How to Enable Telemetry Again

To re-enable telemetry, set the environment variable to `true`:

```bash
export DROIDRUN_TELEMETRY_ENABLED=true
```

Or simply remove the variable from your environment to use the default (enabled) behavior.

```

`docs/v3/overview.mdx`:

```mdx
---
title: 'Overview'
description: 'DroidRun is a powerful framework that enables you to control Android devices through an LLM agent.
It provides a simple and intuitive way to automate Android device interactions using natural language commands.'
---

<CardGroup cols={2}>
  <Card title="Quickstart" icon="rocket" href="/v3/quickstart">
    Get up and running with DroidRun in minutes
  </Card>
    <Card title="Guides" icon="code" href="/v3/guides">
   View Templates for example Use Cases
  </Card>
  <Card title="Agent Settings" icon="robot" href="/v3/concepts/agent">
   See Configurations you can take for to the agent
  </Card>
    <Card title="Supported LLMs" icon="brain" href="/v3/concepts/models">
   Supported Models that are supported with Droidrun
  </Card>
</CardGroup>

## Core Concepts

DroidRun empowers you to automate sophisticated mobile workflows through intelligent agent control. Whether you're handling simple data extraction tasks or orchestrating complex multi-app interactions, DroidRun provides the flexibility and power you need.

**You can leverage DroidRun in two ways:**

<CardGroup cols={2}>
<Card icon="mobile" title="Physical Device" href="/v3/quickstart" arrow>
 - Connect your own physical Android device for direct automation
</Card>
<Card icon="cloud" title="Cloud Environment" href="https://cloud.droidrun.ai">
 - Access our managed cloud environment for instant mobile app automation without any setup.
</Card>
</CardGroup>

```

`docs/v3/quickstart.mdx`:

```mdx
---
title: 'Quickstart'
description: 'Get up and running with DroidRun quickly and effectively'
---

<iframe
  className="w-full aspect-video rounded-xl"
  src="https://www.youtube.com/embed/4WT7FXJah2I"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
></iframe>

This guide will help you get DroidRun installed and running quickly, controlling your Android device through natural language in minutes.

### Prerequisites

Before installing DroidRun, ensure you have:

1. **Python 3.10+** installed on your system
2. [Android Debug Bridge (adb)](https://developer.android.com/studio/releases/platform-tools) installed and configured
3. **Android device** with:
   - [Developer options enabled](https://developer.android.com/studio/debug/dev-options)
   - USB debugging enabled
   - Connected via USB or on the same network (for wireless debugging)

### Install from PyPI
Choose which ever provider you'd like to use. If you encounter dependency resolution issues use [`uv`](https://docs.astral.sh/uv/getting-started/installation/).
```bash
pip install 'droidrun[google,anthropic,openai,deepseek,ollama,dev]'
```

### Setup the Portal APK
```bash
droidrun setup
```

### Test functionality
```bash
droidrun ping
```

### Run Your First Command via CLI

```bash
export OPENAI_API_KEY=<YOUR API KEY>
droidrun "Open the settings app and tell me the android version" --provider OpenAI --model gpt-4o
```

### Create a Simple Agent via Script

For complex automation, create a Python script:

```python
#!/usr/bin/env python3
import asyncio
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    # Load tools
    tools = AdbTools()
    # set up google gemini llm
    llm = GoogleGenAI(
        api_key="YOUR_GEMINI_API_KEY",  # Replace with your Gemini API key
        model="gemini-2.5-flash",  # or "gemini-2.5-pro" for enhanced reasoning
    )
    
    # Create agent
    agent = DroidAgent(
        goal="Open Settings and check battery level",
        llm=llm,
        tools=tools
    )
    
    # Run agent
    result = await agent.run()
    print(f"Success: {result['success']}")
    if result.get('output'):
        print(f"Output: {result['output']}")

if __name__ == "__main__":
    asyncio.run(main())
```


## Next Steps

Now that you've got DroidRun running, you can:

- Learn about the [Agent](/v3/concepts/agent)
- See supported [LLM providers](/v3/concepts/models)
- Discover [Android interactions](/v3/concepts/android-tools)
- Learn about the [Portal App](/v3/concepts/portal-app) 

```

`docs/v4/concepts/architecture.mdx`:

```mdx
---
title: 'Architecture'
description: 'Understanding the Droidrun multi-agent system for device automation.'
---

## What is Droidrun?

Droidrun uses a **multi-agent architecture** where specialized agents work together to complete tasks. Instead of one agent doing everything, different agents handle planning, execution, and computation.

```
DroidAgent (orchestrator)
‚îú‚îÄ‚îÄ Reasoning Mode: ManagerAgent ‚Üí ExecutorAgent ‚Üí ScripterAgent
‚îî‚îÄ‚îÄ Direct Mode: CodeActAgent
```

## Execution Modes

### Reasoning Mode (`reasoning=True`)
Manager creates plans, Executor takes actions. Best for complex multi-step tasks.

```
Goal ‚Üí Manager (plan) ‚Üí Executor (action) ‚Üí Manager (check) ‚Üí Executor (next) ‚Üí ...
```

### Direct Mode (`reasoning=False`)
CodeActAgent executes immediately without planning overhead. Best for simple tasks.

```
Goal ‚Üí CodeActAgent (generate + execute) ‚Üí Done
```

## Core Agents

### DroidAgent (Orchestrator)
Main coordinator that routes between agents based on mode.

**Location**: `droidrun/agent/droid/droid_agent.py`

### ManagerAgent (Planner)
Creates strategic plans and breaks tasks into subgoals. Reasoning mode only.

**Location**: `droidrun/agent/manager/manager_agent.py`

**Workflow**: `prepare_context()` ‚Üí `get_response()` ‚Üí `process_response()` ‚Üí `finalize()`

### ExecutorAgent (Actor)
Executes atomic actions for each subgoal. Reasoning mode only.

**Location**: `droidrun/agent/executor/executor_agent.py`

**Workflow**: `prepare_context()` ‚Üí `get_response()` ‚Üí `process_response()` ‚Üí `execute()` ‚Üí `finalize()`

### CodeActAgent (Direct Executor)
Generates Python code using atomic actions. Direct mode only.

**Location**: `droidrun/agent/codeact/codeact_agent.py`

**Available Actions**:
```python
click(index), long_press(index), type(text, index),
swipe(coordinate, coordinate2), system_button(button),
wait(duration), open_app(text), get_state(), take_screenshot(),
remember(information), complete(success, reason)
```

### ScripterAgent (Off-Device)
Executes Python for API calls, file operations, and computations. Triggered by Manager when needed.

**Location**: `droidrun/agent/scripter/`

## Configuration

Configure different LLMs per agent:

```yaml
llm_profiles:
  manager:
    provider: Anthropic
    model: claude-sonnet-4
  executor:
    provider: OpenAI
    model: gpt-4o
  codeact:
    provider: GoogleGenAI
    model: models/gemini-2.0-flash-exp
  scripter:
    provider: OpenAI
    model: gpt-4o

agent:
  reasoning: true       # Enable Manager/Executor workflow
  max_steps: 15         # Maximum execution steps (global)
  manager:
    vision: true        # Send screenshots to Manager
  executor:
    vision: true        # Send screenshots to Executor
  codeact:
    vision: false
    safe_execution: false
  scripter:
    max_steps: 10       # Scripter-specific max steps
    safe_execution: false
```

## When to Use Each Mode

**Use Reasoning Mode for:**
- Multi-step tasks (booking flights, configuring settings)
- Tasks requiring planning and adaptation
- Complex workflows across multiple apps

**Use Direct Mode for:**
- Simple actions (screenshots, sending messages)
- Fast execution without planning overhead
- Well-defined single-step tasks

## Shared State

All agents share `DroidAgentState` for coordination:
- Action history and outcomes
- Error tracking and recovery
- Memory and context
- Scripter results
- Current plan and progress

## Quick Reference

| Agent | Role | Best For | Mode | Config Key |
|-------|------|----------|------|------------|
| DroidAgent | Orchestrator | Entry point | Both | `agent.*` |
| ManagerAgent | Planner | Strategy, recovery | Reasoning | `agent.manager.*` |
| ExecutorAgent | Actor | Action execution | Reasoning | `agent.executor.*` |
| CodeActAgent | Direct | Simple tasks | Direct | `agent.codeact.*` |
| ScripterAgent | Python Executor | APIs, files, data | Reasoning | `agent.scripter.*` |

```

`docs/v4/concepts/events-and-workflows.mdx`:

```mdx
---
title: "Event Streaming"
description: "How to consume real-time events from DroidAgent execution."
---

## Overview

DroidRun provides **real-time event streaming** that gives you visibility into agent execution as it happens. This allows you to build UIs, logging systems, or monitoring tools that react to agent actions in real-time.

Under the hood, DroidRun uses [llama-index workflows](https://docs.llamaindex.ai/en/stable/understanding/workflows/) - an event-driven orchestration system that powers the agent architecture.

## Basic Usage

```python
from droidrun.agent.droid import DroidAgent

# Create and run agent
agent = DroidAgent(goal="Open Gmail and check inbox", config=config)
handler = agent.run()

# Stream events in real-time
async for event in handler.stream_events():
    if isinstance(event, ManagerPlanDetailsEvent):
        print(f"üìã Plan: {event.plan}")
        print(f"üéØ Current subgoal: {event.current_subgoal}")

    elif isinstance(event, ExecutorActionEvent):
        print(f"‚ö° Action: {event.description}")
        print(f"üí≠ Thought: {event.thought}")

    elif isinstance(event, ScreenshotEvent):
        save_screenshot(event.screenshot, "screenshot.png")

    elif isinstance(event, TaskThinkingEvent):
        print(f"üêç Generated code:")
        if event.code:
            print(event.code)
        if event.thoughts:
            print(f"üí≠ Thoughts: {event.thoughts}")

# Wait for final result
result = await handler
print(f"‚úÖ Success: {result.success}")
print(f"üìù Reason: {result.reason}")
```

## Event Types

<AccordionGroup>
  <Accordion title="Workflow Coordination Events">
Used for workflow coordination between DroidAgent and its child agents.

```python
# Main workflow
class CodeActExecuteEvent(Event):
    instruction: str

class CodeActResultEvent(Event):
    success: bool
    reason: str
    instruction: str

class FinalizeEvent(Event):
    success: bool
    reason: str

class ResultEvent(StopEvent):
    success: bool
    reason: str
    steps: int
    structured_output: BaseModel | None

# Manager/Executor coordination
class ManagerInputEvent(Event): pass
class ManagerPlanEvent(Event):
    plan: str
    current_subgoal: str
    thought: str
    manager_answer: str
    success: bool | None

class ExecutorInputEvent(Event):
    current_subgoal: str

class ExecutorResultEvent(Event):
    action: Dict
    outcome: bool
    error: str
    summary: str
    full_response: str

# Scripter coordination
class ScripterExecutorInputEvent(Event):
    task: str

class ScripterExecutorResultEvent(Event):
    task: str
    message: str
    success: bool
    code_executions: int

# Text manipulation
class TextManipulatorInputEvent(Event):
    task: str

class TextManipulatorResultEvent(Event):
    task: str
    text_to_type: str
    code_ran: str
```
  </Accordion>

  <Accordion title="Manager Events (Internal)">
Internal to ManagerAgent, streamed to frontend/logging.

```python
class ManagerContextEvent(Event): pass

class ManagerResponseEvent(Event):
    output_planning: str
    usage: Optional[UsageResult]

class ManagerPlanDetailsEvent(Event):
    plan: str
    current_subgoal: str
    thought: str
    manager_answer: str
    memory_update: str
    success: bool | None
    full_response: str
```
  </Accordion>

  <Accordion title="Executor Events (Internal)">
Internal to ExecutorAgent, streamed to frontend/logging.

```python
class ExecutorContextEvent(Event):
    messages: list
    subgoal: str

class ExecutorResponseEvent(Event):
    response_text: str
    usage: Optional[UsageResult]

class ExecutorActionEvent(Event):
    action_json: str
    thought: str
    description: str
    full_response: str

class ExecutorActionResultEvent(Event):
    action: Dict
    outcome: bool
    error: str
    summary: str
    thought: str
    action_json: str
    full_response: str
```
  </Accordion>

  <Accordion title="CodeAct Events (Internal)">
Internal to CodeActAgent, used in direct execution mode.

```python
class TaskInputEvent(Event):
    input: list[ChatMessage]

class TaskThinkingEvent(Event):
    thoughts: Optional[str]
    code: Optional[str]
    usage: Optional[UsageResult]

class TaskExecutionEvent(Event):
    code: str
    globals: dict[str, str] = {}
    locals: dict[str, str] = {}

class TaskExecutionResultEvent(Event):
    output: str

class TaskEndEvent(Event):
    success: bool
    reason: str
```
  </Accordion>

  <Accordion title="Scripter Events (Internal)">
Internal to ScripterAgent, for off-device script execution.

```python
class ScripterInputEvent(Event):
    input: List

class ScripterThinkingEvent(Event):
    thoughts: str
    code: Optional[str]
    full_response: str
    usage: Optional[UsageResult]

class ScripterExecutionEvent(Event):
    code: str

class ScripterExecutionResultEvent(Event):
    output: str

class ScripterEndEvent(Event):
    message: str
    success: bool
    code_executions: int
```
  </Accordion>

  <Accordion title="Action Recording Events">
Emitted when actions are performed, used for macro recording and trajectory tracking.

```python
class MacroEvent(Event):  # Base class
    action_type: str
    description: str

class TapActionEvent(MacroEvent):
    x: int
    y: int
    element_index: int = None
    element_text: str = ""
    element_bounds: str = ""

class SwipeActionEvent(MacroEvent):
    start_x: int
    start_y: int
    end_x: int
    end_y: int
    duration_ms: int

class DragActionEvent(MacroEvent):
    start_x: int
    start_y: int
    end_x: int
    end_y: int
    duration_ms: int

class InputTextActionEvent(MacroEvent):
    text: str

class KeyPressActionEvent(MacroEvent):
    keycode: int
    key_name: str = ""

class StartAppEvent(MacroEvent):
    package: str
    activity: str = None

class WaitEvent(MacroEvent):
    duration: float
```
  </Accordion>

  <Accordion title="Visual & Telemetry Events">
```python
# Visual events
class ScreenshotEvent(Event):
    screenshot: bytes

class RecordUIStateEvent(Event):
    ui_state: list[Dict[str, Any]]

# Telemetry events (when enabled)
class DroidAgentInitEvent(TelemetryEvent):
    goal: str
    llms: Dict[str, str]
    tools: str
    max_steps: int
    timeout: int
    vision: Dict[str, bool]
    reasoning: bool
    enable_tracing: bool
    debug: bool
    save_trajectories: str
    runtype: str
    custom_prompts: Optional[Dict[str, str]]

class PackageVisitEvent(TelemetryEvent):
    package_name: str
    activity_name: str
    step_number: int

class DroidAgentFinalizeEvent(TelemetryEvent):
    success: bool
    reason: str
    steps: int
    unique_packages_count: int
    unique_activities_count: int

# Usage tracking
class UsageResult(BaseModel):
    request_tokens: int
    response_tokens: int
    total_tokens: int
    requests: int
```
  </Accordion>
</AccordionGroup>

## Common Patterns

### Building a Live UI

```python
async def run_with_ui(goal: str):
    agent = DroidAgent(goal=goal, config=config)
    handler = agent.run()

    async for event in handler.stream_events():
        if isinstance(event, ManagerPlanDetailsEvent):
            ui.update_plan(event.plan)
            ui.update_current_step(event.current_subgoal)

        elif isinstance(event, ExecutorActionEvent):
            ui.add_action_log(event.description, event.thought)

        elif isinstance(event, ScreenshotEvent):
            ui.update_screenshot(event.screenshot)

    result = await handler
    ui.show_completion(result.success, result.reason)
```

### Tracking Token Usage

```python
async def track_token_usage(goal: str):
    agent = DroidAgent(goal=goal, config=config)
    handler = agent.run()

    total_tokens = 0
    total_requests = 0

    async for event in handler.stream_events():
        # Check for events that contain usage information
        if hasattr(event, 'usage') and event.usage:
            total_tokens += event.usage.total_tokens
            total_requests += event.usage.requests

            print(f"LLM call - Input: {event.usage.request_tokens}, "
                  f"Output: {event.usage.response_tokens}, "
                  f"Total: {event.usage.total_tokens}")

    result = await handler
    print(f"\nüìä Total tokens used: {total_tokens}")
    print(f"üìä Total LLM requests: {total_requests}")
```

### Logging and Monitoring

```python
import logging

logger = logging.getLogger("droidrun.monitor")

async def monitor_execution(goal: str):
    agent = DroidAgent(goal=goal, config=config)
    handler = agent.run()

    start_time = time.time()
    action_count = 0

    async for event in handler.stream_events():
        if isinstance(event, ExecutorActionEvent):
            action_count += 1
            logger.info(f"Action {action_count}: {event.description}")

        elif isinstance(event, TaskExecutionResultEvent):
            logger.info(f"Code execution result: {event.output}")

    result = await handler
    duration = time.time() - start_time

    logger.info(f"Task completed in {duration:.2f}s with {action_count} actions")
    logger.info(f"Result: {result.success} - {result.reason}")
```

## Notes

### Event Streaming Behavior

- Events are **streamed in real-time** as the agent executes
- Not all events are emitted in every execution (depends on mode and actions)
- All events are **Pydantic models** with full type safety
- The `handler` object is **async** - always use `await handler` to get the final result

### Event Emission by Mode

**Reasoning Mode** (`reasoning=True`) emits:
- Coordination: `ManagerInputEvent`, `ManagerPlanEvent`, `ExecutorInputEvent`, `ExecutorResultEvent`
- Internal Manager: `ManagerContextEvent`, `ManagerResponseEvent`, `ManagerPlanDetailsEvent`
- Internal Executor: `ExecutorContextEvent`, `ExecutorResponseEvent`, `ExecutorActionEvent`, `ExecutorActionResultEvent`
- Actions: All action recording events (`TapActionEvent`, `SwipeActionEvent`, etc.)
- Visual: `ScreenshotEvent`, `RecordUIStateEvent` (when enabled)

**Direct Mode** (`reasoning=False`) emits:
- Coordination: `CodeActExecuteEvent`, `CodeActResultEvent`
- Internal CodeAct: `TaskInputEvent`, `TaskThinkingEvent`, `TaskExecutionEvent`, `TaskExecutionResultEvent`, `TaskEndEvent`
- Actions: All action recording events
- Visual: `ScreenshotEvent`, `RecordUIStateEvent` (when enabled)

**ScripterAgent** (when triggered by `<script>` tags) emits:
- Coordination: `ScripterExecutorInputEvent`, `ScripterExecutorResultEvent`
- Internal Scripter: `ScripterInputEvent`, `ScripterThinkingEvent`, `ScripterExecutionEvent`, `ScripterExecutionResultEvent`, `ScripterEndEvent`

**All Modes** emit:
- Finalization: `FinalizeEvent`, `ResultEvent`
- Telemetry: `DroidAgentInitEvent`, `PackageVisitEvent`, `DroidAgentFinalizeEvent` (when telemetry enabled)

### Event Categories

**Coordination Events** - Used for workflow routing between agents (minimal data)
- Located in `droidrun/agent/droid/events.py`
- Examples: `ManagerPlanEvent`, `ExecutorResultEvent`, `ScripterExecutorResultEvent`

**Internal Events** - Used for streaming to frontend/logging (full debug data)
- Located in agent-specific event files
- Examples: `ManagerPlanDetailsEvent`, `ExecutorActionEvent`, `TaskThinkingEvent`

**Action Recording Events** - Emitted when actions are performed (for macros/trajectories)
- Located in `droidrun/agent/common/events.py`
- Examples: `TapActionEvent`, `SwipeActionEvent`, `InputTextActionEvent`

**Telemetry Events** - Captured for analytics (when enabled)
- Located in `droidrun/telemetry/events.py`
- Examples: `DroidAgentInitEvent`, `PackageVisitEvent`, `DroidAgentFinalizeEvent`

## Learn More

- [LlamaIndex Workflows](https://docs.llamaindex.ai/en/stable/understanding/workflows/) - The underlying orchestration system

```

`docs/v4/concepts/prompts.mdx`:

```mdx
---
title: 'Prompt Templates'
description: 'Customizing agent behavior with Jinja2 prompt templates.'
---

## Overview

Droidrun uses **Jinja2 templates** for agent prompts. You can customize agent behavior by passing custom template strings to `DroidAgent`:

```python
custom_prompts = {
    "manager_system": "Your Jinja2 template here...",
    "executor_system": "Another template...",
    "codeact_system": "...",
    "codeact_user": "...",
    "scripter_system": "..."
}

agent = DroidAgent(
    goal="Send an email",
    config=config,
    prompts=custom_prompts  # Pass template strings, not file paths
)
```

**Important**: The `prompts` parameter accepts Jinja2 **template strings**, not file paths.

## How It Works

1. `DroidAgent` creates a `PromptResolver` with your custom prompts
2. Each agent checks if you provided a custom template for its key (e.g., "manager_system")
3. If found: uses your custom template
4. If not found: loads the default template from Droidrun's built-in files
5. Templates are rendered with context variables specific to each agent

## Available Prompt Keys

| Key | Agent | When Used |
|-----|-------|-----------|
| `manager_system` | Manager | Planning and reasoning (only in reasoning mode) |
| `executor_system` | Executor | Action selection (only in reasoning mode) |
| `codeact_system` | CodeAct | Direct execution (always used) |
| `codeact_user` | CodeAct | Task input formatting (always used) |
| `scripter_system` | Scripter | Off-device Python execution (when enabled) |

## Context Variables

Each agent has access to different variables in its templates:

### Manager

- `instruction` - User's goal
- `device_date` - Current device date/time
- `app_card` - App-specific guidance (empty if none available)
- `error_history` - List of recent failed actions with details
- `custom_tools_descriptions` - Custom tool documentation
- `scripter_execution_enabled` - Whether Scripter is available
- `available_secrets` - Available credential IDs
- `variables` - Custom variables passed to DroidAgent
- `output_schema` - Pydantic model schema (if provided)

### Executor

- `instruction` - User's goal
- `device_state` - Current UI tree
- `subgoal` - Current subgoal from Manager
- `atomic_actions` - Available actions (includes custom tools)
- `action_history` - Recent actions with outcomes

### CodeAct

**System prompt:**
- `tool_descriptions` - Available tool signatures
- `available_secrets` - Credential IDs
- `variables` - Custom variables
- `output_schema` - Output model schema (if provided)

**User prompt:**
- `goal` - Task description
- `variables` - Custom variables

### Scripter

- `task` - Task description from Manager
- `available_secrets` - Credential IDs
- `variables` - Custom variables

## Example: Custom Manager Prompt

```python
custom_prompts = {
    "manager_system": """
You are a mobile automation planning agent.

Task: {{ instruction }}
Date: {{ device_date }}

{% if app_card %}
App guidance:
{{ app_card }}
{% endif %}

{% if error_history %}
Recent errors (you may be stuck):
{% for error in error_history %}
- Action: {{ error.action }}
  Error: {{ error.error }}
{% endfor %}
{% endif %}

{% if custom_tools_descriptions %}
Custom tools:
{{ custom_tools_descriptions }}
{% endif %}

{% if variables.domain %}
Domain: {{ variables.domain }}
{% endif %}

Output format:
<thought>Your reasoning</thought>
<plan>
1. First step
2. Second step
3. DONE
</plan>

Or if complete:
<request_accomplished>
Task is done. Answer: ...
</request_accomplished>
"""
}

agent = DroidAgent(
    goal="Send an email",
    config=config,
    prompts=custom_prompts,
    variables={"domain": "finance"}
)
```

## Example: Using Custom Variables

Custom variables let you inject dynamic context into prompts:

```python
custom_prompts = {
    "manager_system": """
Task: {{ instruction }}

{% if variables.budget %}
Budget limit: ${{ variables.budget }}
{% endif %}

{% if variables.priority %}
Priority: {{ variables.priority }}
{% endif %}

Guidelines:
{% for rule in variables.rules %}
- {{ rule }}
{% endfor %}
"""
}

agent = DroidAgent(
    goal="Buy a phone",
    config=config,
    prompts=custom_prompts,
    variables={
        "budget": 1000,
        "priority": "high",
        "rules": ["Check reviews", "Compare prices", "Use coupons"]
    }
)
```

## Jinja2 Syntax Reference

### Variables

```jinja2
{{ instruction }}
{{ variables.my_var }}
```

### Conditionals

```jinja2
{% if app_card %}
<app_card>{{ app_card }}</app_card>
{% endif %}

{% if error_history %}
You have {{ error_history | length }} errors
{% endif %}
```

### Loops

```jinja2
{% for error in error_history %}
- {{ error.action }}: {{ error.error }}
{% endfor %}
```

### Filters

```jinja2
{{ instruction | upper }}
{{ available_secrets | join(', ') }}
{{ error_history | length }}
```

## Best Practices

### 1. Use Clear Structure

```jinja2
<instruction>
{{ instruction }}
</instruction>

<guidelines>
1. Rule one
2. Rule two
</guidelines>

<output_format>
Expected format
</output_format>
```

### 2. Handle Missing Data with Conditionals

```jinja2
{% if app_card %}
<app_card>{{ app_card }}</app_card>
{% else %}
<note>No app-specific guidance available</note>
{% endif %}
```

### 3. Document Expected Variables

```jinja2
{# Expected variables:
   - instruction: str - User's goal
   - device_date: str - Current date/time
   - app_card: str - App guidance (may be empty)
#}
```

### 4. Use Variables for Dynamic Behavior

```jinja2
{% if variables.strict_mode %}
<strict>
Follow instructions exactly. Do not make assumptions.
</strict>
{% endif %}
```

## Complete Example

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# E-commerce automation with custom prompts
ecommerce_prompts = {
    "manager_system": """
You are an e-commerce automation specialist.

Task: {{ instruction }}
Budget: ${{ variables.budget }}

{% if app_card %}
App info:
{{ app_card }}
{% endif %}

{% if error_history %}
Errors encountered:
{% for error in error_history %}
- {{ error.action }}: {{ error.summary }} - {{ error.error }}
{% endfor %}
Consider changing your approach.
{% endif %}

Rules:
1. Verify product names exactly
2. Check prices before purchasing
3. Store order confirmations in memory
4. Never exceed budget

Output:
<thought>Your reasoning</thought>
<plan>
1. Step
2. DONE
</plan>
"""
}

config = DroidrunConfig()
agent = DroidAgent(
    goal="Buy iPhone 15 Pro from Amazon",
    config=config,
    prompts=ecommerce_prompts,
    variables={"budget": 1200}
)

result = await agent.run()
```

## Key Points

- Pass Jinja2 template **strings** (not file paths) to `DroidAgent(prompts={...})`
- Each agent has different available variables in its template
- Use `variables` parameter to inject custom context
- Templates are rendered at runtime with current state
- If no custom prompt provided, default templates are used
- Supports full Jinja2 syntax (conditionals, loops, filters)

```

`docs/v4/concepts/scripter-agent.mdx`:

```mdx
---
title: 'ScripterAgent'
description: 'Off-device Python execution for API calls, file operations, and data processing.'
---

## What is ScripterAgent?

**ScripterAgent** executes **off-device Python code** for tasks that don't require device interaction. It's triggered by ManagerAgent when API calls, file operations, or data processing are needed.

ScripterAgent enables:
- **API calls**: REST APIs, webhooks, database queries
- **File operations**: Reading, writing, parsing files
- **Data processing**: JSON/CSV parsing, transformations, filtering

**Key difference**: ScripterAgent runs code that **doesn't interact with the device**, while CodeActAgent generates code that **uses device atomic actions**.

## How It Works

ManagerAgent delegates tasks to ScripterAgent by providing **full context and a high-level task description**. ScripterAgent is a **ReAct agent** that follows a think-execute-observe loop:

1. **Receives task** from Manager with full context
2. **Thinks** and generates Python code to make progress
3. **Executes** the code and observes the output
4. **Repeats** steps 2-3 until task is complete
5. **Returns message** to Manager summarizing the results

ScripterAgent signals completion by returning a message **without code** (not a function call). Variables persist across iterations like a Jupyter notebook.

## Examples

### API Calls

**Manager delegates**:
```
User needs current weather in San Francisco to decide clothing.
Task: Fetch weather from API and extract temperature + conditions
API: https://api.weather.com/forecast?city=San Francisco
```

**ScripterAgent (Iteration 1)**:
```python
# Think: I need to make an API request to get weather data
import requests

response = requests.get(
    "https://api.weather.com/forecast",
    params={"city": "San Francisco"}
)
print(response.json())
```
**Output**: `{'temp': 62, 'description': 'Partly cloudy', 'humidity': 65}`

**ScripterAgent (Final)**:
```
The weather in San Francisco is 62¬∞F with partly cloudy conditions.
```
*(Manager receives this message)*

### Webhook Notifications

**Manager delegates**:
```
Flight booking was completed successfully at 2024-01-15T10:30:00.
Task: Send status update to monitoring webhook
Webhook URL: https://webhook.site/your-webhook-id
Include: task name, status, timestamp
```

**ScripterAgent**:
```python
import requests

payload = {
    "task": "Flight booking completed",
    "status": "success",
    "timestamp": "2024-01-15T10:30:00"
}

response = requests.post(
    "https://webhook.site/your-webhook-id",
    json=payload
)
print(f"Webhook response: {response.status_code}")
```
**Output**: `Webhook response: 200`

**ScripterAgent (Final)**:
```
Successfully sent webhook notification. Server responded with status 200.
```

### File Operations

**Manager delegates**:
```
Contacts file at /tmp/contacts.csv contains all contacts.
Task: Filter contacts from New York and save as JSON
Output: /tmp/filtered_contacts.json
```

**ScripterAgent (Iteration 1)**:
```python
import csv

with open('/tmp/contacts.csv', 'r') as f:
    reader = csv.DictReader(f)
    contacts = list(reader)
print(f"Total contacts: {len(contacts)}")
print(f"Sample: {contacts[0]}")
```
**Output**: `Total contacts: 150` `Sample: {'name': 'John', 'city': 'New York', 'email': '...'}`

**ScripterAgent (Iteration 2)**:
```python
import json

# Filter New York contacts
ny_contacts = [c for c in contacts if c['city'] == 'New York']

with open('/tmp/filtered_contacts.json', 'w') as f:
    json.dump(ny_contacts, f, indent=2)

print(f"Filtered {len(ny_contacts)} contacts from New York")
```
**Output**: `Filtered 23 contacts from New York`

**ScripterAgent (Final)**:
```
Found 23 contacts from New York and saved them to /tmp/filtered_contacts.json
```

## Configuration

```yaml
agent:
  scripter:
    max_steps: 10
    safe_execution:
      enabled: true
      allowed_modules:
        - requests    # API calls, webhooks
        - json        # JSON parsing
        - csv         # CSV file operations
        - pathlib     # File path handling
      blocked_modules:
        - subprocess  # Process spawning
        - os          # System operations
        - sys         # System modifications
```

**Safe execution** restricts dangerous operations by default. Only modules in `allowed_modules` can be imported.

## Key Points

- **ReAct agent**: Think-execute-observe loop until task complete
- **Off-device only**: No device interactions
- **State persistence**: Variables persist across iterations (Jupyter-style)
- **Completion signal**: Returns message without code when done
- **Safe by default**: Restricted imports/builtins
```

`docs/v4/concepts/shared-state.mdx`:

```mdx
---
title: 'Shared State'
description: 'DroidAgentState - the coordination mechanism for multi-agent workflow communication.'
---

## What is Shared State?

**DroidAgentState** is a Pydantic model that serves as the **central coordination mechanism** for DroidRun's multi-agent workflow. It's a shared data structure that all agents (Manager, Executor, CodeAct, Scripter) can read from and write to.

Shared state enables:
- **Cross-agent communication**: Agents share information about actions, results, and errors
- **Progress tracking**: Step counts, action history, visited apps/screens
- **Memory management**: Agent memory, custom variables, user session data
- **Error coordination**: Error flags, escalation thresholds, error descriptions

**Key insight**: Shared state replaces complex message passing. Instead of sending data back and forth, agents update a single shared object.

## Core State Fields

```python
class DroidAgentState(BaseModel):
    # Task context
    instruction: str = ""           # Original task
    step_number: int = 0            # Current step

    # Device state
    formatted_device_state: str = ""           # Human-readable state
    current_package_name: str = ""             # Current app
    current_activity_name: str = ""            # Current screen

    # Action tracking
    action_history: List[Dict] = []            # All actions taken
    action_outcomes: List[bool] = []           # Success/failure
    summary_history: List[str] = []            # Action summaries

    # Memory
    memory: str = ""                           # Agent persistent memory

    # Planning (Manager)
    plan: str = ""                             # Current plan
    current_subgoal: str = ""                  # Current subgoal
    manager_answer: str = ""                   # Answer-type responses

    # Error handling
    error_flag_plan: bool = False              # Signal error to Manager
    error_descriptions: List[str] = []         # Error messages

    # Script execution (Scripter)
    scripter_history: List[Dict] = []          # Scripter results
    last_scripter_success: bool = True         # Last execution status

    # Custom variables
    custom_variables: Dict = {}                # User-defined data
```
```

`docs/v4/features/app-cards.mdx`:

```mdx
---
title: 'App Instruction Cards'
description: 'App cards give your agents app-specific knowledge to operate apps more effectively. They automatically load when agents work with specific apps, improving success rates for navigation and complex tasks.'
---

## What Are App Cards?

App cards are **app-specific instruction guides** that teach agents how to use apps effectively. Think of them as cheat sheets that help your agent understand:

- How to navigate the app's UI
- Where to find buttons and features
- App-specific shortcuts and gestures
- Search syntax and filters (for apps like Gmail)
- Common workflows and best practices

**Example:** When your agent opens Gmail, it automatically loads the Gmail app card and learns that:
- The compose button is at the bottom-right
- Search supports filters like `from:sender@email.com` or `has:attachment`
- Swiping right archives emails, swiping left deletes them

This knowledge helps agents complete tasks faster and more reliably.

---

## Why Use App Cards?

**Without app cards:**
- Agents guess how to navigate unfamiliar apps
- Trial-and-error wastes time and tokens
- Success rates drop for complex workflows

**With app cards:**
- ‚úÖ Agents know exactly where to find features
- ‚úÖ First-attempt success for common tasks
- ‚úÖ Reduced token usage (less exploration needed)
- ‚úÖ Better handling of app-specific quirks

---

## Quick Start

Droidrun includes a sample Gmail app card to demonstrate how app cards work:

```bash
# App cards are enabled by default
droidrun run "Send an email to john@example.com" --reasoning
```

When the agent opens Gmail, the Gmail app card automatically loads and guides the workflow.

**Sample app card included:**
- **Gmail** (`com.google.android.gm`) - Email navigation, search, composition

You can use this as a template to create cards for other apps (see "Creating Custom App Cards" below).

---

## How App Cards Work

### Automatic Loading

1. **Detection:** Agent detects the current foreground app (e.g., Gmail)
2. **Loading:** Droidrun loads the app card for that package name
3. **Injection:** App card content is added to the agent's prompt
4. **Guidance:** Agent uses the instructions to make better decisions

**Technical note:** App cards are loaded asynchronously and cached in memory. Loading happens in the background and doesn't block agent execution.

### When Are They Used?

App cards are used by the **Manager Agent** when running in reasoning mode (`--reasoning` flag or `reasoning: true` in config):

```bash
# App cards enabled (Manager uses them for planning)
droidrun run "Archive all unread emails" --reasoning

# App cards not used (direct execution mode)
droidrun run "Tap the button"
```

---

## Creating Custom App Cards

Want to add an app card for your favorite app? Here's how:

### Step 1: Find the Package Name

```bash
# Get all apps
adb shell pm list packages

# Or search for a specific app
adb shell pm list packages | grep keyword
```

**Common package names:**
- Chrome: `com.android.chrome`
- WhatsApp: `com.whatsapp`
- Instagram: `com.instagram.android`
- YouTube: `com.google.android.youtube`

### Step 2: Create the Files

Create the app cards directory and files:

```bash
mkdir -p config/app_cards
touch config/app_cards/app_cards.json
touch config/app_cards/chrome.md
```

**Example structure:**

```markdown
# Chrome App Guide

## Navigation
- Address bar at the top for entering URLs
- Three-dot menu (top-right) for settings and history
- Tabs button (top-right) to switch between tabs

## Search
- Type queries directly in the address bar
- Use voice search via the microphone icon

## Common Actions
- **New Tab**: Tap the tabs button ‚Üí Plus icon
- **Close Tab**: Swipe tab away in tab switcher
- **Refresh**: Pull down from the top of the page
- **Bookmarks**: Three-dot menu ‚Üí Bookmarks

## Tips
- Incognito mode available via three-dot menu
- Downloads accessible via three-dot menu ‚Üí Downloads
```

### Step 3: Register the App Card

Add your app mapping to `config/app_cards/app_cards.json`:

```json
{
  "com.google.android.gm": "gmail.md",
  "com.android.chrome": "chrome.md"
}
```

**Using subdirectories:**

```json
{
  "com.whatsapp": "social/whatsapp.md",
  "com.instagram.android": "social/instagram.md"
}
```

### Step 4: Test

```bash
droidrun run "Open Chrome and search for droidrun" --reasoning --debug
```

Look for this log message:
```
Loaded app card for com.android.chrome from config/app_cards/chrome.md
```

---

## Configuration

App cards are enabled by default and load from `config/app_cards/`:

```yaml
agent:
  app_cards:
    enabled: true
    app_cards_dir: config/app_cards
```

**To disable:**
```yaml
agent:
  app_cards:
    enabled: false
```

---

## App Card Best Practices

### Content Guidelines

**Do:**
- Be concise and actionable
- Focus on UI patterns and workflows
- Include search syntax and special features
- Mention common pitfalls or quirks
- Use bullet points and clear headings

**Don't:**
- Write essays or lengthy explanations
- Describe every single feature
- Include information that changes frequently (version-specific details)
- Duplicate general Android knowledge (agents already know how to tap, swipe, etc.)

### Example: Good vs Bad

**‚ùå Bad (too verbose):**
```markdown
Gmail is an email application developed by Google. It has many features
including the ability to send and receive emails. To compose an email,
you need to first understand that Gmail uses a material design interface
with a floating action button, which is a circular button...
```

**‚úÖ Good (concise and actionable):**
```markdown
## Composing Emails
- Tap the floating compose button (bottom-right)
- Fill recipient, subject, and body
- Send via paper plane icon (top-right)
```

---

## Troubleshooting

### App Card Not Loading

**Check these:**

1. **Is the package name correct?**
   ```bash
   adb shell dumpsys window windows | grep -E 'mCurrentFocus'
   ```

2. **Is the mapping correct in app_cards.json?**
   ```json
   {
     "com.your.app": "yourapp.md"
   }
   ```

3. **Does the markdown file exist?**
   ```bash
   ls config/app_cards/yourapp.md
   ```

4. **Are app cards enabled?**
   ```yaml
   agent:
     app_cards:
       enabled: true
   ```

5. **Are you using reasoning mode?**
   ```bash
   droidrun run "command" --reasoning
   ```

### Debug Mode

Run with `--debug` to see app card loading:

```bash
droidrun run "Open Gmail" --reasoning --debug
```

Look for these log messages:
```
Loaded app_cards.json with 2 entries
Loaded app card for com.google.android.gm from config/app_cards/gmail.md
```

---

## Related Documentation

- [CLI Usage](/v4/guides/cli) - Droidrun CLI command reference
- [Configuration](/v4/sdk/configuration) - Configuration system details
- [Agent Architecture](/v4/concepts/architecture) - How agents work
- [Manager Agent](/v4/concepts/architecture#manageragent-planner) - Agent that uses app cards

---

**Help your agents become app experts with well-crafted app cards!**

```

`docs/v4/features/credentials.mdx`:

```mdx
---
title: 'Credential Management'
description: 'Extend Droidrun with secure credential management'
---

## Overview

Secure storage for passwords, API keys, and tokens.
- Stored in YAML files or in-memory dicts
- Never logged or exposed
- Auto-injected as `type_secret` action
- Simple string or dict format

## Quick Start

### Method 1: In-Memory (Recommended for SDK)

```python
import asyncio
from droidrun import DroidAgent, DroidrunConfig

async def main():
    # Define credentials directly
    credentials = {
        "MY_PASSWORD": "secret123",
        "API_KEY": "sk-1234567890"
    }

    config = DroidrunConfig()

    agent = DroidAgent(
        goal="Login to my app",
        config=config,
        credentials=credentials  # Pass directly
    )

    result = await agent.run()
    print(result.success)

asyncio.run(main())
```

### Method 2: YAML File

1. **Create credentials file:**

```yaml
# credentials.yaml
secrets:
  # Dict format (recommended)
  MY_PASSWORD:
    value: "your_password_here"
    enabled: true

  GMAIL_PASSWORD:
    value: "gmail_pass_123"
    enabled: true

  # Simple string format (auto-enabled)
  API_KEY: "sk-1234567890abcdef"

  # Disabled secret
  OLD_PASSWORD:
    value: "old_pass"
    enabled: false  # Not loaded
```

2. **Enable in config.yaml:**

```yaml
# config.yaml
credentials:
  enabled: true
  file_path: config/credentials.yaml
```

3. **Use in code:**

```python
from droidrun import DroidAgent, DroidrunConfig

# Config loads credentials from file
config = DroidrunConfig.from_yaml("config.yaml")

agent = DroidAgent(
    goal="Login to Gmail",
    config=config  # Credentials loaded automatically
)
```

---

## How Agents Use Credentials

When credentials are provided, the `type_secret` action is **automatically available**:

### Executor/Manager Mode
```json
{
  "action": "type_secret",
  "secret_id": "MY_PASSWORD",
  "index": 5
}
```

### CodeAct Mode
```python
type_secret("MY_PASSWORD", index=5)
```

The agent never sees the actual value - only the secret ID.

---

## Example: Login Automation

```python
import asyncio
from droidrun import DroidAgent, DroidrunConfig

async def main():
    credentials = {
        "EMAIL_USER": "user@example.com",
        "EMAIL_PASS": "secret_password"
    }

    config = DroidrunConfig()

    agent = DroidAgent(
        goal="Open Gmail and login with my credentials",
        config=config,
        credentials=credentials
    )

    result = await agent.run()
    print(f"Success: {result.success}")

asyncio.run(main())
```

**What the agent does:**
1. Opens Gmail: `open_app("Gmail")`
2. Clicks email field: `click(index=3)`
3. Types email: `type("user@example.com", index=3)`
4. Clicks password field: `click(index=5)`
5. Types password securely: `type_secret("EMAIL_PASS", index=5)`
6. Clicks login: `click(index=7)`

## Credentials vs Variables

| Feature | Credentials | Variables |
|---------|------------|-----------|
| **Purpose** | Passwords, API keys | Non-sensitive data |
| **Storage** | YAML or in-memory | In-memory only |
| **Logging** | Never logged | May appear in logs |
| **Access** | Via `type_secret` tool | In shared state |
| **Security** | Protected | No protection |

**Example: Using Variables**
```python
variables = {
    "target_email": "john@example.com",
    "subject_line": "Monthly Report"
}

agent = DroidAgent(
    goal="Compose email to {{target_email}}",
    config=config,
    variables=variables  # Non-sensitive
)
```

---

## Troubleshooting

### Error: Credential manager not initialized

**Solution:**
```yaml
# config.yaml
credentials:
  enabled: true  # Must be true
  file_path: config/credentials.yaml
```

Or:
```python
agent = DroidAgent(..., credentials={"PASSWORD": "secret"})
```

### Error: Secret 'X' not found

**Check available secrets:**
```python
from droidrun.credential_manager import FileCredentialManager

cm = FileCredentialManager("config/credentials.yaml")
print(await cm.get_keys())
```

**Verify in YAML:**
```yaml
secrets:
  X:
    value: "your_value"
    enabled: true  # Must be true
```

---

## Custom Credential Managers

Extend `CredentialManager` for custom secret storage:

```python
from droidrun.credential_manager import CredentialManager

class MyCredentialManager(CredentialManager):
    def __init__(self, api_key):
        self.api_key = api_key

    async def resolve_key(self, key: str) -> str:
        # Implement your own credential retrieval logic
        return await fetch_from_service(key, self.api_key)

    async def get_keys(self) -> list[str]:
        # Return list of available credential keys
        return await fetch_available_keys(self.api_key)

# Use it
credentials = MyCredentialManager(api_key="...")
agent = DroidAgent(goal="Login", config=config, credentials=credentials)
```

Implement any custom secret storage backend.

---

## Related

See [Configuration Guide](/v4/sdk/configuration) for credential setup.

See [Custom Variables](/v4/features/custom-variables) for non-sensitive data.

```

`docs/v4/features/custom-tools.mdx`:

```mdx
---
title: 'Custom Tools'
description: 'Extend Droidrun with custom Python functions'
---

## Overview

Custom tools are Python functions that extend agent capabilities beyond built-in atomic actions (click, type, swipe).

**Use cases:**
- External API calls (webhooks, REST services)
- Data processing and calculations
- Database operations
- Domain-specific logic

---

## Quick Start

### Basic Example

Simple custom tool without device access:

```python
import asyncio
from droidrun import DroidAgent, DroidrunConfig

def calculate_tax(amount: float, rate: float, **kwargs) -> str:
    """Calculate tax for a given amount."""
    tax = amount * rate
    total = amount + tax
    return f"Tax: ${tax:.2f}, Total: ${total:.2f}"

custom_tools = {
    "calculate_tax": {
        "arguments": ["amount", "rate"],
        "description": "Calculate tax for a given amount and rate",
        "function": calculate_tax
    }
}

async def main():
    config = DroidrunConfig()

    agent = DroidAgent(
        goal="Calculate tax for $100 at 8% rate",
        config=config,
        custom_tools=custom_tools
    )

    result = await agent.run()
    print(result.success, result.reason)

asyncio.run(main())
```

---

## Tool Structure

All custom tools follow this format:

```python
custom_tools = {
    "tool_name": {
        "arguments": ["arg1", "arg2"],           # Parameter names
        "description": "Tool description...",    # For LLM prompt
        "function": callable_function            # Python function
    }
}
```

**Function signature:**
```python
def tool_name(arg1: type, arg2: type, *, tools=None, shared_state=None, **kwargs) -> str:
    """
    Args:
        arg1: Your parameter
        arg2: Another parameter
        tools: Tools instance (optional, injected automatically)
        shared_state: DroidAgentState (optional, injected automatically)
    """
    # Implementation
    return "result"
```

**Key points:**
- List only user arguments in `"arguments"` (not `tools` or `shared_state`)
- `tools` and `shared_state` are injected automatically as keyword arguments
- Use `**kwargs` for forward compatibility
- Return type should be `str`

---

## Using Tools Instance

Access device via the `tools` parameter:

```python
def screenshot_and_count(*, tools=None, shared_state=None, **kwargs) -> str:
    """Take screenshot and count UI elements."""
    if not tools:
        return "Error: tools instance required"

    # Take screenshot
    screenshot_path, screenshot_bytes = tools.take_screenshot()

    # Get UI state
    state = tools.get_state()
    element_count = len(state.get("ui_elements", []))

    return f"Screenshot saved. Found {element_count} UI elements"

custom_tools = {
    "screenshot_and_count": {
        "arguments": [],
        "description": "Take screenshot and count UI elements on screen",
        "function": screenshot_and_count
    }
}
```

**Available via `tools`:**
- `tools.take_screenshot()` - Capture screen
- `tools.get_state()` - Get UI hierarchy
- `tools.tap_by_index(index)` - Tap element
- `tools.input_text(text, index)` - Type text
- `tools.swipe(x1, y1, x2, y2)` - Swipe gesture
- All methods from AdbTools/IOSTools

---

## Using Shared State

Access agent state via `shared_state`:

```python
def check_action_history(action_name: str, *, tools=None, shared_state=None, **kwargs) -> str:
    """Check if action was recently performed."""
    if not shared_state:
        return "Error: shared_state required"

    # Check recent actions
    recent_actions = shared_state.action_history[-5:]
    already_done = any(a.get("action") == action_name for a in recent_actions)

    if already_done:
        return f"Action '{action_name}' was already performed recently"

    # Check step count
    if shared_state.step_number > 10:
        return "Warning: Task taking too many steps"

    # Access memory
    if "skip_validation" in shared_state.memory:
        return "Validation skipped per memory"

    return f"Action '{action_name}' not yet performed"

custom_tools = {
    "check_action_history": {
        "arguments": ["action_name"],
        "description": "Check if a specific action was recently performed in agent history",
        "function": check_action_history
    }
}
```

**DroidAgentState fields:**
- `step_number` - Current execution step
- `action_history` - List of executed actions
- `action_outcomes` - Success/failure per action
- `memory` - Agent memory dict
- `custom_variables` - User-provided variables
- `visited_packages` - Apps visited
- `current_package_name` - Current app package
- `plan` - Current Manager plan
- More in `droidrun/agent/droid/events.py`

---

## Common Patterns

### API Integration

```python
import requests

def fetch_weather(city: str, **kwargs) -> str:
    """Fetch weather data from API."""
    try:
        # Using OpenWeatherMap API example
        api_key = "your_api_key"
        url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}"

        response = requests.get(url, timeout=10)
        response.raise_for_status()

        data = response.json()
        temp = data["main"]["temp"] - 273.15  # Convert to Celsius
        weather = data["weather"][0]["description"]

        return f"Weather in {city}: {weather}, {temp:.1f}¬∞C"
    except Exception as e:
        return f"Error: {str(e)}"

custom_tools = {
    "fetch_weather": {
        "arguments": ["city"],
        "description": "Fetch current weather data for a given city",
        "function": fetch_weather
    }
}
```

### Database Query

```python
import sqlite3

def query_database(query: str, **kwargs) -> str:
    """Query local database."""
    try:
        conn = sqlite3.connect("app.db")
        cursor = conn.execute(query)
        results = cursor.fetchall()
        conn.close()

        return f"Found {len(results)} results"
    except Exception as e:
        return f"Database error: {str(e)}"

custom_tools = {
    "query_database": {
        "arguments": ["query"],
        "description": "Execute SQL query on local database and return results",
        "function": query_database
    }
}
```

### Async Operations

```python
import aiohttp

async def fetch_async(url: str, **kwargs) -> str:
    """Fetch data asynchronously."""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                data = await response.text()
                return f"Fetched {len(data)} bytes from {url}"
    except Exception as e:
        return f"Error: {str(e)}"

custom_tools = {
    "fetch_async": {
        "arguments": ["url"],
        "description": "Asynchronously fetch data from a URL",
        "function": fetch_async
    }
}
```

---

## Best Practices

### 1. Clear Descriptions
Write descriptive, specific descriptions:

```python
# Good
"description": "Send POST request to webhook URL with JSON data payload"

# Bad
"description": "Send webhook"
```

### 2. Error Handling
Always catch exceptions:

```python
def robust_tool(url: str, **kwargs) -> str:
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        return f"Success: {response.status_code}"
    except requests.Timeout:
        return "Error: Request timed out"
    except requests.RequestException as e:
        return f"Error: {str(e)}"
    except Exception as e:
        return f"Unexpected error: {str(e)}"
```

### 3. Argument Validation
Validate inputs before processing:

```python
def validated_tool(count: int, **kwargs) -> str:
    if not isinstance(count, int):
        return "Error: count must be integer"
    if count < 0 or count > 100:
        return "Error: count must be 0-100"

    return f"Processed {count} items"
```

### 4. Logging
Use Python logging for debugging:

```python
import logging
logger = logging.getLogger("droidrun")

def logged_tool(data: str, **kwargs) -> str:
    logger.info(f"Processing: {data[:50]}...")
    # Process data
    logger.info("Complete")
    return "Success"
```

---

## Advanced Example

Combining tools instance, shared state, and credentials:

```python
import requests

async def send_authenticated_request(
    url: str,
    data: str,
    *,
    tools=None,
    shared_state=None,
    **kwargs
) -> str:
    """Send authenticated API request with credentials."""
    try:
        # Access credentials via tools instance
        if not tools or not hasattr(tools, 'credential_manager'):
            return "Error: Credential manager not available"

        api_key = await tools.credential_manager.resolve_key("API_KEY")

        # Check if we've made too many requests
        if shared_state and shared_state.step_number > 15:
            return "Error: Too many API calls"

        # Send authenticated request
        headers = {"Authorization": f"Bearer {api_key}"}
        response = requests.post(url, json={"data": data}, headers=headers, timeout=10)
        response.raise_for_status()

        return f"Request successful: {response.status_code}"
    except Exception as e:
        return f"Error: {str(e)}"

custom_tools = {
    "send_authenticated_request": {
        "arguments": ["url", "data"],
        "description": "Send authenticated API request using stored credentials",
        "function": send_authenticated_request
    }
}

# Usage with credentials
credentials = {"API_KEY": "sk-1234567890"}

agent = DroidAgent(
    goal="Send data to API",
    config=config,
    custom_tools=custom_tools,
    credentials=credentials
)
```

---

## Related

See [Agent Architecture](/v4/concepts/architecture) for understanding shared state and custom tools integration.
```

`docs/v4/features/custom-variables.mdx`:

```mdx
---
title: 'Custom Variables'
description: 'Pass dynamic data to your Droidrun agents using the `variables` parameter. Variables enable parameterized workflows and reusable automation.'
---

Custom variables are accessible in:
- **Agent prompts** via custom Jinja2 templates
- **Custom tools** via `shared_state.custom_variables`

---

## Quick Start

```python
from droidrun import DroidAgent, DroidrunConfig

# Define custom prompts that render variables
custom_prompts = {
    "manager_system": """
{{ instruction }}

{% if variables %}
Available variables:
{% for key, value in variables.items() %}
- {{ key }}: {{ value }}
{% endfor %}
{% endif %}
    """
}

# Create agent with variables
config = DroidrunConfig()

agent = DroidAgent(
    goal="Send email to recipient with subject",
    config=config,
    variables={"recipient": "john@example.com", "subject": "Update"},
    prompts=custom_prompts  # Required to see variables
)

result = await agent.run()
```

**Important:** Default prompts don't render variables. You must provide custom prompts via the `prompts` parameter.

---

## How Variables Work

When you pass `variables` to `DroidAgent`:

1. **Stored** in `DroidAgentState.custom_variables`
2. **Passed** to prompt templates as `variables` dict
3. **Rendered** in Jinja2 templates via `{% if variables %}` blocks
4. **Available** to all child agents throughout the workflow

**Access Summary:**
- ‚úÖ Agent prompts (via custom Jinja2 templates)
- ‚úÖ Agents can read and pass to tools as arguments
- ‚úÖ Custom tools (via `shared_state.custom_variables`)

---

## Basic Usage

```python
from droidrun import DroidAgent, DroidrunConfig

# Define variables
variables = {
    "recipient": "alice@example.com",
    "message": "Hello from Droidrun!"
}

# Custom prompt to render variables
custom_prompts = {
    "codeact_system": """
You are an agent that controls Android devices.

{% if variables %}
Available variables:
{% for key, value in variables.items() %}
- {{ key }}: {{ value }}
{% endfor %}
{% endif %}

Use these variables when executing tasks.
    """
}

# Create agent
config = DroidrunConfig()

agent = DroidAgent(
    goal="Send message to recipient",
    config=config,
    variables=variables,
    prompts=custom_prompts
)

result = await agent.run()
```

### Available Prompt Keys

Customize these prompts to render variables:

- `manager_system` - Manager agent system prompt
- `executor_system` - Executor agent system prompt
- `codeact_system` - CodeAct agent system prompt
- `codeact_user` - CodeAct agent user prompt
- `scripter_system` - Scripter agent system prompt

---

## Accessing Variables in Custom Tools

Custom tools can directly access variables via the `shared_state` keyword argument:

```python
from droidrun import DroidAgent, DroidrunConfig

def send_notification(title: str, *, tools=None, shared_state=None, **kwargs):
    """Send a notification using channel from custom variables.

    Args:
        title: Notification title
        tools: Tools instance (optional, injected automatically)
        shared_state: DroidAgentState (optional, injected automatically)
    """
    if not shared_state:
        return "Error: shared_state required"

    # Access custom variables
    channel = shared_state.custom_variables.get("notification_channel", "default")
    return f"Sent '{title}' to {channel}"

custom_tools = {
    "send_notification": {
        "arguments": ["title"],
        "description": "Send a notification with title. Usage: {\"action\": \"send_notification\", \"title\": \"Alert\"}",
        "function": send_notification
    }
}

config = DroidrunConfig()

agent = DroidAgent(
    goal="Send notification with title 'Alert'",
    config=config,
    custom_tools=custom_tools,
    variables={"notification_channel": "alerts"}
)
```

---

## Use Cases

### Parameterized Workflows

```python
# Define reusable workflow with different variables
for user in ["alice@example.com", "bob@example.com"]:
    agent = DroidAgent(
        goal="Send welcome email",
        config=config,
        variables={"recipient": user},
        prompts=custom_prompts
    )
    await agent.run()
```

### Configuration Data

```python
variables = {
    "api_endpoint": "https://api.example.com/v2",
    "timeout": 30
}

agent = DroidAgent(
    goal="Call API endpoint",
    config=config,
    variables=variables,
    prompts=custom_prompts
)
```

---

## Key Points

1. **Custom prompts required** - Default prompts don't render variables in agent context
2. **Direct access in tools** - Custom tools access `shared_state.custom_variables` via keyword argument
3. **Available to all agents** - Manager, Executor, CodeAct, Scripter all receive variables
4. **Jinja2 templates** - Use `{% if variables %}` blocks in custom prompts
5. **Auto-injection** - `tools` and `shared_state` are injected automatically by Droidrun

## Related Documentation

- [Custom Prompts](/v4/concepts/prompts) - How to customize agent prompts
- [Custom Tools](/v4/features/custom-tools) - Creating custom tool functions
- [DroidAgent SDK](/v4/sdk/droid-agent) - Complete API reference

```

`docs/v4/features/structured-output.mdx`:

```mdx
---
title: 'Structured Output'
description: 'Extract structured data from device interactions using Pydantic models'
---

## Quick Start

```python
import asyncio
from pydantic import BaseModel, Field
from droidrun import DroidAgent, DroidrunConfig

# 1. Define output structure
class ContactInfo(BaseModel):
    """Contact information from device."""
    name: str = Field(description="Full name of the contact")
    phone: str = Field(description="Phone number")
    email: str = Field(description="Email address", default="Not provided")

# 2. Create agent with output_model
async def main():
    config = DroidrunConfig()

    agent = DroidAgent(
        goal="Find John Smith's contact information",
        config=config,
        output_model=ContactInfo,
    )

    # 3. Run and access structured output
    result = await agent.run()

    if result.success and result.structured_output:
        contact: ContactInfo = result.structured_output
        print(f"Name: {contact.name}")
        print(f"Phone: {contact.phone}")
        print(f"Email: {contact.email}")

asyncio.run(main())
```

---

## How It Works

### Two-Stage Process

**Stage 1: Task Execution**
- DroidAgent performs device actions while collecting required information
- System prompt is automatically injected with your Pydantic schema
- Agent completes with natural language answer containing the data

**Stage 2: Extraction (Post-Completion)**
- `StructuredOutputAgent` receives the final answer text
- Uses LLM's `astructured_predict()` to extract data into your model
- Validates against schema and returns typed object or `None`

---

## Example: Invoice Extraction

```python
from pydantic import BaseModel, Field
from typing import List

class Invoice(BaseModel):
    """Invoice information."""
    invoice_number: str = Field(description="Invoice ID")
    vendor_name: str = Field(description="Vendor name")
    total_due: float = Field(description="Total amount in dollars")

agent = DroidAgent(
    goal="Open Gmail and extract invoice from Acme Corp email",
    config=DroidrunConfig(),
    output_model=Invoice,
)

result = await agent.run()
invoice = result.structured_output
print(f"Invoice {invoice.invoice_number}: ${invoice.total_due}")
```

---

## Working with Results

### Accessing Data

```python
result = await agent.run()

if result.success:
    if result.structured_output:
        data = result.structured_output  # Typed Pydantic object
        print(f"Extracted: {data}")
    else:
        print(f"Extraction failed, text answer: {result.reason}")
else:
    print(f"Task failed: {result.reason}")
```

### Exporting to JSON

```python
result = await agent.run()

if result.structured_output:
    # Convert to JSON and save
    json_str = result.structured_output.model_dump_json(indent=2)
    with open("output.json", "w") as f:
        f.write(json_str)
```

---

## Configuration

### Custom Extraction LLM

By default, extraction uses the `codeact` LLM. Specify a dedicated `structured_output` profile:

**config.yaml:**
```yaml
llm_profiles:
  codeact:
    provider: GoogleGenAI
    model: models/gemini-2.0-flash
    temperature: 0.3

  structured_output:
    provider: OpenAI
    model: gpt-4o-mini
    temperature: 0.0  # Low temp for consistent extraction
```

**Programmatically:**
```python
from droidrun import load_llm

config = DroidrunConfig()

llms = {
    "codeact": load_llm("GoogleGenAI", "models/gemini-2.0-flash"),
    "structured_output": load_llm("OpenAI", "gpt-4o-mini"),
}

agent = DroidAgent(
    goal="Extract contact info for Alice",
    llms=llms,
    config=config,
    output_model=ContactInfo,
)
```

### Reasoning Mode

Works in both direct and reasoning modes:

```python
# Direct mode
config = DroidrunConfig()
config.agent.reasoning = False

agent = DroidAgent(
    goal="Find weather for SF",
    config=config,
    output_model=WeatherInfo,
)

# Reasoning mode
config.agent.reasoning = True

agent = DroidAgent(
    goal="Find weather for SF",
    config=config,
    output_model=WeatherInfo,
)
```

---

## Best Practices

**1. Add clear field descriptions** - The LLM uses these to understand what to extract:
```python
name: str = Field(description="Full name of customer who placed order")
```

**2. Provide defaults for optional fields** - Prevents extraction failures:
```python
rating: Optional[float] = Field(description="Customer rating (1-5)", default=None)
```

**3. Guide data collection in your goal**:
```python
agent = DroidAgent(
    goal="Find contact and get their phone number, email, and full name",
    config=config,
    output_model=ContactInfo,
)
```

---

## Troubleshooting

**Extraction returns None:**
- Verify `output_model` is passed to `DroidAgent`
- Check if task succeeded: `result.success`
- Enable debug logging: `config.logging.debug = True`

**Partial or incorrect data:**
- Add more specific field descriptions
- Mention required fields explicitly in the goal

**Validation errors:**
- Add `Optional` and defaults for uncertain fields

---

## Advanced

### Multiple Items

Extract lists of data using a model with `List` fields:

```python
class ContactList(BaseModel):
    """Multiple contacts."""
    contacts: List[ContactInfo] = Field(description="List of contacts")

agent = DroidAgent(
    goal="Find contacts for John Smith and Jane Doe",
    config=config,
    output_model=ContactList,
)
```

### Workflow Integration

Extraction happens automatically in `DroidAgent.finalize()`:

```python
@step
async def finalize(self, ctx: Context, ev: FinalizeEvent) -> ResultEvent:
    result = ResultEvent(
        success=ev.success,
        reason=ev.reason,
        steps=self.shared_state.step_number,
        structured_output=None,
    )

    # Extract if model was provided
    if self.output_model is not None and ev.reason:
        structured_agent = StructuredOutputAgent(
            llm=self.structured_output_llm,
            pydantic_model=self.output_model,
            answer_text=ev.reason,
        )
        extraction_result = await (await structured_agent.run())
        if extraction_result["success"]:
            result.structured_output = extraction_result["structured_output"]

    return result
```

---

## Related Documentation

- [DroidAgent API](/v4/sdk/droid-agent)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [Configuration Guide](/v4/sdk/configuration)
- [Custom Variables](/v4/features/custom-variables)

```

`docs/v4/features/telemetry.mdx`:

```mdx
---
title: 'Telemetry'
description: 'Configure anonymous telemetry'
---

# Why We Need Telemetry

Telemetry helps us:
- Identify which features are most used and need improvement
- Prioritize bug fixes and new features based on real usage
- Ensure Droidrun works well across different environments

<b>We do not collect any personal or sensitive data.</b> All telemetry is strictly anonymized and used only to improve the framework for everyone.

If you have questions or concerns, please reach out on [GitHub](https://github.com/droidrun/droidrun) or review our privacy policy.

---

# Toggling Telemetry

Droidrun collects <b>anonymized</b> usage data to help us understand which features are most valuable and where improvements are needed. This data is <b>never</b> used for advertising or tracking individuals, and is only used to make Droidrun better for the community.

## How to Disable Telemetry

You can disable telemetry at any time by setting the following environment variable:

```bash
export DROIDRUN_TELEMETRY_ENABLED=false
```

Add this line to your shell profile (e.g., `.bashrc`, `.zshrc`, or `.profile`) to make it persistent across sessions.

## How to Enable Telemetry Again

To re-enable telemetry, set the environment variable to `true`:

```bash
export DROIDRUN_TELEMETRY_ENABLED=true
```

<Note>
Telemetry is currently controlled only by the `DROIDRUN_TELEMETRY_ENABLED` environment variable. While a `telemetry.enabled` config option exists in the configuration schema, it is not currently used by the telemetry system.
</Note>

---

```

`docs/v4/features/tracing.mdx`:

```mdx
---
title: 'Tracing'
description: 'Configure Phoenix/Langfuse tracing and trajectory recording'
---

Droidrun provides multiple monitoring capabilities:

1. **LLM Tracing** - Real-time execution tracing via Arize Phoenix or Langfuse
2. **Trajectory Recording** - Local screenshots and UI state for debugging

## Quick Reference

```sh
# Enable Phoenix tracing
droidrun run "task" --tracing

# Enable trajectory recording
droidrun run "task" --save-trajectory step
```

---

## LLM Tracing

Droidrun supports two tracing providers for real-time monitoring of LLM calls, agent execution, and tool invocations:

- **Arize Phoenix** (default) - Open-source observability platform
- **Langfuse** - LLM engineering platform with cloud and self-hosted options

Use tracing to debug agent behavior, monitor token usage, and analyze execution flow.

---

### Arize Phoenix Tracing

#### Setup

**1. Install Phoenix:**

```sh
uv pip install arize-phoenix
```

**2. Start Phoenix server:**

```sh
phoenix serve
```

The server starts at `http://localhost:6006` and provides a web UI for viewing traces.

**3. Enable tracing in Droidrun:**

**Via CLI:**

```sh
droidrun run "Open settings" --tracing
```

**Via config.yaml:**

```yaml
tracing:
  enabled: true
```

**Via code:**

```python
from droidrun import DroidAgent, DroidrunConfig

config = DroidrunConfig()
config.tracing.enabled = True

agent = DroidAgent(goal="Open settings", config=config)
await agent.run()
```

**4. View traces:**

Navigate to `http://localhost:6006` to see:
- LLM calls with prompts, responses, and token counts
- Agent workflow execution (Manager, Executor, CodeAct)
- Tool invocations and their results
- Execution timings and errors

For more on using Phoenix, see the [Arize Phoenix documentation](https://docs.arize.com/phoenix).

#### Phoenix Configuration

Set environment variables to customize Phoenix:

```sh
# Custom Phoenix server URL (default: http://127.0.0.1:6006)
export phoenix_url=http://localhost:6006

# Project name for organizing traces
export phoenix_project_name=my_droidrun_project
```

<Note>
Environment variable names are lowercase: `phoenix_url` and `phoenix_project_name`.
</Note>

---

### Langfuse Tracing

Langfuse provides LLM observability with features like session tracking, user analytics, and cost monitoring.

#### Setup

**1. Get Langfuse credentials:**
- **Cloud**: Sign up at [cloud.langfuse.com](https://cloud.langfuse.com)
- **Self-hosted**: Deploy using [Langfuse docs](https://langfuse.com/docs/deployment/self-host)

**2. Configure Droidrun:**

**Via environment variables:**
```sh
export LANGFUSE_SECRET_KEY=sk-lf-...
export LANGFUSE_PUBLIC_KEY=pk-lf-...
export LANGFUSE_HOST=https://cloud.langfuse.com
```

**Via config.yaml:**
```yaml
tracing:
  enabled: true
  provider: langfuse
  langfuse_secret_key: sk-lf-...
  langfuse_public_key: pk-lf-...
  langfuse_host: https://cloud.langfuse.com
  langfuse_user_id: user@example.com  # Optional: track by user
  langfuse_session_id: ""              # Optional: custom session ID
```

**Via code:**
```python
from droidrun import DroidAgent, DroidrunConfig, TracingConfig

config = DroidrunConfig(
    tracing=TracingConfig(
        enabled=True,
        provider="langfuse",
        langfuse_secret_key="sk-lf-...",
        langfuse_public_key="pk-lf-...",
        langfuse_host="https://cloud.langfuse.com",
        langfuse_user_id="user@example.com",
    )
)

agent = DroidAgent(goal="Open settings", config=config)
await agent.run()
```

**3. View traces:**

Navigate to your Langfuse dashboard to see:
- LLM calls with prompts, completions, and token usage
- Agent execution traces and nested workflows
- Session-based analytics and cost tracking
- User-level metrics (if `langfuse_user_id` is set)

For more on using Langfuse, see the [Langfuse documentation](https://langfuse.com/docs).

---

## Trajectory Recording

Trajectory recording saves screenshots and UI state locally for offline debugging and analysis. Unlike telemetry (sent to PostHog) and tracing (sent to Phoenix or Langfuse), trajectories stay on your machine.

### Recording Levels

| Level | What's Saved | When to Use |
|-------|--------------|-------------|
| `none` (default) | Nothing | Production use, saves disk space |
| `step` | Screenshot + state per agent step | General debugging, recommended for most use cases |
| `action` | Screenshot + state per atomic action | Detailed debugging, captures every tap/swipe/type |

**Note:** `action` level generates significantly more files than `step` level.

### Enable Recording

**Via CLI:**

```sh
droidrun run "Open settings" --save-trajectory step
```

**Via config.yaml:**

```yaml
logging:
  save_trajectory: step  # none | step | action
```

**Via code:**

```python
from droidrun import DroidAgent, DroidrunConfig

config = DroidrunConfig()
config.logging.save_trajectory = "action"

agent = DroidAgent(goal="Open settings", config=config)
await agent.run()
```

### Output Location

Trajectories are saved to `trajectories/` in your working directory:

```
trajectories/
‚îî‚îÄ‚îÄ 2025-10-17_14-30-45_open_settings/
    ‚îú‚îÄ‚îÄ step_000_screenshot.png
    ‚îú‚îÄ‚îÄ step_000_state.json
    ‚îú‚îÄ‚îÄ step_001_screenshot.png
    ‚îî‚îÄ‚îÄ step_001_state.json
```

Each trajectory folder contains:
- **Screenshots** - PNG images of the device screen at each step/action
- **State files** - JSON files with:
  - UI accessibility tree (element hierarchy with IDs, text, bounds)
  - Action executed (e.g., `click(5)`, `type("hello", 3)`)
  - Agent reasoning and step number
  - Device state (current app package, activity)

Use these files to:
- Debug why the agent made specific decisions
- Replay failed executions
- Analyze UI element detection issues
- Build training datasets for agent improvement

---

## Related Documentation

- [Configuration System](/v4/sdk/configuration) - Configure tracing and telemetry settings
- [Events and Workflows](/v4/concepts/events-and-workflows) - Build custom monitoring integrations
- [CLI Usage](/v4/guides/cli) - Command-line flags for monitoring

```

`docs/v4/guides/cli.mdx`:

```mdx
---
title: 'CLI Usage'
description: 'Command-line interface for controlling devices with natural language'
---

## Overview

The Droidrun CLI lets you control Android and iOS devices using natural language commands powered by LLM agents.

### Quick Start

```bash
# Setup device
droidrun setup

# Run a command (shorthand - no "run" needed)
droidrun "Open Spotify and play my Discover Weekly"

# Or explicit
droidrun run "Turn on Do Not Disturb"
```

<Note>
**Auto-configuration**: If `config.yaml` doesn't exist, Droidrun creates it from `config_example.yaml` automatically.

**Command shorthand**: `droidrun "task"` is equivalent to `droidrun run "task"`
</Note>

---

## Commands

<Tabs>
  <Tab title="run">

Execute natural language commands on your device.

### Usage

```bash
droidrun run "<command>" [OPTIONS]

# Shorthand (omit "run")
droidrun "<command>" [OPTIONS]
```

### Common Flags

| Flag | Description | Default |
|------|-------------|---------|
| `--provider`, `-p` | LLM provider (GoogleGenAI, OpenAI, Anthropic, etc.) | From config |
| `--model`, `-m` | Model name | From config |
| `--device`, `-d` | Device serial or IP | Auto-detect |
| `--steps` | Max execution steps | `15` |
| `--reasoning` | Enable planning mode | `false` |
| `--vision` | Enable vision for all agents | From config |
| `--tcp` | Use TCP instead of content provider | `false` |
| `--debug` | Verbose logging | `false` |
| `--save-trajectory` | Save execution (`none`, `step`, `action`) | `none` |
| `--config`, `-c` | Custom config path | `config.yaml` |

### Examples

<Tabs>
  <Tab title="Basic">
```bash
# Simple command
droidrun "Open Settings"

# Multi-step task
droidrun "Send WhatsApp to John: I'll be late"

# Specific device
droidrun "Check battery" --device emulator-5554
```
  </Tab>

  <Tab title="LLM Providers">
```bash
# Google Gemini
export GOOGLE_API_KEY=your-key
droidrun "Archive old emails" \
  --provider GoogleGenAI \
  --model models/gemini-2.5-flash

# OpenAI
export OPENAI_API_KEY=your-key
droidrun "Create shopping list" \
  --provider OpenAI \
  --model gpt-4o

# Anthropic Claude
export ANTHROPIC_API_KEY=your-key
droidrun "Reply to latest email" \
  --provider Anthropic \
  --model claude-sonnet-4-5-latest

# Local Ollama (free)
droidrun "Turn on dark mode" \
  --provider Ollama \
  --model llama3.3:70b \
  --base_url http://localhost:11434
```
  </Tab>

  <Tab title="Advanced">
```bash
# Complex task with planning
droidrun "Organize inbox by sender" \
  --reasoning \
  --vision \
  --steps 30

# Debug failing command
droidrun "Book Uber to airport" \
  --debug \
  --save-trajectory action

# Wireless execution
droidrun "Clear cache" \
  --device 192.168.1.100:5555 \
  --tcp

# Custom config
droidrun "Enable 2FA" \
  --config /path/to/config.yaml
```
  </Tab>
</Tabs>

### Provider Options

| Provider | Install | Environment Variable |
|----------|---------|---------------------|
| GoogleGenAI | Included by default | `GOOGLE_API_KEY` |
| OpenAI | Included by default | `OPENAI_API_KEY` |
| OpenAILike | Included by default | Varies by provider |
| OpenRouter | Included by default | `OPENROUTER_API_KEY` |
| Ollama | Included by default | None (local) |
| Anthropic | `uv pip install 'droidrun[anthropic]'` | `ANTHROPIC_API_KEY` |
| DeepSeek | `uv pip install 'droidrun[deepseek]'` | `DEEPSEEK_API_KEY` |

  </Tab>

  <Tab title="Device Management">

### `droidrun devices`

List connected devices.

```bash
droidrun devices
# Output:
# Found 2 connected device(s):
#   ‚Ä¢ emulator-5554
#   ‚Ä¢ 192.168.1.100:5555
```

---

### `droidrun setup`

Install Portal APK on device.

```bash
# Auto-detect device
droidrun setup

# Specific device
droidrun setup --device emulator-5554

# Custom APK
droidrun setup --path /path/to/portal.apk
```

**What it does:**
1. Downloads latest Portal APK
2. Installs with all permissions
3. Auto-enables accessibility service
4. Opens settings if manual enable needed

---

### `droidrun ping`

Test Portal connection.

```bash
# Test default communication
droidrun ping

# Test TCP mode
droidrun ping --tcp

# Specific device
droidrun ping --device 192.168.1.100:5555
```

**Success output:** `Portal is installed and accessible. You're good to go!`

---

### `droidrun connect`

Connect to device via TCP/IP.

```bash
droidrun connect 192.168.1.100:5555
```

**Prerequisites:**
```bash
# Enable wireless debugging (Android 11+)
# Settings > Developer options > Wireless debugging

# Or via USB:
adb tcpip 5555
adb shell ip route | awk '{print $9}'  # Get IP
droidrun connect <IP>:5555
```

---

### `droidrun disconnect`

Disconnect from device.

```bash
droidrun disconnect 192.168.1.100:5555
```

  </Tab>

  <Tab title="Macros">

Record and replay automation sequences.

### `droidrun macro list`

List saved trajectories.

```bash
# Default directory
droidrun macro list

# Custom directory
droidrun macro list /path/to/trajectories
```

**Output:**
```
Found 3 trajectory(s):

‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ Folder           ‚îÉ Description               ‚îÉ Actions ‚îÉ
‚î°‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î©
‚îÇ open-settings    ‚îÇ Opens settings app        ‚îÇ 3       ‚îÇ
‚îÇ enable-dark-mode ‚îÇ Navigate to display...    ‚îÇ 8       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### `droidrun macro replay`

Replay recorded macro.

```bash
# Basic replay
droidrun macro replay trajectories/open-settings

# Custom device and timing
droidrun macro replay trajectories/login-flow \
  --device emulator-5554 \
  --delay 0.5

# Start from specific step
droidrun macro replay trajectories/checkout \
  --start-from 5 \
  --max-steps 10

# Preview without executing
droidrun macro replay trajectories/test --dry-run
```

**Flags:**

| Flag | Description | Default |
|------|-------------|---------|
| `--device`, `-d` | Device serial | Auto-detect |
| `--delay`, `-t` | Seconds between actions | `1.0` |
| `--start-from`, `-s` | Start step (1-based) | `1` |
| `--max-steps`, `-m` | Max steps to run | All |
| `--dry-run` | Preview only | `false` |

---

### Recording Trajectories

```bash
# Record at action level (most detailed)
droidrun "Create alarm for 7am" --save-trajectory action

# Record at step level
droidrun "Export contacts" --save-trajectory step
```

**Trajectory structure:**
```
trajectories/2025-10-16_14-30-45/
‚îú‚îÄ‚îÄ macro.json       # Action sequence
‚îú‚îÄ‚îÄ step_0.png       # Screenshots
‚îú‚îÄ‚îÄ step_1.png
‚îî‚îÄ‚îÄ ...
```

  </Tab>
</Tabs>

---

## Configuration

### Override Priority

1. **CLI flags** (highest)
2. **Config file** (`config.yaml`)
3. **Defaults** (lowest)

### Common Patterns

<CodeGroup>

```bash Quick Test
droidrun "Turn on dark mode" \
  --provider GoogleGenAI \
  --model models/gemini-2.5-flash
```

```bash Debug Task
droidrun "Book ride to airport" \
  --debug \
  --reasoning \
  --vision \
  --save-trajectory action
```

```bash Cost Optimization
droidrun "Set alarm" \
  --provider GoogleGenAI \
  --model models/gemini-2.5-flash \
  --no-vision
```

```bash Multiple Devices
for device in $(adb devices | awk 'NR>1 {print $1}'); do
  droidrun "Clear notifications" --device $device
done
```

</CodeGroup>

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="No devices found">
```bash
# Check ADB
adb devices

# If unauthorized: Accept prompt on device
# If not listed: Try different USB port/cable
# Restart ADB
adb kill-server && adb start-server
```
  </Accordion>

  <Accordion title="Portal not accessible">
```bash
# Verify installation
adb shell pm list packages | grep droidrun

# Reinstall
droidrun setup

# Enable accessibility manually
adb shell settings put secure enabled_accessibility_services \
  com.droidrun.portal/.DroidrunAccessibilityService
```
  </Accordion>

  <Accordion title="LLM provider errors">
```bash
# Install provider
uv pip install 'droidrun[anthropic]'

# Check API key
echo $GOOGLE_API_KEY

# Set if missing
export GOOGLE_API_KEY=your-key
```
  </Accordion>

  <Accordion title="Command times out">
```bash
# Increase steps
droidrun "Complex task" --steps 50

# Enable debug mode
droidrun "Task" --debug

# Try reasoning mode
droidrun "Multi-step task" --reasoning
```
  </Accordion>

  <Accordion title="TCP connection fails">
```bash
# Enable TCP mode (USB connected first)
adb tcpip 5555

# Get device IP
adb shell ip route | awk '{print $9}'

# Connect
droidrun connect <IP>:5555

# Verify
droidrun ping --tcp
```
  </Accordion>
</AccordionGroup>

---

## Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `GOOGLE_API_KEY` | Google Gemini API key | None |
| `OPENAI_API_KEY` | OpenAI API key | None |
| `ANTHROPIC_API_KEY` | Anthropic API key | None |
| `DEEPSEEK_API_KEY` | DeepSeek API key | None |
| `DROIDRUN_CONFIG` | Config file path | `config.yaml` |

**Setting variables:**

<CodeGroup>

```bash Linux/macOS
export GOOGLE_API_KEY=your-key
```

```bash Windows PowerShell
$env:GOOGLE_API_KEY="your-key"
```

```bash Permanent (Linux/macOS)
echo 'export GOOGLE_API_KEY=your-key' >> ~/.bashrc
source ~/.bashrc
```

</CodeGroup>

---

## Next Steps

- [Configuration Guide](/v4/sdk/configuration) - Customize behavior
- [Device Setup](/v4/guides/device-setup) - Detailed setup instructions
- [Agent Architecture](/v4/concepts/architecture) - How it works
- [Custom Tools](/v4/features/custom-tools) - Extend functionality

```

`docs/v4/guides/device-setup.mdx`:

```mdx
---
title: 'Device Setup'
description: 'Setting up Android and iOS devices for Droidrun automation'
---

## Overview

Droidrun controls devices through a specialized Portal app that bridges your computer and the device.

<Tabs>
  <Tab title="Android Setup">

## Prerequisites

<Steps>
  <Step title="Install ADB">
    **macOS**: `brew install android-platform-tools`

    **Linux**: `sudo apt install adb`

    **Windows**: Download from [Android Developer Site](https://developer.android.com/studio/releases/platform-tools)

    Verify: `adb version`
  </Step>

  <Step title="Enable USB Debugging">
    1. Go to **Settings** > **About phone**
    2. Tap **Build number** 7 times (enables Developer options)
    3. Go to **Settings** > **Developer options**
    4. Enable **USB debugging**
    5. Connect device and tap **Always allow**

    Verify: `adb devices`
  </Step>

  <Step title="Install Portal App">
    ```bash
    # Automatic setup (downloads latest Portal APK)
    droidrun setup

    # Or specify device
    droidrun setup --device SERIAL_NUMBER
    ```

    This will:
    - Download the latest Portal APK
    - Install with all permissions granted
    - Enable accessibility service automatically
  </Step>

  <Step title="Verify Setup">
    ```bash
    droidrun ping
    # Output: Portal is installed and accessible. You're good to go!
    ```
  </Step>
</Steps>

---

## Portal App

The Droidrun Portal (`com.droidrun.portal`) provides:

- **Accessibility Tree** - Extracts UI elements and their properties
- **Device State** - Tracks current activity, keyboard visibility
- **Action Execution** - Tap, swipe, text input, and other actions
- **Dual Communication** - TCP (faster) or Content Provider (fallback)

<Note>
The Portal only communicates locally via ADB. No data is sent to external servers.
</Note>

---

## Communication Modes

<AccordionGroup>
  <Accordion title="TCP Mode (Recommended) - per operation">
    **How it works:**
    - Portal runs HTTP server on device port 8080
    - ADB forwards local port ‚Üí device port 8080
    - Droidrun sends HTTP requests to `localhost:PORT`

    **Enable:**
    ```bash
    # CLI
    droidrun run "your command" --tcp

    # Python
    tools = DeviceConfig(serial="DEVICE_SERIAL", use_tcp=True)
    ```

    **Troubleshooting:**
    ```bash
    # Check port forwarding
    adb forward --list

    # Test Portal server
    adb shell netstat -an | grep 8080

    # Remove all forwards and retry
    adb forward --remove-all
    droidrun ping --tcp
    ```
  </Accordion>

  <Accordion title="Content Provider (Fallback) - per operation">
    **How it works:**
    - Portal exposes content provider at `content://com.droidrun.portal/`
    - Commands sent via ADB shell: `content query --uri ...`
    - JSON responses parsed from shell output

    **Usage:**
    ```bash
    # Default mode (no flag needed)
    droidrun ping

    # Python
    tools = DeviceConfig(serial="DEVICE_SERIAL", use_tcp=False)
    ```

    **Troubleshooting:**
    ```bash
    # Test content provider directly
    adb shell content query --uri content://com.droidrun.portal/state

    # Should show: Row: 0 result={"data": "{...}"}
    ```
  </Accordion>
</AccordionGroup>

---

## Advanced Setup

<AccordionGroup>
  <Accordion title="Wireless Debugging (Android 11+)">
    ### Setup

    <Steps>
      <Step title="Enable Wireless Debugging">
        1. **Settings** > **Developer options** > **Wireless debugging**
        2. Note IP address and port (e.g., `192.168.1.100:37757`)
      </Step>

      <Step title="Pair Device (First Time)">
        **QR Code Method:**
        ```bash
        adb pair <QR_CODE_STRING>
        ```

        **Pairing Code Method:**
        1. Tap **Pair device with pairing code**
        2. Note pairing code and IP:port
        3. Run: `adb pair IP:PORT`
        4. Enter pairing code
      </Step>

      <Step title="Connect">
        ```bash
        adb connect IP:PORT
        droidrun ping --device IP:PORT
        ```
      </Step>
    </Steps>

    ### Common Issues

    - Connection refused ‚Üí Check same WiFi network and firewall
    - Frequent drops ‚Üí Use 5GHz WiFi or stay near router
    - Can't find IP ‚Üí Run `adb shell ip addr show wlan0 | grep "inet "` via USB
  </Accordion>

  <Accordion title="Wireless Debugging (Android 10 and Below)">
    <Steps>
      <Step title="Enable TCP/IP Mode (USB Required)">
        ```bash
        # Connect via USB first
        adb tcpip 5555
        ```
      </Step>

      <Step title="Find Device IP">
        ```bash
        adb shell ip addr show wlan0 | grep inet
        ```
      </Step>

      <Step title="Connect Wirelessly">
        ```bash
        # Disconnect USB cable
        adb connect DEVICE_IP:5555
        droidrun ping --device DEVICE_IP:5555
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Multiple Devices">
    ### List Devices

    ```bash
    droidrun devices
    # Found 2 connected device(s):
    #   ‚Ä¢ emulator-5554
    #   ‚Ä¢ 192.168.1.100:5555
    ```

    ### Target Specific Device

    ```bash
    # CLI
    droidrun run "your command" --device emulator-5554

    # Python
    tools = DeviceConfig(serial="emulator-5554")
    agent = DroidAgent(goal="your task", tools=tools)
    ```

    ### Parallel Control

    ```python
    import asyncio
    from droidrun import DeviceConfig, DroidrunConfig, DroidAgent
    from adbutils import adb

    async def control_device(serial: str, command: str):
        device_config = DeviceConfig(serial=serial)
        config = DroidrunConfig(device=device_config)
        agent = DroidAgent(goal=command, config=config)
        return await agent.run()

    async def main():
        devices = adb.list()

        tasks = [
            control_device(devices[0].serial, "Open settings"),
            control_device(devices[1].serial, "Check battery"),
        ]

        results = await asyncio.gather(*tasks)
        print(results)

    asyncio.run(main())
    ```
  </Accordion>
</AccordionGroup>

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="Device not found">
    **Symptoms:** `adb devices` shows no devices or `unauthorized`

    **Solutions:**
    1. Unplug/replug USB cable, try different port
    2. Revoke USB debugging authorizations (Developer options)
    3. Reconnect and tap "Always allow"
    4. Restart ADB: `adb kill-server && adb start-server`
    5. **Windows**: Install [Google USB Driver](https://developer.android.com/studio/run/win-usb)
  </Accordion>

  <Accordion title="Portal not installed">
    **Symptoms:** `droidrun ping` fails with "Portal is not installed"

    **Solutions:**
    1. Reinstall: `droidrun setup`
    2. Check: `adb shell pm list packages | grep droidrun`
    3. Verify APK architecture matches device (arm64-v8a for most devices)
  </Accordion>

  <Accordion title="Accessibility service not enabled">
    **Symptoms:** `droidrun ping` fails with "accessibility service not enabled"

    **Solutions:**
    1. Auto-enable:
       ```bash
       adb shell settings put secure enabled_accessibility_services \
         com.droidrun.portal/com.droidrun.portal.DroidrunAccessibilityService
       adb shell settings put secure accessibility_enabled 1
       ```
    2. Manual: Settings > Accessibility > Droidrun Portal > Toggle ON
    3. Verify:
       ```bash
       adb shell settings get secure enabled_accessibility_services
       # Should contain: com.droidrun.portal/...
       ```
  </Accordion>

  <Accordion title="Text input not working">
    **Symptoms:** `input_text()` fails or types gibberish

    **Solutions:**
    1. Keyboard auto-enabled by `AdbTools.__init__()`:
       ```bash
       # Verify
       adb shell settings get secure default_input_method
       # Should show: com.droidrun.portal/.DroidrunKeyboardIME
       ```
    2. Manual switch: Long press space bar ‚Üí Select "Droidrun Keyboard"
    3. Focus element first: `tools.tap_by_index(5)` then `tools.input_text("text")`
  </Accordion>

  <Accordion title="Empty UI state">
    **Symptoms:** `get_state()` returns empty or incomplete UI tree

    **Solutions:**
    1. Verify accessibility: `droidrun ping`
    2. Some apps block accessibility services (WebViews, games, custom UI)
    3. Wait for UI: `time.sleep(1)` after tap/swipe
    4. Enable Portal overlay to see detected elements
  </Accordion>
</AccordionGroup>

  </Tab>

  <Tab title="iOS Setup (experimental)">

<Warning>
iOS support is currently **experimental**. Functionality is limited compared to Android.
</Warning>

---

## Prerequisites

- **macOS** with Xcode installed
- **iOS device** with Developer mode enabled
- **iOS Portal app** (separate from Android Portal)

---

## Setup

<Steps>
  <Step title="Install iOS Portal">
    The iOS Portal app must be manually installed on your device.

    <Note>
    Installation instructions and download link coming soon.
    </Note>
  </Step>

  <Step title="Get Device IP">
    Find your iOS device's IP address in Settings > WiFi > (i) icon
  </Step>

  <Step title="Test Connection">
    ```python
    from droidrun import IOSTools

    tools = IOSTools(url="http://DEVICE_IP:8080")
    result = tools.ping()
    print(result)
    ```
  </Step>
</Steps>

---

## Architecture

iOS Portal uses a different architecture than Android:

| Feature | Android | iOS |
|---------|---------|-----|
| Communication | ADB + TCP/Content Provider | HTTP server only |
| Setup Tool | `droidrun setup` | Manual installation |
| Accessibility | Android Accessibility API | iOS Accessibility API |
| Text Input | Custom keyboard IME | Direct text input |

---

## Usage

### Python API

```python
from droidrun import IOSTools, DroidAgent

# Initialize iOS tools with device URL
tools = IOSTools(
    url="http://192.168.1.100:8080",
    bundle_identifiers=["com.example.app"]  # Optional
)

# Create agent
agent = DroidAgent(
    goal="Open Settings and check WiFi",
    tools=tools
)

result = await agent.run()
```

### CLI

```bash
# Use --ios flag
droidrun run "your command" --ios

# Or set platform in config.yaml:
# device:
#   platform: ios
```

---

## Limitations

Current iOS support has these limitations:

| Feature | Status | Notes |
|---------|--------|-------|
| `get_date()` | ‚ùå | Returns "Not implemented for iOS" |
| `back()` | ‚ùå | Raises `NotImplementedError` |
| `drag()` | ‚ùå | Not implemented, returns False |
| `get_apps()` | ‚ö†Ô∏è | Use `list_packages()` instead |
| `input_text()` | ‚ö†Ô∏è | No `index` or `clear` parameters |
| `tap()`, `swipe()` | ‚úÖ | Fully supported |
| `get_state()` | ‚úÖ | Returns accessibility tree |
| `take_screenshot()` | ‚úÖ | Fully supported |

  </Tab>
</Tabs>

---

## Next Steps

- Learn about the [Agent System](/v4/concepts/architecture)
- Explore [Configuration Options](/v4/sdk/configuration)
- Try [Custom Tools](/v4/features/custom-tools)
- Implement [Structured Output](/v4/features/structured-output)

```

`docs/v4/guides/docker.mdx`:

```mdx
---
title: 'Quickstart with Docker'
description: 'Get up and running with Droidrun in Docker quickly and effectively'
---

This guide will help you get Droidrun running in a Docker container, controlling your Android device through natural language without installing it natively.

### Host configuration

Follow the steps below to ensure your host system is properly configured to mount the smartphone inside the container.

1. Make sure you‚Äôve completed the prerequisite steps in the [Quickstart](/v4/quickstart). Then verify the ADB connection with `adb devices`. This should list your phone as ‚Äúdevice‚Äù along with its Serial Number. If the phone appears as `unauthorized` make sure to accept the prompt on your phone.

2. Confirm that the ADB keys have been correctly created. Check for an `.android` folder under your `$HOME` directory that contains: `adb.5037`, `adbkey`, and `adbkey.pub`.

3. Set up a custom rule to uniquely identify your phone and map it to a static path:
   - Open a terminal and find your device‚Äôs `idVendor` and `idProduct` using the `lsusb` command.

      In the example below, the `idVendor` and `idProduct` are `18d1` and `4ee2`, respectively.

      ```bash
      > lsusb
      Bus 003 Device 002: ID 18d1:4ee2 Google Inc. Nexus/Pixel Device (MTP + debug)
      ```

   - Create a new file (sudo may be required) under `/etc/udev/rules.d` and name it `51-android.rules`.

   - Add the following content and save the file:

      ```bash
      SUBSYSTEM=="usb", ATTR{idVendor}=="XXXX", ATTR{idProduct}=="YYYY", ATTR{serial}=="SSSS", MODE="0666", GROUP="plugdev", SYMLINK+="phone1/phone"
      ```

      where `XXXX`, `YYYY`, and `SSSS` are the vendor ID, product ID, and serial number of your phone.

      This static mapping is required because otherwise the phone‚Äôs mount path will change across reconnections!

   - Reload the rules

      ```bash
      sudo udevadm control --reload-rules
      sudo udevadm trigger
      ```

4. Kill the ADB server on the host so that the container can actually detect the phone:

   ```bash
   adb kill-server
   ```

### Usage

Pull the image from the GitHub Container Registry:

```bash
docker pull ghcr.io/droidrun/droidrun:latest
```

Before running the container, note that the following options are always required when launching Droidrun in Docker:

| Docker option | What it does | Why it matters for Droidrun |
|---------------|--------------|-----------------------------|
| `--group-add plugdev` | Adds the host user to the container‚Äôs `plugdev` group. | Gives the container permission to access USB devices (e.g., your Android phone) without requiring root. |
| `--device /dev/phone1/phone:/dev/phone` | Maps a specific USB device file from the host into the container. Thanks to our udev rule, the phone will always be mapped here. | Allows Droidrun to see the phone as `/dev/phone` inside the container, so it can communicate with the device. |
| `--volume /dev/bus/usb:/dev/bus/usb` | Mounts the entire USB bus directory. | Provides access to all connected USB devices, enabling Droidrun to discover and interact with the phone. |
| `--volume ~/.android:/home/droidrun/.android` | Mounts the host‚Äôs Android configuration directory into the container. | Stores ADB keys and settings so that once you grant permission on the host, Droidrun doesn‚Äôt prompt for it again inside the container. |

The Docker image uses the `droidrun` entrypoint, which means you can use any of the CLI commands described in the [CLI Usage](/v4/guides/cli) section and append it to the following base command:

```bash
docker run \
  --group-add plugdev \
  --device /dev/phone1/phone:/dev/phone \
  --volume /dev/bus/usb:/dev/bus/usb \
  --volume ~/.android:/home/droidrun/.android \
  ghcr.io/droidrun/droidrun:latest \
  <droidrun command>
```

#### Set Up the Portal APK

Simply run the container with the `setup` CLI command.

```bash
docker run \
  --group-add plugdev \
  --device /dev/phone1/phone:/dev/phone \
  --volume /dev/bus/usb:/dev/bus/usb \
  --volume ~/.android:/home/droidrun/.android \
  ghcr.io/droidrun/droidrun:latest \
  setup
```

#### Verify the setup

Simply run the container with the `ping` CLI command.

```bash
docker run \
  --group-add plugdev \
  --device /dev/phone1/phone:/dev/phone \
  --volume /dev/bus/usb:/dev/bus/usb \
  --volume ~/.android:/home/droidrun/.android \
  ghcr.io/droidrun/droidrun:latest \
  ping
```

#### Run some agents

Now you‚Äôre ready to control your device using Docker and natural language:

```bash
# Using default configuration with Google API key
docker run --group-add plugdev --device /dev/phone1/phone:/dev/phone --volume /dev/bus/usb:/dev/bus/usb --volume ~/.android:/home/droidrun/.android --env GOOGLE_API_KEY=your-api-key-here ghcr.io/droidrun/droidrun:latest run "Open the settings app and tell me the Android version"

# Override provider and model
docker run --group-add plugdev --device /dev/phone1/phone:/dev/phone --volume /dev/bus/usb:/dev/bus/usb --volume ~/.android:/home/droidrun/.android --env OPENAI_API_KEY=your-api-key-here ghcr.io/droidrun/droidrun:latest run "Open a browser and search for droidrun" -p OpenAI -m gpt-4o

# Use a locally-running LLM, example for LM Studio running in the LAN
docker run --group-add plugdev --device /dev/phone1/phone:/dev/phone --volume /dev/bus/usb:/dev/bus/usb --volume ~/.android:/home/droidrun/.android --network host ghcr.io/droidrun/droidrun:latest run "Open a browser and search for droidrun" -p OpenAILike -m gpt-oss --api_base http://IP-of-LMStudio-server:PORT/v1
```

#### Troubleshooting

* Error response from daemon

   If you encounter the following error:

   ```
   docker: Error response from daemon: error gathering device information while adding custom '/dev/phone1/phone': no such file or directory
   ```

   it usually indicates one of two things:
   - The phone isn‚Äôt mounted at the expected custom path. Verify that `/dev/phone1/phone` exists.
   - An ADB server is still running on the host. Stop it with `adb kill-server`.

---

## Next Steps

- [CLI Usage](/v4/guides/cli) - Dive into the various parameters and start building your own projects with Docker!

```

`docs/v4/guides/migration-v3-to-v4.mdx`:

```mdx
---
title: 'Migration Guide: v3 to v4'
description: 'Migrate your Droidrun projects from v3 to v4 with this step-by-step guide.'
---

This guide will help you migrate your Droidrun projects from v3 to v4. Version 4 introduces significant changes to installation, configuration, and API design that improve developer experience and simplify usage.

---

## Overview of Major Changes

Droidrun v4 introduces several breaking changes:

1. **Installation method** changed from `pip` to `uv`
2. **Python version requirement** increased from 3.10+ to 3.11+
3. **Configuration system** completely redesigned with `DroidrunConfig`
4. **Agent API** simplified with config-based initialization
5. **LLM initialization** now handled through config profiles
6. **Result format** changed from dictionary to `ResultEvent` object
7. **Credential Manager** feature included for secure handling of sensitive data
8. **App Instruction Cards** for improved app navigation
9. **Custom Tools** support for extending agent capabilities
10. **Output Extraction** using Pydantic models for structured data

---

## Installation Changes

### v3 Installation
```bash
pip install 'droidrun[google,anthropic,openai,deepseek,ollama,dev]'
```

### v4 Installation

**For CLI usage only:**
```bash
uv tool install droidrun
```

**For CLI + Python integration:**
```bash
uv pip install droidrun
```

<Note>
Most LLM providers (Google Gemini, OpenAI, Ollama, OpenRouter) are included by default. For additional providers, install extras: `uv pip install 'droidrun[anthropic,deepseek]'`.
</Note>

Note: `droidrun` now provides a `--version` flag ‚Äî verify your installation with `droidrun --version` after installing.

### Migration Steps

1. **Install uv** (if not already installed):
   ```bash
   # macOS/Linux
   curl -LsSf https://astral.sh/uv/install.sh | sh
   
   # Windows (PowerShell)
   powershell -c "irm https://astral.sh/uv/install.ps1 | iex"
   ```

2. **Uninstall v3** (optional but recommended):
   ```bash
   pip uninstall droidrun
   ```

3. **Install v4** using your preferred method above

4. **Update Python version** to 3.11+ if needed

---

## Configuration System Changes

### v3: No Config Files
v3 had no configuration files. All settings were passed directly to the agent.

### v4: Configuration-Driven Approach

v4 uses a `config.yaml` file that is automatically created on first run:

```yaml
# config.yaml (auto-generated)
llm_profiles:
  - name: "gemini-flash"
    provider: "GoogleGenAI"
    model: "models/gemini-2.5-flash"
    
  - name: "gpt-4o"
    provider: "OpenAI"
    model: "gpt-4o"

default_profile: "gemini-flash"
vision: false
reasoning: false
max_steps: 15
```

### Migration Steps

1. **Create config.yaml** (automatically created on first run, or copy from `config_example.yaml`)

2. **Define your LLM profiles** in the config file instead of in code

3. **Set environment variables** for API keys:
   ```bash
   export GOOGLE_API_KEY=your-api-key
   export OPENAI_API_KEY=your-api-key
   export ANTHROPIC_API_KEY=your-api-key
   ```

---

## API Changes

### Agent Initialization

**v3 Code:**
```python
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

# Manual LLM setup
llm = GoogleGenAI(
    api_key="YOUR_GEMINI_API_KEY",
    model="gemini-2.5-flash",
)

# Manual tools loading
tools = AdbTools()

# Agent creation
agent = DroidAgent(
    goal="Open Settings and check battery level",
    llm=llm,
    tools=tools,
    vision=True,
    reasoning=False,
)
```

**v4 Code:**
```python
from droidrun import DroidAgent
from droidrun.config_manager.config_manager import DroidrunConfig

# Config-based initialization (LLMs loaded automatically)
config = DroidrunConfig()

# Agent creation (tools loaded automatically)
agent = DroidAgent(
    goal="Open Settings and check battery level",
    config=config,
)
```

### Key Differences

| Feature | v3 | v4 |
|---------|----|----|
| **LLM Setup** | Manual instantiation | Loaded from config profiles |
| **Tools Loading** | Manual `AdbTools()` | Automatic from config |
| **Configuration** | Constructor parameters | `DroidrunConfig` object |
| **API Keys** | In code | Environment variables |

---

## Result Object Changes

### v3: Dictionary Result
```python
result = await agent.run()
print(f"Success: {result['success']}")
if result.get('output'):
    print(f"Output: {result['output']}")
```

### v4: ResultEvent Object
```python
result = await agent.run()
print(f"Success: {result.success}")
print(f"Reason: {result.reason}")
print(f"Steps: {result.steps}")
```

### Migration Steps

Update all result access patterns:
- `result['success']` ‚Üí `result.success`
- `result.get('output')` ‚Üí `result.reason` (or appropriate attribute)
- Add access to new fields: `result.steps`

---

## CLI Changes

### New CLI Flags

v4 introduces additional flags:

| Flag | Description | Default |
|------|-------------|---------|
| `--config`, `-c` | Custom config path | `config.yaml` |
| `--device`, `-d` | Device serial or IP | Auto-detect |
| `--tcp` | Use TCP instead of content provider | `false` |
| `--save-trajectory` | Save execution data | `none` |

---

## Breaking Changes Summary

### 1. Python Version
- **v3:** Python 3.10+
- **v4:** Python 3.11+
- **Action:** Update your Python installation

### 2. Installation Tool
- **v3:** `pip install`
- **v4:** `uv tool install` or `uv pip install`
- **Action:** Install `uv` and use new commands

### 3. Import Changes
```python
# v3
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

# v4
from droidrun import DroidAgent
from droidrun.config_manager.config_manager import DroidrunConfig
# No need to import LLM classes directly
```

### 4. Agent Constructor
```python
# v3: Multiple required parameters
agent = DroidAgent(
    goal="...",
    llm=llm,           # Required
    tools=tools,       # Required
    vision=True,
    reasoning=False,
)

# v4: Config-based, simplified
agent = DroidAgent(
    goal="...",
    config=config,     # Single config object
)
```

### 5. LLM Management
- **v3:** Manually instantiate LLM objects
- **v4:** Define profiles in `config.yaml`, loaded automatically
- **Action:** Move LLM configs to `config.yaml`

### 6. Tools Loading
- **v3:** `tools = AdbTools()` required
- **v4:** Tools loaded automatically from config
- **Action:** Remove manual `AdbTools()` instantiation

### 7. Result Access
- **v3:** Dictionary with string keys
- **v4:** Object with attributes
- **Action:** Update result access patterns

---

## Step-by-Step Migration Guide

### Step 1: Update Environment

```bash
# Install uv
curl -LsSf https://astral.sh/uv/install.sh | sh  # macOS/Linux

# Upgrade Python if needed
python --version  # Should be 3.11+

# Uninstall v3
pip uninstall droidrun
```

### Step 2: Install v4

```bash
# For CLI + Python integration
uv pip install droidrun

# Or for CLI only
uv tool install droidrun

# For additional providers (Anthropic, DeepSeek)
uv pip install 'droidrun[anthropic,deepseek]'
```

### Step 3: Create Configuration

```bash
# Run any command to auto-generate config.yaml
droidrun ping
```

Edit `config.yaml` to add your LLM profiles:

```yaml
llm_profiles:
  - name: "my-gemini"
    provider: "GoogleGenAI"
    model: "models/gemini-2.5-flash"
    
  - name: "my-gpt4"
    provider: "OpenAI"
    model: "gpt-4o"

default_profile: "my-gemini"
vision: false
reasoning: false
max_steps: 15
```

### Step 4: Set Environment Variables

```bash
export GOOGLE_API_KEY=your-api-key
export OPENAI_API_KEY=your-api-key
export ANTHROPIC_API_KEY=your-api-key
```

### Step 5: Update Your Code

**Before (v3):**
```python
import asyncio
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    tools = AdbTools()
    llm = GoogleGenAI(
        api_key="YOUR_GEMINI_API_KEY",
        model="gemini-2.5-flash",
    )
    
    agent = DroidAgent(
        goal="Open Settings and check battery level",
        llm=llm,
        tools=tools,
        vision=True,
        reasoning=False,
    )
    
    result = await agent.run()
    print(f"Success: {result['success']}")
    if result.get('output'):
        print(f"Output: {result['output']}")

if __name__ == "__main__":
    asyncio.run(main())
```

**After (v4):**
```python
import asyncio
from droidrun import DroidAgent
from droidrun.config_manager.config_manager import DroidrunConfig

async def main():
    config = DroidrunConfig()
    
    agent = DroidAgent(
        goal="Open Settings and check battery level",
        config=config,
    )
    
    result = await agent.run()
    print(f"Success: {result.success}")
    print(f"Reason: {result.reason}")
    print(f"Steps: {result.steps}")

if __name__ == "__main__":
    asyncio.run(main())
```

### Step 6: Test Your Migration

```bash
# Test device connection
droidrun ping

# Test simple command
droidrun "Open Settings"

# Test your Python script
python your_script.py
```

---

## New Features in v4

Droidrun v4 introduces several powerful new features that weren't available in v3. Here's a quick overview:

### 1. Structured Output Extraction

Extract typed data from device interactions using Pydantic models:

```python
from pydantic import BaseModel, Field
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

class ContactInfo(BaseModel):
    name: str = Field(description="Full name")
    phone: str = Field(description="Phone number")
    email: str = Field(description="Email address")

config = DroidrunConfig()

agent = DroidAgent(
    goal="Find John Smith's contact information",
    config=config,
    output_model=ContactInfo,  # NEW in v4
)

result = await agent.run()
contact = result.structured_output  # Typed Pydantic object
print(f"Name: {contact.name}, Phone: {contact.phone}")
```

The agent automatically extracts structured data into your Pydantic model after completing the task. **‚Üí See [Structured Output Documentation](/v4/features/structured-output)** for detailed examples and best practices.

---

### 2. Credential Management

Securely manage passwords, API keys, and tokens without hardcoding them:

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# In-memory credentials (recommended for SDK)
credentials = {
    "EMAIL_USER": "user@example.com",
    "EMAIL_PASS": "secret_password",
    "API_KEY": "sk-1234567890"
}

config = DroidrunConfig()

agent = DroidAgent(
    goal="Login to Gmail with my credentials",
    config=config,
    credentials=credentials,  # NEW in v4
)

result = await agent.run()
```

Credentials are never logged or exposed - agents use `type_secret()` to securely input sensitive data. You can also store credentials in a `config/credentials.yaml` file. **‚Üí See [Credential Management Documentation](/v4/features/credentials)** for YAML configuration and advanced usage.

---

### 3. App Instruction Cards

Teach agents how to use specific apps with custom instruction guides:

```bash
# App cards are enabled by default
droidrun run "Send an email to john@example.com" --reasoning
```

When your agent opens an app (like Gmail, Chrome, WhatsApp), it automatically loads app-specific instructions that help it:
- Navigate the UI efficiently
- Find buttons and features quickly
- Use app-specific shortcuts and search syntax
- Complete tasks with higher success rates

**Create your own app cards:**

```bash
# 1. Create app cards directory
mkdir -p config/app_cards

# 2. Create a markdown file for your app
touch config/app_cards/chrome.md

# 3. Register in app_cards.json
echo '{"com.android.chrome": "chrome.md"}' > config/app_cards/app_cards.json
```

**‚Üí See [App Instruction Cards Documentation](/v4/features/app-cards)** for examples, best practices, and troubleshooting.

---

### 4. Custom Tools

Extend agent capabilities with custom Python functions for external APIs, data processing, or domain-specific logic:

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

def calculate_tax(amount: float, rate: float, **kwargs) -> str:
    """Calculate tax for a given amount."""
    tax = amount * rate
    total = amount + tax
    return f"Tax: ${tax:.2f}, Total: ${total:.2f}"

custom_tools = {
    "calculate_tax": {
        "arguments": ["amount", "rate"],
        "description": "Calculate tax for a given amount and rate",
        "function": calculate_tax
    }
}

config = DroidrunConfig()

agent = DroidAgent(
    goal="Calculate tax for $100 at 8% rate",
    config=config,
    custom_tools=custom_tools,  # NEW in v4
)

result = await agent.run()
```

Custom tools can access device state, shared memory, and credentials. **‚Üí See [Custom Tools Documentation](/v4/features/custom-tools)** for accessing device state, API integration patterns, and advanced examples.

---

### 5. Advanced Configuration System

v4 introduces granular configuration for all aspects of agent behavior:

```python
from droidrun.config_manager import (
    DroidrunConfig,
    AgentConfig,
    CodeActConfig,
    ManagerConfig,
    ExecutorConfig,
    ScripterConfig,
    AppCardConfig,
    DeviceConfig,
    LoggingConfig,
    TracingConfig
)

config = DroidrunConfig(
    agent=AgentConfig(
        max_steps=30,
        reasoning=True,
        after_sleep_action=1.5,
        codeact=CodeActConfig(vision=True, safe_execution=True),
        manager=ManagerConfig(vision=True),
        executor=ExecutorConfig(vision=False),
        scripter=ScripterConfig(enabled=True, max_steps=10),
        app_cards=AppCardConfig(enabled=True, mode="local")
    ),
    device=DeviceConfig(serial="emulator-5554", use_tcp=False),
    logging=LoggingConfig(debug=True, save_trajectory="action"),
    tracing=TracingConfig(enabled=True)
)

agent = DroidAgent(goal="Complex task", config=config)
```

**‚Üí See [Configuration Reference Documentation](/v4/sdk/droid-agent)** for all available configuration classes and parameters.

---

### 6. Per-Agent LLM Configuration

Use different LLMs for different agent roles (planning, execution, code generation):

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig
from llama_index.llms.openai import OpenAI
from llama_index.llms.gemini import Gemini

config = DroidrunConfig()

agent = DroidAgent(
    goal="Complex multi-step task",
    config=config,
    llms={
        "manager": OpenAI(model="gpt-4o"),                    # Planning
        "executor": Gemini(model="models/gemini-2.5-flash"),  # Action selection
        "codeact": Gemini(model="models/gemini-2.5-pro"),     # Code generation
        "text_manipulator": Gemini(model="models/gemini-2.5-flash"),  # Text input
        "app_opener": OpenAI(model="gpt-4o-mini"),            # App launching
        "scripter": Gemini(model="models/gemini-2.5-flash"),  # Off-device scripts
        "structured_output": Gemini(model="models/gemini-2.5-flash"),  # Output extraction
    }
)
```

This allows you to optimize cost and performance by using appropriate models for each task. **‚Üí See [SDK Configuration Documentation](/v4/sdk/configuration)** for all LLM keys and configuration options.

---

### 7. Custom Variables

Pass non-sensitive contextual data to agents:

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

config = DroidrunConfig()

agent = DroidAgent(
    goal="Send report to the project lead",
    config=config,
    variables={
        "project_id": "12345",
        "lead_email": "alice@example.com",
        "api_endpoint": "https://api.example.com"
    }
)
```

Variables are accessible throughout execution in `shared_state.custom_variables` and can be used in custom tools or referenced by agents.
**‚Üí See [Custom Variables Documentation](/v4/features/custom-variables)** for usage patterns.

---

### 8. Tracing and Trajectory Recording

Monitor agent execution with real-time Phoenix tracing and local trajectory recording:
```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig, TracingConfig, LoggingConfig

config = DroidrunConfig(
    tracing=TracingConfig(enabled=True),  # Phoenix tracing
    logging=LoggingConfig(save_trajectory="step")  # Local recording
)

agent = DroidAgent(goal="Open Settings", config=config)
result = await agent.run()
```

Or via CLI:
```bash
# Enable Phoenix tracing
droidrun run "Open Settings" --tracing

# Enable trajectory recording (screenshots + UI state)
droidrun run "Open Settings" --save-trajectory step
```

**Phoenix Tracing** provides real-time monitoring of:
- LLM calls with prompts and token usage
- Agent workflow execution
- Tool invocations and results

**Trajectory Recording** saves locally:
- Screenshots per step/action
- UI state and element hierarchies
- Agent reasoning and decisions

Trajectories are saved to `trajectories/` directory for offline debugging. 
**‚Üí See [Tracing Documentation](/v4/features/tracing)** for Phoenix setup, configuration options, and trajectory analysis.

---


*Last updated: November 2025*
```

`docs/v4/guides/overview.mdx`:

```mdx
---
title: Overview
---

Welcome to the Droidrun Guides! This section provides step-by-step instructions and best practices for using Droidrun. Each guide focuses on a specific aspect of the framework, from device setup to advanced automation patterns.

---

## Available Guides

### Getting Started

**[CLI Reference](./cli)** - Complete command-line interface guide
- All CLI commands (`run`, `setup`, `devices`, `connect`, `ping`, `macro`)
- Configuration overrides and flags
- Environment variables and API keys
- Common workflows and troubleshooting

**[Device Setup](./device-setup)** - Set up Android and iOS devices
- Portal app installation and configuration
- Accessibility service enablement
- TCP vs Content Provider communication
- Wireless debugging and multi-device management

**[Configuration System](/v4/sdk/configuration)** - Master the config-driven architecture
- YAML configuration structure
- LLM profiles per agent (Manager, Executor, CodeAct, Scripter)
- Mixing LLM providers (OpenAI, Anthropic, Google, Ollama, DeepSeek)
- Safe execution, prompts, and app cards

---

### Templates

Explore real-world examples and starter projects in the [droidrun-examples repository](https://github.com/droidrun/droidrun-examples):

- **[LinkedInJobsScraper](https://github.com/droidrun/droidrun-examples/tree/main/LinkedInJobsScraper)** - Agentic workflow that searches LinkedIn for roles, evaluates matches, and prepares tailored applications
- **[LinkedInLeads](https://github.com/droidrun/droidrun-examples/tree/main/LinkedInLeads)** - End-to-end lead discovery and enrichment for LinkedIn companies and roles
- **[TwitterPost](https://github.com/droidrun/droidrun-examples/tree/main/TwitterPost)** - Finds trending topics, drafts posts, and generates images to publish on X/Twitter
- **[play2048](https://github.com/droidrun/droidrun-examples/tree/main/play2048)** - DroidAgent that plays the 2048 game on play2048.co

Each example includes a self-contained workflow with entrypoint, configuration, and sample data. See the [README](https://github.com/droidrun/droidrun-examples) for setup instructions and contribution guidelines.


---

Need help? Join our [Discord community](https://discord.gg/ZZbKEZZkwK) for support and discussions.

```

`docs/v4/overview.mdx`:

```mdx
---
title: 'Overview'
description: 'Droidrun is a powerful framework that enables you to control Android and iOS devices through intelligent LLM agents. Build sophisticated mobile automation workflows with natural language commands.'
---

<CardGroup cols={2}>
  <Card title="Quickstart" icon="rocket" href="/v4/quickstart">
    Get up and running with Droidrun in minutes
  </Card>
  <Card title="Guides" icon="code" href="/v4/guides/overview">
   View Templates for example Use Cases
  </Card>
  <Card title="Agent Architecture" icon="bot" href="/v4/concepts/architecture">
    Understand the hierarchical agent system
  </Card>
  <Card title="SDK Reference" icon="book" href="/v4/sdk/reference">
    Explore the complete API documentation
  </Card>
</CardGroup>

## Core Features

Learn about the powerful features that make Droidrun a comprehensive mobile automation framework. These capabilities enable you to build sophisticated, production-ready automation workflows.

<CardGroup cols={2}>
  <Card title="Structured Output" icon="table" href="/v4/features/structured-output">
    Extract typed data with Pydantic
  </Card>
  <Card title="Credential Management" icon="shield-check" href="/v4/features/credentials">
    Store and manage API keys securely
  </Card>
  <Card title="App Cards" icon="id-card" href="/v4/features/app-cards">
    Provide app-specific guidance
  </Card>
  <Card title="Custom Tools" icon="wrench" href="/v4/features/custom-tools">
    Extend capabilities with custom functions
  </Card>
</CardGroup>


## Runtime

Choose your preferred environment for running Droidrun automations, from local physical devices to cloud-based solutions.

<CardGroup cols={2}>
<Card icon="smartphone" title="Physical Device" href="/v4/guides/device-setup" arrow>
 - Connect your own physical Android device for direct automation
</Card>
<Card icon="cloud" title="Cloud Environment" href="https://cloud.droidrun.ai">
 - Access our managed cloud environment for instant mobile app automation without any setup.
</Card>
</CardGroup>
```

`docs/v4/quickstart.mdx`:

```mdx
---
title: 'Quickstart'
description: 'Get up and running with Droidrun quickly and effectively'
---

<iframe
  className="w-full aspect-video rounded-xl"
  src="https://www.youtube.com/embed/4WT7FXJah2I"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
></iframe>

This guide will help you get Droidrun installed and running quickly, controlling your Android device through natural language in minutes.

### Prerequisites

Before installing Droidrun, ensure you have:

1. **Python 3.11+** installed on your system (Python 3.14 is not currently supported)
2. [Android Debug Bridge (adb)](https://developer.android.com/studio/releases/platform-tools) installed and configured
3. **Android device** with:
   - [Developer options enabled](https://developer.android.com/studio/debug/dev-options)
   - USB debugging enabled
   - Connected via USB or on the same network (for wireless debugging)

### Installation

Droidrun is installed using [`uv`](https://docs.astral.sh/uv/), a fast Python package installer and resolver.

**Install uv (if not already installed):**

```bash
# macOS/Linux
curl -LsSf https://astral.sh/uv/install.sh | sh

# Windows (PowerShell)
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"
```

**Choose your installation method:**

**For CLI usage only:**
```bash
uv tool install droidrun
```

**For CLI + Python code integration:**
```bash
uv pip install droidrun
```

<Note>
Most LLM providers (Google Gemini, OpenAI, Ollama, OpenRouter) are included by default. For additional providers, install extras: `uv tool install 'droidrun[anthropic,deepseek]'`.
</Note>

### Set Up the Portal APK

Droidrun requires the Portal app to be installed on your Android device for device control. The Portal app provides accessibility services that expose the UI accessibility tree, enabling the agent to see and interact with UI elements.

```bash
droidrun setup
```

This command automatically:
1. Downloads the latest Portal APK
2. Installs it on your connected device
3. Enables the accessibility service

### Test Connection

Verify that Droidrun can communicate with your device:

```bash
droidrun ping
```

If successful, you'll see:
```
‚úì Portal is running
‚úì Accessibility service enabled
‚úì Device ready
```

### Configure Your LLM

Droidrun uses a configuration-driven approach. On first run, Droidrun creates a `config.yaml` file with default settings. You'll need to set your API key for your chosen LLM provider.

**Set your API key:**

```bash
# For Google Gemini (default)
export GOOGLE_API_KEY=your-api-key-here

# For OpenAI
export OPENAI_API_KEY=your-api-key-here

# For Anthropic Claude
export ANTHROPIC_API_KEY=your-api-key-here

# For DeepSeek
export DEEPSEEK_API_KEY=your-api-key-here
```

### Run Your First Command via CLI

Now you're ready to control your device with natural language:

```bash
# Using default configuration (Google Gemini)
droidrun run "Open the settings app and tell me the Android version"

# Override provider and model
droidrun run "Check the battery level" --provider OpenAI --model gpt-4o

# Enable vision mode (sends screenshots to LLM)
droidrun run "What app is currently open?" --vision

# Enable reasoning mode (uses Manager-Executor workflow for complex tasks)
droidrun run "Find a contact named John and send him an email" --reasoning
```

**Common CLI flags:**
- `--provider` - LLM provider (GoogleGenAI, OpenAI, Anthropic, etc.)
- `--model` - Model name (models/gemini-2.5-pro, gpt-4o, etc.)
- `--vision` - Enable screenshot processing
- `--reasoning` - Enable multi-agent planning mode
- `--steps N` - Maximum execution steps (default: 15)
- `--debug` - Enable detailed logging

### Create a Simple Agent via Script

For complex automation or integration into your Python projects, create a script:

```python
import asyncio
from droidrun import DroidAgent, DroidrunConfig

async def main():
    # Use default configuration with built-in LLM profiles
    config = DroidrunConfig()

    # Create agent
    # LLMs are automatically loaded from config.llm_profiles
    agent = DroidAgent(
        goal="Open Settings and check battery level",
        config=config,
    )

    # Run agent
    result = await agent.run()

    # Check results (result is a ResultEvent object)
    print(f"Success: {result.success}")
    print(f"Reason: {result.reason}")
    print(f"Steps: {result.steps}")

if __name__ == "__main__":
    asyncio.run(main())
```

## Next Steps

Now that you've got Droidrun running, explore these topics:

- Walk through a [Guide](/v4/guides/overview)
- Learn about [Agent Architecture](/v4/concepts/architecture)
- Customize the Agent [Configuration System](/v4/sdk/configuration)
- Guide the agent with [App Cards](/v4/features/app-cards)


---
```

`docs/v4/sdk/adb-tools.mdx`:

```mdx
---
title: AdbTools
---

UI Actions - Core UI interaction tools for Android device control via ADB.

<a id="droidrun.tools.adb.AdbTools"></a>

## AdbTools

```python
class AdbTools(Tools)
```

Core UI interaction tools for Android device control.

AdbTools provides a comprehensive interface for interacting with Android devices through ADB (Android Debug Bridge). It supports both TCP communication and content provider modes for device communication via the Droidrun Portal app.

<a id="droidrun.tools.adb.AdbTools.__init__"></a>

#### AdbTools.\_\_init\_\_

```python
def __init__(
    serial: str | None = None,
    use_tcp: bool = False,
    remote_tcp_port: int = 8080,
    app_opener_llm=None,
    text_manipulator_llm=None,
    credential_manager=None
) -> None
```

Initialize the AdbTools instance.

**Arguments**:

- `serial` _str | None_ - Device serial number (e.g., "emulator-5554", "192.168.1.100:5555"). If None, auto-detects the first available device.
- `use_tcp` _bool_ - Whether to prefer TCP communication (default: False). TCP is faster but requires port forwarding. Falls back to content provider mode if TCP fails.
- `remote_tcp_port` _int_ - TCP port for Portal app communication on device (default: 8080)
- `app_opener_llm` _LLM | None_ - LLM instance for app opening workflow (optional). Used by helper tools to open apps by natural language description.
- `text_manipulator_llm` _LLM | None_ - LLM instance for text manipulation (optional). Used by helper tools for text editing operations.
- `credential_manager` _CredentialManager | None_ - CredentialManager instance for secret handling (optional). Enables secure credential access in automation workflows.

**Usage:**

```python
from droidrun.tools import AdbTools

# Auto-detect device
tools = AdbTools()

# Specific device
tools = AdbTools(serial="emulator-5554")

# TCP mode (faster communication, requires port forwarding)
tools = AdbTools(serial="emulator-5554", use_tcp=True)

# With LLM support for advanced workflows
from llama_index.llms.openai import OpenAI
llm = OpenAI(model="gpt-4")
tools = AdbTools(
    serial="emulator-5554",
    app_opener_llm=llm,
    text_manipulator_llm=llm
)
```

**Notes:**
- Automatically sets up the Droidrun Portal keyboard on initialization via `setup_keyboard()`
- Creates a PortalClient instance that handles TCP/content provider communication
- Device serial can be emulator name, USB serial, or TCP/IP address:port

---

## UI Interaction Methods

<a id="droidrun.tools.adb.AdbTools.tap_by_index"></a>

#### AdbTools.tap\_by\_index

```python
def tap_by_index(index: int) -> str
```

Tap on a UI element by its index.

This function uses the cached clickable elements to find the element with the given index and tap on its center coordinates.

**Arguments**:

- `index` _int_ - Index of the element to tap (from accessibility tree)

**Returns**:

- `str` - Result message describing the tapped element

**Usage:**

```python
# Get UI state to populate element cache
state = await tools.get_state()

# Tap element at index 5
result = await tools.tap_by_index(5)
print(result)
# Output: "Tapped element with index 5 | Text: 'Submit' | Class: android.widget.Button | Type: clickable | Coordinates: (540, 960)"
```

**Notes:**
- Call `get_state()` first to populate the clickable elements cache
- Returns a descriptive error message (does not raise an exception) if the element index is invalid
- Error message includes up to 20 available indices to help with debugging
- Automatically searches nested children for the target index
- Returns detailed information about tapped element including text, class, type, and child content

<a id="droidrun.tools.adb.AdbTools.tap_by_coordinates"></a>

#### AdbTools.tap\_by\_coordinates

```python
def tap_by_coordinates(x: int, y: int) -> bool
```

Tap on the device screen at specific coordinates.

**Arguments**:

- `x` _int_ - X coordinate
- `y` _int_ - Y coordinate

**Returns**:

- `bool` - True if tap succeeded, False otherwise

**Usage:**

```python
# Tap at specific screen coordinates
success = await tools.tap_by_coordinates(540, 960)
```

<a id="droidrun.tools.adb.AdbTools.tap"></a>

#### AdbTools.tap

```python
def tap(index: int) -> str
```

Tap on a UI element by its index.

Alias for `tap_by_index()`. This function uses the cached clickable elements from the last `get_state()` call to find the element with the given index and tap on its center coordinates.

**Arguments**:

- `index` _int_ - Index of the element to tap

**Returns**:

- `str` - Result message

<a id="droidrun.tools.adb.AdbTools.swipe"></a>

#### AdbTools.swipe

```python
def swipe(
    start_x: int,
    start_y: int,
    end_x: int,
    end_y: int,
    duration_ms: float = 1000
) -> bool
```

Performs a straight-line swipe gesture on the device screen.

To perform a hold (long press), set the start and end coordinates to the same values and increase the duration as needed.

**Arguments**:

- `start_x` _int_ - Starting X coordinate
- `start_y` _int_ - Starting Y coordinate
- `end_x` _int_ - Ending X coordinate
- `end_y` _int_ - Ending Y coordinate
- `duration_ms` _float_ - Duration of swipe in milliseconds (default: 1000)

**Returns**:

- `bool` - True if swipe succeeded, False otherwise

**Usage:**

```python
# Swipe up (scroll down content)
await tools.swipe(540, 1500, 540, 500, duration_ms=300)

# Swipe left
await tools.swipe(800, 960, 200, 960, duration_ms=250)

# Long press (hold for 2 seconds at same position)
await tools.swipe(540, 960, 540, 960, duration_ms=2000)
```

**Notes:**
- Emits SwipeActionEvent when context is set for trajectory tracking
- Uses `@Tools.ui_action` decorator for automatic screenshot capture
- Duration is converted to seconds internally (dividing by 1000)

<a id="droidrun.tools.adb.AdbTools.drag"></a>

#### AdbTools.drag

```python
def drag(
    start_x: int,
    start_y: int,
    end_x: int,
    end_y: int,
    duration: float = 3
) -> bool
```

Performs a straight-line drag and drop gesture on the device screen.

**Arguments**:

- `start_x` _int_ - Starting X coordinate
- `start_y` _int_ - Starting Y coordinate
- `end_x` _int_ - Ending X coordinate
- `end_y` _int_ - Ending Y coordinate
- `duration` _float_ - Duration of drag in seconds (default: 3)

**Returns**:

- `bool` - True if drag succeeded, False otherwise

**Usage:**

```python
# Drag element from one position to another (3 second duration)
await tools.drag(200, 500, 800, 1200, duration=3)

# Faster drag (1 second)
await tools.drag(200, 500, 800, 1200, duration=1)
```

**Notes:**
- Emits DragActionEvent when context is set for trajectory tracking
- Uses `@Tools.ui_action` decorator for automatic screenshot capture
- Includes sleep after drag operation to allow UI to settle

<a id="droidrun.tools.adb.AdbTools.input_text"></a>

#### AdbTools.input\_text

```python
def input_text(text: str, index: int = -1, clear: bool = False) -> str
```

Input text on the device.

Always make sure that a text field is focused before inputting text.

**Arguments**:

- `text` _str_ - Text to input. Can contain spaces, newlines, and special characters including non-ASCII.
- `index` _int_ - Index of the element to input text into. If -1, uses the currently focused element (default: -1).
- `clear` _bool_ - Whether to clear existing text before inputting (default: False)

**Returns**:

- `str` - Result message

**Usage:**

```python
# Focus element first, then input text
await tools.tap_by_index(3)  # Focus text field
result = await tools.input_text("Hello World")

# Input into specific element by index
result = await tools.input_text("user@example.com", index=5)

# Clear existing text and input new text
result = await tools.input_text("New text", index=5, clear=True)

# Unicode support
result = await tools.input_text("‰Ω†Â•Ω‰∏ñÁïå")  # Chinese characters
result = await tools.input_text("Hello\nWorld")  # Multiline text
```

**Notes:**
- Always ensure a text field is focused before inputting text (use `tap_by_index()` or set `index` parameter)
- Uses the Droidrun Portal app keyboard for reliable text input via PortalClient
- Supports Unicode characters and special characters including non-ASCII
- If `index != -1`, automatically taps the element first before inputting text
- Call `get_state()` first to populate element cache if using `index` parameter
- Emits InputTextActionEvent when context is set for trajectory tracking
- Uses `@Tools.ui_action` decorator for automatic screenshot capture
- Text longer than 50 characters is truncated in the result message (but fully sent to the device)

<a id="droidrun.tools.adb.AdbTools.back"></a>

#### AdbTools.back

```python
def back() -> str
```

Go back on the current view.

This presses the Android back button (keycode 4).

**Returns**:

- `str` - Result message

**Usage:**

```python
result = await tools.back()  # Press back button
print(result)  # Output: "Pressed key BACK"
```

**Notes:**
- Uses Android keycode 4 (KEYCODE_BACK)
- Emits KeyPressActionEvent when context is set for trajectory tracking
- Uses `@Tools.ui_action` decorator for automatic screenshot capture

<a id="droidrun.tools.adb.AdbTools.press_key"></a>

#### AdbTools.press\_key

```python
def press_key(keycode: int) -> str
```

Press a key on the Android device.

**Common keycodes:**
- `3`: HOME
- `4`: BACK
- `66`: ENTER
- `67`: DELETE

Full keycode reference: [Android KeyEvent Documentation](https://developer.android.com/reference/android/view/KeyEvent)

**Arguments**:

- `keycode` _int_ - Android keycode to press

**Returns**:

- `str` - Result message with key name

**Usage:**

```python
# Press enter
result = await tools.press_key(66)
print(result)  # Output: "Pressed key ENTER"

# Press home button
await tools.press_key(3)  # Output: "Pressed key HOME"

# Press back button
await tools.press_key(4)  # Output: "Pressed key BACK"

# Press delete
await tools.press_key(67)  # Output: "Pressed key DELETE"

# Unknown keycodes display as number
await tools.press_key(999)  # Output: "Pressed key 999"
```

**Notes:**
- Common keycodes (3, 4, 66, 67) are mapped to readable names (HOME, BACK, ENTER, DELETE)
- Emits KeyPressActionEvent when context is set for trajectory tracking
- Uses `@Tools.ui_action` decorator for automatic screenshot capture

---

## App Management Methods

<a id="droidrun.tools.adb.AdbTools.start_app"></a>

#### AdbTools.start\_app

```python
def start_app(package: str, activity: str | None = None) -> str
```

Start an app on the device.

If activity is not provided, automatically resolves the main/launcher activity using `cmd package resolve-activity`.

**Arguments**:

- `package` _str_ - Package name (e.g., "com.android.settings", "com.google.android.apps.messaging")
- `activity` _str | None_ - Optional activity name (e.g., ".Settings"). If None, auto-detects the main launcher activity.

**Returns**:

- `str` - Result message indicating success or error

**Usage:**

```python
# Auto-detect main activity
result = await tools.start_app("com.android.settings")
print(result)
# Output: "App started: com.android.settings with activity .Settings"

# Specific activity
result = await tools.start_app("com.android.settings", ".Settings")

# Chrome browser (auto-detects launcher activity)
result = await tools.start_app("com.android.chrome")
```

**Notes:**
- Uses `cmd package resolve-activity --brief` to auto-detect main activity when not specified
- Emits StartAppEvent when context is set for trajectory tracking

<a id="droidrun.tools.adb.AdbTools.install_app"></a>

#### AdbTools.install\_app

```python
def install_app(
    apk_path: str,
    reinstall: bool = False,
    grant_permissions: bool = True
) -> str
```

Install an app on the device.

**Arguments**:

- `apk_path` _str_ - Path to the APK file on the local machine
- `reinstall` _bool_ - Whether to reinstall if app already exists (default: False)
- `grant_permissions` _bool_ - Whether to grant all permissions automatically (default: True)

**Returns**:

- `str` - Result message indicating success or error

**Usage:**

```python
# Install new app
result = await tools.install_app("/path/to/app.apk")
print(result)

# Reinstall existing app
result = await tools.install_app("/path/to/app.apk", reinstall=True)

# Install without granting permissions
result = await tools.install_app("/path/to/app.apk", grant_permissions=False)
```

**Notes:**
- APK file must exist on the local machine (not on device)
- Returns error message if APK file is not found
- With `grant_permissions=True`, automatically grants runtime permissions via `-g` flag

<a id="droidrun.tools.adb.AdbTools.list_packages"></a>

#### AdbTools.list\_packages

```python
def list_packages(include_system_apps: bool = False) -> List[str]
```

List installed packages on the device.

**Arguments**:

- `include_system_apps` _bool_ - Whether to include system apps (default: False)

**Returns**:

- `List[str]` - List of package names

**Usage:**

```python
# User-installed apps only
packages = await tools.list_packages()
print(packages)
# Output: ['com.example.app1', 'com.example.app2', ...]

# Include system apps
all_packages = await tools.list_packages(include_system_apps=True)
```

<a id="droidrun.tools.adb.AdbTools.get_apps"></a>

#### AdbTools.get\_apps

```python
def get_apps(include_system: bool = True) -> List[Dict[str, str]]
```

Get installed apps with package name and human-readable label.

**Arguments**:

- `include_system` _bool_ - Whether to include system apps (default: True)

**Returns**:

- `List[Dict[str, str]]` - List of dictionaries containing 'package' and 'label' keys

**Usage:**

```python
apps = await tools.get_apps(include_system=False)
for app in apps:
    print(f"{app['label']}: {app['package']}")

# Output:
# Chrome: com.android.chrome
# Gmail: com.google.android.gm
# Messages: com.google.android.apps.messaging
```

---

## State and Screenshot Methods

<a id="droidrun.tools.adb.AdbTools.get_state"></a>

#### AdbTools.get\_state

```python
def get_state() -> Dict[str, Any]
```

Get both the accessibility tree and phone state in a single call.

This is the primary method for retrieving UI information from the device. It combines accessibility tree (UI elements) and phone state (current activity, keyboard visibility) into a single response. This method also populates the internal `clickable_elements_cache` used by `tap_by_index()`.

**Returns**:

- `Dict[str, Any]` - Dictionary containing both 'a11y_tree' and 'phone_state' data:
  - `a11y_tree`: List of UI elements with indices, text, class names, bounds, etc.
  - `phone_state`: Current activity name, keyboard visibility, etc.

**Usage:**

```python
state = await tools.get_state()

# Access accessibility tree
for element in state['a11y_tree']:
    print(f"Index {element['index']}: {element['text']} ({element['className']})")

# Access phone state
current_activity = state['phone_state']['current_activity']
keyboard_shown = state['phone_state']['keyboard_shown']

print(f"Current activity: {current_activity}")
print(f"Keyboard visible: {keyboard_shown}")
```

**Element structure:**

```python
{
    "index": 5,
    "className": "android.widget.Button",
    "text": "Submit",
    "bounds": "100,200,300,400",  # left,top,right,bottom
    "clickable": True,
    "children": []  # Nested elements (if any)
}
```

**Phone state structure:**

```python
{
    "current_activity": "com.android.chrome/.MainActivity",
    "keyboard_shown": False
}
```

**Notes:**
- Always call this method before using `tap_by_index()` to populate the element cache
- The `type` attribute is filtered out from elements in the returned tree
- Uses PortalClient which automatically selects TCP or content provider mode

<a id="droidrun.tools.adb.AdbTools.take_screenshot"></a>

#### AdbTools.take\_screenshot

```python
def take_screenshot(hide_overlay: bool = True) -> Tuple[str, bytes]
```

Take a screenshot of the device.

This function captures the current screen and stores the screenshot with timestamp for trajectory recording. Screenshots are automatically stored in the `screenshots` list with timestamp information.

**Arguments**:

- `hide_overlay` _bool_ - Whether to hide Portal app overlay elements during screenshot (default: True)

**Returns**:

- `Tuple[str, bytes]` - Tuple of (format, image_bytes) where format is "PNG" and image_bytes is the PNG image data

**Usage:**

```python
# Take screenshot (hides Portal overlay by default)
format, image_bytes = await tools.take_screenshot()
print(f"Screenshot format: {format}")  # Output: "PNG"

# Save to file
with open("screenshot.png", "wb") as f:
    f.write(image_bytes)

# Take screenshot with overlay visible
format, image_bytes = await tools.take_screenshot(hide_overlay=False)
```

**Notes:**
- Screenshots are automatically stored in `tools.screenshots` list with timestamp
- Each screenshot entry contains: `{"timestamp": float, "image_data": bytes, "format": "PNG"}`
- Uses PortalClient for screenshot capture

<a id="droidrun.tools.adb.AdbTools.get_date"></a>

#### AdbTools.get\_date

```python
def get_date() -> str
```

Get the current date and time on device.

**Returns**:

- `str` - Date and time string from device

**Usage:**

```python
date = await tools.get_date()
print(f"Device date: {date}")
# Output: "Thu Jan 16 14:30:25 UTC 2025"
```

---

## Device Communication Methods

<a id="droidrun.tools.adb.AdbTools.ping"></a>

#### AdbTools.ping

```python
def ping() -> Dict[str, Any]
```

Test the Portal connection.

**Returns**:

- `Dict[str, Any]` - Dictionary with ping result

**Usage:**

```python
result = await tools.ping()
if result.get("status") == "ok":
    print("Portal connection successful")
else:
    print(f"Portal connection failed: {result}")
```

---

## Memory and Completion Methods

<a id="droidrun.tools.adb.AdbTools.remember"></a>

#### AdbTools.remember

```python
def remember(information: str) -> str
```

Store important information to remember for future context.

This information will be extracted and included in future agent steps to maintain context across interactions. Use this for critical facts, observations, or user preferences that should influence future decisions.

**Arguments**:

- `information` _str_ - The information to remember

**Returns**:

- `str` - Confirmation message

**Usage:**

```python
# Remember user preferences
tools.remember("User prefers dark mode")

# Remember important state
tools.remember("Flight booking confirmation code: ABC123")

# Remember task progress
tools.remember("Already sent email to john@example.com")
```

**Notes:**
- Memory is limited to 10 most recent items
- Memory persists for the duration of the agent's execution
- Memory is accessible via `get_memory()` or automatically included in agent context

<a id="droidrun.tools.adb.AdbTools.get_memory"></a>

#### AdbTools.get\_memory

```python
def get_memory() -> List[str]
```

Retrieve all stored memory items.

**Returns**:

- `List[str]` - List of stored memory items

**Usage:**

```python
memory = tools.get_memory()
for item in memory:
    print(f"- {item}")
```

<a id="droidrun.tools.adb.AdbTools.complete"></a>

#### AdbTools.complete

```python
def complete(success: bool, reason: str = "")
```

Mark the task as finished.

**Arguments**:

- `success` _bool_ - Indicates if the task was successful
- `reason` _str_ - Reason for failure/success (optional for success, required if success=False)

**Usage:**

```python
# Success
tools.complete(success=True, reason="Successfully sent message to John")

# Failure
tools.complete(success=False, reason="Could not find contact 'John' in contacts app")
```

**Notes:**
- This sets internal flags (`finished`, `success`, `reason`) used by agents to determine completion
- If `success=False`, `reason` is required (raises ValueError if not provided)
- If `success=True` and no reason provided, defaults to "Task completed successfully."
- Uses `@Tools.ui_action` decorator for automatic screenshot capture
- This does not terminate execution; it only sets completion flags

---

## Properties

**Instance variables:**

- `device` - ADB device instance (from adbutils)
- `portal` - PortalClient instance for device communication (TCP or content provider mode)
- `clickable_elements_cache` - List of cached UI elements from last `get_state()` call
- `memory` - List of remembered information items (max 10)
- `screenshots` - List of captured screenshots with timestamps (format: `[{"timestamp": float, "image_data": bytes, "format": "PNG"}]`)
- `save_trajectories` - Trajectory saving level: "none", "step", or "action"
- `finished` - Boolean indicating if task is complete (set by `complete()`)
- `success` - Boolean indicating if task succeeded (set by `complete()`)
- `reason` - String describing success/failure reason (set by `complete()`)
- `app_opener_llm` - LLM instance for app opening workflow (optional)
- `text_manipulator_llm` - LLM instance for text manipulation (optional)
- `credential_manager` - CredentialManager instance for secret handling (optional)

---

## Notes

- **Portal app required**: The Droidrun Portal app must be installed and accessibility service enabled on the device
- **TCP vs Content Provider**: TCP is faster but requires port forwarding (`adb forward tcp:8080 tcp:8080`). Content provider is the fallback mode using ADB shell commands.
- **Element caching**: Always call `get_state()` before using `tap_by_index()` or `tap()` to populate the element cache
- **Trajectory recording**: When `save_trajectories="action"`, screenshots and UI states are automatically captured for each UI action via the `@Tools.ui_action` decorator
- **Unicode support**: `input_text()` supports Unicode characters and special characters via the Portal app's custom keyboard
- **Event streaming**: When a context is set via `_set_context()`, action events (TapActionEvent, SwipeActionEvent, etc.) are emitted for trajectory tracking
- **Decorator behavior**: Methods decorated with `@Tools.ui_action` automatically capture screenshots and emit events when trajectory recording is enabled

---

## Example Workflow

```python
import asyncio
from droidrun.tools import AdbTools

async def main():
    # Initialize tools (auto-detects device if serial not provided)
    tools = AdbTools(serial="emulator-5554", use_tcp=True)

    # Check Portal connection
    ping_result = await tools.ping()
    print(f"Portal status: {ping_result}")

    # Start Chrome app (auto-detects main activity)
    result = await tools.start_app("com.android.chrome")
    print(result)

    # Get UI state (populates clickable_elements_cache)
    state = await tools.get_state()
    print(f"Current activity: {state['phone_state']['current_activity']}")
    print(f"Keyboard shown: {state['phone_state']['keyboard_shown']}")

    # Find and tap search bar by iterating through elements
    for element in state['a11y_tree']:
        element_text = element.get('text', '').lower()
        if 'search' in element_text or 'address' in element_text:
            result = await tools.tap_by_index(element['index'])
            print(result)
            break

    # Input search query
    result = await tools.input_text("Droidrun framework")
    print(result)

    # Press enter key
    result = await tools.press_key(66)
    print(result)

    # Take screenshot
    format, screenshot = await tools.take_screenshot()
    print(f"Screenshot format: {format}, size: {len(screenshot)} bytes")
    with open("search_result.png", "wb") as f:
        f.write(screenshot)

    # Remember result for future context
    tools.remember("Searched for Droidrun framework in Chrome")

    # Complete task
    tools.complete(success=True, reason="Successfully searched for Droidrun in Chrome")

    # Check completion status
    print(f"Task finished: {tools.finished}")
    print(f"Task success: {tools.success}")
    print(f"Reason: {tools.reason}")

asyncio.run(main())
```

```

`docs/v4/sdk/base-tools.mdx`:

```mdx
---
title: Tools Base Class
---

Abstract base class defining the interface for device control tools.

<a id="droidrun.tools.tools.Tools"></a>

## Tools

```python
class Tools(ABC)
```

Abstract base class for all device control tools.

This class defines the contract that all tool implementations must follow. It provides:
- 16 abstract methods for device interaction (UI, apps, state, memory)
- `@ui_action` decorator for automatic trajectory recording
- Consistent interface across platforms (Android, iOS)

All implementations must provide these methods to ensure compatibility with DroidAgent and other agents.

---

## Quick Reference

**16 Abstract Methods:**
- `get_state()`, `get_date()`, `tap_by_index()`, `swipe()`, `drag()`, `input_text()`, `back()`, `press_key()`, `start_app()`, `take_screenshot()`, `list_packages()`, `get_apps()`, `remember()`, `get_memory()`, `complete()`, `_extract_element_coordinates_by_index()`

**Key Attributes:**
- `save_trajectories`: `"none"` | `"step"` | `"action"` - Controls automatic screenshot capture
- `memory`: `List[str]` - Stores remembered information
- `finished`, `success`, `reason` - Task completion state

**Decorator:**
- `@Tools.ui_action` - Captures screenshots when `save_trajectories="action"`

---

## Architecture

The Tools architecture follows a 2-layer pattern:

1. **Abstract Layer** (`tools.py`): Defines the `Tools` abstract base class with method signatures and the `@ui_action` decorator
2. **Implementation Layer**: Platform-specific implementations
   - `adb.py`: `AdbTools` for Android devices using ADB and Portal app (TCP or content provider)
   - `ios.py`: `IOSTools` for iOS devices using HTTP API to communicate with Portal app

**Key Components:**

- **Tools ABC**: Defines 16 abstract methods that all implementations must provide
- **@ui_action decorator**: Automatically captures screenshots and UI states when `save_trajectories="action"`
- **Portal integration**: Android uses `PortalClient` (TCP or content provider), iOS uses HTTP API

This design ensures:
- Consistent API across platforms
- Easy addition of new device types
- Type safety and IDE support
- Automatic trajectory recording for debugging
- Clear contract for implementing new tools

---

## Common Interface

All Tools implementations must provide these methods:

### UI Interaction

- `tap_by_index(index: int) -> str` - Tap element by index
- `swipe(start_x: int, start_y: int, end_x: int, end_y: int, duration_ms: int = 300) -> bool` - Swipe gesture
- `drag(start_x: int, start_y: int, end_x: int, end_y: int, duration_ms: int = 3000) -> bool` - Drag gesture
- `input_text(text: str, index: int = -1, clear: bool = False) -> str` - Text input
- `back() -> str` - Back navigation
- `press_key(keycode: int) -> str` - Key press

### App Management

- `start_app(package: str, activity: str = "") -> str` - Launch app
- `list_packages(include_system_apps: bool = False) -> List[str]` - List packages
- `get_apps(include_system_apps: bool = True) -> List[Dict[str, Any]]` - Get apps with labels

### State Retrieval

- `get_state() -> Dict[str, Any]` - Get UI state and accessibility tree
- `get_date() -> str` - Get device date/time
- `take_screenshot() -> Tuple[str, bytes]` - Capture screenshot

### Memory and Completion

- `remember(information: str) -> str` - Store context information
- `get_memory() -> List[str]` - Retrieve stored memory
- `complete(success: bool, reason: str) -> None` - Mark task complete

### Internal Helpers

- `_extract_element_coordinates_by_index(index: int) -> Tuple[int, int]` - Extract element coordinates

---

## Decorator: @ui_action

<a id="droidrun.tools.tools.Tools.ui_action"></a>

```python
@staticmethod
def ui_action(func)
```

Decorator to capture screenshots and UI states for actions that modify the UI.

This decorator automatically handles trajectory recording when `save_trajectories="action"` is enabled. It captures screenshots and UI states after each UI action for debugging and analysis.

**Usage:**

```python
class MyTools(Tools):
    @Tools.ui_action
    def tap_by_index(self, index: int) -> str:
        # Perform tap action
        result = self._perform_tap(index)

        # Screenshot and UI state automatically captured after return
        return result
```

**Behavior:**

1. Method executes normally and returns its result
2. After method returns, decorator checks if `self.save_trajectories == "action"`
3. If true, it looks for `step_screenshots` and `step_ui_states` in caller's global scope (using `sys._getframe(1)`)
4. If these lists exist, appends current screenshot (`self.take_screenshot()[1]`) and UI state (`self.get_state()`)
5. Enables action replay and debugging by building a complete trajectory

**Important:** The Tools instance must have `save_trajectories` attribute set to `"action"` for the decorator to capture screenshots. Other values (`"none"`, `"step"`) will skip automatic capture.

**Standard decorated methods in AdbTools:**

- `_extract_element_coordinates_by_index()` - Extract element coordinates
- `swipe()` - Swipe gesture
- `drag()` - Drag gesture
- `input_text()` - Text input
- `back()` - Back button
- `press_key()` - Key press
- `start_app()` - Launch app
- `complete()` - Mark task complete

Note: `tap_by_index()` is NOT decorated with `@ui_action` in the current implementation. The decorator is only applied to the internal `_extract_element_coordinates_by_index()` method that `tap_by_index()` calls.

---

## Custom Tool Integration

You can extend Tools to add platform-specific functionality or create custom tool implementations.

### Extending Existing Tools

```python
from droidrun.tools import AdbTools
from typing import List

class CustomAndroidTools(AdbTools):
    """Custom Android tools with additional methods."""

    def read_notifications(self) -> List[str]:
        """Read all notifications from notification shade."""
        # Swipe down to open notifications
        self.swipe(540, 0, 540, 500)

        # Get UI state
        state = self.get_state()

        # Extract notification texts
        notifications = []
        for element in state['a11y_tree']:
            if 'notification' in element['className'].lower():
                if element['text']:
                    notifications.append(element['text'])

        # Close notifications
        self.back()

        return notifications

# Usage
tools = CustomAndroidTools(serial="emulator-5554")
notifications = tools.read_notifications()
```

### Creating New Tool Implementations

To create a custom Tools implementation, you must implement all 16 abstract methods:

```python
from droidrun.tools import Tools
from typing import Any, Dict, List, Tuple

class CustomTools(Tools):
    """Custom tools implementation."""

    def __init__(self):
        self.memory: List[str] = []
        self.finished = False
        self.success = None
        self.reason = None
        self.save_trajectories = "none"

    # Required abstract methods:
    def get_state(self) -> Dict[str, Any]:
        """Return dict with 'a11y_tree' and 'phone_state' keys."""
        pass

    def get_date(self) -> str:
        """Return device date/time as string."""
        pass

    def tap_by_index(self, index: int) -> str:
        """Tap element at given index."""
        pass

    def swipe(self, start_x: int, start_y: int, end_x: int, end_y: int, duration_ms: int = 300) -> bool:
        """Perform swipe gesture."""
        pass

    def drag(self, start_x: int, start_y: int, end_x: int, end_y: int, duration_ms: int = 3000) -> bool:
        """Perform drag gesture."""
        pass

    def input_text(self, text: str, index: int = -1, clear: bool = False) -> str:
        """Input text."""
        pass

    def back(self) -> str:
        """Navigate back."""
        pass

    def press_key(self, keycode: int) -> str:
        """Press key by keycode."""
        pass

    def start_app(self, package: str, activity: str = "") -> str:
        """Launch app."""
        pass

    def take_screenshot(self) -> Tuple[str, bytes]:
        """Return tuple of (format, image_bytes)."""
        pass

    def list_packages(self, include_system_apps: bool = False) -> List[str]:
        """List installed packages."""
        pass

    def get_apps(self, include_system_apps: bool = True) -> List[Dict[str, Any]]:
        """Get apps with package and label."""
        pass

    def remember(self, information: str) -> str:
        """Store information in memory."""
        self.memory.append(information)
        return f"Remembered: {information}"

    def get_memory(self) -> List[str]:
        """Retrieve stored memory."""
        return self.memory.copy()

    def complete(self, success: bool, reason: str = "") -> None:
        """Mark task as complete."""
        self.finished = True
        self.success = success
        self.reason = reason

    def _extract_element_coordinates_by_index(self, index: int) -> Tuple[int, int]:
        """Extract element coordinates by index."""
        pass
```

---

## Helper Function: describe_tools

<a id="droidrun.tools.tools.describe_tools"></a>

```python
def describe_tools(
    tools: Tools,
    exclude_tools: Optional[List[str]] = None
) -> Dict[str, Callable[..., Any]]
```

Describe the tools available for the given Tools instance.

This function creates a dictionary mapping tool names to their callable methods, useful for introspection and dynamic tool loading.

**Arguments**:

- `tools` _Tools_ - The Tools instance to describe
- `exclude_tools` _Optional[List[str]]_ - List of tool names to exclude from the description

**Returns**:

- `Dict[str, Callable[..., Any]]` - Dictionary mapping tool names to their methods

**Usage:**

```python
from droidrun.tools import AdbTools, describe_tools

tools = AdbTools()

# Get all available tools
available = describe_tools(tools)
print(available.keys())
# Output: dict_keys(['swipe', 'input_text', 'press_key', 'tap_by_index', 'drag',
#                    'start_app', 'list_packages', 'remember', 'complete'])

# Exclude certain tools
limited = describe_tools(tools, exclude_tools=['drag', 'press_key'])
print(limited.keys())
# Output: dict_keys(['swipe', 'input_text', 'tap_by_index', 'start_app',
#                    'list_packages', 'remember', 'complete'])

# Use tool dynamically
tool_name = "tap_by_index"
if tool_name in available:
    result = available[tool_name](5)
```

**Included tools:**

- UI interaction: `swipe`, `input_text`, `press_key`, `tap_by_index`, `drag`
- App management: `start_app`, `list_packages`
- State management: `remember`, `complete`

**Not included by default:**

- `get_state()` - Called internally by agents
- `take_screenshot()` - Called internally by agents
- `get_memory()` - Accessed directly by agents
- `back()` - Typically handled by agents or wrapped in other tools

---

## Tool Communication with Agents

Tools instances are passed to agents and provide the atomic actions for device control. Agents call these methods directly or wrap them for LLM function calling.

### How Agents Use Tools:

```python
from droidrun import DroidAgent
from droidrun.tools import AdbTools
from droidrun.config_manager import DroidrunConfig

# Create tools instance
tools = AdbTools(serial="emulator-5554")

# Create config
config = DroidrunConfig()

# Pass to agent
agent = DroidAgent(
    goal="Open Settings app",
    tools=tools,  # Agent uses these methods
    config=config
)

# Inside agent execution:
# 1. Agent calls tools.get_state() to get UI
# 2. Agent analyzes state and decides action
# 3. Agent calls tools.tap_by_index(5) to tap element
# 4. Agent uses tools.remember() to store context
# 5. Agent calls tools.complete() when done
```

### Tools are used via describe_tools():

The `describe_tools()` function extracts callable methods for LLM function calling:

```python
from droidrun.tools import describe_tools

tools = AdbTools()
tool_dict = describe_tools(tools)

# Returns: {'swipe': <method>, 'input_text': <method>, 'tap_by_index': <method>, ...}
# Agents use this dict to expose tools as LLM functions
```

---

## Platform Comparison

| Feature | AdbTools (Android) | IOSTools (iOS) |
|---------|-------------------|----------------|
| Connection | ADB + Portal (USB/TCP) | HTTP (Portal app) |
| Element indexing | ‚úÖ Full support | ‚úÖ Full support |
| Text input | ‚úÖ Unicode + index/clear | ‚ö†Ô∏è Unicode only (no index/clear) |
| Screenshots | ‚úÖ Fast (PNG) | ‚úÖ Fast (PNG) |
| Swipe | ‚úÖ Precise coordinates | ‚ö†Ô∏è Direction-based |
| Drag | ‚úÖ Full support | ‚ùå Not implemented |
| Back button | ‚úÖ Hardware key (keycode 4) | ‚ùå Not implemented |
| `get_date()` | ‚úÖ Device date/time | ‚ùå Not implemented |
| `get_apps()` | ‚úÖ All packages with labels | ‚ùå Not implemented |
| App packages | ‚úÖ All packages | ‚ö†Ô∏è Limited to configured |
| Key codes | ‚úÖ Full Android keycodes | ‚ö†Ô∏è Limited (HOME/ACTION/CAMERA) |
| State retrieval | ‚úÖ Accessibility tree + phone state | ‚úÖ Accessibility tree + phone state |
| `_extract_element_coordinates_by_index()` | ‚úÖ Implemented | ‚ùå Not implemented |

---

## Best Practices

### 1. Always call get_state() before tap_by_index()

The `tap_by_index()` method relies on cached UI elements from the last `get_state()` call:

```python
# Correct
state = await tools.get_state()
await tools.tap_by_index(5)

# Wrong - will fail with "No UI elements cached"
await tools.tap_by_index(5)
```

### 2. Use remember() for important context

```python
# Store facts that should persist across steps
tools.remember("User's email: user@example.com")
tools.remember("Login successful")

# Agents include memory in subsequent prompts
```

### 3. Enable trajectory recording for debugging

```python
# Set save_trajectories to "action" for automatic screenshot capture
tools.save_trajectories = "action"

# Now all @ui_action decorated methods capture screenshots
await tools.swipe(100, 500, 100, 100)  # Auto-captured
await tools.input_text("test")          # Auto-captured

# Access captured data
for screenshot in tools.screenshots:
    print(f"Timestamp: {screenshot['timestamp']}")
```

### 4. Handle platform differences

```python
from droidrun.tools import AdbTools, IOSTools

if isinstance(tools, AdbTools):
    await tools.press_key(4)  # Android back button
elif isinstance(tools, IOSTools):
    # iOS doesn't have back button - find in UI
    state = tools.get_state()
    for elem in state['a11y_tree']:
        if 'back' in elem.get('label', '').lower():
            tools.tap_by_index(elem['index'])
```

### 5. Use complete() to signal task finish

```python
# Always call complete() to mark task as finished
tools.complete(success=True, reason="Task completed")

# On failure, reason is required
tools.complete(success=False, reason="Login button not found")
```

---

## Error Handling

Tools methods use consistent error handling patterns:

**String returns with error messages:**
```python
result = await tools.tap_by_index(999)
if result.startswith("Error:"):
    print(f"Tap failed: {result}")
```

**Boolean returns:**
```python
success = await tools.swipe(100, 500, 100, 100)
if not success:
    print("Swipe failed")
```

**Exceptions for critical errors:**
```python
try:
    format, screenshot = await tools.take_screenshot()
except ValueError as e:
    print(f"Screenshot failed: {e}")
```

---

## Advanced: Stacking Decorators

You can combine `@Tools.ui_action` with custom decorators:

```python
import logging
from functools import wraps
from droidrun.tools import AdbTools, Tools

def log_action(func):
    """Decorator to log all tool actions."""
    @wraps(func)
    def wrapper(*args, **kwargs):
        logger = logging.getLogger("tools")
        logger.info(f"Calling {func.__name__} with args={args[1:]}")

        result = func(*args, **kwargs)

        logger.info(f"{func.__name__} returned: {result}")
        return result
    return wrapper

class LoggedAdbTools(AdbTools):
    @log_action         # Applied first (outer)
    @Tools.ui_action    # Applied second (inner)
    def swipe(self, start_x: int, start_y: int, end_x: int, end_y: int, duration_ms: int = 300) -> bool:
        return super().swipe(start_x, start_y, end_x, end_y, duration_ms)

# Usage
tools = LoggedAdbTools(serial="emulator-5554")
tools.save_trajectories = "action"
await tools.swipe(100, 500, 100, 100)  # Logs + captures screenshot
```

**Decorator order matters:** Place `@Tools.ui_action` closest to the function definition so it executes last (captures screenshot after all other decorators).

---

## See Also

- [AdbTools API](/v4/sdk/adb-tools) - Android implementation
- [IOSTools API](/v4/sdk/ios-tools) - iOS implementation
- [DroidAgent API](/v4/sdk/droid-agent) - Agent integration
- [Custom Tools Guide](/v4/features/custom-tools) - Creating custom tools

```

`docs/v4/sdk/configuration.mdx`:

```mdx
---
title: 'Configuration'
description: 'Complete DroidAgent configuration guide - all parameters, minimal examples'
---

## Quick Start

```python
from droidrun import DroidAgent, DroidrunConfig

# Minimal (uses defaults)
agent = DroidAgent(goal="Open settings")
result = await agent.run()

# Load from config.yaml
config = DroidrunConfig.from_yaml("config.yaml")
agent = DroidAgent(goal="Open settings", config=config)
result = await agent.run()
```

---

## DroidAgent Parameters

### Required

```python
DroidAgent(
    goal="Your task",  # REQUIRED: Task description
)
```

### Optional Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `config` | `DroidrunConfig \| None` | `None` | Full config object (loads LLMs from profiles if `llms` not provided) |
| `llms` | `dict[str, LLM] \| LLM \| None` | `None` | LLM(s) - dict for per-agent, single LLM for all, or None to load from config |
| `tools` | `Tools \| None` | `None` | Tools instance (AdbTools/IOSTools) |
| `custom_tools` | `dict \| None` | `None` | Custom tool definitions |
| `credentials` | `dict \| None` | `None` | Dict of credential secrets |
| `variables` | `dict \| None` | `None` | Custom variables accessible during execution |
| `output_model` | `Type[BaseModel] \| None` | `None` | Pydantic model for structured output extraction |
| `prompts` | `dict[str, str] \| None` | `None` | Custom Jinja2 prompt templates (NOT file paths) |
| `timeout` | `int` | `1000` | Workflow timeout in seconds |

---

## Configuration Classes

### AgentConfig

```python
from droidrun import AgentConfig, CodeActConfig, ManagerConfig, ExecutorConfig, ScripterConfig, AppCardConfig

AgentConfig(
    # Core settings
    max_steps=15,                    # Max execution steps
    reasoning=True,                 # Enable Manager/Executor workflow
    after_sleep_action=1.0,          # Wait after actions (seconds)
    wait_for_stable_ui=0.3,          # Wait for UI to stabilize (seconds)
    prompts_dir="config/prompts",    # Prompt templates directory

    # Sub-configs
    codeact=CodeActConfig(...),
    manager=ManagerConfig(...),
    executor=ExecutorConfig(...),
    scripter=ScripterConfig(...),
    app_cards=AppCardConfig(...),
)
```

**CodeActConfig**
```python
CodeActConfig(
    vision=True,                    # Enable screenshots
    system_prompt="system.jinja2",   # Filename in prompts_dir/codeact/
    user_prompt="user.jinja2",       # Filename in prompts_dir/codeact/
    safe_execution=True,            # Restrict imports/builtins
)
```

**ManagerConfig**
```python
ManagerConfig(
    vision=True,                    # Enable screenshots
    system_prompt="system.jinja2",   # Filename in prompts_dir/manager/
)
```

**ExecutorConfig**
```python
ExecutorConfig(
    vision=True,                    # Enable screenshots
    system_prompt="system.jinja2",   # Filename in prompts_dir/executor/
)
```

**ScripterConfig**
```python
ScripterConfig(
    enabled=True,                    # Enable off-device Python execution
    max_steps=10,                    # Max scripter steps
    execution_timeout=30.0,          # Code block timeout (seconds)
    system_prompt_path="system.jinja2",  # Filename in prompts_dir/scripter/
    safe_execution=False,            # Restrict imports/builtins
)
```

**AppCardConfig**
```python
AppCardConfig(
    enabled=True,                    # Enable app-specific instructions
    mode="local",                    # "local" | "server" | "composite"
    app_cards_dir="config/app_cards",  # Directory for app card files
    server_url=None,                 # Server URL (for server/composite modes)
    server_timeout=2.0,              # Server request timeout (seconds)
    server_max_retries=2,            # Server retry attempts
)
```

---

### DeviceConfig

```python
from droidrun import DeviceConfig

DeviceConfig(
    serial=None,          # Device serial/IP (None = auto-detect)
    platform="android",   # "android" or "ios"
    use_tcp=False,        # TCP vs content provider communication
)
```

---

### LoggingConfig

```python
from droidrun import LoggingConfig

LoggingConfig(
    debug=True,                   # Enable debug logs
    save_trajectory="none",        # "none" | "step" | "action"
    trajectory_path="trajectories", # Directory for trajectory files
    trajectory_gifs=False,         # Save trajectory as animated GIFs
    rich_text=False,               # Rich text formatting in logs
)
```

---

### TracingConfig

```python
from droidrun import TracingConfig

TracingConfig(
    enabled=True,                      # Enable tracing
    provider="phoenix",                 # "phoenix" or "langfuse"

    # Langfuse settings (only used if provider="langfuse")
    langfuse_secret_key="",             # LANGFUSE_SECRET_KEY env var
    langfuse_public_key="",             # LANGFUSE_PUBLIC_KEY env var
    langfuse_host="",                   # LANGFUSE_HOST env var (e.g., "https://cloud.langfuse.com")
    langfuse_user_id="anonymous",       # User ID for Langfuse tracing
    langfuse_session_id="",             # Empty = auto-generate UUID; custom value to persist across runs
)
```

---

### TelemetryConfig

```python
from droidrun import TelemetryConfig

TelemetryConfig(
    enabled=True,  # Enable anonymous telemetry
)
```

---

### ToolsConfig

```python
from droidrun import ToolsConfig

ToolsConfig(
    allow_drag=True,          # Enable drag tool
    disabled_tools=[],        # List of tools to disable (e.g., ["long_press", "wait"])
)
```

**Example - Disable specific tools:**
```yaml
tools:
  disabled_tools:
    - long_press
    - wait
```
Disabled tools will not be available to agents during execution.

---

### CredentialsConfig

```python
from droidrun import CredentialsConfig

CredentialsConfig(
    enabled=True,                        # Enable credential manager
    file_path="config/credentials.yaml",  # Path to credentials file
)
```

---

### SafeExecutionConfig

```python
from droidrun import SafeExecutionConfig

SafeExecutionConfig(
    # Imports
    allow_all_imports=False,         # Allow all imports (ignores allowed_modules)
    allowed_modules=[],              # Allowed module names (e.g., ["json", "requests"])
    blocked_modules=[                # Blocked modules (takes precedence)
        "os", "sys", "subprocess", "shutil", "pathlib", "pty", "fcntl",
        "resource", "pickle", "shelve", "marshal", "imp", "importlib",
        "ctypes", "code", "codeop", "tempfile", "glob", "socket",
        "socketserver", "asyncio"
    ],

    # Builtins
    allow_all_builtins=False,        # Allow all builtins (ignores allowed_builtins)
    allowed_builtins=[],             # Allowed builtin names (empty = safe defaults)
    blocked_builtins=[               # Blocked builtins (takes precedence)
        "open", "compile", "exec", "eval", "__import__",
        "breakpoint", "exit", "quit", "input"
    ],
)
```

---

## LLM Configuration

### Single LLM (All Agents)

```python
from llama_index.llms.gemini import Gemini

llm = Gemini(model="models/gemini-2.5-pro", temperature=0.2)
agent = DroidAgent(goal="...", llms=llm)
```

### Per-Agent LLMs

```python
from llama_index.llms.openai import OpenAI
from llama_index.llms.gemini import Gemini

agent = DroidAgent(
    goal="...",
    llms={
        "manager": OpenAI(model="gpt-4o"),                    # Planning
        "executor": Gemini(model="models/gemini-2.5-flash"),  # Action selection
        "codeact": Gemini(model="models/gemini-2.5-pro"),     # Code generation
        "text_manipulator": Gemini(model="models/gemini-2.5-flash"),  # Text input
        "app_opener": OpenAI(model="gpt-4o-mini"),            # App launching
        "scripter": Gemini(model="models/gemini-2.5-flash"),  # Off-device scripts
        "structured_output": Gemini(model="models/gemini-2.5-flash"),  # Output extraction
    }
)
```

**LLM Keys:**
- `manager` - Planning (reasoning mode only)
- `executor` - Action selection (reasoning mode only)
- `codeact` - Code generation (direct mode)
- `scripter` - Off-device Python execution
- `text_manipulator` - Text input helper
- `app_opener` - App launching helper
- `structured_output` - Final output extraction

---

## Custom Tools

```python
def my_tool(param: str, **kwargs) -> str:
    """Tool description."""
    return f"Result: {param}"

agent = DroidAgent(
    goal="...",
    custom_tools={
        "my_tool": {
            "arguments": ["param"],
            "description": "Tool description with usage example",
            "function": my_tool
        }
    }
)
```

---

## Credentials

### Dict Format (Recommended)
```python
agent = DroidAgent(
    goal="...",
    credentials={
        "USERNAME": "alice@example.com",
        "PASSWORD": "secret123"
    }
)
# Agent can call get_username() and get_password()
```

### Config Format
```python
from droidrun import DroidrunConfig, CredentialsConfig

config = DroidrunConfig(
    credentials=CredentialsConfig(
        enabled=True,
        file_path="config/credentials.yaml"
    )
)

agent = DroidAgent(
    goal="...",
    config=config
)
```

---

## Custom Variables

```python
agent = DroidAgent(
    goal="...",
    variables={
        "api_url": "https://api.example.com",
        "user_id": "12345",
        "custom_data": {"key": "value"}
    }
)
# Access in shared_state.custom_variables
```

---

## Structured Output

```python
from pydantic import BaseModel

class FlightInfo(BaseModel):
    airline: str
    flight_number: str
    confirmation_code: str

agent = DroidAgent(
    goal="Book a flight and extract details",
    output_model=FlightInfo
)
result = await agent.run()
print(result.structured_output.airline)  # Typed output
```

---

## Custom Prompts

```python
custom_prompt = """
You are an expert mobile agent.
Goal: {{ instruction }}
Be precise and efficient.
"""

agent = DroidAgent(
    goal="...",
    prompts={
        "codeact_system": custom_prompt,
        "codeact_user": "...",
        "manager_system": "...",
        "executor_system": "...",
        "scripter_system": "..."
    }
)
```

**Template Variables:**
- `{{ instruction }}` - User's goal
- `{{ device_date }}` - Device date/time
- `{{ app_card }}` - App-specific instructions
- `{{ state }}` - Device state
- `{{ history }}` - Action history

---

## Complete Example

```python
from droidrun import (
    DroidAgent, DroidrunConfig,
    AgentConfig, CodeActConfig, DeviceConfig, LoggingConfig, TracingConfig
)
from llama_index.llms.openai import OpenAI
from llama_index.llms.gemini import Gemini
from pydantic import BaseModel

# Structured output
class Output(BaseModel):
    name: str
    value: int

# Custom tool
def send_email(to: str, subject: str, **kwargs) -> str:
    """Send email."""
    return f"Sent to {to}"

# Build configuration
config = DroidrunConfig(
    agent=AgentConfig(
        max_steps=30,
        reasoning=True,
        after_sleep_action=1.5,
        codeact=CodeActConfig(vision=True, safe_execution=True)
    ),
    device=DeviceConfig(
        serial="emulator-5554",
        platform="android",
        use_tcp=False
    ),
    logging=LoggingConfig(
        debug=True,
        save_trajectory="action",
        trajectory_gifs=True
    ),
    tracing=TracingConfig(enabled=True),
)

agent = DroidAgent(
    goal="Complex task",
    config=config,

    # LLMs
    llms={
        "manager": OpenAI(model="gpt-4o"),                    # Planning
        "executor": Gemini(model="models/gemini-2.5-flash"),  # Action selection
        "codeact": Gemini(model="models/gemini-2.5-pro"),     # Code generation
        "text_manipulator": Gemini(model="models/gemini-2.5-flash"),  # Text input
        "app_opener": OpenAI(model="gpt-4o-mini"),            # App launching
        "scripter": Gemini(model="models/gemini-2.5-flash"),  # Off-device scripts
        "structured_output": Gemini(model="models/gemini-2.5-flash"),  # Output extraction
    },

    # Custom tools
    custom_tools={
        "send_email": {
            "arguments": ["to", "subject"],
            "description": "Send email to recipient with subject",
            "function": send_email
        }
    },

    # Credentials
    credentials={"USERNAME": "alice", "PASSWORD": "secret"},

    # Variables
    variables={"api_url": "https://api.example.com"},

    # Structured output
    output_model=Output,

    # Timeout
    timeout=600
)

result = await agent.run()
```

---

## YAML Config (CLI)

For CLI usage, create `config.yaml`:

```yaml
agent:
  max_steps: 15
  reasoning: false
  after_sleep_action: 1.0
  wait_for_stable_ui: 0.3
  prompts_dir: config/prompts

  codeact:
    vision: false
    system_prompt: system.jinja2
    user_prompt: user.jinja2
    safe_execution: false

  manager:
    vision: false
    system_prompt: system.jinja2

  executor:
    vision: false
    system_prompt: system.jinja2

  scripter:
    enabled: true
    max_steps: 10
    execution_timeout: 30.0
    system_prompt_path: system.jinja2
    safe_execution: false

  app_cards:
    enabled: true
    mode: local
    app_cards_dir: config/app_cards
    server_url: null
    server_timeout: 2.0
    server_max_retries: 2

llm_profiles:
  manager:
    provider: GoogleGenAI
    model: models/gemini-2.5-pro
    temperature: 0.2
    kwargs:
      max_tokens: 8192

  executor:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.1
    kwargs:
      max_tokens: 4096

  codeact:
    provider: GoogleGenAI
    model: models/gemini-2.5-pro
    temperature: 0.2
    kwargs:
      max_tokens: 8192

  text_manipulator:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.3

  app_opener:
    provider: OpenAI
    model: gpt-4o-mini
    temperature: 0.0

  scripter:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.1

  structured_output:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.0

device:
  serial: null
  platform: android
  use_tcp: false

telemetry:
  enabled: true

tracing:
  enabled: false
  provider: phoenix  # "phoenix" or "langfuse"
  langfuse_secret_key: ""
  langfuse_public_key: ""
  langfuse_host: ""
  langfuse_user_id: anonymous
  langfuse_session_id: ""

logging:
  debug: false
  save_trajectory: none
  trajectory_path: trajectories
  trajectory_gifs: false
  rich_text: false

safe_execution:
  allow_all_imports: false
  allowed_modules: []
  blocked_modules:
    - os
    - sys
    - subprocess
    - shutil
    - pathlib
    - pty
    - fcntl
    - resource
    - pickle
    - shelve
    - marshal
    - imp
    - importlib
    - ctypes
    - code
    - codeop
    - tempfile
    - glob
    - socket
    - socketserver
    - asyncio
  allow_all_builtins: false
  allowed_builtins: []
  blocked_builtins:
    - open
    - compile
    - exec
    - eval
    - __import__
    - breakpoint
    - exit
    - quit
    - input

credentials:
  enabled: false
  file_path: config/credentials.yaml
```

---

## CLI Overrides

```bash
# Override agent settings
droidrun run "Task" --steps 30 --reasoning --vision

# Override device
droidrun run "Task" --device emulator-5554 --tcp

# Override LLM (applies to ALL agents)
droidrun run "Task" --provider GoogleGenAI --model models/gemini-2.5-flash

# Override logging
droidrun run "Task" --debug --save-trajectory action --tracing

# Custom config file
droidrun run "Task" --config /path/to/config.yaml
```

**All CLI Flags:**
- `--config PATH` - Custom config file
- `--device SERIAL` - Device serial/IP
- `--provider PROVIDER` - LLM provider (OpenAI, Ollama, Anthropic, GoogleGenAI, DeepSeek)
- `--model MODEL` - LLM model name
- `--temperature FLOAT` - LLM temperature
- `--steps INT` - Max steps
- `--base_url URL` - API base URL (for Ollama/OpenRouter)
- `--api_base URL` - API base URL (for OpenAI-like)
- `--vision/--no-vision` - Enable/disable vision for all agents
- `--reasoning/--no-reasoning` - Enable/disable reasoning mode
- `--tracing/--no-tracing` - Enable/disable tracing
- `--debug/--no-debug` - Enable/disable debug logs
- `--tcp/--no-tcp` - Enable/disable TCP communication
- `--save-trajectory none|step|action` - Trajectory saving level
- `--ios` - Run on iOS device

---

## Environment Variables

Set API keys via environment variables:

```bash
export GOOGLE_API_KEY=your-key
export OPENAI_API_KEY=your-key
export ANTHROPIC_API_KEY=your-key
export DEEPSEEK_API_KEY=your-key
export DROIDRUN_CONFIG=/path/to/config.yaml  # Custom config path
```

```

`docs/v4/sdk/droid-agent.mdx`:

```mdx
---
title: DroidAgent
---

DroidAgent - A wrapper class that coordinates the planning and execution of tasks to achieve a user's goal on an Android or iOS device.

<a id="droidrun.agent.droid.droid_agent.DroidAgent"></a>

## DroidAgent

```python
class DroidAgent(Workflow)
```

A wrapper class that coordinates between agents to achieve a user's goal.

**Architecture:**
- When `reasoning=False`: Uses CodeActAgent directly for immediate execution
- When `reasoning=True`: Uses ManagerAgent (planning) + ExecutorAgent (actions) + ScripterAgent (off-device operations)

<a id="droidrun.agent.droid.droid_agent.DroidAgent.__init__"></a>

#### DroidAgent.\_\_init\_\_

```python
def __init__(
    goal: str,
    config: DroidrunConfig | None = None,
    llms: dict[str, LLM] | LLM | None = None,
    tools: "Tools | None" = None,
    custom_tools: dict | None = None,
    credentials: dict | None = None,
    variables: dict | None = None,
    output_model: Type[BaseModel] | None = None,
    prompts: dict[str, str] | None = None,
    timeout: int = 1000
)
```

Initialize the DroidAgent wrapper.

**Arguments**:

- `goal` _str_ - User's goal or command to execute
- `config` _DroidrunConfig | None_ - Full configuration object (required if llms not provided). Contains agent settings, LLM profiles, device config, and more.
- `llms` _dict[str, LLM] | LLM | None_ - Optional LLM configuration:
  - `dict[str, LLM]`: Agent-specific LLMs with keys: "manager", "executor", "codeact", "text_manipulator", "app_opener", "scripter", "structured_output"
  - `LLM`: Single LLM instance used for all agents
  - `None`: LLMs will be loaded from config.llm_profiles
- `tools` _Tools | None_ - Pre-configured Tools instance (AdbTools or IOSTools). If None, tools will be created from config.
- `custom_tools` _dict | None_ - Custom tool definitions. Format: `{"tool_name": {"signature": "...", "description": "...", "function": callable}}`. These are merged with auto-generated credential tools.
- `credentials` _dict | None_ - Direct credential mapping `{"SECRET_ID": "value"}`. If None, credentials will be loaded from config.credentials if available.
- `variables` _dict | None_ - Custom variables accessible throughout execution. Available in shared_state.custom_variables.
- `output_model` _Type[BaseModel] | None_ - Pydantic model for structured output extraction from final answer. If provided, the final answer will be parsed into this model.
- `prompts` _dict[str, str] | None_ - Custom Jinja2 prompt templates to override defaults. Keys: "codeact_system", "codeact_user", "manager_system", "executor_system", "scripter_system". Values: Jinja2 template strings (NOT file paths).
- `timeout` _int_ - Workflow timeout in seconds (default: 1000)

**Basic initialization pattern (recommended):**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize with default config
config = DroidrunConfig()

# Create agent (LLMs loaded from config.llm_profiles)
agent = DroidAgent(
    goal="Open Chrome and search for Droidrun",
    config=config
)

# Run agent
result = await agent.run()
```

**Loading from YAML (optional):**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Load config from config.yaml
config = DroidrunConfig.from_yaml("config.yaml")

# Create agent (LLMs loaded from config.llm_profiles)
agent = DroidAgent(
    goal="Open Chrome and search for Droidrun",
    config=config
)

# Run agent
result = await agent.run()
```

**Custom LLM dictionary pattern:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig
from llama_index.llms.openai import OpenAI
from llama_index.llms.anthropic import Anthropic

# Initialize config
config = DroidrunConfig()

# Create custom LLMs
llms = {
    "manager": Anthropic(model="claude-sonnet-4-5-latest", temperature=0.2),
    "executor": Anthropic(model="claude-sonnet-4-5-latest", temperature=0.1),
    "codeact": OpenAI(model="gpt-4o", temperature=0.2),
    "text_manipulator": OpenAI(model="gpt-4o-mini", temperature=0.3),
    "app_opener": OpenAI(model="gpt-4o-mini", temperature=0.0),
    "scripter": OpenAI(model="gpt-4o", temperature=0.1),
    "structured_output": OpenAI(model="gpt-4o-mini", temperature=0.0),
}

# Create agent with custom LLMs
agent = DroidAgent(
    goal="Send a message to John",
    llms=llms,
    config=config
)

result = await agent.run()
```

**Single LLM pattern:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig
from llama_index.llms.openai import OpenAI

# Initialize config
config = DroidrunConfig()

# Use same LLM for all agents
llm = OpenAI(model="gpt-4o", temperature=0.2)

agent = DroidAgent(
    goal="Take a screenshot and save it",
    llms=llm,
    config=config
)

result = await agent.run()
```

**Custom tools and credentials:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

# Define custom tool
def search_database(query: str) -> str:
    """Search the local database."""
    # Your implementation
    return f"Results for: {query}"

custom_tools = {
    "search_database": {
        "signature": "search_database(query: str) -> str",
        "description": "Search the local database for information",
        "function": search_database
    }
}

# Provide credentials directly
credentials = {
    "GMAIL_USERNAME": "user@gmail.com",
    "GMAIL_PASSWORD": "secret123"
}

agent = DroidAgent(
    goal="Search database and email results",
    config=config,
    custom_tools=custom_tools,
    credentials=credentials
)

result = await agent.run()
```

**Structured output extraction:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig
from pydantic import BaseModel, Field

# Initialize config
config = DroidrunConfig()

# Define output schema
class WeatherInfo(BaseModel):
    """Weather information."""
    temperature: float = Field(description="Temperature in Celsius")
    condition: str = Field(description="Weather condition")
    humidity: int = Field(description="Humidity percentage")

agent = DroidAgent(
    goal="Open weather app and get current weather",
    config=config,
    output_model=WeatherInfo
)

result = await agent.run()

# Access structured output
if result.success and result.structured_output:
    weather = result.structured_output  # WeatherInfo object
    print(f"Temperature: {weather.temperature}¬∞C")
    print(f"Condition: {weather.condition}")
```

<a id="droidrun.agent.droid.droid_agent.DroidAgent.run"></a>

#### DroidAgent.run

```python
async def run(*args, **kwargs) -> ResultEvent
```

Run the DroidAgent workflow.

**Returns**:

- `ResultEvent` - Result object with the following attributes:
  - `success` (bool): True if task completed successfully
  - `reason` (str): Success message or failure reason
  - `steps` (int): Number of steps executed
  - `structured_output` (Any): Parsed Pydantic model (if output_model provided, otherwise None)

**Usage:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

# Create and run agent
agent = DroidAgent(goal="...", config=config)
result = await agent.run()

print(f"Success: {result.success}")
print(f"Reason: {result.reason}")
print(f"Steps: {result.steps}")
```

**Streaming events:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

agent = DroidAgent(goal="...", config=config)

# Stream events as they occur
async for event in agent.run_event_stream():
    if isinstance(event, ManagerInputEvent):
        print("Manager is planning...")
    elif isinstance(event, ExecutorInputEvent):
        print("Executor is taking action...")
    elif isinstance(event, TapActionEvent):
        print(f"Tapping element at {event.x}, {event.y}")
    elif isinstance(event, ResultEvent):
        # Final result
        print(f"Success: {event.success}")
        print(f"Reason: {event.reason}")
```

## Event Types

DroidAgent emits various events during execution:

**Workflow Events:**
- `StartEvent` - Workflow started
- `ManagerInputEvent` - Manager planning phase started
- `ManagerContextEvent` - Manager received context for planning
- `ManagerResponseEvent` - Manager intermediate response
- `ManagerPlanEvent` - Manager created a plan
- `ManagerPlanDetailsEvent` - Manager plan details
- `ExecutorInputEvent` - Executor action phase started
- `ExecutorContextEvent` - Executor received context
- `ExecutorResponseEvent` - Executor intermediate response
- `ExecutorActionEvent` - Executor action details
- `ExecutorActionResultEvent` - Executor action result details
- `ExecutorResultEvent` - Executor completed an action
- `ScripterExecutorInputEvent` - ScripterAgent started
- `ScripterExecutorResultEvent` - ScripterAgent completed
- `CodeActExecuteEvent` - CodeActAgent started (direct mode)
- `CodeActResultEvent` - CodeActAgent completed
- `FinalizeEvent` - Workflow finalizing
- `StopEvent` - Workflow completed

**Action Events:**
- `TapActionEvent` - UI element tapped
- `SwipeActionEvent` - Swipe gesture performed
- `DragActionEvent` - Drag gesture performed
- `InputTextActionEvent` - Text input
- `KeyPressActionEvent` - Key press action
- `StartAppEvent` - App launched

**State Events:**
- `ScreenshotEvent` - Screenshot captured
- `RecordUIStateEvent` - UI state recorded
- `MacroEvent` - Macro action recorded

## Configuration

DroidAgent uses a hierarchical configuration system. See the [Configuration Guide](/v4/sdk/configuration) for details.

**Key configuration options:**

```yaml
agent:
  max_steps: 15           # Maximum execution steps
  reasoning: false        # Enable Manager/Executor workflow

  codeact:
    vision: false         # Enable screenshot analysis
    safe_execution: false # Restrict code execution

  manager:
    vision: false         # Enable screenshot analysis

  executor:
    vision: false         # Enable screenshot analysis

device:
  serial: null            # Device serial (null = auto-detect)
  platform: android       # "android" or "ios"
  use_tcp: false          # TCP vs content provider

logging:
  debug: false            # Debug logging
  save_trajectory: none   # Trajectory saving: "none", "step", "action"

tracing:
  enabled: false          # Arize Phoenix tracing
```

## Advanced Usage

**Custom Tools instance:**

```python
from droidrun import DroidAgent, DeviceConfig
from droidrun.config_manager import DroidrunConfig

# Initialize config with device settings
device_config = DeviceConfig(serial="emulator-5554", use_tcp=True)
config = DroidrunConfig(device=device_config)

agent = DroidAgent(
    goal="Open settings",
    config=config,
)

result = await agent.run()
```

**Custom variables:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

agent = DroidAgent(
    goal="Complete task using context",
    config=config,
    variables={
        "user_name": "Alice",
        "project_id": "12345",
        "api_endpoint": "https://api.example.com"
    }
)

result = await agent.run()
```

Variables are accessible in shared_state.custom_variables throughout execution and can be referenced in custom tools or scripts.

**Custom prompts:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

# Override default prompts with custom Jinja2 templates
custom_prompts = {
    "codeact_system": "You are a specialized agent for {{ platform }} devices...",
    "manager_system": "You are a planning agent. Your goal: {{ instruction }}..."
}

agent = DroidAgent(
    goal="Complete specialized task",
    config=config,
    prompts=custom_prompts
)

result = await agent.run()
```

Available prompt keys: "codeact_system", "codeact_user", "manager_system", "executor_system", "scripter_system"

## Notes

- **Config requirement**: Either `config` or `llms` must be provided. If `llms` is not provided, `config` is required to load LLMs from profiles.
- **Vision mode**: Enabling vision (agent_config.*.vision = True) increases token usage as screenshots are sent to the LLM.
- **Reasoning mode**: `reasoning=True` uses Manager/Executor workflow for complex planning. `reasoning=False` uses CodeActAgent for direct execution.
- **Safe execution**: When enabled, restricts imports and builtins in CodeActAgent and ScripterAgent (see safe_execution config).
- **Timeout**: Default is 1000 seconds. Increase for long-running tasks.
- **Credentials**: Credentials are automatically injected as custom tools (e.g., `get_username()`, `get_password()`).

```

`docs/v4/sdk/ios-tools.mdx`:

```mdx
---
title: IOSTools
---

# IOSTools API Reference

<a id="droidrun.tools.ios.IOSTools"></a>

## IOSTools

```python
class IOSTools(Tools)
```

Core UI interaction tools for iOS device control via the Droidrun iOS Portal app.

**Status**: iOS support is in beta with limited functionality compared to AdbTools.

**Key Limitations**:
- ‚ö†Ô∏è `get_date()` - Not implemented
- ‚ö†Ô∏è `get_apps()` - Not implemented
- ‚ö†Ô∏è `drag()` - Not implemented
- ‚ö†Ô∏è `back()` - Not implemented (iOS has no universal back button)
- ‚ö†Ô∏è `input_text()` - Does not support `index` or `clear` parameters
- ‚ö†Ô∏è `_extract_element_coordinates_by_index()` - Not implemented

<a id="droidrun.tools.ios.IOSTools.__init__"></a>

#### IOSTools.\_\_init\_\_

```python
def __init__(
    url: str,
    bundle_identifiers: List[str] | None = None
) -> None
```

Initialize the IOSTools instance.

**Arguments**:

- `url` _str_ - iOS Portal app URL (e.g., "http://192.168.1.100:8080")
- `bundle_identifiers` _List[str] | None_ - Optional list of custom app bundle identifiers

**Usage:**

```python
from droidrun.tools import IOSTools

# Connect to iOS device
tools = IOSTools(url="http://192.168.1.100:8080")

# With specific bundle identifiers
tools = IOSTools(
    url="http://192.168.1.100:8080",
    bundle_identifiers=["com.example.app1", "com.example.app2"]
)
```

**Setup Requirements:**

1. Install Droidrun iOS Portal app on device
2. Launch Portal app (starts HTTP server)
3. Connect device and computer to same network
4. Use displayed URL to initialize IOSTools

---

## UI Interaction Methods

<a id="droidrun.tools.ios.IOSTools.tap_by_index"></a>

#### IOSTools.tap\_by\_index

```python
def tap_by_index(index: int) -> str
```

Tap a UI element by its index from the accessibility tree.

**Arguments**:

- `index` _int_ - Element index from accessibility tree

**Returns**:

- `str` - Result message with tapped element details

**Usage:**

```python
state = tools.get_state()
result = tools.tap_by_index(3)
# Returns: "Tapped element with index 3 | Text: 'Continue' | Class: Button | Rect: {{100,200},{200,50}}"
```

**Notes:**
- Must call `get_state()` first to populate element cache
- Returns error with available indices if index is invalid
- Waits 0.5s after tap for UI to update

<a id="droidrun.tools.ios.IOSTools.tap"></a>

#### IOSTools.tap

```python
def tap(index: int) -> str
```

Alias for `tap_by_index()`.

**Arguments**:

- `index` _int_ - Element index

**Returns**:

- `str` - Result message

<a id="droidrun.tools.ios.IOSTools.swipe"></a>

#### IOSTools.swipe

```python
def swipe(
    start_x: int,
    start_y: int,
    end_x: int,
    end_y: int,
    duration_ms: int = 300
) -> bool
```

Perform directional swipe gesture (up, down, left, right).

**Arguments**:

- `start_x` _int_ - Starting X coordinate
- `start_y` _int_ - Starting Y coordinate
- `end_x` _int_ - Ending X coordinate
- `end_y` _int_ - Ending Y coordinate
- `duration_ms` _int_ - Duration in milliseconds (ignored on iOS)

**Returns**:

- `bool` - True if successful, False otherwise

**Usage:**

```python
# Swipe up (scroll down)
tools.swipe(200, 800, 200, 200)

# Swipe left
tools.swipe(600, 400, 100, 400)
```

**Notes:**
- iOS uses directional swipes, not precise coordinates
- Direction calculated from coordinate delta (largest axis wins)
- `duration_ms` parameter ignored by iOS API

<a id="droidrun.tools.ios.IOSTools.drag"></a>

#### IOSTools.drag

```python
def drag(
    start_x: int,
    start_y: int,
    end_x: int,
    end_y: int,
    duration_ms: int = 3000
) -> bool
```

‚ö†Ô∏è **NOT IMPLEMENTED** - Always returns False.

Drag gestures are not supported on iOS.

**Arguments**:

- `start_x` _int_ - Starting X coordinate (unused)
- `start_y` _int_ - Starting Y coordinate (unused)
- `end_x` _int_ - Ending X coordinate (unused)
- `end_y` _int_ - Ending Y coordinate (unused)
- `duration_ms` _int_ - Duration in milliseconds (unused)

**Returns**:

- `bool` - Always False

<a id="droidrun.tools.ios.IOSTools.input_text"></a>

#### IOSTools.input\_text

```python
def input_text(text: str) -> str
```

Input text into the currently focused element.

‚ö†Ô∏è **Signature differs from base class** - Does not support `index` or `clear` parameters.

**Arguments**:

- `text` _str_ - Text to input (supports Unicode and newlines)

**Returns**:

- `str` - Result message

**Usage:**

```python
# Tap text field first
tools.tap_by_index(5)

# Input text
tools.input_text("Hello World")

# Unicode supported
tools.input_text("‰Ω†Â•Ω‰∏ñÁïå")
```

**Notes:**
- Must tap text field before calling this method
- Uses last tapped element's rect for targeting
- Waits 0.5s after input
- No `index` or `clear` parameters (unlike AdbTools)

<a id="droidrun.tools.ios.IOSTools.back"></a>

#### IOSTools.back

```python
def back() -> str
```

‚ö†Ô∏è **NOT IMPLEMENTED** - Raises `NotImplementedError`.

iOS has no universal back button. Use navigation UI elements instead.

**Raises**:

- `NotImplementedError` - Always raised when called

<a id="droidrun.tools.ios.IOSTools.press_key"></a>

#### IOSTools.press\_key

```python
def press_key(keycode: int) -> str
```

Press a hardware key.

**Supported keycodes:**
- `0` - HOME button
- `4` - ACTION button
- `5` - CAMERA button

**Arguments**:

- `keycode` _int_ - iOS keycode

**Returns**:

- `str` - Result message

**Usage:**

```python
tools.press_key(0)  # Home button
tools.press_key(4)  # Action button
```

**Notes:**
- Limited to hardware keys only
- Most navigation uses gestures or UI elements

---

## App Management Methods

<a id="droidrun.tools.ios.IOSTools.start_app"></a>

#### IOSTools.start\_app

```python
def start_app(package: str, activity: str = "") -> str
```

Launch an app by bundle identifier.

**Arguments**:

- `package` _str_ - Bundle identifier (e.g., "com.apple.MobileSMS")
- `activity` _str_ - Ignored on iOS (for API compatibility)

**Returns**:

- `str` - Result message

**Common bundle identifiers:**
- Messages: `com.apple.MobileSMS`
- Safari: `com.apple.mobilesafari`
- Settings: `com.apple.Preferences`
- Mail: `com.apple.mobilemail`
- Calendar: `com.apple.mobilecal`
- Photos: `com.apple.mobileslideshow`
- Maps: `com.apple.Maps`
- Contacts: `com.apple.MobileAddressBook`

**Usage:**

```python
tools.start_app("com.apple.MobileSMS")
tools.start_app("com.apple.mobilesafari")
```

**Notes:**
- Waits 1s after launch
- `activity` parameter ignored

<a id="droidrun.tools.ios.IOSTools.list_packages"></a>

#### IOSTools.list\_packages

```python
def list_packages(include_system_apps: bool = True) -> List[str]
```

List known bundle identifiers.

**Arguments**:

- `include_system_apps` _bool_ - Include system apps (default: True)

**Returns**:

- `List[str]` - List of bundle identifiers

**Usage:**

```python
packages = tools.list_packages()
custom_only = tools.list_packages(include_system_apps=False)
```

**Notes:**
- Returns union of `bundle_identifiers` + system apps
- System apps: Settings, Safari, Messages, Mail, etc.
- Does not query device for installed apps

---

## State and Screenshot Methods

<a id="droidrun.tools.ios.IOSTools.get_state"></a>

#### IOSTools.get\_state

```python
def get_state() -> Dict[str, Any]
```

Get accessibility tree and device state.

**Returns**:

Dictionary with:
- `a11y_tree` - List of interactive UI elements
- `phone_state` - Current activity and keyboard visibility

**Element structure:**

```python
{
    "index": 3,
    "type": "Button",
    "className": "Button",
    "text": "Continue",
    "label": "Continue",
    "identifier": "continueButton",
    "placeholder": "",
    "value": "",
    "bounds": "100,200,300,250",  # left,top,right,bottom
    "rect": "100,200,200,50",      # x,y,width,height (iOS format)
    "x": 100,
    "y": 200,
    "width": 200,
    "height": 50,
    "center_x": 200,
    "center_y": 225
}
```

**Interactive element types:**
- Button, SearchField, TextField, Cell
- Switch, Slider, Stepper, Picker, Link

**Usage:**

```python
state = tools.get_state()

for elem in state['a11y_tree']:
    print(f"[{elem['index']}] {elem['text']} ({elem['className']})")

activity = state['phone_state']['current_activity']
keyboard = state['phone_state']['keyboard_shown']
```

**Notes:**
- Only interactive elements included
- Non-interactive elements filtered out
- More detailed than Android accessibility tree

<a id="droidrun.tools.ios.IOSTools.take_screenshot"></a>

#### IOSTools.take\_screenshot

```python
def take_screenshot() -> Tuple[str, bytes]
```

Capture device screen as PNG.

**Returns**:

- `Tuple[str, bytes]` - ("PNG", image_bytes)

**Usage:**

```python
format, img_data = tools.take_screenshot()

with open("screenshot.png", "wb") as f:
    f.write(img_data)
```

**Notes:**
- Stores screenshot with timestamp internally
- Used for trajectory recording

---

## Memory and Completion Methods

<a id="droidrun.tools.ios.IOSTools.remember"></a>

#### IOSTools.remember

```python
def remember(information: str) -> str
```

Store information for future context.

**Arguments**:

- `information` _str_ - Information to remember

**Returns**:

- `str` - Confirmation message

**Usage:**

```python
tools.remember("User prefers light mode")
tools.remember("Calendar event created for 3pm")
tools.remember("Already logged into email")
```

**Notes:**
- Max 10 most recent items
- Persists during agent execution only

<a id="droidrun.tools.ios.IOSTools.get_memory"></a>

#### IOSTools.get\_memory

```python
def get_memory() -> List[str]
```

Get all stored memory items.

**Returns**:

- `List[str]` - Stored memory items

**Usage:**

```python
for item in tools.get_memory():
    print(f"- {item}")
```

<a id="droidrun.tools.ios.IOSTools.complete"></a>

#### IOSTools.complete

```python
def complete(success: bool, reason: str = "")
```

Mark task as finished.

**Arguments**:

- `success` _bool_ - Task success status
- `reason` _str_ - Required if `success=False`

**Usage:**

```python
tools.complete(True, "Successfully sent iMessage")
tools.complete(False, "Could not find contact 'John'")
```

---

## Missing Methods

The following abstract methods from `Tools` base class are **not implemented**:

#### get\_date()
‚ö†Ô∏è Not implemented. Returns "Not implemented for iOS" or raises error.

#### get\_apps()
‚ö†Ô∏è Not implemented. Use `list_packages()` instead (returns bundle identifiers only).

#### \_extract\_element\_coordinates\_by\_index()
‚ö†Ô∏è Not implemented. Use `tap_by_index()` directly instead.

---

## Instance Properties

```python
tools.url                       # iOS Portal URL
tools.clickable_elements_cache  # Cached elements from get_state()
tools.memory                    # List of remembered items
tools.screenshots               # List of {timestamp, data} dicts
tools.last_tapped_rect          # Last tapped element rect (for input_text)
tools.bundle_identifiers        # Custom bundle IDs
tools.finished                  # Task completion flag
tools.success                   # Task success flag
tools.reason                    # Completion reason string
```

---

## iOS vs Android Differences

| Feature | iOS | Android |
|---------|-----|---------|
| Back button | ‚ùå Not available | ‚úÖ Available |
| Swipe | Direction-based | Coordinate-based |
| Drag | ‚ùå Not implemented | ‚úÖ Implemented |
| App IDs | Bundle identifiers | Package names |
| Key codes | 3 keys (HOME, ACTION, CAMERA) | Full Android keycodes |
| Accessibility | Richer element data | Basic element data |
| Connection | HTTP (Portal app) | ADB over USB/TCP |
| get_date() | ‚ùå Not implemented | ‚úÖ Implemented |
| input_text() | No index/clear params | Full signature |

**Setup differences:**

**Android**: USB or `adb connect` + Portal APK
**iOS**: Portal app + same network + HTTP connection

**Limitations:**
- HTTP only (no USB like Android)
- Direction-based gestures (not coordinate-precise)
- Fewer system controls

---

## Example Usage

```python
from droidrun.tools import IOSTools

# Initialize
tools = IOSTools(url="http://192.168.1.100:8080")

# Launch app
tools.start_app("com.apple.MobileSMS")

# Get state and find compose button
state = tools.get_state()
for elem in state['a11y_tree']:
    if 'compose' in elem['label'].lower():
        tools.tap_by_index(elem['index'])
        break

# Input recipient
state = tools.get_state()
for elem in state['a11y_tree']:
    if elem['type'] == 'TextField' and 'to' in elem['label'].lower():
        tools.tap_by_index(elem['index'])
        break
tools.input_text("John")

# Input message
state = tools.get_state()
for elem in state['a11y_tree']:
    if elem['type'] == 'TextField' and 'message' in elem['label'].lower():
        tools.tap_by_index(elem['index'])
        break
tools.input_text("Hello from Droidrun!")

# Send
state = tools.get_state()
for elem in state['a11y_tree']:
    if 'send' in elem['label'].lower():
        tools.tap_by_index(elem['index'])
        break

# Complete
tools.remember("Sent message to John via iMessage")
tools.complete(True, "Successfully sent iMessage")
```

---

## See Also

- [AdbTools](/v4/sdk/adb-tools) - Android device control with full functionality
- [Tools Base Class](/v4/sdk/base-tools) - Abstract base class reference

```

`docs/v4/sdk/reference.mdx`:

```mdx
---
title: 'Reference'
description: 'Complete API reference for Droidrun components and tools'
---

## Overview

The Droidrun SDK provides a comprehensive set of APIs for building mobile automation workflows with AI agents. This reference documentation covers all major components and tools.

---

## Core Components

<CardGroup cols={2}>
  <Card title="DroidAgent" icon="bot" href="./droid-agent">
    Main agent coordinator with multi-agent orchestration
  </Card>
  <Card title="ADB Tools" icon="smartphone" href="./adb-tools">
    Android device control via ADB
  </Card>
  <Card title="iOS Tools" icon="monitor-smartphone" href="./ios-tools">
    iOS device control and automation
  </Card>
  <Card title="Base Tools" icon="wrench" href="./base-tools">
    Abstract base classes for tool implementations
  </Card>
</CardGroup>

---

## Configuration

<Card title="Configuration API" icon="settings" href="./configuration">
  DroidrunConfig API and YAML configuration reference
</Card>

---

## API Documentation

Detailed API documentation for each component is available in the sections linked above. Each page includes:

- Class/function signatures
- Parameter descriptions
- Return types
- Usage examples
- Best practices

For conceptual guides and tutorials, see the [Guides](/v4/guides/overview) section.

```

`docs/v5/concepts/architecture.mdx`:

```mdx
---
title: 'Architecture'
description: 'Understanding the Droidrun multi-agent system for device automation.'
---

## What is Droidrun?

Droidrun uses a **multi-agent architecture** where specialized agents work together to complete tasks. Instead of one agent doing everything, different agents handle planning, execution, and computation.

```
DroidAgent (orchestrator)
‚îú‚îÄ‚îÄ Reasoning Mode: ManagerAgent ‚Üí ExecutorAgent ‚Üí ScripterAgent
‚îî‚îÄ‚îÄ Direct Mode: FastAgent
```

## Execution Modes

### Reasoning Mode (`reasoning=True`)
Manager creates plans, Executor takes actions. Best for complex multi-step tasks.

```
Goal ‚Üí Manager (plan) ‚Üí Executor (action) ‚Üí Manager (check) ‚Üí Executor (next) ‚Üí ...
```

### Direct Mode (`reasoning=False`)
FastAgent executes immediately via XML tool-calling without planning overhead. Best for simple tasks.

```
Goal ‚Üí FastAgent (XML tool-calling) ‚Üí Done
```

## Core Agents

### DroidAgent (Orchestrator)
Main coordinator that routes between agents based on mode.

**Location**: `droidrun/agent/droid/droid_agent.py`

### ManagerAgent (Planner)
Creates strategic plans and breaks tasks into subgoals. Reasoning mode only.

**Location**: `droidrun/agent/manager/manager_agent.py`

**Workflow**: `prepare_context()` ‚Üí `get_response()` ‚Üí `process_response()` ‚Üí `finalize()`

### ExecutorAgent (Actor)
Executes atomic actions for each subgoal. Reasoning mode only.

**Location**: `droidrun/agent/executor/executor_agent.py`

**Workflow**: `prepare_context()` ‚Üí `get_response()` ‚Üí `process_response()` ‚Üí `execute()` ‚Üí `finalize()`

### FastAgent (Direct Executor)
Uses XML tool-calling for device interaction. Direct mode only.

**Location**: `droidrun/agent/codeact/tools_agent.py`

**Available Actions**:
```python
click(index), click_at(x, y), click_area(x1, y1, x2, y2),
long_press(index), long_press_at(x, y),
type(text, index), type_secret(secret_id, index),
swipe(coordinate, coordinate2), system_button(button),
wait(duration), open_app(text),
remember(information), complete(success, reason)
```

### ScripterAgent (Off-Device)
Executes Python for API calls, file operations, and computations. Triggered by Manager when needed.

**Location**: `droidrun/agent/scripter/`

## Configuration

Configure different LLMs per agent:

```yaml
llm_profiles:
  manager:
    provider: Anthropic
    model: claude-sonnet-4
  executor:
    provider: OpenAI
    model: gpt-4o
  fast_agent:
    provider: GoogleGenAI
    model: models/gemini-2.0-flash-exp
  scripter:
    provider: OpenAI
    model: gpt-4o

agent:
  reasoning: true       # Enable Manager/Executor workflow
  max_steps: 15         # Maximum execution steps (global)
  manager:
    vision: true        # Send screenshots to Manager
  executor:
    vision: true        # Send screenshots to Executor
  fast_agent:
    vision: false
    parallel_tools: true
    safe_execution: false
  scripter:
    max_steps: 10       # Scripter-specific max steps
    safe_execution: false
```

## When to Use Each Mode

**Use Reasoning Mode for:**
- Multi-step tasks (booking flights, configuring settings)
- Tasks requiring planning and adaptation
- Complex workflows across multiple apps

**Use Direct Mode for:**
- Simple actions (screenshots, sending messages)
- Fast execution without planning overhead
- Well-defined single-step tasks

## Shared State

All agents share `DroidAgentState` for coordination:
- Action history and outcomes
- Error tracking and recovery
- Memory and context
- Scripter results
- Current plan and progress

## Quick Reference

| Agent | Role | Best For | Mode | Config Key |
|-------|------|----------|------|------------|
| DroidAgent | Orchestrator | Entry point | Both | `agent.*` |
| ManagerAgent | Planner | Strategy, recovery | Reasoning | `agent.manager.*` |
| ExecutorAgent | Actor | Action execution | Reasoning | `agent.executor.*` |
| FastAgent | Direct | Simple tasks | Direct | `agent.fast_agent.*` |
| ScripterAgent | Python Executor | APIs, files, data | Reasoning | `agent.scripter.*` |

```

`docs/v5/concepts/events-and-workflows.mdx`:

```mdx
---
title: "Event Streaming"
description: "How to consume real-time events from DroidAgent execution."
---

## Overview

DroidRun provides **real-time event streaming** that gives you visibility into agent execution as it happens. This allows you to build UIs, logging systems, or monitoring tools that react to agent actions in real-time.

Under the hood, DroidRun uses [llama-index workflows](https://docs.llamaindex.ai/en/stable/understanding/workflows/) - an event-driven orchestration system that powers the agent architecture.

## Basic Usage

```python
from droidrun.agent.droid import DroidAgent

# Create and run agent
agent = DroidAgent(goal="Open Gmail and check inbox", config=config)
handler = agent.run()

# Stream events in real-time
async for event in handler.stream_events():
    if isinstance(event, ManagerPlanDetailsEvent):
        print(f"üìã Plan: {event.plan}")
        print(f"üéØ Current subgoal: {event.subgoal}")

    elif isinstance(event, ExecutorActionEvent):
        print(f"‚ö° Action: {event.description}")
        print(f"üí≠ Thought: {event.thought}")

    elif isinstance(event, ScreenshotEvent):
        save_screenshot(event.screenshot, "screenshot.png")

    elif isinstance(event, FastAgentResponseEvent):
        if event.code:
            print(f"üîß Tool calls: {event.code}")
        if event.thought:
            print(f"üí≠ Thought: {event.thought}")

# Wait for final result
result = await handler
print(f"‚úÖ Success: {result.success}")
print(f"üìù Reason: {result.reason}")
```

## Event Types

<AccordionGroup>
  <Accordion title="Workflow Coordination Events">
Used for workflow coordination between DroidAgent and its child agents.

```python
# Main workflow
class FastAgentExecuteEvent(Event):
    instruction: str

class FastAgentResultEvent(Event):
    success: bool
    reason: str
    instruction: str

class FinalizeEvent(Event):
    success: bool
    reason: str

class ResultEvent(StopEvent):
    success: bool
    reason: str
    steps: int
    structured_output: BaseModel | None

# Manager/Executor coordination
class ManagerInputEvent(Event): pass
class ManagerPlanEvent(Event):
    plan: str
    current_subgoal: str
    thought: str
    manager_answer: str = ""
    success: bool | None = None

class ExecutorInputEvent(Event):
    current_subgoal: str

class ExecutorResultEvent(Event):
    action: Dict
    outcome: bool
    error: str
    summary: str

# Scripter coordination
class ScripterExecutorInputEvent(Event):
    task: str

class ScripterExecutorResultEvent(Event):
    task: str
    message: str
    success: bool
    code_executions: int

# Text manipulation
class TextManipulatorInputEvent(Event):
    task: str

class TextManipulatorResultEvent(Event):
    task: str
    text_to_type: str
    code_ran: str
```
  </Accordion>

  <Accordion title="Manager Events (Internal)">
Internal to ManagerAgent, streamed to frontend/logging.

```python
class ManagerContextEvent(Event): pass

class ManagerResponseEvent(Event):
    output_planning: str
    usage: Optional[UsageResult]

class ManagerPlanDetailsEvent(Event):
    plan: str
    subgoal: str
    thought: str
    answer: str = ""
    memory_update: str = ""
    progress_summary: str = ""
    success: bool | None = None
    full_response: str = ""
```
  </Accordion>

  <Accordion title="Executor Events (Internal)">
Internal to ExecutorAgent, streamed to frontend/logging.

```python
class ExecutorContextEvent(Event):
    subgoal: str

class ExecutorResponseEvent(Event):
    response: str
    usage: Optional[UsageResult] = None

class ExecutorActionEvent(Event):
    action_json: str
    thought: str
    description: str
    full_response: str

class ExecutorActionResultEvent(Event):
    action: Dict
    success: bool
    error: str
    summary: str
    thought: str = ""
    full_response: str = ""
```
  </Accordion>

  <Accordion title="FastAgent Events (Internal)">
Internal to FastAgent, used in direct execution mode.

```python
class FastAgentInputEvent(Event):
    pass

class FastAgentResponseEvent(Event):
    thought: str
    code: Optional[str] = None
    usage: Optional[UsageResult] = None

class FastAgentToolCallEvent(Event):
    tool_calls_repr: str

class FastAgentOutputEvent(Event):
    output: str

class FastAgentEndEvent(Event):
    success: bool
    reason: str
    tool_call_count: int = 0
```
  </Accordion>

  <Accordion title="Scripter Events (Internal)">
Internal to ScripterAgent, for off-device script execution.

```python
class ScripterInputEvent(Event):
    pass

class ScripterThinkingEvent(Event):
    thoughts: str
    code: Optional[str]
    full_response: str
    usage: Optional[UsageResult]

class ScripterExecutionEvent(Event):
    code: str

class ScripterExecutionResultEvent(Event):
    output: str

class ScripterEndEvent(Event):
    message: str
    success: bool
    code_executions: int
```
  </Accordion>

  <Accordion title="Action Recording Events">
Emitted when actions are performed, used for macro recording and trajectory tracking.

```python
class MacroEvent(Event):  # Base class
    action_type: str
    description: str

class TapActionEvent(MacroEvent):
    x: int
    y: int
    element_index: int = None
    element_text: str = ""
    element_bounds: str = ""

class SwipeActionEvent(MacroEvent):
    start_x: int
    start_y: int
    end_x: int
    end_y: int
    duration_ms: int

class DragActionEvent(MacroEvent):
    start_x: int
    start_y: int
    end_x: int
    end_y: int
    duration_ms: int

class InputTextActionEvent(MacroEvent):
    text: str

class KeyPressActionEvent(MacroEvent):
    keycode: int
    key_name: str = ""

class StartAppEvent(MacroEvent):
    package: str
    activity: str = None

class WaitEvent(MacroEvent):
    duration: float
```
  </Accordion>

  <Accordion title="Visual & Telemetry Events">
```python
# Visual events
class ScreenshotEvent(Event):
    screenshot: bytes

class RecordUIStateEvent(Event):
    ui_state: list[Dict[str, Any]]

# Telemetry events (when enabled)
class DroidAgentInitEvent(TelemetryEvent):
    goal: str
    llms: Dict[str, str]
    tools: str
    max_steps: int
    timeout: int
    vision: Dict[str, bool]
    reasoning: bool
    enable_tracing: bool
    debug: bool
    save_trajectories: str
    runtype: str
    custom_prompts: Optional[Dict[str, str]]

class PackageVisitEvent(TelemetryEvent):
    package_name: str
    activity_name: str
    step_number: int

class DroidAgentFinalizeEvent(TelemetryEvent):
    success: bool
    reason: str
    steps: int
    unique_packages_count: int
    unique_activities_count: int

# Usage tracking
class UsageResult(BaseModel):
    request_tokens: int
    response_tokens: int
    total_tokens: int
    requests: int
```
  </Accordion>
</AccordionGroup>

## Common Patterns

### Building a Live UI

```python
async def run_with_ui(goal: str):
    agent = DroidAgent(goal=goal, config=config)
    handler = agent.run()

    async for event in handler.stream_events():
        if isinstance(event, ManagerPlanDetailsEvent):
            ui.update_plan(event.plan)
            ui.update_current_step(event.subgoal)

        elif isinstance(event, ExecutorActionEvent):
            ui.add_action_log(event.description, event.thought)

        elif isinstance(event, ScreenshotEvent):
            ui.update_screenshot(event.screenshot)

    result = await handler
    ui.show_completion(result.success, result.reason)
```

### Tracking Token Usage

```python
async def track_token_usage(goal: str):
    agent = DroidAgent(goal=goal, config=config)
    handler = agent.run()

    total_tokens = 0
    total_requests = 0

    async for event in handler.stream_events():
        # Check for events that contain usage information
        if hasattr(event, 'usage') and event.usage:
            total_tokens += event.usage.total_tokens
            total_requests += event.usage.requests

            print(f"LLM call - Input: {event.usage.request_tokens}, "
                  f"Output: {event.usage.response_tokens}, "
                  f"Total: {event.usage.total_tokens}")

    result = await handler
    print(f"\nüìä Total tokens used: {total_tokens}")
    print(f"üìä Total LLM requests: {total_requests}")
```

### Logging and Monitoring

```python
import logging

logger = logging.getLogger("droidrun.monitor")

async def monitor_execution(goal: str):
    agent = DroidAgent(goal=goal, config=config)
    handler = agent.run()

    start_time = time.time()
    action_count = 0

    async for event in handler.stream_events():
        if isinstance(event, ExecutorActionEvent):
            action_count += 1
            logger.info(f"Action {action_count}: {event.description}")

        elif isinstance(event, FastAgentOutputEvent):
            logger.info(f"Tool execution result: {event.output}")

    result = await handler
    duration = time.time() - start_time

    logger.info(f"Task completed in {duration:.2f}s with {action_count} actions")
    logger.info(f"Result: {result.success} - {result.reason}")
```

## Notes

### Event Streaming Behavior

- Events are **streamed in real-time** as the agent executes
- Not all events are emitted in every execution (depends on mode and actions)
- All events are **Pydantic models** with full type safety
- The `handler` object is **async** - always use `await handler` to get the final result

### Event Emission by Mode

**Reasoning Mode** (`reasoning=True`) emits:
- Coordination: `ManagerInputEvent`, `ManagerPlanEvent`, `ExecutorInputEvent`, `ExecutorResultEvent`
- Internal Manager: `ManagerContextEvent`, `ManagerResponseEvent`, `ManagerPlanDetailsEvent`
- Internal Executor: `ExecutorContextEvent`, `ExecutorResponseEvent`, `ExecutorActionEvent`, `ExecutorActionResultEvent`
- Actions: All action recording events (`TapActionEvent`, `SwipeActionEvent`, etc.)
- Visual: `ScreenshotEvent`, `RecordUIStateEvent` (when enabled)

**Direct Mode** (`reasoning=False`) emits:
- Coordination: `FastAgentExecuteEvent`, `FastAgentResultEvent`
- Internal FastAgent: `FastAgentInputEvent`, `FastAgentResponseEvent`, `FastAgentToolCallEvent`, `FastAgentOutputEvent`, `FastAgentEndEvent`
- Actions: All action recording events
- Visual: `ScreenshotEvent`, `RecordUIStateEvent` (when enabled)

**ScripterAgent** (when triggered by `<script>` tags) emits:
- Coordination: `ScripterExecutorInputEvent`, `ScripterExecutorResultEvent`
- Internal Scripter: `ScripterInputEvent`, `ScripterThinkingEvent`, `ScripterExecutionEvent`, `ScripterExecutionResultEvent`, `ScripterEndEvent`

**All Modes** emit:
- Finalization: `FinalizeEvent`, `ResultEvent`
- Telemetry: `DroidAgentInitEvent`, `PackageVisitEvent`, `DroidAgentFinalizeEvent` (when telemetry enabled)

### Event Categories

**Coordination Events** - Used for workflow routing between agents (minimal data)
- Located in `droidrun/agent/droid/events.py`
- Examples: `ManagerPlanEvent`, `ExecutorResultEvent`, `ScripterExecutorResultEvent`

**Internal Events** - Used for streaming to frontend/logging (full debug data)
- Located in agent-specific event files
- Examples: `ManagerPlanDetailsEvent`, `ExecutorActionEvent`, `FastAgentResponseEvent`

**Action Recording Events** - Emitted when actions are performed (for macros/trajectories)
- Located in `droidrun/agent/common/events.py`
- Examples: `TapActionEvent`, `SwipeActionEvent`, `InputTextActionEvent`

**Telemetry Events** - Captured for analytics (when enabled)
- Located in `droidrun/telemetry/events.py`
- Examples: `DroidAgentInitEvent`, `PackageVisitEvent`, `DroidAgentFinalizeEvent`

## Learn More

- [LlamaIndex Workflows](https://docs.llamaindex.ai/en/stable/understanding/workflows/) - The underlying orchestration system

```

`docs/v5/concepts/prompts.mdx`:

```mdx
---
title: 'Prompt Templates'
description: 'Customizing agent behavior with Jinja2 prompt templates.'
---

## Overview

Droidrun uses **Jinja2 templates** for agent prompts. You can customize agent behavior by passing custom template strings to `DroidAgent`:

```python
custom_prompts = {
    "manager_system": "Your Jinja2 template here...",
    "executor_system": "Another template...",
    "fast_agent_system": "...",
    "fast_agent_user": "...",
    "scripter_system": "..."
}

agent = DroidAgent(
    goal="Send an email",
    config=config,
    prompts=custom_prompts  # Pass template strings, not file paths
)
```

**Important**: The `prompts` parameter accepts Jinja2 **template strings**, not file paths.

## How It Works

1. `DroidAgent` creates a `PromptResolver` with your custom prompts
2. Each agent checks if you provided a custom template for its key (e.g., "manager_system")
3. If found: uses your custom template
4. If not found: loads the default template from Droidrun's built-in files
5. Templates are rendered with context variables specific to each agent

## Available Prompt Keys

| Key | Agent | When Used |
|-----|-------|-----------|
| `manager_system` | Manager | Planning and reasoning (only in reasoning mode) |
| `executor_system` | Executor | Action selection (only in reasoning mode) |
| `fast_agent_system` | FastAgent | Direct execution (always used) |
| `fast_agent_user` | FastAgent | Task input formatting (always used) |
| `scripter_system` | Scripter | Off-device Python execution (when enabled) |

## Context Variables

Each agent has access to different variables in its templates:

### Manager

- `instruction` - User's goal
- `device_date` - Current device date/time
- `app_card` - App-specific guidance (empty if none available)
- `error_history` - List of recent failed actions with details
- `custom_tools_descriptions` - Custom tool documentation
- `scripter_execution_enabled` - Whether Scripter is available
- `available_secrets` - Available credential IDs
- `variables` - Custom variables passed to DroidAgent
- `output_schema` - Pydantic model schema (if provided)

### Executor

- `instruction` - User's goal
- `device_state` - Current UI tree
- `subgoal` - Current subgoal from Manager
- `atomic_actions` - Available actions (includes custom tools)
- `action_history` - Recent actions with outcomes

### FastAgent

**System prompt:**
- `tool_descriptions` - Available tool signatures
- `available_secrets` - Credential IDs
- `variables` - Custom variables
- `output_schema` - Output model schema (if provided)

**User prompt:**
- `goal` - Task description
- `variables` - Custom variables

### Scripter

- `task` - Task description from Manager
- `available_secrets` - Credential IDs
- `variables` - Custom variables

## Example: Custom Manager Prompt

```python
custom_prompts = {
    "manager_system": """
You are a mobile automation planning agent.

Task: {{ instruction }}
Date: {{ device_date }}

{% if app_card %}
App guidance:
{{ app_card }}
{% endif %}

{% if error_history %}
Recent errors (you may be stuck):
{% for error in error_history %}
- Action: {{ error.action }}
  Error: {{ error.error }}
{% endfor %}
{% endif %}

{% if custom_tools_descriptions %}
Custom tools:
{{ custom_tools_descriptions }}
{% endif %}

{% if variables.domain %}
Domain: {{ variables.domain }}
{% endif %}

Output format:
<thought>Your reasoning</thought>
<plan>
1. First step
2. Second step
3. DONE
</plan>

Or if complete:
<request_accomplished>
Task is done. Answer: ...
</request_accomplished>
"""
}

agent = DroidAgent(
    goal="Send an email",
    config=config,
    prompts=custom_prompts,
    variables={"domain": "finance"}
)
```

## Example: Using Custom Variables

Custom variables let you inject dynamic context into prompts:

```python
custom_prompts = {
    "manager_system": """
Task: {{ instruction }}

{% if variables.budget %}
Budget limit: ${{ variables.budget }}
{% endif %}

{% if variables.priority %}
Priority: {{ variables.priority }}
{% endif %}

Guidelines:
{% for rule in variables.rules %}
- {{ rule }}
{% endfor %}
"""
}

agent = DroidAgent(
    goal="Buy a phone",
    config=config,
    prompts=custom_prompts,
    variables={
        "budget": 1000,
        "priority": "high",
        "rules": ["Check reviews", "Compare prices", "Use coupons"]
    }
)
```

## Jinja2 Syntax Reference

### Variables

```jinja2
{{ instruction }}
{{ variables.my_var }}
```

### Conditionals

```jinja2
{% if app_card %}
<app_card>{{ app_card }}</app_card>
{% endif %}

{% if error_history %}
You have {{ error_history | length }} errors
{% endif %}
```

### Loops

```jinja2
{% for error in error_history %}
- {{ error.action }}: {{ error.error }}
{% endfor %}
```

### Filters

```jinja2
{{ instruction | upper }}
{{ available_secrets | join(', ') }}
{{ error_history | length }}
```

## Best Practices

### 1. Use Clear Structure

```jinja2
<instruction>
{{ instruction }}
</instruction>

<guidelines>
1. Rule one
2. Rule two
</guidelines>

<output_format>
Expected format
</output_format>
```

### 2. Handle Missing Data with Conditionals

```jinja2
{% if app_card %}
<app_card>{{ app_card }}</app_card>
{% else %}
<note>No app-specific guidance available</note>
{% endif %}
```

### 3. Document Expected Variables

```jinja2
{# Expected variables:
   - instruction: str - User's goal
   - device_date: str - Current date/time
   - app_card: str - App guidance (may be empty)
#}
```

### 4. Use Variables for Dynamic Behavior

```jinja2
{% if variables.strict_mode %}
<strict>
Follow instructions exactly. Do not make assumptions.
</strict>
{% endif %}
```

## Complete Example

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# E-commerce automation with custom prompts
ecommerce_prompts = {
    "manager_system": """
You are an e-commerce automation specialist.

Task: {{ instruction }}
Budget: ${{ variables.budget }}

{% if app_card %}
App info:
{{ app_card }}
{% endif %}

{% if error_history %}
Errors encountered:
{% for error in error_history %}
- {{ error.action }}: {{ error.summary }} - {{ error.error }}
{% endfor %}
Consider changing your approach.
{% endif %}

Rules:
1. Verify product names exactly
2. Check prices before purchasing
3. Store order confirmations in memory
4. Never exceed budget

Output:
<thought>Your reasoning</thought>
<plan>
1. Step
2. DONE
</plan>
"""
}

config = DroidrunConfig()
agent = DroidAgent(
    goal="Buy iPhone 15 Pro from Amazon",
    config=config,
    prompts=ecommerce_prompts,
    variables={"budget": 1200}
)

result = await agent.run()
```

## Key Points

- Pass Jinja2 template **strings** (not file paths) to `DroidAgent(prompts={...})`
- Each agent has different available variables in its template
- Use `variables` parameter to inject custom context
- Templates are rendered at runtime with current state
- If no custom prompt provided, default templates are used
- Supports full Jinja2 syntax (conditionals, loops, filters)

```

`docs/v5/concepts/scripter-agent.mdx`:

```mdx
---
title: 'ScripterAgent'
description: 'Off-device Python execution for API calls, file operations, and data processing.'
---

## What is ScripterAgent?

**ScripterAgent** executes **off-device Python code** for tasks that don't require device interaction. It's triggered by ManagerAgent when API calls, file operations, or data processing are needed.

ScripterAgent enables:
- **API calls**: REST APIs, webhooks, database queries
- **File operations**: Reading, writing, parsing files
- **Data processing**: JSON/CSV parsing, transformations, filtering

**Key difference**: ScripterAgent runs code that **doesn't interact with the device**, while FastAgent uses XML tool-calling for **device interaction**.

## How It Works

ManagerAgent delegates tasks to ScripterAgent by providing **full context and a high-level task description**. ScripterAgent is a **ReAct agent** that follows a think-execute-observe loop:

1. **Receives task** from Manager with full context
2. **Thinks** and generates Python code to make progress
3. **Executes** the code and observes the output
4. **Repeats** steps 2-3 until task is complete
5. **Returns message** to Manager summarizing the results

ScripterAgent signals completion by returning a message **without code** (not a function call). Variables persist across iterations like a Jupyter notebook.

## Examples

### API Calls

**Manager delegates**:
```
User needs current weather in San Francisco to decide clothing.
Task: Fetch weather from API and extract temperature + conditions
API: https://api.weather.com/forecast?city=San Francisco
```

**ScripterAgent (Iteration 1)**:
```python
# Think: I need to make an API request to get weather data
import requests

response = requests.get(
    "https://api.weather.com/forecast",
    params={"city": "San Francisco"}
)
print(response.json())
```
**Output**: `{'temp': 62, 'description': 'Partly cloudy', 'humidity': 65}`

**ScripterAgent (Final)**:
```
The weather in San Francisco is 62¬∞F with partly cloudy conditions.
```
*(Manager receives this message)*

### Webhook Notifications

**Manager delegates**:
```
Flight booking was completed successfully at 2024-01-15T10:30:00.
Task: Send status update to monitoring webhook
Webhook URL: https://webhook.site/your-webhook-id
Include: task name, status, timestamp
```

**ScripterAgent**:
```python
import requests

payload = {
    "task": "Flight booking completed",
    "status": "success",
    "timestamp": "2024-01-15T10:30:00"
}

response = requests.post(
    "https://webhook.site/your-webhook-id",
    json=payload
)
print(f"Webhook response: {response.status_code}")
```
**Output**: `Webhook response: 200`

**ScripterAgent (Final)**:
```
Successfully sent webhook notification. Server responded with status 200.
```

### File Operations

**Manager delegates**:
```
Contacts file at /tmp/contacts.csv contains all contacts.
Task: Filter contacts from New York and save as JSON
Output: /tmp/filtered_contacts.json
```

**ScripterAgent (Iteration 1)**:
```python
import csv

with open('/tmp/contacts.csv', 'r') as f:
    reader = csv.DictReader(f)
    contacts = list(reader)
print(f"Total contacts: {len(contacts)}")
print(f"Sample: {contacts[0]}")
```
**Output**: `Total contacts: 150` `Sample: {'name': 'John', 'city': 'New York', 'email': '...'}`

**ScripterAgent (Iteration 2)**:
```python
import json

# Filter New York contacts
ny_contacts = [c for c in contacts if c['city'] == 'New York']

with open('/tmp/filtered_contacts.json', 'w') as f:
    json.dump(ny_contacts, f, indent=2)

print(f"Filtered {len(ny_contacts)} contacts from New York")
```
**Output**: `Filtered 23 contacts from New York`

**ScripterAgent (Final)**:
```
Found 23 contacts from New York and saved them to /tmp/filtered_contacts.json
```

## Configuration

```yaml
agent:
  scripter:
    max_steps: 10
    safe_execution:
      enabled: true
      allowed_modules:
        - requests    # API calls, webhooks
        - json        # JSON parsing
        - csv         # CSV file operations
        - pathlib     # File path handling
      blocked_modules:
        - subprocess  # Process spawning
        - os          # System operations
        - sys         # System modifications
```

**Safe execution** restricts dangerous operations by default. Only modules in `allowed_modules` can be imported.

## Key Points

- **ReAct agent**: Think-execute-observe loop until task complete
- **Off-device only**: No device interactions
- **State persistence**: Variables persist across iterations (Jupyter-style)
- **Completion signal**: Returns message without code when done
- **Safe by default**: Restricted imports/builtins
```

`docs/v5/concepts/shared-state.mdx`:

```mdx
---
title: 'Shared State'
description: 'DroidAgentState - the coordination mechanism for multi-agent workflow communication.'
---

## What is Shared State?

**DroidAgentState** is a Pydantic model that serves as the **central coordination mechanism** for DroidRun's multi-agent workflow. It's a shared data structure that all agents (Manager, Executor, FastAgent, Scripter) can read from and write to.

Shared state enables:
- **Cross-agent communication**: Agents share information about actions, results, and errors
- **Progress tracking**: Step counts, action history, visited apps/screens
- **Memory management**: Agent memory, custom variables, user session data
- **Error coordination**: Error flags, escalation thresholds, error descriptions

**Key insight**: Shared state replaces complex message passing. Instead of sending data back and forth, agents update a single shared object.

## Core State Fields

```python
class DroidAgentState(BaseModel):
    # Task context
    instruction: str = ""           # Original task
    step_number: int = 0            # Current step

    # Device state
    formatted_device_state: str = ""           # Human-readable state
    current_package_name: str = ""             # Current app
    current_activity_name: str = ""            # Current screen

    # Action tracking
    action_history: List[Dict] = []            # All actions taken
    action_outcomes: List[bool] = []           # Success/failure
    summary_history: List[str] = []            # Action summaries

    # Memory
    memory: str = ""                           # Agent persistent memory

    # Planning (Manager)
    plan: str = ""                             # Current plan
    current_subgoal: str = ""                  # Current subgoal
    manager_answer: str = ""                   # Answer-type responses

    # Error handling
    error_flag_plan: bool = False              # Signal error to Manager
    error_descriptions: List[str] = []         # Error messages

    # Script execution (Scripter)
    scripter_history: List[Dict] = []          # Scripter results
    last_scripter_success: bool = True         # Last execution status

    # Custom variables
    custom_variables: Dict = {}                # User-defined data
```
```

`docs/v5/features/app-cards.mdx`:

```mdx
---
title: 'App Instruction Cards'
description: 'App cards give your agents app-specific knowledge to operate apps more effectively. They automatically load when agents work with specific apps, improving success rates for navigation and complex tasks.'
---

## What Are App Cards?

App cards are **app-specific instruction guides** that teach agents how to use apps effectively. Think of them as cheat sheets that help your agent understand:

- How to navigate the app's UI
- Where to find buttons and features
- App-specific shortcuts and gestures
- Search syntax and filters (for apps like Gmail)
- Common workflows and best practices

**Example:** When your agent opens Gmail, it automatically loads the Gmail app card and learns that:
- The compose button is at the bottom-right
- Search supports filters like `from:sender@email.com` or `has:attachment`
- Swiping right archives emails, swiping left deletes them

This knowledge helps agents complete tasks faster and more reliably.

---

## Why Use App Cards?

**Without app cards:**
- Agents guess how to navigate unfamiliar apps
- Trial-and-error wastes time and tokens
- Success rates drop for complex workflows

**With app cards:**
- ‚úÖ Agents know exactly where to find features
- ‚úÖ First-attempt success for common tasks
- ‚úÖ Reduced token usage (less exploration needed)
- ‚úÖ Better handling of app-specific quirks

---

## Quick Start

Droidrun includes a sample Gmail app card to demonstrate how app cards work:

```bash
# App cards are enabled by default
droidrun run "Send an email to john@example.com" --reasoning
```

When the agent opens Gmail, the Gmail app card automatically loads and guides the workflow.

**Sample app card included:**
- **Gmail** (`com.google.android.gm`) - Email navigation, search, composition

You can use this as a template to create cards for other apps (see "Creating Custom App Cards" below).

---

## How App Cards Work

### Automatic Loading

1. **Detection:** Agent detects the current foreground app (e.g., Gmail)
2. **Loading:** Droidrun loads the app card for that package name
3. **Injection:** App card content is added to the agent's prompt
4. **Guidance:** Agent uses the instructions to make better decisions

**Technical note:** App cards are loaded asynchronously and cached in memory. Loading happens in the background and doesn't block agent execution.

### When Are They Used?

App cards are used by the **Manager Agent** when running in reasoning mode (`--reasoning` flag or `reasoning: true` in config):

```bash
# App cards enabled (Manager uses them for planning)
droidrun run "Archive all unread emails" --reasoning

# App cards not used (direct execution mode)
droidrun run "Tap the button"
```

---

## Creating Custom App Cards

Want to add an app card for your favorite app? Here's how:

### Step 1: Find the Package Name

```bash
# Get all apps
adb shell pm list packages

# Or search for a specific app
adb shell pm list packages | grep keyword
```

**Common package names:**
- Chrome: `com.android.chrome`
- WhatsApp: `com.whatsapp`
- Instagram: `com.instagram.android`
- YouTube: `com.google.android.youtube`

### Step 2: Create the Files

Create the app cards directory and files:

```bash
mkdir -p config/app_cards
touch config/app_cards/app_cards.json
touch config/app_cards/chrome.md
```

**Example structure:**

```markdown
# Chrome App Guide

## Navigation
- Address bar at the top for entering URLs
- Three-dot menu (top-right) for settings and history
- Tabs button (top-right) to switch between tabs

## Search
- Type queries directly in the address bar
- Use voice search via the microphone icon

## Common Actions
- **New Tab**: Tap the tabs button ‚Üí Plus icon
- **Close Tab**: Swipe tab away in tab switcher
- **Refresh**: Pull down from the top of the page
- **Bookmarks**: Three-dot menu ‚Üí Bookmarks

## Tips
- Incognito mode available via three-dot menu
- Downloads accessible via three-dot menu ‚Üí Downloads
```

### Step 3: Register the App Card

Add your app mapping to `config/app_cards/app_cards.json`:

```json
{
  "com.google.android.gm": "gmail.md",
  "com.android.chrome": "chrome.md"
}
```

**Using subdirectories:**

```json
{
  "com.whatsapp": "social/whatsapp.md",
  "com.instagram.android": "social/instagram.md"
}
```

### Step 4: Test

```bash
droidrun run "Open Chrome and search for droidrun" --reasoning --debug
```

Look for this log message:
```
Loaded app card for com.android.chrome from config/app_cards/chrome.md
```

---

## Configuration

App cards are enabled by default and load from `config/app_cards/`:

```yaml
agent:
  app_cards:
    enabled: true
    app_cards_dir: config/app_cards
```

**To disable:**
```yaml
agent:
  app_cards:
    enabled: false
```

---

## App Card Best Practices

### Content Guidelines

**Do:**
- Be concise and actionable
- Focus on UI patterns and workflows
- Include search syntax and special features
- Mention common pitfalls or quirks
- Use bullet points and clear headings

**Don't:**
- Write essays or lengthy explanations
- Describe every single feature
- Include information that changes frequently (version-specific details)
- Duplicate general Android knowledge (agents already know how to tap, swipe, etc.)

### Example: Good vs Bad

**‚ùå Bad (too verbose):**
```markdown
Gmail is an email application developed by Google. It has many features
including the ability to send and receive emails. To compose an email,
you need to first understand that Gmail uses a material design interface
with a floating action button, which is a circular button...
```

**‚úÖ Good (concise and actionable):**
```markdown
## Composing Emails
- Tap the floating compose button (bottom-right)
- Fill recipient, subject, and body
- Send via paper plane icon (top-right)
```

---

## Troubleshooting

### App Card Not Loading

**Check these:**

1. **Is the package name correct?**
   ```bash
   adb shell dumpsys window windows | grep -E 'mCurrentFocus'
   ```

2. **Is the mapping correct in app_cards.json?**
   ```json
   {
     "com.your.app": "yourapp.md"
   }
   ```

3. **Does the markdown file exist?**
   ```bash
   ls config/app_cards/yourapp.md
   ```

4. **Are app cards enabled?**
   ```yaml
   agent:
     app_cards:
       enabled: true
   ```

5. **Are you using reasoning mode?**
   ```bash
   droidrun run "command" --reasoning
   ```

### Debug Mode

Run with `--debug` to see app card loading:

```bash
droidrun run "Open Gmail" --reasoning --debug
```

Look for these log messages:
```
Loaded app_cards.json with 2 entries
Loaded app card for com.google.android.gm from config/app_cards/gmail.md
```

---

## Related Documentation

- [CLI Usage](/v5/guides/cli) - Droidrun CLI command reference
- [Configuration](/v5/sdk/configuration) - Configuration system details
- [Agent Architecture](/v5/concepts/architecture) - How agents work
- [Manager Agent](/v5/concepts/architecture#manageragent-planner) - Agent that uses app cards

---

**Help your agents become app experts with well-crafted app cards!**

```

`docs/v5/features/credentials.mdx`:

```mdx
---
title: 'Credential Management'
description: 'Extend Droidrun with secure credential management'
---

## Overview

Secure storage for passwords, API keys, and tokens.
- Stored in YAML files or in-memory dicts
- Never logged or exposed
- Auto-injected as `type_secret` action
- Simple string or dict format

## Quick Start

### Method 1: In-Memory (Recommended for SDK)

```python
import asyncio
from droidrun import DroidAgent, DroidrunConfig

async def main():
    # Define credentials directly
    credentials = {
        "MY_PASSWORD": "secret123",
        "API_KEY": "sk-1234567890"
    }

    config = DroidrunConfig()

    agent = DroidAgent(
        goal="Login to my app",
        config=config,
        credentials=credentials  # Pass directly
    )

    result = await agent.run()
    print(result.success)

asyncio.run(main())
```

### Method 2: YAML File

1. **Create credentials file:**

```yaml
# credentials.yaml
secrets:
  # Dict format (recommended)
  MY_PASSWORD:
    value: "your_password_here"
    enabled: true

  GMAIL_PASSWORD:
    value: "gmail_pass_123"
    enabled: true

  # Simple string format (auto-enabled)
  API_KEY: "sk-1234567890abcdef"

  # Disabled secret
  OLD_PASSWORD:
    value: "old_pass"
    enabled: false  # Not loaded
```

2. **Enable in config.yaml:**

```yaml
# config.yaml
credentials:
  enabled: true
  file_path: config/credentials.yaml
```

3. **Use in code:**

```python
from droidrun import DroidAgent, DroidrunConfig

# Config loads credentials from file
config = DroidrunConfig.from_yaml("config.yaml")

agent = DroidAgent(
    goal="Login to Gmail",
    config=config  # Credentials loaded automatically
)
```

---

## How Agents Use Credentials

When credentials are provided, the `type_secret` action is **automatically available**:

### Executor/Manager Mode
```json
{
  "action": "type_secret",
  "secret_id": "MY_PASSWORD",
  "index": 5
}
```

### FastAgent Mode
```xml
<type_secret>
  <secret_id>MY_PASSWORD</secret_id>
  <index>5</index>
</type_secret>
```

The agent never sees the actual value - only the secret ID.

---

## Example: Login Automation

```python
import asyncio
from droidrun import DroidAgent, DroidrunConfig

async def main():
    credentials = {
        "EMAIL_USER": "user@example.com",
        "EMAIL_PASS": "secret_password"
    }

    config = DroidrunConfig()

    agent = DroidAgent(
        goal="Open Gmail and login with my credentials",
        config=config,
        credentials=credentials
    )

    result = await agent.run()
    print(f"Success: {result.success}")

asyncio.run(main())
```

**What the agent does:**
1. Opens Gmail: `open_app("Gmail")`
2. Clicks email field: `click(index=3)`
3. Types email: `type("user@example.com", index=3)`
4. Clicks password field: `click(index=5)`
5. Types password securely: `type_secret("EMAIL_PASS", index=5)`
6. Clicks login: `click(index=7)`

## Credentials vs Variables

| Feature | Credentials | Variables |
|---------|------------|-----------|
| **Purpose** | Passwords, API keys | Non-sensitive data |
| **Storage** | YAML or in-memory | In-memory only |
| **Logging** | Never logged | May appear in logs |
| **Access** | Via `type_secret` tool | In shared state |
| **Security** | Protected | No protection |

**Example: Using Variables**
```python
variables = {
    "target_email": "john@example.com",
    "subject_line": "Monthly Report"
}

agent = DroidAgent(
    goal="Compose email to {{target_email}}",
    config=config,
    variables=variables  # Non-sensitive
)
```

---

## Troubleshooting

### Error: Credential manager not initialized

**Solution:**
```yaml
# config.yaml
credentials:
  enabled: true  # Must be true
  file_path: config/credentials.yaml
```

Or:
```python
agent = DroidAgent(..., credentials={"PASSWORD": "secret"})
```

### Error: Secret 'X' not found

**Check available secrets:**
```python
from droidrun.credential_manager import FileCredentialManager

cm = FileCredentialManager("config/credentials.yaml")
print(await cm.get_keys())
```

**Verify in YAML:**
```yaml
secrets:
  X:
    value: "your_value"
    enabled: true  # Must be true
```

---

## Custom Credential Managers

Extend `CredentialManager` for custom secret storage:

```python
from droidrun.credential_manager import CredentialManager

class MyCredentialManager(CredentialManager):
    def __init__(self, api_key):
        self.api_key = api_key

    async def resolve_key(self, key: str) -> str:
        # Implement your own credential retrieval logic
        return await fetch_from_service(key, self.api_key)

    async def get_keys(self) -> list[str]:
        # Return list of available credential keys
        return await fetch_available_keys(self.api_key)

# Use it
credentials = MyCredentialManager(api_key="...")
agent = DroidAgent(goal="Login", config=config, credentials=credentials)
```

Implement any custom secret storage backend.

---

## Related

See [Configuration Guide](/v5/sdk/configuration) for credential setup.

See [Custom Variables](/v5/features/custom-variables) for non-sensitive data.

```

`docs/v5/features/custom-tools.mdx`:

```mdx
---
title: 'Custom Tools'
description: 'Extend Droidrun with custom Python functions'
---

## Overview

Custom tools are Python functions that extend agent capabilities beyond built-in atomic actions (click, type, swipe).

**Use cases:**
- External API calls (webhooks, REST services)
- Data processing and calculations
- Database operations
- Domain-specific logic

---

## Quick Start

### Basic Example

Simple custom tool without device access:

```python
import asyncio
from droidrun import DroidAgent, DroidrunConfig

def calculate_tax(amount: float, rate: float, **kwargs) -> str:
    """Calculate tax for a given amount."""
    tax = amount * rate
    total = amount + tax
    return f"Tax: ${tax:.2f}, Total: ${total:.2f}"

custom_tools = {
    "calculate_tax": {
        "parameters": {
            "amount": {"type": "number", "required": True},
            "rate": {"type": "number", "required": True},
        },
        "description": "Calculate tax for a given amount and rate",
        "function": calculate_tax
    }
}

async def main():
    config = DroidrunConfig()

    agent = DroidAgent(
        goal="Calculate tax for $100 at 8% rate",
        config=config,
        custom_tools=custom_tools
    )

    result = await agent.run()
    print(result.success, result.reason)

asyncio.run(main())
```

---

## Tool Structure

All custom tools follow this format:

```python
custom_tools = {
    "tool_name": {
        "parameters": {                          # Parameter definitions
            "arg1": {"type": "string", "required": True},
            "arg2": {"type": "string", "required": True},
        },
        "description": "Tool description...",    # For LLM prompt
        "function": callable_function            # Python function
    }
}
```

**Function signature:**
```python
async def tool_name(arg1: type, arg2: type, *, ctx: ActionContext, **kwargs) -> str:
    """
    Args:
        arg1: Your parameter
        arg2: Another parameter
        ctx: ActionContext (injected automatically by the registry)
    """
    # Implementation
    return "result"
```

**Key points:**
- List only user parameters in `"parameters"` (not `ctx`)
- `ctx` (an `ActionContext` instance) is injected automatically as a keyword argument
- Access device via `ctx.driver`, shared state via `ctx.shared_state`, credentials via `ctx.credential_manager`
- Use `**kwargs` for forward compatibility
- Return type should be `str`

---

## Using ActionContext

Access the device and state via the `ctx` parameter (an `ActionContext` instance injected automatically):

```python
async def screenshot_and_count(*, ctx, **kwargs) -> str:
    """Take screenshot and count UI elements."""
    # Take screenshot via the driver
    screenshot = await ctx.driver.screenshot()

    # Get UI state via the state provider
    ui_state = await ctx.state_provider.get_state()
    element_count = len(ui_state.elements) if ui_state else 0

    return f"Screenshot taken. Found {element_count} UI elements"

custom_tools = {
    "screenshot_and_count": {
        "parameters": {},
        "description": "Take screenshot and count UI elements on screen",
        "function": screenshot_and_count
    }
}
```

**Available via `ctx`:**
- `ctx.driver` - `DeviceDriver` for raw device I/O (screenshot, tap, swipe, etc.)
- `ctx.state_provider` - `StateProvider` to fetch/parse UI state
- `ctx.ui` - Current `UIState` (refreshed each step)
- `ctx.shared_state` - `DroidAgentState` for agent coordination
- `ctx.credential_manager` - `CredentialManager` for secrets

---

## Accessing Shared State

Access agent state via `ctx.shared_state`:

```python
async def check_action_history(action_name: str, *, ctx, **kwargs) -> str:
    """Check if action was recently performed."""
    shared_state = ctx.shared_state

    # Check recent actions
    recent_actions = shared_state.action_history[-5:]
    already_done = any(a.get("action") == action_name for a in recent_actions)

    if already_done:
        return f"Action '{action_name}' was already performed recently"

    # Check step count
    if shared_state.step_number > 10:
        return "Warning: Task taking too many steps"

    # Access memory
    if "skip_validation" in shared_state.memory:
        return "Validation skipped per memory"

    return f"Action '{action_name}' not yet performed"

custom_tools = {
    "check_action_history": {
        "parameters": {
            "action_name": {"type": "string", "required": True},
        },
        "description": "Check if a specific action was recently performed in agent history",
        "function": check_action_history
    }
}
```

**DroidAgentState fields:**
- `step_number` - Current execution step
- `action_history` - List of executed actions
- `action_outcomes` - Success/failure per action
- `memory` - Agent memory dict
- `custom_variables` - User-provided variables
- `visited_packages` - Apps visited
- `current_package_name` - Current app package
- `plan` - Current Manager plan
- More in `droidrun/agent/droid/state.py`

---

## Common Patterns

### API Integration

```python
import requests

def fetch_weather(city: str, **kwargs) -> str:
    """Fetch weather data from API."""
    try:
        # Using OpenWeatherMap API example
        api_key = "your_api_key"
        url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}"

        response = requests.get(url, timeout=10)
        response.raise_for_status()

        data = response.json()
        temp = data["main"]["temp"] - 273.15  # Convert to Celsius
        weather = data["weather"][0]["description"]

        return f"Weather in {city}: {weather}, {temp:.1f}¬∞C"
    except Exception as e:
        return f"Error: {str(e)}"

custom_tools = {
    "fetch_weather": {
        "parameters": {
            "city": {"type": "string", "required": True},
        },
        "description": "Fetch current weather data for a given city",
        "function": fetch_weather
    }
}
```

### Database Query

```python
import sqlite3

def query_database(query: str, **kwargs) -> str:
    """Query local database."""
    try:
        conn = sqlite3.connect("app.db")
        cursor = conn.execute(query)
        results = cursor.fetchall()
        conn.close()

        return f"Found {len(results)} results"
    except Exception as e:
        return f"Database error: {str(e)}"

custom_tools = {
    "query_database": {
        "parameters": {
            "query": {"type": "string", "required": True},
        },
        "description": "Execute SQL query on local database and return results",
        "function": query_database
    }
}
```

### Async Operations

```python
import aiohttp

async def fetch_async(url: str, **kwargs) -> str:
    """Fetch data asynchronously."""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                data = await response.text()
                return f"Fetched {len(data)} bytes from {url}"
    except Exception as e:
        return f"Error: {str(e)}"

custom_tools = {
    "fetch_async": {
        "parameters": {
            "url": {"type": "string", "required": True},
        },
        "description": "Asynchronously fetch data from a URL",
        "function": fetch_async
    }
}
```

---

## Best Practices

### 1. Clear Descriptions
Write descriptive, specific descriptions:

```python
# Good
"description": "Send POST request to webhook URL with JSON data payload"

# Bad
"description": "Send webhook"
```

### 2. Error Handling
Always catch exceptions:

```python
def robust_tool(url: str, **kwargs) -> str:
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        return f"Success: {response.status_code}"
    except requests.Timeout:
        return "Error: Request timed out"
    except requests.RequestException as e:
        return f"Error: {str(e)}"
    except Exception as e:
        return f"Unexpected error: {str(e)}"
```

### 3. Argument Validation
Validate inputs before processing:

```python
def validated_tool(count: int, **kwargs) -> str:
    if not isinstance(count, int):
        return "Error: count must be integer"
    if count < 0 or count > 100:
        return "Error: count must be 0-100"

    return f"Processed {count} items"
```

### 4. Logging
Use Python logging for debugging:

```python
import logging
logger = logging.getLogger("droidrun")

def logged_tool(data: str, **kwargs) -> str:
    logger.info(f"Processing: {data[:50]}...")
    # Process data
    logger.info("Complete")
    return "Success"
```

---

## Advanced Example

Combining ActionContext, shared state, and credentials:

```python
import requests

async def send_authenticated_request(
    url: str,
    data: str,
    *,
    ctx,
    **kwargs
) -> str:
    """Send authenticated API request with credentials."""
    try:
        # Access credentials via ActionContext
        if not ctx.credential_manager:
            return "Error: Credential manager not available"

        api_key = await ctx.credential_manager.resolve_key("API_KEY")

        # Check if we've made too many requests
        if ctx.shared_state.step_number > 15:
            return "Error: Too many API calls"

        # Send authenticated request
        headers = {"Authorization": f"Bearer {api_key}"}
        response = requests.post(url, json={"data": data}, headers=headers, timeout=10)
        response.raise_for_status()

        return f"Request successful: {response.status_code}"
    except Exception as e:
        return f"Error: {str(e)}"

custom_tools = {
    "send_authenticated_request": {
        "parameters": {
            "url": {"type": "string", "required": True},
            "data": {"type": "string", "required": True},
        },
        "description": "Send authenticated API request using stored credentials",
        "function": send_authenticated_request
    }
}

# Usage with credentials
credentials = {"API_KEY": "sk-1234567890"}

agent = DroidAgent(
    goal="Send data to API",
    config=config,
    custom_tools=custom_tools,
    credentials=credentials
)
```

---

## Related

See [Agent Architecture](/v5/concepts/architecture) for understanding shared state and custom tools integration.
```

`docs/v5/features/custom-variables.mdx`:

```mdx
---
title: 'Custom Variables'
description: 'Pass dynamic data to your Droidrun agents using the `variables` parameter. Variables enable parameterized workflows and reusable automation.'
---

Custom variables are accessible in:
- **Agent prompts** via custom Jinja2 templates
- **Custom tools** via `ctx.shared_state.custom_variables`

---

## Quick Start

```python
from droidrun import DroidAgent, DroidrunConfig

# Define custom prompts that render variables
custom_prompts = {
    "manager_system": """
{{ instruction }}

{% if variables %}
Available variables:
{% for key, value in variables.items() %}
- {{ key }}: {{ value }}
{% endfor %}
{% endif %}
    """
}

# Create agent with variables
config = DroidrunConfig()

agent = DroidAgent(
    goal="Send email to recipient with subject",
    config=config,
    variables={"recipient": "john@example.com", "subject": "Update"},
    prompts=custom_prompts  # Required to see variables
)

result = await agent.run()
```

**Important:** Default prompts don't render variables. You must provide custom prompts via the `prompts` parameter.

---

## How Variables Work

When you pass `variables` to `DroidAgent`:

1. **Stored** in `DroidAgentState.custom_variables`
2. **Passed** to prompt templates as `variables` dict
3. **Rendered** in Jinja2 templates via `{% if variables %}` blocks
4. **Available** to all child agents throughout the workflow

**Access Summary:**
- ‚úÖ Agent prompts (via custom Jinja2 templates)
- ‚úÖ Agents can read and pass to tools as arguments
- ‚úÖ Custom tools (via `ctx.shared_state.custom_variables`)

---

## Basic Usage

```python
from droidrun import DroidAgent, DroidrunConfig

# Define variables
variables = {
    "recipient": "alice@example.com",
    "message": "Hello from Droidrun!"
}

# Custom prompt to render variables
custom_prompts = {
    "fast_agent_system": """
You are an agent that controls Android devices.

{% if variables %}
Available variables:
{% for key, value in variables.items() %}
- {{ key }}: {{ value }}
{% endfor %}
{% endif %}

Use these variables when executing tasks.
    """
}

# Create agent
config = DroidrunConfig()

agent = DroidAgent(
    goal="Send message to recipient",
    config=config,
    variables=variables,
    prompts=custom_prompts
)

result = await agent.run()
```

### Available Prompt Keys

Customize these prompts to render variables:

- `manager_system` - Manager agent system prompt
- `executor_system` - Executor agent system prompt
- `fast_agent_system` - FastAgent system prompt
- `fast_agent_user` - FastAgent user prompt
- `scripter_system` - Scripter agent system prompt

---

## Accessing Variables in Custom Tools

Custom tools can access variables via the `ctx` keyword argument (an `ActionContext` instance injected automatically):

```python
from droidrun import DroidAgent, DroidrunConfig

async def send_notification(title: str, *, ctx, **kwargs):
    """Send a notification using channel from custom variables.

    Args:
        title: Notification title
        ctx: ActionContext (injected automatically by the registry)
    """
    # Access custom variables via ctx.shared_state
    channel = ctx.shared_state.custom_variables.get("notification_channel", "default")
    return f"Sent '{title}' to {channel}"

custom_tools = {
    "send_notification": {
        "parameters": {
            "title": {"type": "string", "required": True},
        },
        "description": "Send a notification with title. Usage: {\"action\": \"send_notification\", \"title\": \"Alert\"}",
        "function": send_notification
    }
}

config = DroidrunConfig()

agent = DroidAgent(
    goal="Send notification with title 'Alert'",
    config=config,
    custom_tools=custom_tools,
    variables={"notification_channel": "alerts"}
)
```

---

## Use Cases

### Parameterized Workflows

```python
# Define reusable workflow with different variables
for user in ["alice@example.com", "bob@example.com"]:
    agent = DroidAgent(
        goal="Send welcome email",
        config=config,
        variables={"recipient": user},
        prompts=custom_prompts
    )
    await agent.run()
```

### Configuration Data

```python
variables = {
    "api_endpoint": "https://api.example.com/v2",
    "timeout": 30
}

agent = DroidAgent(
    goal="Call API endpoint",
    config=config,
    variables=variables,
    prompts=custom_prompts
)
```

---

## Key Points

1. **Custom prompts required** - Default prompts don't render variables in agent context
2. **Direct access in tools** - Custom tools access `ctx.shared_state.custom_variables` via the `ActionContext`
3. **Available to all agents** - Manager, Executor, FastAgent, Scripter all receive variables
4. **Jinja2 templates** - Use `{% if variables %}` blocks in custom prompts
5. **Auto-injection** - `ctx` (ActionContext) is injected automatically by the tool registry

## Related Documentation

- [Custom Prompts](/v5/concepts/prompts) - How to customize agent prompts
- [Custom Tools](/v5/features/custom-tools) - Creating custom tool functions
- [DroidAgent SDK](/v5/sdk/droid-agent) - Complete API reference

```

`docs/v5/features/structured-output.mdx`:

```mdx
---
title: 'Structured Output'
description: 'Extract structured data from device interactions using Pydantic models'
---

## Quick Start

```python
import asyncio
from pydantic import BaseModel, Field
from droidrun import DroidAgent, DroidrunConfig

# 1. Define output structure
class ContactInfo(BaseModel):
    """Contact information from device."""
    name: str = Field(description="Full name of the contact")
    phone: str = Field(description="Phone number")
    email: str = Field(description="Email address", default="Not provided")

# 2. Create agent with output_model
async def main():
    config = DroidrunConfig()

    agent = DroidAgent(
        goal="Find John Smith's contact information",
        config=config,
        output_model=ContactInfo,
    )

    # 3. Run and access structured output
    result = await agent.run()

    if result.success and result.structured_output:
        contact: ContactInfo = result.structured_output
        print(f"Name: {contact.name}")
        print(f"Phone: {contact.phone}")
        print(f"Email: {contact.email}")

asyncio.run(main())
```

---

## How It Works

### Two-Stage Process

**Stage 1: Task Execution**
- DroidAgent performs device actions while collecting required information
- System prompt is automatically injected with your Pydantic schema
- Agent completes with natural language answer containing the data

**Stage 2: Extraction (Post-Completion)**
- `StructuredOutputAgent` receives the final answer text
- Uses LLM's `astructured_predict()` to extract data into your model
- Validates against schema and returns typed object or `None`

---

## Example: Invoice Extraction

```python
from pydantic import BaseModel, Field
from typing import List

class Invoice(BaseModel):
    """Invoice information."""
    invoice_number: str = Field(description="Invoice ID")
    vendor_name: str = Field(description="Vendor name")
    total_due: float = Field(description="Total amount in dollars")

agent = DroidAgent(
    goal="Open Gmail and extract invoice from Acme Corp email",
    config=DroidrunConfig(),
    output_model=Invoice,
)

result = await agent.run()
invoice = result.structured_output
print(f"Invoice {invoice.invoice_number}: ${invoice.total_due}")
```

---

## Working with Results

### Accessing Data

```python
result = await agent.run()

if result.success:
    if result.structured_output:
        data = result.structured_output  # Typed Pydantic object
        print(f"Extracted: {data}")
    else:
        print(f"Extraction failed, text answer: {result.reason}")
else:
    print(f"Task failed: {result.reason}")
```

### Exporting to JSON

```python
result = await agent.run()

if result.structured_output:
    # Convert to JSON and save
    json_str = result.structured_output.model_dump_json(indent=2)
    with open("output.json", "w") as f:
        f.write(json_str)
```

---

## Configuration

### Custom Extraction LLM

By default, extraction uses the `fast_agent` LLM. Specify a dedicated `structured_output` profile:

**config.yaml:**
```yaml
llm_profiles:
  fast_agent:
    provider: GoogleGenAI
    model: models/gemini-2.0-flash
    temperature: 0.3

  structured_output:
    provider: OpenAI
    model: gpt-4o-mini
    temperature: 0.0  # Low temp for consistent extraction
```

**Programmatically:**
```python
from droidrun import load_llm

config = DroidrunConfig()

llms = {
    "fast_agent": load_llm("GoogleGenAI", "models/gemini-2.0-flash"),
    "structured_output": load_llm("OpenAI", "gpt-4o-mini"),
}

agent = DroidAgent(
    goal="Extract contact info for Alice",
    llms=llms,
    config=config,
    output_model=ContactInfo,
)
```

### Reasoning Mode

Works in both direct and reasoning modes:

```python
# Direct mode
config = DroidrunConfig()
config.agent.reasoning = False

agent = DroidAgent(
    goal="Find weather for SF",
    config=config,
    output_model=WeatherInfo,
)

# Reasoning mode
config.agent.reasoning = True

agent = DroidAgent(
    goal="Find weather for SF",
    config=config,
    output_model=WeatherInfo,
)
```

---

## Best Practices

**1. Add clear field descriptions** - The LLM uses these to understand what to extract:
```python
name: str = Field(description="Full name of customer who placed order")
```

**2. Provide defaults for optional fields** - Prevents extraction failures:
```python
rating: Optional[float] = Field(description="Customer rating (1-5)", default=None)
```

**3. Guide data collection in your goal**:
```python
agent = DroidAgent(
    goal="Find contact and get their phone number, email, and full name",
    config=config,
    output_model=ContactInfo,
)
```

---

## Troubleshooting

**Extraction returns None:**
- Verify `output_model` is passed to `DroidAgent`
- Check if task succeeded: `result.success`
- Enable debug logging: `config.logging.debug = True`

**Partial or incorrect data:**
- Add more specific field descriptions
- Mention required fields explicitly in the goal

**Validation errors:**
- Add `Optional` and defaults for uncertain fields

---

## Advanced

### Multiple Items

Extract lists of data using a model with `List` fields:

```python
class ContactList(BaseModel):
    """Multiple contacts."""
    contacts: List[ContactInfo] = Field(description="List of contacts")

agent = DroidAgent(
    goal="Find contacts for John Smith and Jane Doe",
    config=config,
    output_model=ContactList,
)
```

### Workflow Integration

Extraction happens automatically in `DroidAgent.finalize()`:

```python
@step
async def finalize(self, ctx: Context, ev: FinalizeEvent) -> ResultEvent:
    result = ResultEvent(
        success=ev.success,
        reason=ev.reason,
        steps=self.shared_state.step_number,
        structured_output=None,
    )

    # Extract if model was provided
    if self.output_model is not None and ev.reason:
        structured_agent = StructuredOutputAgent(
            llm=self.structured_output_llm,
            pydantic_model=self.output_model,
            answer_text=ev.reason,
        )
        extraction_result = await (await structured_agent.run())
        if extraction_result["success"]:
            result.structured_output = extraction_result["structured_output"]

    return result
```

---

## Related Documentation

- [DroidAgent API](/v5/sdk/droid-agent)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [Configuration Guide](/v5/sdk/configuration)
- [Custom Variables](/v5/features/custom-variables)

```

`docs/v5/features/telemetry.mdx`:

```mdx
---
title: 'Telemetry'
description: 'Configure anonymous telemetry'
---

# Why We Need Telemetry

Telemetry helps us:
- Identify which features are most used and need improvement
- Prioritize bug fixes and new features based on real usage
- Ensure Droidrun works well across different environments

<b>We do not collect any personal or sensitive data.</b> All telemetry is strictly anonymized and used only to improve the framework for everyone.

If you have questions or concerns, please reach out on [GitHub](https://github.com/droidrun/droidrun) or review our privacy policy.

---

# Toggling Telemetry

Droidrun collects <b>anonymized</b> usage data to help us understand which features are most valuable and where improvements are needed. This data is <b>never</b> used for advertising or tracking individuals, and is only used to make Droidrun better for the community.

## How to Disable Telemetry

You can disable telemetry at any time by setting the following environment variable:

```bash
export DROIDRUN_TELEMETRY_ENABLED=false
```

Add this line to your shell profile (e.g., `.bashrc`, `.zshrc`, or `.profile`) to make it persistent across sessions.

## How to Enable Telemetry Again

To re-enable telemetry, set the environment variable to `true`:

```bash
export DROIDRUN_TELEMETRY_ENABLED=true
```

<Note>
Telemetry is currently controlled only by the `DROIDRUN_TELEMETRY_ENABLED` environment variable. While a `telemetry.enabled` config option exists in the configuration schema, it is not currently used by the telemetry system.
</Note>

---

```

`docs/v5/features/tracing.mdx`:

```mdx
---
title: 'Tracing'
description: 'Configure Phoenix/Langfuse tracing and trajectory recording'
---

Droidrun provides multiple monitoring capabilities:

1. **LLM Tracing** - Real-time execution tracing via Arize Phoenix or Langfuse
2. **Trajectory Recording** - Local screenshots and UI state for debugging

## Quick Reference

```sh
# Enable Phoenix tracing
droidrun run "task" --tracing

# Enable trajectory recording
droidrun run "task" --save-trajectory step
```

---

## LLM Tracing

Droidrun supports two tracing providers for real-time monitoring of LLM calls, agent execution, and tool invocations:

- **Arize Phoenix** (default) - Open-source observability platform
- **Langfuse** - LLM engineering platform with cloud and self-hosted options

Use tracing to debug agent behavior, monitor token usage, and analyze execution flow.

---

### Arize Phoenix Tracing

#### Setup

**1. Install Phoenix:**

```sh
uv pip install arize-phoenix
```

**2. Start Phoenix server:**

```sh
phoenix serve
```

The server starts at `http://localhost:6006` and provides a web UI for viewing traces.

**3. Enable tracing in Droidrun:**

**Via CLI:**

```sh
droidrun run "Open settings" --tracing
```

**Via config.yaml:**

```yaml
tracing:
  enabled: true
```

**Via code:**

```python
from droidrun import DroidAgent, DroidrunConfig

config = DroidrunConfig()
config.tracing.enabled = True

agent = DroidAgent(goal="Open settings", config=config)
await agent.run()
```

**4. View traces:**

Navigate to `http://localhost:6006` to see:
- LLM calls with prompts, responses, and token counts
- Agent workflow execution (Manager, Executor, FastAgent)
- Tool invocations and their results
- Execution timings and errors

For more on using Phoenix, see the [Arize Phoenix documentation](https://docs.arize.com/phoenix).

#### Phoenix Configuration

Set environment variables to customize Phoenix:

```sh
# Custom Phoenix server URL (default: http://127.0.0.1:6006)
export phoenix_url=http://localhost:6006

# Project name for organizing traces
export phoenix_project_name=my_droidrun_project
```

<Note>
Environment variable names are lowercase: `phoenix_url` and `phoenix_project_name`.
</Note>

---

### Langfuse Tracing

Langfuse provides LLM observability with features like session tracking, user analytics, and cost monitoring.

#### Setup

**1. Get Langfuse credentials:**
- **Cloud**: Sign up at [cloud.langfuse.com](https://cloud.langfuse.com)
- **Self-hosted**: Deploy using [Langfuse docs](https://langfuse.com/docs/deployment/self-host)

**2. Configure Droidrun:**

**Via environment variables:**
```sh
export LANGFUSE_SECRET_KEY=sk-lf-...
export LANGFUSE_PUBLIC_KEY=pk-lf-...
export LANGFUSE_HOST=https://cloud.langfuse.com
```

**Via config.yaml:**
```yaml
tracing:
  enabled: true
  provider: langfuse
  langfuse_secret_key: sk-lf-...
  langfuse_public_key: pk-lf-...
  langfuse_host: https://cloud.langfuse.com
  langfuse_user_id: user@example.com  # Optional: track by user
  langfuse_session_id: ""              # Optional: custom session ID
```

**Via code:**
```python
from droidrun import DroidAgent, DroidrunConfig, TracingConfig

config = DroidrunConfig(
    tracing=TracingConfig(
        enabled=True,
        provider="langfuse",
        langfuse_secret_key="sk-lf-...",
        langfuse_public_key="pk-lf-...",
        langfuse_host="https://cloud.langfuse.com",
        langfuse_user_id="user@example.com",
    )
)

agent = DroidAgent(goal="Open settings", config=config)
await agent.run()
```

**3. View traces:**

Navigate to your Langfuse dashboard to see:
- LLM calls with prompts, completions, and token usage
- Agent execution traces and nested workflows
- Session-based analytics and cost tracking
- User-level metrics (if `langfuse_user_id` is set)

For more on using Langfuse, see the [Langfuse documentation](https://langfuse.com/docs).

---

## Trajectory Recording

Trajectory recording saves screenshots and UI state locally for offline debugging and analysis. Unlike telemetry (sent to PostHog) and tracing (sent to Phoenix or Langfuse), trajectories stay on your machine.

### Recording Levels

| Level | What's Saved | When to Use |
|-------|--------------|-------------|
| `none` (default) | Nothing | Production use, saves disk space |
| `step` | Screenshot + state per agent step | General debugging, recommended for most use cases |
| `action` | Screenshot + state per atomic action | Detailed debugging, captures every tap/swipe/type |

**Note:** `action` level generates significantly more files than `step` level.

### Enable Recording

**Via CLI:**

```sh
droidrun run "Open settings" --save-trajectory step
```

**Via config.yaml:**

```yaml
logging:
  save_trajectory: step  # none | step | action
```

**Via code:**

```python
from droidrun import DroidAgent, DroidrunConfig

config = DroidrunConfig()
config.logging.save_trajectory = "action"

agent = DroidAgent(goal="Open settings", config=config)
await agent.run()
```

### Output Location

Trajectories are saved to `trajectories/` in your working directory:

```
trajectories/
‚îî‚îÄ‚îÄ 2025-10-17_14-30-45_open_settings/
    ‚îú‚îÄ‚îÄ step_000_screenshot.png
    ‚îú‚îÄ‚îÄ step_000_state.json
    ‚îú‚îÄ‚îÄ step_001_screenshot.png
    ‚îî‚îÄ‚îÄ step_001_state.json
```

Each trajectory folder contains:
- **Screenshots** - PNG images of the device screen at each step/action
- **State files** - JSON files with:
  - UI accessibility tree (element hierarchy with IDs, text, bounds)
  - Action executed (e.g., `click(5)`, `type("hello", 3)`)
  - Agent reasoning and step number
  - Device state (current app package, activity)

Use these files to:
- Debug why the agent made specific decisions
- Replay failed executions
- Analyze UI element detection issues
- Build training datasets for agent improvement

---

## Related Documentation

- [Configuration System](/v5/sdk/configuration) - Configure tracing and telemetry settings
- [Events and Workflows](/v5/concepts/events-and-workflows) - Build custom monitoring integrations
- [CLI Usage](/v5/guides/cli) - Command-line flags for monitoring

```

`docs/v5/guides/cli.mdx`:

```mdx
---
title: 'CLI Usage'
description: 'Command-line interface for controlling devices with natural language'
---

## Overview

The Droidrun CLI lets you control Android and iOS devices using natural language commands powered by LLM agents.

### Quick Start

```bash
# Setup device
droidrun setup

# Run a command (shorthand - no "run" needed)
droidrun "Open Spotify and play my Discover Weekly"

# Or explicit
droidrun run "Turn on Do Not Disturb"
```

<Note>
**Auto-configuration**: If `config.yaml` doesn't exist, Droidrun creates it from `config_example.yaml` automatically.

**Command shorthand**: `droidrun "task"` is equivalent to `droidrun run "task"`
</Note>

---

## Commands

<Tabs>
  <Tab title="run">

Execute natural language commands on your device.

### Usage

```bash
droidrun run "<command>" [OPTIONS]

# Shorthand (omit "run")
droidrun "<command>" [OPTIONS]
```

### Common Flags

| Flag | Description | Default |
|------|-------------|---------|
| `--provider`, `-p` | LLM provider (GoogleGenAI, OpenAI, Anthropic, etc.) | From config |
| `--model`, `-m` | Model name | From config |
| `--device`, `-d` | Device serial or IP | Auto-detect |
| `--steps` | Max execution steps | `15` |
| `--reasoning` | Enable planning mode | `false` |
| `--vision` | Enable vision for all agents | From config |
| `--tcp` | Use TCP instead of content provider | `false` |
| `--debug` | Verbose logging | `false` |
| `--save-trajectory` | Save execution (`none`, `step`, `action`) | `none` |
| `--config`, `-c` | Custom config path | `config.yaml` |

### Examples

<Tabs>
  <Tab title="Basic">
```bash
# Simple command
droidrun "Open Settings"

# Multi-step task
droidrun "Send WhatsApp to John: I'll be late"

# Specific device
droidrun "Check battery" --device emulator-5554
```
  </Tab>

  <Tab title="LLM Providers">
```bash
# Google Gemini
export GOOGLE_API_KEY=your-key
droidrun "Archive old emails" \
  --provider GoogleGenAI \
  --model models/gemini-2.5-flash

# OpenAI
export OPENAI_API_KEY=your-key
droidrun "Create shopping list" \
  --provider OpenAI \
  --model gpt-4o

# Anthropic Claude
export ANTHROPIC_API_KEY=your-key
droidrun "Reply to latest email" \
  --provider Anthropic \
  --model claude-sonnet-4-5-latest

# Local Ollama (free)
droidrun "Turn on dark mode" \
  --provider Ollama \
  --model llama3.3:70b \
  --base_url http://localhost:11434
```
  </Tab>

  <Tab title="Advanced">
```bash
# Complex task with planning
droidrun "Organize inbox by sender" \
  --reasoning \
  --vision \
  --steps 30

# Debug failing command
droidrun "Book Uber to airport" \
  --debug \
  --save-trajectory action

# Wireless execution
droidrun "Clear cache" \
  --device 192.168.1.100:5555 \
  --tcp

# Custom config
droidrun "Enable 2FA" \
  --config /path/to/config.yaml
```
  </Tab>
</Tabs>

### Provider Options

| Provider | Install | Environment Variable |
|----------|---------|---------------------|
| GoogleGenAI | Included by default | `GOOGLE_API_KEY` |
| OpenAI | Included by default | `OPENAI_API_KEY` |
| OpenAILike | Included by default | Varies by provider |
| OpenRouter | Included by default | `OPENROUTER_API_KEY` |
| Ollama | Included by default | None (local) |
| Anthropic | `uv pip install 'droidrun[anthropic]'` | `ANTHROPIC_API_KEY` |
| DeepSeek | `uv pip install 'droidrun[deepseek]'` | `DEEPSEEK_API_KEY` |

  </Tab>

  <Tab title="Device Management">

### `droidrun devices`

List connected devices.

```bash
droidrun devices
# Output:
# Found 2 connected device(s):
#   ‚Ä¢ emulator-5554
#   ‚Ä¢ 192.168.1.100:5555
```

---

### `droidrun setup`

Install Portal APK on device.

```bash
# Auto-detect device
droidrun setup

# Specific device
droidrun setup --device emulator-5554

# Custom APK
droidrun setup --path /path/to/portal.apk
```

**What it does:**
1. Downloads latest Portal APK
2. Installs with all permissions
3. Auto-enables accessibility service
4. Opens settings if manual enable needed

---

### `droidrun ping`

Test Portal connection.

```bash
# Test default communication
droidrun ping

# Test TCP mode
droidrun ping --tcp

# Specific device
droidrun ping --device 192.168.1.100:5555
```

**Success output:** `Portal is installed and accessible. You're good to go!`

---

### `droidrun connect`

Connect to device via TCP/IP.

```bash
droidrun connect 192.168.1.100:5555
```

**Prerequisites:**
```bash
# Enable wireless debugging (Android 11+)
# Settings > Developer options > Wireless debugging

# Or via USB:
adb tcpip 5555
adb shell ip route | awk '{print $9}'  # Get IP
droidrun connect <IP>:5555
```

---

### `droidrun disconnect`

Disconnect from device.

```bash
droidrun disconnect 192.168.1.100:5555
```

  </Tab>

  <Tab title="Macros">

Record and replay automation sequences.

### `droidrun macro list`

List saved trajectories.

```bash
# Default directory
droidrun macro list

# Custom directory
droidrun macro list /path/to/trajectories
```

**Output:**
```
Found 3 trajectory(s):

‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ Folder           ‚îÉ Description               ‚îÉ Actions ‚îÉ
‚î°‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î©
‚îÇ open-settings    ‚îÇ Opens settings app        ‚îÇ 3       ‚îÇ
‚îÇ enable-dark-mode ‚îÇ Navigate to display...    ‚îÇ 8       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### `droidrun macro replay`

Replay recorded macro.

```bash
# Basic replay
droidrun macro replay trajectories/open-settings

# Custom device and timing
droidrun macro replay trajectories/login-flow \
  --device emulator-5554 \
  --delay 0.5

# Start from specific step
droidrun macro replay trajectories/checkout \
  --start-from 5 \
  --max-steps 10

# Preview without executing
droidrun macro replay trajectories/test --dry-run
```

**Flags:**

| Flag | Description | Default |
|------|-------------|---------|
| `--device`, `-d` | Device serial | Auto-detect |
| `--delay`, `-t` | Seconds between actions | `1.0` |
| `--start-from`, `-s` | Start step (1-based) | `1` |
| `--max-steps`, `-m` | Max steps to run | All |
| `--dry-run` | Preview only | `false` |

---

### Recording Trajectories

```bash
# Record at action level (most detailed)
droidrun "Create alarm for 7am" --save-trajectory action

# Record at step level
droidrun "Export contacts" --save-trajectory step
```

**Trajectory structure:**
```
trajectories/2025-10-16_14-30-45/
‚îú‚îÄ‚îÄ macro.json       # Action sequence
‚îú‚îÄ‚îÄ step_0.png       # Screenshots
‚îú‚îÄ‚îÄ step_1.png
‚îî‚îÄ‚îÄ ...
```

  </Tab>
</Tabs>

---

## Configuration

### Override Priority

1. **CLI flags** (highest)
2. **Config file** (`config.yaml`)
3. **Defaults** (lowest)

### Common Patterns

<CodeGroup>

```bash Quick Test
droidrun "Turn on dark mode" \
  --provider GoogleGenAI \
  --model models/gemini-2.5-flash
```

```bash Debug Task
droidrun "Book ride to airport" \
  --debug \
  --reasoning \
  --vision \
  --save-trajectory action
```

```bash Cost Optimization
droidrun "Set alarm" \
  --provider GoogleGenAI \
  --model models/gemini-2.5-flash \
  --no-vision
```

```bash Multiple Devices
for device in $(adb devices | awk 'NR>1 {print $1}'); do
  droidrun "Clear notifications" --device $device
done
```

</CodeGroup>

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="No devices found">
```bash
# Check ADB
adb devices

# If unauthorized: Accept prompt on device
# If not listed: Try different USB port/cable
# Restart ADB
adb kill-server && adb start-server
```
  </Accordion>

  <Accordion title="Portal not accessible">
```bash
# Verify installation
adb shell pm list packages | grep droidrun

# Reinstall
droidrun setup

# Enable accessibility manually
adb shell settings put secure enabled_accessibility_services \
  com.droidrun.portal/.DroidrunAccessibilityService
```
  </Accordion>

  <Accordion title="LLM provider errors">
```bash
# Install provider
uv pip install 'droidrun[anthropic]'

# Check API key
echo $GOOGLE_API_KEY

# Set if missing
export GOOGLE_API_KEY=your-key
```
  </Accordion>

  <Accordion title="Command times out">
```bash
# Increase steps
droidrun "Complex task" --steps 50

# Enable debug mode
droidrun "Task" --debug

# Try reasoning mode
droidrun "Multi-step task" --reasoning
```
  </Accordion>

  <Accordion title="TCP connection fails">
```bash
# Enable TCP mode (USB connected first)
adb tcpip 5555

# Get device IP
adb shell ip route | awk '{print $9}'

# Connect
droidrun connect <IP>:5555

# Verify
droidrun ping --tcp
```
  </Accordion>
</AccordionGroup>

---

## Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `GOOGLE_API_KEY` | Google Gemini API key | None |
| `OPENAI_API_KEY` | OpenAI API key | None |
| `ANTHROPIC_API_KEY` | Anthropic API key | None |
| `DEEPSEEK_API_KEY` | DeepSeek API key | None |
| `DROIDRUN_CONFIG` | Config file path | `config.yaml` |

**Setting variables:**

<CodeGroup>

```bash Linux/macOS
export GOOGLE_API_KEY=your-key
```

```bash Windows PowerShell
$env:GOOGLE_API_KEY="your-key"
```

```bash Permanent (Linux/macOS)
echo 'export GOOGLE_API_KEY=your-key' >> ~/.bashrc
source ~/.bashrc
```

</CodeGroup>

---

## Next Steps

- [Configuration Guide](/v5/sdk/configuration) - Customize behavior
- [Device Setup](/v5/guides/device-setup) - Detailed setup instructions
- [Agent Architecture](/v5/concepts/architecture) - How it works
- [Custom Tools](/v5/features/custom-tools) - Extend functionality

```

`docs/v5/guides/device-setup.mdx`:

```mdx
---
title: 'Device Setup'
description: 'Setting up Android and iOS devices for Droidrun automation'
---

## Overview

Droidrun controls devices through a specialized Portal app that bridges your computer and the device.

<Tabs>
  <Tab title="Android Setup">

## Prerequisites

<Steps>
  <Step title="Install ADB">
    **macOS**: `brew install android-platform-tools`

    **Linux**: `sudo apt install adb`

    **Windows**: Download from [Android Developer Site](https://developer.android.com/studio/releases/platform-tools)

    Verify: `adb version`
  </Step>

  <Step title="Enable USB Debugging">
    1. Go to **Settings** > **About phone**
    2. Tap **Build number** 7 times (enables Developer options)
    3. Go to **Settings** > **Developer options**
    4. Enable **USB debugging**
    5. Connect device and tap **Always allow**

    Verify: `adb devices`
  </Step>

  <Step title="Install Portal App">
    ```bash
    # Automatic setup (downloads latest Portal APK)
    droidrun setup

    # Or specify device
    droidrun setup --device SERIAL_NUMBER
    ```

    This will:
    - Download the latest Portal APK
    - Install with all permissions granted
    - Enable accessibility service automatically
  </Step>

  <Step title="Verify Setup">
    ```bash
    droidrun ping
    # Output: Portal is installed and accessible. You're good to go!
    ```
  </Step>
</Steps>

---

## Portal App

The Droidrun Portal (`com.droidrun.portal`) provides:

- **Accessibility Tree** - Extracts UI elements and their properties
- **Device State** - Tracks current activity, keyboard visibility
- **Action Execution** - Tap, swipe, text input, and other actions
- **Dual Communication** - TCP (faster) or Content Provider (fallback)

<Note>
The Portal only communicates locally via ADB. No data is sent to external servers.
</Note>

---

## Communication Modes

<AccordionGroup>
  <Accordion title="TCP Mode (Recommended) - per operation">
    **How it works:**
    - Portal runs HTTP server on device port 8080
    - ADB forwards local port ‚Üí device port 8080
    - Droidrun sends HTTP requests to `localhost:PORT`

    **Enable:**
    ```bash
    # CLI
    droidrun run "your command" --tcp

    # Python
    config = DroidrunConfig(device=DeviceConfig(serial="DEVICE_SERIAL", use_tcp=True))
    ```

    **Troubleshooting:**
    ```bash
    # Check port forwarding
    adb forward --list

    # Test Portal server
    adb shell netstat -an | grep 8080

    # Remove all forwards and retry
    adb forward --remove-all
    droidrun ping --tcp
    ```
  </Accordion>

  <Accordion title="Content Provider (Fallback) - per operation">
    **How it works:**
    - Portal exposes content provider at `content://com.droidrun.portal/`
    - Commands sent via ADB shell: `content query --uri ...`
    - JSON responses parsed from shell output

    **Usage:**
    ```bash
    # Default mode (no flag needed)
    droidrun ping

    # Python
    config = DroidrunConfig(device=DeviceConfig(serial="DEVICE_SERIAL", use_tcp=False))
    ```

    **Troubleshooting:**
    ```bash
    # Test content provider directly
    adb shell content query --uri content://com.droidrun.portal/state

    # Should show: Row: 0 result={"data": "{...}"}
    ```
  </Accordion>
</AccordionGroup>

---

## Advanced Setup

<AccordionGroup>
  <Accordion title="Wireless Debugging (Android 11+)">
    ### Setup

    <Steps>
      <Step title="Enable Wireless Debugging">
        1. **Settings** > **Developer options** > **Wireless debugging**
        2. Note IP address and port (e.g., `192.168.1.100:37757`)
      </Step>

      <Step title="Pair Device (First Time)">
        **QR Code Method:**
        ```bash
        adb pair <QR_CODE_STRING>
        ```

        **Pairing Code Method:**
        1. Tap **Pair device with pairing code**
        2. Note pairing code and IP:port
        3. Run: `adb pair IP:PORT`
        4. Enter pairing code
      </Step>

      <Step title="Connect">
        ```bash
        adb connect IP:PORT
        droidrun ping --device IP:PORT
        ```
      </Step>
    </Steps>

    ### Common Issues

    - Connection refused ‚Üí Check same WiFi network and firewall
    - Frequent drops ‚Üí Use 5GHz WiFi or stay near router
    - Can't find IP ‚Üí Run `adb shell ip addr show wlan0 | grep "inet "` via USB
  </Accordion>

  <Accordion title="Wireless Debugging (Android 10 and Below)">
    <Steps>
      <Step title="Enable TCP/IP Mode (USB Required)">
        ```bash
        # Connect via USB first
        adb tcpip 5555
        ```
      </Step>

      <Step title="Find Device IP">
        ```bash
        adb shell ip addr show wlan0 | grep inet
        ```
      </Step>

      <Step title="Connect Wirelessly">
        ```bash
        # Disconnect USB cable
        adb connect DEVICE_IP:5555
        droidrun ping --device DEVICE_IP:5555
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Multiple Devices">
    ### List Devices

    ```bash
    droidrun devices
    # Found 2 connected device(s):
    #   ‚Ä¢ emulator-5554
    #   ‚Ä¢ 192.168.1.100:5555
    ```

    ### Target Specific Device

    ```bash
    # CLI
    droidrun run "your command" --device emulator-5554

    # Python
    config = DroidrunConfig(device=DeviceConfig(serial="emulator-5554"))
    agent = DroidAgent(goal="your task", config=config)
    ```

    ### Parallel Control

    ```python
    import asyncio
    from droidrun import DeviceConfig, DroidrunConfig, DroidAgent
    from adbutils import adb

    async def control_device(serial: str, command: str):
        device_config = DeviceConfig(serial=serial)
        config = DroidrunConfig(device=device_config)
        agent = DroidAgent(goal=command, config=config)
        return await agent.run()

    async def main():
        devices = adb.list()

        tasks = [
            control_device(devices[0].serial, "Open settings"),
            control_device(devices[1].serial, "Check battery"),
        ]

        results = await asyncio.gather(*tasks)
        print(results)

    asyncio.run(main())
    ```
  </Accordion>
</AccordionGroup>

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="Device not found">
    **Symptoms:** `adb devices` shows no devices or `unauthorized`

    **Solutions:**
    1. Unplug/replug USB cable, try different port
    2. Revoke USB debugging authorizations (Developer options)
    3. Reconnect and tap "Always allow"
    4. Restart ADB: `adb kill-server && adb start-server`
    5. **Windows**: Install [Google USB Driver](https://developer.android.com/studio/run/win-usb)
  </Accordion>

  <Accordion title="Portal not installed">
    **Symptoms:** `droidrun ping` fails with "Portal is not installed"

    **Solutions:**
    1. Reinstall: `droidrun setup`
    2. Check: `adb shell pm list packages | grep droidrun`
    3. Verify APK architecture matches device (arm64-v8a for most devices)
  </Accordion>

  <Accordion title="Accessibility service not enabled">
    **Symptoms:** `droidrun ping` fails with "accessibility service not enabled"

    **Solutions:**
    1. Auto-enable:
       ```bash
       adb shell settings put secure enabled_accessibility_services \
         com.droidrun.portal/com.droidrun.portal.DroidrunAccessibilityService
       adb shell settings put secure accessibility_enabled 1
       ```
    2. Manual: Settings > Accessibility > Droidrun Portal > Toggle ON
    3. Verify:
       ```bash
       adb shell settings get secure enabled_accessibility_services
       # Should contain: com.droidrun.portal/...
       ```
  </Accordion>

  <Accordion title="Text input not working">
    **Symptoms:** `input_text()` fails or types gibberish

    **Solutions:**
    1. Keyboard auto-enabled by `AndroidDriver` initialization:
       ```bash
       # Verify
       adb shell settings get secure default_input_method
       # Should show: com.droidrun.portal/.DroidrunKeyboardIME
       ```
    2. Manual switch: Long press space bar ‚Üí Select "Droidrun Keyboard"
    3. Focus the element first (tap it), then input text
  </Accordion>

  <Accordion title="Empty UI state">
    **Symptoms:** `get_state()` returns empty or incomplete UI tree

    **Solutions:**
    1. Verify accessibility: `droidrun ping`
    2. Some apps block accessibility services (WebViews, games, custom UI)
    3. Wait for UI: `time.sleep(1)` after tap/swipe
    4. Enable Portal overlay to see detected elements
  </Accordion>
</AccordionGroup>

  </Tab>

  <Tab title="iOS Setup (experimental)">

<Warning>
iOS support is currently **experimental**. Functionality is limited compared to Android.
</Warning>

---

## Prerequisites

- **macOS** with Xcode installed
- **iOS device** with Developer mode enabled
- **iOS Portal app** (separate from Android Portal)

---

## Setup

<Steps>
  <Step title="Install iOS Portal">
    The iOS Portal app must be manually installed on your device.

    <Note>
    Installation instructions and download link coming soon.
    </Note>
  </Step>

  <Step title="Get Device IP">
    Find your iOS device's IP address in Settings > WiFi > (i) icon
  </Step>

  <Step title="Test Connection">
    ```bash
    droidrun ping --ios
    ```
  </Step>
</Steps>

---

## Architecture

iOS Portal uses a different architecture than Android:

| Feature | Android | iOS |
|---------|---------|-----|
| Communication | ADB + TCP/Content Provider | HTTP server only |
| Setup Tool | `droidrun setup` | Manual installation |
| Accessibility | Android Accessibility API | iOS Accessibility API |
| Text Input | Custom keyboard IME | Direct text input |

---

## Usage

### Python API

```python
from droidrun import DroidAgent, DroidrunConfig, DeviceConfig

# Configure for iOS
config = DroidrunConfig(
    device=DeviceConfig(platform="ios")
)

# Create agent
agent = DroidAgent(
    goal="Open Settings and check WiFi",
    config=config
)

result = await agent.run()
```

### CLI

```bash
# Use --ios flag
droidrun run "your command" --ios

# Or set platform in config.yaml:
# device:
#   platform: ios
```

---

## Limitations

Current iOS support has these limitations:

| Feature | Status | Notes |
|---------|--------|-------|
| `get_date()` | ‚ùå | Not available on iOS |
| `back()` | ‚ùå | Raises `NotImplementedError` |
| `drag()` | ‚ùå | Not implemented, returns False |
| `get_apps()` | ‚ö†Ô∏è | Use `list_packages()` instead |
| `input_text()` | ‚ö†Ô∏è | No `index` or `clear` parameters |
| `tap()`, `swipe()` | ‚úÖ | Fully supported |
| `get_state()` | ‚úÖ | Returns accessibility tree |
| `take_screenshot()` | ‚úÖ | Fully supported |

  </Tab>
</Tabs>

---

## Next Steps

- Learn about the [Agent System](/v5/concepts/architecture)
- Explore [Configuration Options](/v5/sdk/configuration)
- Try [Custom Tools](/v5/features/custom-tools)
- Implement [Structured Output](/v5/features/structured-output)

```

`docs/v5/guides/docker.mdx`:

```mdx
---
title: 'Quickstart with Docker'
description: 'Get up and running with Droidrun in Docker quickly and effectively'
---

This guide will help you get Droidrun running in a Docker container, controlling your Android device through natural language without installing it natively.

### Host configuration

Follow the steps below to ensure your host system is properly configured to mount the smartphone inside the container.

1. Make sure you‚Äôve completed the prerequisite steps in the [Quickstart](/v5/quickstart). Then verify the ADB connection with `adb devices`. This should list your phone as ‚Äúdevice‚Äù along with its Serial Number. If the phone appears as `unauthorized` make sure to accept the prompt on your phone.

2. Confirm that the ADB keys have been correctly created. Check for an `.android` folder under your `$HOME` directory that contains: `adb.5037`, `adbkey`, and `adbkey.pub`.

3. Set up a custom rule to uniquely identify your phone and map it to a static path:
   - Open a terminal and find your device‚Äôs `idVendor` and `idProduct` using the `lsusb` command.

      In the example below, the `idVendor` and `idProduct` are `18d1` and `4ee2`, respectively.

      ```bash
      > lsusb
      Bus 003 Device 002: ID 18d1:4ee2 Google Inc. Nexus/Pixel Device (MTP + debug)
      ```

   - Create a new file (sudo may be required) under `/etc/udev/rules.d` and name it `51-android.rules`.

   - Add the following content and save the file:

      ```bash
      SUBSYSTEM=="usb", ATTR{idVendor}=="XXXX", ATTR{idProduct}=="YYYY", ATTR{serial}=="SSSS", MODE="0666", GROUP="plugdev", SYMLINK+="phone1/phone"
      ```

      where `XXXX`, `YYYY`, and `SSSS` are the vendor ID, product ID, and serial number of your phone.

      This static mapping is required because otherwise the phone‚Äôs mount path will change across reconnections!

   - Reload the rules

      ```bash
      sudo udevadm control --reload-rules
      sudo udevadm trigger
      ```

4. Kill the ADB server on the host so that the container can actually detect the phone:

   ```bash
   adb kill-server
   ```

### Usage

Pull the image from the GitHub Container Registry:

```bash
docker pull ghcr.io/droidrun/droidrun:latest
```

Before running the container, note that the following options are always required when launching Droidrun in Docker:

| Docker option | What it does | Why it matters for Droidrun |
|---------------|--------------|-----------------------------|
| `--group-add plugdev` | Adds the host user to the container‚Äôs `plugdev` group. | Gives the container permission to access USB devices (e.g., your Android phone) without requiring root. |
| `--device /dev/phone1/phone:/dev/phone` | Maps a specific USB device file from the host into the container. Thanks to our udev rule, the phone will always be mapped here. | Allows Droidrun to see the phone as `/dev/phone` inside the container, so it can communicate with the device. |
| `--volume /dev/bus/usb:/dev/bus/usb` | Mounts the entire USB bus directory. | Provides access to all connected USB devices, enabling Droidrun to discover and interact with the phone. |
| `--volume ~/.android:/home/droidrun/.android` | Mounts the host‚Äôs Android configuration directory into the container. | Stores ADB keys and settings so that once you grant permission on the host, Droidrun doesn‚Äôt prompt for it again inside the container. |

The Docker image uses the `droidrun` entrypoint, which means you can use any of the CLI commands described in the [CLI Usage](/v5/guides/cli) section and append it to the following base command:

```bash
docker run \
  --group-add plugdev \
  --device /dev/phone1/phone:/dev/phone \
  --volume /dev/bus/usb:/dev/bus/usb \
  --volume ~/.android:/home/droidrun/.android \
  ghcr.io/droidrun/droidrun:latest \
  <droidrun command>
```

#### Set Up the Portal APK

Simply run the container with the `setup` CLI command.

```bash
docker run \
  --group-add plugdev \
  --device /dev/phone1/phone:/dev/phone \
  --volume /dev/bus/usb:/dev/bus/usb \
  --volume ~/.android:/home/droidrun/.android \
  ghcr.io/droidrun/droidrun:latest \
  setup
```

#### Verify the setup

Simply run the container with the `ping` CLI command.

```bash
docker run \
  --group-add plugdev \
  --device /dev/phone1/phone:/dev/phone \
  --volume /dev/bus/usb:/dev/bus/usb \
  --volume ~/.android:/home/droidrun/.android \
  ghcr.io/droidrun/droidrun:latest \
  ping
```

#### Run some agents

Now you‚Äôre ready to control your device using Docker and natural language:

```bash
# Using default configuration with Google API key
docker run --group-add plugdev --device /dev/phone1/phone:/dev/phone --volume /dev/bus/usb:/dev/bus/usb --volume ~/.android:/home/droidrun/.android --env GOOGLE_API_KEY=your-api-key-here ghcr.io/droidrun/droidrun:latest run "Open the settings app and tell me the Android version"

# Override provider and model
docker run --group-add plugdev --device /dev/phone1/phone:/dev/phone --volume /dev/bus/usb:/dev/bus/usb --volume ~/.android:/home/droidrun/.android --env OPENAI_API_KEY=your-api-key-here ghcr.io/droidrun/droidrun:latest run "Open a browser and search for droidrun" -p OpenAI -m gpt-4o

# Use a locally-running LLM, example for LM Studio running in the LAN
docker run --group-add plugdev --device /dev/phone1/phone:/dev/phone --volume /dev/bus/usb:/dev/bus/usb --volume ~/.android:/home/droidrun/.android --network host ghcr.io/droidrun/droidrun:latest run "Open a browser and search for droidrun" -p OpenAILike -m gpt-oss --api_base http://IP-of-LMStudio-server:PORT/v1
```

#### Troubleshooting

* Error response from daemon

   If you encounter the following error:

   ```
   docker: Error response from daemon: error gathering device information while adding custom '/dev/phone1/phone': no such file or directory
   ```

   it usually indicates one of two things:
   - The phone isn‚Äôt mounted at the expected custom path. Verify that `/dev/phone1/phone` exists.
   - An ADB server is still running on the host. Stop it with `adb kill-server`.

---

## Next Steps

- [CLI Usage](/v5/guides/cli) - Dive into the various parameters and start building your own projects with Docker!

```

`docs/v5/guides/overview.mdx`:

```mdx
---
title: Overview
---

Welcome to the Droidrun Guides! This section provides step-by-step instructions and best practices for using Droidrun. Each guide focuses on a specific aspect of the framework, from device setup to advanced automation patterns.

---

## Available Guides

### Getting Started

**[CLI Reference](./cli)** - Complete command-line interface guide
- All CLI commands (`run`, `setup`, `devices`, `connect`, `ping`, `macro`)
- Configuration overrides and flags
- Environment variables and API keys
- Common workflows and troubleshooting

**[Device Setup](./device-setup)** - Set up Android and iOS devices
- Portal app installation and configuration
- Accessibility service enablement
- TCP vs Content Provider communication
- Wireless debugging and multi-device management

**[Configuration System](/v5/sdk/configuration)** - Master the config-driven architecture
- YAML configuration structure
- LLM profiles per agent (Manager, Executor, FastAgent, Scripter)
- Mixing LLM providers (OpenAI, Anthropic, Google, Ollama, DeepSeek)
- Safe execution, prompts, and app cards

---

### Templates

Explore real-world examples and starter projects in the [droidrun-examples repository](https://github.com/droidrun/droidrun-examples):

- **[LinkedInJobsScraper](https://github.com/droidrun/droidrun-examples/tree/main/LinkedInJobsScraper)** - Agentic workflow that searches LinkedIn for roles, evaluates matches, and prepares tailored applications
- **[LinkedInLeads](https://github.com/droidrun/droidrun-examples/tree/main/LinkedInLeads)** - End-to-end lead discovery and enrichment for LinkedIn companies and roles
- **[TwitterPost](https://github.com/droidrun/droidrun-examples/tree/main/TwitterPost)** - Finds trending topics, drafts posts, and generates images to publish on X/Twitter
- **[play2048](https://github.com/droidrun/droidrun-examples/tree/main/play2048)** - DroidAgent that plays the 2048 game on play2048.co

Each example includes a self-contained workflow with entrypoint, configuration, and sample data. See the [README](https://github.com/droidrun/droidrun-examples) for setup instructions and contribution guidelines.


---

Need help? Join our [Discord community](https://discord.gg/ZZbKEZZkwK) for support and discussions.

```

`docs/v5/overview.mdx`:

```mdx
---
title: 'Overview'
description: 'Droidrun is a powerful framework that enables you to control Android and iOS devices through intelligent LLM agents. Build sophisticated mobile automation workflows with natural language commands.'
---

<CardGroup cols={2}>
  <Card title="Quickstart" icon="rocket" href="/v5/quickstart">
    Get up and running with Droidrun in minutes
  </Card>
  <Card title="Guides" icon="code" href="/v5/guides/overview">
   View Templates for example Use Cases
  </Card>
  <Card title="Agent Architecture" icon="bot" href="/v5/concepts/architecture">
    Understand the hierarchical agent system
  </Card>
  <Card title="SDK Reference" icon="book" href="/v5/sdk/reference">
    Explore the complete API documentation
  </Card>
</CardGroup>

## Core Features

Learn about the powerful features that make Droidrun a comprehensive mobile automation framework. These capabilities enable you to build sophisticated, production-ready automation workflows.

<CardGroup cols={2}>
  <Card title="Structured Output" icon="table" href="/v5/features/structured-output">
    Extract typed data with Pydantic
  </Card>
  <Card title="Credential Management" icon="shield-check" href="/v5/features/credentials">
    Store and manage API keys securely
  </Card>
  <Card title="App Cards" icon="id-card" href="/v5/features/app-cards">
    Provide app-specific guidance
  </Card>
  <Card title="Custom Tools" icon="wrench" href="/v5/features/custom-tools">
    Extend capabilities with custom functions
  </Card>
</CardGroup>


## Runtime

Choose your preferred environment for running Droidrun automations, from local physical devices to cloud-based solutions.

<CardGroup cols={2}>
<Card icon="smartphone" title="Physical Device" href="/v5/guides/device-setup" arrow>
 - Connect your own physical Android device for direct automation
</Card>
<Card icon="cloud" title="Cloud Environment" href="https://cloud.droidrun.ai">
 - Access our managed cloud environment for instant mobile app automation without any setup.
</Card>
</CardGroup>
```

`docs/v5/quickstart.mdx`:

```mdx
---
title: 'Quickstart'
description: 'Get up and running with Droidrun quickly and effectively'
---

<iframe
  className="w-full aspect-video rounded-xl"
  src="https://www.youtube.com/embed/4WT7FXJah2I"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
></iframe>

This guide will help you get Droidrun installed and running quickly, controlling your Android device through natural language in minutes.

### Prerequisites

Before installing Droidrun, ensure you have:

1. **Python 3.11+** installed on your system (Python 3.14 is not currently supported)
2. [Android Debug Bridge (adb)](https://developer.android.com/studio/releases/platform-tools) installed and configured
3. **Android device** with:
   - [Developer options enabled](https://developer.android.com/studio/debug/dev-options)
   - USB debugging enabled
   - Connected via USB or on the same network (for wireless debugging)

### Installation

Droidrun is installed using [`uv`](https://docs.astral.sh/uv/), a fast Python package installer and resolver.

**Install uv (if not already installed):**

```bash
# macOS/Linux
curl -LsSf https://astral.sh/uv/install.sh | sh

# Windows (PowerShell)
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"
```

**Choose your installation method:**

**For CLI usage only:**
```bash
uv tool install droidrun
```

**For CLI + Python code integration:**
```bash
uv pip install droidrun
```

<Note>
Most LLM providers (Google Gemini, OpenAI, Ollama, OpenRouter) are included by default. For additional providers, install extras: `uv tool install 'droidrun[anthropic,deepseek]'`.
</Note>

### Set Up the Portal APK

Droidrun requires the Portal app to be installed on your Android device for device control. The Portal app provides accessibility services that expose the UI accessibility tree, enabling the agent to see and interact with UI elements.

```bash
droidrun setup
```

This command automatically:
1. Downloads the latest Portal APK
2. Installs it on your connected device
3. Enables the accessibility service

### Test Connection

Verify that Droidrun can communicate with your device:

```bash
droidrun ping
```

If successful, you'll see:
```
‚úì Portal is running
‚úì Accessibility service enabled
‚úì Device ready
```

### Configure Your LLM

Droidrun uses a configuration-driven approach. On first run, Droidrun creates a `config.yaml` file with default settings. You'll need to set your API key for your chosen LLM provider.

**Set your API key:**

```bash
# For Google Gemini (default)
export GOOGLE_API_KEY=your-api-key-here

# For OpenAI
export OPENAI_API_KEY=your-api-key-here

# For Anthropic Claude
export ANTHROPIC_API_KEY=your-api-key-here

# For DeepSeek
export DEEPSEEK_API_KEY=your-api-key-here
```

### Run Your First Command via CLI

Now you're ready to control your device with natural language:

```bash
# Using default configuration (Google Gemini)
droidrun run "Open the settings app and tell me the Android version"

# Override provider and model
droidrun run "Check the battery level" --provider OpenAI --model gpt-4o

# Enable vision mode (sends screenshots to LLM)
droidrun run "What app is currently open?" --vision

# Enable reasoning mode (uses Manager-Executor workflow for complex tasks)
droidrun run "Find a contact named John and send him an email" --reasoning
```

**Common CLI flags:**
- `--provider` - LLM provider (GoogleGenAI, OpenAI, Anthropic, etc.)
- `--model` - Model name (models/gemini-2.5-pro, gpt-4o, etc.)
- `--vision` - Enable screenshot processing
- `--reasoning` - Enable multi-agent planning mode
- `--steps N` - Maximum execution steps (default: 15)
- `--debug` - Enable detailed logging

### Create a Simple Agent via Script

For complex automation or integration into your Python projects, create a script:

```python
import asyncio
from droidrun import DroidAgent, DroidrunConfig

async def main():
    # Use default configuration with built-in LLM profiles
    config = DroidrunConfig()

    # Create agent
    # LLMs are automatically loaded from config.llm_profiles
    agent = DroidAgent(
        goal="Open Settings and check battery level",
        config=config,
    )

    # Run agent
    result = await agent.run()

    # Check results (result is a ResultEvent object)
    print(f"Success: {result.success}")
    print(f"Reason: {result.reason}")
    print(f"Steps: {result.steps}")

if __name__ == "__main__":
    asyncio.run(main())
```

## Next Steps

Now that you've got Droidrun running, explore these topics:

- Walk through a [Guide](/v5/guides/overview)
- Learn about [Agent Architecture](/v5/concepts/architecture)
- Customize the Agent [Configuration System](/v5/sdk/configuration)
- Guide the agent with [App Cards](/v5/features/app-cards)


---
```

`docs/v5/sdk/adb-tools.mdx`:

```mdx
---
title: AndroidDriver
---

Raw Android device I/O via ADB + Portal.

<a id="droidrun.tools.driver.android.AndroidDriver"></a>

## AndroidDriver

```python
class AndroidDriver(DeviceDriver)
```

Raw Android device I/O via ADB and the Droidrun Portal app.

AndroidDriver provides low-level device communication for Android devices through ADB (Android Debug Bridge). It supports both TCP communication and content provider modes via the Droidrun Portal app. AndroidDriver declares its capabilities in the `supported` set, and unsupported methods raise `NotImplementedError`.

<a id="droidrun.tools.driver.android.AndroidDriver.__init__"></a>

#### AndroidDriver.\_\_init\_\_

```python
def __init__(
    serial: str | None = None,
    use_tcp: bool = False,
    remote_tcp_port: int = 8080,
) -> None
```

Initialize the AndroidDriver instance.

**Arguments**:

- `serial` _str | None_ - Device serial number (e.g., "emulator-5554", "192.168.1.100:5555"). If None, auto-detects the first available device.
- `use_tcp` _bool_ - Whether to prefer TCP communication (default: False). TCP is faster but requires port forwarding. Falls back to content provider mode if TCP fails.
- `remote_tcp_port` _int_ - TCP port for Portal app communication on device (default: 8080)

**Usage:**

```python
from droidrun.tools import AndroidDriver

# Auto-detect device
driver = AndroidDriver()

# Specific device
driver = AndroidDriver(serial="emulator-5554")

# TCP mode (faster communication, requires port forwarding)
driver = AndroidDriver(serial="emulator-5554", use_tcp=True)
```

**Supported methods:**

```python
AndroidDriver.supported = {
    "tap", "swipe", "input_text", "press_key", "drag",
    "start_app", "install_app", "screenshot",
    "get_ui_tree", "get_date", "get_apps", "list_packages",
}
```

**Notes:**
- Automatically sets up the Droidrun Portal keyboard on `connect()` via `setup_keyboard()`
- Creates a PortalClient instance that handles TCP/content provider communication
- Device serial can be emulator name, USB serial, or TCP/IP address:port
- Must call `connect()` or `ensure_connected()` before using any methods

---

## Lifecycle Methods

<a id="droidrun.tools.driver.android.AndroidDriver.connect"></a>

#### AndroidDriver.connect

```python
async def connect() -> None
```

Establish connection to the device. Discovers the ADB device, creates a PortalClient, and sets up the Portal keyboard.

**Usage:**

```python
driver = AndroidDriver(serial="emulator-5554")
await driver.connect()
```

<a id="droidrun.tools.driver.android.AndroidDriver.ensure_connected"></a>

#### AndroidDriver.ensure\_connected

```python
async def ensure_connected() -> None
```

Connect if not already connected. Safe to call multiple times.

---

## Input Action Methods

<a id="droidrun.tools.driver.android.AndroidDriver.tap"></a>

#### AndroidDriver.tap

```python
async def tap(x: int, y: int) -> None
```

Tap at absolute pixel coordinates on the device screen.

**Arguments**:

- `x` _int_ - X coordinate
- `y` _int_ - Y coordinate

**Usage:**

```python
await driver.tap(540, 960)
```

<a id="droidrun.tools.driver.android.AndroidDriver.swipe"></a>

#### AndroidDriver.swipe

```python
async def swipe(
    x1: int,
    y1: int,
    x2: int,
    y2: int,
    duration_ms: float = 1000,
) -> None
```

Swipe from (x1, y1) to (x2, y2).

**Arguments**:

- `x1` _int_ - Starting X coordinate
- `y1` _int_ - Starting Y coordinate
- `x2` _int_ - Ending X coordinate
- `y2` _int_ - Ending Y coordinate
- `duration_ms` _float_ - Duration of swipe in milliseconds (default: 1000)

**Usage:**

```python
# Swipe up (scroll down content)
await driver.swipe(540, 1500, 540, 500, duration_ms=300)

# Swipe left
await driver.swipe(800, 960, 200, 960, duration_ms=250)
```

**Notes:**
- Duration is converted to seconds internally (dividing by 1000)
- Includes an async sleep matching the swipe duration for UI settling

<a id="droidrun.tools.driver.android.AndroidDriver.input_text"></a>

#### AndroidDriver.input\_text

```python
async def input_text(text: str, clear: bool = False) -> bool
```

Type text into the currently focused field.

**Arguments**:

- `text` _str_ - Text to input. Supports Unicode and special characters.
- `clear` _bool_ - Whether to clear existing text before inputting (default: False)

**Returns**:

- `bool` - True if input succeeded, False otherwise

**Usage:**

```python
await driver.tap(540, 300)  # Focus text field first
success = await driver.input_text("Hello World")

# Clear existing text and input new text
success = await driver.input_text("New text", clear=True)
```

**Notes:**
- Uses the Droidrun Portal app keyboard for reliable text input via PortalClient
- Supports Unicode characters and special characters

<a id="droidrun.tools.driver.android.AndroidDriver.press_key"></a>

#### AndroidDriver.press\_key

```python
async def press_key(keycode: int) -> None
```

Send a single key-event to the device.

**Common keycodes:**
- `3`: HOME
- `4`: BACK
- `66`: ENTER
- `67`: DELETE

Full keycode reference: [Android KeyEvent Documentation](https://developer.android.com/reference/android/view/KeyEvent)

**Arguments**:

- `keycode` _int_ - Android keycode to press

**Usage:**

```python
await driver.press_key(66)  # Press enter
await driver.press_key(3)   # Press home
await driver.press_key(4)   # Press back
```

<a id="droidrun.tools.driver.android.AndroidDriver.drag"></a>

#### AndroidDriver.drag

```python
async def drag(
    x1: int,
    y1: int,
    x2: int,
    y2: int,
    duration: float = 3.0,
) -> None
```

Drag from (x1, y1) to (x2, y2).

**Arguments**:

- `x1` _int_ - Starting X coordinate
- `y1` _int_ - Starting Y coordinate
- `x2` _int_ - Ending X coordinate
- `y2` _int_ - Ending Y coordinate
- `duration` _float_ - Duration of drag in seconds (default: 3.0)

**Notes:**
- Currently raises `NotImplementedError` (declared in `supported` set but not yet implemented)

---

## App Management Methods

<a id="droidrun.tools.driver.android.AndroidDriver.start_app"></a>

#### AndroidDriver.start\_app

```python
async def start_app(package: str, activity: str | None = None) -> str
```

Launch an application on the device.

If activity is not provided, automatically resolves the main/launcher activity using `cmd package resolve-activity`.

**Arguments**:

- `package` _str_ - Package name (e.g., "com.android.settings", "com.google.android.apps.messaging")
- `activity` _str | None_ - Optional activity name (e.g., ".Settings"). If None, auto-detects the main launcher activity.

**Returns**:

- `str` - Result message indicating success or error

**Usage:**

```python
# Auto-detect main activity
result = await driver.start_app("com.android.settings")

# Specific activity
result = await driver.start_app("com.android.settings", ".Settings")
```

<a id="droidrun.tools.driver.android.AndroidDriver.install_app"></a>

#### AndroidDriver.install\_app

```python
async def install_app(path: str, **kwargs) -> str
```

Install an APK on the device.

**Arguments**:

- `path` _str_ - Path to the APK file on the local machine
- `reinstall` _bool_ - Whether to reinstall if app already exists (default: False)
- `grant_permissions` _bool_ - Whether to grant all permissions automatically (default: True)

**Returns**:

- `str` - Result message indicating success or error

**Usage:**

```python
result = await driver.install_app("/path/to/app.apk")
result = await driver.install_app("/path/to/app.apk", reinstall=True)
```

<a id="droidrun.tools.driver.android.AndroidDriver.list_packages"></a>

#### AndroidDriver.list\_packages

```python
async def list_packages(include_system: bool = False) -> List[str]
```

Return installed package names.

**Arguments**:

- `include_system` _bool_ - Whether to include system apps (default: False)

**Returns**:

- `List[str]` - List of package names

<a id="droidrun.tools.driver.android.AndroidDriver.get_apps"></a>

#### AndroidDriver.get\_apps

```python
async def get_apps(include_system: bool = True) -> List[Dict[str, str]]
```

Return installed apps as list of dicts with 'package' and 'label' keys.

**Arguments**:

- `include_system` _bool_ - Whether to include system apps (default: True)

**Returns**:

- `List[Dict[str, str]]` - List of dictionaries containing 'package' and 'label' keys

---

## State and Observation Methods

<a id="droidrun.tools.driver.android.AndroidDriver.screenshot"></a>

#### AndroidDriver.screenshot

```python
async def screenshot(hide_overlay: bool = True) -> bytes
```

Capture the current screen as raw PNG bytes.

**Arguments**:

- `hide_overlay` _bool_ - Whether to hide Portal app overlay elements during screenshot (default: True)

**Returns**:

- `bytes` - Raw PNG image data

**Usage:**

```python
png_bytes = await driver.screenshot()
with open("screenshot.png", "wb") as f:
    f.write(png_bytes)
```

<a id="droidrun.tools.driver.android.AndroidDriver.get_ui_tree"></a>

#### AndroidDriver.get\_ui\_tree

```python
async def get_ui_tree() -> Dict[str, Any]
```

Return the raw UI / accessibility tree from the device.

Returns a dictionary containing both the accessibility tree and phone state data from the Portal app.

**Returns**:

- `Dict[str, Any]` - Raw UI tree data from the device

<a id="droidrun.tools.driver.android.AndroidDriver.get_date"></a>

#### AndroidDriver.get\_date

```python
async def get_date() -> str
```

Get the current date and time on the device.

**Returns**:

- `str` - Date and time string from device

**Usage:**

```python
date = await driver.get_date()
print(f"Device date: {date}")
# Output: "Thu Jan 16 14:30:25 UTC 2025"
```

---

## Properties

**Instance variables:**

- `device` - ADB device instance (from async_adbutils)
- `portal` - PortalClient instance for device communication (TCP or content provider mode)
- `supported` - Set of supported method names for capability checking

---

## Notes

- **Portal app required**: The Droidrun Portal app must be installed and accessibility service enabled on the device
- **TCP vs Content Provider**: TCP is faster but requires port forwarding (`adb forward tcp:8080 tcp:8080`). Content provider is the fallback mode using ADB shell commands.
- **Capability checking**: Check `"method_name" in driver.supported` to determine if a method is available before calling it
- **Async-only**: All methods are async and must be awaited
- **No element resolution**: AndroidDriver provides raw device I/O only. Element resolution (by index) is handled by `UIState` via the `StateProvider` layer.

---

## Example Workflow

```python
import asyncio
from droidrun.tools import AndroidDriver

async def main():
    # Initialize driver
    driver = AndroidDriver(serial="emulator-5554", use_tcp=True)
    await driver.connect()

    # Start Chrome app
    result = await driver.start_app("com.android.chrome")
    print(result)

    # Get UI tree (raw data)
    tree = await driver.get_ui_tree()

    # Tap at coordinates
    await driver.tap(540, 300)

    # Input text
    await driver.input_text("Droidrun framework")

    # Press enter
    await driver.press_key(66)

    # Take screenshot
    png_bytes = await driver.screenshot()
    with open("search_result.png", "wb") as f:
        f.write(png_bytes)

asyncio.run(main())
```

**Note:** For higher-level interactions with element indexing and structured results, use action functions with `ActionContext` (see [DroidAgent](/v5/sdk/droid-agent)) rather than calling the driver directly.

```

`docs/v5/sdk/base-tools.mdx`:

```mdx
---
title: DeviceDriver Base Class
---

Base class defining the interface for all device drivers.

<a id="droidrun.tools.driver.base.DeviceDriver"></a>

## DeviceDriver

```python
class DeviceDriver
```

Base class for all device drivers.

Every method raises `NotImplementedError` by default. Concrete drivers override the methods they support and declare them in the `supported` class-level set. This allows capability checking at runtime without introspection.

---

## Quick Reference

**Driver Methods:**
- `connect()`, `ensure_connected()`, `tap()`, `swipe()`, `input_text()`, `press_key()`, `drag()`, `start_app()`, `install_app()`, `get_apps()`, `list_packages()`, `screenshot()`, `get_ui_tree()`, `get_date()`

**Key Attribute:**
- `supported`: `set[str]` - Set of method names the driver implements. Check membership before calling.

---

## Architecture

The tools architecture follows a multi-layer pattern:

1. **DeviceDriver** (`tools/driver/base.py`): Base class for raw device I/O. Methods raise `NotImplementedError` by default.
2. **Driver Implementations**: Platform-specific drivers
   - `AndroidDriver` (`tools/driver/android.py`): Android devices via ADB + Portal app
   - `IOSDriver` (`tools/driver/ios.py`): iOS devices via HTTP REST API to Portal app
   - `StealthDriver` (`tools/driver/stealth.py`): Stealth mode driver
   - `RecordingDriver` (`tools/driver/recording.py`): Wraps another driver with trajectory recording
   - `CloudDriver` (`tools/driver/cloud.py`): Cloud-hosted device driver
3. **StateProvider** (`tools/ui/provider.py`): Fetches raw data from a driver, applies filters/formatters, produces `UIState`
4. **UIState** (`tools/ui/state.py`): Parsed UI elements with element resolution (`get_element()`, `get_element_coords()`, `get_element_info()`)
5. **ToolRegistry** (`agent/tool_registry.py`): Central registry of all agent-callable tools
6. **ActionContext** (`agent/action_context.py`): Dependency bag passed as `ctx` kwarg to action functions
7. **ActionResult** (`agent/action_result.py`): Structured return type (`success: bool`, `summary: str`)

**Key Components:**

- **DeviceDriver**: Raw I/O layer, no element indexing, no event emission
- **StateProvider**: Orchestrates fetching and parsing device state into `UIState`
- **UIState**: Element lookup by index, coordinate conversion, formatted text output
- **ActionContext**: Bundles `driver`, `ui`, `shared_state`, `state_provider` for action functions
- **ToolRegistry**: Registers action functions and custom tools for agent use

This design ensures:
- Clean separation between device I/O, UI state management, and agent logic
- Easy addition of new device types by implementing a new driver
- Capability detection via the `supported` set
- Structured results via `ActionResult`

---

## Common Interface

All DeviceDriver implementations may provide these methods (check `supported` set for availability):

### Lifecycle

- `connect() -> None` - Establish connection to the device
- `ensure_connected() -> None` - Connect if not already connected

### Input Actions

- `tap(x: int, y: int) -> None` - Tap at absolute pixel coordinates
- `swipe(x1: int, y1: int, x2: int, y2: int, duration_ms: float = 1000) -> None` - Swipe gesture
- `drag(x1: int, y1: int, x2: int, y2: int, duration: float = 3.0) -> None` - Drag gesture
- `input_text(text: str, clear: bool = False) -> bool` - Text input into focused field
- `press_key(keycode: int) -> None` - Key press

### App Management

- `start_app(package: str, activity: str | None = None) -> str` - Launch app
- `install_app(path: str, **kwargs) -> str` - Install app
- `list_packages(include_system: bool = False) -> List[str]` - List packages
- `get_apps(include_system: bool = True) -> List[Dict[str, str]]` - Get apps with labels

### State / Observation

- `screenshot(hide_overlay: bool = True) -> bytes` - Capture screen as PNG bytes
- `get_ui_tree() -> Dict[str, Any]` - Get raw UI / accessibility tree
- `get_date() -> str` - Get device date/time

---

## StateProvider

<a id="droidrun.tools.ui.provider.StateProvider"></a>

```python
class StateProvider:
    def __init__(self, driver: DeviceDriver): ...
    async def get_state(self) -> UIState: ...
```

Base class for state providers. Subclass to support different platforms.

### AndroidStateProvider

```python
class AndroidStateProvider(StateProvider)
```

Fetches state from an Android device via `driver.get_ui_tree()`. Includes retry logic (3 attempts). Applies tree filters and formatters to produce a `UIState` snapshot.

---

## UIState

<a id="droidrun.tools.ui.state.UIState"></a>

```python
class UIState
```

Holds parsed UI elements for a single device state snapshot.

**Key Methods:**

- `get_element(index: int) -> Dict | None` - Recursively find an element by its index
- `get_element_coords(index: int) -> Tuple[int, int]` - Return the centre (x, y) of an element. Raises `ValueError` when element is missing or has no bounds.
- `get_element_info(index: int) -> Dict` - Return element metadata (text, className, type, child_texts)

**Key Attributes:**

- `elements` - List of parsed UI elements
- `formatted_text` - Formatted text representation of the UI tree
- `focused_text` - Text of the currently focused element
- `phone_state` - Dict with current activity, keyboard visibility, etc.
- `screen_width` / `screen_height` - Device screen dimensions

---

## ActionContext

<a id="droidrun.agent.action_context.ActionContext"></a>

```python
class ActionContext
```

Everything an action function needs to interact with the device.

**Attributes:**

- `driver` - `DeviceDriver` instance for raw device I/O
- `ui` - `UIState` instance for element resolution (refreshed each step)
- `shared_state` - `DroidAgentState` for shared agent state
- `state_provider` - `StateProvider` for fetching fresh UI state
- `app_opener_llm` - LLM instance for app opening workflow (optional)
- `credential_manager` - CredentialManager instance (optional)
- `streaming` - Whether streaming is enabled

---

## ActionResult

<a id="droidrun.agent.action_result.ActionResult"></a>

```python
@dataclass
class ActionResult:
    success: bool
    summary: str
```

Structured return type from action functions. The `summary` field is what the agent sees.

---

## Action Functions

Action functions live in `agent/utils/actions.py` and follow this pattern:

```python
async def click(index: int, *, ctx: ActionContext) -> ActionResult:
    """Click the element with the given index."""
    x, y = ctx.ui.get_element_coords(index)
    await ctx.driver.tap(x, y)
    return ActionResult(success=True, summary=f"Clicked on element at ({x}, {y})")
```

**Available actions:**
- `click(index)` - Click UI element by index
- `click_at(x, y)` - Click at screen coordinates
- `click_area(area)` - Click a named screen area
- `long_press(index)` - Long press UI element by index
- `long_press_at(x, y)` - Long press at screen coordinates
- `type(text, index)` - Input text into element
- `type_secret(secret_id)` - Input a credential secret
- `swipe(coordinate, coordinate2)` - Swipe gesture
- `system_button(button)` - Press system buttons (back, home, enter)
- `open_app(text)` - Open app by name
- `wait(seconds)` - Wait for a duration
- `remember(information)` - Store info in agent memory
- `complete(success, reason)` - Mark task as finished
- `get_state()` - Get accessibility tree + phone state
- `take_screenshot()` - Capture device screen

---

## ToolRegistry

<a id="droidrun.agent.tool_registry.ToolRegistry"></a>

```python
class ToolRegistry
```

Central registry of all agent-callable tools.

**Methods:**

- `register(name, fn, params, description)` - Register a single tool
- `register_from_dict(tools_dict)` - Register tools from `{"name": {"parameters": {...}, "description": "...", "function": callable}}` format
- `disable(tool_names)` - Remove tools by name

---

## Custom Tool Integration

### Adding Custom Tools

```python
def my_custom_tool(param: str, **kwargs) -> str:
    """Custom tool description."""
    return f"Result: {param}"

custom_tools = {
    "my_custom_tool": {
        "parameters": {
            "param": {"type": "string", "required": True},
        },
        "description": "Custom tool description with usage example",
        "function": my_custom_tool
    }
}

agent = DroidAgent(
    goal="Do something",
    config=config,
    custom_tools=custom_tools
)
```

---

## Platform Comparison

| Feature | AndroidDriver | IOSDriver |
|---------|--------------|-----------|
| Connection | ADB + Portal (USB/TCP) | HTTP (Portal app) |
| tap | Absolute coordinates | Absolute coordinates |
| swipe | Coordinate-based | Direction-based |
| drag | Declared but not yet implemented | Not supported |
| input_text | With clear support | No clear support |
| press_key | Full Android keycodes | HOME only (BACK/ENTER unsupported) |
| screenshot | PNG via Portal | PNG via HTTP |
| get_ui_tree | Accessibility tree + phone state | Accessibility tree + phone state |
| get_date | Via ADB shell | Not available (returns empty) |
| get_apps | Full packages with labels | Bundle identifiers only |

---

## Best Practices

### 1. Check supported methods before calling

```python
if "get_date" in driver.supported:
    date = await driver.get_date()
else:
    date = "Unknown"
```

### 2. Use ActionContext for agent-level interactions

```python
# Action functions use ctx for all device interaction
async def my_action(param: str, *, ctx: ActionContext) -> ActionResult:
    x, y = ctx.ui.get_element_coords(5)
    await ctx.driver.tap(x, y)
    return ActionResult(success=True, summary="Done")
```

### 3. Use StateProvider for UI state

```python
from droidrun.tools import AndroidStateProvider, AndroidDriver

# StateProvider handles fetching + parsing + retries
provider = AndroidStateProvider(driver, tree_filter=my_filter, tree_formatter=my_formatter)
ui_state = await provider.get_state()

# UIState provides element lookup
element = ui_state.get_element(5)
x, y = ui_state.get_element_coords(5)
```

---

## Error Handling

Driver methods use consistent error handling:

**Raises NotImplementedError:**
```python
# Methods not in `supported` set raise NotImplementedError
try:
    await driver.drag(100, 500, 100, 100)
except NotImplementedError:
    print("Drag not supported on this driver")
```

**ActionResult for action functions:**
```python
result = await click(5, ctx=ctx)
if not result.success:
    print(f"Action failed: {result.summary}")
```

---

## See Also

- [AndroidDriver API](/v5/sdk/adb-tools) - Android driver implementation
- [IOSDriver API](/v5/sdk/ios-tools) - iOS driver implementation
- [DroidAgent API](/v5/sdk/droid-agent) - Agent integration
- [Configuration](/v5/sdk/configuration) - Configuration reference

```

`docs/v5/sdk/configuration.mdx`:

```mdx
---
title: 'Configuration'
description: 'Complete DroidAgent configuration guide - all parameters, minimal examples'
---

## Quick Start

```python
from droidrun import DroidAgent, DroidrunConfig

# Minimal (uses defaults)
agent = DroidAgent(goal="Open settings")
result = await agent.run()

# Load from config.yaml
config = DroidrunConfig.from_yaml("config.yaml")
agent = DroidAgent(goal="Open settings", config=config)
result = await agent.run()
```

---

## DroidAgent Parameters

### Required

```python
DroidAgent(
    goal="Your task",  # REQUIRED: Task description
)
```

### Optional Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `config` | `DroidrunConfig \| None` | `None` | Full config object (loads LLMs from profiles if `llms` not provided) |
| `llms` | `dict[str, LLM] \| LLM \| None` | `None` | LLM(s) - dict for per-agent, single LLM for all, or None to load from config |
| `tools` | `Tools \| None` | `None` | Tools instance (AdbTools/IOSTools) |
| `custom_tools` | `dict \| None` | `None` | Custom tool definitions |
| `credentials` | `dict \| None` | `None` | Dict of credential secrets |
| `variables` | `dict \| None` | `None` | Custom variables accessible during execution |
| `output_model` | `Type[BaseModel] \| None` | `None` | Pydantic model for structured output extraction |
| `prompts` | `dict[str, str] \| None` | `None` | Custom Jinja2 prompt templates (NOT file paths) |
| `timeout` | `int` | `1000` | Workflow timeout in seconds |

---

## Configuration Classes

### AgentConfig

```python
from droidrun import AgentConfig, FastAgentConfig, ManagerConfig, ExecutorConfig, ScripterConfig, AppCardConfig

AgentConfig(
    # Core settings
    max_steps=15,                    # Max execution steps
    reasoning=True,                 # Enable Manager/Executor workflow
    streaming=True,                  # Stream LLM responses
    after_sleep_action=1.0,          # Wait after actions (seconds)
    wait_for_stable_ui=0.3,          # Wait for UI to stabilize (seconds)
    prompts_dir="config/prompts",    # Prompt templates directory

    # Sub-configs
    fast_agent=FastAgentConfig(...),
    manager=ManagerConfig(...),
    executor=ExecutorConfig(...),
    scripter=ScripterConfig(...),
    app_cards=AppCardConfig(...),
)
```

**FastAgentConfig**
```python
FastAgentConfig(
    vision=True,                    # Enable screenshots
    system_prompt="system.jinja2",   # Filename in prompts_dir/codeact/
    user_prompt="user.jinja2",       # Filename in prompts_dir/codeact/
    codeact=False,                  # Legacy: enable CodeAct code-execution mode (default: XML tool-calling)
    parallel_tools=True,            # Encourage multiple tool calls in a single response
)
```

**ManagerConfig**
```python
ManagerConfig(
    vision=True,                    # Enable screenshots
    system_prompt="system.jinja2",   # Filename in prompts_dir/manager/
)
```

**ExecutorConfig**
```python
ExecutorConfig(
    vision=True,                    # Enable screenshots
    system_prompt="system.jinja2",   # Filename in prompts_dir/executor/
)
```

**ScripterConfig**
```python
ScripterConfig(
    enabled=True,                    # Enable off-device Python execution
    max_steps=10,                    # Max scripter steps
    execution_timeout=30.0,          # Code block timeout (seconds)
    system_prompt_path="system.jinja2",  # Filename in prompts_dir/scripter/
    safe_execution=False,            # Restrict imports/builtins
)
```

**AppCardConfig**
```python
AppCardConfig(
    enabled=True,                    # Enable app-specific instructions
    mode="local",                    # "local" | "server" | "composite"
    app_cards_dir="config/app_cards",  # Directory for app card files
    server_url=None,                 # Server URL (for server/composite modes)
    server_timeout=2.0,              # Server request timeout (seconds)
    server_max_retries=2,            # Server retry attempts
)
```

---

### DeviceConfig

```python
from droidrun import DeviceConfig

DeviceConfig(
    serial=None,          # Device serial/IP (None = auto-detect)
    platform="android",   # "android" or "ios"
    use_tcp=False,        # TCP vs content provider communication
)
```

---

### LoggingConfig

```python
from droidrun import LoggingConfig

LoggingConfig(
    debug=True,                   # Enable debug logs
    save_trajectory="none",        # "none" | "step" | "action"
    trajectory_path="trajectories", # Directory for trajectory files
    trajectory_gifs=False,         # Save trajectory as animated GIFs
    rich_text=False,               # Rich text formatting in logs
)
```

---

### TracingConfig

```python
from droidrun import TracingConfig

TracingConfig(
    enabled=True,                      # Enable tracing
    provider="phoenix",                 # "phoenix" or "langfuse"

    # Langfuse settings (only used if provider="langfuse")
    langfuse_secret_key="",             # LANGFUSE_SECRET_KEY env var
    langfuse_public_key="",             # LANGFUSE_PUBLIC_KEY env var
    langfuse_host="",                   # LANGFUSE_HOST env var (e.g., "https://cloud.langfuse.com")
    langfuse_user_id="anonymous",       # User ID for Langfuse tracing
    langfuse_session_id="",             # Empty = auto-generate UUID; custom value to persist across runs
)
```

---

### TelemetryConfig

```python
from droidrun import TelemetryConfig

TelemetryConfig(
    enabled=True,  # Enable anonymous telemetry
)
```

---

### ToolsConfig

```python
from droidrun import ToolsConfig

ToolsConfig(
    allow_drag=True,          # Enable drag tool
    disabled_tools=[],        # List of tools to disable (e.g., ["long_press", "wait"])
)
```

**Example - Disable specific tools:**
```yaml
tools:
  disabled_tools:
    - long_press
    - wait
```
Disabled tools will not be available to agents during execution.

---

### CredentialsConfig

```python
from droidrun import CredentialsConfig

CredentialsConfig(
    enabled=True,                        # Enable credential manager
    file_path="config/credentials.yaml",  # Path to credentials file
)
```

---

### SafeExecutionConfig

```python
from droidrun import SafeExecutionConfig

SafeExecutionConfig(
    # Imports
    allow_all_imports=False,         # Allow all imports (ignores allowed_modules)
    allowed_modules=[],              # Allowed module names (e.g., ["json", "requests"])
    blocked_modules=[                # Blocked modules (takes precedence)
        "os", "sys", "subprocess", "shutil", "pathlib", "pty", "fcntl",
        "resource", "pickle", "shelve", "marshal", "imp", "importlib",
        "ctypes", "code", "codeop", "tempfile", "glob", "socket",
        "socketserver", "asyncio"
    ],

    # Builtins
    allow_all_builtins=False,        # Allow all builtins (ignores allowed_builtins)
    allowed_builtins=[],             # Allowed builtin names (empty = safe defaults)
    blocked_builtins=[               # Blocked builtins (takes precedence)
        "open", "compile", "exec", "eval", "__import__",
        "breakpoint", "exit", "quit", "input"
    ],
)
```

---

## LLM Configuration

### Single LLM (All Agents)

```python
from llama_index.llms.gemini import Gemini

llm = Gemini(model="models/gemini-2.5-pro", temperature=0.2)
agent = DroidAgent(goal="...", llms=llm)
```

### Per-Agent LLMs

```python
from llama_index.llms.openai import OpenAI
from llama_index.llms.gemini import Gemini

agent = DroidAgent(
    goal="...",
    llms={
        "manager": OpenAI(model="gpt-4o"),                    # Planning
        "executor": Gemini(model="models/gemini-2.5-flash"),  # Action selection
        "fast_agent": Gemini(model="models/gemini-2.5-pro"),   # Fast Agent: Direct execution (XML tool-calling)
        "text_manipulator": Gemini(model="models/gemini-2.5-flash"),  # Text input
        "app_opener": OpenAI(model="gpt-4o-mini"),            # App launching
        "scripter": Gemini(model="models/gemini-2.5-flash"),  # Off-device scripts
        "structured_output": Gemini(model="models/gemini-2.5-flash"),  # Output extraction
    }
)
```

**LLM Keys:**
- `manager` - Planning (reasoning mode only)
- `executor` - Action selection (reasoning mode only)
- `fast_agent` - Fast Agent: Direct execution (XML tool-calling)
- `scripter` - Off-device Python execution
- `text_manipulator` - Text input helper
- `app_opener` - App launching helper
- `structured_output` - Final output extraction

---

## Custom Tools

```python
def my_tool(param: str, **kwargs) -> str:
    """Tool description."""
    return f"Result: {param}"

agent = DroidAgent(
    goal="...",
    custom_tools={
        "my_tool": {
            "parameters": {
                "param": {"type": "string", "required": True},
            },
            "description": "Tool description with usage example",
            "function": my_tool
        }
    }
)
```

---

## Credentials

### Dict Format (Recommended)
```python
agent = DroidAgent(
    goal="...",
    credentials={
        "USERNAME": "alice@example.com",
        "PASSWORD": "secret123"
    }
)
# Agent can call get_username() and get_password()
```

### Config Format
```python
from droidrun import DroidrunConfig, CredentialsConfig

config = DroidrunConfig(
    credentials=CredentialsConfig(
        enabled=True,
        file_path="config/credentials.yaml"
    )
)

agent = DroidAgent(
    goal="...",
    config=config
)
```

---

## Custom Variables

```python
agent = DroidAgent(
    goal="...",
    variables={
        "api_url": "https://api.example.com",
        "user_id": "12345",
        "custom_data": {"key": "value"}
    }
)
# Access in shared_state.custom_variables
```

---

## Structured Output

```python
from pydantic import BaseModel

class FlightInfo(BaseModel):
    airline: str
    flight_number: str
    confirmation_code: str

agent = DroidAgent(
    goal="Book a flight and extract details",
    output_model=FlightInfo
)
result = await agent.run()
print(result.structured_output.airline)  # Typed output
```

---

## Custom Prompts

```python
custom_prompt = """
You are an expert mobile agent.
Goal: {{ instruction }}
Be precise and efficient.
"""

agent = DroidAgent(
    goal="...",
    prompts={
        "fast_agent_system": custom_prompt,
        "fast_agent_user": "...",
        "manager_system": "...",
        "executor_system": "...",
        "scripter_system": "..."
    }
)
```

**Template Variables:**
- `{{ instruction }}` - User's goal
- `{{ device_date }}` - Device date/time
- `{{ app_card }}` - App-specific instructions
- `{{ state }}` - Device state
- `{{ history }}` - Action history

---

## Complete Example

```python
from droidrun import (
    DroidAgent, DroidrunConfig,
    AgentConfig, FastAgentConfig, DeviceConfig, LoggingConfig, TracingConfig
)
from llama_index.llms.openai import OpenAI
from llama_index.llms.gemini import Gemini
from pydantic import BaseModel

# Structured output
class Output(BaseModel):
    name: str
    value: int

# Custom tool
def send_email(to: str, subject: str, **kwargs) -> str:
    """Send email."""
    return f"Sent to {to}"

# Build configuration
config = DroidrunConfig(
    agent=AgentConfig(
        max_steps=30,
        reasoning=True,
        after_sleep_action=1.5,
        fast_agent=FastAgentConfig(vision=True)
    ),
    device=DeviceConfig(
        serial="emulator-5554",
        platform="android",
        use_tcp=False
    ),
    logging=LoggingConfig(
        debug=True,
        save_trajectory="action",
        trajectory_gifs=True
    ),
    tracing=TracingConfig(enabled=True),
)

agent = DroidAgent(
    goal="Complex task",
    config=config,

    # LLMs
    llms={
        "manager": OpenAI(model="gpt-4o"),                    # Planning
        "executor": Gemini(model="models/gemini-2.5-flash"),  # Action selection
        "fast_agent": Gemini(model="models/gemini-2.5-pro"),   # Fast Agent: Direct execution (XML tool-calling)
        "text_manipulator": Gemini(model="models/gemini-2.5-flash"),  # Text input
        "app_opener": OpenAI(model="gpt-4o-mini"),            # App launching
        "scripter": Gemini(model="models/gemini-2.5-flash"),  # Off-device scripts
        "structured_output": Gemini(model="models/gemini-2.5-flash"),  # Output extraction
    },

    # Custom tools
    custom_tools={
        "send_email": {
            "parameters": {
                "to": {"type": "string", "required": True},
                "subject": {"type": "string", "required": True},
            },
            "description": "Send email to recipient with subject",
            "function": send_email
        }
    },

    # Credentials
    credentials={"USERNAME": "alice", "PASSWORD": "secret"},

    # Variables
    variables={"api_url": "https://api.example.com"},

    # Structured output
    output_model=Output,

    # Timeout
    timeout=600
)

result = await agent.run()
```

---

## YAML Config (CLI)

For CLI usage, create `config.yaml`:

```yaml
agent:
  max_steps: 15
  reasoning: false
  streaming: true
  after_sleep_action: 1.0
  wait_for_stable_ui: 0.3
  prompts_dir: config/prompts

  fast_agent:
    vision: false
    parallel_tools: true
    system_prompt: system.jinja2
    user_prompt: user.jinja2
    codeact: false  # Legacy: enable CodeAct code-execution mode (default: XML tool-calling)
    parallel_tools: true  # Encourage multiple tool calls in a single response

  manager:
    vision: false
    system_prompt: system.jinja2

  executor:
    vision: false
    system_prompt: system.jinja2

  scripter:
    enabled: true
    max_steps: 10
    execution_timeout: 30.0
    system_prompt_path: system.jinja2
    safe_execution: false

  app_cards:
    enabled: true
    mode: local
    app_cards_dir: config/app_cards
    server_url: null
    server_timeout: 2.0
    server_max_retries: 2

llm_profiles:
  manager:
    provider: GoogleGenAI
    model: models/gemini-2.5-pro
    temperature: 0.2
    kwargs:
      max_tokens: 8192

  executor:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.1
    kwargs:
      max_tokens: 4096

  fast_agent:  # Fast Agent: Direct execution (XML tool-calling)
    provider: GoogleGenAI
    model: models/gemini-2.5-pro
    temperature: 0.2
    kwargs:
      max_tokens: 8192

  text_manipulator:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.3

  app_opener:
    provider: OpenAI
    model: gpt-4o-mini
    temperature: 0.0

  scripter:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.1

  structured_output:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.0

device:
  serial: null
  platform: android
  use_tcp: false

telemetry:
  enabled: true

tracing:
  enabled: false
  provider: phoenix  # "phoenix" or "langfuse"
  langfuse_secret_key: ""
  langfuse_public_key: ""
  langfuse_host: ""
  langfuse_user_id: anonymous
  langfuse_session_id: ""

logging:
  debug: false
  save_trajectory: none
  trajectory_path: trajectories
  trajectory_gifs: false
  rich_text: false

safe_execution:
  allow_all_imports: false
  allowed_modules: []
  blocked_modules:
    - os
    - sys
    - subprocess
    - shutil
    - pathlib
    - pty
    - fcntl
    - resource
    - pickle
    - shelve
    - marshal
    - imp
    - importlib
    - ctypes
    - code
    - codeop
    - tempfile
    - glob
    - socket
    - socketserver
    - asyncio
  allow_all_builtins: false
  allowed_builtins: []
  blocked_builtins:
    - open
    - compile
    - exec
    - eval
    - __import__
    - breakpoint
    - exit
    - quit
    - input

credentials:
  enabled: false
  file_path: config/credentials.yaml
```

---

## CLI Overrides

```bash
# Override agent settings
droidrun run "Task" --steps 30 --reasoning --vision

# Override device
droidrun run "Task" --device emulator-5554 --tcp

# Override LLM (applies to ALL agents)
droidrun run "Task" --provider GoogleGenAI --model models/gemini-2.5-flash

# Override logging
droidrun run "Task" --debug --save-trajectory action --tracing

# Custom config file
droidrun run "Task" --config /path/to/config.yaml
```

**All CLI Flags:**
- `--config PATH` - Custom config file
- `--device SERIAL` - Device serial/IP
- `--provider PROVIDER` - LLM provider (OpenAI, Ollama, Anthropic, GoogleGenAI, DeepSeek)
- `--model MODEL` - LLM model name
- `--temperature FLOAT` - LLM temperature
- `--steps INT` - Max steps
- `--base_url URL` - API base URL (for Ollama/OpenRouter)
- `--api_base URL` - API base URL (for OpenAI-like)
- `--vision/--no-vision` - Enable/disable vision for all agents
- `--reasoning/--no-reasoning` - Enable/disable reasoning mode
- `--tracing/--no-tracing` - Enable/disable tracing
- `--debug/--no-debug` - Enable/disable debug logs
- `--tcp/--no-tcp` - Enable/disable TCP communication
- `--save-trajectory none|step|action` - Trajectory saving level
- `--ios` - Run on iOS device

---

## Environment Variables

Set API keys via environment variables:

```bash
export GOOGLE_API_KEY=your-key
export OPENAI_API_KEY=your-key
export ANTHROPIC_API_KEY=your-key
export DEEPSEEK_API_KEY=your-key
export DROIDRUN_CONFIG=/path/to/config.yaml  # Custom config path
```

```

`docs/v5/sdk/droid-agent.mdx`:

```mdx
---
title: DroidAgent
---

DroidAgent - A wrapper class that coordinates the planning and execution of tasks to achieve a user's goal on an Android or iOS device.

<a id="droidrun.agent.droid.droid_agent.DroidAgent"></a>

## DroidAgent

```python
class DroidAgent(Workflow)
```

A wrapper class that coordinates between agents to achieve a user's goal.

**Architecture:**
- When `reasoning=False`: Uses FastAgent directly for immediate execution
- When `reasoning=True`: Uses ManagerAgent (planning) + ExecutorAgent (actions) + ScripterAgent (off-device operations)

<a id="droidrun.agent.droid.droid_agent.DroidAgent.__init__"></a>

#### DroidAgent.\_\_init\_\_

```python
def __init__(
    goal: str,
    config: DroidrunConfig | None = None,
    llms: dict[str, LLM] | LLM | None = None,
    tools: "DeviceDriver | None" = None,
    custom_tools: dict | None = None,
    credentials: dict | None = None,
    variables: dict | None = None,
    output_model: Type[BaseModel] | None = None,
    prompts: dict[str, str] | None = None,
    timeout: int = 1000
)
```

Initialize the DroidAgent wrapper.

**Arguments**:

- `goal` _str_ - User's goal or command to execute
- `config` _DroidrunConfig | None_ - Full configuration object (required if llms not provided). Contains agent settings, LLM profiles, device config, and more.
- `llms` _dict[str, LLM] | LLM | None_ - Optional LLM configuration:
  - `dict[str, LLM]`: Agent-specific LLMs with keys: "manager", "executor", "fast_agent", "text_manipulator", "app_opener", "scripter", "structured_output"
  - `LLM`: Single LLM instance used for all agents
  - `None`: LLMs will be loaded from config.llm_profiles
- `tools` _DeviceDriver | None_ - Pre-configured device driver instance (AndroidDriver or IOSDriver). If None, a driver will be created from config.
- `custom_tools` _dict | None_ - Custom tool definitions. Format: `{"tool_name": {"parameters": {...}, "description": "...", "function": callable}}`. These are merged with auto-generated credential tools.
- `credentials` _dict | None_ - Direct credential mapping `{"SECRET_ID": "value"}`. If None, credentials will be loaded from config.credentials if available.
- `variables` _dict | None_ - Custom variables accessible throughout execution. Available in shared_state.custom_variables.
- `output_model` _Type[BaseModel] | None_ - Pydantic model for structured output extraction from final answer. If provided, the final answer will be parsed into this model.
- `prompts` _dict[str, str] | None_ - Custom Jinja2 prompt templates to override defaults. Keys: "fast_agent_system", "fast_agent_user", "manager_system", "executor_system", "scripter_system". Values: Jinja2 template strings (NOT file paths).
- `timeout` _int_ - Workflow timeout in seconds (default: 1000)

**Basic initialization pattern (recommended):**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize with default config
config = DroidrunConfig()

# Create agent (LLMs loaded from config.llm_profiles)
agent = DroidAgent(
    goal="Open Chrome and search for Droidrun",
    config=config
)

# Run agent
result = await agent.run()
```

**Loading from YAML (optional):**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Load config from config.yaml
config = DroidrunConfig.from_yaml("config.yaml")

# Create agent (LLMs loaded from config.llm_profiles)
agent = DroidAgent(
    goal="Open Chrome and search for Droidrun",
    config=config
)

# Run agent
result = await agent.run()
```

**Custom LLM dictionary pattern:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig
from llama_index.llms.openai import OpenAI
from llama_index.llms.anthropic import Anthropic

# Initialize config
config = DroidrunConfig()

# Create custom LLMs
llms = {
    "manager": Anthropic(model="claude-sonnet-4-5-latest", temperature=0.2),
    "executor": Anthropic(model="claude-sonnet-4-5-latest", temperature=0.1),
    "fast_agent": OpenAI(model="gpt-4o", temperature=0.2),
    "text_manipulator": OpenAI(model="gpt-4o-mini", temperature=0.3),
    "app_opener": OpenAI(model="gpt-4o-mini", temperature=0.0),
    "scripter": OpenAI(model="gpt-4o", temperature=0.1),
    "structured_output": OpenAI(model="gpt-4o-mini", temperature=0.0),
}

# Create agent with custom LLMs
agent = DroidAgent(
    goal="Send a message to John",
    llms=llms,
    config=config
)

result = await agent.run()
```

**Single LLM pattern:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig
from llama_index.llms.openai import OpenAI

# Initialize config
config = DroidrunConfig()

# Use same LLM for all agents
llm = OpenAI(model="gpt-4o", temperature=0.2)

agent = DroidAgent(
    goal="Take a screenshot and save it",
    llms=llm,
    config=config
)

result = await agent.run()
```

**Custom tools and credentials:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

# Define custom tool
def search_database(query: str) -> str:
    """Search the local database."""
    # Your implementation
    return f"Results for: {query}"

custom_tools = {
    "search_database": {
        "parameters": {
            "query": {"type": "string", "required": True},
        },
        "description": "Search the local database for information",
        "function": search_database
    }
}

# Provide credentials directly
credentials = {
    "GMAIL_USERNAME": "user@gmail.com",
    "GMAIL_PASSWORD": "secret123"
}

agent = DroidAgent(
    goal="Search database and email results",
    config=config,
    custom_tools=custom_tools,
    credentials=credentials
)

result = await agent.run()
```

**Structured output extraction:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig
from pydantic import BaseModel, Field

# Initialize config
config = DroidrunConfig()

# Define output schema
class WeatherInfo(BaseModel):
    """Weather information."""
    temperature: float = Field(description="Temperature in Celsius")
    condition: str = Field(description="Weather condition")
    humidity: int = Field(description="Humidity percentage")

agent = DroidAgent(
    goal="Open weather app and get current weather",
    config=config,
    output_model=WeatherInfo
)

result = await agent.run()

# Access structured output
if result.success and result.structured_output:
    weather = result.structured_output  # WeatherInfo object
    print(f"Temperature: {weather.temperature}¬∞C")
    print(f"Condition: {weather.condition}")
```

<a id="droidrun.agent.droid.droid_agent.DroidAgent.run"></a>

#### DroidAgent.run

```python
async def run(*args, **kwargs) -> ResultEvent
```

Run the DroidAgent workflow.

**Returns**:

- `ResultEvent` - Result object with the following attributes:
  - `success` (bool): True if task completed successfully
  - `reason` (str): Success message or failure reason
  - `steps` (int): Number of steps executed
  - `structured_output` (Any): Parsed Pydantic model (if output_model provided, otherwise None)

**Usage:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

# Create and run agent
agent = DroidAgent(goal="...", config=config)
result = await agent.run()

print(f"Success: {result.success}")
print(f"Reason: {result.reason}")
print(f"Steps: {result.steps}")
```

**Streaming events:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

agent = DroidAgent(goal="...", config=config)

# Stream events as they occur
async for event in agent.run_event_stream():
    if isinstance(event, ManagerInputEvent):
        print("Manager is planning...")
    elif isinstance(event, ExecutorInputEvent):
        print("Executor is taking action...")
    elif isinstance(event, TapActionEvent):
        print(f"Tapping element at {event.x}, {event.y}")
    elif isinstance(event, ResultEvent):
        # Final result
        print(f"Success: {event.success}")
        print(f"Reason: {event.reason}")
```

## Event Types

DroidAgent emits various events during execution:

**Workflow Events:**
- `StartEvent` - Workflow started
- `ManagerInputEvent` - Manager planning phase started
- `ManagerContextEvent` - Manager received context for planning
- `ManagerResponseEvent` - Manager intermediate response
- `ManagerPlanEvent` - Manager created a plan
- `ManagerPlanDetailsEvent` - Manager plan details
- `ExecutorInputEvent` - Executor action phase started
- `ExecutorContextEvent` - Executor received context
- `ExecutorResponseEvent` - Executor intermediate response
- `ExecutorActionEvent` - Executor action details
- `ExecutorActionResultEvent` - Executor action result details
- `ExecutorResultEvent` - Executor completed an action
- `ScripterExecutorInputEvent` - ScripterAgent started
- `ScripterExecutorResultEvent` - ScripterAgent completed
- `FastAgentExecuteEvent` - FastAgent started (direct mode)
- `FastAgentResultEvent` - FastAgent completed
- `FinalizeEvent` - Workflow finalizing
- `StopEvent` - Workflow completed

**Action Events:**
- `TapActionEvent` - UI element tapped
- `SwipeActionEvent` - Swipe gesture performed
- `DragActionEvent` - Drag gesture performed
- `InputTextActionEvent` - Text input
- `KeyPressActionEvent` - Key press action
- `StartAppEvent` - App launched
- `WaitEvent` - Wait/sleep action

**State Events:**
- `ScreenshotEvent` - Screenshot captured
- `RecordUIStateEvent` - UI state recorded
- `MacroEvent` - Macro action recorded

## Configuration

DroidAgent uses a hierarchical configuration system. See the [Configuration Guide](/v5/sdk/configuration) for details.

**Key configuration options:**

```yaml
agent:
  max_steps: 15           # Maximum execution steps
  reasoning: false        # Enable Manager/Executor workflow

  fast_agent:
    vision: false         # Enable screenshot analysis
    safe_execution: false # Restrict code execution

  manager:
    vision: false         # Enable screenshot analysis

  executor:
    vision: false         # Enable screenshot analysis

device:
  serial: null            # Device serial (null = auto-detect)
  platform: android       # "android" or "ios"
  use_tcp: false          # TCP vs content provider

logging:
  debug: false            # Debug logging
  save_trajectory: none   # Trajectory saving: "none", "step", "action"

tracing:
  enabled: false          # Arize Phoenix tracing
```

## Advanced Usage

**Custom Tools instance:**

```python
from droidrun import DroidAgent, DeviceConfig
from droidrun.config_manager import DroidrunConfig

# Initialize config with device settings
device_config = DeviceConfig(serial="emulator-5554", use_tcp=True)
config = DroidrunConfig(device=device_config)

agent = DroidAgent(
    goal="Open settings",
    config=config,
)

result = await agent.run()
```

**Custom variables:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

agent = DroidAgent(
    goal="Complete task using context",
    config=config,
    variables={
        "user_name": "Alice",
        "project_id": "12345",
        "api_endpoint": "https://api.example.com"
    }
)

result = await agent.run()
```

Variables are accessible in shared_state.custom_variables throughout execution and can be referenced in custom tools or scripts.

**Custom prompts:**

```python
from droidrun import DroidAgent
from droidrun.config_manager import DroidrunConfig

# Initialize config
config = DroidrunConfig()

# Override default prompts with custom Jinja2 templates
custom_prompts = {
    "fast_agent_system": "You are a specialized agent for {{ platform }} devices...",
    "manager_system": "You are a planning agent. Your goal: {{ instruction }}..."
}

agent = DroidAgent(
    goal="Complete specialized task",
    config=config,
    prompts=custom_prompts
)

result = await agent.run()
```

Available prompt keys: "fast_agent_system", "fast_agent_user", "manager_system", "executor_system", "scripter_system"

## Notes

- **Config requirement**: Either `config` or `llms` must be provided. If `llms` is not provided, `config` is required to load LLMs from profiles.
- **Vision mode**: Enabling vision (agent_config.*.vision = True) increases token usage as screenshots are sent to the LLM.
- **Reasoning mode**: `reasoning=True` uses Manager/Executor workflow for complex planning. `reasoning=False` uses FastAgent for direct execution.
- **Safe execution**: When enabled, restricts imports and builtins in FastAgent and ScripterAgent (see safe_execution config).
- **Timeout**: Default is 1000 seconds. Increase for long-running tasks.
- **Credentials**: Credentials are automatically injected as custom tools (e.g., `get_username()`, `get_password()`).

```

`docs/v5/sdk/ios-tools.mdx`:

```mdx
---
title: IOSDriver
---

# IOSDriver API Reference

<a id="droidrun.tools.driver.ios.IOSDriver"></a>

## IOSDriver

```python
class IOSDriver(DeviceDriver)
```

iOS device driver communicating via HTTP REST to the iOS Portal app.

**Status**: iOS support is in beta with limited functionality compared to AndroidDriver.

**Key Limitations**:
- `get_date()` - Not available (returns empty string)
- `drag()` - Not supported (not in `supported` set)
- `press_key()` - Only HOME is mapped; BACK and ENTER have no iOS equivalent
- `input_text()` - `clear` parameter is ignored

<a id="droidrun.tools.driver.ios.IOSDriver.__init__"></a>

#### IOSDriver.\_\_init\_\_

```python
def __init__(
    url: str,
    bundle_identifiers: List[str] | None = None
) -> None
```

Initialize the IOSDriver instance.

**Arguments**:

- `url` _str_ - iOS Portal app URL (e.g., "http://192.168.1.100:8080")
- `bundle_identifiers` _List[str] | None_ - Optional list of custom app bundle identifiers

**Usage:**

```python
from droidrun.tools.driver import IOSDriver

# Connect to iOS device
driver = IOSDriver(url="http://192.168.1.100:8080")

# With specific bundle identifiers
driver = IOSDriver(
    url="http://192.168.1.100:8080",
    bundle_identifiers=["com.example.app1", "com.example.app2"]
)
```

**Supported methods:**

```python
IOSDriver.supported = {
    "tap", "swipe", "input_text", "press_key",
    "start_app", "screenshot", "get_ui_tree",
    "list_packages", "get_apps",
}
```

**Setup Requirements:**

1. Install Droidrun iOS Portal app on device
2. Launch Portal app (starts HTTP server)
3. Connect device and computer to same network
4. Use displayed URL to initialize IOSDriver

---

## Lifecycle Methods

<a id="droidrun.tools.driver.ios.IOSDriver.connect"></a>

#### IOSDriver.connect

```python
async def connect() -> None
```

Create an HTTP client connection to the iOS Portal app.

<a id="droidrun.tools.driver.ios.IOSDriver.ensure_connected"></a>

#### IOSDriver.ensure\_connected

```python
async def ensure_connected() -> None
```

Connect if not already connected. Safe to call multiple times.

---

## Input Action Methods

<a id="droidrun.tools.driver.ios.IOSDriver.tap"></a>

#### IOSDriver.tap

```python
async def tap(x: int, y: int) -> None
```

Tap at absolute pixel coordinates.

**Arguments**:

- `x` _int_ - X coordinate
- `y` _int_ - Y coordinate

**Usage:**

```python
await driver.tap(200, 400)
```

**Notes:**
- Stores tap coordinates internally for `input_text()` targeting

<a id="droidrun.tools.driver.ios.IOSDriver.swipe"></a>

#### IOSDriver.swipe

```python
async def swipe(
    x1: int,
    y1: int,
    x2: int,
    y2: int,
    duration_ms: float = 1000,
) -> None
```

Perform directional swipe gesture (up, down, left, right).

**Arguments**:

- `x1` _int_ - Starting X coordinate
- `y1` _int_ - Starting Y coordinate
- `x2` _int_ - Ending X coordinate
- `y2` _int_ - Ending Y coordinate
- `duration_ms` _float_ - Duration in milliseconds (ignored on iOS)

**Usage:**

```python
# Swipe up (scroll down)
await driver.swipe(200, 800, 200, 200)

# Swipe left
await driver.swipe(600, 400, 100, 400)
```

**Notes:**
- iOS uses directional swipes, not precise coordinates
- Direction calculated from coordinate delta (largest axis wins)
- `duration_ms` parameter is ignored by iOS API

<a id="droidrun.tools.driver.ios.IOSDriver.input_text"></a>

#### IOSDriver.input\_text

```python
async def input_text(text: str, clear: bool = False) -> bool
```

Input text into the currently focused element.

**Arguments**:

- `text` _str_ - Text to input (supports Unicode)
- `clear` _bool_ - Not supported on iOS (ignored)

**Returns**:

- `bool` - True if input succeeded, False otherwise

**Usage:**

```python
# Tap text field first
await driver.tap(200, 400)

# Input text
success = await driver.input_text("Hello World")
```

**Notes:**
- Must tap text field before calling this method
- Uses last tapped coordinates for targeting
- `clear` parameter is ignored on iOS

<a id="droidrun.tools.driver.ios.IOSDriver.press_key"></a>

#### IOSDriver.press\_key

```python
async def press_key(keycode: int) -> None
```

Press a hardware key.

**Supported keycodes:**
- `3` (Android HOME) maps to iOS HOME button

Unsupported keycodes (BACK=4, ENTER=66, etc.) are silently ignored with a warning log.

**Arguments**:

- `keycode` _int_ - Android-style keycode (translated to iOS internally)

**Usage:**

```python
await driver.press_key(3)  # Home button
```

---

## App Management Methods

<a id="droidrun.tools.driver.ios.IOSDriver.start_app"></a>

#### IOSDriver.start\_app

```python
async def start_app(package: str, activity: str | None = None) -> str
```

Launch an app by bundle identifier.

**Arguments**:

- `package` _str_ - Bundle identifier (e.g., "com.apple.MobileSMS")
- `activity` _str | None_ - Ignored on iOS (for API compatibility)

**Returns**:

- `str` - Result message

**Common bundle identifiers:**
- Messages: `com.apple.MobileSMS`
- Safari: `com.apple.mobilesafari`
- Settings: `com.apple.Preferences`
- Mail: `com.apple.mobilemail`
- Calendar: `com.apple.mobilecal`
- Photos: `com.apple.mobileslideshow`
- Maps: `com.apple.Maps`
- Contacts: `com.apple.MobileAddressBook`

**Usage:**

```python
result = await driver.start_app("com.apple.MobileSMS")
result = await driver.start_app("com.apple.mobilesafari")
```

<a id="droidrun.tools.driver.ios.IOSDriver.list_packages"></a>

#### IOSDriver.list\_packages

```python
async def list_packages(include_system: bool = False) -> List[str]
```

List known bundle identifiers.

**Arguments**:

- `include_system` _bool_ - Include system apps (default: False)

**Returns**:

- `List[str]` - List of bundle identifiers

**Notes:**
- Returns union of `bundle_identifiers` + system apps (if included)
- Does not query device for installed apps

<a id="droidrun.tools.driver.ios.IOSDriver.get_apps"></a>

#### IOSDriver.get\_apps

```python
async def get_apps(include_system: bool = True) -> List[Dict[str, str]]
```

Return known apps as list of dicts. Since iOS has no app listing endpoint, this returns bundle identifiers as both 'package' and 'label'.

**Arguments**:

- `include_system` _bool_ - Include system apps (default: True)

**Returns**:

- `List[Dict[str, str]]` - List of dicts with 'package' and 'label' keys (both set to bundle identifier)

---

## State and Observation Methods

<a id="droidrun.tools.driver.ios.IOSDriver.screenshot"></a>

#### IOSDriver.screenshot

```python
async def screenshot(hide_overlay: bool = True) -> bytes
```

Capture device screen as raw PNG bytes.

**Arguments**:

- `hide_overlay` _bool_ - Unused on iOS (for API compatibility)

**Returns**:

- `bytes` - Raw PNG image data

**Usage:**

```python
png_bytes = await driver.screenshot()
with open("screenshot.png", "wb") as f:
    f.write(png_bytes)
```

<a id="droidrun.tools.driver.ios.IOSDriver.get_ui_tree"></a>

#### IOSDriver.get\_ui\_tree

```python
async def get_ui_tree() -> Dict[str, Any]
```

Return raw iOS accessibility data and phone state.

**Returns**:

Dictionary with:
- `a11y_raw` - The raw accessibility tree text from the portal
- `phone_state` - Dict with `currentApp` and `keyboardVisible`

**Usage:**

```python
tree = await driver.get_ui_tree()
print(tree["phone_state"]["currentApp"])
```

<a id="droidrun.tools.driver.ios.IOSDriver.get_date"></a>

#### IOSDriver.get\_date

```python
async def get_date() -> str
```

Not available on iOS. Returns an empty string.

---

## Unsupported Methods

The following DeviceDriver methods are **not in `supported`** and will raise `NotImplementedError`:

#### drag()
Not supported on iOS. Not declared in `supported` set.

#### install\_app()
Not supported on iOS. Not declared in `supported` set.

---

## Instance Properties

```python
driver.url                    # iOS Portal URL
driver.bundle_identifiers     # Custom bundle IDs
driver.supported              # Set of supported method names
```

---

## iOS vs Android Differences

| Feature | IOSDriver | AndroidDriver |
|---------|-----------|---------------|
| Back button | Not available | Full Android keycodes |
| Swipe | Direction-based | Coordinate-based |
| Drag | Not supported | Declared (not yet implemented) |
| App IDs | Bundle identifiers | Package names |
| Key codes | HOME only | Full Android keycodes |
| Connection | HTTP (Portal app) | ADB over USB/TCP |
| get_date() | Returns empty | Via ADB shell |
| input_text() clear | Ignored | Supported |

**Setup differences:**

**Android**: USB or `adb connect` + Portal APK
**iOS**: Portal app + same network + HTTP connection

---

## Example Usage

```python
import asyncio
from droidrun.tools.driver import IOSDriver

async def main():
    # Initialize and connect
    driver = IOSDriver(url="http://192.168.1.100:8080")
    await driver.connect()

    # Launch Messages
    result = await driver.start_app("com.apple.MobileSMS")
    print(result)

    # Get UI tree
    tree = await driver.get_ui_tree()
    print(tree["phone_state"]["currentApp"])

    # Tap at coordinates
    await driver.tap(200, 400)

    # Input text
    await driver.input_text("Hello from Droidrun!")

    # Take screenshot
    png_bytes = await driver.screenshot()
    with open("screenshot.png", "wb") as f:
        f.write(png_bytes)

asyncio.run(main())
```

**Note:** For higher-level interactions with element indexing and structured results, use action functions with `ActionContext` (see [DroidAgent](/v5/sdk/droid-agent)) rather than calling the driver directly.

---

## See Also

- [AndroidDriver](/v5/sdk/adb-tools) - Android device driver with full functionality
- [DeviceDriver Base Class](/v5/sdk/base-tools) - Base class and architecture reference

```

`docs/v5/sdk/reference.mdx`:

```mdx
---
title: 'Reference'
description: 'Complete API reference for Droidrun components and tools'
---

## Overview

The Droidrun SDK provides a comprehensive set of APIs for building mobile automation workflows with AI agents. This reference documentation covers all major components and tools.

---

## Core Components

<CardGroup cols={2}>
  <Card title="DroidAgent" icon="bot" href="./droid-agent">
    Main agent coordinator with multi-agent orchestration
  </Card>
  <Card title="AndroidDriver" icon="smartphone" href="./adb-tools">
    Android device driver via ADB
  </Card>
  <Card title="IOSDriver" icon="monitor-smartphone" href="./ios-tools">
    iOS device driver and automation
  </Card>
  <Card title="DeviceDriver Base" icon="wrench" href="./base-tools">
    Base class, StateProvider, UIState, ActionContext, and ToolRegistry
  </Card>
</CardGroup>

---

## Configuration

<Card title="Configuration API" icon="settings" href="./configuration">
  DroidrunConfig API and YAML configuration reference
</Card>

---

## API Documentation

Detailed API documentation for each component is available in the sections linked above. Each page includes:

- Class/function signatures
- Parameter descriptions
- Return types
- Usage examples
- Best practices

For conceptual guides and tutorials, see the [Guides](/v5/guides/overview) section.

```

`droidrun/__init__.py`:

```py
"""
Droidrun - A framework for controlling Android devices through LLM agents.
"""

import logging
from importlib.metadata import version

__version__ = version("droidrun")

# Attach a default CLILogHandler so that every consumer (CLI, TUI, SDK,
# tools-only) gets visible output without explicit setup.  CLI and TUI
# replace this with their own handler via ``configure_logging()``.
from droidrun.log_handlers import CLILogHandler

_logger = logging.getLogger("droidrun")
_logger.addHandler(CLILogHandler())
_logger.setLevel(logging.INFO)
_logger.propagate = False

# Import main classes for easier access
from droidrun.agent import ResultEvent
from droidrun.agent.droid import DroidAgent
from droidrun.agent.utils.llm_picker import load_llm

# Import configuration classes
from droidrun.config_manager import (
    # Agent configs
    AgentConfig,
    AppCardConfig,
    FastAgentConfig,
    CredentialsConfig,
    # Feature configs
    DeviceConfig,
    DroidrunConfig,
    ExecutorConfig,
    LLMProfile,
    LoggingConfig,
    ManagerConfig,
    SafeExecutionConfig,
    ScripterConfig,
    TelemetryConfig,
    ToolsConfig,
    TracingConfig,
)

# Import macro functionality
from droidrun.macro import MacroPlayer, replay_macro_file, replay_macro_folder
from droidrun.tools import AndroidDriver, DeviceDriver, RecordingDriver

# Make main components available at package level
__all__ = [
    # Agent
    "DroidAgent",
    "load_llm",
    "ResultEvent",
    # Tools / Drivers
    "DeviceDriver",
    "AndroidDriver",
    "RecordingDriver",
    # Macro
    "MacroPlayer",
    "replay_macro_file",
    "replay_macro_folder",
    # Configuration
    "DroidrunConfig",
    "AgentConfig",
    "FastAgentConfig",
    "ManagerConfig",
    "ExecutorConfig",
    "ScripterConfig",
    "AppCardConfig",
    "DeviceConfig",
    "LoggingConfig",
    "TracingConfig",
    "TelemetryConfig",
    "ToolsConfig",
    "CredentialsConfig",
    "SafeExecutionConfig",
    "LLMProfile",
]

```

`droidrun/__main__.py`:

```py
"""
DroidRun main entry point
"""

from droidrun.cli.main import cli

if __name__ == "__main__":
    cli()

```

`droidrun/agent/__init__.py`:

```py
from droidrun.agent.droid.events import ResultEvent

__all__ = ["ResultEvent"]

```

`droidrun/agent/action_context.py`:

```py
"""ActionContext ‚Äî composed bag of dependencies for action functions.

Replaces the ``tools=tools_instance`` parameter that action functions
previously received.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from droidrun.agent.droid.state import DroidAgentState
    from droidrun.credential_manager import CredentialManager
    from droidrun.tools.driver.base import DeviceDriver
    from droidrun.tools.ui.provider import StateProvider
    from droidrun.tools.ui.state import UIState


class ActionContext:
    """Everything an action function needs to interact with the device."""

    def __init__(
        self,
        driver: "DeviceDriver",
        ui: "Optional[UIState]",
        shared_state: "DroidAgentState",
        state_provider: "StateProvider",
        app_opener_llm=None,
        credential_manager: "Optional[CredentialManager]" = None,
        streaming: bool = False,
    ) -> None:
        self.driver = driver
        self.ui = ui  # refreshed each step before tool execution
        self.shared_state = shared_state
        self.state_provider = state_provider
        self.app_opener_llm = app_opener_llm
        self.credential_manager = credential_manager
        self.streaming = streaming

```

`droidrun/agent/action_result.py`:

```py
"""ActionResult ‚Äî structured return type from action functions."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class ActionResult:
    """What the agent sees after an action runs."""

    success: bool
    summary: str

    def __str__(self) -> str:
        return self.summary

```

`droidrun/agent/codeact/__init__.py`:

```py
from droidrun.agent.codeact.codeact_agent import CodeActAgent
from droidrun.agent.codeact.tools_agent import FastAgent

__all__ = ["CodeActAgent", "FastAgent"]

```

`droidrun/agent/codeact/codeact_agent.py`:

```py
import asyncio
import inspect
import logging
from typing import TYPE_CHECKING, Optional, Type

from llama_index.core.llms.llm import LLM
from llama_index.core.workflow import Context, StartEvent, StopEvent, Workflow, step
from opentelemetry import trace
from pydantic import BaseModel

from droidrun.agent.codeact.events import (
    CodeActCodeEvent,
    CodeActEndEvent,
    CodeActInputEvent,
    CodeActOutputEvent,
    CodeActResponseEvent,
)
from droidrun.agent.common.constants import LLM_HISTORY_LIMIT
from droidrun.agent.common.events import RecordUIStateEvent, ScreenshotEvent
from droidrun.agent.usage import get_usage_from_response
from droidrun.agent.utils.chat_utils import (
    extract_code_and_thought,
    limit_history,
    to_chat_messages,
)
from droidrun.agent.utils.executer import ExecuterState, SimpleCodeExecutor
from droidrun.agent.utils.inference import acall_with_retries
from droidrun.agent.utils.prompt_resolver import PromptResolver
from droidrun.agent.utils.tracing_setup import record_langfuse_screenshot
from droidrun.config_manager.config_manager import AgentConfig, TracingConfig
from droidrun.config_manager.path_resolver import PathResolver
from droidrun.config_manager.prompt_loader import PromptLoader
from droidrun.tools.driver.base import DeviceDisconnectedError

# Legacy codeact prompt paths (used when code_exec=true but config points to tools defaults)
_LEGACY_SYSTEM_PROMPT = "config/prompts/codeact/system.jinja2"
_LEGACY_USER_PROMPT = "config/prompts/codeact/user.jinja2"
_TOOLS_SYSTEM_PROMPT = "config/prompts/codeact/tools_system.jinja2"
_TOOLS_USER_PROMPT = "config/prompts/codeact/tools_user.jinja2"

if TYPE_CHECKING:
    from droidrun.agent.action_context import ActionContext
    from droidrun.agent.droid import DroidAgentState
    from droidrun.agent.tool_registry import ToolRegistry
    from droidrun.tools.ui.provider import StateProvider

logger = logging.getLogger("droidrun")


class CodeActAgent(Workflow):
    """
    Agent that generates and executes Python code using atomic actions.

    Uses ReAct cycle: Thought -> Code -> Observation -> repeat until complete().
    Messages stored as list[dict], converted to ChatMessage only for LLM calls.
    """

    def __init__(
        self,
        llm: LLM,
        agent_config: AgentConfig,
        registry: "ToolRegistry",
        action_ctx: "ActionContext",
        state_provider: "StateProvider",
        save_trajectory: str = "none",
        debug: bool = False,
        shared_state: Optional["DroidAgentState"] = None,
        safe_execution_config=None,
        output_model: Type[BaseModel] | None = None,
        prompt_resolver: Optional[PromptResolver] = None,
        tracing_config: TracingConfig | None = None,
        *args,
        **kwargs,
    ):
        assert llm, "llm must be provided."
        super().__init__(*args, **kwargs)

        self.llm = llm
        self.agent_config = agent_config
        self.config = agent_config.fast_agent
        self.max_steps = agent_config.max_steps
        self.vision = agent_config.fast_agent.vision
        self.debug = debug
        self.registry = registry
        self.action_ctx = action_ctx
        self.state_provider = state_provider
        self.save_trajectory = save_trajectory
        self.shared_state = shared_state
        self.output_model = output_model
        self.prompt_resolver = prompt_resolver or PromptResolver()
        self.tracing_config = tracing_config

        self.system_prompt: dict | None = None
        self.code_exec_counter = 0
        self.remembered_info: list[str] | None = None

        # Build tool_list for code executor from registry
        # Each tool is wrapped to pass ctx automatically
        self.tool_list = {}
        for tool_name, entry in self.registry.tools.items():
            func = entry.fn
            if inspect.iscoroutinefunction(func):

                async def async_wrapper(*a, f=func, ac=action_ctx, **kw):
                    return await f(*a, ctx=ac, **kw)

                self.tool_list[tool_name] = async_wrapper
            else:

                def sync_wrapper(*a, f=func, ac=action_ctx, **kw):
                    return f(*a, ctx=ac, **kw)

                self.tool_list[tool_name] = sync_wrapper

        # Build tool descriptions
        self.tool_descriptions = self.registry.get_tool_descriptions_text()

        self._available_secrets = []
        self._output_schema = None
        if self.output_model is not None:
            self._output_schema = self.output_model.model_json_schema()

        # Initialize code executor
        safe_mode = self.config.safe_execution
        safe_config = safe_execution_config

        self.executor = SimpleCodeExecutor(
            locals={},
            tools=self.tool_list,
            globals={"__builtins__": __builtins__},
            safe_mode=safe_mode,
            allowed_modules=(
                safe_config.get_allowed_modules() if safe_config and safe_mode else None
            ),
            blocked_modules=(
                safe_config.get_blocked_modules() if safe_config and safe_mode else None
            ),
            allowed_builtins=(
                safe_config.get_allowed_builtins()
                if safe_config and safe_mode
                else None
            ),
            blocked_builtins=(
                safe_config.get_blocked_builtins()
                if safe_config and safe_mode
                else None
            ),
            event_loop=None,
        )

        logger.debug("CodeActAgent initialized.")

    async def _build_system_prompt(self) -> dict:
        """Build system prompt message."""
        # Build template context with available tools for conditional examples
        template_context = {
            "tool_descriptions": self.tool_descriptions,
            "available_secrets": self._available_secrets,
            "available_tools": set(self.registry.tools.keys()),
            "variables": (
                self.shared_state.custom_variables if self.shared_state else {}
            ),
            "output_schema": self._output_schema,
        }

        custom_system_prompt = self.prompt_resolver.get_prompt("fast_agent_system")
        if custom_system_prompt:
            system_text = PromptLoader.render_template(
                custom_system_prompt,
                template_context,
            )
        else:
            # If config still points to tools template, use legacy codeact template
            prompt_path = self.agent_config.fast_agent.system_prompt
            if prompt_path == _TOOLS_SYSTEM_PROMPT:
                prompt_path = _LEGACY_SYSTEM_PROMPT
            system_text = await PromptLoader.load_prompt(
                str(PathResolver.resolve(prompt_path, must_exist=True)),
                template_context,
            )
        return {"role": "system", "content": [{"text": system_text}]}

    async def _build_user_prompt(self, goal: str) -> dict:
        """Build initial user prompt message."""
        custom_user_prompt = self.prompt_resolver.get_prompt("fast_agent_user")
        if custom_user_prompt:
            user_text = PromptLoader.render_template(
                custom_user_prompt,
                {
                    "goal": goal,
                    "variables": (
                        self.shared_state.custom_variables if self.shared_state else {}
                    ),
                },
            )
        else:
            # If config still points to tools template, use legacy codeact template
            prompt_path = self.agent_config.fast_agent.user_prompt
            if prompt_path == _TOOLS_USER_PROMPT:
                prompt_path = _LEGACY_USER_PROMPT
            user_text = await PromptLoader.load_prompt(
                str(PathResolver.resolve(prompt_path, must_exist=True)),
                {
                    "goal": goal,
                    "variables": (
                        self.shared_state.custom_variables if self.shared_state else {}
                    ),
                },
            )
        return {"role": "user", "content": [{"text": user_text}]}

    @step
    async def prepare_chat(self, ctx: Context, ev: StartEvent) -> CodeActInputEvent:
        """Initialize message history with goal."""
        logger.debug("Preparing chat for task execution...")

        # Get available secrets
        if self.action_ctx and self.action_ctx.credential_manager:
            self._available_secrets = (
                await self.action_ctx.credential_manager.get_keys()
            )

        # Build system prompt (lazy load)
        if self.system_prompt is None:
            self.system_prompt = await self._build_system_prompt()

        # Get goal and build user message
        user_input = ev.get("input", default=None)
        assert user_input, "User input cannot be empty."

        user_message = await self._build_user_prompt(user_input)
        self.shared_state.message_history.clear()
        self.shared_state.message_history.append(user_message)

        # Store remembered info if provided
        remembered_info = ev.get("remembered_info", default=None)
        if remembered_info:
            self.remembered_info = remembered_info
            memory_text = "\n### Remembered Information:\n"
            for idx, item in enumerate(remembered_info, 1):
                memory_text += f"{idx}. {item}\n"
            # Append to first user message
            self.shared_state.message_history[0]["content"].append(
                {"text": memory_text}
            )

        return CodeActInputEvent()

    @step
    async def handle_llm_input(
        self, ctx: Context, ev: CodeActInputEvent
    ) -> CodeActResponseEvent | CodeActEndEvent:
        """Get device state, call LLM, return response."""
        ctx.write_event_to_stream(ev)

        # Check then bump step counter
        if self.shared_state.step_number >= self.max_steps:
            event = CodeActEndEvent(
                success=False,
                reason=f"Reached max step count of {self.max_steps} steps",
                code_executions=self.code_exec_counter,
            )
            ctx.write_event_to_stream(event)
            return event

        self.shared_state.step_number += 1
        logger.info(f"üîÑ Step {self.shared_state.step_number}/{self.max_steps}")

        # Capture screenshot if needed
        screenshot = None
        if self.vision or self.save_trajectory != "none":
            try:
                screenshot = await self.action_ctx.driver.screenshot()

                if screenshot:
                    ctx.write_event_to_stream(ScreenshotEvent(screenshot=screenshot))
                    parent_span = trace.get_current_span()
                    record_langfuse_screenshot(
                        screenshot,
                        parent_span=parent_span,
                        screenshots_enabled=bool(
                            self.tracing_config
                            and self.tracing_config.langfuse_screenshots
                        ),
                        vision_enabled=self.vision,
                    )
                    await ctx.store.set("screenshot", screenshot)
                    logger.debug("üì∏ Screenshot captured for CodeAct")
            except DeviceDisconnectedError:
                raise
            except Exception as e:
                logger.warning(f"Failed to capture screenshot: {e}")

        # Get device state
        try:
            ui_state = await self.state_provider.get_state()
            self.action_ctx.ui = ui_state

            # Update shared state
            self.shared_state.formatted_device_state = ui_state.formatted_text
            self.shared_state.focused_text = ui_state.focused_text
            self.shared_state.a11y_tree = ui_state.elements
            self.shared_state.phone_state = ui_state.phone_state

            # Extract and store package/app name (using unified update method)
            self.shared_state.update_current_app(
                package_name=ui_state.phone_state.get("packageName", "Unknown"),
                activity_name=ui_state.phone_state.get("currentApp", "Unknown"),
            )

            # Stream formatted state for trajectory
            ctx.write_event_to_stream(RecordUIStateEvent(ui_state=ui_state.elements))

            # Add device state to last user message
            self.shared_state.message_history[-1]["content"].append(
                {"text": f"\n{ui_state.formatted_text}\n"}
            )

        except DeviceDisconnectedError:
            raise
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error retrieving state from the connected device: {e}")
            if self.debug:
                logger.error("State retrieval error details:", exc_info=True)

        # Add screenshot to message if vision enabled
        if self.vision and screenshot:
            self.shared_state.message_history[-1]["content"].append(
                {"image": screenshot}
            )

        # Limit history and prepare for LLM
        limited_history = limit_history(
            self.shared_state.message_history,
            LLM_HISTORY_LIMIT * 2,
            preserve_first=True,
        )

        # Build final messages: system + history
        messages_to_send = [self.system_prompt] + limited_history
        chat_messages = to_chat_messages(messages_to_send)

        # Call LLM
        logger.info("CodeAct response:", extra={"color": "yellow"})
        response = await acall_with_retries(
            self.llm, chat_messages, stream=self.agent_config.streaming
        )

        if response is None:
            return CodeActEndEvent(
                success=False,
                reason="LLM response is None. This is a critical error.",
                code_executions=self.code_exec_counter,
            )

        # Extract usage
        usage = None
        try:
            usage = get_usage_from_response(self.llm.class_name(), response)
        except Exception as e:
            logger.warning(f"Could not get usage: {e}")

        # Store assistant response
        response_text = response.message.content
        self.shared_state.message_history.append(
            {"role": "assistant", "content": [{"text": response_text}]}
        )

        # Extract thought and code
        code, thought = extract_code_and_thought(response_text)

        # Update unified state
        self.shared_state.last_thought = thought

        event = CodeActResponseEvent(thought=thought, code=code, usage=usage)
        ctx.write_event_to_stream(event)
        return event

    @step
    async def handle_llm_output(
        self, ctx: Context, ev: CodeActResponseEvent
    ) -> CodeActCodeEvent | CodeActInputEvent:
        """Route to execution or request code if missing."""
        if not ev.thought:
            logger.warning("LLM provided code without thoughts.")
            # Add reminder to get thoughts
            no_thoughts_text = (
                "Your previous response provided code without explaining your reasoning first. "
                "Remember to always describe your thought process and plan *before* providing the code block.\n\n"
                "The code you provided will be executed below.\n\n"
                "Now, describe the next step you will take to address the original goal."
            )
            self.shared_state.message_history.append(
                {"role": "user", "content": [{"text": no_thoughts_text}]}
            )
        else:
            logger.debug(f"Reasoning: {ev.thought}")

        if ev.code:
            event = CodeActCodeEvent(code=ev.code)
            ctx.write_event_to_stream(event)
            return event
        else:
            # No code - ask for it
            no_code_text = (
                "No code was provided. If you want to mark task as complete "
                "(whether it failed or succeeded), use complete(success: bool, reason: str) "
                "function within a <python></python> code block."
            )
            self.shared_state.message_history.append(
                {"role": "user", "content": [{"text": no_code_text}]}
            )
            return CodeActInputEvent()

    @step
    async def execute_code(
        self, ctx: Context, ev: CodeActCodeEvent
    ) -> CodeActOutputEvent | CodeActEndEvent:
        """Execute the code and return result."""
        code = ev.code
        logger.debug(f"Executing:\n<python>\n{code}\n</python>")

        try:
            self.code_exec_counter += 1
            result = await self.executor.execute(
                ExecuterState(ui_state=await ctx.store.get("ui_state", None)),
                code,
                timeout=self.config.execution_timeout,
            )
            logger.info("üí° Execution result:", extra={"color": "dim"})
            logger.info(f"{result}")
            await asyncio.sleep(self.agent_config.after_sleep_action)

            # Check if complete() was called
            if self.shared_state.finished:
                logger.debug("‚úÖ Task marked as complete via complete() function")

                # Validate completion state
                success = (
                    self.shared_state.success
                    if self.shared_state.success is not None
                    else False
                )
                reason = (
                    self.shared_state.answer
                    if self.shared_state.answer
                    else "Task completed without reason"
                )
                self.shared_state.finished = False

                event = CodeActEndEvent(
                    success=success,
                    reason=reason,
                    code_executions=self.code_exec_counter,
                )
                ctx.write_event_to_stream(event)
                return event

            # Update remembered info
            self.remembered_info = self.shared_state.fast_memory

            event = CodeActOutputEvent(output=str(result))
            ctx.write_event_to_stream(event)
            return event

        except Exception as e:
            logger.error(f"üí• Action failed: {e}")
            if self.debug:
                logger.error("Exception details:", exc_info=True)

            event = CodeActOutputEvent(output=f"Error during execution: {e}")
            ctx.write_event_to_stream(event)
            return event

    @step
    async def handle_execution_result(
        self, ctx: Context, ev: CodeActOutputEvent
    ) -> CodeActInputEvent:
        """Add execution result to history and loop back."""
        output = ev.output or "Code executed, but produced no output."

        # Add execution output as user message
        observation_text = f"Execution Result:\n<result>\n{output}\n</result>"
        self.shared_state.message_history.append(
            {"role": "user", "content": [{"text": observation_text}]}
        )

        return CodeActInputEvent()

    @step
    async def finalize(self, ev: CodeActEndEvent, ctx: Context) -> StopEvent:
        self.shared_state.finished = False
        ctx.write_event_to_stream(ev)

        return StopEvent(
            result={
                "success": ev.success,
                "reason": ev.reason,
                "code_executions": ev.code_executions,
            }
        )

```

`droidrun/agent/codeact/events.py`:

```py
"""
Events for the CodeActAgent workflow.

Internal events for streaming to frontend/logging.
"""

from typing import Optional

from llama_index.core.workflow import Event

from droidrun.agent.usage import UsageResult


class CodeActInputEvent(Event):
    """Input ready for LLM."""

    pass


class CodeActResponseEvent(Event):
    """LLM response received."""

    thought: str
    code: Optional[str] = None
    usage: Optional[UsageResult] = None


class CodeActCodeEvent(Event):
    """Code ready to execute (internal event)."""

    code: str


class CodeActOutputEvent(Event):
    """Code execution result (internal event)."""

    output: str


class CodeActEndEvent(Event):
    """CodeAct finished."""

    success: bool
    reason: str
    code_executions: int = 0


# ============================================================================
# FastAgent events (used by ToolsAgent / FastAgent)
# ============================================================================


class FastAgentInputEvent(Event):
    """Input ready for LLM."""

    pass


class FastAgentResponseEvent(Event):
    """LLM response received."""

    thought: str
    code: Optional[str] = None
    usage: Optional[UsageResult] = None


class FastAgentToolCallEvent(Event):
    """Tool calls ready to execute."""

    tool_calls_repr: str


class FastAgentOutputEvent(Event):
    """Tool execution result."""

    output: str


class FastAgentEndEvent(Event):
    """FastAgent finished."""

    success: bool
    reason: str
    tool_call_count: int = 0

```

`droidrun/agent/codeact/tools_agent.py`:

```py
"""ToolsAgent ‚Äî XML tool-calling agent for device interaction.

Replaces CodeActAgent's Python code generation + exec() with a structured
XML tool-calling protocol. The LLM emits <function_calls> blocks, the agent
parses them, executes the tools, and feeds <function_results> back.

Uses the same event system and workflow structure as CodeActAgent for
compatibility with DroidAgent's execute_task() method.
"""

import asyncio
import logging
import os
from typing import TYPE_CHECKING, Optional, Type

from llama_index.core.llms.llm import LLM
from llama_index.core.workflow import Context, StartEvent, StopEvent, Workflow, step
from opentelemetry import trace
from pydantic import BaseModel

from droidrun.agent.action_result import ActionResult
from droidrun.agent.codeact.events import (
    FastAgentEndEvent,
    FastAgentInputEvent,
    FastAgentOutputEvent,
    FastAgentResponseEvent,
    FastAgentToolCallEvent,
)
from droidrun.agent.codeact.xml_parser import (
    CLOSE_TAG,
    OPEN_TAG,
    ToolResult,
    format_tool_results,
    parse_tool_calls,
)
from droidrun.agent.common.constants import LLM_HISTORY_LIMIT
from droidrun.agent.common.events import RecordUIStateEvent, ScreenshotEvent
from droidrun.agent.usage import get_usage_from_response
from droidrun.agent.utils.chat_utils import limit_history, to_chat_messages
from droidrun.agent.utils.inference import acall_with_retries
from droidrun.agent.utils.prompt_resolver import PromptResolver
from droidrun.agent.utils.tracing_setup import record_langfuse_screenshot
from droidrun.config_manager.config_manager import AgentConfig, TracingConfig
from droidrun.config_manager.prompt_loader import PromptLoader
from droidrun.tools.driver.base import DeviceDisconnectedError

if TYPE_CHECKING:
    from droidrun.agent.action_context import ActionContext
    from droidrun.agent.droid import DroidAgentState
    from droidrun.agent.tool_registry import ToolRegistry
    from droidrun.tools.ui.provider import StateProvider

logger = logging.getLogger("droidrun")


class FastAgent(Workflow):
    """Agent that uses XML tool-calling instead of code generation.

    Uses ReAct cycle: Thought -> Tool Call -> Observation -> repeat until complete().
    Messages stored as list[dict], converted to ChatMessage only for LLM calls.
    """

    def __init__(
        self,
        llm: LLM,
        agent_config: AgentConfig,
        registry: "ToolRegistry",
        action_ctx: "ActionContext",
        state_provider: "StateProvider",
        save_trajectory: str = "none",
        debug: bool = False,
        shared_state: Optional["DroidAgentState"] = None,
        output_model: Type[BaseModel] | None = None,
        prompt_resolver: Optional[PromptResolver] = None,
        tracing_config: TracingConfig | None = None,
        *args,
        **kwargs,
    ):
        assert llm, "llm must be provided."
        super().__init__(*args, **kwargs)

        self.llm = llm
        self.agent_config = agent_config
        self.config = agent_config.fast_agent
        self.max_steps = agent_config.max_steps
        self.vision = agent_config.fast_agent.vision
        self.debug = debug
        self.registry = registry
        self.action_ctx = action_ctx
        self.state_provider = state_provider
        self.save_trajectory = save_trajectory
        self._stream_screenshots = os.environ.get(
            "DROIDRUN_STREAM_SCREENSHOTS", ""
        ).lower() in ("1", "true")
        self.shared_state = shared_state
        self.output_model = output_model
        self.prompt_resolver = prompt_resolver or PromptResolver()
        self.tracing_config = tracing_config

        self.system_prompt: dict | None = None
        self.tool_call_counter = 0
        self.remembered_info: list[str] | None = None

        # Build tool descriptions and param types from registry
        self.tool_descriptions = self.registry.get_tool_descriptions_xml()
        self.param_types = self.registry.get_param_types()

        self._available_secrets = []
        self._output_schema = None
        if self.output_model is not None:
            self._output_schema = self.output_model.model_json_schema()

        logger.debug("FastAgent initialized.")

    async def _build_system_prompt(self) -> dict:
        """Build system prompt message."""
        template_context = {
            "tool_descriptions": self.tool_descriptions,
            "available_secrets": self._available_secrets,
            "available_tools": set(self.registry.tools.keys()),
            "variables": (
                self.shared_state.custom_variables if self.shared_state else {}
            ),
            "output_schema": self._output_schema,
            "parallel_tools": self.config.parallel_tools,
            "vision": self.vision,
        }

        custom_system_prompt = self.prompt_resolver.get_prompt("fast_agent_system")
        if custom_system_prompt:
            system_text = PromptLoader.render_template(
                custom_system_prompt,
                template_context,
            )
        else:
            system_text = await PromptLoader.load_prompt(
                self.agent_config.get_fast_agent_system_prompt_path(),
                template_context,
            )
        return {"role": "system", "content": [{"text": system_text}]}

    async def _build_user_prompt(self, goal: str) -> dict:
        """Build initial user prompt message."""
        custom_user_prompt = self.prompt_resolver.get_prompt("fast_agent_user")
        if custom_user_prompt:
            user_text = PromptLoader.render_template(
                custom_user_prompt,
                {
                    "goal": goal,
                    "variables": (
                        self.shared_state.custom_variables if self.shared_state else {}
                    ),
                },
            )
        else:
            user_text = await PromptLoader.load_prompt(
                self.agent_config.get_fast_agent_user_prompt_path(),
                {
                    "goal": goal,
                    "variables": (
                        self.shared_state.custom_variables if self.shared_state else {}
                    ),
                },
            )
        return {"role": "user", "content": [{"text": user_text}]}

    @step
    async def prepare_chat(self, ctx: Context, ev: StartEvent) -> FastAgentInputEvent:
        """Initialize message history with goal."""
        logger.debug("Preparing chat for task execution...")

        # Get available secrets
        if self.action_ctx and self.action_ctx.credential_manager:
            self._available_secrets = (
                await self.action_ctx.credential_manager.get_keys()
            )

        # Build system prompt (lazy load)
        if self.system_prompt is None:
            self.system_prompt = await self._build_system_prompt()

        # Get goal and build user message
        user_input = ev.get("input", default=None)
        assert user_input, "User input cannot be empty."

        user_message = await self._build_user_prompt(user_input)
        self.shared_state.message_history.clear()
        self.shared_state.message_history.append(user_message)

        # Store remembered info if provided
        remembered_info = ev.get("remembered_info", default=None)
        if remembered_info:
            self.remembered_info = remembered_info
            memory_text = "\n### Remembered Information:\n"
            for idx, item in enumerate(remembered_info, 1):
                memory_text += f"{idx}. {item}\n"
            self.shared_state.message_history[0]["content"].append(
                {"text": memory_text}
            )

        return FastAgentInputEvent()

    @step
    async def handle_llm_input(
        self, ctx: Context, ev: FastAgentInputEvent
    ) -> FastAgentResponseEvent | FastAgentEndEvent:
        """Get device state, call LLM, return response."""
        ctx.write_event_to_stream(ev)

        # Check then bump step counter
        if self.shared_state.step_number >= self.max_steps:
            event = FastAgentEndEvent(
                success=False,
                reason=f"Reached max step count of {self.max_steps} steps",
                tool_call_count=self.tool_call_counter,
            )
            ctx.write_event_to_stream(event)
            return event

        self.shared_state.step_number += 1
        logger.info(f"üîÑ Step {self.shared_state.step_number}/{self.max_steps}")

        # Capture screenshot if needed
        screenshot = None
        if self.vision or self._stream_screenshots or self.save_trajectory != "none":
            try:
                screenshot = await self.action_ctx.driver.screenshot()

                if screenshot:
                    ctx.write_event_to_stream(ScreenshotEvent(screenshot=screenshot))
                    parent_span = trace.get_current_span()
                    record_langfuse_screenshot(
                        screenshot,
                        parent_span=parent_span,
                        screenshots_enabled=bool(
                            self.tracing_config
                            and self.tracing_config.langfuse_screenshots
                        ),
                        vision_enabled=self.vision,
                    )
                    await ctx.store.set("screenshot", screenshot)
                    logger.debug("üì∏ Screenshot captured for FastAgent")
            except DeviceDisconnectedError:
                raise
            except Exception as e:
                logger.warning(f"Failed to capture screenshot: {e}")

        # Get device state
        try:
            ui_state = await self.state_provider.get_state()
            self.action_ctx.ui = ui_state

            # Update shared state
            self.shared_state.formatted_device_state = ui_state.formatted_text
            self.shared_state.focused_text = ui_state.focused_text
            self.shared_state.a11y_tree = ui_state.elements
            self.shared_state.phone_state = ui_state.phone_state

            # Extract and store package/app name
            self.shared_state.update_current_app(
                package_name=ui_state.phone_state.get("packageName", "Unknown"),
                activity_name=ui_state.phone_state.get("currentApp", "Unknown"),
            )

            # Stream formatted state for trajectory
            ctx.write_event_to_stream(RecordUIStateEvent(ui_state=ui_state.elements))

            # Add device state to last user message
            self.shared_state.message_history[-1]["content"].append(
                {"text": f"\n{ui_state.formatted_text}\n"}
            )

        except DeviceDisconnectedError:
            raise
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error retrieving state from the connected device: {e}")
            if self.debug:
                logger.error("State retrieval error details:", exc_info=True)

        # Add screenshot to message if vision enabled
        if self.vision and screenshot:
            self.shared_state.message_history[-1]["content"].append(
                {"image": screenshot}
            )

        # Limit history and prepare for LLM
        limited_history = limit_history(
            self.shared_state.message_history,
            LLM_HISTORY_LIMIT * 2,
            preserve_first=True,
        )

        # Build final messages: system + history
        messages_to_send = [self.system_prompt] + limited_history
        chat_messages = to_chat_messages(messages_to_send)

        # Call LLM
        logger.info("FastAgent response:", extra={"color": "yellow"})
        response = await acall_with_retries(
            self.llm, chat_messages, stream=self.agent_config.streaming
        )

        if response is None:
            return FastAgentEndEvent(
                success=False,
                reason="LLM response is None. This is a critical error.",
                tool_call_count=self.tool_call_counter,
            )

        # Extract usage
        usage = None
        try:
            usage = get_usage_from_response(self.llm.class_name(), response)
        except Exception as e:
            logger.warning(f"Could not get usage: {e}")

        # Store assistant response
        response_text = response.message.content
        self.shared_state.message_history.append(
            {"role": "assistant", "content": [{"text": response_text}]}
        )

        # Parse tool calls from response
        thought, tool_calls = parse_tool_calls(response_text, self.param_types)

        # Extract just the <function_calls> blocks for the event
        tool_calls_xml = None
        if tool_calls:
            blocks = []
            for part in response_text.split(OPEN_TAG)[1:]:
                close_idx = part.find(CLOSE_TAG)
                if close_idx != -1:
                    blocks.append(OPEN_TAG + part[: close_idx + len(CLOSE_TAG)])
            tool_calls_xml = "\n".join(blocks) if blocks else None

        # Store tool calls in context for execute step (avoid re-parsing)
        if tool_calls:
            await ctx.store.set("pending_tool_calls", tool_calls)

        # Update unified state
        self.shared_state.last_thought = thought

        event = FastAgentResponseEvent(
            thought=thought,
            code=tool_calls_xml,
            usage=usage,
        )
        ctx.write_event_to_stream(event)
        return event

    @step
    async def handle_llm_output(
        self, ctx: Context, ev: FastAgentResponseEvent
    ) -> FastAgentToolCallEvent | FastAgentInputEvent:
        """Route to execution or request tool call if missing."""
        has_tool_calls = ev.code is not None

        if not ev.thought:
            logger.warning("LLM provided tool calls without reasoning.")
            no_thoughts_text = (
                "Your previous response called tools without explaining your reasoning first. "
                "Remember to always describe your thought process and plan *before* calling tools.\n\n"
                "The tool calls you made will be executed below.\n\n"
                "Now, describe the next step you will take to address the original goal."
            )
            self.shared_state.message_history.append(
                {"role": "user", "content": [{"text": no_thoughts_text}]}
            )
        else:
            logger.debug(f"Reasoning: {ev.thought}")

        if has_tool_calls:
            event = FastAgentToolCallEvent(tool_calls_repr=ev.code)
            ctx.write_event_to_stream(event)
            return event
        else:
            # No tool calls ‚Äî ask for them
            no_tools_text = (
                "No tool calls were provided. If you want to mark the task as complete "
                "(whether it failed or succeeded), use the `complete` tool:\n\n"
                "<function_calls>\n"
                '<invoke name="complete">\n'
                '<parameter name="success">true</parameter>\n'
                '<parameter name="message">Explanation here</parameter>\n'
                "</invoke>\n"
                "</function_calls>"
            )
            self.shared_state.message_history.append(
                {"role": "user", "content": [{"text": no_tools_text}]}
            )
            return FastAgentInputEvent()

    @step
    async def execute_code(
        self, ctx: Context, ev: FastAgentToolCallEvent
    ) -> FastAgentOutputEvent | FastAgentEndEvent:
        """Execute parsed tool calls and return results."""
        tool_calls = await ctx.store.get("pending_tool_calls", [])

        if not tool_calls:
            event = FastAgentOutputEvent(output="No tool calls to execute.")
            ctx.write_event_to_stream(event)
            return event

        results: list[ToolResult] = []

        for call in tool_calls:
            logger.debug(f"Executing: {call.name}({call.parameters})")
            self.tool_call_counter += 1

            # Skip execution if parsing failed
            if call.error:
                action_result = ActionResult(
                    success=False,
                    summary=f"Invalid arguments for {call.name}: {call.error}",
                )
            else:
                # Dispatch via registry
                action_result = await self.registry.execute(
                    call.name, call.parameters, self.action_ctx, workflow_ctx=ctx
                )
            results.append(
                ToolResult(
                    name=call.name,
                    output=action_result.summary,
                    is_error=not action_result.success,
                )
            )

            # Check if complete() was called successfully
            if self.shared_state.finished:
                logger.debug("‚úÖ Task marked as complete via complete() tool")

                success = (
                    self.shared_state.success
                    if self.shared_state.success is not None
                    else False
                )
                reason = (
                    self.shared_state.answer
                    if self.shared_state.answer
                    else "Task completed without reason"
                )
                self.shared_state.finished = False

                event = FastAgentEndEvent(
                    success=success,
                    reason=reason,
                    tool_call_count=self.tool_call_counter,
                )
                ctx.write_event_to_stream(event)
                return event

        # Format results
        results_xml = format_tool_results(results)
        logger.info("üí° Tool results:", extra={"color": "dim"})
        logger.info(f"{results_xml}")
        await asyncio.sleep(self.agent_config.after_sleep_action)

        # Update remembered info
        self.remembered_info = self.shared_state.fast_memory

        event = FastAgentOutputEvent(output=results_xml)
        ctx.write_event_to_stream(event)
        return event

    @step
    async def handle_execution_result(
        self, ctx: Context, ev: FastAgentOutputEvent
    ) -> FastAgentInputEvent:
        """Add execution result to history and loop back."""
        output = ev.output or "Tool executed, but produced no output."

        # Add results as user message
        self.shared_state.message_history.append(
            {"role": "user", "content": [{"text": output}]}
        )

        return FastAgentInputEvent()

    @step
    async def finalize(self, ev: FastAgentEndEvent, ctx: Context) -> StopEvent:
        self.shared_state.finished = False
        ctx.write_event_to_stream(ev)

        return StopEvent(
            result={
                "success": ev.success,
                "reason": ev.reason,
                "tool_call_count": ev.tool_call_count,
            }
        )

```

`droidrun/agent/codeact/xml_parser.py`:

```py
"""XML tool-call parsing and result formatting.

Parses LLM responses containing <function_calls> blocks into structured
ToolCall objects, and formats tool results as <function_results> XML
for injection back into the conversation.
"""

import json
import logging
import re
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

logger = logging.getLogger("droidrun")

OPEN_TAG = "<function_calls>"
CLOSE_TAG = "</function_calls>"

_PARAM_RE = re.compile(
    r'(<parameter\s+name="[^"]*">)(.*?)(</parameter>)',
    re.DOTALL,
)


@dataclass
class ToolCall:
    """A parsed tool invocation from the LLM response."""

    name: str
    parameters: Dict[str, Any] = field(default_factory=dict)
    error: Optional[str] = None


@dataclass
class ToolResult:
    """Result from executing a single tool."""

    name: str
    output: str
    is_error: bool = False


def parse_tool_calls(
    text: str, param_types: Optional[Dict[str, str]] = None
) -> Tuple[str, List[ToolCall]]:
    """Parse tool calls from LLM response text.

    Args:
        text: Raw LLM response text.
        param_types: Optional {param_name: type_string} map for coercion.
                     If None, all values are kept as strings.

    Returns:
        Tuple of (text_before_tool_calls, list_of_tool_calls).
        If no tool calls found, returns (full_text, []).
    """
    if OPEN_TAG not in text:
        return text.strip(), []

    parts = text.split(OPEN_TAG)
    text_before = parts[0].strip()

    calls: List[ToolCall] = []
    for part in parts[1:]:
        close_idx = part.find(CLOSE_TAG)
        if close_idx == -1:
            continue  # Malformed ‚Äî no closing tag, skip

        block = part[:close_idx].strip()
        if not block:
            continue

        block = _sanitize_param_content(block)

        try:
            root = ET.fromstring(f"<root>{block}</root>")
        except ET.ParseError:
            logger.warning("Failed to parse tool call XML block, skipping")
            continue

        for invoke in root.findall("invoke"):
            name = invoke.get("name", "")
            if not name:
                continue

            params: Dict[str, Any] = {}
            error: Optional[str] = None
            for param in invoke.findall("parameter"):
                param_name = param.get("name", "")
                param_value = param.text or ""
                if param_name:
                    try:
                        params[param_name] = _coerce_param(
                            param_name, param_value, param_types
                        )
                    except ValueError as e:
                        error = str(e)
                        break

            calls.append(ToolCall(name=name, parameters=params, error=error))

    return text_before, calls


def format_tool_results(results: List[ToolResult]) -> str:
    """Format tool results as XML for injection into conversation.

    Args:
        results: List of tool results to format.

    Returns:
        XML string with <function_results> wrapper.
    """
    lines = ["<function_results>"]

    for result in results:
        if result.is_error:
            lines.append(
                f"<result>\n<name>{result.name}</name>\n"
                f"<error>{result.output}</error>\n</result>"
            )
        else:
            lines.append(
                f"<result>\n<name>{result.name}</name>\n"
                f"<output>{result.output}</output>\n</result>"
            )

    lines.append("</function_results>")
    return "\n".join(lines)


def _sanitize_param_content(block: str) -> str:
    """Escape XML-unsafe characters inside parameter values.

    Parameter values often contain raw code or text with <, >, &
    which would break XML parsing. This escapes content inside
    <parameter> tags only, leaving the XML structure intact.
    """

    def _escape(m: re.Match) -> str:
        pre, content, post = m.group(1), m.group(2), m.group(3)
        clean = content.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
        return pre + clean + post

    return _PARAM_RE.sub(_escape, block)


def _coerce_param(
    name: str, value: str, param_types: Optional[Dict[str, str]] = None
) -> Any:
    """Coerce string parameter value to expected type.

    Args:
        name: Parameter name.
        value: Raw string value from XML.
        param_types: Optional type map. If None, returns value as-is.
    """
    if param_types is None:
        return value

    expected = param_types.get(name, "string")

    if expected == "boolean":
        return value.strip().lower() == "true"

    if expected == "number":
        value = value.strip()
        try:
            return int(value)
        except ValueError:
            try:
                return float(value)
            except ValueError:
                raise ValueError(f"parameter '{name}' expected number, got '{value}'")

    if expected == "list":
        value = value.strip()
        try:
            parsed = json.loads(value)
            if isinstance(parsed, list):
                return parsed
            return [parsed]  # Single element ‚Äî wrap in list
        except (json.JSONDecodeError, ValueError):
            raise ValueError(f"parameter '{name}' expected list, got '{value}'")

    return value

```

`droidrun/agent/common/constants.py`:

```py
"""Max number of recent conversation steps to include in LLM prompt"""

LLM_HISTORY_LIMIT = 100

```

`droidrun/agent/common/events.py`:

```py
from typing import Any, Dict

from llama_index.core.workflow import Event


class ScreenshotEvent(Event):
    screenshot: bytes


class RecordUIStateEvent(Event):
    ui_state: list[Dict[str, Any]]


class ToolExecutionEvent(Event):
    """Emitted after every tool call dispatched through ToolRegistry."""

    tool_name: str
    tool_args: Dict[str, Any]
    success: bool
    summary: str

```

`droidrun/agent/droid/__init__.py`:

```py
"""
Droidrun Agent Module.

This module provides a ReAct agent for automating Android devices using reasoning and acting.
"""

from droidrun.agent.droid.droid_agent import DroidAgent
from droidrun.agent.droid.state import DroidAgentState

__all__ = ["DroidAgent", "DroidAgentState"]

```

`droidrun/agent/droid/droid_agent.py`:

```py
"""
DroidAgent - A wrapper class that coordinates the planning and execution of tasks
to achieve a user's goal on an Android device.

Architecture:
- When reasoning=False: Uses CodeActAgent directly
- When reasoning=True: Uses Manager (planning) + Executor (action) workflows
"""

import logging
import os
import traceback
from typing import TYPE_CHECKING, Awaitable, Type, Union

from async_adbutils import adb
from llama_index.core.llms.llm import LLM
from llama_index.core.workflow import Context, StartEvent, StopEvent, Workflow, step
from opentelemetry import trace
from pydantic import BaseModel
from workflows.events import Event
from workflows.handler import WorkflowHandler

from droidrun.agent.action_context import ActionContext
from droidrun.agent.codeact import CodeActAgent, FastAgent
from droidrun.agent.codeact.events import CodeActOutputEvent, FastAgentOutputEvent
from droidrun.agent.common.events import RecordUIStateEvent, ScreenshotEvent
from droidrun.agent.droid.events import (
    ExecutorInputEvent,
    ExecutorResultEvent,
    FastAgentExecuteEvent,
    FastAgentResultEvent,
    FinalizeEvent,
    ManagerInputEvent,
    ManagerPlanEvent,
    ResultEvent,
    ScripterExecutorInputEvent,
    ScripterExecutorResultEvent,
    TextManipulatorInputEvent,
    TextManipulatorResultEvent,
)
from droidrun.agent.droid.state import DroidAgentState
from droidrun.agent.executor import ExecutorAgent
from droidrun.agent.external import load_agent
from droidrun.agent.manager import ManagerAgent, StatelessManagerAgent
from droidrun.agent.oneflows.structured_output_agent import StructuredOutputAgent
from droidrun.agent.oneflows.text_manipulator import run_text_manipulation_agent
from droidrun.agent.scripter import ScripterAgent
from droidrun.agent.tool_registry import ToolRegistry
from droidrun.agent.trajectory import TrajectoryWriter
from droidrun.agent.utils.actions import complete, open_app, remember
from droidrun.agent.utils.llm_loader import (
    load_agent_llms,
    merge_llms_with_config,
)
from droidrun.agent.utils.prompt_resolver import PromptResolver
from droidrun.agent.utils.signatures import (
    ATOMIC_ACTION_SIGNATURES,
    build_credential_tools,
)
from droidrun.agent.utils.tracing_setup import (
    apply_session_context,
    record_langfuse_screenshot,
    setup_tracing,
)
from droidrun.agent.utils.trajectory import Trajectory
from droidrun.config_manager.config_manager import (
    AgentConfig,
    CredentialsConfig,
    DeviceConfig,
    DroidrunConfig,
    LoggingConfig,
    TelemetryConfig,
    ToolsConfig,
    TracingConfig,
)
from droidrun.config_manager.safe_execution import SafeExecutionConfig
from droidrun.credential_manager import CredentialManager, FileCredentialManager
from droidrun.log_handlers import CLILogHandler, configure_logging
from droidrun.mcp.adapter import mcp_to_droidrun_tools
from droidrun.mcp.client import MCPClientManager
from droidrun.mcp.config import MCPConfig
from droidrun.telemetry import (
    DroidAgentFinalizeEvent,
    DroidAgentInitEvent,
    capture,
    flush,
)
from droidrun.tools.driver.android import AndroidDriver
from droidrun.tools.driver.base import DeviceDisconnectedError
from droidrun.tools.driver.ios import IOSDriver
from droidrun.tools.driver.recording import RecordingDriver
from droidrun.tools.driver.stealth import StealthDriver
from droidrun.tools.filters import ConciseFilter, DetailedFilter
from droidrun.tools.formatters import IndexedFormatter
from droidrun.tools.ui.ios_provider import IOSStateProvider
from droidrun.tools.ui.provider import AndroidStateProvider

if TYPE_CHECKING:
    from droidrun.tools.driver.base import DeviceDriver
    from droidrun.tools.ui.provider import StateProvider

logger = logging.getLogger("droidrun")


class DroidAgent(Workflow):
    """
    A wrapper class that coordinates between agents to achieve a user's goal.

    Reasoning modes:
    - reasoning=False: Uses CodeActAgent directly for immediate execution
    - reasoning=True: Uses ManagerAgent (planning) + ExecutorAgent (actions)
    """

    @staticmethod
    def _configure_default_logging(debug: bool = False):
        """
        Configure default logging for DroidAgent if no real handler is present.
        """
        has_real_handler = any(
            not isinstance(h, logging.NullHandler) for h in logger.handlers
        )
        if not has_real_handler:
            handler = CLILogHandler()
            handler.setFormatter(
                logging.Formatter("%(asctime)s %(levelname)s: %(message)s", "%H:%M:%S")
                if debug
                else logging.Formatter("%(message)s")
            )
            configure_logging(debug=debug, handler=handler)

    def __init__(
        self,
        goal: str,
        config: DroidrunConfig | None = None,
        llms: dict[str, LLM] | LLM | None = None,
        custom_tools: dict = None,
        credentials: Union[dict, "CredentialManager", None] = None,
        variables: dict | None = None,
        output_model: Type[BaseModel] | None = None,
        prompts: dict[str, str] | None = None,
        driver: "DeviceDriver | None" = None,
        state_provider: "StateProvider | None" = None,
        timeout: int = 1000,
        *args,
        **kwargs,
    ):
        self.user_id = kwargs.pop("user_id", None)
        self.runtype = kwargs.pop("runtype", "developer")
        self.shared_state = DroidAgentState(
            instruction=goal,
            err_to_manager_thresh=2,
            user_id=self.user_id,
            runtype=self.runtype,
        )
        self.output_model = output_model

        # Initialize prompt resolver for custom prompts
        self.prompt_resolver = PromptResolver(custom_prompts=prompts)

        # Store custom variables in shared state
        if variables:
            self.shared_state.custom_variables = variables

        # Load credential manager (supports both config and direct dict)
        credentials_source = (
            credentials
            if credentials is not None
            else (config.credentials if config else None)
        )

        if isinstance(credentials_source, CredentialManager):
            self.credential_manager = credentials_source
        elif credentials_source is not None:
            cm = FileCredentialManager(credentials_source)
            self.credential_manager = cm if cm.secrets else None
        else:
            self.credential_manager = None

        self.resolved_device_config = config.device if config else DeviceConfig()

        self.config = DroidrunConfig(
            agent=config.agent if config else AgentConfig(),
            device=self.resolved_device_config,
            tools=config.tools if config else ToolsConfig(),
            logging=config.logging if config else LoggingConfig(),
            tracing=config.tracing if config else TracingConfig(),
            telemetry=config.telemetry if config else TelemetryConfig(),
            llm_profiles=config.llm_profiles if config else {},
            credentials=config.credentials if config else CredentialsConfig(),
            safe_execution=config.safe_execution if config else SafeExecutionConfig(),
            external_agents=config.external_agents if config else {},
            mcp=config.mcp if config else MCPConfig(),
        )

        # These are populated in start_handler (unless injected via __init__)
        self._injected_driver = driver
        self._injected_state_provider = state_provider
        self.driver = None
        self.registry = None
        self.action_ctx = None
        self.state_provider = None

        super().__init__(*args, timeout=timeout, **kwargs)

        self._configure_default_logging(debug=self.config.logging.debug)

        setup_tracing(self.config.tracing, agent=self)

        # Check if using external agent - skip LLM loading
        self._using_external_agent = self.config.agent.name != "droidrun"

        self._stream_screenshots = os.environ.get(
            "DROIDRUN_STREAM_SCREENSHOTS", ""
        ).lower() in ("1", "true")

        self.timeout = timeout

        # Store user custom tools
        self.user_custom_tools = custom_tools or {}

        # Initialize MCP manager (connections made lazily in start_handler)
        self.mcp_manager = None

        # Only load LLMs for native DroidRun agents
        if not self._using_external_agent:
            if llms is None:
                if config is None:
                    raise ValueError(
                        "Either 'llms' or 'config' must be provided. "
                        "If llms is not provided, config is required to load LLMs from profiles."
                    )

                logger.debug("üîÑ Loading LLMs from config (llms not provided)...")

                llms = load_agent_llms(
                    config=self.config, output_model=output_model, **kwargs
                )
            if isinstance(llms, dict):
                llms = merge_llms_with_config(
                    self.config, llms, output_model=output_model, **kwargs
                )
            elif isinstance(llms, LLM):
                pass
            else:
                raise ValueError(f"Invalid LLM type: {type(llms)}")

            if isinstance(llms, dict):
                self.manager_llm = llms.get("manager")
                self.executor_llm = llms.get("executor")
                self.fast_agent_llm = llms.get("fast_agent")
                self.text_manipulator_llm = llms.get("text_manipulator")
                self.app_opener_llm = llms.get("app_opener")
                self.scripter_llm = llms.get("scripter", self.fast_agent_llm)
                self.structured_output_llm = llms.get(
                    "structured_output", self.fast_agent_llm
                )
            else:
                self.manager_llm = llms
                self.executor_llm = llms
                self.fast_agent_llm = llms
                self.text_manipulator_llm = llms
                self.app_opener_llm = llms
                self.scripter_llm = llms
                self.structured_output_llm = llms
        else:
            logger.debug(f"üîÑ Using external agent: {self.config.agent.name}")
            self.manager_llm = None
            self.executor_llm = None
            self.fast_agent_llm = None
            self.text_manipulator_llm = None
            self.app_opener_llm = None
            self.scripter_llm = None
            self.structured_output_llm = None

        if self.config.logging.save_trajectory != "none":
            self.trajectory = Trajectory(
                goal=self.shared_state.instruction,
                base_path=self.config.logging.trajectory_path,
            )
            self.trajectory_writer = TrajectoryWriter(queue_size=300)
        else:
            self.trajectory = None
            self.trajectory_writer = None

        # Sub-agents are created in __init__ but wired up in start_handler
        if self._using_external_agent:
            self.manager_agent = None
            self.executor_agent = None
        elif self.config.agent.reasoning:
            if self.config.agent.manager.stateless:
                ManagerClass = StatelessManagerAgent
            else:
                ManagerClass = ManagerAgent

            # Pass None for tools-related params ‚Äî wired up in start_handler
            self.manager_agent = ManagerClass(
                llm=self.manager_llm,
                action_ctx=None,
                state_provider=None,
                save_trajectory=self.config.logging.save_trajectory,
                shared_state=self.shared_state,
                agent_config=self.config.agent,
                registry=None,
                output_model=self.output_model,
                prompt_resolver=self.prompt_resolver,
                tracing_config=self.config.tracing,
                timeout=self.timeout,
            )
            self.executor_agent = ExecutorAgent(
                llm=self.executor_llm,
                registry=None,
                action_ctx=None,
                shared_state=self.shared_state,
                agent_config=self.config.agent,
                prompt_resolver=self.prompt_resolver,
                timeout=self.timeout,
            )
        else:
            self.manager_agent = None
            self.executor_agent = None

        atomic_tools = list(ATOMIC_ACTION_SIGNATURES.keys())

        capture(
            DroidAgentInitEvent(
                goal=self.shared_state.instruction,
                llms={
                    "manager": (
                        self.manager_llm.class_name() if self.manager_llm else "None"
                    ),
                    "executor": (
                        self.executor_llm.class_name() if self.executor_llm else "None"
                    ),
                    "fast_agent": (
                        self.fast_agent_llm.class_name()
                        if self.fast_agent_llm
                        else "None"
                    ),
                    "text_manipulator": (
                        self.text_manipulator_llm.class_name()
                        if self.text_manipulator_llm
                        else "None"
                    ),
                    "app_opener": (
                        self.app_opener_llm.class_name()
                        if self.app_opener_llm
                        else "None"
                    ),
                },
                tools=",".join(atomic_tools + ["remember", "complete"]),
                max_steps=self.config.agent.max_steps,
                timeout=timeout,
                vision={
                    "manager": self.config.agent.manager.vision,
                    "executor": self.config.agent.executor.vision,
                    "fast_agent": self.config.agent.fast_agent.vision,
                },
                reasoning=self.config.agent.reasoning,
                enable_tracing=self.config.tracing.enabled,
                debug=self.config.logging.debug,
                save_trajectories=self.config.logging.save_trajectory,
                runtype=self.runtype,
                custom_prompts=prompts,
            ),
            self.user_id,
        )

        logger.debug("‚úÖ DroidAgent initialized successfully.")

    def run(self, *args, **kwargs) -> Awaitable[ResultEvent] | WorkflowHandler:
        apply_session_context()
        handler = super().run(*args, **kwargs)  # type: ignore[assignment]
        return handler

    # ========================================================================
    # start_handler ‚Äî creates driver, registry, action_ctx
    # ========================================================================

    @step
    async def start_handler(
        self, ctx: Context, ev: StartEvent
    ) -> FastAgentExecuteEvent | ManagerInputEvent:
        logger.info(
            f"üöÄ Running DroidAgent to achieve goal: {self.shared_state.instruction}"
        )
        ctx.write_event_to_stream(ev)

        if self.trajectory_writer:
            await self.trajectory_writer.start()

        # ‚îÄ‚îÄ 1. Create driver ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self.config.agent.reasoning:
            vision_enabled = self.config.agent.manager.vision
        else:
            vision_enabled = self.config.agent.fast_agent.vision

        is_ios = self.resolved_device_config.platform.lower() == "ios"

        if self._injected_driver is not None:
            driver = self._injected_driver
        elif is_ios:
            ios_url = self.resolved_device_config.serial
            if not ios_url:
                raise ValueError("iOS device URL required in config.device.serial")
            # TODO: bundle_identifiers not configurable yet
            driver = IOSDriver(url=ios_url)
            await driver.connect()
        else:
            device_serial = self.resolved_device_config.serial
            if device_serial is None:
                devices = await adb.list()
                if not devices:
                    raise ValueError("No connected Android devices found.")
                device_serial = devices[0].serial

            driver = AndroidDriver(
                serial=device_serial,
                use_tcp=self.resolved_device_config.use_tcp,
            )
            await driver.connect()

        # Wrap with StealthDriver if stealth mode enabled
        stealth_enabled = self.config.tools and self.config.tools.stealth
        if stealth_enabled and not is_ios:
            driver = StealthDriver(driver)

        # Wrap with RecordingDriver if trajectory saving enabled
        if self.config.logging.save_trajectory != "none":
            if not isinstance(driver, RecordingDriver):
                driver = RecordingDriver(driver)

        self.driver = driver

        # ‚îÄ‚îÄ 2. Create state provider ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self._injected_state_provider is not None:
            self.state_provider = self._injected_state_provider
        elif is_ios:
            self.state_provider = IOSStateProvider(
                driver,
                use_normalized=self.config.agent.use_normalized_coordinates,
            )
        else:
            tree_filter = ConciseFilter() if vision_enabled else DetailedFilter()
            tree_formatter = IndexedFormatter()
            self.state_provider = AndroidStateProvider(
                driver,
                tree_filter=tree_filter,
                tree_formatter=tree_formatter,
                use_normalized=self.config.agent.use_normalized_coordinates,
                stealth=stealth_enabled,
            )

        # ‚îÄ‚îÄ 3. Build tool registry ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        registry = ToolRegistry()

        # 3a. Atomic tools (click, long_press, type, system_button, swipe, etc.)
        registry.register_from_dict(ATOMIC_ACTION_SIGNATURES)

        # 3b. open_app (always registered)
        registry.register(
            "open_app",
            fn=open_app,
            params={"text": {"type": "string", "required": True}},
            description='Open an app by name or description. Usage: {"action": "open_app", "text": "Gmail"}',
            deps={"start_app", "get_apps"},
        )

        # 3c. remember + complete (always registered, from DroidAgentState methods)
        registry.register(
            "remember",
            fn=remember,
            params={"information": {"type": "string", "required": True}},
            description="Remember information for later use",
        )
        registry.register(
            "complete",
            fn=complete,
            params={
                "success": {"type": "boolean", "required": True},
                "message": {"type": "string", "required": True},
            },
            description=(
                "Mark task as complete. "
                "success=true if task succeeded, false if failed. "
                "message contains the result, answer, or explanation."
            ),
        )

        # 3d. type_secret (conditional)
        if self.credential_manager:
            credential_tools = await build_credential_tools(self.credential_manager)
            if credential_tools:
                registry.register_from_dict(credential_tools)

        # 3e. User custom tools
        if self.user_custom_tools:
            registry.register_from_dict(self.user_custom_tools)

        # 3f. MCP tools
        if self.config.mcp and self.config.mcp.enabled:
            self.mcp_manager = MCPClientManager(self.config.mcp)
            await self.mcp_manager.discover_tools()
            mcp_tools = mcp_to_droidrun_tools(self.mcp_manager)
            if mcp_tools:
                registry.register_from_dict(mcp_tools)

        # 3g. Disable unsupported tools based on driver + state provider capabilities
        capabilities = driver.supported | self.state_provider.supported
        registry.disable_unsupported(capabilities)

        # 3h. Disable tools from config
        disabled_tools = (
            self.config.tools.disabled_tools
            if self.config.tools and self.config.tools.disabled_tools
            else []
        )
        if disabled_tools:
            registry.disable(disabled_tools)

        self.registry = registry

        # ‚îÄ‚îÄ 4. Create ActionContext ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.action_ctx = ActionContext(
            driver=driver,
            ui=None,  # populated each step by state_provider
            shared_state=self.shared_state,
            state_provider=self.state_provider,
            app_opener_llm=self.app_opener_llm,
            credential_manager=self.credential_manager,
            streaming=self.config.agent.streaming,
        )

        # ‚îÄ‚îÄ 5. Wire up sub-agents ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self.config.agent.reasoning and self.executor_agent:
            self.manager_agent.action_ctx = self.action_ctx
            self.manager_agent.state_provider = self.state_provider
            self.manager_agent.registry = self.registry
            self.manager_agent.save_trajectory = self.config.logging.save_trajectory
            self.executor_agent.registry = self.registry
            self.executor_agent.action_ctx = self.action_ctx

        # ‚îÄ‚îÄ 6. Fetch device date once ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.shared_state.device_date = await driver.get_date()

        # ‚îÄ‚îÄ 7. External agent mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self._using_external_agent:
            agent_name = self.config.agent.name
            agent_module = load_agent(agent_name)
            if not agent_module:
                raise ValueError(f"Failed to load external agent: {agent_name}")

            agent_config = self.config.external_agents.get(agent_name)
            if not agent_config:
                raise ValueError(
                    f"No config found for agent '{agent_name}' in external_agents section"
                )

            final_config = {**agent_module["config"], **agent_config}

            logger.info(f"ü§ñ Using external agent: {agent_name}")

            result = await agent_module["run"](
                driver=self.driver,
                action_ctx=self.action_ctx,
                instruction=self.shared_state.instruction,
                config=final_config,
                max_steps=self.config.agent.max_steps,
            )

            return FinalizeEvent(success=result["success"], reason=result["reason"])

        if self.config.logging.save_trajectory != "none":
            self.trajectory_writer.write(self.trajectory, stage="init")

        if not self.config.agent.reasoning:
            logger.debug(
                f"üîÑ Direct execution mode - executing goal: {self.shared_state.instruction}"
            )
            event = FastAgentExecuteEvent(instruction=self.shared_state.instruction)
            ctx.write_event_to_stream(event)
            return event

        logger.debug("üß† Reasoning mode - initializing Manager/Executor workflow")
        event = ManagerInputEvent()
        ctx.write_event_to_stream(event)
        return event

    # ========================================================================
    # execute_task ‚Äî FastAgent / CodeActAgent
    # ========================================================================

    @step
    async def execute_task(
        self, ctx: Context, ev: FastAgentExecuteEvent
    ) -> FastAgentResultEvent:
        """Execute a single task using CodeActAgent or FastAgent."""

        logger.debug(f"üîß Executing task: {ev.instruction}")

        try:
            if self.config.agent.fast_agent.codeact:
                agent = CodeActAgent(
                    llm=self.fast_agent_llm,
                    agent_config=self.config.agent,
                    registry=self.registry,
                    action_ctx=self.action_ctx,
                    state_provider=self.state_provider,
                    save_trajectory=self.config.logging.save_trajectory,
                    debug=self.config.logging.debug,
                    shared_state=self.shared_state,
                    safe_execution_config=self.config.safe_execution,
                    output_model=self.output_model,
                    prompt_resolver=self.prompt_resolver,
                    timeout=self.timeout,
                    tracing_config=self.config.tracing,
                )
            else:
                agent = FastAgent(
                    llm=self.fast_agent_llm,
                    agent_config=self.config.agent,
                    registry=self.registry,
                    action_ctx=self.action_ctx,
                    state_provider=self.state_provider,
                    save_trajectory=self.config.logging.save_trajectory,
                    debug=self.config.logging.debug,
                    shared_state=self.shared_state,
                    output_model=self.output_model,
                    prompt_resolver=self.prompt_resolver,
                    timeout=self.timeout,
                    tracing_config=self.config.tracing,
                )

            handler = agent.run(
                input=ev.instruction,
                remembered_info=self.shared_state.fast_memory,
            )

            async for nested_ev in handler.stream_events():
                self.handle_stream_event(nested_ev, ctx)

                if isinstance(nested_ev, (CodeActOutputEvent, FastAgentOutputEvent)):
                    if self.config.logging.save_trajectory != "none":
                        self.trajectory_writer.write(
                            self.trajectory,
                            stage=f"fast_agent_step_{self.shared_state.step_number}",
                        )

            result = await handler

            return FastAgentResultEvent(
                success=result.get("success", False),
                reason=result["reason"],
                instruction=ev.instruction,
            )

        except DeviceDisconnectedError as e:
            logger.error(f"Device disconnected: {e}")
            return FastAgentResultEvent(
                success=False,
                reason=f"Device disconnected: {e}",
                instruction=ev.instruction,
            )

        except Exception as e:
            logger.error(f"Error during task execution: {e}")
            if self.config.logging.debug:
                logger.error(traceback.format_exc())
            return FastAgentResultEvent(
                success=False, reason=f"Error: {str(e)}", instruction=ev.instruction
            )

    @step
    async def handle_fast_agent_result(
        self, ctx: Context, ev: FastAgentResultEvent
    ) -> FinalizeEvent:
        try:
            return FinalizeEvent(success=ev.success, reason=ev.reason)

        except Exception as e:
            logger.error(f"‚ùå Error during DroidAgent execution: {e}")
            if self.config.logging.debug:
                logger.error(traceback.format_exc())
            return FinalizeEvent(
                success=False,
                reason=str(e),
            )

    # ========================================================================
    # Manager/Executor Workflow Steps
    # ========================================================================

    @step
    async def run_manager(
        self, ctx: Context, ev: ManagerInputEvent
    ) -> ManagerPlanEvent | FinalizeEvent:
        """Run Manager planning phase."""
        if self.shared_state.step_number >= self.config.agent.max_steps:
            logger.warning(f"‚ö†Ô∏è Reached maximum steps ({self.config.agent.max_steps})")
            return FinalizeEvent(
                success=False,
                reason=f"Reached maximum steps ({self.config.agent.max_steps})",
            )

        self.shared_state.step_number += 1
        logger.info(
            f"üîÑ Step {self.shared_state.step_number}/{self.config.agent.max_steps}"
        )

        try:
            handler = self.manager_agent.run()

            async for nested_ev in handler.stream_events():
                self.handle_stream_event(nested_ev, ctx)

            result = await handler
        except DeviceDisconnectedError as e:
            logger.error(f"Device disconnected: {e}")
            return FinalizeEvent(success=False, reason=f"Device disconnected: {e}")

        event = ManagerPlanEvent(
            plan=result["plan"],
            current_subgoal=result["current_subgoal"],
            thought=result["thought"],
            answer=result.get("answer", ""),
            success=result.get("success"),
        )
        ctx.write_event_to_stream(event)
        return event

    @step
    async def handle_manager_plan(
        self, ctx: Context, ev: ManagerPlanEvent
    ) -> (
        ExecutorInputEvent
        | ScripterExecutorInputEvent
        | FinalizeEvent
        | TextManipulatorInputEvent
    ):
        """Process Manager output and decide next step."""
        # Check for answer-type termination
        if ev.answer.strip():
            success = ev.success if ev.success is not None else True
            self.shared_state.progress_summary = f"Answer: {ev.answer}"
            return FinalizeEvent(success=success, reason=ev.answer)

        # Check for <script> tag
        if "<script>" in ev.current_subgoal:
            start_idx = ev.plan.find("<script>")
            end_idx = ev.plan.find("</script>")

            if start_idx != -1 and end_idx != -1 and end_idx > start_idx:
                task = ev.plan[start_idx + len("<script>") : end_idx].strip()
                logger.debug(f"üêç Routing to ScripterAgent: {task[:80]}...")
                event = ScripterExecutorInputEvent(task=task)
                ctx.write_event_to_stream(event)
                return event
            else:
                logger.warning(
                    "‚ö†Ô∏è Found <script> in subgoal but not properly closed in plan, treating as regular subgoal"
                )
        if "TEXT_TASK" in ev.current_subgoal:
            if self.config.agent.fast_agent.codeact:
                return TextManipulatorInputEvent(
                    task=ev.current_subgoal.replace("TEXT_TASK:", "")
                    .replace("TEXT_TASK", "")
                    .strip()
                )
            else:
                logger.debug(
                    "‚ö†Ô∏è TEXT_TASK in tools mode ‚Äî routing to Executor instead of TextManipulator"
                )
                subgoal = (
                    ev.current_subgoal.replace("TEXT_TASK:", "")
                    .replace("TEXT_TASK", "")
                    .strip()
                )
                return ExecutorInputEvent(current_subgoal=subgoal)

        logger.debug(f"‚ñ∂Ô∏è  Proceeding to Executor with subgoal: {ev.current_subgoal}")
        return ExecutorInputEvent(current_subgoal=ev.current_subgoal)

    @step
    async def run_text_manipulator(
        self, ctx: Context, ev: TextManipulatorInputEvent
    ) -> TextManipulatorResultEvent:
        logger.debug(f"üîç Running TextManipulatorAgent for task: {ev.task}")

        if not self.shared_state.focused_text:
            logger.warning("‚ö†Ô∏è No focused text available, using empty string")
            current_text = ""
        else:
            current_text = self.shared_state.focused_text

        try:
            text_to_type, code_ran = await run_text_manipulation_agent(
                instruction=self.shared_state.instruction,
                current_subgoal=ev.task,
                current_text=current_text,
                overall_plan=self.shared_state.plan,
                llm=self.text_manipulator_llm,
                stream=self.config.agent.streaming,
            )

            return TextManipulatorResultEvent(
                task=ev.task, text_to_type=text_to_type, code_ran=code_ran
            )

        except Exception as e:
            logger.error(f"‚ùå TextManipulator agent failed: {e}")
            if self.config.logging.debug:
                logger.error(traceback.format_exc())

            return TextManipulatorResultEvent(
                task=ev.task, text_to_type="", code_ran=""
            )

    @step
    async def handle_text_manipulator_result(
        self, ctx: Context, ev: TextManipulatorResultEvent
    ) -> ManagerInputEvent:
        if not ev.text_to_type or not ev.text_to_type.strip():
            logger.warning("‚ö†Ô∏è TextManipulator returned empty text, treating as no-op")
            self.shared_state.last_summary = "Text manipulation returned empty result"
            self.shared_state.action_outcomes.append(False)
        else:
            try:
                success = await self.action_ctx.driver.input_text(
                    ev.text_to_type, clear=True
                )

                if not success:
                    logger.warning("‚ö†Ô∏è Text input may have failed")
                    self.shared_state.last_summary = (
                        "Text manipulation attempted but may have failed"
                    )
                    self.shared_state.action_outcomes.append(False)
                else:
                    logger.debug(
                        f"‚úÖ Text manipulator successfully typed {len(ev.text_to_type)} characters"
                    )
                    self.shared_state.last_summary = f"Text manipulation successful: typed {len(ev.text_to_type)} characters"
                    self.shared_state.action_outcomes.append(True)
            except Exception as e:
                logger.error(f"‚ùå Error during text input: {e}")
                self.shared_state.last_summary = f"Text manipulation error: {str(e)}"
                self.shared_state.action_outcomes.append(False)

        text_manipulation_record = {
            "task": ev.task,
            "code_ran": ev.code_ran,
            "text_length": len(ev.text_to_type) if ev.text_to_type else 0,
            "success": (
                self.shared_state.action_outcomes[-1]
                if self.shared_state.action_outcomes
                else False
            ),
        }

        self.shared_state.text_manipulation_history.append(text_manipulation_record)
        self.shared_state.last_text_manipulation_success = text_manipulation_record[
            "success"
        ]

        if self.config.logging.save_trajectory != "none":
            self.trajectory_writer.write(
                self.trajectory, stage=f"step_{self.shared_state.step_number}"
            )

        return ManagerInputEvent()

    @step
    async def run_executor(
        self, ctx: Context, ev: ExecutorInputEvent
    ) -> ExecutorResultEvent:
        """Run Executor action phase."""
        logger.debug("‚ö° Running Executor for action...")

        handler = self.executor_agent.run(subgoal=ev.current_subgoal)

        async for nested_ev in handler.stream_events():
            self.handle_stream_event(nested_ev, ctx)

        result = await handler

        # Update coordination state after execution
        self.shared_state.action_history.append(result["action"])
        self.shared_state.summary_history.append(result["summary"])
        self.shared_state.action_outcomes.append(result["outcome"])
        self.shared_state.error_descriptions.append(result["error"])
        self.shared_state.last_action = result["action"]
        self.shared_state.last_summary = result["summary"]

        return ExecutorResultEvent(
            action=result["action"],
            outcome=result["outcome"],
            error=result["error"],
            summary=result["summary"],
        )

    @step
    async def handle_executor_result(
        self, ctx: Context, ev: ExecutorResultEvent
    ) -> ManagerInputEvent:
        """Process Executor result and continue."""
        err_thresh = self.shared_state.err_to_manager_thresh

        if len(self.shared_state.action_outcomes) >= err_thresh:
            latest = self.shared_state.action_outcomes[-err_thresh:]
            error_count = sum(1 for o in latest if not o)
            if error_count == err_thresh:
                logger.warning(f"‚ö†Ô∏è Error escalation: {err_thresh} consecutive errors")
                self.shared_state.error_flag_plan = True
            else:
                if self.shared_state.error_flag_plan:
                    logger.debug("‚úÖ Error resolved - resetting error flag")
                self.shared_state.error_flag_plan = False

        if self.config.logging.save_trajectory != "none":
            self.trajectory_writer.write(
                self.trajectory, stage=f"step_{self.shared_state.step_number}"
            )

        return ManagerInputEvent()

    # ========================================================================
    # Script Executor Workflow Steps
    # ========================================================================

    @step
    async def run_scripter(
        self, ctx: Context, ev: ScripterExecutorInputEvent
    ) -> ScripterExecutorResultEvent:
        """Instantiate and run ScripterAgent for off-device operations."""
        logger.debug(f"üêç Starting ScripterAgent for task: {ev.task[:2000]}...")

        scripter_agent = ScripterAgent(
            llm=self.scripter_llm,
            agent_config=self.config.agent,
            shared_state=self.shared_state,
            task=ev.task,
            safe_execution_config=self.config.safe_execution,
            timeout=self.timeout,
        )

        handler = scripter_agent.run()

        async for nested_ev in handler.stream_events():
            self.handle_stream_event(nested_ev, ctx)

        result = await handler

        script_record = {
            "task": ev.task,
            "message": result["message"],
            "success": result["success"],
            "code_executions": result.get("code_executions", 0),
        }
        self.shared_state.scripter_history.append(script_record)
        self.shared_state.last_scripter_message = result["message"]
        self.shared_state.last_scripter_success = result["success"]

        return ScripterExecutorResultEvent(
            task=ev.task,
            message=result["message"],
            success=result["success"],
            code_executions=result.get("code_executions", 0),
        )

    @step
    async def handle_scripter_result(
        self, ctx: Context, ev: ScripterExecutorResultEvent
    ) -> ManagerInputEvent:
        """Process ScripterAgent result and loop back to Manager."""
        if ev.success:
            logger.debug(
                f"‚úÖ Script completed successfully in {ev.code_executions} steps"
            )
        else:
            logger.warning(f"‚ö†Ô∏è Script failed or reached max steps: {ev.message}")

        if self.config.logging.save_trajectory != "none":
            self.trajectory_writer.write(
                self.trajectory, stage=f"step_{self.shared_state.step_number}"
            )

        return ManagerInputEvent()

    # ========================================================================
    # Finalize
    # ========================================================================

    @step
    async def finalize(self, ctx: Context, ev: FinalizeEvent) -> ResultEvent:
        ctx.write_event_to_stream(ev)
        capture(
            DroidAgentFinalizeEvent(
                success=ev.success,
                reason=ev.reason,
                steps=self.shared_state.step_number,
                unique_packages_count=len(self.shared_state.visited_packages),
                unique_activities_count=len(self.shared_state.visited_activities),
            ),
            self.user_id,
        )
        await flush()

        # Base result with answer
        result = ResultEvent(
            success=ev.success,
            reason=ev.reason,
            steps=self.shared_state.step_number,
            structured_output=None,
        )

        # Extract structured output if model was provided
        if self.output_model is not None and ev.reason:
            logger.debug("üîÑ Running structured output extraction...")

            try:
                structured_agent = StructuredOutputAgent(
                    llm=self.structured_output_llm,
                    pydantic_model=self.output_model,
                    answer_text=ev.reason,
                    timeout=self.timeout,
                )

                handler = structured_agent.run()

                async for nested_ev in handler.stream_events():
                    self.handle_stream_event(nested_ev, ctx)

                extraction_result = await handler

                if extraction_result["success"]:
                    result.structured_output = extraction_result["structured_output"]
                    logger.debug("‚úÖ Structured output added to final result")
                else:
                    logger.warning(
                        f"‚ö†Ô∏è  Structured extraction failed: {extraction_result['error_message']}"
                    )

            except Exception as e:
                logger.error(f"‚ùå Error during structured extraction: {e}")
                if self.config.logging.debug:
                    logger.error(traceback.format_exc())

        # Capture final screenshot (independent of trajectory persistence)
        vision_any = (
            self.config.agent.manager.vision
            or self.config.agent.executor.vision
            or self.config.agent.fast_agent.vision
        )
        if (
            vision_any
            or self._stream_screenshots
            or self.config.logging.save_trajectory != "none"
        ):
            try:
                screenshot = await self.action_ctx.driver.screenshot()
                if screenshot:
                    ctx.write_event_to_stream(ScreenshotEvent(screenshot=screenshot))
                    parent_span = trace.get_current_span()
                    record_langfuse_screenshot(
                        screenshot,
                        parent_span=parent_span,
                        screenshots_enabled=self.config.tracing.langfuse_screenshots,
                        vision_enabled=vision_any,
                    )
                    logger.debug("üì∏ Final screenshot captured")
            except Exception as e:
                logger.warning(f"Failed to capture final screenshot: {e}")

        # Save trajectory to disk
        if self.config.logging.save_trajectory != "none":
            # Populate macro data from RecordingDriver log
            if isinstance(self.driver, RecordingDriver):
                self.trajectory.macro = list(self.driver.log)

            self.trajectory_writer.write_final(
                self.trajectory, self.config.logging.trajectory_gifs
            )
            await self.trajectory_writer.stop()
            logger.info(f"üìÅ Trajectory saved: {self.trajectory.trajectory_folder}")

        # Cleanup MCP connections
        if self.mcp_manager:
            try:
                await self.mcp_manager.disconnect_all()
            except Exception as e:
                logger.warning(f"MCP cleanup error: {e}")

        return result

    # ========================================================================
    # Event streaming
    # ========================================================================

    def handle_stream_event(self, ev: Event, ctx: Context):
        if not isinstance(ev, StopEvent):
            ctx.write_event_to_stream(ev)

            if self.trajectory:
                if isinstance(ev, ScreenshotEvent):
                    self.trajectory.screenshot_queue.append(ev.screenshot)
                    self.trajectory.screenshot_count += 1
                elif isinstance(ev, RecordUIStateEvent):
                    self.trajectory.ui_states.append(ev.ui_state)
                else:
                    self.trajectory.events.append(ev)

```

`droidrun/agent/droid/events.py`:

```py
"""
DroidAgent coordination events.

These events route between DroidAgent and child agents.
For internal agent events, see each agent's events.py file.
"""

from typing import Dict, Optional

from llama_index.core.workflow import Event, StopEvent
from pydantic import BaseModel


class FastAgentExecuteEvent(Event):
    instruction: str


class FastAgentResultEvent(Event):
    success: bool
    reason: str
    instruction: str


# ============================================================================
# Manager/Executor coordination events
# ============================================================================


class ManagerInputEvent(Event):
    """Trigger Manager workflow for planning"""

    pass


class ManagerPlanEvent(Event):
    """
    Coordination event from ManagerAgent to DroidAgent.

    Used for workflow step routing only (NOT streamed to frontend).
    For internal events with memory_update metadata, see ManagerPlanDetailsEvent.
    """

    plan: str
    current_subgoal: str
    thought: str
    answer: str = ""
    success: Optional[bool] = None  # True/False if complete, None if in progress


class ExecutorInputEvent(Event):
    """Trigger Executor workflow for action execution"""

    current_subgoal: str


class ExecutorResultEvent(Event):
    """Executor finished with action result."""

    action: Dict
    outcome: bool
    error: str
    summary: str


# ============================================================================
# Script executor coordination events
# ============================================================================


class ScripterExecutorInputEvent(Event):
    """Trigger ScripterAgent workflow for off-device operations"""

    task: str


class ScripterExecutorResultEvent(Event):
    """Scripter finished."""

    task: str
    message: str
    success: bool
    code_executions: int


# ============================================================================
# TEXT MANIPULATOR WORKFLOW EVENTS
# ============================================================================


class TextManipulatorInputEvent(Event):
    """Trigger TextManipulatorAgent workflow for text manipulation"""

    task: str


class TextManipulatorResultEvent(Event):
    task: str
    text_to_type: str
    code_ran: str


# ============================================================================
# FINALIZATION EVENTS
# ============================================================================


class FinalizeEvent(Event):
    """Trigger finalization."""

    success: bool
    reason: str


class ResultEvent(StopEvent):
    """
    Final result from DroidAgent.

    Returned by DroidAgent.run() with:
    - success: Whether the task completed successfully
    - reason: Explanation or answer
    - steps: Number of steps taken
    - structured_output: Extracted structured data (if output_model was provided)
    """

    success: bool
    reason: str
    steps: int
    structured_output: Optional[BaseModel] = None

```

`droidrun/agent/droid/state.py`:

```py
from __future__ import annotations

from typing import Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field

from droidrun.telemetry import PackageVisitEvent, capture


class DroidAgentState(BaseModel):
    """
    State model for DroidAgent workflow - shared across parent and child workflows.
    """

    model_config = ConfigDict(arbitrary_types_allowed=True)
    # Task context
    instruction: str = ""
    step_number: int = 0
    runtype: str = "developer"
    user_id: str | None = None

    # ========================================================================
    # Device State (current)
    # ========================================================================
    device_date: str = ""  # Fetched once at startup
    formatted_device_state: str = ""  # Text description for prompts
    focused_text: str = ""  # Text in focused input field
    a11y_tree: List[Dict] = Field(default_factory=list)  # Raw accessibility tree
    phone_state: Dict = Field(default_factory=dict)  # Package, activity, etc.
    screenshot: str | bytes | None = None  # Current screenshot
    width: int = 0
    height: int = 0

    # ========================================================================
    # Device State (previous - for before/after comparison)
    # ========================================================================
    previous_formatted_device_state: str = ""

    # ========================================================================
    # App Tracking
    # ========================================================================
    app_card: str = ""
    current_package_name: str = ""
    current_activity_name: str = ""
    visited_packages: set = Field(default_factory=set)
    visited_activities: set = Field(default_factory=set)

    # ========================================================================
    # Unified Thought/Plan Tracking (used by all agents)
    # ========================================================================
    last_thought: str = ""  # Most recent thought from any agent
    previous_plan: str = ""  # Plan from previous iteration
    progress_summary: str = ""  # Cumulative progress (replaces each turn)

    # ========================================================================
    # Planning State (Manager sets these)
    # ========================================================================
    plan: str = ""  # Current plan
    current_subgoal: str = ""  # Current subgoal for Executor
    answer: str = (
        ""  # Final answer (used by both manager completion and complete() tool)
    )

    # ========================================================================
    # Action Tracking
    # ========================================================================
    action_history: List[Dict] = Field(default_factory=list)
    summary_history: List[str] = Field(default_factory=list)
    action_outcomes: List[bool] = Field(default_factory=list)
    error_descriptions: List[str] = Field(default_factory=list)
    last_action: Dict = Field(default_factory=dict)
    last_summary: str = ""

    # ========================================================================
    # Memory
    # ========================================================================
    manager_memory: str = ""  # Manager's planning notes (append-only string)
    fast_memory: List[str] = Field(
        default_factory=list
    )  # FastAgent/CodeAct remember() items

    # ========================================================================
    # Completion State (set by complete() tool, checked by FastAgent/CodeAct)
    # ========================================================================
    finished: bool = False
    success: Optional[bool] = None

    # ========================================================================
    # Message History (for stateful agents - list of dicts)
    # ========================================================================
    message_history: List[Dict] = Field(default_factory=list)

    # ========================================================================
    # Error Handling
    # ========================================================================
    error_flag_plan: bool = False
    err_to_manager_thresh: int = 2

    # ========================================================================
    # Script Execution Tracking
    # ========================================================================
    scripter_history: List[Dict] = Field(default_factory=list)
    last_scripter_message: str = ""
    last_scripter_success: bool = True

    # ========================================================================
    # Text Manipulation Tracking
    # ========================================================================
    has_text_to_modify: bool = False
    text_manipulation_history: List[Dict] = Field(default_factory=list)
    last_text_manipulation_success: bool = False

    # ========================================================================
    # Custom Variables (user-defined)
    # ========================================================================
    custom_variables: Dict = Field(default_factory=dict)
    output_dir: str = ""

    # ========================================================================
    # Methods for action functions
    # ========================================================================

    async def remember(self, information: str) -> str:
        """Store information in fast_memory for FastAgent/CodeAct context."""
        if (
            not information
            or not isinstance(information, str)
            or not information.strip()
        ):
            return "Failed to remember: please provide valid information."
        self.fast_memory.append(information.strip())
        if len(self.fast_memory) > 10:
            self.fast_memory = self.fast_memory[-10:]
        return f"Remembered: {information}"

    async def complete(
        self, success: bool, reason: str = "", message: str = ""
    ) -> None:
        """Mark task as finished.

        Accepts both ``reason`` and ``message`` params ‚Äî FastAgent XML
        prompt uses ``message``, action signature uses ``reason``.
        """
        answer = reason or message
        if not success and not answer:
            raise ValueError("Reason for failure is required if success is False.")
        self.finished = True
        self.success = success
        self.answer = answer or "Task completed successfully."

    def update_current_app(self, package_name: str, activity_name: str):
        """
        Update package and activity together, capturing telemetry event only once.
        """
        package_changed = package_name != self.current_package_name
        activity_changed = activity_name != self.current_activity_name

        if not (package_changed or activity_changed):
            return

        if package_changed and package_name:
            self.visited_packages.add(package_name)
        if activity_changed and activity_name:
            self.visited_activities.add(activity_name)

        self.current_package_name = package_name
        self.current_activity_name = activity_name

        capture(
            PackageVisitEvent(
                package_name=package_name or "Unknown",
                activity_name=activity_name or "Unknown",
                step_number=self.step_number,
            ),
            user_id=self.user_id,
        )

```

`droidrun/agent/executor/__init__.py`:

```py
"""
Executor Agent - Action execution workflow.
"""

from droidrun.agent.droid.events import ExecutorInputEvent, ExecutorResultEvent
from droidrun.agent.executor.events import (
    ExecutorActionEvent,
    ExecutorContextEvent,
    ExecutorResponseEvent,
    ExecutorActionResultEvent,
)
from droidrun.agent.executor.executor_agent import ExecutorAgent

__all__ = [
    "ExecutorAgent",
    "ExecutorInputEvent",
    "ExecutorResultEvent",
    "ExecutorContextEvent",
    "ExecutorResponseEvent",
    "ExecutorActionEvent",
    "ExecutorActionResultEvent",
]

```

`droidrun/agent/executor/events.py`:

```py
"""
Events for the ExecutorAgent workflow.

Internal events for streaming to frontend/logging.
For DroidAgent coordination events, see droid/events.py
"""

from typing import Dict, Optional

from llama_index.core.workflow import Event

from droidrun.agent.usage import UsageResult


class ExecutorContextEvent(Event):
    """Context prepared, ready for LLM call."""

    subgoal: str


class ExecutorResponseEvent(Event):
    """LLM response received, ready for parsing."""

    response: str
    usage: Optional[UsageResult] = None


class ExecutorActionEvent(Event):
    """Action parsed, ready to execute."""

    action_json: str
    thought: str
    description: str
    full_response: str = ""


class ExecutorActionResultEvent(Event):
    """Action execution result (internal event with full details)."""

    action: Dict
    success: bool
    error: str
    summary: str
    thought: str = ""
    full_response: str = ""

```

`droidrun/agent/executor/executor_agent.py`:

```py
"""
ExecutorAgent - Action execution workflow.

This agent is responsible for:
- Taking a specific subgoal from the Manager
- Analyzing the current UI state
- Selecting and executing appropriate actions
"""

from __future__ import annotations

import asyncio
import json
import logging
from typing import TYPE_CHECKING, Optional

from llama_index.core.llms.llm import LLM
from llama_index.core.workflow import Context, StartEvent, StopEvent, Workflow, step

from droidrun.agent.executor.events import (
    ExecutorActionEvent,
    ExecutorContextEvent,
    ExecutorResponseEvent,
    ExecutorActionResultEvent,
)
from droidrun.agent.executor.prompts import parse_executor_response
from droidrun.agent.usage import get_usage_from_response
from droidrun.agent.utils.chat_utils import to_chat_messages
from droidrun.agent.utils.inference import acall_with_retries
from droidrun.agent.utils.prompt_resolver import PromptResolver
from droidrun.config_manager.config_manager import AgentConfig
from droidrun.config_manager.prompt_loader import PromptLoader

if TYPE_CHECKING:
    from droidrun.agent.action_context import ActionContext
    from droidrun.agent.droid import DroidAgentState
    from droidrun.agent.tool_registry import ToolRegistry

logger = logging.getLogger("droidrun")


class ExecutorAgent(Workflow):
    """
    Action execution agent that performs specific actions.

    Single-turn agent: receives subgoal, selects action, executes it.
    Uses dict messages, converts to ChatMessage at LLM call time.
    """

    # Flow-control tools hidden from executor's LLM prompt
    _EXCLUDE_TOOLS = {"remember", "complete"}

    def __init__(
        self,
        llm: LLM,
        registry: "ToolRegistry | None",
        action_ctx: "ActionContext | None",
        shared_state: "DroidAgentState",
        agent_config: AgentConfig,
        prompt_resolver: Optional[PromptResolver] = None,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.llm = llm
        self.agent_config = agent_config
        self.config = agent_config.executor
        self.vision = agent_config.executor.vision
        self.registry = registry
        self.action_ctx = action_ctx
        self.shared_state = shared_state
        self.prompt_resolver = prompt_resolver or PromptResolver()

        logger.debug("ExecutorAgent initialized.")

    @step
    async def prepare_context(
        self, ctx: Context, ev: StartEvent
    ) -> ExecutorContextEvent:
        """Prepare executor context and prompt."""
        subgoal = ev.get("subgoal", "")
        logger.debug(f"üß† Executor thinking about action for: {subgoal}")

        # Build action history (last 5)
        action_history = []
        if self.shared_state.action_history:
            n = min(5, len(self.shared_state.action_history))
            action_history = [
                {"action": act, "summary": summ, "outcome": outcome, "error": err}
                for act, summ, outcome, err in zip(
                    self.shared_state.action_history[-n:],
                    self.shared_state.summary_history[-n:],
                    self.shared_state.action_outcomes[-n:],
                    self.shared_state.error_descriptions[-n:],
                    strict=True,
                )
            ]

        # Get available secrets
        available_secrets = []
        if self.action_ctx and self.action_ctx.credential_manager:
            available_secrets = await self.action_ctx.credential_manager.get_keys()

        # Build prompt variables
        variables = {
            "instruction": self.shared_state.instruction,
            "app_card": "",
            "device_state": self.shared_state.formatted_device_state,
            "plan": self.shared_state.plan,
            "subgoal": subgoal,
            "progress_status": self.shared_state.progress_summary,
            "atomic_actions": self.registry.get_signatures(exclude=self._EXCLUDE_TOOLS),
            "action_history": action_history,
            "available_secrets": available_secrets,
            "variables": self.shared_state.custom_variables,
        }

        custom_prompt = self.prompt_resolver.get_prompt("executor_system")
        if custom_prompt:
            prompt_text = PromptLoader.render_template(custom_prompt, variables)
        else:
            prompt_text = await PromptLoader.load_prompt(
                self.agent_config.get_executor_system_prompt_path(),
                variables,
            )

        # Build message as dict
        messages = [{"role": "user", "content": [{"text": prompt_text}]}]

        # Add screenshot if vision enabled
        if self.vision:
            screenshot = self.shared_state.screenshot
            if screenshot is not None:
                messages[0]["content"].append({"image": screenshot})
                logger.debug("üì∏ Using screenshot for Executor")
            else:
                logger.warning("‚ö†Ô∏è Vision enabled but no screenshot available")
        await ctx.store.set("executor_messages", messages)
        event = ExecutorContextEvent(subgoal=subgoal)
        ctx.write_event_to_stream(event)
        return event

    @step
    async def get_response(
        self, ctx: Context, ev: ExecutorContextEvent
    ) -> ExecutorResponseEvent:
        """Get LLM response."""
        logger.debug("Executor getting LLM response...")

        # Get messages from context
        messages = await ctx.store.get("executor_messages")

        # Convert to ChatMessage and call LLM
        chat_messages = to_chat_messages(messages)

        try:
            logger.info("Executor response:", extra={"color": "green"})
            response = await acall_with_retries(
                self.llm, chat_messages, stream=self.agent_config.streaming
            )
            response_text = str(response)
        except ValueError as e:
            logger.warning(f"Executor LLM returned empty response: {e}")
            error_response = (
                "### Thought\nExecutor failed to respond, try again\n"
                '### Action\n{"action": "invalid"}\n'
                "### Description\nExecutor failed to respond, try again"
            )
            event = ExecutorResponseEvent(response=error_response, usage=None)
            ctx.write_event_to_stream(event)
            return event
        except Exception as e:
            raise RuntimeError(f"Error calling LLM in executor: {e}") from e

        # Extract usage
        usage = None
        try:
            usage = get_usage_from_response(self.llm.class_name(), response)
        except Exception as e:
            logger.warning(f"Could not get usage: {e}")

        event = ExecutorResponseEvent(response=response_text, usage=usage)
        ctx.write_event_to_stream(event)
        return event

    @step
    async def process_response(
        self, ctx: Context, ev: ExecutorResponseEvent
    ) -> ExecutorActionEvent:
        """Parse LLM response and extract action."""
        logger.debug("‚öôÔ∏è Processing executor response...")

        response_text = ev.response

        try:
            parsed = parse_executor_response(response_text)
        except Exception as e:
            logger.error(f"‚ùå Failed to parse executor response: {e}")
            return ExecutorActionEvent(
                action_json=json.dumps({"action": "invalid"}),
                thought=f"Failed to parse response: {str(e)}",
                description="Invalid response format from LLM",
                full_response=response_text,
            )

        # Update unified state
        self.shared_state.last_thought = parsed["thought"]

        event = ExecutorActionEvent(
            action_json=parsed["action"],
            thought=parsed["thought"],
            description=parsed["description"],
            full_response=response_text,
        )

        ctx.write_event_to_stream(event)
        return event

    @step
    async def execute(
        self, ctx: Context, ev: ExecutorActionEvent
    ) -> ExecutorActionResultEvent:
        """Execute the action."""
        logger.debug(f"‚ö° Executing action: {ev.description}")

        try:
            action_dict = json.loads(ev.action_json)
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå Failed to parse action JSON: {e}")
            event = ExecutorActionResultEvent(
                action={"action": "invalid"},
                success=False,
                error=f"Invalid action JSON: {str(e)}",
                summary="Failed to parse action",
                thought=ev.thought,
                full_response=ev.full_response,
            )
            ctx.write_event_to_stream(event)
            return event

        # Extract action type and args, dispatch via registry
        action_type = action_dict.get("action", "unknown")
        action_args = {k: v for k, v in action_dict.items() if k != "action"}

        result = await self.registry.execute(
            action_type, action_args, self.action_ctx, workflow_ctx=ctx
        )

        await asyncio.sleep(self.agent_config.after_sleep_action)

        logger.debug(
            f"{'‚úÖ' if result.success else '‚ùå'} Execution complete: {result.summary}"
        )

        event = ExecutorActionResultEvent(
            action=action_dict,
            success=result.success,
            error="" if result.success else result.summary,
            summary=result.summary,
            thought=ev.thought,
            full_response=ev.full_response,
        )
        ctx.write_event_to_stream(event)
        return event

    @step
    async def finalize(self, ctx: Context, ev: ExecutorActionResultEvent) -> StopEvent:
        """Return executor results to parent workflow."""
        logger.debug("‚úÖ Executor execution complete")

        return StopEvent(
            result={
                "action": ev.action,
                "outcome": ev.success,
                "error": ev.error,
                "summary": ev.summary,
                "thought": ev.thought,
            }
        )

```

`droidrun/agent/executor/prompts.py`:

```py
"""
Prompts for the ExecutorAgent.
"""


def parse_executor_response(response: str) -> dict:
    """
    Parse the Executor LLM response.

    Extracts:
    - thought: Content between "### Thought" and "### Action"
    - action: Content between "### Action" and "### Description"
    - description: Content after "### Description"

    Args:
        response: Raw LLM response string

    Returns:
        Dictionary with 'thought', 'action', 'description' keys
    """
    thought = (
        response.split("### Thought")[-1]
        .split("### Action")[0]
        .replace("\n", " ")
        .replace("  ", " ")
        .replace("###", "")
        .strip()
    )
    action_raw = (
        response.split("### Action")[-1]
        .split("### Description")[0]
        .replace("\n", " ")
        .replace("  ", " ")
        .replace("###", "")
        .strip()
    )
    start_idx = action_raw.find("{")
    end_idx = action_raw.rfind("}")
    if start_idx != -1 and end_idx != -1:
        action = action_raw[start_idx : end_idx + 1]
    else:
        action = action_raw
    description = (
        response.split("### Description")[-1]
        .replace("\n", " ")
        .replace("  ", " ")
        .replace("###", "")
        .strip()
    )

    return {"thought": thought, "action": action, "description": description}

```

`droidrun/agent/external/__init__.py`:

```py
"""External agent loader - dynamic imports."""

import importlib
import logging
from typing import Any, Callable, Dict, Optional, TypedDict

logger = logging.getLogger("droidrun")


class ExternalAgentModule(TypedDict):
    """Type for loaded external agent module."""

    run: Callable
    config: Dict[str, Any]


def load_agent(name: str) -> Optional[ExternalAgentModule]:
    """
    Dynamically load an external agent by name.

    Args:
        name: Agent module name (e.g., "mai_ui", "autoglm")

    Returns:
        Dict with 'run' function and 'config' defaults, or None if failed.
    """
    try:
        module = importlib.import_module(f"droidrun.agent.external.{name}")

        if not hasattr(module, "run"):
            logger.error(f"External agent '{name}' missing run() function")
            return None

        return {
            "run": module.run,
            "config": getattr(module, "DEFAULT_CONFIG", {}),
        }

    except ImportError as e:
        logger.error(f"Failed to load external agent '{name}': {e}")
        return None

```

`droidrun/agent/external/autoglm.py`:

```py
"""
Open-AutoGLM External Agent - Full Implementation.

This module implements the Open-AutoGLM phone agent protocol, matching the original
implementation from https://github.com/ArtificialZeng/Open-AutoGLM

Key features:
- Stateful conversation history across steps
- Full system prompts (Chinese + English) with 14 actions and 18 rules
- AST-based safe action parsing
- OpenAI-compatible message format
- Tool wrappers matching original DeviceFactory interface
- Timing delays matching original implementation
"""

import ast
import asyncio
import base64
import json
import logging
import re
import time
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional, Tuple

from droidrun.agent.utils.chat_utils import to_chat_messages
from droidrun.agent.utils.inference import acall_with_retries
from droidrun.agent.utils.llm_picker import load_llm

logger = logging.getLogger("droidrun")

# =============================================================================
# System Prompts (exact copy from Open-AutoGLM)
# =============================================================================


def get_system_prompt_zh() -> str:
    """Get Chinese system prompt with current date (matches original prompts_zh.py)."""
    from datetime import datetime

    today = datetime.today()
    weekday_names = [
        "ÊòüÊúü‰∏Ä",
        "ÊòüÊúü‰∫å",
        "ÊòüÊúü‰∏â",
        "ÊòüÊúüÂõõ",
        "ÊòüÊúü‰∫î",
        "ÊòüÊúüÂÖ≠",
        "ÊòüÊúüÊó•",
    ]
    weekday = weekday_names[today.weekday()]
    formatted_date = today.strftime("%YÂπ¥%mÊúà%dÊó•") + " " + weekday
    return (
        "‰ªäÂ§©ÁöÑÊó•ÊúüÊòØ: "
        + formatted_date
        + """
‰Ω†ÊòØ‰∏Ä‰∏™Êô∫ËÉΩ‰ΩìÂàÜÊûê‰∏ìÂÆ∂ÔºåÂèØ‰ª•Ê†πÊçÆÊìç‰ΩúÂéÜÂè≤ÂíåÂΩìÂâçÁä∂ÊÄÅÂõæÊâßË°å‰∏ÄÁ≥ªÂàóÊìç‰ΩúÊù•ÂÆåÊàê‰ªªÂä°„ÄÇ
‰Ω†ÂøÖÈ°ª‰∏•Ê†ºÊåâÁÖßË¶ÅÊ±ÇËæìÂá∫‰ª•‰∏ãÊ†ºÂºèÔºö
<think>{think}</think>
<answer>{action}</answer>

ÂÖ∂‰∏≠Ôºö
- {think} ÊòØÂØπ‰Ω†‰∏∫‰ªÄ‰πàÈÄâÊã©Ëøô‰∏™Êìç‰ΩúÁöÑÁÆÄÁü≠Êé®ÁêÜËØ¥Êòé„ÄÇ
- {action} ÊòØÊú¨Ê¨°ÊâßË°åÁöÑÂÖ∑‰ΩìÊìç‰ΩúÊåá‰ª§ÔºåÂøÖÈ°ª‰∏•Ê†ºÈÅµÂæ™‰∏ãÊñπÂÆö‰πâÁöÑÊåá‰ª§Ê†ºÂºè„ÄÇ

Êìç‰ΩúÊåá‰ª§ÂèäÂÖ∂‰ΩúÁî®Â¶Ç‰∏ãÔºö
- do(action="Launch", app="xxx")  
    LaunchÊòØÂêØÂä®ÁõÆÊ†áappÁöÑÊìç‰ΩúÔºåËøôÊØîÈÄöËøá‰∏ªÂ±èÂπïÂØºËà™Êõ¥Âø´„ÄÇÊ≠§Êìç‰ΩúÂÆåÊàêÂêéÔºåÊÇ®Â∞ÜËá™Âä®Êî∂Âà∞ÁªìÊûúÁä∂ÊÄÅÁöÑÊà™Âõæ„ÄÇ
- do(action="Tap", element=[x,y])  
    TapÊòØÁÇπÂáªÊìç‰ΩúÔºåÁÇπÂáªÂ±èÂπï‰∏äÁöÑÁâπÂÆöÁÇπ„ÄÇÂèØÁî®Ê≠§Êìç‰ΩúÁÇπÂáªÊåâÈíÆ„ÄÅÈÄâÊã©È°πÁõÆ„ÄÅ‰ªé‰∏ªÂ±èÂπïÊâìÂºÄÂ∫îÁî®Á®ãÂ∫èÔºåÊàñ‰∏é‰ªª‰ΩïÂèØÁÇπÂáªÁöÑÁî®Êà∑ÁïåÈù¢ÂÖÉÁ¥†ËøõË°å‰∫§‰∫í„ÄÇÂùêÊ†áÁ≥ªÁªü‰ªéÂ∑¶‰∏äËßí (0,0) ÂºÄÂßãÂà∞Âè≥‰∏ãËßíÔºà999,999)ÁªìÊùü„ÄÇÊ≠§Êìç‰ΩúÂÆåÊàêÂêéÔºåÊÇ®Â∞ÜËá™Âä®Êî∂Âà∞ÁªìÊûúÁä∂ÊÄÅÁöÑÊà™Âõæ„ÄÇ
- do(action="Tap", element=[x,y], message="ÈáçË¶ÅÊìç‰Ωú")  
    Âü∫Êú¨ÂäüËÉΩÂêåTapÔºåÁÇπÂáªÊ∂âÂèäË¥¢‰∫ß„ÄÅÊîØ‰ªò„ÄÅÈöêÁßÅÁ≠âÊïèÊÑüÊåâÈíÆÊó∂Ëß¶Âèë„ÄÇ
- do(action="Type", text="xxx")  
    TypeÊòØËæìÂÖ•Êìç‰ΩúÔºåÂú®ÂΩìÂâçËÅöÁÑ¶ÁöÑËæìÂÖ•Ê°Ü‰∏≠ËæìÂÖ•ÊñáÊú¨„ÄÇ‰ΩøÁî®Ê≠§Êìç‰ΩúÂâçÔºåËØ∑Á°Æ‰øùËæìÂÖ•Ê°ÜÂ∑≤Ë¢´ËÅöÁÑ¶ÔºàÂÖàÁÇπÂáªÂÆÉÔºâ„ÄÇËæìÂÖ•ÁöÑÊñáÊú¨Â∞ÜÂÉè‰ΩøÁî®ÈîÆÁõòËæìÂÖ•‰∏ÄÊ†∑ËæìÂÖ•„ÄÇÈáçË¶ÅÊèêÁ§∫ÔºöÊâãÊú∫ÂèØËÉΩÊ≠£Âú®‰ΩøÁî® ADB ÈîÆÁõòÔºåËØ•ÈîÆÁõò‰∏ç‰ºöÂÉèÊôÆÈÄöÈîÆÁõòÈÇ£Ê†∑Âç†Áî®Â±èÂπïÁ©∫Èó¥„ÄÇË¶ÅÁ°ÆËÆ§ÈîÆÁõòÂ∑≤ÊøÄÊ¥ªÔºåËØ∑Êü•ÁúãÂ±èÂπïÂ∫ïÈÉ®ÊòØÂê¶ÊòæÁ§∫ 'ADB Keyboard {ON}' Á±ª‰ººÁöÑÊñáÊú¨ÔºåÊàñËÄÖÊ£ÄÊü•ËæìÂÖ•Ê°ÜÊòØÂê¶Â§Ñ‰∫éÊøÄÊ¥ª/È´ò‰∫ÆÁä∂ÊÄÅ„ÄÇ‰∏çË¶Å‰ªÖ‰ªÖ‰æùËµñËßÜËßâ‰∏äÁöÑÈîÆÁõòÊòæÁ§∫„ÄÇËá™Âä®Ê∏ÖÈô§ÊñáÊú¨ÔºöÂΩì‰Ω†‰ΩøÁî®ËæìÂÖ•Êìç‰ΩúÊó∂ÔºåËæìÂÖ•Ê°Ü‰∏≠Áé∞ÊúâÁöÑ‰ªª‰ΩïÊñáÊú¨ÔºàÂåÖÊã¨Âç†‰ΩçÁ¨¶ÊñáÊú¨ÂíåÂÆûÈôÖËæìÂÖ•ÔºâÈÉΩ‰ºöÂú®ËæìÂÖ•Êñ∞ÊñáÊú¨ÂâçËá™Âä®Ê∏ÖÈô§„ÄÇ‰Ω†Êó†ÈúÄÂú®ËæìÂÖ•ÂâçÊâãÂä®Ê∏ÖÈô§ÊñáÊú¨‚Äî‚ÄîÁõ¥Êé•‰ΩøÁî®ËæìÂÖ•Êìç‰ΩúËæìÂÖ•ÊâÄÈúÄÊñáÊú¨Âç≥ÂèØ„ÄÇÊìç‰ΩúÂÆåÊàêÂêéÔºå‰Ω†Â∞ÜËá™Âä®Êî∂Âà∞ÁªìÊûúÁä∂ÊÄÅÁöÑÊà™Âõæ„ÄÇ
- do(action="Type_Name", text="xxx")  
    Type_NameÊòØËæìÂÖ•‰∫∫ÂêçÁöÑÊìç‰ΩúÔºåÂü∫Êú¨ÂäüËÉΩÂêåType„ÄÇ
- do(action="Interact")  
    InteractÊòØÂΩìÊúâÂ§ö‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑÈÄâÈ°πÊó∂ËÄåËß¶ÂèëÁöÑ‰∫§‰∫íÊìç‰ΩúÔºåËØ¢ÈóÆÁî®Êà∑Â¶Ç‰ΩïÈÄâÊã©„ÄÇ
- do(action="Swipe", start=[x1,y1], end=[x2,y2])  
    SwipeÊòØÊªëÂä®Êìç‰ΩúÔºåÈÄöËøá‰ªéËµ∑ÂßãÂùêÊ†áÊãñÂä®Âà∞ÁªìÊùüÂùêÊ†áÊù•ÊâßË°åÊªëÂä®ÊâãÂäø„ÄÇÂèØÁî®‰∫éÊªöÂä®ÂÜÖÂÆπ„ÄÅÂú®Â±èÂπï‰πãÈó¥ÂØºËà™„ÄÅ‰∏ãÊãâÈÄöÁü•Ê†è‰ª•ÂèäÈ°πÁõÆÊ†èÊàñËøõË°åÂü∫‰∫éÊâãÂäøÁöÑÂØºËà™„ÄÇÂùêÊ†áÁ≥ªÁªü‰ªéÂ∑¶‰∏äËßí (0,0) ÂºÄÂßãÂà∞Âè≥‰∏ãËßíÔºà999,999)ÁªìÊùü„ÄÇÊªëÂä®ÊåÅÁª≠Êó∂Èó¥‰ºöËá™Âä®Ë∞ÉÊï¥‰ª•ÂÆûÁé∞Ëá™ÁÑ∂ÁöÑÁßªÂä®„ÄÇÊ≠§Êìç‰ΩúÂÆåÊàêÂêéÔºåÊÇ®Â∞ÜËá™Âä®Êî∂Âà∞ÁªìÊûúÁä∂ÊÄÅÁöÑÊà™Âõæ„ÄÇ
- do(action="Note", message="True")  
    ËÆ∞ÂΩïÂΩìÂâçÈ°µÈù¢ÂÜÖÂÆπ‰ª•‰æøÂêéÁª≠ÊÄªÁªì„ÄÇ
- do(action="Call_API", instruction="xxx")  
    ÊÄªÁªìÊàñËØÑËÆ∫ÂΩìÂâçÈ°µÈù¢ÊàñÂ∑≤ËÆ∞ÂΩïÁöÑÂÜÖÂÆπ„ÄÇ
- do(action="Long Press", element=[x,y])  
    Long PresÊòØÈïøÊåâÊìç‰ΩúÔºåÂú®Â±èÂπï‰∏äÁöÑÁâπÂÆöÁÇπÈïøÊåâÊåáÂÆöÊó∂Èó¥„ÄÇÂèØÁî®‰∫éËß¶Âèë‰∏ä‰∏ãÊñáËèúÂçï„ÄÅÈÄâÊã©ÊñáÊú¨ÊàñÊøÄÊ¥ªÈïøÊåâ‰∫§‰∫í„ÄÇÂùêÊ†áÁ≥ªÁªü‰ªéÂ∑¶‰∏äËßí (0,0) ÂºÄÂßãÂà∞Âè≥‰∏ãËßíÔºà999,999)ÁªìÊùü„ÄÇÊ≠§Êìç‰ΩúÂÆåÊàêÂêéÔºåÊÇ®Â∞ÜËá™Âä®Êî∂Âà∞ÁªìÊûúÁä∂ÊÄÅÁöÑÂ±èÂπïÊà™Âõæ„ÄÇ
- do(action="Double Tap", element=[x,y])  
    Double TapÂú®Â±èÂπï‰∏äÁöÑÁâπÂÆöÁÇπÂø´ÈÄüËøûÁª≠ÁÇπÊåâ‰∏§Ê¨°„ÄÇ‰ΩøÁî®Ê≠§Êìç‰ΩúÂèØ‰ª•ÊøÄÊ¥ªÂèåÂáª‰∫§‰∫íÔºåÂ¶ÇÁº©Êîæ„ÄÅÈÄâÊã©ÊñáÊú¨ÊàñÊâìÂºÄÈ°πÁõÆ„ÄÇÂùêÊ†áÁ≥ªÁªü‰ªéÂ∑¶‰∏äËßí (0,0) ÂºÄÂßãÂà∞Âè≥‰∏ãËßíÔºà999,999)ÁªìÊùü„ÄÇÊ≠§Êìç‰ΩúÂÆåÊàêÂêéÔºåÊÇ®Â∞ÜËá™Âä®Êî∂Âà∞ÁªìÊûúÁä∂ÊÄÅÁöÑÊà™Âõæ„ÄÇ
- do(action="Take_over", message="xxx")  
    Take_overÊòØÊé•ÁÆ°Êìç‰ΩúÔºåË°®Á§∫Âú®ÁôªÂΩïÂíåÈ™åËØÅÈò∂ÊÆµÈúÄË¶ÅÁî®Êà∑ÂçèÂä©„ÄÇ
- do(action="Back")  
    ÂØºËà™ËøîÂõûÂà∞‰∏ä‰∏Ä‰∏™Â±èÂπïÊàñÂÖ≥Èó≠ÂΩìÂâçÂØπËØùÊ°Ü„ÄÇÁõ∏ÂΩì‰∫éÊåâ‰∏ã Android ÁöÑËøîÂõûÊåâÈíÆ„ÄÇ‰ΩøÁî®Ê≠§Êìç‰ΩúÂèØ‰ª•‰ªéÊõ¥Ê∑±ÁöÑÂ±èÂπïËøîÂõû„ÄÅÂÖ≥Èó≠ÂºπÂá∫Á™óÂè£ÊàñÈÄÄÂá∫ÂΩìÂâç‰∏ä‰∏ãÊñá„ÄÇÊ≠§Êìç‰ΩúÂÆåÊàêÂêéÔºåÊÇ®Â∞ÜËá™Âä®Êî∂Âà∞ÁªìÊûúÁä∂ÊÄÅÁöÑÊà™Âõæ„ÄÇ
- do(action="Home") 
    HomeÊòØÂõûÂà∞Á≥ªÁªüÊ°åÈù¢ÁöÑÊìç‰ΩúÔºåÁõ∏ÂΩì‰∫éÊåâ‰∏ã Android ‰∏ªÂ±èÂπïÊåâÈíÆ„ÄÇ‰ΩøÁî®Ê≠§Êìç‰ΩúÂèØÈÄÄÂá∫ÂΩìÂâçÂ∫îÁî®Âπ∂ËøîÂõûÂêØÂä®Âô®ÔºåÊàñ‰ªéÂ∑≤Áü•Áä∂ÊÄÅÂêØÂä®Êñ∞‰ªªÂä°„ÄÇÊ≠§Êìç‰ΩúÂÆåÊàêÂêéÔºåÊÇ®Â∞ÜËá™Âä®Êî∂Âà∞ÁªìÊûúÁä∂ÊÄÅÁöÑÊà™Âõæ„ÄÇ
- do(action="Wait", duration="x seconds")  
    Á≠âÂæÖÈ°µÈù¢Âä†ËΩΩÔºåx‰∏∫ÈúÄË¶ÅÁ≠âÂæÖÂ§öÂ∞ëÁßí„ÄÇ
- finish(message="xxx")  
    finishÊòØÁªìÊùü‰ªªÂä°ÁöÑÊìç‰ΩúÔºåË°®Á§∫ÂáÜÁ°ÆÂÆåÊï¥ÂÆåÊàê‰ªªÂä°ÔºåmessageÊòØÁªàÊ≠¢‰ø°ÊÅØ„ÄÇ 

ÂøÖÈ°ªÈÅµÂæ™ÁöÑËßÑÂàôÔºö
1. Âú®ÊâßË°å‰ªª‰ΩïÊìç‰ΩúÂâçÔºåÂÖàÊ£ÄÊü•ÂΩìÂâçappÊòØÂê¶ÊòØÁõÆÊ†áappÔºåÂ¶ÇÊûú‰∏çÊòØÔºåÂÖàÊâßË°å Launch„ÄÇ
2. Â¶ÇÊûúËøõÂÖ•Âà∞‰∫ÜÊó†ÂÖ≥È°µÈù¢ÔºåÂÖàÊâßË°å Back„ÄÇÂ¶ÇÊûúÊâßË°åBackÂêéÈ°µÈù¢Ê≤°ÊúâÂèòÂåñÔºåËØ∑ÁÇπÂáªÈ°µÈù¢Â∑¶‰∏äËßíÁöÑËøîÂõûÈîÆËøõË°åËøîÂõûÔºåÊàñËÄÖÂè≥‰∏äËßíÁöÑXÂè∑ÂÖ≥Èó≠„ÄÇ
3. Â¶ÇÊûúÈ°µÈù¢Êú™Âä†ËΩΩÂá∫ÂÜÖÂÆπÔºåÊúÄÂ§öËøûÁª≠ Wait ‰∏âÊ¨°ÔºåÂê¶ÂàôÊâßË°å BackÈáçÊñ∞ËøõÂÖ•„ÄÇ
4. Â¶ÇÊûúÈ°µÈù¢ÊòæÁ§∫ÁΩëÁªúÈóÆÈ¢òÔºåÈúÄË¶ÅÈáçÊñ∞Âä†ËΩΩÔºåËØ∑ÁÇπÂáªÈáçÊñ∞Âä†ËΩΩ„ÄÇ
5. Â¶ÇÊûúÂΩìÂâçÈ°µÈù¢Êâæ‰∏çÂà∞ÁõÆÊ†áËÅîÁ≥ª‰∫∫„ÄÅÂïÜÂìÅ„ÄÅÂ∫óÈì∫Á≠â‰ø°ÊÅØÔºåÂèØ‰ª•Â∞ùËØï Swipe ÊªëÂä®Êü•Êâæ„ÄÇ
6. ÈÅáÂà∞‰ª∑Ê†ºÂå∫Èó¥„ÄÅÊó∂Èó¥Âå∫Èó¥Á≠âÁ≠õÈÄâÊù°‰ª∂ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂÆåÂÖ®Á¨¶ÂêàÁöÑÔºåÂèØ‰ª•ÊîæÂÆΩË¶ÅÊ±Ç„ÄÇ
7. Âú®ÂÅöÂ∞èÁ∫¢‰π¶ÊÄªÁªìÁ±ª‰ªªÂä°Êó∂‰∏ÄÂÆöË¶ÅÁ≠õÈÄâÂõæÊñáÁ¨îËÆ∞„ÄÇ
8. Ë¥≠Áâ©ËΩ¶ÂÖ®ÈÄâÂêéÂÜçÁÇπÂáªÂÖ®ÈÄâÂèØ‰ª•ÊääÁä∂ÊÄÅËÆæ‰∏∫ÂÖ®‰∏çÈÄâÔºåÂú®ÂÅöË¥≠Áâ©ËΩ¶‰ªªÂä°Êó∂ÔºåÂ¶ÇÊûúË¥≠Áâ©ËΩ¶ÈáåÂ∑≤ÁªèÊúâÂïÜÂìÅË¢´ÈÄâ‰∏≠Êó∂Ôºå‰Ω†ÈúÄË¶ÅÁÇπÂáªÂÖ®ÈÄâÂêéÂÜçÁÇπÂáªÂèñÊ∂àÂÖ®ÈÄâÔºåÂÜçÂéªÊâæÈúÄË¶ÅË¥≠‰π∞ÊàñËÄÖÂà†Èô§ÁöÑÂïÜÂìÅ„ÄÇ
9. Âú®ÂÅöÂ§ñÂçñ‰ªªÂä°Êó∂ÔºåÂ¶ÇÊûúÁõ∏Â∫îÂ∫óÈì∫Ë¥≠Áâ©ËΩ¶ÈáåÂ∑≤ÁªèÊúâÂÖ∂‰ªñÂïÜÂìÅ‰Ω†ÈúÄË¶ÅÂÖàÊääË¥≠Áâ©ËΩ¶Ê∏ÖÁ©∫ÂÜçÂéªË¥≠‰π∞Áî®Êà∑ÊåáÂÆöÁöÑÂ§ñÂçñ„ÄÇ
10. Âú®ÂÅöÁÇπÂ§ñÂçñ‰ªªÂä°Êó∂ÔºåÂ¶ÇÊûúÁî®Êà∑ÈúÄË¶ÅÁÇπÂ§ö‰∏™Â§ñÂçñÔºåËØ∑Â∞ΩÈáèÂú®Âêå‰∏ÄÂ∫óÈì∫ËøõË°åË¥≠‰π∞ÔºåÂ¶ÇÊûúÊó†Ê≥ïÊâæÂà∞ÂèØ‰ª•‰∏ãÂçïÔºåÂπ∂ËØ¥ÊòéÊüê‰∏™ÂïÜÂìÅÊú™ÊâæÂà∞„ÄÇ
11. ËØ∑‰∏•Ê†ºÈÅµÂæ™Áî®Êà∑ÊÑèÂõæÊâßË°å‰ªªÂä°ÔºåÁî®Êà∑ÁöÑÁâπÊÆäË¶ÅÊ±ÇÂèØ‰ª•ÊâßË°åÂ§öÊ¨°ÊêúÁ¥¢ÔºåÊªëÂä®Êü•Êâæ„ÄÇÊØîÂ¶ÇÔºàiÔºâÁî®Êà∑Ë¶ÅÊ±ÇÁÇπ‰∏ÄÊùØÂíñÂï°ÔºåË¶ÅÂí∏ÁöÑÔºå‰Ω†ÂèØ‰ª•Áõ¥Êé•ÊêúÁ¥¢Âí∏ÂíñÂï°ÔºåÊàñËÄÖÊêúÁ¥¢ÂíñÂï°ÂêéÊªëÂä®Êü•ÊâæÂí∏ÁöÑÂíñÂï°ÔºåÊØîÂ¶ÇÊµ∑ÁõêÂíñÂï°„ÄÇÔºàiiÔºâÁî®Êà∑Ë¶ÅÊâæÂà∞XXÁæ§ÔºåÂèë‰∏ÄÊù°Ê∂àÊÅØÔºå‰Ω†ÂèØ‰ª•ÂÖàÊêúÁ¥¢XXÁæ§ÔºåÊâæ‰∏çÂà∞ÁªìÊûúÂêéÔºåÂ∞Ü"Áæ§"Â≠óÂéªÊéâÔºåÊêúÁ¥¢XXÈáçËØï„ÄÇÔºàiiiÔºâÁî®Êà∑Ë¶ÅÊâæÂà∞ÂÆ†Áâ©ÂèãÂ•ΩÁöÑÈ§êÂéÖÔºå‰Ω†ÂèØ‰ª•ÊêúÁ¥¢È§êÂéÖÔºåÊâæÂà∞Á≠õÈÄâÔºåÊâæÂà∞ËÆæÊñΩÔºåÈÄâÊã©ÂèØÂ∏¶ÂÆ†Áâ©ÔºåÊàñËÄÖÁõ¥Êé•ÊêúÁ¥¢ÂèØÂ∏¶ÂÆ†Áâ©ÔºåÂøÖË¶ÅÊó∂ÂèØ‰ª•‰ΩøÁî®AIÊêúÁ¥¢„ÄÇ
12. Âú®ÈÄâÊã©Êó•ÊúüÊó∂ÔºåÂ¶ÇÊûúÂéüÊªëÂä®ÊñπÂêë‰∏éÈ¢ÑÊúüÊó•ÊúüË∂äÊù•Ë∂äËøúÔºåËØ∑ÂêëÂèçÊñπÂêëÊªëÂä®Êü•Êâæ„ÄÇ
13. ÊâßË°å‰ªªÂä°ËøáÁ®ã‰∏≠Â¶ÇÊûúÊúâÂ§ö‰∏™ÂèØÈÄâÊã©ÁöÑÈ°πÁõÆÊ†èÔºåËØ∑ÈÄê‰∏™Êü•ÊâæÊØè‰∏™È°πÁõÆÊ†èÔºåÁõ¥Âà∞ÂÆåÊàê‰ªªÂä°Ôºå‰∏ÄÂÆö‰∏çË¶ÅÂú®Âêå‰∏ÄÈ°πÁõÆÊ†èÂ§öÊ¨°Êü•ÊâæÔºå‰ªéËÄåÈô∑ÂÖ•Ê≠ªÂæ™ÁéØ„ÄÇ
14. Âú®ÊâßË°å‰∏ã‰∏ÄÊ≠•Êìç‰ΩúÂâçËØ∑‰∏ÄÂÆöË¶ÅÊ£ÄÊü•‰∏ä‰∏ÄÊ≠•ÁöÑÊìç‰ΩúÊòØÂê¶ÁîüÊïàÔºåÂ¶ÇÊûúÁÇπÂáªÊ≤°ÁîüÊïàÔºåÂèØËÉΩÂõ†‰∏∫appÂèçÂ∫îËæÉÊÖ¢ÔºåËØ∑ÂÖàÁ®çÂæÆÁ≠âÂæÖ‰∏Ä‰∏ãÔºåÂ¶ÇÊûúËøòÊòØ‰∏çÁîüÊïàËØ∑Ë∞ÉÊï¥‰∏Ä‰∏ãÁÇπÂáª‰ΩçÁΩÆÈáçËØïÔºåÂ¶ÇÊûú‰ªçÁÑ∂‰∏çÁîüÊïàËØ∑Ë∑≥ËøáËøô‰∏ÄÊ≠•ÁªßÁª≠‰ªªÂä°ÔºåÂπ∂Âú®finish messageËØ¥ÊòéÁÇπÂáª‰∏çÁîüÊïà„ÄÇ
15. Âú®ÊâßË°å‰ªªÂä°‰∏≠Â¶ÇÊûúÈÅáÂà∞ÊªëÂä®‰∏çÁîüÊïàÁöÑÊÉÖÂÜµÔºåËØ∑Ë∞ÉÊï¥‰∏Ä‰∏ãËµ∑ÂßãÁÇπ‰ΩçÁΩÆÔºåÂ¢ûÂ§ßÊªëÂä®Ë∑ùÁ¶ªÈáçËØïÔºåÂ¶ÇÊûúËøòÊòØ‰∏çÁîüÊïàÔºåÊúâÂèØËÉΩÊòØÂ∑≤ÁªèÊªëÂà∞Â∫ï‰∫ÜÔºåËØ∑ÁªßÁª≠ÂêëÂèçÊñπÂêëÊªëÂä®ÔºåÁõ¥Âà∞È°∂ÈÉ®ÊàñÂ∫ïÈÉ®ÔºåÂ¶ÇÊûú‰ªçÁÑ∂Ê≤°ÊúâÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑÁªìÊûúÔºåËØ∑Ë∑≥ËøáËøô‰∏ÄÊ≠•ÁªßÁª≠‰ªªÂä°ÔºåÂπ∂Âú®finish messageËØ¥Êòé‰ΩÜÊ≤°ÊâæÂà∞Ë¶ÅÊ±ÇÁöÑÈ°πÁõÆ„ÄÇ
16. Âú®ÂÅöÊ∏∏Êàè‰ªªÂä°Êó∂Â¶ÇÊûúÂú®ÊàòÊñóÈ°µÈù¢Â¶ÇÊûúÊúâËá™Âä®ÊàòÊñó‰∏ÄÂÆöË¶ÅÂºÄÂêØËá™Âä®ÊàòÊñóÔºåÂ¶ÇÊûúÂ§öËΩÆÂéÜÂè≤Áä∂ÊÄÅÁõ∏‰ººË¶ÅÊ£ÄÊü•Ëá™Âä®ÊàòÊñóÊòØÂê¶ÂºÄÂêØ„ÄÇ
17. Â¶ÇÊûúÊ≤°ÊúâÂêàÈÄÇÁöÑÊêúÁ¥¢ÁªìÊûúÔºåÂèØËÉΩÊòØÂõ†‰∏∫ÊêúÁ¥¢È°µÈù¢‰∏çÂØπÔºåËØ∑ËøîÂõûÂà∞ÊêúÁ¥¢È°µÈù¢ÁöÑ‰∏ä‰∏ÄÁ∫ßÂ∞ùËØïÈáçÊñ∞ÊêúÁ¥¢ÔºåÂ¶ÇÊûúÂ∞ùËØï‰∏âÊ¨°ËøîÂõû‰∏ä‰∏ÄÁ∫ßÊêúÁ¥¢Âêé‰ªçÁÑ∂Ê≤°ÊúâÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑÁªìÊûúÔºåÊâßË°å finish(message="ÂéüÂõ†")„ÄÇ
18. Âú®ÁªìÊùü‰ªªÂä°ÂâçËØ∑‰∏ÄÂÆöË¶Å‰ªîÁªÜÊ£ÄÊü•‰ªªÂä°ÊòØÂê¶ÂÆåÊï¥ÂáÜÁ°ÆÁöÑÂÆåÊàêÔºåÂ¶ÇÊûúÂá∫Áé∞ÈîôÈÄâ„ÄÅÊºèÈÄâ„ÄÅÂ§öÈÄâÁöÑÊÉÖÂÜµÔºåËØ∑ËøîÂõû‰πãÂâçÁöÑÊ≠•È™§ËøõË°åÁ∫†Ê≠£„ÄÇ
"""
    )


def get_system_prompt_en() -> str:
    """Get English system prompt with current date (matches original prompts_en.py)."""
    from datetime import datetime

    today = datetime.today()
    formatted_date = today.strftime("%Y-%m-%d, %A")
    return (
        "The current date: "
        + formatted_date
        + """
# Setup
You are a professional Android operation agent assistant that can fulfill the user's high-level instructions. Given a screenshot of the Android interface at each step, you first analyze the situation, then plan the best course of action using Python-style pseudo-code.

# More details about the code
Your response format must be structured as follows:

Think first: Use <think>...</think> to analyze the current screen, identify key elements, and determine the most efficient action.
Provide the action: Use <answer>...</answer> to return a single line of pseudo-code representing the operation.

Your output should STRICTLY follow the format:
<think>
[Your thought]
</think>
<answer>
[Your operation code]
</answer>

- **Tap**
  Perform a tap action on a specified screen area. The element is a list of 2 integers, representing the coordinates of the tap point.
  **Example**:
  <answer>
  do(action="Tap", element=[x,y])
  </answer>
- **Type**
  Enter text into the currently focused input field.
  **Example**:
  <answer>
  do(action="Type", text="Hello World")
  </answer>
- **Swipe**
  Perform a swipe action with start point and end point.
  **Examples**:
  <answer>
  do(action="Swipe", start=[x1,y1], end=[x2,y2])
  </answer>
- **Long Press**
  Perform a long press action on a specified screen area.
  You can add the element to the action to specify the long press area. The element is a list of 2 integers, representing the coordinates of the long press point.
  **Example**:
  <answer>
  do(action="Long Press", element=[x,y])
  </answer>
- **Launch**
  Launch an app. Try to use launch action when you need to launch an app. Check the instruction to choose the right app before you use this action.
  **Example**:
  <answer>
  do(action="Launch", app="Settings")
  </answer>
- **Back**
  Press the Back button to navigate to the previous screen.
  **Example**:
  <answer>
  do(action="Back")
  </answer>
- **Finish**
  Terminate the program and optionally print a message.
  **Example**:
  <answer>
  finish(message="Task completed.")
  </answer>


REMEMBER:
- Think before you act: Always analyze the current UI and the best course of action before executing any step, and output in <think> part.
- Only ONE LINE of action in <answer> part per response: Each step must contain exactly one line of executable code.
- Generate execution code strictly according to format requirements.
"""
    )


def get_system_prompt(lang: str = "cn") -> str:
    """
    Get system prompt by language.

    Args:
        lang: Language code, 'cn' for Chinese (default), 'en' for English.

    Returns:
        System prompt string with current date.
    """
    if lang == "cn":
        return get_system_prompt_zh()
    else:
        return get_system_prompt_en()


# =============================================================================
# Default Configuration (agent-specific only, NOT LLM)
# =============================================================================

DEFAULT_CONFIG: Dict[str, Any] = {
    # Agent-specific settings only - LLM must be provided by user
    "lang": "cn",  # cn (18 detailed rules) or en (minimal rules)
    "stream": True,
}


# =============================================================================
# Timing Configuration (matches original Open-AutoGLM)
# =============================================================================


@dataclass
class ActionTimingConfig:
    """Configuration for action handler timing delays."""

    keyboard_switch_delay: float = 1.0
    text_clear_delay: float = 1.0
    text_input_delay: float = 1.0
    keyboard_restore_delay: float = 1.0


@dataclass
class DeviceTimingConfig:
    """Configuration for device operation timing delays."""

    default_tap_delay: float = 1.0
    default_double_tap_delay: float = 1.0
    double_tap_interval: float = 0.1
    default_long_press_delay: float = 1.0
    default_swipe_delay: float = 1.0
    default_back_delay: float = 1.0
    default_home_delay: float = 1.0
    default_launch_delay: float = 1.0


@dataclass
class TimingConfig:
    """Master timing configuration."""

    action: ActionTimingConfig = field(default_factory=ActionTimingConfig)
    device: DeviceTimingConfig = field(default_factory=DeviceTimingConfig)


TIMING_CONFIG = TimingConfig()


# =============================================================================
# Screenshot Data Class (matches original Open-AutoGLM)
# =============================================================================


@dataclass
class Screenshot:
    """Represents a captured screenshot (matches original interface)."""

    base64_data: str
    width: int
    height: int
    is_sensitive: bool = False


# =============================================================================
# Device Factory Wrapper (wraps DroidRun tools to match original interface)
# =============================================================================


class DeviceFactoryWrapper:
    """
    Wraps DroidRun Tools to provide the same interface as original Open-AutoGLM's
    DeviceFactory. All methods are async but match the original signatures and
    return types.
    """

    def __init__(self, tools, loop: asyncio.AbstractEventLoop):
        """
        Initialize wrapper.

        Args:
            tools: DroidRun Tools instance
            loop: Event loop for running async operations
        """
        self.tools = tools
        self.loop = loop
        self._current_app = "System Home"

    async def get_screenshot(self, timeout: int = 10) -> Screenshot:
        """
        Get screenshot matching original interface.

        Returns:
            Screenshot object with base64_data, width, height, is_sensitive
        """
        try:
            _, screenshot_bytes = await self.tools.take_screenshot()
            if screenshot_bytes:
                base64_data = base64.b64encode(screenshot_bytes).decode("utf-8")
                return Screenshot(
                    base64_data=base64_data,
                    width=self.tools.screen_width or 1080,
                    height=self.tools.screen_height or 2400,
                    is_sensitive=False,
                )
        except Exception as e:
            logger.warning(f"Screenshot failed: {e}")

        # Return fallback black image
        return self._create_fallback_screenshot()

    def _create_fallback_screenshot(self, is_sensitive: bool = False) -> Screenshot:
        """Create a black fallback image when screenshot fails."""
        # Create a minimal black PNG (1x1 pixel)
        # In production, you might want a full-size black image
        width = self.tools.screen_width or 1080
        height = self.tools.screen_height or 2400

        try:
            from io import BytesIO

            from PIL import Image

            black_img = Image.new("RGB", (width, height), color="black")
            buffered = BytesIO()
            black_img.save(buffered, format="PNG")
            base64_data = base64.b64encode(buffered.getvalue()).decode("utf-8")
        except ImportError:
            # Minimal 1x1 black PNG if PIL not available
            base64_data = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=="

        return Screenshot(
            base64_data=base64_data,
            width=width,
            height=height,
            is_sensitive=is_sensitive,
        )

    async def get_current_app(self) -> str:
        """
        Get current app name.

        Returns:
            App name string (or "System Home" if unknown)
        """
        # Try to get from tools state
        if hasattr(self.tools, "current_package") and self.tools.current_package:
            return self.tools.current_package

        # Try to extract from clickable elements
        if (
            hasattr(self.tools, "clickable_elements_cache")
            and self.tools.clickable_elements_cache
        ):
            first_elem = (
                self.tools.clickable_elements_cache[0]
                if self.tools.clickable_elements_cache
                else {}
            )
            pkg = first_elem.get("package", "")
            if pkg:
                return pkg

        return self._current_app

    async def tap(self, x: int, y: int, delay: Optional[float] = None) -> None:
        """
        Tap at coordinates with post-action delay.

        Args:
            x: X coordinate (pixels)
            y: Y coordinate (pixels)
            delay: Delay after tap (default: 1.0s)
        """
        if delay is None:
            delay = TIMING_CONFIG.device.default_tap_delay

        await self.tools.tap_by_coordinates(x, y)
        await asyncio.sleep(delay)

    async def double_tap(self, x: int, y: int, delay: Optional[float] = None) -> None:
        """
        Double tap at coordinates.

        Args:
            x: X coordinate (pixels)
            y: Y coordinate (pixels)
            delay: Delay after double tap (default: 1.0s)
        """
        if delay is None:
            delay = TIMING_CONFIG.device.default_double_tap_delay

        await self.tools.tap_by_coordinates(x, y)
        await asyncio.sleep(TIMING_CONFIG.device.double_tap_interval)
        await self.tools.tap_by_coordinates(x, y)
        await asyncio.sleep(delay)

    async def long_press(
        self, x: int, y: int, duration_ms: int = 3000, delay: Optional[float] = None
    ) -> None:
        """
        Long press at coordinates.

        Args:
            x: X coordinate (pixels)
            y: Y coordinate (pixels)
            duration_ms: Press duration in milliseconds
            delay: Delay after long press (default: 1.0s)
        """
        if delay is None:
            delay = TIMING_CONFIG.device.default_long_press_delay

        # Long press = swipe from same point to same point
        await self.tools.swipe(x, y, x, y, duration_ms=duration_ms)
        await asyncio.sleep(delay)

    async def swipe(
        self,
        start_x: int,
        start_y: int,
        end_x: int,
        end_y: int,
        duration_ms: Optional[int] = None,
        delay: Optional[float] = None,
    ) -> None:
        """
        Swipe from start to end coordinates.

        Args:
            start_x, start_y: Starting coordinates
            end_x, end_y: Ending coordinates
            duration_ms: Swipe duration (auto-calculated if None)
            delay: Delay after swipe (default: 1.0s)
        """
        if delay is None:
            delay = TIMING_CONFIG.device.default_swipe_delay

        if duration_ms is None:
            # Calculate duration based on distance (matches original)
            dist_sq = (start_x - end_x) ** 2 + (start_y - end_y) ** 2
            duration_ms = int(dist_sq / 1000)
            duration_ms = max(1000, min(duration_ms, 2000))  # Clamp 1000-2000ms

        await self.tools.swipe(start_x, start_y, end_x, end_y, duration_ms=duration_ms)
        await asyncio.sleep(delay)

    async def back(self, delay: Optional[float] = None) -> None:
        """Press back button."""
        if delay is None:
            delay = TIMING_CONFIG.device.default_back_delay

        await self.tools.press_key(4)  # KEYCODE_BACK
        await asyncio.sleep(delay)

    async def home(self, delay: Optional[float] = None) -> None:
        """Press home button."""
        if delay is None:
            delay = TIMING_CONFIG.device.default_home_delay

        await self.tools.press_key(3)  # KEYCODE_HOME
        await asyncio.sleep(delay)

    async def launch_app(self, app_name: str, delay: Optional[float] = None) -> bool:
        """
        Launch an app by name.

        Args:
            app_name: App name or package name

        Returns:
            True if launched successfully
        """
        if delay is None:
            delay = TIMING_CONFIG.device.default_launch_delay

        try:
            await self.tools.start_app(app_name)
            await asyncio.sleep(delay)
            return True
        except Exception as e:
            logger.warning(f"Failed to launch {app_name}: {e}")
            return False

    async def type_text(self, text: str) -> None:
        """
        Type text with keyboard handling.

        Matches original behavior:
        1. Switch to ADB keyboard (handled by DroidRun portal)
        2. Clear existing text
        3. Type new text
        4. Restore keyboard (handled by DroidRun portal)
        """
        # DroidRun's input_text with clear=True handles all this
        await self.tools.input_text(text, index=-1, clear=True)
        await asyncio.sleep(TIMING_CONFIG.action.text_input_delay)

    async def clear_text(self) -> None:
        """Clear text in focused field."""
        # Type empty string with clear flag
        await self.tools.input_text("", index=-1, clear=True)
        await asyncio.sleep(TIMING_CONFIG.action.text_clear_delay)


# =============================================================================
# Message Builder (matches original Open-AutoGLM)
# =============================================================================


class MessageBuilder:
    """Helper class for building OpenAI-compatible conversation messages."""

    @staticmethod
    def create_system_message(content: str) -> Dict[str, Any]:
        """Create a system message."""
        return {"role": "system", "content": content}

    @staticmethod
    def create_user_message(
        text: str, image_base64: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create a user message with optional image in OpenAI format.

        Image comes first, then text (matches original).
        """
        content: List[Dict[str, Any]] = []

        if image_base64:
            content.append(
                {
                    "type": "image_url",
                    "image_url": {"url": f"data:image/png;base64,{image_base64}"},
                }
            )

        content.append({"type": "text", "text": text})

        return {"role": "user", "content": content}

    @staticmethod
    def create_assistant_message(content: str) -> Dict[str, Any]:
        """Create an assistant message."""
        return {"role": "assistant", "content": content}

    @staticmethod
    def remove_images_from_message(message: Dict[str, Any]) -> Dict[str, Any]:
        """Remove image content from a message to save context space."""
        if isinstance(message.get("content"), list):
            message["content"] = [
                item for item in message["content"] if item.get("type") == "text"
            ]
        return message

    @staticmethod
    def build_screen_info(current_app: str, **extra_info) -> str:
        """Build screen info JSON string."""
        info = {"current_app": current_app, **extra_info}
        return json.dumps(info, ensure_ascii=False)


# =============================================================================
# Action Parsing (matches original Open-AutoGLM)
# =============================================================================


@dataclass
class ActionResult:
    """Result of an action execution (matches original Open-AutoGLM)."""

    success: bool
    should_finish: bool
    message: Optional[str] = None
    requires_confirmation: bool = False


def parse_action(response: str) -> Dict[str, Any]:
    """
    Parse action from model response.

    Matches original Open-AutoGLM handler.py parse_action exactly.
    """
    logger.debug(f"Parsing action: {response}")
    try:
        response = response.strip()

        # Special case for Type/Type_Name - extract text directly (matches original)
        if response.startswith('do(action="Type"') or response.startswith(
            'do(action="Type_Name"'
        ):
            text = response.split("text=", 1)[1][1:-2]
            action = {"_metadata": "do", "action": "Type", "text": text}
            return action

        elif response.startswith("do"):
            # Use AST parsing instead of eval for safety
            try:
                # Escape special characters (newlines, tabs, etc.) for valid Python syntax
                response = response.replace("\n", "\\n")
                response = response.replace("\r", "\\r")
                response = response.replace("\t", "\\t")

                tree = ast.parse(response, mode="eval")
                if not isinstance(tree.body, ast.Call):
                    raise ValueError("Expected a function call")

                call = tree.body
                # Extract keyword arguments safely
                action: Dict[str, Any] = {"_metadata": "do"}
                for keyword in call.keywords:
                    key = keyword.arg
                    value = ast.literal_eval(keyword.value)
                    action[key] = value

                return action
            except (SyntaxError, ValueError) as e:
                raise ValueError(f"Failed to parse do() action: {e}") from e

        elif response.startswith("finish"):
            action = {
                "_metadata": "finish",
                "message": response.replace("finish(message=", "")[1:-2],
            }
        else:
            raise ValueError(f"Failed to parse action: {response}")
        return action
    except Exception as e:
        raise ValueError(f"Failed to parse action: {e}") from e


def do(**kwargs) -> Dict[str, Any]:
    """Helper function for creating 'do' actions."""
    kwargs["_metadata"] = "do"
    return kwargs


def finish(**kwargs) -> Dict[str, Any]:
    """Helper function for creating 'finish' actions."""
    kwargs["_metadata"] = "finish"
    return kwargs


def parse_response(content: str) -> Tuple[str, str]:
    """
    Parse the model response into thinking and action parts.

    Matches original Open-AutoGLM parsing rules.
    """
    # Rule 1: Check for finish(message=
    if "finish(message=" in content:
        parts = content.split("finish(message=", 1)
        thinking = parts[0].strip()
        action = "finish(message=" + parts[1]
        return thinking, action

    # Rule 2: Check for do(action=
    if "do(action=" in content:
        parts = content.split("do(action=", 1)
        thinking = parts[0].strip()
        action = "do(action=" + parts[1]
        return thinking, action

    # Rule 3: Fallback to legacy XML tag parsing
    if "<answer>" in content:
        parts = content.split("<answer>", 1)
        thinking = parts[0].replace("<think>", "").replace("</think>", "").strip()
        action = parts[1].replace("</answer>", "").strip()
        return thinking, action

    # Rule 4: No markers found, return content as action
    return "", content


# =============================================================================
# Action Handler (matches original Open-AutoGLM)
# =============================================================================


class ActionHandler:
    """
    Handles execution of actions from AI model output.

    Matches original Open-AutoGLM ActionHandler interface.

    Args:
        device: DeviceFactoryWrapper instance for device operations.
        confirmation_callback: Optional callback for sensitive action confirmation.
            Should return True to proceed, False to cancel.
        takeover_callback: Optional callback for takeover requests (login, captcha).
    """

    def __init__(
        self,
        device: DeviceFactoryWrapper,
        confirmation_callback: Optional[Callable[[str], bool]] = None,
        takeover_callback: Optional[Callable[[str], None]] = None,
    ):
        self.device = device
        self.confirmation_callback = confirmation_callback or self._default_confirmation
        self.takeover_callback = takeover_callback or self._default_takeover

    def _convert_relative_to_absolute(
        self, element: List[int], screen_width: int, screen_height: int
    ) -> Tuple[int, int]:
        """Convert relative coordinates (0-1000) to absolute pixels."""
        x = int(element[0] / 1000 * screen_width)
        y = int(element[1] / 1000 * screen_height)
        return x, y

    async def execute(
        self, action: Dict[str, Any], screen_width: int, screen_height: int
    ) -> ActionResult:
        """
        Execute an action from the AI model.

        Args:
            action: The action dictionary from the model.
            screen_width: Current screen width in pixels.
            screen_height: Current screen height in pixels.

        Returns:
            ActionResult indicating success and whether to finish.
        """
        action_type = action.get("_metadata")

        if action_type == "finish":
            return ActionResult(
                success=True, should_finish=True, message=action.get("message")
            )

        if action_type != "do":
            return ActionResult(
                success=False,
                should_finish=True,
                message=f"Unknown action type: {action_type}",
            )

        action_name = action.get("action")
        handler_method = self._get_handler(action_name)

        if handler_method is None:
            return ActionResult(
                success=False,
                should_finish=False,
                message=f"Unknown action: {action_name}",
            )

        try:
            return await handler_method(action, screen_width, screen_height)
        except Exception as e:
            return ActionResult(
                success=False, should_finish=False, message=f"Action failed: {e}"
            )

    def _get_handler(self, action_name: str) -> Optional[Callable]:
        """Get the handler method for an action."""
        handlers = {
            "Launch": self._handle_launch,
            "Tap": self._handle_tap,
            "Type": self._handle_type,
            "Type_Name": self._handle_type,
            "Swipe": self._handle_swipe,
            "Back": self._handle_back,
            "Home": self._handle_home,
            "Double Tap": self._handle_double_tap,
            "Long Press": self._handle_long_press,
            "Wait": self._handle_wait,
            "Take_over": self._handle_takeover,
            "Note": self._handle_note,
            "Call_API": self._handle_call_api,
            "Interact": self._handle_interact,
        }
        return handlers.get(action_name)

    async def _handle_launch(
        self, action: Dict, width: int, height: int
    ) -> ActionResult:
        """Handle app launch action."""
        app_name = action.get("app")
        if not app_name:
            return ActionResult(False, False, "No app name specified")

        success = await self.device.launch_app(app_name)
        if success:
            return ActionResult(True, False)
        return ActionResult(False, False, f"App not found: {app_name}")

    async def _handle_tap(self, action: Dict, width: int, height: int) -> ActionResult:
        """Handle tap action."""
        element = action.get("element")
        if not element:
            return ActionResult(False, False, "No element coordinates")

        x, y = self._convert_relative_to_absolute(element, width, height)

        # Check for sensitive operation
        if "message" in action:
            if not self.confirmation_callback(action["message"]):
                return ActionResult(
                    success=False,
                    should_finish=True,
                    message="User cancelled sensitive operation",
                )

        await self.device.tap(x, y)
        return ActionResult(True, False)

    async def _handle_type(self, action: Dict, width: int, height: int) -> ActionResult:
        """Handle text input action."""
        text = action.get("text", "")
        await self.device.type_text(text)
        return ActionResult(True, False)

    async def _handle_swipe(
        self, action: Dict, width: int, height: int
    ) -> ActionResult:
        """Handle swipe action."""
        start = action.get("start")
        end = action.get("end")

        if not start or not end:
            return ActionResult(False, False, "Missing swipe coordinates")

        start_x, start_y = self._convert_relative_to_absolute(start, width, height)
        end_x, end_y = self._convert_relative_to_absolute(end, width, height)

        await self.device.swipe(start_x, start_y, end_x, end_y)
        return ActionResult(True, False)

    async def _handle_back(self, action: Dict, width: int, height: int) -> ActionResult:
        """Handle back button action."""
        await self.device.back()
        return ActionResult(True, False)

    async def _handle_home(self, action: Dict, width: int, height: int) -> ActionResult:
        """Handle home button action."""
        await self.device.home()
        return ActionResult(True, False)

    async def _handle_double_tap(
        self, action: Dict, width: int, height: int
    ) -> ActionResult:
        """Handle double tap action."""
        element = action.get("element")
        if not element:
            return ActionResult(False, False, "No element coordinates")

        x, y = self._convert_relative_to_absolute(element, width, height)
        await self.device.double_tap(x, y)
        return ActionResult(True, False)

    async def _handle_long_press(
        self, action: Dict, width: int, height: int
    ) -> ActionResult:
        """Handle long press action."""
        element = action.get("element")
        if not element:
            return ActionResult(False, False, "No element coordinates")

        x, y = self._convert_relative_to_absolute(element, width, height)
        await self.device.long_press(x, y)
        return ActionResult(True, False)

    async def _handle_wait(self, action: Dict, width: int, height: int) -> ActionResult:
        """Handle wait action."""
        duration_str = action.get("duration", "1 seconds")
        try:
            duration = float(duration_str.replace("seconds", "").strip())
        except ValueError:
            duration = 1.0

        await asyncio.sleep(duration)
        return ActionResult(True, False)

    async def _handle_takeover(
        self, action: Dict, width: int, height: int
    ) -> ActionResult:
        """Handle takeover request (login, captcha, etc.)."""
        message = action.get("message", "User intervention required")
        self.takeover_callback(message)
        return ActionResult(True, False)

    async def _handle_note(self, action: Dict, width: int, height: int) -> ActionResult:
        """Handle note action (placeholder for content recording)."""
        # This action is typically used for recording page content
        # Implementation depends on specific requirements
        return ActionResult(True, False)

    async def _handle_call_api(
        self, action: Dict, width: int, height: int
    ) -> ActionResult:
        """Handle API call action (placeholder for summarization)."""
        # This action is typically used for content summarization
        # Implementation depends on specific requirements
        return ActionResult(True, False)

    async def _handle_interact(
        self, action: Dict, width: int, height: int
    ) -> ActionResult:
        """Handle interaction request (user choice needed)."""
        # This action signals that user input is needed
        return ActionResult(True, False, message="User interaction required")

    @staticmethod
    def _default_confirmation(message: str) -> bool:
        """Default confirmation callback using console input."""
        response = input(f"Sensitive operation: {message}\nConfirm? (Y/N): ")
        return response.upper() == "Y"

    @staticmethod
    def _default_takeover(message: str) -> None:
        """Default takeover callback using console input."""
        input(f"{message}\nPress Enter after completing manual operation...")


# =============================================================================
# Main Entry Point
# =============================================================================


async def run(
    tools,
    instruction: str,
    config: Dict[str, Any],
    max_steps: int = 15,
    confirmation_callback: Optional[Callable[[str], bool]] = None,
    takeover_callback: Optional[Callable[[str], None]] = None,
) -> Dict[str, Any]:
    """
    Run AutoGLM agent matching original Open-AutoGLM implementation.

    Args:
        tools: DroidRun Tools instance
        instruction: Task to complete
        config: Configuration dictionary:
            llm: Dict passed directly to load_llm() - REQUIRED
                provider: LLM provider (required, e.g. "OpenAILike")
                model: Model name (required, e.g. "autoglm-phone-9b")
                + any other params for load_llm (temperature, base_url, etc.)
            lang: "cn" (detailed rules) or "en" (minimal) - default: "cn"
            stream: Enable streaming - default: True
        max_steps: Max iterations
        confirmation_callback: Optional callback for sensitive action confirmation
        takeover_callback: Optional callback for takeover requests

    Returns:
        {"success": bool, "reason": str, "steps": int}
    """
    # Validate LLM config - must be provided by user
    llm_cfg = config.get("llm")
    if not llm_cfg or not isinstance(llm_cfg, dict):
        raise ValueError(
            "AutoGLM requires 'llm' configuration. "
            "Please configure external_agents.autoglm.llm in your config.yaml"
        )

    if "provider" not in llm_cfg:
        raise ValueError(
            "AutoGLM requires 'llm.provider' to be specified. "
            "Example: provider: OpenAILike"
        )

    if "model" not in llm_cfg:
        raise ValueError(
            "AutoGLM requires 'llm.model' to be specified. "
            "Example: model: autoglm-phone-9b"
        )

    # Load LLM - pass config directly to load_llm
    llm_cfg = dict(llm_cfg)  # Copy to avoid mutating
    provider = llm_cfg.pop("provider")
    llm = load_llm(provider, **llm_cfg)

    # Agent-specific configuration (defaults from DEFAULT_CONFIG)
    lang = config.get("lang", DEFAULT_CONFIG["lang"])
    stream = config.get("stream", DEFAULT_CONFIG["stream"])

    # Get system prompt with date (matches original)
    system_prompt = get_system_prompt(lang=lang)

    # Create device wrapper
    loop = asyncio.get_running_loop()
    device = DeviceFactoryWrapper(tools, loop)

    # Stateful conversation context (matches original)
    context: List[Dict[str, Any]] = []

    logger.info(f"ü§ñ AutoGLM: {instruction}")

    for step in range(max_steps):
        step_start = time.time()
        logger.info(f"üìç Step {step + 1}/{max_steps}")

        # Get current screen state
        await tools.get_state()
        w = tools.screen_width or 1080
        h = tools.screen_height or 2400

        # Get screenshot (matches original interface)
        screenshot = await device.get_screenshot()

        # Get current app (matches original)
        current_app = await device.get_current_app()

        # Build screen info (matches original format)
        screen_info = MessageBuilder.build_screen_info(current_app)

        # Build messages (matches original flow)
        if step == 0:
            # First step: system message + user message with task + screen info
            context.append(MessageBuilder.create_system_message(system_prompt))
            text_content = f"{instruction}\n\n{screen_info}"
            context.append(
                MessageBuilder.create_user_message(text_content, screenshot.base64_data)
            )
        else:
            # Subsequent steps: user message with screen info
            text_content = f"** Screen Info **\n\n{screen_info}"
            context.append(
                MessageBuilder.create_user_message(text_content, screenshot.base64_data)
            )

        # Convert to LlamaIndex format and call LLM
        try:
            response = await acall_with_retries(
                llm,
                to_chat_messages(context),
                stream=stream,
            )
            response_text = str(response)
        except Exception as e:
            logger.error(f"LLM call failed: {e}")
            return {"success": False, "reason": f"LLM error: {e}", "steps": step + 1}

        # Parse thinking and action (matches original)
        thinking, action_str = parse_response(response_text)

        # Only log thinking if not streaming (streaming already printed it)
        if thinking and not stream:
            logger.info(f"üí≠ {thinking[:200]}{'...' if len(thinking) > 200 else ''}")

        # Remove image from current user message BEFORE adding assistant (matches original agent.py:205)
        context[-1] = MessageBuilder.remove_images_from_message(context[-1])

        # Add assistant response to context (matches original format)
        context.append(
            MessageBuilder.create_assistant_message(
                f"<think>{thinking}</think><answer>{action_str}</answer>"
            )
        )

        # Parse action
        try:
            action = parse_action(action_str)
        except ValueError as e:
            logger.warning(f"Failed to parse action: {e}")
            action = {"_metadata": "finish", "message": action_str}

        action_name = action.get("action", action.get("_metadata", "unknown"))
        # Log action with key details
        if action_name in ("Tap", "Double Tap", "Long Press"):
            coords = action.get("element", [])
            logger.info(f"‚ö° {action_name} {coords}")
        elif action_name == "Swipe":
            start, end = action.get("start", []), action.get("end", [])
            logger.info(f"‚ö° {action_name} {start} ‚Üí {end}")
        elif action_name == "Type":
            text = action.get("text", "")[:30]
            logger.info(
                f"‚ö° {action_name}: \"{text}{'...' if len(action.get('text', '')) > 30 else ''}\""
            )
        elif action_name == "Launch":
            logger.info(f"‚ö° {action_name}: {action.get('app', '')}")
        elif action_name == "finish":
            logger.info(f"‚ö° {action_name}: {action.get('message', '')[:50]}")
        else:
            logger.info(f"‚ö° {action_name}")

        # Create action handler and execute (matches original interface)
        handler = ActionHandler(
            device=device,
            confirmation_callback=confirmation_callback,
            takeover_callback=takeover_callback,
        )

        result = await handler.execute(action, screenshot.width, screenshot.height)

        step_time = time.time() - step_start
        logger.debug(f"   ‚è±Ô∏è {step_time:.1f}s")

        # Check if finished
        if result.should_finish:
            reason = result.message or action.get("message", "Task completed")
            logger.info(f"‚úÖ Done ({step + 1} steps): {reason}")
            return {"success": result.success, "reason": reason, "steps": step + 1}

    logger.warning(f"‚ö†Ô∏è Max steps ({max_steps}) reached")
    return {"success": False, "reason": "Max steps reached", "steps": max_steps}

```

`droidrun/agent/external/mai_ui.py`:

```py
"""MAI-UI External Agent - Exact implementation matching MAI-UI prompts and behavior.

This agent replicates MAI-UI's exact prompts, message building, and trajectory
management while using DroidRun's AdbTools for execution.
"""

import asyncio
import base64
import copy
import json
import logging
import re
from dataclasses import dataclass, field
from io import BytesIO
from typing import Any, Dict, List, Optional, Tuple

from PIL import Image
from jinja2 import Template

from droidrun.agent.oneflows.app_starter_workflow import AppStarter
from droidrun.agent.utils.chat_utils import to_chat_messages
from droidrun.agent.utils.inference import acall_with_retries
from droidrun.agent.utils.llm_picker import load_llm

logger = logging.getLogger("droidrun")

# =============================================================================
# Constants
# =============================================================================

SCALE_FACTOR = 999

# =============================================================================
# Default Configuration (agent-specific only, NOT LLM)
# =============================================================================

DEFAULT_CONFIG: Dict[str, Any] = {
    # Agent-specific settings matching MAI-UI defaults
    "history_n": 3,  # Number of history steps with images
    # Note: vision is always True for MAI-UI (screenshot-based agent)
}


# =============================================================================
# Trajectory Memory (matches MAI-UI's unified_memory.py)
# =============================================================================


@dataclass
class TrajStep:
    """
    Single step in an agent's trajectory.

    Attributes:
        screenshot_bytes: Screenshot as PNG bytes
        prediction: Raw LLM response text
        action: Parsed action dictionary
        thought: Extracted thinking/reasoning
        step_index: Index of this step
        structured_action: {"action_json": action} for history reconstruction
        ask_user_response: Response from user when ask_user action was used
    """

    screenshot_bytes: bytes
    prediction: str
    action: Dict[str, Any]
    thought: str
    step_index: int
    structured_action: Dict[str, Any]
    ask_user_response: Optional[str] = None


@dataclass
class TrajMemory:
    """
    Container for complete trajectory.

    Attributes:
        task_goal: The instruction/goal for this trajectory
        steps: List of trajectory steps
    """

    task_goal: str
    steps: List[TrajStep] = field(default_factory=list)


# =============================================================================
# System Prompt (exact MAI-UI prompt with MCP template - renders without MCP when no tools passed)
# =============================================================================

# fmt: off
MAI_MOBILE_SYS_PROMPT_TEMPLATE = Template(
    "You are a GUI agent. You are given a task and your action history, with screenshots. You need to perform the next action to complete the task. \n"
    "\n"
    "## Output Format\n"
    "For each function call, return the thinking process in <thinking> </thinking> tags, and a json object with function name and arguments within <tool_call></tool_call> XML tags:\n"
    "```\n"
    "<thinking>\n"
    "...\n"
    "</thinking>\n"
    "<tool_call>\n"
    "{\"name\": \"mobile_use\", \"arguments\": <args-json-object>}\n"
    "</tool_call>\n"
    "```\n"
    "\n"
    "## Action Space\n"
    "\n"
    "{\"action\": \"click\", \"coordinate\": [x, y]}\n"
    "{\"action\": \"long_press\", \"coordinate\": [x, y]}\n"
    "{\"action\": \"type\", \"text\": \"\"}\n"
    "{\"action\": \"swipe\", \"direction\": \"up or down or left or right\", \"coordinate\": [x, y]} # \"coordinate\" is optional. Use the \"coordinate\" if you want to swipe a specific UI element.\n"
    "{\"action\": \"open\", \"text\": \"app_name\"}\n"
    "{\"action\": \"drag\", \"start_coordinate\": [x1, y1], \"end_coordinate\": [x2, y2]}\n"
    "{\"action\": \"system_button\", \"button\": \"button_name\"} # Options: back, home, menu, enter \n"
    "{\"action\": \"wait\"}\n"
    "{\"action\": \"terminate\", \"status\": \"success or fail\"} \n"
    "{\"action\": \"answer\", \"text\": \"xxx\"} # Use escape characters \\', \\\", and \\n in text part to ensure we can parse the text in normal python string format.\n"
    "{\"action\": \"ask_user\", \"text\": \"xxx\"} # you can ask user for more information to complete the task.\n"
    "{\"action\": \"double_click\", \"coordinate\": [x, y]}\n"
    "\n"
    "{% if tools %}"
    "## MCP Tools\n"
    "You are also provided with MCP tools, you can use them to complete the task.\n"
    "{{ tools }}\n"
    "\n"
    "If you want to use MCP tools, you must output as the following format:\n"
    "```\n"
    "<thinking>\n"
    "...\n"
    "</thinking>\n"
    "<tool_call>\n"
    "{\"name\": <function-name>, \"arguments\": <args-json-object>}\n"
    "</tool_call>\n"
    "```\n"
    "{% endif %}"
    "## Note\n"
    "- Available Apps: `{{ apps_list }}`.\n"
    "- Write a small plan and finally summarize your next action (with its target element) in one sentence in <thinking></thinking> part."
)
# fmt: on


# =============================================================================
# Parsing Functions (matches MAI-UI's parsing)
# =============================================================================


def parse_tagged_text(text: str) -> Dict[str, Any]:
    """
    Parse text containing <thinking> and <tool_call> tags.

    Handles both standard format and thinking model format (</think>).

    Args:
        text: Raw model output

    Returns:
        Dictionary with "thinking" and "tool_call" keys
    """
    text = text.strip()

    # Handle thinking model output format (uses </think> instead of </thinking>)
    if "</think>" in text and "</thinking>" not in text:
        text = text.replace("</think>", "</thinking>")
        text = "<thinking>" + text

    result: Dict[str, Any] = {
        "thinking": None,
        "tool_call": None,
    }

    # Extract thinking content
    think_pattern = r"<thinking>(.*?)</thinking>"
    think_match = re.search(think_pattern, text, re.DOTALL)
    if think_match:
        result["thinking"] = think_match.group(1).strip()

    # Extract tool_call content
    call_pattern = r"<tool_call>(.*?)</tool_call>"
    call_match = re.search(call_pattern, text, re.DOTALL)
    if call_match:
        try:
            result["tool_call"] = json.loads(call_match.group(1).strip())
        except json.JSONDecodeError:
            result["tool_call"] = None

    return result


def parse_action(text: str) -> Dict[str, Any]:
    """
    Parse model output into structured action format.

    Normalizes coordinates from SCALE_FACTOR (0-999) to 0-1 range,
    matching MAI-UI's parse_action_to_structure_output behavior.

    Args:
        text: Raw model output

    Returns:
        Dictionary with "thinking" and "action_json" keys

    Raises:
        ValueError: If parsing fails
    """
    parsed = parse_tagged_text(text)

    if not parsed["tool_call"]:
        raise ValueError("No valid tool_call found in response")

    action = parsed["tool_call"].get("arguments", {})

    # Normalize coordinates from SCALE_FACTOR range to [0, 1]
    # This matches MAI-UI's parse_action_to_structure_output behavior
    for coord_key in ["coordinate", "start_coordinate", "end_coordinate"]:
        if coord_key in action:
            coordinates = action[coord_key]
            if len(coordinates) == 2:
                point_x, point_y = coordinates
            elif len(coordinates) == 4:
                # Handle bounding box format (x1, y1, x2, y2) -> center point
                x1, y1, x2, y2 = coordinates
                point_x = (x1 + x2) / 2
                point_y = (y1 + y2) / 2
            else:
                raise ValueError(
                    f"Invalid {coord_key} format: expected 2 or 4 values, got {len(coordinates)}"
                )
            action[coord_key] = [point_x / SCALE_FACTOR, point_y / SCALE_FACTOR]

    return {
        "thinking": parsed["thinking"],
        "action_json": action,
    }


# =============================================================================
# Helper Functions
# =============================================================================


def pil_to_base64(image: Image.Image) -> str:
    """Convert PIL Image to base64 string."""
    buffer = BytesIO()
    image.save(buffer, format="PNG")
    return base64.b64encode(buffer.getvalue()).decode("utf-8")


def bytes_to_base64(image_bytes: bytes) -> str:
    image = Image.open(BytesIO(image_bytes))
    if image.mode != "RGB":
        image = image.convert("RGB")
    buffer = BytesIO()
    image.save(buffer, format="PNG")
    return base64.b64encode(buffer.getvalue()).decode("utf-8")


async def resolve_app_name(tools, app_name: str) -> str:
    """
    Resolve friendly app name to package name.

    Args:
        tools: DroidRun Tools instance
        app_name: Friendly app name (e.g., "Settings", "Chrome")

    Returns:
        Package name (e.g., "com.android.settings")
    """
    try:
        apps = await tools.get_apps(include_system=True)

        # Try exact label match (case-insensitive)
        for app in apps:
            if app.get("label", "").lower() == app_name.lower():
                return app["package"]

        # Try partial match
        for app in apps:
            if app_name.lower() in app.get("label", "").lower():
                return app["package"]

        # Return as-is (might already be a package name)
        return app_name

    except Exception as e:
        logger.warning(f"Failed to resolve app name '{app_name}': {e}")
        return app_name


async def get_available_apps(tools) -> str:
    """
    Get list of available apps for the prompt.

    Returns:
        Formatted string of app names
    """
    try:
        apps = await tools.get_apps(include_system=False)
        app_names = [app.get("label", app.get("package", "")) for app in apps[:30]]
        return json.dumps(app_names)
    except Exception:
        # Fallback to generic list
        return '["Settings", "Chrome", "Camera", "Files", "Contacts", "Messages", "Phone", "Calendar", "Clock", "Calculator"]'


# =============================================================================
# Message Building (matches MAI-UI's _build_messages)
# =============================================================================


def mem2response(step: TrajStep) -> str:
    """
    Reconstruct assistant response from trajectory step.

    Converts stored action back to the format the LLM expects in history.

    Args:
        step: Trajectory step

    Returns:
        Formatted response string with <thinking> and <tool_call> tags
    """
    thinking = step.thought or ""
    structured_action = step.structured_action

    if not structured_action:
        return f"<thinking>\n{thinking}\n</thinking>\n<tool_call>\n{{}}\n</tool_call>"

    action_json = copy.deepcopy(structured_action.get("action_json", {}))

    # Convert normalized coordinates back to SCALE_FACTOR range for history
    # NOTE: Original MAI-UI only converts "coordinate", NOT start_coordinate/end_coordinate
    # This matches the behavior in mai_naivigation_agent.py mem2response()
    if "coordinate" in action_json:
        coords = action_json["coordinate"]
        if len(coords) == 2:
            # Coordinates are stored normalized (0-1), convert to 0-999
            action_json["coordinate"] = [
                int(coords[0] * SCALE_FACTOR),
                int(coords[1] * SCALE_FACTOR),
            ]

    tool_call_dict = {
        "name": "mobile_use",
        "arguments": action_json,
    }
    tool_call_json = json.dumps(tool_call_dict, separators=(",", ":"))

    return f"<thinking>\n{thinking}\n</thinking>\n<tool_call>\n{tool_call_json}\n</tool_call>"


def build_messages(
    instruction: str,
    system_prompt: str,
    traj_memory: TrajMemory,
    current_screenshot_bytes: bytes,
    history_n: int = 3,
) -> List[Dict[str, Any]]:
    """
    Build multi-turn messages matching MAI-UI's format.

    Message structure:
    1. System prompt
    2. User instruction
    3. For each history step:
       - Image (only for last history_n-1 steps)
       - Assistant response
    4. Current screenshot

    Args:
        instruction: Task instruction
        system_prompt: System prompt text
        traj_memory: Trajectory memory with history
        current_screenshot_bytes: Current screenshot as bytes
        history_n: Number of history images to include

    Returns:
        List of message dictionaries
    """
    messages = [
        {
            "role": "system",
            "content": [{"type": "text", "text": system_prompt}],
        },
        {
            "role": "user",
            "content": [{"type": "text", "text": instruction}],
        },
    ]

    steps = traj_memory.steps
    image_idx = 0

    if len(steps) > 0:
        # Calculate which steps get images (last history_n - 1 steps)
        start_image_idx = max(0, len(steps) - (history_n - 1))

        # Collect history images
        history_images = []
        for i, step in enumerate(steps):
            if i >= start_image_idx:
                history_images.append(step.screenshot_bytes)

        for history_idx, step in enumerate(steps):
            should_include_image = history_idx >= start_image_idx

            if should_include_image and image_idx < len(history_images):
                # Add image before assistant response
                encoded = bytes_to_base64(history_images[image_idx])
                messages.append(
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/png;base64,{encoded}"
                                },
                            }
                        ],
                    }
                )
                image_idx += 1

            # Add assistant response
            history_response = mem2response(step)
            messages.append(
                {
                    "role": "assistant",
                    "content": [{"type": "text", "text": history_response}],
                }
            )

            # Add ask_user_response if present (matches MAI-UI behavior)
            if step.ask_user_response:
                messages.append(
                    {
                        "role": "user",
                        "content": [{"type": "text", "text": step.ask_user_response}],
                    }
                )

    # Add current screenshot
    current_encoded = bytes_to_base64(current_screenshot_bytes)
    messages.append(
        {
            "role": "user",
            "content": [
                {
                    "type": "image_url",
                    "image_url": {"url": f"data:image/png;base64,{current_encoded}"},
                }
            ],
        }
    )

    return messages


# =============================================================================
# Action Execution
# =============================================================================


async def execute_action(
    tools,
    action: Dict[str, Any],
    screen_width: int,
    screen_height: int,
    llm=None,
) -> Tuple[bool, str]:
    """
    Execute a MAI-UI action using DroidRun tools.

    Args:
        tools: DroidRun Tools instance
        action: Parsed action dictionary with normalized coordinates (0-1 range)
        screen_width: Screen width in pixels
        screen_height: Screen height in pixels
        llm: LLM instance for intelligent app opening (AppStarter workflow)

    Returns:
        Tuple of (success, result_message)
    """
    action_type = action.get("action", "")
    w, h = screen_width, screen_height

    try:
        if action_type == "click":
            # Coordinates are normalized (0-1), convert to pixels
            coord = action.get("coordinate", [0, 0])
            x = int(coord[0] * w)
            y = int(coord[1] * h)
            result = await tools.tap_by_coordinates(x, y)
            return True, f"click ({x},{y}): {result}"

        elif action_type == "long_press":
            coord = action.get("coordinate", [0, 0])
            x = int(coord[0] * w)
            y = int(coord[1] * h)
            await tools.swipe(x, y, x, y, 1000)
            return True, f"long_press ({x},{y})"

        elif action_type == "double_click":
            coord = action.get("coordinate", [0, 0])
            x = int(coord[0] * w)
            y = int(coord[1] * h)
            await tools.tap_by_coordinates(x, y)
            await asyncio.sleep(0.1)
            await tools.tap_by_coordinates(x, y)
            return True, f"double_click ({x},{y})"

        elif action_type == "type":
            text = action.get("text", "")
            result = await tools.input_text(text)
            return True, (
                f"type '{text[:30]}...': {result}"
                if len(text) > 30
                else f"type '{text}': {result}"
            )

        elif action_type == "swipe":
            direction = action.get("direction", "up")
            # Default to center if no coordinate provided (0.5, 0.5 normalized)
            coord = action.get("coordinate", [0.5, 0.5])

            # Start position (normalized to pixels)
            sx = int(coord[0] * w)
            sy = int(coord[1] * h)

            # Direction offsets (proportional to screen size)
            offsets = {
                "up": (0, -h // 3),
                "down": (0, h // 3),
                "left": (-w // 3, 0),
                "right": (w // 3, 0),
            }
            dx, dy = offsets.get(direction, (0, 0))

            # Clamp end coordinates to screen bounds
            ex = max(0, min(w - 1, sx + dx))
            ey = max(0, min(h - 1, sy + dy))

            await tools.swipe(sx, sy, ex, ey, 300)
            return True, f"swipe {direction} from ({sx},{sy}) to ({ex},{ey})"

        elif action_type == "drag":
            start_coord = action.get("start_coordinate", [0, 0])
            end_coord = action.get("end_coordinate", [0, 0])

            sx = int(start_coord[0] * w)
            sy = int(start_coord[1] * h)
            ex = int(end_coord[0] * w)
            ey = int(end_coord[1] * h)

            # Use longer duration for drag semantics
            await tools.swipe(sx, sy, ex, ey, 2000)
            return True, f"drag from ({sx},{sy}) to ({ex},{ey})"

        elif action_type == "open":
            app_name = action.get("text", "")
            if llm is not None:
                # Use intelligent LLM-based app matching via AppStarter
                workflow = AppStarter(
                    tools=tools,
                    llm=llm,
                    timeout=60,
                    verbose=False,
                )
                result = await workflow.run(app_description=app_name)
                await asyncio.sleep(1)
                return True, f"open '{app_name}': {result}"
            else:
                # Fallback to simple name matching
                package = await resolve_app_name(tools, app_name)
                result = await tools.start_app(package)
                return True, f"open '{app_name}' ({package}): {result}"

        elif action_type == "system_button":
            button = action.get("button", "back")
            keycodes = {
                "back": 4,
                "home": 3,
                "enter": 66,
                "menu": 82,
            }
            keycode = keycodes.get(button, 4)
            result = await tools.press_key(keycode)
            return True, f"{button}: {result}"

        elif action_type == "wait":
            await asyncio.sleep(1.0)
            return True, "wait 1s"

        elif action_type == "terminate":
            # Handled in main loop
            return True, "terminate"

        elif action_type == "answer":
            # Handled in main loop
            return True, f"answer: {action.get('text', '')}"

        elif action_type == "ask_user":
            # Handled in main loop - returns special marker
            return True, "ask_user"

        else:
            return False, f"unknown action: {action_type}"

    except Exception as e:
        logger.error(f"Action execution failed: {e}")
        return False, f"error: {e}"


# =============================================================================
# Main Run Function
# =============================================================================


async def run(
    tools,
    instruction: str,
    config: Dict[str, Any],
    max_steps: int = 15,
) -> Dict[str, Any]:
    """
    Run MAI-UI agent with exact MAI-UI behavior.

    Args:
        tools: DroidRun Tools instance (AdbTools)
        instruction: Task to complete
        config: Configuration dictionary:
            llm: Dict passed directly to load_llm() with:
                provider: LLM provider (default: "OpenAI")
                model, temperature, base_url, api_key, max_tokens, top_p, top_k, etc.
            history_n: Number of history images (default: 3)
            vision: Whether to use screenshots (default: True)
        max_steps: Maximum iterations

    Returns:
        Dictionary with: success, reason, steps, answer (if answer action)
    """
    # Validate LLM config - must be provided by user
    llm_cfg = config.get("llm")
    if not llm_cfg or not isinstance(llm_cfg, dict):
        raise ValueError(
            "MAI-UI requires 'llm' configuration. "
            "Please configure external_agents.mai_ui.llm in your config.yaml"
        )

    if "provider" not in llm_cfg:
        raise ValueError(
            "MAI-UI requires 'llm.provider' to be specified. "
            "Example: provider: OpenAI"
        )

    if "model" not in llm_cfg:
        raise ValueError(
            "MAI-UI requires 'llm.model' to be specified. " "Example: model: mai-ui-8b"
        )

    # Load LLM - pass config directly to load_llm
    llm_cfg = dict(llm_cfg)  # Copy to avoid mutating
    provider = llm_cfg.pop("provider")
    llm = load_llm(provider, **llm_cfg)

    # Agent-specific configuration (defaults from DEFAULT_CONFIG)
    history_n = config.get("history_n", DEFAULT_CONFIG["history_n"])

    # Initialize trajectory memory
    traj_memory = TrajMemory(task_goal=instruction)

    # Get available apps for prompt and render system prompt
    # No MCP tools passed - the MCP section will not appear in the prompt
    apps_list = await get_available_apps(tools)
    system_prompt = MAI_MOBILE_SYS_PROMPT_TEMPLATE.render(
        apps_list=apps_list,
        tools=None,  # No MCP tools - section won't render
    )

    logger.info(f"MAI-UI agent starting: {instruction}")

    for step in range(max_steps):
        logger.info(f"Step {step + 1}/{max_steps}")

        # Get screen dimensions
        try:
            await tools.get_state()
            w, h = tools.screen_width, tools.screen_height
        except Exception as e:
            logger.error(f"Failed to get state: {e}")
            w, h = 1080, 2400  # Fallback dimensions

        # Take screenshot (MAI-UI is vision-based, always requires screenshots)
        try:
            _, screenshot_bytes = await tools.take_screenshot()
        except Exception as e:
            logger.error(f"Failed to take screenshot: {e}")
            continue

        if not screenshot_bytes:
            logger.error("No screenshot available")
            continue

        # Build messages
        messages = build_messages(
            instruction=instruction,
            system_prompt=system_prompt,
            traj_memory=traj_memory,
            current_screenshot_bytes=screenshot_bytes,
            history_n=history_n,
        )

        # Call LLM
        try:
            response = await acall_with_retries(llm, to_chat_messages(messages))
            response_text = str(response)
        except Exception as e:
            logger.error(f"LLM call failed: {e}")
            continue

        # Parse response
        try:
            parsed = parse_action(response_text)
            thinking = parsed["thinking"] or ""
            action_json = parsed["action_json"]
        except ValueError as e:
            logger.error(f"Failed to parse response: {e}")
            logger.debug(f"Raw response: {response_text[:500]}")
            continue

        logger.info(f"Thinking: {thinking[:150]}...")
        logger.info(f"Action: {action_json.get('action', 'unknown')}")

        # Check for terminal actions first (before storing step)
        action_type = action_json.get("action", "")

        if action_type == "terminate":
            # Store step before returning
            traj_step = TrajStep(
                screenshot_bytes=screenshot_bytes,
                prediction=response_text,
                action=action_json,
                thought=thinking,
                step_index=step,
                structured_action={"action_json": action_json},
            )
            traj_memory.steps.append(traj_step)

            success = action_json.get("status") == "success"
            reason = action_json.get("message", "Task terminated")
            logger.info(f"Terminated: success={success}, reason={reason}")
            return {"success": success, "reason": reason, "steps": step + 1}

        if action_type == "answer":
            # Store step before returning
            traj_step = TrajStep(
                screenshot_bytes=screenshot_bytes,
                prediction=response_text,
                action=action_json,
                thought=thinking,
                step_index=step,
                structured_action={"action_json": action_json},
            )
            traj_memory.steps.append(traj_step)

            answer_text = action_json.get("text", "")
            logger.info(f"Answer: {answer_text}")
            return {
                "success": True,
                "reason": "Task completed with answer",
                "steps": step + 1,
                "answer": answer_text,
            }

        if action_type == "ask_user":
            # Get user input via stdin
            question = action_json.get("text", "Please provide input:")
            logger.info(f"ü§ñ Agent asks: {question}")
            user_response = input("Your response: ").strip()
            logger.info(f"User response: {user_response}")

            # Store step with ask_user_response
            traj_step = TrajStep(
                screenshot_bytes=screenshot_bytes,
                prediction=response_text,
                action=action_json,
                thought=thinking,
                step_index=step,
                structured_action={"action_json": action_json},
                ask_user_response=user_response,
            )
            traj_memory.steps.append(traj_step)

            # Continue to next iteration (no device action needed)
            await asyncio.sleep(0.5)
            continue

        # Store step in trajectory (for non-terminal, non-ask_user actions)
        # action_json already has normalized coordinates (0-1) from parse_action
        traj_step = TrajStep(
            screenshot_bytes=screenshot_bytes,
            prediction=response_text,
            action=action_json,
            thought=thinking,
            step_index=step,
            structured_action={"action_json": action_json},
        )
        traj_memory.steps.append(traj_step)

        # Execute action
        success, result_msg = await execute_action(tools, action_json, w, h, llm)
        logger.info(f"Execution: {result_msg}")

        # Brief pause between steps
        await asyncio.sleep(0.5)

    # Max steps reached
    return {"success": False, "reason": "Max steps reached", "steps": max_steps}

```

`droidrun/agent/manager/__init__.py`:

```py
"""
Manager Agent - Planning and reasoning workflow.

Two variants available:
- ManagerAgent: Stateful, maintains chat history
- StatelessManagerAgent: Stateless, rebuilds context each turn
"""

from droidrun.agent.droid.events import ManagerInputEvent, ManagerPlanEvent
from droidrun.agent.manager.events import (
    ManagerContextEvent,
    ManagerPlanDetailsEvent,
    ManagerResponseEvent,
)
from droidrun.agent.manager.manager_agent import ManagerAgent
from droidrun.agent.manager.stateless_manager_agent import StatelessManagerAgent
from droidrun.agent.manager.prompts import parse_manager_response

__all__ = [
    "ManagerAgent",
    "StatelessManagerAgent",
    "ManagerInputEvent",
    "ManagerPlanEvent",
    "ManagerContextEvent",
    "ManagerResponseEvent",
    "ManagerPlanDetailsEvent",
    "parse_manager_response",
]

```

`droidrun/agent/manager/events.py`:

```py
"""
Events for the ManagerAgent workflow.

Internal events for streaming to frontend/logging.
For DroidAgent coordination events, see droid/events.py
"""

from typing import Optional

from llama_index.core.workflow import Event

from droidrun.agent.usage import UsageResult


class ManagerContextEvent(Event):
    """Context prepared, ready for LLM call."""

    pass


class ManagerResponseEvent(Event):
    """LLM response received, ready for parsing."""

    response: str
    usage: Optional[UsageResult] = None


class ManagerPlanDetailsEvent(Event):
    """Plan parsed and ready (internal event with full details)."""

    plan: str
    subgoal: str
    thought: str
    answer: str = ""
    memory_update: str = ""
    progress_summary: str = ""
    success: Optional[bool] = None  # True/False if complete, None if in progress
    full_response: str = ""

```

`droidrun/agent/manager/manager_agent.py`:

```py
"""
ManagerAgent - Planning and reasoning workflow.

This agent is responsible for:
- Analyzing the current state
- Creating plans and subgoals
- Tracking progress
- Deciding when tasks are complete
"""

from __future__ import annotations

import copy
import json
import logging
import os
from typing import TYPE_CHECKING, Optional, Type

from llama_index.core.llms.llm import LLM
from llama_index.core.workflow import Context, StartEvent, StopEvent, Workflow, step
from opentelemetry import trace
from pydantic import BaseModel

from droidrun.agent.common.events import RecordUIStateEvent, ScreenshotEvent
from droidrun.agent.manager.events import (
    ManagerContextEvent,
    ManagerPlanDetailsEvent,
    ManagerResponseEvent,
)
from droidrun.agent.manager.prompts import parse_manager_response
from droidrun.agent.usage import get_usage_from_response
from droidrun.agent.utils.chat_utils import (
    filter_empty_messages,
    to_chat_messages,
)
from droidrun.agent.utils.inference import acall_with_retries
from droidrun.agent.utils.prompt_resolver import PromptResolver
from droidrun.agent.utils.signatures import ATOMIC_ACTION_SIGNATURES
from droidrun.agent.utils.tracing_setup import record_langfuse_screenshot
from droidrun.app_cards.app_card_provider import AppCardProvider
from droidrun.app_cards.providers import (
    CompositeAppCardProvider,
    LocalAppCardProvider,
    ServerAppCardProvider,
)
from droidrun.config_manager.prompt_loader import PromptLoader
from droidrun.tools.driver.base import DeviceDisconnectedError

if TYPE_CHECKING:
    from droidrun.agent.action_context import ActionContext
    from droidrun.agent.droid import DroidAgentState
    from droidrun.agent.tool_registry import ToolRegistry
    from droidrun.config_manager.config_manager import AgentConfig, TracingConfig
    from droidrun.tools.ui.provider import StateProvider


logger = logging.getLogger("droidrun")


class ManagerAgent(Workflow):
    """
    Planning and reasoning agent that decides what to do next.

    The Manager:
    1. Analyzes current device state and action history
    2. Creates plans with specific subgoals
    3. Tracks progress and completed steps
    4. Decides when tasks are complete or need to provide answers
    """

    def __init__(
        self,
        llm: LLM,
        action_ctx: "ActionContext | None",
        state_provider: "StateProvider | None",
        save_trajectory: str = "none",
        shared_state: "DroidAgentState" = None,
        agent_config: "AgentConfig" = None,
        registry: "ToolRegistry | None" = None,
        output_model: Type[BaseModel] | None = None,
        prompt_resolver: Optional[PromptResolver] = None,
        tracing_config: "TracingConfig | None" = None,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.llm = llm
        self.config = agent_config.manager
        self.vision = self.config.vision
        self.action_ctx = action_ctx
        self.state_provider = state_provider
        self.save_trajectory = save_trajectory
        self._stream_screenshots = os.environ.get(
            "DROIDRUN_STREAM_SCREENSHOTS", ""
        ).lower() in ("1", "true")
        self.shared_state = shared_state
        self.registry = registry
        self.output_model = output_model
        self.agent_config = agent_config
        self.app_card_config = self.agent_config.app_cards
        self.prompt_resolver = prompt_resolver or PromptResolver()
        self.tracing_config = tracing_config

        # Initialize app card provider
        self.app_card_provider: AppCardProvider = self._initialize_app_card_provider()

        logger.debug("ManagerAgent initialized.")

    def _initialize_app_card_provider(self) -> AppCardProvider:
        """Initialize app card provider based on configuration mode."""
        if not self.app_card_config.enabled:

            class DisabledProvider(AppCardProvider):
                async def load_app_card(
                    self, package_name: str, instruction: str = ""
                ) -> str:
                    return ""

            return DisabledProvider()

        mode = self.app_card_config.mode.lower()

        if mode == "local":
            return LocalAppCardProvider(
                app_cards_dir=self.app_card_config.app_cards_dir
            )
        elif mode == "server":
            if not self.app_card_config.server_url:
                logger.warning("Server mode but no server_url, falling back to local")
                return LocalAppCardProvider(
                    app_cards_dir=self.app_card_config.app_cards_dir
                )
            return ServerAppCardProvider(
                server_url=self.app_card_config.server_url,
                timeout=self.app_card_config.server_timeout,
                max_retries=self.app_card_config.server_max_retries,
            )
        elif mode == "composite":
            if not self.app_card_config.server_url:
                logger.warning(
                    "Composite mode but no server_url, falling back to local"
                )
                return LocalAppCardProvider(
                    app_cards_dir=self.app_card_config.app_cards_dir
                )
            return CompositeAppCardProvider(
                server_url=self.app_card_config.server_url,
                app_cards_dir=self.app_card_config.app_cards_dir,
                server_timeout=self.app_card_config.server_timeout,
                server_max_retries=self.app_card_config.server_max_retries,
            )
        else:
            logger.warning(f"Unknown app_card mode '{mode}', falling back to local")
            return LocalAppCardProvider(
                app_cards_dir=self.app_card_config.app_cards_dir
            )

    async def _build_system_prompt(self, has_text_to_modify: bool) -> str:
        """Build system prompt with all context."""
        # Build error history if needed
        error_history = None
        if self.shared_state.error_flag_plan:
            k = self.shared_state.err_to_manager_thresh
            error_history = [
                {"action": act, "summary": summ, "error": err_des}
                for act, summ, err_des in zip(
                    self.shared_state.action_history[-k:],
                    self.shared_state.summary_history[-k:],
                    self.shared_state.error_descriptions[-k:],
                    strict=True,
                )
            ]

        # Get available secrets
        available_secrets = []
        if self.action_ctx and self.action_ctx.credential_manager:
            available_secrets = await self.action_ctx.credential_manager.get_keys()

        # Output schema if provided
        output_schema = None
        if self.output_model is not None:
            output_schema = self.output_model.model_json_schema()

        # Build custom tools descriptions from registry.
        # Exclude standard atomic actions (Manager prompt already describes them)
        # and flow-control tools (remember, complete) which Manager doesn't use.
        custom_tools_descriptions = ""
        if self.registry:
            _standard = set(ATOMIC_ACTION_SIGNATURES.keys()) | {"remember", "complete"}
            custom_tools_descriptions = self.registry.get_tool_descriptions_text(
                exclude=_standard
            )

        variables = {
            "instruction": self.shared_state.instruction,
            "device_date": self.shared_state.device_date,
            "app_card": self.shared_state.app_card,
            "important_notes": "",  # TODO: implement
            "error_history": error_history,
            "text_manipulation_enabled": has_text_to_modify
            and self.agent_config.fast_agent.codeact,
            "custom_tools_descriptions": custom_tools_descriptions,
            "scripter_execution_enabled": self.agent_config.scripter.enabled,
            "scripter_max_steps": self.agent_config.scripter.max_steps,
            "available_secrets": available_secrets,
            "variables": self.shared_state.custom_variables,
            "output_schema": output_schema,
        }

        custom_prompt = self.prompt_resolver.get_prompt("manager_system")
        if custom_prompt:
            return PromptLoader.render_template(custom_prompt, variables)
        else:
            return await PromptLoader.load_prompt(
                self.agent_config.get_manager_system_prompt_path(),
                variables,
            )

    def _build_user_message_content(self) -> str:
        """Build user message content with last action context."""
        parts = []

        # Add last thought
        if self.shared_state.last_thought:
            parts.append(f"<thought>\n{self.shared_state.last_thought}\n</thought>\n")

        # Add last action
        if self.shared_state.last_action:
            action_str = json.dumps(self.shared_state.last_action)
            parts.append(f"<last_action>\n{action_str}\n</last_action>\n")

        # Add last action summary
        if self.shared_state.last_summary:
            parts.append(
                f"<last_action_description>\n{self.shared_state.last_summary}\n</last_action_description>\n"
            )

        return "".join(parts)

    def _build_messages_with_context(
        self, system_prompt: str, screenshot: bytes | None = None
    ) -> list[dict]:
        """
        Build messages from history and inject current context.

        Args:
            system_prompt: System prompt text
            screenshot: Current screenshot if vision enabled

        Returns:
            List of message dicts ready for conversion
        """

        # Start with system message
        messages = [{"role": "system", "content": [{"text": system_prompt}]}]

        # Add accumulated message history (deep copy to avoid mutation)
        messages.extend(copy.deepcopy(self.shared_state.message_history))

        # Find last user message
        user_indices = [i for i, msg in enumerate(messages) if msg["role"] == "user"]

        if user_indices:
            last_user_idx = user_indices[-1]

            # Add memory to last user message
            current_memory = (self.shared_state.manager_memory or "").strip()
            if current_memory:
                messages[last_user_idx]["content"].append(
                    {"text": f"\n<memory>\n{current_memory}\n</memory>\n"}
                )

            # Add current device state
            current_state = self.shared_state.formatted_device_state.strip()
            if current_state:
                messages[last_user_idx]["content"].append(
                    {"text": f"\n<device_state>\n{current_state}\n</device_state>\n"}
                )

            # Add screenshot if vision enabled
            if screenshot and self.vision:
                messages[last_user_idx]["content"].append({"image": screenshot})

            # Add script result if available
            if self.shared_state.last_scripter_message:
                status = (
                    "SUCCESS" if self.shared_state.last_scripter_success else "FAILED"
                )
                script_context = (
                    f'\n<script_result status="{status}">\n'
                    f"{self.shared_state.last_scripter_message}\n"
                    f"</script_result>\n"
                )
                messages[last_user_idx]["content"].append({"text": script_context})
                self.shared_state.last_scripter_message = ""

            # Add previous device state to second-to-last user message
            if len(user_indices) >= 2:
                second_last_idx = user_indices[-2]
                prev_state = self.shared_state.previous_formatted_device_state.strip()
                if prev_state:
                    messages[second_last_idx]["content"].append(
                        {"text": f"\n<device_state>\n{prev_state}\n</device_state>\n"}
                    )

        messages = filter_empty_messages(messages)
        return messages

    async def _validate_and_retry(
        self, messages: list[dict], initial_response: str
    ) -> str:
        """Validate LLM response and retry if needed."""
        output = initial_response
        parsed = parse_manager_response(output)

        max_retries = 3
        retry_count = 0

        while retry_count < max_retries:
            error_message = None

            if parsed["answer"] and not parsed["plan"]:
                if parsed["success"] is None:
                    error_message = (
                        'You must include success="true" or success="false" attribute '
                        "in the <request_accomplished> tag.\n"
                        'Example: <request_accomplished success="true">Task completed</request_accomplished>\n'
                        "Retry again."
                    )
                else:
                    break  # Valid
            elif parsed["plan"] and parsed["answer"]:
                error_message = (
                    "You cannot use both request_accomplished tag while the plan is not finished. "
                    "If you want to use request_accomplished tag, please make sure the plan is finished.\n"
                    "Retry again."
                )
            elif not parsed["plan"]:
                error_message = (
                    "You must provide a plan to complete the task. "
                    "Please provide a plan with the correct format."
                )
            else:
                break  # Valid: plan without answer

            if error_message:
                retry_count += 1
                logger.warning(
                    f"Manager response invalid (retry {retry_count}/{max_retries}): {error_message}"
                )

                # Build retry messages
                retry_messages = messages + [
                    {"role": "assistant", "content": [{"text": output}]},
                    {"role": "user", "content": [{"text": error_message}]},
                ]

                chat_messages = to_chat_messages(retry_messages)

                try:
                    response = await acall_with_retries(
                        self.llm, chat_messages, stream=self.agent_config.streaming
                    )
                    output = response.message.content
                    parsed = parse_manager_response(output)
                except Exception as e:
                    logger.error(f"LLM retry failed: {e}")
                    break

        return output

    # ========================================================================
    # Workflow Steps
    # ========================================================================

    @step
    async def prepare_context(
        self, ctx: Context, ev: StartEvent
    ) -> ManagerContextEvent:
        """Gather context and prepare manager prompt."""
        logger.debug("üí¨ Preparing manager context...")

        # Get and format device state
        ui_state = await self.state_provider.get_state()
        self.action_ctx.ui = ui_state

        # Update shared state (previous ‚Üê current, current ‚Üê new)
        self.shared_state.previous_formatted_device_state = (
            self.shared_state.formatted_device_state
        )
        self.shared_state.formatted_device_state = ui_state.formatted_text
        self.shared_state.focused_text = ui_state.focused_text
        self.shared_state.a11y_tree = ui_state.elements
        self.shared_state.phone_state = ui_state.phone_state

        # Update package/activity tracking
        self.shared_state.update_current_app(
            package_name=ui_state.phone_state.get("packageName", "Unknown"),
            activity_name=ui_state.phone_state.get("currentApp", "Unknown"),
        )

        # Stream UI state for trajectory
        ctx.write_event_to_stream(RecordUIStateEvent(ui_state=ui_state.elements))

        # Load app card
        if self.app_card_config.enabled:
            try:
                self.shared_state.app_card = await self.app_card_provider.load_app_card(
                    package_name=self.shared_state.current_package_name,
                    instruction=self.shared_state.instruction,
                )
            except Exception as e:
                logger.warning(f"Error loading app card: {e}")
                self.shared_state.app_card = ""
        else:
            self.shared_state.app_card = ""

        # Capture screenshot if needed
        screenshot = None
        if self.vision or self._stream_screenshots or self.save_trajectory != "none":
            try:
                screenshot = await self.action_ctx.driver.screenshot()

                if screenshot:
                    ctx.write_event_to_stream(ScreenshotEvent(screenshot=screenshot))
                    parent_span = trace.get_current_span()
                    record_langfuse_screenshot(
                        screenshot,
                        parent_span=parent_span,
                        screenshots_enabled=bool(
                            self.tracing_config
                            and self.tracing_config.langfuse_screenshots
                        ),
                        vision_enabled=self.vision,
                    )
                    logger.debug("üì∏ Screenshot captured for Manager")
            except DeviceDisconnectedError:
                raise
            except Exception as e:
                logger.warning(f"Failed to capture screenshot: {e}")

        # Detect text manipulation mode
        focused_text_clean = self.shared_state.focused_text.replace("'", "").strip()
        has_text_to_modify = focused_text_clean != ""

        # Store for next step
        self.shared_state.has_text_to_modify = has_text_to_modify
        self.shared_state.screenshot = screenshot

        # Build user message and add to history
        user_content = self._build_user_message_content()
        self.shared_state.message_history.append(
            {"role": "user", "content": [{"text": user_content}]}
        )

        event = ManagerContextEvent()
        ctx.write_event_to_stream(event)
        return event

    @step
    async def get_response(
        self, ctx: Context, ev: ManagerContextEvent
    ) -> ManagerResponseEvent:
        """Get LLM response."""
        logger.debug("üß† Manager thinking about the plan...")

        has_text_to_modify = self.shared_state.has_text_to_modify
        screenshot = self.shared_state.screenshot

        # Build system prompt
        system_prompt = await self._build_system_prompt(has_text_to_modify)

        # Build messages with context
        messages = self._build_messages_with_context(
            system_prompt=system_prompt, screenshot=screenshot
        )

        # Convert and call LLM
        chat_messages = to_chat_messages(messages)

        try:
            logger.info("üìã Manager response:", extra={"color": "cyan"})
            response = await acall_with_retries(
                self.llm, chat_messages, stream=self.agent_config.streaming
            )
            output = response.message.content
        except Exception as e:
            logger.error(f"LLM call failed: {e}")
            raise RuntimeError(f"Error calling LLM in manager: {e}") from e

        # Extract usage
        usage = None
        try:
            usage = get_usage_from_response(self.llm.class_name(), response)
        except Exception as e:
            logger.warning(f"Could not get usage: {e}")

        output = await self._validate_and_retry(messages, output)

        event = ManagerResponseEvent(response=output, usage=usage)
        ctx.write_event_to_stream(event)
        return event

    @step
    async def process_response(
        self, ctx: Context, ev: ManagerResponseEvent
    ) -> ManagerPlanDetailsEvent:
        """Parse LLM response and update state."""
        logger.debug("‚öôÔ∏è Processing manager response...")

        output = ev.response
        parsed = parse_manager_response(output)

        # Update memory (append)
        memory_update = parsed.get("memory", "").strip()
        if memory_update:
            if self.shared_state.manager_memory:
                self.shared_state.manager_memory += "\n" + memory_update
            else:
                self.shared_state.manager_memory = memory_update

        # Append assistant response to message history
        self.shared_state.message_history.append(
            {"role": "assistant", "content": [{"text": output}]}
        )

        # Update unified state fields
        self.shared_state.previous_plan = self.shared_state.plan
        self.shared_state.plan = parsed["plan"]
        self.shared_state.current_subgoal = parsed["current_subgoal"]
        self.shared_state.last_thought = parsed["thought"]
        self.shared_state.answer = parsed["answer"]

        if parsed.get("progress_summary"):
            self.shared_state.progress_summary = parsed["progress_summary"]

        event = ManagerPlanDetailsEvent(
            plan=parsed["plan"],
            subgoal=parsed["current_subgoal"],
            thought=parsed["thought"],
            answer=parsed["answer"],
            memory_update=memory_update,
            progress_summary=parsed.get("progress_summary", ""),
            success=parsed["success"],
            full_response=output,
        )
        ctx.write_event_to_stream(event)
        return event

    @step
    async def finalize(self, ctx: Context, ev: ManagerPlanDetailsEvent) -> StopEvent:
        logger.debug("‚úÖ Manager planning complete")

        return StopEvent(
            result={
                "plan": ev.plan,
                "current_subgoal": ev.subgoal,
                "thought": ev.thought,
                "answer": ev.answer,
                "memory_update": ev.memory_update,
                "success": ev.success,
            }
        )

```

`droidrun/agent/manager/prompts.py`:

```py
"""
Prompts for the ManagerAgent.
"""

import re


def parse_manager_response(response: str) -> dict:
    """
    Parse manager LLM response into structured dict.

    Extracts XML-style tags from the response:
    - <thought>...</thought>
    - <add_memory>...</add_memory>
    - <plan>...</plan>
    - <request_accomplished success="true|false">...</request_accomplished> (answer)

    Also derives:
    - current_subgoal: first line of plan (with list markers removed)
    - If first item is <script> tag, extract script content as current_subgoal
    - success: bool | None parsed from request_accomplished success attribute

    Args:
        response: Raw LLM response text

    Returns:
        Dict with keys:
            - thought: str
            - memory: str
            - plan: str
            - current_subgoal: str (first line of plan, cleaned, or script content)
            - answer: str (from request_accomplished tag)
            - success: bool | None (True/False if task complete, None if still in progress)
    """

    def extract(tag: str) -> str:
        """Extract content between XML-style tags (handles attributes)."""
        # Use regex to handle tags with attributes like <tag attr="value">
        pattern = rf"<{tag}(?:\s+[^>]*)?>(.+?)</{tag}>"
        match = re.search(pattern, response, re.DOTALL)
        if match:
            return match.group(1).strip()
        return ""

    thought = extract("thought")
    memory_section = extract("add_memory")
    plan = extract("plan")
    progress_summary = extract("progress_summary")
    answer = extract("request_accomplished")

    # Also support <answer> tag as alternative to <request_accomplished>
    if not answer:
        answer = extract("answer")

    # Parse success attribute from request_accomplished or answer tag
    success = None
    if answer:
        # Try to extract success attribute from tag
        success_match = re.search(
            r'<(?:request_accomplished|answer)\s+success="(true|false)">', response
        )
        if success_match:
            success = success_match.group(1) == "true"
        else:
            # Default to True for backward compatibility if no attribute present
            success = True

    # Parse current subgoal from first line of plan
    current_goal_text = plan

    # Check if first item is a <script> tag
    script_match = re.search(
        r"^\s*<script>(.*?)</script>", current_goal_text, re.DOTALL
    )

    if script_match:
        # Script is first task - extract script content with tag
        current_subgoal = f"<script>{script_match.group(1).strip()}</script>"
    else:
        # Regular subgoal - use existing logic
        plan_lines = [
            line.strip() for line in current_goal_text.splitlines() if line.strip()
        ]
        if plan_lines:
            first_line = plan_lines[0]
        else:
            first_line = current_goal_text.strip()

        # Remove common list markers like "1.", "-", "*", or bullet characters
        first_line = re.sub(
            r"^\s*\d+\.\s*", "", first_line
        )  # Remove "1. ", "2. ", etc.
        first_line = re.sub(r"^\s*[-*]\s*", "", first_line)  # Remove "- " or "* "
        first_line = re.sub(r"^\s*‚Ä¢\s*", "", first_line)  # Remove bullet "‚Ä¢ "

        current_subgoal = first_line.strip()

    return {
        "thought": thought,
        "plan": plan,
        "memory": memory_section,
        "current_subgoal": current_subgoal,
        "answer": answer,
        "success": success,
        "progress_summary": progress_summary,
    }

```

`droidrun/agent/manager/stateless_manager_agent.py`:

```py
"""
StatelessManagerAgent - Stateless planning agent that rebuilds context each turn.
"""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Optional, Type

from llama_index.core.llms.llm import LLM
from llama_index.core.workflow import Context, StartEvent, StopEvent, Workflow, step
from opentelemetry import trace
from pydantic import BaseModel

from droidrun.agent.common.events import RecordUIStateEvent, ScreenshotEvent
from droidrun.agent.manager.events import (
    ManagerContextEvent,
    ManagerPlanDetailsEvent,
    ManagerResponseEvent,
)
from droidrun.agent.manager.prompts import parse_manager_response
from droidrun.agent.usage import get_usage_from_response
from droidrun.agent.utils.chat_utils import to_chat_messages
from droidrun.agent.utils.inference import acall_with_retries
from droidrun.agent.utils.prompt_resolver import PromptResolver
from droidrun.agent.utils.tracing_setup import record_langfuse_screenshot
from droidrun.config_manager.prompt_loader import PromptLoader
from droidrun.tools.driver.base import DeviceDisconnectedError

if TYPE_CHECKING:
    from droidrun.agent.action_context import ActionContext
    from droidrun.agent.droid import DroidAgentState
    from droidrun.agent.tool_registry import ToolRegistry
    from droidrun.config_manager.config_manager import AgentConfig, TracingConfig
    from droidrun.tools.ui.provider import StateProvider


logger = logging.getLogger("droidrun")


class StatelessManagerAgent(Workflow):
    def __init__(
        self,
        llm: LLM,
        action_ctx: "ActionContext | None",
        state_provider: "StateProvider | None",
        save_trajectory: str = "none",
        shared_state: "DroidAgentState" = None,
        agent_config: "AgentConfig" = None,
        registry: "ToolRegistry | None" = None,
        output_model: Type[BaseModel] | None = None,
        prompt_resolver: Optional[PromptResolver] = None,
        tracing_config: "TracingConfig | None" = None,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.llm = llm
        self.config = agent_config.manager
        self.vision = self.config.vision
        self.action_ctx = action_ctx
        self.state_provider = state_provider
        self.save_trajectory = save_trajectory
        self.shared_state = shared_state
        self.registry = registry
        self.output_model = output_model
        self.agent_config = agent_config
        self.prompt_resolver = prompt_resolver or PromptResolver()
        self.tracing_config = tracing_config

    def _build_action_history(self) -> list[dict]:
        if not self.shared_state.action_history:
            return []

        n = min(5, len(self.shared_state.action_history))
        return [
            {
                "action": act,
                "summary": summ,
                "outcome": outcome,
                "error": err,
            }
            for act, summ, outcome, err in zip(
                self.shared_state.action_history[-n:],
                self.shared_state.summary_history[-n:],
                self.shared_state.action_outcomes[-n:],
                self.shared_state.error_descriptions[-n:],
                strict=True,
            )
        ]

    async def _build_prompt(self, has_text_to_modify: bool) -> str:
        variables = {
            "instruction": self.shared_state.instruction,
            "device_date": self.shared_state.device_date,
            "previous_plan": self.shared_state.previous_plan,
            "previous_state": self.shared_state.previous_formatted_device_state,
            "memory": self.shared_state.manager_memory,
            "last_thought": self.shared_state.last_thought,
            "progress_summary": self.shared_state.progress_summary,
            "action_history": self._build_action_history(),
            "current_state": self.shared_state.formatted_device_state,
            "text_manipulation_enabled": has_text_to_modify
            and self.agent_config.fast_agent.codeact,
        }

        custom_prompt = self.prompt_resolver.get_prompt("manager_system")
        if custom_prompt:
            return PromptLoader.render_template(custom_prompt, variables)

        return await PromptLoader.load_prompt(
            self.agent_config.get_manager_system_prompt_path(),
            variables,
        )

    async def _validate_and_retry(
        self, messages: list[dict], initial_response: str
    ) -> str:
        output = initial_response
        parsed = parse_manager_response(output)

        max_retries = 3
        retry_count = 0

        while retry_count < max_retries:
            error_message = None

            if parsed["answer"] and not parsed["plan"]:
                if parsed["success"] is None:
                    error_message = (
                        'You must include success="true" or success="false" attribute '
                        "in the <answer> or <request_accomplished> tag.\n"
                        'Example: <answer success="true">Task completed</answer>\n'
                        "Retry again."
                    )
                else:
                    break
            elif parsed["plan"] and parsed["answer"]:
                error_message = (
                    "You cannot include both <plan> and <answer> tags. "
                    "Use <answer> only when the task is complete.\n"
                    "Retry again."
                )
            elif not parsed["plan"] and not parsed["answer"]:
                error_message = (
                    "You must provide either a <plan> or an <answer>. "
                    "Please provide a plan with numbered steps."
                )
            else:
                break

            if error_message:
                retry_count += 1
                logger.warning(
                    f"Manager response invalid (retry {retry_count}/{max_retries}): {error_message}"
                )

                retry_messages = messages + [
                    {"role": "assistant", "content": [{"text": output}]},
                    {"role": "user", "content": [{"text": error_message}]},
                ]

                chat_messages = to_chat_messages(retry_messages)

                try:
                    response = await acall_with_retries(self.llm, chat_messages)
                    output = response.message.content
                    parsed = parse_manager_response(output)
                except Exception as e:
                    logger.error(f"LLM retry failed: {e}")
                    break

        return output

    @step
    async def prepare_context(
        self, ctx: Context, ev: StartEvent
    ) -> ManagerContextEvent:
        ui_state = await self.state_provider.get_state()
        self.action_ctx.ui = ui_state

        self.shared_state.previous_formatted_device_state = (
            self.shared_state.formatted_device_state
        )
        self.shared_state.formatted_device_state = ui_state.formatted_text
        self.shared_state.focused_text = ui_state.focused_text
        self.shared_state.a11y_tree = ui_state.elements
        self.shared_state.phone_state = ui_state.phone_state

        self.shared_state.update_current_app(
            package_name=ui_state.phone_state.get("packageName", "Unknown"),
            activity_name=ui_state.phone_state.get("currentApp", "Unknown"),
        )

        ctx.write_event_to_stream(RecordUIStateEvent(ui_state=ui_state.elements))

        screenshot = None
        if self.vision or self.save_trajectory != "none":
            try:
                screenshot = await self.action_ctx.driver.screenshot()

                if screenshot:
                    ctx.write_event_to_stream(ScreenshotEvent(screenshot=screenshot))
                    parent_span = trace.get_current_span()
                    record_langfuse_screenshot(
                        screenshot,
                        parent_span=parent_span,
                        screenshots_enabled=bool(
                            self.tracing_config
                            and self.tracing_config.langfuse_screenshots
                        ),
                        vision_enabled=self.vision,
                    )
            except DeviceDisconnectedError:
                raise
            except Exception as e:
                logger.warning(f"Failed to capture screenshot: {e}")

        focused_text_clean = self.shared_state.focused_text.replace("'", "").strip()
        has_text_to_modify = focused_text_clean != ""

        self.shared_state.has_text_to_modify = has_text_to_modify
        self.shared_state.screenshot = screenshot

        event = ManagerContextEvent()
        ctx.write_event_to_stream(event)
        return event

    @step
    async def get_response(
        self, ctx: Context, ev: ManagerContextEvent
    ) -> ManagerResponseEvent:
        has_text_to_modify = self.shared_state.has_text_to_modify
        screenshot = self.shared_state.screenshot

        prompt_text = await self._build_prompt(has_text_to_modify)
        messages = [{"role": "user", "content": [{"text": prompt_text}]}]

        if self.vision and screenshot:
            messages[0]["content"].append({"image": screenshot})

        chat_messages = to_chat_messages(messages)

        try:
            logger.info("Manager response:", extra={"color": "cyan"})
            response = await acall_with_retries(
                self.llm, chat_messages, stream=self.agent_config.streaming
            )
            output = response.message.content
        except Exception as e:
            logger.error(f"LLM call failed: {e}")
            raise RuntimeError(f"Error calling LLM in stateless manager: {e}") from e

        usage = None
        try:
            usage = get_usage_from_response(self.llm.class_name(), response)
        except Exception as e:
            logger.warning(f"Could not get usage: {e}")

        output = await self._validate_and_retry(messages, output)

        event = ManagerResponseEvent(response=output, usage=usage)
        ctx.write_event_to_stream(event)
        return event

    @step
    async def process_response(
        self, ctx: Context, ev: ManagerResponseEvent
    ) -> ManagerPlanDetailsEvent:
        output = ev.response
        parsed = parse_manager_response(output)

        self.shared_state.previous_plan = parsed["plan"]
        self.shared_state.last_thought = parsed["thought"]

        if parsed.get("progress_summary"):
            self.shared_state.progress_summary = parsed["progress_summary"]

        memory_update = parsed.get("memory", "").strip()
        if memory_update:
            if self.shared_state.manager_memory:
                self.shared_state.manager_memory += "\n" + memory_update
            else:
                self.shared_state.manager_memory = memory_update

        self.shared_state.plan = parsed["plan"]
        self.shared_state.current_subgoal = parsed["current_subgoal"]
        self.shared_state.answer = parsed["answer"]

        event = ManagerPlanDetailsEvent(
            plan=parsed["plan"],
            subgoal=parsed["current_subgoal"],
            thought=parsed["thought"],
            answer=parsed["answer"],
            memory_update=memory_update,
            progress_summary=parsed.get("progress_summary", ""),
            success=parsed["success"],
            full_response=output,
        )
        ctx.write_event_to_stream(event)
        return event

    @step
    async def finalize(self, ctx: Context, ev: ManagerPlanDetailsEvent) -> StopEvent:
        return StopEvent(
            result={
                "plan": ev.plan,
                "current_subgoal": ev.subgoal,
                "thought": ev.thought,
                "answer": ev.answer,
                "memory_update": ev.memory_update,
                "success": ev.success,
            }
        )

```

`droidrun/agent/oneflows/app_starter_workflow.py`:

```py
"""
Simple workflow to open an app based on a description.
"""

import json
import logging

from workflows import Context, Workflow, step
from workflows.events import StartEvent, StopEvent

from droidrun.agent.utils.inference import acomplete_with_retries

logger = logging.getLogger("droidrun")


class AppStarter(Workflow):
    """
    A simple workflow that opens an app based on a description.

    The workflow uses an LLM to intelligently match the app description
    to an installed app's package name, then opens it.
    """

    def __init__(self, tools, llm, timeout: int = 60, stream: bool = False, **kwargs):
        """
        Initialize the OpenAppWorkflow.

        Args:
            tools: A Tools instance or DeviceDriver with get_apps()/start_app()
            llm: An LLM instance (e.g., OpenAI) to determine which app to open
            timeout: Workflow timeout in seconds (default: 60)
            stream: If True, stream LLM response to console in real-time
            **kwargs: Additional arguments passed to Workflow
        """
        super().__init__(timeout=timeout, **kwargs)
        self.tools = tools
        self.llm = llm
        self.stream = stream

    @step
    async def open_app_step(self, ev: StartEvent, ctx: Context) -> StopEvent:
        """
        Opens an app based on the provided description.

        Expected StartEvent attributes:
            - app_description (str): The name or description of the app to open

        Returns:
            StopEvent with the result of the open_app operation
        """
        app_description = ev.app_description

        # Get list of installed apps
        apps = await self.tools.get_apps(include_system=True)

        # Format apps list for LLM
        apps_list = "\n".join(
            [
                f"- {app['label']} (package: {app['package_name'] if 'package_name' in app else app['package']})"
                for app in apps
            ]
        )

        # Construct prompt for LLM
        prompt = f"""Given the following list of installed apps and a user's description, determine which app package name to open.

Installed Apps:
{apps_list}

User's Request: "{app_description}"

Return ONLY a JSON object with the following structure:
{{
    "package": "com.example.package"
}}

If no app matches the user's request, return:
{{
    "package": null
}}

Choose the most appropriate app based on the description. Return the package name of the best match, or null if no app matches."""

        # Get LLM response
        logger.info("üì± AppOpener response:", extra={"color": "blue"})
        response = await acomplete_with_retries(self.llm, prompt, stream=self.stream)
        response_text = response.text.strip()

        # Parse JSON response - extract content between { and }
        try:
            start = response_text.find("{")
            end = response_text.rfind("}") + 1
            json_str = response_text[start:end]
            result_json = json.loads(json_str)
            package_name = result_json["package"]
        except (json.JSONDecodeError, KeyError, ValueError) as e:
            return StopEvent(
                result=f"Error parsing LLM response: {e}. Response: {response_text}"
            )

        if not package_name:
            logger.warning(f"No matching app found for: {app_description}")
            return StopEvent(
                result=f"Could not open app: no installed app matches '{app_description}'"
            )

        logger.info(f"Starting app {package_name}")
        result = await self.tools.start_app(package_name)

        return StopEvent(result=result)


# Example usage
async def main():
    """
    Example of how to use the OpenAppWorkflow.
    """
    from llama_index.llms.openai import OpenAI

    from droidrun.tools.driver.android import AndroidDriver

    # Initialize driver with device serial (None for default device)
    tools = AndroidDriver(serial=None)
    await tools.connect()

    # Initialize LLM
    llm = OpenAI(model="gpt-4o-mini")

    # Create workflow instance
    workflow = AppStarter(tools=tools, llm=llm, timeout=60, verbose=True)

    # Run workflow to open an app
    result = await workflow.run(app_description="Settings")

    print(f"Result: {result}")


if __name__ == "__main__":
    import asyncio

    asyncio.run(main())

```

`droidrun/agent/oneflows/structured_output_agent.py`:

```py
"""
StructuredOutputAgent - Extract structured data from final answers.

Takes a raw text answer and a Pydantic model, uses structured_predict()
to extract structured data from the text.
"""

import logging
from typing import Type

from llama_index.core.llms.llm import LLM
from llama_index.core.prompts import PromptTemplate
from llama_index.core.workflow import Context, StartEvent, StopEvent, Workflow, step
from pydantic import BaseModel

from droidrun.agent.utils.inference import astructured_predict_with_retries

logger = logging.getLogger("droidrun")


class StructuredOutputAgent(Workflow):
    """
    Agent that extracts structured output from text answers.

    Uses LLM.structured_predict() to parse text into Pydantic models.
    """

    def __init__(
        self,
        llm: LLM,
        pydantic_model: Type[BaseModel],
        answer_text: str,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.llm = llm
        self.pydantic_model = pydantic_model
        self.answer_text = answer_text

    @step
    async def extract_structured_output(
        self, ctx: Context, ev: StartEvent
    ) -> StopEvent:
        """
        Extract structured output using structured_predict().
        """
        logger.debug("üîç Extracting structured output from final answer...")

        try:
            # Create prompt for extraction
            prompt = PromptTemplate(
                "Extract structured information from the following text:\n\n{text}"
            )

            # Use structured_predict to extract data
            logger.info("üîç StructuredOutput response:", extra={"color": "magenta"})
            structured_output = await astructured_predict_with_retries(
                self.llm, self.pydantic_model, prompt, text=self.answer_text
            )

            logger.debug("‚úÖ Successfully extracted structured output")

            return StopEvent(
                result={
                    "structured_output": structured_output,
                    "success": True,
                    "error_message": "",
                }
            )

        except Exception as e:
            logger.error(f"‚ùå Failed to extract structured output: {e}")

            return StopEvent(
                result={
                    "structured_output": None,
                    "success": False,
                    "error_message": str(e),
                }
            )

```

`droidrun/agent/oneflows/text_manipulator.py`:

```py
'''CodeAct-style agent for text manipulation via constrained Python execution.

This agent receives two inputs:
- current_text: the current content of the focused text box
- task_instruction: a natural language instruction describing how to modify the text

It asks an LLM to produce Python code that:
- Uses ONLY a single provided function: input_text(text: str)
- Constructs the final text to type as a triple-quoted big string, assigned
  to a variable of the model's choice (e.g., new_text = """...""")
- May reference the predefined variable ORIGINAL which contains the current text
  from the text box
- Calls input_text(new_text) exactly once to clear the field and input the new text

The produced code is executed in a restricted sandbox exposing ONLY:
- ORIGINAL: str (the original text content)
- input_text: function (captures the final text; semantically clears and types)

If the generated code produces execution errors, the agent automatically sends the
stack trace back to the LLM for correction, with up to 3 retry attempts by default.
This enables iterative refinement of the generated code.

The agent returns the final text that should be entered into the text box and the
raw code produced by the model (potentially after corrections).
'''

import logging
import traceback

from llama_index.core.llms import ChatMessage
from llama_index.core.llms.llm import LLM

from droidrun.agent.utils.inference import acall_with_retries
from llama_index_instrumentation import get_dispatcher

logger = logging.getLogger("droidrun")

dispatcher = get_dispatcher()


@dispatcher.span
async def run_text_manipulation_agent(
    instruction: str,
    current_subgoal: str,
    current_text: str,
    overall_plan,
    llm: LLM,
    max_retries: int = 4,
    stream: bool = False,
) -> tuple[str, str]:
    """Convenience function to run CodeAct text manipulation with error correction.

    Args:
        instruction: User's overall instruction
        current_subgoal: Current subgoal to accomplish
        current_text: The current content of the focused text field
        overall_plan: Overall plan context
        llm: LLM instance to use for text manipulation
        max_retries: Maximum number of retry attempts if code execution fails
        stream: If True, stream LLM response to console in real-time

    Returns:
        Tuple of (final_text, raw_code) - the final text to input and the generated code
    """
    system_prompt = (
        "You are CODEACT_TEXT_AGENT, a constrained Python code generator for editing text in an Android text box.\n"
        "You will be given: (1) the current text in the focused text box as ORIGINAL, and (2) a TASK that describes how to modify it.\n\n"
        "Your job is to output ONLY a single Python code block in <python></python> format that:\n"
        "- Defines NO new functions, classes, or imports.\n"
        "- Uses ONLY the provided function input_text(text: str).\n"
        "- Builds the final content in a triple-quoted big string assigned to a variable of your choice, e.g.:\n"
        '    new_text = """..."""\n'
        "- Includes ORIGINAL in the new_text if needed to fulfill the TASK.\n"
        "- Calls input_text(new_text) exactly once to clear the field and input the new content.\n\n"
        "STRICT FORMAT RULES:\n"
        "- Respond with ONLY a Python code block: <python>\n<code>\n</python>\n"
        "- Do NOT print anything. Do NOT use input().\n"
        "- Do NOT import any modules. Do NOT define additional functions or classes.\n"
        "- Do NOT access files, network, or system.\n"
        "If you are unsure about the ORIGINAL, use it by referencing ORIGINAL variable so you dont make mistake with white space or new line characters\n"
        "below is ORIGINAL use it by referencing ORIGINAL variable or directly typing it out:\n<ORIGINAL>\n{current_text}\n</ORIGINAL>\n"
        f"""
<user_request>
{instruction}
</user_request>
<overall_plan>
{overall_plan}
</overall_plan>
<current_subgoal>
{current_subgoal}
</current_subgoal>
        """
    )

    error_correction_prompt = (
        "You are CODEACT_TEXT_AGENT, correcting your previous code that had execution errors.\n\n"
        "The code you generated previously failed with this error:\n{error_message}\n\n"
        "Please fix the code and output ONLY a new Python code block in <python></python> format.\n"
        "Follow the same rules as before:\n"
        "- Use ONLY the provided function input_text(text: str)\n"
        "- Build the final content in a triple-quoted big string\n"
        "- Include ORIGINAL in the new_text if needed\n"
        "- Call input_text(new_text) exactly once\n"
        "- Respond with ONLY a <python></python> code block\n"
        "If you are unsure about the ORIGINAL, use it by referencing ORIGINAL variable so you dont make mistake with white space or new line characters"
        "below is ORIGINAL use it by referencing ORIGINAL variable or directly typing it out:\n<ORIGINAL>{current_text}</ORIGINAL>\n"
    )

    user_prompt = (
        "TASK:\n{task_instruction}\n\n"
        "CURRENT TEXT (ORIGINAL):\n{current_text}\n\n"
        "Write the Python code now."
    ).format(
        task_instruction=current_subgoal.strip(),
        current_text=current_text,
    )

    messages = [
        ChatMessage(
            role="system",
            content=system_prompt.format(
                overall_plan=overall_plan,
                current_subgoal=current_subgoal,
                instruction=instruction,
                current_text=current_text,
            ),
        ),
        ChatMessage(role="user", content=user_prompt),
    ]

    for attempt in range(max_retries + 1):  # +1 for initial attempt
        # Call the LLM with current messages
        logger.info("‚úèÔ∏è TextManipulator response:", extra={"color": "cyan"})
        response_message = (
            await acall_with_retries(llm, messages, stream=stream)
        ).message
        content = response_message.content
        messages.append(response_message)

        # Extract code from <python> blocks
        code = _extract_python_code(content)
        if not code:
            # Fallback: if no code block found, use entire response as code
            code = content.strip()

        # Execute the code in a sandbox
        final_text, error_message = _execute_sandbox(code, current_text)

        # If successful (no error), return the result
        if not error_message:
            return final_text, code

        # If this was the last attempt, return what we have
        if attempt == max_retries:
            return final_text, code

        # Add error correction message to conversation
        correction_message = error_correction_prompt.format(error_message=error_message)
        messages.append(ChatMessage(role="user", content=correction_message))

    # This should never be reached, but just in case
    return current_text, ""


def _extract_python_code(text: str) -> str:
    """Extract Python code from <python>...</python> tags."""
    if not text:
        return ""

    open_tag = "<python>"
    close_tag = "</python>"

    open_idx = text.find(open_tag)
    if open_idx == -1:
        return ""

    close_idx = text.find(close_tag, open_idx + len(open_tag))
    if close_idx == -1:
        return ""

    code = text[open_idx + len(open_tag) : close_idx].strip()
    return code


def _execute_sandbox(code: str, original_text: str) -> tuple[str, str]:
    """Execute model code in a locked-down environment with exec().

    Returns:
        Tuple of (result_text, error_message) - result_text is the final text if successful,
        or original_text if failed. error_message is the stack trace if execution failed,
        or empty string if successful.
    """
    if not code:
        return original_text, ""

    captured = {"value": None}

    def input_text(text: str) -> None:
        """Capture the final text to be input."""
        captured["value"] = text

    # Create restricted environment
    sandbox_globals = {
        "__builtins__": {},  # Empty builtins for security
        "input_text": input_text,
        "ORIGINAL": original_text,
    }
    sandbox_locals = {}

    try:
        exec(code, sandbox_globals, sandbox_locals)
        return captured["value"] if captured["value"] is not None else original_text, ""
    except Exception:
        error_message = traceback.format_exc()
        return original_text, error_message

```

`droidrun/agent/scripter/__init__.py`:

```py
"""
ScripterAgent - ReAct agent for executing Python scripts (off-device operations).
"""

from droidrun.agent.scripter.scripter_agent import ScripterAgent

__all__ = ["ScripterAgent"]

```

`droidrun/agent/scripter/events.py`:

```py
"""
Events for the ScripterAgent workflow.

Internal events for streaming to frontend/logging.
"""

from typing import Optional

from llama_index.core.workflow import Event

from droidrun.agent.usage import UsageResult


class ScripterInputEvent(Event):
    """Input ready for LLM."""

    pass


class ScripterThinkingEvent(Event):
    """LLM response received."""

    thought: str
    code: Optional[str] = None
    full_response: str = ""
    usage: Optional[UsageResult] = None


class ScripterExecutionEvent(Event):
    """Code ready to execute."""

    code: str


class ScripterExecutionResultEvent(Event):
    """Code execution result."""

    output: str


class ScripterEndEvent(Event):
    """Scripter finished."""

    message: str  # Message to Manager
    success: bool  # True if response() called, False if max_steps
    code_executions: int = 0

```

`droidrun/agent/scripter/scripter_agent.py`:

```py
"""
ScripterAgent - ReAct agent for executing Python scripts (off-device operations).

Works like CodeAct but:
- No device tools (no click, type, swipe, etc.)
- When done, returns message without code (not a function call)
- Variables persist across iterations (Jupyter notebook style)
"""

import asyncio
import logging
from typing import TYPE_CHECKING

from llama_index.core.llms.llm import LLM
from llama_index.core.workflow import Context, StartEvent, StopEvent, Workflow, step

from droidrun.agent.scripter.events import (
    ScripterEndEvent,
    ScripterExecutionEvent,
    ScripterExecutionResultEvent,
    ScripterInputEvent,
    ScripterThinkingEvent,
)
from droidrun.agent.usage import get_usage_from_response
from droidrun.agent.utils import chat_utils
from droidrun.agent.utils.executer import ExecuterState, SimpleCodeExecutor
from droidrun.agent.utils.inference import acall_with_retries
from droidrun.config_manager.config_manager import AgentConfig
from droidrun.config_manager.prompt_loader import PromptLoader

if TYPE_CHECKING:
    from droidrun.agent.droid import DroidAgentState

logger = logging.getLogger("droidrun")


class ScripterAgent(Workflow):
    """
    ReAct agent for executing Python scripts (off-device operations).

    Like CodeAct but for off-device operations:
    - No device tools
    - Variables persist across code executions (Jupyter style)
    - Signals completion by returning message without code block
    """

    def __init__(
        self,
        llm: LLM,
        agent_config: AgentConfig,
        shared_state: "DroidAgentState",
        task: str,
        safe_execution_config=None,
        **kwargs,
    ):
        super().__init__(**kwargs)

        self.llm = llm
        self.agent_config = agent_config
        self.config = agent_config.scripter
        self.max_steps = self.config.max_steps
        self.shared_state = shared_state
        self.task = task

        self.message_history = []
        self.step_counter = 0

        # Build tool list (Python libraries only)
        self.tool_list = {}

        # Add standard library imports
        try:
            import requests

            self.tool_list["requests"] = requests
        except ImportError:
            logger.warning("requests library not available")

        try:
            import json

            self.tool_list["json"] = json
        except ImportError:
            pass

        # Get safety settings
        safe_mode = self.config.safe_execution
        safe_config = safe_execution_config

        # Initialize SimpleCodeExecutor with state preservation
        self.executor = SimpleCodeExecutor(
            locals={},
            tools=self.tool_list,
            globals={"__builtins__": __builtins__},
            use_same_scope=True,  # Preserve variables across calls
            safe_mode=safe_mode,
            allowed_modules=(
                safe_config.get_allowed_modules() if safe_config and safe_mode else None
            ),
            blocked_modules=(
                safe_config.get_blocked_modules() if safe_config and safe_mode else None
            ),
            allowed_builtins=(
                safe_config.get_allowed_builtins()
                if safe_config and safe_mode
                else None
            ),
            blocked_builtins=(
                safe_config.get_blocked_builtins()
                if safe_config and safe_mode
                else None
            ),
            event_loop=None,
        )

    def _get_library_descriptions(self) -> str:
        """Build description of available libraries."""
        libraries = [
            "- requests: HTTP library for making web requests",
            "- json: JSON parsing and generation",
            "- urllib: URL handling and parsing",
            "- re: Regular expressions",
            "- datetime, time: Time and date operations",
            "- pathlib: File path operations",
            "- base64: Encoding/decoding",
        ]
        return "\n".join(libraries)

    @step
    async def prepare_chat(self, ctx: Context, ev: StartEvent) -> ScripterInputEvent:
        """Initialize chat history with task."""
        logger.debug("üí¨ Preparing script chat...")

        # Load system prompt
        system_prompt_text = await PromptLoader.load_prompt(
            self.agent_config.get_scripter_system_prompt_path(),
            {
                "task": self.task,
                "max_steps": self.max_steps,
                "available_libraries": self._get_library_descriptions(),
            },
        )

        # Build initial message history (JSON format like ManagerAgent)
        self.message_history = [
            {"role": "system", "content": [{"text": system_prompt_text}]},
            {
                "role": "user",
                "content": [
                    {
                        "text": f"Task: {self.task}\n\nProvide your thought process and code to complete this task."
                    }
                ],
            },
        ]

        return ScripterInputEvent()

    @step
    async def handle_llm_input(
        self, ctx: Context, ev: ScripterInputEvent
    ) -> ScripterThinkingEvent | ScripterEndEvent:
        """Call LLM to generate thought + code."""

        if self.step_counter >= self.max_steps:
            logger.warning(f"‚ö†Ô∏è Max steps ({self.max_steps}) reached without completion")
            event = ScripterEndEvent(
                message=f"Max steps ({self.max_steps}) reached without completion",
                success=False,
                code_executions=self.step_counter,
            )
            ctx.write_event_to_stream(event)
            return event

        self.step_counter += 1
        logger.debug(
            f"üêç Script Step {self.step_counter}/{self.max_steps}: Thinking..."
        )

        ctx.write_event_to_stream(ev)

        # Convert to ChatMessages for LLM call
        chat_messages = chat_utils.to_chat_messages(self.message_history)

        try:
            logger.info("üêç Scripter response:", extra={"color": "magenta"})
            response = await acall_with_retries(
                self.llm, chat_messages, stream=self.agent_config.streaming
            )
        except Exception as e:
            logger.error(f"LLM call failed: {e}")
            event = ScripterEndEvent(
                message=f"LLM call failed: {e}",
                success=False,
                code_executions=self.step_counter,
            )
            ctx.write_event_to_stream(event)
            return event

        # Extract usage from response
        try:
            usage = get_usage_from_response(self.llm.class_name(), response)
        except Exception as e:
            logger.warning(f"Could not get llm usage from response: {e}")
            usage = None

        # Add assistant response to history
        full_response = response.message.content
        self.message_history.append(
            {"role": "assistant", "content": [{"text": full_response}]}
        )

        # Extract code and thoughts
        code, thoughts = chat_utils.extract_code_and_thought(full_response)

        event = ScripterThinkingEvent(
            thought=thoughts, code=code, full_response=full_response, usage=usage
        )
        ctx.write_event_to_stream(event)
        return event

    @step
    async def handle_llm_output(
        self, ctx: Context, ev: ScripterThinkingEvent
    ) -> ScripterExecutionEvent | ScripterEndEvent:
        """Route to execution or treat as final response if no code."""

        if not ev.thought:
            logger.warning("ü§î LLM provided code without thoughts")
        else:
            logger.debug(f"ü§î Reasoning: {ev.thought}")

        if ev.code:
            event = ScripterExecutionEvent(code=ev.code)
            ctx.write_event_to_stream(event)
            return event
        else:
            logger.debug("üìù No code provided, treating response as final answer")

            response_message = (
                ev.thought.strip() if ev.thought.strip() else ev.full_response.strip()
            )

            if not response_message:
                response_message = "No response provided by LLM"

            logger.debug(
                f"‚úÖ Script completed with response: {response_message[:100]}..."
            )
            event = ScripterEndEvent(
                message=response_message,
                success=True,
                code_executions=self.step_counter,
            )
            ctx.write_event_to_stream(event)
            return event

    @step
    async def execute_code(
        self, ctx: Context, ev: ScripterExecutionEvent
    ) -> ScripterExecutionResultEvent | ScripterEndEvent:
        """Execute Python code with state preservation."""

        code = ev.code
        logger.debug("‚ö° Executing script...")
        logger.debug(f"Code:\n<python>\n{code}\n</python>")

        try:
            # Execute with timeout from config
            result = await self.executor.execute(
                ExecuterState(ui_state=None),
                code,
                timeout=self.config.execution_timeout,
            )

            logger.info("üí° Execution result:", extra={"color": "dim"})
            logger.info(f"{result}")

            # Continue loop (completion detected in handle_llm_output)
            event = ScripterExecutionResultEvent(output=str(result))
            ctx.write_event_to_stream(event)
            return event

        except Exception as e:
            logger.error(f"üí• Execution failed: {e}")
            error_message = f"Error: {e}"
            event = ScripterExecutionResultEvent(output=error_message)
            ctx.write_event_to_stream(event)
            return event

    @step
    async def handle_execution_result(
        self, ctx: Context, ev: ScripterExecutionResultEvent
    ) -> ScripterInputEvent:
        """Add execution result to chat and loop back."""

        output = ev.output or "Code executed with no output."

        logger.debug(
            f"üìä Execution output: {output[:100]}..."
            if len(output) > 100
            else f"üìä Execution output: {output}"
        )

        # Add observation to chat history
        self.message_history.append(
            {
                "role": "user",
                "content": [
                    {"text": f"Execution Result:\n<result>\n{output}\n</result>"}
                ],
            }
        )

        return ScripterInputEvent()

    @step
    async def finalize(self, ctx: Context, ev: ScripterEndEvent) -> StopEvent:
        """Return result to DroidAgent."""

        logger.debug("‚úÖ Script agent complete")
        ctx.write_event_to_stream(ev)

        result = {
            "message": ev.message,
            "success": ev.success,
            "code_executions": ev.code_executions,
            "task": self.task,
        }

        return StopEvent(result)

```

`droidrun/agent/tool_registry.py`:

```py
"""ToolRegistry ‚Äî single source of truth for available tools.

Replaces ``ATOMIC_ACTION_SIGNATURES`` dispatch + executor if/elif chain +
FastAgent closure-building loop.
"""

from __future__ import annotations

import inspect
import json
import logging
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, Callable, Dict, Optional, Set

from droidrun.agent.action_result import ActionResult

if TYPE_CHECKING:
    from llama_index.core.workflow import Context as WorkflowContext

    from droidrun.agent.action_context import ActionContext

logger = logging.getLogger("droidrun")


@dataclass
class ToolEntry:
    fn: Callable
    params: Dict[str, Any]
    description: str
    deps: Optional[Set[str]] = None


class ToolRegistry:
    """Central registry of all agent-callable tools."""

    def __init__(self) -> None:
        self.tools: Dict[str, ToolEntry] = {}

    # -- registration --------------------------------------------------------

    def register(
        self,
        name: str,
        fn: Callable,
        params: Dict[str, Any],
        description: str,
        deps: Optional[Set[str]] = None,
    ) -> None:
        self.tools[name] = ToolEntry(
            fn=fn, params=params, description=description, deps=deps
        )

    def register_from_dict(self, tools_dict: Dict[str, Any]) -> None:
        """Register tools from the existing ``{name: {parameters, description, function}}`` format."""
        for name, spec in tools_dict.items():
            deps = spec.get("deps")
            if deps is not None:
                deps = set(deps)
            self.register(
                name=name,
                fn=spec["function"],
                params=spec.get("parameters", {}),
                description=spec.get("description", f"Tool: {name}"),
                deps=deps,
            )

    def disable(self, tool_names: list[str]) -> None:
        """Remove tools by name (silently ignores unknown names)."""
        for name in tool_names:
            self.tools.pop(name, None)

    def disable_unsupported(self, capabilities: Set[str]) -> None:
        """Remove tools whose ``deps`` set is not satisfied by *capabilities*.

        Tools with ``deps=None`` (custom tools, MCP tools, etc.) are kept.
        """
        to_remove = [
            name
            for name, entry in self.tools.items()
            if entry.deps is not None and not entry.deps <= capabilities
        ]
        if to_remove:
            logger.debug(f"Disabling unsupported tools: {to_remove}")
        self.disable(to_remove)

    # -- query ---------------------------------------------------------------

    def get_signatures(self, exclude: Optional[Set[str]] = None) -> Dict[str, Any]:
        """Return ``{name: {parameters, description}}`` for prompt building.

        Args:
            exclude: Optional set of tool names to omit.  Used by
                     ExecutorAgent to hide flow-control tools (remember,
                     complete) that only FastAgent/CodeAct should see.
        """
        exclude = exclude or set()
        return {
            name: {"parameters": entry.params, "description": entry.description}
            for name, entry in self.tools.items()
            if name not in exclude
        }

    # -- execution -----------------------------------------------------------

    async def execute(
        self,
        name: str,
        args: Dict[str, Any],
        ctx: "ActionContext",
        workflow_ctx: "Optional[WorkflowContext]" = None,
    ) -> ActionResult:
        """Dispatch action by name.

        All actions receive ``ctx=ctx`` as a keyword argument.

        Args:
            workflow_ctx: Optional llama-index workflow Context. When provided,
                a ``ToolExecutionEvent`` is streamed after execution.

        Handles:
        - Unknown tool names
        - Sync vs async functions
        - TypeError (bad arguments)
        - General exceptions
        """
        if name not in self.tools:
            result = ActionResult(
                success=False,
                summary=(
                    f"Unknown tool: {name}. " f"Available: {list(self.tools.keys())}"
                ),
            )
            self._emit_event(workflow_ctx, name, args, result)
            return result

        entry = self.tools[name]
        try:
            if inspect.iscoroutinefunction(entry.fn):
                result = await entry.fn(**args, ctx=ctx)
            else:
                result = entry.fn(**args, ctx=ctx)
        except TypeError as e:
            result = ActionResult(
                success=False,
                summary=f"Invalid arguments for {name}: {e}",
            )
            self._emit_event(workflow_ctx, name, args, result)
            return result
        except Exception as e:
            result = ActionResult(
                success=False,
                summary=f"Failed to execute {name}: {e}",
            )
            self._emit_event(workflow_ctx, name, args, result)
            return result

        # Normalise the return value into ActionResult
        if isinstance(result, ActionResult):
            action_result = result
        elif isinstance(result, tuple):
            action_result = ActionResult(success=result[0], summary=str(result[1]))
        elif isinstance(result, str):
            success = not result.startswith("Failed")
            action_result = ActionResult(success=success, summary=result)
        else:
            action_result = ActionResult(
                success=True, summary=str(result) if result else "Done"
            )

        self._emit_event(workflow_ctx, name, args, action_result)
        return action_result

    @staticmethod
    def _emit_event(
        workflow_ctx: "Optional[WorkflowContext]",
        name: str,
        args: Dict[str, Any],
        result: ActionResult,
    ) -> None:
        if workflow_ctx is None:
            return
        from droidrun.agent.common.events import ToolExecutionEvent

        workflow_ctx.write_event_to_stream(
            ToolExecutionEvent(
                tool_name=name,
                tool_args=args,
                success=result.success,
                summary=result.summary,
            )
        )

    # -- prompt helpers ------------------------------------------------------

    def get_tool_descriptions_xml(self, exclude: Optional[Set[str]] = None) -> str:
        """Build XML ``<functions>`` block for FastAgent system prompt."""
        exclude = exclude or set()
        lines = ["<functions>"]
        for name, entry in self.tools.items():
            if name in exclude:
                continue
            lines.append(f"<function>{self._spec_to_json(name, entry)}</function>")
        lines.append("</functions>")
        return "\n".join(lines)

    def get_tool_descriptions_text(self, exclude: Optional[Set[str]] = None) -> str:
        """Build text tool descriptions for executor/codeact prompts."""
        exclude = exclude or set()
        descriptions = []
        for name, entry in self.tools.items():
            if name in exclude:
                continue
            params = self._format_params(entry.params)
            descriptions.append(f"- {name}({params}): {entry.description}")
        return "\n".join(descriptions)

    def get_param_types(self, exclude: Optional[Set[str]] = None) -> Dict[str, str]:
        """Build a flat ``{param_name: type_string}`` map for XML coercion.

        Note: parameter names are global (not per-tool).
        """
        exclude = exclude or set()
        param_types: Dict[str, str] = {}
        for name, entry in self.tools.items():
            if name in exclude:
                continue
            for param_name, param_info in entry.params.items():
                param_types[param_name] = param_info.get("type", "string")
        return param_types

    # -- internal helpers ----------------------------------------------------

    @staticmethod
    def _format_params(parameters: Dict[str, Any]) -> str:
        parts = []
        for name, info in parameters.items():
            type_str = info.get("type", "string")
            if info.get("required", True):
                parts.append(f"{name}: {type_str}")
            else:
                default = info.get("default", "None")
                parts.append(f"{name}: {type_str} = {default}")
        return ", ".join(parts)

    @staticmethod
    def _spec_to_json(name: str, entry: ToolEntry) -> str:
        parameters = entry.params
        properties = {}
        required = []
        for param_name, param_info in parameters.items():
            properties[param_name] = {"type": param_info.get("type", "string")}
            if param_info.get("description"):
                properties[param_name]["description"] = param_info["description"]
            if param_info.get("required", True):
                required.append(param_name)
            if "default" in param_info:
                properties[param_name]["default"] = param_info["default"]

        tool_dict = {
            "name": name,
            "description": entry.description,
            "parameters": {
                "type": "object",
                "properties": properties,
                "required": required,
            },
        }
        return json.dumps(tool_dict, separators=(",", ":"))

```

`droidrun/agent/trajectory/__init__.py`:

```py
from droidrun.agent.trajectory.writer import TrajectoryWriter, make_serializable

__all__ = ["TrajectoryWriter", "make_serializable"]

```

`droidrun/agent/trajectory/writer.py`:

```py
import asyncio
import json
import logging
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

import aiofiles
from PIL import Image

from aiofiles import ospath

logger = logging.getLogger("droidrun")


def make_serializable(obj):
    """Recursively make objects JSON serializable."""
    if hasattr(obj, "__class__") and obj.__class__.__name__ == "ChatMessage":
        if hasattr(obj, "content") and obj.content is not None:
            return {"role": obj.role.value, "content": obj.content}
        elif hasattr(obj, "blocks") and obj.blocks:
            text_content = ""
            for block in obj.blocks:
                if hasattr(block, "text"):
                    text_content += block.text
            return {"role": obj.role.value, "content": text_content}
        else:
            return str(obj)
    elif isinstance(obj, dict):
        return {k: make_serializable(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [make_serializable(item) for item in obj]
    elif hasattr(obj, "__dict__"):
        result = {}
        for k, v in obj.__dict__.items():
            if not k.startswith("_"):
                try:
                    result[k] = make_serializable(v)
                except (TypeError, ValueError) as e:
                    logger.warning(f"Failed to serialize attribute {k}: {e}")
                    result[k] = str(v)
        return result
    else:
        try:
            json.dumps(obj)
            return obj
        except (TypeError, ValueError):
            return str(obj)


@dataclass(frozen=True)
class WriteJob(ABC):
    """Immutable write operation.

    Jobs capture a snapshot of data at creation time, preventing race
    conditions from concurrent trajectory mutations during async writes.
    """

    trajectory_id: str
    stage: str

    @abstractmethod
    async def execute(self) -> None:
        """Execute the write operation asynchronously."""
        pass


@dataclass(frozen=True)
class EventsWriteJob(WriteJob):
    """Writes trajectory.json."""

    target_path: Path
    serialized_events: str

    async def execute(self) -> None:
        async with aiofiles.open(self.target_path, "w") as f:
            await f.write(self.serialized_events)


@dataclass(frozen=True)
class MacroWriteJob(WriteJob):
    """Writes macro.json."""

    target_path: Path
    serialized_macro: str

    async def execute(self) -> None:
        async with aiofiles.open(self.target_path, "w") as f:
            await f.write(self.serialized_macro)


@dataclass(frozen=True)
class ScreenshotWriteJob(WriteJob):
    """Writes individual screenshot PNG."""

    target_path: Path
    screenshot_bytes: bytes

    async def execute(self) -> None:
        async with aiofiles.open(self.target_path, "wb") as f:
            await f.write(self.screenshot_bytes)


@dataclass(frozen=True)
class GifWriteJob(WriteJob):
    """Creates animated GIF from screenshots on disk."""

    target_path: Path
    screenshots_folder: Path
    screenshot_count: int
    duration: int = 1000

    async def execute(self) -> None:
        def _create_gif():
            images = []

            for idx in range(self.screenshot_count):
                screenshot_path = self.screenshots_folder / f"{idx:04d}.png"
                if not screenshot_path.exists():
                    logger.warning(f"Screenshot {idx:04d}.png not found, skipping")
                    continue

                try:
                    img = Image.open(screenshot_path)
                    images.append(img.copy())
                    img.close()
                except Exception as e:
                    logger.warning(f"Failed to load screenshot {idx}: {e}")
                    continue

            if images:
                try:
                    images[0].save(
                        str(self.target_path),
                        save_all=True,
                        append_images=images[1:],
                        duration=self.duration,
                        loop=0,
                    )
                finally:
                    for img in images:
                        try:
                            img.close()
                        except Exception:
                            pass

        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, _create_gif)


@dataclass(frozen=True)
class UIStateWriteJob(WriteJob):
    """Writes UI state JSON."""

    target_path: Path
    serialized_state: str

    async def execute(self) -> None:
        if not (await ospath.exists(self.target_path)):
            async with aiofiles.open(self.target_path, "w", encoding="utf-8") as f:
                await f.write(self.serialized_state)


class WriterWorker:
    """Async worker that processes write jobs from a queue.

    Jobs are executed sequentially (FIFO order). Errors are logged but
    don't stop the worker - it continues processing remaining jobs.
    """

    def __init__(self, max_queue_size: int = 300):
        self.queue = asyncio.Queue(maxsize=max_queue_size)
        self.worker_task = None
        self.running = False
        self._write_count = 0
        self._error_count = 0

    async def start(self) -> None:
        """Start the worker task."""
        if self.running:
            return

        self.running = True
        self.worker_task = asyncio.create_task(self._work_loop())

    async def stop(self, timeout: float = 30.0) -> None:
        """Stop worker and wait for pending writes to complete.

        Drains the queue before canceling. Any jobs still pending after
        timeout are dropped with a warning.

        Args:
            timeout: Maximum seconds to wait for queue to drain
        """
        if not self.running:
            return

        try:
            await asyncio.wait_for(self.queue.join(), timeout=timeout)
        except asyncio.TimeoutError:
            logger.warning(
                f"Writer timeout after {timeout}s, {self.queue.qsize()} jobs remaining"
            )

        self.running = False

        if self.worker_task:
            self.worker_task.cancel()
            try:
                await self.worker_task
            except asyncio.CancelledError:
                pass

    async def _work_loop(self) -> None:
        while self.running:
            try:
                job = await self.queue.get()

                try:
                    await job.execute()
                    self._write_count += 1
                except Exception as e:
                    self._error_count += 1
                    logger.error(f"Write failed: {e}", exc_info=True)
                finally:
                    self.queue.task_done()

            except asyncio.CancelledError:
                break

    def submit(self, job: WriteJob) -> bool:
        try:
            self.queue.put_nowait(job)
            return True
        except asyncio.QueueFull:
            logger.warning(f"Queue full, dropping {job.__class__.__name__}")
            return False


class TrajectoryWriter:
    """Background writer that persists trajectory data without blocking.

    Manages a single async worker that processes write jobs from a queue.
    All writes happen in the background - agent never blocks on I/O.

    Usage:
        writer = TrajectoryWriter(queue_size=300)
        await writer.start()

        # Non-blocking writes
        writer.write(trajectory, stage="step_1")

        # Wait for completion
        writer.write_final(trajectory)
        await writer.stop()
    """

    def __init__(self, queue_size: int = 300):
        self.worker = WriterWorker(max_queue_size=queue_size)
        self._started = False

    async def start(self) -> None:
        """Start the background worker."""
        await self.worker.start()
        self._started = True

    async def stop(self, timeout: float = 30.0) -> None:
        """Stop the background worker and wait for pending writes."""
        await self.worker.stop(timeout=timeout)

    def write(self, trajectory, stage: str) -> None:
        """Write trajectory data to disk in background (non-blocking).

        Creates a snapshot of trajectory data and queues write jobs.
        Returns immediately - actual writes happen asynchronously.

        Args:
            trajectory: Trajectory instance with data to persist
            stage: Label for this save point (e.g. "init", "step_1", "final")
        """
        if not self._started:
            logger.warning("TrajectoryWriter not started, skipping save")
            return

        trajectory_id = trajectory.trajectory_folder.name

        events_snapshot = list(trajectory.events)
        macro_snapshot = list(trajectory.macro) if trajectory.macro else []
        screenshot_queue_snapshot = list(trajectory.screenshot_queue)
        ui_states_snapshot = list(trajectory.ui_states)

        jobs = []

        events_job = self._create_events_job(
            events_snapshot, trajectory, trajectory_id, stage
        )
        if events_job:
            jobs.append(events_job)

        macro_job = self._create_macro_job(
            macro_snapshot, trajectory, trajectory_id, stage
        )
        if macro_job:
            jobs.append(macro_job)

        screenshot_jobs = self._create_screenshot_jobs(
            screenshot_queue_snapshot, trajectory, trajectory_id, stage
        )
        jobs.extend(screenshot_jobs)

        ui_jobs = self._create_ui_state_jobs(
            ui_states_snapshot, trajectory, trajectory_id, stage
        )
        jobs.extend(ui_jobs)

        for job in jobs:
            self.worker.submit(job)

        if screenshot_queue_snapshot:
            trajectory.screenshot_queue.clear()
            logger.debug(
                f"Cleared {len(screenshot_queue_snapshot)} screenshots from queue"
            )

    def write_final(self, trajectory, trajectory_gifs) -> None:
        """Write final trajectory data including GIF creation.

        Args:
            trajectory: Trajectory instance to finalize
        """
        self.write(trajectory, stage="final")
        # GIF is only created at finalize (all screenshots available)
        if trajectory_gifs is True:
            trajectory_id = trajectory.trajectory_folder.name
            gif_job = self._create_gif_job(trajectory, trajectory_id, "final")
            if gif_job:
                self.worker.submit(gif_job)

    def _create_events_job(
        self, events_snapshot, trajectory, trajectory_id, stage
    ) -> Optional[EventsWriteJob]:
        serialized_events = []

        for event in events_snapshot:
            event_dict = {"type": event.__class__.__name__}

            for k, v in event.__dict__.items():
                if not k.startswith("_"):
                    try:
                        event_dict[k] = make_serializable(v)
                    except (TypeError, ValueError) as e:
                        logger.warning(f"Failed to serialize {k}: {e}")
                        event_dict[k] = str(v)

            if hasattr(event, "tokens") and "tokens" not in event_dict:
                event_dict["tokens"] = make_serializable(event.tokens)

            serialized_events.append(event_dict)

        return EventsWriteJob(
            trajectory_id=trajectory_id,
            stage=stage,
            target_path=trajectory.trajectory_folder / "trajectory.json",
            serialized_events=json.dumps(serialized_events, indent=2),
        )

    def _create_macro_job(
        self, macro_snapshot, trajectory, trajectory_id, stage
    ) -> Optional[MacroWriteJob]:
        if not macro_snapshot:
            return None

        macro_data = {
            "version": "1.0",
            "description": trajectory.goal,
            "timestamp": time.strftime("%Y%m%d_%H%M%S"),
            "total_actions": len(macro_snapshot),
            "actions": macro_snapshot,  # already list[dict] from RecordingDriver.log
        }

        return MacroWriteJob(
            trajectory_id=trajectory_id,
            stage=stage,
            target_path=trajectory.trajectory_folder / "macro.json",
            serialized_macro=json.dumps(macro_data, indent=2),
        )

    def _create_screenshot_jobs(
        self, screenshot_queue_snapshot, trajectory, trajectory_id, stage
    ) -> List[ScreenshotWriteJob]:
        jobs = []
        screenshots_folder = trajectory.trajectory_folder / "screenshots"
        screenshots_folder.mkdir(exist_ok=True)

        start_idx = trajectory.screenshot_count - len(screenshot_queue_snapshot)

        for offset, screenshot_bytes in enumerate(screenshot_queue_snapshot):
            screenshot_idx = start_idx + offset
            screenshot_path = screenshots_folder / f"{screenshot_idx:04d}.png"
            jobs.append(
                ScreenshotWriteJob(
                    trajectory_id=trajectory_id,
                    stage=stage,
                    target_path=screenshot_path,
                    screenshot_bytes=screenshot_bytes,
                )
            )

        return jobs

    def _create_gif_job(
        self, trajectory, trajectory_id, stage
    ) -> Optional[GifWriteJob]:
        if trajectory.screenshot_count == 0:
            return None

        screenshots_folder = trajectory.trajectory_folder / "screenshots"
        screenshots_folder.mkdir(exist_ok=True)

        return GifWriteJob(
            trajectory_id=trajectory_id,
            stage=stage,
            target_path=screenshots_folder / "trajectory.gif",
            screenshots_folder=screenshots_folder,
            screenshot_count=trajectory.screenshot_count,
        )

    def _create_ui_state_jobs(
        self, ui_states_snapshot, trajectory, trajectory_id, stage
    ) -> List[UIStateWriteJob]:
        jobs = []
        ui_states_folder = trajectory.trajectory_folder / "ui_states"
        ui_states_folder.mkdir(exist_ok=True)

        for idx, ui_state in enumerate(ui_states_snapshot):
            ui_state_path = ui_states_folder / f"{idx:04d}.json"
            jobs.append(
                UIStateWriteJob(
                    trajectory_id=trajectory_id,
                    stage=stage,
                    target_path=ui_state_path,
                    serialized_state=json.dumps(ui_state, ensure_ascii=False, indent=2),
                )
            )

        return jobs

```

`droidrun/agent/usage.py`:

```py
import contextlib
import logging
from typing import Any, Dict, List, Optional
from uuid import uuid4

from llama_index.core.callbacks.base_handler import BaseCallbackHandler
from llama_index.core.callbacks.schema import CBEventType, EventPayload
from llama_index.core.llms import LLM, ChatResponse
from pydantic import BaseModel

logger = logging.getLogger("droidrun")
SUPPORTED_PROVIDERS = [
    "Gemini",
    "GoogleGenAI",
    "GenAI",
    "OpenAI",
    "openai_llm",
    "Anthropic",
    "Ollama",
    "DeepSeek",
]


class UsageResult(BaseModel):
    request_tokens: int
    response_tokens: int
    total_tokens: int
    requests: int


def get_usage_from_response(provider: str, chat_rsp: ChatResponse) -> UsageResult:
    rsp = chat_rsp.raw
    if not rsp:
        raise ValueError("No raw response in chat response")

    if provider == "Gemini" or provider == "GoogleGenAI" or provider == "GenAI":
        return UsageResult(
            request_tokens=rsp["usage_metadata"]["prompt_token_count"],
            response_tokens=rsp["usage_metadata"]["candidates_token_count"],
            total_tokens=rsp["usage_metadata"]["total_token_count"],
            requests=1,
        )
    elif provider == "OpenAI" or provider == "OpenAILike" or provider == "openai_llm":
        from openai.types import CompletionUsage as OpenAIUsage

        usage: OpenAIUsage = rsp.usage
        return UsageResult(
            request_tokens=usage.prompt_tokens,
            response_tokens=usage.completion_tokens,
            total_tokens=usage.total_tokens,
            requests=1,
        )
    elif provider == "Anthropic_LLM":
        from anthropic.types import Usage as AnthropicUsage

        usage: AnthropicUsage = rsp["usage"]
        return UsageResult(
            request_tokens=usage.input_tokens,
            response_tokens=usage.output_tokens,
            total_tokens=usage.input_tokens + usage.output_tokens,
            requests=1,
        )
    elif provider == "Ollama":
        # Ollama response format uses different field names
        prompt_eval_count = rsp.get("prompt_eval_count", 0)
        eval_count = rsp.get("eval_count", 0)
        return UsageResult(
            request_tokens=prompt_eval_count,
            response_tokens=eval_count,
            total_tokens=prompt_eval_count + eval_count,
            requests=1,
        )
    elif provider == "DeepSeek":
        # DeepSeek follows OpenAI-compatible format
        usage = rsp.usage
        if not usage:
            usage = {}
        return UsageResult(
            request_tokens=usage.prompt_tokens or 0,
            response_tokens=usage.completion_tokens or 0,
            total_tokens=usage.total_tokens or 0,
            requests=1,
        )

    raise ValueError(f"Unsupported provider: {provider}")


class TokenCountingHandler(BaseCallbackHandler):
    """Token counting handler for LLamaIndex LLM calls."""

    def __init__(self, provider: str):
        super().__init__(event_starts_to_ignore=[], event_ends_to_ignore=[])
        self.provider = provider
        self.request_tokens: int = 0
        self.response_tokens: int = 0
        self.total_tokens: int = 0
        self.requests: int = 0

    @classmethod
    def class_name(cls) -> str:
        """Class name."""
        return "TokenCountingHandler"

    @property
    def usage(self) -> UsageResult:
        return UsageResult(
            request_tokens=self.request_tokens,
            response_tokens=self.response_tokens,
            total_tokens=self.total_tokens,
            requests=self.requests,
        )

    def _get_event_usage(self, payload: Dict[str, Any]) -> UsageResult:
        if EventPayload.RESPONSE not in payload:
            raise ValueError("No response in payload")

        chat_rsp: ChatResponse = payload.get(EventPayload.RESPONSE)
        return get_usage_from_response(self.provider, chat_rsp)

    def on_event_start(
        self,
        event_type: CBEventType,
        payload: Optional[Dict[str, Any]] = None,
        event_id: str = "",
        parent_id: str = "",
        **kwargs: Any,
    ) -> str:
        """Run when an event starts and return id of event."""
        return event_id or str(uuid4())

    def on_event_end(
        self,
        event_type: CBEventType,
        payload: Optional[Dict[str, Any]] = None,
        event_id: str = "",
        **kwargs: Any,
    ) -> None:
        """Run when an event ends."""
        try:
            usage = self._get_event_usage(payload)

            self.request_tokens += usage.request_tokens
            self.response_tokens += usage.response_tokens
            self.total_tokens += usage.total_tokens
            self.requests += usage.requests
        except Exception as e:
            self.requests += 1
            logger.warning(
                f"Error tracking usage for provider {self.provider}: {e}",
                extra={"provider": self.provider},
            )

    def start_trace(self, trace_id: Optional[str] = None) -> None:
        """Run when an overall trace is launched."""
        pass

    def end_trace(
        self,
        trace_id: Optional[str] = None,
        trace_map: Optional[Dict[str, List[str]]] = None,
    ) -> None:
        """Run when an overall trace is exited."""
        pass


@contextlib.contextmanager
def llm_callback(llm: LLM, *args: List[BaseCallbackHandler]):
    for arg in args:
        llm.callback_manager.add_handler(arg)
    yield
    for arg in args:
        llm.callback_manager.remove_handler(arg)


def create_tracker(llm: LLM) -> TokenCountingHandler:
    provider = llm.__class__.__name__
    if provider not in SUPPORTED_PROVIDERS:
        raise ValueError(f"Tracking not yet supported for provider: {provider}")

    return TokenCountingHandler(provider)


def track_usage(llm: LLM) -> TokenCountingHandler:
    """Track token usage for an LLM instance across all requests.

    This function:
    - Creates a new TokenCountingHandler for the LLM provider
    - Registers that handler as an LLM callback to monitor all requests
    - Returns the handler for accessing cumulative usage statistics

    The handler counts tokens for total LLM usage across all requests. For fine-grained
    per-request counting, use either:
    - `create_tracker()` with `llm_callback()` context manager for temporary tracking
    - `get_usage_from_response()` to extract usage from individual responses

    Args:
        llm: The LLamaIndex LLM instance to track usage for

    Returns:
        TokenCountingHandler: The registered handler that accumulates usage statistics

    Raises:
        ValueError: If the LLM provider is not supported for tracking

    Example:
        >>> llm = OpenAI()
        >>> tracker = track_usage(llm)
        >>> # ... make LLM calls ...
        >>> print(f"Total tokens used: {tracker.usage.total_tokens}")
    """
    provider = llm.__class__.__name__
    if provider not in SUPPORTED_PROVIDERS:
        raise ValueError(f"Tracking not yet supported for provider: {provider}")

    tracker = TokenCountingHandler(provider)
    llm.callback_manager.add_handler(tracker)
    return tracker

```

`droidrun/agent/utils/__init__.py`:

```py
"""
Utility modules for DroidRun agents.
"""

from .chat_utils import (
    to_chat_messages,
    extract_code_and_thought,
    has_content,
    filter_empty_messages,
    limit_history,
)

from .prompt_resolver import PromptResolver
from .signatures import (
    ATOMIC_ACTION_SIGNATURES,
    build_credential_tools,
)

from .trajectory import Trajectory

from .executer import ExecuterState, SimpleCodeExecutor

__all__ = [
    # Chat utilities
    "to_chat_messages",
    "extract_code_and_thought",
    "has_content",
    "filter_empty_messages",
    "limit_history",
    # Prompt utilities
    "PromptResolver",
    # Tool utilities
    "ATOMIC_ACTION_SIGNATURES",
    "build_credential_tools",
    # Trajectory
    "Trajectory",
    # Executor
    "ExecuterState",
    "SimpleCodeExecutor",
]

```

`droidrun/agent/utils/actions.py`:

```py
"""Action functions for device interaction.

Each function receives ``ctx: ActionContext`` as a keyword argument and
interacts with the device via ``ctx.driver``, resolves UI elements via
``ctx.ui``, and accesses shared state via ``ctx.shared_state``.
"""

import asyncio
import logging
from typing import TYPE_CHECKING, List

if TYPE_CHECKING:
    from droidrun.agent.action_context import ActionContext

from droidrun.agent.action_result import ActionResult
from droidrun.agent.oneflows.app_starter_workflow import AppStarter

logger = logging.getLogger("droidrun")


# ---------------------------------------------------------------------------
# Core UI actions
# ---------------------------------------------------------------------------


async def click(index: int, *, ctx: "ActionContext") -> ActionResult:
    """Click the element with the given index."""
    try:
        x, y = ctx.ui.get_element_coords(index)
        await ctx.driver.tap(x, y)

        info = ctx.ui.get_element_info(index)
        detail_parts = [
            f"Text: '{info.get('text', 'No text')}'",
            f"Class: {info.get('className', 'Unknown class')}",
            f"Type: {info.get('type', 'unknown')}",
        ]
        if info.get("child_texts"):
            detail_parts.append(f"Contains text: {' | '.join(info['child_texts'])}")
        detail_parts.append(f"Coordinates: ({x}, {y})")

        return ActionResult(
            success=True, summary=f"Clicked on {' | '.join(detail_parts)}"
        )
    except ValueError as e:
        return ActionResult(
            success=False, summary=f"Failed to click element at index {index}: {e}"
        )


async def long_press(index: int, *, ctx: "ActionContext") -> ActionResult:
    """Long press the element with the given index."""
    try:
        x, y = ctx.ui.get_element_coords(index)
        await ctx.driver.swipe(x, y, x, y, 1000)
        return ActionResult(
            success=True, summary=f"Long pressed element at index {index} at ({x}, {y})"
        )
    except ValueError as e:
        return ActionResult(
            success=False, summary=f"Failed to long press element at index {index}: {e}"
        )


async def long_press_at(x: int, y: int, *, ctx: "ActionContext") -> ActionResult:
    """Long press at screen coordinates."""
    try:
        abs_x, abs_y = ctx.ui.convert_point(x, y)
        await ctx.driver.swipe(abs_x, abs_y, abs_x, abs_y, 1000)
        return ActionResult(success=True, summary=f"Long pressed at ({abs_x}, {abs_y})")
    except Exception as e:
        return ActionResult(
            success=False, summary=f"Failed to long press at ({x}, {y}): {e}"
        )


async def click_at(x: int, y: int, *, ctx: "ActionContext") -> ActionResult:
    """Click at screen coordinates."""
    try:
        abs_x, abs_y = ctx.ui.convert_point(x, y)
        await ctx.driver.tap(abs_x, abs_y)
        return ActionResult(success=True, summary=f"Tapped at ({abs_x}, {abs_y})")
    except Exception as e:
        return ActionResult(success=False, summary=f"Failed to tap at ({x}, {y}): {e}")


async def click_area(
    x1: int, y1: int, x2: int, y2: int, *, ctx: "ActionContext"
) -> ActionResult:
    """Click center of area."""
    try:
        cx, cy = (x1 + x2) // 2, (y1 + y2) // 2
        abs_x, abs_y = ctx.ui.convert_point(cx, cy)
        await ctx.driver.tap(abs_x, abs_y)
        return ActionResult(
            success=True, summary=f"Tapped center of area at ({abs_x}, {abs_y})"
        )
    except Exception as e:
        return ActionResult(success=False, summary=f"Failed to tap area center: {e}")


async def type(
    text: str, index: int, clear: bool = False, *, ctx: "ActionContext"
) -> ActionResult:
    """Type text into the element with the given index."""
    try:
        # Tap the element first if a specific index is given
        if index != -1:
            x, y = ctx.ui.get_element_coords(index)
            await ctx.driver.tap(x, y)

        success = await ctx.driver.input_text(text, clear)
        if success:
            return ActionResult(
                success=True, summary=f"Text typed successfully (clear={clear})"
            )
        else:
            return ActionResult(
                success=False, summary="Failed to type text: input failed"
            )
    except Exception as e:
        return ActionResult(success=False, summary=f"Failed to type text: {e}")


async def system_button(button: str, *, ctx: "ActionContext") -> ActionResult:
    """Press a system button (back, home, or enter)."""
    button_map = {"back": 4, "home": 3, "enter": 66}
    button_lower = button.lower()

    if button_lower not in button_map:
        return ActionResult(
            success=False,
            summary=f"Failed to press {button} button: unknown button. Valid options: back, home, enter",
        )

    keycode = button_map[button_lower]
    key_names = {66: "ENTER", 4: "BACK", 3: "HOME"}
    key_name = key_names.get(keycode, str(keycode))

    try:
        await ctx.driver.press_key(keycode)
        return ActionResult(success=True, summary=f"Pressed {key_name} button")
    except Exception as e:
        return ActionResult(
            success=False, summary=f"Failed to press {key_name} button: {e}"
        )


async def swipe(
    coordinate: List[int],
    coordinate2: List[int],
    duration: float = 1.0,
    *,
    ctx: "ActionContext",
) -> ActionResult:
    """Swipe from one coordinate to another."""
    if not isinstance(coordinate, list) or len(coordinate) != 2:
        return ActionResult(
            success=False,
            summary=f"Failed: coordinate must be a list of 2 integers, got: {coordinate}",
        )
    if not isinstance(coordinate2, list) or len(coordinate2) != 2:
        return ActionResult(
            success=False,
            summary=f"Failed: coordinate2 must be a list of 2 integers, got: {coordinate2}",
        )

    try:
        start_x, start_y = ctx.ui.convert_point(*coordinate)
        end_x, end_y = ctx.ui.convert_point(*coordinate2)
        duration_ms = int(duration * 1000)
        await ctx.driver.swipe(start_x, start_y, end_x, end_y, duration_ms=duration_ms)
        return ActionResult(
            success=True,
            summary=f"Swiped from ({start_x}, {start_y}) to ({end_x}, {end_y})",
        )
    except Exception as e:
        return ActionResult(success=False, summary=f"Failed to swipe: {e}")


async def open_app(text: str, *, ctx: "ActionContext") -> ActionResult:
    """Open an app by its name."""
    if ctx.app_opener_llm is None:
        return ActionResult(
            success=False,
            summary="Failed: app_opener_llm not configured.",
        )

    workflow = AppStarter(
        tools=ctx.driver,
        llm=ctx.app_opener_llm,
        timeout=60,
        stream=ctx.streaming,
        verbose=False,
    )

    result = await workflow.run(app_description=text)
    await asyncio.sleep(1)

    if isinstance(result, str) and "could not open app" in result.lower():
        return ActionResult(success=False, summary=result)
    return ActionResult(success=True, summary=str(result))


async def wait(duration: float = 1.0, *, ctx: "ActionContext") -> ActionResult:
    """Wait for a specified duration in seconds."""
    await asyncio.sleep(duration)
    return ActionResult(success=True, summary=f"Waited for {duration} seconds")


# ---------------------------------------------------------------------------
# State / memory actions
# ---------------------------------------------------------------------------


async def remember(information: str, *, ctx: "ActionContext") -> ActionResult:
    """Remember important information for later use."""
    result = await ctx.shared_state.remember(information)
    success = not result.startswith("Failed")
    return ActionResult(success=success, summary=result)


async def complete(
    success: bool, reason: str = "", message: str = "", *, ctx: "ActionContext"
) -> ActionResult:
    """Mark the task as complete.

    Accepts both ``reason`` and ``message`` ‚Äî FastAgent XML prompt uses
    ``message``, action signature uses ``reason``.
    """
    await ctx.shared_state.complete(success, reason=reason, message=message)
    return ActionResult(success=True, summary=ctx.shared_state.answer)


async def type_secret(
    secret_id: str, index: int, *, ctx: "ActionContext"
) -> ActionResult:
    """Type a secret credential into an input field without exposing the value."""
    if ctx.credential_manager is None:
        return ActionResult(
            success=False,
            summary="Failed to type secret: Credential manager not initialized. Enable credentials in config.yaml",
        )

    try:
        secret_value = await ctx.credential_manager.resolve_key(secret_id)

        # Tap the element first if a specific index is given
        if index != -1:
            x, y = ctx.ui.get_element_coords(index)
            await ctx.driver.tap(x, y)

        ok = await ctx.driver.input_text(secret_value)
        if ok:
            return ActionResult(
                success=True,
                summary=f"Successfully typed secret '{secret_id}' into element {index}",
            )
        else:
            return ActionResult(
                success=False,
                summary=f"Failed to type secret '{secret_id}': input failed",
            )
    except Exception as e:
        logger.error(f"Failed to type secret '{secret_id}': {e}")
        available = (
            await ctx.credential_manager.get_keys() if ctx.credential_manager else []
        )
        return ActionResult(
            success=False,
            summary=f"Failed to type secret '{secret_id}': not found. Available: {available}",
        )

```

`droidrun/agent/utils/chat_utils.py`:

```py
import logging
from io import BytesIO
from pathlib import Path
from typing import List, Optional, Tuple, Union

from PIL import Image
from llama_index.core.base.llms.types import ChatMessage, ImageBlock, TextBlock

logger = logging.getLogger("droidrun")


# ============================================================================
# CONVERSION TO CHATMESSAGE (call right before LLM)
# ============================================================================


def _ensure_image_bytes(image_source: Union[str, Path, Image.Image, bytes]) -> bytes:
    """Convert image to bytes."""
    if isinstance(image_source, bytes):
        return image_source
    if isinstance(image_source, (str, Path)):
        image = Image.open(image_source)
    elif isinstance(image_source, Image.Image):
        image = image_source
    else:
        raise ValueError(f"Unsupported image type: {type(image_source)}")

    buffer = BytesIO()
    image.save(buffer, format="PNG")
    return buffer.getvalue()


def to_chat_messages(messages: list[dict]) -> list[ChatMessage]:
    """
    Convert dict messages to ChatMessage list.

    Args:
        messages: List of message dicts

    Returns:
        List of ChatMessage objects
    """
    chat_messages = []

    for msg in messages:
        blocks = []
        for item in msg.get("content", []):
            if "text" in item:
                blocks.append(TextBlock(text=item["text"]))
            elif "image" in item:
                image_bytes = _ensure_image_bytes(item["image"])
                blocks.append(ImageBlock(image=image_bytes))

        chat_messages.append(ChatMessage(role=msg["role"], blocks=blocks))

    return chat_messages


# ============================================================================
# CODE EXTRACTION
# ============================================================================


def extract_code_and_thought(response_text: str) -> Tuple[Optional[str], str]:
    """
    Extract code from <python>...</python> tags and the surrounding text (thought).

    Returns:
        Tuple[Optional[code_string], thought_string]
    """
    open_tag = "<python>"
    close_tag = "</python>"

    open_idx = response_text.find(open_tag)
    if open_idx == -1:
        return None, response_text.strip()

    close_idx = response_text.rfind(close_tag)
    if close_idx == -1:
        return None, response_text.strip()

    code_content = response_text[open_idx + len(open_tag) : close_idx]
    extracted_code = code_content.strip()

    thought_before = response_text[:open_idx].strip()
    thought_after = response_text[close_idx + len(close_tag) :].strip()
    thought_text = (thought_before + " " + thought_after).strip()

    return extracted_code, thought_text


# ============================================================================
# MESSAGE UTILITIES
# ============================================================================


def has_content(message: dict) -> bool:
    for item in message.get("content", []):
        if "text" in item and item["text"].strip():
            return True
        if "image" in item and item["image"]:
            return True
    return False


def filter_empty_messages(messages: list[dict]) -> list[dict]:
    return [msg for msg in messages if has_content(msg)]


def limit_history(
    messages: list[dict], max_messages: int, preserve_first: bool = True
) -> list[dict]:
    if len(messages) <= max_messages:
        return messages

    if preserve_first and messages:
        first = messages[0]
        tail = messages[-max_messages + 1 :]
        if first not in tail:
            return [first] + tail
        return tail

    return messages[-max_messages:]

```

`droidrun/agent/utils/code_checker.py`:

```py
"""Code checker hook for safe execution."""

from typing import Callable, Optional, Tuple, Set

CodeCheckerFn = Callable[[str], Tuple[bool, str]]
ToolsCallbackFn = Callable[[Set[str]], None]

_checker_fn: Optional[CodeCheckerFn] = None
_tools_callback: Optional[ToolsCallbackFn] = None


def set_code_checker(fn: CodeCheckerFn, tools_callback: ToolsCallbackFn = None) -> None:
    """Register a checker: fn(code) -> (is_safe, error_msg). Optional tools_callback receives tool names."""
    global _checker_fn, _tools_callback
    _checker_fn = fn
    _tools_callback = tools_callback


def clear_code_checker() -> None:
    """Remove the registered checker."""
    global _checker_fn, _tools_callback
    _checker_fn = None
    _tools_callback = None


def set_tools(tool_names: Set[str]) -> None:
    """Called by executor to inform checker of available tools."""
    if _tools_callback:
        _tools_callback(tool_names)


def check_code(code: str) -> Tuple[bool, str]:
    """Run checker if registered. Returns (True, "") if none."""
    if _checker_fn is None:
        return True, ""
    return _checker_fn(code)

```

`droidrun/agent/utils/executer.py`:

```py
import asyncio
import contextlib
import contextvars
import io
import logging
import threading
import traceback
from asyncio import AbstractEventLoop
from typing import Any, Dict, Optional, Set

from pydantic import BaseModel, ConfigDict

from droidrun.config_manager.safe_execution import (
    create_safe_builtins,
    create_safe_import,
)
from droidrun.agent.utils.code_checker import check_code, set_tools

logger = logging.getLogger("droidrun")


class ExecuterState(BaseModel):
    """State object for the code executor."""

    model_config = ConfigDict(arbitrary_types_allowed=True)

    ui_state: Optional[Any] = None


class SimpleCodeExecutor:
    """
    A simple code executor that runs Python code with state persistence.

    This executor maintains a global and local state between executions,
    allowing for variables to persist across multiple code runs.

    NOTE: not safe for production use! Use with caution.
    """

    def __init__(
        self,
        locals: Dict[str, Any] = None,
        globals: Dict[str, Any] = None,
        tools=None,
        use_same_scope: bool = True,
        safe_mode: bool = False,
        allowed_modules: Optional[Set[str]] = None,
        blocked_modules: Optional[Set[str]] = None,
        allowed_builtins: Optional[Set[str]] = None,
        blocked_builtins: Optional[Set[str]] = None,
        event_loop=None,
    ):
        """
        Initialize the code executor.

        Args:
            locals: Local variables to use in the execution context
            globals: Global variables to use in the execution context
            tools: Dict or list of tools available for execution
            use_same_scope: Whether to use the same scope for globals and locals
            safe_mode: Enable restricted execution (limited builtins/imports)
            allowed_modules: Set of allowed modules (None = allow all, empty = allow none)
            blocked_modules: Set of blocked modules (takes precedence)
            allowed_builtins: Set of allowed builtins (None = allow all, empty = use defaults)
            blocked_builtins: Set of blocked builtins (takes precedence)
            event_loop: Event loop for async tool execution
        """
        if locals is None:
            locals = {}
        if globals is None:
            globals = {}
        if tools is None:
            tools = {}

        self.safe_mode = safe_mode
        self._thread_local = threading.local()
        self._event_loop = event_loop

        # Setup builtins based on safe mode
        if safe_mode:
            logger.debug("üîí Safe execution mode enabled")
            if allowed_modules is not None and not allowed_modules:
                logger.debug("   No imports allowed (allowed_modules is empty)")
            elif allowed_modules is not None:
                logger.debug(f"   Allowed modules: {allowed_modules}")
            else:
                logger.debug("   All imports allowed (except blocked)")
            logger.debug(f"   Blocked modules: {blocked_modules or 'none'}")
            logger.debug(f"   Blocked builtins: {blocked_builtins or 'none'}")

            # Create restricted builtins
            safe_builtins_dict = create_safe_builtins(
                allowed_builtins, blocked_builtins
            )

            # Add safe import function
            safe_builtins_dict["__import__"] = create_safe_import(
                allowed_modules, blocked_modules
            )

            globals["__builtins__"] = safe_builtins_dict
        else:
            # No restrictions - current behavior
            globals["__builtins__"] = __builtins__

        # Add tools to globals (always allowed, even in safe mode)
        if isinstance(tools, dict):
            logger.debug(
                f"üîß Initializing SimpleCodeExecutor with tools: {list(tools.keys())}"
            )
            wrapped_tools = self._wrap_tools_dict(tools)
            globals.update(wrapped_tools)
            set_tools(set(tools.keys()))
        elif isinstance(tools, list):
            logger.debug(f"üîß Initializing SimpleCodeExecutor with {len(tools)} tools")
            wrapped_tools = self._wrap_tools_list(tools)
            for tool in wrapped_tools:
                globals[tool.__name__] = tool
            set_tools({tool.__name__ for tool in tools})
        else:
            raise ValueError("Tools must be a dictionary or a list of functions.")

        self.globals = globals
        self.locals = locals
        self.use_same_scope = use_same_scope

        if self.use_same_scope:
            # If using the same scope, merge globals and locals
            self.globals = self.locals = {
                **self.locals,
                **{k: v for k, v in self.globals.items() if k not in self.locals},
            }

    def _wrap_tools_dict(self, tools_dict: dict) -> dict:
        """Wrap async tools in dict format."""
        wrapped = {}
        for name, func in tools_dict.items():
            wrapped[name] = self._wrap_single_tool(func)
        return wrapped

    def _wrap_tools_list(self, tools_list: list) -> list:
        """Wrap async tools in list format."""
        return [self._wrap_single_tool(tool) for tool in tools_list]

    def _wrap_single_tool(self, func):
        """Wrap a single tool function if async."""
        if not asyncio.iscoroutinefunction(func):
            return func

        def sync_wrapper(*args, **kwargs):
            def create_and_schedule():
                async def run_with_context():
                    return await func(*args, **kwargs)

                if self._event_loop is None:
                    raise RuntimeError(
                        "Event loop not set on executor. Call executor._event_loop = loop before execution."
                    )
                future = asyncio.run_coroutine_threadsafe(
                    run_with_context(), self._event_loop
                )
                return future.result()

            ctx = self.get_current_context()
            if ctx is not None:
                return ctx.run(create_and_schedule)
            else:
                return create_and_schedule()

        return sync_wrapper

    def get_current_context(self) -> Optional[contextvars.Context]:
        """Get context for current execution."""
        return getattr(self._thread_local, "context", None)

    def _execute_in_thread(
        self, code: str, ui_state: Any, ctx: contextvars.Context = None
    ) -> str:
        """Execute code in thread with context propagation."""
        # Run code through checker if one is registered
        is_safe, error_msg = check_code(code)
        if not is_safe:
            return f"Error: Code blocked by security check: {error_msg}"

        self.globals["ui_state"] = ui_state

        if ctx is not None:
            self._thread_local.context = ctx

        stdout = io.StringIO()
        stderr = io.StringIO()

        output = ""
        try:
            with contextlib.redirect_stdout(stdout), contextlib.redirect_stderr(stderr):
                exec(code, self.globals, self.locals)

            output = stdout.getvalue()
            if stderr.getvalue():
                output += "\n" + stderr.getvalue()

        except Exception as e:
            output = f"Error: {type(e).__name__}: {str(e)}\n"
            output += traceback.format_exc()
        finally:
            if ctx is not None:
                self._thread_local.context = None

        return output

    async def execute(
        self, state: ExecuterState, code: str, timeout: float = 50.0
    ) -> str:
        """Execute code in thread and return output."""
        loop = asyncio.get_running_loop()
        ui_state = state.ui_state
        ctx = contextvars.copy_context()

        if self._event_loop is None:
            self._event_loop = loop

        try:
            output = await asyncio.wait_for(
                loop.run_in_executor(
                    None, self._execute_in_thread, code, ui_state, ctx
                ),
                timeout=timeout,
            )
            return output
        except asyncio.TimeoutError:
            return f"Error: Execution timed out after {timeout} seconds"

```

`droidrun/agent/utils/inference.py`:

```py
import asyncio
import logging
from typing import Any, Optional, Type, TypeVar

from llama_index.core.base.llms.types import (
    ChatMessage,
    ChatResponse,
    CompletionResponse,
)
from llama_index.core.prompts import PromptTemplate
from pydantic import BaseModel

logger = logging.getLogger("droidrun")

T = TypeVar("T", bound=BaseModel)


async def acall_with_retries(
    llm,
    messages: list,
    retries: int = 3,
    timeout: float = 500,
    delay: float = 1.0,
    stream: bool = False,
) -> ChatResponse:
    """
    Call LLM with retries and timeout handling.

    Args:
        llm: The LLM client instance
        messages: List of messages to send
        retries: Number of retry attempts
        timeout: Timeout in seconds for each attempt
        delay: Base delay between retries (multiplied by attempt number)
        stream: If True, stream response chunks to console in real-time

    Returns:
        The LLM ChatResponse object
    """
    last_exception: Optional[Exception] = None

    for attempt in range(1, retries + 1):
        try:
            if stream:
                response = await _stream_response(llm, messages, timeout)
            else:
                response = await asyncio.wait_for(
                    llm.achat(messages=messages),
                    timeout=timeout,
                )

            # Validate response
            if (
                response is not None
                and getattr(response, "message", None) is not None
                and getattr(response.message, "content", None)
            ):
                if not stream:
                    logger.info(f"{response.message.content}")
                return response
            else:
                logger.warning(f"Attempt {attempt} returned empty content")
                last_exception = ValueError("Empty response content")

        except asyncio.TimeoutError:
            logger.warning(f"Attempt {attempt} timed out after {timeout} seconds")
            last_exception = TimeoutError("Timed out")

        except Exception as e:
            logger.warning(f"Attempt {attempt} failed with error: {e!r}")
            last_exception = e

        if attempt < retries:
            await asyncio.sleep(delay * attempt)

    if last_exception:
        raise last_exception
    raise ValueError("All attempts returned empty response content")


async def _stream_response(llm, messages: list, timeout: float) -> ChatResponse:
    """
    Stream LLM response chunks to console and return accumulated response.

    Args:
        llm: The LLM client instance
        messages: List of messages to send
        timeout: Timeout in seconds for the entire stream

    Returns:
        ChatResponse with accumulated content
    """
    content = ""
    last_chunk: Optional[ChatResponse] = None

    async def stream_chunks():
        nonlocal content, last_chunk
        async for chunk in await llm.astream_chat(messages=messages):
            delta = chunk.delta or ""
            if delta:
                logger.info(delta, extra={"stream": True})
            content += delta
            last_chunk = chunk
        logger.info("", extra={"stream_end": True})

    await asyncio.wait_for(stream_chunks(), timeout=timeout)

    # Build response matching non-streaming format
    response = ChatResponse(
        message=ChatMessage(role="assistant", content=content),
        raw=last_chunk.raw if last_chunk else None,
        additional_kwargs=last_chunk.additional_kwargs if last_chunk else {},
    )

    return response


async def acomplete_with_retries(
    llm,
    prompt: str,
    retries: int = 3,
    timeout: float = 500,
    delay: float = 1.0,
    stream: bool = False,
) -> CompletionResponse:
    """
    Call LLM completion with retries and timeout handling.

    Args:
        llm: The LLM client instance
        prompt: The prompt string to send
        retries: Number of retry attempts
        timeout: Timeout in seconds for each attempt
        delay: Base delay between retries (multiplied by attempt number)
        stream: If True, stream response chunks to console in real-time

    Returns:
        The LLM CompletionResponse object
    """
    last_exception: Optional[Exception] = None

    for attempt in range(1, retries + 1):
        try:
            if stream:
                response = await _stream_complete_response(llm, prompt, timeout)
            else:
                response = await asyncio.wait_for(
                    llm.acomplete(prompt),
                    timeout=timeout,
                )

            # Validate response
            if response is not None and getattr(response, "text", None):
                if not stream:
                    logger.info(f"{response.text}")
                return response
            else:
                logger.warning(f"Attempt {attempt} returned empty content")
                last_exception = ValueError("Empty response content")

        except asyncio.TimeoutError:
            logger.warning(f"Attempt {attempt} timed out after {timeout} seconds")
            last_exception = TimeoutError("Timed out")

        except Exception as e:
            logger.warning(f"Attempt {attempt} failed with error: {e!r}")
            last_exception = e

        if attempt < retries:
            await asyncio.sleep(delay * attempt)

    if last_exception:
        raise last_exception
    raise ValueError("All attempts returned empty response content")


async def _stream_complete_response(
    llm, prompt: str, timeout: float
) -> CompletionResponse:
    """
    Stream LLM completion response chunks to console and return accumulated response.

    Args:
        llm: The LLM client instance
        prompt: The prompt string to send
        timeout: Timeout in seconds for the entire stream

    Returns:
        CompletionResponse with accumulated content
    """
    content = ""
    last_chunk: Optional[CompletionResponse] = None

    async def stream_chunks():
        nonlocal content, last_chunk
        async for chunk in await llm.astream_complete(prompt):
            delta = chunk.delta or ""
            if delta:
                logger.info(delta, extra={"stream": True})
            content += delta
            last_chunk = chunk
        logger.info("", extra={"stream_end": True})

    await asyncio.wait_for(stream_chunks(), timeout=timeout)

    # Build response matching non-streaming format
    response = CompletionResponse(
        text=content,
        raw=last_chunk.raw if last_chunk else None,
        additional_kwargs=last_chunk.additional_kwargs if last_chunk else {},
    )

    return response


async def astructured_predict_with_retries(
    llm,
    output_cls: Type[T],
    prompt: PromptTemplate,
    retries: int = 3,
    timeout: float = 500,
    delay: float = 1.0,
    **prompt_args,
) -> T:
    """
    Call LLM structured predict with retries and timeout handling.

    Args:
        llm: The LLM client instance
        output_cls: The Pydantic model class for structured output
        prompt: PromptTemplate with {variables}
        retries: Number of retry attempts
        timeout: Timeout in seconds for each attempt
        delay: Base delay between retries (multiplied by attempt number)
        **prompt_args: Values for template variables

    Returns:
        Instance of the output_cls Pydantic model
    """
    last_exception: Optional[Exception] = None

    for attempt in range(1, retries + 1):
        try:
            result = await asyncio.wait_for(
                llm.astructured_predict(output_cls, prompt, **prompt_args),
                timeout=timeout,
            )

            # Validate response
            if result is not None:
                logger.info(f"{result}")
                return result
            else:
                logger.warning(f"Attempt {attempt} returned None")
                last_exception = ValueError("Empty response")

        except asyncio.TimeoutError:
            logger.warning(f"Attempt {attempt} timed out after {timeout} seconds")
            last_exception = TimeoutError("Timed out")

        except Exception as e:
            logger.warning(f"Attempt {attempt} failed with error: {e!r}")
            last_exception = e

        if attempt < retries:
            await asyncio.sleep(delay * attempt)

    if last_exception:
        raise last_exception
    raise ValueError("All attempts returned empty response")

```

`droidrun/agent/utils/llm_loader.py`:

```py
"""
LLM Loader - Centralized logic for loading agent-specific LLMs based on configuration.

This module determines which LLMs are needed based on the agent mode (reasoning vs direct execution)
and loads them from config profiles.
"""

import logging
from typing import Any, List, Type

from llama_index.core.llms.llm import LLM
from pydantic import BaseModel

from droidrun.agent.utils.llm_picker import load_llm, load_llms_from_profiles
from droidrun.config_manager.config_manager import DroidrunConfig

logger = logging.getLogger("droidrun")


def _get_required_profiles(
    config: DroidrunConfig, output_model: Type[BaseModel] | None = None
) -> List[str]:
    """
    Determine which LLM profiles are required based on agent configuration.

    Args:
        config: DroidRun configuration containing agent settings
        output_model: Optional Pydantic model for structured output extraction

    Returns:
        List of required profile names
    """
    if config.agent.reasoning:
        profiles = ["manager", "executor", "text_manipulator", "app_opener"]
        if config.agent.scripter.enabled:
            profiles.append("scripter")
    else:
        # Direct execution mode only needs FastAgent and helper agents
        profiles = ["fast_agent", "app_opener"]

    # Add structured_output if output_model is provided
    if output_model is not None:
        profiles.append("structured_output")

    return profiles


def validate_llm_dict(
    config: DroidrunConfig,
    llms: dict[str, LLM],
    output_model: Type[BaseModel] | None = None,
) -> List[str]:
    """
    Validate that required LLM profiles exist in the provided LLM dictionary.

    Args:
        config: DroidRun configuration containing LLM profiles
        llms: Dictionary containing LLM profiles
        output_model: Optional Pydantic model for structured output extraction

    Returns:
        List of required profile names

    Raises:
        ValueError: If any required profiles are missing from llms
    """
    required_profiles = _get_required_profiles(config, output_model)
    missing_profiles = [name for name in required_profiles if name not in llms]

    if missing_profiles:
        available_profiles = list(llms.keys())
        raise ValueError(
            f"Missing required LLM profiles: {', '.join(missing_profiles)}.\n"
            f"Available profiles: {', '.join(available_profiles)}.\n"
            f"Please add the missing profiles to your config."
        )

    return required_profiles


def validate_llm_profiles(
    config: DroidrunConfig, output_model: Type[BaseModel] | None = None
) -> List[str]:
    """
    Validate that required LLM profiles exist in the configuration.

    Args:
        config: DroidRun configuration containing LLM profiles
        output_model: Optional Pydantic model for structured output extraction

    Returns:
        List of required profile names

    Raises:
        ValueError: If any required profiles are missing from config
    """
    required_profiles = _get_required_profiles(config, output_model)
    missing_profiles = [
        name for name in required_profiles if name not in config.llm_profiles
    ]

    if missing_profiles:
        available_profiles = list(config.llm_profiles.keys())
        raise ValueError(
            f"Missing required LLM profiles in config: {', '.join(missing_profiles)}.\n"
            f"Available profiles: {', '.join(available_profiles)}.\n"
            f"Please add the missing profiles to your config."
        )

    return required_profiles


def load_agent_llms(
    config: DroidrunConfig,
    custom_provider: str | None = None,
    custom_model: str | None = None,
    temperature: float | None = None,
    output_model: Type[BaseModel] | None = None,
    **kwargs: Any,
) -> dict[str, LLM]:
    """
    Load LLMs required for DroidAgent based on reasoning mode and configuration.

    Args:
        config: DroidRun configuration containing LLM profiles
        custom_provider: Optional custom provider to use for all agents
        custom_model: Optional custom model to use for all agents
        temperature: Optional temperature override for all agents
        output_model: Optional Pydantic model for structured output extraction
        **kwargs: Additional kwargs to pass to LLM constructor (base_url, api_base, etc.)

    Returns:
        Dictionary mapping agent type to LLM instance:
        - If reasoning=True: {manager, executor, text_manipulator, app_opener, scripter, structured_output?}
        - If reasoning=False: {fast_agent, text_manipulator, app_opener, structured_output?}
        - structured_output is only included if output_model is provided

    Raises:
        ValueError: If required LLM profiles are missing from config
    """
    # Check if user wants custom LLM for all agents
    if custom_provider is not None or custom_model is not None:
        logger.debug("üîß Using custom LLM for all agents")

        # Use provided values or fall back to first profile's defaults
        if custom_provider is None:
            custom_provider = list(config.llm_profiles.values())[0].provider
        if custom_model is None:
            custom_model = list(config.llm_profiles.values())[0].model

        # Build kwargs
        llm_kwargs = {}
        if temperature is not None:
            llm_kwargs["temperature"] = temperature
        else:
            llm_kwargs["temperature"] = kwargs.get("temperature", 0.3)

        # Add any additional kwargs (base_url, api_base, etc.)
        llm_kwargs.update(kwargs)

        # Load single LLM for all agents
        custom_llm = load_llm(
            provider_name=custom_provider, model=custom_model, **llm_kwargs
        )

        # Use same LLM for all agents
        llms = {
            "manager": custom_llm,
            "executor": custom_llm,
            "fast_agent": custom_llm,
            "text_manipulator": custom_llm,
            "app_opener": custom_llm,
            "scripter": custom_llm,
        }

        # Add structured_output if output_model is provided
        if output_model is not None:
            llms["structured_output"] = custom_llm

        logger.debug(f"üß† Custom LLM ready: {custom_provider}/{custom_model}")
        return llms

    # No custom provider/model - use profiles from config
    logger.debug("üìã Loading LLMs from config profiles...")

    # Determine which LLMs are needed and validate they exist
    profile_names = validate_llm_profiles(config, output_model)

    # Apply temperature override to all profiles if specified
    overrides = {}
    if temperature is not None:
        overrides = {name: {"temperature": temperature} for name in profile_names}

    # Add any additional kwargs to overrides
    if kwargs:
        for name in profile_names:
            if name not in overrides:
                overrides[name] = {}
            overrides[name].update(kwargs)

    # Load LLMs from profiles
    llms = load_llms_from_profiles(
        config.llm_profiles, profile_names=profile_names, **overrides
    )
    logger.debug(f"üß† Loaded {len(llms)} agent-specific LLMs from profiles")

    return llms


def merge_llms_with_config(
    config: DroidrunConfig,
    llms: dict[str, LLM],
    output_model: Type[BaseModel] | None = None,
    **kwargs: Any,
) -> dict[str, LLM]:
    """
    Merge a user-provided partial llms dict with LLMs loaded from the
    configuration for any missing required profiles.
    Args:
        config: DroidRun configuration containing LLM profiles
        llms: Partial dictionary of LLM instances provided by user. Keys may be
            a subset of required agent names.
        output_model: Optional Pydantic model for structured output extraction
        **kwargs: Additional kwargs forwarded when loading missing profiles
    Returns:
        A dictionary containing the union of provided LLMs and any LLMs loaded
        from config for missing required profiles.
    Raises:
        ValueError: If required profiles are missing from both the provided
            llms dict and the config profiles.
    """
    required = _get_required_profiles(config, output_model)

    missing = [name for name in required if name not in llms]
    if not missing:
        return llms

    logger.debug(
        f"üîÅ Merging provided LLMs with config for missing profiles: {', '.join(missing)}"
    )

    # Build overrides for missing profiles (temperature and other kwargs)
    overrides: dict[str, dict] = {}
    temperature = kwargs.get("temperature", None)
    if temperature is not None:
        overrides = {name: {"temperature": temperature} for name in missing}

    if kwargs:
        for name in missing:
            if name not in overrides:
                overrides[name] = {}
            overrides[name].update(kwargs)

    loaded = load_llms_from_profiles(
        config.llm_profiles, profile_names=missing, **overrides
    )

    merged = {**llms, **loaded}
    logger.debug(f"‚úÖ Merged LLMs. Loaded: {', '.join(list(loaded.keys()))}")
    return merged

```

`droidrun/agent/utils/llm_picker.py`:

```py
import importlib
import logging
from typing import TYPE_CHECKING, Any

from llama_index.core.llms.llm import LLM

from droidrun.agent.usage import track_usage

if TYPE_CHECKING:
    from droidrun.config_manager.config_manager import LLMProfile

# Configure logging
logger = logging.getLogger("droidrun")


def load_llm(provider_name: str, model: str | None = None, **kwargs: Any) -> LLM:
    """
    Dynamically loads and initializes a LlamaIndex LLM.

    Imports `llama_index.llms.<provider_name_lower>`, finds the class named
    `provider_name` within that module, verifies it's an LLM subclass,
    and initializes it with kwargs.

    Args:
        provider_name: The case-sensitive name of the provider and the class
                       (e.g., "OpenAI", "Ollama", "HuggingFaceLLM").
        model: The model name to use (e.g., "gpt-4", "models/gemini-2.5-pro").
               If provided, will be passed as 'model' kwarg to the LLM constructor.
        **kwargs: Keyword arguments for the LLM class constructor.

    Returns:
        An initialized LLM instance.

    Raises:
        ModuleNotFoundError: If the provider's module cannot be found.
        AttributeError: If the class `provider_name` is not found in the module.
        TypeError: If the found class is not a subclass of LLM or if kwargs are invalid.
        RuntimeError: For other initialization errors.
    """
    if not provider_name:
        raise ValueError("provider_name cannot be empty.")

    # Add model to kwargs if provided as positional argument
    if model is not None:
        kwargs["model"] = model

    if provider_name == "OpenAILike":
        module_provider_part = "openai_like"
        kwargs.setdefault("is_chat_model", True)
        # OpenAILike uses api_base, not base_url - handle both for convenience
        if "base_url" in kwargs and "api_base" not in kwargs:
            kwargs["api_base"] = kwargs.pop("base_url")
    elif provider_name == "GoogleGenAI":
        module_provider_part = "google_genai"
    else:
        # Use lowercase for module path, handle hyphens for package name suggestion
        lower_provider_name = provider_name.lower()
        # Special case common variations like HuggingFaceLLM -> huggingface module
        if lower_provider_name.endswith("llm"):
            module_provider_part = lower_provider_name[:-3].replace("-", "_")
        else:
            module_provider_part = lower_provider_name.replace("-", "_")
    module_path = f"llama_index.llms.{module_provider_part}"
    install_package_name = f"llama-index-llms-{module_provider_part.replace('_', '-')}"

    try:
        logger.debug(f"Attempting to import module: {module_path}")
        llm_module = importlib.import_module(module_path)
        logger.debug(f"Successfully imported module: {module_path}")

    except ModuleNotFoundError:
        logger.error(
            f"Module '{module_path}' not found. Try: pip install {install_package_name}"
        )
        raise ModuleNotFoundError(
            f"Could not import '{module_path}'. Is '{install_package_name}' installed?"
        ) from None

    try:
        logger.debug(
            f"Attempting to get class '{provider_name}' from module {module_path}"
        )
        llm_class = getattr(llm_module, provider_name)
        logger.debug(f"Found class: {llm_class.__name__}")

        # Verify the class is a subclass of LLM
        if not isinstance(llm_class, type) or not issubclass(llm_class, LLM):
            raise TypeError(
                f"Class '{provider_name}' found in '{module_path}' is not a valid LLM subclass."
            )

        # Filter out None values from kwargs
        filtered_kwargs = {k: v for k, v in kwargs.items() if v is not None}

        # Initialize
        logger.debug(
            f"Initializing {llm_class.__name__} with kwargs: {list(filtered_kwargs.keys())}"
        )
        llm_instance = llm_class(**filtered_kwargs)
        logger.debug(f"Successfully loaded and initialized LLM: {provider_name}")
        if not llm_instance:
            raise RuntimeError(
                f"Failed to initialize LLM instance for {provider_name}."
            )
        return llm_instance

    except AttributeError:
        logger.error(f"Class '{provider_name}' not found in module '{module_path}'.")
        raise AttributeError(
            f"Could not find class '{provider_name}' in module '{module_path}'. Check spelling and capitalization."
        ) from None
    except TypeError as e:
        logger.error(f"Error initializing {provider_name}: {e}")
        raise  # Re-raise TypeError (could be from issubclass check or __init__)
    except Exception as e:
        logger.error(f"An unexpected error occurred initializing {provider_name}: {e}")
        raise e


def load_llms_from_profiles(
    profiles: dict[str, "LLMProfile"],
    profile_names: list[str] | None = None,
    **override_kwargs_per_profile,
) -> dict[str, LLM]:
    """
    Load multiple LLMs from LLMProfile objects.

    Args:
        profiles: Dict of profile_name -> LLMProfile objects
        profile_names: List of profile names to load. If None, loads all profiles
        **override_kwargs_per_profile: Dict of profile-specific overrides
            Example: manager={'temperature': 0.1}, executor={'max_tokens': 8000}

    Returns:
        Dict mapping profile names to initialized LLM instances

    Example:
        >>> config = DroidrunConfig.from_yaml("config.yaml")
        >>> llms = load_llms_from_profiles(config.llm_profiles)
        >>> manager_llm = llms['manager']

        >>> # Load specific profiles with overrides
        >>> llms = load_llms_from_profiles(
        ...     config.llm_profiles,
        ...     profile_names=['manager', 'executor'],
        ...     manager={'temperature': 0.1}
        ... )
    """
    if profile_names is None:
        profile_names = list(profiles.keys())

    llms = {}
    for profile_name in profile_names:
        logger.debug(f"Loading LLM for profile: {profile_name}")

        if profile_name not in profiles:
            raise KeyError(
                f"Profile '{profile_name}' not found. "
                f"Available profiles: {list(profiles.keys())}"
            )

        profile = profiles[profile_name]

        # Get base kwargs from profile
        kwargs = profile.to_load_llm_kwargs()

        # Apply profile-specific overrides if provided
        if profile_name in override_kwargs_per_profile:
            logger.debug(
                f"Applying overrides for {profile_name}: {override_kwargs_per_profile[profile_name]}"
            )
            kwargs.update(override_kwargs_per_profile[profile_name])

        # Load the LLM
        llms[profile_name] = load_llm(provider_name=profile.provider, **kwargs)
        logger.debug(
            f"Successfully loaded {profile_name} LLM: {profile.provider}/{profile.model}"
        )

    return llms


# --- Example Usage ---
if __name__ == "__main__":
    # Install the specific LLM integrations you want to test:
    # pip install \
    #   llama-index-llms-anthropic \
    #   llama-index-llms-deepseek \
    #   llama-index-llms-gemini \
    #   llama-index-llms-openai

    from llama_index.core.base.llms.types import ChatMessage

    providers = [
        {
            "name": "Anthropic",
            "model": "claude-3-7-sonnet-latest",
        },
        {
            "name": "DeepSeek",
            "model": "deepseek-reasoner",
        },
        {
            "name": "GoogleGenAI",
            "model": "gemini-2.5-flash",
        },
        {
            "name": "OpenAI",
            "model": "gpt-4",
        },
        {
            "name": "Ollama",
            "model": "llama3.2:1b",
            "base_url": "http://localhost:11434",
        },
    ]

    system_prompt = ChatMessage(
        role="system",
        content="You are a personal health and food coach. You are given a user's health and food preferences and you need to recommend a meal plan for them. only output the meal plan, no other text.",
    )

    user_prompt = ChatMessage(
        role="user",
        content="I am a 25 year old male. I am 5'10 and 180 pounds. I am a vegetarian. I am allergic to peanuts and tree nuts. I am allergic to shellfish. I am allergic to eggs. I am allergic to dairy. I am allergic to soy. I am allergic to wheat. I am allergic to corn. I am allergic to oats. I am allergic to rice. I am allergic to barley. I am allergic to rye. I am allergic to oats. I am allergic to rice. I am allergic to barley. I am allergic to rye.",
    )

    messages = [system_prompt, user_prompt]

    for provider in providers:
        print(f"\n{'#' * 35} Loading {provider['name']} {'#' * 35}")
        print("-" * 100)

        try:
            provider_name = provider.pop("name")
            llm = load_llm(provider_name, **provider)
            provider["name"] = provider_name
            print(f"Loaded LLM: {type(llm)}")
            print(f"Model: {llm.metadata}")
            print("-" * 100)

            tracker = track_usage(llm)
            print(f"Tracker: {type(tracker)}")
            print(f"Usage: {tracker.usage}")
            print("-" * 100)

            assert tracker.usage.requests == 0
            assert tracker.usage.request_tokens == 0
            assert tracker.usage.response_tokens == 0
            assert tracker.usage.total_tokens == 0

            res = llm.chat(messages)
            print(f"Response: {res.message.content}")
            print("-" * 100)
            print(f"Usage: {tracker.usage}")

            assert tracker.usage.requests == 1
            assert tracker.usage.request_tokens > 0
            assert tracker.usage.response_tokens > 0
            assert tracker.usage.total_tokens > tracker.usage.request_tokens
            assert tracker.usage.total_tokens > tracker.usage.response_tokens
        except Exception as e:
            print(f"Failed to load and track usage for {provider['name']}: {e}")

```

`droidrun/agent/utils/prompt_resolver.py`:

```py
"""
Prompt resolution utility for handling custom prompts passed as dict.

This module provides logic to resolve prompts from either:
1. Custom prompt strings (Jinja2 templates passed at runtime)
2. File paths (default behavior via AgentConfig)

This keeps the DroidAgent clean and separates prompt resolution logic.
"""

from typing import Dict, Optional


class PromptResolver:
    """
    Resolves prompts from custom dict or falls back to file paths.

    Usage:
        resolver = PromptResolver(custom_prompts={"fast_agent_system": "..."})
        prompt = resolver.get_prompt("fast_agent_system", fallback_path="/path/to/prompt.j2")
    """

    def __init__(self, custom_prompts: Optional[Dict[str, str]] = None):
        """
        Initialize prompt resolver.

        Args:
            custom_prompts: Dict mapping prompt keys to Jinja2 template strings.
                           Keys: "fast_agent_system", "fast_agent_user", "manager_system",
                                 "executor_system", "scripter_system"
        """
        self.custom_prompts = custom_prompts or {}

    def get_prompt(
        self, prompt_key: str, fallback_path: Optional[str] = None
    ) -> Optional[str]:
        """
        Get prompt by key, returning custom template or None if not found.

        Args:
            prompt_key: Prompt identifier (e.g., "fast_agent_system", "manager_system")
            fallback_path: Optional file path (unused, for API compatibility)

        Returns:
            Jinja2 template string if found in custom_prompts, else None
        """
        return self.custom_prompts.get(prompt_key)

    def has_custom_prompt(self, prompt_key: str) -> bool:
        """Check if a custom prompt exists for the given key."""
        return prompt_key in self.custom_prompts

    @staticmethod
    def get_valid_prompt_keys() -> list[str]:
        """
        Return list of valid prompt keys that can be customized.

        Returns:
            List of valid prompt key strings
        """
        return [
            "fast_agent_system",
            "fast_agent_user",
            "manager_system",
            "executor_system",
            "scripter_system",
        ]

```

`droidrun/agent/utils/signatures.py`:

```py
"""Action signatures and credential tool builder."""

import logging

from droidrun.agent.utils.actions import (
    click,
    click_at,
    click_area,
    long_press,
    long_press_at,
    swipe,
    system_button,
    type,
    type_secret,
    wait,
)


ATOMIC_ACTION_SIGNATURES = {
    "click": {
        "parameters": {
            "index": {"type": "number", "required": True},
        },
        "description": 'Click the point on the screen with specified index. Usage Example: {"action": "click", "index": element_index}',
        "function": click,
        "deps": {"tap", "element_index"},
    },
    "long_press": {
        "parameters": {
            "index": {"type": "number", "required": True},
        },
        "description": 'Long press on the position with specified index. Usage Example: {"action": "long_press", "index": element_index}',
        "function": long_press,
        "deps": {"swipe", "element_index"},
    },
    "click_at": {
        "parameters": {
            "x": {"type": "number", "required": True},
            "y": {"type": "number", "required": True},
        },
        "description": 'Click at screen position (x, y). Use element bounds as reference to determine where to click. Usage: {"action": "click_at", "x": 500, "y": 300}',
        "function": click_at,
        "deps": {"tap", "convert_point"},
    },
    "click_area": {
        "parameters": {
            "x1": {"type": "number", "required": True},
            "y1": {"type": "number", "required": True},
            "x2": {"type": "number", "required": True},
            "y2": {"type": "number", "required": True},
        },
        "description": 'Click center of area (x1, y1, x2, y2). Useful when you want to click a specific region. Usage: {"action": "click_area", "x1": 100, "y1": 200, "x2": 300, "y2": 400}',
        "function": click_area,
        "deps": {"tap", "convert_point"},
    },
    "long_press_at": {
        "parameters": {
            "x": {"type": "number", "required": True},
            "y": {"type": "number", "required": True},
        },
        "description": 'Long press at screen position (x, y). Use element bounds as reference. Usage: {"action": "long_press_at", "x": 500, "y": 300}',
        "function": long_press_at,
        "deps": {"swipe", "convert_point"},
    },
    "type": {
        "parameters": {
            "text": {"type": "string", "required": True},
            "index": {"type": "number", "required": True},
            "clear": {"type": "boolean", "required": False, "default": False},
        },
        "description": 'Type text into an input box or text field. Specify the element with index to focus the input field before typing. By default, text is APPENDED to existing content. Set clear=True to clear the field first (recommended for URL bars, search fields, or when replacing text). Usage Example: {"action": "type", "text": "example.com", "index": element_index, "clear": true}',
        "function": type,
        "deps": {"tap", "input_text", "element_index"},
    },
    "system_button": {
        "parameters": {
            "button": {"type": "string", "required": True},
        },
        "description": 'Press a system button, including back, home, and enter. Usage example: {"action": "system_button", "button": "Home"}',
        "function": system_button,
        "deps": {"press_key"},
    },
    "swipe": {
        "parameters": {
            "coordinate": {"type": "list", "required": True},
            "coordinate2": {"type": "list", "required": True},
            "duration": {"type": "number", "required": False, "default": 1.0},
        },
        "description": 'Scroll from the position with coordinate to the position with coordinate2. Duration is in seconds (default: 1.0). Usage Example: {"action": "swipe", "coordinate": [x1, y1], "coordinate2": [x2, y2], "duration": 1.5}',
        "function": swipe,
        "deps": {"swipe", "convert_point"},
    },
    "wait": {
        "parameters": {
            "duration": {"type": "number", "required": False, "default": 1.0},
        },
        "description": 'Wait for a specified duration in seconds. Useful for waiting for animations, page loads, or other time-based operations. Usage Example: {"action": "wait", "duration": 2.0}',
        "function": wait,
    },
}


async def build_credential_tools(credential_manager) -> dict:
    """Build credential-related custom tools if credential manager is available."""
    logger = logging.getLogger("droidrun")

    if credential_manager is None:
        return {}

    available_secrets = await credential_manager.get_keys()
    if not available_secrets:
        logger.debug("No enabled secrets found, credential tools disabled")
        return {}

    logger.debug(f"Building credential tools with {len(available_secrets)} secrets")

    return {
        "type_secret": {
            "parameters": {
                "secret_id": {"type": "string", "required": True},
                "index": {"type": "number", "required": True},
            },
            "description": 'Type a secret credential from the credential store into an input field. The agent never sees the actual secret value, only the secret_id. Usage: {"action": "type_secret", "secret_id": "MY_PASSWORD", "index": 5}',
            "function": type_secret,
            "deps": {"tap", "input_text", "element_index"},
        },
    }

```

`droidrun/agent/utils/tracing_setup.py`:

```py
"""
Tracing setup utility for DroidAgent.

This module provides a centralized way to configure tracing providers
(Phoenix, Langfuse, etc.) based on the TracingConfig.
"""

import logging
import os
from typing import Optional
from uuid import uuid4
import base64

import llama_index.core

from droidrun.config_manager.config_manager import TracingConfig

logger = logging.getLogger("droidrun")

_default_session_id: str = str(uuid4())
_session_id: str = _default_session_id
_tracing_initialized: bool = False
_tracing_provider: Optional[str] = None
_user_id: str = "anonymous"


def setup_tracing(
    tracing_config: TracingConfig, agent: Optional[object] = None
) -> None:
    global _tracing_initialized, _tracing_provider, _session_id, _user_id

    if not tracing_config.enabled:
        return

    provider = tracing_config.provider.lower()

    if tracing_config.langfuse_session_id:
        _session_id = tracing_config.langfuse_session_id
    else:
        _session_id = _default_session_id

    if tracing_config.langfuse_user_id:
        _user_id = tracing_config.langfuse_user_id
    else:
        _user_id = "anonymous"

    if _tracing_initialized:
        logger.debug(
            f"üîç Tracing already initialized with {_tracing_provider}, skipping setup"
        )
        if provider == "langfuse" and agent:
            from droidrun.telemetry.langfuse_processor import set_current_agent

            set_current_agent(agent)
        return

    if provider == "phoenix":
        _setup_phoenix_tracing()
        _tracing_initialized = True
        _tracing_provider = "phoenix"
    elif provider == "langfuse":
        _setup_langfuse_tracing(tracing_config, agent)
        _tracing_initialized = True
        _tracing_provider = "langfuse"
        logger.debug(f"üîç Langfuse tracing enabled | Session: {_session_id}")
    else:
        logger.warning(
            f"‚ö†Ô∏è  Unknown tracing provider: {provider}. "
            f"Supported providers: phoenix, langfuse"
        )


def _setup_phoenix_tracing() -> None:
    """Set up Arize Phoenix tracing."""
    try:
        from droidrun.telemetry.phoenix import arize_phoenix_callback_handler

        handler = arize_phoenix_callback_handler()
        llama_index.core.global_handler = handler
        llama_index.core.set_global_handler
        logger.debug("üîç Arize Phoenix tracing enabled globally")
    except ImportError:
        logger.warning(
            "‚ö†Ô∏è  Arize Phoenix is not installed.\n"
            "    To enable Phoenix integration, install with:\n"
            "    ‚Ä¢ If installed via tool: `uv tool install droidrun[phoenix]`"
            "    ‚Ä¢ If installed via pip: `uv pip install droidrun[phoenix]`\n"
        )


def _setup_langfuse_tracing(
    tracing_config: TracingConfig, agent: Optional[object] = None
) -> None:
    """
    Set up Langfuse tracing with custom span processor.

    Args:
        tracing_config: TracingConfig instance containing Langfuse credentials
        agent: Optional DroidAgent instance to pass to span processor
    """

    try:
        # Set environment variables
        if tracing_config.langfuse_secret_key:
            os.environ["LANGFUSE_SECRET_KEY"] = tracing_config.langfuse_secret_key
        if tracing_config.langfuse_public_key:
            os.environ["LANGFUSE_PUBLIC_KEY"] = tracing_config.langfuse_public_key
        if tracing_config.langfuse_host:
            os.environ["LANGFUSE_HOST"] = tracing_config.langfuse_host
        else:
            os.environ["LANGFUSE_HOST"] = "https://us.cloud.langfuse.com"

        # Verify credentials
        from langfuse import Langfuse

        langfuse = Langfuse()
        try:
            if not langfuse.auth_check():
                logger.error(
                    "‚ùå Langfuse authentication failed. Please check your credentials."
                )
                return
        except Exception as e:
            logger.error(
                f"Error checking Langfuse authentication: {e}\nLikely a network issue or credentials are incorrect"
            )
            return

        # STEP 1: Set up tracer provider (before any LlamaIndex imports!)
        from opentelemetry.sdk.trace import TracerProvider
        from opentelemetry import trace

        # Check if there's already a tracer provider (from Phoenix or previous setup)
        existing_provider = trace.get_tracer_provider()
        if hasattr(existing_provider, "add_span_processor"):
            # Use existing provider
            tracer_provider = existing_provider
            logger.debug("üîç Using existing TracerProvider")
        else:
            # Create new provider
            tracer_provider = TracerProvider()
            trace.set_tracer_provider(tracer_provider)
            logger.debug("üîç Created new TracerProvider")

        # STEP 2: Instrument LlamaIndex FIRST (before any LlamaIndex imports!)
        from openinference.instrumentation.llama_index import LlamaIndexInstrumentor

        instrumentor = LlamaIndexInstrumentor()
        if not instrumentor.is_instrumented_by_opentelemetry:
            instrumentor.instrument()
            logger.debug("üîç Instrumented LlamaIndex")
        else:
            logger.debug("üîç LlamaIndex already instrumented")

        # STEP 3: Patch the encoder (now that instrumentation is active)
        from pydantic import BaseModel as PydanticV2BaseModel
        from openinference.instrumentation.llama_index import _handler

        _original_encoder = _handler._encoder

        def _fixed_encoder(obj):
            """Fixed encoder that properly handles Pydantic v2 models."""
            if isinstance(obj, PydanticV2BaseModel):
                return obj.model_dump()
            return _original_encoder(obj)

        _handler._encoder = _fixed_encoder

        # STEP 4: Add our custom processor (after instrumentation is set up)
        from droidrun.telemetry.langfuse_processor import (
            LangfuseSpanProcessor,
            set_current_agent,
        )

        if agent:
            set_current_agent(agent)

        span_processor = LangfuseSpanProcessor(
            public_key=os.environ["LANGFUSE_PUBLIC_KEY"],
            secret_key=os.environ["LANGFUSE_SECRET_KEY"],
            base_url=os.environ["LANGFUSE_HOST"],
        )
        tracer_provider.add_span_processor(span_processor)

    except ImportError as e:
        logger.warning(
            "‚ö†Ô∏è  Langfuse dependencies are not installed.\n"
            "    To enable Langfuse integration, install with:\n"
            "    ‚Ä¢ If installed via tool: `uv tool install droidrun[langfuse]`\n"
            "    ‚Ä¢ If installed via pip: `uv pip install droidrun[langfuse]`\n"
            f"    Missing: {e.name if hasattr(e, 'name') else str(e)}\n"
        )


def apply_session_context() -> None:
    """Apply session context for tracing. Only active when Langfuse tracing is enabled."""
    if not _tracing_initialized or _tracing_provider != "langfuse":
        return

    from opentelemetry.context import attach, get_current, set_value
    from openinference.semconv.trace import SpanAttributes

    ctx = get_current()
    ctx = set_value(SpanAttributes.SESSION_ID, _session_id, ctx)
    ctx = set_value(SpanAttributes.USER_ID, _user_id, ctx)
    attach(ctx)


def record_langfuse_screenshot(
    screenshot: bytes,
    mime_type: str = "image/png",
    parent_span=None,
    screenshots_enabled: bool = False,
    vision_enabled: bool = False,
) -> None:
    """
    Emit a tracing span that carries a screenshot for Langfuse uploads.

    Only active when Langfuse tracing is enabled and screenshots are enabled.
    """
    if (
        not _tracing_initialized
        or _tracing_provider != "langfuse"
        or not screenshot
        or not screenshots_enabled
        or vision_enabled  # avoid duplicate uploads when vision already embeds images in LLM spans
    ):
        return

    try:
        from opentelemetry import trace
        from droidrun.telemetry.langfuse_processor import (
            get_root_span_context,
            get_last_step_span_context,
        )

        tracer = trace.get_tracer("droidrun.screenshot")
        image_b64 = base64.b64encode(screenshot).decode()

        # Attach to the provided span if valid; otherwise use current span; else root; skip if none.
        candidate = (
            parent_span
            if parent_span and parent_span.get_span_context().is_valid
            else None
        )
        if candidate is None:
            current_span = trace.get_current_span()
            if current_span and current_span.get_span_context().is_valid:
                candidate = current_span

        parent_ctx = (
            trace.set_span_in_context(candidate)
            if candidate is not None
            else (get_last_step_span_context() or get_root_span_context())
        )

        if parent_ctx is None:
            return

        span = tracer.start_span("droidrun.screenshot", context=parent_ctx)
        try:
            span.set_attribute("droidrun.screenshot.image_base64", image_b64)
            span.set_attribute("droidrun.screenshot.mime_type", mime_type)
        finally:
            span.end()
    except Exception as e:
        logger.debug(f"Failed to record Langfuse screenshot span: {e}")

```

`droidrun/agent/utils/trajectory.py`:

```py
"""
Trajectory utilities for DroidRun agents.

This module provides the Trajectory data container and utilities for
loading and analyzing saved trajectory data.
"""

import json
import logging
import os
import time
import uuid
from typing import Any, Dict, List

from llama_index.core.workflow import Event

from droidrun.agent.trajectory.writer import make_serializable

logger = logging.getLogger("droidrun")


class Trajectory:
    def __init__(self, goal: str = None, base_path: str = "trajectories"):
        """Initialize trajectory with incremental saving.

        Args:
            goal: The goal/prompt that this trajectory is trying to achieve
            base_path: Directory for saving (absolute or relative to cwd)
        """
        self.events: List[Event] = []
        self.screenshot_count: int = 0
        self.screenshot_queue: List[bytes] = []
        self.ui_states: List[Dict[str, Any]] = []
        self.macro: List[Dict[str, Any]] = []  # populated from RecordingDriver.log
        self.goal = goal or "DroidRun automation sequence"

        self.base_path = self._resolve_path(base_path)
        self.trajectory_folder = self._create_trajectory_folder()

        logger.info(f"üìÅ Trajectory folder: {self.trajectory_folder}")

    def _resolve_path(self, config_path: str):
        """Convert config path to absolute Path."""
        from pathlib import Path

        path = Path(config_path)
        return path if path.is_absolute() else Path.cwd() / path

    def _create_trajectory_folder(self):
        """Create unique trajectory folder with timestamp and UUID."""
        from pathlib import Path

        timestamp = time.strftime("%Y%m%d_%H%M%S")
        unique_id = str(uuid.uuid4())[:8]
        folder = self.base_path / f"{timestamp}_{unique_id}"
        folder.mkdir(parents=True, exist_ok=True)
        return folder

    def set_goal(self, goal: str) -> None:
        """Update the goal/description for this trajectory.

        Args:
            goal: The new goal/prompt description
        """
        self.goal = goal

    def get_trajectory(self) -> List[Dict[str, Any]]:
        # Save main trajectory events
        serializable_events = []
        for event in self.events:
            event_dict = {
                "type": event.__class__.__name__,
                **{
                    k: make_serializable(v)
                    for k, v in event.__dict__.items()
                    if not k.startswith("_")
                },
            }
            serializable_events.append(event_dict)

        return serializable_events

    @staticmethod
    def load_trajectory_folder(trajectory_folder: str) -> Dict[str, Any]:
        """
        Load trajectory data from a trajectory folder.

        Args:
            trajectory_folder: Path to the trajectory folder

        Returns:
            Dictionary containing trajectory data, macro data, and file paths
        """
        result = {
            "trajectory_data": None,
            "macro_data": None,
            "gif_path": None,
            "folder_path": trajectory_folder,
        }

        try:
            # Load main trajectory
            trajectory_json_path = os.path.join(trajectory_folder, "trajectory.json")
            if os.path.exists(trajectory_json_path):
                with open(trajectory_json_path, "r") as f:
                    result["trajectory_data"] = json.load(f)
                logger.debug(f"üìñ Loaded trajectory data from {trajectory_json_path}")

            # Load macro sequence
            macro_json_path = os.path.join(trajectory_folder, "macro.json")
            if os.path.exists(macro_json_path):
                with open(macro_json_path, "r") as f:
                    result["macro_data"] = json.load(f)
                logger.debug(f"üìñ Loaded macro data from {macro_json_path}")

            # Check for GIF
            gif_path = os.path.join(trajectory_folder, "screenshots", "trajectory.gif")
            if os.path.exists(gif_path):
                result["gif_path"] = gif_path
                logger.debug(f"üé¨ Found screenshot GIF at {gif_path}")

            return result

        except Exception as e:
            logger.error(f"‚ùå Error loading trajectory folder {trajectory_folder}: {e}")
            return result

    @staticmethod
    def load_macro_sequence(macro_file_path: str) -> Dict[str, Any]:
        """
        Load a macro sequence from a saved macro file.

        Args:
            macro_file_path: Path to the macro JSON file (can be full path or trajectory folder)

        Returns:
            Dictionary containing the macro sequence data
        """
        # Check if it's a folder path - if so, look for macro.json inside
        if os.path.isdir(macro_file_path):
            macro_file_path = os.path.join(macro_file_path, "macro.json")

        try:
            with open(macro_file_path, "r") as f:
                macro_data = json.load(f)

            logger.debug(
                f"üìñ Loaded macro sequence with {macro_data.get('total_actions', 0)} actions from {macro_file_path}"
            )
            return macro_data
        except FileNotFoundError:
            logger.error(f"‚ùå Macro file not found: {macro_file_path}")
            return {}
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå Error parsing macro file {macro_file_path}: {e}")
            return {}

    @staticmethod
    def get_macro_summary(macro_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Get a summary of a macro sequence.

        Args:
            macro_data: The macro data dictionary

        Returns:
            Dictionary with statistics about the macro
        """
        if not macro_data or "actions" not in macro_data:
            return {"error": "Invalid macro data"}

        actions = macro_data["actions"]

        # Count action types
        action_types = {}
        for action in actions:
            action_type = action.get("action_type", "unknown")
            action_types[action_type] = action_types.get(action_type, 0) + 1

        # Calculate duration if timestamps are available
        timestamps = [
            action.get("timestamp") for action in actions if action.get("timestamp")
        ]
        duration = max(timestamps) - min(timestamps) if len(timestamps) > 1 else 0

        return {
            "version": macro_data.get("version", "unknown"),
            "description": macro_data.get("description", "No description"),
            "total_actions": len(actions),
            "action_types": action_types,
            "duration_seconds": round(duration, 2) if duration > 0 else None,
            "timestamp": macro_data.get("timestamp", "unknown"),
        }

    @staticmethod
    def print_macro_summary(macro_file_path: str) -> None:
        """
        Print a summary of a macro sequence.

        Args:
            macro_file_path: Path to the macro JSON file or trajectory folder
        """
        macro_data = Trajectory.load_macro_sequence(macro_file_path)
        if not macro_data:
            print("‚ùå Could not load macro data")
            return

        summary = Trajectory.get_macro_summary(macro_data)

        print("=== Macro Summary ===")
        print(f"File: {macro_file_path}")
        print(f"Version: {summary.get('version', 'unknown')}")
        print(f"Description: {summary.get('description', 'No description')}")
        print(f"Timestamp: {summary.get('timestamp', 'unknown')}")
        print(f"Total actions: {summary.get('total_actions', 0)}")
        if summary.get("duration_seconds"):
            print(f"Duration: {summary['duration_seconds']} seconds")
        print("Action breakdown:")
        for action_type, count in summary.get("action_types", {}).items():
            print(f"  - {action_type}: {count}")
        print("=====================")

    @staticmethod
    def print_trajectory_folder_summary(trajectory_folder: str) -> None:
        """
        Print a comprehensive summary of a trajectory folder.

        Args:
            trajectory_folder: Path to the trajectory folder
        """
        folder_data = Trajectory.load_trajectory_folder(trajectory_folder)

        print("=== Trajectory Folder Summary ===")
        print(f"Folder: {trajectory_folder}")
        print(
            f"Trajectory data: {'‚úÖ Available' if folder_data['trajectory_data'] else '‚ùå Missing'}"
        )
        print(
            f"Macro data: {'‚úÖ Available' if folder_data['macro_data'] else '‚ùå Missing'}"
        )
        print(
            f"Screenshot GIF: {'‚úÖ Available' if folder_data['gif_path'] else '‚ùå Missing'}"
        )

        if folder_data["macro_data"]:
            print("\n--- Macro Summary ---")
            summary = Trajectory.get_macro_summary(folder_data["macro_data"])
            print(f"Description: {summary.get('description', 'No description')}")
            print(f"Total actions: {summary.get('total_actions', 0)}")
            if summary.get("duration_seconds"):
                print(f"Duration: {summary['duration_seconds']} seconds")
            print("Action breakdown:")
            for action_type, count in summary.get("action_types", {}).items():
                print(f"  - {action_type}: {count}")

        if folder_data["trajectory_data"]:
            print("\n--- Trajectory Summary ---")
            print(f"Total events: {len(folder_data['trajectory_data'])}")

        print("=================================")

    def print_trajectory_summary(self, trajectory_data: Dict[str, Any]) -> None:
        """
        Print a summary of a trajectory.

        Args:
            trajectory_data: The trajectory data dictionary
        """
        stats = self.get_trajectory_statistics(trajectory_data)

        print("=== Trajectory Summary ===")
        print(f"Goal: {trajectory_data.get('goal', 'Unknown')}")
        print(f"Success: {trajectory_data.get('success', False)}")
        print(f"Reason: {trajectory_data.get('reason', 'Unknown')}")
        print(f"Total steps: {stats['total_steps']}")
        print("Step breakdown:")
        for step_type, count in stats["step_types"].items():
            print(f"  - {step_type}: {count}")
        print(f"Planning steps: {stats['planning_steps']}")
        print(f"Execution steps: {stats['execution_steps']}")
        print(f"Successful executions: {stats['successful_executions']}")
        print(f"Failed executions: {stats['failed_executions']}")
        print("==========================")


def get_trajectory_statistics(
    trajectory_steps: List[Dict[str, Any]],
) -> Dict[str, Any]:
    """
    Get statistics about a trajectory.

    Args:
        trajectory_steps: The trajectory list of steps

    Returns:
        Dictionary with statistics about the trajectory
    """

    # Count different types of steps
    step_types = {}
    for step in trajectory_steps:
        step_type = step.get("type", "unknown")
        step_types[step_type] = step_types.get(step_type, 0) + 1

    # Count planning vs execution steps
    planning_steps = sum(
        count
        for step_type, count in step_types.items()
        if step_type.startswith("planner_")
    )
    execution_steps = sum(
        count
        for step_type, count in step_types.items()
        if step_type.startswith("fast_agent_")
    )

    # Count successful vs failed executions
    successful_executions = sum(
        1
        for step in trajectory_steps
        if step.get("type") == "fast_agent_execution" and step.get("success", False)
    )
    failed_executions = sum(
        1
        for step in trajectory_steps
        if step.get("type") == "fast_agent_execution" and not step.get("success", True)
    )

    # Return statistics
    return {
        "total_steps": len(trajectory_steps),
        "step_types": step_types,
        "planning_steps": planning_steps,
        "execution_steps": execution_steps,
        "successful_executions": successful_executions,
        "failed_executions": failed_executions,
    }


# Example usage:
"""
# Save a trajectory with a specific goal (automatically creates folder structure)
trajectory = Trajectory(goal="Open settings and check battery level")
# ... add events and screenshots to trajectory ...
folder_path = trajectory.save_trajectory()

# Or update the goal later
trajectory.set_goal("Navigate to Settings and find device info")

# Load entire trajectory folder
folder_data = Trajectory.load_trajectory_folder(folder_path)
trajectory_events = folder_data['trajectory_data']
macro_actions = folder_data['macro_data']
gif_path = folder_data['gif_path']

# Load just the macro from folder
macro_data = Trajectory.load_macro_sequence(folder_path)

# Print summaries
Trajectory.print_trajectory_folder_summary(folder_path)
Trajectory.print_macro_summary(folder_path)

# Example folder structure created:
# trajectories/
# ‚îî‚îÄ‚îÄ trajectory_20250108_143052/
#     ‚îú‚îÄ‚îÄ trajectory.json      # Full trajectory events
#     ‚îú‚îÄ‚îÄ macro.json          # Macro sequence with goal as description
#     ‚îî‚îÄ‚îÄ screenshots.gif     # Screenshot animation
"""

```

`droidrun/app_cards/app_card_provider.py`:

```py
"""
Abstract base class for app card providers.

Providers load app-specific instruction cards based on package names.
Supports multiple backends: local files, remote servers, or composite strategies.
"""

from abc import ABC, abstractmethod


class AppCardProvider(ABC):
    """Abstract interface for loading app-specific instruction cards."""

    @abstractmethod
    async def load_app_card(self, package_name: str, instruction: str = "") -> str:
        """
        Load app card for a given package asynchronously.

        Args:
            package_name: Android package name (e.g., "com.google.android.gm")
            instruction: User's instruction/goal (optional context for server providers)

        Returns:
            App card content as string, or empty string if not found or on error
        """
        pass

```

`droidrun/app_cards/providers/__init__.py`:

```py
"""App card provider implementations."""

from droidrun.app_cards.providers.composite_provider import CompositeAppCardProvider
from droidrun.app_cards.providers.local_provider import LocalAppCardProvider
from droidrun.app_cards.providers.server_provider import ServerAppCardProvider

__all__ = ["LocalAppCardProvider", "ServerAppCardProvider", "CompositeAppCardProvider"]

```

`droidrun/app_cards/providers/composite_provider.py`:

```py
"""
Composite app card provider.

Tries server first, falls back to local if server fails or returns empty.
"""

import logging
from typing import Dict

from droidrun.app_cards.app_card_provider import AppCardProvider
from droidrun.app_cards.providers.local_provider import LocalAppCardProvider
from droidrun.app_cards.providers.server_provider import ServerAppCardProvider

logger = logging.getLogger("droidrun")


class CompositeAppCardProvider(AppCardProvider):
    """
    Load app cards from server with local fallback.

    Strategy:
    1. Try server first
    2. If server fails or returns empty, try local
    3. Return first non-empty result, or empty if both fail
    """

    def __init__(
        self,
        server_url: str,
        app_cards_dir: str = "config/app_cards",
        server_timeout: float = 2.0,
        server_max_retries: int = 2,
    ):
        """
        Initialize composite provider.

        Args:
            server_url: Base URL of the app card server
            app_cards_dir: Directory containing local app_cards.json
            server_timeout: Server request timeout in seconds
            server_max_retries: Number of server retry attempts
        """
        self.server_provider = ServerAppCardProvider(
            server_url=server_url,
            timeout=server_timeout,
            max_retries=server_max_retries,
        )
        self.local_provider = LocalAppCardProvider(app_cards_dir=app_cards_dir)

    async def load_app_card(self, package_name: str, instruction: str = "") -> str:
        """
        Load app card with server-first, local-fallback strategy.

        Args:
            package_name: Android package name (e.g., "com.google.android.gm")
            instruction: User instruction/goal

        Returns:
            App card content from server or local, or empty string if both fail
        """
        if not package_name:
            return ""

        # Try server first
        server_result = await self.server_provider.load_app_card(
            package_name, instruction
        )

        if server_result:
            return server_result

        # Server failed or returned empty, try local
        logger.debug(f"Composite provider: falling back to local for {package_name}")
        local_result = await self.local_provider.load_app_card(
            package_name, instruction
        )

        if local_result:
            logger.debug(f"Composite provider: using local fallback for {package_name}")
        else:
            logger.debug(f"Composite provider: no app card found for {package_name}")

        return local_result

    def clear_cache(self) -> None:
        """Clear caches in both providers."""
        self.server_provider.clear_cache()
        self.local_provider.clear_cache()
        logger.debug("Composite app card cache cleared")

    def get_cache_stats(self) -> Dict[str, any]:
        """
        Get cache statistics from both providers.

        Returns:
            Dict with cache stats from server and local providers
        """
        return {
            "server": self.server_provider.get_cache_stats(),
            "local": self.local_provider.get_cache_stats(),
        }

```

`droidrun/app_cards/providers/local_provider.py`:

```py
"""
Local file-based app card provider.

Loads app cards from local filesystem using app_cards.json mapping.
"""

import json
import logging
from typing import Dict

from droidrun.app_cards.app_card_provider import AppCardProvider
from droidrun.config_manager.path_resolver import PathResolver

logger = logging.getLogger("droidrun")


class LocalAppCardProvider(AppCardProvider):
    """Load app cards from local filesystem with in-memory caching."""

    def __init__(self, app_cards_dir: str = "config/app_cards"):
        """
        Initialize local provider.

        Args:
            app_cards_dir: Directory containing app_cards.json and markdown files
        """
        # Resolve app_cards.json path once
        mapping_path = PathResolver.resolve(f"{app_cards_dir}/app_cards.json")
        self.app_cards_dir = mapping_path.parent

        # Load mapping immediately
        try:
            if mapping_path.exists():
                with open(mapping_path, "r", encoding="utf-8") as f:
                    self.mapping = json.load(f)
                logger.debug(f"Loaded app_cards.json with {len(self.mapping)} entries")
            else:
                logger.warning(f"app_cards.json not found at {mapping_path}")
                self.mapping = {}
        except Exception as e:
            logger.warning(f"Failed to load app_cards.json: {e}")
            self.mapping = {}

        # Content cache: (package_name, instruction) -> content
        self._content_cache: Dict[tuple[str, str], str] = {}

    async def load_app_card(self, package_name: str, instruction: str = "") -> str:
        """
        Load app card for a package name from local files.

        Args:
            package_name: Android package name (e.g., "com.google.android.gm")
            instruction: User instruction (for cache key consistency, not used in loading)

        Returns:
            App card content or empty string if not found
        """
        if not package_name:
            return ""

        # Check content cache first
        cache_key = (package_name, instruction)
        if cache_key in self._content_cache:
            logger.debug(f"App card cache hit: {package_name}")
            return self._content_cache[cache_key]

        # Check if package exists in mapping
        if package_name not in self.mapping:
            self._content_cache[cache_key] = ""
            return ""

        # Get app card file path (relative to app_cards_dir)
        filename = self.mapping[package_name]
        app_card_path = self.app_cards_dir / filename

        # Read file
        try:
            if not app_card_path.exists():
                self._content_cache[cache_key] = ""
                logger.debug(f"App card not found: {app_card_path}")
                return ""

            # Async file read
            import asyncio

            loop = asyncio.get_running_loop()
            content = await loop.run_in_executor(None, app_card_path.read_text, "utf-8")

            # Cache and return
            self._content_cache[cache_key] = content
            logger.debug(f"Loaded app card for {package_name} from {app_card_path}")
            return content

        except Exception as e:
            logger.warning(f"Failed to load app card for {package_name}: {e}")
            self._content_cache[cache_key] = ""
            return ""

    def clear_cache(self) -> None:
        """Clear content cache (useful for testing or runtime reloading)."""
        self._content_cache.clear()
        logger.debug("Local app card cache cleared")

    def get_cache_stats(self) -> Dict[str, int]:
        """
        Get cache statistics.

        Returns:
            Dict with cache stats (useful for debugging)
        """
        return {
            "content_entries": len(self._content_cache),
            "mapping_entries": len(self.mapping),
        }

```

`droidrun/app_cards/providers/server_provider.py`:

```py
"""
Server-based app card provider.

Fetches app cards from a remote HTTP server.
"""

import logging
from typing import Dict

import httpx

from droidrun.app_cards.app_card_provider import AppCardProvider

logger = logging.getLogger("droidrun")


class ServerAppCardProvider(AppCardProvider):
    """Load app cards from remote server with in-memory caching."""

    def __init__(self, server_url: str, timeout: float = 2.0, max_retries: int = 2):
        """
        Initialize server provider.

        Args:
            server_url: Base URL of the app card server (e.g., "https://api.example.com")
            timeout: Request timeout in seconds
            max_retries: Number of retry attempts on failure
        """
        self.server_url = server_url.rstrip("/")
        self.timeout = timeout
        self.max_retries = max_retries
        self._content_cache: Dict[tuple[str, str], str] = {}

    async def load_app_card(self, package_name: str, instruction: str = "") -> str:
        """
        Load app card from remote server.

        Args:
            package_name: Android package name (e.g., "com.google.android.gm")
            instruction: User instruction/goal (sent to server for context)

        Returns:
            App card content or empty string if not found or on error
        """
        if not package_name:
            return ""

        # Check content cache first (key: package_name, instruction)
        cache_key = (package_name, instruction)
        if cache_key in self._content_cache:
            return self._content_cache[cache_key]

        # Make HTTP request with retries
        endpoint = f"{self.server_url}/app-cards"
        payload = {"package_name": package_name, "instruction": instruction}

        for attempt in range(1, self.max_retries + 1):
            try:
                async with httpx.AsyncClient(timeout=self.timeout) as client:
                    response = await client.post(endpoint, json=payload)

                    if response.status_code == 200:
                        data = response.json()
                        app_card = data.get("app_card", "")

                        # Cache the result (even if empty)
                        self._content_cache[cache_key] = app_card
                        return app_card

                    elif response.status_code == 404:
                        # Not found is expected, cache empty result
                        self._content_cache[cache_key] = ""
                        return ""

                    else:
                        logger.warning(
                            f"Server returned status {response.status_code} for {package_name} "
                            f"(attempt {attempt}/{self.max_retries})"
                        )

            except httpx.TimeoutException:
                logger.warning(
                    f"Server request timeout for {package_name} "
                    f"(attempt {attempt}/{self.max_retries})"
                )

            except httpx.RequestError as e:
                logger.warning(
                    f"Server request failed for {package_name}: {e} "
                    f"(attempt {attempt}/{self.max_retries})"
                )

            except Exception as e:
                logger.warning(
                    f"Unexpected error loading app card from server: {e} "
                    f"(attempt {attempt}/{self.max_retries})"
                )

        # All retries failed, cache empty result
        logger.warning(
            f"Failed to load app card from server after {self.max_retries} attempts"
        )
        self._content_cache[cache_key] = ""
        return ""

    def clear_cache(self) -> None:
        """Clear content cache."""
        self._content_cache.clear()
        logger.debug("Server app card cache cleared")

    def get_cache_stats(self) -> Dict[str, int]:
        """
        Get cache statistics.

        Returns:
            Dict with cache stats (useful for debugging)
        """
        return {
            "content_entries": len(self._content_cache),
        }

```

`droidrun/cli/__init__.py`:

```py
"""
DroidRun CLI Module.

This module provides command-line interfaces for interacting with Android devices.
"""

from droidrun.cli.main import cli

__all__ = ["cli"]

```

`droidrun/cli/doctor.py`:

```py
"""DroidRun Doctor - System health checks and diagnostics."""

import asyncio
import json
import re
import shutil
from dataclasses import dataclass
from enum import Enum
from typing import Any

import requests
from async_adbutils import AdbDevice, adb
from rich.console import Console

from droidrun import __version__
from droidrun.portal import (
    PORTAL_PACKAGE_NAME,
    GITHUB_API_HOSTS,
    check_portal_accessibility,
    enable_portal_accessibility,
    get_compatible_portal_version,
)

console = Console()

PORTAL_REMOTE_PORT = 8080


class Status(Enum):
    PASS = "pass"
    WARN = "warn"
    FAIL = "fail"


@dataclass
class CheckResult:
    name: str
    status: Status
    message: str
    detail: str = ""


def _status_icon(status: Status) -> str:
    if status == Status.PASS:
        return "[green]‚úì[/]"
    elif status == Status.WARN:
        return "[yellow]‚ö†[/]"
    else:
        return "[red]‚úó[/]"


def _print_result(result: CheckResult, debug: bool = False) -> None:
    icon = _status_icon(result.status)
    console.print(f"  {result.name:<22} {result.message:<42} {icon}")
    if debug and result.detail:
        console.print(f"  {'':22} [dim]{result.detail}[/]")


def _parse_version_tuple(version_str: str) -> tuple:
    """Parse a version string like '0.4.23' or 'v0.4.23' into a comparable tuple."""
    cleaned = version_str.lstrip("v").strip()
    parts = []
    for p in cleaned.split("."):
        try:
            parts.append(int(p))
        except ValueError:
            parts.append(0)
    return tuple(parts)


# ‚îÄ‚îÄ Check Functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


async def check_sdk_version(debug: bool) -> CheckResult:
    """Check DroidRun SDK version against latest GitHub release."""
    current = __version__
    latest = None

    for host in GITHUB_API_HOSTS:
        try:
            url = f"{host}/repos/droidrun/droidrun/releases/latest"
            resp = requests.get(url, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                # Handle both GitHub API formats
                if "release" in data:
                    tag = data["release"].get(
                        "tag", data["release"].get("tag_name", "")
                    )
                else:
                    tag = data.get("tag_name", "")
                latest = tag.lstrip("v")
                break
        except Exception:
            continue

    if latest is None:
        return CheckResult(
            "SDK Version",
            Status.WARN,
            f"{current} (could not check latest)",
            detail="GitHub API unreachable",
        )

    current_t = _parse_version_tuple(current)
    latest_t = _parse_version_tuple(latest)

    if current_t < latest_t:
        return CheckResult(
            "SDK Version",
            Status.WARN,
            f"{current} (latest: {latest})",
            detail="pip install --upgrade droidrun",
        )
    else:
        return CheckResult("SDK Version", Status.PASS, f"{current} (up to date)")


async def check_config(debug: bool) -> tuple[CheckResult, Any]:
    """Check config file exists and loads."""
    from droidrun.config_manager import ConfigLoader
    from droidrun.config_manager.loader import OutdatedConfigError

    config_path = ConfigLoader.get_user_config_path()

    if not config_path.exists():
        # Will be created on first load
        try:
            config = ConfigLoader.load()
            return (
                CheckResult(
                    "Config",
                    Status.PASS,
                    f"{config_path} (created)",
                ),
                config,
            )
        except Exception as e:
            return (
                CheckResult(
                    "Config",
                    Status.FAIL,
                    "failed to create default config",
                    detail=str(e),
                ),
                None,
            )

    try:
        config = ConfigLoader.load()
        return CheckResult("Config", Status.PASS, str(config_path)), config
    except OutdatedConfigError:
        return (
            CheckResult(
                "Config",
                Status.FAIL,
                f"{config_path} (outdated, missing _version)",
                detail="See: droidrun config_example.yaml",
            ),
            None,
        )
    except Exception as e:
        return (
            CheckResult(
                "Config",
                Status.FAIL,
                f"failed to load: {e}",
                detail=str(config_path),
            ),
            None,
        )


async def check_adb(debug: bool) -> CheckResult:
    """Check ADB is available and list devices."""
    adb_path = shutil.which("adb")
    if not adb_path:
        return CheckResult(
            "ADB",
            Status.FAIL,
            "adb not found in PATH",
            detail="Install Android SDK Platform Tools",
        )

    try:
        devices = await adb.list()
        count = len(devices)
        return CheckResult(
            "ADB",
            Status.PASS,
            f"found, {count} device(s)",
            detail=adb_path,
        )
    except Exception as e:
        return CheckResult(
            "ADB",
            Status.FAIL,
            f"adb found but server error: {e}",
            detail=adb_path,
        )


async def check_device(
    serial: str | None, debug: bool
) -> tuple[CheckResult, AdbDevice | None]:
    """Check device connection."""
    try:
        device = await adb.device(serial)
        state = await device.get_state()
        if state == "device":
            return (
                CheckResult(
                    "Device",
                    Status.PASS,
                    f"{device.serial} (online)",
                ),
                device,
            )
        else:
            return (
                CheckResult(
                    "Device",
                    Status.FAIL,
                    f"{device.serial} (state: {state})",
                ),
                None,
            )
    except Exception as e:
        msg = str(e)
        if "no devices" in msg.lower() or "not found" in msg.lower():
            return CheckResult("Device", Status.FAIL, "no device connected"), None
        return CheckResult("Device", Status.FAIL, str(e)), None


async def check_portal_installed(
    device: AdbDevice, debug: bool
) -> tuple[CheckResult, bool]:
    """Check if Portal APK is installed. Returns (result, is_installed)."""
    try:
        packages = await device.list_packages()
        if PORTAL_PACKAGE_NAME in packages:
            return CheckResult("Portal", Status.PASS, "installed"), True
        else:
            return CheckResult("Portal", Status.FAIL, "not installed"), False
    except Exception as e:
        return CheckResult("Portal", Status.FAIL, f"error: {e}"), False


def _get_latest_portal_version() -> str | None:
    """Fetch latest portal release version from GitHub."""
    for host in GITHUB_API_HOSTS:
        try:
            url = f"{host}/repos/droidrun/droidrun-portal/releases/latest"
            resp = requests.get(url, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                if "release" in data:
                    tag = data["release"].get(
                        "tag", data["release"].get("tag_name", "")
                    )
                else:
                    tag = data.get("tag_name", "")
                return tag.lstrip("v").strip() if tag else None
        except Exception:
            continue
    return None


async def check_portal_version(
    device: AdbDevice, debug: bool
) -> tuple[CheckResult, str | None, str | None, str | None]:
    """Check portal version and compatibility. Returns (result, installed_ver, expected_ver, download_base)."""
    # Get installed version
    installed = None
    try:
        output = await device.shell(
            "content query --uri content://com.droidrun.portal/version"
        )
        if "result=" in output:
            json_str = output.split("result=", 1)[1].strip()
            data = json.loads(json_str)
            if data.get("status") == "success":
                installed = data.get("result") or data.get("data")
    except Exception:
        pass

    if not installed:
        return (
            CheckResult(
                "Portal Version",
                Status.WARN,
                "could not read version",
            ),
            None,
            None,
            None,
        )

    # Get latest portal version from GitHub
    latest_portal = _get_latest_portal_version()

    # Get expected (compatible) version from version mapping
    expected, download_base, mapping_fetched = get_compatible_portal_version(
        __version__, debug
    )

    installed_t = _parse_version_tuple(installed)

    # Build message parts
    parts = [f"v{installed}"]

    if expected:
        expected_t = _parse_version_tuple(expected)
        if installed_t != expected_t:
            parts.append(f"expected {expected}")

    if latest_portal:
        latest_t = _parse_version_tuple(latest_portal)
        if installed_t < latest_t:
            parts.append(f"latest: {latest_portal}")

    msg = " ‚Üí ".join(parts[:1]) + (
        " (" + ", ".join(parts[1:]) + ")" if len(parts) > 1 else ""
    )

    # Determine status
    if expected:
        expected_t = _parse_version_tuple(expected)
        if installed_t != expected_t:
            return (
                CheckResult("Portal Version", Status.WARN, msg),
                installed,
                expected,
                download_base,
            )

    if latest_portal:
        latest_t = _parse_version_tuple(latest_portal)
        if installed_t < latest_t:
            # Outdated but no specific compatible version required ‚Äî warn
            return (
                CheckResult(
                    "Portal Version",
                    Status.WARN,
                    msg,
                    detail=f"pip install --upgrade droidrun, then droidrun setup",
                ),
                installed,
                expected,
                download_base,
            )

    if not mapping_fetched and not latest_portal:
        return (
            CheckResult(
                "Portal Version",
                Status.WARN,
                f"v{installed} (could not check latest)",
            ),
            installed,
            None,
            None,
        )

    return (
        CheckResult(
            "Portal Version",
            Status.PASS,
            f"v{installed} (up to date)",
        ),
        installed,
        expected,
        download_base,
    )


async def check_accessibility(
    device: AdbDevice, debug: bool
) -> tuple[CheckResult, bool]:
    """Check accessibility service. Returns (result, is_enabled)."""
    try:
        enabled = await check_portal_accessibility(device, debug=debug)
        if enabled:
            return CheckResult("Accessibility", Status.PASS, "enabled"), True
        else:
            return CheckResult("Accessibility", Status.FAIL, "not enabled"), False
    except Exception as e:
        return CheckResult("Accessibility", Status.FAIL, str(e)), False


async def check_content_provider(device: AdbDevice, debug: bool) -> CheckResult:
    """Check content provider connectivity."""
    try:
        state = await device.shell(
            "content query --uri content://com.droidrun.portal/state"
        )
        if "Row: 0 result=" in state:
            return CheckResult("Content Provider", Status.PASS, "reachable")
        else:
            return CheckResult(
                "Content Provider",
                Status.FAIL,
                "invalid response",
                detail=state[:100] if debug else "",
            )
    except Exception as e:
        return CheckResult("Content Provider", Status.FAIL, f"unreachable: {e}")


async def check_tcp(device: AdbDevice, debug: bool) -> CheckResult:
    """Check TCP mode with explicit steps: enable server, forward port, ping."""
    import httpx

    steps = []

    # Step 1: Enable socket server via content provider
    try:
        await device.shell(
            "content insert --uri content://com.droidrun.portal/toggle_socket_server --bind enabled:b:true"
        )
        steps.append("server enabled")
    except Exception as e:
        return CheckResult(
            "TCP Mode",
            Status.FAIL,
            "failed to enable socket server",
            detail=str(e),
        )

    # Wait for server startup
    await asyncio.sleep(1)

    # Step 2: Set up port forward
    local_port = None
    try:
        # Check for existing forward first
        forwards = []
        async for fwd in device.forward_list():
            forwards.append(fwd)
        for fwd in forwards:
            if (
                fwd.serial == device.serial
                and fwd.remote == f"tcp:{PORTAL_REMOTE_PORT}"
            ):
                match = re.search(r"tcp:(\d+)", fwd.local)
                if match:
                    local_port = int(match.group(1))
                    steps.append(f"reusing forward :{local_port}")
                    break

        if local_port is None:
            local_port = await device.forward_port(PORTAL_REMOTE_PORT)
            steps.append(f"forwarded :{local_port}")
    except Exception as e:
        return CheckResult(
            "TCP Mode",
            Status.FAIL,
            "port forward failed",
            detail=str(e),
        )

    # Step 3: Test connection
    try:
        async with httpx.AsyncClient() as client:
            resp = await client.get(f"http://localhost:{local_port}/ping", timeout=5)
            if resp.status_code == 200:
                steps.append("ping ok")
                return CheckResult(
                    "TCP Mode",
                    Status.PASS,
                    f"localhost:{local_port}",
                    detail=", ".join(steps),
                )
            else:
                return CheckResult(
                    "TCP Mode",
                    Status.FAIL,
                    f"ping returned {resp.status_code}",
                    detail=", ".join(steps),
                )
    except Exception as e:
        return CheckResult(
            "TCP Mode",
            Status.FAIL,
            f"ping failed: {e}",
            detail=", ".join(steps),
        )


async def check_portal_state(
    device: AdbDevice, use_tcp: bool, debug: bool
) -> tuple[CheckResult, Any]:
    """Fetch full state and verify a11y_tree, phone_state, device_context are present."""
    from droidrun.tools.android.portal_client import PortalClient

    try:
        portal = PortalClient(device, prefer_tcp=use_tcp)
        await portal.connect()
        method = "tcp" if portal.tcp_available else "content_provider"

        state = await portal.get_state()

        if isinstance(state, dict) and state.get("error"):
            return (
                CheckResult(
                    "Portal State",
                    Status.FAIL,
                    f"error: {state.get('message', state.get('error'))}",
                ),
                portal,
            )

        required = ("a11y_tree", "phone_state", "device_context")
        present = [k for k in required if k in state]
        missing = [k for k in required if k not in state]

        if missing:
            return (
                CheckResult(
                    "Portal State",
                    Status.FAIL,
                    f"missing: {', '.join(missing)}",
                    detail=f"present: {', '.join(present)} (via {method})",
                ),
                portal,
            )
        else:
            return (
                CheckResult(
                    "Portal State",
                    Status.PASS,
                    f"a11y_tree, phone_state, device_context (via {method})",
                ),
                portal,
            )
    except Exception as e:
        return CheckResult("Portal State", Status.FAIL, str(e)), None


async def check_screenshot(portal: Any, debug: bool) -> CheckResult:
    """Take a test screenshot to verify the full capture pipeline."""
    try:
        data = await portal.take_screenshot(hide_overlay=True)
        if data and len(data) > 0:
            size_kb = len(data) / 1024
            return CheckResult(
                "Screenshot",
                Status.PASS,
                f"ok ({size_kb:.0f} KB)",
            )
        else:
            return CheckResult(
                "Screenshot",
                Status.FAIL,
                "empty response",
            )
    except Exception as e:
        return CheckResult(
            "Screenshot",
            Status.FAIL,
            f"capture failed: {e}",
        )


async def check_keyboard(device: AdbDevice, debug: bool) -> CheckResult:
    """Check if DroidRun keyboard IME is available."""
    try:
        output = await device.shell("ime list -s")
        ime_id = "com.droidrun.portal/.input.DroidrunKeyboardIME"
        if ime_id in output:
            return CheckResult("Keyboard", Status.PASS, "available")
        else:
            return CheckResult(
                "Keyboard",
                Status.WARN,
                "not listed",
                detail="Will be set up automatically when needed",
            )
    except Exception as e:
        return CheckResult("Keyboard", Status.WARN, f"could not check: {e}")


# ‚îÄ‚îÄ Auto-fix Functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


async def fix_enable_accessibility(device: AdbDevice, debug: bool) -> bool:
    """Enable accessibility service. Returns True on success."""
    console.print("  [blue]‚Üí Enabling accessibility service...[/]")
    try:
        await enable_portal_accessibility(device)
        # Verify
        enabled = await check_portal_accessibility(device, debug=debug)
        if enabled:
            console.print("  [green]  accessibility enabled[/]")
            return True
        else:
            console.print(
                "  [yellow]  auto-enable may have failed, opening settings...[/]"
            )
            await device.shell("am start -a android.settings.ACCESSIBILITY_SETTINGS")
            console.print(
                f"  [yellow]  please enable {PORTAL_PACKAGE_NAME} manually[/]"
            )
            return False
    except Exception as e:
        console.print(f"  [red]  failed: {e}[/]")
        try:
            await device.shell("am start -a android.settings.ACCESSIBILITY_SETTINGS")
            console.print(
                f"  [yellow]  please enable {PORTAL_PACKAGE_NAME} manually[/]"
            )
        except Exception:
            pass
        return False


# ‚îÄ‚îÄ Orchestrator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


async def run_doctor(
    device_serial: str | None = None,
    debug: bool = False,
) -> None:
    """Run all doctor checks and auto-fix where possible."""
    debug = debug or False

    console.print("\n[bold]DroidRun Doctor[/]\n")

    results: list[CheckResult] = []

    # 1. SDK Version
    r = await check_sdk_version(debug)
    _print_result(r, debug)
    results.append(r)

    # 2. Config
    r_config, config = await check_config(debug)
    _print_result(r_config, debug)
    results.append(r_config)

    # Load serial from config if not provided
    if device_serial is None and config:
        device_serial = getattr(getattr(config, "device", None), "serial", None)

    # 3. ADB
    r = await check_adb(debug)
    _print_result(r, debug)
    results.append(r)
    if r.status == Status.FAIL:
        _print_summary(results)
        return

    # 5. Device
    r_device, device = await check_device(device_serial, debug)
    _print_result(r_device, debug)
    results.append(r_device)
    if device is None:
        console.print("\n  [dim]Skipping device-dependent checks (no device)[/]")
        _print_summary(results)
        return

    # 6. Portal Installed
    r_portal, is_installed = await check_portal_installed(device, debug)
    _print_result(r_portal, debug)
    if not is_installed:
        # Auto-fix: run setup
        from droidrun.cli.main import _setup_portal

        await _setup_portal(path=None, device=device.serial, debug=debug)
        # Re-check
        r_portal, is_installed = await check_portal_installed(device, debug)
        if not is_installed:
            results.append(r_portal)
            _print_summary(results)
            return
    results.append(r_portal)

    # 7. Portal Version
    r_version, installed_ver, _, _ = await check_portal_version(device, debug)
    _print_result(r_version, debug)
    if r_version.status == Status.WARN and installed_ver:
        # Auto-fix: run setup to install compatible version
        console.print("  [blue]‚Üí Updating portal...[/]")
        from droidrun.cli.main import _setup_portal

        await _setup_portal(path=None, device=device.serial, debug=debug)
        # Wait for portal service to initialize after install
        console.print("  [dim]  waiting for portal to start...[/]")
        await asyncio.sleep(3)
        # Re-check
        r_version, _, _, _ = await check_portal_version(device, debug)
        if r_version.status == Status.PASS:
            console.print("  [green]  portal updated[/]")
        else:
            console.print(
                "  [yellow]  update may not have resolved the version mismatch[/]"
            )
    results.append(r_version)

    # 8. Accessibility
    r_a11y, a11y_enabled = await check_accessibility(device, debug)
    if not a11y_enabled:
        _print_result(r_a11y, debug)
        # Auto-fix: enable accessibility
        success = await fix_enable_accessibility(device, debug)
        if success:
            r_a11y = CheckResult("Accessibility", Status.PASS, "enabled (auto-fixed)")
            _print_result(r_a11y, debug)
    else:
        _print_result(r_a11y, debug)
    results.append(r_a11y)

    # 9. Content Provider ‚Äî connectivity, state, screenshot
    r = await check_content_provider(device, debug)
    _print_result(r, debug)
    results.append(r)

    r_cp_state, cp_portal = await check_portal_state(device, False, debug)
    r_cp_state.name = "State (content)"
    _print_result(r_cp_state, debug)
    results.append(r_cp_state)

    if cp_portal and r_cp_state.status == Status.PASS:
        r = await check_screenshot(cp_portal, debug)
        r.name = "Screenshot (content)"
        _print_result(r, debug)
        results.append(r)

    # 10. TCP ‚Äî connectivity, state, screenshot
    r = await check_tcp(device, debug)
    _print_result(r, debug)
    results.append(r)

    if r.status == Status.PASS:
        r_tcp_state, tcp_portal = await check_portal_state(device, True, debug)
        r_tcp_state.name = "State (tcp)"
        _print_result(r_tcp_state, debug)
        results.append(r_tcp_state)

        if tcp_portal and r_tcp_state.status == Status.PASS:
            r = await check_screenshot(tcp_portal, debug)
            r.name = "Screenshot (tcp)"
            _print_result(r, debug)
            results.append(r)

    # 12. Keyboard
    r = await check_keyboard(device, debug)
    _print_result(r, debug)
    results.append(r)

    _print_summary(results)


def _print_summary(results: list[CheckResult]) -> None:
    """Print final summary."""
    fails = [r for r in results if r.status == Status.FAIL]
    warns = [r for r in results if r.status == Status.WARN]

    console.print()
    if not fails and not warns:
        console.print("  [bold green]All checks passed.[/]")
    else:
        if fails:
            console.print(f"  [bold red]{len(fails)} issue(s):[/]")
            for r in fails:
                console.print(f"    [red]‚úó {r.name}: {r.message}[/]")
                if r.detail:
                    console.print(f"      [dim]{r.detail}[/]")
        if warns:
            console.print(f"  [bold yellow]{len(warns)} warning(s):[/]")
            for r in warns:
                console.print(f"    [yellow]‚ö† {r.name}: {r.message}[/]")
                if r.detail:
                    console.print(f"      [dim]{r.detail}[/]")
    console.print()

```

`droidrun/cli/event_handler.py`:

```py
"""
Shared event handler for CLI, TUI and SDK.

Translates workflow events into ``logging`` calls with ``extra`` params
(color, step_increment, etc.).  The actual rendering is handled by
whichever ``logging.Handler`` is attached (CLILogHandler, TUILogHandler, ‚Ä¶).
"""

import logging

from droidrun.agent.codeact.events import (
    CodeActCodeEvent,
    CodeActEndEvent,
    CodeActInputEvent,
    CodeActOutputEvent,
    CodeActResponseEvent,
    FastAgentEndEvent,
    FastAgentInputEvent,
    FastAgentOutputEvent,
    FastAgentResponseEvent,
    FastAgentToolCallEvent,
)
from droidrun.agent.common.events import (
    RecordUIStateEvent,
    ScreenshotEvent,
)
from droidrun.agent.droid.events import (
    ExecutorResultEvent,
    FastAgentExecuteEvent,
    FastAgentResultEvent,
    FinalizeEvent,
)
from droidrun.agent.executor.events import (
    ExecutorActionEvent,
    ExecutorActionResultEvent,
)
from droidrun.agent.manager.events import (
    ManagerContextEvent,
    ManagerPlanDetailsEvent,
    ManagerResponseEvent,
)
from droidrun.agent.scripter.events import ScripterThinkingEvent

logger = logging.getLogger("droidrun")


class EventHandler:
    """Translates workflow events into logger calls.

    No UI state tracking ‚Äî purely converts events into log records with
    ``extra`` params so that any attached handler can render them.
    """

    def handle(self, event) -> None:  # noqa: C901
        # ‚îÄ‚îÄ Screenshots / UI state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if isinstance(event, ScreenshotEvent):
            logger.debug("üì∏ Taking screenshot...")

        elif isinstance(event, RecordUIStateEvent):
            logger.debug("‚úèÔ∏è Recording UI state")

        # ‚îÄ‚îÄ Manager events (reasoning mode) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        elif isinstance(event, ManagerContextEvent):
            logger.debug("üß† Manager preparing context...")

        elif isinstance(event, ManagerResponseEvent):
            logger.debug("üì• Manager received LLM response")

        elif isinstance(event, ManagerPlanDetailsEvent):
            if event.thought:
                preview = (
                    event.thought[:120] + "..."
                    if len(event.thought) > 120
                    else event.thought
                )
                logger.debug(f"üí≠ Thought: {preview}", extra={"color": "cyan"})
            if event.subgoal:
                preview = (
                    event.subgoal[:150] + "..."
                    if len(event.subgoal) > 150
                    else event.subgoal
                )
                logger.debug(f"üìã Next step: {preview}", extra={"color": "yellow"})
            if event.answer:
                preview = (
                    event.answer[:200] + "..."
                    if len(event.answer) > 200
                    else event.answer
                )
                logger.debug(f"üí¨ Answer: {preview}", extra={"color": "green"})
            if event.plan:
                logger.debug(f"‚ñ∏ {event.plan}", extra={"color": "yellow"})
            if event.memory_update:
                logger.debug(
                    f"üß† Memory: {event.memory_update[:100]}...",
                    extra={"color": "cyan"},
                )

        # ‚îÄ‚îÄ Executor events (reasoning mode) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        elif isinstance(event, ExecutorActionEvent):
            if event.description:
                logger.debug(
                    f"üéØ Action: {event.description}", extra={"color": "yellow"}
                )
            if event.thought:
                preview = (
                    event.thought[:120] + "..."
                    if len(event.thought) > 120
                    else event.thought
                )
                logger.debug(f"üí≠ Reasoning: {preview}", extra={"color": "cyan"})

        elif isinstance(event, ExecutorActionResultEvent):
            if event.success:
                logger.debug(f"‚úÖ {event.summary}", extra={"color": "green"})
            else:
                error_msg = event.error or "Unknown error"
                logger.debug(
                    f"‚ùå {event.summary} ({error_msg})", extra={"color": "red"}
                )

        elif isinstance(event, ExecutorResultEvent):
            logger.debug("Step complete", extra={"color": "magenta"})

        # ‚îÄ‚îÄ CodeAct events (direct mode) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        elif isinstance(event, CodeActInputEvent):
            logger.debug("üí¨ Task input received...")

        elif isinstance(event, CodeActResponseEvent):
            logger.debug("CodeAct response", extra={"color": "magenta"})
            if event.thought:
                preview = (
                    event.thought[:150] + "..."
                    if len(event.thought) > 150
                    else event.thought
                )
                logger.debug(f"üß† Thinking: {preview}", extra={"color": "cyan"})
            if event.code:
                logger.debug("üíª Executing action code", extra={"color": "yellow"})
                logger.debug(f"{event.code}", extra={"color": "blue"})

        elif isinstance(event, CodeActCodeEvent):
            logger.debug("‚ö° Executing action...", extra={"color": "yellow"})

        elif isinstance(event, CodeActOutputEvent):
            if event.output:
                output = str(event.output)
                preview = output[:100] + "..." if len(output) > 100 else output
                if "Error" in output or "Exception" in output:
                    logger.debug(f"‚ùå Action error: {preview}", extra={"color": "red"})
                else:
                    logger.debug(
                        f"‚ö° Action result: {preview}", extra={"color": "green"}
                    )

        elif isinstance(event, CodeActEndEvent):
            status = "done" if event.success else "failed"
            color = "green" if event.success else "red"
            logger.debug(
                f"‚ñ† {status}: {event.reason} ({event.code_executions} runs)",
                extra={"color": color},
            )

        # ‚îÄ‚îÄ FastAgent events (direct mode, XML tool-calling) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        elif isinstance(event, FastAgentInputEvent):
            logger.debug("üí¨ Task input received...")

        elif isinstance(event, FastAgentResponseEvent):
            logger.debug("FastAgent response", extra={"color": "magenta"})
            if event.thought:
                preview = (
                    event.thought[:150] + "..."
                    if len(event.thought) > 150
                    else event.thought
                )
                logger.debug(f"üß† Thinking: {preview}", extra={"color": "cyan"})
            if event.code:
                logger.debug("üíª Executing action code", extra={"color": "yellow"})
                logger.debug(f"{event.code}", extra={"color": "blue"})

        elif isinstance(event, FastAgentToolCallEvent):
            logger.debug("‚ö° Executing tool calls...", extra={"color": "yellow"})

        elif isinstance(event, FastAgentOutputEvent):
            if event.output:
                output = str(event.output)
                preview = output[:100] + "..." if len(output) > 100 else output
                if "Error" in output or "Exception" in output:
                    logger.debug(f"‚ùå Action error: {preview}", extra={"color": "red"})
                else:
                    logger.debug(
                        f"‚ö° Action result: {preview}", extra={"color": "green"}
                    )

        elif isinstance(event, FastAgentEndEvent):
            status = "done" if event.success else "failed"
            color = "green" if event.success else "red"
            logger.debug(
                f"‚ñ† {status}: {event.reason} ({event.tool_call_count} runs)",
                extra={"color": color},
            )

        # ‚îÄ‚îÄ Scripter events ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        elif isinstance(event, ScripterThinkingEvent):
            if event.thought:
                logger.debug(f"    {event.thought}", extra={"color": "cyan"})
            if event.code:
                logger.debug("  $ script", extra={"color": "blue"})
                for line in event.code.split("\n")[:5]:
                    if line.strip():
                        logger.debug(f"    {line}", extra={"color": "blue"})

        # ‚îÄ‚îÄ Droid coordination events ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        elif isinstance(event, FastAgentExecuteEvent):
            logger.debug("üîß Starting task execution...", extra={"color": "magenta"})

        elif isinstance(event, FastAgentResultEvent):
            if event.success:
                logger.debug(f"Task result: {event.reason}", extra={"color": "green"})
            else:
                logger.debug(f"Task failed: {event.reason}", extra={"color": "red"})

        elif isinstance(event, FinalizeEvent):
            if event.success:
                logger.info(
                    f"üéâ Goal achieved: {event.reason}", extra={"color": "green"}
                )
            else:
                logger.info(f"‚ùå Goal failed: {event.reason}", extra={"color": "red"})

        # ‚îÄ‚îÄ Fallback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        else:
            logger.debug(f"üîÑ {event.__class__.__name__}")

```

`droidrun/cli/logs.py`:

```py
"""
DroidRun CLI logging setup.

Re-exports from ``droidrun.cli.handlers`` for backward compatibility.
"""

from droidrun.log_handlers import CLILogHandler, TUILogHandler, configure_logging

__all__ = ["CLILogHandler", "TUILogHandler", "configure_logging"]

```

`droidrun/cli/main.py`:

```py
"""
DroidRun CLI - Command line interface for controlling Android devices through LLM agents.
"""

import asyncio
import logging
import os
import sys
import warnings
from contextlib import nullcontext
from functools import wraps

import click
import importlib.metadata
import tomllib
from pathlib import Path
from async_adbutils import adb
from rich.console import Console
from rich.panel import Panel
from rich.text import Text

from droidrun import ResultEvent, DroidAgent
from droidrun.log_handlers import CLILogHandler, configure_logging
from droidrun.cli.event_handler import EventHandler
from droidrun.config_manager import ConfigLoader, DroidrunConfig
from droidrun.macro.cli import macro_cli
from droidrun import __version__
from droidrun.portal import (
    PORTAL_PACKAGE_NAME,
    download_portal_apk,
    download_versioned_portal_apk,
    enable_portal_accessibility,
    get_compatible_portal_version,
    ping_portal,
    ping_portal_content,
    ping_portal_tcp,
)
from droidrun.telemetry import print_telemetry_message
from droidrun.agent.utils.llm_picker import load_llm
import json

# Suppress all warnings
warnings.filterwarnings("ignore")
os.environ["TOKENIZERS_PARALLELISM"] = "false"
os.environ["GRPC_ENABLE_FORK_SUPPORT"] = "false"

console = Console()


def _setup_cli_logging(debug: bool) -> None:
    """Configure the droidrun logger with a CLILogHandler."""
    handler = CLILogHandler()
    handler.setFormatter(
        logging.Formatter("%(levelname)s %(name)s %(message)s", "%H:%M:%S")
        if debug
        else logging.Formatter("%(message)s")
    )
    configure_logging(debug=debug, handler=handler)


def coro(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        return asyncio.run(f(*args, **kwargs))

    return wrapper


async def get_portal_version(device_obj) -> str | None:
    try:
        version_output = await device_obj.shell(
            "content query --uri content://com.droidrun.portal/version"
        )

        if "result=" in version_output:
            json_str = version_output.split("result=", 1)[1].strip()
            version_data = json.loads(json_str)

            if version_data.get("status") == "success":
                # Check for 'result' first (new portal), then 'data' (legacy)
                return version_data.get("result") or version_data.get("data")
        return None
    except Exception:
        return None


async def run_command(
    command: str,
    config_path: str | None = None,
    device: str | None = None,
    provider: str | None = None,
    model: str | None = None,
    steps: int | None = None,
    base_url: str | None = None,
    api_base: str | None = None,
    vision: bool | None = None,
    manager_vision: bool | None = None,
    executor_vision: bool | None = None,
    fast_agent_vision: bool | None = None,
    reasoning: bool | None = None,
    stream: bool | None = None,
    tracing: bool | None = None,
    debug: bool | None = None,
    tcp: bool | None = None,
    save_trajectory: str | None = None,
    ios: bool = False,
    temperature: float | None = None,
    **kwargs,
) -> bool:
    """Run a command on your Android device using natural language.

    Returns:
        bool: True if the task completed successfully, False otherwise.
    """
    config = ConfigLoader.load(config_path)

    # Print cloud link in a box
    if config.logging.rich_text:
        cloud_text = Text()
        cloud_text.append("‚ú® Try DroidRun Cloud: ", style="bold cyan")
        cloud_text.append(
            "https://cloud.droidrun.ai/sign-in", style="bold blue underline"
        )
        cloud_panel = Panel(
            cloud_text,
            border_style="cyan",
            padding=(0, 1),
        )
        console.print(cloud_panel)
    else:
        console.print("\n‚ú® Try DroidRun Cloud: https://cloud.droidrun.ai/sign-in\n")

    # Initialize logging
    debug_mode = debug if debug is not None else config.logging.debug
    _setup_cli_logging(debug_mode)
    logger = logging.getLogger("droidrun")

    try:
        logger.info(f"üöÄ Starting: {command}")
        print_telemetry_message()

        # ================================================================
        # STEP 1: Apply CLI overrides via direct mutation
        # ================================================================

        # Vision overrides
        if vision is not None:
            # --vision flag overrides all agents
            config.agent.manager.vision = vision
            config.agent.executor.vision = vision
            config.agent.fast_agent.vision = vision
            logger.debug(f"CLI override: vision={vision} (all agents)")
        else:
            # Apply individual agent vision overrides
            if manager_vision is not None:
                config.agent.manager.vision = manager_vision
            if executor_vision is not None:
                config.agent.executor.vision = executor_vision
            if fast_agent_vision is not None:
                config.agent.fast_agent.vision = fast_agent_vision

        # Agent overrides
        if steps is not None:
            config.agent.max_steps = steps
        if reasoning is not None:
            config.agent.reasoning = reasoning
        if stream is not None:
            config.agent.streaming = stream

        # Device overrides
        if device is not None:
            config.device.serial = device
        if tcp is not None:
            config.device.use_tcp = tcp

        # Logging overrides
        if debug is not None:
            config.logging.debug = debug
        if save_trajectory is not None:
            config.logging.save_trajectory = save_trajectory

        # Tracing overrides
        if tracing is not None:
            config.tracing.enabled = tracing

        # Platform overrides
        if ios:
            config.device.platform = "ios"

        # ================================================================
        # STEP 2: Initialize DroidAgent with config
        # ================================================================

        mode = (
            "planning with reasoning" if config.agent.reasoning else "direct execution"
        )
        logger.info(f"ü§ñ Agent mode: {mode}")
        logger.info(
            f"üëÅÔ∏è  Vision settings: Manager={config.agent.manager.vision}, "
            f"Executor={config.agent.executor.vision}, FastAgent={config.agent.fast_agent.vision}"
        )

        if config.tracing.enabled:
            logger.info("üîç Tracing enabled")

        # Build DroidAgent kwargs for LLM loading
        droid_agent_kwargs = {"runtype": "cli"}
        llm = None

        if provider or model:
            assert (
                provider and model
            ), "Either both provider and model must be provided or none of them"
            llm_kwargs = {}
            if temperature is not None:
                llm_kwargs["temperature"] = temperature
            if base_url is not None:
                llm_kwargs["base_url"] = base_url
            if api_base is not None:
                llm_kwargs["api_base"] = api_base
            llm = load_llm(provider, model=model, **llm_kwargs, **kwargs)
        else:
            if temperature is not None:
                droid_agent_kwargs["temperature"] = temperature
            if base_url is not None:
                droid_agent_kwargs["base_url"] = base_url
            if api_base is not None:
                droid_agent_kwargs["api_base"] = api_base

        if not ios:
            try:
                device_obj = await adb.device(config.device.serial)
                if device_obj:
                    portal_version = await get_portal_version(device_obj)

                    if not portal_version or portal_version < "0.4.1":
                        logger.warning(
                            f"‚ö†Ô∏è  Portal version {portal_version} is outdated"
                        )
                        console.print(
                            f"\n[yellow]Portal version {portal_version} < 0.4.1. Running setup...[/]\n"
                        )

                        await _setup_portal(
                            path=None, device=config.device.serial, debug=debug_mode
                        )

                else:
                    logger.debug("Could not get portal version, skipping check")
            except Exception as e:
                logger.warning(f"Version check failed: {e}")

        droid_agent = DroidAgent(
            goal=command,
            llms=llm,
            config=config,
            timeout=1000,
            **droid_agent_kwargs,
        )

        # ================================================================
        # STEP 3: Run agent
        # ================================================================

        logger.debug("‚ñ∂Ô∏è  Starting agent execution...")
        logger.debug("Press Ctrl+C to stop")

        event_handler = EventHandler()

        try:
            handler = droid_agent.run()

            async for event in handler.stream_events():
                event_handler.handle(event)
            result: ResultEvent = await handler
            return result.success

        except KeyboardInterrupt:
            logger.info("‚èπÔ∏è Stopped by user")
            return False

        except Exception as e:
            logger.error(f"üí• Error: {e}")
            if config.logging.debug:
                import traceback

                logger.debug(traceback.format_exc())
            return False

    except Exception as e:
        logger.error(f"üí• Setup error: {e}")
        if debug_mode:
            import traceback

            logger.debug(traceback.format_exc())
        return False


class DroidRunCLI(click.Group):
    def parse_args(self, ctx, args):
        # If the first arg is not an option and not a known command, treat as 'run'
        if args and not args[0].startswith("-") and args[0] not in self.commands:
            args.insert(0, "run")

        return super().parse_args(ctx, args)


def _print_version(ctx, param, value):
    """Click callback to print version and exit early when --version is passed."""
    if not value or ctx.resilient_parsing:
        return
    version = None
    try:
        version = importlib.metadata.version("droidrun")
        # print("debug: step 1")
    except Exception:
        pass

    if not version:
        try:
            from droidrun import __version__ as pkg_version

            version = pkg_version
            # print("debug: step 2")
        except Exception:
            pass

    if not version:
        try:
            repo_root = Path(__file__).resolve().parents[2]
            pyproject = repo_root / "pyproject.toml"
            if pyproject.exists():
                with pyproject.open("rb") as f:
                    data = tomllib.load(f)
                    version = data.get("project", {}).get("version")
            # print("debug: step 3")
        except Exception:
            version = None

    if not version:
        version = "unknown"
    click.echo(f"v{version}")
    ctx.exit()


@click.group(cls=DroidRunCLI)
@click.option(
    "--version",
    is_flag=True,
    callback=_print_version,
    expose_value=False,
    is_eager=True,
    help="Show droidrun version and exit",
)
def cli():
    """DroidRun - Control your Android device through LLM agents."""
    pass


@cli.command()
@click.argument("command", type=str)
@click.option("--config", "-c", help="Path to custom config file", default=None)
@click.option("--device", "-d", help="Device serial number or IP address", default=None)
@click.option(
    "--provider",
    "-p",
    help="LLM provider (OpenAI, Ollama, Anthropic, GoogleGenAI, DeepSeek)",
    default=None,
)
@click.option(
    "--model",
    "-m",
    help="LLM model name",
    default=None,
)
@click.option("--temperature", type=float, help="Temperature for LLM", default=None)
@click.option("--steps", type=int, help="Maximum number of steps", default=None)
@click.option(
    "--base_url",
    "-u",
    help="Base URL for API (e.g., OpenRouter or Ollama)",
    default=None,
)
@click.option(
    "--api_base",
    help="Base URL for API (e.g., OpenAI or OpenAI-Like)",
    default=None,
)
@click.option(
    "--vision/--no-vision",
    default=None,
    help="Enable vision capabilites by using screenshots for all agents.",
)
@click.option(
    "--reasoning/--no-reasoning", default=None, help="Enable planning with reasoning"
)
@click.option(
    "--stream/--no-stream",
    default=None,
    help="Stream LLM responses to console in real-time",
)
@click.option(
    "--tracing/--no-tracing", default=None, help="Enable Arize Phoenix tracing"
)
@click.option("--debug/--no-debug", default=None, help="Enable verbose debug logging")
@click.option(
    "--tcp/--no-tcp",
    default=None,
    help="Use TCP communication for device control",
)
@click.option(
    "--save-trajectory",
    type=click.Choice(["none", "step", "action"]),
    help="Trajectory saving level: none (no saving), step (save per step), action (save per action)",
    default=None,
)
@click.option("--ios", type=bool, default=None, help="Run on iOS device")
@coro
async def run(
    command: str,
    config: str | None,
    device: str | None,
    provider: str | None,
    model: str | None,
    steps: int | None,
    base_url: str | None,
    api_base: str | None,
    temperature: float | None,
    vision: bool | None,
    reasoning: bool | None,
    stream: bool | None,
    tracing: bool | None,
    debug: bool | None,
    tcp: bool | None,
    save_trajectory: str | None,
    ios: bool | None,
):
    """Run a command on your Android device using natural language."""

    try:
        success = await run_command(
            command=command,
            config_path=config,
            device=device,
            provider=provider,
            model=model,
            steps=steps,
            base_url=base_url,
            api_base=api_base,
            vision=vision,
            reasoning=reasoning,
            stream=stream,
            tracing=tracing,
            debug=debug,
            tcp=tcp,
            temperature=temperature,
            save_trajectory=save_trajectory,
            ios=ios if ios is not None else False,
        )
    finally:
        # Disable DroidRun keyboard after execution
        # Note: Port forwards are managed automatically and persist until device disconnect
        try:
            if not (ios if ios is not None else False):
                device_obj = await adb.device(device)
                if device_obj:
                    await device_obj.shell(
                        "ime disable com.droidrun.portal/.input.DroidrunKeyboardIME"
                    )
        except Exception:
            click.echo("Failed to disable DroidRun keyboard")

    # Exit with appropriate code
    sys.exit(0 if success else 1)


@cli.command()
@coro
async def devices():
    """List connected Android devices."""
    try:
        devices = await adb.list()
        if not devices:
            console.print("[yellow]No devices connected.[/]")
            return

        console.print(f"[green]Found {len(devices)} connected device(s):[/]")
        for device in devices:
            console.print(f"  ‚Ä¢ [bold]{device.serial}[/]")
    except Exception as e:
        console.print(f"[red]Error listing devices: {e}[/]")


@cli.command()
@click.argument("serial")
@coro
async def connect(serial: str):
    """Connect to a device over TCP/IP."""
    try:
        device = await adb.connect(serial)
        if device.count("already connected"):
            console.print(f"[green]Successfully connected to {serial}[/]")
        else:
            console.print(f"[red]Failed to connect to {serial}: {device}[/]")
    except Exception as e:
        console.print(f"[red]Error connecting to device: {e}[/]")


@cli.command()
@click.argument("serial")
@coro
async def disconnect(serial: str):
    """Disconnect from a device."""
    try:
        success = await adb.disconnect(serial, raise_error=True)
        if success:
            console.print(f"[green]Successfully disconnected from {serial}[/]")
        else:
            console.print(f"[yellow]Device {serial} was not connected[/]")
    except Exception as e:
        console.print(f"[red]Error disconnecting from device: {e}[/]")


async def _setup_portal(
    path: str | None,
    device: str | None,
    debug: bool,
    latest: bool = False,
    specific_version: str | None = None,
):
    """Internal async function to install and enable the DroidRun Portal on a device."""
    try:
        if not device:
            devices = await adb.list()
            if not devices:
                console.print("[yellow]No devices connected.[/]")
                return

            device = devices[0].serial
            console.print(f"[blue]Using device:[/] {device}")

        device_obj = await adb.device(device)
        if not device_obj:
            console.print(
                f"[bold red]Error:[/] Could not get device object for {device}"
            )
            return

        if path:
            console.print(f"[bold blue]Using provided APK:[/] {path}")
            apk_context = nullcontext(path)
        elif specific_version:
            version = specific_version.lstrip("v")
            version = f"v{version}"
            download_base = (
                "https://github.com/droidrun/droidrun-portal/releases/download"
            )
            apk_context = download_versioned_portal_apk(version, download_base, debug)
        elif latest:
            console.print("[bold blue]Downloading latest Portal APK...[/]")
            apk_context = download_portal_apk(debug)
        else:
            from droidrun import __version__

            portal_version, download_base, mapping_fetched = (
                get_compatible_portal_version(__version__, debug)
            )

            if portal_version:
                apk_context = download_versioned_portal_apk(
                    portal_version, download_base, debug
                )
            else:
                if not mapping_fetched:
                    console.print(
                        "[yellow]Could not fetch version mapping, falling back to latest...[/]"
                    )
                apk_context = download_portal_apk(debug)

        with apk_context as apk_path:
            if not os.path.exists(apk_path):
                console.print(f"[bold red]Error:[/] APK file not found at {apk_path}")
                return

            console.print(f"[bold blue]Step 1/2: Installing APK:[/] {apk_path}")
            try:
                await device_obj.install(
                    apk_path, uninstall=True, flags=["-g"], silent=not debug
                )
            except Exception as e:
                console.print(f"[bold red]Installation failed:[/] {e}")
                return

            console.print("[bold green]Installation successful![/]")

            console.print("[bold blue]Step 2/2: Enabling accessibility service[/]")

            try:
                await enable_portal_accessibility(device_obj)

                console.print("[green]Accessibility service enabled successfully![/]")
                console.print(
                    "\n[bold green]Setup complete![/] The DroidRun Portal is now installed and ready to use."
                )

            except Exception as e:
                console.print(
                    f"[yellow]Could not automatically enable accessibility service: {e}[/]"
                )
                console.print(
                    "[yellow]Opening accessibility settings for manual configuration...[/]"
                )

                await device_obj.shell(
                    "am start -a android.settings.ACCESSIBILITY_SETTINGS"
                )

                console.print(
                    "\n[yellow]Please complete the following steps on your device:[/]"
                )
                console.print(
                    f"1. Find [bold]{PORTAL_PACKAGE_NAME}[/] in the accessibility services list"
                )
                console.print("2. Tap on the service name")
                console.print(
                    "3. Toggle the switch to [bold]ON[/] to enable the service"
                )
                console.print("4. Accept any permission dialogs that appear")

                console.print(
                    "\n[bold green]APK installation complete![/] Please manually enable the accessibility service using the steps above."
                )

    except Exception as e:
        console.print(f"[bold red]Error:[/] {e}")

        if debug:
            import traceback

            traceback.print_exc()


@cli.command()
@click.option("--device", "-d", help="Device serial number or IP address", default=None)
@click.option(
    "--path",
    help="Path to the Droidrun Portal APK to install on the device. If not provided, the latest portal apk version will be downloaded and installed.",
    default=None,
)
@click.option(
    "--portal-version",
    "-pv",
    help="Specific Portal version to install (e.g., 0.4.7)",
    default=None,
)
@click.option(
    "--latest",
    is_flag=True,
    help="Install latest Portal instead of compatible version",
    default=False,
)
@click.option(
    "--debug", is_flag=True, help="Enable verbose debug logging", default=False
)
@coro
async def setup(
    path: str | None,
    device: str | None,
    portal_version: str | None,
    latest: bool,
    debug: bool,
):
    """Install and enable the DroidRun Portal on a device."""
    await _setup_portal(path, device, debug, latest, portal_version)


@cli.command()
@click.option("--device", "-d", help="Device serial number or IP address", default=None)
@click.option(
    "--tcp/--no-tcp",
    default=None,
    help="Use TCP communication for device control",
)
@click.option("--debug/--no-debug", default=None, help="Enable verbose debug logging")
@coro
async def ping(device: str | None, tcp: bool | None, debug: bool | None):
    """Ping a device to check if it is ready and accessible."""
    # Handle None defaults
    debug_mode = debug if debug is not None else False
    use_tcp_mode = tcp if tcp is not None else False

    try:
        device_obj = await adb.device(device)
        if not device_obj:
            console.print(f"[bold red]Error:[/] Could not find device {device}")
            return

        await ping_portal(device_obj, debug_mode)

        if use_tcp_mode:
            await ping_portal_tcp(device_obj, debug_mode)
        else:
            await ping_portal_content(device_obj, debug_mode)

        console.print(
            "[bold green]Portal is installed and accessible. You're good to go![/]"
        )
    except Exception as e:
        console.print(f"[bold red]Error:[/] {e}")
        if debug_mode:
            import traceback

            traceback.print_exc()


# Add macro commands as a subgroup
cli.add_command(macro_cli, name="macro")


@cli.command()
@click.option("--device", "-d", help="Device serial number or IP address", default=None)
@click.option("--debug/--no-debug", default=None, help="Enable verbose debug output")
@coro
async def doctor(device: str | None, debug: bool | None):
    """Check system health and diagnose issues."""
    from droidrun.cli.doctor import run_doctor

    await run_doctor(device, debug if debug is not None else False)


@cli.command()
def tui():
    """Launch the DroidRun Terminal User Interface."""
    from droidrun.cli.tui import run_tui

    run_tui()


async def test(
    command: str,
    config_path: str | None = None,
    device: str | None = None,
    steps: int | None = None,
    vision: bool | None = None,
    reasoning: bool | None = None,
    tracing: bool | None = None,
    debug: bool | None = None,
    use_tcp: bool | None = None,
    save_trajectory: str | None = None,
    temperature: float | None = None,
    ios: bool = False,
):
    config = ConfigLoader.load(config_path)

    # Initialize logging
    debug_mode = debug if debug is not None else config.logging.debug
    _setup_cli_logging(debug_mode)
    logger = logging.getLogger("droidrun")

    try:
        logger.info(f"üöÄ Starting: {command}")
        print_telemetry_message()

        # ================================================================
        # STEP 1: Apply CLI overrides via direct mutation
        # ================================================================

        # Vision overrides
        if vision is not None:
            # --vision flag overrides all agents
            config.agent.manager.vision = vision
            config.agent.executor.vision = vision
            config.agent.fast_agent.vision = vision
            logger.debug(f"CLI override: vision={vision} (all agents)")

        # Agent overrides
        if steps is not None:
            config.agent.max_steps = steps
        if reasoning is not None:
            config.agent.reasoning = reasoning

        # Device overrides
        if device is not None:
            config.device.serial = device
        if use_tcp is not None:
            config.device.use_tcp = use_tcp

        # Logging overrides
        if debug is not None:
            config.logging.debug = debug
        if save_trajectory is not None:
            config.logging.save_trajectory = save_trajectory

        # Tracing overrides
        if tracing is not None:
            config.tracing.enabled = tracing

        # Platform overrides
        if ios:
            config.device.platform = "ios"

        # ================================================================
        # STEP 2: Initialize DroidAgent with config
        # ================================================================

        mode = (
            "planning with reasoning" if config.agent.reasoning else "direct execution"
        )
        logger.info(f"ü§ñ Agent mode: {mode}")
        logger.info(
            f"üëÅÔ∏è  Vision settings: Manager={config.agent.manager.vision}, "
            f"Executor={config.agent.executor.vision}, FastAgent={config.agent.fast_agent.vision}"
        )

        if config.tracing.enabled:
            logger.info("üîç Tracing enabled")

        # Build DroidAgent kwargs for LLM loading
        droid_agent_kwargs = {}
        if temperature is not None:
            droid_agent_kwargs["temperature"] = temperature

        droid_agent = DroidAgent(
            goal=command,
            config=config,
            timeout=1000,
            **droid_agent_kwargs,
        )

        # ================================================================
        # STEP 3: Run agent
        # ================================================================

        logger.debug("‚ñ∂Ô∏è  Starting agent execution...")
        logger.debug("Press Ctrl+C to stop")

        event_handler = EventHandler()

        try:
            handler = droid_agent.run()

            async for event in handler.stream_events():
                event_handler.handle(event)
            result = await handler  # noqa: F841

        except KeyboardInterrupt:
            logger.info("‚èπÔ∏è Stopped by user")

        except Exception as e:
            logger.error(f"üí• Error: {e}")
            if config.logging.debug:
                import traceback

                logger.debug(traceback.format_exc())

    except Exception as e:
        logger.error(f"üí• Setup error: {e}")
        if debug_mode:
            import traceback

            logger.debug(traceback.format_exc())


if __name__ == "__main__":
    command = "open youtube and play a song by shakira"
    command = "use open_app to open the settings and search for the battery and enter the first result"
    device = None
    provider = "GoogleGenAI"
    model = "models/gemini-2.5-flash"
    temperature = 0
    api_key = os.getenv("GOOGLE_API_KEY")
    steps = 15
    vision = True
    reasoning = False
    tracing = True
    debug = True
    use_tcp = False
    base_url = None
    api_base = None
    ios = False
    save_trajectory = "none"
    asyncio.run(run_command(command, device="emulator-5556", reasoning=False))

```

`droidrun/cli/tui/__init__.py`:

```py
"""DroidRun Terminal User Interface."""

from droidrun.cli.tui.app import DroidrunTUI


def run_tui():
    """Run the DroidRun TUI application."""
    app = DroidrunTUI()
    app.run()


__all__ = ["DroidrunTUI", "run_tui"]

```

`droidrun/cli/tui/app.py`:

```py
"""DroidRun TUI - Main application."""

from __future__ import annotations

import time

from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Container, Vertical
from textual.widgets import Static
from textual.worker import Worker, WorkerState
from textual import events

from droidrun.cli.tui.commands import match_commands, resolve_command
from droidrun.cli.event_handler import EventHandler
from droidrun.log_handlers import TUILogHandler, configure_logging
from droidrun.cli.tui.settings import SettingsData, SettingsScreen
from droidrun.cli.tui.widgets import (
    InputBar,
    CommandDropdown,
    DevicePicker,
    LogView,
    StatusBar,
)

# Map basic color names (from EventHandler) to TUI hex palette
COLOR_HEX = {
    "blue": "#b7bdf8",
    "cyan": "#CAD3F6",
    "green": "#a6da95",
    "red": "#ed8796",
    "yellow": "#f5a97f",
    "magenta": "#838BBC",
    "white": "#a1a1aa",
    "dim": "#71717a",
}
DEFAULT_LOG_STYLE = "#a1a1aa"


BANNER = """[#CAD3F6]
\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557
\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551
\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551
\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551
\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551
\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d
[/#CAD3F6]
[#838BBC]Type a command or [bold]/[/bold] for options[/#838BBC]"""


class DroidrunTUI(App):

    ALLOW_SELECT = False
    CSS_PATH = "css/app.tcss"

    BINDINGS = [
        Binding("ctrl+l", "clear_logs", "Clear Logs", show=False),
        Binding("ctrl+shift+c", "copy_logs", "Copy Logs", show=False),
        Binding("escape", "handle_esc", "Esc", show=False),
        Binding("ctrl+c", "handle_ctrl_c", "Quit", show=False),
        Binding("ctrl+z", "quit", "Quit", show=False),
    ]

    def __init__(self) -> None:
        super().__init__()
        self.running = False
        self._cancel_requested = False
        self._logs_visible = False
        self._dropdown_visible = False
        self._device_pick_visible = False
        self._esc_last: float = 0.0
        self._ctrl_c_last: float = 0.0

        self.reasoning: bool = False
        self.device_serial: str = ""
        self._device_connected: bool = False  # tracks portal health
        self._pending_input: str | None = (
            None  # e.g. "steps" ‚Äî next submit goes to handler
        )

        # Load settings from user config
        try:
            from droidrun.config_manager import ConfigLoader

            config = ConfigLoader.load()
            self.settings = SettingsData.from_config(config)
            self._config_serial = config.device.serial or ""
        except Exception:
            self.settings = SettingsData()
            self._config_serial = ""

    def compose(self) -> ComposeResult:
        yield Static(BANNER, id="banner")

        with Container(id="log-container", classes="hidden"):
            yield LogView(id="log-display")

        with Vertical(id="bottom-area"):
            yield CommandDropdown(id="command-dropdown", classes="hidden")
            yield DevicePicker(id="device-picker", classes="hidden")
            yield InputBar(
                placeholder="Type a command or / for options",
                id="input-bar",
            )
            yield StatusBar(id="status-bar")

    def on_mount(self) -> None:
        self.query_one("#input-bar", InputBar).focus()
        self._sync_status_bar()
        self._update_hint()
        self.run_worker(self._autoconnect(), group="autoconnect", exclusive=True)
        self.set_interval(5, self._health_check_tick, name="health-check")

    def on_key(self, event: events.Key) -> None:
        if self._device_pick_visible or self._dropdown_visible:
            return
        input_bar = self.query_one("#input-bar", InputBar)
        if not input_bar.has_focus and event.is_printable and event.character:
            input_bar.focus()
            input_bar.value += event.character
            input_bar.cursor_position = len(input_bar.value)
            event.prevent_default()
            event.stop()

    # ‚îÄ‚îÄ Status bar ‚îÄ‚îÄ

    def _sync_status_bar(self) -> None:
        status = self.query_one("#status-bar", StatusBar)
        status.device_serial = self.device_serial
        status.device_connected = self._device_connected
        # Show model name from first profile in status bar
        first_profile = next(iter(self.settings.profiles.values()), None)
        if first_profile:
            model_display = first_profile.model
            if "/" in model_display:
                model_display = model_display.rsplit("/", 1)[-1]
        else:
            model_display = "no model"
        status.device_name = model_display
        status.mode = "reasoning" if self.reasoning else "fast"

    def _update_hint(self) -> None:
        status = self.query_one("#status-bar", StatusBar)
        if self.running:
            status.hint = "esc to stop"
        else:
            status.hint = ""

    # ‚îÄ‚îÄ Autoconnect ‚îÄ‚îÄ

    async def _autoconnect(self) -> None:
        """Silently find and verify a device on startup."""
        from async_adbutils import adb

        status = self.query_one("#status-bar", StatusBar)
        status.hint = "connecting..."

        try:
            devices = await adb.list()
        except Exception:
            status.hint = ""
            return

        # Filter to online devices
        available: list[str] = []
        for d in devices:
            if getattr(d, "state", None) == "device":
                available.append(d.serial)

        if not available:
            status.hint = ""
            return

        # Config serial gets priority, then the rest
        candidates = []
        if self._config_serial and self._config_serial in available:
            candidates.append(self._config_serial)
        for s in available:
            if s not in candidates:
                candidates.append(s)

        # Try each until portal responds
        for serial in candidates:
            try:
                await self._verify_portal(serial)
                self.device_serial = serial
                self._device_connected = True
                self._sync_status_bar()
                status.hint = ""
                return
            except Exception:
                continue

        # No portal found ‚Äî use config serial if it's online (device exists but no portal)
        if self._config_serial and self._config_serial in available:
            self.device_serial = self._config_serial
            self._sync_status_bar()

        status.hint = ""

    # ‚îÄ‚îÄ Health check ‚îÄ‚îÄ

    def _health_check_tick(self) -> None:
        """Called every 5s by set_interval. Kicks off async health check."""
        if not self.device_serial:
            return
        self.run_worker(self._health_check(), group="health", exclusive=True)

    async def _health_check(self) -> None:
        """Ping the current device. Handle disconnect/reconnect."""
        import logging

        logger = logging.getLogger("droidrun")
        serial = self.device_serial
        if not serial:
            return

        try:
            await self._verify_portal(serial)

            if not self._device_connected:
                # Was disconnected, now back
                self._device_connected = True
                self._sync_status_bar()
                logger.info(f"Device reconnected: {serial}", extra={"color": "green"})

        except Exception:
            if self._device_connected:
                # Was connected, now lost
                self._device_connected = False
                self._sync_status_bar()
                logger.warning(
                    f"Device disconnected: {serial}", extra={"color": "yellow"}
                )

            # Try to reconnect
            try:
                await self._verify_portal(serial)
                self._device_connected = True
                self._sync_status_bar()
                logger.info(f"Device reconnected: {serial}", extra={"color": "green"})
            except Exception:
                pass

    # ‚îÄ‚îÄ Worker crash recovery ‚îÄ‚îÄ

    def on_worker_state_changed(self, event: Worker.StateChanged) -> None:
        if event.state == WorkerState.ERROR:
            # Recover UI state so it's not stuck
            self._device_pick_visible = False
            self.query_one("#device-picker").add_class("hidden")
            self.query_one("#status-bar").remove_class("hidden")
            input_bar = self.query_one("#input-bar", InputBar)
            input_bar.disabled = False
            input_bar.focus()
            # Show the error
            self._show_logs()
            log = self.query_one("#log-display", LogView)
            log.append(f"  worker error: {event.worker.error}")

    # ‚îÄ‚îÄ Debug ‚îÄ‚îÄ

    def _dbg(self, msg: str) -> None:
        if not self.settings.debug:
            return
        ts = time.strftime("%H:%M:%S", time.localtime())
        ms = f"{time.time() % 1:.3f}"[1:]  # .XXX
        self._show_logs()
        log = self.query_one("#log-display", LogView)
        log.append(f"  [{ts}{ms}] {msg}")

    # ‚îÄ‚îÄ Input messages ‚îÄ‚îÄ

    def on_input_bar_submitted(self, message: InputBar.Submitted) -> None:
        text = message.value.strip()
        if not text:
            if self._pending_input:
                self._cancel_pending_input()
            return

        self._hide_dropdown()

        if self._pending_input:
            self._handle_pending_input(text)
        elif text.startswith("/"):
            self._handle_slash_command(text[1:])
        else:
            self.run_worker(self._execute_command(text), exclusive=True)

    def on_input_bar_slash_changed(self, message: InputBar.SlashChanged) -> None:
        commands = match_commands(message.query)
        if not commands:
            self._hide_dropdown()
            return
        dropdown = self.query_one("#command-dropdown", CommandDropdown)
        dropdown.update_commands(commands)
        self._show_dropdown()

    def on_input_bar_slash_exited(self, message: InputBar.SlashExited) -> None:
        self._hide_dropdown()

    def on_input_bar_slash_select(self, message: InputBar.SlashSelect) -> None:
        dropdown = self.query_one("#command-dropdown", CommandDropdown)
        if dropdown.has_commands:
            dropdown.select_highlighted()

    def on_input_bar_slash_navigate(self, message: InputBar.SlashNavigate) -> None:
        dropdown = self.query_one("#command-dropdown", CommandDropdown)
        dropdown.move_highlight(message.direction)

    def on_input_bar_tab_pressed(self, message: InputBar.TabPressed) -> None:
        if self._dropdown_visible:
            dropdown = self.query_one("#command-dropdown", CommandDropdown)
            if dropdown.has_commands:
                cmd = dropdown._commands[dropdown.highlighted]
                input_bar = self.query_one("#input-bar", InputBar)
                input_bar.value = f"/{cmd.name}"
                input_bar.cursor_position = len(input_bar.value)
        else:
            self.reasoning = not self.reasoning
            self._sync_status_bar()

    def on_command_dropdown_selected(self, message: CommandDropdown.Selected) -> None:
        input_bar = self.query_one("#input-bar", InputBar)
        input_bar.value = ""
        self._hide_dropdown()
        self._handle_slash_command(message.command_name)

    # ‚îÄ‚îÄ Dropdown visibility ‚îÄ‚îÄ

    def _show_dropdown(self) -> None:
        self.query_one("#command-dropdown").remove_class("hidden")
        self.query_one("#status-bar").add_class("hidden")
        self._dropdown_visible = True
        self.query_one("#input-bar", InputBar).slash_mode = True

    def _hide_dropdown(self) -> None:
        self.query_one("#command-dropdown").add_class("hidden")
        self.query_one("#status-bar").remove_class("hidden")
        self._dropdown_visible = False
        self.query_one("#input-bar", InputBar).slash_mode = False

    # ‚îÄ‚îÄ Slash commands ‚îÄ‚îÄ

    def _handle_slash_command(self, text: str) -> None:
        parts = text.strip().split()
        if not parts:
            return

        cmd = resolve_command(parts[0])

        if cmd is None:
            self._show_logs()
            log = self.query_one("#log-display", LogView)
            log.append(f"  unknown command: /{parts[0]}")
            return

        handler = getattr(self, cmd.handler, None)
        if handler:
            args = parts[1:]
            handler(*args) if args else handler()

    # ‚îÄ‚îÄ Pending input ‚îÄ‚îÄ

    def _start_pending_input(
        self, kind: str, prompt: str, placeholder: str = ""
    ) -> None:
        self._pending_input = kind
        picker = self.query_one("#device-picker", DevicePicker)
        picker.set_status(prompt)
        self.query_one("#device-picker").remove_class("hidden")
        self.query_one("#status-bar").add_class("hidden")
        input_bar = self.query_one("#input-bar", InputBar)
        input_bar.placeholder = placeholder
        input_bar.focus()

    def _cancel_pending_input(self) -> None:
        self._pending_input = None
        self.query_one("#device-picker").add_class("hidden")
        self.query_one("#status-bar").remove_class("hidden")
        input_bar = self.query_one("#input-bar", InputBar)
        input_bar.placeholder = "Type a command or / for options"
        input_bar.focus()

    def _handle_pending_input(self, text: str) -> None:
        kind = self._pending_input
        self._cancel_pending_input()

        if kind == "steps":
            self._apply_steps(text)

    # ‚îÄ‚îÄ Command handlers ‚îÄ‚îÄ

    def action_toggle_debug(self) -> None:
        self.settings.debug = not self.settings.debug
        self._show_logs()
        log = self.query_one("#log-display", LogView)
        state = "on" if self.settings.debug else "off"
        log.append(f"  debug logging {state}")

    def action_show_help(self) -> None:
        self._show_logs()
        log = self.query_one("#log-display", LogView)
        dim = "#838BBC"
        heading = "#CAD3F6"
        cmd_style = "#b7bdf8"

        log.append("")
        log.append("  ‚îÄ‚îÄ commands ‚îÄ‚îÄ", style=heading)
        log.append("")
        log.append("    /config       ", style=cmd_style)
        log.append("      open settings modal", style=dim)
        log.append("    /devices      ", style=cmd_style)
        log.append("      select connected device", style=dim)
        log.append("    /steps [n]    ", style=cmd_style)
        log.append("      set max agent steps (prompts if no number given)", style=dim)
        log.append("    /debug        ", style=cmd_style)
        log.append("      toggle debug logging on/off", style=dim)
        log.append("    /copy         ", style=cmd_style)
        log.append("      copy log output to clipboard", style=dim)
        log.append("    /clear        ", style=cmd_style)
        log.append("      clear log and show banner", style=dim)
        log.append("    /help         ", style=cmd_style)
        log.append("      show this help", style=dim)
        log.append("")
        log.append("  ‚îÄ‚îÄ keys ‚îÄ‚îÄ", style=heading)
        log.append("")
        log.append("    tab           ", style=cmd_style)
        log.append("      toggle reasoning / fast mode", style=dim)
        log.append("    up / down     ", style=cmd_style)
        log.append("      navigate command history", style=dim)
        log.append("    ctrl+l        ", style=cmd_style)
        log.append("      clear logs", style=dim)
        log.append("    ctrl+shift+c  ", style=cmd_style)
        log.append("      copy logs to clipboard", style=dim)
        log.append("    esc           ", style=cmd_style)
        log.append("      stop running agent", style=dim)
        log.append("    esc √ó2        ", style=cmd_style)
        log.append("      clear input", style=dim)
        log.append("    ctrl+c √ó2     ", style=cmd_style)
        log.append("      quit", style=dim)
        log.append("")
        log.append("  ‚îÄ‚îÄ status bar ‚îÄ‚îÄ", style=heading)
        log.append("")
        log.append("    green dot     ", style="#a6da95")
        log.append("      device connected, portal verified", style=dim)
        log.append("    yellow dot    ", style="#f5a97f")
        log.append("      device set but portal unreachable", style=dim)
        log.append("    red dot       ", style="#ed8796")
        log.append("      no device", style=dim)
        log.append("")

    def action_set_steps(self, *args: str) -> None:
        if args:
            self._apply_steps(args[0])
        else:
            self._start_pending_input(
                "steps",
                f"How many steps should the agent take? (current: {self.settings.max_steps})",
                placeholder="Enter number of steps",
            )

    def _apply_steps(self, value: str) -> None:
        try:
            n = int(value)
            if n < 1:
                raise ValueError
        except (ValueError, TypeError):
            self._show_logs()
            log = self.query_one("#log-display", LogView)
            log.append(f"  invalid steps: {value}")
            return

        self.settings.max_steps = n
        self._show_logs()
        log = self.query_one("#log-display", LogView)
        log.append(f"  max steps set to {n}")

    def action_open_config(self) -> None:
        modal = SettingsScreen(self.settings)
        self.push_screen(modal, callback=self._on_settings_dismissed)

    def _on_settings_dismissed(self, result: SettingsData | None) -> None:
        if result is None:
            return

        self.settings = result
        self.settings.save()
        self._sync_status_bar()

        if self._logs_visible:
            log = self.query_one("#log-display", LogView)
            log.append("  settings updated")

    def action_open_device(self) -> None:
        self.run_worker(self._scan_devices(), exclusive=True)

    async def _scan_devices(self) -> None:
        from async_adbutils import adb

        picker = self.query_one("#device-picker", DevicePicker)
        picker.set_status("scanning...")
        self._show_device_picker()

        try:
            devices = await adb.list()
        except Exception:
            devices = []

        if not devices:
            picker.set_status("no devices found")
            return

        entries = []
        for d in devices:
            state = getattr(d, "state", "unknown")
            entries.append((d.serial, state))

        picker.set_devices(entries)
        picker.focus()

    def _show_device_picker(self) -> None:
        self.query_one("#device-picker").remove_class("hidden")
        self.query_one("#status-bar").add_class("hidden")
        self.query_one("#input-bar", InputBar).disabled = True
        self._device_pick_visible = True

    def _hide_device_picker(self) -> None:
        self.query_one("#device-picker").add_class("hidden")
        self.query_one("#status-bar").remove_class("hidden")
        self._device_pick_visible = False
        input_bar = self.query_one("#input-bar", InputBar)
        input_bar.disabled = False
        input_bar.focus()

    def on_device_picker_device_selected(
        self, message: DevicePicker.DeviceSelected
    ) -> None:
        self._dbg(f"device_selected serial={message.serial}")
        picker = self.query_one("#device-picker", DevicePicker)
        picker.set_status("checking portal...")
        self.run_worker(self._check_device(message.serial), exclusive=True)

    def on_device_picker_option_selected(
        self, message: DevicePicker.OptionSelected
    ) -> None:
        self._dbg(f"option_selected id={message.option_id} serial={message.serial}")
        picker = self.query_one("#device-picker", DevicePicker)
        if message.option_id == "setup":
            # Hide picker but keep input disabled during setup
            self.query_one("#device-picker").add_class("hidden")
            self.query_one("#status-bar").remove_class("hidden")
            self._device_pick_visible = False
            self._dbg("starting _run_device_setup worker")
            self.run_worker(self._run_device_setup(message.serial), exclusive=True)
        elif message.option_id == "back":
            picker.set_devices(picker._devices)
            picker.focus()

    def on_device_picker_cancelled(self, message: DevicePicker.Cancelled) -> None:
        self._hide_device_picker()

    async def _verify_portal(self, serial: str) -> None:
        """Check portal connectivity. Raises on failure."""
        from async_adbutils import adb
        from droidrun.tools.android.portal_client import PortalClient

        device_obj = await adb.device(serial)
        portal = PortalClient(device_obj, prefer_tcp=self.settings.use_tcp)
        await portal.connect()
        result = await portal.ping()

        status = result.get("status")
        self._dbg(
            f"verify_portal serial={serial} tcp={portal.tcp_available} status={status}"
        )

        if status != "success":
            raise Exception(result.get("message", "portal not responding"))

    async def _check_device(self, serial: str) -> None:
        """Check device from the picker flow ‚Äî shows options on failure."""
        self._dbg(f"_check_device start serial={serial}")
        picker = self.query_one("#device-picker", DevicePicker)
        picker.set_status("checking portal...")

        try:
            await self._verify_portal(serial)

            # All good
            self.device_serial = serial
            self._device_connected = True
            self._hide_device_picker()
            self._sync_status_bar()
            self._show_logs()
            log = self.query_one("#log-display", LogView)
            log.append(f"  device ready: {serial}")
            self._dbg("_check_device ok")

        except Exception as e:
            self._dbg(f"_check_device failed: {e}")
            picker.set_options(
                serial,
                "DroidRun Portal is not set up on this device",
                [
                    ("setup", "Auto-install and set up DroidRun Portal"),
                    ("back", "Back to devices"),
                ],
            )

    async def _run_device_setup(self, serial: str) -> None:
        self._dbg(f"_run_device_setup ENTER serial={serial}")

        self._show_logs()
        log = self.query_one("#log-display", LogView)
        status = self.query_one("#status-bar", StatusBar)
        status.hint = "installing portal..."

        log.append(f"\n\u2500\u2500 setup {serial}")
        log.append("")

        apk_tmp = None
        try:
            import asyncio
            import os
            import tempfile

            import requests
            from async_adbutils import adb
            from droidrun.portal import (
                get_compatible_portal_version,
                enable_portal_accessibility,
                ASSET_NAME,
            )

            self._dbg("_run_device_setup imports done")

            # Resolve device
            device_obj = await adb.device(serial)
            self._dbg("_run_device_setup got device")

            # Determine APK version (blocking HTTP call)
            log.append("  checking compatible version...")
            from droidrun import __version__

            portal_version, download_base, mapping_fetched = await asyncio.to_thread(
                get_compatible_portal_version, __version__
            )
            self._dbg(
                f"_run_device_setup version={portal_version} fetched={mapping_fetched}"
            )

            # Build download URL
            if portal_version:
                log.append(f"  downloading portal {portal_version}...")
                url = f"{download_base}/{portal_version}/{ASSET_NAME}-{portal_version}.apk"
            else:
                if not mapping_fetched:
                    log.append("  version map unavailable, using latest")
                log.append("  downloading latest portal...")

                from droidrun.portal import get_latest_release_assets

                assets = await asyncio.to_thread(get_latest_release_assets)
                url = None
                for asset in assets:
                    if "browser_download_url" in asset and asset.get(
                        "name", ""
                    ).startswith(ASSET_NAME):
                        url = asset["browser_download_url"]
                        break
                    elif "downloadUrl" in asset and os.path.basename(
                        asset["downloadUrl"]
                    ).startswith(ASSET_NAME):
                        url = asset["downloadUrl"]
                        break
                if not url:
                    raise Exception("portal APK not found in latest release")

            # Download APK in thread
            def _download(download_url: str) -> str:
                tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".apk")
                r = requests.get(download_url, stream=True)
                r.raise_for_status()
                for chunk in r.iter_content(chunk_size=8192):
                    if chunk:
                        tmp.write(chunk)
                tmp.close()
                return tmp.name

            apk_tmp = await asyncio.to_thread(_download, url)
            log.append("  downloaded")
            self._dbg("_run_device_setup downloaded")

            # Install
            log.append("  installing APK...")
            await device_obj.install(apk_tmp, uninstall=True, flags=["-g"], silent=True)
            log.append("  APK installed")
            self._dbg("_run_device_setup installed")

            # Enable accessibility
            log.append("  enabling accessibility service...")
            await enable_portal_accessibility(device_obj)
            log.append("  accessibility enabled")
            self._dbg("_run_device_setup accessibility enabled, waiting for portal...")

            # Give the Portal service time to initialize
            log.append("  waiting for portal to start...")
            await asyncio.sleep(3)

            # Verify
            log.append("  verifying portal...")
            await self._verify_portal(serial)

            # Success ‚Äî link device
            self.device_serial = serial
            self._device_connected = True
            self._sync_status_bar()
            log.append(f"  device ready: {serial}")
            log.append("")
            self._dbg("_run_device_setup SUCCESS")

        except Exception as e:
            self._dbg(f"_run_device_setup FAILED: {type(e).__name__}: {e}")
            import traceback

            for line in traceback.format_exc().splitlines():
                if line.strip():
                    self._dbg(f"  {line}")
            log.append(f"  setup failed: {e}")
            log.append("")

            # Re-show picker with retry options
            picker = self.query_one("#device-picker", DevicePicker)
            self._show_device_picker()
            picker.set_options(
                serial,
                f"setup failed: {e}",
                [
                    ("setup", "Retry setup"),
                    ("back", "Back to devices"),
                ],
            )

        else:
            # Re-enable input only on success
            input_bar = self.query_one("#input-bar", InputBar)
            input_bar.disabled = False
            input_bar.focus()

        finally:
            if apk_tmp:
                import os

                if os.path.exists(apk_tmp):
                    os.unlink(apk_tmp)
            status.hint = ""

    def action_clear_logs(self) -> None:
        log = self.query_one("#log-display", LogView)
        log.clear_log()
        self.query_one("#log-container").add_class("hidden")
        self.query_one("#banner").remove_class("hidden")
        self._logs_visible = False

    def action_copy_logs(self) -> None:
        log = self.query_one("#log-display", LogView)
        text = log.get_plain_text()
        if text:
            self.copy_to_clipboard(text)
            self.notify("Copied", timeout=1.5)

    # ‚îÄ‚îÄ Esc handling ‚îÄ‚îÄ

    def action_handle_esc(self) -> None:
        if self._pending_input:
            self._cancel_pending_input()
            return

        if self._device_pick_visible:
            self._hide_device_picker()
            return

        now = time.monotonic()
        double_esc = (now - self._esc_last) < 0.3
        self._esc_last = now

        if self.running and not double_esc:
            self._cancel_requested = True
            log = self.query_one("#log-display", LogView)
            log.append("  stopping...")
        elif double_esc:
            self.query_one("#input-bar", InputBar).clear_input()

    def action_handle_ctrl_c(self) -> None:
        now = time.monotonic()
        if (now - self._ctrl_c_last) < 1.5:
            self.exit()
        else:
            self._ctrl_c_last = now
            status = self.query_one("#status-bar", StatusBar)
            status.hint = "ctrl+c again to quit"
            self.set_timer(1.5, self._reset_ctrl_c_hint)

    def _reset_ctrl_c_hint(self) -> None:
        if (time.monotonic() - self._ctrl_c_last) >= 1.0:
            self._update_hint()

    # ‚îÄ‚îÄ Log visibility ‚îÄ‚îÄ

    def _show_logs(self) -> None:
        if not self._logs_visible:
            self.query_one("#log-container").remove_class("hidden")
            self.query_one("#banner").add_class("hidden")
            self._logs_visible = True

    # ‚îÄ‚îÄ Agent execution ‚îÄ‚îÄ

    async def _execute_command(self, command: str) -> None:
        if self.running:
            log = self.query_one("#log-display", LogView)
            log.append("  already running")
            return

        self.running = True
        self._cancel_requested = False
        input_bar = self.query_one("#input-bar", InputBar)
        input_bar.disabled = True
        self._update_hint()

        self._show_logs()

        log = self.query_one("#log-display", LogView)
        status = self.query_one("#status-bar", StatusBar)

        log.append(f"\n\u2500\u2500 {command}", style="#CAD3F6")
        log.append("")

        status.is_running = True

        # Set up TUI logging handler
        _stream_buf: list[str] = []

        def _append_indented(msg: str, style: str) -> None:
            for line in msg.split("\n"):
                log.append(f"  {line}", style=style)

        def _on_record(rec: dict) -> None:
            style = COLOR_HEX.get(rec.get("color")) or DEFAULT_LOG_STYLE

            if rec["stream"]:
                _stream_buf.append(rec["msg"])
            elif rec["stream_end"]:
                if _stream_buf:
                    _append_indented("".join(_stream_buf), style)
                    _stream_buf.clear()
            else:
                if _stream_buf:
                    _append_indented("".join(_stream_buf), style)
                    _stream_buf.clear()
                _append_indented(rec["msg"], style)

        tui_handler = TUILogHandler(on_record=_on_record)
        configure_logging(debug=self.settings.debug, handler=tui_handler)
        event_handler = EventHandler()
        success = False

        try:
            from droidrun import DroidAgent, ResultEvent
            from droidrun.config_manager import ConfigLoader

            config = ConfigLoader.load()

            # Apply settings to config
            self.settings.apply_to_config(config)

            config.agent.reasoning = self.reasoning
            config.device.serial = self.device_serial or None

            log.append("  initializing...", style="#838BBC")
            first_profile = next(iter(self.settings.profiles.values()), None)
            if first_profile:
                log.append(
                    f"  {first_profile.provider} \u2022 {first_profile.model}",
                    style="#838BBC",
                )

            # DroidAgent loads LLMs from config.llm_profiles via load_agent_llms
            droid_agent = DroidAgent(
                goal=command,
                config=config,
                timeout=1000,
                runtype="tui",
            )

            log.append("")

            handler = droid_agent.run()

            async for event in handler.stream_events():
                if self._cancel_requested:
                    log.append("\n  stopped by user")
                    break
                event_handler.handle(event)

            if not self._cancel_requested:
                result: ResultEvent = await handler
                success = result.success
                log.append(f"\n  {result.steps} steps", style="#838BBC")

        except Exception as e:
            log.append(f"\n  error: {e}", style="#ed8796")
            import traceback

            for line in traceback.format_exc().split("\n"):
                if line.strip():
                    log.append(f"  {line}", style="#ed8796")

        finally:
            if _stream_buf:
                log.append("  " + "".join(_stream_buf))
                _stream_buf.clear()

            if success:
                log.append("  done", style="#a6da95")
            else:
                log.append("  failed", style="#ed8796")
            log.append("")

            self.running = False
            self._cancel_requested = False
            status.is_running = False
            input_bar.disabled = False
            input_bar.focus()
            self._update_hint()

```

`droidrun/cli/tui/commands.py`:

```py
"""Slash command registry with alias support."""

from __future__ import annotations

from dataclasses import dataclass, field


@dataclass
class Command:
    """A slash command with optional hidden aliases."""

    name: str
    description: str
    handler: str  # Method name on the App
    aliases: list[str] = field(default_factory=list)


COMMANDS: list[Command] = [
    Command(
        "config", "Configure agent settings", "action_open_config", aliases=["settings"]
    ),
    Command("copy", "Copy log to clipboard", "action_copy_logs"),
    Command("debug", "Toggle debug logging", "action_toggle_debug"),
    Command("devices", "Select connected device", "action_open_device"),
    Command("help", "Show keybindings and commands", "action_show_help"),
    Command("steps", "Set max agent steps", "action_set_steps"),
    Command("clear", "Clear log output", "action_clear_logs"),
]


def match_commands(query: str) -> list[Command]:
    """
    Match query against canonical names and aliases.

    Returns deduplicated Commands sorted by canonical name.
    Typing "set" matches alias "settings" and returns the "config" Command.
    """
    query = query.lower().strip()
    if not query:
        return list(COMMANDS)

    seen: set[str] = set()
    results: list[Command] = []

    for cmd in COMMANDS:
        if cmd.name in seen:
            continue
        # Check canonical name
        if cmd.name.startswith(query):
            seen.add(cmd.name)
            results.append(cmd)
            continue
        # Check aliases
        for alias in cmd.aliases:
            if alias.startswith(query):
                seen.add(cmd.name)
                results.append(cmd)
                break

    return sorted(results, key=lambda c: c.name)


def resolve_command(text: str) -> Command | None:
    """Resolve exact command name or alias to a Command."""
    text = text.lower().strip()
    for cmd in COMMANDS:
        if cmd.name == text:
            return cmd
        if text in cmd.aliases:
            return cmd
    return None

```

`droidrun/cli/tui/css/advanced_tab.tcss`:

```tcss
AdvancedTab .hidden-field {
    display: none;
}

```

`droidrun/cli/tui/css/app.tcss`:

```tcss
/*
 * DroidRun TUI ‚Äî Dark theme
 *
 * Layer hierarchy (darkest ‚Üí lightest):
 *   L0  #09090b  ‚Äî screen base
 *   L1  #0c0c0f  ‚Äî log area
 *   L2  #111116  ‚Äî modal background, cards
 *   L3  #18181b  ‚Äî input/select fields
 *   L4  #27272a  ‚Äî hover, elevated surfaces
 *   L5  #3f3f46  ‚Äî borders on focus, active
 *
 * Text:
 *   primary    #f4f4f5
 *   secondary  #a1a1aa
 *   muted      #52525b
 *
 * Accent:
 *   blue       #60a5fa
 *   green      #4ade80
 *   red        #f87171
 *   yellow     #facc15
 */

Screen {
    background: #09090b;
}

/* ‚îÄ‚îÄ Toast ‚îÄ‚îÄ */
ToastRack {
    dock: top;
    align: right top;
    margin-top: 1;
    margin-bottom: 0;
}

/* ‚îÄ‚îÄ Banner ‚îÄ‚îÄ */
#banner {
    width: 100%;
    content-align: center middle;
    text-align: center;
    height: 1fr;
}

#banner.hidden {
    display: none;
}

/* ‚îÄ‚îÄ Log Area ‚îÄ‚îÄ */
#log-container {
    height: 1fr;
    padding: 0 1;
}

#log-container.hidden {
    display: none;
}

#log-display {
    height: 100%;
    background: #0c0c0f;
    scrollbar-size: 1 1;
    scrollbar-color: #3f3f46;
    scrollbar-color-hover: #60a5fa;
    scrollbar-color-active: #f4f4f5;
    scrollbar-background: #0c0c0f;
    scrollbar-background-hover: #0c0c0f;
    scrollbar-background-active: #0c0c0f;
}

/* ‚îÄ‚îÄ Bottom Area ‚îÄ‚îÄ */
#bottom-area {
    dock: bottom;
    height: auto;
    padding: 0;
}

/* ‚îÄ‚îÄ Input Bar ‚îÄ‚îÄ */
InputBar {
    background: #09090b;
    border: tall #27272a;
    height: 3;
    margin: 0 1;
    padding: 0 1;
}

InputBar:focus {
    border: tall #60a5fa;
}

InputBar.-disabled {
    opacity: 0.4;
}

/* ‚îÄ‚îÄ Command Dropdown ‚îÄ‚îÄ */
CommandDropdown {
    height: auto;
    max-height: 8;
    background: #18181b;
    margin: 0 1;
    padding: 0;
}

CommandDropdown.hidden {
    display: none;
}

/* ‚îÄ‚îÄ Device Picker ‚îÄ‚îÄ */
DevicePicker {
    height: auto;
    max-height: 10;
    background: #18181b;
    margin: 0 1;
    padding: 0;
}

DevicePicker.hidden {
    display: none;
}

/* ‚îÄ‚îÄ Status Bar ‚îÄ‚îÄ */
StatusBar {
    height: 1;
    background: #09090b;
    color: #a1a1aa;
    padding: 0 2;
}

StatusBar.hidden {
    display: none;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Settings Modal
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

/* ‚îÄ‚îÄ Input ‚îÄ‚îÄ */

SettingsScreen Input {
    background: #18181b;
    border: tall #27272a;
    height: 3;
    padding: 0 1;
    color: #f4f4f5;
}

SettingsScreen Input:hover {
    border: tall #3f3f46;
}

SettingsScreen Input:focus {
    border: tall #60a5fa;
}

/* ‚îÄ‚îÄ Select ‚îÄ‚îÄ */

SettingsScreen Select {
    height: auto;
}

SettingsScreen SelectCurrent {
    background: #18181b;
    border: tall #27272a;
    color: #f4f4f5;
}

SettingsScreen Select:hover > SelectCurrent {
    border: tall #3f3f46;
}

SettingsScreen SelectCurrent:hover {
    border: tall #3f3f46;
}

SettingsScreen Select:focus > SelectCurrent {
    border: tall #60a5fa;
}

SettingsScreen SelectOverlay {
    background: #18181b;
    border: tall #27272a;
}

SettingsScreen SelectOverlay > .option-list--option-highlighted {
    background: #27272a;
    color: #f4f4f5;
}

SettingsScreen SelectOverlay > .option-list--option-hover {
    background: #27272a;
    color: #f4f4f5;
}

/* ‚îÄ‚îÄ BoolToggle ‚îÄ‚îÄ */

SettingsScreen BoolToggle {
    width: 1fr;
    height: 3;
    content-align: left middle;
    background: #18181b;
    color: #52525b;
    border: tall #27272a;
    padding: 0 1;
}

SettingsScreen BoolToggle.-on {
    color: #4ade80;
    border: tall #27272a;
}

SettingsScreen BoolToggle:hover {
    border: tall #3f3f46;
}

SettingsScreen BoolToggle.-on:hover {
    border: tall #3f3f46;
}

/* ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ */

SettingsScreen Button {
    background: #27272a;
    color: #a1a1aa;
    border: none;
}

SettingsScreen Button:hover {
    background: #3f3f46;
    color: #f4f4f5;
    border: none;
}

SettingsScreen Button:focus {
    border: none;
}

SettingsScreen #settings-save-btn {
    color: #4ade80;
    min-width: 12;
    margin-right: 1;
}

SettingsScreen #settings-save-btn:hover {
    color: #86efac;
}

SettingsScreen #settings-cancel-btn {
    min-width: 12;
}

SettingsScreen ._KwargsRow Button {
    min-width: 3;
    width: 3;
    background: transparent;
    color: #f87171;
}

SettingsScreen ._KwargsRow Button:hover {
    background: transparent;
    color: #fca5a5;
}

/* ‚îÄ‚îÄ Sections ‚îÄ‚îÄ */

SettingsScreen Section {
    background: #111116;
    border: round #27272a;
    border-title-color: #f4f4f5;
    border-title-style: bold;
    border-subtitle-color: #52525b;
    padding: 1 2;
    margin-bottom: 1;
    height: auto;
}

/* ‚îÄ‚îÄ Tab pane scrollbar ‚îÄ‚îÄ */

SettingsScreen TabPane {
    scrollbar-size: 1 1;
    scrollbar-color: #3f3f46;
    scrollbar-color-hover: #60a5fa;
    scrollbar-color-active: #f4f4f5;
    scrollbar-background: transparent;
    scrollbar-background-hover: transparent;
    scrollbar-background-active: transparent;
}

/* ‚îÄ‚îÄ Field layout ‚îÄ‚îÄ */

SettingsScreen .field-row {
    height: auto;
    margin-bottom: 1;
}

SettingsScreen .field-label {
    width: 16;
    padding-top: 1;
    color: #a1a1aa;
}

SettingsScreen .field-input {
    width: 1fr;
}

SettingsScreen .field-select {
    width: 1fr;
}

```

`droidrun/cli/tui/css/models_tab.tcss`:

```tcss
/* _KwargsRow */
_KwargsRow {
    height: auto;
    margin-bottom: 1;
}
_KwargsRow Input {
    width: 1fr;
    margin-right: 1;
}
_KwargsRow .kwarg-key {
    width: 20;
}
_KwargsRow Button {
    min-width: 3;
    width: 3;
}

/* _KwargsEditor */
_KwargsEditor {
    height: auto;
}
_KwargsEditor .kwargs-add-btn {
    min-width: 8;
    margin-top: 1;
}

/* _ProfileCard */
_ProfileCard .profile-fields {
    height: auto;
}
_ProfileCard .hidden-field {
    display: none;
}

/* ModelsTab */
ModelsTab #apply-all-btn {
    color: #60a5fa;
    min-width: 14;
    margin-bottom: 1;
}
ModelsTab .kwargs-label {
    color: #52525b;
    margin-top: 1;
}

```

`droidrun/cli/tui/css/settings_screen.tcss`:

```tcss
SettingsScreen {
    align: center middle;
    background: rgba(0, 0, 0, 0.7);
}

#settings-dialog {
    width: 80;
    max-width: 95%;
    height: 85%;
    background: #0c0c0f;
    border: round #27272a;
    padding: 0 2;
}

#settings-tabs {
    height: 1fr;
}

#settings-tabs ContentSwitcher {
    height: 1fr;
}

#settings-tabs TabPane {
    height: 100%;
    overflow-y: auto;
    padding: 0;
}

#settings-tabs Tabs {
    background: #0c0c0f;
}

#settings-tabs Tab {
    color: #52525b;
    background: #0c0c0f;
}

#settings-tabs Tab.-active {
    color: #f4f4f5;
}

#settings-tabs Underline {
    color: #27272a;
}

#settings-tabs Tab:hover {
    color: #a1a1aa;
}

#settings-buttons {
    height: auto;
    margin-top: 0;
    padding-top: 0;
    border-top: solid #27272a;
    align: right middle;
}

```

`droidrun/cli/tui/settings/__init__.py`:

```py
"""TUI settings package."""

from droidrun.cli.tui.settings.data import SettingsData
from droidrun.cli.tui.settings.settings_screen import SettingsScreen

__all__ = ["SettingsData", "SettingsScreen"]

```

`droidrun/cli/tui/settings/advanced_tab.py`:

```py
"""Advanced tab ‚Äî TCP, trajectory, tracing, timing."""

from __future__ import annotations

from textual.app import ComposeResult
from textual.containers import HorizontalGroup, VerticalGroup
from textual.widgets import Input, Label, Select
from textual import on

from droidrun.cli.tui.settings.data import SettingsData
from droidrun.cli.tui.settings.section import BoolToggle, Section

TRACING_PROVIDERS = [
    ("Phoenix", "phoenix"),
    ("Langfuse", "langfuse"),
]


class AdvancedTab(VerticalGroup):
    """Content for the Advanced tab pane."""

    CSS_PATH = "../css/advanced_tab.tcss"

    def __init__(self, settings: SettingsData) -> None:
        super().__init__()
        self.settings = settings

    def compose(self) -> ComposeResult:
        with Section("Connection"):
            with HorizontalGroup(classes="field-row"):
                yield Label("Use TCP", classes="field-label")
                yield BoolToggle(value=self.settings.use_tcp, id="use-tcp")

        with Section("Logging"):
            with HorizontalGroup(classes="field-row"):
                yield Label("Debug", classes="field-label")
                yield BoolToggle(value=self.settings.debug, id="debug-logging")

            with HorizontalGroup(classes="field-row"):
                yield Label("Trajectory", classes="field-label")
                yield BoolToggle(
                    value=self.settings.save_trajectory, id="save-trajectory"
                )

            with HorizontalGroup(classes="field-row"):
                yield Label("GIFs", classes="field-label")
                yield BoolToggle(
                    value=self.settings.trajectory_gifs, id="trajectory-gifs"
                )

        with Section("Tracing"):
            with HorizontalGroup(classes="field-row"):
                yield Label("Enabled", classes="field-label")
                yield BoolToggle(
                    value=self.settings.tracing_enabled, id="tracing-enabled"
                )

            with HorizontalGroup(classes="field-row"):
                yield Label("Provider", classes="field-label")
                yield Select(
                    TRACING_PROVIDERS,
                    value=self.settings.tracing_provider,
                    allow_blank=False,
                    id="tracing-provider",
                    classes="field-select",
                )

            langfuse_cls = (
                "field-row"
                if self.settings.tracing_provider == "langfuse"
                else "field-row hidden-field"
            )

            with HorizontalGroup(classes=langfuse_cls, id="row-langfuse-host"):
                yield Label("Host", classes="field-label")
                yield Input(
                    value=self.settings.langfuse_host,
                    placeholder="https://cloud.langfuse.com",
                    id="langfuse-host",
                    classes="field-input",
                )

            with HorizontalGroup(classes=langfuse_cls, id="row-langfuse-pk"):
                yield Label("Public Key", classes="field-label")
                yield Input(
                    value=self.settings.langfuse_public_key,
                    id="langfuse-pk",
                    classes="field-input",
                )

            with HorizontalGroup(classes=langfuse_cls, id="row-langfuse-sk"):
                yield Label("Secret Key", classes="field-label")
                yield Input(
                    value=self.settings.langfuse_secret_key,
                    password=True,
                    id="langfuse-sk",
                    classes="field-input",
                )

            with HorizontalGroup(classes=langfuse_cls, id="row-langfuse-screenshots"):
                yield Label("Screenshots", classes="field-label")
                yield BoolToggle(
                    value=self.settings.langfuse_screenshots, id="langfuse-screenshots"
                )

        with Section("Timing"):
            with HorizontalGroup(classes="field-row"):
                yield Label("Action Sleep", classes="field-label")
                yield Input(
                    value=str(self.settings.after_sleep_action),
                    placeholder="1.0",
                    id="after-sleep-action",
                    classes="field-input",
                )

            with HorizontalGroup(classes="field-row"):
                yield Label("UI Stable Wait", classes="field-label")
                yield Input(
                    value=str(self.settings.wait_for_stable_ui),
                    placeholder="0.3",
                    id="wait-for-stable-ui",
                    classes="field-input",
                )

    @on(Select.Changed, "#tracing-provider")
    def _on_provider_changed(self, event: Select.Changed) -> None:
        is_langfuse = str(event.value) == "langfuse"
        for row_id in (
            "row-langfuse-host",
            "row-langfuse-pk",
            "row-langfuse-sk",
            "row-langfuse-screenshots",
        ):
            row = self.query_one(f"#{row_id}")
            if is_langfuse:
                row.remove_class("hidden-field")
            else:
                row.add_class("hidden-field")

    def collect(self) -> dict:
        """Collect current advanced settings."""
        after_sleep_str = self.query_one("#after-sleep-action", Input).value.strip()
        wait_stable_str = self.query_one("#wait-for-stable-ui", Input).value.strip()
        try:
            after_sleep = float(after_sleep_str)
        except (ValueError, TypeError):
            after_sleep = 1.0
        try:
            wait_stable = float(wait_stable_str)
        except (ValueError, TypeError):
            wait_stable = 0.3

        return {
            "use_tcp": self.query_one("#use-tcp", BoolToggle).value,
            "debug": self.query_one("#debug-logging", BoolToggle).value,
            "save_trajectory": self.query_one("#save-trajectory", BoolToggle).value,
            "trajectory_gifs": self.query_one("#trajectory-gifs", BoolToggle).value,
            "tracing_enabled": self.query_one("#tracing-enabled", BoolToggle).value,
            "tracing_provider": self.query_one("#tracing-provider", Select).value,
            "langfuse_host": self.query_one("#langfuse-host", Input).value.strip(),
            "langfuse_public_key": self.query_one("#langfuse-pk", Input).value.strip(),
            "langfuse_secret_key": self.query_one("#langfuse-sk", Input).value.strip(),
            "langfuse_screenshots": self.query_one(
                "#langfuse-screenshots", BoolToggle
            ).value,
            "after_sleep_action": after_sleep,
            "wait_for_stable_ui": wait_stable,
        }

```

`droidrun/cli/tui/settings/agent_tab.py`:

```py
"""Agent tab ‚Äî vision, max steps, per-agent prompt paths."""

from __future__ import annotations

from textual.app import ComposeResult
from textual.containers import HorizontalGroup, VerticalGroup
from textual.widgets import Input, Label

from droidrun.cli.tui.settings.data import AGENT_ROLES, SettingsData
from droidrun.cli.tui.settings.section import BoolToggle, Section


class AgentTab(VerticalGroup):
    """Content for the Agent tab pane."""

    def __init__(self, settings: SettingsData) -> None:
        super().__init__()
        self.settings = settings

    def compose(self) -> ComposeResult:
        with Section("Vision", hint="send screenshots to the LLM"):
            with HorizontalGroup(classes="field-row"):
                yield Label("Manager", classes="field-label")
                yield BoolToggle(
                    value=self.settings.manager_vision, id="vision-manager"
                )

            with HorizontalGroup(classes="field-row"):
                yield Label("Executor", classes="field-label")
                yield BoolToggle(
                    value=self.settings.executor_vision, id="vision-executor"
                )

            with HorizontalGroup(classes="field-row"):
                yield Label("Fast Agent", classes="field-label")
                yield BoolToggle(
                    value=self.settings.fast_agent_vision, id="vision-fast-agent"
                )

        with Section("Steps"):
            with HorizontalGroup(classes="field-row"):
                yield Label("Max Steps", classes="field-label")
                yield Input(
                    value=str(self.settings.max_steps),
                    id="max-steps",
                    classes="field-input",
                )

        with Section("Prompts", hint="system prompt path per agent"):
            for role in AGENT_ROLES:
                with HorizontalGroup(classes="field-row"):
                    yield Label(role.title(), classes="field-label")
                    yield Input(
                        value=self.settings.agent_prompts.get(role, ""),
                        id=f"prompt-{role}",
                        classes="field-input",
                    )

    def collect(self) -> dict:
        """Collect current agent settings."""
        return {
            "manager_vision": self.query_one("#vision-manager", BoolToggle).value,
            "executor_vision": self.query_one("#vision-executor", BoolToggle).value,
            "fast_agent_vision": self.query_one("#vision-fast-agent", BoolToggle).value,
            "max_steps": self.query_one("#max-steps", Input).value.strip(),
            "agent_prompts": {
                role: self.query_one(f"#prompt-{role}", Input).value.strip()
                for role in AGENT_ROLES
            },
        }

```

`droidrun/cli/tui/settings/data.py`:

```py
"""Settings data model for the TUI."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from droidrun.config_manager.config_manager import DroidrunConfig

from droidrun.config_manager.env_keys import load_env_keys, save_env_keys

PROVIDERS = [
    "GoogleGenAI",
    "OpenAI",
    "Anthropic",
    "Ollama",
    "OpenAILike",
]

AGENT_ROLES = ["manager", "executor", "fast_agent", "scripter"]

# Maps provider name to the env key slot used by save_env_keys/load_env_keys.
# Providers not listed here store their api_key in kwargs instead.
PROVIDER_ENV_KEY_SLOT: dict[str, str] = {
    "GoogleGenAI": "google",
    "OpenAI": "openai",
    "Anthropic": "anthropic",
}

# Which fields are relevant per provider.
PROVIDER_FIELDS: dict[str, dict[str, Any]] = {
    "GoogleGenAI": {"api_key": True, "base_url": False},
    "OpenAI": {"api_key": True, "base_url": False},
    "Anthropic": {"api_key": True, "base_url": False},
    "Ollama": {"api_key": False, "base_url": True},
    "OpenAILike": {"api_key": True, "base_url": True},
}


@dataclass
class ProfileSettings:
    """Full LLM profile for one agent role."""

    provider: str = "GoogleGenAI"
    model: str = "gemini-2.5-pro"
    temperature: float = 0.2
    api_key: str = ""
    base_url: str = ""
    kwargs: dict[str, str] = field(default_factory=dict)


@dataclass
class SettingsData:
    """All TUI settings in one object."""

    # Per-agent LLM profiles (the real config, no fake global)
    profiles: dict[str, ProfileSettings] = field(
        default_factory=lambda: {role: ProfileSettings() for role in AGENT_ROLES}
    )

    # Per-agent custom prompt paths
    agent_prompts: dict[str, str] = field(
        default_factory=lambda: {role: "" for role in AGENT_ROLES}
    )

    # Agent
    manager_vision: bool = True
    executor_vision: bool = False
    fast_agent_vision: bool = False
    max_steps: int = 15

    # Advanced
    use_tcp: bool = False
    debug: bool = False
    save_trajectory: bool = False
    trajectory_gifs: bool = True
    tracing_enabled: bool = False
    tracing_provider: str = "phoenix"

    # Langfuse
    langfuse_host: str = ""
    langfuse_public_key: str = ""
    langfuse_secret_key: str = ""
    langfuse_screenshots: bool = False

    # Timing
    after_sleep_action: float = 1.0
    wait_for_stable_ui: float = 0.3

    @classmethod
    def from_config(cls, config: DroidrunConfig) -> SettingsData:
        """Build settings from a loaded DroidrunConfig."""
        llm_profiles = config.llm_profiles or {}
        env_keys = load_env_keys()

        profiles: dict[str, ProfileSettings] = {}
        for role in AGENT_ROLES:
            lp = llm_profiles.get(role)
            if lp:
                # Determine API key source
                provider = lp.provider
                env_slot = PROVIDER_ENV_KEY_SLOT.get(provider)
                if env_slot:
                    api_key = env_keys.get(env_slot, "")
                elif provider == "OpenAILike":
                    api_key = lp.kwargs.get("api_key", "stub")
                else:
                    api_key = lp.kwargs.get("api_key", "")

                # Build kwargs without api_key (shown separately)
                kwargs = {k: str(v) for k, v in lp.kwargs.items() if k != "api_key"}

                profiles[role] = ProfileSettings(
                    provider=provider,
                    model=lp.model,
                    temperature=lp.temperature,
                    api_key=api_key,
                    base_url=lp.base_url or lp.api_base or "",
                    kwargs=kwargs,
                )
            else:
                profiles[role] = ProfileSettings()

        agent_prompts = {
            "manager": config.agent.manager.system_prompt,
            "executor": config.agent.executor.system_prompt,
            "fast_agent": config.agent.fast_agent.system_prompt,
            "scripter": config.agent.scripter.system_prompt,
        }

        return cls(
            profiles=profiles,
            agent_prompts=agent_prompts,
            manager_vision=config.agent.manager.vision,
            executor_vision=config.agent.executor.vision,
            fast_agent_vision=config.agent.fast_agent.vision,
            max_steps=config.agent.max_steps,
            use_tcp=config.device.use_tcp,
            debug=config.logging.debug,
            save_trajectory=config.logging.save_trajectory != "none",
            trajectory_gifs=config.logging.trajectory_gifs,
            tracing_enabled=config.tracing.enabled,
            tracing_provider=config.tracing.provider,
            langfuse_host=config.tracing.langfuse_host,
            langfuse_public_key=config.tracing.langfuse_public_key,
            langfuse_secret_key=config.tracing.langfuse_secret_key,
            langfuse_screenshots=config.tracing.langfuse_screenshots,
            after_sleep_action=config.agent.after_sleep_action,
            wait_for_stable_ui=config.agent.wait_for_stable_ui,
        )

    def save(self) -> None:
        """Persist all settings: API keys to .env and config to config.yaml."""
        from droidrun.config_manager.loader import ConfigLoader

        # Save env-based API keys for all cloud providers that have a key set
        env_keys: dict[str, str] = {}
        for role, profile in self.profiles.items():
            env_slot = PROVIDER_ENV_KEY_SLOT.get(profile.provider)
            if env_slot and profile.api_key:
                env_keys[env_slot] = profile.api_key
        if env_keys:
            save_env_keys(env_keys)

        try:
            config = ConfigLoader.load()
        except Exception:
            from droidrun.config_manager.config_manager import DroidrunConfig

            config = DroidrunConfig()

        self.apply_to_config(config)
        ConfigLoader.save(config)

    @staticmethod
    def _build_kwargs(ps: ProfileSettings) -> dict[str, Any]:
        """Parse kwargs string values to typed values and inject api_key for OpenAILike."""
        parsed: dict[str, Any] = {}
        for k, v in ps.kwargs.items():
            if not k:
                continue
            try:
                parsed[k] = int(v)
            except ValueError:
                try:
                    parsed[k] = float(v)
                except ValueError:
                    parsed[k] = v
        if ps.provider == "OpenAILike":
            parsed["api_key"] = ps.api_key or "stub"
        return parsed

    @staticmethod
    def _apply_profile_to_llm(
        ps: ProfileSettings, cp: Any, update_model: bool = True
    ) -> None:
        """Write a ProfileSettings onto an LLMProfile config object."""
        cp.provider = ps.provider
        if update_model:
            cp.model = ps.model
        cp.temperature = ps.temperature
        if ps.base_url:
            cp.base_url = ps.base_url
            if ps.provider == "OpenAILike":
                cp.api_base = ps.base_url
        else:
            cp.base_url = None
            cp.api_base = None
        cp.kwargs = SettingsData._build_kwargs(ps)

    def apply_to_config(self, config: DroidrunConfig) -> None:
        """Apply all TUI settings onto a DroidrunConfig, in place."""
        for role, ps in self.profiles.items():
            if role not in config.llm_profiles:
                continue
            self._apply_profile_to_llm(ps, config.llm_profiles[role])

        # Propagate fast_agent settings to hidden roles (text_manipulator, app_opener, structured_output)
        # keeping their existing model (these are usually lighter models)
        fast_agent_ps = self.profiles.get("fast_agent")
        if fast_agent_ps:
            for hidden_role in ("text_manipulator", "app_opener", "structured_output"):
                if hidden_role in config.llm_profiles:
                    self._apply_profile_to_llm(
                        fast_agent_ps,
                        config.llm_profiles[hidden_role],
                        update_model=False,
                    )

        # Per-agent prompt paths
        prompt = self.agent_prompts.get("manager", "")
        if prompt:
            config.agent.manager.system_prompt = prompt
        prompt = self.agent_prompts.get("executor", "")
        if prompt:
            config.agent.executor.system_prompt = prompt
        prompt = self.agent_prompts.get("fast_agent", "")
        if prompt:
            config.agent.fast_agent.system_prompt = prompt
        prompt = self.agent_prompts.get("scripter", "")
        if prompt:
            config.agent.scripter.system_prompt = prompt

        # Agent
        config.agent.max_steps = self.max_steps
        config.agent.manager.vision = self.manager_vision
        config.agent.executor.vision = self.executor_vision
        config.agent.fast_agent.vision = self.fast_agent_vision

        # Device
        config.device.use_tcp = self.use_tcp

        # Logging
        config.logging.debug = self.debug
        config.logging.save_trajectory = "action" if self.save_trajectory else "none"
        config.logging.trajectory_gifs = self.trajectory_gifs

        # Tracing
        config.tracing.enabled = self.tracing_enabled
        config.tracing.provider = self.tracing_provider
        config.tracing.langfuse_host = self.langfuse_host
        config.tracing.langfuse_public_key = self.langfuse_public_key
        config.tracing.langfuse_secret_key = self.langfuse_secret_key
        config.tracing.langfuse_screenshots = self.langfuse_screenshots

        # Timing
        config.agent.after_sleep_action = self.after_sleep_action
        config.agent.wait_for_stable_ui = self.wait_for_stable_ui

```

`droidrun/cli/tui/settings/models_tab.py`:

```py
"""Models tab ‚Äî per-agent LLM profile cards with apply-to-all."""

from __future__ import annotations

from textual.app import ComposeResult
from textual.containers import HorizontalGroup, VerticalGroup
from textual.widgets import Button, Input, Label, Select, Static
from textual import on

from droidrun.cli.tui.settings.data import (
    AGENT_ROLES,
    PROVIDER_FIELDS,
    PROVIDERS,
    ProfileSettings,
    SettingsData,
)
from droidrun.cli.tui.settings.section import Section


PROVIDER_OPTIONS = [(p, p) for p in PROVIDERS]


class _KwargsRow(HorizontalGroup):
    """A single key-value pair row with a remove button."""

    CSS_PATH = "../css/models_tab.tcss"

    def __init__(self, key: str, value: str, row_id: str) -> None:
        super().__init__()
        self._key = key
        self._value = value
        self._row_id = row_id

    def compose(self) -> ComposeResult:
        yield Input(
            value=self._key,
            placeholder="key",
            classes="kwarg-key",
            id=f"kk-{self._row_id}",
        )
        yield Input(value=self._value, placeholder="value", id=f"kv-{self._row_id}")
        yield Button("√ó", id=f"kr-{self._row_id}")


class _KwargsEditor(VerticalGroup):
    """Editable key-value pair list."""

    CSS_PATH = "../css/models_tab.tcss"

    def __init__(self, kwargs: dict[str, str], role: str) -> None:
        super().__init__()
        self._kwargs = kwargs
        self._role = role
        self._counter = 0

    def compose(self) -> ComposeResult:
        for key, value in self._kwargs.items():
            rid = f"{self._role}-{self._counter}"
            self._counter += 1
            yield _KwargsRow(key, value, rid)
        yield Button("+ add", classes="kwargs-add-btn", id=f"kwargs-add-{self._role}")

    def on_button_pressed(self, event: Button.Pressed) -> None:
        btn_id = event.button.id or ""
        if btn_id == f"kwargs-add-{self._role}":
            event.stop()
            rid = f"{self._role}-{self._counter}"
            self._counter += 1
            self.mount(_KwargsRow("", "", rid), before=event.button)
        elif btn_id.startswith("kr-"):
            event.stop()
            row = event.button.parent
            if row:
                row.remove()

    def collect(self) -> dict[str, str]:
        result: dict[str, str] = {}
        for row in self.query(_KwargsRow):
            key_input = row.query("Input.kwarg-key")
            val_input = row.query("Input:not(.kwarg-key)")
            if key_input and val_input:
                k = key_input.first().value.strip()
                v = val_input.first().value.strip()
                if k:
                    result[k] = v
        return result


class _ProfileCard(Section):
    """Full LLM config card for one agent role."""

    CSS_PATH = "../css/models_tab.tcss"

    def __init__(self, role: str, profile: ProfileSettings) -> None:
        super().__init__(title=role.title())
        self._role = role
        self._profile = profile

    def compose(self) -> ComposeResult:
        if self._role == "manager":
            yield Button("Apply to all", id="apply-all-btn")

        pf = PROVIDER_FIELDS.get(self._profile.provider, {})

        with VerticalGroup(classes="profile-fields"):
            with HorizontalGroup(classes="field-row"):
                yield Label("Provider", classes="field-label")
                yield Select(
                    PROVIDER_OPTIONS,
                    value=self._profile.provider,
                    allow_blank=False,
                    id=f"provider-{self._role}",
                    classes="field-select",
                )

            with HorizontalGroup(classes="field-row"):
                yield Label("Model", classes="field-label")
                yield Input(
                    value=self._profile.model,
                    id=f"model-{self._role}",
                    classes="field-input",
                )

            api_key_cls = "field-row" if pf.get("api_key") else "field-row hidden-field"
            with HorizontalGroup(classes=api_key_cls, id=f"row-apikey-{self._role}"):
                yield Label("API Key", classes="field-label")
                yield Input(
                    value=self._profile.api_key,
                    password=True,
                    id=f"apikey-{self._role}",
                    classes="field-input",
                )

            url_cls = "field-row" if pf.get("base_url") else "field-row hidden-field"
            with HorizontalGroup(classes=url_cls, id=f"row-baseurl-{self._role}"):
                yield Label("Base URL", classes="field-label")
                yield Input(
                    value=self._profile.base_url,
                    placeholder="http://localhost:11434",
                    id=f"baseurl-{self._role}",
                    classes="field-input",
                )

            with HorizontalGroup(classes="field-row"):
                yield Label("Temperature", classes="field-label")
                yield Input(
                    value=str(self._profile.temperature),
                    id=f"temp-{self._role}",
                    classes="field-input",
                )

        yield Static("extra parameters", classes="kwargs-label")
        yield _KwargsEditor(self._profile.kwargs, self._role)

    @on(Select.Changed)
    def _on_provider_changed(self, event: Select.Changed) -> None:
        if event.select.id != f"provider-{self._role}":
            return
        provider = str(event.value)
        pf = PROVIDER_FIELDS.get(provider, {})

        api_row = self.query_one(f"#row-apikey-{self._role}")
        url_row = self.query_one(f"#row-baseurl-{self._role}")

        if pf.get("api_key"):
            api_row.remove_class("hidden-field")
        else:
            api_row.add_class("hidden-field")

        if pf.get("base_url"):
            url_row.remove_class("hidden-field")
        else:
            url_row.add_class("hidden-field")

    def collect(self) -> ProfileSettings:
        provider = str(self.query_one(f"#provider-{self._role}", Select).value)
        model = self.query_one(f"#model-{self._role}", Input).value.strip()
        api_key = self.query_one(f"#apikey-{self._role}", Input).value.strip()
        base_url = self.query_one(f"#baseurl-{self._role}", Input).value.strip()
        temp_str = self.query_one(f"#temp-{self._role}", Input).value.strip()
        try:
            temperature = float(temp_str)
        except (ValueError, TypeError):
            temperature = 0.2
        kwargs = self.query_one(_KwargsEditor).collect()
        return ProfileSettings(
            provider=provider,
            model=model,
            temperature=temperature,
            api_key=api_key,
            base_url=base_url,
            kwargs=kwargs,
        )


class ModelsTab(VerticalGroup):
    """Content for the Models tab pane ‚Äî per-agent profile cards."""

    CSS_PATH = "../css/models_tab.tcss"

    def __init__(self, settings: SettingsData) -> None:
        super().__init__()
        self.settings = settings

    def compose(self) -> ComposeResult:
        for role in AGENT_ROLES:
            profile = self.settings.profiles.get(role, ProfileSettings())
            yield _ProfileCard(role, profile)

    def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "apply-all-btn":
            event.stop()
            self._apply_first_to_all()

    def _apply_first_to_all(self) -> None:
        """Copy the first profile card's values to all other cards."""
        cards = list(self.query(_ProfileCard))
        if len(cards) < 2:
            return
        source = cards[0].collect()
        for card in cards[1:]:
            card.query_one(f"#provider-{card._role}", Select).value = source.provider
            card.query_one(f"#model-{card._role}", Input).value = source.model
            card.query_one(f"#apikey-{card._role}", Input).value = source.api_key
            card.query_one(f"#baseurl-{card._role}", Input).value = source.base_url
            card.query_one(f"#temp-{card._role}", Input).value = str(source.temperature)
            # Trigger field visibility update
            pf = PROVIDER_FIELDS.get(source.provider, {})
            api_row = card.query_one(f"#row-apikey-{card._role}")
            url_row = card.query_one(f"#row-baseurl-{card._role}")
            if pf.get("api_key"):
                api_row.remove_class("hidden-field")
            else:
                api_row.add_class("hidden-field")
            if pf.get("base_url"):
                url_row.remove_class("hidden-field")
            else:
                url_row.add_class("hidden-field")

    def collect(self) -> dict[str, ProfileSettings]:
        result: dict[str, ProfileSettings] = {}
        for card in self.query(_ProfileCard):
            result[card._role] = card.collect()
        return result

```

`droidrun/cli/tui/settings/section.py`:

```py
"""Reusable widgets for settings tabs."""

from __future__ import annotations

from textual.containers import VerticalGroup
from textual.reactive import reactive
from textual.widgets import Static


class Section(VerticalGroup):
    """A visually grouped section with a border title."""

    def __init__(
        self,
        title: str,
        hint: str = "",
        *children,
        **kwargs,
    ) -> None:
        super().__init__(*children, **kwargs)
        self.border_title = title
        if hint:
            self.border_subtitle = hint


class BoolToggle(Static):
    """A clickable true/false toggle."""

    value: reactive[bool] = reactive(False)

    def __init__(self, value: bool = False, **kwargs) -> None:
        super().__init__(**kwargs)
        self.value = value

    def render(self) -> str:
        return "‚óè true" if self.value else "‚óã false"

    def on_click(self) -> None:
        self.value = not self.value

    def watch_value(self, value: bool) -> None:
        if value:
            self.add_class("-on")
        else:
            self.remove_class("-on")

    def on_mount(self) -> None:
        if self.value:
            self.add_class("-on")

```

`droidrun/cli/tui/settings/settings_screen.py`:

```py
"""Main settings modal screen with tabbed navigation."""

from __future__ import annotations

from textual.app import ComposeResult
from textual.containers import HorizontalGroup, Vertical
from textual.screen import ModalScreen
from textual.widgets import Button, TabbedContent, TabPane

from droidrun.cli.tui.settings.agent_tab import AgentTab
from droidrun.cli.tui.settings.advanced_tab import AdvancedTab
from droidrun.cli.tui.settings.data import SettingsData
from droidrun.cli.tui.settings.models_tab import ModelsTab


class SettingsScreen(ModalScreen[SettingsData | None]):
    """Tabbed settings modal."""

    CSS_PATH = "../css/settings_screen.tcss"

    BINDINGS = [
        ("escape", "cancel", "Close"),
        ("ctrl+c", "handle_ctrl_c", "Quit"),
    ]

    def __init__(self, settings: SettingsData) -> None:
        super().__init__()
        self._settings = settings

    def compose(self) -> ComposeResult:
        with Vertical(id="settings-dialog"):
            with TabbedContent(id="settings-tabs"):
                with TabPane("Models", id="tab-models"):
                    yield ModelsTab(self._settings)
                with TabPane("Agent", id="tab-agent"):
                    yield AgentTab(self._settings)
                with TabPane("Advanced", id="tab-advanced"):
                    yield AdvancedTab(self._settings)

            with HorizontalGroup(id="settings-buttons"):
                yield Button("Save", variant="success", id="settings-save-btn")
                yield Button("Cancel", variant="default", id="settings-cancel-btn")

    def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "settings-save-btn":
            self.dismiss(self._collect())
        elif event.button.id == "settings-cancel-btn":
            self.dismiss(None)

    def action_cancel(self) -> None:
        self.dismiss(None)

    def action_handle_ctrl_c(self) -> None:
        self.app.action_handle_ctrl_c()

    def _collect(self) -> SettingsData:
        """Collect all tab values into a SettingsData."""
        profiles = self.query_one(ModelsTab).collect()
        agent = self.query_one(AgentTab).collect()
        advanced = self.query_one(AdvancedTab).collect()

        try:
            max_steps = int(agent["max_steps"])
        except (ValueError, TypeError):
            max_steps = self._settings.max_steps

        return SettingsData(
            profiles=profiles,
            agent_prompts=agent.get("agent_prompts", {}),
            manager_vision=agent["manager_vision"],
            executor_vision=agent["executor_vision"],
            fast_agent_vision=agent["fast_agent_vision"],
            max_steps=max_steps,
            use_tcp=advanced["use_tcp"],
            debug=advanced["debug"],
            save_trajectory=advanced["save_trajectory"],
            trajectory_gifs=advanced["trajectory_gifs"],
            tracing_enabled=advanced["tracing_enabled"],
            tracing_provider=advanced["tracing_provider"],
            langfuse_host=advanced["langfuse_host"],
            langfuse_public_key=advanced["langfuse_public_key"],
            langfuse_secret_key=advanced["langfuse_secret_key"],
            langfuse_screenshots=advanced["langfuse_screenshots"],
            after_sleep_action=advanced["after_sleep_action"],
            wait_for_stable_ui=advanced["wait_for_stable_ui"],
        )

```

`droidrun/cli/tui/widgets/__init__.py`:

```py
from droidrun.cli.tui.widgets.input_bar import InputBar
from droidrun.cli.tui.widgets.command_dropdown import CommandDropdown
from droidrun.cli.tui.widgets.device_picker import DevicePicker
from droidrun.cli.tui.widgets.log_view import LogView
from droidrun.cli.tui.widgets.status_bar import StatusBar

__all__ = ["InputBar", "CommandDropdown", "DevicePicker", "LogView", "StatusBar"]

```

`droidrun/cli/tui/widgets/command_dropdown.py`:

```py
"""Dropdown widget for slash command selection."""

from __future__ import annotations

from textual.widget import Widget
from textual.message import Message
from textual.app import RenderResult
from textual.reactive import reactive
from rich.text import Text

from droidrun.cli.tui.commands import Command


class CommandDropdown(Widget):
    can_focus = False

    class Selected(Message):
        def __init__(self, command_name: str) -> None:
            super().__init__()
            self.command_name = command_name

    highlighted: reactive[int] = reactive(0)

    def __init__(self, **kwargs) -> None:
        super().__init__(**kwargs)
        self._commands: list[Command] = []

    def update_commands(self, commands: list[Command]) -> None:
        self._commands = commands
        self.highlighted = 0
        self.refresh()

    def move_highlight(self, direction: int) -> None:
        if not self._commands:
            return
        new_idx = self.highlighted + direction
        self.highlighted = max(0, min(new_idx, len(self._commands) - 1))

    def select_highlighted(self) -> None:
        if self._commands and 0 <= self.highlighted < len(self._commands):
            cmd = self._commands[self.highlighted]
            self.post_message(self.Selected(cmd.name))

    @property
    def has_commands(self) -> bool:
        return bool(self._commands)

    def render(self) -> RenderResult:
        if not self._commands:
            return Text()

        # Compute column width from longest command name
        name_width = max(len(c.name) for c in self._commands) + 2
        try:
            total_width = self.size.width - 4  # account for padding
        except Exception:
            total_width = 60

        output = Text()
        for i, cmd in enumerate(self._commands):
            if i > 0:
                output.append("\n")

            is_highlighted = i == self.highlighted
            bg = " on #2e2e4a" if is_highlighted else ""
            name_style = f"bold #CAD3F6{bg}"
            desc_style = f"#838BBC{bg}" if not is_highlighted else f"#CAD3F6{bg}"
            slash_style = f"#47475e{bg}" if not is_highlighted else f"#838BBC{bg}"

            line_content = f"/{cmd.name:<{name_width}}{cmd.description}"
            pad = max(0, total_width - len(line_content) - 1)

            output.append(" /", style=slash_style)
            output.append(f"{cmd.name:<{name_width}}", style=name_style)
            output.append(cmd.description, style=desc_style)
            if is_highlighted:
                output.append(" " * pad, style=f"{bg}")

        return output

```

`droidrun/cli/tui/widgets/device_picker.py`:

```py
"""Inline device picker widget ‚Äî keyboard-driven, shown above input bar."""

from __future__ import annotations

from textual.widget import Widget
from textual.message import Message
from textual.app import RenderResult
from textual.reactive import reactive
from textual import events
from rich.text import Text


class DevicePicker(Widget):
    """Inline picker for devices and setup prompts.

    Modes:
        pick    ‚Äî arrow keys navigate device list, enter selects
        options ‚Äî arrow keys navigate action options, enter selects
        status  ‚Äî non-interactive text (e.g. "scanning...")
    """

    can_focus = True

    class DeviceSelected(Message):
        def __init__(self, serial: str) -> None:
            super().__init__()
            self.serial = serial

    class OptionSelected(Message):
        def __init__(self, serial: str, option_id: str) -> None:
            super().__init__()
            self.serial = serial
            self.option_id = option_id

    class Cancelled(Message):
        pass

    highlighted: reactive[int] = reactive(0)

    def __init__(self, **kwargs) -> None:
        super().__init__(**kwargs)
        self._devices: list[tuple[str, str]] = []  # (serial, state)
        self._mode: str = "pick"  # pick | options | status
        self._status_text: str = ""
        self._options_serial: str = ""
        self._options_header: str = ""
        self._options: list[tuple[str, str]] = []  # (option_id, label)
        self._options_highlighted: int = 0

    # ‚îÄ‚îÄ Public API ‚îÄ‚îÄ

    def set_devices(self, devices: list[tuple[str, str]]) -> None:
        self._devices = devices
        self._mode = "pick"
        self.highlighted = 0
        self.refresh(layout=True)

    def set_status(self, text: str) -> None:
        self._mode = "status"
        self._status_text = text
        self.refresh(layout=True)

    def set_options(
        self,
        serial: str,
        header: str,
        options: list[tuple[str, str]],
    ) -> None:
        """Show a list of selectable options.

        Args:
            serial: Device serial this relates to.
            header: Text shown above the options (e.g. error message).
            options: List of (option_id, label) tuples.
        """
        self._mode = "options"
        self._options_serial = serial
        self._options_header = header
        self._options = options
        self._options_highlighted = 0
        self.refresh(layout=True)
        self.set_timer(0.05, self.focus)

    @property
    def has_devices(self) -> bool:
        return bool(self._devices)

    # ‚îÄ‚îÄ Keyboard ‚îÄ‚îÄ

    def on_key(self, event: events.Key) -> None:
        if self._mode == "pick":
            self._handle_pick_key(event)
        elif self._mode == "options":
            self._handle_options_key(event)
        elif self._mode == "status":
            if event.key == "escape":
                event.stop()
                event.prevent_default()
                self.post_message(self.Cancelled())

    def _handle_pick_key(self, event: events.Key) -> None:
        if event.key == "up":
            event.stop()
            event.prevent_default()
            self.highlighted = max(0, self.highlighted - 1)
        elif event.key == "down":
            event.stop()
            event.prevent_default()
            self.highlighted = min(len(self._devices) - 1, self.highlighted + 1)
        elif event.key == "enter":
            event.stop()
            event.prevent_default()
            if self._devices:
                serial = self._devices[self.highlighted][0]
                self.post_message(self.DeviceSelected(serial))
        elif event.key == "escape":
            event.stop()
            event.prevent_default()
            self.post_message(self.Cancelled())

    def _handle_options_key(self, event: events.Key) -> None:
        if event.key == "up":
            event.stop()
            event.prevent_default()
            self._options_highlighted = max(0, self._options_highlighted - 1)
            self.refresh(layout=True)
        elif event.key == "down":
            event.stop()
            event.prevent_default()
            self._options_highlighted = min(
                len(self._options) - 1, self._options_highlighted + 1
            )
            self.refresh(layout=True)
        elif event.key == "enter":
            event.stop()
            event.prevent_default()
            if self._options:
                option_id, _ = self._options[self._options_highlighted]
                self.post_message(self.OptionSelected(self._options_serial, option_id))
        elif event.key == "escape":
            event.stop()
            event.prevent_default()
            # Back to pick mode if we have devices, otherwise cancel
            if self._devices:
                self._mode = "pick"
                self.refresh(layout=True)
            else:
                self.post_message(self.Cancelled())

    # ‚îÄ‚îÄ Render ‚îÄ‚îÄ

    def render(self) -> RenderResult:
        if self._mode == "status":
            return self._render_status()
        if self._mode == "options":
            return self._render_options()
        return self._render_pick()

    def _render_status(self) -> Text:
        return Text(f"  {self._status_text}", style="#52525b")

    def _render_pick(self) -> Text:
        if not self._devices:
            return Text("  no devices found", style="#52525b")

        try:
            total_width = self.size.width - 4
        except Exception:
            total_width = 60

        out = Text()
        for i, (serial, state) in enumerate(self._devices):
            if i > 0:
                out.append("\n")

            hl = i == self.highlighted
            bg = " on #2e2e4a" if hl else ""
            serial_style = f"bold #CAD3F6{bg}"
            state_style = f"#838BBC{bg}" if not hl else f"#a6da95{bg}"

            label = f"  {serial}  ({state})"
            pad = max(0, total_width - len(label))
            out.append(f"  {serial}", style=serial_style)
            out.append(f"  ({state})", style=state_style)
            if hl:
                out.append(" " * pad, style=bg)

        return out

    def _render_options(self) -> Text:
        try:
            total_width = self.size.width - 4
        except Exception:
            total_width = 60

        out = Text()

        # Header (error / info text)
        if self._options_header:
            out.append(f"  {self._options_header}\n", style="#ed8796")
            out.append("\n")

        # Option list
        for i, (_, label) in enumerate(self._options):
            if i > 0:
                out.append("\n")

            hl = i == self._options_highlighted
            bg = " on #2e2e4a" if hl else ""
            label_style = f"bold #CAD3F6{bg}" if hl else f"#838BBC{bg}"

            display = f"  {label}"
            pad = max(0, total_width - len(display))
            out.append(display, style=label_style)
            if hl:
                out.append(" " * pad, style=bg)

        return out

```

`droidrun/cli/tui/widgets/input_bar.py`:

```py
"""Custom input widget with command history and slash detection."""

from __future__ import annotations

from textual.widgets import Input
from textual.message import Message
from textual import events


class InputBar(Input):

    class Submitted(Message):
        def __init__(self, value: str) -> None:
            super().__init__()
            self.value = value

    class SlashChanged(Message):
        def __init__(self, query: str) -> None:
            super().__init__()
            self.query = query

    class SlashExited(Message):
        pass

    class SlashSelect(Message):
        """Enter pressed while dropdown is visible."""

        pass

    class SlashNavigate(Message):
        """Up/Down pressed while dropdown is visible."""

        def __init__(self, direction: int) -> None:
            super().__init__()
            self.direction = direction

    class TabPressed(Message):
        pass

    def __init__(self, **kwargs) -> None:
        super().__init__(**kwargs)
        self._history: list[str] = []
        self._history_index: int = -1
        self._was_slash: bool = False
        self.slash_mode: bool = False

    @property
    def history(self) -> list[str]:
        return list(self._history)

    def _on_key(self, event: events.Key) -> None:
        if event.key == "tab":
            event.prevent_default()
            event.stop()
            self.post_message(self.TabPressed())
            return

        if self.slash_mode:
            if event.key == "enter":
                event.prevent_default()
                event.stop()
                self.post_message(self.SlashSelect())
                return
            elif event.key in ("up", "down"):
                event.prevent_default()
                event.stop()
                direction = -1 if event.key == "up" else 1
                self.post_message(self.SlashNavigate(direction))
                return

        if event.key == "up":
            event.prevent_default()
            event.stop()
            self._navigate_history(-1)
            return
        elif event.key == "down":
            event.prevent_default()
            event.stop()
            self._navigate_history(1)
            return
        elif event.key == "enter":
            event.prevent_default()
            event.stop()
            self._submit()
            return

        super()._on_key(event)

    def _navigate_history(self, direction: int) -> None:
        if not self._history:
            return

        if direction == -1:
            if self._history_index == -1:
                self._history_index = len(self._history) - 1
            elif self._history_index > 0:
                self._history_index -= 1
            else:
                return
        else:
            if self._history_index == -1:
                return
            elif self._history_index < len(self._history) - 1:
                self._history_index += 1
            else:
                self._history_index = -1
                self.value = ""
                return

        self.value = self._history[self._history_index]
        self.cursor_position = len(self.value)

    def _submit(self) -> None:
        text = self.value.strip()
        if not text:
            return

        if not self._history or self._history[-1] != text:
            self._history.append(text)
        self._history_index = -1

        self.post_message(self.Submitted(text))
        self.value = ""

    def watch_value(self, value: str) -> None:
        is_slash = value.startswith("/")

        if is_slash:
            query = value[1:]
            self.post_message(self.SlashChanged(query))
            self._was_slash = True
        elif self._was_slash:
            self.post_message(self.SlashExited())
            self._was_slash = False

    def clear_input(self) -> None:
        self.value = ""
        self._history_index = -1

```

`droidrun/cli/tui/widgets/log_view.py`:

```py
"""Styled log view built on RichLog."""

from __future__ import annotations

from collections import deque

from textual.widgets import RichLog
from rich.text import Text

MAX_LOG_LINES = 10_000


class LogView(RichLog):
    """Colored log view with plain-text copy support.

    Uses RichLog for Rich-styled output (colored lines).
    Maintains a parallel plain-text buffer for clipboard copy.
    """

    ALLOW_SELECT = False

    def __init__(self, **kwargs) -> None:
        super().__init__(
            wrap=True,
            markup=False,
            auto_scroll=True,
            max_lines=MAX_LOG_LINES,
            **kwargs,
        )
        self._plain_lines: deque[str] = deque(maxlen=MAX_LOG_LINES)

    def append(self, line: str, style: str | None = None) -> None:
        """Append a line of text with optional color style."""
        text = Text(line)
        if style:
            text.stylize(style)
        self.write(text)
        self._plain_lines.append(line)

    def clear_log(self) -> None:
        """Clear all log content."""
        self.clear()
        self._plain_lines.clear()

    def get_plain_text(self) -> str:
        """Return all log content as plain text for clipboard."""
        return "\n".join(self._plain_lines)

```

`droidrun/cli/tui/widgets/status_bar.py`:

```py
"""Status bar widget."""

from __future__ import annotations

from textual.reactive import reactive
from textual.widget import Widget
from textual.app import RenderResult
from rich.text import Text


class StatusBar(Widget):
    can_focus = False

    device_serial: reactive[str] = reactive("")
    device_connected: reactive[bool] = reactive(False)
    device_name: reactive[str] = reactive("no model")
    mode: reactive[str] = reactive("fast")
    is_running: reactive[bool] = reactive(False)
    hint: reactive[str] = reactive("")

    def render(self) -> RenderResult:
        bar = Text()

        # Device serial ‚Äî green=connected, yellow=serial set but not verified, red=no device
        if self.device_serial and self.device_connected:
            bar.append("\u25cf ", style="#a6da95")
            bar.append(self.device_serial, style="#a6da95")
        elif self.device_serial:
            bar.append("\u25cf ", style="#f5a97f")
            bar.append(self.device_serial, style="#f5a97f")
        else:
            bar.append("\u25cf ", style="#ed8796")
            bar.append("no device", style="#ed8796")

        bar.append("  \u2502  ", style="#2e2e4a")

        # Model name
        bar.append(self.device_name, style="#838BBC")

        bar.append("  \u2502  ", style="#2e2e4a")

        # Mode
        bar.append(self.mode, style="#CAD3F6")

        # Right-aligned hint
        if self.hint:
            try:
                width = self.size.width
                used = bar.cell_len
                gap = max(1, width - used - len(self.hint) - 2)
                bar.append(" " * gap)
                bar.append(self.hint, style="#47475e")
            except Exception:
                pass

        return bar

```

`droidrun/config/app_cards/README.md`:

```md
# App Cards

App cards provide app-specific guidance to DroidRun agents. They help agents understand how to operate specific apps more effectively.

## How It Works

1. **Mapping File**: `app_cards.json` maps Android package names to markdown files
2. **App Card Files**: Markdown files containing app-specific guidance
3. **Automatic Loading**: DroidRun automatically loads the appropriate app card based on the current package name
4. **Prompt Injection**: App cards are injected into agent prompts when available

## File Structure

```
config/app_cards/
‚îú‚îÄ‚îÄ app_cards.json       # Package name ‚Üí file mapping
‚îú‚îÄ‚îÄ gmail.md             # Gmail app card
‚îú‚îÄ‚îÄ chrome.md            # Chrome app card
‚îî‚îÄ‚îÄ social/              # Organize in subdirectories if needed
    ‚îî‚îÄ‚îÄ whatsapp.md
```

## Creating App Cards

### 1. Add entry to app_cards.json

```json
{
  "com.google.android.gm": "gmail.md",
  "com.android.chrome": "chrome.md",
  "com.whatsapp": "social/whatsapp.md"
}
```

### 2. Create the markdown file

Create a `.md` file with guidance about the app:

```markdown
# App Name Guide

## Navigation
- How to navigate the app
- Key screens and menus

## Common Actions
- List of common tasks
- How to perform them

## Tips
- App-specific tips
- Known issues or quirks
```

## Path Resolution

App cards support three path types:

1. **Relative to app_cards directory** (most common):
   ```json
   {"com.google.android.gm": "gmail.md"}
   ```
   Resolves to: `config/app_cards/gmail.md` (in package)

2. **Relative paths with PathResolver**:
   ```json
   {"com.google.gm": "config/custom_cards/gmail.md"}
   ```
   Checks working directory first, then package directory
   - Working dir: `./config/custom_cards/gmail.md`
   - Package dir: `<package>/config/custom_cards/gmail.md`

3. **Absolute path**:
   ```json
   {"com.google.gm": "/usr/share/droidrun/cards/gmail.md"}
   ```
   Uses the absolute path directly

## Finding Package Names

To find an app's package name:

1. **Using ADB**:
   ```bash
   adb shell pm list packages | grep keyword
   ```

2. **From device**:
   - Open the app
   - Run DroidRun with debug mode to see the current package name in logs

3. **Common apps**:
   - Gmail: `com.google.android.gm`
   - Chrome: `com.android.chrome`
   - WhatsApp: `com.whatsapp`
   - Instagram: `com.instagram.android`
   - Facebook: `com.facebook.katana`

## Configuration

Enable/disable app cards in `config.yaml`:

```yaml
agent:
  app_cards:
    enabled: true
    app_cards_dir: config/app_cards
```

## Best Practices

1. **Be Concise**: Keep app cards focused and actionable
2. **Use Examples**: Show concrete examples of common tasks
3. **Update Regularly**: Keep app cards current with app updates
4. **Test**: Verify that guidance actually helps agents
5. **Organize**: Use subdirectories for related apps (e.g., social/, banking/)

## Programmatic Usage

```python
from droidrun.config_manager import AppCardLoader, config

# Load app card for a package
app_card = AppCardLoader.load_app_card(
    package_name="com.google.android.gm",
    app_cards_dir=config.agent.app_cards.app_cards_dir
)

# Check if enabled
if config.agent.app_cards.enabled:
    print("App cards are enabled")

# Clear cache (useful for testing)
AppCardLoader.clear_cache()

# Get cache statistics
stats = AppCardLoader.get_cache_stats()
print(f"Cached entries: {stats['content_entries']}")
```

```

`droidrun/config/app_cards/app_cards.json`:

```json
{
  "com.google.android.gm": "gmail.md"
}

```

`droidrun/config/app_cards/gmail.md`:

```md
# Gmail App Guide

## Navigation
- Use the hamburger menu (top-left) to access folders (Inbox, Sent, Drafts, Trash, etc.)
- Tap the compose button (bottom-right floating action button) to write new emails
- Swipe left or right on emails to quickly archive or delete

## Search
- Use the search bar at the top to find emails
- Search supports filters like:
  - `from:sender@email.com` - Find emails from specific sender
  - `to:recipient@email.com` - Find emails to specific recipient
  - `subject:keyword` - Search in subject line
  - `has:attachment` - Find emails with attachments
  - `is:unread` - Find unread emails

## Common Actions
- **Archive**: Swipe right on an email in the list
- **Delete**: Swipe left on an email in the list
- **Select Multiple**: Long press on an email to enter selection mode
- **Star/Unstar**: Tap the star icon next to an email
- **Mark as Read/Unread**: Long press ‚Üí Select ‚Üí Tap the mark read/unread icon
- **Move to Folder**: Long press ‚Üí Select ‚Üí Tap the folder icon

## Composing Emails
- Tap the floating compose button (bottom-right)
- Fill in recipient, subject, and body
- Attach files by tapping the paperclip icon
- Send by tapping the send button (paper plane icon) in the top-right

## Tips
- Primary inbox shows important emails automatically
- Social and Promotions tabs filter promotional and social emails
- Enable notifications for important emails only
- Use labels to organize emails

```

`droidrun/config/credentials_example.yaml`:

```yaml
# Credentials Configuration Example
#
# This file shows how to configure secrets for DroidRun agents.
# Copy this file to config/credentials.yaml and add your actual secrets.
#
# SECURITY WARNING:
# - Add config/credentials.yaml to .gitignore (DO NOT commit secrets!)
# - Never share this file with actual passwords/API keys
# - Keep config/credentials.yaml out of version control

secrets:
  # === Dict Format (Recommended) ===
  # Provides fine-grained control with enabled/disabled flag

  MY_PASSWORD:
    value: "your_password_here"
    enabled: true  # Set to false to temporarily disable

  API_KEY:
    value: "your_api_key_here"
    enabled: true

  GMAIL_PASSWORD:
    value: "example_password"
    enabled: true

  # === Simple String Format ===
  # Automatically enabled when loaded

  SIMPLE_SECRET: "simple_value"
  ANOTHER_KEY: "another_value"

  # === Disabled Secret Example ===
  # Useful for temporarily disabling without deleting

  OLD_PASSWORD:
    value: "old_password_no_longer_used"
    enabled: false  # This secret will NOT be loaded

# === Usage in DroidRun ===
#
# 1. Enable in config.yaml:
#    credentials:
#      enabled: true
#      file_path: config/credentials.yaml
#
# 2. The agent can use the type_secret tool:
#    {"action": "type_secret", "secret_id": "MY_PASSWORD", "index": 5}
#
# 3. Or pass credentials programmatically:
#    agent = DroidAgent(
#        goal="login to app",
#        credentials={"PASSWORD": "secret123"}
#    )

# === Security Features ===
#
# - Secrets are NEVER logged or displayed in output
# - Error messages show secret IDs but never values
# - Access is logged: "üîë Accessing secret: 'MY_PASSWORD'"
# - The type_secret tool types secrets without exposing them
# - CredentialManager validates and sanitizes all inputs

# === File Format Notes ===
#
# Valid value types:
# - Strings (required)
# - Empty strings are filtered out
# - Whitespace-only values are filtered out
#
# Invalid value types (will be skipped with warning):
# - Integers
# - Booleans
# - null/None
# - Lists or nested objects

# === Example Secrets by Category ===

# App Passwords
# APP_PASSWORD: "your_app_password"
# BACKUP_PASSWORD: "your_backup_password"

# API Keys
# OPENAI_API_KEY: "sk-..."
# ANTHROPIC_API_KEY: "sk-ant-..."
# GOOGLE_API_KEY: "AIza..."

# Authentication Tokens
# BEARER_TOKEN: "eyJhbG..."
# REFRESH_TOKEN: "refresh_..."

# Database Credentials
# DB_PASSWORD: "database_password"
# DB_CONNECTION_STRING: "postgresql://..."

# Social Media
# TWITTER_PASSWORD: "twitter_pass"
# FACEBOOK_PASSWORD: "facebook_pass"

# Email
# EMAIL_PASSWORD: "email_password"
# IMAP_PASSWORD: "imap_password"

# Two-Factor Codes (for testing)
# TOTP_SECRET: "base32_secret"
# BACKUP_CODE: "123456789"

```

`droidrun/config/prompts/codeact/system.jinja2`:

```jinja2
You are a helpful AI assistant that can write and execute Python code to solve problems.

You will be given a task to perform. You should output:
- Python code wrapped in <python></python> tags that provides the solution to the task, or a step towards the solution.
- If there is a precondition for the task, you MUST check if it is met.
- If a goal's precondition is unmet, fail the task by calling `complete(success=False, reason='...')` with an explanation.
- If you task is complete, you should use the complete(success:bool, reason:str) function within a code block to mark it as finished. The success parameter should be True if the task was completed successfully, and False otherwise. The reason parameter should be a string explaining the reason for failure if failed.


## Context:
The following context is given to you for analysis:
- **ui_state**: A list of all currently visible UI elements with their indices. Use this to understand what interactive elements are available on the screen.
- **screenshots**: A visual screenshot of the current state of the Android screen. This provides visual context for what the user sees. screenshots won't be saved in the chat history. So, make sure to describe what you see and explain the key parts of your plan in your thoughts, as those will be saved and used to assist you in future steps.
- **phone_state**: The current app you are navigating in. This tells you which application context you're working within.
- **chat history**: You are also given the history of your actions (if any) from your previous steps.
- **execution result**: The result of your last Action
NOTE: you don't have access to these inputs in your tool calling context

## Response Format:
Example of proper code format:
**Task Assignment:**
**Task:** "Precondition: Settings app is open. Goal: Navigate to Wi-Fi settings and connect to the network 'HomeNetwork'."
{% if 'click' in available_tools %}

**(Step 1) Agent Analysis:** I can see the Settings app is open from the screenshot. This is a multi-step task that requires me to first navigate to Wi-Fi settings, then ensure Wi-Fi is enabled, and finally connect to 'HomeNetwork'. Let me start by finding and tapping on the Wi-Fi option in the settings menu. Looking at the UI elements, I can see "Wi-Fi" option at index 3.

**(Step 1) Agent Action:**
<python>
# First step: Navigate to Wi-Fi settings
click(3)
</python>

**(Step 2) Agent Analysis:** Good! I've successfully navigated to the Wi-Fi settings screen. Now I can see the Wi-Fi settings interface. I notice that Wi-Fi appears to be turned off based on the toggle switch at index 1. I need to turn it on before I can see available networks and connect to 'HomeNetwork'.

**(Step 2) Agent Action:**
<python>
# Second step: Turn on Wi-Fi to see available networks
click(1)
</python>

**(Step 3) Agent Analysis:** Excellent! Wi-Fi is now enabled and I can see a list of available networks appearing on the screen. I can see 'HomeNetwork' in the list at index 5. This is the final step - I need to tap on it to initiate the connection, which will complete my assigned task.

**(Step 3) Agent Action:**
<python>
# Final step: Connect to the target network
click(5)
complete(success=True, reason="Successfully navigated to Wi-Fi settings and initiated connection to HomeNetwork")
</python>
{% elif 'click_at' in available_tools %}

**(Step 1) Agent Analysis:** I can see the Settings app is open from the screenshot. This is a multi-step task that requires me to first navigate to Wi-Fi settings, then ensure Wi-Fi is enabled, and finally connect to 'HomeNetwork'. Let me start by finding and tapping on the Wi-Fi option. From the screenshot, I can see the "Wi-Fi" option is located at approximately (540, 350).

**(Step 1) Agent Action:**
<python>
# First step: Navigate to Wi-Fi settings (tap at coordinates)
click_at(540, 350)
</python>

**(Step 2) Agent Analysis:** Good! I've successfully navigated to the Wi-Fi settings screen. Now I can see the Wi-Fi settings interface. I notice that Wi-Fi appears to be turned off based on the toggle switch. The toggle is located at approximately (980, 200). I need to turn it on before I can see available networks.

**(Step 2) Agent Action:**
<python>
# Second step: Turn on Wi-Fi (tap toggle at coordinates)
click_at(980, 200)
</python>

**(Step 3) Agent Analysis:** Excellent! Wi-Fi is now enabled and I can see a list of available networks appearing on the screen. I can see 'HomeNetwork' in the list at approximately (540, 600). This is the final step - I need to tap on it to initiate the connection.

**(Step 3) Agent Action:**
<python>
# Final step: Connect to the target network (tap at coordinates)
click_at(540, 600)
complete(success=True, reason="Successfully navigated to Wi-Fi settings and initiated connection to HomeNetwork")
</python>
{% else %}

**(Step 1) Agent Analysis:** I can see the Settings app is open from the screenshot. I need to navigate to Wi-Fi settings. I'll use the available tools to interact with the UI elements.

**(Step 1) Agent Action:**
<python>
# Use available tools to navigate - check tool_descriptions above
</python>
{% endif %}

## Tools:
In addition to the Python Standard Library and any functions you have already written, you can use the following functions:
{{ tool_descriptions }}

{% if available_secrets %}

## Available Secrets:
The credential manager has the following secret IDs available for use with the `type_secret` function:
{% for secret_id in available_secrets %}
- {{ secret_id }}
{% endfor %}

Use `type_secret(secret_id, index)` to type these secrets into input fields without exposing their values.
{% endif %}

## Final Answer Guidelines:
- When providing a final answer, focus on directly answering the user's question in the response format given
- Present the results clearly and concisely as if you computed them directly
- Structure your response like you're directly answering the user's query, not explaining how you solved it

{% if output_schema %}

## Output Requirements:
**IMPORTANT:** When you call `complete(success, reason)` to mark this task as complete, include the following information in your `reason` parameter:

{{ output_schema.description if output_schema.description else "Information to collect:" }}

**Required data fields:**
{% for field_name, field_info in output_schema.properties.items() %}
- **{{ field_name }}**: {{ field_info.description if field_info.description else field_info.type }}{% if field_name in output_schema.get('required', []) %} (REQUIRED){% endif %}

{% endfor %}

**Important:**
- Collect ALL required data before calling complete()
- Include this information in the `reason` parameter in a natural, readable format
- Do NOT output JSON - present data as plain text
{% endif %}

Reminder: Always place your Python code between <python></python> tags when you want to run code.

```

`droidrun/config/prompts/codeact/tools_system.jinja2`:

```jinja2
You are Droidrun ‚Äî a sharp, clever agent that controls Android devices through tools. You've got a dry sense of humor and you read screens like a pro. Be concise.

You will be given a task to perform. You should:
1. Analyze the current device state and screenshot
2. Explain your reasoning
3. Call the appropriate tool(s) using the XML format below
4. If there is a precondition for the task, you MUST check if it is met.
5. If a goal's precondition is unmet, call `complete` with success=false and an explanation.
6. When the task is complete, call `complete` with success=true/false and a reason.

## Tool Call Format

To call a tool, wrap it in <function_calls> tags:

<function_calls>
<invoke name="TOOL_NAME">
<parameter name="PARAM_NAME">value</parameter>
</invoke>
</function_calls>

Multiple <invoke> blocks in one <function_calls> block are executed sequentially, in order.
{% if parallel_tools %}
Prefer combining actions in one block when targets are visible and won't move ‚Äî e.g. type into a field then tap a button on the same dialog. Use separate calls when an action may change the screen.
{% endif %}

## Context

The following context is given to you for analysis:
- **ui_state**: A list of all currently visible UI elements with their indices. Use this to understand what interactive elements are available on the screen.
{% if vision %}
- **screenshots**: A visual screenshot of the current screen. Screenshots aren't saved in history, so note key details you'll need later.
{%- endif %}
- **phone_state**: The current app you are navigating in. This tells you which application context you're working within.
- **chat history**: You are also given the history of your actions (if any) from your previous steps.
- **tool results**: The result of your last tool call

## Available Tools

{{ tool_descriptions }}

{% if available_secrets %}

## Available Secrets
The credential manager has the following secret IDs available for use with the `type_secret` function:
{% for secret_id in available_secrets %}
- {{ secret_id }}
{% endfor %}

Use `type_secret` to type these secrets into input fields without exposing their values.
{% endif %}

## Response Format

State what you'll do before making tool calls. Example:
{% if 'click' in available_tools %}
{% if parallel_tools %}

Settings is open. I need to tap Wi-Fi at index 3. This will navigate to a new screen.

<function_calls>
<invoke name="click">
<parameter name="index">3</parameter>
</invoke>
</function_calls>

The Wi-Fi password dialog is showing. The password field is at index 4 and Connect button at index 8. Both are on the same dialog so I'll type the password and connect in one go.

<function_calls>
<invoke name="type">
<parameter name="index">4</parameter>
<parameter name="text">MyPassword</parameter>
</invoke>
<invoke name="click">
<parameter name="index">8</parameter>
</invoke>
</function_calls>

Successfully connected to HomeNetwork.

<function_calls>
<invoke name="complete">
<parameter name="success">true</parameter>
<parameter name="message">Connected to HomeNetwork Wi-Fi network</parameter>
</invoke>
</function_calls>
{% else %}

I can see the Settings app is open. I need to tap on the Wi-Fi option which is at index 3 in the UI elements.

<function_calls>
<invoke name="click">
<parameter name="index">3</parameter>
</invoke>
</function_calls>

After receiving the result, continue reasoning and acting:

Wi-Fi settings are now open. I can see the toggle is off. I need to enable it by clicking the toggle at index 1.

<function_calls>
<invoke name="click">
<parameter name="index">1</parameter>
</invoke>
</function_calls>

When done:

<function_calls>
<invoke name="complete">
<parameter name="success">true</parameter>
<parameter name="message">Successfully enabled Wi-Fi in settings</parameter>
</invoke>
</function_calls>
{% endif %}
{% endif %}

## Important Rules
- State your intent before calling tools
{% if parallel_tools %}
- Batch multiple tool calls in one <function_calls> block when targets are visible and won't move. Use separate calls when an action may change the screen. After batching, verify the outcome from the updated state.
{% else %}
- Prefer one tool call per response so you can observe the result before acting again
{% endif %}
- Use `complete` to signal task completion (success or failure)
- Use `remember` to store important information for later steps

{% if output_schema %}

## Output Requirements
**IMPORTANT:** When you call `complete` to mark this task as complete, include the following information in your `reason` parameter:

{{ output_schema.description if output_schema.description else "Information to collect:" }}

**Required data fields:**
{% for field_name, field_info in output_schema.properties.items() %}
- **{{ field_name }}**: {{ field_info.description if field_info.description else field_info.type }}{% if field_name in output_schema.get('required', []) %} (REQUIRED){% endif %}

{% endfor %}

**Important:**
- Collect ALL required data before calling complete()
- Include this information in the `message` parameter in a natural, readable format
- Do NOT output JSON - present data as plain text
{% endif %}

```

`droidrun/config/prompts/codeact/tools_user.jinja2`:

```jinja2
**Current Request:**
{{ goal }}

**What is your reasoning and the next step to address this request?**
Explain your thought process then call the appropriate tool(s).

```

`droidrun/config/prompts/codeact/user.jinja2`:

```jinja2
**Current Request:**
{{ goal }}

**Is the precondition met? What is your reasoning and the next step to address this request?**
Explain your thought process then provide code in <python></python> tags if needed.

```

`droidrun/config/prompts/executor/rev1.jinja2`:

```jinja2
# Android Action Executor

You are an action executor. Your only job: execute the current subgoal exactly as written.

## Context

**User Request:** {{ instruction }}

{% if app_card %}
App card gives information on how to operate the app and perform actions.
**App Card:** {{ app_card }}

{% endif %}
{% if device_state %}
**Device State:** {{ device_state }}

{% endif %}
**Overall Plan:** {{ plan }}

**Current Subgoal:** {{ subgoal }}

**Progress:** {{ progress_status|default("No progress yet.") }}

**Recent Actions:**
{% if action_history %}
{% for action in action_history[-5:] %}
{% if action.outcome %}
- Action: {{ action.action }} | Description: {{ action.summary }} | Outcome: Successful
{% else %}
- Action: {{ action.action }} | Description: {{ action.summary }} | Outcome: Failed | Feedback: {{ action.error }}
{% endif %}
{% endfor %}
{% else %}
No actions have been taken yet.
{% endif %}

---

## Your Task

1. Read the current subgoal
2. Identify the action verb (tap, swipe, type, press, open)
3. Identify the target (button name, text, coordinates)
4. Execute that exact action

**Do not:**
- Answer questions
- Make decisions about what to do next
- Optimize or substitute actions
- Repeat failed actions more than once

---

## Action Reference

### Available Actions
{% for action_name, action_info in atomic_actions.items() %}
- {{ action_name }}({% for p, info in action_info.parameters.items() %}{{ p }}: {{ info.type }}{% if not info.get('required', True) %} = {{ info.get('default', 'None') }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}): {{ action_info.description }}
{% endfor %}

### Key Rules
- Close popups (permission requests) before proceeding
- Always activate input box (click it) before typing
- Use `open_app` to launch apps, not the app drawer
- Try different swipe directions if content doesn't change

---

## Output Format

### Thought ###
What action and target does the subgoal specify?

### Action ###
{"action": "action_name", "param_name": "value"}

### Description ###
One sentence describing the action you're taking.

```

`droidrun/config/prompts/executor/system.jinja2`:

```jinja2
You are a LOW-LEVEL ACTION EXECUTOR for an Android phone. You do NOT answer questions or provide results. You ONLY perform individual atomic actions as specified in the current subgoal. You are part of a larger system - your job is to execute actions, not to think about or answer the user's original question.

### User Request ###
{{ instruction }}

{% if app_card %}
App card gives information on how to operate the app and perform actions.
### App Card ###
{{ app_card }}

{% endif %}
{% if device_state %}
### Device State ###
{{ device_state }}

{% endif %}
### Overall Plan ###
{{ plan }}

### Current Subgoal ###
EXECUTE THIS SUBGOAL: {{ subgoal }}

EXECUTION MODE: You are a dumb robot. Find the exact text/element mentioned in the subgoal above and perform the specified action on it. Do not read anything below this line until after you execute the subgoal.

### SUBGOAL PARSING MODE ###
Read the current subgoal exactly as written. Look for:
- Action words: "tap", "click", "swipe", "type", "press", "open" etc.
- Target elements: specific text, buttons, fields, coordinates mentioned
- Locations: "header", "bottom", "left", "right", specific coordinates
Convert directly to atomic action:
- "tap/click" ‚Üí click action
- "swipe" ‚Üí swipe action
- "type" ‚Üí type action
- "press [system button]" ‚Üí system_button action
- "open [app]" ‚Üí open_app action
Execute the atomic action for the exact target mentioned. Ignore everything else.

### Progress Status ###
{{ progress_status|default("No progress yet.") }}

### Guidelines ###
General:
- For any pop-up window, such as a permission request, you need to close it (e.g., by clicking `Don't Allow` or `Accept & continue`) before proceeding. Never choose to add any account or log in.
Action Related:
- Use the `open_app` action whenever you want to open an app (nothing will happen if the app is not installed), do not use the app drawer to open an app.
- Consider exploring the screen by using the `swipe` action with different directions to reveal additional content. Or use search to quickly find a specific entry, if applicable.
- If you cannot change the page content by swiping in the same direction continuously, the page may have been swiped to the bottom. Please try another operation to display more content.
- For some horizontally distributed tags, you can swipe horizontally to view more.
Text Related Operations:
- Activated input box: If an input box is activated, it may have a cursor inside it and the keyboard is visible. If there is no cursor on the screen but the keyboard is visible, it may be because the cursor is blinking. The color of the activated input box will be highlighted. If you are not sure whether the input box is activated, click it before typing.
- To input some text: first click the input box that you want to input, make sure the correct input box is activated and the keyboard is visible, then use `type` action to enter the specified text.
- To clear the text: long press the backspace button in the keyboard.
- To copy some text: first long press the text you want to copy, then click the `copy` button in bar.
- To paste text into a text box: first long press the text box, then click the `paste` button in bar.

---
Execute the current subgoal mechanically. Do NOT examine the screen content or make decisions about what you see. Parse the current subgoal text to identify the required action and execute it exactly as written. You must choose your action from one of the atomic actions.

#### Atomic Actions ####
The atomic action functions are listed in the format of `action(parameters): description` as follows:
{% for action_name, action_info in atomic_actions.items() %}
- {{ action_name }}({% for p, info in action_info.parameters.items() %}{{ p }}: {{ info.type }}{% if not info.get('required', True) %} = {{ info.get('default', 'None') }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}): {{ action_info.description }}
{% endfor %}

{% if available_secrets %}

#### Available Secrets ####
The following secret IDs are available for use with the type_secret action:
{% for secret_id in available_secrets %}
- {{ secret_id }}
{% endfor %}

When the current subgoal requires typing a secret (password, API key, etc.), use `type_secret` with the appropriate secret_id instead of the regular `type` action.
{% endif %}

### Latest Action History ###
{% if action_history %}
Recent actions you took previously and whether they were successful:
{% for action in action_history[-5:] %}
{% if action.outcome %}
Action: {{ action.action }} | Description: {{ action.summary }} | Outcome: Successful
{% else %}
Action: {{ action.action }} | Description: {{ action.summary }} | Outcome: Failed | Feedback: {{ action.error }}
{% endif %}
{% endfor %}

{% else %}
No actions have been taken yet.

{% endif %}
---
### LITERAL EXECUTION RULE ###
Whatever the current subgoal says to do, do that EXACTLY. Do not substitute with what you think is better. Do not optimize. Do not consider screen state. Parse the subgoal text literally and execute the matching atomic action.

IMPORTANT:
1. Do NOT repeat previously failed actions multiple times. Try changing to another action.
2. Must do the current subgoal.

Provide your output in the following format, which contains three parts:

### Thought ###
Break down the current subgoal into: (1) What atomic action is required? (2) What target/location is specified? (3) What parameters do I need? Do NOT reason about whether this makes sense - just mechanically convert the subgoal text into the appropriate action format.

### Action ###
Choose only one action or shortcut from the options provided.
You must provide your decision using a valid JSON format specifying the `action` and the parameters of the action. For example, if you want to open an App, you should write {"action":"open_app", "text": "app name"}.

### Description ###
A brief description of the chosen action. Do not describe expected outcome.

```

`droidrun/config/prompts/manager/rev1.jinja2`:

```jinja2
# Android Planning Agent

You operate an Android phone by creating high-level plans to fulfill user requests.

## User Request
{{ instruction }}

## Current Context
{% if device_date %}
<device_date>
{{ device_date }}
</device_date>

{% endif %}
{% if app_card %}
App card gives information on how to operate the app and perform actions.
<app_card>
{{ app_card }}
</app_card>

{% endif %}
{% if important_notes %}
<important_notes>
{{ important_notes }}
</important_notes>

{% endif %}
{% if error_history %}
<potentially_stuck>
You have encountered several failed attempts. Here are some logs:
{% for error in error_history %}
- Attempt: Action: {{ error.action }} | Description: {{ error.summary }} | Outcome: Failed | Feedback: {{ error.error }}
{% endfor %}
</potentially_stuck>

{% endif %}
{% if custom_tools_descriptions %}

<custom_actions>
The executor has access to these additional custom actions beyond the standard actions (click, type, swipe, etc.):
{{ custom_tools_descriptions }}

You can reference these custom actions or tell the Executer agent to use them in your plan when they help achieve the user's goal.
</custom_actions>
{% endif %}

---

## Guidelines

**Planning:**
- Open apps using `open_app` action directly
- Use search functions when available to find specific files/entries
- File names and dates must match the user request exactly
- Check full names/titles, not truncated versions in notifications
- Only do what the user asks‚Äînothing more

**Memory Usage:**
- Store information with context: "At step X, I obtained [content] from [source]"
- Store actual content, not references (e.g., full recipe text, not "found recipes")
- Memory is append-only‚Äînew entries add to existing memory
- Use memory instead of clipboard unless specifically requested

**Text Operations:**
{% if text_manipulation_enabled %}

<text_manipulation>
1. Use **TEXT_TASK:** prefix in your plan when you need to modify text in the currently focused text input field
2. TEXT_TASK is for editing, formatting, or transforming existing text content in text boxes using Python code
3. Do not use TEXT_TASK for extracting text from messages, typing new text, or composing messages
4. The focused text field contains editable text that you can modify
5. Example plan item: 'TEXT_TASK: Add "Hello World" at the beginning of the text'
6. Always use TEXT_TASK for modifying text, do not try to select the text to copy/cut/paste or adjust the text
</text_manipulation>
{% endif %}

**Scripter Operations:**
{% if scripter_execution_enabled %}

<scripter_execution>
You can delegate off-device Python operations using **<script>** tags in your plan.

**When to use <script>:**
- Downloading files from the internet
- Making HTTP API calls (GET, POST, etc.)
- Sending webhooks
- Processing data (JSON, XML, CSV)
- Any operation that doesn't involve the device UI

**When NOT to use <script>:**
- Device interactions (use regular subgoals)
- Text manipulation in input fields (use TEXT_TASK)

**Format:**
<script>
Clear description of what needs to be accomplished. Be specific.
</script>

**Example plan:**
<plan>
<script>
Fetch weather data from https://api.weather.com/city/london and extract the temperature in Celsius
</script>
1. Open the weather app
2. Navigate to settings
<script>
Send the temperature to webhook https://webhook.site/abc123 as JSON with format {"city": "london", "temp": value}
</script>
3. DONE
</plan>

**Scripter results:**
After a script executes, you'll see:
<script_result status="SUCCESS|FAILED">
Message from the scripter agent explaining what happened
</script_result>

You should:
- Check the status (SUCCESS/FAILED)
- React accordingly (continue plan, retry with different approach, or provide final answer)
- Use information from successful scripts in subsequent planning

**Scripter capabilities:**
- HTTP requests (requests library)
- JSON/data processing (json library)
- File operations in temp directory
- Iterative problem solving (like Jupyter notebook)
- Max {{ scripter_max_steps }} steps per scripter task
</scripter_execution>
{% endif %}
{% if output_schema %}

<output_requirements>
**IMPORTANT:** When you complete this task and use the `<request_accomplished>` tag, your final answer must include the following information:

{{ output_schema.description if output_schema.description else "Information to collect:" }}

**Required data fields:**
{% for field_name, field_info in output_schema.properties.items() %}
- **{{ field_name }}**: {{ field_info.description if field_info.description else field_info.type }}{% if field_name in output_schema.get('required', []) %} (REQUIRED){% endif %}

{% endfor %}

**Important:**
- Make sure to collect ALL required data before marking the task as complete
- Include this information clearly in your `<request_accomplished>` message
- Present the data in a natural, readable format - do NOT output JSON or structured data
- Simply state the information as plain text answers
</output_requirements>
{% endif %}

---

## Your Task

1. **Assess** the current screenshot and progress
2. **Decide:** Is the request complete?
   - If YES and SUCCESSFUL ‚Üí Use `<request_accomplished success="true">` with confirmation message
   - If YES but FAILED ‚Üí Use `<request_accomplished success="false">` with explanation of why it failed
   - If NO ‚Üí Update the plan
3. **Handle errors:** Revise plan if stuck or blocked
4. **Make assumptions:** If clarification needed, act as the user would

**Important:**
- Remove completed subgoals from the plan
- Keep the next action as the first item
- Don't repeat completed steps unless screen shows they failed
- Always include `success="true"` or `success="false"` attribute in `<request_accomplished>` tag

---

## Output Format

<thought>
Explain your reasoning for the plan and next subgoal.
</thought>

<add_memory>
Store important information with step context.
Example: "At step 5, I obtained recipe from recipes.jpg: Chicken Pasta - ingredients: chicken, pasta, cream; instructions: cook pasta, saut√© chicken, add cream."
</add_memory>

<plan>
1. Next subgoal to execute
2. Second subgoal
3. Third subgoal
...
</plan>

<request_accomplished success="true">
Use ONLY when request is fully completed successfully. Include confirmation message of what was accomplished.
</request_accomplished>

OR

<request_accomplished success="false">
Use when request cannot be completed due to insurmountable errors or constraints. Explain why it failed.
</request_accomplished>

```

`droidrun/config/prompts/manager/stateless.jinja2`:

```jinja2
You are an agent who can operate an Android phone on behalf of a user. Your goal is to track progress and devise high-level plans to achieve the user's requests.

<user_request>
{{ instruction }}
</user_request>

{% if device_date %}
<device_date>
{{ device_date }}
</device_date>
{% endif %}

{% if previous_plan %}
<previous_plan>
{{ previous_plan }}
</previous_plan>
{% endif %}

{% if previous_state %}
<previous_state>
{{ previous_state }}
</previous_state>
{% endif %}

{% if memory %}
<memory>
{{ memory }}
</memory>
{% endif %}

{% if last_thought %}
<last_thought>
{{ last_thought }}
</last_thought>
{% endif %}

{% if progress_summary %}
<progress_summary>
{{ progress_summary }}
</progress_summary>
{% endif %}

{% if action_history %}
<action_history>
Recent actions taken by the executor:
{% for action in action_history %}
- Action: {{ action.action }} | Description: {{ action.summary }} | Outcome: {{ "Success" if action.outcome else "Failed" }}{% if not action.outcome and action.error %} | Error: {{ action.error }}{% endif %}

{% endfor %}
</action_history>
{% endif %}

<current_state>
{{ current_state }}
</current_state>

{% if text_manipulation_enabled %}
<text_manipulation>
1. Use **TEXT_TASK:** prefix in your plan when you need to modify text in the currently focused text input field
2. TEXT_TASK is for editing, formatting, or transforming existing text content in text boxes using Python code
3. Do not use TEXT_TASK for extracting text from messages, typing new text, or composing messages
4. The focused text field contains editable text that you can modify
5. Example plan item: 'TEXT_TASK: Add "Hello World" at the beginning of the text'
6. Always use TEXT_TASK for modifying text, do not try to select the text to copy/cut/paste or adjust the text
</text_manipulation>
{% endif %}

<guidelines>
General:
1. Use the `open_app` action whenever you want to open an app, do not use the app drawer.
2. Use search to quickly find a file or entry with a specific name, if search function is applicable.
3. Only use copy to clipboard actions when the task specifically requires copying text to clipboard. Use Memory instead for storing information.
4. When you need to remember information for later use, add it to memory using <add_memory> tags.
5. File names in the user request must always match the exact file name you are working with.
6. Make sure names and titles are not cutoff. Check full names, not just what appears in truncated UI.
7. Dates and file names must match the user query exactly.
8. Don't do more than what the user asks for.

Memory Usage:
- Store important discovered information (names, values, content found during execution)
- Memory is append-only: whatever you put in <add_memory> tags gets added to existing memory
- Use memory to pass information between steps

Progress Tracking:
- Update <progress_summary> each turn to reflect ALL progress made so far (cumulative, not just this step)
- This is your only record of what has been accomplished since there is no conversation history
- Include completed steps, current status, and any important context from previous steps
</guidelines>

---

Analyze the current state and compare with previous state (if available). Determine if progress was made, if the plan needs adjustment, or if the task is complete.

Provide your output in the following format:

<thought>
Your reasoning about the current situation, what changed, and what to do next.
</thought>

<add_memory>
Any new important information discovered this step that should be remembered for later.
Only include NEW information to add, not the full memory.
Leave empty if nothing new to remember.
</add_memory>

<progress_summary>
Brief cumulative summary of ALL progress made so far (not just this step).
This replaces the previous progress summary, so include everything accomplished.
Example: "Opened Settings app. Navigated to Battery section. Currently viewing battery usage stats."
</progress_summary>

<plan>
Updated plan with numbered steps, one per line.
The first item is what the executor will do next.
Example:
1. Open Gmail app
2. Tap on the first unread message
3. Note the sender's name
4. Go back to home screen
</plan>

OR (if task is complete, do NOT include <plan>):

<answer success="true">
Use this when the task completed successfully. Include confirmation of what was accomplished.
</answer>

OR

<answer success="false">
Use this when the task cannot be completed. Explain why it failed.
</answer>

IMPORTANT:
- Use EITHER <plan> OR <answer>, never both. If you include both, your response will be rejected.
- The <answer> tag MUST include the success attribute (success="true" or success="false").

```

`droidrun/config/prompts/manager/system.jinja2`:

```jinja2
You are an agent who can operate an Android phone on behalf of a user. Your goal is to track progress and devise high-level plans to achieve the user's requests.

<user_request>
{{ instruction }}
</user_request>

{% if device_date %}
<device_date>
{{ device_date }}
</device_date>

{% endif %}
{% if app_card %}
App card gives information on how to operate the app and perform actions.
<app_card>
{{ app_card }}
</app_card>

{% endif %}
{% if important_notes %}
<important_notes>
{{ important_notes }}
</important_notes>

{% endif %}
{% if error_history %}
<potentially_stuck>
You have encountered several failed attempts. Here are some logs:
{% for error in error_history %}
- Attempt: Action: {{ error.action }} | Description: {{ error.summary }} | Outcome: Failed | Feedback: {{ error.error }}
{% endfor %}
</potentially_stuck>

{% endif %}
<guidelines>
The following guidelines will help you plan this request.
General:
1. Use the `open_app` action whenever you want to open an app, do not use the app drawer to open an app.
2. Use search to quickly find a file or entry with a specific name, if search function is applicable.
3. Only use copy to clipboard actions when the task specifically requires copying text to clipboard. Do not copy text just to use it later - use the Memory section instead.
4. When you need to remember information for later use, store it in the Memory section (using <add_memory> tags) with step context (e.g., "At step X, I obtained [information] from [source]").
5. File names in the user request must always match the exact file name you are working with, make that reflect in the plan too.
6. Make sure names and titles are not cutoff. If the request is to check who sent a message, make sure to check the message sender's full name not just what appears in the notification because it might be cut off.
7. Dates and file names must match the user query exactly.
8. Don't do more than what the user asks for.
{% if text_manipulation_enabled %}

<text_manipulation>
1. Use **TEXT_TASK:** prefix in your plan when you need to modify text in the currently focused text input field
2. TEXT_TASK is for editing, formatting, or transforming existing text content in text boxes using Python code
3. Do not use TEXT_TASK for extracting text from messages, typing new text, or composing messages
4. The focused text field contains editable text that you can modify
5. Example plan item: 'TEXT_TASK: Add "Hello World" at the beginning of the text'
6. Always use TEXT_TASK for modifying text, do not try to select the text to copy/cut/paste or adjust the text
</text_manipulation>
{% endif %}

Memory Usage:
- Always include step context: "At step [number], I obtained [actual content] from [source]"
- Store the actual content you observe, not just references (e.g., store full recipe text, not "found recipes")
- Use memory instead of copying text unless specifically requested
- Memory is append-only: whatever you put in <add_memory> tags gets added to existing memory, not replaced
- Update memory to track progress on multi-step tasks

</guidelines>
{% if custom_tools_descriptions %}

<custom_actions>
The executor has access to these additional custom actions beyond the standard actions (click, type, swipe, etc.):
{{ custom_tools_descriptions }}

You can reference these custom actions or tell the Executer agent to use them in your plan when they help achieve the user's goal.
</custom_actions>
{% endif %}
{% if available_secrets %}

<available_secrets>
The executor has access to the following secret IDs via the type_secret custom action:
{% for secret_id in available_secrets %}
- {{ secret_id }}
{% endfor %}

You can include these secret IDs in your plan when the task requires entering sensitive information (passwords, API keys, etc.). The executor will use `type_secret(secret_id, index)` to type them securely without exposing values.
</available_secrets>
{% endif %}
{% if scripter_execution_enabled %}

<scripter_execution>
You can delegate off-device Python operations using **<script>** tags in your plan to run code on host machine.

**When to use <script>:**
- Downloading files from the internet
- Making HTTP API calls (GET, POST, etc.)
- Sending webhooks
- Processing data (JSON, XML, CSV)
- Any operation that doesn't involve the device UI

**When NOT to use <script>:**
- Device interactions (use regular subgoals)
- Text manipulation in input fields (use TEXT_TASK)

**Format:**
<script>
Clear description of what needs to be accomplished. Be specific.
</script>

**Example plan:**
<plan>
<script>
Fetch weather data from https://api.weather.com/city/london and extract the temperature in Celsius
</script>
1. Open the weather app
2. Navigate to settings
<script>
Send the temperature to webhook https://webhook.site/abc123 as JSON with format {"city": "london", "temp": value}
</script>
3. DONE
</plan>

**Script results:**
After a script executes, you'll see:
<script_result status="SUCCESS|FAILED">
Message from the scripter agent explaining what happened
</script_result>

You should:
- Check the status (SUCCESS/FAILED)
- React accordingly (continue plan, retry with different approach, or provide final answer)
- Use information from successful scripts in subsequent planning

**Script capabilities:**
- HTTP requests (requests library)
- JSON/data processing (json library)
- File operations
</scripter_execution>
{% endif %}
{% if output_schema %}

<output_requirements>
**IMPORTANT:** When you complete this task and use the `<request_accomplished>` tag, your final answer must include the following information:

{{ output_schema.description if output_schema.description else "Information to collect:" }}

**Required data fields:**
{% for field_name, field_info in output_schema.properties.items() %}
- **{{ field_name }}**: {{ field_info.description if field_info.description else field_info.type }}{% if field_name in output_schema.get('required', []) %} (REQUIRED){% endif %}

{% endfor %}

**Important:**
- Make sure to collect ALL required data before marking the task as complete
- Include this information clearly in your `<request_accomplished>` message
- Present the data in a natural, readable format - do NOT output JSON or structured data
- Simply state the information as plain text answers
</output_requirements>
{% endif %}

---
Carefully assess the current status and the provided screenshot. Check if the current plan needs to be revised.
Determine if the user request has been fully completed. If you are confident that no further actions are required and the task succeeded, use the request_accomplished tag with success="true" and a confirmation message. If the task failed and cannot be completed, use success="false" with an explanation. If the user request is not finished, update the plan and don't use the request_accomplished tag. If you are stuck with errors, think step by step about whether the overall plan needs to be revised to address the error.
NOTE: 1. If the current situation prevents proceeding with the original plan or requires clarification from the user, make reasonable assumptions and revise the plan accordingly. Act as though you are the user in such cases. 2. Please refer to the helpful information and steps in the Guidelines first for planning. 3. If the first subgoal in plan has been completed, please update the plan in time according to the screenshot and progress to ensure that the next subgoal is always the first item in the plan. 4. If the first subgoal is not completed, please copy the previous round's plan or update the plan based on the completion of the subgoal.
Provide your output in the following format, which contains four or five parts:

<thought>
An explanation of your rationale for the updated plan and current subgoal.
</thought>

<add_memory>
Store important information here with step context for later reference. Always include "At step X, I obtained [actual content] from [source]".
Examples:
- At step 5, I obtained recipe details from recipes.jpg: Recipe 1 "Chicken Pasta" - ingredients: chicken, pasta, cream. Instructions: Cook pasta, saut√© chicken, add cream.
or
- At step 12, I successfully added Recipe 1 to Broccoli app. Still need to add Recipe 2 and Recipe 3 from memory.
Store important information here with step context for later reference.
</add_memory>

<plan>
Please update or copy the existing plan according to the current page and progress. Please pay close attention to the historical operations. Please do not repeat the plan of completed content unless you can judge from the screen status that a subgoal is indeed not completed.
</plan>

<request_accomplished success="true">
Use this tag ONLY after successfully completing the user's request through concrete actions, not at the beginning or for planning.

1. Set success="true" when the task completed successfully
2. Always include a message inside this tag confirming what you accomplished
3. Ensure both opening and closing tags are present
4. Use exclusively for signaling completed user requests
</request_accomplished>

OR

<request_accomplished success="false">
Use this tag when the task cannot be completed due to insurmountable errors or constraints.

1. Set success="false" when the task definitively failed
2. Always include a message explaining why the task could not be completed
3. Ensure both opening and closing tags are present
4. Use only when you are certain the task cannot proceed further
</request_accomplished>

```

`droidrun/config/prompts/manager/trained.jinja2`:

```jinja2
Plan actions for an Android phone task.

<user_request>
{{ instruction }}
</user_request>

{% if device_date %}<device_date>{{ device_date }}</device_date>
{% endif %}
{% if previous_plan %}<previous_plan>
{{ previous_plan }}
</previous_plan>
{% endif %}
{% if previous_state %}<previous_state>
{{ previous_state }}
</previous_state>
{% endif %}
{% if memory %}<memory>
{{ memory }}
</memory>
{% endif %}
{% if last_thought %}<last_thought>
{{ last_thought }}
</last_thought>
{% endif %}
{% if progress_summary %}<progress_summary>
{{ progress_summary }}
</progress_summary>
{% endif %}
{% if action_history %}<action_history>
{{ action_history }}
</action_history>
{% endif %}
<current_state>
{{ current_state }}
</current_state>

{% if text_manipulation_enabled %}<text_manipulation>
Use TEXT_TASK: prefix in plan to modify text in focused input field.
</text_manipulation>
{% endif %}
<guidelines>
- Use `open_app` to open apps, not the app drawer
- Use search when looking for specific files/entries
- Store info in memory, not clipboard
- Match exact file names and dates from user request
- Don't do more than asked
</guidelines>

---

Analyze state and plan next steps.

Output: <think>, <add_memory>, <progress_summary>, <plan>
If complete: <answer success="true|false"> instead of <plan>
```

`droidrun/config/prompts/scripter/system.jinja2`:

```jinja2
You are a Python scripter agent for off-device operations. You will be given a task that requires executing Python code to accomplish goals like API calls, web requests, data processing, file downloads, etc.

<task>
{{ task }}
</task>

<capabilities>
You have access to the following Python libraries:
{{ available_libraries }}

You do NOT have access to device control functions.
</capabilities>

<execution_model>
You work like a Jupyter notebook:
1. Variables persist across code executions
2. You can iteratively build solutions
3. Previous code results are available
4. You have {{ max_steps }} steps maximum

Example flow:
Step 1: Fetch data from API, store in variable
Step 2: Process the data
Step 3: Send to webhook
Step 4: Provide final summary (without code)
</execution_model>

<instructions>
1. **Always explain your thought process first** before providing code
2. **Write code incrementally** - you can execute multiple times
3. **Use print() statements** to see intermediate results
4. **Store results in variables** to reuse across steps
5. **When finished, provide your final message WITHOUT a code block**

Example iteration 1:
**Thought:** I need to fetch user data from the API first.
<python>
import requests

# Fetch user data
response = requests.get("https://api.example.com/user/123")
data = response.json()

print(f"Fetched user: {data['name']}")
</python>

Example iteration 2:
**Thought:** Now I'll send the data to the webhook.
<python>
# Send to webhook
webhook_url = "https://webhook.site/abc"
webhook_response = requests.post(webhook_url, json=data)

print(f"Webhook status: {webhook_response.status_code}")
</python>

Example final iteration (NO CODE BLOCK):
**Thought:** Task complete. I successfully fetched user data for John Doe and sent it to the webhook with a 200 status code. Everything worked as expected.
</instructions>

<how_to_finish>
When you complete the task (successfully or with errors), simply provide your final message WITHOUT a code block:

Good examples:
- "Successfully downloaded 245KB file and sent to webhook"
- "Error: API returned 404. The endpoint might have changed"
- "Downloaded data for 50 users and saved to results.json"
- "Connection timeout after 20 seconds. The API at https://example.com might be down. Please verify the URL or try again later."

Bad examples (don't do this):
- Providing empty response
- Saying "I'll do X" without actually doing it
</how_to_finish>

<important>
- You have {{ max_steps }} steps maximum before timeout
- If you encounter errors, explain them clearly in your message without code blocks. You can still provide code but without code blocks.
- If you need more information, ask for it in your message without code blocks
- Always provide context about what you accomplished
- Variables persist across code blocks - you can reference them later
- **To finish: just write your final message without a code block**
</important>

Provide your thought process and then either:
- A <python></python> code block (if you need to execute something), OR
- Your final message without code blocks (if you're done)

```

`droidrun/config_example.yaml`:

```yaml
# DroidRun Configuration File
# This file is auto-generated. Edit values as needed.

_version: 1

# === Agent Settings ===
agent:
  # Agent to use: "droidrun" (native) or external: "mai_ui", "autoglm"
  name: droidrun
  # Maximum number of steps per task
  max_steps: 15
  # Enable planning with reasoning mode
  reasoning: false
  # Enable streaming LLM responses to console in real-time
  streaming: true
  # Sleep duration after each action, waits for ui state to be updated (seconds)
  after_sleep_action: 1.0
  # Wait duration for UI to stabilize (seconds)
  wait_for_stable_ui: 0.3

  # Coordinate system for swipe and state bounds output
  # false = absolute pixels (default)
  # true = normalized [0-1000] range (resolution-independent)
  use_normalized_coordinates: false

  # Fast Agent Configuration
  fast_agent:
    # Enable vision capabilities (screenshots)
    vision: false
    # Enable code execution mode (generates and exec() Python code)
    # false (default) = uses XML tool-calling (safer, no code execution)
    # true = legacy code generation mode with exec()
    codeact: false
    # Allow multiple tool calls in a single response when safe
    # Reduces round-trips by combining actions that don't depend on screen changes
    parallel_tools: true
    # System prompt path (relative or absolute)
    # Default points to tools agent prompt; legacy codeact prompt used automatically when codeact: true
    system_prompt: config/prompts/codeact/tools_system.jinja2
    # User prompt path (relative or absolute)
    user_prompt: config/prompts/codeact/tools_user.jinja2
    # Enable safe code execution (restricts imports and builtins)
    safe_execution: false
    # Execution timeout per code block (seconds)
    execution_timeout: 50.0

  # Manager Agent Configuration
  manager:
    # Enable vision capabilities (screenshots)
    vision: false
    # System prompt path (relative or absolute)
    system_prompt: config/prompts/manager/system.jinja2
    # Use stateless manager (rebuilds context each turn, no chat history, experimental)
    stateless: false

  # Executor Agent Configuration
  executor:
    # Enable vision capabilities (screenshots)
    vision: false
    # System prompt path (relative or absolute)
    system_prompt: config/prompts/executor/system.jinja2

  # Scripter Agent Configuration
  scripter:
    # Enable scripter execution for off-device operations
    enabled: true
    # Maximum steps per scripter agent task
    max_steps: 10
    # Execution timeout per code block (seconds)
    execution_timeout: 30.0
    # System prompt path (relative or absolute)
    system_prompt: config/prompts/scripter/system.jinja2
    # Enable safe code execution (restricts imports and builtins)
    safe_execution: false

  # App Cards Configuration
  app_cards:
    # Enable app-specific instruction cards
    enabled: true
    # Mode: local (file-based), server (HTTP API), or composite (server with local fallback)
    mode: local
    # Directory containing app card files (for local/composite modes)
    app_cards_dir: config/app_cards
    # Server URL for remote app cards (for server/composite modes)
    server_url: null
    # Server request timeout in seconds
    server_timeout: 10.0
    # Number of server retry attempts
    server_max_retries: 2

# === LLM Profiles ===
# Define LLM configurations for each agent type
llm_profiles:
  # Manager: Plans and reasons about task progress
  manager:
    provider: GoogleGenAI
    model: models/gemini-2.5-pro
    temperature: 0.2
    # kwargs: # optional kwargs, add api_key in kwargs if not already in .env
    #   max_tokens: 8192
      
  # Executor: Selects and executes atomic actions
  executor:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.1
    # kwargs:
    #   max_tokens: 4096
      
  # Fast Agent: Direct execution agent (XML tool-calling or code generation)
  fast_agent:
    provider: GoogleGenAI
    model: models/gemini-2.5-pro
    temperature: 0.2
    # kwargs:
    #   max_tokens: 8192
      
  # Text Manipulator: Edits text in input fields
  text_manipulator:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.3
    # kwargs:
    #   max_tokens: 4096
      
  # App Opener: Opens apps by name/description
  app_opener:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.0
    # kwargs:
    #   max_tokens: 512

  # Scripter: Executes Python scripts for off-device operations
  scripter:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.1
    # kwargs:
    #   max_tokens: 4096

  # Structured Output: Extracts structured data from final answers
  structured_output:
    provider: GoogleGenAI
    model: models/gemini-2.5-flash
    temperature: 0.0
    # kwargs:
    #   max_tokens: 2048

# === Device Settings ===
device:
  # Default device serial (null = auto-detect)
  serial: null
  # Use TCP communication instead of usb
  use_tcp: false
  # Platform: android or ios but currently only android is supported
  platform: android

# === Telemetry Settings ===
telemetry:
  # Enable anonymous telemetry
  enabled: true

# === Tracing Settings ===
tracing:
  # Enable tracing
  enabled: false
  # Tracing provider: phoenix or langfuse
  provider: phoenix
  # Upload screenshots to Langfuse (cloud traces)
  langfuse_screenshots: false
  # Langfuse configuration (set as environment variables if not empty string)
  langfuse_secret_key: ""  # LANGFUSE_SECRET_KEY
  langfuse_public_key: ""  # LANGFUSE_PUBLIC_KEY
  langfuse_host: ""        # LANGFUSE_HOST
  langfuse_user_id: "anonymous"  # User ID for tracing
  langfuse_session_id: ""  # Session ID (empty = auto-generate UUID per process)

# === Logging Settings ===
logging:
  # Enable debug logging
  debug: false
  # Trajectory saving level (none, step, action)
  save_trajectory: none
  # Path for trajectory files (absolute or relative to cwd)
  trajectory_path: trajectories
  # Trajectory video/gif settings (False, true)
  trajectory_gifs: true
  rich_text: false

# === Safe Execution Settings ===
# Applied when agent.fast_agent.safe_execution or agent.scripter.safe_execution is true
safe_execution:
  # Allow all imports (ignores allowed_modules, respects blocked_modules)
  allow_all_imports: true

  # Allowed modules (empty + allow_all_imports=false = no imports allowed)
  # Example: ['json', 'requests', 're', 'datetime', 'math', 'collections']
  allowed_modules: []

  # Blocked modules (takes precedence over allowed_modules and allow_all_imports)
  # Prevents dangerous file operations, subprocess execution, and code manipulation
  blocked_modules:
    - os
    - sys
    - subprocess
    - shutil
    - pathlib
    - pty
    - fcntl
    - resource
    - pickle
    - shelve
    - marshal
    - imp
    - importlib
    - ctypes
    - code
    - codeop
    - tempfile
    - glob
    - socket
    - socketserver
    - asyncio

  # Allow all builtins (ignores allowed_builtins, respects blocked_builtins)
  allow_all_builtins: true

  # Allowed builtins (empty + allow_all_builtins=false = use safe defaults)
  # Safe defaults include: int, str, list, dict, print, len, range, etc.
  allowed_builtins: []

  # Blocked builtins (takes precedence over allowed_builtins and allow_all_builtins)
  blocked_builtins:
    - open
    - compile
    - exec
    - eval
    - __import__
    - breakpoint
    - exit
    - quit
    - input

# === Tool Settings ===
tools:
  # Disabled tools - add tool names to disable them
  # Available tools:
  #   - click          # Tap UI elements by index
  #   - click_at       # Tap at specific coordinates
  #   - click_area     # Tap center of an area
  #   - long_press     # Long press UI elements by index
  #   - long_press_at  # Long press at specific coordinates
  #   - type           # Type text into input fields
  #   - system_button  # Press back, home, enter
  #   - swipe          # Swipe gestures
  #   - wait           # Wait for duration
  #   - open_app       # Open apps by name
  #   - type_secret    # Type credentials (requires credentials.enabled: true)
  # Coordinate-based tools disabled by default (enable if needed)
  disabled_tools:
    - click_at
    - click_area
    - long_press_at

# === Credential Settings ===
credentials:
  # Enable credential manager for secure secret storage
  enabled: false
  # Path to credentials file (see config/credentials_example.yaml for format)
  file_path: config/credentials.yaml

# === MCP (Model Context Protocol) Settings ===
# Connect to MCP servers to extend agent capabilities with external tools
# Requires: pip install mcp
mcp:
  # Enable MCP client
  enabled: false

  # MCP server configurations
  # Each server exposes tools that become available to agents
  servers:
    # Example: Filesystem server for file operations
    # filesystem:
    #   command: npx
    #   args: ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
    #   prefix: "fs_"  # Tool names become fs_read_file, fs_write_file, etc.
    #   # Optional: Only include specific tools
    #   # include_tools: [read_file, list_directory]
    #   # Optional: Exclude specific tools
    #   # exclude_tools: [write_file]

    # Example: Fetch server for HTTP requests
    # fetch:
    #   command: uvx
    #   args: ["mcp-server-fetch"]
    #   prefix: ""  # No prefix, tools keep original names

    # Example: Custom Python MCP server
    # my_server:
    #   command: python
    #   args: ["/path/to/my_server.py"]
    #   env:
    #     API_KEY: "your-api-key"
    #   enabled: true

# === External Agent Settings ===
# External agents are selected via agent.name above.
# Set agent.name to "mai_ui" or "autoglm" to use external agents.
# Settings below are merged with agent-specific defaults.
#
# Example:
#   agent:
#     name: mai_ui
#     max_steps: 20
#
# Optional overrides via external_agent section:
# external_agent:
#   llm:
#     base_url: http://custom:8000/v1

# External agent configurations (reference settings)
external_agents:
  # MAI-UI - Alibaba's GUI agent foundation model
  # https://github.com/Tongyi-MAI/MAI-UI
  # Requires vLLM server: vllm serve Tongyi-MAI/MAI-UI-8B
  mai_ui:
    llm:
      provider: OpenAILike
      model: Tongyi-MAI/MAI-UI-8B  # or mai-ui-2b, mai-ui-32b, mai-ui-235b-a22b
      api_base: https://enjoyed-placed-theaters-survival.trycloudflare.com/v1
      api_key: EMPTY
      temperature: 0.0
      max_tokens: 2048
      top_p: 1.0
      top_k: -1
    history_n: 3  # Number of history steps with images

  # AutoGLM - Open-AutoGLM phone agent
  # https://github.com/zai-org/Open-AutoGLM/
  autoglm:
    llm:
      provider: OpenAILike
      model: autoglm-phone-9b
      api_base: http://localhost:8000/v1
      api_key: EMPTY
      temperature: 0.0
      top_p: 0.85
      frequency_penalty: 0.2
      max_tokens: 3000
    lang: en      # cn or en
    stream: true

```

`droidrun/config_manager/__init__.py`:

```py
from droidrun.config_manager.config_manager import (
    AgentConfig,
    AppCardConfig,
    FastAgentConfig,
    CredentialsConfig,
    DeviceConfig,
    DroidrunConfig,
    ExecutorConfig,
    LLMProfile,
    LoggingConfig,
    ManagerConfig,
    ScripterConfig,
    TelemetryConfig,
    ToolsConfig,
    TracingConfig,
)
from droidrun.config_manager.loader import ConfigLoader, OutdatedConfigError
from droidrun.config_manager.path_resolver import PathResolver
from droidrun.config_manager.prompt_loader import PromptLoader
from droidrun.config_manager.safe_execution import (
    DEFAULT_SAFE_BUILTINS,
    SafeExecutionConfig,
    create_safe_builtins,
    create_safe_import,
)

__all__ = [
    "DroidrunConfig",
    "LLMProfile",
    "AgentConfig",
    "FastAgentConfig",
    "ManagerConfig",
    "ExecutorConfig",
    "ScripterConfig",
    "AppCardConfig",
    "DeviceConfig",
    "TelemetryConfig",
    "TracingConfig",
    "LoggingConfig",
    "ToolsConfig",
    "CredentialsConfig",
    "SafeExecutionConfig",
    "ConfigLoader",
    "OutdatedConfigError",
    "PathResolver",
    "PromptLoader",
    "DEFAULT_SAFE_BUILTINS",
    "create_safe_builtins",
    "create_safe_import",
]

```

`droidrun/config_manager/config_manager.py`:

```py
from __future__ import annotations

from dataclasses import asdict, dataclass, field
from typing import Any, Dict, List, Optional

import yaml

from droidrun.config_manager.path_resolver import PathResolver
from droidrun.config_manager.safe_execution import SafeExecutionConfig
from droidrun.mcp.config import MCPConfig, MCPServerConfig


# ---------- Config Schema ----------
@dataclass
class LLMProfile:
    """LLM profile configuration."""

    provider: str = "GoogleGenAI"
    model: str = "gemini-2.5-pro"
    temperature: float = 0.2
    base_url: Optional[str] = None
    api_base: Optional[str] = None
    kwargs: Dict[str, Any] = field(default_factory=dict)

    def to_load_llm_kwargs(self) -> Dict[str, Any]:
        """Convert profile to kwargs for load_llm function."""
        result = {
            "model": self.model,
            "temperature": self.temperature,
        }
        # Add optional URL parameters
        if self.base_url:
            result["base_url"] = self.base_url
        if self.api_base:
            result["api_base"] = self.api_base
        # Merge additional kwargs
        result.update(self.kwargs)
        return result


@dataclass
class FastAgentConfig:
    vision: bool = False
    codeact: bool = False
    parallel_tools: bool = True
    system_prompt: str = "config/prompts/codeact/tools_system.jinja2"
    user_prompt: str = "config/prompts/codeact/tools_user.jinja2"
    safe_execution: bool = False
    execution_timeout: float = 50.0


@dataclass
class ManagerConfig:
    vision: bool = False
    system_prompt: str = "config/prompts/manager/system.jinja2"
    stateless: bool = False


@dataclass
class ExecutorConfig:
    vision: bool = False
    system_prompt: str = "config/prompts/executor/system.jinja2"


@dataclass
class ScripterConfig:
    enabled: bool = True
    max_steps: int = 10
    execution_timeout: float = 30.0
    system_prompt: str = "config/prompts/scripter/system.jinja2"
    safe_execution: bool = False


@dataclass
class AppCardConfig:
    """App card configuration."""

    enabled: bool = True
    mode: str = "local"  # local | server | composite
    app_cards_dir: str = "config/app_cards"
    server_url: Optional[str] = None
    server_timeout: float = 2.0
    server_max_retries: int = 2


@dataclass
class AgentConfig:
    name: str = "droidrun"
    max_steps: int = 15
    reasoning: bool = False
    streaming: bool = True
    after_sleep_action: float = 1.0
    wait_for_stable_ui: float = 0.3
    use_normalized_coordinates: bool = False

    fast_agent: FastAgentConfig = field(default_factory=FastAgentConfig)
    manager: ManagerConfig = field(default_factory=ManagerConfig)
    executor: ExecutorConfig = field(default_factory=ExecutorConfig)
    scripter: ScripterConfig = field(default_factory=ScripterConfig)
    app_cards: AppCardConfig = field(default_factory=AppCardConfig)

    def get_fast_agent_system_prompt_path(self) -> str:
        return str(PathResolver.resolve(self.fast_agent.system_prompt, must_exist=True))

    def get_fast_agent_user_prompt_path(self) -> str:
        return str(PathResolver.resolve(self.fast_agent.user_prompt, must_exist=True))

    def get_manager_system_prompt_path(self) -> str:
        return str(PathResolver.resolve(self.manager.system_prompt, must_exist=True))

    def get_executor_system_prompt_path(self) -> str:
        return str(PathResolver.resolve(self.executor.system_prompt, must_exist=True))

    def get_scripter_system_prompt_path(self) -> str:
        return str(PathResolver.resolve(self.scripter.system_prompt, must_exist=True))


@dataclass
class DeviceConfig:
    """Device-related configuration."""

    serial: Optional[str] = None
    use_tcp: bool = False
    platform: str = "android"  # "android" or "ios"


@dataclass
class TelemetryConfig:
    """Telemetry configuration."""

    enabled: bool = True


@dataclass
class TracingConfig:
    """Tracing configuration."""

    enabled: bool = False
    provider: str = "phoenix"  # "phoenix" or "langfuse"
    langfuse_screenshots: bool = False  # Upload screenshots to Langfuse (if enabled)
    langfuse_secret_key: str = ""  # Set as LANGFUSE_SECRET_KEY env var if not empty
    langfuse_public_key: str = ""  # Set as LANGFUSE_PUBLIC_KEY env var if not empty
    langfuse_host: str = ""  # Set as LANGFUSE_HOST env var if not empty
    langfuse_user_id: str = "anonymous"
    langfuse_session_id: str = (
        ""  # Empty = auto-generate UUID; set to custom value to persist across runs
    )


@dataclass
class LoggingConfig:
    """Logging configuration."""

    debug: bool = False
    save_trajectory: str = "none"
    trajectory_path: str = "trajectories"
    rich_text: bool = False
    trajectory_gifs: bool = True


def _default_disabled_tools() -> List[str]:
    return ["click_at", "click_area", "long_press_at"]


@dataclass
class ToolsConfig:
    """Tools configuration."""

    disabled_tools: List[str] = field(default_factory=_default_disabled_tools)
    stealth: bool = False


@dataclass
class CredentialsConfig:
    """Credentials configuration."""

    enabled: bool = False
    file_path: str = "config/credentials.yaml"


@dataclass
class DroidrunConfig:
    """Complete DroidRun configuration schema."""

    agent: AgentConfig = field(default_factory=AgentConfig)
    llm_profiles: Dict[str, LLMProfile] = field(default_factory=dict)
    device: DeviceConfig = field(default_factory=DeviceConfig)
    telemetry: TelemetryConfig = field(default_factory=TelemetryConfig)
    tracing: TracingConfig = field(default_factory=TracingConfig)
    logging: LoggingConfig = field(default_factory=LoggingConfig)
    tools: ToolsConfig = field(default_factory=ToolsConfig)
    credentials: CredentialsConfig = field(default_factory=CredentialsConfig)
    safe_execution: SafeExecutionConfig = field(default_factory=SafeExecutionConfig)
    external_agents: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    mcp: MCPConfig = field(default_factory=MCPConfig)

    def __post_init__(self):
        """Ensure default profiles exist."""
        if not self.llm_profiles:
            self.llm_profiles = self._default_profiles()

    @staticmethod
    def _default_profiles() -> Dict[str, LLMProfile]:
        """Get default agent specific LLM profiles."""
        return {
            "manager": LLMProfile(
                provider="GoogleGenAI",
                model="gemini-2.5-pro",
                temperature=0.2,
                kwargs={},
            ),
            "executor": LLMProfile(
                provider="GoogleGenAI",
                model="gemini-2.5-pro",
                temperature=0.1,
                kwargs={},
            ),
            "fast_agent": LLMProfile(
                provider="GoogleGenAI",
                model="gemini-2.5-pro",
                temperature=0.2,
                kwargs={},
            ),
            "text_manipulator": LLMProfile(
                provider="GoogleGenAI",
                model="gemini-2.5-pro",
                temperature=0.3,
                kwargs={},
            ),
            "app_opener": LLMProfile(
                provider="GoogleGenAI",
                model="gemini-2.5-pro",
                temperature=0.0,
                kwargs={},
            ),
            "scripter": LLMProfile(
                provider="GoogleGenAI",
                model="gemini-2.5-flash",
                temperature=0.1,
                kwargs={},
            ),
            "structured_output": LLMProfile(
                provider="GoogleGenAI",
                model="gemini-2.5-flash",
                temperature=0.0,
                kwargs={},
            ),
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary."""
        result = asdict(self)
        # Convert LLMProfile objects to dicts
        result["llm_profiles"] = {
            name: asdict(profile) for name, profile in self.llm_profiles.items()
        }
        # safe_execution is already converted by asdict
        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "DroidrunConfig":
        """Create config from dictionary."""
        # Parse LLM profiles
        llm_profiles = {}
        for name, profile_data in data.get("llm_profiles", {}).items():
            llm_profiles[name] = LLMProfile(**profile_data)

        # Parse agent config with sub-configs
        agent_data = data.get("agent", {})

        fast_agent_data = agent_data.get("fast_agent", {})
        fast_agent_config = (
            FastAgentConfig(**fast_agent_data) if fast_agent_data else FastAgentConfig()
        )

        manager_data = agent_data.get("manager", {})
        manager_config = (
            ManagerConfig(**manager_data) if manager_data else ManagerConfig()
        )

        executor_data = agent_data.get("executor", {})
        executor_config = (
            ExecutorConfig(**executor_data) if executor_data else ExecutorConfig()
        )

        script_data = agent_data.get("scripter", {})
        scripter_config = (
            ScripterConfig(**script_data) if script_data else ScripterConfig()
        )

        app_cards_data = agent_data.get("app_cards", {})
        app_cards_config = (
            AppCardConfig(**app_cards_data) if app_cards_data else AppCardConfig()
        )

        agent_config = AgentConfig(
            name=agent_data.get("name", "droidrun"),
            max_steps=agent_data.get("max_steps", 15),
            reasoning=agent_data.get("reasoning", False),
            streaming=agent_data.get("streaming", False),
            after_sleep_action=agent_data.get("after_sleep_action", 1.0),
            wait_for_stable_ui=agent_data.get("wait_for_stable_ui", 0.3),
            use_normalized_coordinates=agent_data.get(
                "use_normalized_coordinates", False
            ),
            fast_agent=fast_agent_config,
            manager=manager_config,
            executor=executor_config,
            scripter=scripter_config,
            app_cards=app_cards_config,
        )

        safe_exec_data = data.get("safe_execution", {})
        safe_execution_config = (
            SafeExecutionConfig(**safe_exec_data)
            if safe_exec_data
            else SafeExecutionConfig()
        )

        # External agents config - just pass through as-is
        external_agents = data.get("external_agents", {})

        # Parse MCP config
        mcp_data = data.get("mcp", {}) or {}
        mcp_servers = {}
        servers_data = mcp_data.get("servers") or {}
        for server_name, server_data in servers_data.items():
            mcp_servers[server_name] = MCPServerConfig(
                command=server_data.get("command", ""),
                args=server_data.get("args", []),
                env=server_data.get("env", {}),
                prefix=server_data.get("prefix"),
                enabled=server_data.get("enabled", True),
                include_tools=server_data.get("include_tools"),
                exclude_tools=server_data.get("exclude_tools", []),
            )
        mcp_config = MCPConfig(
            enabled=mcp_data.get("enabled", False),
            servers=mcp_servers,
        )

        return cls(
            agent=agent_config,
            llm_profiles=llm_profiles,
            device=DeviceConfig(**data.get("device", {})),
            telemetry=TelemetryConfig(**data.get("telemetry", {})),
            tracing=TracingConfig(**data.get("tracing", {})),
            logging=LoggingConfig(**data.get("logging", {})),
            tools=ToolsConfig(**data.get("tools", {})),
            credentials=CredentialsConfig(**data.get("credentials", {})),
            safe_execution=safe_execution_config,
            external_agents=external_agents,
            mcp=mcp_config,
        )

    @classmethod
    def from_yaml(cls, path: str) -> "DroidrunConfig":
        """
        Load config from YAML file.

        Args:
            path: Path to config file (relative to CWD or absolute)

        Returns:
            DroidrunConfig instance

        Raises:
            FileNotFoundError: If file doesn't exist
            Exception: If file can't be parsed
        """
        with open(path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)
        return cls.from_dict(data)

```

`droidrun/config_manager/env_keys.py`:

```py
"""Persistent API key storage using a .env file in the user config directory."""

from __future__ import annotations

import os
from pathlib import Path

import platformdirs
from dotenv import dotenv_values, set_key

ENV_FILE = Path(platformdirs.user_config_dir("droidrun")) / ".env"

API_KEY_ENV_VARS = {
    "google": "GOOGLE_API_KEY",
    "gemini": "GEMINI_API_KEY",
    "openai": "OPENAI_API_KEY",
    "anthropic": "ANTHROPIC_API_KEY",
}


def load_env_keys() -> dict[str, str]:
    """Load API keys. The .env file takes precedence over shell env vars.

    Returns:
        Dict mapping slot name (e.g. "google") to key value.
    """
    result: dict[str, str] = {}
    for slot, env_var in API_KEY_ENV_VARS.items():
        result[slot] = os.environ.get(env_var, "")
    if ENV_FILE.exists():
        for slot, env_var in API_KEY_ENV_VARS.items():
            val = dotenv_values(ENV_FILE).get(env_var)
            if val:
                result[slot] = val
    return result


def save_env_keys(keys: dict[str, str]) -> None:
    """Persist API keys to the .env file and set them as env vars.

    Args:
        keys: Dict mapping slot name (e.g. "google") to key value.
    """
    ENV_FILE.parent.mkdir(parents=True, exist_ok=True)
    if not ENV_FILE.exists():
        ENV_FILE.touch()
    for slot, env_var in API_KEY_ENV_VARS.items():
        val = keys.get(slot, "")
        if val:
            set_key(str(ENV_FILE), env_var, val)
            os.environ[env_var] = val

```

`droidrun/config_manager/loader.py`:

```py
"""Config loading with platform-aware user config and migrations."""

from __future__ import annotations

import os
from pathlib import Path
from typing import Any, Dict, Optional

import platformdirs
import yaml

from .config_manager import DroidrunConfig
from .migrations import CURRENT_VERSION, migrate


class OutdatedConfigError(Exception):
    """Raised when user config is missing _version field."""

    pass


class ConfigLoader:
    """Unified config loading with user config support."""

    APP_NAME = "droidrun"
    CONFIG_FILE = "config.yaml"

    @classmethod
    def get_user_config_dir(cls) -> Path:
        return Path(platformdirs.user_config_dir(cls.APP_NAME))

    @classmethod
    def get_user_config_path(cls) -> Path:
        return cls.get_user_config_dir() / cls.CONFIG_FILE

    @classmethod
    def load(cls, config_path: Optional[str] = None) -> DroidrunConfig:
        """
        Load config with resolution order:
        1. Explicit config_path argument
        2. DROIDRUN_CONFIG env var
        3. User config (~/.config/droidrun/config.yaml)
        4. Package defaults (creates user config)
        """
        if config_path:
            return cls._load_user_config(Path(config_path))

        env_config = os.environ.get("DROIDRUN_CONFIG")
        if env_config and Path(env_config).exists():
            return cls._load_user_config(Path(env_config))

        user_config_path = cls.get_user_config_path()

        if user_config_path.exists():
            return cls._load_user_config(user_config_path)

        return cls._init_user_config()

    @classmethod
    def _load_user_config(cls, user_config_path: Path) -> DroidrunConfig:
        """Load user config and run migrations."""
        with open(user_config_path, "r", encoding="utf-8") as f:
            user_dict = yaml.safe_load(f) or {}

        if "_version" not in user_dict:
            raise OutdatedConfigError(
                f"Config at {user_config_path} is outdated (missing _version).\n"
                "Please update your config based on the latest example:\n"
                "https://github.com/droidrun/droidrun/blob/main/droidrun/config_example.yaml"
            )

        old_version = user_dict["_version"]
        user_dict = migrate(user_dict)

        if user_dict.get("_version", 0) > old_version:
            cls._save_dict(user_dict, user_config_path)

        return DroidrunConfig.from_dict(user_dict)

    @classmethod
    def _init_user_config(cls) -> DroidrunConfig:
        """Create user config from defaults on first run."""
        config = DroidrunConfig()
        cls.save(config)
        return config

    @classmethod
    def save(cls, config: DroidrunConfig) -> Path:
        """Save config to user config path."""
        config_dict = config.to_dict()
        config_dict["_version"] = CURRENT_VERSION
        return cls._save_dict(config_dict, cls.get_user_config_path())

    @classmethod
    def _save_dict(cls, config_dict: Dict[str, Any], path: Path) -> Path:
        """Save config dict to path."""
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w", encoding="utf-8") as f:
            yaml.dump(config_dict, f, default_flow_style=False, sort_keys=False)
        return path

```

`droidrun/config_manager/migrations/__init__.py`:

```py
"""Config migration system."""

from typing import Dict, Any, List
import importlib
import pkgutil
from pathlib import Path


CURRENT_VERSION = 2


def get_migrations() -> List:
    """Discover and load all migration modules."""
    migrations = []
    migrations_dir = Path(__file__).parent

    for _, name, _ in pkgutil.iter_modules([str(migrations_dir)]):
        if name.startswith("v") and name[1:4].isdigit():
            module = importlib.import_module(f".{name}", package=__name__)
            if hasattr(module, "VERSION") and hasattr(module, "migrate"):
                migrations.append(module)

    return sorted(migrations, key=lambda m: m.VERSION)


def migrate(config: Dict[str, Any]) -> Dict[str, Any]:
    """Run all pending migrations on config."""
    version = config.get("_version", 0)

    if version >= CURRENT_VERSION:
        return config

    migrations = get_migrations()

    for migration in migrations:
        if migration.VERSION > version:
            config = migration.migrate(config)
            config["_version"] = migration.VERSION

    return config

```

`droidrun/config_manager/migrations/v002_add_code_exec.py`:

```py
"""Migration v2: Rename codeact config to fast_agent, add codeact flag."""

from typing import Any, Dict

VERSION = 2

_OLD_SYSTEM_PROMPT = "config/prompts/codeact/system.jinja2"
_OLD_USER_PROMPT = "config/prompts/codeact/user.jinja2"
_NEW_SYSTEM_PROMPT = "config/prompts/codeact/tools_system.jinja2"
_NEW_USER_PROMPT = "config/prompts/codeact/tools_user.jinja2"


def migrate(config: Dict[str, Any]) -> Dict[str, Any]:
    """Rename agent.codeact -> agent.fast_agent and llm_profiles.codeact -> fast_agent."""
    agent = config.get("agent", {})

    # Rename agent.codeact -> agent.fast_agent
    if "codeact" in agent and "fast_agent" not in agent:
        agent["fast_agent"] = agent.pop("codeact")

    fast_agent = agent.setdefault("fast_agent", {})

    fast_agent.setdefault("codeact", False)
    fast_agent.setdefault("parallel_tools", True)

    # Remove safe_execution and execution_timeout (now in top-level safe_execution)
    fast_agent.pop("safe_execution", None)
    fast_agent.pop("execution_timeout", None)

    # Update prompt paths if still at old defaults
    if fast_agent.get("system_prompt") == _OLD_SYSTEM_PROMPT:
        fast_agent["system_prompt"] = _NEW_SYSTEM_PROMPT
    if fast_agent.get("user_prompt") == _OLD_USER_PROMPT:
        fast_agent["user_prompt"] = _NEW_USER_PROMPT

    config["agent"] = agent

    # Rename llm_profiles.codeact -> llm_profiles.fast_agent
    profiles = config.get("llm_profiles", {})
    if "codeact" in profiles and "fast_agent" not in profiles:
        profiles["fast_agent"] = profiles.pop("codeact")

    return config

```

`droidrun/config_manager/path_resolver.py`:

```py
"""
Unified path resolution for DroidRun.

This module provides a single path resolver that handles all file path resolution
with consistent priority: working directory first, then package directory.
"""

from pathlib import Path
from typing import Union


class PathResolver:
    """
    Unified path resolver for all DroidRun file operations.

    Resolution order:
    1. Absolute paths ‚Üí use as-is
    2. Relative paths ‚Üí check working dir first, then package dir (bundled resources)
    3. For creation ‚Üí prefer working dir
    """

    @staticmethod
    def get_project_root() -> Path:
        """
        Get the package root directory (where config/ bundled resources live).

        This is 1 parent up from this file's location:
        droidrun/config_manager/path_resolver.py -> droidrun/ (package root)
        """
        return Path(__file__).resolve().parents[1]

    @staticmethod
    def resolve(
        path: Union[str, Path],
        create_if_missing: bool = False,
        must_exist: bool = False,
    ) -> Path:
        """
        Universal path resolver for all file operations.

        Resolution order:
        1. Absolute path ‚Üí use as-is
        2. Relative path:
           - If creating: prefer working directory (for user outputs)
           - If reading: check working dir first, then package dir (for bundled resources)
        3. If must_exist and not found ‚Üí raise FileNotFoundError

        Args:
            path: Path to resolve (str or Path object). Use absolute paths to avoid
                 ambiguity, or relative paths for portable configs.
            create_if_missing: If True, prefer working dir for relative paths (output mode).
                              Does not create the file/directory, just determines the location.
            must_exist: If True, raise FileNotFoundError if path doesn't exist after resolution.
                       Use for required config files and prompts.

        Returns:
            Resolved absolute Path object

        Raises:
            FileNotFoundError: If must_exist=True and path not found in any location.
                              Error message includes both checked locations.

        Security Note:
            Expands tilde (~) to user home directory. Does not follow symlinks during
            resolution, but the returned path may point to a symlink target.

        Examples:
            # Reading config (checks CWD first, then package dir)
            config_path = PathResolver.resolve("config.yaml")

            # Creating output (creates in CWD)
            output_dir = PathResolver.resolve("trajectories", create_if_missing=True)

            # Loading prompts (must exist, checks both locations)
            prompt = PathResolver.resolve("config/prompts/system.jinja2", must_exist=True)

            # Absolute path (used as-is)
            abs_path = PathResolver.resolve("/tmp/output")
        """
        # Convert to Path and expand user home directory (~/)
        path = Path(path).expanduser()

        # Absolute paths: use as-is
        if path.is_absolute():
            if must_exist and not path.exists():
                raise FileNotFoundError(f"Path not found: {path}")
            return path

        # Relative paths: check working dir and package dir
        cwd_path = Path.cwd() / path
        package_path = PathResolver.get_project_root() / path

        # For creation, always prefer working directory (user's context)
        if create_if_missing:
            return cwd_path

        # For reading, check both locations (working dir first)
        if cwd_path.exists():
            return cwd_path
        if package_path.exists():
            return package_path

        # Not found in either location
        if must_exist:
            raise FileNotFoundError(
                f"Path not found in:\n"
                f"  - Working dir: {cwd_path}\n"
                f"  - Package dir: {package_path}"
            )

        # Default to working dir (user's context)
        return cwd_path

```

`droidrun/config_manager/prompt_loader.py`:

```py
"""
Prompt loading utility using Jinja2 templates.

Features:
- Loads from absolute file paths (resolved by AgentConfig + PathResolver)
- Conditional rendering: {% if variable %}...{% endif %}
- Loops with slicing: {% for item in items[-5:] %}...{% endfor %}
- Filters: {{ variable|default("fallback") }}
- Missing variables: silently ignored (renders as empty string)
- Extra variables: silently ignored
"""

from pathlib import Path
from typing import Any, Dict

import aiofiles
from jinja2 import Environment


class PromptLoader:
    """Jinja2 template renderer - loads from absolute file paths using aiofiles."""

    _env = None  # Cached Jinja2 environment

    @classmethod
    def _get_environment(cls) -> Environment:
        """Get or create cached Jinja2 environment."""
        if cls._env is None:
            cls._env = Environment(
                trim_blocks=True,  # Remove first newline after block
                lstrip_blocks=True,  # Strip leading whitespace before blocks
                keep_trailing_newline=False,
            )

        return cls._env

    @staticmethod
    async def load_prompt(file_path: str, variables: Dict[str, Any] = None) -> str:
        """
        Load and render Jinja2 template from absolute file path.

        Path resolution is handled by AgentConfig + PathResolver.
        This method just loads and renders.

        Args:
            file_path: ABSOLUTE path to template file (from AgentConfig methods)
            variables: Dict of variables to pass to template
                      - Missing variables: silently ignored (render as empty string)
                      - Extra variables: silently ignored

        Returns:
            Rendered prompt string

        Raises:
            FileNotFoundError: If template file doesn't exist

        """
        path = Path(file_path)

        if not path.exists():
            raise FileNotFoundError(f"Prompt file not found: {file_path}")

        # Read template content
        async with aiofiles.open(path, mode="r", encoding="utf-8") as f:
            template_content = await f.read()

        # Use render_template for actual rendering
        return PromptLoader.render_template(template_content, variables)

    @staticmethod
    def render_template(template_string: str, variables: Dict[str, Any] = None) -> str:
        """
        Render Jinja2 template from string (NOT file path).

        This is used for custom prompts passed at runtime.

        Args:
            template_string: Jinja2 template as string
            variables: Dict of variables to pass to template
                      - Missing variables: silently ignored (render as empty string)
                      - Extra variables: silently ignored

        Returns:
            Rendered prompt string

        """
        # Get cached environment and create template from string
        env = PromptLoader._get_environment()
        template = env.from_string(template_string)

        # Render with variables (empty dict if None)
        # Missing variables render as empty string (default Undefined behavior)
        # Extra variables are silently ignored
        return template.render(**(variables or {}))

```

`droidrun/config_manager/safe_execution.py`:

```py
"""
Safe execution configuration for code executors.

This module provides configuration and utilities for restricting code execution
in CodeAct and Scripter agents. It defines which modules and builtins are allowed
or blocked when safe_execution mode is enabled.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set

# Default safe builtins (used when allow_all_builtins=False and allowed_builtins is empty)
DEFAULT_SAFE_BUILTINS = {
    # Type constructors
    "int",
    "float",
    "str",
    "bool",
    "list",
    "dict",
    "tuple",
    "set",
    "frozenset",
    "complex",
    "bytes",
    "bytearray",
    # Iteration and inspection
    "range",
    "enumerate",
    "zip",
    "map",
    "filter",
    "sorted",
    "reversed",
    "len",
    "sum",
    "min",
    "max",
    "any",
    "all",
    # Type checking
    "type",
    "isinstance",
    "issubclass",
    "callable",
    # Attribute access
    "getattr",
    "setattr",
    "hasattr",
    "delattr",
    "dir",
    # Math
    "abs",
    "round",
    "pow",
    "divmod",
    # Output
    "print",
    "repr",
    "chr",
    "ord",
    "hex",
    "oct",
    "bin",
    "format",
    # Exceptions
    "Exception",
    "ValueError",
    "TypeError",
    "KeyError",
    "IndexError",
    "AttributeError",
    "RuntimeError",
    "StopIteration",
    "ZeroDivisionError",
    "NameError",
    "ImportError",
    # Special
    "True",
    "False",
    "None",
    "NotImplemented",
    "Ellipsis",
    # Object operations
    "object",
    "super",
    "property",
    "staticmethod",
    "classmethod",
    # Utility
    "slice",
    "hash",
    "id",
    "vars",
}


@dataclass
class SafeExecutionConfig:
    """
    Safe code execution configuration (shared by CodeAct and Scripter).

    When safe_execution is enabled in an agent, this config determines what
    modules and builtins are accessible.

    Defaults (when safe_execution=True):
    - allow_all_imports=False: No imports allowed by default
    - allow_all_builtins=False: Only DEFAULT_SAFE_BUILTINS allowed
    - Network operations blocked by default (can enable via allowed_modules)
    """

    # === Import Control ===
    # Allow all imports (takes precedence, overrides allowed_modules)
    allow_all_imports: bool = False

    # Allowed modules (empty + allow_all_imports=False = no imports allowed)
    allowed_modules: List[str] = field(default_factory=list)

    # Blocked modules (takes precedence over allowed_modules and allow_all_imports)
    blocked_modules: List[str] = field(default_factory=list)

    # === Builtin Control ===
    # Allow all builtins (takes precedence, overrides allowed_builtins)
    allow_all_builtins: bool = False

    # Allowed builtins (empty + allow_all_builtins=False = use DEFAULT_SAFE_BUILTINS)
    allowed_builtins: List[str] = field(default_factory=list)

    # Blocked builtins (takes precedence over allowed_builtins and allow_all_builtins)
    blocked_builtins: List[str] = field(default_factory=list)

    def get_allowed_modules(self) -> Optional[Set[str]]:
        """
        Get final set of allowed modules for import restriction.

        Returns:
            None if all imports allowed (allow_all_imports=True)
            Empty set if no imports allowed
            Set of allowed module names otherwise
        """
        if self.allow_all_imports:
            # All imports allowed (except blocked)
            return None

        if not self.allowed_modules:
            # No imports allowed (strict default)
            return set()

        # Only specified modules allowed
        return set(self.allowed_modules) - set(self.blocked_modules)

    def get_blocked_modules(self) -> Set[str]:
        """
        Get final set of blocked modules.

        These modules are always blocked regardless of allow_all_imports or allowed_modules.

        Returns:
            Set of blocked module names (takes precedence over all other settings)
        """
        return set(self.blocked_modules)

    def get_allowed_builtins(self) -> Optional[Set[str]]:
        """
        Get final set of allowed builtins.

        Returns:
            None if all builtins allowed (allow_all_builtins=True)
            DEFAULT_SAFE_BUILTINS if allowed_builtins is empty
            Set of allowed builtin names otherwise
        """
        if self.allow_all_builtins:
            # All builtins allowed (except blocked)
            return None

        if not self.allowed_builtins:
            # Use default safe set
            return DEFAULT_SAFE_BUILTINS - set(self.blocked_builtins)

        # Use custom allowed set
        return set(self.allowed_builtins) - set(self.blocked_builtins)

    def get_blocked_builtins(self) -> Set[str]:
        """
        Get final set of blocked builtins.

        These builtins are always blocked regardless of allow_all_builtins or allowed_builtins.

        Returns:
            Set of blocked builtin names (takes precedence over all other settings)
        """
        return set(self.blocked_builtins)


def create_safe_builtins(
    allowed_builtins: Optional[Set[str]] = None,
    blocked_builtins: Optional[Set[str]] = None,
) -> Dict[str, Any]:
    """
    Create restricted builtins dictionary.

    Args:
        allowed_builtins: Set of allowed builtins (None = allow all)
        blocked_builtins: Set of blocked builtins (takes precedence)

    Returns:
        Dictionary of safe builtins
    """
    blocked = blocked_builtins or set()

    # Get original builtins
    original_builtins = (
        __builtins__ if isinstance(__builtins__, dict) else __builtins__.__dict__
    )

    # If None, allow all except blocked
    if allowed_builtins is None:
        safe_dict = {}
        for name, value in original_builtins.items():
            if name not in blocked:
                safe_dict[name] = value
        return safe_dict

    # Otherwise, only allow specified
    safe_dict = {}
    for name in allowed_builtins:
        if name in original_builtins and name not in blocked:
            safe_dict[name] = original_builtins[name]

    return safe_dict


def create_safe_import(
    allowed_modules: Optional[Set[str]] = None,
    blocked_modules: Optional[Set[str]] = None,
):
    """
    Create a restricted __import__ function.

    Args:
        allowed_modules: Set of allowed modules (None = allow all, empty set = allow none)
        blocked_modules: Set of blocked modules (takes precedence)

    Returns:
        Restricted import function
    """
    original_import = (
        __builtins__.__import__ if hasattr(__builtins__, "__import__") else __import__
    )
    blocked = blocked_modules or set()

    def safe_import(name, globals=None, locals=None, fromlist=(), level=0):
        # Get base module name (e.g., 'os' from 'os.path')
        base_module = name.split(".")[0]

        # Check blocked list first (always enforced)
        if base_module in blocked:
            raise ImportError(
                f"Module '{name}' is blocked in safe execution mode. "
                f"Blocked modules: {', '.join(sorted(blocked))}"
            )

        # Check allowed list
        if allowed_modules is not None:
            # If allowed_modules is empty set, no imports allowed
            if not allowed_modules:
                raise ImportError(
                    f"Module '{name}' cannot be imported. No imports are allowed in safe execution mode. "
                    f"Set 'allow_all_imports: true' or add modules to 'allowed_modules' to enable imports."
                )

            # If allowed_modules is non-empty set, check membership
            if base_module not in allowed_modules:
                raise ImportError(
                    f"Module '{name}' is not in the allowed modules list. "
                    f"Allowed modules: {', '.join(sorted(allowed_modules))}"
                )

        # If allowed_modules is None, all imports allowed (except blocked)
        return original_import(name, globals, locals, fromlist, level)

    return safe_import

```

`droidrun/credential_manager/__init__.py`:

```py
"""Credential management for DroidRun."""

from droidrun.credential_manager.credential_manager import (
    CredentialManager,
    CredentialNotFoundError,
)
from droidrun.credential_manager.file_credential_manager import FileCredentialManager

__all__ = [
    "CredentialManager",
    "CredentialNotFoundError",
    "FileCredentialManager",
]

```

`droidrun/credential_manager/credential_manager.py`:

```py
from abc import ABC, abstractmethod
from typing import List


class CredentialNotFoundError(KeyError):
    """Raised when a credential key is not found."""

    pass


class CredentialManager(ABC):
    """Abstract base class for credential resolution."""

    @abstractmethod
    async def resolve_key(self, key: str) -> str:
        """
        Resolve and return the value for the given credential key.

        Args:
            key: Credential identifier

        Returns:
            The credential value as a string

        Raises:
            CredentialNotFoundError: If key doesn't exist
        """
        pass

    @abstractmethod
    async def get_keys(self) -> List[str]:
        """
        Get all available credential keys.

        Returns:
            List of credential identifiers
        """
        pass

```

`droidrun/credential_manager/file_credential_manager.py`:

```py
import logging
from typing import Any, Dict, Optional

import yaml

from droidrun.config_manager.path_resolver import PathResolver
from droidrun.credential_manager.credential_manager import (
    CredentialManager,
    CredentialNotFoundError,
)

logger = logging.getLogger("droidrun")


class FileCredentialManager(CredentialManager):
    """
    Credential manager that supports both dict and YAML file sources.
    """

    def __init__(self, credentials: Any):
        """
        Initialize credential manager from dict or file path.

        Args:
            credentials: Either dict or string (file path) or CredentialsConfig
        """
        self.path: Optional[str] = None
        self.secrets = self._load(credentials)

        if self.path:
            logger.debug(f"‚úÖ Loaded {len(self.secrets)} secrets from {self.path}")
        else:
            logger.debug(f"‚úÖ Loaded {len(self.secrets)} secrets from in-memory dict")

    def _load(self, credentials: Any) -> Dict[str, str]:
        """Load credentials from dict or file."""
        from droidrun.config_manager.config_manager import CredentialsConfig

        # Dict mode
        if isinstance(credentials, dict):
            return self._load_from_dict(credentials)

        # CredentialsConfig mode
        if isinstance(credentials, CredentialsConfig):
            if not credentials.enabled:
                logger.debug("Credentials disabled in config")
                return {}
            self.path = credentials.file_path
            return self._load_from_file(credentials.file_path)

        # String mode (direct file path)
        if isinstance(credentials, str):
            self.path = credentials
            return self._load_from_file(credentials)

        logger.warning(f"Unknown credentials type: {type(credentials)}")
        return {}

    def _load_from_dict(self, credentials_dict: dict) -> Dict[str, str]:
        """Load credentials from in-memory dict."""
        secrets = {}
        for secret_id, secret_value in credentials_dict.items():
            if isinstance(secret_value, str) and secret_value:
                secrets[secret_id] = secret_value
            else:
                logger.warning(
                    f"Skipped invalid secret: {secret_id} (type={type(secret_value)})"
                )
        return secrets

    def _load_from_file(self, file_path: str) -> Dict[str, str]:
        """
        Load credentials from YAML file.

        File format:
            secrets:
              MY_PASSWORD:
                value: "secret123"
                enabled: true
              SIMPLE_KEY: "simple_value"  # Auto-enabled

        Returns:
            Dict of enabled secrets {secret_id: secret_value}
        """
        path = PathResolver.resolve(file_path, must_exist=True)
        with open(path, "r") as f:
            data = yaml.safe_load(f)

        if not data or "secrets" not in data:
            logger.warning(f"No 'secrets' section found in {path}")
            return {}

        secrets = {}
        for secret_id, secret_data in data["secrets"].items():
            if isinstance(secret_data, dict):
                enabled = secret_data.get("enabled", True)
                value = secret_data.get("value", "")
            else:
                enabled = True
                value = secret_data

            if enabled and value:
                secrets[secret_id] = value
                logger.debug(f"Loaded secret: {secret_id}")
            else:
                logger.debug(
                    f"Skipped secret: {secret_id} (enabled={enabled}, has_value={bool(value)})"
                )

        return secrets

    async def resolve_key(self, key: str) -> str:
        """Get secret value by key."""
        logger.debug(f"üîë Accessing secret: '{key}'")

        if key not in self.secrets:
            available = list(self.secrets.keys())
            raise CredentialNotFoundError(
                f"Secret '{key}' not found. Available: {available}"
            )

        return self.secrets[key]

    async def get_keys(self) -> list[str]:
        """Get all available credential keys."""
        return list(self.secrets.keys())

    def has_credential(self, secret_id: str) -> bool:
        """Check if secret ID exists."""
        return secret_id in self.secrets

    def __repr__(self) -> str:
        """String representation."""
        count = len(self.secrets)
        if self.path:
            return f"<FileCredentialManager path={self.path} secrets={count}>"
        return f"<FileCredentialManager mode=dict secrets={count}>"

```

`droidrun/log_handlers.py`:

```py
"""
Logging handlers for DroidRun.

Provides CLILogHandler (Rich colored terminal output) and TUILogHandler
(record buffer for deferred Textual rendering). Both support extra params:

    color:      logger.info("msg", extra={"color": "blue"})
    stream:     logger.info(token, extra={"stream": True})
    stream_end: logger.info("", extra={"stream_end": True})
"""

import logging

from rich.console import Console

COLORS = frozenset(
    {"blue", "cyan", "green", "red", "yellow", "magenta", "white", "dim"}
)


def configure_logging(debug: bool, handler: logging.Handler) -> None:
    """Replace all handlers on the ``droidrun`` logger."""
    logger = logging.getLogger("droidrun")
    logger.handlers = []
    logger.addHandler(handler)
    logger.setLevel(logging.DEBUG if debug else logging.INFO)
    logger.propagate = False


class CLILogHandler(logging.Handler):
    """Rich-colored line output for CLI and SDK use."""

    def __init__(self, level: int = logging.NOTSET) -> None:
        super().__init__(level)
        self.console = Console()

    def emit(self, record: logging.LogRecord) -> None:
        try:
            msg = self.format(record)
            color = getattr(record, "color", None)
            stream = getattr(record, "stream", False)
            stream_end = getattr(record, "stream_end", False)

            if stream:
                # style= applies color without markup parsing
                self.console.print(msg, end="", highlight=False, markup=False)
            elif stream_end:
                self.console.print("", highlight=False)
            elif color and color in COLORS:
                self.console.print(msg, style=color, highlight=False, markup=False)
            else:
                self.console.print(msg, highlight=False, markup=False)
        except Exception:
            self.handleError(record)


class TUILogHandler(logging.Handler):
    """Captures log records for TUI rendering.

    Args:
        on_record: Optional callback invoked for every record with the record dict.
    """

    def __init__(self, on_record=None, level: int = logging.NOTSET) -> None:
        super().__init__(level)
        self.on_record = on_record
        self.records: list[dict] = []

    def emit(self, record: logging.LogRecord) -> None:
        try:
            msg = self.format(record)
            color = getattr(record, "color", None)
            stream = getattr(record, "stream", False)
            stream_end = getattr(record, "stream_end", False)

            rec = {
                "msg": msg,
                "color": color,
                "stream": stream,
                "stream_end": stream_end,
                "level": record.levelno,
            }
            self.records.append(rec)

            if self.on_record:
                self.on_record(rec)
        except Exception:
            self.handleError(record)

```

`droidrun/macro/__init__.py`:

```py
"""
DroidRun Macro Module - Record and replay UI automation sequences.

This module provides functionality to replay macro sequences that were
recorded during DroidAgent execution.
"""

from droidrun.macro.replay import MacroPlayer, replay_macro_file, replay_macro_folder

__all__ = ["MacroPlayer", "replay_macro_file", "replay_macro_folder"]

```

`droidrun/macro/__main__.py`:

```py
"""
Entry point for running DroidRun macro CLI as a module.

Usage: python -m droidrun.macro <command>
"""

from droidrun.macro.cli import macro_cli

if __name__ == "__main__":
    macro_cli()

```

`droidrun/macro/cli.py`:

```py
"""
Command-line interface for DroidRun macro replay.
"""

import asyncio
import logging
from typing import Optional

import click
from async_adbutils import adb
from rich.console import Console
from rich.table import Table

from droidrun.agent.utils.trajectory import Trajectory
from droidrun.config_manager.path_resolver import PathResolver
from droidrun.macro.replay import MacroPlayer

console = Console()


def configure_logging(debug: bool = False):
    """Configure logging for the macro CLI."""
    logger = logging.getLogger("droidrun-macro")
    logger.handlers = []

    handler = logging.StreamHandler()

    if debug:
        level = logging.DEBUG
        formatter = logging.Formatter("%(levelname)s %(name)s %(message)s", "%H:%M:%S")
    else:
        level = logging.INFO
        formatter = logging.Formatter("%(message)s", "%H:%M:%S")

    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(level)
    logger.propagate = False

    return logger


@click.group()
def macro_cli():
    """Replay recorded automation sequences."""
    pass


@macro_cli.command()
@click.argument("path", type=click.Path(exists=True))
@click.option("--device", "-d", help="Device serial number", default=None)
@click.option(
    "--delay", "-t", help="Delay between actions (seconds)", default=1.0, type=float
)
@click.option(
    "--start-from", "-s", help="Start from step number (1-based)", default=1, type=int
)
@click.option(
    "--max-steps", "-m", help="Maximum steps to execute", default=None, type=int
)
@click.option("--debug", is_flag=True, help="Enable debug logging", default=False)
@click.option(
    "--dry-run", is_flag=True, help="Show actions without executing", default=False
)
def replay(
    path: str,
    device: Optional[str],
    delay: float,
    start_from: int,
    max_steps: Optional[int],
    debug: bool,
    dry_run: bool,
):
    """Replay a macro from a file or trajectory folder."""
    logger = configure_logging(debug)

    logger.info("üé¨ DroidRun Macro Replay")

    # Convert start_from from 1-based to 0-based
    start_from_zero = max(0, start_from - 1)

    async def get_device():
        if device is None:
            logger.info("üîç Finding connected device...")
            devices = await adb.list()
            if not devices:
                raise ValueError("No connected devices found.")
            dev = devices[0].serial
            logger.info(f"üì± Using device: {dev}")
            return dev
        else:
            logger.info(f"üì± Using device: {device}")
            return device

    asyncio.run(
        _replay_with_device(
            path, device, delay, start_from_zero, max_steps, dry_run, logger, get_device
        )
    )


async def _replay_with_device(
    path: str,
    device: str,
    delay: float,
    start_from: int,
    max_steps: Optional[int],
    dry_run: bool,
    logger: logging.Logger,
    get_device,
):
    device = await get_device()
    await _replay_async(path, device, delay, start_from, max_steps, dry_run, logger)


async def _replay_async(
    path: str,
    device: str,
    delay: float,
    start_from: int,
    max_steps: Optional[int],
    dry_run: bool,
    logger: logging.Logger,
):
    """Async function to handle macro replay."""
    try:
        # Resolve path (checks working dir, then package dir)
        resolved_path = PathResolver.resolve(path, must_exist=True)

        if resolved_path.is_file():
            logger.info(f"üìÑ Loading macro from file: {resolved_path}")
            player = MacroPlayer(device_serial=device, delay_between_actions=delay)
            macro_data = player.load_macro_from_file(str(resolved_path))
        elif resolved_path.is_dir():
            logger.info(f"üìÅ Loading macro from folder: {resolved_path}")
            player = MacroPlayer(device_serial=device, delay_between_actions=delay)
            macro_data = player.load_macro_from_folder(str(resolved_path))
        else:
            logger.error(f"‚ùå Invalid path: {resolved_path}")
            return

        if not macro_data:
            logger.error("‚ùå Failed to load macro data")
            return

        # Show macro information
        description = macro_data.get("description", "No description")
        total_actions = macro_data.get("total_actions", 0)
        version = macro_data.get("version", "unknown")

        logger.info("üìã Macro Information:")
        logger.info(f"   Description: {description}")
        logger.info(f"   Version: {version}")
        logger.info(f"   Total actions: {total_actions}")
        logger.info(f"   Device: {device}")
        logger.info(f"   Delay between actions: {delay}s")

        if start_from > 0:
            logger.info(f"   Starting from step: {start_from + 1}")
        if max_steps:
            logger.info(f"   Maximum steps: {max_steps}")

        if dry_run:
            logger.info("üîç DRY RUN MODE - Actions will be shown but not executed")
            await _show_dry_run(macro_data, start_from, max_steps, logger)
        else:
            logger.info("‚ñ∂Ô∏è  Starting macro replay...")
            success = await player.replay_macro(
                macro_data, start_from_step=start_from, max_steps=max_steps
            )

            if success:
                logger.info("üéâ Macro replay completed successfully!")
            else:
                logger.error("üí• Macro replay completed with errors")

    except Exception as e:
        logger.error(f"üí• Error: {e}")
        if logger.isEnabledFor(logging.DEBUG):
            import traceback

            logger.debug(traceback.format_exc())


async def _show_dry_run(
    macro_data: dict, start_from: int, max_steps: Optional[int], logger: logging.Logger
):
    """Show what actions would be executed in dry run mode."""
    actions = macro_data.get("actions", [])

    # Apply filters
    if start_from > 0:
        actions = actions[start_from:]
    if max_steps:
        actions = actions[:max_steps]

    logger.info(f"üìã Found {len(actions)} actions to execute:")

    table = Table(title="Actions to Execute")
    table.add_column("Step", style="cyan")
    table.add_column("Type", style="green")
    table.add_column("Details", style="white")
    table.add_column("Description", style="yellow")

    for i, action in enumerate(actions, start=start_from + 1):
        action_type = action.get("action_type", action.get("type", "unknown"))
        details = ""

        if action_type == "tap":
            x, y = action.get("x", 0), action.get("y", 0)
            element_text = action.get("element_text", "")
            details = f"({x}, {y}) - '{element_text}'"
        elif action_type == "swipe":
            start_x, start_y = action.get("start_x", 0), action.get("start_y", 0)
            end_x, end_y = action.get("end_x", 0), action.get("end_y", 0)
            details = f"({start_x}, {start_y}) ‚Üí ({end_x}, {end_y})"
        elif action_type == "input_text":
            text = action.get("text", "")
            details = f"'{text}'"
        elif action_type == "key_press":
            key_name = action.get("key_name", "UNKNOWN")
            details = f"{key_name}"
        elif action_type == "wait":
            duration = action.get("duration", 1.0)
            details = f"{duration}s"

        description = action.get("description", "")
        table.add_row(
            str(i),
            action_type,
            details,
            description[:50] + "..." if len(description) > 50 else description,
        )

    # Still use console for table display as it's structured data
    console.print(table)


@macro_cli.command()
@click.argument("directory", type=click.Path(exists=True), default="trajectories")
@click.option("--debug", is_flag=True, help="Enable debug logging", default=False)
def list(directory: str, debug: bool):
    """List available trajectory folders in a directory."""
    logger = configure_logging(debug)

    # Resolve directory (checks working dir, then package dir)
    resolved_dir = PathResolver.resolve(directory, must_exist=True)
    logger.info(f"üìÅ Scanning directory: {resolved_dir}")

    try:
        folders = []
        for item in resolved_dir.iterdir():
            if item.is_dir():
                macro_file = item / "macro.json"
                if macro_file.exists():
                    # Load macro info
                    try:
                        macro_data = Trajectory.load_macro_sequence(str(item))
                        description = macro_data.get("description", "No description")
                        total_actions = macro_data.get("total_actions", 0)
                        folders.append((item.name, description, total_actions))
                    except Exception as e:
                        logger.debug(f"Error loading macro from {item.name}: {e}")
                        folders.append((item.name, "Error loading", 0))

        if not folders:
            logger.info("üì≠ No trajectory folders found")
            return

        logger.info(f"üéØ Found {len(folders)} trajectory(s):")

        table = Table(title=f"Available Trajectories in {directory}")
        table.add_column("Folder", style="cyan")
        table.add_column("Description", style="white")
        table.add_column("Actions", style="green")

        for folder, description, actions in sorted(folders):
            table.add_row(
                folder,
                description[:80] + "..." if len(description) > 80 else description,
                str(actions),
            )

        # Still use console for table display as it's structured data
        console.print(table)
        logger.info(
            f"üí° Use 'droidrun macro replay {resolved_dir}/<folder>' to replay a trajectory"
        )

    except Exception as e:
        logger.error(f"üí• Error: {e}")
        if logger.isEnabledFor(logging.DEBUG):
            import traceback

            logger.debug(traceback.format_exc())


if __name__ == "__main__":
    macro_cli()

```

`droidrun/macro/replay.py`:

```py
"""
Macro Replay Module - Replay recorded UI automation sequences.

This module provides functionality to load and replay macro JSON files
that were generated during DroidAgent trajectory recording.
"""

import asyncio
import logging
from typing import Any, Dict, Optional

from droidrun.agent.utils.trajectory import Trajectory
from droidrun.tools.driver.android import AndroidDriver

logger = logging.getLogger("droidrun-macro")


class MacroPlayer:
    """
    A class for loading and replaying DroidRun macro sequences.

    This player can execute recorded UI actions (taps, swipes, text input, key presses)
    on Android devices using AndroidDriver.
    """

    def __init__(self, device_serial: str = None, delay_between_actions: float = 1.0):
        """
        Initialize the MacroPlayer.

        Args:
            device_serial: Serial number of the target device. If None, will use first available device.
            delay_between_actions: Delay in seconds between each action (default: 1.0s)
        """
        self.device_serial = device_serial
        self.delay_between_actions = delay_between_actions
        self.driver: AndroidDriver | None = None

    async def _initialize_driver(self) -> AndroidDriver:
        """Initialize AndroidDriver for the target device."""
        if self.driver is None:
            self.driver = AndroidDriver(serial=self.device_serial)
            await self.driver.connect()
            logger.info(f"ü§ñ Initialized driver for device: {self.device_serial}")
        return self.driver

    def load_macro_from_file(self, macro_file_path: str) -> Dict[str, Any]:
        """
        Load macro data from a JSON file.

        Args:
            macro_file_path: Path to the macro JSON file

        Returns:
            Dictionary containing the macro data
        """
        return Trajectory.load_macro_sequence(macro_file_path)

    def load_macro_from_folder(self, trajectory_folder: str) -> Dict[str, Any]:
        """
        Load macro data from a trajectory folder.

        Args:
            trajectory_folder: Path to the trajectory folder containing macro.json

        Returns:
            Dictionary containing the macro data
        """
        return Trajectory.load_macro_sequence(trajectory_folder)

    async def replay_action(self, action: Dict[str, Any]) -> bool:
        """
        Replay a single action.

        Args:
            action: Action dictionary containing type and parameters

        Returns:
            True if action was executed successfully, False otherwise
        """
        driver = await self._initialize_driver()
        action_type = action.get("action_type", action.get("type", "unknown"))

        try:
            if action_type == "start_app":
                package = action.get("package")
                activity = action.get("activity", None)
                await driver.start_app(package, activity)
                return True

            elif action_type == "tap":
                x = action.get("x", 0)
                y = action.get("y", 0)
                logger.info(f"ü´∞ Tapping at ({x}, {y})")
                await driver.tap(x, y)
                return True

            elif action_type == "swipe":
                start_x = action.get("start_x", 0)
                start_y = action.get("start_y", 0)
                end_x = action.get("end_x", 0)
                end_y = action.get("end_y", 0)
                duration_ms = action.get("duration_ms", 300)

                logger.info(
                    f"üëÜ Swiping from ({start_x}, {start_y}) to ({end_x}, {end_y}) in {duration_ms}ms"
                )
                await driver.swipe(start_x, start_y, end_x, end_y, duration_ms)
                # Additional wait after swipe for UI to settle
                await asyncio.sleep(2)
                return True

            elif action_type == "drag":
                start_x = action.get("start_x", 0)
                start_y = action.get("start_y", 0)
                end_x = action.get("end_x", 0)
                end_y = action.get("end_y", 0)
                duration = action.get(
                    "duration", action.get("duration_ms", 300) / 1000.0
                )

                logger.info(
                    f"üëÜ Dragging from ({start_x}, {start_y}) to ({end_x}, {end_y})"
                )
                await driver.drag(start_x, start_y, end_x, end_y, duration)
                return True

            elif action_type == "input_text":
                text = action.get("text", "")
                clear = action.get("clear", False)
                logger.info(f"‚å®Ô∏è  Inputting text: '{text}'")
                await driver.input_text(text, clear)
                return True

            elif action_type == "key_press":
                keycode = action.get("keycode", 0)
                logger.info(f"üîò Pressing key: {keycode}")
                await driver.press_key(keycode)
                return True

            elif action_type == "back":
                logger.info("‚¨ÖÔ∏è  Pressing back button")
                await driver.press_key(4)
                return True

            elif action_type == "wait":
                duration = action.get("duration", 1.0)
                logger.info(f"‚è≥ Waiting for {duration} seconds")
                await asyncio.sleep(duration)
                return True

            else:
                logger.warning(f"‚ö†Ô∏è  Unknown action type: {action_type}")
                return False

        except Exception as e:
            logger.error(f"‚ùå Error executing action {action_type}: {e}")
            return False

    async def replay_macro(
        self,
        macro_data: Dict[str, Any],
        start_from_step: int = 0,
        max_steps: Optional[int] = None,
    ) -> bool:
        """
        Replay a complete macro sequence.

        Args:
            macro_data: Macro data dictionary loaded from JSON
            start_from_step: Step number to start from (0-based, default: 0)
            max_steps: Maximum number of steps to execute (default: all)

        Returns:
            True if all actions were executed successfully, False otherwise
        """
        if not macro_data or "actions" not in macro_data:
            logger.error("‚ùå Invalid macro data - no actions found")
            return False

        actions = macro_data["actions"]
        description = macro_data.get("description", "Unknown macro")
        total_actions = len(actions)

        # Apply start_from_step and max_steps filters
        if start_from_step > 0:
            actions = actions[start_from_step:]
            logger.info(f"üìç Starting from step {start_from_step + 1}")

        if max_steps is not None:
            actions = actions[:max_steps]
            logger.info(f"üéØ Limiting to {max_steps} steps")

        logger.info(f"üé¨ Starting macro replay: '{description}'")
        logger.info(f"üìä Total actions to execute: {len(actions)} / {total_actions}")

        success_count = 0
        failed_count = 0

        for i, action in enumerate(actions, start=start_from_step + 1):
            action_type = action.get("action_type", action.get("type", "unknown"))
            description_text = action.get("description", "")

            logger.info(f"\nüìç Step {i}/{total_actions}: {action_type}")
            if description_text:
                logger.info(f"   Description: {description_text}")

            # Execute the action
            success = await self.replay_action(action)

            if success:
                success_count += 1
                logger.info("   ‚úÖ Action completed successfully")
            else:
                failed_count += 1
                logger.error("   ‚ùå Action failed")

            # Wait between actions (except for the last one)
            if i < len(actions):
                logger.debug(f"   ‚è≥ Waiting {self.delay_between_actions}s...")
                await asyncio.sleep(self.delay_between_actions)

        # Summary
        total_executed = success_count + failed_count
        success_rate = (
            (success_count / total_executed * 100) if total_executed > 0 else 0
        )

        logger.info("\nüéâ Macro replay completed!")
        logger.info(
            f"üìä Success: {success_count}/{total_executed} ({success_rate:.1f}%)"
        )

        if failed_count > 0:
            logger.warning(f"‚ö†Ô∏è  Failed actions: {failed_count}")

        return failed_count == 0


# Utility functions for convenience


async def replay_macro_file(
    macro_file_path: str,
    device_serial: str = None,
    delay_between_actions: float = 1.0,
    start_from_step: int = 0,
    max_steps: Optional[int] = None,
) -> bool:
    """
    Convenience function to replay a macro from a file.

    Args:
        macro_file_path: Path to the macro JSON file
        device_serial: Target device serial (optional)
        delay_between_actions: Delay between actions in seconds
        start_from_step: Step to start from (0-based)
        max_steps: Maximum steps to execute

    Returns:
        True if replay was successful, False otherwise
    """
    player = MacroPlayer(
        device_serial=device_serial, delay_between_actions=delay_between_actions
    )

    try:
        macro_data = player.load_macro_from_file(macro_file_path)
        return await player.replay_macro(
            macro_data, start_from_step=start_from_step, max_steps=max_steps
        )
    except Exception as e:
        logger.error(f"‚ùå Error replaying macro file {macro_file_path}: {e}")
        return False


async def replay_macro_folder(
    trajectory_folder: str,
    device_serial: str = None,
    delay_between_actions: float = 1.0,
    start_from_step: int = 0,
    max_steps: Optional[int] = None,
) -> bool:
    """
    Convenience function to replay a macro from a trajectory folder.

    Args:
        trajectory_folder: Path to the trajectory folder containing macro.json
        device_serial: Target device serial (optional)
        delay_between_actions: Delay between actions in seconds
        start_from_step: Step to start from (0-based)
        max_steps: Maximum steps to execute

    Returns:
        True if replay was successful, False otherwise
    """
    player = MacroPlayer(
        device_serial=device_serial, delay_between_actions=delay_between_actions
    )

    try:
        macro_data = player.load_macro_from_folder(trajectory_folder)
        return await player.replay_macro(
            macro_data, start_from_step=start_from_step, max_steps=max_steps
        )
    except Exception as e:
        logger.error(f"‚ùå Error replaying macro folder {trajectory_folder}: {e}")
        return False

```

`droidrun/mcp/__init__.py`:

```py
"""MCP client integration for DroidRun."""

from droidrun.mcp.config import MCPConfig, MCPServerConfig
from droidrun.mcp.client import MCPClientManager, MCPToolInfo
from droidrun.mcp.adapter import mcp_to_droidrun_tools

__all__ = [
    "MCPConfig",
    "MCPServerConfig",
    "MCPClientManager",
    "MCPToolInfo",
    "mcp_to_droidrun_tools",
]

```

`droidrun/mcp/adapter.py`:

```py
"""Adapter to convert MCP tools to DroidRun custom tool format."""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from droidrun.mcp.client import MCPClientManager


def schema_to_parameters(input_schema: dict) -> dict[str, dict[str, Any]]:
    """Convert JSON Schema properties to DroidRun parameters format.

    Args:
        input_schema: JSON Schema with "properties" and "required" fields.

    Returns:
        Dict mapping param name to {"type": ..., "required": ..., "default": ...}.
    """
    properties = input_schema.get("properties", {})
    required = set(input_schema.get("required", []))

    parameters: dict[str, dict[str, Any]] = {}
    for prop_name, prop_info in properties.items():
        param: dict[str, Any] = {
            "type": prop_info.get("type", "string"),
            "required": prop_name in required,
        }
        if "default" in prop_info:
            param["default"] = prop_info["default"]
        if "description" in prop_info:
            param["description"] = prop_info["description"]
        parameters[prop_name] = param

    return parameters


def mcp_to_droidrun_tools(mcp_manager: "MCPClientManager") -> dict[str, dict[str, Any]]:
    """Convert discovered MCP tools to DroidRun custom tool format."""
    custom_tools: dict[str, dict[str, Any]] = {}

    for tool_name, tool_info in mcp_manager.tools.items():
        wrapper = _create_tool_wrapper(tool_name, mcp_manager)
        custom_tools[tool_name] = {
            "parameters": schema_to_parameters(tool_info.input_schema),
            "description": tool_info.description,
            "function": wrapper,
        }

    return custom_tools


def _create_tool_wrapper(tool_name: str, manager: "MCPClientManager"):
    """Create async wrapper function for an MCP tool."""

    async def mcp_tool_wrapper(*, ctx=None, **kwargs) -> str:
        result = await manager.call_tool(tool_name, kwargs)

        if hasattr(result, "content") and result.content:
            text_parts = []
            for block in result.content:
                if hasattr(block, "text") and block.text:
                    text_parts.append(block.text)
            if text_parts:
                return "\n".join(text_parts)

        return str(result)

    mcp_tool_wrapper.__name__ = f"mcp_{tool_name}"
    return mcp_tool_wrapper

```

`droidrun/mcp/client.py`:

```py
"""MCP Client Manager - handles connections to MCP servers."""

from __future__ import annotations

import logging
from contextlib import AsyncExitStack
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

if TYPE_CHECKING:
    from droidrun.mcp.config import MCPConfig, MCPServerConfig

logger = logging.getLogger("droidrun")


@dataclass
class MCPToolInfo:
    """Cached metadata about an MCP tool."""

    server_name: str
    original_name: str
    description: str
    input_schema: dict


class MCPClientManager:
    """Manages MCP server connections with lazy initialization."""

    def __init__(self, config: "MCPConfig"):
        self.config = config
        self._tools: dict[str, MCPToolInfo] = {}
        self._server_tools: dict[str, list[str]] = {}
        self._sessions: dict[str, ClientSession] = {}
        self._exit_stacks: dict[str, AsyncExitStack] = {}

    async def discover_tools(self) -> dict[str, MCPToolInfo]:
        """Discover tools from all configured servers."""
        if not self.config.enabled:
            return {}

        for server_name, server_config in self.config.servers.items():
            if not server_config.enabled:
                continue
            try:
                await self._discover_server_tools(server_name, server_config)
            except Exception as e:
                logger.warning(f"MCP '{server_name}': discovery failed: {e}")

        if self._tools:
            logger.info(
                f"MCP: discovered {len(self._tools)} tools from {len(self._server_tools)} servers"
            )
        return self._tools

    async def _discover_server_tools(
        self, server_name: str, config: "MCPServerConfig"
    ) -> None:
        """Connect temporarily to fetch tool schemas."""
        server_params = StdioServerParameters(
            command=config.command,
            args=config.args,
            env=config.env if config.env else None,
        )

        server_tool_names: list[str] = []

        async with AsyncExitStack() as stack:
            transport = await stack.enter_async_context(stdio_client(server_params))
            read, write = transport
            session = await stack.enter_async_context(ClientSession(read, write))
            await session.initialize()

            response = await session.list_tools()
            prefix = config.prefix if config.prefix is not None else f"{server_name}_"

            for tool in response.tools:
                if not self._should_include_tool(tool.name, config):
                    continue

                tool_name = f"{prefix}{tool.name}" if prefix else tool.name
                self._tools[tool_name] = MCPToolInfo(
                    server_name=server_name,
                    original_name=tool.name,
                    description=tool.description or f"MCP tool: {tool.name}",
                    input_schema=tool.inputSchema,
                )
                server_tool_names.append(tool_name)

        self._server_tools[server_name] = server_tool_names
        logger.debug(f"MCP '{server_name}': discovered {len(server_tool_names)} tools")

    def _should_include_tool(self, tool_name: str, config: "MCPServerConfig") -> bool:
        """Check if tool passes include/exclude filters."""
        if tool_name in config.exclude_tools:
            return False
        if config.include_tools is not None:
            return tool_name in config.include_tools
        return True

    async def call_tool(self, tool_name: str, arguments: dict) -> Any:
        """Call an MCP tool, connecting lazily if needed."""
        if tool_name not in self._tools:
            raise ValueError(f"Unknown MCP tool: {tool_name}")

        tool_info = self._tools[tool_name]
        server_name = tool_info.server_name

        if server_name not in self._sessions:
            await self._connect_server(server_name)

        session = self._sessions[server_name]
        return await session.call_tool(tool_info.original_name, arguments)

    async def _connect_server(self, server_name: str) -> None:
        """Establish persistent connection to a server."""
        config = self.config.servers[server_name]
        server_params = StdioServerParameters(
            command=config.command,
            args=config.args,
            env=config.env if config.env else None,
        )

        logger.debug(f"MCP '{server_name}': connecting...")

        stack = AsyncExitStack()
        self._exit_stacks[server_name] = stack

        transport = await stack.enter_async_context(stdio_client(server_params))
        read, write = transport
        session = await stack.enter_async_context(ClientSession(read, write))
        await session.initialize()

        self._sessions[server_name] = session
        logger.info(f"MCP '{server_name}': connected")

    async def disconnect_all(self) -> None:
        """Clean up all server connections."""
        for server_name, stack in list(self._exit_stacks.items()):
            try:
                await stack.aclose()
                logger.debug(f"MCP '{server_name}': disconnected")
            except Exception as e:
                logger.warning(f"MCP '{server_name}': disconnect error: {e}")

        self._sessions.clear()
        self._exit_stacks.clear()

    @property
    def tools(self) -> dict[str, MCPToolInfo]:
        return self._tools

    @property
    def connected_servers(self) -> list[str]:
        return list(self._sessions.keys())

```

`droidrun/mcp/config.py`:

```py
"""MCP configuration models."""

from dataclasses import dataclass, field
from typing import Dict, List, Optional


@dataclass
class MCPServerConfig:
    """Configuration for a single MCP server."""

    command: str = ""
    args: List[str] = field(default_factory=list)
    env: Dict[str, str] = field(default_factory=dict)
    prefix: Optional[str] = None
    enabled: bool = True
    include_tools: Optional[List[str]] = None
    exclude_tools: List[str] = field(default_factory=list)


@dataclass
class MCPConfig:
    """MCP client configuration."""

    enabled: bool = False
    servers: Dict[str, MCPServerConfig] = field(default_factory=dict)

```

`droidrun/portal.py`:

```py
"""
Portal APK management and device communication utilities.

This module handles downloading, installing, and managing the DroidRun Portal app
on Android devices. It also provides utilities for checking accessibility service
status and managing device communication modes (TCP and content provider).
"""

import asyncio
import contextlib
import os
import tempfile

import requests
from rich.console import Console

from droidrun.tools.driver.android import AndroidDriver
from async_adbutils import AdbDevice, adb

REPO = "droidrun/droidrun-portal"
ASSET_NAME = "droidrun-portal"
GITHUB_API_HOSTS = ["https://api.github.com", "https://ungh.cc"]

VERSION_MAP_GIST_URL = "https://raw.githubusercontent.com/droidrun/gists/refs/heads/main/version_map_android.json"

PORTAL_PACKAGE_NAME = "com.droidrun.portal"
A11Y_SERVICE_NAME = (
    f"{PORTAL_PACKAGE_NAME}/com.droidrun.portal.service.DroidrunAccessibilityService"
)


def get_version_mapping(debug: bool = False) -> dict | None:
    try:
        response = requests.get(VERSION_MAP_GIST_URL, timeout=10)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        if debug:
            print(f"Failed to fetch version mapping: {e}")
        return None


def _version_in_range(version: str, range_str: str) -> bool:
    if "-" not in range_str:
        return False
    try:
        start, end = range_str.split("-", 1)
        v_parts = [int(x) for x in version.split(".")]
        s_parts = [int(x) for x in start.split(".")]
        e_parts = [int(x) for x in end.split(".")]
        return s_parts <= v_parts <= e_parts
    except (ValueError, AttributeError):
        return False


def get_compatible_portal_version(
    droidrun_version: str, debug: bool = False
) -> tuple[str | None, str, bool]:
    mapping = get_version_mapping(debug)
    if mapping is None:
        return (None, "", False)

    mappings = mapping.get("mappings", {})
    download_base = mapping.get(
        "download_base", "https://github.com/droidrun/droidrun-portal/releases/download"
    )

    # Try exact match first
    if droidrun_version in mappings:
        return (mappings[droidrun_version], download_base, True)

    # Try range match (e.g., "0.4.0-0.4.14": "1.0.0")
    for key, portal_version in mappings.items():
        if "-" in key and _version_in_range(droidrun_version, key):
            return (portal_version, download_base, True)

    return (None, download_base, True)


@contextlib.contextmanager
def download_versioned_portal_apk(
    version: str, download_base: str, debug: bool = False
):
    """Download a specific Portal APK version."""
    console = Console()
    asset_url = f"{download_base}/{version}/{ASSET_NAME}-{version}.apk"

    console.print(f"Downloading Portal APK [bold]{version}[/bold]")
    if debug:
        console.print(f"Asset URL: {asset_url}")

    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".apk")
    try:
        r = requests.get(asset_url, stream=True)
        r.raise_for_status()
        for chunk in r.iter_content(chunk_size=8192):
            if chunk:
                tmp.write(chunk)
        tmp.close()
        yield tmp.name
    finally:
        if os.path.exists(tmp.name):
            os.unlink(tmp.name)


def get_latest_release_assets(debug: bool = False):
    """
    Fetch the latest Portal APK release assets from GitHub.

    Args:
        debug: Enable debug logging

    Returns:
        List of asset dictionaries from the latest GitHub release

    Raises:
        requests.HTTPError: If the GitHub API request fails
    """
    for host in GITHUB_API_HOSTS:
        url = f"{host}/repos/{REPO}/releases/latest"
        response = requests.get(url)
        if response.status_code == 200:
            if debug:
                print(f"Using GitHub release on {host}")
            break

    response.raise_for_status()
    latest_release = response.json()

    if "release" in latest_release:
        assets = latest_release["release"]["assets"]
    else:
        assets = latest_release.get("assets", [])

    return assets


@contextlib.contextmanager
def download_portal_apk(debug: bool = False):
    """
    Download the latest Portal APK from GitHub releases.

    This context manager downloads the APK to a temporary file and yields
    the file path. The file is automatically deleted when the context exits.

    Args:
        debug: Enable debug logging

    Yields:
        str: Path to the downloaded APK file

    Raises:
        Exception: If the Portal APK asset is not found in the release
        requests.HTTPError: If the download fails
    """
    console = Console()
    assets = get_latest_release_assets(debug)

    asset_version = None
    asset_url = None
    for asset in assets:
        if (
            "browser_download_url" in asset
            and "name" in asset
            and asset["name"].startswith(ASSET_NAME)
        ):
            asset_url = asset["browser_download_url"]
            asset_version = asset["name"].split("-")[-1]
            asset_version = asset_version.removesuffix(".apk")
            break
        elif "downloadUrl" in asset and os.path.basename(
            asset["downloadUrl"]
        ).startswith(ASSET_NAME):
            asset_url = asset["downloadUrl"]
            asset_version: str = asset.get("name", os.path.basename(asset_url)).split(
                "-"
            )[-1]
            asset_version = asset_version.removesuffix(".apk")
            break
        else:
            if debug:
                print(asset)

    if not asset_url:
        raise Exception(f"Asset named '{ASSET_NAME}' not found in the latest release.")

    console.print(f"Found Portal APK [bold]{asset_version}[/bold]")
    if debug:
        console.print(f"Asset URL: {asset_url}")

    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".apk")
    try:
        r = requests.get(asset_url, stream=True)
        r.raise_for_status()
        for chunk in r.iter_content(chunk_size=8192):
            if chunk:
                tmp.write(chunk)
        tmp.close()
        yield tmp.name
    finally:
        if os.path.exists(tmp.name):
            os.unlink(tmp.name)


async def enable_portal_accessibility(
    device: AdbDevice, service_name: str = A11Y_SERVICE_NAME
):
    """
    Enable the Portal accessibility service on the device.

    Args:
        device: ADB device connection
        service_name: Full accessibility service name (default: Portal service)

    Note:
        This may fail on some devices due to security restrictions.
        Manual enablement may be required.
    """
    await device.shell(
        f"settings put secure enabled_accessibility_services {service_name}"
    )
    await device.shell("settings put secure accessibility_enabled 1")


async def check_portal_accessibility(
    device: AdbDevice, service_name: str = A11Y_SERVICE_NAME, debug: bool = False
) -> bool:
    """
    Check if the Portal accessibility service is enabled.

    Args:
        device: ADB device connection
        service_name: Full accessibility service name to check
        debug: Enable debug logging

    Returns:
        True if the accessibility service is enabled, False otherwise
    """
    a11y_services = await device.shell(
        "settings get secure enabled_accessibility_services"
    )
    if service_name not in a11y_services:
        if debug:
            print(a11y_services)
        return False

    a11y_enabled = await device.shell("settings get secure accessibility_enabled")
    if a11y_enabled != "1":
        if debug:
            print(a11y_enabled)
        return False

    return True


async def ping_portal(device: AdbDevice, debug: bool = False):
    """
    Ping the Droidrun Portal to check if it is installed and accessible.
    """
    try:
        packages = await device.list_packages()
    except Exception as e:
        raise Exception("Failed to list packages") from e

    if PORTAL_PACKAGE_NAME not in packages:
        if debug:
            print(packages)
        raise Exception("Portal is not installed on the device")

    if not await check_portal_accessibility(device, debug=debug):
        await device.shell("am start -a android.settings.ACCESSIBILITY_SETTINGS")
        raise Exception(
            "Droidrun Portal is not enabled as an accessibility service on the device"
        )


async def ping_portal_content(device: AdbDevice, debug: bool = False):
    """
    Test Portal accessibility via content provider.

    Args:
        device: ADB device connection
        debug: Enable debug logging

    Raises:
        Exception: If Portal is not reachable via content provider
    """
    try:
        state = await device.shell(
            "content query --uri content://com.droidrun.portal/state"
        )
        if "Row: 0 result=" not in state:
            raise Exception("Failed to get state from Droidrun Portal")
    except Exception as e:
        raise Exception("Droidrun Portal is not reachable") from e


async def ping_portal_tcp(device: AdbDevice, debug: bool = False):
    """
    Test Portal accessibility via TCP mode.

    Args:
        device: ADB device connection
        debug: Enable debug logging

    Raises:
        Exception: If Portal is not reachable via TCP or port forwarding fails
    """
    try:
        driver = AndroidDriver(serial=device.serial, use_tcp=True)
        await driver.connect()
    except Exception as e:
        raise Exception("Failed to setup TCP forwarding") from e


async def set_overlay_offset(device: AdbDevice, offset: int):
    """
    Set the overlay offset using the /overlay_offset portal content provider endpoint.
    """
    try:
        cmd = f'content insert --uri "content://com.droidrun.portal/overlay_offset" --bind offset:i:{offset}'
        await device.shell(cmd)
    except Exception as e:
        raise Exception("Error setting overlay offset") from e


async def toggle_overlay(device: AdbDevice, visible: bool):
    """Toggle the overlay visibility.

    Args:
        device: Device to toggle the overlay on
        visible: Whether to show the overlay

    throws:
        Exception: If the overlay toggle fails
    """
    try:
        visible_str = "true" if visible else "false"
        cmd = f'content insert --uri "content://com.droidrun.portal/overlay_visible" --bind visible:b:{visible_str}'
        await device.shell(cmd)
    except Exception as e:
        raise Exception("Failed to toggle overlay") from e


async def setup_keyboard(device: AdbDevice):
    """
    Set up the DroidRun keyboard as the default input method.
    Simple setup that just switches to DroidRun keyboard without saving/restoring.

    throws:
        Exception: If the keyboard setup fails
    """
    try:
        await device.shell("ime enable com.droidrun.portal/.input.DroidrunKeyboardIME")
        await device.shell("ime set com.droidrun.portal/.input.DroidrunKeyboardIME")
    except Exception as e:
        raise Exception("Error setting up keyboard") from e


async def disable_keyboard(
    device: AdbDevice,
    target_ime: str = "com.droidrun.portal/.input.DroidrunKeyboardIME",
):
    """
    Disable a specific IME (keyboard) and optionally switch to another.
    By default, disables the DroidRun keyboard.

    Args:
        target_ime: The IME package/activity to disable (default: DroidRun keyboard)

    Returns:
        bool: True if disabled successfully, False otherwise
    """
    try:
        await device.shell(f"ime disable {target_ime}")
        return True
    except Exception as e:
        raise Exception("Error disabling keyboard") from e


async def test():
    device = await adb.device()
    await ping_portal(device, debug=False)


if __name__ == "__main__":
    asyncio.run(test())

```

`droidrun/telemetry/__init__.py`:

```py
from droidrun.telemetry.events import (
    DroidAgentFinalizeEvent,
    DroidAgentInitEvent,
    PackageVisitEvent,
)
from droidrun.telemetry.tracker import capture, flush, print_telemetry_message

__all__ = [
    "capture",
    "flush",
    "DroidAgentInitEvent",
    "PackageVisitEvent",
    "DroidAgentFinalizeEvent",
    "print_telemetry_message",
]

```

`droidrun/telemetry/events.py`:

```py
"""
Telemetry event models for DroidRun analytics.

This module defines Pydantic models for telemetry events captured during
agent execution. All events inherit from TelemetryEvent base class.
"""

from typing import Dict, Optional

from pydantic import BaseModel


class TelemetryEvent(BaseModel):
    """Base class for all telemetry events."""

    pass


class DroidAgentInitEvent(TelemetryEvent):
    """Event captured when DroidAgent is initialized."""

    goal: str
    llms: Dict[str, str]
    tools: str
    max_steps: int
    timeout: int
    vision: Dict[str, bool]
    reasoning: bool
    enable_tracing: bool
    debug: bool
    save_trajectories: str = "none"
    runtype: str = "developer"  # "cli" | "developer" | "web"
    custom_prompts: Optional[Dict[str, str]] = (
        None  # Keys: prompt names, Values: "custom" or None
    )


class PackageVisitEvent(TelemetryEvent):
    """Event captured when agent visits a new app package."""

    package_name: str
    activity_name: str
    step_number: int


class DroidAgentFinalizeEvent(TelemetryEvent):
    """Event captured when DroidAgent execution completes."""

    success: bool
    reason: str
    steps: int
    unique_packages_count: int
    unique_activities_count: int

```

`droidrun/telemetry/langfuse_processor.py`:

```py
"""Production-ready Langfuse span processor with image upload support.

This module provides a custom OpenTelemetry span processor that:
- Uploads images to Langfuse blob storage (S3/Azure/GCS)
- Transforms LlamaIndex block-based messages to Langfuse content format
- Auto-scales from 3 to 50 worker threads based on load
- Uses HTTP connection pooling for performance
- Operates silently (warnings and errors only)

Usage:
    from droidrun.telemetry.langfuse_processor import LangfuseSpanProcessor

    processor = LangfuseSpanProcessor(
        public_key="pk-lf-...",
        secret_key="sk-lf-...",
        base_url="https://cloud.langfuse.com",
    )
"""

import base64
import hashlib
import json
import logging
import threading
import time
from concurrent.futures import ThreadPoolExecutor, Future
from contextvars import ContextVar
from datetime import datetime, timezone
from typing import List, Optional, TYPE_CHECKING

import requests
from opentelemetry.context import Context
from opentelemetry.sdk.trace import ReadableSpan, Span
from opentelemetry import trace

from langfuse._client.span_processor import (
    LangfuseSpanProcessor as BaseLangfuseSpanProcessor,
)

from droidrun import __version__

if TYPE_CHECKING:
    from droidrun import DroidAgent

_current_agent: ContextVar[Optional["DroidAgent"]] = ContextVar(
    "_current_agent", default=None
)
_root_span_context: ContextVar[Optional[Context]] = ContextVar(
    "_root_span_context", default=None
)
# Track last active step span (FastAgent/CodeAct/Manager/Executor) to parent screenshots
_last_step_span_context: ContextVar[Optional[Context]] = ContextVar(
    "_last_step_span_context", default=None
)


def set_current_agent(agent: "DroidAgent") -> None:
    _current_agent.set(agent)


def set_root_span_context(span: Span) -> None:
    """Store the root span context so screenshots can attach even if current span is missing."""
    try:
        ctx = trace.set_span_in_context(span)
        _root_span_context.set(ctx)
    except Exception:
        pass


def get_root_span_context() -> Optional[Context]:
    return _root_span_context.get()


def set_last_step_span_context(span: Span) -> None:
    try:
        ctx = trace.set_span_in_context(span)
        _last_step_span_context.set(ctx)
    except Exception:
        pass


def get_last_step_span_context() -> Optional[Context]:
    return _last_step_span_context.get()


MAX_IMAGE_SIZE_KB = 10000
MAX_UPLOAD_WORKERS = 50  # Maximum concurrent upload threads
SHUTDOWN_TIMEOUT = 30  # Seconds to wait for pending uploads on shutdown

# Use DroidRun's logger
logger = logging.getLogger("droidrun")


class LangfuseSpanProcessor(BaseLangfuseSpanProcessor):
    """
    Production span processor with image upload and message formatting.

    Extends the base LangfuseSpanProcessor with:
    - Auto-scaling thread pool (3-50 workers based on load)
    - Image upload to blob storage with deduplication
    - Message format transformation (blocks ‚Üí content)
    """

    def __init__(
        self,
        *,
        public_key: str,
        secret_key: str,
        base_url: str,
        timeout: Optional[int] = None,
        flush_at: Optional[int] = None,
        flush_interval: Optional[float] = None,
        blocked_instrumentation_scopes: Optional[List[str]] = None,
        additional_headers: Optional[dict] = None,
        agent: Optional["DroidAgent"] = None,
    ):
        """Initialize the span processor with media upload support.

        Args:
            agent: Optional DroidAgent instance for accessing agent context during span processing.
        """
        super().__init__(
            public_key=public_key,
            secret_key=secret_key,
            base_url=base_url,
            timeout=timeout,
            flush_at=flush_at,
            flush_interval=flush_interval,
            blocked_instrumentation_scopes=blocked_instrumentation_scopes,
            additional_headers=additional_headers,
        )

        # Store credentials for media API calls
        self._base_url = base_url
        auth_string = f"{public_key}:{secret_key}"
        self._auth_header = "Basic " + base64.b64encode(auth_string.encode()).decode()

        # HTTP connection pooling (shared across all threads)
        self._http_session = requests.Session()
        self._http_session.headers.update(
            {
                "Authorization": self._auth_header,
                "Content-Type": "application/json",
            }
        )
        adapter = requests.adapters.HTTPAdapter(
            pool_connections=3,  # Increase this if hosting on server with multiple users
            pool_maxsize=10,  # Increase this if hosting on server with multiple users (task api)
            max_retries=3,
        )
        self._http_session.mount("http://", adapter)
        self._http_session.mount("https://", adapter)

        self._executor = ThreadPoolExecutor(
            max_workers=MAX_UPLOAD_WORKERS,
            thread_name_prefix="LangfuseMediaUpload",
        )

        self._pending_uploads: List[Future] = []
        self._pending_lock = threading.Lock()

    @property
    def agent(self) -> Optional["DroidAgent"]:
        return _current_agent.get()

    def _extract_agent_input(self) -> Optional[dict]:
        if not self.agent:
            return None

        try:
            input_data = {}

            if self.agent.shared_state.instruction:
                input_data["goal"] = self.agent.shared_state.instruction

            input_data["reasoning"] = self.agent.config.agent.reasoning

            if self.agent.config.device:
                device = self.agent.config.device
                input_data["device"] = {
                    "platform": device.platform,
                    "serial": device.serial,
                    "use_tcp": device.use_tcp,
                }

            if self.agent.output_model:
                input_data["output_model"] = self.agent.output_model.__name__

            input_data["droidrun_version"] = "v" + __version__

            if self.agent.config.agent.after_sleep_action:
                input_data["after_action_sleep"] = (
                    self.agent.config.agent.after_sleep_action
                )

            # Vision settings
            vision_state = {
                "manager": getattr(self.agent.config.agent.manager, "vision", False),
                "executor": getattr(self.agent.config.agent.executor, "vision", False),
                "fast_agent": getattr(
                    self.agent.config.agent.fast_agent, "vision", False
                ),
            }
            input_data["vision_enabled"] = any(vision_state.values())
            input_data["vision"] = vision_state

            active_llms = []
            if self.agent.config.agent.reasoning:
                # Reasoning mode uses manager, executor, scripter
                llm_attrs = ["manager_llm", "executor_llm"]
                if self.agent.config.agent.scripter.enabled:
                    llm_attrs.append("scripter_llm")
            else:
                # Direct mode uses fast_agent
                llm_attrs = ["fast_agent_llm"]

            # Add helper LLMs
            llm_attrs.extend(["text_manipulator_llm", "app_opener_llm"])

            # Add structured_output if output_model is present
            if self.agent.output_model:
                llm_attrs.append("structured_output_llm")

            for llm_attr in llm_attrs:
                llm = getattr(self.agent, llm_attr)
                if llm:
                    role = llm_attr.replace("_llm", "")
                    llm_info = {
                        "role": role,
                        "provider": (
                            llm.class_name()
                            if hasattr(llm, "class_name")
                            else "unknown"
                        ),
                    }
                    if role in vision_state:
                        llm_info["vision"] = vision_state[role]

                    # Extract model name
                    if hasattr(llm, "model"):
                        llm_info["model"] = llm.model
                    elif hasattr(llm, "metadata") and hasattr(
                        llm.metadata, "model_name"
                    ):
                        llm_info["model"] = llm.metadata.model_name

                    # Extract temperature
                    if hasattr(llm, "temperature"):
                        llm_info["temperature"] = llm.temperature

                    active_llms.append(llm_info)

            input_data["llms"] = active_llms

            return input_data

        except Exception as e:
            logger.warning(f"Failed to extract agent input: {e}")
            return None

    # Media API
    def _submit_upload(self, job: dict):
        """Submit upload job to thread pool (non-blocking)."""
        try:
            future = self._executor.submit(self._upload_media_to_langfuse, job)

            with self._pending_lock:
                self._pending_uploads.append(future)

            future.add_done_callback(self._cleanup_future)

        except Exception as e:
            logger.error(f"Failed to submit media upload: {e}")

    def _cleanup_future(self, future: Future):
        """Remove completed future from tracking list."""
        with self._pending_lock:
            try:
                self._pending_uploads.remove(future)
            except ValueError:
                pass

    def _upload_media_to_langfuse(self, job: dict):
        """Upload media to Langfuse blob storage."""
        try:
            # Step 1: Request presigned upload URL
            upload_response = self._request_upload_url(
                media_id=job["media_id"],
                content_type=job["content_type"],
                content_length=job["content_length"],
                sha256_hash=job["sha256_hash"],
                trace_id=job["trace_id"],
                observation_id=job.get("observation_id"),
                field=job["field"],
            )

            if not upload_response or not upload_response.get("uploadUrl"):
                # Media already exists (deduplication)
                return

            upload_url = upload_response["uploadUrl"]

            # Step 2: Upload to blob storage (S3/Azure/GCS)
            headers = {"Content-Type": job["content_type"]}

            # GCS doesn't support these headers
            if "storage.googleapis.com" not in upload_url:
                headers["x-ms-blob-type"] = "BlockBlob"
                headers["x-amz-checksum-sha256"] = job["sha256_hash"]

            response = self._http_session.put(
                upload_url, headers=headers, data=job["content_bytes"]
            )

            # Step 3: Notify Langfuse of upload completion
            if response.status_code in (200, 201):
                self._notify_upload_complete(job["media_id"], response.status_code)
            else:
                logger.error(
                    f"Media upload failed for {job['media_id']}: "
                    f"HTTP {response.status_code} - {response.text}"
                )

        except Exception as e:
            logger.error(f"Failed to upload media {job['media_id']}: {e}")

    def _request_upload_url(
        self,
        media_id: str,
        content_type: str,
        content_length: int,
        sha256_hash: str,
        trace_id: str,
        observation_id: Optional[str],
        field: str,
    ) -> Optional[dict]:
        """Request presigned upload URL from Langfuse API."""
        try:
            url = f"{self._base_url}/api/public/media"
            payload = {
                "traceId": trace_id,
                "observationId": observation_id,
                "contentType": content_type,
                "contentLength": content_length,
                "sha256Hash": sha256_hash,
                "field": field,
            }

            response = self._http_session.post(url, json=payload, timeout=10)

            if response.status_code == 200:
                return response.json()
            elif response.status_code == 201:
                data = response.json()
                if data.get("uploadUrl") is None:
                    # media already exists (deduplication)
                    return None
                return data
            else:
                logger.error(
                    f"Failed to request upload URL: HTTP {response.status_code} - {response.text}"
                )
                return None

        except Exception as e:
            logger.error(f"Error requesting upload URL: {e}")
            return None

    def _notify_upload_complete(self, media_id: str, status_code: int):
        """Notify Langfuse that upload completed."""
        try:
            url = f"{self._base_url}/api/public/media/{media_id}"
            payload = {
                "uploadedAt": datetime.now(timezone.utc).isoformat(),
                "uploadHttpStatus": status_code,
            }

            response = self._http_session.patch(url, json=payload, timeout=10)

            if response.status_code != 200:
                logger.warning(
                    f"Failed to notify upload complete: HTTP {response.status_code}"
                )

        except Exception as e:
            logger.error(f"Error notifying upload complete: {e}")

    def shutdown(self):
        """Override shutdown to wait for pending media uploads."""

        self._executor.shutdown(wait=False, cancel_futures=False)

        # Wait for pending uploads with timeout
        deadline = time.time() + SHUTDOWN_TIMEOUT
        all_done = False

        while time.time() < deadline:
            with self._pending_lock:
                pending = [f for f in self._pending_uploads if not f.done()]
                pending_count = len(pending)

            if pending_count == 0:
                all_done = True
                break

            time.sleep(0.1)

        if not all_done:
            with self._pending_lock:
                pending_count = len([f for f in self._pending_uploads if not f.done()])
            logger.warning(
                f"Langfuse shutdown timeout after {SHUTDOWN_TIMEOUT}s - "
                f"{pending_count} media uploads still pending"
            )

        self._http_session.close()

        super().shutdown()

    def on_start(self, span: Span, parent_context: Optional[Context] = None) -> None:
        super().on_start(span, parent_context)

        if not self.agent:
            return

        try:
            if "input.value" in span._attributes:
                del span._attributes["input.value"]

            if span.name == "DroidAgent.run":
                set_root_span_context(span)
                span._attributes["langfuse.release"] = "v" + __version__
                input_data = self._extract_agent_input()
                if input_data:
                    span._attributes["langfuse.observation.input"] = json.dumps(
                        input_data
                    )
                    tags = ["reasoning"] if input_data.get("reasoning") else ["fast"]
                    span._attributes["langfuse.trace.tags"] = tags
                    if "vision_enabled" in input_data:
                        span._attributes["droidrun.vision.enabled"] = input_data[
                            "vision_enabled"
                        ]

            elif span.name in (
                "ManagerAgent.run",
                "StatelessManagerAgent.run",
                "CodeActAgent.run",
                "FastAgent.run",
                "ExecutorAgent.run",
            ):
                set_last_step_span_context(span)
                memory_size = (
                    len(self.agent.shared_state.manager_memory)
                    if self.agent.shared_state.manager_memory
                    else 0
                )
                message_history_count = len(self.agent.shared_state.message_history) + 1

                input_data = {
                    "memory_size": memory_size,
                    "message_history_count": message_history_count,
                }

                if span.name == "ExecutorAgent.run":
                    input_data["subgoal"] = (
                        self.agent.shared_state.current_subgoal or "Unknown"
                    )

                if span.name in ("FastAgent.run", "CodeActAgent.run"):
                    input_data["fast_memory_count"] = len(
                        self.agent.shared_state.fast_memory
                    )

                span._attributes["langfuse.observation.input"] = json.dumps(input_data)

                if self.agent.shared_state.error_flag_plan:
                    span._attributes["langfuse.trace.tags"] = ["error_recovery"]

        except Exception as e:
            logger.error(f"Error injecting metadata in on_start: {e}")

    # Span processing
    def on_end(self, span: ReadableSpan) -> None:
        if self._is_langfuse_span(span) and not self._is_langfuse_project_span(span):
            return

        if self._is_blocked_instrumentation_scope(span):
            return

        if span.name.endswith("_done"):
            span._attributes["langfuse.observation.level"] = "DEBUG"

        try:
            if "output.value" in span._attributes and not span._attributes.get(
                "langfuse.observation.output"
            ):
                span._attributes["langfuse.observation.output"] = span._attributes[
                    "output.value"
                ]
                del span._attributes["output.value"]
            if span.name in (
                "DroidAgent.run",
                "ManagerAgent.run",
                "StatelessManagerAgent.run",
                "ExecutorAgent.run",
                "FastAgent.run",
                "CodeActAgent.run",
            ):
                if "input.value" in span._attributes:
                    del span._attributes["input.value"]
            elif span.name.endswith(
                (".chat", ".achat", ".stream_chat", ".astream_chat")
            ):
                self._format_chat(span)
            elif span.name.endswith(
                (".complete", ".acomplete", ".stream_complete", ".astream_complete")
            ):
                self._format_complete(span)
            elif span.name == "droidrun.screenshot":
                self._process_screenshot_span(span)
        except Exception as e:
            logger.error(f"Error processing span for Langfuse: {e}")

        super(BaseLangfuseSpanProcessor, self).on_end(span)

    def _format_complete(self, span: ReadableSpan) -> None:
        span._attributes["input.value"] = span._attributes["llm.prompts"][0]
        del span._attributes["llm.prompts"]
        pass

    def _format_chat(self, span: ReadableSpan) -> None:
        """
        Apply custom formatting to transform blocks and set Langfuse attributes.

        Processes both input.value and output.value attributes:
        - Plain strings: Set langfuse.observation.{field} directly
        - JSON with blocks: Transform blocks to content format (images, tool calls, etc.)
        - JSON without blocks: Set langfuse.observation.{field} as-is
        """
        if not hasattr(span, "_attributes") or span._attributes is None:
            return

        attrs = span._attributes
        trace_id = format(span.context.trace_id, "032x")

        self._process_field(attrs, trace_id, "input")
        self._process_field(attrs, trace_id, "output")

    # Message transformation
    def _process_field(self, attrs: dict, trace_id: str, field: str) -> None:
        """Process input or output field - handle both JSON messages and plain strings."""
        field_key = f"{field}.value"

        if field_key not in attrs:
            return

        value = attrs[field_key]
        if not isinstance(value, str):
            return

        # Try parsing as JSON with messages
        try:
            data = json.loads(value)

            # Check if it has messages with blocks that need transformation
            if self._has_blocks_to_transform(data):
                self._transform_and_set_field(attrs, trace_id, field, data)
                return

        except (json.JSONDecodeError, ValueError):
            pass

        attrs[f"langfuse.observation.{field}"] = value

    def _has_blocks_to_transform(self, data: dict) -> bool:
        """Check if data contains messages with blocks that need transformation."""
        if not isinstance(data, dict) or "messages" not in data:
            return False

        messages = data["messages"]
        if not isinstance(messages, list):
            return False

        return any(isinstance(msg, dict) and "blocks" in msg for msg in messages)

    def _transform_and_set_field(
        self, attrs: dict, trace_id: str, field: str, data: dict
    ) -> None:
        """Transform blocks to content and set Langfuse attributes."""
        # Remove legacy LLM message attributes
        prefix = f"llm.{field}_messages."
        keys_to_remove = [key for key in attrs if key.startswith(prefix)]
        for key in keys_to_remove:
            del attrs[key]

        # Transform and set
        formatted = self._transform_blocks_to_content(data, trace_id, field)
        attrs[f"langfuse.observation.{field}"] = formatted
        attrs[f"{field}.value"] = formatted

    def _transform_blocks_to_content(
        self, data: dict, trace_id: str, field: str
    ) -> str:
        """Transform parsed message data from blocks to content format."""
        processed = self._convert_message_array(data["messages"], trace_id, field)
        return json.dumps({"messages": json.loads(processed)})

    def _convert_message_array(self, messages: list, trace_id: str, field: str) -> str:
        """Convert message array from blocks format to content format."""
        restructured_messages = []

        for msg in messages:
            if not isinstance(msg, dict):
                continue

            if "content" in msg and "blocks" not in msg:
                restructured_messages.append(msg)
                continue

            if (
                "json" in msg
                and isinstance(msg["json"], dict)
                and "blocks" in msg["json"]
            ):
                msg = msg.copy()
                msg.update(msg["json"])
                del msg["json"]

            if "blocks" not in msg or "role" not in msg:
                if "role" in msg:
                    restructured_messages.append(msg)
                continue

            role = msg["role"]
            blocks = msg["blocks"]

            if not isinstance(blocks, list) or len(blocks) == 0:
                restructured_messages.append(msg)
                continue

            if (
                len(blocks) == 1
                and isinstance(blocks[0], dict)
                and blocks[0].get("block_type") == "text"
                and "text" in blocks[0]
            ):
                restructured_messages.append(
                    {"role": role, "content": blocks[0]["text"]}
                )
            else:
                content_blocks = self._convert_blocks_to_content(
                    blocks, trace_id, field
                )

                if content_blocks:
                    restructured_messages.append(
                        {"role": role, "content": content_blocks}
                    )
                else:
                    restructured_messages.append(msg)

        return json.dumps(restructured_messages)

    def _convert_blocks_to_content(
        self,
        blocks: list,
        trace_id: str,
        field: str,
    ) -> list:
        """Convert LlamaIndex blocks to Langfuse content blocks."""
        content_blocks = []

        for block in blocks:
            if not isinstance(block, dict) or "block_type" not in block:
                continue

            block_type = block["block_type"]

            if block_type == "text":
                if "text" in block:
                    content_blocks.append({"type": "text", "text": block["text"]})

            elif block_type == "image":
                image_block = self._upload_image_to_storage(block, trace_id, field)
                if image_block:
                    content_blocks.append(image_block)

            elif block_type == "tool_call":
                if "tool_name" in block and "tool_kwargs" in block:
                    content_blocks.append(
                        {
                            "type": "tool_call",
                            "tool_call": {
                                "name": block["tool_name"],
                                "arguments": block["tool_kwargs"],
                            },
                        }
                    )

        return content_blocks

    def _process_screenshot_span(self, span: ReadableSpan) -> None:
        """Convert custom screenshot spans into Langfuse image content."""
        attrs = span._attributes or {}
        image_b64 = attrs.get("droidrun.screenshot.image_base64")
        mime_type = attrs.get("droidrun.screenshot.mime_type", "image/png")

        if not image_b64:
            return

        trace_id = format(span.context.trace_id, "032x")
        data = {
            "messages": [
                {
                    "role": "assistant",
                    "blocks": [
                        {
                            "block_type": "image",
                            "image": image_b64,
                            "image_mimetype": mime_type,
                        }
                    ],
                }
            ]
        }

        attrs["output.value"] = json.dumps(data)
        self._transform_and_set_field(attrs, trace_id, "output", data)

        # Clean up raw fields to avoid duplication
        attrs.pop("droidrun.screenshot.image_base64", None)
        attrs.pop("droidrun.screenshot.mime_type", None)
        attrs.pop("output.value", None)

    # Image upload
    def _upload_image_to_storage(
        self,
        block: dict,
        trace_id: str,
        field: str,
    ) -> Optional[dict]:
        """Upload image to blob storage and return media reference."""
        if "image" in block and block["image"] is not None:
            image_base64 = block["image"]
            mime_type = block.get("image_mimetype")

            if not mime_type:
                logger.warning("Image missing MIME type, skipping upload")
                return None

            try:
                image_bytes = base64.b64decode(image_base64)
                size_kb = len(image_bytes) / 1024

                if size_kb > MAX_IMAGE_SIZE_KB:
                    logger.warning(
                        f"Image size ({size_kb:.1f}KB) exceeds limit ({MAX_IMAGE_SIZE_KB}KB), skipping upload"
                    )
                    return None

                sha256_hash_bytes = hashlib.sha256(image_bytes).digest()
                sha256_hash = base64.b64encode(sha256_hash_bytes).decode()
                media_id = (
                    sha256_hash.replace("+", "-").replace("/", "_").rstrip("=")[:22]
                )

                self._submit_upload(
                    {
                        "media_id": media_id,
                        "content_bytes": image_bytes,
                        "content_type": mime_type,
                        "content_length": len(image_bytes),
                        "sha256_hash": sha256_hash,
                        "trace_id": trace_id,
                        "observation_id": None,
                        "field": field,
                    }
                )

                reference_string = (
                    f"@@@langfuseMedia:type={mime_type}|id={media_id}|source=bytes@@@"
                )
                return {
                    "type": "image_url",
                    "image_url": {"url": reference_string},
                }

            except Exception as e:
                logger.error(f"Failed to process image: {e}")
                return None

        if "url" in block and block["url"] is not None:
            return {"type": "image_url", "image_url": {"url": block["url"]}}

        if "path" in block and block["path"] is not None:
            logger.warning(
                f"Using file path for image - may not work on server: {block['path']}"
            )
            return {
                "type": "image_url",
                "image_url": {"url": f"file://{block['path']}"},
            }

        return None

```

`droidrun/telemetry/phoenix.py`:

```py
"""
Arize Phoenix tracing integration for DroidRun.

This module provides Phoenix instrumentation for tracing LLM calls and agent execution.
It includes utilities for creating custom spans with clean names and context management.
"""

import asyncio
import functools
import inspect
import os
import uuid
from contextvars import Token, copy_context
from typing import Any, Callable

from llama_index.core.callbacks.base_handler import BaseCallbackHandler
from llama_index_instrumentation import get_dispatcher
from openinference.instrumentation import TraceConfig

dispatcher = get_dispatcher()


def arize_phoenix_callback_handler(**kwargs: Any) -> BaseCallbackHandler:
    """
    Create and configure an Arize Phoenix callback handler for LlamaIndex.

    This function sets up OpenTelemetry tracing with Phoenix backend for monitoring
    LLM calls and agent execution.

    Args:
        **kwargs: Optional configuration overrides
            - endpoint: Phoenix server URL (default: http://0.0.0.0:6006 or PHOENIX_URL env var)
            - tracer_provider: Custom tracer provider
            - separate_trace_from_runtime_context: Separate traces from runtime context

    Returns:
        Configured LlamaIndex instrumentor instance

    Environment Variables:
        - PHOENIX_URL: Phoenix server URL
        - PHOENIX_PROJECT_NAME: Project name for organizing traces
    """
    # newer versions of arize, v2.x
    from openinference.instrumentation.llama_index import LlamaIndexInstrumentor
    from openinference.semconv.resource import ResourceAttributes
    from opentelemetry.exporter.otlp.proto.http.trace_exporter import (
        OTLPSpanExporter,
    )
    from opentelemetry.sdk import trace as trace_sdk
    from opentelemetry.sdk.resources import Resource
    from opentelemetry.sdk.trace.export import SimpleSpanProcessor

    endpoint = (
        kwargs.get("endpoint", os.getenv("phoenix_url", "http://0.0.0.0:6006"))
        + "/v1/traces"
    )

    resource_attributes = {}
    phoenix_project_name = os.getenv("phoenix_project_name", "")
    if phoenix_project_name.strip():
        resource_attributes[ResourceAttributes.PROJECT_NAME] = phoenix_project_name
    resource = Resource(attributes=resource_attributes)

    tracer_provider = trace_sdk.TracerProvider(resource=resource)
    tracer_provider.add_span_processor(SimpleSpanProcessor(OTLPSpanExporter(endpoint)))
    config = TraceConfig(base64_image_max_length=64000000)

    return LlamaIndexInstrumentor().instrument(
        tracer_provider=kwargs.get("tracer_provider", tracer_provider),
        separate_trace_from_runtime_context=kwargs.get(
            "separate_trace_from_runtime_context"
        ),
        config=config,
    )


def clean_span(span_name: str):
    """
    Create a span with a clean name (without class prefix).

    This function returns a decorator that creates spans with custom names
    instead of the default class.method format.

    It preserves parent-child relationships by using the same active span
    context variable as the built-in dispatcher decorator does.

    Args:
        span_name: The desired name for the span

    Returns:
        A decorator function
    """

    def decorator(func: Callable) -> Callable:
        # Support both sync and async callables
        if inspect.iscoroutinefunction(func):

            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs):
                # Import here to avoid circular imports
                from llama_index_instrumentation.dispatcher import (
                    active_instrument_tags,
                )
                from llama_index_instrumentation.span import active_span_id

                span_id = f"{span_name}-{uuid.uuid4()}"
                bound_args = inspect.signature(func).bind(*args, **kwargs)
                # Treat as method only if qualname indicates Class.method
                is_method = "." in getattr(func, "__qualname__", "")
                instance = args[0] if (args and is_method) else None

                tags = active_instrument_tags.get()
                token = active_span_id.set(span_id)
                parent_id = (
                    None if token.old_value is Token.MISSING else token.old_value
                )

                dispatcher.span_enter(
                    id_=span_id,
                    bound_args=bound_args,
                    instance=instance,
                    parent_id=parent_id,
                    tags=tags,
                )
                try:
                    result = await func(*args, **kwargs)
                except Exception as e:
                    dispatcher.span_drop(
                        id_=span_id, bound_args=bound_args, instance=instance, err=e
                    )
                    raise
                else:
                    dispatcher.span_exit(
                        id_=span_id,
                        bound_args=bound_args,
                        instance=instance,
                        result=result,
                    )
                    return result
                finally:
                    active_span_id.reset(token)

            return async_wrapper
        else:

            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                # Import here to avoid circular imports
                from llama_index_instrumentation.dispatcher import (
                    active_instrument_tags,
                )
                from llama_index_instrumentation.span import active_span_id

                span_id = f"{span_name}-{uuid.uuid4()}"
                bound_args = inspect.signature(func).bind(*args, **kwargs)
                # Treat as method only if qualname indicates Class.method
                is_method = "." in getattr(func, "__qualname__", "")
                instance = args[0] if (args and is_method) else None

                tags = active_instrument_tags.get()
                context = copy_context()
                token = active_span_id.set(span_id)
                parent_id = (
                    None if token.old_value is Token.MISSING else token.old_value
                )

                dispatcher.span_enter(
                    id_=span_id,
                    bound_args=bound_args,
                    instance=instance,
                    parent_id=parent_id,
                    tags=tags,
                )
                try:
                    result = func(*args, **kwargs)
                    if isinstance(result, asyncio.Future):
                        new_future = asyncio.ensure_future(result)

                        def _on_done(fut: asyncio.Future) -> None:
                            try:
                                fut_result = None if fut.exception() else fut.result()
                                dispatcher.span_exit(
                                    id_=span_id,
                                    bound_args=bound_args,
                                    instance=instance,
                                    result=fut_result,
                                )
                            except Exception as e2:
                                dispatcher.span_drop(
                                    id_=span_id,
                                    bound_args=bound_args,
                                    instance=instance,
                                    err=e2,
                                )
                                raise
                            finally:
                                try:
                                    context.run(active_span_id.reset, token)
                                except ValueError:
                                    pass

                        new_future.add_done_callback(_on_done)
                        return new_future
                except Exception as e:
                    dispatcher.span_drop(
                        id_=span_id, bound_args=bound_args, instance=instance, err=e
                    )
                    raise
                else:
                    dispatcher.span_exit(
                        id_=span_id,
                        bound_args=bound_args,
                        instance=instance,
                        result=result,
                    )
                    return result
                finally:
                    if not isinstance(locals().get("result"), asyncio.Future):
                        active_span_id.reset(token)

            return wrapper

    return decorator

```

`droidrun/telemetry/tracker.py`:

```py
"""
Anonymous telemetry tracking using PostHog.

This module handles opt-in telemetry collection to help improve DroidRun.
All data is anonymized and can be disabled by setting DROIDRUN_TELEMETRY_ENABLED=false.
"""

import asyncio
import logging
import os
from pathlib import Path
from uuid import UUID, uuid4

from posthog import Posthog

from droidrun.telemetry.events import TelemetryEvent

logger = logging.getLogger("droidrun-telemetry")
droidrun_logger = logging.getLogger("droidrun")

PROJECT_API_KEY = "phc_XyD3HKIsetZeRkmnfaBughs8fXWYArSUFc30C0HmRiO"
HOST = "https://eu.i.posthog.com"
USER_ID_PATH = Path.home() / ".droidrun" / "user_id"
RUN_ID = str(uuid4())

TELEMETRY_ENABLED_MESSAGE = "Anonymized telemetry enabled. See https://docs.droidrun.ai/v3/guides/telemetry for more information."
TELEMETRY_DISABLED_MESSAGE = "üõë Anonymized telemetry disabled. Consider setting the DROIDRUN_TELEMETRY_ENABLED environment variable to 'true' to enable telemetry and help us improve DroidRun."

posthog = Posthog(
    project_api_key=PROJECT_API_KEY,
    host=HOST,
    disable_geoip=False,
)


def is_telemetry_enabled():
    """
    Check if telemetry is enabled via environment variable.

    Returns:
        True if DROIDRUN_TELEMETRY_ENABLED is set to true/1/yes/y (case-insensitive),
        or if the environment variable is not set (default is enabled).
    """
    telemetry_enabled = os.environ.get("DROIDRUN_TELEMETRY_ENABLED", "true")
    enabled = telemetry_enabled.lower() in ["true", "1", "yes", "y"]
    logger.debug(f"Telemetry enabled: {enabled}")
    return enabled


def print_telemetry_message():
    """
    Print telemetry status message to the logger.

    Displays enabled or disabled message based on DROIDRUN_TELEMETRY_ENABLED setting.
    """
    if is_telemetry_enabled():
        droidrun_logger.debug(TELEMETRY_ENABLED_MESSAGE)

    else:
        droidrun_logger.debug(TELEMETRY_DISABLED_MESSAGE)


# Print telemetry message on import
print_telemetry_message()


def _is_valid_uuid(value: str) -> bool:
    """Check if string is a valid UUID format."""
    try:
        UUID(value)
        return True
    except (ValueError, AttributeError):
        return False


def get_user_id() -> str:
    """
    Get or create persistent anonymous user ID.

    The user ID is stored in ~/.droidrun/user_id and persists across sessions.
    If the file doesn't exist or contains an invalid UUID, a new one is generated.

    Returns:
        User UUID string, or "unknown" if an error occurs.
    """
    try:
        # Ensure directory exists
        USER_ID_PATH.parent.mkdir(parents=True, exist_ok=True)

        # Read existing ID if valid
        if USER_ID_PATH.exists():
            user_id = USER_ID_PATH.read_text().strip()

            # Validate UUID format
            if user_id and _is_valid_uuid(user_id):
                logger.debug(f"User ID: {user_id}")
                return user_id
            else:
                logger.debug(f"Invalid user ID found in {USER_ID_PATH}, regenerating")

        # Generate new UUID (file missing or invalid)
        user_id = str(uuid4())
        USER_ID_PATH.write_text(user_id)
        logger.debug(f"Generated new user ID: {user_id}")
        return user_id

    except Exception as e:
        logger.error(f"Error getting user ID: {e}")
        return "unknown"


def capture(event: TelemetryEvent, user_id: str | None = None):
    """
    Capture and send a telemetry event to PostHog.

    Args:
        event: Telemetry event to capture (must be a TelemetryEvent subclass)
        user_id: Optional user ID to use instead of the default persistent ID

    Note:
        This function is a no-op if telemetry is disabled.
    """
    try:
        if not is_telemetry_enabled():
            logger.debug(f"Telemetry disabled, skipping capture of {event}")
            return
        event_name = type(event).__name__
        event_data = event.model_dump()
        properties = {
            "run_id": RUN_ID,
            **event_data,
        }

        posthog.capture(
            event_name, distinct_id=user_id or get_user_id(), properties=properties
        )
        logger.debug(f"Captured event: {event_name} with properties: {event}")
    except Exception as e:
        logger.error(f"Error capturing event: {e}")


async def flush():
    try:
        if not is_telemetry_enabled():
            return

        await asyncio.wait_for(asyncio.to_thread(posthog.flush), timeout=10)
    except asyncio.TimeoutError:
        logger.warning("PostHog flush timed out after 10 seconds")
    except Exception as e:
        logger.error(f"Error flushing data: {e}")

```

`droidrun/tools/__init__.py`:

```py
"""
DroidRun Tools - Public API.

    from droidrun.tools import AndroidDriver, RecordingDriver, UIState, StateProvider
"""

from droidrun.tools.driver import AndroidDriver, DeviceDriver, RecordingDriver
from droidrun.tools.ui import AndroidStateProvider, StateProvider, UIState

__all__ = [
    "DeviceDriver",
    "AndroidDriver",
    "RecordingDriver",
    "UIState",
    "StateProvider",
    "AndroidStateProvider",
]

```

`droidrun/tools/android/__init__.py`:

```py
"""Android tools."""

from .portal_client import PortalClient

__all__ = ["PortalClient"]

```

`droidrun/tools/android/portal_client.py`:

```py
"""
Portal Client - Unified communication layer for DroidRun Portal app.

This module provides automatic TCP/Content Provider fallback for Portal communication.
"""

import asyncio
import base64
import io
import json
import logging
import re
from typing import Any, Dict, List, Optional

import httpx
from async_adbutils import AdbDevice

logger = logging.getLogger("droidrun")

PORTAL_REMOTE_PORT = 8080  # Port on device where Portal HTTP server runs


class PortalClient:
    """
    Unified client for DroidRun Portal communication.

    Automatically handles TCP vs Content Provider fallback with the following strategy:
    - On init, checks for existing port forward and reuses it
    - If no forward exists, creates new one
    - Tests connection and sets tcp_available flag
    - All methods auto-select TCP or content provider based on availability
    - Port forwards persist until device disconnect (no explicit cleanup needed)

    Key features:
    - Reuses existing port forwards (no cleanup needed)
    - Automatic fallback to content provider if TCP fails
    - Zero explicit resource management
    - Graceful degradation

    Note: TCP mode is significantly faster but requires ADB port forwarding.
    Content provider mode works without port forwarding but has higher latency.
    """

    def __init__(self, device: AdbDevice, prefer_tcp: bool = False):
        """
        Initialize Portal client.

        Args:
            device: ADB device instance
            prefer_tcp: Whether to prefer TCP communication (will fallback to content provider if unavailable)

        Note:
            Call `await client.connect()` after initialization to establish connection.
        """
        self.device = device
        self.prefer_tcp = prefer_tcp
        self.tcp_available = False
        self.tcp_base_url = None
        self.local_tcp_port = None
        self._connected = False

    async def connect(self) -> None:
        """
        Establish connection...
        """
        if self._connected:
            return

        if self.prefer_tcp:
            await self._try_enable_tcp()

        self._connected = True

    async def _ensure_connected(self) -> None:
        """Check if connected, raise error if not."""
        if not self._connected:
            await self.connect()

    async def _try_enable_tcp(self) -> None:
        """
        Try to enable TCP communication. Fails silently and falls back to content provider.

        Strategy:
        1. Check if forward already exists ‚Üí reuse
        2. If not, create new forward
        3. Test connection with ping
        4. Set tcp_available flag
        """
        try:
            # Step 1: Check for existing forward
            local_port = await self._find_existing_forward()

            # Step 2: If no forward exists, create one
            if local_port is None:
                logger.debug(
                    f"No existing forward found, creating new forward for port {PORTAL_REMOTE_PORT}"
                )
                local_port = await self.device.forward_port(PORTAL_REMOTE_PORT)
                logger.debug(
                    f"Created forward: localhost:{local_port} -> device:{PORTAL_REMOTE_PORT}"
                )
            else:
                logger.debug(
                    f"Reusing existing forward: localhost:{local_port} -> device:{PORTAL_REMOTE_PORT}"
                )

            # Store local port
            self.local_tcp_port = local_port

            # Step 3: Test connection
            self.tcp_base_url = f"http://localhost:{local_port}"
            if await self._test_connection():
                self.tcp_available = True
                logger.debug(f"‚úì TCP mode enabled: {self.tcp_base_url}")
            else:
                # Step 3b: Try enabling the HTTP server via content provider
                logger.debug("TCP ping failed, trying to enable Portal HTTP server...")
                await self.device.shell(
                    "content insert --uri content://com.droidrun.portal/toggle_socket_server --bind enabled:b:true"
                )
                await asyncio.sleep(1)
                if await self._test_connection():
                    self.tcp_available = True
                    logger.debug(
                        f"‚úì TCP mode enabled after starting server: {self.tcp_base_url}"
                    )
                else:
                    logger.warning("TCP unavailable, using content provider fallback")
                    self.tcp_available = False

        except Exception as e:
            logger.warning(f"TCP unavailable ({e}), using content provider fallback")
            self.tcp_available = False

    async def _find_existing_forward(self) -> Optional[int]:
        """
        Check if a forward already exists for the Portal remote port.

        Returns:
            Local port number if forward exists, None otherwise
        """
        try:
            forwards = []
            async for forward in self.device.forward_list():
                forwards.append(forward)
            # forwards is a list of ForwardItem objects with serial, local, remote attributes
            for forward in forwards:
                if (
                    forward.serial == self.device.serial
                    and forward.remote == f"tcp:{PORTAL_REMOTE_PORT}"
                ):
                    # Extract local port from "tcp:12345"
                    match = re.search(r"tcp:(\d+)", forward.local)
                    if match:
                        local_port = int(match.group(1))
                        logger.debug(
                            f"Found existing forward: localhost:{local_port} -> {PORTAL_REMOTE_PORT}"
                        )
                        return local_port
        except Exception as e:
            logger.debug(f"Failed to check existing forwards: {e}")

        return None

    async def _test_connection(self) -> bool:
        """Test if TCP connection to Portal is working."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(f"{self.tcp_base_url}/ping", timeout=5)
                return response.status_code == 200
        except Exception as e:
            logger.debug(f"TCP connection test failed: {e}")
            return False

    def _parse_content_provider_output(
        self, raw_output: str
    ) -> Optional[Dict[str, Any]]:
        """
        Parse the raw ADB content provider output and extract JSON data.

        Args:
            raw_output: Raw output from ADB content query command

        Returns:
            Parsed JSON data or None if parsing failed
        """
        lines = raw_output.strip().split("\n")

        # Try line-by-line parsing
        for line in lines:
            line = line.strip()

            # Look for "result=" pattern (common content provider format)
            if "result=" in line:
                result_start = line.find("result=") + 7
                json_str = line[result_start:]
                try:
                    json_data = json.loads(json_str)
                    # Handle nested "result" or "data" field with JSON string (backward compatible)
                    if isinstance(json_data, dict):
                        # Check for 'result' first (new portal format), then 'data' (legacy)
                        inner_key = (
                            "result"
                            if "result" in json_data
                            else "data" if "data" in json_data else None
                        )
                        if inner_key:
                            inner_value = json_data[inner_key]
                            if isinstance(inner_value, str):
                                try:
                                    return json.loads(inner_value)
                                except json.JSONDecodeError:
                                    return inner_value
                            return inner_value
                    return json_data
                except json.JSONDecodeError:
                    continue

            # Fallback: try lines starting with JSON
            elif line.startswith("{") or line.startswith("["):
                try:
                    return json.loads(line)
                except json.JSONDecodeError:
                    continue

        # Last resort: try parsing entire output
        try:
            return json.loads(raw_output.strip())
        except json.JSONDecodeError:
            return None

    async def get_state(self) -> Dict[str, Any]:
        """
        Get device state (accessibility tree + phone state).
        Auto-selects TCP or content provider.

        Returns:
            Dictionary containing 'a11y_tree' and 'phone_state' keys
        """
        await self._ensure_connected()
        if self.tcp_available:
            return await self._get_state_tcp()
        return await self._get_state_content_provider()

    async def _get_state_tcp(self) -> Dict[str, Any]:
        """Get state via TCP."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.tcp_base_url}/state_full", timeout=10
                )
                if response.status_code == 200:
                    data = response.json()

                    # Handle nested "result" or "data" field (backward compatible)
                    if isinstance(data, dict):
                        # Check for 'result' first (new portal format), then 'data' (legacy)
                        inner_key = (
                            "result"
                            if "result" in data
                            else "data" if "data" in data else None
                        )
                        if inner_key:
                            inner_value = data[inner_key]
                            if isinstance(inner_value, str):
                                try:
                                    return json.loads(inner_value)
                                except json.JSONDecodeError:
                                    pass
                            elif isinstance(inner_value, dict):
                                return inner_value
                    return data
                else:
                    logger.debug(
                        f"TCP get_state failed ({response.status_code}), using fallback"
                    )
                    return await self._get_state_content_provider()
        except Exception as e:
            logger.debug(f"TCP get_state error: {e}, using fallback")
            return await self._get_state_content_provider()

    async def _get_state_content_provider(self) -> Dict[str, Any]:
        """Get state via content provider (fallback)."""
        try:
            output = await self.device.shell(
                "content query --uri content://com.droidrun.portal/state_full"
            )
            state_data = self._parse_content_provider_output(output)

            if state_data is None:
                return {
                    "error": "Parse Error",
                    "message": "Failed to parse state data from ContentProvider",
                }

            # Handle nested "result" or "data" field if present (backward compatible)
            if isinstance(state_data, dict):
                # Check for 'result' first (new portal format), then 'data' (legacy)
                inner_key = (
                    "result"
                    if "result" in state_data
                    else "data" if "data" in state_data else None
                )
                if inner_key:
                    inner_value = state_data[inner_key]
                    if isinstance(inner_value, str):
                        try:
                            return json.loads(inner_value)
                        except json.JSONDecodeError:
                            return {
                                "error": "Parse Error",
                                "message": "Failed to parse nested JSON data",
                            }
                    elif isinstance(inner_value, dict):
                        return inner_value

            return state_data

        except Exception as e:
            return {"error": "ContentProvider Error", "message": str(e)}

    async def input_text(self, text: str, clear: bool = False) -> bool:
        """
        Input text via keyboard.
        Auto-selects TCP or content provider.

        Args:
            text: Text to input
            clear: Whether to clear existing text first

        Returns:
            True if successful, False otherwise
        """
        await self._ensure_connected()
        if self.tcp_available:
            return await self._input_text_tcp(text, clear)
        return await self._input_text_content_provider(text, clear)

    async def _input_text_tcp(self, text: str, clear: bool) -> bool:
        """Input text via TCP."""
        try:
            encoded = base64.b64encode(text.encode()).decode()
            payload = {"base64_text": encoded, "clear": clear}
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.tcp_base_url}/keyboard/input",
                    json=payload,
                    headers={"Content-Type": "application/json"},
                    timeout=10,
                )
                if response.status_code == 200:
                    logger.debug("TCP input_text successful")
                    return True
                else:
                    logger.debug(
                        f"TCP input_text failed ({response.status_code}), using fallback"
                    )
                    return await self._input_text_content_provider(text, clear)
        except Exception as e:
            logger.debug(f"TCP input_text error: {e}, using fallback")
            return await self._input_text_content_provider(text, clear)

    async def _input_text_content_provider(self, text: str, clear: bool) -> bool:
        """Input text via content provider (fallback)."""
        try:
            encoded = base64.b64encode(text.encode()).decode()
            clear_str = "true" if clear else "false"
            cmd = (
                f'content insert --uri "content://com.droidrun.portal/keyboard/input" '
                f'--bind base64_text:s:"{encoded}" '
                f"--bind clear:b:{clear_str}"
            )
            await self.device.shell(cmd)
            logger.debug("Content provider input_text successful")
            return True
        except Exception as e:
            logger.error(f"Content provider input_text error: {e}")
            return False

    async def take_screenshot(self, hide_overlay: bool = True) -> bytes:
        """
        Take screenshot of device.
        Auto-selects TCP or ADB screencap.

        Args:
            hide_overlay: Whether to hide Portal overlay during screenshot

        Returns:
            Screenshot image bytes (PNG format)
        """
        await self._ensure_connected()
        if self.tcp_available:
            return await self._take_screenshot_tcp(hide_overlay)
        return await self._take_screenshot_adb()

    async def _take_screenshot_tcp(self, hide_overlay: bool) -> bytes:
        """Take screenshot via TCP."""
        try:
            url = f"{self.tcp_base_url}/screenshot"
            if not hide_overlay:
                url += "?hideOverlay=false"

            async with httpx.AsyncClient() as client:
                response = await client.get(url, timeout=10.0)
                if response.status_code == 200:
                    data = response.json()
                    # Check for 'result' first (new portal format), then 'data' (legacy)
                    if data.get("status") == "success":
                        inner_key = (
                            "result"
                            if "result" in data
                            else "data" if "data" in data else None
                        )
                        if inner_key:
                            logger.debug("Screenshot taken via TCP")
                            return base64.b64decode(data[inner_key])
                    logger.debug(
                        "TCP screenshot failed (invalid response), using fallback"
                    )
                    return await self._take_screenshot_adb()
                else:
                    logger.debug(
                        f"TCP screenshot failed ({response.status_code}), using fallback"
                    )
                    return await self._take_screenshot_adb()
        except Exception as e:
            logger.debug(f"TCP screenshot error: {e}, using fallback")
            return await self._take_screenshot_adb()

    async def _take_screenshot_adb(self) -> bytes:
        """Take screenshot via ADB screencap (fallback)."""
        data = await self.device.screenshot_bytes()
        logger.debug("Screenshot taken via ADB")
        return data

    async def get_apps(self, include_system: bool = True) -> List[Dict[str, str]]:
        """
        Get installed apps with package name and label.

        Note: Currently only supports content provider (no TCP endpoint exists yet)

        Args:
            include_system: Whether to include system apps

        Returns:
            List of dicts with 'package' and 'label' keys
        """
        await self._ensure_connected()
        try:
            logger.debug("Getting apps via content provider")

            # Query content provider
            output = await self.device.shell(
                "content query --uri content://com.droidrun.portal/packages"
            )
            packages_data = self._parse_content_provider_output(output)

            if not packages_data:
                logger.warning("No packages data found in content provider response")
                return []

            # Handle both formats:
            # - New format: array directly (via RawArray -> result: [...])
            # - Legacy format: wrapped in {"packages": [...]}
            packages_list = None
            if isinstance(packages_data, list):
                # New format: packages_data is already the list
                packages_list = packages_data
            elif isinstance(packages_data, dict):
                if "packages" in packages_data:
                    # Legacy format: wrapped in {"packages": [...]}
                    packages_list = packages_data["packages"]
                else:
                    # May be wrapped in result/data
                    inner_key = (
                        "result"
                        if "result" in packages_data
                        else "data" if "data" in packages_data else None
                    )
                    if inner_key:
                        inner_value = packages_data[inner_key]
                        if isinstance(inner_value, list):
                            packages_list = inner_value
                        elif (
                            isinstance(inner_value, dict) and "packages" in inner_value
                        ):
                            packages_list = inner_value["packages"]

            if not packages_list:
                logger.warning("Could not extract packages list from response")
                return []

            # Filter and format apps
            apps = []
            for package_info in packages_list:
                if not include_system and package_info.get("isSystemApp", False):
                    continue

                apps.append(
                    {
                        "package": package_info.get("packageName", ""),
                        "label": package_info.get("label", ""),
                    }
                )

            logger.debug(f"Found {len(apps)} apps")
            return apps

        except Exception as e:
            logger.error(f"Error getting apps: {e}")
            raise ValueError(f"Error getting apps: {e}") from e

    async def get_version(self) -> str:
        """Get Portal app version."""
        await self._ensure_connected()
        if self.tcp_available:
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.get(
                        f"{self.tcp_base_url}/version", timeout=5.0
                    )
                    if response.status_code == 200:
                        data = response.json()
                        # Check for 'result' first (new portal format), then 'data' (legacy)
                        inner_key = (
                            "result"
                            if "result" in data
                            else "data" if "data" in data else None
                        )
                        if inner_key:
                            return data[inner_key]
                        return data.get("status", "unknown")
            except Exception:
                pass

        # Fallback to content provider
        try:
            output = await self.device.shell(
                "content query --uri content://com.droidrun.portal/version"
            )
            result = self._parse_content_provider_output(output)
            if result:
                # Check for 'result' first (new portal format), then 'data' (legacy)
                inner_key = (
                    "result"
                    if "result" in result
                    else "data" if "data" in result else None
                )
                if inner_key:
                    return result[inner_key]
        except Exception:
            pass

        return "unknown"

    async def ping(self) -> Dict[str, Any]:
        """
        Test Portal connection and verify state availability.

        Returns:
            Dictionary with status and connection details
        """
        await self._ensure_connected()
        if self.tcp_available:
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.get(
                        f"{self.tcp_base_url}/ping", timeout=5.0
                    )
                    if response.status_code == 200:
                        try:
                            tcp_response = response.json() if response.content else {}
                            result = {
                                "status": "success",
                                "method": "tcp",
                                "url": self.tcp_base_url,
                                "response": tcp_response,
                            }
                        except json.JSONDecodeError:
                            result = {
                                "status": "success",
                                "method": "tcp",
                                "url": self.tcp_base_url,
                                "response": response.text,
                            }
                    else:
                        return {
                            "status": "error",
                            "method": "tcp",
                            "message": f"HTTP {response.status_code}: {response.text}",
                        }
            except Exception as e:
                return {"status": "error", "method": "tcp", "message": str(e)}
        else:
            # Test content provider
            try:
                output = await self.device.shell(
                    "content query --uri content://com.droidrun.portal/state"
                )
                if "Row: 0 result=" in output:
                    result = {"status": "success", "method": "content_provider"}
                else:
                    return {
                        "status": "error",
                        "method": "content_provider",
                        "message": "Invalid response",
                    }
            except Exception as e:
                return {
                    "status": "error",
                    "method": "content_provider",
                    "message": str(e),
                }

        # Verify state has the required keys
        try:
            state = await self.get_state()
            required = ("a11y_tree", "phone_state", "device_context")
            missing = [k for k in required if k not in state]
            if missing:
                return {
                    "status": "error",
                    "method": result.get("method", "unknown"),
                    "message": f"incompatible portal ‚Äî missing {', '.join(missing)}",
                }
        except Exception as e:
            return {
                "status": "error",
                "method": result.get("method", "unknown"),
                "message": f"state check failed: {e}",
            }

        return result

```

`droidrun/tools/driver/__init__.py`:

```py
"""Device driver abstractions for DroidRun."""

from droidrun.tools.driver.android import AndroidDriver
from droidrun.tools.driver.base import DeviceDisconnectedError, DeviceDriver
from droidrun.tools.driver.cloud import CloudDriver
from droidrun.tools.driver.ios import IOSDriver
from droidrun.tools.driver.recording import RecordingDriver
from droidrun.tools.driver.stealth import StealthDriver

__all__ = [
    "DeviceDisconnectedError",
    "DeviceDriver",
    "AndroidDriver",
    "CloudDriver",
    "IOSDriver",
    "RecordingDriver",
    "StealthDriver",
]

```

`droidrun/tools/driver/android.py`:

```py
"""AndroidDriver ‚Äî ADB-based device driver.

Wraps ``adbutils.Device`` + ``PortalClient`` to provide clean device I/O
without event emission, formatting, or element lookup.
"""

from __future__ import annotations

import asyncio
import logging
import os
from typing import Any, Dict, List, Optional

from async_adbutils import adb

from droidrun.tools.android.portal_client import PortalClient
from droidrun.tools.driver.base import DeviceDriver

logger = logging.getLogger("droidrun")

PORTAL_DEFAULT_TCP_PORT = 8080


class AndroidDriver(DeviceDriver):
    """Raw Android device I/O via ADB + Portal."""

    supported = {
        "tap",
        "swipe",
        "input_text",
        "press_key",
        "start_app",
        "screenshot",
        "get_ui_tree",
        "get_date",
        "get_apps",
        "list_packages",
        "install_app",
        "drag",
    }

    def __init__(
        self,
        serial: str | None = None,
        use_tcp: bool = False,
        remote_tcp_port: int = PORTAL_DEFAULT_TCP_PORT,
    ) -> None:
        self._serial = serial
        self._use_tcp = use_tcp
        self._remote_tcp_port = remote_tcp_port
        self.device = None
        self.portal: PortalClient | None = None
        self._connected = False

    # -- lifecycle -----------------------------------------------------------

    async def connect(self) -> None:
        if self._connected:
            return

        self.device = await adb.device(serial=self._serial)
        state = await self.device.get_state()
        if state != "device":
            raise ConnectionError(f"Device is not online. State: {state}")

        self.portal = PortalClient(self.device, prefer_tcp=self._use_tcp)
        await self.portal.connect()

        from droidrun.portal import setup_keyboard  # circular import guard

        await setup_keyboard(self.device)
        self._connected = True

    async def ensure_connected(self) -> None:
        if not self._connected:
            await self.connect()

    # -- input actions -------------------------------------------------------

    async def tap(self, x: int, y: int) -> None:
        await self.ensure_connected()
        await self.device.click(x, y)

    async def swipe(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        duration_ms: float = 1000,
    ) -> None:
        await self.ensure_connected()
        await self.device.swipe(x1, y1, x2, y2, float(duration_ms / 1000))
        await asyncio.sleep(duration_ms / 1000)

    async def input_text(self, text: str, clear: bool = False) -> bool:
        await self.ensure_connected()
        return await self.portal.input_text(text, clear)

    async def press_key(self, keycode: int) -> None:
        await self.ensure_connected()
        await self.device.keyevent(keycode)

    async def drag(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        duration: float = 3.0,
    ) -> None:
        await self.ensure_connected()
        raise NotImplementedError("Drag is not implemented yet")

    # -- app management ------------------------------------------------------

    async def start_app(self, package: str, activity: Optional[str] = None) -> str:
        await self.ensure_connected()
        try:
            logger.debug(f"Starting app {package} with activity {activity}")
            if not activity:
                dumpsys_output = await self.device.shell(
                    f"cmd package resolve-activity --brief {package}"
                )
                activity = dumpsys_output.splitlines()[1].split("/")[1]

            logger.debug(f"Activity: {activity}")
            await self.device.app_start(package, activity)
            logger.debug(f"App started: {package} with activity {activity}")
            return f"App started: {package} with activity {activity}"
        except Exception as e:
            return f"Failed to start app {package}: {e}"

    async def install_app(self, path: str, **kwargs) -> str:
        await self.ensure_connected()
        if not os.path.exists(path):
            return f"Failed to install app: APK file not found at {path}"

        reinstall = kwargs.get("reinstall", False)
        grant_permissions = kwargs.get("grant_permissions", True)

        logger.debug(
            f"Installing app: {path} with reinstall: {reinstall} "
            f"and grant_permissions: {grant_permissions}"
        )
        result = await self.device.install(
            path,
            nolaunch=True,
            uninstall=reinstall,
            flags=["-g"] if grant_permissions else [],
            silent=True,
        )
        logger.debug(f"Installed app: {path} with result: {result}")
        return result

    async def get_apps(self, include_system: bool = True) -> List[Dict[str, str]]:
        await self.ensure_connected()
        return await self.portal.get_apps(include_system)

    async def list_packages(self, include_system: bool = False) -> List[str]:
        await self.ensure_connected()
        filter_list = [] if include_system else ["-3"]
        return await self.device.list_packages(filter_list)

    # -- state / observation -------------------------------------------------

    async def screenshot(self, hide_overlay: bool = True) -> bytes:
        await self.ensure_connected()
        return await self.portal.take_screenshot(hide_overlay)

    async def get_ui_tree(self) -> Dict[str, Any]:
        await self.ensure_connected()
        return await self.portal.get_state()

    async def get_date(self) -> str:
        await self.ensure_connected()
        result = await self.device.shell("date")
        return result.strip()

```

`droidrun/tools/driver/base.py`:

```py
"""DeviceDriver ‚Äî raw device I/O interface.

Subclasses implement the actual communication (ADB, iOS HTTP, cloud SDK, etc.).
Unsupported methods are detected via the ``supported`` set, not introspection.
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional


class DeviceDisconnectedError(Exception):
    """Raised when the device is no longer reachable."""

    pass


class DeviceDriver:
    """Base class for all device drivers.

    Every method raises ``NotImplementedError`` by default.
    Concrete drivers override the methods they support and declare them
    in the ``supported`` class-level set.
    """

    supported: set[str] = set()

    # -- lifecycle -----------------------------------------------------------

    async def connect(self) -> None:
        """Establish connection to the device."""
        raise NotImplementedError

    async def ensure_connected(self) -> None:
        """Connect if not already connected."""
        raise NotImplementedError

    # -- input actions -------------------------------------------------------

    async def tap(self, x: int, y: int) -> None:
        """Tap at absolute pixel coordinates."""
        raise NotImplementedError

    async def swipe(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        duration_ms: float = 1000,
    ) -> None:
        """Swipe from (x1, y1) to (x2, y2)."""
        raise NotImplementedError

    async def input_text(self, text: str, clear: bool = False) -> bool:
        """Type *text* into the currently focused field.

        Returns ``True`` on success, ``False`` on failure.
        """
        raise NotImplementedError

    async def press_key(self, keycode: int) -> None:
        """Send a single key-event."""
        raise NotImplementedError

    async def drag(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        duration: float = 3.0,
    ) -> None:
        """Drag from (x1, y1) to (x2, y2)."""
        raise NotImplementedError

    # -- app management ------------------------------------------------------

    async def start_app(self, package: str, activity: Optional[str] = None) -> str:
        """Launch an application.

        Returns a human-readable result string.
        """
        raise NotImplementedError

    async def install_app(self, path: str, **kwargs) -> str:
        """Install an APK/IPA at *path*."""
        raise NotImplementedError

    async def get_apps(self, include_system: bool = True) -> List[Dict[str, str]]:
        """Return installed apps as ``[{"package": ‚Ä¶, "label": ‚Ä¶}, ‚Ä¶]``."""
        raise NotImplementedError

    async def list_packages(self, include_system: bool = False) -> List[str]:
        """Return installed package names."""
        raise NotImplementedError

    # -- state / observation -------------------------------------------------

    async def screenshot(self, hide_overlay: bool = True) -> bytes:
        """Capture the current screen.

        Returns raw PNG bytes.
        """
        raise NotImplementedError

    async def get_ui_tree(self) -> Dict[str, Any]:
        """Return the raw UI / accessibility tree from the device."""
        raise NotImplementedError

    async def get_date(self) -> str:
        """Return the device's current date/time as a string."""
        raise NotImplementedError

```

`droidrun/tools/driver/cloud.py`:

```py
"""CloudDriver ‚Äî MobileRun cloud device driver.

Wraps the ``mobilerun`` SDK (``AsyncMobilerun``) to provide device I/O
for cloud-hosted devices via the MobileRun API.
"""

from __future__ import annotations

import logging
from typing import Any, Awaitable, Dict, List, Optional, TypeVar

from mobilerun import AsyncMobilerun
from mobilerun._exceptions import APIConnectionError, APITimeoutError, ConflictError

from droidrun.tools.driver.base import DeviceDisconnectedError, DeviceDriver

logger = logging.getLogger("droidrun")

T = TypeVar("T")


class CloudDriver(DeviceDriver):
    """Cloud device I/O via the MobileRun SDK."""

    supported = {
        "tap",
        "swipe",
        "input_text",
        "press_key",
        "start_app",
        "screenshot",
        "get_ui_tree",
        "get_date",
        "get_apps",
        "list_packages",
    }

    # MobileRun global action codes (accessibility service)
    _GLOBAL_BACK = 1
    _GLOBAL_HOME = 2

    def __init__(
        self,
        device_id: str,
        display_id: int = 0,
        api_key: str | None = None,
        base_url: str = "https://api.mobilerun.com/v1",
        user_id: str | None = None,
    ) -> None:
        self.device_id = device_id
        self.display_id = display_id

        if user_id:
            self._client = AsyncMobilerun(
                api_key="x",
                base_url=base_url,
                timeout=10.0,
                max_retries=4,
                default_headers={"X-User-ID": user_id},
            )
        else:
            self._client = AsyncMobilerun(
                api_key=api_key,
                base_url=base_url,
                timeout=10.0,
                max_retries=4,
            )

    @property
    def _display_kw(self) -> dict:
        """Common keyword arg for display routing."""
        return {"x_device_display_id": self.display_id}

    async def _call(self, coro: Awaitable[T]) -> T:
        """Await an SDK coroutine, translating disconnect errors."""
        try:
            return await coro
        except (ConflictError, APIConnectionError, APITimeoutError) as e:
            raise DeviceDisconnectedError(str(e)) from e

    # -- lifecycle -----------------------------------------------------------

    async def connect(self) -> None:
        pass  # SDK handles connection

    async def ensure_connected(self) -> None:
        pass

    # -- input actions -------------------------------------------------------

    async def tap(self, x: int, y: int) -> None:
        await self._call(
            self._client.devices.actions.tap(
                self.device_id, x=x, y=y, **self._display_kw
            )
        )

    async def swipe(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        duration_ms: float = 1000,
    ) -> None:
        await self._call(
            self._client.devices.actions.swipe(
                self.device_id,
                start_x=x1,
                start_y=y1,
                end_x=x2,
                end_y=y2,
                duration=duration_ms,
                **self._display_kw,
            )
        )

    async def input_text(self, text: str, clear: bool = False) -> bool:
        await self._call(
            self._client.devices.keyboard.write(
                self.device_id, text=text, clear=clear, **self._display_kw
            )
        )
        return True

    async def press_key(self, keycode: int) -> None:
        # Map Android keycodes to MobileRun global actions where needed
        if keycode == 4:  # KEYCODE_BACK
            await self.global_action(self._GLOBAL_BACK)
        elif keycode == 3:  # KEYCODE_HOME
            await self.global_action(self._GLOBAL_HOME)
        else:
            await self._call(
                self._client.devices.keyboard.key(
                    self.device_id, key=keycode, **self._display_kw
                )
            )

    async def drag(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        duration: float = 3.0,
    ) -> None:
        raise NotImplementedError("Drag is not supported on cloud devices")

    # -- app management ------------------------------------------------------

    async def start_app(self, package: str, activity: Optional[str] = None) -> str:
        await self._call(
            self._client.devices.apps.start(
                package,
                device_id=self.device_id,
                activity=activity or None,
                **self._display_kw,
            )
        )
        return f"App started: {package}"

    async def get_apps(self, include_system: bool = True) -> List[Dict[str, Any]]:
        apps = await self._call(
            self._client.devices.apps.list(
                device_id=self.device_id,
                include_system_apps=include_system,
                **self._display_kw,
            )
        )
        return [app.model_dump() for app in apps]

    async def list_packages(self, include_system: bool = False) -> List[str]:
        packages = await self._call(
            self._client.devices.packages.list(
                device_id=self.device_id,
                include_system_packages=include_system,
                **self._display_kw,
            )
        )
        return packages

    # -- state / observation -------------------------------------------------

    async def screenshot(self, hide_overlay: bool = True) -> bytes:
        response = await self._call(
            self._client.devices.state.with_raw_response.screenshot(
                self.device_id, **self._display_kw
            )
        )
        return await self._call(response.read())

    async def get_ui_tree(self) -> Dict[str, Any]:
        response = await self._call(
            self._client.devices.state.ui(self.device_id, **self._display_kw)
        )
        return response.model_dump()

    async def get_date(self) -> str:
        return await self._call(
            self._client.devices.state.time(self.device_id, **self._display_kw)
        )

    # -- cloud-specific ------------------------------------------------------

    async def global_action(self, action: int) -> bool:
        """Execute a MobileRun global action (accessibility service).

        Common actions: 1=Back, 2=Home, 3=Recents, 4=Notifications,
        5=QuickSettings, 6=PowerDialog, 9=TakeScreenshot.
        """
        await self._call(
            self._client.devices.actions.global_(
                self.device_id, action=action, **self._display_kw
            )
        )
        return True

```

`droidrun/tools/driver/ios.py`:

```py
"""IOSDriver ‚Äî HTTP REST-based device driver for iOS.

Wraps the iOS portal HTTP API (running on the device) to provide device I/O
through the same ``DeviceDriver`` interface used by Android.

Known limitations (pre-existing, documented as TODOs):
- ``clear`` parameter in ``input_text`` is ignored
- ``press_key`` only maps HOME; BACK and ENTER have no iOS equivalent
- ``get_date`` not available (no iOS portal endpoint)
- ``drag`` not implemented
- ``get_apps`` returns bundle identifiers, not real app metadata
- Screen dimensions inferred from element bounds (no portal endpoint)
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

import httpx

from droidrun.tools.driver.base import DeviceDriver

logger = logging.getLogger("droidrun")

SYSTEM_BUNDLE_IDENTIFIERS = [
    "ai.droidrun.droidrun-ios-portal",
    "com.apple.Bridge",
    "com.apple.DocumentsApp",
    "com.apple.Fitness",
    "com.apple.Health",
    "com.apple.Maps",
    "com.apple.MobileAddressBook",
    "com.apple.MobileSMS",
    "com.apple.Passbook",
    "com.apple.Passwords",
    "com.apple.Preferences",
    "com.apple.PreviewShell",
    "com.apple.mobilecal",
    "com.apple.mobilesafari",
    "com.apple.mobileslideshow",
    "com.apple.news",
    "com.apple.reminders",
    "com.apple.shortcuts",
    "com.apple.webapp",
]

# Android keycode ‚Üí iOS keycode translation.
# Only HOME is mapped; others have no iOS equivalent.
_ANDROID_TO_IOS_KEYCODE = {
    3: 0,  # HOME
    # TODO: 4 (BACK) has no iOS equivalent
    # TODO: 66 (ENTER) has no iOS equivalent
}


class IOSDriver(DeviceDriver):
    """iOS device driver communicating via HTTP REST to the iOS portal app."""

    supported = {
        "tap",
        "swipe",
        "input_text",
        "press_key",
        "start_app",
        "screenshot",
        "get_ui_tree",
        "list_packages",
        "get_apps",
    }

    def __init__(
        self,
        url: str,
        bundle_identifiers: Optional[List[str]] = None,
    ) -> None:
        self.url = url.rstrip("/")
        self.bundle_identifiers = bundle_identifiers or []
        self._client: Optional[httpx.AsyncClient] = None
        self._last_tapped_rect: Optional[str] = None
        self._connected = False

    # -- lifecycle -----------------------------------------------------------

    async def connect(self) -> None:
        self._client = httpx.AsyncClient(base_url=self.url, timeout=30.0)
        # TODO: verify URL is reachable (ping /vision/state or similar)
        self._connected = True
        logger.info(f"Connected to iOS device at {self.url}")

    async def ensure_connected(self) -> None:
        if not self._connected:
            await self.connect()

    # -- input actions -------------------------------------------------------

    async def tap(self, x: int, y: int) -> None:
        ios_rect = f"{{{{{x},{y}}},{{{1},{1}}}}}"
        # Store for input_text (iOS API requires a rect for typing)
        # TODO: stores center point as 1x1 rect, not full element bounds
        self._last_tapped_rect = f"{x},{y},1,1"
        resp = await self._client.post(
            "/gestures/tap",
            json={"rect": ios_rect, "count": 1, "longPress": False},
        )
        resp.raise_for_status()

    async def swipe(
        self, x1: int, y1: int, x2: int, y2: int, duration_ms: float = 1000
    ) -> None:
        # iOS API is direction-based, not coordinate-based
        dx, dy = x2 - x1, y2 - y1
        if abs(dx) > abs(dy):
            direction = "right" if dx > 0 else "left"
        else:
            direction = "down" if dy > 0 else "up"
        resp = await self._client.post(
            "/gestures/swipe",
            json={"x": float(x1), "y": float(y1), "dir": direction},
        )
        resp.raise_for_status()

    async def input_text(self, text: str, clear: bool = False) -> bool:
        # TODO: clear not supported on iOS portal
        rect = self._last_tapped_rect or "0,0,100,100"
        resp = await self._client.post(
            "/inputs/type", json={"rect": rect, "text": text}
        )
        return resp.status_code == 200

    async def press_key(self, keycode: int) -> None:
        ios_keycode = _ANDROID_TO_IOS_KEYCODE.get(keycode)
        if ios_keycode is None:
            # TODO: BACK (4) and ENTER (66) have no iOS equivalent
            logger.warning(f"Keycode {keycode} not supported on iOS, ignoring")
            return
        resp = await self._client.post("/inputs/key", json={"key": ios_keycode})
        resp.raise_for_status()

    # -- app management ------------------------------------------------------

    async def start_app(self, package: str, activity: Optional[str] = None) -> str:
        resp = await self._client.post(
            "/inputs/launch", json={"bundleIdentifier": package}
        )
        if resp.status_code == 200:
            return f"Launched {package}"
        return f"Failed to launch {package}: HTTP {resp.status_code}"

    async def get_apps(self, include_system: bool = True) -> List[Dict[str, str]]:
        # TODO: iOS portal has no app listing endpoint.
        # Returns bundle identifiers as both package and label.
        all_ids: set[str] = set(self.bundle_identifiers)
        if include_system:
            all_ids.update(SYSTEM_BUNDLE_IDENTIFIERS)
        return [{"package": bid, "label": bid} for bid in sorted(all_ids)]

    async def list_packages(self, include_system: bool = False) -> List[str]:
        apps = await self.get_apps(include_system)
        return [a["package"] for a in apps]

    # -- state / observation -------------------------------------------------

    async def screenshot(self, hide_overlay: bool = True) -> bytes:
        resp = await self._client.get("/vision/screenshot")
        resp.raise_for_status()
        return resp.content

    async def get_ui_tree(self) -> Dict[str, Any]:
        """Return raw iOS accessibility data and phone state.

        Returns a dict with:
        - ``a11y_raw``: the raw accessibility tree text from the portal
        - ``phone_state``: dict with ``current_activity`` and ``keyboard_shown``
        """
        a11y_resp = await self._client.get("/vision/a11y")
        a11y_resp.raise_for_status()
        a11y_data = a11y_resp.json()

        state_resp = await self._client.get("/vision/state")
        if state_resp.status_code == 200:
            state_data = state_resp.json()
            phone_state = {
                "currentApp": state_data.get("activity", "Unknown"),
                "keyboardVisible": state_data.get("keyboardShown", False),
            }
        else:
            phone_state = {
                "currentApp": "Unknown",
                "keyboardVisible": False,
            }

        return {
            "a11y_raw": a11y_data["accessibilityTree"],
            "phone_state": phone_state,
        }

    async def get_date(self) -> str:
        # TODO: not available on iOS portal
        return ""

```

`droidrun/tools/driver/recording.py`:

```py
"""RecordingDriver ‚Äî transparent proxy that logs user-visible actions.

Wraps any ``DeviceDriver`` and appends dicts to ``self.log`` for every
mutating action.  Read-only methods (screenshot, get_ui_tree, ‚Ä¶) pass
through automatically via ``__getattr__``.
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional

from droidrun.tools.driver.base import DeviceDriver


class RecordingDriver:
    """Proxy that records device-level actions for macro replay.

    Dict key is ``"action_type"`` ‚Äî consistent with ``replay.py`` and
    ``trajectory.py`` expectations.
    """

    def __init__(self, inner: DeviceDriver) -> None:
        self.inner = inner
        self.log: List[Dict[str, Any]] = []

    @property
    def supported(self) -> set[str]:
        return self.inner.supported

    def __getattr__(self, name: str):
        """Delegate all non-overridden attribute lookups to the inner driver."""
        return getattr(self.inner, name)

    # -- recorded actions ----------------------------------------------------

    async def tap(self, x: int, y: int) -> None:
        await self.inner.tap(x, y)
        self.log.append({"action_type": "tap", "x": x, "y": y})

    async def swipe(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        duration_ms: float = 1000,
    ) -> None:
        await self.inner.swipe(x1, y1, x2, y2, duration_ms)
        self.log.append(
            {
                "action_type": "swipe",
                "start_x": x1,
                "start_y": y1,
                "end_x": x2,
                "end_y": y2,
                "duration_ms": duration_ms,
            }
        )

    async def input_text(self, text: str, clear: bool = False) -> bool:
        result = await self.inner.input_text(text, clear)
        self.log.append({"action_type": "input_text", "text": text, "clear": clear})
        return result

    async def press_key(self, keycode: int) -> None:
        await self.inner.press_key(keycode)
        self.log.append({"action_type": "key_press", "keycode": keycode})

    async def start_app(self, package: str, activity: Optional[str] = None) -> str:
        result = await self.inner.start_app(package, activity)
        self.log.append(
            {
                "action_type": "start_app",
                "package": package,
                "activity": activity,
            }
        )
        return result

    async def drag(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        duration: float = 3.0,
    ) -> None:
        await self.inner.drag(x1, y1, x2, y2, duration)
        self.log.append(
            {
                "action_type": "drag",
                "start_x": x1,
                "start_y": y1,
                "end_x": x2,
                "end_y": y2,
                "duration": duration,
            }
        )

```

`droidrun/tools/driver/stealth.py`:

```py
"""StealthDriver ‚Äî human-like interaction wrapper for device drivers.

Wraps any ``DeviceDriver`` to provide:
- Curved Bezier swipe paths with easing and micro-jitter
- Word-by-word typing with random inter-word delays

Non-overridden methods delegate to the inner driver via ``__getattr__``.
"""

from __future__ import annotations

import asyncio
import math
import random
from typing import Any, List, Tuple

from droidrun.tools.driver.base import DeviceDriver

# ---------------------------------------------------------------------------
# Path generation helpers
# ---------------------------------------------------------------------------


def _ease_in_out_cubic(t: float) -> float:
    """Cubic easing for natural acceleration/deceleration."""
    if t < 0.5:
        return 4 * t**3
    return 1 - pow(-2 * t + 2, 3) / 2


def _perlin_noise_1d(x: float, seed: int = 0) -> float:
    """Simple 1-D Perlin-like noise for micro-jitter simulation."""
    random.seed(seed + int(x * 1000))
    freq1 = random.uniform(0.5, 1.5)
    freq2 = random.uniform(2.0, 3.0)
    freq3 = random.uniform(4.0, 6.0)
    return (
        math.sin(x * freq1) * 0.5
        + math.sin(x * freq2) * 0.3
        + math.sin(x * freq3) * 0.2
    )


def generate_curved_path(
    start_x: int,
    start_y: int,
    end_x: int,
    end_y: int,
    num_points: int = 15,
) -> List[Tuple[int, int]]:
    """Generate a curved path using a quadratic Bezier curve.

    Includes velocity profiling (ease-in/ease-out), micro-jitter via
    Perlin noise, and randomized control points for organic curves.
    """
    distance = ((end_x - start_x) ** 2 + (end_y - start_y) ** 2) ** 0.5

    if distance <= 100:
        num_points = max(5, int(num_points / 3))

    mid_x = (start_x + end_x) / 2
    mid_y = (start_y + end_y) / 2

    curve_intensity = random.uniform(0.1, 0.25)
    max_offset = distance * curve_intensity
    offset = random.uniform(-max_offset, max_offset)

    dx = end_x - start_x
    dy = end_y - start_y

    if distance > 0:
        perp_x = -dy / distance
        perp_y = dx / distance
        control_x = mid_x + perp_x * offset
        control_y = mid_y + perp_y * offset
    else:
        control_x = mid_x
        control_y = mid_y

    noise_seed = random.randint(0, 10000)
    jitter_intensity = min(2.0, distance * 0.01)

    points: List[Tuple[int, int]] = []
    for i in range(num_points):
        linear_t = i / (num_points - 1)
        eased_t = _ease_in_out_cubic(linear_t)

        x = (
            (1 - eased_t) ** 2 * start_x
            + 2 * (1 - eased_t) * eased_t * control_x
            + eased_t**2 * end_x
        )
        y = (
            (1 - eased_t) ** 2 * start_y
            + 2 * (1 - eased_t) * eased_t * control_y
            + eased_t**2 * end_y
        )

        jitter_x = _perlin_noise_1d(linear_t * 10, noise_seed) * jitter_intensity
        jitter_y = _perlin_noise_1d(linear_t * 10, noise_seed + 1000) * jitter_intensity

        points.append((int(x + jitter_x), int(y + jitter_y)))

    return points


# ---------------------------------------------------------------------------
# StealthDriver
# ---------------------------------------------------------------------------


class StealthDriver:
    """Transparent proxy that adds human-like randomness to device I/O.

    Overrides:
    - ``swipe()`` ‚Üí curved Bezier path via ``input motionevent``
    - ``input_text()`` ‚Üí word-by-word typing with random delays

    Everything else delegates to the inner driver.
    """

    def __init__(self, inner: DeviceDriver) -> None:
        self.inner = inner

    @property
    def supported(self) -> set[str]:
        return self.inner.supported

    def __getattr__(self, name: str) -> Any:
        return getattr(self.inner, name)

    # -- overridden actions --------------------------------------------------

    async def swipe(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        duration_ms: float = 1000,
    ) -> None:
        """Perform a curved swipe using motionevent commands."""
        await self.inner.ensure_connected()
        path_points = generate_curved_path(x1, y1, x2, y2)

        x0, y0 = path_points[0]
        await self.inner.device.shell(f"input motionevent DOWN {x0} {y0}")

        delay = duration_ms / 1000 / len(path_points)
        for x, y in path_points[1:]:
            await asyncio.sleep(delay)
            await self.inner.device.shell(f"input motionevent MOVE {x} {y}")

        x_end, y_end = path_points[-1]
        await self.inner.device.shell(f"input motionevent UP {x_end} {y_end}")

    async def input_text(self, text: str, clear: bool = False) -> bool:
        """Type text word-by-word with random delays between words."""
        words = text.split(" ")

        for i, word in enumerate(words):
            ok = await self.inner.input_text(word, clear=(clear and i == 0))
            if not ok:
                return False

            if i < len(words) - 1:
                space_ok = await self.inner.input_text(" ", clear=False)
                if not space_ok:
                    return False
                await asyncio.sleep(random.uniform(0.1, 0.3))

        return True

```

`droidrun/tools/filters/__init__.py`:

```py
"""Filter exports."""

from .base import TreeFilter
from .concise_filter import ConciseFilter
from .detailed_filter import DetailedFilter


def get_filter(name: str, **kwargs) -> TreeFilter:
    """Factory to get filter by name."""
    filters = {
        "concise": ConciseFilter,
        "detailed": DetailedFilter,
    }

    filter_class = filters.get(name.lower())
    if filter_class is None:
        raise ValueError(f"Unknown filter: {name}. Available: {list(filters.keys())}")

    return filter_class(**kwargs)


__all__ = ["TreeFilter", "ConciseFilter", "DetailedFilter", "get_filter"]

```

`droidrun/tools/filters/base.py`:

```py
"""Base interface for accessibility tree filters."""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional


class TreeFilter(ABC):
    """Interface for filtering accessibility trees."""

    @abstractmethod
    def filter(
        self, a11y_tree: Dict[str, Any], device_context: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Filter tree and return filtered tree with hierarchy preserved."""
        pass

    @abstractmethod
    def get_name(self) -> str:
        """Return filter name."""
        pass

```

`droidrun/tools/filters/concise_filter.py`:

```py
"""Concise filtering - all logic self-contained."""

from typing import Dict, Any, Optional
from .base import TreeFilter


class ConciseFilter(TreeFilter):
    """Concise tree filtering (formerly DroidRun)."""

    def filter(
        self, a11y_tree: Dict[str, Any], device_context: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Filter using concise logic."""
        screen_bounds = device_context.get("screen_bounds", {})
        filtering_params = device_context.get("filtering_params", {})

        return self._filter_node(a11y_tree, screen_bounds, filtering_params)

    def _filter_node(
        self,
        node: Dict[str, Any],
        screen_bounds: Dict[str, int],
        filtering_params: Dict[str, Any],
    ) -> Optional[Dict[str, Any]]:
        """Recursively filter node."""
        min_size = filtering_params.get("min_element_size", 5)
        screen_width = screen_bounds.get("width", 1080)
        screen_height = screen_bounds.get("height", 2400)

        if not self._intersects_screen(node, screen_width, screen_height):
            return None
        if not self._min_size(node, min_size):
            return None

        filtered_children = []
        for child in node.get("children", []):
            filtered_child = self._filter_node(child, screen_bounds, filtering_params)
            if filtered_child:
                filtered_children.append(filtered_child)

        return {**node, "children": filtered_children}

    @staticmethod
    def _intersects_screen(
        node: Dict[str, Any], screen_width: int, screen_height: int
    ) -> bool:
        """Check if element intersects screen bounds."""
        bounds = node.get("boundsInScreen", {})
        left = bounds.get("left", 0)
        top = bounds.get("top", 0)
        right = bounds.get("right", 0)
        bottom = bounds.get("bottom", 0)
        return not (
            right <= 0 or bottom <= 0 or left >= screen_width or top >= screen_height
        )

    @staticmethod
    def _min_size(node: Dict[str, Any], min_size: int) -> bool:
        """Check if element meets minimum size."""
        bounds = node.get("boundsInScreen", {})
        w = bounds.get("right", 0) - bounds.get("left", 0)
        h = bounds.get("bottom", 0) - bounds.get("top", 0)
        return w > min_size and h > min_size

    def get_name(self) -> str:
        """Return filter name."""
        return "concise"

```

`droidrun/tools/filters/detailed_filter.py`:

```py
"""Detailed filtering - all logic self-contained."""

from typing import Dict, Any, Optional
from .base import TreeFilter


class DetailedFilter(TreeFilter):
    """Detailed tree filtering with 10% visibility rule."""

    def __init__(
        self,
        visibility_threshold: float = 0.1,
        filter_keyboard: bool = True,
        clip_bounds: bool = False,
    ):
        self.visibility_threshold = visibility_threshold
        self.filter_keyboard = filter_keyboard
        self.clip_bounds = clip_bounds

    def filter(
        self, a11y_tree: Dict[str, Any], device_context: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Filter using detailed logic."""
        screen_bounds = device_context.get("screen_bounds", {})
        screen_width = screen_bounds.get("width", 1080)
        screen_height = screen_bounds.get("height", 2400)

        filtered_tree = a11y_tree

        if self.clip_bounds:
            filtered_tree = self._clip_tree_bounds(
                filtered_tree, screen_width, screen_height
            )

        if self.filter_keyboard:
            filtered_tree = self._filter_keyboard_elements(filtered_tree)
            if filtered_tree is None:
                return None

        filtered_tree = self._filter_out_of_bounds(
            filtered_tree, screen_width, screen_height
        )

        return filtered_tree

    @staticmethod
    def _get_visible_percentage(
        bounds: Dict[str, int], screen_width: int, screen_height: int
    ) -> float:
        """Calculate what percentage of element is visible on screen."""
        left = bounds.get("left", 0)
        top = bounds.get("top", 0)
        right = bounds.get("right", 0)
        bottom = bounds.get("bottom", 0)

        width = right - left
        height = bottom - top

        if width == 0 and height == 0:
            return 0.0

        overflow = (
            left <= 0 and top <= 0 and right >= screen_width and bottom >= screen_height
        )
        if overflow:
            return 1.0

        visible_x = max(0, min(right, screen_width) - max(left, 0))
        visible_y = max(0, min(bottom, screen_height) - max(top, 0))

        visible_area = visible_x * visible_y
        total_area = width * height

        return visible_area / total_area if total_area > 0 else 0.0

    @staticmethod
    def _clip_bounds_to_screen(
        bounds: Dict[str, int], screen_width: int, screen_height: int
    ) -> Dict[str, int]:
        """Clip element bounds to screen boundaries."""
        return {
            "left": max(bounds.get("left", 0), 0),
            "top": max(bounds.get("top", 0), 0),
            "right": min(bounds.get("right", 0), screen_width),
            "bottom": min(bounds.get("bottom", 0), screen_height),
        }

    @classmethod
    def _clip_tree_bounds(
        cls, node: Dict[str, Any], screen_width: int, screen_height: int
    ) -> Dict[str, Any]:
        """Recursively clip all bounds in tree to screen."""
        if "boundsInScreen" in node:
            node = {**node}
            node["boundsInScreen"] = cls._clip_bounds_to_screen(
                node["boundsInScreen"], screen_width, screen_height
            )

        if "children" in node:
            node["children"] = [
                cls._clip_tree_bounds(child, screen_width, screen_height)
                for child in node["children"]
            ]

        return node

    @staticmethod
    def _should_filter_keyboard(node: Dict[str, Any]) -> bool:
        """Check if element is from Google keyboard."""
        resource_id = node.get("resourceId", "")
        return resource_id.startswith("com.google.android.inputmethod.latin:id/")

    @classmethod
    def _filter_keyboard_elements(
        cls, node: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Recursively remove keyboard elements from tree."""
        filtered_children = []
        for child in node.get("children", []):
            filtered_child = cls._filter_keyboard_elements(child)
            if filtered_child is not None:
                filtered_children.append(filtered_child)

        if cls._should_filter_keyboard(node):
            return None

        return {**node, "children": filtered_children}

    def _filter_out_of_bounds(
        self, node: Dict[str, Any], screen_width: int, screen_height: int
    ) -> Optional[Dict[str, Any]]:
        """Filter tree by visibility with parent preservation."""
        if node.get("ignoreBoundsFiltering") == "true":
            return node

        filtered_children = []
        for child in node.get("children", []):
            filtered_child = self._filter_out_of_bounds(
                child, screen_width, screen_height
            )
            if filtered_child is not None:
                filtered_children.append(filtered_child)

        bounds = node.get("boundsInScreen")
        if bounds is None:
            visible_percentage = 0.0
        else:
            visible_percentage = self._get_visible_percentage(
                bounds, screen_width, screen_height
            )

        if visible_percentage < self.visibility_threshold and not filtered_children:
            return None

        return {**node, "children": filtered_children}

    def get_name(self) -> str:
        """Return filter name."""
        return "detailed"

```

`droidrun/tools/formatters/__init__.py`:

```py
"""Formatter exports."""

from .base import TreeFormatter
from .indexed_formatter import IndexedFormatter


__all__ = ["TreeFormatter", "IndexedFormatter"]

```

`droidrun/tools/formatters/base.py`:

```py
"""Base interface for tree formatters."""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional, Tuple


class TreeFormatter(ABC):
    """Interface for formatting filtered trees."""

    @abstractmethod
    def format(
        self, filtered_tree: Optional[Dict[str, Any]], phone_state: Dict[str, Any]
    ) -> Tuple[str, str, List[Dict[str, Any]], Dict[str, Any]]:
        """Format filtered tree to standard output format.

        Args:
            filtered_tree: Filtered accessibility tree (or None)
            phone_state: Raw phone state dictionary

        Returns:
            Tuple of:
            - formatted_text (str): Complete formatted device state for prompts
            - focused_text (str): Text content of focused element (empty if none)
            - a11y_tree (List[Dict]): Flattened/Processed accessibility tree with indices
            - phone_state (Dict): Raw phone state dict
        """
        pass

```

`droidrun/tools/formatters/indexed_formatter.py`:

```py
"""Indexed formatter - Standard DroidRun format."""

from typing import Dict, Any, List, Optional, Tuple
from .base import TreeFormatter
from ..helpers.coordinate import bounds_to_normalized


class IndexedFormatter(TreeFormatter):
    """Format tree in the standard DroidRun format."""

    def __init__(self):
        self.screen_width: Optional[int] = None
        self.screen_height: Optional[int] = None
        self.use_normalized: bool = False

    def format(
        self, filtered_tree: Optional[Dict[str, Any]], phone_state: Dict[str, Any]
    ) -> Tuple[str, str, List[Dict[str, Any]], Dict[str, Any]]:
        """Format device state with indices and hierarchy."""
        focused_text = self._get_focused_text(phone_state)

        if filtered_tree is None:
            a11y_tree = []
        else:
            a11y_tree = self._flatten_with_index(filtered_tree, [1])

        phone_state_text = self._format_phone_state(phone_state)
        ui_elements_text = self._format_ui_elements_text(a11y_tree)

        formatted_text = f"{phone_state_text}\n\n{ui_elements_text}"

        return (formatted_text, focused_text, a11y_tree, phone_state)

    @staticmethod
    def _get_focused_text(phone_state: Dict[str, Any]) -> str:
        """Extract focused element text."""
        focused_element = phone_state.get("focusedElement")
        if focused_element:
            return focused_element.get("text", "")
        return ""

    @staticmethod
    def _format_phone_state(phone_state: Dict[str, Any]) -> str:
        """Format phone state."""
        if isinstance(phone_state, dict) and "error" not in phone_state:
            current_app = phone_state.get("currentApp", "")
            package_name = phone_state.get("packageName", "Unknown")
            focused_element = phone_state.get("focusedElement")
            is_editable = phone_state.get("isEditable", False)

            if focused_element and focused_element.get("text"):
                focused_desc = f"'{focused_element.get('text', '')}'"
            else:
                focused_desc = "''"

            phone_state_text = f"""**Current Phone State:**
‚Ä¢ **App:** {current_app} ({package_name})
‚Ä¢ **Keyboard:** {'Visible' if is_editable else 'Hidden'}
‚Ä¢ **Focused Element:** {focused_desc}"""
        else:
            if isinstance(phone_state, dict) and "error" in phone_state:
                phone_state_text = f"üì± **Phone State Error:** {phone_state.get('message', 'Unknown error')}"
            else:
                phone_state_text = f"üì± **Phone State:** {phone_state}"

        return phone_state_text

    def _format_ui_elements_text(self, a11y_tree: List[Dict[str, Any]]) -> str:
        """Format UI elements text."""
        coord_note = " (normalized [0-1000])" if self.use_normalized else ""
        schema = "'index. className: resourceId, text - bounds(x1,y1,x2,y2)'"
        if a11y_tree:
            formatted_ui = IndexedFormatter._format_ui_elements(a11y_tree)
            ui_elements_text = (
                f"Current Clickable UI elements{coord_note}:\n{schema}:\n{formatted_ui}"
            )
        else:
            ui_elements_text = f"Current Clickable UI elements{coord_note}:\n{schema}:\nNo UI elements found"
        return ui_elements_text

    @staticmethod
    def _format_ui_elements(ui_data: List[Dict[str, Any]], level: int = 0) -> str:
        """Format UI elements."""
        if not ui_data:
            return ""

        formatted_lines = []
        indent = "  " * level

        elements = ui_data if isinstance(ui_data, list) else [ui_data]

        for element in elements:
            if not isinstance(element, dict):
                continue

            index = element.get("index", "")
            class_name = element.get("className", "")
            resource_id = element.get("resourceId", "")
            text = element.get("text", "")
            bounds = element.get("bounds", "")
            children = element.get("children", [])

            line_parts = []
            if index != "":
                line_parts.append(f"{index}.")
            if class_name:
                line_parts.append(class_name + ":")

            details = []
            if resource_id:
                details.append(f'"{resource_id}"')
            if text:
                details.append(f'"{text}"')

            if details:
                line_parts.append(", ".join(details))

            if bounds:
                line_parts.append(f"- ({bounds})")

            formatted_line = f"{indent}{' '.join(line_parts)}"
            formatted_lines.append(formatted_line)

            if children:
                child_formatted = IndexedFormatter._format_ui_elements(
                    children, level + 1
                )
                if child_formatted:
                    formatted_lines.append(child_formatted)

        return "\n".join(formatted_lines)

    def _flatten_with_index(
        self, node: Dict[str, Any], counter: List[int]
    ) -> List[Dict[str, Any]]:
        """Recursively flatten tree with index assignment."""
        results = []

        formatted = self._format_node(node, counter[0])
        results.append(formatted)
        counter[0] += 1

        for child in node.get("children", []):
            results.extend(self._flatten_with_index(child, counter))

        return results

    def _format_node(self, node: Dict[str, Any], index: int) -> Dict[str, Any]:
        """Format single node to DroidRun format."""
        bounds = node.get("boundsInScreen", {})
        bounds_str = f"{bounds.get('left', 0)},{bounds.get('top', 0)},{bounds.get('right', 0)},{bounds.get('bottom', 0)}"

        if self.use_normalized and self.screen_width and self.screen_height:
            bounds_str = bounds_to_normalized(
                bounds_str, self.screen_width, self.screen_height
            )

        text = (
            node.get("text")
            or node.get("contentDescription")
            or node.get("resourceId")
            or node.get("className", "")
        )

        class_name = node.get("className", "")
        short_class = class_name.split(".")[-1] if class_name else ""

        return {
            "index": index,
            "resourceId": node.get("resourceId", ""),
            "className": short_class,
            "text": text,
            "bounds": bounds_str,
            "children": [],
        }

```

`droidrun/tools/helpers/__init__.py`:

```py
"""Helper utilities for tools."""

from .geometry import find_clear_point, rects_overlap
from .coordinate import (
    NORMALIZED_MAX,
    to_absolute,
    to_normalized,
    bounds_to_normalized,
)

__all__ = [
    "find_clear_point",
    "rects_overlap",
    "NORMALIZED_MAX",
    "to_absolute",
    "to_normalized",
    "bounds_to_normalized",
]

```

`droidrun/tools/helpers/coordinate.py`:

```py
"""Coordinate conversion utilities for normalized [0-1000] coordinates."""

NORMALIZED_MAX = 1000


def to_absolute(x: int, y: int, width: int, height: int) -> tuple[int, int]:
    """Convert [0-1000] normalized to absolute pixels."""
    if width is None or height is None:
        raise ValueError("Screen dimensions not available. Call get_state() first.")
    return int(x * width / NORMALIZED_MAX), int(y * height / NORMALIZED_MAX)


def to_normalized(x: int, y: int, width: int, height: int) -> tuple[int, int]:
    """Convert absolute pixels to [0-1000] normalized."""
    if width is None or height is None:
        raise ValueError("Screen dimensions not available. Call get_state() first.")
    return int(x * NORMALIZED_MAX / width), int(y * NORMALIZED_MAX / height)


def bounds_to_normalized(bounds_str: str, width: int, height: int) -> str:
    """Convert 'left,top,right,bottom' bounds string to normalized."""
    left, top, right, bottom = map(int, bounds_str.split(","))
    n_left, n_top = to_normalized(left, top, width, height)
    n_right, n_bottom = to_normalized(right, bottom, width, height)
    return f"{n_left},{n_top},{n_right},{n_bottom}"

```

`droidrun/tools/helpers/element_search.py`:

```py
"""
Element search and filtering for Android accessibility trees.

Provides composable filters to search elements by text, ID, spatial relationships, and traits.
Works with raw a11y tree data from Portal before index assignment.
"""

from typing import List, Dict, Any, Callable, Tuple
import re

ElementFilter = Callable[[List[Dict[str, Any]]], List[Dict[str, Any]]]


# ========== HELPER FUNCTIONS ==========


def flatten_tree(root: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Recursively flatten tree to list of all nodes."""
    results = [root]
    for child in root.get("children", []):
        results.extend(flatten_tree(child))
    return results


def get_element_center(node: Dict[str, Any]) -> Tuple[int, int]:
    """Get center coordinates from boundsInScreen."""
    bounds = node.get("boundsInScreen", {})
    left = bounds.get("left", 0)
    top = bounds.get("top", 0)
    right = bounds.get("right", 0)
    bottom = bounds.get("bottom", 0)

    center_x = (left + right) // 2
    center_y = (top + bottom) // 2

    return (center_x, center_y)


def sort_by_position(nodes: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Sort elements top-to-bottom, left-to-right."""

    def get_sort_key(node: Dict) -> Tuple[int, int]:
        bounds = node.get("boundsInScreen", {})
        top = bounds.get("top", 0)
        left = bounds.get("left", 0)
        return (top, left)

    return sorted(nodes, key=get_sort_key)


# ========== FILTERS CLASS ==========


class Filters:
    """Composable filters for element search."""

    # ========== TEXT MATCHING ==========

    @staticmethod
    def text_matches(pattern: str | re.Pattern) -> ElementFilter:
        """
        Match elements by text content in text, contentDescription, or hint fields.
        Supports exact match, regex, and newline normalization.
        """
        if isinstance(pattern, str):
            regex = re.compile(re.escape(pattern), re.IGNORECASE)
            pattern_str = pattern
        else:
            regex = pattern
            pattern_str = pattern.pattern

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            results = []

            for node in all_nodes:
                text = node.get("text", "")
                content_desc = node.get("contentDescription", "")
                hint = node.get("hint", "")

                for field_value in [text, content_desc, hint]:
                    if not field_value:
                        continue

                    # Exact match
                    if pattern_str == field_value:
                        results.append(node)
                        break

                    # Regex match
                    if regex.search(field_value):
                        results.append(node)
                        break

                    # Newline-normalized match
                    normalized = field_value.replace("\n", " ")
                    if pattern_str == normalized or regex.search(normalized):
                        results.append(node)
                        break

            return results

        return filter_fn

    @staticmethod
    def id_matches(pattern: str | re.Pattern) -> ElementFilter:
        """Match elements by resource ID (full or short form)."""
        if isinstance(pattern, str):
            regex = re.compile(re.escape(pattern), re.IGNORECASE)
            pattern_str = pattern
        else:
            regex = pattern
            pattern_str = pattern.pattern

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            results = []

            for node in all_nodes:
                resource_id = node.get("resourceId", "")

                if not resource_id:
                    continue

                short_id = (
                    resource_id.split("/")[-1] if "/" in resource_id else resource_id
                )

                # Check full ID
                if pattern_str == resource_id or regex.search(resource_id):
                    results.append(node)
                    continue

                # Check short ID
                if pattern_str == short_id or regex.search(short_id):
                    results.append(node)

            return results

        return filter_fn

    # ========== SPATIAL FILTERS ==========

    @staticmethod
    def below(anchor_filter: ElementFilter) -> ElementFilter:
        """Find elements positioned below the anchor element."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            anchor_results = anchor_filter(nodes)

            if not anchor_results:
                return []

            anchor = anchor_results[0]
            anchor_bounds = anchor.get("boundsInScreen", {})
            anchor_bottom = anchor_bounds.get("bottom", 0)
            anchor_center_x, anchor_center_y = get_element_center(anchor)

            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            candidates = []
            for node in all_nodes:
                if node == anchor:
                    continue

                node_bounds = node.get("boundsInScreen", {})
                node_top = node_bounds.get("top", 0)

                if node_top > anchor_bottom:
                    node_center_x, node_center_y = get_element_center(node)
                    distance = (
                        (node_center_x - anchor_center_x) ** 2
                        + (node_center_y - anchor_center_y) ** 2
                    ) ** 0.5
                    candidates.append((distance, node))

            candidates.sort(key=lambda x: x[0])
            return [node for dist, node in candidates]

        return filter_fn

    @staticmethod
    def above(anchor_filter: ElementFilter) -> ElementFilter:
        """Find elements positioned above the anchor element."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            anchor_results = anchor_filter(nodes)

            if not anchor_results:
                return []

            anchor = anchor_results[0]
            anchor_bounds = anchor.get("boundsInScreen", {})
            anchor_top = anchor_bounds.get("top", 0)
            anchor_center_x, anchor_center_y = get_element_center(anchor)

            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            candidates = []
            for node in all_nodes:
                if node == anchor:
                    continue

                node_bounds = node.get("boundsInScreen", {})
                node_bottom = node_bounds.get("bottom", 0)

                if node_bottom < anchor_top:
                    node_center_x, node_center_y = get_element_center(node)
                    distance = (
                        (node_center_x - anchor_center_x) ** 2
                        + (node_center_y - anchor_center_y) ** 2
                    ) ** 0.5
                    candidates.append((distance, node))

            candidates.sort(key=lambda x: x[0])
            return [node for dist, node in candidates]

        return filter_fn

    @staticmethod
    def left_of(anchor_filter: ElementFilter) -> ElementFilter:
        """Find elements positioned left of the anchor element."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            anchor_results = anchor_filter(nodes)

            if not anchor_results:
                return []

            anchor = anchor_results[0]
            anchor_bounds = anchor.get("boundsInScreen", {})
            anchor_left = anchor_bounds.get("left", 0)
            anchor_center_x, anchor_center_y = get_element_center(anchor)

            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            candidates = []
            for node in all_nodes:
                if node == anchor:
                    continue

                node_bounds = node.get("boundsInScreen", {})
                node_right = node_bounds.get("right", 0)

                if node_right < anchor_left:
                    node_center_x, node_center_y = get_element_center(node)
                    distance = (
                        (node_center_x - anchor_center_x) ** 2
                        + (node_center_y - anchor_center_y) ** 2
                    ) ** 0.5
                    candidates.append((distance, node))

            candidates.sort(key=lambda x: x[0])
            return [node for dist, node in candidates]

        return filter_fn

    @staticmethod
    def right_of(anchor_filter: ElementFilter) -> ElementFilter:
        """Find elements positioned right of the anchor element."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            anchor_results = anchor_filter(nodes)

            if not anchor_results:
                return []

            anchor = anchor_results[0]
            anchor_bounds = anchor.get("boundsInScreen", {})
            anchor_right = anchor_bounds.get("right", 0)
            anchor_center_x, anchor_center_y = get_element_center(anchor)

            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            candidates = []
            for node in all_nodes:
                if node == anchor:
                    continue

                node_bounds = node.get("boundsInScreen", {})
                node_left = node_bounds.get("left", 0)

                if node_left > anchor_right:
                    node_center_x, node_center_y = get_element_center(node)
                    distance = (
                        (node_center_x - anchor_center_x) ** 2
                        + (node_center_y - anchor_center_y) ** 2
                    ) ** 0.5
                    candidates.append((distance, node))

            candidates.sort(key=lambda x: x[0])
            return [node for dist, node in candidates]

        return filter_fn

    # ========== TRAIT FILTERS ==========

    @staticmethod
    def clickable() -> ElementFilter:
        """Match clickable elements."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            return [node for node in all_nodes if node.get("isClickable", False)]

        return filter_fn

    @staticmethod
    def non_clickable() -> ElementFilter:
        """Match non-clickable elements."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            return [node for node in all_nodes if not node.get("isClickable", False)]

        return filter_fn

    @staticmethod
    def enabled(expected: bool = True) -> ElementFilter:
        """Match elements by enabled state."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            return [
                node for node in all_nodes if node.get("isEnabled", False) == expected
            ]

        return filter_fn

    @staticmethod
    def selected(expected: bool = True) -> ElementFilter:
        """Match elements by selected state."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            return [
                node for node in all_nodes if node.get("isSelected", False) == expected
            ]

        return filter_fn

    @staticmethod
    def checked(expected: bool = True) -> ElementFilter:
        """Match elements by checked state."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            return [
                node for node in all_nodes if node.get("isChecked", False) == expected
            ]

        return filter_fn

    @staticmethod
    def focused(expected: bool = True) -> ElementFilter:
        """Match elements by focused state."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            return [
                node for node in all_nodes if node.get("isFocused", False) == expected
            ]

        return filter_fn

    # ========== SIZE MATCHING ==========

    @staticmethod
    def size_matches(
        width: int = None, height: int = None, tolerance: int = 0
    ) -> ElementFilter:
        """Match elements by size (width and/or height with tolerance)."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            results = []
            for node in all_nodes:
                bounds = node.get("boundsInScreen", {})

                actual_width = bounds.get("right", 0) - bounds.get("left", 0)
                actual_height = bounds.get("bottom", 0) - bounds.get("top", 0)

                if width is not None:
                    if abs(actual_width - width) > tolerance:
                        continue

                if height is not None:
                    if abs(actual_height - height) > tolerance:
                        continue

                results.append(node)

            return results

        return filter_fn

    # ========== HIERARCHY FILTERS ==========

    @staticmethod
    def contains_child(child_filter: ElementFilter) -> ElementFilter:
        """Match elements that contain at least one direct child matching the filter."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            results = []

            for node in all_nodes:
                children = node.get("children", [])

                if not children:
                    continue

                matching_children = child_filter(children)

                if matching_children:
                    results.append(node)

            return results

        return filter_fn

    @staticmethod
    def contains_descendants(filters: List[ElementFilter]) -> ElementFilter:
        """Match elements that contain ALL specified descendants at any depth."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            results = []

            for node in all_nodes:
                descendants = flatten_tree(node)

                all_match = True

                for descendant_filter in filters:
                    matches = descendant_filter(descendants)

                    if not matches:
                        all_match = False
                        break

                if all_match:
                    results.append(node)

            return results

        return filter_fn

    @staticmethod
    def child_of(parent_filter: ElementFilter) -> ElementFilter:
        """Match elements that are direct children of elements matching the parent filter."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            parents = parent_filter(nodes)

            if not parents:
                return []

            results = []
            for parent in parents:
                results.extend(parent.get("children", []))

            return results

        return filter_fn

    # ========== UTILITY FILTERS ==========

    @staticmethod
    def has_text() -> ElementFilter:
        """Match elements that have non-empty text content."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            return [
                node
                for node in all_nodes
                if (
                    node.get("text")
                    or node.get("contentDescription")
                    or node.get("hint")
                )
            ]

        return filter_fn

    @staticmethod
    def clickable_first() -> ElementFilter:
        """Sort elements to put clickable ones first."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            return sorted(all_nodes, key=lambda n: not n.get("isClickable", False))

        return filter_fn

    # ========== INDEX SELECTION ==========

    @staticmethod
    def index(idx: int) -> ElementFilter:
        """Select element at index position (supports negative indices)."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            sorted_nodes = sort_by_position(all_nodes)

            try:
                return [sorted_nodes[idx]]
            except IndexError:
                return []

        return filter_fn

    # ========== COMPOSITION ==========

    @staticmethod
    def compose(filters: List[ElementFilter]) -> ElementFilter:
        """Apply filters sequentially (pipeline)."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            result = nodes

            for f in filters:
                result = f(result)

                if not result:
                    break

            return result

        return filter_fn

    @staticmethod
    def intersect(filters: List[ElementFilter]) -> ElementFilter:
        """Return elements matching ALL filters (AND logic)."""

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            if not filters:
                return nodes

            result_sets = [set(id(n) for n in filters[0](nodes))]

            for f in filters[1:]:
                result_ids = set(id(n) for n in f(nodes))
                result_sets.append(result_ids)

            common_ids = result_sets[0].intersection(*result_sets[1:])

            all_nodes = []
            for node in nodes:
                all_nodes.extend(flatten_tree(node))

            return [n for n in all_nodes if id(n) in common_ids]

        return filter_fn

    # ========== DEEPEST MATCHING ==========

    @staticmethod
    def deepest_matching(base_filter: ElementFilter) -> ElementFilter:
        """Find the deepest (most specific) matching elements in the tree."""

        def find_deepest_in_node(node: Dict) -> List[Dict]:
            child_matches = []
            for child in node.get("children", []):
                child_matches.extend(find_deepest_in_node(child))

            if child_matches:
                return child_matches

            current_matches = base_filter([node])
            if current_matches:
                return [node]

            return []

        def filter_fn(nodes: List[Dict]) -> List[Dict]:
            results = []

            for node in nodes:
                results.extend(find_deepest_in_node(node))

            return results

        return filter_fn

```

`droidrun/tools/helpers/geometry.py`:

```py
"""Geometry utilities for UI element bounds and tap point calculation."""

from typing import List, Tuple, Optional

Bounds = Tuple[int, int, int, int]


def rects_overlap(a: Bounds, b: Bounds) -> bool:
    """Check if two rectangles overlap."""
    return not (a[2] <= b[0] or b[2] <= a[0] or a[3] <= b[1] or b[3] <= a[1])


def find_clear_point(
    bounds: Bounds,
    blockers: List[Bounds],
    depth: int = 0,
) -> Optional[Tuple[int, int]]:
    """Find a clear point in bounds using quadrant subdivision."""
    left, top, right, bottom = bounds
    cx, cy = (left + right) // 2, (top + bottom) // 2

    blocked = any(b[0] <= cx < b[2] and b[1] <= cy < b[3] for b in blockers)

    if not blocked:
        return cx, cy

    if depth > 4 or (right - left) * (bottom - top) < 100:
        return None

    quadrants = [
        (left, top, cx, cy),
        (cx, top, right, cy),
        (left, cy, cx, bottom),
        (cx, cy, right, bottom),
    ]

    best_point = None
    best_area = 0

    for q in quadrants:
        q_area = (q[2] - q[0]) * (q[3] - q[1])
        if q_area <= 0:
            continue
        point = find_clear_point(q, blockers, depth + 1)
        if point and q_area > best_area:
            best_point = point
            best_area = q_area

    return best_point

```

`droidrun/tools/ios/__init__.py`:

```py
"""iOS tools."""

from droidrun.tools.driver.ios import IOSDriver

__all__ = ["IOSDriver"]

```

`droidrun/tools/ui/__init__.py`:

```py
"""UI state and provider abstractions for DroidRun."""

from droidrun.tools.ui.ios_provider import IOSStateProvider
from droidrun.tools.ui.provider import AndroidStateProvider, StateProvider
from droidrun.tools.ui.state import UIState
from droidrun.tools.ui.stealth_state import StealthUIState

__all__ = [
    "UIState",
    "StealthUIState",
    "StateProvider",
    "AndroidStateProvider",
    "IOSStateProvider",
]

```

`droidrun/tools/ui/ios_provider.py`:

```py
"""IOSStateProvider ‚Äî builds UIState from iOS portal accessibility data.

Parses the raw text-based accessibility tree returned by the iOS portal
into structured elements compatible with UIState.

Known limitations (pre-existing, documented as TODOs):
- Screen dimensions inferred from element bounds with hardcoded fallback
- ``focused_text`` always empty (iOS portal doesn't expose it)
- Normalized coordinates untested on iOS
- No filter/formatter pipeline (iOS a11y tree is raw text, not structured JSON)
"""

from __future__ import annotations

import logging
import re
from typing import Any, Dict, List, Tuple

from droidrun.tools.driver.base import DeviceDriver
from droidrun.tools.ui.provider import StateProvider
from droidrun.tools.ui.state import UIState

logger = logging.getLogger("droidrun")

# Element types considered interactive on iOS.
_INTERACTIVE_TYPES = {
    "Button",
    "SearchField",
    "TextField",
    "Cell",
    "Switch",
    "Slider",
    "Stepper",
    "Picker",
    "Link",
}

_COORD_RE = re.compile(r"\{\{([0-9.]+),\s*([0-9.]+)\},\s*\{([0-9.]+),\s*([0-9.]+)\}\}")
_ELEMENT_TYPE_RE = re.compile(r"\s*(.+?),")
_LABEL_RE = re.compile(r"label:\s*'([^']*)'")
_IDENTIFIER_RE = re.compile(r"identifier:\s*'([^']*)'")
_PLACEHOLDER_RE = re.compile(r"placeholderValue:\s*'([^']*)'")
_VALUE_RE = re.compile(r"value:\s*([^,}]+)")


class IOSStateProvider(StateProvider):
    """Produces ``UIState`` from an iOS device's accessibility tree."""

    supported = {"element_index", "convert_point"}

    def __init__(self, driver: DeviceDriver, use_normalized: bool = False) -> None:
        super().__init__(driver)
        # TODO: normalized coordinates untested on iOS
        self.use_normalized = use_normalized

    async def get_state(self) -> UIState:
        raw = await self.driver.get_ui_tree()
        a11y_text = raw.get("a11y_raw", "")
        phone_state = raw.get("phone_state", {})

        elements = _parse_a11y_tree(a11y_text)
        screen_width, screen_height = _infer_screen_size(elements)
        formatted_text = _format_elements(elements, screen_width, screen_height)

        return UIState(
            elements=elements,
            formatted_text=formatted_text,
            focused_text="",  # TODO: iOS doesn't expose focused element text
            phone_state=phone_state,
            screen_width=screen_width,
            screen_height=screen_height,
            use_normalized=self.use_normalized,
        )


# ---------------------------------------------------------------------------
# Parsing
# ---------------------------------------------------------------------------


def _parse_a11y_tree(a11y_text: str) -> List[Dict[str, Any]]:
    """Parse iOS accessibility tree text into structured elements.

    Moved verbatim from ``IOSTools._parse_ios_accessibility_tree``.
    """
    elements: List[Dict[str, Any]] = []
    element_index = 0

    for line in a11y_text.strip().split("\n"):
        stripped = line.strip()
        if (
            not stripped
            or stripped.startswith("Attributes:")
            or stripped.startswith("Element subtree:")
            or stripped.startswith("Path to element:")
            or stripped.startswith("Query chain:")
        ):
            continue

        coord_match = _COORD_RE.search(line)
        if not coord_match:
            continue

        x, y, width, height = map(float, coord_match.groups())

        # Element type
        type_match = _ELEMENT_TYPE_RE.match(line)
        element_type = type_match.group(1).strip() if type_match else "Unknown"
        element_type = re.sub(r"^[‚Üí\s]+", "", element_type)

        # Only keep interactive elements
        if not any(it in element_type for it in _INTERACTIVE_TYPES):
            continue

        # Extract properties
        label_m = _LABEL_RE.search(line)
        label = label_m.group(1) if label_m else ""
        ident_m = _IDENTIFIER_RE.search(line)
        identifier = ident_m.group(1) if ident_m else ""
        ph_m = _PLACEHOLDER_RE.search(line)
        placeholder = ph_m.group(1) if ph_m else ""
        val_m = _VALUE_RE.search(line)
        value = val_m.group(1).strip() if val_m else ""

        text = label or identifier or placeholder or ""

        # Bounds in "left,top,right,bottom" format ‚Äî compatible with UIState
        bounds_str = f"{int(x)},{int(y)},{int(x + width)},{int(y + height)}"

        elements.append(
            {
                "index": element_index,
                "type": element_type,
                "className": element_type,
                "text": text,
                "label": label,
                "identifier": identifier,
                "placeholder": placeholder,
                "value": value,
                "bounds": bounds_str,
                "rect": f"{x},{y},{width},{height}",
                "children": [],
            }
        )
        element_index += 1

    return elements


# ---------------------------------------------------------------------------
# Screen size inference
# ---------------------------------------------------------------------------


def _infer_screen_size(
    elements: List[Dict[str, Any]],
) -> Tuple[int, int]:
    """Best-effort screen dimensions from element bounds.

    Falls back to iPhone 14 dimensions if no elements are available.
    """
    max_right = 0
    max_bottom = 0
    for el in elements:
        bounds = el.get("bounds", "")
        if not bounds:
            continue
        parts = bounds.split(",")
        if len(parts) == 4:
            max_right = max(max_right, int(float(parts[2])))
            max_bottom = max(max_bottom, int(float(parts[3])))
    if max_right > 0 and max_bottom > 0:
        return max_right, max_bottom
    # TODO: hardcoded iPhone 14 fallback ‚Äî no portal endpoint for screen size
    return 390, 844


# ---------------------------------------------------------------------------
# Formatting for agent prompt
# ---------------------------------------------------------------------------


def _format_elements(
    elements: List[Dict[str, Any]],
    screen_width: int,
    screen_height: int,
) -> str:
    """Build the text representation shown to the agent."""
    schema = "'index. className: text - bounds(x1,y1,x2,y2)'"
    if not elements:
        return f"Current Clickable UI elements:\n{schema}:\nNo UI elements found"

    lines = [f"Current Clickable UI elements:\n{schema}:"]
    for el in elements:
        idx = el.get("index", 0)
        cls = el.get("className", "Unknown")
        text = el.get("text", "")
        bounds = el.get("bounds", "")

        parts = [f"{idx}. {cls}:"]
        if text:
            parts.append(text)
        if bounds:
            parts.append(f"- ({bounds})")
        lines.append(" ".join(parts))

    return "\n".join(lines)

```

`droidrun/tools/ui/provider.py`:

```py
"""StateProvider ‚Äî orchestrates fetching and parsing device state.

Fetches raw data from a ``DeviceDriver``, applies tree filters/formatters,
and produces a ``UIState`` snapshot.
"""

from __future__ import annotations

import asyncio
import logging
from typing import TYPE_CHECKING

from droidrun.tools.driver.base import DeviceDisconnectedError
from droidrun.tools.ui.state import UIState
from droidrun.tools.ui.stealth_state import StealthUIState

if TYPE_CHECKING:
    from droidrun.tools.driver.base import DeviceDriver
    from droidrun.tools.filters import TreeFilter
    from droidrun.tools.formatters import TreeFormatter

logger = logging.getLogger("droidrun")


class StateProvider:
    """Base class ‚Äî subclass to support different platforms."""

    supported: set[str] = set()

    def __init__(self, driver: "DeviceDriver") -> None:
        self.driver = driver

    async def get_state(self) -> UIState:
        raise NotImplementedError


class AndroidStateProvider(StateProvider):
    """Fetches state from an Android device via ``driver.get_ui_tree()``.

    Includes retry logic (3 attempts) matching the original
    ``AdbTools.get_state()`` behaviour.
    """

    supported = {"element_index", "convert_point"}

    def __init__(
        self,
        driver: "DeviceDriver",
        tree_filter: "TreeFilter",
        tree_formatter: "TreeFormatter",
        use_normalized: bool = False,
        stealth: bool = False,
        ui_cls: "type[UIState] | None" = None,
    ) -> None:
        super().__init__(driver)
        self.tree_filter = tree_filter
        self.tree_formatter = tree_formatter
        self.use_normalized = use_normalized
        self._ui_cls = ui_cls or (StealthUIState if stealth else UIState)

    async def get_state(self) -> UIState:
        max_retries = 3
        last_error = None

        for attempt in range(max_retries):
            try:
                logger.debug(f"Getting state (attempt {attempt + 1}/{max_retries})")

                combined_data = await self.driver.get_ui_tree()

                if "error" in combined_data:
                    raise Exception(
                        f"Portal returned error: "
                        f"{combined_data.get('message', 'Unknown error')}"
                    )

                required_keys = ["a11y_tree", "phone_state", "device_context"]
                missing = [k for k in required_keys if k not in combined_data]
                if missing:
                    raise Exception(f"Missing data in state: {', '.join(missing)}")

                device_context = combined_data["device_context"]
                screen_bounds = device_context.get("screen_bounds", {})
                screen_width = screen_bounds.get("width")
                screen_height = screen_bounds.get("height")

                filtered = self.tree_filter.filter(
                    combined_data["a11y_tree"], device_context
                )

                self.tree_formatter.screen_width = screen_width
                self.tree_formatter.screen_height = screen_height
                self.tree_formatter.use_normalized = self.use_normalized

                formatted_text, focused_text, elements, phone_state = (
                    self.tree_formatter.format(filtered, combined_data["phone_state"])
                )

                return self._ui_cls(
                    elements=elements,
                    formatted_text=formatted_text,
                    focused_text=focused_text,
                    phone_state=phone_state,
                    screen_width=screen_width,
                    screen_height=screen_height,
                    use_normalized=self.use_normalized,
                )

            except DeviceDisconnectedError:
                raise
            except Exception as e:
                last_error = e
                logger.warning(f"get_state attempt {attempt + 1} failed: {e}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(0.5)
                else:
                    error_msg = (
                        f"Failed to get state after {max_retries} "
                        f"attempts: {last_error}"
                    )
                    logger.error(error_msg)
                    raise Exception(error_msg) from last_error

```

`droidrun/tools/ui/state.py`:

```py
"""UIState ‚Äî parsed UI elements with element resolution and coordinate conversion.

Replaces ``clickable_elements_cache``, ``_extract_element_coordinates_by_index``,
and the scattered ``find_element_by_index`` local functions from ``adb.py``.
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from droidrun.tools.helpers.coordinate import to_absolute
from droidrun.tools.helpers.geometry import find_clear_point, rects_overlap


class UIState:
    """Holds parsed UI elements for a single device state snapshot."""

    def __init__(
        self,
        elements: List[Dict[str, Any]],
        formatted_text: str,
        focused_text: str,
        phone_state: Dict[str, Any],
        screen_width: int,
        screen_height: int,
        use_normalized: bool = False,
    ) -> None:
        self.elements = elements
        self.formatted_text = formatted_text
        self.focused_text = focused_text
        self.phone_state = phone_state
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.use_normalized = use_normalized

    # -- element lookup ------------------------------------------------------

    def get_element(self, index: int) -> Optional[Dict[str, Any]]:
        """Recursively find an element by its index."""
        return self._find_by_index(self.elements, index)

    def get_element_coords(self, index: int) -> Tuple[int, int]:
        """Return the centre (x, y) of element *index*.

        Raises ``ValueError`` when the element is missing or has no bounds.
        """
        element = self._find_by_index(self.elements, index)

        if element is None:
            indices = sorted(self._collect_indices(self.elements))
            indices_str = ", ".join(str(i) for i in indices[:20])
            if len(indices) > 20:
                indices_str += f"... and {len(indices) - 20} more"
            raise ValueError(
                f"No element found with index {index}. "
                f"Available indices: {indices_str}"
            )

        bounds_str = element.get("bounds")
        if not bounds_str:
            text = element.get("text", "No text")
            cls = element.get("className", "Unknown class")
            etype = element.get("type", "unknown")
            raise ValueError(
                f"Element with index {index} ('{text}', {cls}, type: {etype}) "
                f"has no bounds and cannot be tapped"
            )

        try:
            left, top, right, bottom = map(int, bounds_str.split(","))
        except ValueError as e:
            raise ValueError(
                f"Invalid bounds format for element with index {index}: "
                f"{bounds_str}"
            ) from e

        return (left + right) // 2, (top + bottom) // 2

    def get_element_info(self, index: int) -> Dict[str, Any]:
        """Return a dict with common element fields for display."""
        element = self.get_element(index)
        if element is None:
            return {}

        info: Dict[str, Any] = {
            "text": element.get("text", "No text"),
            "className": element.get("className", "Unknown class"),
            "type": element.get("type", "unknown"),
        }

        children = element.get("children", [])
        if children:
            child_texts = [c.get("text") for c in children if c.get("text")]
            if child_texts:
                info["child_texts"] = child_texts

        return info

    def get_clear_point(self, index: int) -> Tuple[int, int]:
        """Find a tap point for *index* that avoids overlapping elements.

        Falls back to the centre if no clear point exists.
        """
        element = self._find_by_index(self.elements, index)
        if element is None:
            raise ValueError(f"No element found with index {index}")

        bounds_str = element.get("bounds")
        if not bounds_str:
            raise ValueError(f"Element {index} has no bounds")

        target_bounds = tuple(map(int, bounds_str.split(",")))

        all_elements = self._collect_all(self.elements)
        blockers = []
        for el in all_elements:
            el_idx = el.get("index")
            el_bounds_str = el.get("bounds")
            if el_idx is not None and el_idx > index and el_bounds_str:
                el_bounds = tuple(map(int, el_bounds_str.split(",")))
                if rects_overlap(target_bounds, el_bounds):
                    blockers.append(el_bounds)

        point = find_clear_point(target_bounds, blockers)
        if point is None:
            raise ValueError(
                f"Element {index} is fully obscured by overlapping elements"
            )
        return point

    def convert_point(self, x: int, y: int) -> Tuple[int, int]:
        """Convert point to absolute pixels if normalized mode is active."""
        if self.use_normalized:
            return to_absolute(x, y, self.screen_width, self.screen_height)
        return x, y

    # -- internal helpers ----------------------------------------------------

    @staticmethod
    def _find_by_index(
        elements: List[Dict[str, Any]], target: int
    ) -> Optional[Dict[str, Any]]:
        for item in elements:
            if item.get("index") == target:
                return item
            child = UIState._find_by_index(item.get("children", []), target)
            if child is not None:
                return child
        return None

    @staticmethod
    def _collect_indices(elements: List[Dict[str, Any]]) -> List[int]:
        indices: List[int] = []
        for item in elements:
            if item.get("index") is not None:
                indices.append(item["index"])
            indices.extend(UIState._collect_indices(item.get("children", [])))
        return indices

    @staticmethod
    def _collect_all(
        elements: List[Dict[str, Any]],
    ) -> List[Dict[str, Any]]:
        result: List[Dict[str, Any]] = []
        for item in elements:
            result.append(item)
            result.extend(UIState._collect_all(item.get("children", [])))
        return result

```

`droidrun/tools/ui/stealth_state.py`:

```py
"""StealthUIState ‚Äî randomized coordinate resolution for human-like taps.

Overrides ``UIState.get_element_coords()`` and ``get_clear_point()``
to return randomized positions within element bounds, avoiding the
predictable dead-center taps that betray automation.
"""

from __future__ import annotations

import random
from typing import Tuple

from droidrun.tools.ui.state import UIState


class StealthUIState(UIState):
    """UIState variant that randomizes tap coordinates within element bounds."""

    def get_element_coords(self, index: int) -> Tuple[int, int]:
        """Return a randomized point within the safe zone of element *index*.

        The safe zone is the inner 40% of the element (20% inset from each
        edge), ensuring taps land clearly inside the element.

        Raises ``ValueError`` when the element is missing or has no bounds.
        """
        element = self._find_by_index(self.elements, index)

        if element is None:
            indices = sorted(self._collect_indices(self.elements))
            indices_str = ", ".join(str(i) for i in indices[:20])
            if len(indices) > 20:
                indices_str += f"... and {len(indices) - 20} more"
            raise ValueError(
                f"No element found with index {index}. "
                f"Available indices: {indices_str}"
            )

        bounds_str = element.get("bounds")
        if not bounds_str:
            text = element.get("text", "No text")
            cls = element.get("className", "Unknown class")
            etype = element.get("type", "unknown")
            raise ValueError(
                f"Element with index {index} ('{text}', {cls}, type: {etype}) "
                f"has no bounds and cannot be tapped"
            )

        try:
            left, top, right, bottom = map(int, bounds_str.split(","))
        except ValueError as e:
            raise ValueError(
                f"Invalid bounds format for element with index {index}: "
                f"{bounds_str}"
            ) from e

        center_x = (left + right) // 2
        center_y = (top + bottom) // 2

        width = right - left
        height = bottom - top

        # Safe zone: inner 40% (20% inset from each edge)
        safe_zone = 0.4
        x_range = max(5, int(width * safe_zone))
        y_range = max(5, int(height * safe_zone))

        x = center_x + random.randint(-x_range // 2, x_range // 2)
        y = center_y + random.randint(-y_range // 2, y_range // 2)

        # Clamp to stay within bounds
        x = max(left + 2, min(x, right - 2))
        y = max(top + 2, min(y, bottom - 2))

        return x, y

    def get_clear_point(self, index: int) -> Tuple[int, int]:
        """Find a clear tap point for *index*, then randomize around it.

        Uses the parent overlap-avoidance logic, then adds jitter within
        a 20% radius of the element dimensions.
        """
        # Get the overlap-free center from parent
        cx, cy = super().get_clear_point(index)

        element = self._find_by_index(self.elements, index)
        bounds_str = element.get("bounds", "")
        if not bounds_str:
            return cx, cy

        left, top, right, bottom = map(int, bounds_str.split(","))
        width = right - left
        height = bottom - top

        x_range = max(5, int(width * 0.2))
        y_range = max(5, int(height * 0.2))

        x = cx + random.randint(-x_range // 2, x_range // 2)
        y = cy + random.randint(-y_range // 2, y_range // 2)

        x = max(left + 2, min(x, right - 2))
        y = max(top + 2, min(y, bottom - 2))

        return x, y

```

`gen-docs-sdk-ref.sh`:

```sh
#!/bin/bash

# Generate documentation for the SDK reference

pydoc-markdown

# rename .md to .mdx
# Rename all .md files to .mdx in the docs/v3/sdk directory
find docs/v5/sdk -name "*.md" -exec sh -c 'mv "$1" "${1%.md}.mdx"' _ {} \;

# update docs/v3/.generated-files.txt with the new files extension
# Set sed in-place flag for macOS and Linux compatibility
if [[ "$(uname)" == "Darwin" ]]; then
  SED_INPLACE=(-i '')
else
  SED_INPLACE=(-i)
fi

sed "${SED_INPLACE[@]}" 's/\.md/.mdx/g' docs/.generated-files.txt

```

`pyproject.toml`:

```toml
[project]
name = "droidrun"
version = "0.5.0.dev6"
description = "A framework for controlling Android devices through LLM agents"
authors = [{ name = "Niels Schmidt", email = "niels.schmidt@droidrun.ai" }]
dependencies = [
    "async_adbutils",
    "llama-index==0.14.4",
    "posthog>=6.7.6",
    "pydantic>=2.11.10",
    "rich>=14.1.0",
    "arize-phoenix>=12.3.0",
    "httpx>=0.27.0",
    "llama-index-callbacks-arize-phoenix>=0.6.1",
    "llama-index-workflows==2.8.3",
    "aiofiles>=25.1.0",
    "textual>=6.11.0",
    "mcp>=1.26.0",
    "python-dotenv>=1.2.1",
    "llama-index-llms-openai>=0.5.6",
    "llama-index-llms-openai-like>=0.5.1",
    "llama-index-llms-google-genai>=0.8.5",
    "llama-index-llms-ollama>=0.7.2",
    "llama-index-llms-openrouter>=0.4.2",
    "mobilerun-sdk",
]
requires-python = ">=3.11,<3.14"
readme = "README.md"
license = { text = "MIT" }
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "Intended Audience :: Information Technology",
    "Intended Audience :: Science/Research",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Topic :: Software Development :: Testing",
    "Topic :: Scientific/Engineering :: Artificial Intelligence",
    "Topic :: Software Development :: Libraries :: Application Frameworks",
    "Topic :: Communications :: Chat",
    "Topic :: Software Development :: Testing :: Acceptance",
    "Topic :: Software Development :: Quality Assurance",
    "Topic :: System :: Emulators",
    "Topic :: Utilities",
]

[project.urls]
Homepage = "https://github.com/droidrun/droidrun"
"Bug Tracker" = "https://github.com/droidrun/droidrun/issues"
Documentation = "https://docs.droidrun.ai/"

[project.optional-dependencies]
anthropic = [
    "anthropic>=0.67.0",
    "llama-index-llms-anthropic>=0.8.6,<0.9.0",
]
deepseek = [
    "llama-index-llms-deepseek>=0.2.1",
]
dev = [
    "black==25.9.0",
    "ruff>=0.13.0",
    "mypy>=1.0.0",
    "bandit>=1.8.6",
    "safety>=3.2.11",
    "droidrun[langfuse]",
]
langfuse = [
    "langfuse==3.12.1",
    "openinference-instrumentation-llama-index>=3.0.0",
    "llama-index-instrumentation"
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.metadata]
allow-direct-references = true

[tool.hatch.build.targets.wheel]
packages = ["droidrun"]

[project.scripts]
droidrun = "droidrun.cli.main:cli"

[tool.ruff]
line-length = 100
target-version = "py313"

[tool.ruff.lint]
select = [
    "E", # pycodestyle errors
    "W", # pycodestyle warnings
    "F", # pyflakes
    "I", # isort
    "B", # flake8-bugbear
]
ignore = ["E501"]

[[tool.pydoc-markdown.loaders]]
type = "python"
packages = ["droidrun"]
modules = ["droidrun"]

[[tool.pydoc-markdown.processors]]
type = "filter"
documented_only = false
do_not_filter_modules = true
skip_empty_modules = true

[[tool.pydoc-markdown.processors]]
type = "smart"

[[tool.pydoc-markdown.processors]]
type = "crossref"

[tool.pydoc-markdown.renderer]
type = "hugo"
build_directory = "docs"
content_directory = "v4/sdk"
clean_render = true


[tool.pydoc-markdown.renderer.markdown]
classdef_with_decorators = false
signature_with_decorators = false
data_code_block = true
descriptive_class_title = false
render_module_header = false
format_code_style = "facebook"
add_module_prefix = false
add_method_class_prefix = true

header_level_by_type = { Module = 1, Class = 2, Method = 4, Function = 4, Variable = 4 }


[[tool.pydoc-markdown.renderer.pages]]
title = "DroidAgent"
name = "droid-agent"
contents = [
    "droidrun.agent.droid.droid_agent.DroidAgent",
    "droidrun.agent.droid.droid_agent.DroidAgent.__init__",
    "droidrun.agent.droid.droid_agent.DroidAgent.run",
]

[[tool.pydoc-markdown.renderer.pages]]
title = "Tools"
name = "base-tools"
contents = [
    "droidrun.tools.tools.Tools.*",
    "droidrun.tools.tools.describe_tools",
]

[[tool.pydoc-markdown.renderer.pages]]
title = "AdbTools"
name = "adb-tools"
contents = ["droidrun.tools.adb.AdbTools.*"]

[[tool.pydoc-markdown.renderer.pages]]
title = "IOSTools"
name = "ios-tools"
contents = ["droidrun.tools.ios.IOSTools.*"]

[[tool.pydoc-markdown.renderer.pages]]
title = "CloudTools"
name = "cloud-tools"
contents = ["droidrun.tools.cloud.MobileRunTools.*"]

[dependency-groups]
dev = [
    "arize-phoenix>=11.32.1",
    "bandit>=1.8.6",
    "llama-index-callbacks-arize-phoenix>=0.6.1",
    "ruff>=0.13.0",
    "safety>=3.2.11",
]

```

`setup.py`:

```py
"""
Setup file for backward compatibility.
Configuration is handled by pyproject.toml
"""

from setuptools import setup

setup()

```

`uv.lock`:

```lock
version = 1
revision = 3
requires-python = ">=3.11, <3.14"
resolution-markers = [
    "python_full_version >= '3.13' and sys_platform == 'win32'",
    "python_full_version == '3.12.*' and sys_platform == 'win32'",
    "python_full_version < '3.12' and sys_platform == 'win32'",
    "python_full_version >= '3.13' and sys_platform != 'win32'",
    "python_full_version == '3.12.*' and sys_platform != 'win32'",
    "python_full_version < '3.12' and sys_platform != 'win32'",
]

[[package]]
name = "aiofiles"
version = "25.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/41/c3/534eac40372d8ee36ef40df62ec129bee4fdb5ad9706e58a29be53b2c970/aiofiles-25.1.0.tar.gz", hash = "sha256:a8d728f0a29de45dc521f18f07297428d56992a742f0cd2701ba86e44d23d5b2", size = 46354, upload-time = "2025-10-09T20:51:04.358Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/bc/8a/340a1555ae33d7354dbca4faa54948d76d89a27ceef032c8c3bc661d003e/aiofiles-25.1.0-py3-none-any.whl", hash = "sha256:abe311e527c862958650f9438e859c1fa7568a141b22abcd015e120e86a85695", size = 14668, upload-time = "2025-10-09T20:51:03.174Z" },
]

[[package]]
name = "aiohappyeyeballs"
version = "2.6.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/26/30/f84a107a9c4331c14b2b586036f40965c128aa4fee4dda5d3d51cb14ad54/aiohappyeyeballs-2.6.1.tar.gz", hash = "sha256:c3f9d0113123803ccadfdf3f0faa505bc78e6a72d1cc4806cbd719826e943558", size = 22760, upload-time = "2025-03-12T01:42:48.764Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0f/15/5bf3b99495fb160b63f95972b81750f18f7f4e02ad051373b669d17d44f2/aiohappyeyeballs-2.6.1-py3-none-any.whl", hash = "sha256:f349ba8f4b75cb25c99c5c2d84e997e485204d2902a9597802b0371f09331fb8", size = 15265, upload-time = "2025-03-12T01:42:47.083Z" },
]

[[package]]
name = "aiohttp"
version = "3.13.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "aiohappyeyeballs" },
    { name = "aiosignal" },
    { name = "attrs" },
    { name = "frozenlist" },
    { name = "multidict" },
    { name = "propcache" },
    { name = "yarl" },
]
sdist = { url = "https://files.pythonhosted.org/packages/50/42/32cf8e7704ceb4481406eb87161349abb46a57fee3f008ba9cb610968646/aiohttp-3.13.3.tar.gz", hash = "sha256:a949eee43d3782f2daae4f4a2819b2cb9b0c5d3b7f7a927067cc84dafdbb9f88", size = 7844556, upload-time = "2026-01-03T17:33:05.204Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f1/4c/a164164834f03924d9a29dc3acd9e7ee58f95857e0b467f6d04298594ebb/aiohttp-3.13.3-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:5b6073099fb654e0a068ae678b10feff95c5cae95bbfcbfa7af669d361a8aa6b", size = 746051, upload-time = "2026-01-03T17:29:43.287Z" },
    { url = "https://files.pythonhosted.org/packages/82/71/d5c31390d18d4f58115037c432b7e0348c60f6f53b727cad33172144a112/aiohttp-3.13.3-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:1cb93e166e6c28716c8c6aeb5f99dfb6d5ccf482d29fe9bf9a794110e6d0ab64", size = 499234, upload-time = "2026-01-03T17:29:44.822Z" },
    { url = "https://files.pythonhosted.org/packages/0e/c9/741f8ac91e14b1d2e7100690425a5b2b919a87a5075406582991fb7de920/aiohttp-3.13.3-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:28e027cf2f6b641693a09f631759b4d9ce9165099d2b5d92af9bd4e197690eea", size = 494979, upload-time = "2026-01-03T17:29:46.405Z" },
    { url = "https://files.pythonhosted.org/packages/75/b5/31d4d2e802dfd59f74ed47eba48869c1c21552c586d5e81a9d0d5c2ad640/aiohttp-3.13.3-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:3b61b7169ababd7802f9568ed96142616a9118dd2be0d1866e920e77ec8fa92a", size = 1748297, upload-time = "2026-01-03T17:29:48.083Z" },
    { url = "https://files.pythonhosted.org/packages/1a/3e/eefad0ad42959f226bb79664826883f2687d602a9ae2941a18e0484a74d3/aiohttp-3.13.3-cp311-cp311-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:80dd4c21b0f6237676449c6baaa1039abae86b91636b6c91a7f8e61c87f89540", size = 1707172, upload-time = "2026-01-03T17:29:49.648Z" },
    { url = "https://files.pythonhosted.org/packages/c5/3a/54a64299fac2891c346cdcf2aa6803f994a2e4beeaf2e5a09dcc54acc842/aiohttp-3.13.3-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:65d2ccb7eabee90ce0503c17716fc77226be026dcc3e65cce859a30db715025b", size = 1805405, upload-time = "2026-01-03T17:29:51.244Z" },
    { url = "https://files.pythonhosted.org/packages/6c/70/ddc1b7169cf64075e864f64595a14b147a895a868394a48f6a8031979038/aiohttp-3.13.3-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:5b179331a481cb5529fca8b432d8d3c7001cb217513c94cd72d668d1248688a3", size = 1899449, upload-time = "2026-01-03T17:29:53.938Z" },
    { url = "https://files.pythonhosted.org/packages/a1/7e/6815aab7d3a56610891c76ef79095677b8b5be6646aaf00f69b221765021/aiohttp-3.13.3-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:9d4c940f02f49483b18b079d1c27ab948721852b281f8b015c058100e9421dd1", size = 1748444, upload-time = "2026-01-03T17:29:55.484Z" },
    { url = "https://files.pythonhosted.org/packages/6b/f2/073b145c4100da5511f457dc0f7558e99b2987cf72600d42b559db856fbc/aiohttp-3.13.3-cp311-cp311-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:f9444f105664c4ce47a2a7171a2418bce5b7bae45fb610f4e2c36045d85911d3", size = 1606038, upload-time = "2026-01-03T17:29:57.179Z" },
    { url = "https://files.pythonhosted.org/packages/0a/c1/778d011920cae03ae01424ec202c513dc69243cf2db303965615b81deeea/aiohttp-3.13.3-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:694976222c711d1d00ba131904beb60534f93966562f64440d0c9d41b8cdb440", size = 1724156, upload-time = "2026-01-03T17:29:58.914Z" },
    { url = "https://files.pythonhosted.org/packages/0e/cb/3419eabf4ec1e9ec6f242c32b689248365a1cf621891f6f0386632525494/aiohttp-3.13.3-cp311-cp311-musllinux_1_2_armv7l.whl", hash = "sha256:f33ed1a2bf1997a36661874b017f5c4b760f41266341af36febaf271d179f6d7", size = 1722340, upload-time = "2026-01-03T17:30:01.962Z" },
    { url = "https://files.pythonhosted.org/packages/7a/e5/76cf77bdbc435bf233c1f114edad39ed4177ccbfab7c329482b179cff4f4/aiohttp-3.13.3-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:e636b3c5f61da31a92bf0d91da83e58fdfa96f178ba682f11d24f31944cdd28c", size = 1783041, upload-time = "2026-01-03T17:30:03.609Z" },
    { url = "https://files.pythonhosted.org/packages/9d/d4/dd1ca234c794fd29c057ce8c0566b8ef7fd6a51069de5f06fa84b9a1971c/aiohttp-3.13.3-cp311-cp311-musllinux_1_2_riscv64.whl", hash = "sha256:5d2d94f1f5fcbe40838ac51a6ab5704a6f9ea42e72ceda48de5e6b898521da51", size = 1596024, upload-time = "2026-01-03T17:30:05.132Z" },
    { url = "https://files.pythonhosted.org/packages/55/58/4345b5f26661a6180afa686c473620c30a66afdf120ed3dd545bbc809e85/aiohttp-3.13.3-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:2be0e9ccf23e8a94f6f0650ce06042cefc6ac703d0d7ab6c7a917289f2539ad4", size = 1804590, upload-time = "2026-01-03T17:30:07.135Z" },
    { url = "https://files.pythonhosted.org/packages/7b/06/05950619af6c2df7e0a431d889ba2813c9f0129cec76f663e547a5ad56f2/aiohttp-3.13.3-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:9af5e68ee47d6534d36791bbe9b646d2a7c7deb6fc24d7943628edfbb3581f29", size = 1740355, upload-time = "2026-01-03T17:30:09.083Z" },
    { url = "https://files.pythonhosted.org/packages/3e/80/958f16de79ba0422d7c1e284b2abd0c84bc03394fbe631d0a39ffa10e1eb/aiohttp-3.13.3-cp311-cp311-win32.whl", hash = "sha256:a2212ad43c0833a873d0fb3c63fa1bacedd4cf6af2fee62bf4b739ceec3ab239", size = 433701, upload-time = "2026-01-03T17:30:10.869Z" },
    { url = "https://files.pythonhosted.org/packages/dc/f2/27cdf04c9851712d6c1b99df6821a6623c3c9e55956d4b1e318c337b5a48/aiohttp-3.13.3-cp311-cp311-win_amd64.whl", hash = "sha256:642f752c3eb117b105acbd87e2c143de710987e09860d674e068c4c2c441034f", size = 457678, upload-time = "2026-01-03T17:30:12.719Z" },
    { url = "https://files.pythonhosted.org/packages/a0/be/4fc11f202955a69e0db803a12a062b8379c970c7c84f4882b6da17337cc1/aiohttp-3.13.3-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:b903a4dfee7d347e2d87697d0713be59e0b87925be030c9178c5faa58ea58d5c", size = 739732, upload-time = "2026-01-03T17:30:14.23Z" },
    { url = "https://files.pythonhosted.org/packages/97/2c/621d5b851f94fa0bb7430d6089b3aa970a9d9b75196bc93bb624b0db237a/aiohttp-3.13.3-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:a45530014d7a1e09f4a55f4f43097ba0fd155089372e105e4bff4ca76cb1b168", size = 494293, upload-time = "2026-01-03T17:30:15.96Z" },
    { url = "https://files.pythonhosted.org/packages/5d/43/4be01406b78e1be8320bb8316dc9c42dbab553d281c40364e0f862d5661c/aiohttp-3.13.3-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:27234ef6d85c914f9efeb77ff616dbf4ad2380be0cda40b4db086ffc7ddd1b7d", size = 493533, upload-time = "2026-01-03T17:30:17.431Z" },
    { url = "https://files.pythonhosted.org/packages/8d/a8/5a35dc56a06a2c90d4742cbf35294396907027f80eea696637945a106f25/aiohttp-3.13.3-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:d32764c6c9aafb7fb55366a224756387cd50bfa720f32b88e0e6fa45b27dcf29", size = 1737839, upload-time = "2026-01-03T17:30:19.422Z" },
    { url = "https://files.pythonhosted.org/packages/bf/62/4b9eeb331da56530bf2e198a297e5303e1c1ebdceeb00fe9b568a65c5a0c/aiohttp-3.13.3-cp312-cp312-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:b1a6102b4d3ebc07dad44fbf07b45bb600300f15b552ddf1851b5390202ea2e3", size = 1703932, upload-time = "2026-01-03T17:30:21.756Z" },
    { url = "https://files.pythonhosted.org/packages/7c/f6/af16887b5d419e6a367095994c0b1332d154f647e7dc2bd50e61876e8e3d/aiohttp-3.13.3-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:c014c7ea7fb775dd015b2d3137378b7be0249a448a1612268b5a90c2d81de04d", size = 1771906, upload-time = "2026-01-03T17:30:23.932Z" },
    { url = "https://files.pythonhosted.org/packages/ce/83/397c634b1bcc24292fa1e0c7822800f9f6569e32934bdeef09dae7992dfb/aiohttp-3.13.3-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:2b8d8ddba8f95ba17582226f80e2de99c7a7948e66490ef8d947e272a93e9463", size = 1871020, upload-time = "2026-01-03T17:30:26Z" },
    { url = "https://files.pythonhosted.org/packages/86/f6/a62cbbf13f0ac80a70f71b1672feba90fdb21fd7abd8dbf25c0105fb6fa3/aiohttp-3.13.3-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:9ae8dd55c8e6c4257eae3a20fd2c8f41edaea5992ed67156642493b8daf3cecc", size = 1755181, upload-time = "2026-01-03T17:30:27.554Z" },
    { url = "https://files.pythonhosted.org/packages/0a/87/20a35ad487efdd3fba93d5843efdfaa62d2f1479eaafa7453398a44faf13/aiohttp-3.13.3-cp312-cp312-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:01ad2529d4b5035578f5081606a465f3b814c542882804e2e8cda61adf5c71bf", size = 1561794, upload-time = "2026-01-03T17:30:29.254Z" },
    { url = "https://files.pythonhosted.org/packages/de/95/8fd69a66682012f6716e1bc09ef8a1a2a91922c5725cb904689f112309c4/aiohttp-3.13.3-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:bb4f7475e359992b580559e008c598091c45b5088f28614e855e42d39c2f1033", size = 1697900, upload-time = "2026-01-03T17:30:31.033Z" },
    { url = "https://files.pythonhosted.org/packages/e5/66/7b94b3b5ba70e955ff597672dad1691333080e37f50280178967aff68657/aiohttp-3.13.3-cp312-cp312-musllinux_1_2_armv7l.whl", hash = "sha256:c19b90316ad3b24c69cd78d5c9b4f3aa4497643685901185b65166293d36a00f", size = 1728239, upload-time = "2026-01-03T17:30:32.703Z" },
    { url = "https://files.pythonhosted.org/packages/47/71/6f72f77f9f7d74719692ab65a2a0252584bf8d5f301e2ecb4c0da734530a/aiohttp-3.13.3-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:96d604498a7c782cb15a51c406acaea70d8c027ee6b90c569baa6e7b93073679", size = 1740527, upload-time = "2026-01-03T17:30:34.695Z" },
    { url = "https://files.pythonhosted.org/packages/fa/b4/75ec16cbbd5c01bdaf4a05b19e103e78d7ce1ef7c80867eb0ace42ff4488/aiohttp-3.13.3-cp312-cp312-musllinux_1_2_riscv64.whl", hash = "sha256:084911a532763e9d3dd95adf78a78f4096cd5f58cdc18e6fdbc1b58417a45423", size = 1554489, upload-time = "2026-01-03T17:30:36.864Z" },
    { url = "https://files.pythonhosted.org/packages/52/8f/bc518c0eea29f8406dcf7ed1f96c9b48e3bc3995a96159b3fc11f9e08321/aiohttp-3.13.3-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:7a4a94eb787e606d0a09404b9c38c113d3b099d508021faa615d70a0131907ce", size = 1767852, upload-time = "2026-01-03T17:30:39.433Z" },
    { url = "https://files.pythonhosted.org/packages/9d/f2/a07a75173124f31f11ea6f863dc44e6f09afe2bca45dd4e64979490deab1/aiohttp-3.13.3-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:87797e645d9d8e222e04160ee32aa06bc5c163e8499f24db719e7852ec23093a", size = 1722379, upload-time = "2026-01-03T17:30:41.081Z" },
    { url = "https://files.pythonhosted.org/packages/3c/4a/1a3fee7c21350cac78e5c5cef711bac1b94feca07399f3d406972e2d8fcd/aiohttp-3.13.3-cp312-cp312-win32.whl", hash = "sha256:b04be762396457bef43f3597c991e192ee7da460a4953d7e647ee4b1c28e7046", size = 428253, upload-time = "2026-01-03T17:30:42.644Z" },
    { url = "https://files.pythonhosted.org/packages/d9/b7/76175c7cb4eb73d91ad63c34e29fc4f77c9386bba4a65b53ba8e05ee3c39/aiohttp-3.13.3-cp312-cp312-win_amd64.whl", hash = "sha256:e3531d63d3bdfa7e3ac5e9b27b2dd7ec9df3206a98e0b3445fa906f233264c57", size = 455407, upload-time = "2026-01-03T17:30:44.195Z" },
    { url = "https://files.pythonhosted.org/packages/97/8a/12ca489246ca1faaf5432844adbfce7ff2cc4997733e0af120869345643a/aiohttp-3.13.3-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:5dff64413671b0d3e7d5918ea490bdccb97a4ad29b3f311ed423200b2203e01c", size = 734190, upload-time = "2026-01-03T17:30:45.832Z" },
    { url = "https://files.pythonhosted.org/packages/32/08/de43984c74ed1fca5c014808963cc83cb00d7bb06af228f132d33862ca76/aiohttp-3.13.3-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:87b9aab6d6ed88235aa2970294f496ff1a1f9adcd724d800e9b952395a80ffd9", size = 491783, upload-time = "2026-01-03T17:30:47.466Z" },
    { url = "https://files.pythonhosted.org/packages/17/f8/8dd2cf6112a5a76f81f81a5130c57ca829d101ad583ce57f889179accdda/aiohttp-3.13.3-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:425c126c0dc43861e22cb1c14ba4c8e45d09516d0a3ae0a3f7494b79f5f233a3", size = 490704, upload-time = "2026-01-03T17:30:49.373Z" },
    { url = "https://files.pythonhosted.org/packages/6d/40/a46b03ca03936f832bc7eaa47cfbb1ad012ba1be4790122ee4f4f8cba074/aiohttp-3.13.3-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:7f9120f7093c2a32d9647abcaf21e6ad275b4fbec5b55969f978b1a97c7c86bf", size = 1720652, upload-time = "2026-01-03T17:30:50.974Z" },
    { url = "https://files.pythonhosted.org/packages/f7/7e/917fe18e3607af92657e4285498f500dca797ff8c918bd7d90b05abf6c2a/aiohttp-3.13.3-cp313-cp313-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:697753042d57f4bf7122cab985bf15d0cef23c770864580f5af4f52023a56bd6", size = 1692014, upload-time = "2026-01-03T17:30:52.729Z" },
    { url = "https://files.pythonhosted.org/packages/71/b6/cefa4cbc00d315d68973b671cf105b21a609c12b82d52e5d0c9ae61d2a09/aiohttp-3.13.3-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:6de499a1a44e7de70735d0b39f67c8f25eb3d91eb3103be99ca0fa882cdd987d", size = 1759777, upload-time = "2026-01-03T17:30:54.537Z" },
    { url = "https://files.pythonhosted.org/packages/fb/e3/e06ee07b45e59e6d81498b591fc589629be1553abb2a82ce33efe2a7b068/aiohttp-3.13.3-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:37239e9f9a7ea9ac5bf6b92b0260b01f8a22281996da609206a84df860bc1261", size = 1861276, upload-time = "2026-01-03T17:30:56.512Z" },
    { url = "https://files.pythonhosted.org/packages/7c/24/75d274228acf35ceeb2850b8ce04de9dd7355ff7a0b49d607ee60c29c518/aiohttp-3.13.3-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:f76c1e3fe7d7c8afad7ed193f89a292e1999608170dcc9751a7462a87dfd5bc0", size = 1743131, upload-time = "2026-01-03T17:30:58.256Z" },
    { url = "https://files.pythonhosted.org/packages/04/98/3d21dde21889b17ca2eea54fdcff21b27b93f45b7bb94ca029c31ab59dc3/aiohttp-3.13.3-cp313-cp313-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:fc290605db2a917f6e81b0e1e0796469871f5af381ce15c604a3c5c7e51cb730", size = 1556863, upload-time = "2026-01-03T17:31:00.445Z" },
    { url = "https://files.pythonhosted.org/packages/9e/84/da0c3ab1192eaf64782b03971ab4055b475d0db07b17eff925e8c93b3aa5/aiohttp-3.13.3-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:4021b51936308aeea0367b8f006dc999ca02bc118a0cc78c303f50a2ff6afb91", size = 1682793, upload-time = "2026-01-03T17:31:03.024Z" },
    { url = "https://files.pythonhosted.org/packages/ff/0f/5802ada182f575afa02cbd0ec5180d7e13a402afb7c2c03a9aa5e5d49060/aiohttp-3.13.3-cp313-cp313-musllinux_1_2_armv7l.whl", hash = "sha256:49a03727c1bba9a97d3e93c9f93ca03a57300f484b6e935463099841261195d3", size = 1716676, upload-time = "2026-01-03T17:31:04.842Z" },
    { url = "https://files.pythonhosted.org/packages/3f/8c/714d53bd8b5a4560667f7bbbb06b20c2382f9c7847d198370ec6526af39c/aiohttp-3.13.3-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:3d9908a48eb7416dc1f4524e69f1d32e5d90e3981e4e37eb0aa1cd18f9cfa2a4", size = 1733217, upload-time = "2026-01-03T17:31:06.868Z" },
    { url = "https://files.pythonhosted.org/packages/7d/79/e2176f46d2e963facea939f5be2d26368ce543622be6f00a12844d3c991f/aiohttp-3.13.3-cp313-cp313-musllinux_1_2_riscv64.whl", hash = "sha256:2712039939ec963c237286113c68dbad80a82a4281543f3abf766d9d73228998", size = 1552303, upload-time = "2026-01-03T17:31:08.958Z" },
    { url = "https://files.pythonhosted.org/packages/ab/6a/28ed4dea1759916090587d1fe57087b03e6c784a642b85ef48217b0277ae/aiohttp-3.13.3-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:7bfdc049127717581866fa4708791220970ce291c23e28ccf3922c700740fdc0", size = 1763673, upload-time = "2026-01-03T17:31:10.676Z" },
    { url = "https://files.pythonhosted.org/packages/e8/35/4a3daeb8b9fab49240d21c04d50732313295e4bd813a465d840236dd0ce1/aiohttp-3.13.3-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:8057c98e0c8472d8846b9c79f56766bcc57e3e8ac7bfd510482332366c56c591", size = 1721120, upload-time = "2026-01-03T17:31:12.575Z" },
    { url = "https://files.pythonhosted.org/packages/bc/9f/d643bb3c5fb99547323e635e251c609fbbc660d983144cfebec529e09264/aiohttp-3.13.3-cp313-cp313-win32.whl", hash = "sha256:1449ceddcdbcf2e0446957863af03ebaaa03f94c090f945411b61269e2cb5daf", size = 427383, upload-time = "2026-01-03T17:31:14.382Z" },
    { url = "https://files.pythonhosted.org/packages/4e/f1/ab0395f8a79933577cdd996dd2f9aa6014af9535f65dddcf88204682fe62/aiohttp-3.13.3-cp313-cp313-win_amd64.whl", hash = "sha256:693781c45a4033d31d4187d2436f5ac701e7bbfe5df40d917736108c1cc7436e", size = 453899, upload-time = "2026-01-03T17:31:15.958Z" },
]

[[package]]
name = "aioitertools"
version = "0.12.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/06/de/38491a84ab323b47c7f86e94d2830e748780525f7a10c8600b67ead7e9ea/aioitertools-0.12.0.tar.gz", hash = "sha256:c2a9055b4fbb7705f561b9d86053e8af5d10cc845d22c32008c43490b2d8dd6b", size = 19369, upload-time = "2024-09-02T03:33:40.349Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/85/13/58b70a580de00893223d61de8fea167877a3aed97d4a5e1405c9159ef925/aioitertools-0.12.0-py3-none-any.whl", hash = "sha256:fc1f5fac3d737354de8831cbba3eb04f79dd649d8f3afb4c5b114925e662a796", size = 24345, upload-time = "2024-09-02T03:34:59.454Z" },
]

[[package]]
name = "aiosignal"
version = "1.4.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "frozenlist" },
    { name = "typing-extensions", marker = "python_full_version < '3.13'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/61/62/06741b579156360248d1ec624842ad0edf697050bbaf7c3e46394e106ad1/aiosignal-1.4.0.tar.gz", hash = "sha256:f47eecd9468083c2029cc99945502cb7708b082c232f9aca65da147157b251c7", size = 25007, upload-time = "2025-07-03T22:54:43.528Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/fb/76/641ae371508676492379f16e2fa48f4e2c11741bd63c48be4b12a6b09cba/aiosignal-1.4.0-py3-none-any.whl", hash = "sha256:053243f8b92b990551949e63930a839ff0cf0b0ebbe0597b0f3fb19e1a0fe82e", size = 7490, upload-time = "2025-07-03T22:54:42.156Z" },
]

[[package]]
name = "aiosqlite"
version = "0.21.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/13/7d/8bca2bf9a247c2c5dfeec1d7a5f40db6518f88d314b8bca9da29670d2671/aiosqlite-0.21.0.tar.gz", hash = "sha256:131bb8056daa3bc875608c631c678cda73922a2d4ba8aec373b19f18c17e7aa3", size = 13454, upload-time = "2025-02-03T07:30:16.235Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f5/10/6c25ed6de94c49f88a91fa5018cb4c0f3625f31d5be9f771ebe5cc7cd506/aiosqlite-0.21.0-py3-none-any.whl", hash = "sha256:2549cf4057f95f53dcba16f2b64e8e2791d7e1adedb13197dd8ed77bb226d7d0", size = 15792, upload-time = "2025-02-03T07:30:13.6Z" },
]

[[package]]
name = "alembic"
version = "1.17.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "mako" },
    { name = "sqlalchemy" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/6e/b6/2a81d7724c0c124edc5ec7a167e85858b6fd31b9611c6fb8ecf617b7e2d3/alembic-1.17.1.tar.gz", hash = "sha256:8a289f6778262df31571d29cca4c7fbacd2f0f582ea0816f4c399b6da7528486", size = 1981285, upload-time = "2025-10-29T00:23:16.667Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a5/32/7df1d81ec2e50fb661944a35183d87e62d3f6c6d9f8aff64a4f245226d55/alembic-1.17.1-py3-none-any.whl", hash = "sha256:cbc2386e60f89608bb63f30d2d6cc66c7aaed1fe105bd862828600e5ad167023", size = 247848, upload-time = "2025-10-29T00:23:18.79Z" },
]

[[package]]
name = "annotated-doc"
version = "0.0.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d7/a6/dc46877b911e40c00d395771ea710d5e77b6de7bacd5fdcd78d70cc5a48f/annotated_doc-0.0.3.tar.gz", hash = "sha256:e18370014c70187422c33e945053ff4c286f453a984eba84d0dbfa0c935adeda", size = 5535, upload-time = "2025-10-24T14:57:10.718Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/02/b7/cf592cb5de5cb3bade3357f8d2cf42bf103bbe39f459824b4939fd212911/annotated_doc-0.0.3-py3-none-any.whl", hash = "sha256:348ec6664a76f1fd3be81f43dffbee4c7e8ce931ba71ec67cc7f4ade7fbbb580", size = 5488, upload-time = "2025-10-24T14:57:09.462Z" },
]

[[package]]
name = "annotated-types"
version = "0.7.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ee/67/531ea369ba64dcff5ec9c3402f9f51bf748cec26dde048a2f973a4eea7f5/annotated_types-0.7.0.tar.gz", hash = "sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89", size = 16081, upload-time = "2024-05-20T21:33:25.928Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/78/b6/6307fbef88d9b5ee7421e68d78a9f162e0da4900bc5f5793f6d3d0e34fb8/annotated_types-0.7.0-py3-none-any.whl", hash = "sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53", size = 13643, upload-time = "2024-05-20T21:33:24.1Z" },
]

[[package]]
name = "anthropic"
version = "0.72.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "distro" },
    { name = "docstring-parser" },
    { name = "httpx" },
    { name = "jiter" },
    { name = "pydantic" },
    { name = "sniffio" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/49/07/61f3ca8e69c5dcdaec31b36b79a53ea21c5b4ca5e93c7df58c71f43bf8d8/anthropic-0.72.0.tar.gz", hash = "sha256:8971fe76dcffc644f74ac3883069beb1527641115ae0d6eb8fa21c1ce4082f7a", size = 493721, upload-time = "2025-10-28T19:13:01.755Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7b/b7/160d4fb30080395b4143f1d1a4f6c646ba9105561108d2a434b606c03579/anthropic-0.72.0-py3-none-any.whl", hash = "sha256:0e9f5a7582f038cab8efbb4c959e49ef654a56bfc7ba2da51b5a7b8a84de2e4d", size = 357464, upload-time = "2025-10-28T19:13:00.215Z" },
]

[package.optional-dependencies]
bedrock = [
    { name = "boto3" },
    { name = "botocore" },
]
vertex = [
    { name = "google-auth", extra = ["requests"] },
]

[[package]]
name = "anyio"
version = "4.11.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "idna" },
    { name = "sniffio" },
    { name = "typing-extensions", marker = "python_full_version < '3.13'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/c6/78/7d432127c41b50bccba979505f272c16cbcadcc33645d5fa3a738110ae75/anyio-4.11.0.tar.gz", hash = "sha256:82a8d0b81e318cc5ce71a5f1f8b5c4e63619620b63141ef8c995fa0db95a57c4", size = 219094, upload-time = "2025-09-23T09:19:12.58Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/15/b3/9b1a8074496371342ec1e796a96f99c82c945a339cd81a8e73de28b4cf9e/anyio-4.11.0-py3-none-any.whl", hash = "sha256:0287e96f4d26d4149305414d4e3bc32f0dcd0862365a4bddea19d7a1ec38c4fc", size = 109097, upload-time = "2025-09-23T09:19:10.601Z" },
]

[[package]]
name = "apkutils2"
version = "1.0.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "cigam" },
    { name = "pyelftools" },
    { name = "xmltodict" },
]
sdist = { url = "https://files.pythonhosted.org/packages/e5/d0/432fb6fb1fe48aa0ea1c80e8dec4a26f70c868999c076f92af88582ae91a/apkutils2-1.0.0.tar.gz", hash = "sha256:c5ae8f86d3ebee6a59fc014d88507741d7f3f9ab183bab34b44d011fe878660b", size = 60986, upload-time = "2019-07-31T06:47:25.201Z" }

[[package]]
name = "arize-phoenix"
version = "12.10.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "aioitertools" },
    { name = "aiosqlite" },
    { name = "alembic" },
    { name = "arize-phoenix-client" },
    { name = "arize-phoenix-evals" },
    { name = "arize-phoenix-otel" },
    { name = "authlib" },
    { name = "cachetools" },
    { name = "email-validator" },
    { name = "fastapi" },
    { name = "grpc-interceptor" },
    { name = "grpcio" },
    { name = "httpx" },
    { name = "jinja2" },
    { name = "jmespath" },
    { name = "numpy" },
    { name = "openinference-instrumentation" },
    { name = "openinference-semantic-conventions" },
    { name = "opentelemetry-exporter-otlp" },
    { name = "opentelemetry-proto" },
    { name = "opentelemetry-sdk" },
    { name = "opentelemetry-semantic-conventions" },
    { name = "orjson" },
    { name = "pandas" },
    { name = "prometheus-client" },
    { name = "protobuf" },
    { name = "psutil" },
    { name = "pyarrow" },
    { name = "pydantic" },
    { name = "python-dateutil" },
    { name = "python-multipart" },
    { name = "scikit-learn" },
    { name = "scipy" },
    { name = "sqlalchemy", extra = ["asyncio"] },
    { name = "sqlean-py" },
    { name = "starlette" },
    { name = "strawberry-graphql" },
    { name = "tqdm" },
    { name = "typing-extensions" },
    { name = "uvicorn" },
    { name = "wrapt" },
]
sdist = { url = "https://files.pythonhosted.org/packages/31/80/e0414ca1c6859768d5d3807c71514989de07e984dcec604aa9fe9cf194d3/arize_phoenix-12.10.0.tar.gz", hash = "sha256:4275edff06dca7a91c20853a49decb9b6fc849eae235e254e31534acaa188f64", size = 2341818, upload-time = "2025-11-05T19:51:28.664Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/94/ae/8d001dc189d65107f2c5d6b71ac722e5532e11fa0c3ac3f353d5d4e4d07d/arize_phoenix-12.10.0-py3-none-any.whl", hash = "sha256:d6fdfd695fd1c0b3d5d21c48ad45c1c1b7c59dead8cf1030464fc0312643ef8e", size = 2565425, upload-time = "2025-11-05T19:51:26.358Z" },
]

[[package]]
name = "arize-phoenix-client"
version = "1.22.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "httpx" },
    { name = "openinference-instrumentation" },
    { name = "openinference-semantic-conventions" },
    { name = "opentelemetry-exporter-otlp" },
    { name = "opentelemetry-sdk" },
    { name = "tqdm" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/22/9b/3cf002422bbdcfc4f46a58feb5f0d3476e0701c7878c8b3c511259262cf6/arize_phoenix_client-1.22.0.tar.gz", hash = "sha256:e415c8386ee4ef1be8fa6faafe1aef1268f728a562d3fbdfbbd3cb91f81739ae", size = 132554, upload-time = "2025-11-05T19:56:34.291Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/65/e8/106f63ae4ee35e569d89eac8e00bdc10d76b8f7274c72dc8ae2fd01dc7ed/arize_phoenix_client-1.22.0-py3-none-any.whl", hash = "sha256:2cc3ac5e589faa6a75f9e0048cabeb4ae36d178bb29423f5cd43bcb2935fc5ae", size = 139453, upload-time = "2025-11-05T19:56:32.797Z" },
]

[[package]]
name = "arize-phoenix-evals"
version = "2.5.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "jsonpath-ng" },
    { name = "openinference-instrumentation" },
    { name = "openinference-semantic-conventions" },
    { name = "opentelemetry-api" },
    { name = "pandas" },
    { name = "pydantic" },
    { name = "pystache" },
    { name = "tqdm" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/08/51/de7bd0611ee4e9a229a5eca3e7458a3682c159c8ccefe332a54adb25d3ac/arize_phoenix_evals-2.5.0.tar.gz", hash = "sha256:6f7995ee29e401a9df6ead675ea9d5dd005ccd5ffe209924f265e9b80b1cdd81", size = 98136, upload-time = "2025-10-07T15:27:46.612Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f0/e7/5126a9c1c9577699d47f852802e1016e0636bff907c0f57f4f23d59607ea/arize_phoenix_evals-2.5.0-py3-none-any.whl", hash = "sha256:ddea69bff74dc5f0417cb13c05920a42bfdc7b36572e96290acdc2875cf6832b", size = 134718, upload-time = "2025-10-07T15:27:45.212Z" },
]

[[package]]
name = "arize-phoenix-otel"
version = "0.13.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "openinference-instrumentation" },
    { name = "openinference-semantic-conventions" },
    { name = "opentelemetry-exporter-otlp" },
    { name = "opentelemetry-proto" },
    { name = "opentelemetry-sdk" },
    { name = "opentelemetry-semantic-conventions" },
    { name = "typing-extensions" },
    { name = "wrapt" },
]
sdist = { url = "https://files.pythonhosted.org/packages/44/3b/8745dc29b9d7db658f64d4a14d100285d1b74f38827171c22120aa5b7c9c/arize_phoenix_otel-0.13.1.tar.gz", hash = "sha256:6fb7bcfed4260b9ddd5bcaa20a678b60e388525e4bbaec1247092f163a0e0204", size = 20166, upload-time = "2025-09-10T06:09:30.954Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8d/40/1d421e172453f07fc8a91b5a2407350bbba598e37b9025ae84b68b0ce8a2/arize_phoenix_otel-0.13.1-py3-none-any.whl", hash = "sha256:98d34da78aebac7f60ec4bc30f0eab1e4490c7329b2c74988b9684f9dc182949", size = 17717, upload-time = "2025-09-10T06:09:30.037Z" },
]

[[package]]
name = "async-adbutils"
version = "0.1.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "apkutils2" },
    { name = "httpx" },
    { name = "pillow" },
    { name = "retry" },
]
sdist = { url = "https://files.pythonhosted.org/packages/94/e0/177151e2b4139f64a4674838771f437179f94db5302bd1a2177c8b1672f3/async_adbutils-0.1.0.tar.gz", hash = "sha256:f2fd9b6d0270902f96fe527db8bc5f0cc91a1c04be8aa06eb76327ccdf0dc299", size = 39806, upload-time = "2025-11-10T10:29:38.714Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/57/2a/e63977a7b911aba9001c165219f40f052223ce1ad2f6d3dc23cf9a07a427/async_adbutils-0.1.0-py3-none-any.whl", hash = "sha256:e10b6beed7622b9ac1450a11c4871844d3ad99b37074536a335fdfc613ef88b4", size = 37245, upload-time = "2025-11-10T10:29:37.731Z" },
]

[[package]]
name = "attrs"
version = "25.4.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/6b/5c/685e6633917e101e5dcb62b9dd76946cbb57c26e133bae9e0cd36033c0a9/attrs-25.4.0.tar.gz", hash = "sha256:16d5969b87f0859ef33a48b35d55ac1be6e42ae49d5e853b597db70c35c57e11", size = 934251, upload-time = "2025-10-06T13:54:44.725Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/3a/2a/7cc015f5b9f5db42b7d48157e23356022889fc354a2813c15934b7cb5c0e/attrs-25.4.0-py3-none-any.whl", hash = "sha256:adcf7e2a1fb3b36ac48d97835bb6d8ade15b8dcce26aba8bf1d14847b57a3373", size = 67615, upload-time = "2025-10-06T13:54:43.17Z" },
]

[[package]]
name = "authlib"
version = "1.6.8"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "cryptography" },
]
sdist = { url = "https://files.pythonhosted.org/packages/6b/6c/c88eac87468c607f88bc24df1f3b31445ee6fc9ba123b09e666adf687cd9/authlib-1.6.8.tar.gz", hash = "sha256:41ae180a17cf672bc784e4a518e5c82687f1fe1e98b0cafaeda80c8e4ab2d1cb", size = 165074, upload-time = "2026-02-14T04:02:17.941Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9b/73/f7084bf12755113cd535ae586782ff3a6e710bfbe6a0d13d1c2f81ffbbfa/authlib-1.6.8-py2.py3-none-any.whl", hash = "sha256:97286fd7a15e6cfefc32771c8ef9c54f0ed58028f1322de6a2a7c969c3817888", size = 244116, upload-time = "2026-02-14T04:02:15.579Z" },
]

[[package]]
name = "backoff"
version = "2.2.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/47/d7/5bbeb12c44d7c4f2fb5b56abce497eb5ed9f34d85701de869acedd602619/backoff-2.2.1.tar.gz", hash = "sha256:03f829f5bb1923180821643f8753b0502c3b682293992485b0eef2807afa5cba", size = 17001, upload-time = "2022-10-05T19:19:32.061Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/df/73/b6e24bd22e6720ca8ee9a85a0c4a2971af8497d8f3193fa05390cbd46e09/backoff-2.2.1-py3-none-any.whl", hash = "sha256:63579f9a0628e06278f7e47b7d7d5b6ce20dc65c5e96a6f3ca99a6adca0396e8", size = 15148, upload-time = "2022-10-05T19:19:30.546Z" },
]

[[package]]
name = "bandit"
version = "1.8.6"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama", marker = "sys_platform == 'win32'" },
    { name = "pyyaml" },
    { name = "rich" },
    { name = "stevedore" },
]
sdist = { url = "https://files.pythonhosted.org/packages/fb/b5/7eb834e213d6f73aace21938e5e90425c92e5f42abafaf8a6d5d21beed51/bandit-1.8.6.tar.gz", hash = "sha256:dbfe9c25fc6961c2078593de55fd19f2559f9e45b99f1272341f5b95dea4e56b", size = 4240271, upload-time = "2025-07-06T03:10:50.9Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/48/ca/ba5f909b40ea12ec542d5d7bdd13ee31c4d65f3beed20211ef81c18fa1f3/bandit-1.8.6-py3-none-any.whl", hash = "sha256:3348e934d736fcdb68b6aa4030487097e23a501adf3e7827b63658df464dddd0", size = 133808, upload-time = "2025-07-06T03:10:49.134Z" },
]

[[package]]
name = "banks"
version = "2.2.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "deprecated" },
    { name = "griffe" },
    { name = "jinja2" },
    { name = "platformdirs" },
    { name = "pydantic" },
]
sdist = { url = "https://files.pythonhosted.org/packages/7d/f8/25ef24814f77f3fd7f0fd3bd1ef3749e38a9dbd23502fbb53034de49900c/banks-2.2.0.tar.gz", hash = "sha256:d1446280ce6e00301e3e952dd754fd8cee23ff277d29ed160994a84d0d7ffe62", size = 179052, upload-time = "2025-07-18T16:28:26.892Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b4/d6/f9168956276934162ec8d48232f9920f2985ee45aa7602e3c6b4bc203613/banks-2.2.0-py3-none-any.whl", hash = "sha256:963cd5c85a587b122abde4f4064078def35c50c688c1b9d36f43c92503854e7d", size = 29244, upload-time = "2025-07-18T16:28:27.835Z" },
]

[[package]]
name = "beautifulsoup4"
version = "4.14.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "soupsieve" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/77/e9/df2358efd7659577435e2177bfa69cba6c33216681af51a707193dec162a/beautifulsoup4-4.14.2.tar.gz", hash = "sha256:2a98ab9f944a11acee9cc848508ec28d9228abfd522ef0fad6a02a72e0ded69e", size = 625822, upload-time = "2025-09-29T10:05:42.613Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/94/fe/3aed5d0be4d404d12d36ab97e2f1791424d9ca39c2f754a6285d59a3b01d/beautifulsoup4-4.14.2-py3-none-any.whl", hash = "sha256:5ef6fa3a8cbece8488d66985560f97ed091e22bbc4e9c2338508a9d5de6d4515", size = 106392, upload-time = "2025-09-29T10:05:43.771Z" },
]

[[package]]
name = "black"
version = "25.9.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "mypy-extensions" },
    { name = "packaging" },
    { name = "pathspec" },
    { name = "platformdirs" },
    { name = "pytokens" },
]
sdist = { url = "https://files.pythonhosted.org/packages/4b/43/20b5c90612d7bdb2bdbcceeb53d588acca3bb8f0e4c5d5c751a2c8fdd55a/black-25.9.0.tar.gz", hash = "sha256:0474bca9a0dd1b51791fcc507a4e02078a1c63f6d4e4ae5544b9848c7adfb619", size = 648393, upload-time = "2025-09-19T00:27:37.758Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b7/f4/7531d4a336d2d4ac6cc101662184c8e7d068b548d35d874415ed9f4116ef/black-25.9.0-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:456386fe87bad41b806d53c062e2974615825c7a52159cde7ccaeb0695fa28fa", size = 1698727, upload-time = "2025-09-19T00:31:14.264Z" },
    { url = "https://files.pythonhosted.org/packages/28/f9/66f26bfbbf84b949cc77a41a43e138d83b109502cd9c52dfc94070ca51f2/black-25.9.0-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:a16b14a44c1af60a210d8da28e108e13e75a284bf21a9afa6b4571f96ab8bb9d", size = 1555679, upload-time = "2025-09-19T00:31:29.265Z" },
    { url = "https://files.pythonhosted.org/packages/bf/59/61475115906052f415f518a648a9ac679d7afbc8da1c16f8fdf68a8cebed/black-25.9.0-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:aaf319612536d502fdd0e88ce52d8f1352b2c0a955cc2798f79eeca9d3af0608", size = 1617453, upload-time = "2025-09-19T00:30:42.24Z" },
    { url = "https://files.pythonhosted.org/packages/7f/5b/20fd5c884d14550c911e4fb1b0dae00d4abb60a4f3876b449c4d3a9141d5/black-25.9.0-cp311-cp311-win_amd64.whl", hash = "sha256:c0372a93e16b3954208417bfe448e09b0de5cc721d521866cd9e0acac3c04a1f", size = 1333655, upload-time = "2025-09-19T00:30:56.715Z" },
    { url = "https://files.pythonhosted.org/packages/fb/8e/319cfe6c82f7e2d5bfb4d3353c6cc85b523d677ff59edc61fdb9ee275234/black-25.9.0-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:1b9dc70c21ef8b43248f1d86aedd2aaf75ae110b958a7909ad8463c4aa0880b0", size = 1742012, upload-time = "2025-09-19T00:33:08.678Z" },
    { url = "https://files.pythonhosted.org/packages/94/cc/f562fe5d0a40cd2a4e6ae3f685e4c36e365b1f7e494af99c26ff7f28117f/black-25.9.0-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:8e46eecf65a095fa62e53245ae2795c90bdecabd53b50c448d0a8bcd0d2e74c4", size = 1581421, upload-time = "2025-09-19T00:35:25.937Z" },
    { url = "https://files.pythonhosted.org/packages/84/67/6db6dff1ebc8965fd7661498aea0da5d7301074b85bba8606a28f47ede4d/black-25.9.0-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:9101ee58ddc2442199a25cb648d46ba22cd580b00ca4b44234a324e3ec7a0f7e", size = 1655619, upload-time = "2025-09-19T00:30:49.241Z" },
    { url = "https://files.pythonhosted.org/packages/10/10/3faef9aa2a730306cf469d76f7f155a8cc1f66e74781298df0ba31f8b4c8/black-25.9.0-cp312-cp312-win_amd64.whl", hash = "sha256:77e7060a00c5ec4b3367c55f39cf9b06e68965a4f2e61cecacd6d0d9b7ec945a", size = 1342481, upload-time = "2025-09-19T00:31:29.625Z" },
    { url = "https://files.pythonhosted.org/packages/48/99/3acfea65f5e79f45472c45f87ec13037b506522719cd9d4ac86484ff51ac/black-25.9.0-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:0172a012f725b792c358d57fe7b6b6e8e67375dd157f64fa7a3097b3ed3e2175", size = 1742165, upload-time = "2025-09-19T00:34:10.402Z" },
    { url = "https://files.pythonhosted.org/packages/3a/18/799285282c8236a79f25d590f0222dbd6850e14b060dfaa3e720241fd772/black-25.9.0-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:3bec74ee60f8dfef564b573a96b8930f7b6a538e846123d5ad77ba14a8d7a64f", size = 1581259, upload-time = "2025-09-19T00:32:49.685Z" },
    { url = "https://files.pythonhosted.org/packages/f1/ce/883ec4b6303acdeca93ee06b7622f1fa383c6b3765294824165d49b1a86b/black-25.9.0-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:b756fc75871cb1bcac5499552d771822fd9db5a2bb8db2a7247936ca48f39831", size = 1655583, upload-time = "2025-09-19T00:30:44.505Z" },
    { url = "https://files.pythonhosted.org/packages/21/17/5c253aa80a0639ccc427a5c7144534b661505ae2b5a10b77ebe13fa25334/black-25.9.0-cp313-cp313-win_amd64.whl", hash = "sha256:846d58e3ce7879ec1ffe816bb9df6d006cd9590515ed5d17db14e17666b2b357", size = 1343428, upload-time = "2025-09-19T00:32:13.839Z" },
    { url = "https://files.pythonhosted.org/packages/1b/46/863c90dcd3f9d41b109b7f19032ae0db021f0b2a81482ba0a1e28c84de86/black-25.9.0-py3-none-any.whl", hash = "sha256:474b34c1342cdc157d307b56c4c65bce916480c4a8f6551fdc6bf9b486a7c4ae", size = 203363, upload-time = "2025-09-19T00:27:35.724Z" },
]

[[package]]
name = "boto3"
version = "1.40.67"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "botocore" },
    { name = "jmespath" },
    { name = "s3transfer" },
]
sdist = { url = "https://files.pythonhosted.org/packages/40/a5/0e87ff413d2ca57500b1ec9e583a83589ed56fc27af8bacf8f0681c28672/boto3-1.40.67.tar.gz", hash = "sha256:3e4317139ace6d44658b8e1f2b5b6612f05b45720721841c90cdee45b02aa514", size = 111587, upload-time = "2025-11-05T20:33:16.326Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b9/2d/f4896b59ff21d1bf228bde2973b5c5af2debc71e11137533dd088f094846/boto3-1.40.67-py3-none-any.whl", hash = "sha256:3d06e9b3c7abedb8253c7d75b9ab27005480ca1e6e448d1f3c3cc3e209673ca0", size = 139362, upload-time = "2025-11-05T20:33:14.994Z" },
]

[[package]]
name = "botocore"
version = "1.40.67"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "jmespath" },
    { name = "python-dateutil" },
    { name = "urllib3" },
]
sdist = { url = "https://files.pythonhosted.org/packages/2d/aa/4d3d04e3fb2f497fbe574051d50180a6326ffef481caea80837605a0016d/botocore-1.40.67.tar.gz", hash = "sha256:cc086f39c877aee0ea8dc88ef69062c9f395b9d30d49bfcfac7b8b7e61864b3a", size = 14417097, upload-time = "2025-11-05T20:33:06.595Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9e/65/2b50bb0112d6e2c171c8e07cc7f2a0581d39b850921d4defdf5421098fc9/botocore-1.40.67-py3-none-any.whl", hash = "sha256:e49e61f6718e8bc8b34e9bb8a97f16c8dc560485faef4981b55d76f825c9d78a", size = 14081807, upload-time = "2025-11-05T20:33:03.804Z" },
]

[[package]]
name = "cachetools"
version = "6.2.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/cc/7e/b975b5814bd36faf009faebe22c1072a1fa1168db34d285ef0ba071ad78c/cachetools-6.2.1.tar.gz", hash = "sha256:3f391e4bd8f8bf0931169baf7456cc822705f4e2a31f840d218f445b9a854201", size = 31325, upload-time = "2025-10-12T14:55:30.139Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/96/c5/1e741d26306c42e2bf6ab740b2202872727e0f606033c9dd713f8b93f5a8/cachetools-6.2.1-py3-none-any.whl", hash = "sha256:09868944b6dde876dfd44e1d47e18484541eaf12f26f29b7af91b26cc892d701", size = 11280, upload-time = "2025-10-12T14:55:28.382Z" },
]

[[package]]
name = "certifi"
version = "2025.10.5"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/4c/5b/b6ce21586237c77ce67d01dc5507039d444b630dd76611bbca2d8e5dcd91/certifi-2025.10.5.tar.gz", hash = "sha256:47c09d31ccf2acf0be3f701ea53595ee7e0b8fa08801c6624be771df09ae7b43", size = 164519, upload-time = "2025-10-05T04:12:15.808Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e4/37/af0d2ef3967ac0d6113837b44a4f0bfe1328c2b9763bd5b1744520e5cfed/certifi-2025.10.5-py3-none-any.whl", hash = "sha256:0f212c2744a9bb6de0c56639a6f68afe01ecd92d91f14ae897c4fe7bbeeef0de", size = 163286, upload-time = "2025-10-05T04:12:14.03Z" },
]

[[package]]
name = "cffi"
version = "2.0.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "pycparser", marker = "implementation_name != 'PyPy'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/eb/56/b1ba7935a17738ae8453301356628e8147c79dbb825bcbc73dc7401f9846/cffi-2.0.0.tar.gz", hash = "sha256:44d1b5909021139fe36001ae048dbdde8214afa20200eda0f64c068cac5d5529", size = 523588, upload-time = "2025-09-08T23:24:04.541Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/12/4a/3dfd5f7850cbf0d06dc84ba9aa00db766b52ca38d8b86e3a38314d52498c/cffi-2.0.0-cp311-cp311-macosx_10_13_x86_64.whl", hash = "sha256:b4c854ef3adc177950a8dfc81a86f5115d2abd545751a304c5bcf2c2c7283cfe", size = 184344, upload-time = "2025-09-08T23:22:26.456Z" },
    { url = "https://files.pythonhosted.org/packages/4f/8b/f0e4c441227ba756aafbe78f117485b25bb26b1c059d01f137fa6d14896b/cffi-2.0.0-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:2de9a304e27f7596cd03d16f1b7c72219bd944e99cc52b84d0145aefb07cbd3c", size = 180560, upload-time = "2025-09-08T23:22:28.197Z" },
    { url = "https://files.pythonhosted.org/packages/b1/b7/1200d354378ef52ec227395d95c2576330fd22a869f7a70e88e1447eb234/cffi-2.0.0-cp311-cp311-manylinux1_i686.manylinux2014_i686.manylinux_2_17_i686.manylinux_2_5_i686.whl", hash = "sha256:baf5215e0ab74c16e2dd324e8ec067ef59e41125d3eade2b863d294fd5035c92", size = 209613, upload-time = "2025-09-08T23:22:29.475Z" },
    { url = "https://files.pythonhosted.org/packages/b8/56/6033f5e86e8cc9bb629f0077ba71679508bdf54a9a5e112a3c0b91870332/cffi-2.0.0-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:730cacb21e1bdff3ce90babf007d0a0917cc3e6492f336c2f0134101e0944f93", size = 216476, upload-time = "2025-09-08T23:22:31.063Z" },
    { url = "https://files.pythonhosted.org/packages/dc/7f/55fecd70f7ece178db2f26128ec41430d8720f2d12ca97bf8f0a628207d5/cffi-2.0.0-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:6824f87845e3396029f3820c206e459ccc91760e8fa24422f8b0c3d1731cbec5", size = 203374, upload-time = "2025-09-08T23:22:32.507Z" },
    { url = "https://files.pythonhosted.org/packages/84/ef/a7b77c8bdc0f77adc3b46888f1ad54be8f3b7821697a7b89126e829e676a/cffi-2.0.0-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:9de40a7b0323d889cf8d23d1ef214f565ab154443c42737dfe52ff82cf857664", size = 202597, upload-time = "2025-09-08T23:22:34.132Z" },
    { url = "https://files.pythonhosted.org/packages/d7/91/500d892b2bf36529a75b77958edfcd5ad8e2ce4064ce2ecfeab2125d72d1/cffi-2.0.0-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:8941aaadaf67246224cee8c3803777eed332a19d909b47e29c9842ef1e79ac26", size = 215574, upload-time = "2025-09-08T23:22:35.443Z" },
    { url = "https://files.pythonhosted.org/packages/44/64/58f6255b62b101093d5df22dcb752596066c7e89dd725e0afaed242a61be/cffi-2.0.0-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:a05d0c237b3349096d3981b727493e22147f934b20f6f125a3eba8f994bec4a9", size = 218971, upload-time = "2025-09-08T23:22:36.805Z" },
    { url = "https://files.pythonhosted.org/packages/ab/49/fa72cebe2fd8a55fbe14956f9970fe8eb1ac59e5df042f603ef7c8ba0adc/cffi-2.0.0-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:94698a9c5f91f9d138526b48fe26a199609544591f859c870d477351dc7b2414", size = 211972, upload-time = "2025-09-08T23:22:38.436Z" },
    { url = "https://files.pythonhosted.org/packages/0b/28/dd0967a76aab36731b6ebfe64dec4e981aff7e0608f60c2d46b46982607d/cffi-2.0.0-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:5fed36fccc0612a53f1d4d9a816b50a36702c28a2aa880cb8a122b3466638743", size = 217078, upload-time = "2025-09-08T23:22:39.776Z" },
    { url = "https://files.pythonhosted.org/packages/2b/c0/015b25184413d7ab0a410775fdb4a50fca20f5589b5dab1dbbfa3baad8ce/cffi-2.0.0-cp311-cp311-win32.whl", hash = "sha256:c649e3a33450ec82378822b3dad03cc228b8f5963c0c12fc3b1e0ab940f768a5", size = 172076, upload-time = "2025-09-08T23:22:40.95Z" },
    { url = "https://files.pythonhosted.org/packages/ae/8f/dc5531155e7070361eb1b7e4c1a9d896d0cb21c49f807a6c03fd63fc877e/cffi-2.0.0-cp311-cp311-win_amd64.whl", hash = "sha256:66f011380d0e49ed280c789fbd08ff0d40968ee7b665575489afa95c98196ab5", size = 182820, upload-time = "2025-09-08T23:22:42.463Z" },
    { url = "https://files.pythonhosted.org/packages/95/5c/1b493356429f9aecfd56bc171285a4c4ac8697f76e9bbbbb105e537853a1/cffi-2.0.0-cp311-cp311-win_arm64.whl", hash = "sha256:c6638687455baf640e37344fe26d37c404db8b80d037c3d29f58fe8d1c3b194d", size = 177635, upload-time = "2025-09-08T23:22:43.623Z" },
    { url = "https://files.pythonhosted.org/packages/ea/47/4f61023ea636104d4f16ab488e268b93008c3d0bb76893b1b31db1f96802/cffi-2.0.0-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:6d02d6655b0e54f54c4ef0b94eb6be0607b70853c45ce98bd278dc7de718be5d", size = 185271, upload-time = "2025-09-08T23:22:44.795Z" },
    { url = "https://files.pythonhosted.org/packages/df/a2/781b623f57358e360d62cdd7a8c681f074a71d445418a776eef0aadb4ab4/cffi-2.0.0-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:8eca2a813c1cb7ad4fb74d368c2ffbbb4789d377ee5bb8df98373c2cc0dee76c", size = 181048, upload-time = "2025-09-08T23:22:45.938Z" },
    { url = "https://files.pythonhosted.org/packages/ff/df/a4f0fbd47331ceeba3d37c2e51e9dfc9722498becbeec2bd8bc856c9538a/cffi-2.0.0-cp312-cp312-manylinux1_i686.manylinux2014_i686.manylinux_2_17_i686.manylinux_2_5_i686.whl", hash = "sha256:21d1152871b019407d8ac3985f6775c079416c282e431a4da6afe7aefd2bccbe", size = 212529, upload-time = "2025-09-08T23:22:47.349Z" },
    { url = "https://files.pythonhosted.org/packages/d5/72/12b5f8d3865bf0f87cf1404d8c374e7487dcf097a1c91c436e72e6badd83/cffi-2.0.0-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:b21e08af67b8a103c71a250401c78d5e0893beff75e28c53c98f4de42f774062", size = 220097, upload-time = "2025-09-08T23:22:48.677Z" },
    { url = "https://files.pythonhosted.org/packages/c2/95/7a135d52a50dfa7c882ab0ac17e8dc11cec9d55d2c18dda414c051c5e69e/cffi-2.0.0-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:1e3a615586f05fc4065a8b22b8152f0c1b00cdbc60596d187c2a74f9e3036e4e", size = 207983, upload-time = "2025-09-08T23:22:50.06Z" },
    { url = "https://files.pythonhosted.org/packages/3a/c8/15cb9ada8895957ea171c62dc78ff3e99159ee7adb13c0123c001a2546c1/cffi-2.0.0-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:81afed14892743bbe14dacb9e36d9e0e504cd204e0b165062c488942b9718037", size = 206519, upload-time = "2025-09-08T23:22:51.364Z" },
    { url = "https://files.pythonhosted.org/packages/78/2d/7fa73dfa841b5ac06c7b8855cfc18622132e365f5b81d02230333ff26e9e/cffi-2.0.0-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:3e17ed538242334bf70832644a32a7aae3d83b57567f9fd60a26257e992b79ba", size = 219572, upload-time = "2025-09-08T23:22:52.902Z" },
    { url = "https://files.pythonhosted.org/packages/07/e0/267e57e387b4ca276b90f0434ff88b2c2241ad72b16d31836adddfd6031b/cffi-2.0.0-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:3925dd22fa2b7699ed2617149842d2e6adde22b262fcbfada50e3d195e4b3a94", size = 222963, upload-time = "2025-09-08T23:22:54.518Z" },
    { url = "https://files.pythonhosted.org/packages/b6/75/1f2747525e06f53efbd878f4d03bac5b859cbc11c633d0fb81432d98a795/cffi-2.0.0-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:2c8f814d84194c9ea681642fd164267891702542f028a15fc97d4674b6206187", size = 221361, upload-time = "2025-09-08T23:22:55.867Z" },
    { url = "https://files.pythonhosted.org/packages/7b/2b/2b6435f76bfeb6bbf055596976da087377ede68df465419d192acf00c437/cffi-2.0.0-cp312-cp312-win32.whl", hash = "sha256:da902562c3e9c550df360bfa53c035b2f241fed6d9aef119048073680ace4a18", size = 172932, upload-time = "2025-09-08T23:22:57.188Z" },
    { url = "https://files.pythonhosted.org/packages/f8/ed/13bd4418627013bec4ed6e54283b1959cf6db888048c7cf4b4c3b5b36002/cffi-2.0.0-cp312-cp312-win_amd64.whl", hash = "sha256:da68248800ad6320861f129cd9c1bf96ca849a2771a59e0344e88681905916f5", size = 183557, upload-time = "2025-09-08T23:22:58.351Z" },
    { url = "https://files.pythonhosted.org/packages/95/31/9f7f93ad2f8eff1dbc1c3656d7ca5bfd8fb52c9d786b4dcf19b2d02217fa/cffi-2.0.0-cp312-cp312-win_arm64.whl", hash = "sha256:4671d9dd5ec934cb9a73e7ee9676f9362aba54f7f34910956b84d727b0d73fb6", size = 177762, upload-time = "2025-09-08T23:22:59.668Z" },
    { url = "https://files.pythonhosted.org/packages/4b/8d/a0a47a0c9e413a658623d014e91e74a50cdd2c423f7ccfd44086ef767f90/cffi-2.0.0-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:00bdf7acc5f795150faa6957054fbbca2439db2f775ce831222b66f192f03beb", size = 185230, upload-time = "2025-09-08T23:23:00.879Z" },
    { url = "https://files.pythonhosted.org/packages/4a/d2/a6c0296814556c68ee32009d9c2ad4f85f2707cdecfd7727951ec228005d/cffi-2.0.0-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:45d5e886156860dc35862657e1494b9bae8dfa63bf56796f2fb56e1679fc0bca", size = 181043, upload-time = "2025-09-08T23:23:02.231Z" },
    { url = "https://files.pythonhosted.org/packages/b0/1e/d22cc63332bd59b06481ceaac49d6c507598642e2230f201649058a7e704/cffi-2.0.0-cp313-cp313-manylinux1_i686.manylinux2014_i686.manylinux_2_17_i686.manylinux_2_5_i686.whl", hash = "sha256:07b271772c100085dd28b74fa0cd81c8fb1a3ba18b21e03d7c27f3436a10606b", size = 212446, upload-time = "2025-09-08T23:23:03.472Z" },
    { url = "https://files.pythonhosted.org/packages/a9/f5/a2c23eb03b61a0b8747f211eb716446c826ad66818ddc7810cc2cc19b3f2/cffi-2.0.0-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:d48a880098c96020b02d5a1f7d9251308510ce8858940e6fa99ece33f610838b", size = 220101, upload-time = "2025-09-08T23:23:04.792Z" },
    { url = "https://files.pythonhosted.org/packages/f2/7f/e6647792fc5850d634695bc0e6ab4111ae88e89981d35ac269956605feba/cffi-2.0.0-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:f93fd8e5c8c0a4aa1f424d6173f14a892044054871c771f8566e4008eaa359d2", size = 207948, upload-time = "2025-09-08T23:23:06.127Z" },
    { url = "https://files.pythonhosted.org/packages/cb/1e/a5a1bd6f1fb30f22573f76533de12a00bf274abcdc55c8edab639078abb6/cffi-2.0.0-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:dd4f05f54a52fb558f1ba9f528228066954fee3ebe629fc1660d874d040ae5a3", size = 206422, upload-time = "2025-09-08T23:23:07.753Z" },
    { url = "https://files.pythonhosted.org/packages/98/df/0a1755e750013a2081e863e7cd37e0cdd02664372c754e5560099eb7aa44/cffi-2.0.0-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:c8d3b5532fc71b7a77c09192b4a5a200ea992702734a2e9279a37f2478236f26", size = 219499, upload-time = "2025-09-08T23:23:09.648Z" },
    { url = "https://files.pythonhosted.org/packages/50/e1/a969e687fcf9ea58e6e2a928ad5e2dd88cc12f6f0ab477e9971f2309b57c/cffi-2.0.0-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:d9b29c1f0ae438d5ee9acb31cadee00a58c46cc9c0b2f9038c6b0b3470877a8c", size = 222928, upload-time = "2025-09-08T23:23:10.928Z" },
    { url = "https://files.pythonhosted.org/packages/36/54/0362578dd2c9e557a28ac77698ed67323ed5b9775ca9d3fe73fe191bb5d8/cffi-2.0.0-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:6d50360be4546678fc1b79ffe7a66265e28667840010348dd69a314145807a1b", size = 221302, upload-time = "2025-09-08T23:23:12.42Z" },
    { url = "https://files.pythonhosted.org/packages/eb/6d/bf9bda840d5f1dfdbf0feca87fbdb64a918a69bca42cfa0ba7b137c48cb8/cffi-2.0.0-cp313-cp313-win32.whl", hash = "sha256:74a03b9698e198d47562765773b4a8309919089150a0bb17d829ad7b44b60d27", size = 172909, upload-time = "2025-09-08T23:23:14.32Z" },
    { url = "https://files.pythonhosted.org/packages/37/18/6519e1ee6f5a1e579e04b9ddb6f1676c17368a7aba48299c3759bbc3c8b3/cffi-2.0.0-cp313-cp313-win_amd64.whl", hash = "sha256:19f705ada2530c1167abacb171925dd886168931e0a7b78f5bffcae5c6b5be75", size = 183402, upload-time = "2025-09-08T23:23:15.535Z" },
    { url = "https://files.pythonhosted.org/packages/cb/0e/02ceeec9a7d6ee63bb596121c2c8e9b3a9e150936f4fbef6ca1943e6137c/cffi-2.0.0-cp313-cp313-win_arm64.whl", hash = "sha256:256f80b80ca3853f90c21b23ee78cd008713787b1b1e93eae9f3d6a7134abd91", size = 177780, upload-time = "2025-09-08T23:23:16.761Z" },
]

[[package]]
name = "charset-normalizer"
version = "3.4.4"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/13/69/33ddede1939fdd074bce5434295f38fae7136463422fe4fd3e0e89b98062/charset_normalizer-3.4.4.tar.gz", hash = "sha256:94537985111c35f28720e43603b8e7b43a6ecfb2ce1d3058bbe955b73404e21a", size = 129418, upload-time = "2025-10-14T04:42:32.879Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ed/27/c6491ff4954e58a10f69ad90aca8a1b6fe9c5d3c6f380907af3c37435b59/charset_normalizer-3.4.4-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:6e1fcf0720908f200cd21aa4e6750a48ff6ce4afe7ff5a79a90d5ed8a08296f8", size = 206988, upload-time = "2025-10-14T04:40:33.79Z" },
    { url = "https://files.pythonhosted.org/packages/94/59/2e87300fe67ab820b5428580a53cad894272dbb97f38a7a814a2a1ac1011/charset_normalizer-3.4.4-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:5f819d5fe9234f9f82d75bdfa9aef3a3d72c4d24a6e57aeaebba32a704553aa0", size = 147324, upload-time = "2025-10-14T04:40:34.961Z" },
    { url = "https://files.pythonhosted.org/packages/07/fb/0cf61dc84b2b088391830f6274cb57c82e4da8bbc2efeac8c025edb88772/charset_normalizer-3.4.4-cp311-cp311-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:a59cb51917aa591b1c4e6a43c132f0cdc3c76dbad6155df4e28ee626cc77a0a3", size = 142742, upload-time = "2025-10-14T04:40:36.105Z" },
    { url = "https://files.pythonhosted.org/packages/62/8b/171935adf2312cd745d290ed93cf16cf0dfe320863ab7cbeeae1dcd6535f/charset_normalizer-3.4.4-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:8ef3c867360f88ac904fd3f5e1f902f13307af9052646963ee08ff4f131adafc", size = 160863, upload-time = "2025-10-14T04:40:37.188Z" },
    { url = "https://files.pythonhosted.org/packages/09/73/ad875b192bda14f2173bfc1bc9a55e009808484a4b256748d931b6948442/charset_normalizer-3.4.4-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:d9e45d7faa48ee908174d8fe84854479ef838fc6a705c9315372eacbc2f02897", size = 157837, upload-time = "2025-10-14T04:40:38.435Z" },
    { url = "https://files.pythonhosted.org/packages/6d/fc/de9cce525b2c5b94b47c70a4b4fb19f871b24995c728e957ee68ab1671ea/charset_normalizer-3.4.4-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:840c25fb618a231545cbab0564a799f101b63b9901f2569faecd6b222ac72381", size = 151550, upload-time = "2025-10-14T04:40:40.053Z" },
    { url = "https://files.pythonhosted.org/packages/55/c2/43edd615fdfba8c6f2dfbd459b25a6b3b551f24ea21981e23fb768503ce1/charset_normalizer-3.4.4-cp311-cp311-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:ca5862d5b3928c4940729dacc329aa9102900382fea192fc5e52eb69d6093815", size = 149162, upload-time = "2025-10-14T04:40:41.163Z" },
    { url = "https://files.pythonhosted.org/packages/03/86/bde4ad8b4d0e9429a4e82c1e8f5c659993a9a863ad62c7df05cf7b678d75/charset_normalizer-3.4.4-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:d9c7f57c3d666a53421049053eaacdd14bbd0a528e2186fcb2e672effd053bb0", size = 150019, upload-time = "2025-10-14T04:40:42.276Z" },
    { url = "https://files.pythonhosted.org/packages/1f/86/a151eb2af293a7e7bac3a739b81072585ce36ccfb4493039f49f1d3cae8c/charset_normalizer-3.4.4-cp311-cp311-musllinux_1_2_armv7l.whl", hash = "sha256:277e970e750505ed74c832b4bf75dac7476262ee2a013f5574dd49075879e161", size = 143310, upload-time = "2025-10-14T04:40:43.439Z" },
    { url = "https://files.pythonhosted.org/packages/b5/fe/43dae6144a7e07b87478fdfc4dbe9efd5defb0e7ec29f5f58a55aeef7bf7/charset_normalizer-3.4.4-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:31fd66405eaf47bb62e8cd575dc621c56c668f27d46a61d975a249930dd5e2a4", size = 162022, upload-time = "2025-10-14T04:40:44.547Z" },
    { url = "https://files.pythonhosted.org/packages/80/e6/7aab83774f5d2bca81f42ac58d04caf44f0cc2b65fc6db2b3b2e8a05f3b3/charset_normalizer-3.4.4-cp311-cp311-musllinux_1_2_riscv64.whl", hash = "sha256:0d3d8f15c07f86e9ff82319b3d9ef6f4bf907608f53fe9d92b28ea9ae3d1fd89", size = 149383, upload-time = "2025-10-14T04:40:46.018Z" },
    { url = "https://files.pythonhosted.org/packages/4f/e8/b289173b4edae05c0dde07f69f8db476a0b511eac556dfe0d6bda3c43384/charset_normalizer-3.4.4-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:9f7fcd74d410a36883701fafa2482a6af2ff5ba96b9a620e9e0721e28ead5569", size = 159098, upload-time = "2025-10-14T04:40:47.081Z" },
    { url = "https://files.pythonhosted.org/packages/d8/df/fe699727754cae3f8478493c7f45f777b17c3ef0600e28abfec8619eb49c/charset_normalizer-3.4.4-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:ebf3e58c7ec8a8bed6d66a75d7fb37b55e5015b03ceae72a8e7c74495551e224", size = 152991, upload-time = "2025-10-14T04:40:48.246Z" },
    { url = "https://files.pythonhosted.org/packages/1a/86/584869fe4ddb6ffa3bd9f491b87a01568797fb9bd8933f557dba9771beaf/charset_normalizer-3.4.4-cp311-cp311-win32.whl", hash = "sha256:eecbc200c7fd5ddb9a7f16c7decb07b566c29fa2161a16cf67b8d068bd21690a", size = 99456, upload-time = "2025-10-14T04:40:49.376Z" },
    { url = "https://files.pythonhosted.org/packages/65/f6/62fdd5feb60530f50f7e38b4f6a1d5203f4d16ff4f9f0952962c044e919a/charset_normalizer-3.4.4-cp311-cp311-win_amd64.whl", hash = "sha256:5ae497466c7901d54b639cf42d5b8c1b6a4fead55215500d2f486d34db48d016", size = 106978, upload-time = "2025-10-14T04:40:50.844Z" },
    { url = "https://files.pythonhosted.org/packages/7a/9d/0710916e6c82948b3be62d9d398cb4fcf4e97b56d6a6aeccd66c4b2f2bd5/charset_normalizer-3.4.4-cp311-cp311-win_arm64.whl", hash = "sha256:65e2befcd84bc6f37095f5961e68a6f077bf44946771354a28ad434c2cce0ae1", size = 99969, upload-time = "2025-10-14T04:40:52.272Z" },
    { url = "https://files.pythonhosted.org/packages/f3/85/1637cd4af66fa687396e757dec650f28025f2a2f5a5531a3208dc0ec43f2/charset_normalizer-3.4.4-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:0a98e6759f854bd25a58a73fa88833fba3b7c491169f86ce1180c948ab3fd394", size = 208425, upload-time = "2025-10-14T04:40:53.353Z" },
    { url = "https://files.pythonhosted.org/packages/9d/6a/04130023fef2a0d9c62d0bae2649b69f7b7d8d24ea5536feef50551029df/charset_normalizer-3.4.4-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:b5b290ccc2a263e8d185130284f8501e3e36c5e02750fc6b6bdeb2e9e96f1e25", size = 148162, upload-time = "2025-10-14T04:40:54.558Z" },
    { url = "https://files.pythonhosted.org/packages/78/29/62328d79aa60da22c9e0b9a66539feae06ca0f5a4171ac4f7dc285b83688/charset_normalizer-3.4.4-cp312-cp312-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:74bb723680f9f7a6234dcf67aea57e708ec1fbdf5699fb91dfd6f511b0a320ef", size = 144558, upload-time = "2025-10-14T04:40:55.677Z" },
    { url = "https://files.pythonhosted.org/packages/86/bb/b32194a4bf15b88403537c2e120b817c61cd4ecffa9b6876e941c3ee38fe/charset_normalizer-3.4.4-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:f1e34719c6ed0b92f418c7c780480b26b5d9c50349e9a9af7d76bf757530350d", size = 161497, upload-time = "2025-10-14T04:40:57.217Z" },
    { url = "https://files.pythonhosted.org/packages/19/89/a54c82b253d5b9b111dc74aca196ba5ccfcca8242d0fb64146d4d3183ff1/charset_normalizer-3.4.4-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:2437418e20515acec67d86e12bf70056a33abdacb5cb1655042f6538d6b085a8", size = 159240, upload-time = "2025-10-14T04:40:58.358Z" },
    { url = "https://files.pythonhosted.org/packages/c0/10/d20b513afe03acc89ec33948320a5544d31f21b05368436d580dec4e234d/charset_normalizer-3.4.4-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:11d694519d7f29d6cd09f6ac70028dba10f92f6cdd059096db198c283794ac86", size = 153471, upload-time = "2025-10-14T04:40:59.468Z" },
    { url = "https://files.pythonhosted.org/packages/61/fa/fbf177b55bdd727010f9c0a3c49eefa1d10f960e5f09d1d887bf93c2e698/charset_normalizer-3.4.4-cp312-cp312-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:ac1c4a689edcc530fc9d9aa11f5774b9e2f33f9a0c6a57864e90908f5208d30a", size = 150864, upload-time = "2025-10-14T04:41:00.623Z" },
    { url = "https://files.pythonhosted.org/packages/05/12/9fbc6a4d39c0198adeebbde20b619790e9236557ca59fc40e0e3cebe6f40/charset_normalizer-3.4.4-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:21d142cc6c0ec30d2efee5068ca36c128a30b0f2c53c1c07bd78cb6bc1d3be5f", size = 150647, upload-time = "2025-10-14T04:41:01.754Z" },
    { url = "https://files.pythonhosted.org/packages/ad/1f/6a9a593d52e3e8c5d2b167daf8c6b968808efb57ef4c210acb907c365bc4/charset_normalizer-3.4.4-cp312-cp312-musllinux_1_2_armv7l.whl", hash = "sha256:5dbe56a36425d26d6cfb40ce79c314a2e4dd6211d51d6d2191c00bed34f354cc", size = 145110, upload-time = "2025-10-14T04:41:03.231Z" },
    { url = "https://files.pythonhosted.org/packages/30/42/9a52c609e72471b0fc54386dc63c3781a387bb4fe61c20231a4ebcd58bdd/charset_normalizer-3.4.4-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:5bfbb1b9acf3334612667b61bd3002196fe2a1eb4dd74d247e0f2a4d50ec9bbf", size = 162839, upload-time = "2025-10-14T04:41:04.715Z" },
    { url = "https://files.pythonhosted.org/packages/c4/5b/c0682bbf9f11597073052628ddd38344a3d673fda35a36773f7d19344b23/charset_normalizer-3.4.4-cp312-cp312-musllinux_1_2_riscv64.whl", hash = "sha256:d055ec1e26e441f6187acf818b73564e6e6282709e9bcb5b63f5b23068356a15", size = 150667, upload-time = "2025-10-14T04:41:05.827Z" },
    { url = "https://files.pythonhosted.org/packages/e4/24/a41afeab6f990cf2daf6cb8c67419b63b48cf518e4f56022230840c9bfb2/charset_normalizer-3.4.4-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:af2d8c67d8e573d6de5bc30cdb27e9b95e49115cd9baad5ddbd1a6207aaa82a9", size = 160535, upload-time = "2025-10-14T04:41:06.938Z" },
    { url = "https://files.pythonhosted.org/packages/2a/e5/6a4ce77ed243c4a50a1fecca6aaaab419628c818a49434be428fe24c9957/charset_normalizer-3.4.4-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:780236ac706e66881f3b7f2f32dfe90507a09e67d1d454c762cf642e6e1586e0", size = 154816, upload-time = "2025-10-14T04:41:08.101Z" },
    { url = "https://files.pythonhosted.org/packages/a8/ef/89297262b8092b312d29cdb2517cb1237e51db8ecef2e9af5edbe7b683b1/charset_normalizer-3.4.4-cp312-cp312-win32.whl", hash = "sha256:5833d2c39d8896e4e19b689ffc198f08ea58116bee26dea51e362ecc7cd3ed26", size = 99694, upload-time = "2025-10-14T04:41:09.23Z" },
    { url = "https://files.pythonhosted.org/packages/3d/2d/1e5ed9dd3b3803994c155cd9aacb60c82c331bad84daf75bcb9c91b3295e/charset_normalizer-3.4.4-cp312-cp312-win_amd64.whl", hash = "sha256:a79cfe37875f822425b89a82333404539ae63dbdddf97f84dcbc3d339aae9525", size = 107131, upload-time = "2025-10-14T04:41:10.467Z" },
    { url = "https://files.pythonhosted.org/packages/d0/d9/0ed4c7098a861482a7b6a95603edce4c0d9db2311af23da1fb2b75ec26fc/charset_normalizer-3.4.4-cp312-cp312-win_arm64.whl", hash = "sha256:376bec83a63b8021bb5c8ea75e21c4ccb86e7e45ca4eb81146091b56599b80c3", size = 100390, upload-time = "2025-10-14T04:41:11.915Z" },
    { url = "https://files.pythonhosted.org/packages/97/45/4b3a1239bbacd321068ea6e7ac28875b03ab8bc0aa0966452db17cd36714/charset_normalizer-3.4.4-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:e1f185f86a6f3403aa2420e815904c67b2f9ebc443f045edd0de921108345794", size = 208091, upload-time = "2025-10-14T04:41:13.346Z" },
    { url = "https://files.pythonhosted.org/packages/7d/62/73a6d7450829655a35bb88a88fca7d736f9882a27eacdca2c6d505b57e2e/charset_normalizer-3.4.4-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:6b39f987ae8ccdf0d2642338faf2abb1862340facc796048b604ef14919e55ed", size = 147936, upload-time = "2025-10-14T04:41:14.461Z" },
    { url = "https://files.pythonhosted.org/packages/89/c5/adb8c8b3d6625bef6d88b251bbb0d95f8205831b987631ab0c8bb5d937c2/charset_normalizer-3.4.4-cp313-cp313-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:3162d5d8ce1bb98dd51af660f2121c55d0fa541b46dff7bb9b9f86ea1d87de72", size = 144180, upload-time = "2025-10-14T04:41:15.588Z" },
    { url = "https://files.pythonhosted.org/packages/91/ed/9706e4070682d1cc219050b6048bfd293ccf67b3d4f5a4f39207453d4b99/charset_normalizer-3.4.4-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:81d5eb2a312700f4ecaa977a8235b634ce853200e828fbadf3a9c50bab278328", size = 161346, upload-time = "2025-10-14T04:41:16.738Z" },
    { url = "https://files.pythonhosted.org/packages/d5/0d/031f0d95e4972901a2f6f09ef055751805ff541511dc1252ba3ca1f80cf5/charset_normalizer-3.4.4-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:5bd2293095d766545ec1a8f612559f6b40abc0eb18bb2f5d1171872d34036ede", size = 158874, upload-time = "2025-10-14T04:41:17.923Z" },
    { url = "https://files.pythonhosted.org/packages/f5/83/6ab5883f57c9c801ce5e5677242328aa45592be8a00644310a008d04f922/charset_normalizer-3.4.4-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:a8a8b89589086a25749f471e6a900d3f662d1d3b6e2e59dcecf787b1cc3a1894", size = 153076, upload-time = "2025-10-14T04:41:19.106Z" },
    { url = "https://files.pythonhosted.org/packages/75/1e/5ff781ddf5260e387d6419959ee89ef13878229732732ee73cdae01800f2/charset_normalizer-3.4.4-cp313-cp313-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:bc7637e2f80d8530ee4a78e878bce464f70087ce73cf7c1caf142416923b98f1", size = 150601, upload-time = "2025-10-14T04:41:20.245Z" },
    { url = "https://files.pythonhosted.org/packages/d7/57/71be810965493d3510a6ca79b90c19e48696fb1ff964da319334b12677f0/charset_normalizer-3.4.4-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:f8bf04158c6b607d747e93949aa60618b61312fe647a6369f88ce2ff16043490", size = 150376, upload-time = "2025-10-14T04:41:21.398Z" },
    { url = "https://files.pythonhosted.org/packages/e5/d5/c3d057a78c181d007014feb7e9f2e65905a6c4ef182c0ddf0de2924edd65/charset_normalizer-3.4.4-cp313-cp313-musllinux_1_2_armv7l.whl", hash = "sha256:554af85e960429cf30784dd47447d5125aaa3b99a6f0683589dbd27e2f45da44", size = 144825, upload-time = "2025-10-14T04:41:22.583Z" },
    { url = "https://files.pythonhosted.org/packages/e6/8c/d0406294828d4976f275ffbe66f00266c4b3136b7506941d87c00cab5272/charset_normalizer-3.4.4-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:74018750915ee7ad843a774364e13a3db91682f26142baddf775342c3f5b1133", size = 162583, upload-time = "2025-10-14T04:41:23.754Z" },
    { url = "https://files.pythonhosted.org/packages/d7/24/e2aa1f18c8f15c4c0e932d9287b8609dd30ad56dbe41d926bd846e22fb8d/charset_normalizer-3.4.4-cp313-cp313-musllinux_1_2_riscv64.whl", hash = "sha256:c0463276121fdee9c49b98908b3a89c39be45d86d1dbaa22957e38f6321d4ce3", size = 150366, upload-time = "2025-10-14T04:41:25.27Z" },
    { url = "https://files.pythonhosted.org/packages/e4/5b/1e6160c7739aad1e2df054300cc618b06bf784a7a164b0f238360721ab86/charset_normalizer-3.4.4-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:362d61fd13843997c1c446760ef36f240cf81d3ebf74ac62652aebaf7838561e", size = 160300, upload-time = "2025-10-14T04:41:26.725Z" },
    { url = "https://files.pythonhosted.org/packages/7a/10/f882167cd207fbdd743e55534d5d9620e095089d176d55cb22d5322f2afd/charset_normalizer-3.4.4-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:9a26f18905b8dd5d685d6d07b0cdf98a79f3c7a918906af7cc143ea2e164c8bc", size = 154465, upload-time = "2025-10-14T04:41:28.322Z" },
    { url = "https://files.pythonhosted.org/packages/89/66/c7a9e1b7429be72123441bfdbaf2bc13faab3f90b933f664db506dea5915/charset_normalizer-3.4.4-cp313-cp313-win32.whl", hash = "sha256:9b35f4c90079ff2e2edc5b26c0c77925e5d2d255c42c74fdb70fb49b172726ac", size = 99404, upload-time = "2025-10-14T04:41:29.95Z" },
    { url = "https://files.pythonhosted.org/packages/c4/26/b9924fa27db384bdcd97ab83b4f0a8058d96ad9626ead570674d5e737d90/charset_normalizer-3.4.4-cp313-cp313-win_amd64.whl", hash = "sha256:b435cba5f4f750aa6c0a0d92c541fb79f69a387c91e61f1795227e4ed9cece14", size = 107092, upload-time = "2025-10-14T04:41:31.188Z" },
    { url = "https://files.pythonhosted.org/packages/af/8f/3ed4bfa0c0c72a7ca17f0380cd9e4dd842b09f664e780c13cff1dcf2ef1b/charset_normalizer-3.4.4-cp313-cp313-win_arm64.whl", hash = "sha256:542d2cee80be6f80247095cc36c418f7bddd14f4a6de45af91dfad36d817bba2", size = 100408, upload-time = "2025-10-14T04:41:32.624Z" },
    { url = "https://files.pythonhosted.org/packages/0a/4c/925909008ed5a988ccbb72dcc897407e5d6d3bd72410d69e051fc0c14647/charset_normalizer-3.4.4-py3-none-any.whl", hash = "sha256:7a32c560861a02ff789ad905a2fe94e3f840803362c84fecf1851cb4cf3dc37f", size = 53402, upload-time = "2025-10-14T04:42:31.76Z" },
]

[[package]]
name = "cigam"
version = "0.0.3"
source = { registry = "https://pypi.org/simple" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/3c/d0/19ff49c1938aea4e0076ee084ca23845408cffb51582b2be975f926533b5/cigam-0.0.3-py3-none-any.whl", hash = "sha256:8fcf65d7361f0372c53780e861307abd1f11a94b6204fa653ba3f38277822783", size = 3788, upload-time = "2018-03-21T03:07:58.247Z" },
]

[[package]]
name = "click"
version = "8.3.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama", marker = "sys_platform == 'win32'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/46/61/de6cd827efad202d7057d93e0fed9294b96952e188f7384832791c7b2254/click-8.3.0.tar.gz", hash = "sha256:e7b8232224eba16f4ebe410c25ced9f7875cb5f3263ffc93cc3e8da705e229c4", size = 276943, upload-time = "2025-09-18T17:32:23.696Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/db/d3/9dcc0f5797f070ec8edf30fbadfb200e71d9db6b84d211e3b2085a7589a0/click-8.3.0-py3-none-any.whl", hash = "sha256:9b9f285302c6e3064f4330c05f05b81945b2a39544279343e6e7c5f27a9baddc", size = 107295, upload-time = "2025-09-18T17:32:22.42Z" },
]

[[package]]
name = "colorama"
version = "0.4.6"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d8/53/6f443c9a4a8358a93a6792e2acffb9d9d5cb0a5cfd8802644b7b1c9a02e4/colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44", size = 27697, upload-time = "2022-10-25T02:36:22.414Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d1/d6/3965ed04c63042e047cb6a3e6ed1a63a35087b6a609aa3a15ed8ac56c221/colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6", size = 25335, upload-time = "2022-10-25T02:36:20.889Z" },
]

[[package]]
name = "cryptography"
version = "46.0.5"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "cffi", marker = "platform_python_implementation != 'PyPy'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/60/04/ee2a9e8542e4fa2773b81771ff8349ff19cdd56b7258a0cc442639052edb/cryptography-46.0.5.tar.gz", hash = "sha256:abace499247268e3757271b2f1e244b36b06f8515cf27c4d49468fc9eb16e93d", size = 750064, upload-time = "2026-02-10T19:18:38.255Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f7/81/b0bb27f2ba931a65409c6b8a8b358a7f03c0e46eceacddff55f7c84b1f3b/cryptography-46.0.5-cp311-abi3-macosx_10_9_universal2.whl", hash = "sha256:351695ada9ea9618b3500b490ad54c739860883df6c1f555e088eaf25b1bbaad", size = 7176289, upload-time = "2026-02-10T19:17:08.274Z" },
    { url = "https://files.pythonhosted.org/packages/ff/9e/6b4397a3e3d15123de3b1806ef342522393d50736c13b20ec4c9ea6693a6/cryptography-46.0.5-cp311-abi3-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:c18ff11e86df2e28854939acde2d003f7984f721eba450b56a200ad90eeb0e6b", size = 4275637, upload-time = "2026-02-10T19:17:10.53Z" },
    { url = "https://files.pythonhosted.org/packages/63/e7/471ab61099a3920b0c77852ea3f0ea611c9702f651600397ac567848b897/cryptography-46.0.5-cp311-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:4d7e3d356b8cd4ea5aff04f129d5f66ebdc7b6f8eae802b93739ed520c47c79b", size = 4424742, upload-time = "2026-02-10T19:17:12.388Z" },
    { url = "https://files.pythonhosted.org/packages/37/53/a18500f270342d66bf7e4d9f091114e31e5ee9e7375a5aba2e85a91e0044/cryptography-46.0.5-cp311-abi3-manylinux_2_28_aarch64.whl", hash = "sha256:50bfb6925eff619c9c023b967d5b77a54e04256c4281b0e21336a130cd7fc263", size = 4277528, upload-time = "2026-02-10T19:17:13.853Z" },
    { url = "https://files.pythonhosted.org/packages/22/29/c2e812ebc38c57b40e7c583895e73c8c5adb4d1e4a0cc4c5a4fdab2b1acc/cryptography-46.0.5-cp311-abi3-manylinux_2_28_ppc64le.whl", hash = "sha256:803812e111e75d1aa73690d2facc295eaefd4439be1023fefc4995eaea2af90d", size = 4947993, upload-time = "2026-02-10T19:17:15.618Z" },
    { url = "https://files.pythonhosted.org/packages/6b/e7/237155ae19a9023de7e30ec64e5d99a9431a567407ac21170a046d22a5a3/cryptography-46.0.5-cp311-abi3-manylinux_2_28_x86_64.whl", hash = "sha256:3ee190460e2fbe447175cda91b88b84ae8322a104fc27766ad09428754a618ed", size = 4456855, upload-time = "2026-02-10T19:17:17.221Z" },
    { url = "https://files.pythonhosted.org/packages/2d/87/fc628a7ad85b81206738abbd213b07702bcbdada1dd43f72236ef3cffbb5/cryptography-46.0.5-cp311-abi3-manylinux_2_31_armv7l.whl", hash = "sha256:f145bba11b878005c496e93e257c1e88f154d278d2638e6450d17e0f31e558d2", size = 3984635, upload-time = "2026-02-10T19:17:18.792Z" },
    { url = "https://files.pythonhosted.org/packages/84/29/65b55622bde135aedf4565dc509d99b560ee4095e56989e815f8fd2aa910/cryptography-46.0.5-cp311-abi3-manylinux_2_34_aarch64.whl", hash = "sha256:e9251e3be159d1020c4030bd2e5f84d6a43fe54b6c19c12f51cde9542a2817b2", size = 4277038, upload-time = "2026-02-10T19:17:20.256Z" },
    { url = "https://files.pythonhosted.org/packages/bc/36/45e76c68d7311432741faf1fbf7fac8a196a0a735ca21f504c75d37e2558/cryptography-46.0.5-cp311-abi3-manylinux_2_34_ppc64le.whl", hash = "sha256:47fb8a66058b80e509c47118ef8a75d14c455e81ac369050f20ba0d23e77fee0", size = 4912181, upload-time = "2026-02-10T19:17:21.825Z" },
    { url = "https://files.pythonhosted.org/packages/6d/1a/c1ba8fead184d6e3d5afcf03d569acac5ad063f3ac9fb7258af158f7e378/cryptography-46.0.5-cp311-abi3-manylinux_2_34_x86_64.whl", hash = "sha256:4c3341037c136030cb46e4b1e17b7418ea4cbd9dd207e4a6f3b2b24e0d4ac731", size = 4456482, upload-time = "2026-02-10T19:17:25.133Z" },
    { url = "https://files.pythonhosted.org/packages/f9/e5/3fb22e37f66827ced3b902cf895e6a6bc1d095b5b26be26bd13c441fdf19/cryptography-46.0.5-cp311-abi3-musllinux_1_2_aarch64.whl", hash = "sha256:890bcb4abd5a2d3f852196437129eb3667d62630333aacc13dfd470fad3aaa82", size = 4405497, upload-time = "2026-02-10T19:17:26.66Z" },
    { url = "https://files.pythonhosted.org/packages/1a/df/9d58bb32b1121a8a2f27383fabae4d63080c7ca60b9b5c88be742be04ee7/cryptography-46.0.5-cp311-abi3-musllinux_1_2_x86_64.whl", hash = "sha256:80a8d7bfdf38f87ca30a5391c0c9ce4ed2926918e017c29ddf643d0ed2778ea1", size = 4667819, upload-time = "2026-02-10T19:17:28.569Z" },
    { url = "https://files.pythonhosted.org/packages/ea/ed/325d2a490c5e94038cdb0117da9397ece1f11201f425c4e9c57fe5b9f08b/cryptography-46.0.5-cp311-abi3-win32.whl", hash = "sha256:60ee7e19e95104d4c03871d7d7dfb3d22ef8a9b9c6778c94e1c8fcc8365afd48", size = 3028230, upload-time = "2026-02-10T19:17:30.518Z" },
    { url = "https://files.pythonhosted.org/packages/e9/5a/ac0f49e48063ab4255d9e3b79f5def51697fce1a95ea1370f03dc9db76f6/cryptography-46.0.5-cp311-abi3-win_amd64.whl", hash = "sha256:38946c54b16c885c72c4f59846be9743d699eee2b69b6988e0a00a01f46a61a4", size = 3480909, upload-time = "2026-02-10T19:17:32.083Z" },
    { url = "https://files.pythonhosted.org/packages/e2/fa/a66aa722105ad6a458bebd64086ca2b72cdd361fed31763d20390f6f1389/cryptography-46.0.5-cp38-abi3-macosx_10_9_universal2.whl", hash = "sha256:4108d4c09fbbf2789d0c926eb4152ae1760d5a2d97612b92d508d96c861e4d31", size = 7170514, upload-time = "2026-02-10T19:17:56.267Z" },
    { url = "https://files.pythonhosted.org/packages/0f/04/c85bdeab78c8bc77b701bf0d9bdcf514c044e18a46dcff330df5448631b0/cryptography-46.0.5-cp38-abi3-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:7d1f30a86d2757199cb2d56e48cce14deddf1f9c95f1ef1b64ee91ea43fe2e18", size = 4275349, upload-time = "2026-02-10T19:17:58.419Z" },
    { url = "https://files.pythonhosted.org/packages/5c/32/9b87132a2f91ee7f5223b091dc963055503e9b442c98fc0b8a5ca765fab0/cryptography-46.0.5-cp38-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:039917b0dc418bb9f6edce8a906572d69e74bd330b0b3fea4f79dab7f8ddd235", size = 4420667, upload-time = "2026-02-10T19:18:00.619Z" },
    { url = "https://files.pythonhosted.org/packages/a1/a6/a7cb7010bec4b7c5692ca6f024150371b295ee1c108bdc1c400e4c44562b/cryptography-46.0.5-cp38-abi3-manylinux_2_28_aarch64.whl", hash = "sha256:ba2a27ff02f48193fc4daeadf8ad2590516fa3d0adeeb34336b96f7fa64c1e3a", size = 4276980, upload-time = "2026-02-10T19:18:02.379Z" },
    { url = "https://files.pythonhosted.org/packages/8e/7c/c4f45e0eeff9b91e3f12dbd0e165fcf2a38847288fcfd889deea99fb7b6d/cryptography-46.0.5-cp38-abi3-manylinux_2_28_ppc64le.whl", hash = "sha256:61aa400dce22cb001a98014f647dc21cda08f7915ceb95df0c9eaf84b4b6af76", size = 4939143, upload-time = "2026-02-10T19:18:03.964Z" },
    { url = "https://files.pythonhosted.org/packages/37/19/e1b8f964a834eddb44fa1b9a9976f4e414cbb7aa62809b6760c8803d22d1/cryptography-46.0.5-cp38-abi3-manylinux_2_28_x86_64.whl", hash = "sha256:3ce58ba46e1bc2aac4f7d9290223cead56743fa6ab94a5d53292ffaac6a91614", size = 4453674, upload-time = "2026-02-10T19:18:05.588Z" },
    { url = "https://files.pythonhosted.org/packages/db/ed/db15d3956f65264ca204625597c410d420e26530c4e2943e05a0d2f24d51/cryptography-46.0.5-cp38-abi3-manylinux_2_31_armv7l.whl", hash = "sha256:420d0e909050490d04359e7fdb5ed7e667ca5c3c402b809ae2563d7e66a92229", size = 3978801, upload-time = "2026-02-10T19:18:07.167Z" },
    { url = "https://files.pythonhosted.org/packages/41/e2/df40a31d82df0a70a0daf69791f91dbb70e47644c58581d654879b382d11/cryptography-46.0.5-cp38-abi3-manylinux_2_34_aarch64.whl", hash = "sha256:582f5fcd2afa31622f317f80426a027f30dc792e9c80ffee87b993200ea115f1", size = 4276755, upload-time = "2026-02-10T19:18:09.813Z" },
    { url = "https://files.pythonhosted.org/packages/33/45/726809d1176959f4a896b86907b98ff4391a8aa29c0aaaf9450a8a10630e/cryptography-46.0.5-cp38-abi3-manylinux_2_34_ppc64le.whl", hash = "sha256:bfd56bb4b37ed4f330b82402f6f435845a5f5648edf1ad497da51a8452d5d62d", size = 4901539, upload-time = "2026-02-10T19:18:11.263Z" },
    { url = "https://files.pythonhosted.org/packages/99/0f/a3076874e9c88ecb2ecc31382f6e7c21b428ede6f55aafa1aa272613e3cd/cryptography-46.0.5-cp38-abi3-manylinux_2_34_x86_64.whl", hash = "sha256:a3d507bb6a513ca96ba84443226af944b0f7f47dcc9a399d110cd6146481d24c", size = 4452794, upload-time = "2026-02-10T19:18:12.914Z" },
    { url = "https://files.pythonhosted.org/packages/02/ef/ffeb542d3683d24194a38f66ca17c0a4b8bf10631feef44a7ef64e631b1a/cryptography-46.0.5-cp38-abi3-musllinux_1_2_aarch64.whl", hash = "sha256:9f16fbdf4da055efb21c22d81b89f155f02ba420558db21288b3d0035bafd5f4", size = 4404160, upload-time = "2026-02-10T19:18:14.375Z" },
    { url = "https://files.pythonhosted.org/packages/96/93/682d2b43c1d5f1406ed048f377c0fc9fc8f7b0447a478d5c65ab3d3a66eb/cryptography-46.0.5-cp38-abi3-musllinux_1_2_x86_64.whl", hash = "sha256:ced80795227d70549a411a4ab66e8ce307899fad2220ce5ab2f296e687eacde9", size = 4667123, upload-time = "2026-02-10T19:18:15.886Z" },
    { url = "https://files.pythonhosted.org/packages/45/2d/9c5f2926cb5300a8eefc3f4f0b3f3df39db7f7ce40c8365444c49363cbda/cryptography-46.0.5-cp38-abi3-win32.whl", hash = "sha256:02f547fce831f5096c9a567fd41bc12ca8f11df260959ecc7c3202555cc47a72", size = 3010220, upload-time = "2026-02-10T19:18:17.361Z" },
    { url = "https://files.pythonhosted.org/packages/48/ef/0c2f4a8e31018a986949d34a01115dd057bf536905dca38897bacd21fac3/cryptography-46.0.5-cp38-abi3-win_amd64.whl", hash = "sha256:556e106ee01aa13484ce9b0239bca667be5004efb0aabbed28d353df86445595", size = 3467050, upload-time = "2026-02-10T19:18:18.899Z" },
    { url = "https://files.pythonhosted.org/packages/eb/dd/2d9fdb07cebdf3d51179730afb7d5e576153c6744c3ff8fded23030c204e/cryptography-46.0.5-pp311-pypy311_pp73-macosx_11_0_arm64.whl", hash = "sha256:3b4995dc971c9fb83c25aa44cf45f02ba86f71ee600d81091c2f0cbae116b06c", size = 3476964, upload-time = "2026-02-10T19:18:20.687Z" },
    { url = "https://files.pythonhosted.org/packages/e9/6f/6cc6cc9955caa6eaf83660b0da2b077c7fe8ff9950a3c5e45d605038d439/cryptography-46.0.5-pp311-pypy311_pp73-manylinux_2_28_aarch64.whl", hash = "sha256:bc84e875994c3b445871ea7181d424588171efec3e185dced958dad9e001950a", size = 4218321, upload-time = "2026-02-10T19:18:22.349Z" },
    { url = "https://files.pythonhosted.org/packages/3e/5d/c4da701939eeee699566a6c1367427ab91a8b7088cc2328c09dbee940415/cryptography-46.0.5-pp311-pypy311_pp73-manylinux_2_28_x86_64.whl", hash = "sha256:2ae6971afd6246710480e3f15824ed3029a60fc16991db250034efd0b9fb4356", size = 4381786, upload-time = "2026-02-10T19:18:24.529Z" },
    { url = "https://files.pythonhosted.org/packages/ac/97/a538654732974a94ff96c1db621fa464f455c02d4bb7d2652f4edc21d600/cryptography-46.0.5-pp311-pypy311_pp73-manylinux_2_34_aarch64.whl", hash = "sha256:d861ee9e76ace6cf36a6a89b959ec08e7bc2493ee39d07ffe5acb23ef46d27da", size = 4217990, upload-time = "2026-02-10T19:18:25.957Z" },
    { url = "https://files.pythonhosted.org/packages/ae/11/7e500d2dd3ba891197b9efd2da5454b74336d64a7cc419aa7327ab74e5f6/cryptography-46.0.5-pp311-pypy311_pp73-manylinux_2_34_x86_64.whl", hash = "sha256:2b7a67c9cd56372f3249b39699f2ad479f6991e62ea15800973b956f4b73e257", size = 4381252, upload-time = "2026-02-10T19:18:27.496Z" },
    { url = "https://files.pythonhosted.org/packages/bc/58/6b3d24e6b9bc474a2dcdee65dfd1f008867015408a271562e4b690561a4d/cryptography-46.0.5-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:8456928655f856c6e1533ff59d5be76578a7157224dbd9ce6872f25055ab9ab7", size = 3407605, upload-time = "2026-02-10T19:18:29.233Z" },
]

[[package]]
name = "dataclasses-json"
version = "0.6.7"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "marshmallow" },
    { name = "typing-inspect" },
]
sdist = { url = "https://files.pythonhosted.org/packages/64/a4/f71d9cf3a5ac257c993b5ca3f93df5f7fb395c725e7f1e6479d2514173c3/dataclasses_json-0.6.7.tar.gz", hash = "sha256:b6b3e528266ea45b9535223bc53ca645f5208833c29229e847b3f26a1cc55fc0", size = 32227, upload-time = "2024-06-09T16:20:19.103Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c3/be/d0d44e092656fe7a06b55e6103cbce807cdbdee17884a5367c68c9860853/dataclasses_json-0.6.7-py3-none-any.whl", hash = "sha256:0dbf33f26c8d5305befd61b39d2b3414e8a407bedc2834dea9b8d642666fb40a", size = 28686, upload-time = "2024-06-09T16:20:16.715Z" },
]

[[package]]
name = "decorator"
version = "5.2.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/43/fa/6d96a0978d19e17b68d634497769987b16c8f4cd0a7a05048bec693caa6b/decorator-5.2.1.tar.gz", hash = "sha256:65f266143752f734b0a7cc83c46f4618af75b8c5911b00ccb61d0ac9b6da0360", size = 56711, upload-time = "2025-02-24T04:41:34.073Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4e/8c/f3147f5c4b73e7550fe5f9352eaa956ae838d5c51eb58e7a25b9f3e2643b/decorator-5.2.1-py3-none-any.whl", hash = "sha256:d316bb415a2d9e2d2b3abcc4084c6502fc09240e292cd76a76afc106a1c8e04a", size = 9190, upload-time = "2025-02-24T04:41:32.565Z" },
]

[[package]]
name = "defusedxml"
version = "0.7.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/0f/d5/c66da9b79e5bdb124974bfe172b4daf3c984ebd9c2a06e2b8a4dc7331c72/defusedxml-0.7.1.tar.gz", hash = "sha256:1bb3032db185915b62d7c6209c5a8792be6a32ab2fedacc84e01b52c51aa3e69", size = 75520, upload-time = "2021-03-08T10:59:26.269Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/07/6c/aa3f2f849e01cb6a001cd8554a88d4c77c5c1a31c95bdf1cf9301e6d9ef4/defusedxml-0.7.1-py2.py3-none-any.whl", hash = "sha256:a352e7e428770286cc899e2542b6cdaedb2b4953ff269a210103ec58f6198a61", size = 25604, upload-time = "2021-03-08T10:59:24.45Z" },
]

[[package]]
name = "deprecated"
version = "1.2.18"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "wrapt" },
]
sdist = { url = "https://files.pythonhosted.org/packages/98/97/06afe62762c9a8a86af0cfb7bfdab22a43ad17138b07af5b1a58442690a2/deprecated-1.2.18.tar.gz", hash = "sha256:422b6f6d859da6f2ef57857761bfb392480502a64c3028ca9bbe86085d72115d", size = 2928744, upload-time = "2025-01-27T10:46:25.7Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6e/c6/ac0b6c1e2d138f1002bcf799d330bd6d85084fece321e662a14223794041/Deprecated-1.2.18-py2.py3-none-any.whl", hash = "sha256:bd5011788200372a32418f888e326a09ff80d0214bd961147cfed01b5c018eec", size = 9998, upload-time = "2025-01-27T10:46:09.186Z" },
]

[[package]]
name = "dirtyjson"
version = "1.0.8"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/db/04/d24f6e645ad82ba0ef092fa17d9ef7a21953781663648a01c9371d9e8e98/dirtyjson-1.0.8.tar.gz", hash = "sha256:90ca4a18f3ff30ce849d100dcf4a003953c79d3a2348ef056f1d9c22231a25fd", size = 30782, upload-time = "2022-11-28T23:32:33.319Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/68/69/1bcf70f81de1b4a9f21b3a62ec0c83bdff991c88d6cc2267d02408457e88/dirtyjson-1.0.8-py3-none-any.whl", hash = "sha256:125e27248435a58acace26d5c2c4c11a1c0de0a9c5124c5a94ba78e517d74f53", size = 25197, upload-time = "2022-11-28T23:32:31.219Z" },
]

[[package]]
name = "distro"
version = "1.9.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/fc/f8/98eea607f65de6527f8a2e8885fc8015d3e6f5775df186e443e0964a11c3/distro-1.9.0.tar.gz", hash = "sha256:2fa77c6fd8940f116ee1d6b94a2f90b13b5ea8d019b98bc8bafdcabcdd9bdbed", size = 60722, upload-time = "2023-12-24T09:54:32.31Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/12/b3/231ffd4ab1fc9d679809f356cebee130ac7daa00d6d6f3206dd4fd137e9e/distro-1.9.0-py3-none-any.whl", hash = "sha256:7bffd925d65168f85027d8da9af6bddab658135b840670a223589bc0c8ef02b2", size = 20277, upload-time = "2023-12-24T09:54:30.421Z" },
]

[[package]]
name = "dnspython"
version = "2.8.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/8c/8b/57666417c0f90f08bcafa776861060426765fdb422eb10212086fb811d26/dnspython-2.8.0.tar.gz", hash = "sha256:181d3c6996452cb1189c4046c61599b84a5a86e099562ffde77d26984ff26d0f", size = 368251, upload-time = "2025-09-07T18:58:00.022Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ba/5a/18ad964b0086c6e62e2e7500f7edc89e3faa45033c71c1893d34eed2b2de/dnspython-2.8.0-py3-none-any.whl", hash = "sha256:01d9bbc4a2d76bf0db7c1f729812ded6d912bd318d3b1cf81d30c0f845dbf3af", size = 331094, upload-time = "2025-09-07T18:57:58.071Z" },
]

[[package]]
name = "docstring-parser"
version = "0.17.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b2/9d/c3b43da9515bd270df0f80548d9944e389870713cc1fe2b8fb35fe2bcefd/docstring_parser-0.17.0.tar.gz", hash = "sha256:583de4a309722b3315439bb31d64ba3eebada841f2e2cee23b99df001434c912", size = 27442, upload-time = "2025-07-21T07:35:01.868Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/55/e2/2537ebcff11c1ee1ff17d8d0b6f4db75873e3b0fb32c2d4a2ee31ecb310a/docstring_parser-0.17.0-py3-none-any.whl", hash = "sha256:cf2569abd23dce8099b300f9b4fa8191e9582dda731fd533daf54c4551658708", size = 36896, upload-time = "2025-07-21T07:35:00.684Z" },
]

[[package]]
name = "dparse"
version = "0.6.4"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "packaging" },
]
sdist = { url = "https://files.pythonhosted.org/packages/29/ee/96c65e17222b973f0d3d0aa9bad6a59104ca1b0eb5b659c25c2900fccd85/dparse-0.6.4.tar.gz", hash = "sha256:90b29c39e3edc36c6284c82c4132648eaf28a01863eb3c231c2512196132201a", size = 27912, upload-time = "2024-11-08T16:52:06.444Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/56/26/035d1c308882514a1e6ddca27f9d3e570d67a0e293e7b4d910a70c8fe32b/dparse-0.6.4-py3-none-any.whl", hash = "sha256:fbab4d50d54d0e739fbb4dedfc3d92771003a5b9aa8545ca7a7045e3b174af57", size = 11925, upload-time = "2024-11-08T16:52:03.844Z" },
]

[[package]]
name = "droidrun"
version = "0.5.0.dev6"
source = { editable = "." }
dependencies = [
    { name = "aiofiles" },
    { name = "arize-phoenix" },
    { name = "async-adbutils" },
    { name = "httpx" },
    { name = "llama-index" },
    { name = "llama-index-callbacks-arize-phoenix" },
    { name = "llama-index-llms-google-genai" },
    { name = "llama-index-llms-ollama" },
    { name = "llama-index-llms-openai" },
    { name = "llama-index-llms-openai-like" },
    { name = "llama-index-llms-openrouter" },
    { name = "llama-index-workflows" },
    { name = "mcp" },
    { name = "mobilerun-sdk" },
    { name = "posthog" },
    { name = "pydantic" },
    { name = "python-dotenv" },
    { name = "rich" },
    { name = "textual" },
]

[package.optional-dependencies]
anthropic = [
    { name = "anthropic" },
    { name = "llama-index-llms-anthropic" },
]
deepseek = [
    { name = "llama-index-llms-deepseek" },
]
dev = [
    { name = "bandit" },
    { name = "black" },
    { name = "langfuse" },
    { name = "llama-index-instrumentation" },
    { name = "mypy" },
    { name = "openinference-instrumentation-llama-index" },
    { name = "ruff" },
    { name = "safety" },
]
langfuse = [
    { name = "langfuse" },
    { name = "llama-index-instrumentation" },
    { name = "openinference-instrumentation-llama-index" },
]

[package.dev-dependencies]
dev = [
    { name = "arize-phoenix" },
    { name = "bandit" },
    { name = "llama-index-callbacks-arize-phoenix" },
    { name = "ruff" },
    { name = "safety" },
]

[package.metadata]
requires-dist = [
    { name = "aiofiles", specifier = ">=25.1.0" },
    { name = "anthropic", marker = "extra == 'anthropic'", specifier = ">=0.67.0" },
    { name = "arize-phoenix", specifier = ">=12.3.0" },
    { name = "async-adbutils" },
    { name = "bandit", marker = "extra == 'dev'", specifier = ">=1.8.6" },
    { name = "black", marker = "extra == 'dev'", specifier = "==25.9.0" },
    { name = "droidrun", extras = ["langfuse"], marker = "extra == 'dev'" },
    { name = "httpx", specifier = ">=0.27.0" },
    { name = "langfuse", marker = "extra == 'langfuse'", specifier = "==3.12.1" },
    { name = "llama-index", specifier = "==0.14.4" },
    { name = "llama-index-callbacks-arize-phoenix", specifier = ">=0.6.1" },
    { name = "llama-index-instrumentation", marker = "extra == 'langfuse'" },
    { name = "llama-index-llms-anthropic", marker = "extra == 'anthropic'", specifier = ">=0.8.6,<0.9.0" },
    { name = "llama-index-llms-deepseek", marker = "extra == 'deepseek'", specifier = ">=0.2.1" },
    { name = "llama-index-llms-google-genai", specifier = ">=0.8.5" },
    { name = "llama-index-llms-ollama", specifier = ">=0.7.2" },
    { name = "llama-index-llms-openai", specifier = ">=0.5.6" },
    { name = "llama-index-llms-openai-like", specifier = ">=0.5.1" },
    { name = "llama-index-llms-openrouter", specifier = ">=0.4.2" },
    { name = "llama-index-workflows", specifier = "==2.8.3" },
    { name = "mcp", specifier = ">=1.26.0" },
    { name = "mobilerun-sdk" },
    { name = "mypy", marker = "extra == 'dev'", specifier = ">=1.0.0" },
    { name = "openinference-instrumentation-llama-index", marker = "extra == 'langfuse'", specifier = ">=3.0.0" },
    { name = "posthog", specifier = ">=6.7.6" },
    { name = "pydantic", specifier = ">=2.11.10" },
    { name = "python-dotenv", specifier = ">=1.2.1" },
    { name = "rich", specifier = ">=14.1.0" },
    { name = "ruff", marker = "extra == 'dev'", specifier = ">=0.13.0" },
    { name = "safety", marker = "extra == 'dev'", specifier = ">=3.2.11" },
    { name = "textual", specifier = ">=6.11.0" },
]
provides-extras = ["anthropic", "deepseek", "dev", "langfuse"]

[package.metadata.requires-dev]
dev = [
    { name = "arize-phoenix", specifier = ">=11.32.1" },
    { name = "bandit", specifier = ">=1.8.6" },
    { name = "llama-index-callbacks-arize-phoenix", specifier = ">=0.6.1" },
    { name = "ruff", specifier = ">=0.13.0" },
    { name = "safety", specifier = ">=3.2.11" },
]

[[package]]
name = "email-validator"
version = "2.3.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "dnspython" },
    { name = "idna" },
]
sdist = { url = "https://files.pythonhosted.org/packages/f5/22/900cb125c76b7aaa450ce02fd727f452243f2e91a61af068b40adba60ea9/email_validator-2.3.0.tar.gz", hash = "sha256:9fc05c37f2f6cf439ff414f8fc46d917929974a82244c20eb10231ba60c54426", size = 51238, upload-time = "2025-08-26T13:09:06.831Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/de/15/545e2b6cf2e3be84bc1ed85613edd75b8aea69807a71c26f4ca6a9258e82/email_validator-2.3.0-py3-none-any.whl", hash = "sha256:80f13f623413e6b197ae73bb10bf4eb0908faf509ad8362c5edeb0be7fd450b4", size = 35604, upload-time = "2025-08-26T13:09:05.858Z" },
]

[[package]]
name = "fastapi"
version = "0.121.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "annotated-doc" },
    { name = "pydantic" },
    { name = "starlette" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/8c/e3/77a2df0946703973b9905fd0cde6172c15e0781984320123b4f5079e7113/fastapi-0.121.0.tar.gz", hash = "sha256:06663356a0b1ee93e875bbf05a31fb22314f5bed455afaaad2b2dad7f26e98fa", size = 342412, upload-time = "2025-11-03T10:25:54.818Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/dd/2c/42277afc1ba1a18f8358561eee40785d27becab8f80a1f945c0a3051c6eb/fastapi-0.121.0-py3-none-any.whl", hash = "sha256:8bdf1b15a55f4e4b0d6201033da9109ea15632cb76cf156e7b8b4019f2172106", size = 109183, upload-time = "2025-11-03T10:25:53.27Z" },
]

[[package]]
name = "filelock"
version = "3.24.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/02/a8/dae62680be63cbb3ff87cfa2f51cf766269514ea5488479d42fec5aa6f3a/filelock-3.24.2.tar.gz", hash = "sha256:c22803117490f156e59fafce621f0550a7a853e2bbf4f87f112b11d469b6c81b", size = 37601, upload-time = "2026-02-16T02:50:45.614Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e7/04/a94ebfb4eaaa08db56725a40de2887e95de4e8641b9e902c311bfa00aa39/filelock-3.24.2-py3-none-any.whl", hash = "sha256:667d7dc0b7d1e1064dd5f8f8e80bdac157a6482e8d2e02cd16fd3b6b33bd6556", size = 24152, upload-time = "2026-02-16T02:50:44Z" },
]

[[package]]
name = "filetype"
version = "1.2.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/bb/29/745f7d30d47fe0f251d3ad3dc2978a23141917661998763bebb6da007eb1/filetype-1.2.0.tar.gz", hash = "sha256:66b56cd6474bf41d8c54660347d37afcc3f7d1970648de365c102ef77548aadb", size = 998020, upload-time = "2022-11-02T17:34:04.141Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/18/79/1b8fa1bb3568781e84c9200f951c735f3f157429f44be0495da55894d620/filetype-1.2.0-py2.py3-none-any.whl", hash = "sha256:7ce71b6880181241cf7ac8697a2f1eb6a8bd9b429f7ad6d27b8db9ba5f1c2d25", size = 19970, upload-time = "2022-11-02T17:34:01.425Z" },
]

[[package]]
name = "frozenlist"
version = "1.8.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/2d/f5/c831fac6cc817d26fd54c7eaccd04ef7e0288806943f7cc5bbf69f3ac1f0/frozenlist-1.8.0.tar.gz", hash = "sha256:3ede829ed8d842f6cd48fc7081d7a41001a56f1f38603f9d49bf3020d59a31ad", size = 45875, upload-time = "2025-10-06T05:38:17.865Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/bc/03/077f869d540370db12165c0aa51640a873fb661d8b315d1d4d67b284d7ac/frozenlist-1.8.0-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:09474e9831bc2b2199fad6da3c14c7b0fbdd377cce9d3d77131be28906cb7d84", size = 86912, upload-time = "2025-10-06T05:35:45.98Z" },
    { url = "https://files.pythonhosted.org/packages/df/b5/7610b6bd13e4ae77b96ba85abea1c8cb249683217ef09ac9e0ae93f25a91/frozenlist-1.8.0-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:17c883ab0ab67200b5f964d2b9ed6b00971917d5d8a92df149dc2c9779208ee9", size = 50046, upload-time = "2025-10-06T05:35:47.009Z" },
    { url = "https://files.pythonhosted.org/packages/6e/ef/0e8f1fe32f8a53dd26bdd1f9347efe0778b0fddf62789ea683f4cc7d787d/frozenlist-1.8.0-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:fa47e444b8ba08fffd1c18e8cdb9a75db1b6a27f17507522834ad13ed5922b93", size = 50119, upload-time = "2025-10-06T05:35:48.38Z" },
    { url = "https://files.pythonhosted.org/packages/11/b1/71a477adc7c36e5fb628245dfbdea2166feae310757dea848d02bd0689fd/frozenlist-1.8.0-cp311-cp311-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl", hash = "sha256:2552f44204b744fba866e573be4c1f9048d6a324dfe14475103fd51613eb1d1f", size = 231067, upload-time = "2025-10-06T05:35:49.97Z" },
    { url = "https://files.pythonhosted.org/packages/45/7e/afe40eca3a2dc19b9904c0f5d7edfe82b5304cb831391edec0ac04af94c2/frozenlist-1.8.0-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:957e7c38f250991e48a9a73e6423db1bb9dd14e722a10f6b8bb8e16a0f55f695", size = 233160, upload-time = "2025-10-06T05:35:51.729Z" },
    { url = "https://files.pythonhosted.org/packages/a6/aa/7416eac95603ce428679d273255ffc7c998d4132cfae200103f164b108aa/frozenlist-1.8.0-cp311-cp311-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:8585e3bb2cdea02fc88ffa245069c36555557ad3609e83be0ec71f54fd4abb52", size = 228544, upload-time = "2025-10-06T05:35:53.246Z" },
    { url = "https://files.pythonhosted.org/packages/8b/3d/2a2d1f683d55ac7e3875e4263d28410063e738384d3adc294f5ff3d7105e/frozenlist-1.8.0-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:edee74874ce20a373d62dc28b0b18b93f645633c2943fd90ee9d898550770581", size = 243797, upload-time = "2025-10-06T05:35:54.497Z" },
    { url = "https://files.pythonhosted.org/packages/78/1e/2d5565b589e580c296d3bb54da08d206e797d941a83a6fdea42af23be79c/frozenlist-1.8.0-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:c9a63152fe95756b85f31186bddf42e4c02c6321207fd6601a1c89ebac4fe567", size = 247923, upload-time = "2025-10-06T05:35:55.861Z" },
    { url = "https://files.pythonhosted.org/packages/aa/c3/65872fcf1d326a7f101ad4d86285c403c87be7d832b7470b77f6d2ed5ddc/frozenlist-1.8.0-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:b6db2185db9be0a04fecf2f241c70b63b1a242e2805be291855078f2b404dd6b", size = 230886, upload-time = "2025-10-06T05:35:57.399Z" },
    { url = "https://files.pythonhosted.org/packages/a0/76/ac9ced601d62f6956f03cc794f9e04c81719509f85255abf96e2510f4265/frozenlist-1.8.0-cp311-cp311-musllinux_1_2_armv7l.whl", hash = "sha256:f4be2e3d8bc8aabd566f8d5b8ba7ecc09249d74ba3c9ed52e54dc23a293f0b92", size = 245731, upload-time = "2025-10-06T05:35:58.563Z" },
    { url = "https://files.pythonhosted.org/packages/b9/49/ecccb5f2598daf0b4a1415497eba4c33c1e8ce07495eb07d2860c731b8d5/frozenlist-1.8.0-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:c8d1634419f39ea6f5c427ea2f90ca85126b54b50837f31497f3bf38266e853d", size = 241544, upload-time = "2025-10-06T05:35:59.719Z" },
    { url = "https://files.pythonhosted.org/packages/53/4b/ddf24113323c0bbcc54cb38c8b8916f1da7165e07b8e24a717b4a12cbf10/frozenlist-1.8.0-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:1a7fa382a4a223773ed64242dbe1c9c326ec09457e6b8428efb4118c685c3dfd", size = 241806, upload-time = "2025-10-06T05:36:00.959Z" },
    { url = "https://files.pythonhosted.org/packages/a7/fb/9b9a084d73c67175484ba2789a59f8eebebd0827d186a8102005ce41e1ba/frozenlist-1.8.0-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:11847b53d722050808926e785df837353bd4d75f1d494377e59b23594d834967", size = 229382, upload-time = "2025-10-06T05:36:02.22Z" },
    { url = "https://files.pythonhosted.org/packages/95/a3/c8fb25aac55bf5e12dae5c5aa6a98f85d436c1dc658f21c3ac73f9fa95e5/frozenlist-1.8.0-cp311-cp311-win32.whl", hash = "sha256:27c6e8077956cf73eadd514be8fb04d77fc946a7fe9f7fe167648b0b9085cc25", size = 39647, upload-time = "2025-10-06T05:36:03.409Z" },
    { url = "https://files.pythonhosted.org/packages/0a/f5/603d0d6a02cfd4c8f2a095a54672b3cf967ad688a60fb9faf04fc4887f65/frozenlist-1.8.0-cp311-cp311-win_amd64.whl", hash = "sha256:ac913f8403b36a2c8610bbfd25b8013488533e71e62b4b4adce9c86c8cea905b", size = 44064, upload-time = "2025-10-06T05:36:04.368Z" },
    { url = "https://files.pythonhosted.org/packages/5d/16/c2c9ab44e181f043a86f9a8f84d5124b62dbcb3a02c0977ec72b9ac1d3e0/frozenlist-1.8.0-cp311-cp311-win_arm64.whl", hash = "sha256:d4d3214a0f8394edfa3e303136d0575eece0745ff2b47bd2cb2e66dd92d4351a", size = 39937, upload-time = "2025-10-06T05:36:05.669Z" },
    { url = "https://files.pythonhosted.org/packages/69/29/948b9aa87e75820a38650af445d2ef2b6b8a6fab1a23b6bb9e4ef0be2d59/frozenlist-1.8.0-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:78f7b9e5d6f2fdb88cdde9440dc147259b62b9d3b019924def9f6478be254ac1", size = 87782, upload-time = "2025-10-06T05:36:06.649Z" },
    { url = "https://files.pythonhosted.org/packages/64/80/4f6e318ee2a7c0750ed724fa33a4bdf1eacdc5a39a7a24e818a773cd91af/frozenlist-1.8.0-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:229bf37d2e4acdaf808fd3f06e854a4a7a3661e871b10dc1f8f1896a3b05f18b", size = 50594, upload-time = "2025-10-06T05:36:07.69Z" },
    { url = "https://files.pythonhosted.org/packages/2b/94/5c8a2b50a496b11dd519f4a24cb5496cf125681dd99e94c604ccdea9419a/frozenlist-1.8.0-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:f833670942247a14eafbb675458b4e61c82e002a148f49e68257b79296e865c4", size = 50448, upload-time = "2025-10-06T05:36:08.78Z" },
    { url = "https://files.pythonhosted.org/packages/6a/bd/d91c5e39f490a49df14320f4e8c80161cfcce09f1e2cde1edd16a551abb3/frozenlist-1.8.0-cp312-cp312-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl", hash = "sha256:494a5952b1c597ba44e0e78113a7266e656b9794eec897b19ead706bd7074383", size = 242411, upload-time = "2025-10-06T05:36:09.801Z" },
    { url = "https://files.pythonhosted.org/packages/8f/83/f61505a05109ef3293dfb1ff594d13d64a2324ac3482be2cedc2be818256/frozenlist-1.8.0-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:96f423a119f4777a4a056b66ce11527366a8bb92f54e541ade21f2374433f6d4", size = 243014, upload-time = "2025-10-06T05:36:11.394Z" },
    { url = "https://files.pythonhosted.org/packages/d8/cb/cb6c7b0f7d4023ddda30cf56b8b17494eb3a79e3fda666bf735f63118b35/frozenlist-1.8.0-cp312-cp312-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:3462dd9475af2025c31cc61be6652dfa25cbfb56cbbf52f4ccfe029f38decaf8", size = 234909, upload-time = "2025-10-06T05:36:12.598Z" },
    { url = "https://files.pythonhosted.org/packages/31/c5/cd7a1f3b8b34af009fb17d4123c5a778b44ae2804e3ad6b86204255f9ec5/frozenlist-1.8.0-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:c4c800524c9cd9bac5166cd6f55285957fcfc907db323e193f2afcd4d9abd69b", size = 250049, upload-time = "2025-10-06T05:36:14.065Z" },
    { url = "https://files.pythonhosted.org/packages/c0/01/2f95d3b416c584a1e7f0e1d6d31998c4a795f7544069ee2e0962a4b60740/frozenlist-1.8.0-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:d6a5df73acd3399d893dafc71663ad22534b5aa4f94e8a2fabfe856c3c1b6a52", size = 256485, upload-time = "2025-10-06T05:36:15.39Z" },
    { url = "https://files.pythonhosted.org/packages/ce/03/024bf7720b3abaebcff6d0793d73c154237b85bdf67b7ed55e5e9596dc9a/frozenlist-1.8.0-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:405e8fe955c2280ce66428b3ca55e12b3c4e9c336fb2103a4937e891c69a4a29", size = 237619, upload-time = "2025-10-06T05:36:16.558Z" },
    { url = "https://files.pythonhosted.org/packages/69/fa/f8abdfe7d76b731f5d8bd217827cf6764d4f1d9763407e42717b4bed50a0/frozenlist-1.8.0-cp312-cp312-musllinux_1_2_armv7l.whl", hash = "sha256:908bd3f6439f2fef9e85031b59fd4f1297af54415fb60e4254a95f75b3cab3f3", size = 250320, upload-time = "2025-10-06T05:36:17.821Z" },
    { url = "https://files.pythonhosted.org/packages/f5/3c/b051329f718b463b22613e269ad72138cc256c540f78a6de89452803a47d/frozenlist-1.8.0-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:294e487f9ec720bd8ffcebc99d575f7eff3568a08a253d1ee1a0378754b74143", size = 246820, upload-time = "2025-10-06T05:36:19.046Z" },
    { url = "https://files.pythonhosted.org/packages/0f/ae/58282e8f98e444b3f4dd42448ff36fa38bef29e40d40f330b22e7108f565/frozenlist-1.8.0-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:74c51543498289c0c43656701be6b077f4b265868fa7f8a8859c197006efb608", size = 250518, upload-time = "2025-10-06T05:36:20.763Z" },
    { url = "https://files.pythonhosted.org/packages/8f/96/007e5944694d66123183845a106547a15944fbbb7154788cbf7272789536/frozenlist-1.8.0-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:776f352e8329135506a1d6bf16ac3f87bc25b28e765949282dcc627af36123aa", size = 239096, upload-time = "2025-10-06T05:36:22.129Z" },
    { url = "https://files.pythonhosted.org/packages/66/bb/852b9d6db2fa40be96f29c0d1205c306288f0684df8fd26ca1951d461a56/frozenlist-1.8.0-cp312-cp312-win32.whl", hash = "sha256:433403ae80709741ce34038da08511d4a77062aa924baf411ef73d1146e74faf", size = 39985, upload-time = "2025-10-06T05:36:23.661Z" },
    { url = "https://files.pythonhosted.org/packages/b8/af/38e51a553dd66eb064cdf193841f16f077585d4d28394c2fa6235cb41765/frozenlist-1.8.0-cp312-cp312-win_amd64.whl", hash = "sha256:34187385b08f866104f0c0617404c8eb08165ab1272e884abc89c112e9c00746", size = 44591, upload-time = "2025-10-06T05:36:24.958Z" },
    { url = "https://files.pythonhosted.org/packages/a7/06/1dc65480ab147339fecc70797e9c2f69d9cea9cf38934ce08df070fdb9cb/frozenlist-1.8.0-cp312-cp312-win_arm64.whl", hash = "sha256:fe3c58d2f5db5fbd18c2987cba06d51b0529f52bc3a6cdc33d3f4eab725104bd", size = 40102, upload-time = "2025-10-06T05:36:26.333Z" },
    { url = "https://files.pythonhosted.org/packages/2d/40/0832c31a37d60f60ed79e9dfb5a92e1e2af4f40a16a29abcc7992af9edff/frozenlist-1.8.0-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:8d92f1a84bb12d9e56f818b3a746f3efba93c1b63c8387a73dde655e1e42282a", size = 85717, upload-time = "2025-10-06T05:36:27.341Z" },
    { url = "https://files.pythonhosted.org/packages/30/ba/b0b3de23f40bc55a7057bd38434e25c34fa48e17f20ee273bbde5e0650f3/frozenlist-1.8.0-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:96153e77a591c8adc2ee805756c61f59fef4cf4073a9275ee86fe8cba41241f7", size = 49651, upload-time = "2025-10-06T05:36:28.855Z" },
    { url = "https://files.pythonhosted.org/packages/0c/ab/6e5080ee374f875296c4243c381bbdef97a9ac39c6e3ce1d5f7d42cb78d6/frozenlist-1.8.0-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:f21f00a91358803399890ab167098c131ec2ddd5f8f5fd5fe9c9f2c6fcd91e40", size = 49417, upload-time = "2025-10-06T05:36:29.877Z" },
    { url = "https://files.pythonhosted.org/packages/d5/4e/e4691508f9477ce67da2015d8c00acd751e6287739123113a9fca6f1604e/frozenlist-1.8.0-cp313-cp313-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl", hash = "sha256:fb30f9626572a76dfe4293c7194a09fb1fe93ba94c7d4f720dfae3b646b45027", size = 234391, upload-time = "2025-10-06T05:36:31.301Z" },
    { url = "https://files.pythonhosted.org/packages/40/76/c202df58e3acdf12969a7895fd6f3bc016c642e6726aa63bd3025e0fc71c/frozenlist-1.8.0-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:eaa352d7047a31d87dafcacbabe89df0aa506abb5b1b85a2fb91bc3faa02d822", size = 233048, upload-time = "2025-10-06T05:36:32.531Z" },
    { url = "https://files.pythonhosted.org/packages/f9/c0/8746afb90f17b73ca5979c7a3958116e105ff796e718575175319b5bb4ce/frozenlist-1.8.0-cp313-cp313-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:03ae967b4e297f58f8c774c7eabcce57fe3c2434817d4385c50661845a058121", size = 226549, upload-time = "2025-10-06T05:36:33.706Z" },
    { url = "https://files.pythonhosted.org/packages/7e/eb/4c7eefc718ff72f9b6c4893291abaae5fbc0c82226a32dcd8ef4f7a5dbef/frozenlist-1.8.0-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:f6292f1de555ffcc675941d65fffffb0a5bcd992905015f85d0592201793e0e5", size = 239833, upload-time = "2025-10-06T05:36:34.947Z" },
    { url = "https://files.pythonhosted.org/packages/c2/4e/e5c02187cf704224f8b21bee886f3d713ca379535f16893233b9d672ea71/frozenlist-1.8.0-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:29548f9b5b5e3460ce7378144c3010363d8035cea44bc0bf02d57f5a685e084e", size = 245363, upload-time = "2025-10-06T05:36:36.534Z" },
    { url = "https://files.pythonhosted.org/packages/1f/96/cb85ec608464472e82ad37a17f844889c36100eed57bea094518bf270692/frozenlist-1.8.0-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:ec3cc8c5d4084591b4237c0a272cc4f50a5b03396a47d9caaf76f5d7b38a4f11", size = 229314, upload-time = "2025-10-06T05:36:38.582Z" },
    { url = "https://files.pythonhosted.org/packages/5d/6f/4ae69c550e4cee66b57887daeebe006fe985917c01d0fff9caab9883f6d0/frozenlist-1.8.0-cp313-cp313-musllinux_1_2_armv7l.whl", hash = "sha256:517279f58009d0b1f2e7c1b130b377a349405da3f7621ed6bfae50b10adf20c1", size = 243365, upload-time = "2025-10-06T05:36:40.152Z" },
    { url = "https://files.pythonhosted.org/packages/7a/58/afd56de246cf11780a40a2c28dc7cbabbf06337cc8ddb1c780a2d97e88d8/frozenlist-1.8.0-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:db1e72ede2d0d7ccb213f218df6a078a9c09a7de257c2fe8fcef16d5925230b1", size = 237763, upload-time = "2025-10-06T05:36:41.355Z" },
    { url = "https://files.pythonhosted.org/packages/cb/36/cdfaf6ed42e2644740d4a10452d8e97fa1c062e2a8006e4b09f1b5fd7d63/frozenlist-1.8.0-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:b4dec9482a65c54a5044486847b8a66bf10c9cb4926d42927ec4e8fd5db7fed8", size = 240110, upload-time = "2025-10-06T05:36:42.716Z" },
    { url = "https://files.pythonhosted.org/packages/03/a8/9ea226fbefad669f11b52e864c55f0bd57d3c8d7eb07e9f2e9a0b39502e1/frozenlist-1.8.0-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:21900c48ae04d13d416f0e1e0c4d81f7931f73a9dfa0b7a8746fb2fe7dd970ed", size = 233717, upload-time = "2025-10-06T05:36:44.251Z" },
    { url = "https://files.pythonhosted.org/packages/1e/0b/1b5531611e83ba7d13ccc9988967ea1b51186af64c42b7a7af465dcc9568/frozenlist-1.8.0-cp313-cp313-win32.whl", hash = "sha256:8b7b94a067d1c504ee0b16def57ad5738701e4ba10cec90529f13fa03c833496", size = 39628, upload-time = "2025-10-06T05:36:45.423Z" },
    { url = "https://files.pythonhosted.org/packages/d8/cf/174c91dbc9cc49bc7b7aab74d8b734e974d1faa8f191c74af9b7e80848e6/frozenlist-1.8.0-cp313-cp313-win_amd64.whl", hash = "sha256:878be833caa6a3821caf85eb39c5ba92d28e85df26d57afb06b35b2efd937231", size = 43882, upload-time = "2025-10-06T05:36:46.796Z" },
    { url = "https://files.pythonhosted.org/packages/c1/17/502cd212cbfa96eb1388614fe39a3fc9ab87dbbe042b66f97acb57474834/frozenlist-1.8.0-cp313-cp313-win_arm64.whl", hash = "sha256:44389d135b3ff43ba8cc89ff7f51f5a0bb6b63d829c8300f79a2fe4fe61bcc62", size = 39676, upload-time = "2025-10-06T05:36:47.8Z" },
    { url = "https://files.pythonhosted.org/packages/d2/5c/3bbfaa920dfab09e76946a5d2833a7cbdf7b9b4a91c714666ac4855b88b4/frozenlist-1.8.0-cp313-cp313t-macosx_10_13_universal2.whl", hash = "sha256:e25ac20a2ef37e91c1b39938b591457666a0fa835c7783c3a8f33ea42870db94", size = 89235, upload-time = "2025-10-06T05:36:48.78Z" },
    { url = "https://files.pythonhosted.org/packages/d2/d6/f03961ef72166cec1687e84e8925838442b615bd0b8854b54923ce5b7b8a/frozenlist-1.8.0-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:07cdca25a91a4386d2e76ad992916a85038a9b97561bf7a3fd12d5d9ce31870c", size = 50742, upload-time = "2025-10-06T05:36:49.837Z" },
    { url = "https://files.pythonhosted.org/packages/1e/bb/a6d12b7ba4c3337667d0e421f7181c82dda448ce4e7ad7ecd249a16fa806/frozenlist-1.8.0-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:4e0c11f2cc6717e0a741f84a527c52616140741cd812a50422f83dc31749fb52", size = 51725, upload-time = "2025-10-06T05:36:50.851Z" },
    { url = "https://files.pythonhosted.org/packages/bc/71/d1fed0ffe2c2ccd70b43714c6cab0f4188f09f8a67a7914a6b46ee30f274/frozenlist-1.8.0-cp313-cp313t-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl", hash = "sha256:b3210649ee28062ea6099cfda39e147fa1bc039583c8ee4481cb7811e2448c51", size = 284533, upload-time = "2025-10-06T05:36:51.898Z" },
    { url = "https://files.pythonhosted.org/packages/c9/1f/fb1685a7b009d89f9bf78a42d94461bc06581f6e718c39344754a5d9bada/frozenlist-1.8.0-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:581ef5194c48035a7de2aefc72ac6539823bb71508189e5de01d60c9dcd5fa65", size = 292506, upload-time = "2025-10-06T05:36:53.101Z" },
    { url = "https://files.pythonhosted.org/packages/e6/3b/b991fe1612703f7e0d05c0cf734c1b77aaf7c7d321df4572e8d36e7048c8/frozenlist-1.8.0-cp313-cp313t-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:3ef2d026f16a2b1866e1d86fc4e1291e1ed8a387b2c333809419a2f8b3a77b82", size = 274161, upload-time = "2025-10-06T05:36:54.309Z" },
    { url = "https://files.pythonhosted.org/packages/ca/ec/c5c618767bcdf66e88945ec0157d7f6c4a1322f1473392319b7a2501ded7/frozenlist-1.8.0-cp313-cp313t-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:5500ef82073f599ac84d888e3a8c1f77ac831183244bfd7f11eaa0289fb30714", size = 294676, upload-time = "2025-10-06T05:36:55.566Z" },
    { url = "https://files.pythonhosted.org/packages/7c/ce/3934758637d8f8a88d11f0585d6495ef54b2044ed6ec84492a91fa3b27aa/frozenlist-1.8.0-cp313-cp313t-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:50066c3997d0091c411a66e710f4e11752251e6d2d73d70d8d5d4c76442a199d", size = 300638, upload-time = "2025-10-06T05:36:56.758Z" },
    { url = "https://files.pythonhosted.org/packages/fc/4f/a7e4d0d467298f42de4b41cbc7ddaf19d3cfeabaf9ff97c20c6c7ee409f9/frozenlist-1.8.0-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:5c1c8e78426e59b3f8005e9b19f6ff46e5845895adbde20ece9218319eca6506", size = 283067, upload-time = "2025-10-06T05:36:57.965Z" },
    { url = "https://files.pythonhosted.org/packages/dc/48/c7b163063d55a83772b268e6d1affb960771b0e203b632cfe09522d67ea5/frozenlist-1.8.0-cp313-cp313t-musllinux_1_2_armv7l.whl", hash = "sha256:eefdba20de0d938cec6a89bd4d70f346a03108a19b9df4248d3cf0d88f1b0f51", size = 292101, upload-time = "2025-10-06T05:36:59.237Z" },
    { url = "https://files.pythonhosted.org/packages/9f/d0/2366d3c4ecdc2fd391e0afa6e11500bfba0ea772764d631bbf82f0136c9d/frozenlist-1.8.0-cp313-cp313t-musllinux_1_2_ppc64le.whl", hash = "sha256:cf253e0e1c3ceb4aaff6df637ce033ff6535fb8c70a764a8f46aafd3d6ab798e", size = 289901, upload-time = "2025-10-06T05:37:00.811Z" },
    { url = "https://files.pythonhosted.org/packages/b8/94/daff920e82c1b70e3618a2ac39fbc01ae3e2ff6124e80739ce5d71c9b920/frozenlist-1.8.0-cp313-cp313t-musllinux_1_2_s390x.whl", hash = "sha256:032efa2674356903cd0261c4317a561a6850f3ac864a63fc1583147fb05a79b0", size = 289395, upload-time = "2025-10-06T05:37:02.115Z" },
    { url = "https://files.pythonhosted.org/packages/e3/20/bba307ab4235a09fdcd3cc5508dbabd17c4634a1af4b96e0f69bfe551ebd/frozenlist-1.8.0-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:6da155091429aeba16851ecb10a9104a108bcd32f6c1642867eadaee401c1c41", size = 283659, upload-time = "2025-10-06T05:37:03.711Z" },
    { url = "https://files.pythonhosted.org/packages/fd/00/04ca1c3a7a124b6de4f8a9a17cc2fcad138b4608e7a3fc5877804b8715d7/frozenlist-1.8.0-cp313-cp313t-win32.whl", hash = "sha256:0f96534f8bfebc1a394209427d0f8a63d343c9779cda6fc25e8e121b5fd8555b", size = 43492, upload-time = "2025-10-06T05:37:04.915Z" },
    { url = "https://files.pythonhosted.org/packages/59/5e/c69f733a86a94ab10f68e496dc6b7e8bc078ebb415281d5698313e3af3a1/frozenlist-1.8.0-cp313-cp313t-win_amd64.whl", hash = "sha256:5d63a068f978fc69421fb0e6eb91a9603187527c86b7cd3f534a5b77a592b888", size = 48034, upload-time = "2025-10-06T05:37:06.343Z" },
    { url = "https://files.pythonhosted.org/packages/16/6c/be9d79775d8abe79b05fa6d23da99ad6e7763a1d080fbae7290b286093fd/frozenlist-1.8.0-cp313-cp313t-win_arm64.whl", hash = "sha256:bf0a7e10b077bf5fb9380ad3ae8ce20ef919a6ad93b4552896419ac7e1d8e042", size = 41749, upload-time = "2025-10-06T05:37:07.431Z" },
    { url = "https://files.pythonhosted.org/packages/9a/9a/e35b4a917281c0b8419d4207f4334c8e8c5dbf4f3f5f9ada73958d937dcc/frozenlist-1.8.0-py3-none-any.whl", hash = "sha256:0c18a16eab41e82c295618a77502e17b195883241c563b00f0aa5106fc4eaa0d", size = 13409, upload-time = "2025-10-06T05:38:16.721Z" },
]

[[package]]
name = "fsspec"
version = "2025.10.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/24/7f/2747c0d332b9acfa75dc84447a066fdf812b5a6b8d30472b74d309bfe8cb/fsspec-2025.10.0.tar.gz", hash = "sha256:b6789427626f068f9a83ca4e8a3cc050850b6c0f71f99ddb4f542b8266a26a59", size = 309285, upload-time = "2025-10-30T14:58:44.036Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/eb/02/a6b21098b1d5d6249b7c5ab69dde30108a71e4e819d4a9778f1de1d5b70d/fsspec-2025.10.0-py3-none-any.whl", hash = "sha256:7c7712353ae7d875407f97715f0e1ffcc21e33d5b24556cb1e090ae9409ec61d", size = 200966, upload-time = "2025-10-30T14:58:42.53Z" },
]

[[package]]
name = "google-auth"
version = "2.48.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "cryptography" },
    { name = "pyasn1-modules" },
    { name = "rsa" },
]
sdist = { url = "https://files.pythonhosted.org/packages/0c/41/242044323fbd746615884b1c16639749e73665b718209946ebad7ba8a813/google_auth-2.48.0.tar.gz", hash = "sha256:4f7e706b0cd3208a3d940a19a822c37a476ddba5450156c3e6624a71f7c841ce", size = 326522, upload-time = "2026-01-26T19:22:47.157Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/83/1d/d6466de3a5249d35e832a52834115ca9d1d0de6abc22065f049707516d47/google_auth-2.48.0-py3-none-any.whl", hash = "sha256:2e2a537873d449434252a9632c28bfc268b0adb1e53f9fb62afc5333a975903f", size = 236499, upload-time = "2026-01-26T19:22:45.099Z" },
]

[package.optional-dependencies]
requests = [
    { name = "requests" },
]

[[package]]
name = "google-genai"
version = "1.61.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "distro" },
    { name = "google-auth", extra = ["requests"] },
    { name = "httpx" },
    { name = "pydantic" },
    { name = "requests" },
    { name = "sniffio" },
    { name = "tenacity" },
    { name = "typing-extensions" },
    { name = "websockets" },
]
sdist = { url = "https://files.pythonhosted.org/packages/69/38/421cd7e70952a536be87a0249409f87297d84f523754a25b08fe94b97e7f/google_genai-1.61.0.tar.gz", hash = "sha256:5773a4e8ad5b2ebcd54a633a67d8e9c4f413032fef07977ee47ffa34a6d3bbdf", size = 489672, upload-time = "2026-01-30T20:50:27.177Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0e/87/78dd70cb59f7acf3350f53c5144a7aa7bc39c6f425cd7dc1224b59fcdac3/google_genai-1.61.0-py3-none-any.whl", hash = "sha256:cb073ef8287581476c1c3f4d8e735426ee34478e500a56deef218fa93071e3ca", size = 721948, upload-time = "2026-01-30T20:50:25.551Z" },
]

[[package]]
name = "googleapis-common-protos"
version = "1.71.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "protobuf" },
]
sdist = { url = "https://files.pythonhosted.org/packages/30/43/b25abe02db2911397819003029bef768f68a974f2ece483e6084d1a5f754/googleapis_common_protos-1.71.0.tar.gz", hash = "sha256:1aec01e574e29da63c80ba9f7bbf1ccfaacf1da877f23609fe236ca7c72a2e2e", size = 146454, upload-time = "2025-10-20T14:58:08.732Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/25/e8/eba9fece11d57a71e3e22ea672742c8f3cf23b35730c9e96db768b295216/googleapis_common_protos-1.71.0-py3-none-any.whl", hash = "sha256:59034a1d849dc4d18971997a72ac56246570afdd17f9369a0ff68218d50ab78c", size = 294576, upload-time = "2025-10-20T14:56:21.295Z" },
]

[[package]]
name = "graphql-core"
version = "3.2.7"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ac/9b/037a640a2983b09aed4a823f9cf1729e6d780b0671f854efa4727a7affbe/graphql_core-3.2.7.tar.gz", hash = "sha256:27b6904bdd3b43f2a0556dad5d579bdfdeab1f38e8e8788e555bdcb586a6f62c", size = 513484, upload-time = "2025-11-01T22:30:40.436Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0a/14/933037032608787fb92e365883ad6a741c235e0ff992865ec5d904a38f1e/graphql_core-3.2.7-py3-none-any.whl", hash = "sha256:17fc8f3ca4a42913d8e24d9ac9f08deddf0a0b2483076575757f6c412ead2ec0", size = 207262, upload-time = "2025-11-01T22:30:38.912Z" },
]

[[package]]
name = "greenlet"
version = "3.2.4"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/03/b8/704d753a5a45507a7aab61f18db9509302ed3d0a27ac7e0359ec2905b1a6/greenlet-3.2.4.tar.gz", hash = "sha256:0dca0d95ff849f9a364385f36ab49f50065d76964944638be9691e1832e9f86d", size = 188260, upload-time = "2025-08-07T13:24:33.51Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a4/de/f28ced0a67749cac23fecb02b694f6473f47686dff6afaa211d186e2ef9c/greenlet-3.2.4-cp311-cp311-macosx_11_0_universal2.whl", hash = "sha256:96378df1de302bc38e99c3a9aa311967b7dc80ced1dcc6f171e99842987882a2", size = 272305, upload-time = "2025-08-07T13:15:41.288Z" },
    { url = "https://files.pythonhosted.org/packages/09/16/2c3792cba130000bf2a31c5272999113f4764fd9d874fb257ff588ac779a/greenlet-3.2.4-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:1ee8fae0519a337f2329cb78bd7a8e128ec0f881073d43f023c7b8d4831d5246", size = 632472, upload-time = "2025-08-07T13:42:55.044Z" },
    { url = "https://files.pythonhosted.org/packages/ae/8f/95d48d7e3d433e6dae5b1682e4292242a53f22df82e6d3dda81b1701a960/greenlet-3.2.4-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:94abf90142c2a18151632371140b3dba4dee031633fe614cb592dbb6c9e17bc3", size = 644646, upload-time = "2025-08-07T13:45:26.523Z" },
    { url = "https://files.pythonhosted.org/packages/d5/5e/405965351aef8c76b8ef7ad370e5da58d57ef6068df197548b015464001a/greenlet-3.2.4-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:4d1378601b85e2e5171b99be8d2dc85f594c79967599328f95c1dc1a40f1c633", size = 640519, upload-time = "2025-08-07T13:53:13.928Z" },
    { url = "https://files.pythonhosted.org/packages/25/5d/382753b52006ce0218297ec1b628e048c4e64b155379331f25a7316eb749/greenlet-3.2.4-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:0db5594dce18db94f7d1650d7489909b57afde4c580806b8d9203b6e79cdc079", size = 639707, upload-time = "2025-08-07T13:18:27.146Z" },
    { url = "https://files.pythonhosted.org/packages/1f/8e/abdd3f14d735b2929290a018ecf133c901be4874b858dd1c604b9319f064/greenlet-3.2.4-cp311-cp311-manylinux_2_24_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:2523e5246274f54fdadbce8494458a2ebdcdbc7b802318466ac5606d3cded1f8", size = 587684, upload-time = "2025-08-07T13:18:25.164Z" },
    { url = "https://files.pythonhosted.org/packages/5d/65/deb2a69c3e5996439b0176f6651e0052542bb6c8f8ec2e3fba97c9768805/greenlet-3.2.4-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:1987de92fec508535687fb807a5cea1560f6196285a4cde35c100b8cd632cc52", size = 1116647, upload-time = "2025-08-07T13:42:38.655Z" },
    { url = "https://files.pythonhosted.org/packages/3f/cc/b07000438a29ac5cfb2194bfc128151d52f333cee74dd7dfe3fb733fc16c/greenlet-3.2.4-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:55e9c5affaa6775e2c6b67659f3a71684de4c549b3dd9afca3bc773533d284fa", size = 1142073, upload-time = "2025-08-07T13:18:21.737Z" },
    { url = "https://files.pythonhosted.org/packages/67/24/28a5b2fa42d12b3d7e5614145f0bd89714c34c08be6aabe39c14dd52db34/greenlet-3.2.4-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:c9c6de1940a7d828635fbd254d69db79e54619f165ee7ce32fda763a9cb6a58c", size = 1548385, upload-time = "2025-11-04T12:42:11.067Z" },
    { url = "https://files.pythonhosted.org/packages/6a/05/03f2f0bdd0b0ff9a4f7b99333d57b53a7709c27723ec8123056b084e69cd/greenlet-3.2.4-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:03c5136e7be905045160b1b9fdca93dd6727b180feeafda6818e6496434ed8c5", size = 1613329, upload-time = "2025-11-04T12:42:12.928Z" },
    { url = "https://files.pythonhosted.org/packages/d8/0f/30aef242fcab550b0b3520b8e3561156857c94288f0332a79928c31a52cf/greenlet-3.2.4-cp311-cp311-win_amd64.whl", hash = "sha256:9c40adce87eaa9ddb593ccb0fa6a07caf34015a29bf8d344811665b573138db9", size = 299100, upload-time = "2025-08-07T13:44:12.287Z" },
    { url = "https://files.pythonhosted.org/packages/44/69/9b804adb5fd0671f367781560eb5eb586c4d495277c93bde4307b9e28068/greenlet-3.2.4-cp312-cp312-macosx_11_0_universal2.whl", hash = "sha256:3b67ca49f54cede0186854a008109d6ee71f66bd57bb36abd6d0a0267b540cdd", size = 274079, upload-time = "2025-08-07T13:15:45.033Z" },
    { url = "https://files.pythonhosted.org/packages/46/e9/d2a80c99f19a153eff70bc451ab78615583b8dac0754cfb942223d2c1a0d/greenlet-3.2.4-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:ddf9164e7a5b08e9d22511526865780a576f19ddd00d62f8a665949327fde8bb", size = 640997, upload-time = "2025-08-07T13:42:56.234Z" },
    { url = "https://files.pythonhosted.org/packages/3b/16/035dcfcc48715ccd345f3a93183267167cdd162ad123cd93067d86f27ce4/greenlet-3.2.4-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:f28588772bb5fb869a8eb331374ec06f24a83a9c25bfa1f38b6993afe9c1e968", size = 655185, upload-time = "2025-08-07T13:45:27.624Z" },
    { url = "https://files.pythonhosted.org/packages/31/da/0386695eef69ffae1ad726881571dfe28b41970173947e7c558d9998de0f/greenlet-3.2.4-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:5c9320971821a7cb77cfab8d956fa8e39cd07ca44b6070db358ceb7f8797c8c9", size = 649926, upload-time = "2025-08-07T13:53:15.251Z" },
    { url = "https://files.pythonhosted.org/packages/68/88/69bf19fd4dc19981928ceacbc5fd4bb6bc2215d53199e367832e98d1d8fe/greenlet-3.2.4-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:c60a6d84229b271d44b70fb6e5fa23781abb5d742af7b808ae3f6efd7c9c60f6", size = 651839, upload-time = "2025-08-07T13:18:30.281Z" },
    { url = "https://files.pythonhosted.org/packages/19/0d/6660d55f7373b2ff8152401a83e02084956da23ae58cddbfb0b330978fe9/greenlet-3.2.4-cp312-cp312-manylinux_2_24_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:3b3812d8d0c9579967815af437d96623f45c0f2ae5f04e366de62a12d83a8fb0", size = 607586, upload-time = "2025-08-07T13:18:28.544Z" },
    { url = "https://files.pythonhosted.org/packages/8e/1a/c953fdedd22d81ee4629afbb38d2f9d71e37d23caace44775a3a969147d4/greenlet-3.2.4-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:abbf57b5a870d30c4675928c37278493044d7c14378350b3aa5d484fa65575f0", size = 1123281, upload-time = "2025-08-07T13:42:39.858Z" },
    { url = "https://files.pythonhosted.org/packages/3f/c7/12381b18e21aef2c6bd3a636da1088b888b97b7a0362fac2e4de92405f97/greenlet-3.2.4-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:20fb936b4652b6e307b8f347665e2c615540d4b42b3b4c8a321d8286da7e520f", size = 1151142, upload-time = "2025-08-07T13:18:22.981Z" },
    { url = "https://files.pythonhosted.org/packages/27/45/80935968b53cfd3f33cf99ea5f08227f2646e044568c9b1555b58ffd61c2/greenlet-3.2.4-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:ee7a6ec486883397d70eec05059353b8e83eca9168b9f3f9a361971e77e0bcd0", size = 1564846, upload-time = "2025-11-04T12:42:15.191Z" },
    { url = "https://files.pythonhosted.org/packages/69/02/b7c30e5e04752cb4db6202a3858b149c0710e5453b71a3b2aec5d78a1aab/greenlet-3.2.4-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:326d234cbf337c9c3def0676412eb7040a35a768efc92504b947b3e9cfc7543d", size = 1633814, upload-time = "2025-11-04T12:42:17.175Z" },
    { url = "https://files.pythonhosted.org/packages/e9/08/b0814846b79399e585f974bbeebf5580fbe59e258ea7be64d9dfb253c84f/greenlet-3.2.4-cp312-cp312-win_amd64.whl", hash = "sha256:a7d4e128405eea3814a12cc2605e0e6aedb4035bf32697f72deca74de4105e02", size = 299899, upload-time = "2025-08-07T13:38:53.448Z" },
    { url = "https://files.pythonhosted.org/packages/49/e8/58c7f85958bda41dafea50497cbd59738c5c43dbbea5ee83d651234398f4/greenlet-3.2.4-cp313-cp313-macosx_11_0_universal2.whl", hash = "sha256:1a921e542453fe531144e91e1feedf12e07351b1cf6c9e8a3325ea600a715a31", size = 272814, upload-time = "2025-08-07T13:15:50.011Z" },
    { url = "https://files.pythonhosted.org/packages/62/dd/b9f59862e9e257a16e4e610480cfffd29e3fae018a68c2332090b53aac3d/greenlet-3.2.4-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:cd3c8e693bff0fff6ba55f140bf390fa92c994083f838fece0f63be121334945", size = 641073, upload-time = "2025-08-07T13:42:57.23Z" },
    { url = "https://files.pythonhosted.org/packages/f7/0b/bc13f787394920b23073ca3b6c4a7a21396301ed75a655bcb47196b50e6e/greenlet-3.2.4-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:710638eb93b1fa52823aa91bf75326f9ecdfd5e0466f00789246a5280f4ba0fc", size = 655191, upload-time = "2025-08-07T13:45:29.752Z" },
    { url = "https://files.pythonhosted.org/packages/f2/d6/6adde57d1345a8d0f14d31e4ab9c23cfe8e2cd39c3baf7674b4b0338d266/greenlet-3.2.4-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:c5111ccdc9c88f423426df3fd1811bfc40ed66264d35aa373420a34377efc98a", size = 649516, upload-time = "2025-08-07T13:53:16.314Z" },
    { url = "https://files.pythonhosted.org/packages/7f/3b/3a3328a788d4a473889a2d403199932be55b1b0060f4ddd96ee7cdfcad10/greenlet-3.2.4-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:d76383238584e9711e20ebe14db6c88ddcedc1829a9ad31a584389463b5aa504", size = 652169, upload-time = "2025-08-07T13:18:32.861Z" },
    { url = "https://files.pythonhosted.org/packages/ee/43/3cecdc0349359e1a527cbf2e3e28e5f8f06d3343aaf82ca13437a9aa290f/greenlet-3.2.4-cp313-cp313-manylinux_2_24_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:23768528f2911bcd7e475210822ffb5254ed10d71f4028387e5a99b4c6699671", size = 610497, upload-time = "2025-08-07T13:18:31.636Z" },
    { url = "https://files.pythonhosted.org/packages/b8/19/06b6cf5d604e2c382a6f31cafafd6f33d5dea706f4db7bdab184bad2b21d/greenlet-3.2.4-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:00fadb3fedccc447f517ee0d3fd8fe49eae949e1cd0f6a611818f4f6fb7dc83b", size = 1121662, upload-time = "2025-08-07T13:42:41.117Z" },
    { url = "https://files.pythonhosted.org/packages/a2/15/0d5e4e1a66fab130d98168fe984c509249c833c1a3c16806b90f253ce7b9/greenlet-3.2.4-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:d25c5091190f2dc0eaa3f950252122edbbadbb682aa7b1ef2f8af0f8c0afefae", size = 1149210, upload-time = "2025-08-07T13:18:24.072Z" },
    { url = "https://files.pythonhosted.org/packages/1c/53/f9c440463b3057485b8594d7a638bed53ba531165ef0ca0e6c364b5cc807/greenlet-3.2.4-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:6e343822feb58ac4d0a1211bd9399de2b3a04963ddeec21530fc426cc121f19b", size = 1564759, upload-time = "2025-11-04T12:42:19.395Z" },
    { url = "https://files.pythonhosted.org/packages/47/e4/3bb4240abdd0a8d23f4f88adec746a3099f0d86bfedb623f063b2e3b4df0/greenlet-3.2.4-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:ca7f6f1f2649b89ce02f6f229d7c19f680a6238af656f61e0115b24857917929", size = 1634288, upload-time = "2025-11-04T12:42:21.174Z" },
    { url = "https://files.pythonhosted.org/packages/0b/55/2321e43595e6801e105fcfdee02b34c0f996eb71e6ddffca6b10b7e1d771/greenlet-3.2.4-cp313-cp313-win_amd64.whl", hash = "sha256:554b03b6e73aaabec3745364d6239e9e012d64c68ccd0b8430c64ccc14939a8b", size = 299685, upload-time = "2025-08-07T13:24:38.824Z" },
]

[[package]]
name = "griffe"
version = "1.14.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama" },
]
sdist = { url = "https://files.pythonhosted.org/packages/ec/d7/6c09dd7ce4c7837e4cdb11dce980cb45ae3cd87677298dc3b781b6bce7d3/griffe-1.14.0.tar.gz", hash = "sha256:9d2a15c1eca966d68e00517de5d69dd1bc5c9f2335ef6c1775362ba5b8651a13", size = 424684, upload-time = "2025-09-05T15:02:29.167Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2a/b1/9ff6578d789a89812ff21e4e0f80ffae20a65d5dd84e7a17873fe3b365be/griffe-1.14.0-py3-none-any.whl", hash = "sha256:0e9d52832cccf0f7188cfe585ba962d2674b241c01916d780925df34873bceb0", size = 144439, upload-time = "2025-09-05T15:02:27.511Z" },
]

[[package]]
name = "grpc-interceptor"
version = "0.15.4"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "grpcio" },
]
sdist = { url = "https://files.pythonhosted.org/packages/9f/28/57449d5567adf4c1d3e216aaca545913fbc21a915f2da6790d6734aac76e/grpc-interceptor-0.15.4.tar.gz", hash = "sha256:1f45c0bcb58b6f332f37c637632247c9b02bc6af0fdceb7ba7ce8d2ebbfb0926", size = 19322, upload-time = "2023-11-16T02:05:42.459Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/15/ac/8d53f230a7443401ce81791ec50a3b0e54924bf615ad287654fa4a2f5cdc/grpc_interceptor-0.15.4-py3-none-any.whl", hash = "sha256:0035f33228693ed3767ee49d937bac424318db173fef4d2d0170b3215f254d9d", size = 20848, upload-time = "2023-11-16T02:05:40.913Z" },
]

[[package]]
name = "grpcio"
version = "1.76.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b6/e0/318c1ce3ae5a17894d5791e87aea147587c9e702f24122cc7a5c8bbaeeb1/grpcio-1.76.0.tar.gz", hash = "sha256:7be78388d6da1a25c0d5ec506523db58b18be22d9c37d8d3a32c08be4987bd73", size = 12785182, upload-time = "2025-10-21T16:23:12.106Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a0/00/8163a1beeb6971f66b4bbe6ac9457b97948beba8dd2fc8e1281dce7f79ec/grpcio-1.76.0-cp311-cp311-linux_armv7l.whl", hash = "sha256:2e1743fbd7f5fa713a1b0a8ac8ebabf0ec980b5d8809ec358d488e273b9cf02a", size = 5843567, upload-time = "2025-10-21T16:20:52.829Z" },
    { url = "https://files.pythonhosted.org/packages/10/c1/934202f5cf335e6d852530ce14ddb0fef21be612ba9ecbbcbd4d748ca32d/grpcio-1.76.0-cp311-cp311-macosx_11_0_universal2.whl", hash = "sha256:a8c2cf1209497cf659a667d7dea88985e834c24b7c3b605e6254cbb5076d985c", size = 11848017, upload-time = "2025-10-21T16:20:56.705Z" },
    { url = "https://files.pythonhosted.org/packages/11/0b/8dec16b1863d74af6eb3543928600ec2195af49ca58b16334972f6775663/grpcio-1.76.0-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:08caea849a9d3c71a542827d6df9d5a69067b0a1efbea8a855633ff5d9571465", size = 6412027, upload-time = "2025-10-21T16:20:59.3Z" },
    { url = "https://files.pythonhosted.org/packages/d7/64/7b9e6e7ab910bea9d46f2c090380bab274a0b91fb0a2fe9b0cd399fffa12/grpcio-1.76.0-cp311-cp311-manylinux2014_i686.manylinux_2_17_i686.whl", hash = "sha256:f0e34c2079d47ae9f6188211db9e777c619a21d4faba6977774e8fa43b085e48", size = 7075913, upload-time = "2025-10-21T16:21:01.645Z" },
    { url = "https://files.pythonhosted.org/packages/68/86/093c46e9546073cefa789bd76d44c5cb2abc824ca62af0c18be590ff13ba/grpcio-1.76.0-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:8843114c0cfce61b40ad48df65abcfc00d4dba82eae8718fab5352390848c5da", size = 6615417, upload-time = "2025-10-21T16:21:03.844Z" },
    { url = "https://files.pythonhosted.org/packages/f7/b6/5709a3a68500a9c03da6fb71740dcdd5ef245e39266461a03f31a57036d8/grpcio-1.76.0-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:8eddfb4d203a237da6f3cc8a540dad0517d274b5a1e9e636fd8d2c79b5c1d397", size = 7199683, upload-time = "2025-10-21T16:21:06.195Z" },
    { url = "https://files.pythonhosted.org/packages/91/d3/4b1f2bf16ed52ce0b508161df3a2d186e4935379a159a834cb4a7d687429/grpcio-1.76.0-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:32483fe2aab2c3794101c2a159070584e5db11d0aa091b2c0ea9c4fc43d0d749", size = 8163109, upload-time = "2025-10-21T16:21:08.498Z" },
    { url = "https://files.pythonhosted.org/packages/5c/61/d9043f95f5f4cf085ac5dd6137b469d41befb04bd80280952ffa2a4c3f12/grpcio-1.76.0-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:dcfe41187da8992c5f40aa8c5ec086fa3672834d2be57a32384c08d5a05b4c00", size = 7626676, upload-time = "2025-10-21T16:21:10.693Z" },
    { url = "https://files.pythonhosted.org/packages/36/95/fd9a5152ca02d8881e4dd419cdd790e11805979f499a2e5b96488b85cf27/grpcio-1.76.0-cp311-cp311-win32.whl", hash = "sha256:2107b0c024d1b35f4083f11245c0e23846ae64d02f40b2b226684840260ed054", size = 3997688, upload-time = "2025-10-21T16:21:12.746Z" },
    { url = "https://files.pythonhosted.org/packages/60/9c/5c359c8d4c9176cfa3c61ecd4efe5affe1f38d9bae81e81ac7186b4c9cc8/grpcio-1.76.0-cp311-cp311-win_amd64.whl", hash = "sha256:522175aba7af9113c48ec10cc471b9b9bd4f6ceb36aeb4544a8e2c80ed9d252d", size = 4709315, upload-time = "2025-10-21T16:21:15.26Z" },
    { url = "https://files.pythonhosted.org/packages/bf/05/8e29121994b8d959ffa0afd28996d452f291b48cfc0875619de0bde2c50c/grpcio-1.76.0-cp312-cp312-linux_armv7l.whl", hash = "sha256:81fd9652b37b36f16138611c7e884eb82e0cec137c40d3ef7c3f9b3ed00f6ed8", size = 5799718, upload-time = "2025-10-21T16:21:17.939Z" },
    { url = "https://files.pythonhosted.org/packages/d9/75/11d0e66b3cdf998c996489581bdad8900db79ebd83513e45c19548f1cba4/grpcio-1.76.0-cp312-cp312-macosx_11_0_universal2.whl", hash = "sha256:04bbe1bfe3a68bbfd4e52402ab7d4eb59d72d02647ae2042204326cf4bbad280", size = 11825627, upload-time = "2025-10-21T16:21:20.466Z" },
    { url = "https://files.pythonhosted.org/packages/28/50/2f0aa0498bc188048f5d9504dcc5c2c24f2eb1a9337cd0fa09a61a2e75f0/grpcio-1.76.0-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:d388087771c837cdb6515539f43b9d4bf0b0f23593a24054ac16f7a960be16f4", size = 6359167, upload-time = "2025-10-21T16:21:23.122Z" },
    { url = "https://files.pythonhosted.org/packages/66/e5/bbf0bb97d29ede1d59d6588af40018cfc345b17ce979b7b45424628dc8bb/grpcio-1.76.0-cp312-cp312-manylinux2014_i686.manylinux_2_17_i686.whl", hash = "sha256:9f8f757bebaaea112c00dba718fc0d3260052ce714e25804a03f93f5d1c6cc11", size = 7044267, upload-time = "2025-10-21T16:21:25.995Z" },
    { url = "https://files.pythonhosted.org/packages/f5/86/f6ec2164f743d9609691115ae8ece098c76b894ebe4f7c94a655c6b03e98/grpcio-1.76.0-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:980a846182ce88c4f2f7e2c22c56aefd515daeb36149d1c897f83cf57999e0b6", size = 6573963, upload-time = "2025-10-21T16:21:28.631Z" },
    { url = "https://files.pythonhosted.org/packages/60/bc/8d9d0d8505feccfdf38a766d262c71e73639c165b311c9457208b56d92ae/grpcio-1.76.0-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:f92f88e6c033db65a5ae3d97905c8fea9c725b63e28d5a75cb73b49bda5024d8", size = 7164484, upload-time = "2025-10-21T16:21:30.837Z" },
    { url = "https://files.pythonhosted.org/packages/67/e6/5d6c2fc10b95edf6df9b8f19cf10a34263b7fd48493936fffd5085521292/grpcio-1.76.0-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:4baf3cbe2f0be3289eb68ac8ae771156971848bb8aaff60bad42005539431980", size = 8127777, upload-time = "2025-10-21T16:21:33.577Z" },
    { url = "https://files.pythonhosted.org/packages/3f/c8/dce8ff21c86abe025efe304d9e31fdb0deaaa3b502b6a78141080f206da0/grpcio-1.76.0-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:615ba64c208aaceb5ec83bfdce7728b80bfeb8be97562944836a7a0a9647d882", size = 7594014, upload-time = "2025-10-21T16:21:41.882Z" },
    { url = "https://files.pythonhosted.org/packages/e0/42/ad28191ebf983a5d0ecef90bab66baa5a6b18f2bfdef9d0a63b1973d9f75/grpcio-1.76.0-cp312-cp312-win32.whl", hash = "sha256:45d59a649a82df5718fd9527ce775fd66d1af35e6d31abdcdc906a49c6822958", size = 3984750, upload-time = "2025-10-21T16:21:44.006Z" },
    { url = "https://files.pythonhosted.org/packages/9e/00/7bd478cbb851c04a48baccaa49b75abaa8e4122f7d86da797500cccdd771/grpcio-1.76.0-cp312-cp312-win_amd64.whl", hash = "sha256:c088e7a90b6017307f423efbb9d1ba97a22aa2170876223f9709e9d1de0b5347", size = 4704003, upload-time = "2025-10-21T16:21:46.244Z" },
    { url = "https://files.pythonhosted.org/packages/fc/ed/71467ab770effc9e8cef5f2e7388beb2be26ed642d567697bb103a790c72/grpcio-1.76.0-cp313-cp313-linux_armv7l.whl", hash = "sha256:26ef06c73eb53267c2b319f43e6634c7556ea37672029241a056629af27c10e2", size = 5807716, upload-time = "2025-10-21T16:21:48.475Z" },
    { url = "https://files.pythonhosted.org/packages/2c/85/c6ed56f9817fab03fa8a111ca91469941fb514e3e3ce6d793cb8f1e1347b/grpcio-1.76.0-cp313-cp313-macosx_11_0_universal2.whl", hash = "sha256:45e0111e73f43f735d70786557dc38141185072d7ff8dc1829d6a77ac1471468", size = 11821522, upload-time = "2025-10-21T16:21:51.142Z" },
    { url = "https://files.pythonhosted.org/packages/ac/31/2b8a235ab40c39cbc141ef647f8a6eb7b0028f023015a4842933bc0d6831/grpcio-1.76.0-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:83d57312a58dcfe2a3a0f9d1389b299438909a02db60e2f2ea2ae2d8034909d3", size = 6362558, upload-time = "2025-10-21T16:21:54.213Z" },
    { url = "https://files.pythonhosted.org/packages/bd/64/9784eab483358e08847498ee56faf8ff6ea8e0a4592568d9f68edc97e9e9/grpcio-1.76.0-cp313-cp313-manylinux2014_i686.manylinux_2_17_i686.whl", hash = "sha256:3e2a27c89eb9ac3d81ec8835e12414d73536c6e620355d65102503064a4ed6eb", size = 7049990, upload-time = "2025-10-21T16:21:56.476Z" },
    { url = "https://files.pythonhosted.org/packages/2b/94/8c12319a6369434e7a184b987e8e9f3b49a114c489b8315f029e24de4837/grpcio-1.76.0-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:61f69297cba3950a524f61c7c8ee12e55c486cb5f7db47ff9dcee33da6f0d3ae", size = 6575387, upload-time = "2025-10-21T16:21:59.051Z" },
    { url = "https://files.pythonhosted.org/packages/15/0f/f12c32b03f731f4a6242f771f63039df182c8b8e2cf8075b245b409259d4/grpcio-1.76.0-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:6a15c17af8839b6801d554263c546c69c4d7718ad4321e3166175b37eaacca77", size = 7166668, upload-time = "2025-10-21T16:22:02.049Z" },
    { url = "https://files.pythonhosted.org/packages/ff/2d/3ec9ce0c2b1d92dd59d1c3264aaec9f0f7c817d6e8ac683b97198a36ed5a/grpcio-1.76.0-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:25a18e9810fbc7e7f03ec2516addc116a957f8cbb8cbc95ccc80faa072743d03", size = 8124928, upload-time = "2025-10-21T16:22:04.984Z" },
    { url = "https://files.pythonhosted.org/packages/1a/74/fd3317be5672f4856bcdd1a9e7b5e17554692d3db9a3b273879dc02d657d/grpcio-1.76.0-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:931091142fd8cc14edccc0845a79248bc155425eee9a98b2db2ea4f00a235a42", size = 7589983, upload-time = "2025-10-21T16:22:07.881Z" },
    { url = "https://files.pythonhosted.org/packages/45/bb/ca038cf420f405971f19821c8c15bcbc875505f6ffadafe9ffd77871dc4c/grpcio-1.76.0-cp313-cp313-win32.whl", hash = "sha256:5e8571632780e08526f118f74170ad8d50fb0a48c23a746bef2a6ebade3abd6f", size = 3984727, upload-time = "2025-10-21T16:22:10.032Z" },
    { url = "https://files.pythonhosted.org/packages/41/80/84087dc56437ced7cdd4b13d7875e7439a52a261e3ab4e06488ba6173b0a/grpcio-1.76.0-cp313-cp313-win_amd64.whl", hash = "sha256:f9f7bd5faab55f47231ad8dba7787866b69f5e93bc306e3915606779bbfb4ba8", size = 4702799, upload-time = "2025-10-21T16:22:12.709Z" },
]

[[package]]
name = "h11"
version = "0.16.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/01/ee/02a2c011bdab74c6fb3c75474d40b3052059d95df7e73351460c8588d963/h11-0.16.0.tar.gz", hash = "sha256:4e35b956cf45792e4caa5885e69fba00bdbc6ffafbfa020300e549b208ee5ff1", size = 101250, upload-time = "2025-04-24T03:35:25.427Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/04/4b/29cac41a4d98d144bf5f6d33995617b185d14b22401f75ca86f384e87ff1/h11-0.16.0-py3-none-any.whl", hash = "sha256:63cf8bbe7522de3bf65932fda1d9c2772064ffb3dae62d55932da54b31cb6c86", size = 37515, upload-time = "2025-04-24T03:35:24.344Z" },
]

[[package]]
name = "hf-xet"
version = "1.2.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/5e/6e/0f11bacf08a67f7fb5ee09740f2ca54163863b07b70d579356e9222ce5d8/hf_xet-1.2.0.tar.gz", hash = "sha256:a8c27070ca547293b6890c4bf389f713f80e8c478631432962bb7f4bc0bd7d7f", size = 506020, upload-time = "2025-10-24T19:04:32.129Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9e/a5/85ef910a0aa034a2abcfadc360ab5ac6f6bc4e9112349bd40ca97551cff0/hf_xet-1.2.0-cp313-cp313t-macosx_10_12_x86_64.whl", hash = "sha256:ceeefcd1b7aed4956ae8499e2199607765fbd1c60510752003b6cc0b8413b649", size = 2861870, upload-time = "2025-10-24T19:04:11.422Z" },
    { url = "https://files.pythonhosted.org/packages/ea/40/e2e0a7eb9a51fe8828ba2d47fe22a7e74914ea8a0db68a18c3aa7449c767/hf_xet-1.2.0-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:b70218dd548e9840224df5638fdc94bd033552963cfa97f9170829381179c813", size = 2717584, upload-time = "2025-10-24T19:04:09.586Z" },
    { url = "https://files.pythonhosted.org/packages/a5/7d/daf7f8bc4594fdd59a8a596f9e3886133fdc68e675292218a5e4c1b7e834/hf_xet-1.2.0-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:7d40b18769bb9a8bc82a9ede575ce1a44c75eb80e7375a01d76259089529b5dc", size = 3315004, upload-time = "2025-10-24T19:04:00.314Z" },
    { url = "https://files.pythonhosted.org/packages/b1/ba/45ea2f605fbf6d81c8b21e4d970b168b18a53515923010c312c06cd83164/hf_xet-1.2.0-cp313-cp313t-manylinux_2_28_aarch64.whl", hash = "sha256:cd3a6027d59cfb60177c12d6424e31f4b5ff13d8e3a1247b3a584bf8977e6df5", size = 3222636, upload-time = "2025-10-24T19:03:58.111Z" },
    { url = "https://files.pythonhosted.org/packages/4a/1d/04513e3cab8f29ab8c109d309ddd21a2705afab9d52f2ba1151e0c14f086/hf_xet-1.2.0-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:6de1fc44f58f6dd937956c8d304d8c2dea264c80680bcfa61ca4a15e7b76780f", size = 3408448, upload-time = "2025-10-24T19:04:20.951Z" },
    { url = "https://files.pythonhosted.org/packages/f0/7c/60a2756d7feec7387db3a1176c632357632fbe7849fce576c5559d4520c7/hf_xet-1.2.0-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:f182f264ed2acd566c514e45da9f2119110e48a87a327ca271027904c70c5832", size = 3503401, upload-time = "2025-10-24T19:04:22.549Z" },
    { url = "https://files.pythonhosted.org/packages/4e/64/48fffbd67fb418ab07451e4ce641a70de1c40c10a13e25325e24858ebe5a/hf_xet-1.2.0-cp313-cp313t-win_amd64.whl", hash = "sha256:293a7a3787e5c95d7be1857358a9130694a9c6021de3f27fa233f37267174382", size = 2900866, upload-time = "2025-10-24T19:04:33.461Z" },
    { url = "https://files.pythonhosted.org/packages/96/2d/22338486473df5923a9ab7107d375dbef9173c338ebef5098ef593d2b560/hf_xet-1.2.0-cp37-abi3-macosx_10_12_x86_64.whl", hash = "sha256:46740d4ac024a7ca9b22bebf77460ff43332868b661186a8e46c227fdae01848", size = 2866099, upload-time = "2025-10-24T19:04:15.366Z" },
    { url = "https://files.pythonhosted.org/packages/7f/8c/c5becfa53234299bc2210ba314eaaae36c2875e0045809b82e40a9544f0c/hf_xet-1.2.0-cp37-abi3-macosx_11_0_arm64.whl", hash = "sha256:27df617a076420d8845bea087f59303da8be17ed7ec0cd7ee3b9b9f579dff0e4", size = 2722178, upload-time = "2025-10-24T19:04:13.695Z" },
    { url = "https://files.pythonhosted.org/packages/9a/92/cf3ab0b652b082e66876d08da57fcc6fa2f0e6c70dfbbafbd470bb73eb47/hf_xet-1.2.0-cp37-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:3651fd5bfe0281951b988c0facbe726aa5e347b103a675f49a3fa8144c7968fd", size = 3320214, upload-time = "2025-10-24T19:04:03.596Z" },
    { url = "https://files.pythonhosted.org/packages/46/92/3f7ec4a1b6a65bf45b059b6d4a5d38988f63e193056de2f420137e3c3244/hf_xet-1.2.0-cp37-abi3-manylinux_2_28_aarch64.whl", hash = "sha256:d06fa97c8562fb3ee7a378dd9b51e343bc5bc8190254202c9771029152f5e08c", size = 3229054, upload-time = "2025-10-24T19:04:01.949Z" },
    { url = "https://files.pythonhosted.org/packages/0b/dd/7ac658d54b9fb7999a0ccb07ad863b413cbaf5cf172f48ebcd9497ec7263/hf_xet-1.2.0-cp37-abi3-musllinux_1_2_aarch64.whl", hash = "sha256:4c1428c9ae73ec0939410ec73023c4f842927f39db09b063b9482dac5a3bb737", size = 3413812, upload-time = "2025-10-24T19:04:24.585Z" },
    { url = "https://files.pythonhosted.org/packages/92/68/89ac4e5b12a9ff6286a12174c8538a5930e2ed662091dd2572bbe0a18c8a/hf_xet-1.2.0-cp37-abi3-musllinux_1_2_x86_64.whl", hash = "sha256:a55558084c16b09b5ed32ab9ed38421e2d87cf3f1f89815764d1177081b99865", size = 3508920, upload-time = "2025-10-24T19:04:26.927Z" },
    { url = "https://files.pythonhosted.org/packages/cb/44/870d44b30e1dcfb6a65932e3e1506c103a8a5aea9103c337e7a53180322c/hf_xet-1.2.0-cp37-abi3-win_amd64.whl", hash = "sha256:e6584a52253f72c9f52f9e549d5895ca7a471608495c4ecaa6cc73dba2b24d69", size = 2905735, upload-time = "2025-10-24T19:04:35.928Z" },
]

[[package]]
name = "httpcore"
version = "1.0.9"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "certifi" },
    { name = "h11" },
]
sdist = { url = "https://files.pythonhosted.org/packages/06/94/82699a10bca87a5556c9c59b5963f2d039dbd239f25bc2a63907a05a14cb/httpcore-1.0.9.tar.gz", hash = "sha256:6e34463af53fd2ab5d807f399a9b45ea31c3dfa2276f15a2c3f00afff6e176e8", size = 85484, upload-time = "2025-04-24T22:06:22.219Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7e/f5/f66802a942d491edb555dd61e3a9961140fd64c90bce1eafd741609d334d/httpcore-1.0.9-py3-none-any.whl", hash = "sha256:2d400746a40668fc9dec9810239072b40b4484b640a8c38fd654a024c7a1bf55", size = 78784, upload-time = "2025-04-24T22:06:20.566Z" },
]

[[package]]
name = "httpx"
version = "0.28.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "certifi" },
    { name = "httpcore" },
    { name = "idna" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b1/df/48c586a5fe32a0f01324ee087459e112ebb7224f646c0b5023f5e79e9956/httpx-0.28.1.tar.gz", hash = "sha256:75e98c5f16b0f35b567856f597f06ff2270a374470a5c2392242528e3e3e42fc", size = 141406, upload-time = "2024-12-06T15:37:23.222Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2a/39/e50c7c3a983047577ee07d2a9e53faf5a69493943ec3f6a384bdc792deb2/httpx-0.28.1-py3-none-any.whl", hash = "sha256:d909fcccc110f8c7faf814ca82a9a4d816bc5a6dbfea25d6591d6985b8ba59ad", size = 73517, upload-time = "2024-12-06T15:37:21.509Z" },
]

[[package]]
name = "httpx-sse"
version = "0.4.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/0f/4c/751061ffa58615a32c31b2d82e8482be8dd4a89154f003147acee90f2be9/httpx_sse-0.4.3.tar.gz", hash = "sha256:9b1ed0127459a66014aec3c56bebd93da3c1bc8bb6618c8082039a44889a755d", size = 15943, upload-time = "2025-10-10T21:48:22.271Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d2/fd/6668e5aec43ab844de6fc74927e155a3b37bf40d7c3790e49fc0406b6578/httpx_sse-0.4.3-py3-none-any.whl", hash = "sha256:0ac1c9fe3c0afad2e0ebb25a934a59f4c7823b60792691f779fad2c5568830fc", size = 8960, upload-time = "2025-10-10T21:48:21.158Z" },
]

[[package]]
name = "huggingface-hub"
version = "0.36.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "filelock" },
    { name = "fsspec" },
    { name = "hf-xet", marker = "platform_machine == 'aarch64' or platform_machine == 'amd64' or platform_machine == 'arm64' or platform_machine == 'x86_64'" },
    { name = "packaging" },
    { name = "pyyaml" },
    { name = "requests" },
    { name = "tqdm" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/98/63/4910c5fa9128fdadf6a9c5ac138e8b1b6cee4ca44bf7915bbfbce4e355ee/huggingface_hub-0.36.0.tar.gz", hash = "sha256:47b3f0e2539c39bf5cde015d63b72ec49baff67b6931c3d97f3f84532e2b8d25", size = 463358, upload-time = "2025-10-23T12:12:01.413Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/cb/bd/1a875e0d592d447cbc02805fd3fe0f497714d6a2583f59d14fa9ebad96eb/huggingface_hub-0.36.0-py3-none-any.whl", hash = "sha256:7bcc9ad17d5b3f07b57c78e79d527102d08313caa278a641993acddcb894548d", size = 566094, upload-time = "2025-10-23T12:11:59.557Z" },
]

[[package]]
name = "idna"
version = "3.11"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/6f/6d/0703ccc57f3a7233505399edb88de3cbd678da106337b9fcde432b65ed60/idna-3.11.tar.gz", hash = "sha256:795dafcc9c04ed0c1fb032c2aa73654d8e8c5023a7df64a53f39190ada629902", size = 194582, upload-time = "2025-10-12T14:55:20.501Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0e/61/66938bbb5fc52dbdf84594873d5b51fb1f7c7794e9c0f5bd885f30bc507b/idna-3.11-py3-none-any.whl", hash = "sha256:771a87f49d9defaf64091e6e6fe9c18d4833f140bd19464795bc32d966ca37ea", size = 71008, upload-time = "2025-10-12T14:55:18.883Z" },
]

[[package]]
name = "importlib-metadata"
version = "8.7.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "zipp" },
]
sdist = { url = "https://files.pythonhosted.org/packages/76/66/650a33bd90f786193e4de4b3ad86ea60b53c89b669a5c7be931fac31cdb0/importlib_metadata-8.7.0.tar.gz", hash = "sha256:d13b81ad223b890aa16c5471f2ac3056cf76c5f10f82d6f9292f0b415f389000", size = 56641, upload-time = "2025-04-27T15:29:01.736Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/20/b0/36bd937216ec521246249be3bf9855081de4c5e06a0c9b4219dbeda50373/importlib_metadata-8.7.0-py3-none-any.whl", hash = "sha256:e5dd1551894c77868a30651cef00984d50e1002d06942a7101d34870c5f02afd", size = 27656, upload-time = "2025-04-27T15:29:00.214Z" },
]

[[package]]
name = "jinja2"
version = "3.1.6"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markupsafe" },
]
sdist = { url = "https://files.pythonhosted.org/packages/df/bf/f7da0350254c0ed7c72f3e33cef02e048281fec7ecec5f032d4aac52226b/jinja2-3.1.6.tar.gz", hash = "sha256:0137fb05990d35f1275a587e9aee6d56da821fc83491a0fb838183be43f66d6d", size = 245115, upload-time = "2025-03-05T20:05:02.478Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/62/a1/3d680cbfd5f4b8f15abc1d571870c5fc3e594bb582bc3b64ea099db13e56/jinja2-3.1.6-py3-none-any.whl", hash = "sha256:85ece4451f492d0c13c5dd7c13a64681a86afae63a5f347908daf103ce6d2f67", size = 134899, upload-time = "2025-03-05T20:05:00.369Z" },
]

[[package]]
name = "jiter"
version = "0.11.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a3/68/0357982493a7b20925aece061f7fb7a2678e3b232f8d73a6edb7e5304443/jiter-0.11.1.tar.gz", hash = "sha256:849dcfc76481c0ea0099391235b7ca97d7279e0fa4c86005457ac7c88e8b76dc", size = 168385, upload-time = "2025-10-17T11:31:15.186Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8b/34/c9e6cfe876f9a24f43ed53fe29f052ce02bd8d5f5a387dbf46ad3764bef0/jiter-0.11.1-cp311-cp311-macosx_10_12_x86_64.whl", hash = "sha256:9b0088ff3c374ce8ce0168523ec8e97122ebb788f950cf7bb8e39c7dc6a876a2", size = 310160, upload-time = "2025-10-17T11:28:59.174Z" },
    { url = "https://files.pythonhosted.org/packages/bc/9f/b06ec8181d7165858faf2ac5287c54fe52b2287760b7fe1ba9c06890255f/jiter-0.11.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:74433962dd3c3090655e02e461267095d6c84f0741c7827de11022ef8d7ff661", size = 316573, upload-time = "2025-10-17T11:29:00.905Z" },
    { url = "https://files.pythonhosted.org/packages/66/49/3179d93090f2ed0c6b091a9c210f266d2d020d82c96f753260af536371d0/jiter-0.11.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:6d98030e345e6546df2cc2c08309c502466c66c4747b043f1a0d415fada862b8", size = 348998, upload-time = "2025-10-17T11:29:02.321Z" },
    { url = "https://files.pythonhosted.org/packages/ae/9d/63db2c8eabda7a9cad65a2e808ca34aaa8689d98d498f5a2357d7a2e2cec/jiter-0.11.1-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:1d6db0b2e788db46bec2cf729a88b6dd36959af2abd9fa2312dfba5acdd96dcb", size = 363413, upload-time = "2025-10-17T11:29:03.787Z" },
    { url = "https://files.pythonhosted.org/packages/25/ff/3e6b3170c5053053c7baddb8d44e2bf11ff44cd71024a280a8438ae6ba32/jiter-0.11.1-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:55678fbbda261eafe7289165dd2ddd0e922df5f9a1ae46d7c79a5a15242bd7d1", size = 487144, upload-time = "2025-10-17T11:29:05.37Z" },
    { url = "https://files.pythonhosted.org/packages/b0/50/b63fcadf699893269b997f4c2e88400bc68f085c6db698c6e5e69d63b2c1/jiter-0.11.1-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:6a6b74fae8e40497653b52ce6ca0f1b13457af769af6fb9c1113efc8b5b4d9be", size = 376215, upload-time = "2025-10-17T11:29:07.123Z" },
    { url = "https://files.pythonhosted.org/packages/39/8c/57a8a89401134167e87e73471b9cca321cf651c1fd78c45f3a0f16932213/jiter-0.11.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:0a55a453f8b035eb4f7852a79a065d616b7971a17f5e37a9296b4b38d3b619e4", size = 359163, upload-time = "2025-10-17T11:29:09.047Z" },
    { url = "https://files.pythonhosted.org/packages/4b/96/30b0cdbffbb6f753e25339d3dbbe26890c9ef119928314578201c758aace/jiter-0.11.1-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:2638148099022e6bdb3f42904289cd2e403609356fb06eb36ddec2d50958bc29", size = 385344, upload-time = "2025-10-17T11:29:10.69Z" },
    { url = "https://files.pythonhosted.org/packages/c6/d5/31dae27c1cc9410ad52bb514f11bfa4f286f7d6ef9d287b98b8831e156ec/jiter-0.11.1-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:252490567a5d990986f83b95a5f1ca1bf205ebd27b3e9e93bb7c2592380e29b9", size = 517972, upload-time = "2025-10-17T11:29:12.174Z" },
    { url = "https://files.pythonhosted.org/packages/61/1e/5905a7a3aceab80de13ab226fd690471a5e1ee7e554dc1015e55f1a6b896/jiter-0.11.1-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:d431d52b0ca2436eea6195f0f48528202100c7deda354cb7aac0a302167594d5", size = 508408, upload-time = "2025-10-17T11:29:13.597Z" },
    { url = "https://files.pythonhosted.org/packages/91/12/1c49b97aa49077e136e8591cef7162f0d3e2860ae457a2d35868fd1521ef/jiter-0.11.1-cp311-cp311-win32.whl", hash = "sha256:db6f41e40f8bae20c86cb574b48c4fd9f28ee1c71cb044e9ec12e78ab757ba3a", size = 203937, upload-time = "2025-10-17T11:29:14.894Z" },
    { url = "https://files.pythonhosted.org/packages/6d/9d/2255f7c17134ee9892c7e013c32d5bcf4bce64eb115402c9fe5e727a67eb/jiter-0.11.1-cp311-cp311-win_amd64.whl", hash = "sha256:0cc407b8e6cdff01b06bb80f61225c8b090c3df108ebade5e0c3c10993735b19", size = 207589, upload-time = "2025-10-17T11:29:16.166Z" },
    { url = "https://files.pythonhosted.org/packages/3c/28/6307fc8f95afef84cae6caf5429fee58ef16a582c2ff4db317ceb3e352fa/jiter-0.11.1-cp311-cp311-win_arm64.whl", hash = "sha256:fe04ea475392a91896d1936367854d346724a1045a247e5d1c196410473b8869", size = 188391, upload-time = "2025-10-17T11:29:17.488Z" },
    { url = "https://files.pythonhosted.org/packages/15/8b/318e8af2c904a9d29af91f78c1e18f0592e189bbdb8a462902d31fe20682/jiter-0.11.1-cp312-cp312-macosx_10_12_x86_64.whl", hash = "sha256:c92148eec91052538ce6823dfca9525f5cfc8b622d7f07e9891a280f61b8c96c", size = 305655, upload-time = "2025-10-17T11:29:18.859Z" },
    { url = "https://files.pythonhosted.org/packages/f7/29/6c7de6b5d6e511d9e736312c0c9bfcee8f9b6bef68182a08b1d78767e627/jiter-0.11.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:ecd4da91b5415f183a6be8f7158d127bdd9e6a3174138293c0d48d6ea2f2009d", size = 315645, upload-time = "2025-10-17T11:29:20.889Z" },
    { url = "https://files.pythonhosted.org/packages/ac/5f/ef9e5675511ee0eb7f98dd8c90509e1f7743dbb7c350071acae87b0145f3/jiter-0.11.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:d7e3ac25c00b9275684d47aa42febaa90a9958e19fd1726c4ecf755fbe5e553b", size = 348003, upload-time = "2025-10-17T11:29:22.712Z" },
    { url = "https://files.pythonhosted.org/packages/56/1b/abe8c4021010b0a320d3c62682769b700fb66f92c6db02d1a1381b3db025/jiter-0.11.1-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:57d7305c0a841858f866cd459cd9303f73883fb5e097257f3d4a3920722c69d4", size = 365122, upload-time = "2025-10-17T11:29:24.408Z" },
    { url = "https://files.pythonhosted.org/packages/2a/2d/4a18013939a4f24432f805fbd5a19893e64650b933edb057cd405275a538/jiter-0.11.1-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:e86fa10e117dce22c547f31dd6d2a9a222707d54853d8de4e9a2279d2c97f239", size = 488360, upload-time = "2025-10-17T11:29:25.724Z" },
    { url = "https://files.pythonhosted.org/packages/f0/77/38124f5d02ac4131f0dfbcfd1a19a0fac305fa2c005bc4f9f0736914a1a4/jiter-0.11.1-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:ae5ef1d48aec7e01ee8420155d901bb1d192998fa811a65ebb82c043ee186711", size = 376884, upload-time = "2025-10-17T11:29:27.056Z" },
    { url = "https://files.pythonhosted.org/packages/7b/43/59fdc2f6267959b71dd23ce0bd8d4aeaf55566aa435a5d00f53d53c7eb24/jiter-0.11.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:eb68e7bf65c990531ad8715e57d50195daf7c8e6f1509e617b4e692af1108939", size = 358827, upload-time = "2025-10-17T11:29:28.698Z" },
    { url = "https://files.pythonhosted.org/packages/7d/d0/b3cc20ff5340775ea3bbaa0d665518eddecd4266ba7244c9cb480c0c82ec/jiter-0.11.1-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:43b30c8154ded5845fa454ef954ee67bfccce629b2dea7d01f795b42bc2bda54", size = 385171, upload-time = "2025-10-17T11:29:30.078Z" },
    { url = "https://files.pythonhosted.org/packages/d2/bc/94dd1f3a61f4dc236f787a097360ec061ceeebebf4ea120b924d91391b10/jiter-0.11.1-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:586cafbd9dd1f3ce6a22b4a085eaa6be578e47ba9b18e198d4333e598a91db2d", size = 518359, upload-time = "2025-10-17T11:29:31.464Z" },
    { url = "https://files.pythonhosted.org/packages/7e/8c/12ee132bd67e25c75f542c227f5762491b9a316b0dad8e929c95076f773c/jiter-0.11.1-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:677cc2517d437a83bb30019fd4cf7cad74b465914c56ecac3440d597ac135250", size = 509205, upload-time = "2025-10-17T11:29:32.895Z" },
    { url = "https://files.pythonhosted.org/packages/39/d5/9de848928ce341d463c7e7273fce90ea6d0ea4343cd761f451860fa16b59/jiter-0.11.1-cp312-cp312-win32.whl", hash = "sha256:fa992af648fcee2b850a3286a35f62bbbaeddbb6dbda19a00d8fbc846a947b6e", size = 205448, upload-time = "2025-10-17T11:29:34.217Z" },
    { url = "https://files.pythonhosted.org/packages/ee/b0/8002d78637e05009f5e3fb5288f9d57d65715c33b5d6aa20fd57670feef5/jiter-0.11.1-cp312-cp312-win_amd64.whl", hash = "sha256:88b5cae9fa51efeb3d4bd4e52bfd4c85ccc9cac44282e2a9640893a042ba4d87", size = 204285, upload-time = "2025-10-17T11:29:35.446Z" },
    { url = "https://files.pythonhosted.org/packages/9f/a2/bb24d5587e4dff17ff796716542f663deee337358006a80c8af43ddc11e5/jiter-0.11.1-cp312-cp312-win_arm64.whl", hash = "sha256:9a6cae1ab335551917f882f2c3c1efe7617b71b4c02381e4382a8fc80a02588c", size = 188712, upload-time = "2025-10-17T11:29:37.027Z" },
    { url = "https://files.pythonhosted.org/packages/7c/4b/e4dd3c76424fad02a601d570f4f2a8438daea47ba081201a721a903d3f4c/jiter-0.11.1-cp313-cp313-macosx_10_12_x86_64.whl", hash = "sha256:71b6a920a5550f057d49d0e8bcc60945a8da998019e83f01adf110e226267663", size = 305272, upload-time = "2025-10-17T11:29:39.249Z" },
    { url = "https://files.pythonhosted.org/packages/67/83/2cd3ad5364191130f4de80eacc907f693723beaab11a46c7d155b07a092c/jiter-0.11.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:0b3de72e925388453a5171be83379549300db01284f04d2a6f244d1d8de36f94", size = 314038, upload-time = "2025-10-17T11:29:40.563Z" },
    { url = "https://files.pythonhosted.org/packages/d3/3c/8e67d9ba524e97d2f04c8f406f8769a23205026b13b0938d16646d6e2d3e/jiter-0.11.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:cc19dd65a2bd3d9c044c5b4ebf657ca1e6003a97c0fc10f555aa4f7fb9821c00", size = 345977, upload-time = "2025-10-17T11:29:42.009Z" },
    { url = "https://files.pythonhosted.org/packages/8d/a5/489ce64d992c29bccbffabb13961bbb0435e890d7f2d266d1f3df5e917d2/jiter-0.11.1-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:d58faaa936743cd1464540562f60b7ce4fd927e695e8bc31b3da5b914baa9abd", size = 364503, upload-time = "2025-10-17T11:29:43.459Z" },
    { url = "https://files.pythonhosted.org/packages/d4/c0/e321dd83ee231d05c8fe4b1a12caf1f0e8c7a949bf4724d58397104f10f2/jiter-0.11.1-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:902640c3103625317291cb73773413b4d71847cdf9383ba65528745ff89f1d14", size = 487092, upload-time = "2025-10-17T11:29:44.835Z" },
    { url = "https://files.pythonhosted.org/packages/f9/5e/8f24ec49c8d37bd37f34ec0112e0b1a3b4b5a7b456c8efff1df5e189ad43/jiter-0.11.1-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:30405f726e4c2ed487b176c09f8b877a957f535d60c1bf194abb8dadedb5836f", size = 376328, upload-time = "2025-10-17T11:29:46.175Z" },
    { url = "https://files.pythonhosted.org/packages/7f/70/ded107620e809327cf7050727e17ccfa79d6385a771b7fe38fb31318ef00/jiter-0.11.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:3217f61728b0baadd2551844870f65219ac4a1285d5e1a4abddff3d51fdabe96", size = 356632, upload-time = "2025-10-17T11:29:47.454Z" },
    { url = "https://files.pythonhosted.org/packages/19/53/c26f7251613f6a9079275ee43c89b8a973a95ff27532c421abc2a87afb04/jiter-0.11.1-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:b1364cc90c03a8196f35f396f84029f12abe925415049204446db86598c8b72c", size = 384358, upload-time = "2025-10-17T11:29:49.377Z" },
    { url = "https://files.pythonhosted.org/packages/84/16/e0f2cc61e9c4d0b62f6c1bd9b9781d878a427656f88293e2a5335fa8ff07/jiter-0.11.1-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:53a54bf8e873820ab186b2dca9f6c3303f00d65ae5e7b7d6bda1b95aa472d646", size = 517279, upload-time = "2025-10-17T11:29:50.968Z" },
    { url = "https://files.pythonhosted.org/packages/60/5c/4cd095eaee68961bca3081acbe7c89e12ae24a5dae5fd5d2a13e01ed2542/jiter-0.11.1-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:7e29aca023627b0e0c2392d4248f6414d566ff3974fa08ff2ac8dbb96dfee92a", size = 508276, upload-time = "2025-10-17T11:29:52.619Z" },
    { url = "https://files.pythonhosted.org/packages/4f/25/f459240e69b0e09a7706d96ce203ad615ca36b0fe832308d2b7123abf2d0/jiter-0.11.1-cp313-cp313-win32.whl", hash = "sha256:f153e31d8bca11363751e875c0a70b3d25160ecbaee7b51e457f14498fb39d8b", size = 205593, upload-time = "2025-10-17T11:29:53.938Z" },
    { url = "https://files.pythonhosted.org/packages/7c/16/461bafe22bae79bab74e217a09c907481a46d520c36b7b9fe71ee8c9e983/jiter-0.11.1-cp313-cp313-win_amd64.whl", hash = "sha256:f773f84080b667c69c4ea0403fc67bb08b07e2b7ce1ef335dea5868451e60fed", size = 203518, upload-time = "2025-10-17T11:29:55.216Z" },
    { url = "https://files.pythonhosted.org/packages/7b/72/c45de6e320edb4fa165b7b1a414193b3cae302dd82da2169d315dcc78b44/jiter-0.11.1-cp313-cp313-win_arm64.whl", hash = "sha256:635ecd45c04e4c340d2187bcb1cea204c7cc9d32c1364d251564bf42e0e39c2d", size = 188062, upload-time = "2025-10-17T11:29:56.631Z" },
    { url = "https://files.pythonhosted.org/packages/65/9b/4a57922437ca8753ef823f434c2dec5028b237d84fa320f06a3ba1aec6e8/jiter-0.11.1-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:d892b184da4d94d94ddb4031296931c74ec8b325513a541ebfd6dfb9ae89904b", size = 313814, upload-time = "2025-10-17T11:29:58.509Z" },
    { url = "https://files.pythonhosted.org/packages/76/50/62a0683dadca25490a4bedc6a88d59de9af2a3406dd5a576009a73a1d392/jiter-0.11.1-cp313-cp313t-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:aa22c223a3041dacb2fcd37c70dfd648b44662b4a48e242592f95bda5ab09d58", size = 344987, upload-time = "2025-10-17T11:30:00.208Z" },
    { url = "https://files.pythonhosted.org/packages/da/00/2355dbfcbf6cdeaddfdca18287f0f38ae49446bb6378e4a5971e9356fc8a/jiter-0.11.1-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:330e8e6a11ad4980cd66a0f4a3e0e2e0f646c911ce047014f984841924729789", size = 356399, upload-time = "2025-10-17T11:30:02.084Z" },
    { url = "https://files.pythonhosted.org/packages/c9/07/c2bd748d578fa933d894a55bff33f983bc27f75fc4e491b354bef7b78012/jiter-0.11.1-cp313-cp313t-win_amd64.whl", hash = "sha256:09e2e386ebf298547ca3a3704b729471f7ec666c2906c5c26c1a915ea24741ec", size = 203289, upload-time = "2025-10-17T11:30:03.656Z" },
    { url = "https://files.pythonhosted.org/packages/e6/ee/ace64a853a1acbd318eb0ca167bad1cf5ee037207504b83a868a5849747b/jiter-0.11.1-cp313-cp313t-win_arm64.whl", hash = "sha256:fe4a431c291157e11cee7c34627990ea75e8d153894365a3bc84b7a959d23ca8", size = 188284, upload-time = "2025-10-17T11:30:05.046Z" },
    { url = "https://files.pythonhosted.org/packages/9d/51/bd41562dd284e2a18b6dc0a99d195fd4a3560d52ab192c42e56fe0316643/jiter-0.11.1-graalpy311-graalpy242_311_native-macosx_10_12_x86_64.whl", hash = "sha256:e642b5270e61dd02265866398707f90e365b5db2eb65a4f30c789d826682e1f6", size = 306871, upload-time = "2025-10-17T11:31:03.616Z" },
    { url = "https://files.pythonhosted.org/packages/ba/cb/64e7f21dd357e8cd6b3c919c26fac7fc198385bbd1d85bb3b5355600d787/jiter-0.11.1-graalpy311-graalpy242_311_native-macosx_11_0_arm64.whl", hash = "sha256:464ba6d000585e4e2fd1e891f31f1231f497273414f5019e27c00a4b8f7a24ad", size = 301454, upload-time = "2025-10-17T11:31:05.338Z" },
    { url = "https://files.pythonhosted.org/packages/55/b0/54bdc00da4ef39801b1419a01035bd8857983de984fd3776b0be6b94add7/jiter-0.11.1-graalpy311-graalpy242_311_native-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:055568693ab35e0bf3a171b03bb40b2dcb10352359e0ab9b5ed0da2bf1eb6f6f", size = 336801, upload-time = "2025-10-17T11:31:06.893Z" },
    { url = "https://files.pythonhosted.org/packages/de/8f/87176ed071d42e9db415ed8be787ef4ef31a4fa27f52e6a4fbf34387bd28/jiter-0.11.1-graalpy311-graalpy242_311_native-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:e0c69ea798d08a915ba4478113efa9e694971e410056392f4526d796f136d3fa", size = 343452, upload-time = "2025-10-17T11:31:08.259Z" },
    { url = "https://files.pythonhosted.org/packages/a6/bc/950dd7f170c6394b6fdd73f989d9e729bd98907bcc4430ef080a72d06b77/jiter-0.11.1-graalpy312-graalpy250_312_native-macosx_10_12_x86_64.whl", hash = "sha256:0d4d6993edc83cf75e8c6828a8d6ce40a09ee87e38c7bfba6924f39e1337e21d", size = 302626, upload-time = "2025-10-17T11:31:09.645Z" },
    { url = "https://files.pythonhosted.org/packages/3a/65/43d7971ca82ee100b7b9b520573eeef7eabc0a45d490168ebb9a9b5bb8b2/jiter-0.11.1-graalpy312-graalpy250_312_native-macosx_11_0_arm64.whl", hash = "sha256:f78d151c83a87a6cf5461d5ee55bc730dd9ae227377ac6f115b922989b95f838", size = 297034, upload-time = "2025-10-17T11:31:10.975Z" },
    { url = "https://files.pythonhosted.org/packages/19/4c/000e1e0c0c67e96557a279f8969487ea2732d6c7311698819f977abae837/jiter-0.11.1-graalpy312-graalpy250_312_native-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c9022974781155cd5521d5cb10997a03ee5e31e8454c9d999dcdccd253f2353f", size = 337328, upload-time = "2025-10-17T11:31:12.399Z" },
    { url = "https://files.pythonhosted.org/packages/d9/71/71408b02c6133153336d29fa3ba53000f1e1a3f78bb2fc2d1a1865d2e743/jiter-0.11.1-graalpy312-graalpy250_312_native-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:18c77aaa9117510d5bdc6a946baf21b1f0cfa58ef04d31c8d016f206f2118960", size = 343697, upload-time = "2025-10-17T11:31:13.773Z" },
]

[[package]]
name = "jmespath"
version = "1.0.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/00/2a/e867e8531cf3e36b41201936b7fa7ba7b5702dbef42922193f05c8976cd6/jmespath-1.0.1.tar.gz", hash = "sha256:90261b206d6defd58fdd5e85f478bf633a2901798906be2ad389150c5c60edbe", size = 25843, upload-time = "2022-06-17T18:00:12.224Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/31/b4/b9b800c45527aadd64d5b442f9b932b00648617eb5d63d2c7a6587b7cafc/jmespath-1.0.1-py3-none-any.whl", hash = "sha256:02e2e4cc71b5bcab88332eebf907519190dd9e6e82107fa7f83b1003a6252980", size = 20256, upload-time = "2022-06-17T18:00:10.251Z" },
]

[[package]]
name = "joblib"
version = "1.5.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e8/5d/447af5ea094b9e4c4054f82e223ada074c552335b9b4b2d14bd9b35a67c4/joblib-1.5.2.tar.gz", hash = "sha256:3faa5c39054b2f03ca547da9b2f52fde67c06240c31853f306aea97f13647b55", size = 331077, upload-time = "2025-08-27T12:15:46.575Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1e/e8/685f47e0d754320684db4425a0967f7d3fa70126bffd76110b7009a0090f/joblib-1.5.2-py3-none-any.whl", hash = "sha256:4e1f0bdbb987e6d843c70cf43714cb276623def372df3c22fe5266b2670bc241", size = 308396, upload-time = "2025-08-27T12:15:45.188Z" },
]

[[package]]
name = "jsonpath-ng"
version = "1.7.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "ply" },
]
sdist = { url = "https://files.pythonhosted.org/packages/6d/86/08646239a313f895186ff0a4573452038eed8c86f54380b3ebac34d32fb2/jsonpath-ng-1.7.0.tar.gz", hash = "sha256:f6f5f7fd4e5ff79c785f1573b394043b39849fb2bb47bcead935d12b00beab3c", size = 37838, upload-time = "2024-10-11T15:41:42.404Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/35/5a/73ecb3d82f8615f32ccdadeb9356726d6cae3a4bbc840b437ceb95708063/jsonpath_ng-1.7.0-py3-none-any.whl", hash = "sha256:f3d7f9e848cba1b6da28c55b1c26ff915dc9e0b1ba7e752a53d6da8d5cbd00b6", size = 30105, upload-time = "2024-11-20T17:58:30.418Z" },
]

[[package]]
name = "jsonschema"
version = "4.26.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "attrs" },
    { name = "jsonschema-specifications" },
    { name = "referencing" },
    { name = "rpds-py" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b3/fc/e067678238fa451312d4c62bf6e6cf5ec56375422aee02f9cb5f909b3047/jsonschema-4.26.0.tar.gz", hash = "sha256:0c26707e2efad8aa1bfc5b7ce170f3fccc2e4918ff85989ba9ffa9facb2be326", size = 366583, upload-time = "2026-01-07T13:41:07.246Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/69/90/f63fb5873511e014207a475e2bb4e8b2e570d655b00ac19a9a0ca0a385ee/jsonschema-4.26.0-py3-none-any.whl", hash = "sha256:d489f15263b8d200f8387e64b4c3a75f06629559fb73deb8fdfb525f2dab50ce", size = 90630, upload-time = "2026-01-07T13:41:05.306Z" },
]

[[package]]
name = "jsonschema-specifications"
version = "2025.9.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "referencing" },
]
sdist = { url = "https://files.pythonhosted.org/packages/19/74/a633ee74eb36c44aa6d1095e7cc5569bebf04342ee146178e2d36600708b/jsonschema_specifications-2025.9.1.tar.gz", hash = "sha256:b540987f239e745613c7a9176f3edb72b832a4ac465cf02712288397832b5e8d", size = 32855, upload-time = "2025-09-08T01:34:59.186Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/41/45/1a4ed80516f02155c51f51e8cedb3c1902296743db0bbc66608a0db2814f/jsonschema_specifications-2025.9.1-py3-none-any.whl", hash = "sha256:98802fee3a11ee76ecaca44429fda8a41bff98b00a0f2838151b113f210cc6fe", size = 18437, upload-time = "2025-09-08T01:34:57.871Z" },
]

[[package]]
name = "langfuse"
version = "3.12.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "backoff" },
    { name = "httpx" },
    { name = "openai" },
    { name = "opentelemetry-api" },
    { name = "opentelemetry-exporter-otlp-proto-http" },
    { name = "opentelemetry-sdk" },
    { name = "packaging" },
    { name = "pydantic" },
    { name = "requests" },
    { name = "wrapt" },
]
sdist = { url = "https://files.pythonhosted.org/packages/f3/87/c28a09b696a1b908cf59b201d01e69066aeab804163d8dba055811790ed5/langfuse-3.12.1.tar.gz", hash = "sha256:da3bf4c0469eab4305f88a63cbb5ef89cf7542abbbcc9136a35c1bc708810520", size = 232768, upload-time = "2026-01-27T06:11:24.648Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1e/51/a5752417d704831f8c9fc4d7ec070342dee21d781d92e6fe937e60912e61/langfuse-3.12.1-py3-none-any.whl", hash = "sha256:ccf091ed6b6e0d9d4dbc95ad5cbb0f60c4452ce95b18c114ed5896f4546af38f", size = 416999, upload-time = "2026-01-27T06:11:22.657Z" },
]

[[package]]
name = "linkify-it-py"
version = "2.0.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "uc-micro-py" },
]
sdist = { url = "https://files.pythonhosted.org/packages/2a/ae/bb56c6828e4797ba5a4821eec7c43b8bf40f69cda4d4f5f8c8a2810ec96a/linkify-it-py-2.0.3.tar.gz", hash = "sha256:68cda27e162e9215c17d786649d1da0021a451bdc436ef9e0fa0ba5234b9b048", size = 27946, upload-time = "2024-02-04T14:48:04.179Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/04/1e/b832de447dee8b582cac175871d2f6c3d5077cc56d5575cadba1fd1cccfa/linkify_it_py-2.0.3-py3-none-any.whl", hash = "sha256:6bcbc417b0ac14323382aef5c5192c0075bf8a9d6b41820a2b66371eac6b6d79", size = 19820, upload-time = "2024-02-04T14:48:02.496Z" },
]

[[package]]
name = "llama-cloud"
version = "0.1.35"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "certifi" },
    { name = "httpx" },
    { name = "pydantic" },
]
sdist = { url = "https://files.pythonhosted.org/packages/9b/72/816e6e900448e1b4a8137d90e65876b296c5264a23db6ae888bd3e6660ba/llama_cloud-0.1.35.tar.gz", hash = "sha256:200349d5d57424d7461f304cdb1355a58eea3e6ca1e6b0d75c66b2e937216983", size = 106403, upload-time = "2025-07-28T17:22:06.41Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1d/d2/8d18a021ab757cea231428404f21fe3186bf1ebaac3f57a73c379483fd3f/llama_cloud-0.1.35-py3-none-any.whl", hash = "sha256:b7abab4423118e6f638d2f326749e7a07c6426543bea6da99b623c715b22af71", size = 303280, upload-time = "2025-07-28T17:22:04.946Z" },
]

[[package]]
name = "llama-cloud-services"
version = "0.6.54"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "llama-cloud" },
    { name = "llama-index-core" },
    { name = "platformdirs" },
    { name = "pydantic" },
    { name = "python-dotenv" },
    { name = "tenacity" },
]
sdist = { url = "https://files.pythonhosted.org/packages/8a/0c/8ca87d33bea0340a8ed791f36390112aeb29fd3eebfd64b6aef6204a03f0/llama_cloud_services-0.6.54.tar.gz", hash = "sha256:baf65d9bffb68f9dca98ac6e22908b6675b2038b021e657ead1ffc0e43cbd45d", size = 53468, upload-time = "2025-08-01T20:09:20.988Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7f/48/4e295e3f791b279885a2e584f71e75cbe4ac84e93bba3c36e2668f60a8ac/llama_cloud_services-0.6.54-py3-none-any.whl", hash = "sha256:07f595f7a0ba40c6a1a20543d63024ca7600fe65c4811d1951039977908997be", size = 63874, upload-time = "2025-08-01T20:09:20.076Z" },
]

[[package]]
name = "llama-index"
version = "0.14.4"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-cli" },
    { name = "llama-index-core" },
    { name = "llama-index-embeddings-openai" },
    { name = "llama-index-indices-managed-llama-cloud" },
    { name = "llama-index-llms-openai" },
    { name = "llama-index-readers-file" },
    { name = "llama-index-readers-llama-parse" },
    { name = "nltk" },
]
sdist = { url = "https://files.pythonhosted.org/packages/05/59/1ce3ed6807a4bf445cdcf44c2881888dd4a8d1c7395e29d0839f2b7e6dd9/llama_index-0.14.4.tar.gz", hash = "sha256:1fe9f633df313a76bb6d7cf40c3512b6324e08003130b2a38d9418d02e0bfb52", size = 8446, upload-time = "2025-10-03T17:43:16.511Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0e/57/04dd48582f4964cfbdb98ff1f5efcc86f5638eb69db3c1646cc6b10e2fbc/llama_index-0.14.4-py3-none-any.whl", hash = "sha256:f6effb2d6c875eaf17a24353c8e7c3c5cc79990d4e30ff3a3f5dc5e14edb4b5e", size = 7445, upload-time = "2025-10-03T17:43:15.144Z" },
]

[[package]]
name = "llama-index-callbacks-arize-phoenix"
version = "0.6.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-core" },
    { name = "openinference-instrumentation-llama-index" },
]
sdist = { url = "https://files.pythonhosted.org/packages/04/b2/caa1d802459a7ec9011c99a39f42ff5cad53fa4bc2ce65b429c82408b71e/llama_index_callbacks_arize_phoenix-0.6.1.tar.gz", hash = "sha256:0d8d92d8768e1a30fb6dbb601fb89e1590d7bcff7b3fd818c4859fb7992f6c6d", size = 2715, upload-time = "2025-09-08T20:13:43.394Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e6/3c/3a47c2fbaec9aee93d59b7e3eb70954ffb4eb21829570348d079018e4a30/llama_index_callbacks_arize_phoenix-0.6.1-py3-none-any.whl", hash = "sha256:168a4dca29de19c5b43d3abb71feb901be9175f65a91b786a44d73b85e3bea0e", size = 3110, upload-time = "2025-09-08T20:13:42.702Z" },
]

[[package]]
name = "llama-index-cli"
version = "0.5.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-core" },
    { name = "llama-index-embeddings-openai" },
    { name = "llama-index-llms-openai" },
]
sdist = { url = "https://files.pythonhosted.org/packages/67/84/41e820efffbe327c38228d3b37fe42512a37e0c3ee4ff6bf97a394e9577a/llama_index_cli-0.5.3.tar.gz", hash = "sha256:ebaf39e785efbfa8d50d837f60cb0f95125c04bf73ed1f92092a2a5f506172f8", size = 24821, upload-time = "2025-09-29T18:03:10.798Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/54/81/b7b3778aa8662913760fbbee77578daf4407aeaa677ccbf0125c4cfa2e67/llama_index_cli-0.5.3-py3-none-any.whl", hash = "sha256:7deb1e953e582bd885443881ce8bd6ab2817b594fef00079dce9993c47d990f7", size = 28173, upload-time = "2025-09-29T18:03:10.024Z" },
]

[[package]]
name = "llama-index-core"
version = "0.14.7"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "aiohttp" },
    { name = "aiosqlite" },
    { name = "banks" },
    { name = "dataclasses-json" },
    { name = "deprecated" },
    { name = "dirtyjson" },
    { name = "filetype" },
    { name = "fsspec" },
    { name = "httpx" },
    { name = "llama-index-workflows" },
    { name = "nest-asyncio" },
    { name = "networkx" },
    { name = "nltk" },
    { name = "numpy" },
    { name = "pillow" },
    { name = "platformdirs" },
    { name = "pydantic" },
    { name = "pyyaml" },
    { name = "requests" },
    { name = "setuptools" },
    { name = "sqlalchemy", extra = ["asyncio"] },
    { name = "tenacity" },
    { name = "tiktoken" },
    { name = "tqdm" },
    { name = "typing-extensions" },
    { name = "typing-inspect" },
    { name = "wrapt" },
]
sdist = { url = "https://files.pythonhosted.org/packages/53/a8/11f128ad6e1918ae56aecf4f99619ef16acba31a7dfdad47f9801dc7ab0b/llama_index_core-0.14.7.tar.gz", hash = "sha256:ceacf30131b84c72e4881748ef428f5392ab484adf1c0e7e0f1048b2b98eb70e", size = 11578585, upload-time = "2025-10-30T23:08:09.091Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/80/0a/5e9b9b1b10b58df1f6c219872b19ffd41cc49bdad58b1c24a2c971883c11/llama_index_core-0.14.7-py3-none-any.whl", hash = "sha256:568591a27dd171f9d5299155920bfef6bac9e7fa59df200404877a57b7973765", size = 11919918, upload-time = "2025-10-30T23:08:06.202Z" },
]

[[package]]
name = "llama-index-embeddings-openai"
version = "0.5.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-core" },
    { name = "openai" },
]
sdist = { url = "https://files.pythonhosted.org/packages/10/36/90336d054a5061a3f5bc17ac2c18ef63d9d84c55c14d557de484e811ea4d/llama_index_embeddings_openai-0.5.1.tar.gz", hash = "sha256:1c89867a48b0d0daa3d2d44f5e76b394b2b2ef9935932daf921b9e77939ccda8", size = 7020, upload-time = "2025-09-08T20:17:44.681Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/23/4a/8ab11026cf8deff8f555aa73919be0bac48332683111e5fc4290f352dc50/llama_index_embeddings_openai-0.5.1-py3-none-any.whl", hash = "sha256:a2fcda3398bbd987b5ce3f02367caee8e84a56b930fdf43cc1d059aa9fd20ca5", size = 7011, upload-time = "2025-09-08T20:17:44.015Z" },
]

[[package]]
name = "llama-index-indices-managed-llama-cloud"
version = "0.9.4"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "deprecated" },
    { name = "llama-cloud" },
    { name = "llama-index-core" },
]
sdist = { url = "https://files.pythonhosted.org/packages/61/4a/79044fcb3209583d1ffe0c2a7c19dddfb657a03faeb9fe0cf5a74027e646/llama_index_indices_managed_llama_cloud-0.9.4.tar.gz", hash = "sha256:b5e00752ab30564abf19c57595a2107f5697c3b03b085817b4fca84a38ebbd59", size = 15146, upload-time = "2025-09-08T20:29:58.673Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a6/6a/0e33245df06afc9766c46a1fe92687be8a09da5d0d0128bc08d84a9f5efa/llama_index_indices_managed_llama_cloud-0.9.4-py3-none-any.whl", hash = "sha256:535a08811046803ca6ab7f8e9d510e926aa5306608b02201ad3d9d21701383bc", size = 17005, upload-time = "2025-09-08T20:29:57.876Z" },
]

[[package]]
name = "llama-index-instrumentation"
version = "0.4.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "deprecated" },
    { name = "pydantic" },
]
sdist = { url = "https://files.pythonhosted.org/packages/af/b9/a7a74de6d8aacf4be329329495983d78d96b1a6e69b6d9fcf4a233febd4b/llama_index_instrumentation-0.4.2.tar.gz", hash = "sha256:dc4957b64da0922060690e85a6be9698ac08e34e0f69e90b01364ddec4f3de7f", size = 46146, upload-time = "2025-10-13T20:44:48.85Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/40/54/df8063b0441242e250e03d1e31ebde5dffbe24e1af32b025cb1a4544150c/llama_index_instrumentation-0.4.2-py3-none-any.whl", hash = "sha256:b4989500e6454059ab3f3c4a193575d47ab1fadb730c2e8f2b962649ae88b70b", size = 15411, upload-time = "2025-10-13T20:44:47.685Z" },
]

[[package]]
name = "llama-index-llms-anthropic"
version = "0.8.6"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anthropic", extra = ["bedrock", "vertex"] },
    { name = "llama-index-core" },
]
sdist = { url = "https://files.pythonhosted.org/packages/cc/3b/21654a99c82be2b30bbc72a45de6bcd12477f931fad78de371f50ca94539/llama_index_llms_anthropic-0.8.6.tar.gz", hash = "sha256:1aafdb83629af6aff7f44f8c91a772de15269f878e5a14d0d056d6a9fe644c5c", size = 12729, upload-time = "2025-09-08T20:40:37.404Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/dc/7b/2212365c6d672b62f567c0d23918c68290091358fa7daac30461c2aa564e/llama_index_llms_anthropic-0.8.6-py3-none-any.whl", hash = "sha256:7887bf6540af4b016505e04eab4a5426e1d8d367d170b424f0b3160596faa1ea", size = 12905, upload-time = "2025-09-08T20:40:36.552Z" },
]

[[package]]
name = "llama-index-llms-deepseek"
version = "0.2.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-llms-openai-like" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b6/fe/9d1bb5818142b4e4aed265a7d97b57e752ade86a53edf3ec11a1bd091669/llama_index_llms_deepseek-0.2.2.tar.gz", hash = "sha256:52bd4f9a493770cb84c62c288b72593ef4982c4e0c1f7d636f39f5d4f0b1d3d2", size = 3726, upload-time = "2025-09-16T01:53:26.43Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/48/8a/51b9e1dd13699ddc875966a4157ba941b4994aab1f2541edc0db2e3bd759/llama_index_llms_deepseek-0.2.2-py3-none-any.whl", hash = "sha256:81bf01d221a8f4b7a18db518af96219f79fae396e84ab102b9734b94695eebba", size = 3578, upload-time = "2025-09-16T01:53:25.615Z" },
]

[[package]]
name = "llama-index-llms-google-genai"
version = "0.8.5"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "google-genai" },
    { name = "llama-index-core" },
    { name = "pillow" },
]
sdist = { url = "https://files.pythonhosted.org/packages/92/7d/107f3a256dd2ada09fed58b9ea8588eaf9b355746089eedab5e207b6c078/llama_index_llms_google_genai-0.8.5.tar.gz", hash = "sha256:64c319a5a288881161806929a7a3bc06eb90b4d085d4f5a6eddda9375376785c", size = 13457, upload-time = "2026-01-30T11:08:33.424Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/42/5a/2cf8b4fb860f239a9913e4deb4c8ea07c1760abfaa27c9abd7a505ca4e58/llama_index_llms_google_genai-0.8.5-py3-none-any.whl", hash = "sha256:5a28436eb338fc47654811cae3f3d75e467d3def900a2f1dd0454a88e77d550a", size = 14046, upload-time = "2026-01-30T11:08:34.561Z" },
]

[[package]]
name = "llama-index-llms-ollama"
version = "0.9.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-core" },
    { name = "ollama" },
]
sdist = { url = "https://files.pythonhosted.org/packages/05/10/8be8a0f057ea2834c92b6f5db72317b36d007f8dfae14c485921934b30c0/llama_index_llms_ollama-0.9.0.tar.gz", hash = "sha256:cdfa167f7ea8074fbfd50b3e80153d6d05fa3b4e72e530b18dc54f77518503d1", size = 8986, upload-time = "2025-10-27T15:52:47.717Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/50/6d/068dd19afbce84af2706a6ba12bb1c7c19f06c75ee00b2ce3d4418cd9c71/llama_index_llms_ollama-0.9.0-py3-none-any.whl", hash = "sha256:af1799ac7d3a7fee72256c2533b20f786119703108ccb2678d877cf918945173", size = 8640, upload-time = "2025-10-27T15:52:46.586Z" },
]

[[package]]
name = "llama-index-llms-openai"
version = "0.6.7"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-core" },
    { name = "openai" },
]
sdist = { url = "https://files.pythonhosted.org/packages/02/64/62c079203c659ba379a286c36d556a9f88098976d4eac76ed3892d42fc0b/llama_index_llms_openai-0.6.7.tar.gz", hash = "sha256:70ec68233fc4a3fbce3fccd21ad427013a74e51768986d4e57a1860365abc824", size = 25518, upload-time = "2025-11-03T15:20:03.139Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/61/a2/1180fe8133bf9aac067d26526bf7e89362f45ebae7993efadb4718fcbd0d/llama_index_llms_openai-0.6.7-py3-none-any.whl", hash = "sha256:39dbffb8d31f9bf9f4fa799042ff1f06aefc735387adaae17c2facc867093351", size = 26520, upload-time = "2025-11-03T15:20:02.129Z" },
]

[[package]]
name = "llama-index-llms-openai-like"
version = "0.5.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-core" },
    { name = "llama-index-llms-openai" },
    { name = "transformers" },
]
sdist = { url = "https://files.pythonhosted.org/packages/9b/fd/aed635d298380cfdc84a4e475a8367d8fcdd4677cd8914de2f495edea28d/llama_index_llms_openai_like-0.5.3.tar.gz", hash = "sha256:84bdfc88bb5d9ea806bdd1be4b4378357781c0637c78c548242aac857f165090", size = 4993, upload-time = "2025-09-28T23:48:26.659Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/aa/22/3d15a3f0f2c4befecb8e7a81a4a0bbd3121f567b22b9ac34817ecf15a155/llama_index_llms_openai_like-0.5.3-py3-none-any.whl", hash = "sha256:9ef2374916427e1a21db0ea5f624056fb323e13308c6722b3de0384dfecd467b", size = 4689, upload-time = "2025-09-28T23:48:25.557Z" },
]

[[package]]
name = "llama-index-llms-openrouter"
version = "0.4.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-core" },
    { name = "llama-index-llms-openai-like" },
]
sdist = { url = "https://files.pythonhosted.org/packages/82/92/1931afb4edf2e4a4ecef9f64bcc33143449bc70f56287a4b495d4a1043ad/llama_index_llms_openrouter-0.4.2.tar.gz", hash = "sha256:af09829b2ebc8ccb22b7afe7ad92fe8ce35ea9a3be2430ec811416bad7d7edb9", size = 4565, upload-time = "2025-09-29T16:59:26.159Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1f/6b/80c7259de8020e1f64e0c746e3f8cde3bc48288f842bbba8f8ab9810ae24/llama_index_llms_openrouter-0.4.2-py3-none-any.whl", hash = "sha256:a7c91ddc90b2c68c47722e81a72641a423045499773d2c38ed74b622be45c18a", size = 4502, upload-time = "2025-09-29T16:59:25.119Z" },
]

[[package]]
name = "llama-index-readers-file"
version = "0.5.4"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "beautifulsoup4" },
    { name = "defusedxml" },
    { name = "llama-index-core" },
    { name = "pandas" },
    { name = "pypdf" },
    { name = "striprtf" },
]
sdist = { url = "https://files.pythonhosted.org/packages/01/d9/c67ad2b9cba8dacf1d4a55fe5432357b6eceaecfb096a0de5c1cbd959b98/llama_index_readers_file-0.5.4.tar.gz", hash = "sha256:5e766f32597622e66529464101914548ad683770a0a5d2bdc9ee84eb3a110332", size = 32565, upload-time = "2025-09-08T20:39:40.287Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ea/e3/76d72a7281b9c88d488908731c9034e1ee1a2cad5aa1dead76b051eca989/llama_index_readers_file-0.5.4-py3-none-any.whl", hash = "sha256:135be5ddda66c5b35883911918b2d99f67a2ab010d180af5630c872ea9509d45", size = 51827, upload-time = "2025-09-08T20:39:39.408Z" },
]

[[package]]
name = "llama-index-readers-llama-parse"
version = "0.5.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-core" },
    { name = "llama-parse" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b3/77/5bfaab20e6ec8428dbf2352e18be550c957602723d69383908176b5686cd/llama_index_readers_llama_parse-0.5.1.tar.gz", hash = "sha256:2b78b73faa933e30e6c69df351e4e9f36dfe2ae142e2ab3969ddd2ac48930e37", size = 3858, upload-time = "2025-09-08T20:41:29.201Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/68/81/52410c7245dcbf1a54756a9ce3892cdd167ec0b884d696de1304ca3f452e/llama_index_readers_llama_parse-0.5.1-py3-none-any.whl", hash = "sha256:0d41450ed29b0c49c024e206ef6c8e662b1854e77a1c5faefed3b958be54f880", size = 3203, upload-time = "2025-09-08T20:41:28.438Z" },
]

[[package]]
name = "llama-index-workflows"
version = "2.8.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-index-instrumentation" },
    { name = "pydantic" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/53/8e/1ad4e546ce8dc744c2170e522dc90ee471de871032374fc2f6b93bb69630/llama_index_workflows-2.8.3.tar.gz", hash = "sha256:442072b6d44b6c947e8dc2cbd3be1a8586a1e334c4c01ff0bd3e80139da52497", size = 4991631, upload-time = "2025-10-17T16:30:46.337Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9c/e1/8d448481dde7605b85058f117d9220d2c6f675a90abc11fc1bd781f26087/llama_index_workflows-2.8.3-py3-none-any.whl", hash = "sha256:450c2b6f32ebbf8ff4d48069209e0c4621135674be95220ee5c015e833795f34", size = 61322, upload-time = "2025-10-17T16:30:44.799Z" },
]

[[package]]
name = "llama-parse"
version = "0.6.54"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "llama-cloud-services" },
]
sdist = { url = "https://files.pythonhosted.org/packages/08/f6/93b5d123c480bc8c93e6dc3ea930f4f8df8da27f829bb011100ba3ce23dc/llama_parse-0.6.54.tar.gz", hash = "sha256:c707b31152155c9bae84e316fab790bbc8c85f4d8825ce5ee386ebeb7db258f1", size = 3577, upload-time = "2025-08-01T20:09:23.762Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/05/50/c5ccd2a50daa0a10c7f3f7d4e6992392454198cd8a7d99fcb96cb60d0686/llama_parse-0.6.54-py3-none-any.whl", hash = "sha256:c66c8d51cf6f29a44eaa8595a595de5d2598afc86e5a33a4cebe5fe228036920", size = 4879, upload-time = "2025-08-01T20:09:22.651Z" },
]

[[package]]
name = "mako"
version = "1.3.10"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markupsafe" },
]
sdist = { url = "https://files.pythonhosted.org/packages/9e/38/bd5b78a920a64d708fe6bc8e0a2c075e1389d53bef8413725c63ba041535/mako-1.3.10.tar.gz", hash = "sha256:99579a6f39583fa7e5630a28c3c1f440e4e97a414b80372649c0ce338da2ea28", size = 392474, upload-time = "2025-04-10T12:44:31.16Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/87/fb/99f81ac72ae23375f22b7afdb7642aba97c00a713c217124420147681a2f/mako-1.3.10-py3-none-any.whl", hash = "sha256:baef24a52fc4fc514a0887ac600f9f1cff3d82c61d4d700a1fa84d597b88db59", size = 78509, upload-time = "2025-04-10T12:50:53.297Z" },
]

[[package]]
name = "markdown-it-py"
version = "4.0.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "mdurl" },
]
sdist = { url = "https://files.pythonhosted.org/packages/5b/f5/4ec618ed16cc4f8fb3b701563655a69816155e79e24a17b651541804721d/markdown_it_py-4.0.0.tar.gz", hash = "sha256:cb0a2b4aa34f932c007117b194e945bd74e0ec24133ceb5bac59009cda1cb9f3", size = 73070, upload-time = "2025-08-11T12:57:52.854Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/94/54/e7d793b573f298e1c9013b8c4dade17d481164aa517d1d7148619c2cedbf/markdown_it_py-4.0.0-py3-none-any.whl", hash = "sha256:87327c59b172c5011896038353a81343b6754500a08cd7a4973bb48c6d578147", size = 87321, upload-time = "2025-08-11T12:57:51.923Z" },
]

[package.optional-dependencies]
linkify = [
    { name = "linkify-it-py" },
]

[[package]]
name = "markupsafe"
version = "3.0.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/7e/99/7690b6d4034fffd95959cbe0c02de8deb3098cc577c67bb6a24fe5d7caa7/markupsafe-3.0.3.tar.gz", hash = "sha256:722695808f4b6457b320fdc131280796bdceb04ab50fe1795cd540799ebe1698", size = 80313, upload-time = "2025-09-27T18:37:40.426Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/08/db/fefacb2136439fc8dd20e797950e749aa1f4997ed584c62cfb8ef7c2be0e/markupsafe-3.0.3-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:1cc7ea17a6824959616c525620e387f6dd30fec8cb44f649e31712db02123dad", size = 11631, upload-time = "2025-09-27T18:36:18.185Z" },
    { url = "https://files.pythonhosted.org/packages/e1/2e/5898933336b61975ce9dc04decbc0a7f2fee78c30353c5efba7f2d6ff27a/markupsafe-3.0.3-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:4bd4cd07944443f5a265608cc6aab442e4f74dff8088b0dfc8238647b8f6ae9a", size = 12058, upload-time = "2025-09-27T18:36:19.444Z" },
    { url = "https://files.pythonhosted.org/packages/1d/09/adf2df3699d87d1d8184038df46a9c80d78c0148492323f4693df54e17bb/markupsafe-3.0.3-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:6b5420a1d9450023228968e7e6a9ce57f65d148ab56d2313fcd589eee96a7a50", size = 24287, upload-time = "2025-09-27T18:36:20.768Z" },
    { url = "https://files.pythonhosted.org/packages/30/ac/0273f6fcb5f42e314c6d8cd99effae6a5354604d461b8d392b5ec9530a54/markupsafe-3.0.3-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:0bf2a864d67e76e5c9a34dc26ec616a66b9888e25e7b9460e1c76d3293bd9dbf", size = 22940, upload-time = "2025-09-27T18:36:22.249Z" },
    { url = "https://files.pythonhosted.org/packages/19/ae/31c1be199ef767124c042c6c3e904da327a2f7f0cd63a0337e1eca2967a8/markupsafe-3.0.3-cp311-cp311-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:bc51efed119bc9cfdf792cdeaa4d67e8f6fcccab66ed4bfdd6bde3e59bfcbb2f", size = 21887, upload-time = "2025-09-27T18:36:23.535Z" },
    { url = "https://files.pythonhosted.org/packages/b2/76/7edcab99d5349a4532a459e1fe64f0b0467a3365056ae550d3bcf3f79e1e/markupsafe-3.0.3-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:068f375c472b3e7acbe2d5318dea141359e6900156b5b2ba06a30b169086b91a", size = 23692, upload-time = "2025-09-27T18:36:24.823Z" },
    { url = "https://files.pythonhosted.org/packages/a4/28/6e74cdd26d7514849143d69f0bf2399f929c37dc2b31e6829fd2045b2765/markupsafe-3.0.3-cp311-cp311-musllinux_1_2_riscv64.whl", hash = "sha256:7be7b61bb172e1ed687f1754f8e7484f1c8019780f6f6b0786e76bb01c2ae115", size = 21471, upload-time = "2025-09-27T18:36:25.95Z" },
    { url = "https://files.pythonhosted.org/packages/62/7e/a145f36a5c2945673e590850a6f8014318d5577ed7e5920a4b3448e0865d/markupsafe-3.0.3-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:f9e130248f4462aaa8e2552d547f36ddadbeaa573879158d721bbd33dfe4743a", size = 22923, upload-time = "2025-09-27T18:36:27.109Z" },
    { url = "https://files.pythonhosted.org/packages/0f/62/d9c46a7f5c9adbeeeda52f5b8d802e1094e9717705a645efc71b0913a0a8/markupsafe-3.0.3-cp311-cp311-win32.whl", hash = "sha256:0db14f5dafddbb6d9208827849fad01f1a2609380add406671a26386cdf15a19", size = 14572, upload-time = "2025-09-27T18:36:28.045Z" },
    { url = "https://files.pythonhosted.org/packages/83/8a/4414c03d3f891739326e1783338e48fb49781cc915b2e0ee052aa490d586/markupsafe-3.0.3-cp311-cp311-win_amd64.whl", hash = "sha256:de8a88e63464af587c950061a5e6a67d3632e36df62b986892331d4620a35c01", size = 15077, upload-time = "2025-09-27T18:36:29.025Z" },
    { url = "https://files.pythonhosted.org/packages/35/73/893072b42e6862f319b5207adc9ae06070f095b358655f077f69a35601f0/markupsafe-3.0.3-cp311-cp311-win_arm64.whl", hash = "sha256:3b562dd9e9ea93f13d53989d23a7e775fdfd1066c33494ff43f5418bc8c58a5c", size = 13876, upload-time = "2025-09-27T18:36:29.954Z" },
    { url = "https://files.pythonhosted.org/packages/5a/72/147da192e38635ada20e0a2e1a51cf8823d2119ce8883f7053879c2199b5/markupsafe-3.0.3-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:d53197da72cc091b024dd97249dfc7794d6a56530370992a5e1a08983ad9230e", size = 11615, upload-time = "2025-09-27T18:36:30.854Z" },
    { url = "https://files.pythonhosted.org/packages/9a/81/7e4e08678a1f98521201c3079f77db69fb552acd56067661f8c2f534a718/markupsafe-3.0.3-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:1872df69a4de6aead3491198eaf13810b565bdbeec3ae2dc8780f14458ec73ce", size = 12020, upload-time = "2025-09-27T18:36:31.971Z" },
    { url = "https://files.pythonhosted.org/packages/1e/2c/799f4742efc39633a1b54a92eec4082e4f815314869865d876824c257c1e/markupsafe-3.0.3-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:3a7e8ae81ae39e62a41ec302f972ba6ae23a5c5396c8e60113e9066ef893da0d", size = 24332, upload-time = "2025-09-27T18:36:32.813Z" },
    { url = "https://files.pythonhosted.org/packages/3c/2e/8d0c2ab90a8c1d9a24f0399058ab8519a3279d1bd4289511d74e909f060e/markupsafe-3.0.3-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:d6dd0be5b5b189d31db7cda48b91d7e0a9795f31430b7f271219ab30f1d3ac9d", size = 22947, upload-time = "2025-09-27T18:36:33.86Z" },
    { url = "https://files.pythonhosted.org/packages/2c/54/887f3092a85238093a0b2154bd629c89444f395618842e8b0c41783898ea/markupsafe-3.0.3-cp312-cp312-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:94c6f0bb423f739146aec64595853541634bde58b2135f27f61c1ffd1cd4d16a", size = 21962, upload-time = "2025-09-27T18:36:35.099Z" },
    { url = "https://files.pythonhosted.org/packages/c9/2f/336b8c7b6f4a4d95e91119dc8521402461b74a485558d8f238a68312f11c/markupsafe-3.0.3-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:be8813b57049a7dc738189df53d69395eba14fb99345e0a5994914a3864c8a4b", size = 23760, upload-time = "2025-09-27T18:36:36.001Z" },
    { url = "https://files.pythonhosted.org/packages/32/43/67935f2b7e4982ffb50a4d169b724d74b62a3964bc1a9a527f5ac4f1ee2b/markupsafe-3.0.3-cp312-cp312-musllinux_1_2_riscv64.whl", hash = "sha256:83891d0e9fb81a825d9a6d61e3f07550ca70a076484292a70fde82c4b807286f", size = 21529, upload-time = "2025-09-27T18:36:36.906Z" },
    { url = "https://files.pythonhosted.org/packages/89/e0/4486f11e51bbba8b0c041098859e869e304d1c261e59244baa3d295d47b7/markupsafe-3.0.3-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:77f0643abe7495da77fb436f50f8dab76dbc6e5fd25d39589a0f1fe6548bfa2b", size = 23015, upload-time = "2025-09-27T18:36:37.868Z" },
    { url = "https://files.pythonhosted.org/packages/2f/e1/78ee7a023dac597a5825441ebd17170785a9dab23de95d2c7508ade94e0e/markupsafe-3.0.3-cp312-cp312-win32.whl", hash = "sha256:d88b440e37a16e651bda4c7c2b930eb586fd15ca7406cb39e211fcff3bf3017d", size = 14540, upload-time = "2025-09-27T18:36:38.761Z" },
    { url = "https://files.pythonhosted.org/packages/aa/5b/bec5aa9bbbb2c946ca2733ef9c4ca91c91b6a24580193e891b5f7dbe8e1e/markupsafe-3.0.3-cp312-cp312-win_amd64.whl", hash = "sha256:26a5784ded40c9e318cfc2bdb30fe164bdb8665ded9cd64d500a34fb42067b1c", size = 15105, upload-time = "2025-09-27T18:36:39.701Z" },
    { url = "https://files.pythonhosted.org/packages/e5/f1/216fc1bbfd74011693a4fd837e7026152e89c4bcf3e77b6692fba9923123/markupsafe-3.0.3-cp312-cp312-win_arm64.whl", hash = "sha256:35add3b638a5d900e807944a078b51922212fb3dedb01633a8defc4b01a3c85f", size = 13906, upload-time = "2025-09-27T18:36:40.689Z" },
    { url = "https://files.pythonhosted.org/packages/38/2f/907b9c7bbba283e68f20259574b13d005c121a0fa4c175f9bed27c4597ff/markupsafe-3.0.3-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:e1cf1972137e83c5d4c136c43ced9ac51d0e124706ee1c8aa8532c1287fa8795", size = 11622, upload-time = "2025-09-27T18:36:41.777Z" },
    { url = "https://files.pythonhosted.org/packages/9c/d9/5f7756922cdd676869eca1c4e3c0cd0df60ed30199ffd775e319089cb3ed/markupsafe-3.0.3-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:116bb52f642a37c115f517494ea5feb03889e04df47eeff5b130b1808ce7c219", size = 12029, upload-time = "2025-09-27T18:36:43.257Z" },
    { url = "https://files.pythonhosted.org/packages/00/07/575a68c754943058c78f30db02ee03a64b3c638586fba6a6dd56830b30a3/markupsafe-3.0.3-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:133a43e73a802c5562be9bbcd03d090aa5a1fe899db609c29e8c8d815c5f6de6", size = 24374, upload-time = "2025-09-27T18:36:44.508Z" },
    { url = "https://files.pythonhosted.org/packages/a9/21/9b05698b46f218fc0e118e1f8168395c65c8a2c750ae2bab54fc4bd4e0e8/markupsafe-3.0.3-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:ccfcd093f13f0f0b7fdd0f198b90053bf7b2f02a3927a30e63f3ccc9df56b676", size = 22980, upload-time = "2025-09-27T18:36:45.385Z" },
    { url = "https://files.pythonhosted.org/packages/7f/71/544260864f893f18b6827315b988c146b559391e6e7e8f7252839b1b846a/markupsafe-3.0.3-cp313-cp313-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:509fa21c6deb7a7a273d629cf5ec029bc209d1a51178615ddf718f5918992ab9", size = 21990, upload-time = "2025-09-27T18:36:46.916Z" },
    { url = "https://files.pythonhosted.org/packages/c2/28/b50fc2f74d1ad761af2f5dcce7492648b983d00a65b8c0e0cb457c82ebbe/markupsafe-3.0.3-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:a4afe79fb3de0b7097d81da19090f4df4f8d3a2b3adaa8764138aac2e44f3af1", size = 23784, upload-time = "2025-09-27T18:36:47.884Z" },
    { url = "https://files.pythonhosted.org/packages/ed/76/104b2aa106a208da8b17a2fb72e033a5a9d7073c68f7e508b94916ed47a9/markupsafe-3.0.3-cp313-cp313-musllinux_1_2_riscv64.whl", hash = "sha256:795e7751525cae078558e679d646ae45574b47ed6e7771863fcc079a6171a0fc", size = 21588, upload-time = "2025-09-27T18:36:48.82Z" },
    { url = "https://files.pythonhosted.org/packages/b5/99/16a5eb2d140087ebd97180d95249b00a03aa87e29cc224056274f2e45fd6/markupsafe-3.0.3-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:8485f406a96febb5140bfeca44a73e3ce5116b2501ac54fe953e488fb1d03b12", size = 23041, upload-time = "2025-09-27T18:36:49.797Z" },
    { url = "https://files.pythonhosted.org/packages/19/bc/e7140ed90c5d61d77cea142eed9f9c303f4c4806f60a1044c13e3f1471d0/markupsafe-3.0.3-cp313-cp313-win32.whl", hash = "sha256:bdd37121970bfd8be76c5fb069c7751683bdf373db1ed6c010162b2a130248ed", size = 14543, upload-time = "2025-09-27T18:36:51.584Z" },
    { url = "https://files.pythonhosted.org/packages/05/73/c4abe620b841b6b791f2edc248f556900667a5a1cf023a6646967ae98335/markupsafe-3.0.3-cp313-cp313-win_amd64.whl", hash = "sha256:9a1abfdc021a164803f4d485104931fb8f8c1efd55bc6b748d2f5774e78b62c5", size = 15113, upload-time = "2025-09-27T18:36:52.537Z" },
    { url = "https://files.pythonhosted.org/packages/f0/3a/fa34a0f7cfef23cf9500d68cb7c32dd64ffd58a12b09225fb03dd37d5b80/markupsafe-3.0.3-cp313-cp313-win_arm64.whl", hash = "sha256:7e68f88e5b8799aa49c85cd116c932a1ac15caaa3f5db09087854d218359e485", size = 13911, upload-time = "2025-09-27T18:36:53.513Z" },
    { url = "https://files.pythonhosted.org/packages/e4/d7/e05cd7efe43a88a17a37b3ae96e79a19e846f3f456fe79c57ca61356ef01/markupsafe-3.0.3-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:218551f6df4868a8d527e3062d0fb968682fe92054e89978594c28e642c43a73", size = 11658, upload-time = "2025-09-27T18:36:54.819Z" },
    { url = "https://files.pythonhosted.org/packages/99/9e/e412117548182ce2148bdeacdda3bb494260c0b0184360fe0d56389b523b/markupsafe-3.0.3-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:3524b778fe5cfb3452a09d31e7b5adefeea8c5be1d43c4f810ba09f2ceb29d37", size = 12066, upload-time = "2025-09-27T18:36:55.714Z" },
    { url = "https://files.pythonhosted.org/packages/bc/e6/fa0ffcda717ef64a5108eaa7b4f5ed28d56122c9a6d70ab8b72f9f715c80/markupsafe-3.0.3-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:4e885a3d1efa2eadc93c894a21770e4bc67899e3543680313b09f139e149ab19", size = 25639, upload-time = "2025-09-27T18:36:56.908Z" },
    { url = "https://files.pythonhosted.org/packages/96/ec/2102e881fe9d25fc16cb4b25d5f5cde50970967ffa5dddafdb771237062d/markupsafe-3.0.3-cp313-cp313t-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:8709b08f4a89aa7586de0aadc8da56180242ee0ada3999749b183aa23df95025", size = 23569, upload-time = "2025-09-27T18:36:57.913Z" },
    { url = "https://files.pythonhosted.org/packages/4b/30/6f2fce1f1f205fc9323255b216ca8a235b15860c34b6798f810f05828e32/markupsafe-3.0.3-cp313-cp313t-manylinux_2_31_riscv64.manylinux_2_39_riscv64.whl", hash = "sha256:b8512a91625c9b3da6f127803b166b629725e68af71f8184ae7e7d54686a56d6", size = 23284, upload-time = "2025-09-27T18:36:58.833Z" },
    { url = "https://files.pythonhosted.org/packages/58/47/4a0ccea4ab9f5dcb6f79c0236d954acb382202721e704223a8aafa38b5c8/markupsafe-3.0.3-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:9b79b7a16f7fedff2495d684f2b59b0457c3b493778c9eed31111be64d58279f", size = 24801, upload-time = "2025-09-27T18:36:59.739Z" },
    { url = "https://files.pythonhosted.org/packages/6a/70/3780e9b72180b6fecb83a4814d84c3bf4b4ae4bf0b19c27196104149734c/markupsafe-3.0.3-cp313-cp313t-musllinux_1_2_riscv64.whl", hash = "sha256:12c63dfb4a98206f045aa9563db46507995f7ef6d83b2f68eda65c307c6829eb", size = 22769, upload-time = "2025-09-27T18:37:00.719Z" },
    { url = "https://files.pythonhosted.org/packages/98/c5/c03c7f4125180fc215220c035beac6b9cb684bc7a067c84fc69414d315f5/markupsafe-3.0.3-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:8f71bc33915be5186016f675cd83a1e08523649b0e33efdb898db577ef5bb009", size = 23642, upload-time = "2025-09-27T18:37:01.673Z" },
    { url = "https://files.pythonhosted.org/packages/80/d6/2d1b89f6ca4bff1036499b1e29a1d02d282259f3681540e16563f27ebc23/markupsafe-3.0.3-cp313-cp313t-win32.whl", hash = "sha256:69c0b73548bc525c8cb9a251cddf1931d1db4d2258e9599c28c07ef3580ef354", size = 14612, upload-time = "2025-09-27T18:37:02.639Z" },
    { url = "https://files.pythonhosted.org/packages/2b/98/e48a4bfba0a0ffcf9925fe2d69240bfaa19c6f7507b8cd09c70684a53c1e/markupsafe-3.0.3-cp313-cp313t-win_amd64.whl", hash = "sha256:1b4b79e8ebf6b55351f0d91fe80f893b4743f104bff22e90697db1590e47a218", size = 15200, upload-time = "2025-09-27T18:37:03.582Z" },
    { url = "https://files.pythonhosted.org/packages/0e/72/e3cc540f351f316e9ed0f092757459afbc595824ca724cbc5a5d4263713f/markupsafe-3.0.3-cp313-cp313t-win_arm64.whl", hash = "sha256:ad2cf8aa28b8c020ab2fc8287b0f823d0a7d8630784c31e9ee5edea20f406287", size = 13973, upload-time = "2025-09-27T18:37:04.929Z" },
]

[[package]]
name = "marshmallow"
version = "3.26.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "packaging" },
]
sdist = { url = "https://files.pythonhosted.org/packages/55/79/de6c16cc902f4fc372236926b0ce2ab7845268dcc30fb2fbb7f71b418631/marshmallow-3.26.2.tar.gz", hash = "sha256:bbe2adb5a03e6e3571b573f42527c6fe926e17467833660bebd11593ab8dfd57", size = 222095, upload-time = "2025-12-22T06:53:53.309Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/be/2f/5108cb3ee4ba6501748c4908b908e55f42a5b66245b4cfe0c99326e1ef6e/marshmallow-3.26.2-py3-none-any.whl", hash = "sha256:013fa8a3c4c276c24d26d84ce934dc964e2aa794345a0f8c7e5a7191482c8a73", size = 50964, upload-time = "2025-12-22T06:53:51.801Z" },
]

[[package]]
name = "mcp"
version = "1.26.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "httpx" },
    { name = "httpx-sse" },
    { name = "jsonschema" },
    { name = "pydantic" },
    { name = "pydantic-settings" },
    { name = "pyjwt", extra = ["crypto"] },
    { name = "python-multipart" },
    { name = "pywin32", marker = "sys_platform == 'win32'" },
    { name = "sse-starlette" },
    { name = "starlette" },
    { name = "typing-extensions" },
    { name = "typing-inspection" },
    { name = "uvicorn", marker = "sys_platform != 'emscripten'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/fc/6d/62e76bbb8144d6ed86e202b5edd8a4cb631e7c8130f3f4893c3f90262b10/mcp-1.26.0.tar.gz", hash = "sha256:db6e2ef491eecc1a0d93711a76f28dec2e05999f93afd48795da1c1137142c66", size = 608005, upload-time = "2026-01-24T19:40:32.468Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/fd/d9/eaa1f80170d2b7c5ba23f3b59f766f3a0bb41155fbc32a69adfa1adaaef9/mcp-1.26.0-py3-none-any.whl", hash = "sha256:904a21c33c25aa98ddbeb47273033c435e595bbacfdb177f4bd87f6dceebe1ca", size = 233615, upload-time = "2026-01-24T19:40:30.652Z" },
]

[[package]]
name = "mdit-py-plugins"
version = "0.5.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markdown-it-py" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b2/fd/a756d36c0bfba5f6e39a1cdbdbfdd448dc02692467d83816dff4592a1ebc/mdit_py_plugins-0.5.0.tar.gz", hash = "sha256:f4918cb50119f50446560513a8e311d574ff6aaed72606ddae6d35716fe809c6", size = 44655, upload-time = "2025-08-11T07:25:49.083Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/fb/86/dd6e5db36df29e76c7a7699123569a4a18c1623ce68d826ed96c62643cae/mdit_py_plugins-0.5.0-py3-none-any.whl", hash = "sha256:07a08422fc1936a5d26d146759e9155ea466e842f5ab2f7d2266dd084c8dab1f", size = 57205, upload-time = "2025-08-11T07:25:47.597Z" },
]

[[package]]
name = "mdurl"
version = "0.1.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d6/54/cfe61301667036ec958cb99bd3efefba235e65cdeb9c84d24a8293ba1d90/mdurl-0.1.2.tar.gz", hash = "sha256:bb413d29f5eea38f31dd4754dd7377d4465116fb207585f97bf925588687c1ba", size = 8729, upload-time = "2022-08-14T12:40:10.846Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b3/38/89ba8ad64ae25be8de66a6d463314cf1eb366222074cfda9ee839c56a4b4/mdurl-0.1.2-py3-none-any.whl", hash = "sha256:84008a41e51615a49fc9966191ff91509e3c40b939176e643fd50a5c2196b8f8", size = 9979, upload-time = "2022-08-14T12:40:09.779Z" },
]

[[package]]
name = "mobilerun-sdk"
version = "2.0.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "distro" },
    { name = "httpx" },
    { name = "pydantic" },
    { name = "sniffio" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/f6/16/c7c2480068546819287cf24aed1d6d3e42c010c833d5ef94d75771456243/mobilerun_sdk-2.0.0.tar.gz", hash = "sha256:96697f30321e23210f73b492fd87941a79ab639ecda51e9dd07e72b5e1a56de4", size = 136644, upload-time = "2026-01-12T16:35:46.789Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2a/43/ef9e7973d8d9a2febecb50245a86cf85ffc2a026f6ae14825e3c9211ce51/mobilerun_sdk-2.0.0-py3-none-any.whl", hash = "sha256:c7ae148b9b02e198214a8320ea53ad46c81b3c0204f50044bf4883c222ace3b0", size = 145509, upload-time = "2026-01-12T16:35:45.373Z" },
]

[[package]]
name = "multidict"
version = "6.7.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/80/1e/5492c365f222f907de1039b91f922b93fa4f764c713ee858d235495d8f50/multidict-6.7.0.tar.gz", hash = "sha256:c6e99d9a65ca282e578dfea819cfa9c0a62b2499d8677392e09feaf305e9e6f5", size = 101834, upload-time = "2025-10-06T14:52:30.657Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/34/9e/5c727587644d67b2ed479041e4b1c58e30afc011e3d45d25bbe35781217c/multidict-6.7.0-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:4d409aa42a94c0b3fa617708ef5276dfe81012ba6753a0370fcc9d0195d0a1fc", size = 76604, upload-time = "2025-10-06T14:48:54.277Z" },
    { url = "https://files.pythonhosted.org/packages/17/e4/67b5c27bd17c085a5ea8f1ec05b8a3e5cba0ca734bfcad5560fb129e70ca/multidict-6.7.0-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:14c9e076eede3b54c636f8ce1c9c252b5f057c62131211f0ceeec273810c9721", size = 44715, upload-time = "2025-10-06T14:48:55.445Z" },
    { url = "https://files.pythonhosted.org/packages/4d/e1/866a5d77be6ea435711bef2a4291eed11032679b6b28b56b4776ab06ba3e/multidict-6.7.0-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:4c09703000a9d0fa3c3404b27041e574cc7f4df4c6563873246d0e11812a94b6", size = 44332, upload-time = "2025-10-06T14:48:56.706Z" },
    { url = "https://files.pythonhosted.org/packages/31/61/0c2d50241ada71ff61a79518db85ada85fdabfcf395d5968dae1cbda04e5/multidict-6.7.0-cp311-cp311-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:a265acbb7bb33a3a2d626afbe756371dce0279e7b17f4f4eda406459c2b5ff1c", size = 245212, upload-time = "2025-10-06T14:48:58.042Z" },
    { url = "https://files.pythonhosted.org/packages/ac/e0/919666a4e4b57fff1b57f279be1c9316e6cdc5de8a8b525d76f6598fefc7/multidict-6.7.0-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:51cb455de290ae462593e5b1cb1118c5c22ea7f0d3620d9940bf695cea5a4bd7", size = 246671, upload-time = "2025-10-06T14:49:00.004Z" },
    { url = "https://files.pythonhosted.org/packages/a1/cc/d027d9c5a520f3321b65adea289b965e7bcbd2c34402663f482648c716ce/multidict-6.7.0-cp311-cp311-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:db99677b4457c7a5c5a949353e125ba72d62b35f74e26da141530fbb012218a7", size = 225491, upload-time = "2025-10-06T14:49:01.393Z" },
    { url = "https://files.pythonhosted.org/packages/75/c4/bbd633980ce6155a28ff04e6a6492dd3335858394d7bb752d8b108708558/multidict-6.7.0-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:f470f68adc395e0183b92a2f4689264d1ea4b40504a24d9882c27375e6662bb9", size = 257322, upload-time = "2025-10-06T14:49:02.745Z" },
    { url = "https://files.pythonhosted.org/packages/4c/6d/d622322d344f1f053eae47e033b0b3f965af01212de21b10bcf91be991fb/multidict-6.7.0-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:0db4956f82723cc1c270de9c6e799b4c341d327762ec78ef82bb962f79cc07d8", size = 254694, upload-time = "2025-10-06T14:49:04.15Z" },
    { url = "https://files.pythonhosted.org/packages/a8/9f/78f8761c2705d4c6d7516faed63c0ebdac569f6db1bef95e0d5218fdc146/multidict-6.7.0-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:3e56d780c238f9e1ae66a22d2adf8d16f485381878250db8d496623cd38b22bd", size = 246715, upload-time = "2025-10-06T14:49:05.967Z" },
    { url = "https://files.pythonhosted.org/packages/78/59/950818e04f91b9c2b95aab3d923d9eabd01689d0dcd889563988e9ea0fd8/multidict-6.7.0-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:9d14baca2ee12c1a64740d4531356ba50b82543017f3ad6de0deb943c5979abb", size = 243189, upload-time = "2025-10-06T14:49:07.37Z" },
    { url = "https://files.pythonhosted.org/packages/7a/3d/77c79e1934cad2ee74991840f8a0110966d9599b3af95964c0cd79bb905b/multidict-6.7.0-cp311-cp311-musllinux_1_2_armv7l.whl", hash = "sha256:295a92a76188917c7f99cda95858c822f9e4aae5824246bba9b6b44004ddd0a6", size = 237845, upload-time = "2025-10-06T14:49:08.759Z" },
    { url = "https://files.pythonhosted.org/packages/63/1b/834ce32a0a97a3b70f86437f685f880136677ac00d8bce0027e9fd9c2db7/multidict-6.7.0-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:39f1719f57adbb767ef592a50ae5ebb794220d1188f9ca93de471336401c34d2", size = 246374, upload-time = "2025-10-06T14:49:10.574Z" },
    { url = "https://files.pythonhosted.org/packages/23/ef/43d1c3ba205b5dec93dc97f3fba179dfa47910fc73aaaea4f7ceb41cec2a/multidict-6.7.0-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:0a13fb8e748dfc94749f622de065dd5c1def7e0d2216dba72b1d8069a389c6ff", size = 253345, upload-time = "2025-10-06T14:49:12.331Z" },
    { url = "https://files.pythonhosted.org/packages/6b/03/eaf95bcc2d19ead522001f6a650ef32811aa9e3624ff0ad37c445c7a588c/multidict-6.7.0-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:e3aa16de190d29a0ea1b48253c57d99a68492c8dd8948638073ab9e74dc9410b", size = 246940, upload-time = "2025-10-06T14:49:13.821Z" },
    { url = "https://files.pythonhosted.org/packages/e8/df/ec8a5fd66ea6cd6f525b1fcbb23511b033c3e9bc42b81384834ffa484a62/multidict-6.7.0-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:a048ce45dcdaaf1defb76b2e684f997fb5abf74437b6cb7b22ddad934a964e34", size = 242229, upload-time = "2025-10-06T14:49:15.603Z" },
    { url = "https://files.pythonhosted.org/packages/8a/a2/59b405d59fd39ec86d1142630e9049243015a5f5291ba49cadf3c090c541/multidict-6.7.0-cp311-cp311-win32.whl", hash = "sha256:a90af66facec4cebe4181b9e62a68be65e45ac9b52b67de9eec118701856e7ff", size = 41308, upload-time = "2025-10-06T14:49:16.871Z" },
    { url = "https://files.pythonhosted.org/packages/32/0f/13228f26f8b882c34da36efa776c3b7348455ec383bab4a66390e42963ae/multidict-6.7.0-cp311-cp311-win_amd64.whl", hash = "sha256:95b5ffa4349df2887518bb839409bcf22caa72d82beec453216802f475b23c81", size = 46037, upload-time = "2025-10-06T14:49:18.457Z" },
    { url = "https://files.pythonhosted.org/packages/84/1f/68588e31b000535a3207fd3c909ebeec4fb36b52c442107499c18a896a2a/multidict-6.7.0-cp311-cp311-win_arm64.whl", hash = "sha256:329aa225b085b6f004a4955271a7ba9f1087e39dcb7e65f6284a988264a63912", size = 43023, upload-time = "2025-10-06T14:49:19.648Z" },
    { url = "https://files.pythonhosted.org/packages/c2/9e/9f61ac18d9c8b475889f32ccfa91c9f59363480613fc807b6e3023d6f60b/multidict-6.7.0-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:8a3862568a36d26e650a19bb5cbbba14b71789032aebc0423f8cc5f150730184", size = 76877, upload-time = "2025-10-06T14:49:20.884Z" },
    { url = "https://files.pythonhosted.org/packages/38/6f/614f09a04e6184f8824268fce4bc925e9849edfa654ddd59f0b64508c595/multidict-6.7.0-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:960c60b5849b9b4f9dcc9bea6e3626143c252c74113df2c1540aebce70209b45", size = 45467, upload-time = "2025-10-06T14:49:22.054Z" },
    { url = "https://files.pythonhosted.org/packages/b3/93/c4f67a436dd026f2e780c433277fff72be79152894d9fc36f44569cab1a6/multidict-6.7.0-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:2049be98fb57a31b4ccf870bf377af2504d4ae35646a19037ec271e4c07998aa", size = 43834, upload-time = "2025-10-06T14:49:23.566Z" },
    { url = "https://files.pythonhosted.org/packages/7f/f5/013798161ca665e4a422afbc5e2d9e4070142a9ff8905e482139cd09e4d0/multidict-6.7.0-cp312-cp312-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:0934f3843a1860dd465d38895c17fce1f1cb37295149ab05cd1b9a03afacb2a7", size = 250545, upload-time = "2025-10-06T14:49:24.882Z" },
    { url = "https://files.pythonhosted.org/packages/71/2f/91dbac13e0ba94669ea5119ba267c9a832f0cb65419aca75549fcf09a3dc/multidict-6.7.0-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:b3e34f3a1b8131ba06f1a73adab24f30934d148afcd5f5de9a73565a4404384e", size = 258305, upload-time = "2025-10-06T14:49:26.778Z" },
    { url = "https://files.pythonhosted.org/packages/ef/b0/754038b26f6e04488b48ac621f779c341338d78503fb45403755af2df477/multidict-6.7.0-cp312-cp312-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:efbb54e98446892590dc2458c19c10344ee9a883a79b5cec4bc34d6656e8d546", size = 242363, upload-time = "2025-10-06T14:49:28.562Z" },
    { url = "https://files.pythonhosted.org/packages/87/15/9da40b9336a7c9fa606c4cf2ed80a649dffeb42b905d4f63a1d7eb17d746/multidict-6.7.0-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:a35c5fc61d4f51eb045061e7967cfe3123d622cd500e8868e7c0c592a09fedc4", size = 268375, upload-time = "2025-10-06T14:49:29.96Z" },
    { url = "https://files.pythonhosted.org/packages/82/72/c53fcade0cc94dfaad583105fd92b3a783af2091eddcb41a6d5a52474000/multidict-6.7.0-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:29fe6740ebccba4175af1b9b87bf553e9c15cd5868ee967e010efcf94e4fd0f1", size = 269346, upload-time = "2025-10-06T14:49:31.404Z" },
    { url = "https://files.pythonhosted.org/packages/0d/e2/9baffdae21a76f77ef8447f1a05a96ec4bc0a24dae08767abc0a2fe680b8/multidict-6.7.0-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:123e2a72e20537add2f33a79e605f6191fba2afda4cbb876e35c1a7074298a7d", size = 256107, upload-time = "2025-10-06T14:49:32.974Z" },
    { url = "https://files.pythonhosted.org/packages/3c/06/3f06f611087dc60d65ef775f1fb5aca7c6d61c6db4990e7cda0cef9b1651/multidict-6.7.0-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:b284e319754366c1aee2267a2036248b24eeb17ecd5dc16022095e747f2f4304", size = 253592, upload-time = "2025-10-06T14:49:34.52Z" },
    { url = "https://files.pythonhosted.org/packages/20/24/54e804ec7945b6023b340c412ce9c3f81e91b3bf5fa5ce65558740141bee/multidict-6.7.0-cp312-cp312-musllinux_1_2_armv7l.whl", hash = "sha256:803d685de7be4303b5a657b76e2f6d1240e7e0a8aa2968ad5811fa2285553a12", size = 251024, upload-time = "2025-10-06T14:49:35.956Z" },
    { url = "https://files.pythonhosted.org/packages/14/48/011cba467ea0b17ceb938315d219391d3e421dfd35928e5dbdc3f4ae76ef/multidict-6.7.0-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:c04a328260dfd5db8c39538f999f02779012268f54614902d0afc775d44e0a62", size = 251484, upload-time = "2025-10-06T14:49:37.631Z" },
    { url = "https://files.pythonhosted.org/packages/0d/2f/919258b43bb35b99fa127435cfb2d91798eb3a943396631ef43e3720dcf4/multidict-6.7.0-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:8a19cdb57cd3df4cd865849d93ee14920fb97224300c88501f16ecfa2604b4e0", size = 263579, upload-time = "2025-10-06T14:49:39.502Z" },
    { url = "https://files.pythonhosted.org/packages/31/22/a0e884d86b5242b5a74cf08e876bdf299e413016b66e55511f7a804a366e/multidict-6.7.0-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:9b2fd74c52accced7e75de26023b7dccee62511a600e62311b918ec5c168fc2a", size = 259654, upload-time = "2025-10-06T14:49:41.32Z" },
    { url = "https://files.pythonhosted.org/packages/b2/e5/17e10e1b5c5f5a40f2fcbb45953c9b215f8a4098003915e46a93f5fcaa8f/multidict-6.7.0-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:3e8bfdd0e487acf992407a140d2589fe598238eaeffa3da8448d63a63cd363f8", size = 251511, upload-time = "2025-10-06T14:49:46.021Z" },
    { url = "https://files.pythonhosted.org/packages/e3/9a/201bb1e17e7af53139597069c375e7b0dcbd47594604f65c2d5359508566/multidict-6.7.0-cp312-cp312-win32.whl", hash = "sha256:dd32a49400a2c3d52088e120ee00c1e3576cbff7e10b98467962c74fdb762ed4", size = 41895, upload-time = "2025-10-06T14:49:48.718Z" },
    { url = "https://files.pythonhosted.org/packages/46/e2/348cd32faad84eaf1d20cce80e2bb0ef8d312c55bca1f7fa9865e7770aaf/multidict-6.7.0-cp312-cp312-win_amd64.whl", hash = "sha256:92abb658ef2d7ef22ac9f8bb88e8b6c3e571671534e029359b6d9e845923eb1b", size = 46073, upload-time = "2025-10-06T14:49:50.28Z" },
    { url = "https://files.pythonhosted.org/packages/25/ec/aad2613c1910dce907480e0c3aa306905830f25df2e54ccc9dea450cb5aa/multidict-6.7.0-cp312-cp312-win_arm64.whl", hash = "sha256:490dab541a6a642ce1a9d61a4781656b346a55c13038f0b1244653828e3a83ec", size = 43226, upload-time = "2025-10-06T14:49:52.304Z" },
    { url = "https://files.pythonhosted.org/packages/d2/86/33272a544eeb36d66e4d9a920602d1a2f57d4ebea4ef3cdfe5a912574c95/multidict-6.7.0-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:bee7c0588aa0076ce77c0ea5d19a68d76ad81fcd9fe8501003b9a24f9d4000f6", size = 76135, upload-time = "2025-10-06T14:49:54.26Z" },
    { url = "https://files.pythonhosted.org/packages/91/1c/eb97db117a1ebe46d457a3d235a7b9d2e6dcab174f42d1b67663dd9e5371/multidict-6.7.0-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:7ef6b61cad77091056ce0e7ce69814ef72afacb150b7ac6a3e9470def2198159", size = 45117, upload-time = "2025-10-06T14:49:55.82Z" },
    { url = "https://files.pythonhosted.org/packages/f1/d8/6c3442322e41fb1dd4de8bd67bfd11cd72352ac131f6368315617de752f1/multidict-6.7.0-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:9c0359b1ec12b1d6849c59f9d319610b7f20ef990a6d454ab151aa0e3b9f78ca", size = 43472, upload-time = "2025-10-06T14:49:57.048Z" },
    { url = "https://files.pythonhosted.org/packages/75/3f/e2639e80325af0b6c6febdf8e57cc07043ff15f57fa1ef808f4ccb5ac4cd/multidict-6.7.0-cp313-cp313-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:cd240939f71c64bd658f186330603aac1a9a81bf6273f523fca63673cb7378a8", size = 249342, upload-time = "2025-10-06T14:49:58.368Z" },
    { url = "https://files.pythonhosted.org/packages/5d/cc/84e0585f805cbeaa9cbdaa95f9a3d6aed745b9d25700623ac89a6ecff400/multidict-6.7.0-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:a60a4d75718a5efa473ebd5ab685786ba0c67b8381f781d1be14da49f1a2dc60", size = 257082, upload-time = "2025-10-06T14:49:59.89Z" },
    { url = "https://files.pythonhosted.org/packages/b0/9c/ac851c107c92289acbbf5cfb485694084690c1b17e555f44952c26ddc5bd/multidict-6.7.0-cp313-cp313-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:53a42d364f323275126aff81fb67c5ca1b7a04fda0546245730a55c8c5f24bc4", size = 240704, upload-time = "2025-10-06T14:50:01.485Z" },
    { url = "https://files.pythonhosted.org/packages/50/cc/5f93e99427248c09da95b62d64b25748a5f5c98c7c2ab09825a1d6af0e15/multidict-6.7.0-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:3b29b980d0ddbecb736735ee5bef69bb2ddca56eff603c86f3f29a1128299b4f", size = 266355, upload-time = "2025-10-06T14:50:02.955Z" },
    { url = "https://files.pythonhosted.org/packages/ec/0c/2ec1d883ceb79c6f7f6d7ad90c919c898f5d1c6ea96d322751420211e072/multidict-6.7.0-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:f8a93b1c0ed2d04b97a5e9336fd2d33371b9a6e29ab7dd6503d63407c20ffbaf", size = 267259, upload-time = "2025-10-06T14:50:04.446Z" },
    { url = "https://files.pythonhosted.org/packages/c6/2d/f0b184fa88d6630aa267680bdb8623fb69cb0d024b8c6f0d23f9a0f406d3/multidict-6.7.0-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:9ff96e8815eecacc6645da76c413eb3b3d34cfca256c70b16b286a687d013c32", size = 254903, upload-time = "2025-10-06T14:50:05.98Z" },
    { url = "https://files.pythonhosted.org/packages/06/c9/11ea263ad0df7dfabcad404feb3c0dd40b131bc7f232d5537f2fb1356951/multidict-6.7.0-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:7516c579652f6a6be0e266aec0acd0db80829ca305c3d771ed898538804c2036", size = 252365, upload-time = "2025-10-06T14:50:07.511Z" },
    { url = "https://files.pythonhosted.org/packages/41/88/d714b86ee2c17d6e09850c70c9d310abac3d808ab49dfa16b43aba9d53fd/multidict-6.7.0-cp313-cp313-musllinux_1_2_armv7l.whl", hash = "sha256:040f393368e63fb0f3330e70c26bfd336656bed925e5cbe17c9da839a6ab13ec", size = 250062, upload-time = "2025-10-06T14:50:09.074Z" },
    { url = "https://files.pythonhosted.org/packages/15/fe/ad407bb9e818c2b31383f6131ca19ea7e35ce93cf1310fce69f12e89de75/multidict-6.7.0-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:b3bc26a951007b1057a1c543af845f1c7e3e71cc240ed1ace7bf4484aa99196e", size = 249683, upload-time = "2025-10-06T14:50:10.714Z" },
    { url = "https://files.pythonhosted.org/packages/8c/a4/a89abdb0229e533fb925e7c6e5c40201c2873efebc9abaf14046a4536ee6/multidict-6.7.0-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:7b022717c748dd1992a83e219587aabe45980d88969f01b316e78683e6285f64", size = 261254, upload-time = "2025-10-06T14:50:12.28Z" },
    { url = "https://files.pythonhosted.org/packages/8d/aa/0e2b27bd88b40a4fb8dc53dd74eecac70edaa4c1dd0707eb2164da3675b3/multidict-6.7.0-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:9600082733859f00d79dee64effc7aef1beb26adb297416a4ad2116fd61374bd", size = 257967, upload-time = "2025-10-06T14:50:14.16Z" },
    { url = "https://files.pythonhosted.org/packages/d0/8e/0c67b7120d5d5f6d874ed85a085f9dc770a7f9d8813e80f44a9fec820bb7/multidict-6.7.0-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:94218fcec4d72bc61df51c198d098ce2b378e0ccbac41ddbed5ef44092913288", size = 250085, upload-time = "2025-10-06T14:50:15.639Z" },
    { url = "https://files.pythonhosted.org/packages/ba/55/b73e1d624ea4b8fd4dd07a3bb70f6e4c7c6c5d9d640a41c6ffe5cdbd2a55/multidict-6.7.0-cp313-cp313-win32.whl", hash = "sha256:a37bd74c3fa9d00be2d7b8eca074dc56bd8077ddd2917a839bd989612671ed17", size = 41713, upload-time = "2025-10-06T14:50:17.066Z" },
    { url = "https://files.pythonhosted.org/packages/32/31/75c59e7d3b4205075b4c183fa4ca398a2daf2303ddf616b04ae6ef55cffe/multidict-6.7.0-cp313-cp313-win_amd64.whl", hash = "sha256:30d193c6cc6d559db42b6bcec8a5d395d34d60c9877a0b71ecd7c204fcf15390", size = 45915, upload-time = "2025-10-06T14:50:18.264Z" },
    { url = "https://files.pythonhosted.org/packages/31/2a/8987831e811f1184c22bc2e45844934385363ee61c0a2dcfa8f71b87e608/multidict-6.7.0-cp313-cp313-win_arm64.whl", hash = "sha256:ea3334cabe4d41b7ccd01e4d349828678794edbc2d3ae97fc162a3312095092e", size = 43077, upload-time = "2025-10-06T14:50:19.853Z" },
    { url = "https://files.pythonhosted.org/packages/e8/68/7b3a5170a382a340147337b300b9eb25a9ddb573bcdfff19c0fa3f31ffba/multidict-6.7.0-cp313-cp313t-macosx_10_13_universal2.whl", hash = "sha256:ad9ce259f50abd98a1ca0aa6e490b58c316a0fce0617f609723e40804add2c00", size = 83114, upload-time = "2025-10-06T14:50:21.223Z" },
    { url = "https://files.pythonhosted.org/packages/55/5c/3fa2d07c84df4e302060f555bbf539310980362236ad49f50eeb0a1c1eb9/multidict-6.7.0-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:07f5594ac6d084cbb5de2df218d78baf55ef150b91f0ff8a21cc7a2e3a5a58eb", size = 48442, upload-time = "2025-10-06T14:50:22.871Z" },
    { url = "https://files.pythonhosted.org/packages/fc/56/67212d33239797f9bd91962bb899d72bb0f4c35a8652dcdb8ed049bef878/multidict-6.7.0-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:0591b48acf279821a579282444814a2d8d0af624ae0bc600aa4d1b920b6e924b", size = 46885, upload-time = "2025-10-06T14:50:24.258Z" },
    { url = "https://files.pythonhosted.org/packages/46/d1/908f896224290350721597a61a69cd19b89ad8ee0ae1f38b3f5cd12ea2ac/multidict-6.7.0-cp313-cp313t-manylinux1_i686.manylinux_2_28_i686.manylinux_2_5_i686.whl", hash = "sha256:749a72584761531d2b9467cfbdfd29487ee21124c304c4b6cb760d8777b27f9c", size = 242588, upload-time = "2025-10-06T14:50:25.716Z" },
    { url = "https://files.pythonhosted.org/packages/ab/67/8604288bbd68680eee0ab568fdcb56171d8b23a01bcd5cb0c8fedf6e5d99/multidict-6.7.0-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:6b4c3d199f953acd5b446bf7c0de1fe25d94e09e79086f8dc2f48a11a129cdf1", size = 249966, upload-time = "2025-10-06T14:50:28.192Z" },
    { url = "https://files.pythonhosted.org/packages/20/33/9228d76339f1ba51e3efef7da3ebd91964d3006217aae13211653193c3ff/multidict-6.7.0-cp313-cp313t-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:9fb0211dfc3b51efea2f349ec92c114d7754dd62c01f81c3e32b765b70c45c9b", size = 228618, upload-time = "2025-10-06T14:50:29.82Z" },
    { url = "https://files.pythonhosted.org/packages/f8/2d/25d9b566d10cab1c42b3b9e5b11ef79c9111eaf4463b8c257a3bd89e0ead/multidict-6.7.0-cp313-cp313t-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:a027ec240fe73a8d6281872690b988eed307cd7d91b23998ff35ff577ca688b5", size = 257539, upload-time = "2025-10-06T14:50:31.731Z" },
    { url = "https://files.pythonhosted.org/packages/b6/b1/8d1a965e6637fc33de3c0d8f414485c2b7e4af00f42cab3d84e7b955c222/multidict-6.7.0-cp313-cp313t-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:d1d964afecdf3a8288789df2f5751dc0a8261138c3768d9af117ed384e538fad", size = 256345, upload-time = "2025-10-06T14:50:33.26Z" },
    { url = "https://files.pythonhosted.org/packages/ba/0c/06b5a8adbdeedada6f4fb8d8f193d44a347223b11939b42953eeb6530b6b/multidict-6.7.0-cp313-cp313t-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:caf53b15b1b7df9fbd0709aa01409000a2b4dd03a5f6f5cc548183c7c8f8b63c", size = 247934, upload-time = "2025-10-06T14:50:34.808Z" },
    { url = "https://files.pythonhosted.org/packages/8f/31/b2491b5fe167ca044c6eb4b8f2c9f3b8a00b24c432c365358eadac5d7625/multidict-6.7.0-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:654030da3197d927f05a536a66186070e98765aa5142794c9904555d3a9d8fb5", size = 245243, upload-time = "2025-10-06T14:50:36.436Z" },
    { url = "https://files.pythonhosted.org/packages/61/1a/982913957cb90406c8c94f53001abd9eafc271cb3e70ff6371590bec478e/multidict-6.7.0-cp313-cp313t-musllinux_1_2_armv7l.whl", hash = "sha256:2090d3718829d1e484706a2f525e50c892237b2bf9b17a79b059cb98cddc2f10", size = 235878, upload-time = "2025-10-06T14:50:37.953Z" },
    { url = "https://files.pythonhosted.org/packages/be/c0/21435d804c1a1cf7a2608593f4d19bca5bcbd7a81a70b253fdd1c12af9c0/multidict-6.7.0-cp313-cp313t-musllinux_1_2_i686.whl", hash = "sha256:2d2cfeec3f6f45651b3d408c4acec0ebf3daa9bc8a112a084206f5db5d05b754", size = 243452, upload-time = "2025-10-06T14:50:39.574Z" },
    { url = "https://files.pythonhosted.org/packages/54/0a/4349d540d4a883863191be6eb9a928846d4ec0ea007d3dcd36323bb058ac/multidict-6.7.0-cp313-cp313t-musllinux_1_2_ppc64le.whl", hash = "sha256:4ef089f985b8c194d341eb2c24ae6e7408c9a0e2e5658699c92f497437d88c3c", size = 252312, upload-time = "2025-10-06T14:50:41.612Z" },
    { url = "https://files.pythonhosted.org/packages/26/64/d5416038dbda1488daf16b676e4dbfd9674dde10a0cc8f4fc2b502d8125d/multidict-6.7.0-cp313-cp313t-musllinux_1_2_s390x.whl", hash = "sha256:e93a0617cd16998784bf4414c7e40f17a35d2350e5c6f0bd900d3a8e02bd3762", size = 246935, upload-time = "2025-10-06T14:50:43.972Z" },
    { url = "https://files.pythonhosted.org/packages/9f/8c/8290c50d14e49f35e0bd4abc25e1bc7711149ca9588ab7d04f886cdf03d9/multidict-6.7.0-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:f0feece2ef8ebc42ed9e2e8c78fc4aa3cf455733b507c09ef7406364c94376c6", size = 243385, upload-time = "2025-10-06T14:50:45.648Z" },
    { url = "https://files.pythonhosted.org/packages/ef/a0/f83ae75e42d694b3fbad3e047670e511c138be747bc713cf1b10d5096416/multidict-6.7.0-cp313-cp313t-win32.whl", hash = "sha256:19a1d55338ec1be74ef62440ca9e04a2f001a04d0cc49a4983dc320ff0f3212d", size = 47777, upload-time = "2025-10-06T14:50:47.154Z" },
    { url = "https://files.pythonhosted.org/packages/dc/80/9b174a92814a3830b7357307a792300f42c9e94664b01dee8e457551fa66/multidict-6.7.0-cp313-cp313t-win_amd64.whl", hash = "sha256:3da4fb467498df97e986af166b12d01f05d2e04f978a9c1c680ea1988e0bc4b6", size = 53104, upload-time = "2025-10-06T14:50:48.851Z" },
    { url = "https://files.pythonhosted.org/packages/cc/28/04baeaf0428d95bb7a7bea0e691ba2f31394338ba424fb0679a9ed0f4c09/multidict-6.7.0-cp313-cp313t-win_arm64.whl", hash = "sha256:b4121773c49a0776461f4a904cdf6264c88e42218aaa8407e803ca8025872792", size = 45503, upload-time = "2025-10-06T14:50:50.16Z" },
    { url = "https://files.pythonhosted.org/packages/b7/da/7d22601b625e241d4f23ef1ebff8acfc60da633c9e7e7922e24d10f592b3/multidict-6.7.0-py3-none-any.whl", hash = "sha256:394fc5c42a333c9ffc3e421a4c85e08580d990e08b99f6bf35b4132114c5dcb3", size = 12317, upload-time = "2025-10-06T14:52:29.272Z" },
]

[[package]]
name = "mypy"
version = "1.18.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "mypy-extensions" },
    { name = "pathspec" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/c0/77/8f0d0001ffad290cef2f7f216f96c814866248a0b92a722365ed54648e7e/mypy-1.18.2.tar.gz", hash = "sha256:06a398102a5f203d7477b2923dda3634c36727fa5c237d8f859ef90c42a9924b", size = 3448846, upload-time = "2025-09-19T00:11:10.519Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/88/87/cafd3ae563f88f94eec33f35ff722d043e09832ea8530ef149ec1efbaf08/mypy-1.18.2-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:807d9315ab9d464125aa9fcf6d84fde6e1dc67da0b6f80e7405506b8ac72bc7f", size = 12731198, upload-time = "2025-09-19T00:09:44.857Z" },
    { url = "https://files.pythonhosted.org/packages/0f/e0/1e96c3d4266a06d4b0197ace5356d67d937d8358e2ee3ffac71faa843724/mypy-1.18.2-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:776bb00de1778caf4db739c6e83919c1d85a448f71979b6a0edd774ea8399341", size = 11817879, upload-time = "2025-09-19T00:09:47.131Z" },
    { url = "https://files.pythonhosted.org/packages/72/ef/0c9ba89eb03453e76bdac5a78b08260a848c7bfc5d6603634774d9cd9525/mypy-1.18.2-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:1379451880512ffce14505493bd9fe469e0697543717298242574882cf8cdb8d", size = 12427292, upload-time = "2025-09-19T00:10:22.472Z" },
    { url = "https://files.pythonhosted.org/packages/1a/52/ec4a061dd599eb8179d5411d99775bec2a20542505988f40fc2fee781068/mypy-1.18.2-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:1331eb7fd110d60c24999893320967594ff84c38ac6d19e0a76c5fd809a84c86", size = 13163750, upload-time = "2025-09-19T00:09:51.472Z" },
    { url = "https://files.pythonhosted.org/packages/c4/5f/2cf2ceb3b36372d51568f2208c021870fe7834cf3186b653ac6446511839/mypy-1.18.2-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:3ca30b50a51e7ba93b00422e486cbb124f1c56a535e20eff7b2d6ab72b3b2e37", size = 13351827, upload-time = "2025-09-19T00:09:58.311Z" },
    { url = "https://files.pythonhosted.org/packages/c8/7d/2697b930179e7277529eaaec1513f8de622818696857f689e4a5432e5e27/mypy-1.18.2-cp311-cp311-win_amd64.whl", hash = "sha256:664dc726e67fa54e14536f6e1224bcfce1d9e5ac02426d2326e2bb4e081d1ce8", size = 9757983, upload-time = "2025-09-19T00:10:09.071Z" },
    { url = "https://files.pythonhosted.org/packages/07/06/dfdd2bc60c66611dd8335f463818514733bc763e4760dee289dcc33df709/mypy-1.18.2-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:33eca32dd124b29400c31d7cf784e795b050ace0e1f91b8dc035672725617e34", size = 12908273, upload-time = "2025-09-19T00:10:58.321Z" },
    { url = "https://files.pythonhosted.org/packages/81/14/6a9de6d13a122d5608e1a04130724caf9170333ac5a924e10f670687d3eb/mypy-1.18.2-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:a3c47adf30d65e89b2dcd2fa32f3aeb5e94ca970d2c15fcb25e297871c8e4764", size = 11920910, upload-time = "2025-09-19T00:10:20.043Z" },
    { url = "https://files.pythonhosted.org/packages/5f/a9/b29de53e42f18e8cc547e38daa9dfa132ffdc64f7250e353f5c8cdd44bee/mypy-1.18.2-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:5d6c838e831a062f5f29d11c9057c6009f60cb294fea33a98422688181fe2893", size = 12465585, upload-time = "2025-09-19T00:10:33.005Z" },
    { url = "https://files.pythonhosted.org/packages/77/ae/6c3d2c7c61ff21f2bee938c917616c92ebf852f015fb55917fd6e2811db2/mypy-1.18.2-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:01199871b6110a2ce984bde85acd481232d17413868c9807e95c1b0739a58914", size = 13348562, upload-time = "2025-09-19T00:10:11.51Z" },
    { url = "https://files.pythonhosted.org/packages/4d/31/aec68ab3b4aebdf8f36d191b0685d99faa899ab990753ca0fee60fb99511/mypy-1.18.2-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:a2afc0fa0b0e91b4599ddfe0f91e2c26c2b5a5ab263737e998d6817874c5f7c8", size = 13533296, upload-time = "2025-09-19T00:10:06.568Z" },
    { url = "https://files.pythonhosted.org/packages/9f/83/abcb3ad9478fca3ebeb6a5358bb0b22c95ea42b43b7789c7fb1297ca44f4/mypy-1.18.2-cp312-cp312-win_amd64.whl", hash = "sha256:d8068d0afe682c7c4897c0f7ce84ea77f6de953262b12d07038f4d296d547074", size = 9828828, upload-time = "2025-09-19T00:10:28.203Z" },
    { url = "https://files.pythonhosted.org/packages/5f/04/7f462e6fbba87a72bc8097b93f6842499c428a6ff0c81dd46948d175afe8/mypy-1.18.2-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:07b8b0f580ca6d289e69209ec9d3911b4a26e5abfde32228a288eb79df129fcc", size = 12898728, upload-time = "2025-09-19T00:10:01.33Z" },
    { url = "https://files.pythonhosted.org/packages/99/5b/61ed4efb64f1871b41fd0b82d29a64640f3516078f6c7905b68ab1ad8b13/mypy-1.18.2-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:ed4482847168439651d3feee5833ccedbf6657e964572706a2adb1f7fa4dfe2e", size = 11910758, upload-time = "2025-09-19T00:10:42.607Z" },
    { url = "https://files.pythonhosted.org/packages/3c/46/d297d4b683cc89a6e4108c4250a6a6b717f5fa96e1a30a7944a6da44da35/mypy-1.18.2-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:c3ad2afadd1e9fea5cf99a45a822346971ede8685cc581ed9cd4d42eaf940986", size = 12475342, upload-time = "2025-09-19T00:11:00.371Z" },
    { url = "https://files.pythonhosted.org/packages/83/45/4798f4d00df13eae3bfdf726c9244bcb495ab5bd588c0eed93a2f2dd67f3/mypy-1.18.2-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:a431a6f1ef14cf8c144c6b14793a23ec4eae3db28277c358136e79d7d062f62d", size = 13338709, upload-time = "2025-09-19T00:11:03.358Z" },
    { url = "https://files.pythonhosted.org/packages/d7/09/479f7358d9625172521a87a9271ddd2441e1dab16a09708f056e97007207/mypy-1.18.2-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:7ab28cc197f1dd77a67e1c6f35cd1f8e8b73ed2217e4fc005f9e6a504e46e7ba", size = 13529806, upload-time = "2025-09-19T00:10:26.073Z" },
    { url = "https://files.pythonhosted.org/packages/71/cf/ac0f2c7e9d0ea3c75cd99dff7aec1c9df4a1376537cb90e4c882267ee7e9/mypy-1.18.2-cp313-cp313-win_amd64.whl", hash = "sha256:0e2785a84b34a72ba55fb5daf079a1003a34c05b22238da94fcae2bbe46f3544", size = 9833262, upload-time = "2025-09-19T00:10:40.035Z" },
    { url = "https://files.pythonhosted.org/packages/87/e3/be76d87158ebafa0309946c4a73831974d4d6ab4f4ef40c3b53a385a66fd/mypy-1.18.2-py3-none-any.whl", hash = "sha256:22a1748707dd62b58d2ae53562ffc4d7f8bcc727e8ac7cbc69c053ddc874d47e", size = 2352367, upload-time = "2025-09-19T00:10:15.489Z" },
]

[[package]]
name = "mypy-extensions"
version = "1.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a2/6e/371856a3fb9d31ca8dac321cda606860fa4548858c0cc45d9d1d4ca2628b/mypy_extensions-1.1.0.tar.gz", hash = "sha256:52e68efc3284861e772bbcd66823fde5ae21fd2fdb51c62a211403730b916558", size = 6343, upload-time = "2025-04-22T14:54:24.164Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/79/7b/2c79738432f5c924bef5071f933bcc9efd0473bac3b4aa584a6f7c1c8df8/mypy_extensions-1.1.0-py3-none-any.whl", hash = "sha256:1be4cccdb0f2482337c4743e60421de3a356cd97508abadd57d47403e94f5505", size = 4963, upload-time = "2025-04-22T14:54:22.983Z" },
]

[[package]]
name = "nest-asyncio"
version = "1.6.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/83/f8/51569ac65d696c8ecbee95938f89d4abf00f47d58d48f6fbabfe8f0baefe/nest_asyncio-1.6.0.tar.gz", hash = "sha256:6f172d5449aca15afd6c646851f4e31e02c598d553a667e38cafa997cfec55fe", size = 7418, upload-time = "2024-01-21T14:25:19.227Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a0/c4/c2971a3ba4c6103a3d10c4b0f24f461ddc027f0f09763220cf35ca1401b3/nest_asyncio-1.6.0-py3-none-any.whl", hash = "sha256:87af6efd6b5e897c81050477ef65c62e2b2f35d51703cae01aff2905b1852e1c", size = 5195, upload-time = "2024-01-21T14:25:17.223Z" },
]

[[package]]
name = "networkx"
version = "3.5"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/6c/4f/ccdb8ad3a38e583f214547fd2f7ff1fc160c43a75af88e6aec213404b96a/networkx-3.5.tar.gz", hash = "sha256:d4c6f9cf81f52d69230866796b82afbccdec3db7ae4fbd1b65ea750feed50037", size = 2471065, upload-time = "2025-05-29T11:35:07.804Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/eb/8d/776adee7bbf76365fdd7f2552710282c79a4ead5d2a46408c9043a2b70ba/networkx-3.5-py3-none-any.whl", hash = "sha256:0030d386a9a06dee3565298b4a734b68589749a544acbb6c412dc9e2489ec6ec", size = 2034406, upload-time = "2025-05-29T11:35:04.961Z" },
]

[[package]]
name = "nltk"
version = "3.9.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "joblib" },
    { name = "regex" },
    { name = "tqdm" },
]
sdist = { url = "https://files.pythonhosted.org/packages/f9/76/3a5e4312c19a028770f86fd7c058cf9f4ec4321c6cf7526bab998a5b683c/nltk-3.9.2.tar.gz", hash = "sha256:0f409e9b069ca4177c1903c3e843eef90c7e92992fa4931ae607da6de49e1419", size = 2887629, upload-time = "2025-10-01T07:19:23.764Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/60/90/81ac364ef94209c100e12579629dc92bf7a709a84af32f8c551b02c07e94/nltk-3.9.2-py3-none-any.whl", hash = "sha256:1e209d2b3009110635ed9709a67a1a3e33a10f799490fa71cf4bec218c11c88a", size = 1513404, upload-time = "2025-10-01T07:19:21.648Z" },
]

[[package]]
name = "numpy"
version = "2.3.4"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b5/f4/098d2270d52b41f1bd7db9fc288aaa0400cb48c2a3e2af6fa365d9720947/numpy-2.3.4.tar.gz", hash = "sha256:a7d018bfedb375a8d979ac758b120ba846a7fe764911a64465fd87b8729f4a6a", size = 20582187, upload-time = "2025-10-15T16:18:11.77Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/60/e7/0e07379944aa8afb49a556a2b54587b828eb41dc9adc56fb7615b678ca53/numpy-2.3.4-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:e78aecd2800b32e8347ce49316d3eaf04aed849cd5b38e0af39f829a4e59f5eb", size = 21259519, upload-time = "2025-10-15T16:15:19.012Z" },
    { url = "https://files.pythonhosted.org/packages/d0/cb/5a69293561e8819b09e34ed9e873b9a82b5f2ade23dce4c51dc507f6cfe1/numpy-2.3.4-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:7fd09cc5d65bda1e79432859c40978010622112e9194e581e3415a3eccc7f43f", size = 14452796, upload-time = "2025-10-15T16:15:23.094Z" },
    { url = "https://files.pythonhosted.org/packages/e4/04/ff11611200acd602a1e5129e36cfd25bf01ad8e5cf927baf2e90236eb02e/numpy-2.3.4-cp311-cp311-macosx_14_0_arm64.whl", hash = "sha256:1b219560ae2c1de48ead517d085bc2d05b9433f8e49d0955c82e8cd37bd7bf36", size = 5381639, upload-time = "2025-10-15T16:15:25.572Z" },
    { url = "https://files.pythonhosted.org/packages/ea/77/e95c757a6fe7a48d28a009267408e8aa382630cc1ad1db7451b3bc21dbb4/numpy-2.3.4-cp311-cp311-macosx_14_0_x86_64.whl", hash = "sha256:bafa7d87d4c99752d07815ed7a2c0964f8ab311eb8168f41b910bd01d15b6032", size = 6914296, upload-time = "2025-10-15T16:15:27.079Z" },
    { url = "https://files.pythonhosted.org/packages/a3/d2/137c7b6841c942124eae921279e5c41b1c34bab0e6fc60c7348e69afd165/numpy-2.3.4-cp311-cp311-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:36dc13af226aeab72b7abad501d370d606326a0029b9f435eacb3b8c94b8a8b7", size = 14591904, upload-time = "2025-10-15T16:15:29.044Z" },
    { url = "https://files.pythonhosted.org/packages/bb/32/67e3b0f07b0aba57a078c4ab777a9e8e6bc62f24fb53a2337f75f9691699/numpy-2.3.4-cp311-cp311-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:a7b2f9a18b5ff9824a6af80de4f37f4ec3c2aab05ef08f51c77a093f5b89adda", size = 16939602, upload-time = "2025-10-15T16:15:31.106Z" },
    { url = "https://files.pythonhosted.org/packages/95/22/9639c30e32c93c4cee3ccdb4b09c2d0fbff4dcd06d36b357da06146530fb/numpy-2.3.4-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:9984bd645a8db6ca15d850ff996856d8762c51a2239225288f08f9050ca240a0", size = 16372661, upload-time = "2025-10-15T16:15:33.546Z" },
    { url = "https://files.pythonhosted.org/packages/12/e9/a685079529be2b0156ae0c11b13d6be647743095bb51d46589e95be88086/numpy-2.3.4-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:64c5825affc76942973a70acf438a8ab618dbd692b84cd5ec40a0a0509edc09a", size = 18884682, upload-time = "2025-10-15T16:15:36.105Z" },
    { url = "https://files.pythonhosted.org/packages/cf/85/f6f00d019b0cc741e64b4e00ce865a57b6bed945d1bbeb1ccadbc647959b/numpy-2.3.4-cp311-cp311-win32.whl", hash = "sha256:ed759bf7a70342f7817d88376eb7142fab9fef8320d6019ef87fae05a99874e1", size = 6570076, upload-time = "2025-10-15T16:15:38.225Z" },
    { url = "https://files.pythonhosted.org/packages/7d/10/f8850982021cb90e2ec31990291f9e830ce7d94eef432b15066e7cbe0bec/numpy-2.3.4-cp311-cp311-win_amd64.whl", hash = "sha256:faba246fb30ea2a526c2e9645f61612341de1a83fb1e0c5edf4ddda5a9c10996", size = 13089358, upload-time = "2025-10-15T16:15:40.404Z" },
    { url = "https://files.pythonhosted.org/packages/d1/ad/afdd8351385edf0b3445f9e24210a9c3971ef4de8fd85155462fc4321d79/numpy-2.3.4-cp311-cp311-win_arm64.whl", hash = "sha256:4c01835e718bcebe80394fd0ac66c07cbb90147ebbdad3dcecd3f25de2ae7e2c", size = 10462292, upload-time = "2025-10-15T16:15:42.896Z" },
    { url = "https://files.pythonhosted.org/packages/96/7a/02420400b736f84317e759291b8edaeee9dc921f72b045475a9cbdb26b17/numpy-2.3.4-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:ef1b5a3e808bc40827b5fa2c8196151a4c5abe110e1726949d7abddfe5c7ae11", size = 20957727, upload-time = "2025-10-15T16:15:44.9Z" },
    { url = "https://files.pythonhosted.org/packages/18/90/a014805d627aa5750f6f0e878172afb6454552da929144b3c07fcae1bb13/numpy-2.3.4-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:c2f91f496a87235c6aaf6d3f3d89b17dba64996abadccb289f48456cff931ca9", size = 14187262, upload-time = "2025-10-15T16:15:47.761Z" },
    { url = "https://files.pythonhosted.org/packages/c7/e4/0a94b09abe89e500dc748e7515f21a13e30c5c3fe3396e6d4ac108c25fca/numpy-2.3.4-cp312-cp312-macosx_14_0_arm64.whl", hash = "sha256:f77e5b3d3da652b474cc80a14084927a5e86a5eccf54ca8ca5cbd697bf7f2667", size = 5115992, upload-time = "2025-10-15T16:15:50.144Z" },
    { url = "https://files.pythonhosted.org/packages/88/dd/db77c75b055c6157cbd4f9c92c4458daef0dd9cbe6d8d2fe7f803cb64c37/numpy-2.3.4-cp312-cp312-macosx_14_0_x86_64.whl", hash = "sha256:8ab1c5f5ee40d6e01cbe96de5863e39b215a4d24e7d007cad56c7184fdf4aeef", size = 6648672, upload-time = "2025-10-15T16:15:52.442Z" },
    { url = "https://files.pythonhosted.org/packages/e1/e6/e31b0d713719610e406c0ea3ae0d90760465b086da8783e2fd835ad59027/numpy-2.3.4-cp312-cp312-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:77b84453f3adcb994ddbd0d1c5d11db2d6bda1a2b7fd5ac5bd4649d6f5dc682e", size = 14284156, upload-time = "2025-10-15T16:15:54.351Z" },
    { url = "https://files.pythonhosted.org/packages/f9/58/30a85127bfee6f108282107caf8e06a1f0cc997cb6b52cdee699276fcce4/numpy-2.3.4-cp312-cp312-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:4121c5beb58a7f9e6dfdee612cb24f4df5cd4db6e8261d7f4d7450a997a65d6a", size = 16641271, upload-time = "2025-10-15T16:15:56.67Z" },
    { url = "https://files.pythonhosted.org/packages/06/f2/2e06a0f2adf23e3ae29283ad96959267938d0efd20a2e25353b70065bfec/numpy-2.3.4-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:65611ecbb00ac9846efe04db15cbe6186f562f6bb7e5e05f077e53a599225d16", size = 16059531, upload-time = "2025-10-15T16:15:59.412Z" },
    { url = "https://files.pythonhosted.org/packages/b0/e7/b106253c7c0d5dc352b9c8fab91afd76a93950998167fa3e5afe4ef3a18f/numpy-2.3.4-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:dabc42f9c6577bcc13001b8810d300fe814b4cfbe8a92c873f269484594f9786", size = 18578983, upload-time = "2025-10-15T16:16:01.804Z" },
    { url = "https://files.pythonhosted.org/packages/73/e3/04ecc41e71462276ee867ccbef26a4448638eadecf1bc56772c9ed6d0255/numpy-2.3.4-cp312-cp312-win32.whl", hash = "sha256:a49d797192a8d950ca59ee2d0337a4d804f713bb5c3c50e8db26d49666e351dc", size = 6291380, upload-time = "2025-10-15T16:16:03.938Z" },
    { url = "https://files.pythonhosted.org/packages/3d/a8/566578b10d8d0e9955b1b6cd5db4e9d4592dd0026a941ff7994cedda030a/numpy-2.3.4-cp312-cp312-win_amd64.whl", hash = "sha256:985f1e46358f06c2a09921e8921e2c98168ed4ae12ccd6e5e87a4f1857923f32", size = 12787999, upload-time = "2025-10-15T16:16:05.801Z" },
    { url = "https://files.pythonhosted.org/packages/58/22/9c903a957d0a8071b607f5b1bff0761d6e608b9a965945411f867d515db1/numpy-2.3.4-cp312-cp312-win_arm64.whl", hash = "sha256:4635239814149e06e2cb9db3dd584b2fa64316c96f10656983b8026a82e6e4db", size = 10197412, upload-time = "2025-10-15T16:16:07.854Z" },
    { url = "https://files.pythonhosted.org/packages/57/7e/b72610cc91edf138bc588df5150957a4937221ca6058b825b4725c27be62/numpy-2.3.4-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:c090d4860032b857d94144d1a9976b8e36709e40386db289aaf6672de2a81966", size = 20950335, upload-time = "2025-10-15T16:16:10.304Z" },
    { url = "https://files.pythonhosted.org/packages/3e/46/bdd3370dcea2f95ef14af79dbf81e6927102ddf1cc54adc0024d61252fd9/numpy-2.3.4-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:a13fc473b6db0be619e45f11f9e81260f7302f8d180c49a22b6e6120022596b3", size = 14179878, upload-time = "2025-10-15T16:16:12.595Z" },
    { url = "https://files.pythonhosted.org/packages/ac/01/5a67cb785bda60f45415d09c2bc245433f1c68dd82eef9c9002c508b5a65/numpy-2.3.4-cp313-cp313-macosx_14_0_arm64.whl", hash = "sha256:3634093d0b428e6c32c3a69b78e554f0cd20ee420dcad5a9f3b2a63762ce4197", size = 5108673, upload-time = "2025-10-15T16:16:14.877Z" },
    { url = "https://files.pythonhosted.org/packages/c2/cd/8428e23a9fcebd33988f4cb61208fda832800ca03781f471f3727a820704/numpy-2.3.4-cp313-cp313-macosx_14_0_x86_64.whl", hash = "sha256:043885b4f7e6e232d7df4f51ffdef8c36320ee9d5f227b380ea636722c7ed12e", size = 6641438, upload-time = "2025-10-15T16:16:16.805Z" },
    { url = "https://files.pythonhosted.org/packages/3e/d1/913fe563820f3c6b079f992458f7331278dcd7ba8427e8e745af37ddb44f/numpy-2.3.4-cp313-cp313-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:4ee6a571d1e4f0ea6d5f22d6e5fbd6ed1dc2b18542848e1e7301bd190500c9d7", size = 14281290, upload-time = "2025-10-15T16:16:18.764Z" },
    { url = "https://files.pythonhosted.org/packages/9e/7e/7d306ff7cb143e6d975cfa7eb98a93e73495c4deabb7d1b5ecf09ea0fd69/numpy-2.3.4-cp313-cp313-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:fc8a63918b04b8571789688b2780ab2b4a33ab44bfe8ccea36d3eba51228c953", size = 16636543, upload-time = "2025-10-15T16:16:21.072Z" },
    { url = "https://files.pythonhosted.org/packages/47/6a/8cfc486237e56ccfb0db234945552a557ca266f022d281a2f577b98e955c/numpy-2.3.4-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:40cc556d5abbc54aabe2b1ae287042d7bdb80c08edede19f0c0afb36ae586f37", size = 16056117, upload-time = "2025-10-15T16:16:23.369Z" },
    { url = "https://files.pythonhosted.org/packages/b1/0e/42cb5e69ea901e06ce24bfcc4b5664a56f950a70efdcf221f30d9615f3f3/numpy-2.3.4-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:ecb63014bb7f4ce653f8be7f1df8cbc6093a5a2811211770f6606cc92b5a78fd", size = 18577788, upload-time = "2025-10-15T16:16:27.496Z" },
    { url = "https://files.pythonhosted.org/packages/86/92/41c3d5157d3177559ef0a35da50f0cda7fa071f4ba2306dd36818591a5bc/numpy-2.3.4-cp313-cp313-win32.whl", hash = "sha256:e8370eb6925bb8c1c4264fec52b0384b44f675f191df91cbe0140ec9f0955646", size = 6282620, upload-time = "2025-10-15T16:16:29.811Z" },
    { url = "https://files.pythonhosted.org/packages/09/97/fd421e8bc50766665ad35536c2bb4ef916533ba1fdd053a62d96cc7c8b95/numpy-2.3.4-cp313-cp313-win_amd64.whl", hash = "sha256:56209416e81a7893036eea03abcb91c130643eb14233b2515c90dcac963fe99d", size = 12784672, upload-time = "2025-10-15T16:16:31.589Z" },
    { url = "https://files.pythonhosted.org/packages/ad/df/5474fb2f74970ca8eb978093969b125a84cc3d30e47f82191f981f13a8a0/numpy-2.3.4-cp313-cp313-win_arm64.whl", hash = "sha256:a700a4031bc0fd6936e78a752eefb79092cecad2599ea9c8039c548bc097f9bc", size = 10196702, upload-time = "2025-10-15T16:16:33.902Z" },
    { url = "https://files.pythonhosted.org/packages/11/83/66ac031464ec1767ea3ed48ce40f615eb441072945e98693bec0bcd056cc/numpy-2.3.4-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:86966db35c4040fdca64f0816a1c1dd8dbd027d90fca5a57e00e1ca4cd41b879", size = 21049003, upload-time = "2025-10-15T16:16:36.101Z" },
    { url = "https://files.pythonhosted.org/packages/5f/99/5b14e0e686e61371659a1d5bebd04596b1d72227ce36eed121bb0aeab798/numpy-2.3.4-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:838f045478638b26c375ee96ea89464d38428c69170360b23a1a50fa4baa3562", size = 14302980, upload-time = "2025-10-15T16:16:39.124Z" },
    { url = "https://files.pythonhosted.org/packages/2c/44/e9486649cd087d9fc6920e3fc3ac2aba10838d10804b1e179fb7cbc4e634/numpy-2.3.4-cp313-cp313t-macosx_14_0_arm64.whl", hash = "sha256:d7315ed1dab0286adca467377c8381cd748f3dc92235f22a7dfc42745644a96a", size = 5231472, upload-time = "2025-10-15T16:16:41.168Z" },
    { url = "https://files.pythonhosted.org/packages/3e/51/902b24fa8887e5fe2063fd61b1895a476d0bbf46811ab0c7fdf4bd127345/numpy-2.3.4-cp313-cp313t-macosx_14_0_x86_64.whl", hash = "sha256:84f01a4d18b2cc4ade1814a08e5f3c907b079c847051d720fad15ce37aa930b6", size = 6739342, upload-time = "2025-10-15T16:16:43.777Z" },
    { url = "https://files.pythonhosted.org/packages/34/f1/4de9586d05b1962acdcdb1dc4af6646361a643f8c864cef7c852bf509740/numpy-2.3.4-cp313-cp313t-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:817e719a868f0dacde4abdfc5c1910b301877970195db9ab6a5e2c4bd5b121f7", size = 14354338, upload-time = "2025-10-15T16:16:46.081Z" },
    { url = "https://files.pythonhosted.org/packages/1f/06/1c16103b425de7969d5a76bdf5ada0804b476fed05d5f9e17b777f1cbefd/numpy-2.3.4-cp313-cp313t-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:85e071da78d92a214212cacea81c6da557cab307f2c34b5f85b628e94803f9c0", size = 16702392, upload-time = "2025-10-15T16:16:48.455Z" },
    { url = "https://files.pythonhosted.org/packages/34/b2/65f4dc1b89b5322093572b6e55161bb42e3e0487067af73627f795cc9d47/numpy-2.3.4-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:2ec646892819370cf3558f518797f16597b4e4669894a2ba712caccc9da53f1f", size = 16134998, upload-time = "2025-10-15T16:16:51.114Z" },
    { url = "https://files.pythonhosted.org/packages/d4/11/94ec578896cdb973aaf56425d6c7f2aff4186a5c00fac15ff2ec46998b46/numpy-2.3.4-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:035796aaaddfe2f9664b9a9372f089cfc88bd795a67bd1bfe15e6e770934cf64", size = 18651574, upload-time = "2025-10-15T16:16:53.429Z" },
    { url = "https://files.pythonhosted.org/packages/62/b7/7efa763ab33dbccf56dade36938a77345ce8e8192d6b39e470ca25ff3cd0/numpy-2.3.4-cp313-cp313t-win32.whl", hash = "sha256:fea80f4f4cf83b54c3a051f2f727870ee51e22f0248d3114b8e755d160b38cfb", size = 6413135, upload-time = "2025-10-15T16:16:55.992Z" },
    { url = "https://files.pythonhosted.org/packages/43/70/aba4c38e8400abcc2f345e13d972fb36c26409b3e644366db7649015f291/numpy-2.3.4-cp313-cp313t-win_amd64.whl", hash = "sha256:15eea9f306b98e0be91eb344a94c0e630689ef302e10c2ce5f7e11905c704f9c", size = 12928582, upload-time = "2025-10-15T16:16:57.943Z" },
    { url = "https://files.pythonhosted.org/packages/67/63/871fad5f0073fc00fbbdd7232962ea1ac40eeaae2bba66c76214f7954236/numpy-2.3.4-cp313-cp313t-win_arm64.whl", hash = "sha256:b6c231c9c2fadbae4011ca5e7e83e12dc4a5072f1a1d85a0a7b3ed754d145a40", size = 10266691, upload-time = "2025-10-15T16:17:00.048Z" },
    { url = "https://files.pythonhosted.org/packages/b1/b6/64898f51a86ec88ca1257a59c1d7fd077b60082a119affefcdf1dd0df8ca/numpy-2.3.4-pp311-pypy311_pp73-macosx_10_15_x86_64.whl", hash = "sha256:6e274603039f924c0fe5cb73438fa9246699c78a6df1bd3decef9ae592ae1c05", size = 21131552, upload-time = "2025-10-15T16:17:55.845Z" },
    { url = "https://files.pythonhosted.org/packages/ce/4c/f135dc6ebe2b6a3c77f4e4838fa63d350f85c99462012306ada1bd4bc460/numpy-2.3.4-pp311-pypy311_pp73-macosx_11_0_arm64.whl", hash = "sha256:d149aee5c72176d9ddbc6803aef9c0f6d2ceeea7626574fc68518da5476fa346", size = 14377796, upload-time = "2025-10-15T16:17:58.308Z" },
    { url = "https://files.pythonhosted.org/packages/d0/a4/f33f9c23fcc13dd8412fc8614559b5b797e0aba9d8e01dfa8bae10c84004/numpy-2.3.4-pp311-pypy311_pp73-macosx_14_0_arm64.whl", hash = "sha256:6d34ed9db9e6395bb6cd33286035f73a59b058169733a9db9f85e650b88df37e", size = 5306904, upload-time = "2025-10-15T16:18:00.596Z" },
    { url = "https://files.pythonhosted.org/packages/28/af/c44097f25f834360f9fb960fa082863e0bad14a42f36527b2a121abdec56/numpy-2.3.4-pp311-pypy311_pp73-macosx_14_0_x86_64.whl", hash = "sha256:fdebe771ca06bb8d6abce84e51dca9f7921fe6ad34a0c914541b063e9a68928b", size = 6819682, upload-time = "2025-10-15T16:18:02.32Z" },
    { url = "https://files.pythonhosted.org/packages/c5/8c/cd283b54c3c2b77e188f63e23039844f56b23bba1712318288c13fe86baf/numpy-2.3.4-pp311-pypy311_pp73-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:957e92defe6c08211eb77902253b14fe5b480ebc5112bc741fd5e9cd0608f847", size = 14422300, upload-time = "2025-10-15T16:18:04.271Z" },
    { url = "https://files.pythonhosted.org/packages/b0/f0/8404db5098d92446b3e3695cf41c6f0ecb703d701cb0b7566ee2177f2eee/numpy-2.3.4-pp311-pypy311_pp73-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:13b9062e4f5c7ee5c7e5be96f29ba71bc5a37fed3d1d77c37390ae00724d296d", size = 16760806, upload-time = "2025-10-15T16:18:06.668Z" },
    { url = "https://files.pythonhosted.org/packages/95/8e/2844c3959ce9a63acc7c8e50881133d86666f0420bcde695e115ced0920f/numpy-2.3.4-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:81b3a59793523e552c4a96109dde028aa4448ae06ccac5a76ff6532a85558a7f", size = 12973130, upload-time = "2025-10-15T16:18:09.397Z" },
]

[[package]]
name = "ollama"
version = "0.6.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "httpx" },
    { name = "pydantic" },
]
sdist = { url = "https://files.pythonhosted.org/packages/d6/47/f9ee32467fe92744474a8c72e138113f3b529fc266eea76abfdec9a33f3b/ollama-0.6.0.tar.gz", hash = "sha256:da2b2d846b5944cfbcee1ca1e6ee0585f6c9d45a2fe9467cbcd096a37383da2f", size = 50811, upload-time = "2025-09-24T22:46:02.417Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b5/c1/edc9f41b425ca40b26b7c104c5f6841a4537bb2552bfa6ca66e81405bb95/ollama-0.6.0-py3-none-any.whl", hash = "sha256:534511b3ccea2dff419ae06c3b58d7f217c55be7897c8ce5868dfb6b219cf7a0", size = 14130, upload-time = "2025-09-24T22:46:01.19Z" },
]

[[package]]
name = "openai"
version = "1.109.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "distro" },
    { name = "httpx" },
    { name = "jiter" },
    { name = "pydantic" },
    { name = "sniffio" },
    { name = "tqdm" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/c6/a1/a303104dc55fc546a3f6914c842d3da471c64eec92043aef8f652eb6c524/openai-1.109.1.tar.gz", hash = "sha256:d173ed8dbca665892a6db099b4a2dfac624f94d20a93f46eb0b56aae940ed869", size = 564133, upload-time = "2025-09-24T13:00:53.075Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1d/2a/7dd3d207ec669cacc1f186fd856a0f61dbc255d24f6fdc1a6715d6051b0f/openai-1.109.1-py3-none-any.whl", hash = "sha256:6bcaf57086cf59159b8e27447e4e7dd019db5d29a438072fbd49c290c7e65315", size = 948627, upload-time = "2025-09-24T13:00:50.754Z" },
]

[[package]]
name = "openinference-instrumentation"
version = "0.1.42"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "openinference-semantic-conventions" },
    { name = "opentelemetry-api" },
    { name = "opentelemetry-sdk" },
    { name = "wrapt" },
]
sdist = { url = "https://files.pythonhosted.org/packages/00/d0/b19061a21fd6127d2857c77744a36073bba9c1502d1d5e8517b708eb8b7c/openinference_instrumentation-0.1.42.tar.gz", hash = "sha256:2275babc34022e151b5492cfba41d3b12e28377f8e08cb45e5d64fe2d9d7fe37", size = 23954, upload-time = "2025-11-05T01:37:46.869Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c3/71/43ee4616fc95dbd2f560550f199c6652a5eb93f84e8aa0039bc95c19cfe0/openinference_instrumentation-0.1.42-py3-none-any.whl", hash = "sha256:e7521ff90833ef7cc65db526a2f59b76a496180abeaaee30ec6abbbc0b43f8ec", size = 30086, upload-time = "2025-11-05T01:37:43.866Z" },
]

[[package]]
name = "openinference-instrumentation-llama-index"
version = "4.3.8"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "openinference-instrumentation" },
    { name = "openinference-semantic-conventions" },
    { name = "opentelemetry-api" },
    { name = "opentelemetry-instrumentation" },
    { name = "opentelemetry-semantic-conventions" },
    { name = "typing-extensions" },
    { name = "wrapt" },
]
sdist = { url = "https://files.pythonhosted.org/packages/4e/aa/c22b78bc600046a890fcf2e10bc32e11f06590cd694b0fe646de14da6783/openinference_instrumentation_llama_index-4.3.8.tar.gz", hash = "sha256:ceff6e0a6773b3ddf78a50a9237bf3b7b9bf8a9e0709f2f610f7c464075b9f49", size = 60758, upload-time = "2025-10-23T20:55:33.858Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/5e/3f/36816c214bfdc066133354291ca324a862c9310dc844a136abfe9741c9ab/openinference_instrumentation_llama_index-4.3.8-py3-none-any.whl", hash = "sha256:e7a16881ba124079980508d8f6b20d5b23ba15f13a976e4dd68336c036351cfb", size = 28866, upload-time = "2025-10-23T20:55:32.578Z" },
]

[[package]]
name = "openinference-semantic-conventions"
version = "0.1.25"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/0b/68/81c8a0b90334ff11e4f285e4934c57f30bea3ef0c0b9f99b65e7b80fae3b/openinference_semantic_conventions-0.1.25.tar.gz", hash = "sha256:f0a8c2cfbd00195d1f362b4803518341e80867d446c2959bf1743f1894fce31d", size = 12767, upload-time = "2025-11-05T01:37:45.89Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/fd/3d/dd14ee2eb8a3f3054249562e76b253a1545c76adbbfd43a294f71acde5c3/openinference_semantic_conventions-0.1.25-py3-none-any.whl", hash = "sha256:3814240f3bd61f05d9562b761de70ee793d55b03bca1634edf57d7a2735af238", size = 10395, upload-time = "2025-11-05T01:37:43.697Z" },
]

[[package]]
name = "opentelemetry-api"
version = "1.38.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "importlib-metadata" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/08/d8/0f354c375628e048bd0570645b310797299754730079853095bf000fba69/opentelemetry_api-1.38.0.tar.gz", hash = "sha256:f4c193b5e8acb0912b06ac5b16321908dd0843d75049c091487322284a3eea12", size = 65242, upload-time = "2025-10-16T08:35:50.25Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ae/a2/d86e01c28300bd41bab8f18afd613676e2bd63515417b77636fc1add426f/opentelemetry_api-1.38.0-py3-none-any.whl", hash = "sha256:2891b0197f47124454ab9f0cf58f3be33faca394457ac3e09daba13ff50aa582", size = 65947, upload-time = "2025-10-16T08:35:30.23Z" },
]

[[package]]
name = "opentelemetry-exporter-otlp"
version = "1.38.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "opentelemetry-exporter-otlp-proto-grpc" },
    { name = "opentelemetry-exporter-otlp-proto-http" },
]
sdist = { url = "https://files.pythonhosted.org/packages/c2/2d/16e3487ddde2dee702bd746dd41950a8789b846d22a1c7e64824aac5ebea/opentelemetry_exporter_otlp-1.38.0.tar.gz", hash = "sha256:2f55acdd475e4136117eff20fbf1b9488b1b0b665ab64407516e1ac06f9c3f9d", size = 6147, upload-time = "2025-10-16T08:35:52.53Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/fd/8a/81cd252b16b7d95ec1147982b6af81c7932d23918b4c3b15372531242ddd/opentelemetry_exporter_otlp-1.38.0-py3-none-any.whl", hash = "sha256:bc6562cef229fac8887ed7109fc5abc52315f39d9c03fd487bb8b4ef8fbbc231", size = 7018, upload-time = "2025-10-16T08:35:32.995Z" },
]

[[package]]
name = "opentelemetry-exporter-otlp-proto-common"
version = "1.38.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "opentelemetry-proto" },
]
sdist = { url = "https://files.pythonhosted.org/packages/19/83/dd4660f2956ff88ed071e9e0e36e830df14b8c5dc06722dbde1841accbe8/opentelemetry_exporter_otlp_proto_common-1.38.0.tar.gz", hash = "sha256:e333278afab4695aa8114eeb7bf4e44e65c6607d54968271a249c180b2cb605c", size = 20431, upload-time = "2025-10-16T08:35:53.285Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a7/9e/55a41c9601191e8cd8eb626b54ee6827b9c9d4a46d736f32abc80d8039fc/opentelemetry_exporter_otlp_proto_common-1.38.0-py3-none-any.whl", hash = "sha256:03cb76ab213300fe4f4c62b7d8f17d97fcfd21b89f0b5ce38ea156327ddda74a", size = 18359, upload-time = "2025-10-16T08:35:34.099Z" },
]

[[package]]
name = "opentelemetry-exporter-otlp-proto-grpc"
version = "1.38.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "googleapis-common-protos" },
    { name = "grpcio" },
    { name = "opentelemetry-api" },
    { name = "opentelemetry-exporter-otlp-proto-common" },
    { name = "opentelemetry-proto" },
    { name = "opentelemetry-sdk" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/a2/c0/43222f5b97dc10812bc4f0abc5dc7cd0a2525a91b5151d26c9e2e958f52e/opentelemetry_exporter_otlp_proto_grpc-1.38.0.tar.gz", hash = "sha256:2473935e9eac71f401de6101d37d6f3f0f1831db92b953c7dcc912536158ebd6", size = 24676, upload-time = "2025-10-16T08:35:53.83Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/28/f0/bd831afbdba74ca2ce3982142a2fad707f8c487e8a3b6fef01f1d5945d1b/opentelemetry_exporter_otlp_proto_grpc-1.38.0-py3-none-any.whl", hash = "sha256:7c49fd9b4bd0dbe9ba13d91f764c2d20b0025649a6e4ac35792fb8d84d764bc7", size = 19695, upload-time = "2025-10-16T08:35:35.053Z" },
]

[[package]]
name = "opentelemetry-exporter-otlp-proto-http"
version = "1.38.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "googleapis-common-protos" },
    { name = "opentelemetry-api" },
    { name = "opentelemetry-exporter-otlp-proto-common" },
    { name = "opentelemetry-proto" },
    { name = "opentelemetry-sdk" },
    { name = "requests" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/81/0a/debcdfb029fbd1ccd1563f7c287b89a6f7bef3b2902ade56797bfd020854/opentelemetry_exporter_otlp_proto_http-1.38.0.tar.gz", hash = "sha256:f16bd44baf15cbe07633c5112ffc68229d0edbeac7b37610be0b2def4e21e90b", size = 17282, upload-time = "2025-10-16T08:35:54.422Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e5/77/154004c99fb9f291f74aa0822a2f5bbf565a72d8126b3a1b63ed8e5f83c7/opentelemetry_exporter_otlp_proto_http-1.38.0-py3-none-any.whl", hash = "sha256:84b937305edfc563f08ec69b9cb2298be8188371217e867c1854d77198d0825b", size = 19579, upload-time = "2025-10-16T08:35:36.269Z" },
]

[[package]]
name = "opentelemetry-instrumentation"
version = "0.59b0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "opentelemetry-api" },
    { name = "opentelemetry-semantic-conventions" },
    { name = "packaging" },
    { name = "wrapt" },
]
sdist = { url = "https://files.pythonhosted.org/packages/04/ed/9c65cd209407fd807fa05be03ee30f159bdac8d59e7ea16a8fe5a1601222/opentelemetry_instrumentation-0.59b0.tar.gz", hash = "sha256:6010f0faaacdaf7c4dff8aac84e226d23437b331dcda7e70367f6d73a7db1adc", size = 31544, upload-time = "2025-10-16T08:39:31.959Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/10/f5/7a40ff3f62bfe715dad2f633d7f1174ba1a7dd74254c15b2558b3401262a/opentelemetry_instrumentation-0.59b0-py3-none-any.whl", hash = "sha256:44082cc8fe56b0186e87ee8f7c17c327c4c2ce93bdbe86496e600985d74368ee", size = 33020, upload-time = "2025-10-16T08:38:31.463Z" },
]

[[package]]
name = "opentelemetry-proto"
version = "1.38.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "protobuf" },
]
sdist = { url = "https://files.pythonhosted.org/packages/51/14/f0c4f0f6371b9cb7f9fa9ee8918bfd59ac7040c7791f1e6da32a1839780d/opentelemetry_proto-1.38.0.tar.gz", hash = "sha256:88b161e89d9d372ce723da289b7da74c3a8354a8e5359992be813942969ed468", size = 46152, upload-time = "2025-10-16T08:36:01.612Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b6/6a/82b68b14efca5150b2632f3692d627afa76b77378c4999f2648979409528/opentelemetry_proto-1.38.0-py3-none-any.whl", hash = "sha256:b6ebe54d3217c42e45462e2a1ae28c3e2bf2ec5a5645236a490f55f45f1a0a18", size = 72535, upload-time = "2025-10-16T08:35:45.749Z" },
]

[[package]]
name = "opentelemetry-sdk"
version = "1.38.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "opentelemetry-api" },
    { name = "opentelemetry-semantic-conventions" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/85/cb/f0eee1445161faf4c9af3ba7b848cc22a50a3d3e2515051ad8628c35ff80/opentelemetry_sdk-1.38.0.tar.gz", hash = "sha256:93df5d4d871ed09cb4272305be4d996236eedb232253e3ab864c8620f051cebe", size = 171942, upload-time = "2025-10-16T08:36:02.257Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2f/2e/e93777a95d7d9c40d270a371392b6d6f1ff170c2a3cb32d6176741b5b723/opentelemetry_sdk-1.38.0-py3-none-any.whl", hash = "sha256:1c66af6564ecc1553d72d811a01df063ff097cdc82ce188da9951f93b8d10f6b", size = 132349, upload-time = "2025-10-16T08:35:46.995Z" },
]

[[package]]
name = "opentelemetry-semantic-conventions"
version = "0.59b0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "opentelemetry-api" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/40/bc/8b9ad3802cd8ac6583a4eb7de7e5d7db004e89cb7efe7008f9c8a537ee75/opentelemetry_semantic_conventions-0.59b0.tar.gz", hash = "sha256:7a6db3f30d70202d5bf9fa4b69bc866ca6a30437287de6c510fb594878aed6b0", size = 129861, upload-time = "2025-10-16T08:36:03.346Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/24/7d/c88d7b15ba8fe5c6b8f93be50fc11795e9fc05386c44afaf6b76fe191f9b/opentelemetry_semantic_conventions-0.59b0-py3-none-any.whl", hash = "sha256:35d3b8833ef97d614136e253c1da9342b4c3c083bbaf29ce31d572a1c3825eed", size = 207954, upload-time = "2025-10-16T08:35:48.054Z" },
]

[[package]]
name = "orjson"
version = "3.11.7"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/53/45/b268004f745ede84e5798b48ee12b05129d19235d0e15267aa57dcdb400b/orjson-3.11.7.tar.gz", hash = "sha256:9b1a67243945819ce55d24a30b59d6a168e86220452d2c96f4d1f093e71c0c49", size = 6144992, upload-time = "2026-02-02T15:38:49.29Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/37/02/da6cb01fc6087048d7f61522c327edf4250f1683a58a839fdcc435746dd5/orjson-3.11.7-cp311-cp311-macosx_10_15_x86_64.macosx_11_0_arm64.macosx_10_15_universal2.whl", hash = "sha256:9487abc2c2086e7c8eb9a211d2ce8855bae0e92586279d0d27b341d5ad76c85c", size = 228664, upload-time = "2026-02-02T15:37:25.542Z" },
    { url = "https://files.pythonhosted.org/packages/c1/c2/5885e7a5881dba9a9af51bc564e8967225a642b3e03d089289a35054e749/orjson-3.11.7-cp311-cp311-macosx_15_0_arm64.whl", hash = "sha256:79cacb0b52f6004caf92405a7e1f11e6e2de8bdf9019e4f76b44ba045125cd6b", size = 125344, upload-time = "2026-02-02T15:37:26.92Z" },
    { url = "https://files.pythonhosted.org/packages/a4/1d/4e7688de0a92d1caf600dfd5fb70b4c5bfff51dfa61ac555072ef2d0d32a/orjson-3.11.7-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c2e85fe4698b6a56d5e2ebf7ae87544d668eb6bde1ad1226c13f44663f20ec9e", size = 128404, upload-time = "2026-02-02T15:37:28.108Z" },
    { url = "https://files.pythonhosted.org/packages/2f/b2/ec04b74ae03a125db7bd69cffd014b227b7f341e3261bf75b5eb88a1aa92/orjson-3.11.7-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:b8d14b71c0b12963fe8a62aac87119f1afdf4cb88a400f61ca5ae581449efcb5", size = 123677, upload-time = "2026-02-02T15:37:30.287Z" },
    { url = "https://files.pythonhosted.org/packages/4c/69/f95bdf960605f08f827f6e3291fe243d8aa9c5c9ff017a8d7232209184c3/orjson-3.11.7-cp311-cp311-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:91c81ef070c8f3220054115e1ef468b1c9ce8497b4e526cb9f68ab4dc0a7ac62", size = 128950, upload-time = "2026-02-02T15:37:31.595Z" },
    { url = "https://files.pythonhosted.org/packages/a4/1b/de59c57bae1d148ef298852abd31909ac3089cff370dfd4cd84cc99cbc42/orjson-3.11.7-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:411ebaf34d735e25e358a6d9e7978954a9c9d58cfb47bc6683cdc3964cd2f910", size = 141756, upload-time = "2026-02-02T15:37:32.985Z" },
    { url = "https://files.pythonhosted.org/packages/ee/9e/9decc59f4499f695f65c650f6cfa6cd4c37a3fbe8fa235a0a3614cb54386/orjson-3.11.7-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:a16bcd08ab0bcdfc7e8801d9c4a9cc17e58418e4d48ddc6ded4e9e4b1a94062b", size = 130812, upload-time = "2026-02-02T15:37:34.204Z" },
    { url = "https://files.pythonhosted.org/packages/28/e6/59f932bcabd1eac44e334fe8e3281a92eacfcb450586e1f4bde0423728d8/orjson-3.11.7-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9c0b51672e466fd7e56230ffbae7f1639e18d0ce023351fb75da21b71bc2c960", size = 133444, upload-time = "2026-02-02T15:37:35.446Z" },
    { url = "https://files.pythonhosted.org/packages/f1/36/b0f05c0eaa7ca30bc965e37e6a2956b0d67adb87a9872942d3568da846ae/orjson-3.11.7-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:136dcd6a2e796dfd9ffca9fc027d778567b0b7c9968d092842d3c323cef88aa8", size = 138609, upload-time = "2026-02-02T15:37:36.657Z" },
    { url = "https://files.pythonhosted.org/packages/b8/03/58ec7d302b8d86944c60c7b4b82975d5161fcce4c9bc8c6cb1d6741b6115/orjson-3.11.7-cp311-cp311-musllinux_1_2_armv7l.whl", hash = "sha256:7ba61079379b0ae29e117db13bda5f28d939766e410d321ec1624afc6a0b0504", size = 408918, upload-time = "2026-02-02T15:37:38.076Z" },
    { url = "https://files.pythonhosted.org/packages/06/3a/868d65ef9a8b99be723bd510de491349618abd9f62c826cf206d962db295/orjson-3.11.7-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:0527a4510c300e3b406591b0ba69b5dc50031895b0a93743526a3fc45f59d26e", size = 143998, upload-time = "2026-02-02T15:37:39.706Z" },
    { url = "https://files.pythonhosted.org/packages/5b/c7/1e18e1c83afe3349f4f6dc9e14910f0ae5f82eac756d1412ea4018938535/orjson-3.11.7-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:a709e881723c9b18acddcfb8ba357322491ad553e277cf467e1e7e20e2d90561", size = 134802, upload-time = "2026-02-02T15:37:41.002Z" },
    { url = "https://files.pythonhosted.org/packages/d4/0b/ccb7ee1a65b37e8eeb8b267dc953561d72370e85185e459616d4345bab34/orjson-3.11.7-cp311-cp311-win32.whl", hash = "sha256:c43b8b5bab288b6b90dac410cca7e986a4fa747a2e8f94615aea407da706980d", size = 127828, upload-time = "2026-02-02T15:37:42.241Z" },
    { url = "https://files.pythonhosted.org/packages/af/9e/55c776dffda3f381e0f07d010a4f5f3902bf48eaba1bb7684d301acd4924/orjson-3.11.7-cp311-cp311-win_amd64.whl", hash = "sha256:6543001328aa857187f905308a028935864aefe9968af3848401b6fe80dbb471", size = 124941, upload-time = "2026-02-02T15:37:43.444Z" },
    { url = "https://files.pythonhosted.org/packages/aa/8e/424a620fa7d263b880162505fb107ef5e0afaa765b5b06a88312ac291560/orjson-3.11.7-cp311-cp311-win_arm64.whl", hash = "sha256:1ee5cc7160a821dfe14f130bc8e63e7611051f964b463d9e2a3a573204446a4d", size = 126245, upload-time = "2026-02-02T15:37:45.18Z" },
    { url = "https://files.pythonhosted.org/packages/80/bf/76f4f1665f6983385938f0e2a5d7efa12a58171b8456c252f3bae8a4cf75/orjson-3.11.7-cp312-cp312-macosx_10_15_x86_64.macosx_11_0_arm64.macosx_10_15_universal2.whl", hash = "sha256:bd03ea7606833655048dab1a00734a2875e3e86c276e1d772b2a02556f0d895f", size = 228545, upload-time = "2026-02-02T15:37:46.376Z" },
    { url = "https://files.pythonhosted.org/packages/79/53/6c72c002cb13b5a978a068add59b25a8bdf2800ac1c9c8ecdb26d6d97064/orjson-3.11.7-cp312-cp312-macosx_15_0_arm64.whl", hash = "sha256:89e440ebc74ce8ab5c7bc4ce6757b4a6b1041becb127df818f6997b5c71aa60b", size = 125224, upload-time = "2026-02-02T15:37:47.697Z" },
    { url = "https://files.pythonhosted.org/packages/2c/83/10e48852865e5dd151bdfe652c06f7da484578ed02c5fca938e3632cb0b8/orjson-3.11.7-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:5ede977b5fe5ac91b1dffc0a517ca4542d2ec8a6a4ff7b2652d94f640796342a", size = 128154, upload-time = "2026-02-02T15:37:48.954Z" },
    { url = "https://files.pythonhosted.org/packages/6e/52/a66e22a2b9abaa374b4a081d410edab6d1e30024707b87eab7c734afe28d/orjson-3.11.7-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:b7b1dae39230a393df353827c855a5f176271c23434cfd2db74e0e424e693e10", size = 123548, upload-time = "2026-02-02T15:37:50.187Z" },
    { url = "https://files.pythonhosted.org/packages/de/38/605d371417021359f4910c496f764c48ceb8997605f8c25bf1dfe58c0ebe/orjson-3.11.7-cp312-cp312-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:ed46f17096e28fb28d2975834836a639af7278aa87c84f68ab08fbe5b8bd75fa", size = 129000, upload-time = "2026-02-02T15:37:51.426Z" },
    { url = "https://files.pythonhosted.org/packages/44/98/af32e842b0ffd2335c89714d48ca4e3917b42f5d6ee5537832e069a4b3ac/orjson-3.11.7-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:3726be79e36e526e3d9c1aceaadbfb4a04ee80a72ab47b3f3c17fefb9812e7b8", size = 141686, upload-time = "2026-02-02T15:37:52.607Z" },
    { url = "https://files.pythonhosted.org/packages/96/0b/fc793858dfa54be6feee940c1463370ece34b3c39c1ca0aa3845f5ba9892/orjson-3.11.7-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:0724e265bc548af1dedebd9cb3d24b4e1c1e685a343be43e87ba922a5c5fff2f", size = 130812, upload-time = "2026-02-02T15:37:53.944Z" },
    { url = "https://files.pythonhosted.org/packages/dc/91/98a52415059db3f374757d0b7f0f16e3b5cd5976c90d1c2b56acaea039e6/orjson-3.11.7-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:e7745312efa9e11c17fbd3cb3097262d079da26930ae9ae7ba28fb738367cbad", size = 133440, upload-time = "2026-02-02T15:37:55.615Z" },
    { url = "https://files.pythonhosted.org/packages/dc/b6/cb540117bda61791f46381f8c26c8f93e802892830a6055748d3bb1925ab/orjson-3.11.7-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:f904c24bdeabd4298f7a977ef14ca2a022ca921ed670b92ecd16ab6f3d01f867", size = 138386, upload-time = "2026-02-02T15:37:56.814Z" },
    { url = "https://files.pythonhosted.org/packages/63/1a/50a3201c334a7f17c231eee5f841342190723794e3b06293f26e7cf87d31/orjson-3.11.7-cp312-cp312-musllinux_1_2_armv7l.whl", hash = "sha256:b9fc4d0f81f394689e0814617aadc4f2ea0e8025f38c226cbf22d3b5ddbf025d", size = 408853, upload-time = "2026-02-02T15:37:58.291Z" },
    { url = "https://files.pythonhosted.org/packages/87/cd/8de1c67d0be44fdc22701e5989c0d015a2adf391498ad42c4dc589cd3013/orjson-3.11.7-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:849e38203e5be40b776ed2718e587faf204d184fc9a008ae441f9442320c0cab", size = 144130, upload-time = "2026-02-02T15:38:00.163Z" },
    { url = "https://files.pythonhosted.org/packages/0f/fe/d605d700c35dd55f51710d159fc54516a280923cd1b7e47508982fbb387d/orjson-3.11.7-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:4682d1db3bcebd2b64757e0ddf9e87ae5f00d29d16c5cdf3a62f561d08cc3dd2", size = 134818, upload-time = "2026-02-02T15:38:01.507Z" },
    { url = "https://files.pythonhosted.org/packages/e4/e4/15ecc67edb3ddb3e2f46ae04475f2d294e8b60c1825fbe28a428b93b3fbd/orjson-3.11.7-cp312-cp312-win32.whl", hash = "sha256:f4f7c956b5215d949a1f65334cf9d7612dde38f20a95f2315deef167def91a6f", size = 127923, upload-time = "2026-02-02T15:38:02.75Z" },
    { url = "https://files.pythonhosted.org/packages/34/70/2e0855361f76198a3965273048c8e50a9695d88cd75811a5b46444895845/orjson-3.11.7-cp312-cp312-win_amd64.whl", hash = "sha256:bf742e149121dc5648ba0a08ea0871e87b660467ef168a3a5e53bc1fbd64bb74", size = 125007, upload-time = "2026-02-02T15:38:04.032Z" },
    { url = "https://files.pythonhosted.org/packages/68/40/c2051bd19fc467610fed469dc29e43ac65891571138f476834ca192bc290/orjson-3.11.7-cp312-cp312-win_arm64.whl", hash = "sha256:26c3b9132f783b7d7903bf1efb095fed8d4a3a85ec0d334ee8beff3d7a4749d5", size = 126089, upload-time = "2026-02-02T15:38:05.297Z" },
    { url = "https://files.pythonhosted.org/packages/89/25/6e0e52cac5aab51d7b6dcd257e855e1dec1c2060f6b28566c509b4665f62/orjson-3.11.7-cp313-cp313-macosx_10_15_x86_64.macosx_11_0_arm64.macosx_10_15_universal2.whl", hash = "sha256:1d98b30cc1313d52d4af17d9c3d307b08389752ec5f2e5febdfada70b0f8c733", size = 228390, upload-time = "2026-02-02T15:38:06.8Z" },
    { url = "https://files.pythonhosted.org/packages/a5/29/a77f48d2fc8a05bbc529e5ff481fb43d914f9e383ea2469d4f3d51df3d00/orjson-3.11.7-cp313-cp313-macosx_15_0_arm64.whl", hash = "sha256:d897e81f8d0cbd2abb82226d1860ad2e1ab3ff16d7b08c96ca00df9d45409ef4", size = 125189, upload-time = "2026-02-02T15:38:08.181Z" },
    { url = "https://files.pythonhosted.org/packages/89/25/0a16e0729a0e6a1504f9d1a13cdd365f030068aab64cec6958396b9969d7/orjson-3.11.7-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:814be4b49b228cfc0b3c565acf642dd7d13538f966e3ccde61f4f55be3e20785", size = 128106, upload-time = "2026-02-02T15:38:09.41Z" },
    { url = "https://files.pythonhosted.org/packages/66/da/a2e505469d60666a05ab373f1a6322eb671cb2ba3a0ccfc7d4bc97196787/orjson-3.11.7-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:d06e5c5fed5caedd2e540d62e5b1c25e8c82431b9e577c33537e5fa4aa909539", size = 123363, upload-time = "2026-02-02T15:38:10.73Z" },
    { url = "https://files.pythonhosted.org/packages/23/bf/ed73f88396ea35c71b38961734ea4a4746f7ca0768bf28fd551d37e48dd0/orjson-3.11.7-cp313-cp313-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:31c80ce534ac4ea3739c5ee751270646cbc46e45aea7576a38ffec040b4029a1", size = 129007, upload-time = "2026-02-02T15:38:12.138Z" },
    { url = "https://files.pythonhosted.org/packages/73/3c/b05d80716f0225fc9008fbf8ab22841dcc268a626aa550561743714ce3bf/orjson-3.11.7-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:f50979824bde13d32b4320eedd513431c921102796d86be3eee0b58e58a3ecd1", size = 141667, upload-time = "2026-02-02T15:38:13.398Z" },
    { url = "https://files.pythonhosted.org/packages/61/e8/0be9b0addd9bf86abfc938e97441dcd0375d494594b1c8ad10fe57479617/orjson-3.11.7-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:9e54f3808e2b6b945078c41aa8d9b5834b28c50843846e97807e5adb75fa9705", size = 130832, upload-time = "2026-02-02T15:38:14.698Z" },
    { url = "https://files.pythonhosted.org/packages/c9/ec/c68e3b9021a31d9ec15a94931db1410136af862955854ed5dd7e7e4f5bff/orjson-3.11.7-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:a12b80df61aab7b98b490fe9e4879925ba666fccdfcd175252ce4d9035865ace", size = 133373, upload-time = "2026-02-02T15:38:16.109Z" },
    { url = "https://files.pythonhosted.org/packages/d2/45/f3466739aaafa570cc8e77c6dbb853c48bf56e3b43738020e2661e08b0ac/orjson-3.11.7-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:996b65230271f1a97026fd0e6a753f51fbc0c335d2ad0c6201f711b0da32693b", size = 138307, upload-time = "2026-02-02T15:38:17.453Z" },
    { url = "https://files.pythonhosted.org/packages/e1/84/9f7f02288da1ffb31405c1be07657afd1eecbcb4b64ee2817b6fe0f785fa/orjson-3.11.7-cp313-cp313-musllinux_1_2_armv7l.whl", hash = "sha256:ab49d4b2a6a1d415ddb9f37a21e02e0d5dbfe10b7870b21bf779fc21e9156157", size = 408695, upload-time = "2026-02-02T15:38:18.831Z" },
    { url = "https://files.pythonhosted.org/packages/18/07/9dd2f0c0104f1a0295ffbe912bc8d63307a539b900dd9e2c48ef7810d971/orjson-3.11.7-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:390a1dce0c055ddf8adb6aa94a73b45a4a7d7177b5c584b8d1c1947f2ba60fb3", size = 144099, upload-time = "2026-02-02T15:38:20.28Z" },
    { url = "https://files.pythonhosted.org/packages/a5/66/857a8e4a3292e1f7b1b202883bcdeb43a91566cf59a93f97c53b44bd6801/orjson-3.11.7-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:1eb80451a9c351a71dfaf5b7ccc13ad065405217726b59fdbeadbcc544f9d223", size = 134806, upload-time = "2026-02-02T15:38:22.186Z" },
    { url = "https://files.pythonhosted.org/packages/0a/5b/6ebcf3defc1aab3a338ca777214966851e92efb1f30dc7fc8285216e6d1b/orjson-3.11.7-cp313-cp313-win32.whl", hash = "sha256:7477aa6a6ec6139c5cb1cc7b214643592169a5494d200397c7fc95d740d5fcf3", size = 127914, upload-time = "2026-02-02T15:38:23.511Z" },
    { url = "https://files.pythonhosted.org/packages/00/04/c6f72daca5092e3117840a1b1e88dfc809cc1470cf0734890d0366b684a1/orjson-3.11.7-cp313-cp313-win_amd64.whl", hash = "sha256:b9f95dcdea9d4f805daa9ddf02617a89e484c6985fa03055459f90e87d7a0757", size = 124986, upload-time = "2026-02-02T15:38:24.836Z" },
    { url = "https://files.pythonhosted.org/packages/03/ba/077a0f6f1085d6b806937246860fafbd5b17f3919c70ee3f3d8d9c713f38/orjson-3.11.7-cp313-cp313-win_arm64.whl", hash = "sha256:800988273a014a0541483dc81021247d7eacb0c845a9d1a34a422bc718f41539", size = 126045, upload-time = "2026-02-02T15:38:26.216Z" },
]

[[package]]
name = "packaging"
version = "25.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a1/d4/1fc4078c65507b51b96ca8f8c3ba19e6a61c8253c72794544580a7b6c24d/packaging-25.0.tar.gz", hash = "sha256:d443872c98d677bf60f6a1f2f8c1cb748e8fe762d2bf9d3148b5599295b0fc4f", size = 165727, upload-time = "2025-04-19T11:48:59.673Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/20/12/38679034af332785aac8774540895e234f4d07f7545804097de4b666afd8/packaging-25.0-py3-none-any.whl", hash = "sha256:29572ef2b1f17581046b3a2227d5c611fb25ec70ca1ba8554b24b0e69331a484", size = 66469, upload-time = "2025-04-19T11:48:57.875Z" },
]

[[package]]
name = "pandas"
version = "2.2.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "numpy" },
    { name = "python-dateutil" },
    { name = "pytz" },
    { name = "tzdata" },
]
sdist = { url = "https://files.pythonhosted.org/packages/9c/d6/9f8431bacc2e19dca897724cd097b1bb224a6ad5433784a44b587c7c13af/pandas-2.2.3.tar.gz", hash = "sha256:4f18ba62b61d7e192368b84517265a99b4d7ee8912f8708660fb4a366cc82667", size = 4399213, upload-time = "2024-09-20T13:10:04.827Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a8/44/d9502bf0ed197ba9bf1103c9867d5904ddcaf869e52329787fc54ed70cc8/pandas-2.2.3-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:66108071e1b935240e74525006034333f98bcdb87ea116de573a6a0dccb6c039", size = 12602222, upload-time = "2024-09-20T13:08:56.254Z" },
    { url = "https://files.pythonhosted.org/packages/52/11/9eac327a38834f162b8250aab32a6781339c69afe7574368fffe46387edf/pandas-2.2.3-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:7c2875855b0ff77b2a64a0365e24455d9990730d6431b9e0ee18ad8acee13dbd", size = 11321274, upload-time = "2024-09-20T13:08:58.645Z" },
    { url = "https://files.pythonhosted.org/packages/45/fb/c4beeb084718598ba19aa9f5abbc8aed8b42f90930da861fcb1acdb54c3a/pandas-2.2.3-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:cd8d0c3be0515c12fed0bdbae072551c8b54b7192c7b1fda0ba56059a0179698", size = 15579836, upload-time = "2024-09-20T19:01:57.571Z" },
    { url = "https://files.pythonhosted.org/packages/cd/5f/4dba1d39bb9c38d574a9a22548c540177f78ea47b32f99c0ff2ec499fac5/pandas-2.2.3-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:c124333816c3a9b03fbeef3a9f230ba9a737e9e5bb4060aa2107a86cc0a497fc", size = 13058505, upload-time = "2024-09-20T13:09:01.501Z" },
    { url = "https://files.pythonhosted.org/packages/b9/57/708135b90391995361636634df1f1130d03ba456e95bcf576fada459115a/pandas-2.2.3-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:63cc132e40a2e084cf01adf0775b15ac515ba905d7dcca47e9a251819c575ef3", size = 16744420, upload-time = "2024-09-20T19:02:00.678Z" },
    { url = "https://files.pythonhosted.org/packages/86/4a/03ed6b7ee323cf30404265c284cee9c65c56a212e0a08d9ee06984ba2240/pandas-2.2.3-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:29401dbfa9ad77319367d36940cd8a0b3a11aba16063e39632d98b0e931ddf32", size = 14440457, upload-time = "2024-09-20T13:09:04.105Z" },
    { url = "https://files.pythonhosted.org/packages/ed/8c/87ddf1fcb55d11f9f847e3c69bb1c6f8e46e2f40ab1a2d2abadb2401b007/pandas-2.2.3-cp311-cp311-win_amd64.whl", hash = "sha256:3fc6873a41186404dad67245896a6e440baacc92f5b716ccd1bc9ed2995ab2c5", size = 11617166, upload-time = "2024-09-20T13:09:06.917Z" },
    { url = "https://files.pythonhosted.org/packages/17/a3/fb2734118db0af37ea7433f57f722c0a56687e14b14690edff0cdb4b7e58/pandas-2.2.3-cp312-cp312-macosx_10_9_x86_64.whl", hash = "sha256:b1d432e8d08679a40e2a6d8b2f9770a5c21793a6f9f47fdd52c5ce1948a5a8a9", size = 12529893, upload-time = "2024-09-20T13:09:09.655Z" },
    { url = "https://files.pythonhosted.org/packages/e1/0c/ad295fd74bfac85358fd579e271cded3ac969de81f62dd0142c426b9da91/pandas-2.2.3-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:a5a1595fe639f5988ba6a8e5bc9649af3baf26df3998a0abe56c02609392e0a4", size = 11363475, upload-time = "2024-09-20T13:09:14.718Z" },
    { url = "https://files.pythonhosted.org/packages/c6/2a/4bba3f03f7d07207481fed47f5b35f556c7441acddc368ec43d6643c5777/pandas-2.2.3-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:5de54125a92bb4d1c051c0659e6fcb75256bf799a732a87184e5ea503965bce3", size = 15188645, upload-time = "2024-09-20T19:02:03.88Z" },
    { url = "https://files.pythonhosted.org/packages/38/f8/d8fddee9ed0d0c0f4a2132c1dfcf0e3e53265055da8df952a53e7eaf178c/pandas-2.2.3-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:fffb8ae78d8af97f849404f21411c95062db1496aeb3e56f146f0355c9989319", size = 12739445, upload-time = "2024-09-20T13:09:17.621Z" },
    { url = "https://files.pythonhosted.org/packages/20/e8/45a05d9c39d2cea61ab175dbe6a2de1d05b679e8de2011da4ee190d7e748/pandas-2.2.3-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:6dfcb5ee8d4d50c06a51c2fffa6cff6272098ad6540aed1a76d15fb9318194d8", size = 16359235, upload-time = "2024-09-20T19:02:07.094Z" },
    { url = "https://files.pythonhosted.org/packages/1d/99/617d07a6a5e429ff90c90da64d428516605a1ec7d7bea494235e1c3882de/pandas-2.2.3-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:062309c1b9ea12a50e8ce661145c6aab431b1e99530d3cd60640e255778bd43a", size = 14056756, upload-time = "2024-09-20T13:09:20.474Z" },
    { url = "https://files.pythonhosted.org/packages/29/d4/1244ab8edf173a10fd601f7e13b9566c1b525c4f365d6bee918e68381889/pandas-2.2.3-cp312-cp312-win_amd64.whl", hash = "sha256:59ef3764d0fe818125a5097d2ae867ca3fa64df032331b7e0917cf5d7bf66b13", size = 11504248, upload-time = "2024-09-20T13:09:23.137Z" },
    { url = "https://files.pythonhosted.org/packages/64/22/3b8f4e0ed70644e85cfdcd57454686b9057c6c38d2f74fe4b8bc2527214a/pandas-2.2.3-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:f00d1345d84d8c86a63e476bb4955e46458b304b9575dcf71102b5c705320015", size = 12477643, upload-time = "2024-09-20T13:09:25.522Z" },
    { url = "https://files.pythonhosted.org/packages/e4/93/b3f5d1838500e22c8d793625da672f3eec046b1a99257666c94446969282/pandas-2.2.3-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:3508d914817e153ad359d7e069d752cdd736a247c322d932eb89e6bc84217f28", size = 11281573, upload-time = "2024-09-20T13:09:28.012Z" },
    { url = "https://files.pythonhosted.org/packages/f5/94/6c79b07f0e5aab1dcfa35a75f4817f5c4f677931d4234afcd75f0e6a66ca/pandas-2.2.3-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:22a9d949bfc9a502d320aa04e5d02feab689d61da4e7764b62c30b991c42c5f0", size = 15196085, upload-time = "2024-09-20T19:02:10.451Z" },
    { url = "https://files.pythonhosted.org/packages/e8/31/aa8da88ca0eadbabd0a639788a6da13bb2ff6edbbb9f29aa786450a30a91/pandas-2.2.3-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:f3a255b2c19987fbbe62a9dfd6cff7ff2aa9ccab3fc75218fd4b7530f01efa24", size = 12711809, upload-time = "2024-09-20T13:09:30.814Z" },
    { url = "https://files.pythonhosted.org/packages/ee/7c/c6dbdb0cb2a4344cacfb8de1c5808ca885b2e4dcfde8008266608f9372af/pandas-2.2.3-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:800250ecdadb6d9c78eae4990da62743b857b470883fa27f652db8bdde7f6659", size = 16356316, upload-time = "2024-09-20T19:02:13.825Z" },
    { url = "https://files.pythonhosted.org/packages/57/b7/8b757e7d92023b832869fa8881a992696a0bfe2e26f72c9ae9f255988d42/pandas-2.2.3-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:6374c452ff3ec675a8f46fd9ab25c4ad0ba590b71cf0656f8b6daa5202bca3fb", size = 14022055, upload-time = "2024-09-20T13:09:33.462Z" },
    { url = "https://files.pythonhosted.org/packages/3b/bc/4b18e2b8c002572c5a441a64826252ce5da2aa738855747247a971988043/pandas-2.2.3-cp313-cp313-win_amd64.whl", hash = "sha256:61c5ad4043f791b61dd4752191d9f07f0ae412515d59ba8f005832a532f8736d", size = 11481175, upload-time = "2024-09-20T13:09:35.871Z" },
    { url = "https://files.pythonhosted.org/packages/76/a3/a5d88146815e972d40d19247b2c162e88213ef51c7c25993942c39dbf41d/pandas-2.2.3-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:3b71f27954685ee685317063bf13c7709a7ba74fc996b84fc6821c59b0f06468", size = 12615650, upload-time = "2024-09-20T13:09:38.685Z" },
    { url = "https://files.pythonhosted.org/packages/9c/8c/f0fd18f6140ddafc0c24122c8a964e48294acc579d47def376fef12bcb4a/pandas-2.2.3-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:38cf8125c40dae9d5acc10fa66af8ea6fdf760b2714ee482ca691fc66e6fcb18", size = 11290177, upload-time = "2024-09-20T13:09:41.141Z" },
    { url = "https://files.pythonhosted.org/packages/ed/f9/e995754eab9c0f14c6777401f7eece0943840b7a9fc932221c19d1abee9f/pandas-2.2.3-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:ba96630bc17c875161df3818780af30e43be9b166ce51c9a18c1feae342906c2", size = 14651526, upload-time = "2024-09-20T19:02:16.905Z" },
    { url = "https://files.pythonhosted.org/packages/25/b0/98d6ae2e1abac4f35230aa756005e8654649d305df9a28b16b9ae4353bff/pandas-2.2.3-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:1db71525a1538b30142094edb9adc10be3f3e176748cd7acc2240c2f2e5aa3a4", size = 11871013, upload-time = "2024-09-20T13:09:44.39Z" },
    { url = "https://files.pythonhosted.org/packages/cc/57/0f72a10f9db6a4628744c8e8f0df4e6e21de01212c7c981d31e50ffc8328/pandas-2.2.3-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:15c0e1e02e93116177d29ff83e8b1619c93ddc9c49083f237d4312337a61165d", size = 15711620, upload-time = "2024-09-20T19:02:20.639Z" },
    { url = "https://files.pythonhosted.org/packages/ab/5f/b38085618b950b79d2d9164a711c52b10aefc0ae6833b96f626b7021b2ed/pandas-2.2.3-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:ad5b65698ab28ed8d7f18790a0dc58005c7629f227be9ecc1072aa74c0c1d43a", size = 13098436, upload-time = "2024-09-20T13:09:48.112Z" },
]

[[package]]
name = "pathspec"
version = "0.12.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ca/bc/f35b8446f4531a7cb215605d100cd88b7ac6f44ab3fc94870c120ab3adbf/pathspec-0.12.1.tar.gz", hash = "sha256:a482d51503a1ab33b1c67a6c3813a26953dbdc71c31dacaef9a838c4e29f5712", size = 51043, upload-time = "2023-12-10T22:30:45Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/cc/20/ff623b09d963f88bfde16306a54e12ee5ea43e9b597108672ff3a408aad6/pathspec-0.12.1-py3-none-any.whl", hash = "sha256:a0d503e138a4c123b27490a4f7beda6a01c6f288df0e4a8b79c7eb0dc7b4cc08", size = 31191, upload-time = "2023-12-10T22:30:43.14Z" },
]

[[package]]
name = "pillow"
version = "12.1.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/1f/42/5c74462b4fd957fcd7b13b04fb3205ff8349236ea74c7c375766d6c82288/pillow-12.1.1.tar.gz", hash = "sha256:9ad8fa5937ab05218e2b6a4cff30295ad35afd2f83ac592e68c0d871bb0fdbc4", size = 46980264, upload-time = "2026-02-11T04:23:07.146Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2b/46/5da1ec4a5171ee7bf1a0efa064aba70ba3d6e0788ce3f5acd1375d23c8c0/pillow-12.1.1-cp311-cp311-macosx_10_10_x86_64.whl", hash = "sha256:e879bb6cd5c73848ef3b2b48b8af9ff08c5b71ecda8048b7dd22d8a33f60be32", size = 5304084, upload-time = "2026-02-11T04:20:27.501Z" },
    { url = "https://files.pythonhosted.org/packages/78/93/a29e9bc02d1cf557a834da780ceccd54e02421627200696fcf805ebdc3fb/pillow-12.1.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:365b10bb9417dd4498c0e3b128018c4a624dc11c7b97d8cc54effe3b096f4c38", size = 4657866, upload-time = "2026-02-11T04:20:29.827Z" },
    { url = "https://files.pythonhosted.org/packages/13/84/583a4558d492a179d31e4aae32eadce94b9acf49c0337c4ce0b70e0a01f2/pillow-12.1.1-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:d4ce8e329c93845720cd2014659ca67eac35f6433fd3050393d85f3ecef0dad5", size = 6232148, upload-time = "2026-02-11T04:20:31.329Z" },
    { url = "https://files.pythonhosted.org/packages/d5/e2/53c43334bbbb2d3b938978532fbda8e62bb6e0b23a26ce8592f36bcc4987/pillow-12.1.1-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:fc354a04072b765eccf2204f588a7a532c9511e8b9c7f900e1b64e3e33487090", size = 8038007, upload-time = "2026-02-11T04:20:34.225Z" },
    { url = "https://files.pythonhosted.org/packages/b8/a6/3d0e79c8a9d58150dd98e199d7c1c56861027f3829a3a60b3c2784190180/pillow-12.1.1-cp311-cp311-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:7e7976bf1910a8116b523b9f9f58bf410f3e8aa330cd9a2bb2953f9266ab49af", size = 6345418, upload-time = "2026-02-11T04:20:35.858Z" },
    { url = "https://files.pythonhosted.org/packages/a2/c8/46dfeac5825e600579157eea177be43e2f7ff4a99da9d0d0a49533509ac5/pillow-12.1.1-cp311-cp311-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:597bd9c8419bc7c6af5604e55847789b69123bbe25d65cc6ad3012b4f3c98d8b", size = 7034590, upload-time = "2026-02-11T04:20:37.91Z" },
    { url = "https://files.pythonhosted.org/packages/af/bf/e6f65d3db8a8bbfeaf9e13cc0417813f6319863a73de934f14b2229ada18/pillow-12.1.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:2c1fc0f2ca5f96a3c8407e41cca26a16e46b21060fe6d5b099d2cb01412222f5", size = 6458655, upload-time = "2026-02-11T04:20:39.496Z" },
    { url = "https://files.pythonhosted.org/packages/f9/c2/66091f3f34a25894ca129362e510b956ef26f8fb67a0e6417bc5744e56f1/pillow-12.1.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:578510d88c6229d735855e1f278aa305270438d36a05031dfaae5067cc8eb04d", size = 7159286, upload-time = "2026-02-11T04:20:41.139Z" },
    { url = "https://files.pythonhosted.org/packages/7b/5a/24bc8eb526a22f957d0cec6243146744966d40857e3d8deb68f7902ca6c1/pillow-12.1.1-cp311-cp311-win32.whl", hash = "sha256:7311c0a0dcadb89b36b7025dfd8326ecfa36964e29913074d47382706e516a7c", size = 6328663, upload-time = "2026-02-11T04:20:43.184Z" },
    { url = "https://files.pythonhosted.org/packages/31/03/bef822e4f2d8f9d7448c133d0a18185d3cce3e70472774fffefe8b0ed562/pillow-12.1.1-cp311-cp311-win_amd64.whl", hash = "sha256:fbfa2a7c10cc2623f412753cddf391c7f971c52ca40a3f65dc5039b2939e8563", size = 7031448, upload-time = "2026-02-11T04:20:44.696Z" },
    { url = "https://files.pythonhosted.org/packages/49/70/f76296f53610bd17b2e7d31728b8b7825e3ac3b5b3688b51f52eab7c0818/pillow-12.1.1-cp311-cp311-win_arm64.whl", hash = "sha256:b81b5e3511211631b3f672a595e3221252c90af017e399056d0faabb9538aa80", size = 2453651, upload-time = "2026-02-11T04:20:46.243Z" },
    { url = "https://files.pythonhosted.org/packages/07/d3/8df65da0d4df36b094351dce696f2989bec731d4f10e743b1c5f4da4d3bf/pillow-12.1.1-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:ab323b787d6e18b3d91a72fc99b1a2c28651e4358749842b8f8dfacd28ef2052", size = 5262803, upload-time = "2026-02-11T04:20:47.653Z" },
    { url = "https://files.pythonhosted.org/packages/d6/71/5026395b290ff404b836e636f51d7297e6c83beceaa87c592718747e670f/pillow-12.1.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:adebb5bee0f0af4909c30db0d890c773d1a92ffe83da908e2e9e720f8edf3984", size = 4657601, upload-time = "2026-02-11T04:20:49.328Z" },
    { url = "https://files.pythonhosted.org/packages/b1/2e/1001613d941c67442f745aff0f7cc66dd8df9a9c084eb497e6a543ee6f7e/pillow-12.1.1-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:bb66b7cc26f50977108790e2456b7921e773f23db5630261102233eb355a3b79", size = 6234995, upload-time = "2026-02-11T04:20:51.032Z" },
    { url = "https://files.pythonhosted.org/packages/07/26/246ab11455b2549b9233dbd44d358d033a2f780fa9007b61a913c5b2d24e/pillow-12.1.1-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:aee2810642b2898bb187ced9b349e95d2a7272930796e022efaf12e99dccd293", size = 8045012, upload-time = "2026-02-11T04:20:52.882Z" },
    { url = "https://files.pythonhosted.org/packages/b2/8b/07587069c27be7535ac1fe33874e32de118fbd34e2a73b7f83436a88368c/pillow-12.1.1-cp312-cp312-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:a0b1cd6232e2b618adcc54d9882e4e662a089d5768cd188f7c245b4c8c44a397", size = 6349638, upload-time = "2026-02-11T04:20:54.444Z" },
    { url = "https://files.pythonhosted.org/packages/ff/79/6df7b2ee763d619cda2fb4fea498e5f79d984dae304d45a8999b80d6cf5c/pillow-12.1.1-cp312-cp312-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:7aac39bcf8d4770d089588a2e1dd111cbaa42df5a94be3114222057d68336bd0", size = 7041540, upload-time = "2026-02-11T04:20:55.97Z" },
    { url = "https://files.pythonhosted.org/packages/2c/5e/2ba19e7e7236d7529f4d873bdaf317a318896bac289abebd4bb00ef247f0/pillow-12.1.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:ab174cd7d29a62dd139c44bf74b698039328f45cb03b4596c43473a46656b2f3", size = 6462613, upload-time = "2026-02-11T04:20:57.542Z" },
    { url = "https://files.pythonhosted.org/packages/03/03/31216ec124bb5c3dacd74ce8efff4cc7f52643653bad4825f8f08c697743/pillow-12.1.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:339ffdcb7cbeaa08221cd401d517d4b1fe7a9ed5d400e4a8039719238620ca35", size = 7166745, upload-time = "2026-02-11T04:20:59.196Z" },
    { url = "https://files.pythonhosted.org/packages/1f/e7/7c4552d80052337eb28653b617eafdef39adfb137c49dd7e831b8dc13bc5/pillow-12.1.1-cp312-cp312-win32.whl", hash = "sha256:5d1f9575a12bed9e9eedd9a4972834b08c97a352bd17955ccdebfeca5913fa0a", size = 6328823, upload-time = "2026-02-11T04:21:01.385Z" },
    { url = "https://files.pythonhosted.org/packages/3d/17/688626d192d7261bbbf98846fc98995726bddc2c945344b65bec3a29d731/pillow-12.1.1-cp312-cp312-win_amd64.whl", hash = "sha256:21329ec8c96c6e979cd0dfd29406c40c1d52521a90544463057d2aaa937d66a6", size = 7033367, upload-time = "2026-02-11T04:21:03.536Z" },
    { url = "https://files.pythonhosted.org/packages/ed/fe/a0ef1f73f939b0eca03ee2c108d0043a87468664770612602c63266a43c4/pillow-12.1.1-cp312-cp312-win_arm64.whl", hash = "sha256:af9a332e572978f0218686636610555ae3defd1633597be015ed50289a03c523", size = 2453811, upload-time = "2026-02-11T04:21:05.116Z" },
    { url = "https://files.pythonhosted.org/packages/d5/11/6db24d4bd7685583caeae54b7009584e38da3c3d4488ed4cd25b439de486/pillow-12.1.1-cp313-cp313-ios_13_0_arm64_iphoneos.whl", hash = "sha256:d242e8ac078781f1de88bf823d70c1a9b3c7950a44cdf4b7c012e22ccbcd8e4e", size = 4062689, upload-time = "2026-02-11T04:21:06.804Z" },
    { url = "https://files.pythonhosted.org/packages/33/c0/ce6d3b1fe190f0021203e0d9b5b99e57843e345f15f9ef22fcd43842fd21/pillow-12.1.1-cp313-cp313-ios_13_0_arm64_iphonesimulator.whl", hash = "sha256:02f84dfad02693676692746df05b89cf25597560db2857363a208e393429f5e9", size = 4138535, upload-time = "2026-02-11T04:21:08.452Z" },
    { url = "https://files.pythonhosted.org/packages/a0/c6/d5eb6a4fb32a3f9c21a8c7613ec706534ea1cf9f4b3663e99f0d83f6fca8/pillow-12.1.1-cp313-cp313-ios_13_0_x86_64_iphonesimulator.whl", hash = "sha256:e65498daf4b583091ccbb2556c7000abf0f3349fcd57ef7adc9a84a394ed29f6", size = 3601364, upload-time = "2026-02-11T04:21:10.194Z" },
    { url = "https://files.pythonhosted.org/packages/14/a1/16c4b823838ba4c9c52c0e6bbda903a3fe5a1bdbf1b8eb4fff7156f3e318/pillow-12.1.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:6c6db3b84c87d48d0088943bf33440e0c42370b99b1c2a7989216f7b42eede60", size = 5262561, upload-time = "2026-02-11T04:21:11.742Z" },
    { url = "https://files.pythonhosted.org/packages/bb/ad/ad9dc98ff24f485008aa5cdedaf1a219876f6f6c42a4626c08bc4e80b120/pillow-12.1.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:8b7e5304e34942bf62e15184219a7b5ad4ff7f3bb5cca4d984f37df1a0e1aee2", size = 4657460, upload-time = "2026-02-11T04:21:13.786Z" },
    { url = "https://files.pythonhosted.org/packages/9e/1b/f1a4ea9a895b5732152789326202a82464d5254759fbacae4deea3069334/pillow-12.1.1-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:18e5bddd742a44b7e6b1e773ab5db102bd7a94c32555ba656e76d319d19c3850", size = 6232698, upload-time = "2026-02-11T04:21:15.949Z" },
    { url = "https://files.pythonhosted.org/packages/95/f4/86f51b8745070daf21fd2e5b1fe0eb35d4db9ca26e6d58366562fb56a743/pillow-12.1.1-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:fc44ef1f3de4f45b50ccf9136999d71abb99dca7706bc75d222ed350b9fd2289", size = 8041706, upload-time = "2026-02-11T04:21:17.723Z" },
    { url = "https://files.pythonhosted.org/packages/29/9b/d6ecd956bb1266dd1045e995cce9b8d77759e740953a1c9aad9502a0461e/pillow-12.1.1-cp313-cp313-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:5a8eb7ed8d4198bccbd07058416eeec51686b498e784eda166395a23eb99138e", size = 6346621, upload-time = "2026-02-11T04:21:19.547Z" },
    { url = "https://files.pythonhosted.org/packages/71/24/538bff45bde96535d7d998c6fed1a751c75ac7c53c37c90dc2601b243893/pillow-12.1.1-cp313-cp313-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:47b94983da0c642de92ced1702c5b6c292a84bd3a8e1d1702ff923f183594717", size = 7038069, upload-time = "2026-02-11T04:21:21.378Z" },
    { url = "https://files.pythonhosted.org/packages/94/0e/58cb1a6bc48f746bc4cb3adb8cabff73e2742c92b3bf7a220b7cf69b9177/pillow-12.1.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:518a48c2aab7ce596d3bf79d0e275661b846e86e4d0e7dec34712c30fe07f02a", size = 6460040, upload-time = "2026-02-11T04:21:23.148Z" },
    { url = "https://files.pythonhosted.org/packages/6c/57/9045cb3ff11eeb6c1adce3b2d60d7d299d7b273a2e6c8381a524abfdc474/pillow-12.1.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:a550ae29b95c6dc13cf69e2c9dc5747f814c54eeb2e32d683e5e93af56caa029", size = 7164523, upload-time = "2026-02-11T04:21:25.01Z" },
    { url = "https://files.pythonhosted.org/packages/73/f2/9be9cb99f2175f0d4dbadd6616ce1bf068ee54a28277ea1bf1fbf729c250/pillow-12.1.1-cp313-cp313-win32.whl", hash = "sha256:a003d7422449f6d1e3a34e3dd4110c22148336918ddbfc6a32581cd54b2e0b2b", size = 6332552, upload-time = "2026-02-11T04:21:27.238Z" },
    { url = "https://files.pythonhosted.org/packages/3f/eb/b0834ad8b583d7d9d42b80becff092082a1c3c156bb582590fcc973f1c7c/pillow-12.1.1-cp313-cp313-win_amd64.whl", hash = "sha256:344cf1e3dab3be4b1fa08e449323d98a2a3f819ad20f4b22e77a0ede31f0faa1", size = 7040108, upload-time = "2026-02-11T04:21:29.462Z" },
    { url = "https://files.pythonhosted.org/packages/d5/7d/fc09634e2aabdd0feabaff4a32f4a7d97789223e7c2042fd805ea4b4d2c2/pillow-12.1.1-cp313-cp313-win_arm64.whl", hash = "sha256:5c0dd1636633e7e6a0afe7bf6a51a14992b7f8e60de5789018ebbdfae55b040a", size = 2453712, upload-time = "2026-02-11T04:21:31.072Z" },
    { url = "https://files.pythonhosted.org/packages/19/2a/b9d62794fc8a0dd14c1943df68347badbd5511103e0d04c035ffe5cf2255/pillow-12.1.1-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:0330d233c1a0ead844fc097a7d16c0abff4c12e856c0b325f231820fee1f39da", size = 5264880, upload-time = "2026-02-11T04:21:32.865Z" },
    { url = "https://files.pythonhosted.org/packages/26/9d/e03d857d1347fa5ed9247e123fcd2a97b6220e15e9cb73ca0a8d91702c6e/pillow-12.1.1-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:5dae5f21afb91322f2ff791895ddd8889e5e947ff59f71b46041c8ce6db790bc", size = 4660616, upload-time = "2026-02-11T04:21:34.97Z" },
    { url = "https://files.pythonhosted.org/packages/f7/ec/8a6d22afd02570d30954e043f09c32772bfe143ba9285e2fdb11284952cd/pillow-12.1.1-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:2e0c664be47252947d870ac0d327fea7e63985a08794758aa8af5b6cb6ec0c9c", size = 6269008, upload-time = "2026-02-11T04:21:36.623Z" },
    { url = "https://files.pythonhosted.org/packages/3d/1d/6d875422c9f28a4a361f495a5f68d9de4a66941dc2c619103ca335fa6446/pillow-12.1.1-cp313-cp313t-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:691ab2ac363b8217f7d31b3497108fb1f50faab2f75dfb03284ec2f217e87bf8", size = 8073226, upload-time = "2026-02-11T04:21:38.585Z" },
    { url = "https://files.pythonhosted.org/packages/a1/cd/134b0b6ee5eda6dc09e25e24b40fdafe11a520bc725c1d0bbaa5e00bf95b/pillow-12.1.1-cp313-cp313t-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:e9e8064fb1cc019296958595f6db671fba95209e3ceb0c4734c9baf97de04b20", size = 6380136, upload-time = "2026-02-11T04:21:40.562Z" },
    { url = "https://files.pythonhosted.org/packages/7a/a9/7628f013f18f001c1b98d8fffe3452f306a70dc6aba7d931019e0492f45e/pillow-12.1.1-cp313-cp313t-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:472a8d7ded663e6162dafdf20015c486a7009483ca671cece7a9279b512fcb13", size = 7067129, upload-time = "2026-02-11T04:21:42.521Z" },
    { url = "https://files.pythonhosted.org/packages/1e/f8/66ab30a2193b277785601e82ee2d49f68ea575d9637e5e234faaa98efa4c/pillow-12.1.1-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:89b54027a766529136a06cfebeecb3a04900397a3590fd252160b888479517bf", size = 6491807, upload-time = "2026-02-11T04:21:44.22Z" },
    { url = "https://files.pythonhosted.org/packages/da/0b/a877a6627dc8318fdb84e357c5e1a758c0941ab1ddffdafd231983788579/pillow-12.1.1-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:86172b0831b82ce4f7877f280055892b31179e1576aa00d0df3bb1bbf8c3e524", size = 7190954, upload-time = "2026-02-11T04:21:46.114Z" },
    { url = "https://files.pythonhosted.org/packages/83/43/6f732ff85743cf746b1361b91665d9f5155e1483817f693f8d57ea93147f/pillow-12.1.1-cp313-cp313t-win32.whl", hash = "sha256:44ce27545b6efcf0fdbdceb31c9a5bdea9333e664cda58a7e674bb74608b3986", size = 6336441, upload-time = "2026-02-11T04:21:48.22Z" },
    { url = "https://files.pythonhosted.org/packages/3b/44/e865ef3986611bb75bfabdf94a590016ea327833f434558801122979cd0e/pillow-12.1.1-cp313-cp313t-win_amd64.whl", hash = "sha256:a285e3eb7a5a45a2ff504e31f4a8d1b12ef62e84e5411c6804a42197c1cf586c", size = 7045383, upload-time = "2026-02-11T04:21:50.015Z" },
    { url = "https://files.pythonhosted.org/packages/a8/c6/f4fb24268d0c6908b9f04143697ea18b0379490cb74ba9e8d41b898bd005/pillow-12.1.1-cp313-cp313t-win_arm64.whl", hash = "sha256:cc7d296b5ea4d29e6570dabeaed58d31c3fea35a633a69679fb03d7664f43fb3", size = 2456104, upload-time = "2026-02-11T04:21:51.633Z" },
    { url = "https://files.pythonhosted.org/packages/56/11/5d43209aa4cb58e0cc80127956ff1796a68b928e6324bbf06ef4db34367b/pillow-12.1.1-pp311-pypy311_pp73-macosx_10_15_x86_64.whl", hash = "sha256:600fd103672b925fe62ed08e0d874ea34d692474df6f4bf7ebe148b30f89f39f", size = 5228606, upload-time = "2026-02-11T04:22:52.106Z" },
    { url = "https://files.pythonhosted.org/packages/5f/d5/3b005b4e4fda6698b371fa6c21b097d4707585d7db99e98d9b0b87ac612a/pillow-12.1.1-pp311-pypy311_pp73-macosx_11_0_arm64.whl", hash = "sha256:665e1b916b043cef294bc54d47bf02d87e13f769bc4bc5fa225a24b3a6c5aca9", size = 4622321, upload-time = "2026-02-11T04:22:53.827Z" },
    { url = "https://files.pythonhosted.org/packages/df/36/ed3ea2d594356fd8037e5a01f6156c74bc8d92dbb0fa60746cc96cabb6e8/pillow-12.1.1-pp311-pypy311_pp73-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:495c302af3aad1ca67420ddd5c7bd480c8867ad173528767d906428057a11f0e", size = 5247579, upload-time = "2026-02-11T04:22:56.094Z" },
    { url = "https://files.pythonhosted.org/packages/54/9a/9cc3e029683cf6d20ae5085da0dafc63148e3252c2f13328e553aaa13cfb/pillow-12.1.1-pp311-pypy311_pp73-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:8fd420ef0c52c88b5a035a0886f367748c72147b2b8f384c9d12656678dfdfa9", size = 6989094, upload-time = "2026-02-11T04:22:58.288Z" },
    { url = "https://files.pythonhosted.org/packages/00/98/fc53ab36da80b88df0967896b6c4b4cd948a0dc5aa40a754266aa3ae48b3/pillow-12.1.1-pp311-pypy311_pp73-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:f975aa7ef9684ce7e2c18a3aa8f8e2106ce1e46b94ab713d156b2898811651d3", size = 5313850, upload-time = "2026-02-11T04:23:00.554Z" },
    { url = "https://files.pythonhosted.org/packages/30/02/00fa585abfd9fe9d73e5f6e554dc36cc2b842898cbfc46d70353dae227f8/pillow-12.1.1-pp311-pypy311_pp73-manylinux_2_27_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:8089c852a56c2966cf18835db62d9b34fef7ba74c726ad943928d494fa7f4735", size = 5963343, upload-time = "2026-02-11T04:23:02.934Z" },
    { url = "https://files.pythonhosted.org/packages/f2/26/c56ce33ca856e358d27fda9676c055395abddb82c35ac0f593877ed4562e/pillow-12.1.1-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:cb9bb857b2d057c6dfc72ac5f3b44836924ba15721882ef103cecb40d002d80e", size = 7029880, upload-time = "2026-02-11T04:23:04.783Z" },
]

[[package]]
name = "platformdirs"
version = "4.5.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/61/33/9611380c2bdb1225fdef633e2a9610622310fed35ab11dac9620972ee088/platformdirs-4.5.0.tar.gz", hash = "sha256:70ddccdd7c99fc5942e9fc25636a8b34d04c24b335100223152c2803e4063312", size = 21632, upload-time = "2025-10-08T17:44:48.791Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/73/cb/ac7874b3e5d58441674fb70742e6c374b28b0c7cb988d37d991cde47166c/platformdirs-4.5.0-py3-none-any.whl", hash = "sha256:e578a81bb873cbb89a41fcc904c7ef523cc18284b7e3b3ccf06aca1403b7ebd3", size = 18651, upload-time = "2025-10-08T17:44:47.223Z" },
]

[[package]]
name = "ply"
version = "3.11"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e5/69/882ee5c9d017149285cab114ebeab373308ef0f874fcdac9beb90e0ac4da/ply-3.11.tar.gz", hash = "sha256:00c7c1aaa88358b9c765b6d3000c6eec0ba42abca5351b095321aef446081da3", size = 159130, upload-time = "2018-02-15T19:01:31.097Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a3/58/35da89ee790598a0700ea49b2a66594140f44dec458c07e8e3d4979137fc/ply-3.11-py2.py3-none-any.whl", hash = "sha256:096f9b8350b65ebd2fd1346b12452efe5b9607f7482813ffca50c22722a807ce", size = 49567, upload-time = "2018-02-15T19:01:27.172Z" },
]

[[package]]
name = "posthog"
version = "6.8.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "backoff" },
    { name = "distro" },
    { name = "python-dateutil" },
    { name = "requests" },
    { name = "six" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/6a/26/fbd8a29d094c1b3df109b79f7165ddb20dc37ec1e5b55717585de9ee9b65/posthog-6.8.0.tar.gz", hash = "sha256:40bc3bffe4818d37de63a4f4f13d2e90a78efe14f0d808c962f0ffebc3b15256", size = 122781, upload-time = "2025-11-04T19:43:34.651Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/bb/9a/970fe48b888c53de5768f67524444c2adf2ea86fba97a672434deb8db971/posthog-6.8.0-py3-none-any.whl", hash = "sha256:b30b3cb06234d9177cecabe6f3e04e34e1e15fe7b60428771a67be57920a6308", size = 141210, upload-time = "2025-11-04T19:43:33.375Z" },
]

[[package]]
name = "prometheus-client"
version = "0.23.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/23/53/3edb5d68ecf6b38fcbcc1ad28391117d2a322d9a1a3eff04bfdb184d8c3b/prometheus_client-0.23.1.tar.gz", hash = "sha256:6ae8f9081eaaaf153a2e959d2e6c4f4fb57b12ef76c8c7980202f1e57b48b2ce", size = 80481, upload-time = "2025-09-18T20:47:25.043Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b8/db/14bafcb4af2139e046d03fd00dea7873e48eafe18b7d2797e73d6681f210/prometheus_client-0.23.1-py3-none-any.whl", hash = "sha256:dd1913e6e76b59cfe44e7a4b83e01afc9873c1bdfd2ed8739f1e76aeca115f99", size = 61145, upload-time = "2025-09-18T20:47:23.875Z" },
]

[[package]]
name = "propcache"
version = "0.4.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/9e/da/e9fc233cf63743258bff22b3dfa7ea5baef7b5bc324af47a0ad89b8ffc6f/propcache-0.4.1.tar.gz", hash = "sha256:f48107a8c637e80362555f37ecf49abe20370e557cc4ab374f04ec4423c97c3d", size = 46442, upload-time = "2025-10-08T19:49:02.291Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8c/d4/4e2c9aaf7ac2242b9358f98dccd8f90f2605402f5afeff6c578682c2c491/propcache-0.4.1-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:60a8fda9644b7dfd5dece8c61d8a85e271cb958075bfc4e01083c148b61a7caf", size = 80208, upload-time = "2025-10-08T19:46:24.597Z" },
    { url = "https://files.pythonhosted.org/packages/c2/21/d7b68e911f9c8e18e4ae43bdbc1e1e9bbd971f8866eb81608947b6f585ff/propcache-0.4.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:c30b53e7e6bda1d547cabb47c825f3843a0a1a42b0496087bb58d8fedf9f41b5", size = 45777, upload-time = "2025-10-08T19:46:25.733Z" },
    { url = "https://files.pythonhosted.org/packages/d3/1d/11605e99ac8ea9435651ee71ab4cb4bf03f0949586246476a25aadfec54a/propcache-0.4.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:6918ecbd897443087a3b7cd978d56546a812517dcaaca51b49526720571fa93e", size = 47647, upload-time = "2025-10-08T19:46:27.304Z" },
    { url = "https://files.pythonhosted.org/packages/58/1a/3c62c127a8466c9c843bccb503d40a273e5cc69838805f322e2826509e0d/propcache-0.4.1-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:3d902a36df4e5989763425a8ab9e98cd8ad5c52c823b34ee7ef307fd50582566", size = 214929, upload-time = "2025-10-08T19:46:28.62Z" },
    { url = "https://files.pythonhosted.org/packages/56/b9/8fa98f850960b367c4b8fe0592e7fc341daa7a9462e925228f10a60cf74f/propcache-0.4.1-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:a9695397f85973bb40427dedddf70d8dc4a44b22f1650dd4af9eedf443d45165", size = 221778, upload-time = "2025-10-08T19:46:30.358Z" },
    { url = "https://files.pythonhosted.org/packages/46/a6/0ab4f660eb59649d14b3d3d65c439421cf2f87fe5dd68591cbe3c1e78a89/propcache-0.4.1-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:2bb07ffd7eaad486576430c89f9b215f9e4be68c4866a96e97db9e97fead85dc", size = 228144, upload-time = "2025-10-08T19:46:32.607Z" },
    { url = "https://files.pythonhosted.org/packages/52/6a/57f43e054fb3d3a56ac9fc532bc684fc6169a26c75c353e65425b3e56eef/propcache-0.4.1-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:fd6f30fdcf9ae2a70abd34da54f18da086160e4d7d9251f81f3da0ff84fc5a48", size = 210030, upload-time = "2025-10-08T19:46:33.969Z" },
    { url = "https://files.pythonhosted.org/packages/40/e2/27e6feebb5f6b8408fa29f5efbb765cd54c153ac77314d27e457a3e993b7/propcache-0.4.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:fc38cba02d1acba4e2869eef1a57a43dfbd3d49a59bf90dda7444ec2be6a5570", size = 208252, upload-time = "2025-10-08T19:46:35.309Z" },
    { url = "https://files.pythonhosted.org/packages/9e/f8/91c27b22ccda1dbc7967f921c42825564fa5336a01ecd72eb78a9f4f53c2/propcache-0.4.1-cp311-cp311-musllinux_1_2_armv7l.whl", hash = "sha256:67fad6162281e80e882fb3ec355398cf72864a54069d060321f6cd0ade95fe85", size = 202064, upload-time = "2025-10-08T19:46:36.993Z" },
    { url = "https://files.pythonhosted.org/packages/f2/26/7f00bd6bd1adba5aafe5f4a66390f243acab58eab24ff1a08bebb2ef9d40/propcache-0.4.1-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:f10207adf04d08bec185bae14d9606a1444715bc99180f9331c9c02093e1959e", size = 212429, upload-time = "2025-10-08T19:46:38.398Z" },
    { url = "https://files.pythonhosted.org/packages/84/89/fd108ba7815c1117ddca79c228f3f8a15fc82a73bca8b142eb5de13b2785/propcache-0.4.1-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:e9b0d8d0845bbc4cfcdcbcdbf5086886bc8157aa963c31c777ceff7846c77757", size = 216727, upload-time = "2025-10-08T19:46:39.732Z" },
    { url = "https://files.pythonhosted.org/packages/79/37/3ec3f7e3173e73f1d600495d8b545b53802cbf35506e5732dd8578db3724/propcache-0.4.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:981333cb2f4c1896a12f4ab92a9cc8f09ea664e9b7dbdc4eff74627af3a11c0f", size = 205097, upload-time = "2025-10-08T19:46:41.025Z" },
    { url = "https://files.pythonhosted.org/packages/61/b0/b2631c19793f869d35f47d5a3a56fb19e9160d3c119f15ac7344fc3ccae7/propcache-0.4.1-cp311-cp311-win32.whl", hash = "sha256:f1d2f90aeec838a52f1c1a32fe9a619fefd5e411721a9117fbf82aea638fe8a1", size = 38084, upload-time = "2025-10-08T19:46:42.693Z" },
    { url = "https://files.pythonhosted.org/packages/f4/78/6cce448e2098e9f3bfc91bb877f06aa24b6ccace872e39c53b2f707c4648/propcache-0.4.1-cp311-cp311-win_amd64.whl", hash = "sha256:364426a62660f3f699949ac8c621aad6977be7126c5807ce48c0aeb8e7333ea6", size = 41637, upload-time = "2025-10-08T19:46:43.778Z" },
    { url = "https://files.pythonhosted.org/packages/9c/e9/754f180cccd7f51a39913782c74717c581b9cc8177ad0e949f4d51812383/propcache-0.4.1-cp311-cp311-win_arm64.whl", hash = "sha256:e53f3a38d3510c11953f3e6a33f205c6d1b001129f972805ca9b42fc308bc239", size = 38064, upload-time = "2025-10-08T19:46:44.872Z" },
    { url = "https://files.pythonhosted.org/packages/a2/0f/f17b1b2b221d5ca28b4b876e8bb046ac40466513960646bda8e1853cdfa2/propcache-0.4.1-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:e153e9cd40cc8945138822807139367f256f89c6810c2634a4f6902b52d3b4e2", size = 80061, upload-time = "2025-10-08T19:46:46.075Z" },
    { url = "https://files.pythonhosted.org/packages/76/47/8ccf75935f51448ba9a16a71b783eb7ef6b9ee60f5d14c7f8a8a79fbeed7/propcache-0.4.1-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:cd547953428f7abb73c5ad82cbb32109566204260d98e41e5dfdc682eb7f8403", size = 46037, upload-time = "2025-10-08T19:46:47.23Z" },
    { url = "https://files.pythonhosted.org/packages/0a/b6/5c9a0e42df4d00bfb4a3cbbe5cf9f54260300c88a0e9af1f47ca5ce17ac0/propcache-0.4.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:f048da1b4f243fc44f205dfd320933a951b8d89e0afd4c7cacc762a8b9165207", size = 47324, upload-time = "2025-10-08T19:46:48.384Z" },
    { url = "https://files.pythonhosted.org/packages/9e/d3/6c7ee328b39a81ee877c962469f1e795f9db87f925251efeb0545e0020d0/propcache-0.4.1-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:ec17c65562a827bba85e3872ead335f95405ea1674860d96483a02f5c698fa72", size = 225505, upload-time = "2025-10-08T19:46:50.055Z" },
    { url = "https://files.pythonhosted.org/packages/01/5d/1c53f4563490b1d06a684742cc6076ef944bc6457df6051b7d1a877c057b/propcache-0.4.1-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:405aac25c6394ef275dee4c709be43745d36674b223ba4eb7144bf4d691b7367", size = 230242, upload-time = "2025-10-08T19:46:51.815Z" },
    { url = "https://files.pythonhosted.org/packages/20/e1/ce4620633b0e2422207c3cb774a0ee61cac13abc6217763a7b9e2e3f4a12/propcache-0.4.1-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:0013cb6f8dde4b2a2f66903b8ba740bdfe378c943c4377a200551ceb27f379e4", size = 238474, upload-time = "2025-10-08T19:46:53.208Z" },
    { url = "https://files.pythonhosted.org/packages/46/4b/3aae6835b8e5f44ea6a68348ad90f78134047b503765087be2f9912140ea/propcache-0.4.1-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:15932ab57837c3368b024473a525e25d316d8353016e7cc0e5ba9eb343fbb1cf", size = 221575, upload-time = "2025-10-08T19:46:54.511Z" },
    { url = "https://files.pythonhosted.org/packages/6e/a5/8a5e8678bcc9d3a1a15b9a29165640d64762d424a16af543f00629c87338/propcache-0.4.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:031dce78b9dc099f4c29785d9cf5577a3faf9ebf74ecbd3c856a7b92768c3df3", size = 216736, upload-time = "2025-10-08T19:46:56.212Z" },
    { url = "https://files.pythonhosted.org/packages/f1/63/b7b215eddeac83ca1c6b934f89d09a625aa9ee4ba158338854c87210cc36/propcache-0.4.1-cp312-cp312-musllinux_1_2_armv7l.whl", hash = "sha256:ab08df6c9a035bee56e31af99be621526bd237bea9f32def431c656b29e41778", size = 213019, upload-time = "2025-10-08T19:46:57.595Z" },
    { url = "https://files.pythonhosted.org/packages/57/74/f580099a58c8af587cac7ba19ee7cb418506342fbbe2d4a4401661cca886/propcache-0.4.1-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:4d7af63f9f93fe593afbf104c21b3b15868efb2c21d07d8732c0c4287e66b6a6", size = 220376, upload-time = "2025-10-08T19:46:59.067Z" },
    { url = "https://files.pythonhosted.org/packages/c4/ee/542f1313aff7eaf19c2bb758c5d0560d2683dac001a1c96d0774af799843/propcache-0.4.1-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:cfc27c945f422e8b5071b6e93169679e4eb5bf73bbcbf1ba3ae3a83d2f78ebd9", size = 226988, upload-time = "2025-10-08T19:47:00.544Z" },
    { url = "https://files.pythonhosted.org/packages/8f/18/9c6b015dd9c6930f6ce2229e1f02fb35298b847f2087ea2b436a5bfa7287/propcache-0.4.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:35c3277624a080cc6ec6f847cbbbb5b49affa3598c4535a0a4682a697aaa5c75", size = 215615, upload-time = "2025-10-08T19:47:01.968Z" },
    { url = "https://files.pythonhosted.org/packages/80/9e/e7b85720b98c45a45e1fca6a177024934dc9bc5f4d5dd04207f216fc33ed/propcache-0.4.1-cp312-cp312-win32.whl", hash = "sha256:671538c2262dadb5ba6395e26c1731e1d52534bfe9ae56d0b5573ce539266aa8", size = 38066, upload-time = "2025-10-08T19:47:03.503Z" },
    { url = "https://files.pythonhosted.org/packages/54/09/d19cff2a5aaac632ec8fc03737b223597b1e347416934c1b3a7df079784c/propcache-0.4.1-cp312-cp312-win_amd64.whl", hash = "sha256:cb2d222e72399fcf5890d1d5cc1060857b9b236adff2792ff48ca2dfd46c81db", size = 41655, upload-time = "2025-10-08T19:47:04.973Z" },
    { url = "https://files.pythonhosted.org/packages/68/ab/6b5c191bb5de08036a8c697b265d4ca76148efb10fa162f14af14fb5f076/propcache-0.4.1-cp312-cp312-win_arm64.whl", hash = "sha256:204483131fb222bdaaeeea9f9e6c6ed0cac32731f75dfc1d4a567fc1926477c1", size = 37789, upload-time = "2025-10-08T19:47:06.077Z" },
    { url = "https://files.pythonhosted.org/packages/bf/df/6d9c1b6ac12b003837dde8a10231a7344512186e87b36e855bef32241942/propcache-0.4.1-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:43eedf29202c08550aac1d14e0ee619b0430aaef78f85864c1a892294fbc28cf", size = 77750, upload-time = "2025-10-08T19:47:07.648Z" },
    { url = "https://files.pythonhosted.org/packages/8b/e8/677a0025e8a2acf07d3418a2e7ba529c9c33caf09d3c1f25513023c1db56/propcache-0.4.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:d62cdfcfd89ccb8de04e0eda998535c406bf5e060ffd56be6c586cbcc05b3311", size = 44780, upload-time = "2025-10-08T19:47:08.851Z" },
    { url = "https://files.pythonhosted.org/packages/89/a4/92380f7ca60f99ebae761936bc48a72a639e8a47b29050615eef757cb2a7/propcache-0.4.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:cae65ad55793da34db5f54e4029b89d3b9b9490d8abe1b4c7ab5d4b8ec7ebf74", size = 46308, upload-time = "2025-10-08T19:47:09.982Z" },
    { url = "https://files.pythonhosted.org/packages/2d/48/c5ac64dee5262044348d1d78a5f85dd1a57464a60d30daee946699963eb3/propcache-0.4.1-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:333ddb9031d2704a301ee3e506dc46b1fe5f294ec198ed6435ad5b6a085facfe", size = 208182, upload-time = "2025-10-08T19:47:11.319Z" },
    { url = "https://files.pythonhosted.org/packages/c6/0c/cd762dd011a9287389a6a3eb43aa30207bde253610cca06824aeabfe9653/propcache-0.4.1-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:fd0858c20f078a32cf55f7e81473d96dcf3b93fd2ccdb3d40fdf54b8573df3af", size = 211215, upload-time = "2025-10-08T19:47:13.146Z" },
    { url = "https://files.pythonhosted.org/packages/30/3e/49861e90233ba36890ae0ca4c660e95df565b2cd15d4a68556ab5865974e/propcache-0.4.1-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:678ae89ebc632c5c204c794f8dab2837c5f159aeb59e6ed0539500400577298c", size = 218112, upload-time = "2025-10-08T19:47:14.913Z" },
    { url = "https://files.pythonhosted.org/packages/f1/8b/544bc867e24e1bd48f3118cecd3b05c694e160a168478fa28770f22fd094/propcache-0.4.1-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:d472aeb4fbf9865e0c6d622d7f4d54a4e101a89715d8904282bb5f9a2f476c3f", size = 204442, upload-time = "2025-10-08T19:47:16.277Z" },
    { url = "https://files.pythonhosted.org/packages/50/a6/4282772fd016a76d3e5c0df58380a5ea64900afd836cec2c2f662d1b9bb3/propcache-0.4.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:4d3df5fa7e36b3225954fba85589da77a0fe6a53e3976de39caf04a0db4c36f1", size = 199398, upload-time = "2025-10-08T19:47:17.962Z" },
    { url = "https://files.pythonhosted.org/packages/3e/ec/d8a7cd406ee1ddb705db2139f8a10a8a427100347bd698e7014351c7af09/propcache-0.4.1-cp313-cp313-musllinux_1_2_armv7l.whl", hash = "sha256:ee17f18d2498f2673e432faaa71698032b0127ebf23ae5974eeaf806c279df24", size = 196920, upload-time = "2025-10-08T19:47:19.355Z" },
    { url = "https://files.pythonhosted.org/packages/f6/6c/f38ab64af3764f431e359f8baf9e0a21013e24329e8b85d2da32e8ed07ca/propcache-0.4.1-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:580e97762b950f993ae618e167e7be9256b8353c2dcd8b99ec100eb50f5286aa", size = 203748, upload-time = "2025-10-08T19:47:21.338Z" },
    { url = "https://files.pythonhosted.org/packages/d6/e3/fa846bd70f6534d647886621388f0a265254d30e3ce47e5c8e6e27dbf153/propcache-0.4.1-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:501d20b891688eb8e7aa903021f0b72d5a55db40ffaab27edefd1027caaafa61", size = 205877, upload-time = "2025-10-08T19:47:23.059Z" },
    { url = "https://files.pythonhosted.org/packages/e2/39/8163fc6f3133fea7b5f2827e8eba2029a0277ab2c5beee6c1db7b10fc23d/propcache-0.4.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:9a0bd56e5b100aef69bd8562b74b46254e7c8812918d3baa700c8a8009b0af66", size = 199437, upload-time = "2025-10-08T19:47:24.445Z" },
    { url = "https://files.pythonhosted.org/packages/93/89/caa9089970ca49c7c01662bd0eeedfe85494e863e8043565aeb6472ce8fe/propcache-0.4.1-cp313-cp313-win32.whl", hash = "sha256:bcc9aaa5d80322bc2fb24bb7accb4a30f81e90ab8d6ba187aec0744bc302ad81", size = 37586, upload-time = "2025-10-08T19:47:25.736Z" },
    { url = "https://files.pythonhosted.org/packages/f5/ab/f76ec3c3627c883215b5c8080debb4394ef5a7a29be811f786415fc1e6fd/propcache-0.4.1-cp313-cp313-win_amd64.whl", hash = "sha256:381914df18634f5494334d201e98245c0596067504b9372d8cf93f4bb23e025e", size = 40790, upload-time = "2025-10-08T19:47:26.847Z" },
    { url = "https://files.pythonhosted.org/packages/59/1b/e71ae98235f8e2ba5004d8cb19765a74877abf189bc53fc0c80d799e56c3/propcache-0.4.1-cp313-cp313-win_arm64.whl", hash = "sha256:8873eb4460fd55333ea49b7d189749ecf6e55bf85080f11b1c4530ed3034cba1", size = 37158, upload-time = "2025-10-08T19:47:27.961Z" },
    { url = "https://files.pythonhosted.org/packages/83/ce/a31bbdfc24ee0dcbba458c8175ed26089cf109a55bbe7b7640ed2470cfe9/propcache-0.4.1-cp313-cp313t-macosx_10_13_universal2.whl", hash = "sha256:92d1935ee1f8d7442da9c0c4fa7ac20d07e94064184811b685f5c4fada64553b", size = 81451, upload-time = "2025-10-08T19:47:29.445Z" },
    { url = "https://files.pythonhosted.org/packages/25/9c/442a45a470a68456e710d96cacd3573ef26a1d0a60067e6a7d5e655621ed/propcache-0.4.1-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:473c61b39e1460d386479b9b2f337da492042447c9b685f28be4f74d3529e566", size = 46374, upload-time = "2025-10-08T19:47:30.579Z" },
    { url = "https://files.pythonhosted.org/packages/f4/bf/b1d5e21dbc3b2e889ea4327044fb16312a736d97640fb8b6aa3f9c7b3b65/propcache-0.4.1-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:c0ef0aaafc66fbd87842a3fe3902fd889825646bc21149eafe47be6072725835", size = 48396, upload-time = "2025-10-08T19:47:31.79Z" },
    { url = "https://files.pythonhosted.org/packages/f4/04/5b4c54a103d480e978d3c8a76073502b18db0c4bc17ab91b3cb5092ad949/propcache-0.4.1-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:f95393b4d66bfae908c3ca8d169d5f79cd65636ae15b5e7a4f6e67af675adb0e", size = 275950, upload-time = "2025-10-08T19:47:33.481Z" },
    { url = "https://files.pythonhosted.org/packages/b4/c1/86f846827fb969c4b78b0af79bba1d1ea2156492e1b83dea8b8a6ae27395/propcache-0.4.1-cp313-cp313t-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:c07fda85708bc48578467e85099645167a955ba093be0a2dcba962195676e859", size = 273856, upload-time = "2025-10-08T19:47:34.906Z" },
    { url = "https://files.pythonhosted.org/packages/36/1d/fc272a63c8d3bbad6878c336c7a7dea15e8f2d23a544bda43205dfa83ada/propcache-0.4.1-cp313-cp313t-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:af223b406d6d000830c6f65f1e6431783fc3f713ba3e6cc8c024d5ee96170a4b", size = 280420, upload-time = "2025-10-08T19:47:36.338Z" },
    { url = "https://files.pythonhosted.org/packages/07/0c/01f2219d39f7e53d52e5173bcb09c976609ba30209912a0680adfb8c593a/propcache-0.4.1-cp313-cp313t-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:a78372c932c90ee474559c5ddfffd718238e8673c340dc21fe45c5b8b54559a0", size = 263254, upload-time = "2025-10-08T19:47:37.692Z" },
    { url = "https://files.pythonhosted.org/packages/2d/18/cd28081658ce597898f0c4d174d4d0f3c5b6d4dc27ffafeef835c95eb359/propcache-0.4.1-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:564d9f0d4d9509e1a870c920a89b2fec951b44bf5ba7d537a9e7c1ccec2c18af", size = 261205, upload-time = "2025-10-08T19:47:39.659Z" },
    { url = "https://files.pythonhosted.org/packages/7a/71/1f9e22eb8b8316701c2a19fa1f388c8a3185082607da8e406a803c9b954e/propcache-0.4.1-cp313-cp313t-musllinux_1_2_armv7l.whl", hash = "sha256:17612831fda0138059cc5546f4d12a2aacfb9e47068c06af35c400ba58ba7393", size = 247873, upload-time = "2025-10-08T19:47:41.084Z" },
    { url = "https://files.pythonhosted.org/packages/4a/65/3d4b61f36af2b4eddba9def857959f1016a51066b4f1ce348e0cf7881f58/propcache-0.4.1-cp313-cp313t-musllinux_1_2_ppc64le.whl", hash = "sha256:41a89040cb10bd345b3c1a873b2bf36413d48da1def52f268a055f7398514874", size = 262739, upload-time = "2025-10-08T19:47:42.51Z" },
    { url = "https://files.pythonhosted.org/packages/2a/42/26746ab087faa77c1c68079b228810436ccd9a5ce9ac85e2b7307195fd06/propcache-0.4.1-cp313-cp313t-musllinux_1_2_s390x.whl", hash = "sha256:e35b88984e7fa64aacecea39236cee32dd9bd8c55f57ba8a75cf2399553f9bd7", size = 263514, upload-time = "2025-10-08T19:47:43.927Z" },
    { url = "https://files.pythonhosted.org/packages/94/13/630690fe201f5502d2403dd3cfd451ed8858fe3c738ee88d095ad2ff407b/propcache-0.4.1-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:6f8b465489f927b0df505cbe26ffbeed4d6d8a2bbc61ce90eb074ff129ef0ab1", size = 257781, upload-time = "2025-10-08T19:47:45.448Z" },
    { url = "https://files.pythonhosted.org/packages/92/f7/1d4ec5841505f423469efbfc381d64b7b467438cd5a4bbcbb063f3b73d27/propcache-0.4.1-cp313-cp313t-win32.whl", hash = "sha256:2ad890caa1d928c7c2965b48f3a3815c853180831d0e5503d35cf00c472f4717", size = 41396, upload-time = "2025-10-08T19:47:47.202Z" },
    { url = "https://files.pythonhosted.org/packages/48/f0/615c30622316496d2cbbc29f5985f7777d3ada70f23370608c1d3e081c1f/propcache-0.4.1-cp313-cp313t-win_amd64.whl", hash = "sha256:f7ee0e597f495cf415bcbd3da3caa3bd7e816b74d0d52b8145954c5e6fd3ff37", size = 44897, upload-time = "2025-10-08T19:47:48.336Z" },
    { url = "https://files.pythonhosted.org/packages/fd/ca/6002e46eccbe0e33dcd4069ef32f7f1c9e243736e07adca37ae8c4830ec3/propcache-0.4.1-cp313-cp313t-win_arm64.whl", hash = "sha256:929d7cbe1f01bb7baffb33dc14eb5691c95831450a26354cd210a8155170c93a", size = 39789, upload-time = "2025-10-08T19:47:49.876Z" },
    { url = "https://files.pythonhosted.org/packages/5b/5a/bc7b4a4ef808fa59a816c17b20c4bef6884daebbdf627ff2a161da67da19/propcache-0.4.1-py3-none-any.whl", hash = "sha256:af2a6052aeb6cf17d3e46ee169099044fd8224cbaf75c76a2ef596e8163e2237", size = 13305, upload-time = "2025-10-08T19:49:00.792Z" },
]

[[package]]
name = "protobuf"
version = "6.33.5"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ba/25/7c72c307aafc96fa87062aa6291d9f7c94836e43214d43722e86037aac02/protobuf-6.33.5.tar.gz", hash = "sha256:6ddcac2a081f8b7b9642c09406bc6a4290128fce5f471cddd165960bb9119e5c", size = 444465, upload-time = "2026-01-29T21:51:33.494Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b1/79/af92d0a8369732b027e6d6084251dd8e782c685c72da161bd4a2e00fbabb/protobuf-6.33.5-cp310-abi3-win32.whl", hash = "sha256:d71b040839446bac0f4d162e758bea99c8251161dae9d0983a3b88dee345153b", size = 425769, upload-time = "2026-01-29T21:51:21.751Z" },
    { url = "https://files.pythonhosted.org/packages/55/75/bb9bc917d10e9ee13dee8607eb9ab963b7cf8be607c46e7862c748aa2af7/protobuf-6.33.5-cp310-abi3-win_amd64.whl", hash = "sha256:3093804752167bcab3998bec9f1048baae6e29505adaf1afd14a37bddede533c", size = 437118, upload-time = "2026-01-29T21:51:24.022Z" },
    { url = "https://files.pythonhosted.org/packages/a2/6b/e48dfc1191bc5b52950246275bf4089773e91cb5ba3592621723cdddca62/protobuf-6.33.5-cp39-abi3-macosx_10_9_universal2.whl", hash = "sha256:a5cb85982d95d906df1e2210e58f8e4f1e3cdc088e52c921a041f9c9a0386de5", size = 427766, upload-time = "2026-01-29T21:51:25.413Z" },
    { url = "https://files.pythonhosted.org/packages/4e/b1/c79468184310de09d75095ed1314b839eb2f72df71097db9d1404a1b2717/protobuf-6.33.5-cp39-abi3-manylinux2014_aarch64.whl", hash = "sha256:9b71e0281f36f179d00cbcb119cb19dec4d14a81393e5ea220f64b286173e190", size = 324638, upload-time = "2026-01-29T21:51:26.423Z" },
    { url = "https://files.pythonhosted.org/packages/c5/f5/65d838092fd01c44d16037953fd4c2cc851e783de9b8f02b27ec4ffd906f/protobuf-6.33.5-cp39-abi3-manylinux2014_s390x.whl", hash = "sha256:8afa18e1d6d20af15b417e728e9f60f3aa108ee76f23c3b2c07a2c3b546d3afd", size = 339411, upload-time = "2026-01-29T21:51:27.446Z" },
    { url = "https://files.pythonhosted.org/packages/9b/53/a9443aa3ca9ba8724fdfa02dd1887c1bcd8e89556b715cfbacca6b63dbec/protobuf-6.33.5-cp39-abi3-manylinux2014_x86_64.whl", hash = "sha256:cbf16ba3350fb7b889fca858fb215967792dc125b35c7976ca4818bee3521cf0", size = 323465, upload-time = "2026-01-29T21:51:28.925Z" },
    { url = "https://files.pythonhosted.org/packages/57/bf/2086963c69bdac3d7cff1cc7ff79b8ce5ea0bec6797a017e1be338a46248/protobuf-6.33.5-py3-none-any.whl", hash = "sha256:69915a973dd0f60f31a08b8318b73eab2bd6a392c79184b3612226b0a3f8ec02", size = 170687, upload-time = "2026-01-29T21:51:32.557Z" },
]

[[package]]
name = "psutil"
version = "7.1.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e1/88/bdd0a41e5857d5d703287598cbf08dad90aed56774ea52ae071bae9071b6/psutil-7.1.3.tar.gz", hash = "sha256:6c86281738d77335af7aec228328e944b30930899ea760ecf33a4dba66be5e74", size = 489059, upload-time = "2025-11-02T12:25:54.619Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/bd/93/0c49e776b8734fef56ec9c5c57f923922f2cf0497d62e0f419465f28f3d0/psutil-7.1.3-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:0005da714eee687b4b8decd3d6cc7c6db36215c9e74e5ad2264b90c3df7d92dc", size = 239751, upload-time = "2025-11-02T12:25:58.161Z" },
    { url = "https://files.pythonhosted.org/packages/6f/8d/b31e39c769e70780f007969815195a55c81a63efebdd4dbe9e7a113adb2f/psutil-7.1.3-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:19644c85dcb987e35eeeaefdc3915d059dac7bd1167cdcdbf27e0ce2df0c08c0", size = 240368, upload-time = "2025-11-02T12:26:00.491Z" },
    { url = "https://files.pythonhosted.org/packages/62/61/23fd4acc3c9eebbf6b6c78bcd89e5d020cfde4acf0a9233e9d4e3fa698b4/psutil-7.1.3-cp313-cp313t-manylinux2010_x86_64.manylinux_2_12_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:95ef04cf2e5ba0ab9eaafc4a11eaae91b44f4ef5541acd2ee91d9108d00d59a7", size = 287134, upload-time = "2025-11-02T12:26:02.613Z" },
    { url = "https://files.pythonhosted.org/packages/30/1c/f921a009ea9ceb51aa355cb0cc118f68d354db36eae18174bab63affb3e6/psutil-7.1.3-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:1068c303be3a72f8e18e412c5b2a8f6d31750fb152f9cb106b54090296c9d251", size = 289904, upload-time = "2025-11-02T12:26:05.207Z" },
    { url = "https://files.pythonhosted.org/packages/a6/82/62d68066e13e46a5116df187d319d1724b3f437ddd0f958756fc052677f4/psutil-7.1.3-cp313-cp313t-win_amd64.whl", hash = "sha256:18349c5c24b06ac5612c0428ec2a0331c26443d259e2a0144a9b24b4395b58fa", size = 249642, upload-time = "2025-11-02T12:26:07.447Z" },
    { url = "https://files.pythonhosted.org/packages/df/ad/c1cd5fe965c14a0392112f68362cfceb5230819dbb5b1888950d18a11d9f/psutil-7.1.3-cp313-cp313t-win_arm64.whl", hash = "sha256:c525ffa774fe4496282fb0b1187725793de3e7c6b29e41562733cae9ada151ee", size = 245518, upload-time = "2025-11-02T12:26:09.719Z" },
    { url = "https://files.pythonhosted.org/packages/ef/94/46b9154a800253e7ecff5aaacdf8ebf43db99de4a2dfa18575b02548654e/psutil-7.1.3-cp36-abi3-macosx_10_9_x86_64.whl", hash = "sha256:2bdbcd0e58ca14996a42adf3621a6244f1bb2e2e528886959c72cf1e326677ab", size = 238359, upload-time = "2025-11-02T12:26:25.284Z" },
    { url = "https://files.pythonhosted.org/packages/68/3a/9f93cff5c025029a36d9a92fef47220ab4692ee7f2be0fba9f92813d0cb8/psutil-7.1.3-cp36-abi3-macosx_11_0_arm64.whl", hash = "sha256:bc31fa00f1fbc3c3802141eede66f3a2d51d89716a194bf2cd6fc68310a19880", size = 239171, upload-time = "2025-11-02T12:26:27.23Z" },
    { url = "https://files.pythonhosted.org/packages/ce/b1/5f49af514f76431ba4eea935b8ad3725cdeb397e9245ab919dbc1d1dc20f/psutil-7.1.3-cp36-abi3-manylinux2010_x86_64.manylinux_2_12_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:3bb428f9f05c1225a558f53e30ccbad9930b11c3fc206836242de1091d3e7dd3", size = 263261, upload-time = "2025-11-02T12:26:29.48Z" },
    { url = "https://files.pythonhosted.org/packages/e0/95/992c8816a74016eb095e73585d747e0a8ea21a061ed3689474fabb29a395/psutil-7.1.3-cp36-abi3-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:56d974e02ca2c8eb4812c3f76c30e28836fffc311d55d979f1465c1feeb2b68b", size = 264635, upload-time = "2025-11-02T12:26:31.74Z" },
    { url = "https://files.pythonhosted.org/packages/55/4c/c3ed1a622b6ae2fd3c945a366e64eb35247a31e4db16cf5095e269e8eb3c/psutil-7.1.3-cp37-abi3-win_amd64.whl", hash = "sha256:f39c2c19fe824b47484b96f9692932248a54c43799a84282cfe58d05a6449efd", size = 247633, upload-time = "2025-11-02T12:26:33.887Z" },
    { url = "https://files.pythonhosted.org/packages/c9/ad/33b2ccec09bf96c2b2ef3f9a6f66baac8253d7565d8839e024a6b905d45d/psutil-7.1.3-cp37-abi3-win_arm64.whl", hash = "sha256:bd0d69cee829226a761e92f28140bec9a5ee9d5b4fb4b0cc589068dbfff559b1", size = 244608, upload-time = "2025-11-02T12:26:36.136Z" },
]

[[package]]
name = "py"
version = "1.11.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/98/ff/fec109ceb715d2a6b4c4a85a61af3b40c723a961e8828319fbcb15b868dc/py-1.11.0.tar.gz", hash = "sha256:51c75c4126074b472f746a24399ad32f6053d1b34b68d2fa41e558e6f4a98719", size = 207796, upload-time = "2021-11-04T17:17:01.377Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f6/f0/10642828a8dfb741e5f3fbaac830550a518a775c7fff6f04a007259b0548/py-1.11.0-py2.py3-none-any.whl", hash = "sha256:607c53218732647dff4acdfcd50cb62615cedf612e72d1724fb1a0cc6405b378", size = 98708, upload-time = "2021-11-04T17:17:00.152Z" },
]

[[package]]
name = "pyarrow"
version = "22.0.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/30/53/04a7fdc63e6056116c9ddc8b43bc28c12cdd181b85cbeadb79278475f3ae/pyarrow-22.0.0.tar.gz", hash = "sha256:3d600dc583260d845c7d8a6db540339dd883081925da2bd1c5cb808f720b3cd9", size = 1151151, upload-time = "2025-10-24T12:30:00.762Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2e/b7/18f611a8cdc43417f9394a3ccd3eace2f32183c08b9eddc3d17681819f37/pyarrow-22.0.0-cp311-cp311-macosx_12_0_arm64.whl", hash = "sha256:3e294c5eadfb93d78b0763e859a0c16d4051fc1c5231ae8956d61cb0b5666f5a", size = 34272022, upload-time = "2025-10-24T10:04:28.973Z" },
    { url = "https://files.pythonhosted.org/packages/26/5c/f259e2526c67eb4b9e511741b19870a02363a47a35edbebc55c3178db22d/pyarrow-22.0.0-cp311-cp311-macosx_12_0_x86_64.whl", hash = "sha256:69763ab2445f632d90b504a815a2a033f74332997052b721002298ed6de40f2e", size = 35995834, upload-time = "2025-10-24T10:04:35.467Z" },
    { url = "https://files.pythonhosted.org/packages/50/8d/281f0f9b9376d4b7f146913b26fac0aa2829cd1ee7e997f53a27411bbb92/pyarrow-22.0.0-cp311-cp311-manylinux_2_28_aarch64.whl", hash = "sha256:b41f37cabfe2463232684de44bad753d6be08a7a072f6a83447eeaf0e4d2a215", size = 45030348, upload-time = "2025-10-24T10:04:43.366Z" },
    { url = "https://files.pythonhosted.org/packages/f5/e5/53c0a1c428f0976bf22f513d79c73000926cb00b9c138d8e02daf2102e18/pyarrow-22.0.0-cp311-cp311-manylinux_2_28_x86_64.whl", hash = "sha256:35ad0f0378c9359b3f297299c3309778bb03b8612f987399a0333a560b43862d", size = 47699480, upload-time = "2025-10-24T10:04:51.486Z" },
    { url = "https://files.pythonhosted.org/packages/95/e1/9dbe4c465c3365959d183e6345d0a8d1dc5b02ca3f8db4760b3bc834cf25/pyarrow-22.0.0-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:8382ad21458075c2e66a82a29d650f963ce51c7708c7c0ff313a8c206c4fd5e8", size = 48011148, upload-time = "2025-10-24T10:04:59.585Z" },
    { url = "https://files.pythonhosted.org/packages/c5/b4/7caf5d21930061444c3cf4fa7535c82faf5263e22ce43af7c2759ceb5b8b/pyarrow-22.0.0-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:1a812a5b727bc09c3d7ea072c4eebf657c2f7066155506ba31ebf4792f88f016", size = 50276964, upload-time = "2025-10-24T10:05:08.175Z" },
    { url = "https://files.pythonhosted.org/packages/ae/f3/cec89bd99fa3abf826f14d4e53d3d11340ce6f6af4d14bdcd54cd83b6576/pyarrow-22.0.0-cp311-cp311-win_amd64.whl", hash = "sha256:ec5d40dd494882704fb876c16fa7261a69791e784ae34e6b5992e977bd2e238c", size = 28106517, upload-time = "2025-10-24T10:05:14.314Z" },
    { url = "https://files.pythonhosted.org/packages/af/63/ba23862d69652f85b615ca14ad14f3bcfc5bf1b99ef3f0cd04ff93fdad5a/pyarrow-22.0.0-cp312-cp312-macosx_12_0_arm64.whl", hash = "sha256:bea79263d55c24a32b0d79c00a1c58bb2ee5f0757ed95656b01c0fb310c5af3d", size = 34211578, upload-time = "2025-10-24T10:05:21.583Z" },
    { url = "https://files.pythonhosted.org/packages/b1/d0/f9ad86fe809efd2bcc8be32032fa72e8b0d112b01ae56a053006376c5930/pyarrow-22.0.0-cp312-cp312-macosx_12_0_x86_64.whl", hash = "sha256:12fe549c9b10ac98c91cf791d2945e878875d95508e1a5d14091a7aaa66d9cf8", size = 35989906, upload-time = "2025-10-24T10:05:29.485Z" },
    { url = "https://files.pythonhosted.org/packages/b4/a8/f910afcb14630e64d673f15904ec27dd31f1e009b77033c365c84e8c1e1d/pyarrow-22.0.0-cp312-cp312-manylinux_2_28_aarch64.whl", hash = "sha256:334f900ff08ce0423407af97e6c26ad5d4e3b0763645559ece6fbf3747d6a8f5", size = 45021677, upload-time = "2025-10-24T10:05:38.274Z" },
    { url = "https://files.pythonhosted.org/packages/13/95/aec81f781c75cd10554dc17a25849c720d54feafb6f7847690478dcf5ef8/pyarrow-22.0.0-cp312-cp312-manylinux_2_28_x86_64.whl", hash = "sha256:c6c791b09c57ed76a18b03f2631753a4960eefbbca80f846da8baefc6491fcfe", size = 47726315, upload-time = "2025-10-24T10:05:47.314Z" },
    { url = "https://files.pythonhosted.org/packages/bb/d4/74ac9f7a54cfde12ee42734ea25d5a3c9a45db78f9def949307a92720d37/pyarrow-22.0.0-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:c3200cb41cdbc65156e5f8c908d739b0dfed57e890329413da2748d1a2cd1a4e", size = 47990906, upload-time = "2025-10-24T10:05:58.254Z" },
    { url = "https://files.pythonhosted.org/packages/2e/71/fedf2499bf7a95062eafc989ace56572f3343432570e1c54e6599d5b88da/pyarrow-22.0.0-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:ac93252226cf288753d8b46280f4edf3433bf9508b6977f8dd8526b521a1bbb9", size = 50306783, upload-time = "2025-10-24T10:06:08.08Z" },
    { url = "https://files.pythonhosted.org/packages/68/ed/b202abd5a5b78f519722f3d29063dda03c114711093c1995a33b8e2e0f4b/pyarrow-22.0.0-cp312-cp312-win_amd64.whl", hash = "sha256:44729980b6c50a5f2bfcc2668d36c569ce17f8b17bccaf470c4313dcbbf13c9d", size = 27972883, upload-time = "2025-10-24T10:06:14.204Z" },
    { url = "https://files.pythonhosted.org/packages/a6/d6/d0fac16a2963002fc22c8fa75180a838737203d558f0ed3b564c4a54eef5/pyarrow-22.0.0-cp313-cp313-macosx_12_0_arm64.whl", hash = "sha256:e6e95176209257803a8b3d0394f21604e796dadb643d2f7ca21b66c9c0b30c9a", size = 34204629, upload-time = "2025-10-24T10:06:20.274Z" },
    { url = "https://files.pythonhosted.org/packages/c6/9c/1d6357347fbae062ad3f17082f9ebc29cc733321e892c0d2085f42a2212b/pyarrow-22.0.0-cp313-cp313-macosx_12_0_x86_64.whl", hash = "sha256:001ea83a58024818826a9e3f89bf9310a114f7e26dfe404a4c32686f97bd7901", size = 35985783, upload-time = "2025-10-24T10:06:27.301Z" },
    { url = "https://files.pythonhosted.org/packages/ff/c0/782344c2ce58afbea010150df07e3a2f5fdad299cd631697ae7bd3bac6e3/pyarrow-22.0.0-cp313-cp313-manylinux_2_28_aarch64.whl", hash = "sha256:ce20fe000754f477c8a9125543f1936ea5b8867c5406757c224d745ed033e691", size = 45020999, upload-time = "2025-10-24T10:06:35.387Z" },
    { url = "https://files.pythonhosted.org/packages/1b/8b/5362443737a5307a7b67c1017c42cd104213189b4970bf607e05faf9c525/pyarrow-22.0.0-cp313-cp313-manylinux_2_28_x86_64.whl", hash = "sha256:e0a15757fccb38c410947df156f9749ae4a3c89b2393741a50521f39a8cf202a", size = 47724601, upload-time = "2025-10-24T10:06:43.551Z" },
    { url = "https://files.pythonhosted.org/packages/69/4d/76e567a4fc2e190ee6072967cb4672b7d9249ac59ae65af2d7e3047afa3b/pyarrow-22.0.0-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:cedb9dd9358e4ea1d9bce3665ce0797f6adf97ff142c8e25b46ba9cdd508e9b6", size = 48001050, upload-time = "2025-10-24T10:06:52.284Z" },
    { url = "https://files.pythonhosted.org/packages/01/5e/5653f0535d2a1aef8223cee9d92944cb6bccfee5cf1cd3f462d7cb022790/pyarrow-22.0.0-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:252be4a05f9d9185bb8c18e83764ebcfea7185076c07a7a662253af3a8c07941", size = 50307877, upload-time = "2025-10-24T10:07:02.405Z" },
    { url = "https://files.pythonhosted.org/packages/2d/f8/1d0bd75bf9328a3b826e24a16e5517cd7f9fbf8d34a3184a4566ef5a7f29/pyarrow-22.0.0-cp313-cp313-win_amd64.whl", hash = "sha256:a4893d31e5ef780b6edcaf63122df0f8d321088bb0dee4c8c06eccb1ca28d145", size = 27977099, upload-time = "2025-10-24T10:08:07.259Z" },
    { url = "https://files.pythonhosted.org/packages/90/81/db56870c997805bf2b0f6eeeb2d68458bf4654652dccdcf1bf7a42d80903/pyarrow-22.0.0-cp313-cp313t-macosx_12_0_arm64.whl", hash = "sha256:f7fe3dbe871294ba70d789be16b6e7e52b418311e166e0e3cba9522f0f437fb1", size = 34336685, upload-time = "2025-10-24T10:07:11.47Z" },
    { url = "https://files.pythonhosted.org/packages/1c/98/0727947f199aba8a120f47dfc229eeb05df15bcd7a6f1b669e9f882afc58/pyarrow-22.0.0-cp313-cp313t-macosx_12_0_x86_64.whl", hash = "sha256:ba95112d15fd4f1105fb2402c4eab9068f0554435e9b7085924bcfaac2cc306f", size = 36032158, upload-time = "2025-10-24T10:07:18.626Z" },
    { url = "https://files.pythonhosted.org/packages/96/b4/9babdef9c01720a0785945c7cf550e4acd0ebcd7bdd2e6f0aa7981fa85e2/pyarrow-22.0.0-cp313-cp313t-manylinux_2_28_aarch64.whl", hash = "sha256:c064e28361c05d72eed8e744c9605cbd6d2bb7481a511c74071fd9b24bc65d7d", size = 44892060, upload-time = "2025-10-24T10:07:26.002Z" },
    { url = "https://files.pythonhosted.org/packages/f8/ca/2f8804edd6279f78a37062d813de3f16f29183874447ef6d1aadbb4efa0f/pyarrow-22.0.0-cp313-cp313t-manylinux_2_28_x86_64.whl", hash = "sha256:6f9762274496c244d951c819348afbcf212714902742225f649cf02823a6a10f", size = 47504395, upload-time = "2025-10-24T10:07:34.09Z" },
    { url = "https://files.pythonhosted.org/packages/b9/f0/77aa5198fd3943682b2e4faaf179a674f0edea0d55d326d83cb2277d9363/pyarrow-22.0.0-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:a9d9ffdc2ab696f6b15b4d1f7cec6658e1d788124418cb30030afbae31c64746", size = 48066216, upload-time = "2025-10-24T10:07:43.528Z" },
    { url = "https://files.pythonhosted.org/packages/79/87/a1937b6e78b2aff18b706d738c9e46ade5bfcf11b294e39c87706a0089ac/pyarrow-22.0.0-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:ec1a15968a9d80da01e1d30349b2b0d7cc91e96588ee324ce1b5228175043e95", size = 50288552, upload-time = "2025-10-24T10:07:53.519Z" },
    { url = "https://files.pythonhosted.org/packages/60/ae/b5a5811e11f25788ccfdaa8f26b6791c9807119dffcf80514505527c384c/pyarrow-22.0.0-cp313-cp313t-win_amd64.whl", hash = "sha256:bba208d9c7decf9961998edf5c65e3ea4355d5818dd6cd0f6809bec1afb951cc", size = 28262504, upload-time = "2025-10-24T10:08:00.932Z" },
]

[[package]]
name = "pyasn1"
version = "0.6.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/fe/b6/6e630dff89739fcd427e3f72b3d905ce0acb85a45d4ec3e2678718a3487f/pyasn1-0.6.2.tar.gz", hash = "sha256:9b59a2b25ba7e4f8197db7686c09fb33e658b98339fadb826e9512629017833b", size = 146586, upload-time = "2026-01-16T18:04:18.534Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/44/b5/a96872e5184f354da9c84ae119971a0a4c221fe9b27a4d94bd43f2596727/pyasn1-0.6.2-py3-none-any.whl", hash = "sha256:1eb26d860996a18e9b6ed05e7aae0e9fc21619fcee6af91cca9bad4fbea224bf", size = 83371, upload-time = "2026-01-16T18:04:17.174Z" },
]

[[package]]
name = "pyasn1-modules"
version = "0.4.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "pyasn1" },
]
sdist = { url = "https://files.pythonhosted.org/packages/e9/e6/78ebbb10a8c8e4b61a59249394a4a594c1a7af95593dc933a349c8d00964/pyasn1_modules-0.4.2.tar.gz", hash = "sha256:677091de870a80aae844b1ca6134f54652fa2c8c5a52aa396440ac3106e941e6", size = 307892, upload-time = "2025-03-28T02:41:22.17Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/47/8d/d529b5d697919ba8c11ad626e835d4039be708a35b0d22de83a269a6682c/pyasn1_modules-0.4.2-py3-none-any.whl", hash = "sha256:29253a9207ce32b64c3ac6600edc75368f98473906e8fd1043bd6b5b1de2c14a", size = 181259, upload-time = "2025-03-28T02:41:19.028Z" },
]

[[package]]
name = "pycparser"
version = "2.23"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/fe/cf/d2d3b9f5699fb1e4615c8e32ff220203e43b248e1dfcc6736ad9057731ca/pycparser-2.23.tar.gz", hash = "sha256:78816d4f24add8f10a06d6f05b4d424ad9e96cfebf68a4ddc99c65c0720d00c2", size = 173734, upload-time = "2025-09-09T13:23:47.91Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a0/e3/59cd50310fc9b59512193629e1984c1f95e5c8ae6e5d8c69532ccc65a7fe/pycparser-2.23-py3-none-any.whl", hash = "sha256:e5c6e8d3fbad53479cab09ac03729e0a9faf2bee3db8208a550daf5af81a5934", size = 118140, upload-time = "2025-09-09T13:23:46.651Z" },
]

[[package]]
name = "pydantic"
version = "2.12.4"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "annotated-types" },
    { name = "pydantic-core" },
    { name = "typing-extensions" },
    { name = "typing-inspection" },
]
sdist = { url = "https://files.pythonhosted.org/packages/96/ad/a17bc283d7d81837c061c49e3eaa27a45991759a1b7eae1031921c6bd924/pydantic-2.12.4.tar.gz", hash = "sha256:0f8cb9555000a4b5b617f66bfd2566264c4984b27589d3b845685983e8ea85ac", size = 821038, upload-time = "2025-11-05T10:50:08.59Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/82/2f/e68750da9b04856e2a7ec56fc6f034a5a79775e9b9a81882252789873798/pydantic-2.12.4-py3-none-any.whl", hash = "sha256:92d3d202a745d46f9be6df459ac5a064fdaa3c1c4cd8adcfa332ccf3c05f871e", size = 463400, upload-time = "2025-11-05T10:50:06.732Z" },
]

[[package]]
name = "pydantic-core"
version = "2.41.5"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/71/70/23b021c950c2addd24ec408e9ab05d59b035b39d97cdc1130e1bce647bb6/pydantic_core-2.41.5.tar.gz", hash = "sha256:08daa51ea16ad373ffd5e7606252cc32f07bc72b28284b6bc9c6df804816476e", size = 460952, upload-time = "2025-11-04T13:43:49.098Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e8/72/74a989dd9f2084b3d9530b0915fdda64ac48831c30dbf7c72a41a5232db8/pydantic_core-2.41.5-cp311-cp311-macosx_10_12_x86_64.whl", hash = "sha256:a3a52f6156e73e7ccb0f8cced536adccb7042be67cb45f9562e12b319c119da6", size = 2105873, upload-time = "2025-11-04T13:39:31.373Z" },
    { url = "https://files.pythonhosted.org/packages/12/44/37e403fd9455708b3b942949e1d7febc02167662bf1a7da5b78ee1ea2842/pydantic_core-2.41.5-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:7f3bf998340c6d4b0c9a2f02d6a400e51f123b59565d74dc60d252ce888c260b", size = 1899826, upload-time = "2025-11-04T13:39:32.897Z" },
    { url = "https://files.pythonhosted.org/packages/33/7f/1d5cab3ccf44c1935a359d51a8a2a9e1a654b744b5e7f80d41b88d501eec/pydantic_core-2.41.5-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:378bec5c66998815d224c9ca994f1e14c0c21cb95d2f52b6021cc0b2a58f2a5a", size = 1917869, upload-time = "2025-11-04T13:39:34.469Z" },
    { url = "https://files.pythonhosted.org/packages/6e/6a/30d94a9674a7fe4f4744052ed6c5e083424510be1e93da5bc47569d11810/pydantic_core-2.41.5-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:e7b576130c69225432866fe2f4a469a85a54ade141d96fd396dffcf607b558f8", size = 2063890, upload-time = "2025-11-04T13:39:36.053Z" },
    { url = "https://files.pythonhosted.org/packages/50/be/76e5d46203fcb2750e542f32e6c371ffa9b8ad17364cf94bb0818dbfb50c/pydantic_core-2.41.5-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:6cb58b9c66f7e4179a2d5e0f849c48eff5c1fca560994d6eb6543abf955a149e", size = 2229740, upload-time = "2025-11-04T13:39:37.753Z" },
    { url = "https://files.pythonhosted.org/packages/d3/ee/fed784df0144793489f87db310a6bbf8118d7b630ed07aa180d6067e653a/pydantic_core-2.41.5-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:88942d3a3dff3afc8288c21e565e476fc278902ae4d6d134f1eeda118cc830b1", size = 2350021, upload-time = "2025-11-04T13:39:40.94Z" },
    { url = "https://files.pythonhosted.org/packages/c8/be/8fed28dd0a180dca19e72c233cbf58efa36df055e5b9d90d64fd1740b828/pydantic_core-2.41.5-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:f31d95a179f8d64d90f6831d71fa93290893a33148d890ba15de25642c5d075b", size = 2066378, upload-time = "2025-11-04T13:39:42.523Z" },
    { url = "https://files.pythonhosted.org/packages/b0/3b/698cf8ae1d536a010e05121b4958b1257f0b5522085e335360e53a6b1c8b/pydantic_core-2.41.5-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:c1df3d34aced70add6f867a8cf413e299177e0c22660cc767218373d0779487b", size = 2175761, upload-time = "2025-11-04T13:39:44.553Z" },
    { url = "https://files.pythonhosted.org/packages/b8/ba/15d537423939553116dea94ce02f9c31be0fa9d0b806d427e0308ec17145/pydantic_core-2.41.5-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:4009935984bd36bd2c774e13f9a09563ce8de4abaa7226f5108262fa3e637284", size = 2146303, upload-time = "2025-11-04T13:39:46.238Z" },
    { url = "https://files.pythonhosted.org/packages/58/7f/0de669bf37d206723795f9c90c82966726a2ab06c336deba4735b55af431/pydantic_core-2.41.5-cp311-cp311-musllinux_1_1_armv7l.whl", hash = "sha256:34a64bc3441dc1213096a20fe27e8e128bd3ff89921706e83c0b1ac971276594", size = 2340355, upload-time = "2025-11-04T13:39:48.002Z" },
    { url = "https://files.pythonhosted.org/packages/e5/de/e7482c435b83d7e3c3ee5ee4451f6e8973cff0eb6007d2872ce6383f6398/pydantic_core-2.41.5-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:c9e19dd6e28fdcaa5a1de679aec4141f691023916427ef9bae8584f9c2fb3b0e", size = 2319875, upload-time = "2025-11-04T13:39:49.705Z" },
    { url = "https://files.pythonhosted.org/packages/fe/e6/8c9e81bb6dd7560e33b9053351c29f30c8194b72f2d6932888581f503482/pydantic_core-2.41.5-cp311-cp311-win32.whl", hash = "sha256:2c010c6ded393148374c0f6f0bf89d206bf3217f201faa0635dcd56bd1520f6b", size = 1987549, upload-time = "2025-11-04T13:39:51.842Z" },
    { url = "https://files.pythonhosted.org/packages/11/66/f14d1d978ea94d1bc21fc98fcf570f9542fe55bfcc40269d4e1a21c19bf7/pydantic_core-2.41.5-cp311-cp311-win_amd64.whl", hash = "sha256:76ee27c6e9c7f16f47db7a94157112a2f3a00e958bc626e2f4ee8bec5c328fbe", size = 2011305, upload-time = "2025-11-04T13:39:53.485Z" },
    { url = "https://files.pythonhosted.org/packages/56/d8/0e271434e8efd03186c5386671328154ee349ff0354d83c74f5caaf096ed/pydantic_core-2.41.5-cp311-cp311-win_arm64.whl", hash = "sha256:4bc36bbc0b7584de96561184ad7f012478987882ebf9f9c389b23f432ea3d90f", size = 1972902, upload-time = "2025-11-04T13:39:56.488Z" },
    { url = "https://files.pythonhosted.org/packages/5f/5d/5f6c63eebb5afee93bcaae4ce9a898f3373ca23df3ccaef086d0233a35a7/pydantic_core-2.41.5-cp312-cp312-macosx_10_12_x86_64.whl", hash = "sha256:f41a7489d32336dbf2199c8c0a215390a751c5b014c2c1c5366e817202e9cdf7", size = 2110990, upload-time = "2025-11-04T13:39:58.079Z" },
    { url = "https://files.pythonhosted.org/packages/aa/32/9c2e8ccb57c01111e0fd091f236c7b371c1bccea0fa85247ac55b1e2b6b6/pydantic_core-2.41.5-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:070259a8818988b9a84a449a2a7337c7f430a22acc0859c6b110aa7212a6d9c0", size = 1896003, upload-time = "2025-11-04T13:39:59.956Z" },
    { url = "https://files.pythonhosted.org/packages/68/b8/a01b53cb0e59139fbc9e4fda3e9724ede8de279097179be4ff31f1abb65a/pydantic_core-2.41.5-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:e96cea19e34778f8d59fe40775a7a574d95816eb150850a85a7a4c8f4b94ac69", size = 1919200, upload-time = "2025-11-04T13:40:02.241Z" },
    { url = "https://files.pythonhosted.org/packages/38/de/8c36b5198a29bdaade07b5985e80a233a5ac27137846f3bc2d3b40a47360/pydantic_core-2.41.5-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:ed2e99c456e3fadd05c991f8f437ef902e00eedf34320ba2b0842bd1c3ca3a75", size = 2052578, upload-time = "2025-11-04T13:40:04.401Z" },
    { url = "https://files.pythonhosted.org/packages/00/b5/0e8e4b5b081eac6cb3dbb7e60a65907549a1ce035a724368c330112adfdd/pydantic_core-2.41.5-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:65840751b72fbfd82c3c640cff9284545342a4f1eb1586ad0636955b261b0b05", size = 2208504, upload-time = "2025-11-04T13:40:06.072Z" },
    { url = "https://files.pythonhosted.org/packages/77/56/87a61aad59c7c5b9dc8caad5a41a5545cba3810c3e828708b3d7404f6cef/pydantic_core-2.41.5-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:e536c98a7626a98feb2d3eaf75944ef6f3dbee447e1f841eae16f2f0a72d8ddc", size = 2335816, upload-time = "2025-11-04T13:40:07.835Z" },
    { url = "https://files.pythonhosted.org/packages/0d/76/941cc9f73529988688a665a5c0ecff1112b3d95ab48f81db5f7606f522d3/pydantic_core-2.41.5-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:eceb81a8d74f9267ef4081e246ffd6d129da5d87e37a77c9bde550cb04870c1c", size = 2075366, upload-time = "2025-11-04T13:40:09.804Z" },
    { url = "https://files.pythonhosted.org/packages/d3/43/ebef01f69baa07a482844faaa0a591bad1ef129253ffd0cdaa9d8a7f72d3/pydantic_core-2.41.5-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:d38548150c39b74aeeb0ce8ee1d8e82696f4a4e16ddc6de7b1d8823f7de4b9b5", size = 2171698, upload-time = "2025-11-04T13:40:12.004Z" },
    { url = "https://files.pythonhosted.org/packages/b1/87/41f3202e4193e3bacfc2c065fab7706ebe81af46a83d3e27605029c1f5a6/pydantic_core-2.41.5-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:c23e27686783f60290e36827f9c626e63154b82b116d7fe9adba1fda36da706c", size = 2132603, upload-time = "2025-11-04T13:40:13.868Z" },
    { url = "https://files.pythonhosted.org/packages/49/7d/4c00df99cb12070b6bccdef4a195255e6020a550d572768d92cc54dba91a/pydantic_core-2.41.5-cp312-cp312-musllinux_1_1_armv7l.whl", hash = "sha256:482c982f814460eabe1d3bb0adfdc583387bd4691ef00b90575ca0d2b6fe2294", size = 2329591, upload-time = "2025-11-04T13:40:15.672Z" },
    { url = "https://files.pythonhosted.org/packages/cc/6a/ebf4b1d65d458f3cda6a7335d141305dfa19bdc61140a884d165a8a1bbc7/pydantic_core-2.41.5-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:bfea2a5f0b4d8d43adf9d7b8bf019fb46fdd10a2e5cde477fbcb9d1fa08c68e1", size = 2319068, upload-time = "2025-11-04T13:40:17.532Z" },
    { url = "https://files.pythonhosted.org/packages/49/3b/774f2b5cd4192d5ab75870ce4381fd89cf218af999515baf07e7206753f0/pydantic_core-2.41.5-cp312-cp312-win32.whl", hash = "sha256:b74557b16e390ec12dca509bce9264c3bbd128f8a2c376eaa68003d7f327276d", size = 1985908, upload-time = "2025-11-04T13:40:19.309Z" },
    { url = "https://files.pythonhosted.org/packages/86/45/00173a033c801cacf67c190fef088789394feaf88a98a7035b0e40d53dc9/pydantic_core-2.41.5-cp312-cp312-win_amd64.whl", hash = "sha256:1962293292865bca8e54702b08a4f26da73adc83dd1fcf26fbc875b35d81c815", size = 2020145, upload-time = "2025-11-04T13:40:21.548Z" },
    { url = "https://files.pythonhosted.org/packages/f9/22/91fbc821fa6d261b376a3f73809f907cec5ca6025642c463d3488aad22fb/pydantic_core-2.41.5-cp312-cp312-win_arm64.whl", hash = "sha256:1746d4a3d9a794cacae06a5eaaccb4b8643a131d45fbc9af23e353dc0a5ba5c3", size = 1976179, upload-time = "2025-11-04T13:40:23.393Z" },
    { url = "https://files.pythonhosted.org/packages/87/06/8806241ff1f70d9939f9af039c6c35f2360cf16e93c2ca76f184e76b1564/pydantic_core-2.41.5-cp313-cp313-macosx_10_12_x86_64.whl", hash = "sha256:941103c9be18ac8daf7b7adca8228f8ed6bb7a1849020f643b3a14d15b1924d9", size = 2120403, upload-time = "2025-11-04T13:40:25.248Z" },
    { url = "https://files.pythonhosted.org/packages/94/02/abfa0e0bda67faa65fef1c84971c7e45928e108fe24333c81f3bfe35d5f5/pydantic_core-2.41.5-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:112e305c3314f40c93998e567879e887a3160bb8689ef3d2c04b6cc62c33ac34", size = 1896206, upload-time = "2025-11-04T13:40:27.099Z" },
    { url = "https://files.pythonhosted.org/packages/15/df/a4c740c0943e93e6500f9eb23f4ca7ec9bf71b19e608ae5b579678c8d02f/pydantic_core-2.41.5-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0cbaad15cb0c90aa221d43c00e77bb33c93e8d36e0bf74760cd00e732d10a6a0", size = 1919307, upload-time = "2025-11-04T13:40:29.806Z" },
    { url = "https://files.pythonhosted.org/packages/9a/e3/6324802931ae1d123528988e0e86587c2072ac2e5394b4bc2bc34b61ff6e/pydantic_core-2.41.5-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:03ca43e12fab6023fc79d28ca6b39b05f794ad08ec2feccc59a339b02f2b3d33", size = 2063258, upload-time = "2025-11-04T13:40:33.544Z" },
    { url = "https://files.pythonhosted.org/packages/c9/d4/2230d7151d4957dd79c3044ea26346c148c98fbf0ee6ebd41056f2d62ab5/pydantic_core-2.41.5-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:dc799088c08fa04e43144b164feb0c13f9a0bc40503f8df3e9fde58a3c0c101e", size = 2214917, upload-time = "2025-11-04T13:40:35.479Z" },
    { url = "https://files.pythonhosted.org/packages/e6/9f/eaac5df17a3672fef0081b6c1bb0b82b33ee89aa5cec0d7b05f52fd4a1fa/pydantic_core-2.41.5-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:97aeba56665b4c3235a0e52b2c2f5ae9cd071b8a8310ad27bddb3f7fb30e9aa2", size = 2332186, upload-time = "2025-11-04T13:40:37.436Z" },
    { url = "https://files.pythonhosted.org/packages/cf/4e/35a80cae583a37cf15604b44240e45c05e04e86f9cfd766623149297e971/pydantic_core-2.41.5-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:406bf18d345822d6c21366031003612b9c77b3e29ffdb0f612367352aab7d586", size = 2073164, upload-time = "2025-11-04T13:40:40.289Z" },
    { url = "https://files.pythonhosted.org/packages/bf/e3/f6e262673c6140dd3305d144d032f7bd5f7497d3871c1428521f19f9efa2/pydantic_core-2.41.5-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:b93590ae81f7010dbe380cdeab6f515902ebcbefe0b9327cc4804d74e93ae69d", size = 2179146, upload-time = "2025-11-04T13:40:42.809Z" },
    { url = "https://files.pythonhosted.org/packages/75/c7/20bd7fc05f0c6ea2056a4565c6f36f8968c0924f19b7d97bbfea55780e73/pydantic_core-2.41.5-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:01a3d0ab748ee531f4ea6c3e48ad9dac84ddba4b0d82291f87248f2f9de8d740", size = 2137788, upload-time = "2025-11-04T13:40:44.752Z" },
    { url = "https://files.pythonhosted.org/packages/3a/8d/34318ef985c45196e004bc46c6eab2eda437e744c124ef0dbe1ff2c9d06b/pydantic_core-2.41.5-cp313-cp313-musllinux_1_1_armv7l.whl", hash = "sha256:6561e94ba9dacc9c61bce40e2d6bdc3bfaa0259d3ff36ace3b1e6901936d2e3e", size = 2340133, upload-time = "2025-11-04T13:40:46.66Z" },
    { url = "https://files.pythonhosted.org/packages/9c/59/013626bf8c78a5a5d9350d12e7697d3d4de951a75565496abd40ccd46bee/pydantic_core-2.41.5-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:915c3d10f81bec3a74fbd4faebe8391013ba61e5a1a8d48c4455b923bdda7858", size = 2324852, upload-time = "2025-11-04T13:40:48.575Z" },
    { url = "https://files.pythonhosted.org/packages/1a/d9/c248c103856f807ef70c18a4f986693a46a8ffe1602e5d361485da502d20/pydantic_core-2.41.5-cp313-cp313-win32.whl", hash = "sha256:650ae77860b45cfa6e2cdafc42618ceafab3a2d9a3811fcfbd3bbf8ac3c40d36", size = 1994679, upload-time = "2025-11-04T13:40:50.619Z" },
    { url = "https://files.pythonhosted.org/packages/9e/8b/341991b158ddab181cff136acd2552c9f35bd30380422a639c0671e99a91/pydantic_core-2.41.5-cp313-cp313-win_amd64.whl", hash = "sha256:79ec52ec461e99e13791ec6508c722742ad745571f234ea6255bed38c6480f11", size = 2019766, upload-time = "2025-11-04T13:40:52.631Z" },
    { url = "https://files.pythonhosted.org/packages/73/7d/f2f9db34af103bea3e09735bb40b021788a5e834c81eedb541991badf8f5/pydantic_core-2.41.5-cp313-cp313-win_arm64.whl", hash = "sha256:3f84d5c1b4ab906093bdc1ff10484838aca54ef08de4afa9de0f5f14d69639cd", size = 1981005, upload-time = "2025-11-04T13:40:54.734Z" },
    { url = "https://files.pythonhosted.org/packages/11/72/90fda5ee3b97e51c494938a4a44c3a35a9c96c19bba12372fb9c634d6f57/pydantic_core-2.41.5-graalpy311-graalpy242_311_native-macosx_10_12_x86_64.whl", hash = "sha256:b96d5f26b05d03cc60f11a7761a5ded1741da411e7fe0909e27a5e6a0cb7b034", size = 2115441, upload-time = "2025-11-04T13:42:39.557Z" },
    { url = "https://files.pythonhosted.org/packages/1f/53/8942f884fa33f50794f119012dc6a1a02ac43a56407adaac20463df8e98f/pydantic_core-2.41.5-graalpy311-graalpy242_311_native-macosx_11_0_arm64.whl", hash = "sha256:634e8609e89ceecea15e2d61bc9ac3718caaaa71963717bf3c8f38bfde64242c", size = 1930291, upload-time = "2025-11-04T13:42:42.169Z" },
    { url = "https://files.pythonhosted.org/packages/79/c8/ecb9ed9cd942bce09fc888ee960b52654fbdbede4ba6c2d6e0d3b1d8b49c/pydantic_core-2.41.5-graalpy311-graalpy242_311_native-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:93e8740d7503eb008aa2df04d3b9735f845d43ae845e6dcd2be0b55a2da43cd2", size = 1948632, upload-time = "2025-11-04T13:42:44.564Z" },
    { url = "https://files.pythonhosted.org/packages/2e/1b/687711069de7efa6af934e74f601e2a4307365e8fdc404703afc453eab26/pydantic_core-2.41.5-graalpy311-graalpy242_311_native-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:f15489ba13d61f670dcc96772e733aad1a6f9c429cc27574c6cdaed82d0146ad", size = 2138905, upload-time = "2025-11-04T13:42:47.156Z" },
    { url = "https://files.pythonhosted.org/packages/09/32/59b0c7e63e277fa7911c2fc70ccfb45ce4b98991e7ef37110663437005af/pydantic_core-2.41.5-graalpy312-graalpy250_312_native-macosx_10_12_x86_64.whl", hash = "sha256:7da7087d756b19037bc2c06edc6c170eeef3c3bafcb8f532ff17d64dc427adfd", size = 2110495, upload-time = "2025-11-04T13:42:49.689Z" },
    { url = "https://files.pythonhosted.org/packages/aa/81/05e400037eaf55ad400bcd318c05bb345b57e708887f07ddb2d20e3f0e98/pydantic_core-2.41.5-graalpy312-graalpy250_312_native-macosx_11_0_arm64.whl", hash = "sha256:aabf5777b5c8ca26f7824cb4a120a740c9588ed58df9b2d196ce92fba42ff8dc", size = 1915388, upload-time = "2025-11-04T13:42:52.215Z" },
    { url = "https://files.pythonhosted.org/packages/6e/0d/e3549b2399f71d56476b77dbf3cf8937cec5cd70536bdc0e374a421d0599/pydantic_core-2.41.5-graalpy312-graalpy250_312_native-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c007fe8a43d43b3969e8469004e9845944f1a80e6acd47c150856bb87f230c56", size = 1942879, upload-time = "2025-11-04T13:42:56.483Z" },
    { url = "https://files.pythonhosted.org/packages/f7/07/34573da085946b6a313d7c42f82f16e8920bfd730665de2d11c0c37a74b5/pydantic_core-2.41.5-graalpy312-graalpy250_312_native-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:76d0819de158cd855d1cbb8fcafdf6f5cf1eb8e470abe056d5d161106e38062b", size = 2139017, upload-time = "2025-11-04T13:42:59.471Z" },
    { url = "https://files.pythonhosted.org/packages/5f/9b/1b3f0e9f9305839d7e84912f9e8bfbd191ed1b1ef48083609f0dabde978c/pydantic_core-2.41.5-pp311-pypy311_pp73-macosx_10_12_x86_64.whl", hash = "sha256:b2379fa7ed44ddecb5bfe4e48577d752db9fc10be00a6b7446e9663ba143de26", size = 2101980, upload-time = "2025-11-04T13:43:25.97Z" },
    { url = "https://files.pythonhosted.org/packages/a4/ed/d71fefcb4263df0da6a85b5d8a7508360f2f2e9b3bf5814be9c8bccdccc1/pydantic_core-2.41.5-pp311-pypy311_pp73-macosx_11_0_arm64.whl", hash = "sha256:266fb4cbf5e3cbd0b53669a6d1b039c45e3ce651fd5442eff4d07c2cc8d66808", size = 1923865, upload-time = "2025-11-04T13:43:28.763Z" },
    { url = "https://files.pythonhosted.org/packages/ce/3a/626b38db460d675f873e4444b4bb030453bbe7b4ba55df821d026a0493c4/pydantic_core-2.41.5-pp311-pypy311_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:58133647260ea01e4d0500089a8c4f07bd7aa6ce109682b1426394988d8aaacc", size = 2134256, upload-time = "2025-11-04T13:43:31.71Z" },
    { url = "https://files.pythonhosted.org/packages/83/d9/8412d7f06f616bbc053d30cb4e5f76786af3221462ad5eee1f202021eb4e/pydantic_core-2.41.5-pp311-pypy311_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:287dad91cfb551c363dc62899a80e9e14da1f0e2b6ebde82c806612ca2a13ef1", size = 2174762, upload-time = "2025-11-04T13:43:34.744Z" },
    { url = "https://files.pythonhosted.org/packages/55/4c/162d906b8e3ba3a99354e20faa1b49a85206c47de97a639510a0e673f5da/pydantic_core-2.41.5-pp311-pypy311_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:03b77d184b9eb40240ae9fd676ca364ce1085f203e1b1256f8ab9984dca80a84", size = 2143141, upload-time = "2025-11-04T13:43:37.701Z" },
    { url = "https://files.pythonhosted.org/packages/1f/f2/f11dd73284122713f5f89fc940f370d035fa8e1e078d446b3313955157fe/pydantic_core-2.41.5-pp311-pypy311_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:a668ce24de96165bb239160b3d854943128f4334822900534f2fe947930e5770", size = 2330317, upload-time = "2025-11-04T13:43:40.406Z" },
    { url = "https://files.pythonhosted.org/packages/88/9d/b06ca6acfe4abb296110fb1273a4d848a0bfb2ff65f3ee92127b3244e16b/pydantic_core-2.41.5-pp311-pypy311_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:f14f8f046c14563f8eb3f45f499cc658ab8d10072961e07225e507adb700e93f", size = 2316992, upload-time = "2025-11-04T13:43:43.602Z" },
    { url = "https://files.pythonhosted.org/packages/36/c7/cfc8e811f061c841d7990b0201912c3556bfeb99cdcb7ed24adc8d6f8704/pydantic_core-2.41.5-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:56121965f7a4dc965bff783d70b907ddf3d57f6eba29b6d2e5dabfaf07799c51", size = 2145302, upload-time = "2025-11-04T13:43:46.64Z" },
]

[[package]]
name = "pydantic-settings"
version = "2.12.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "pydantic" },
    { name = "python-dotenv" },
    { name = "typing-inspection" },
]
sdist = { url = "https://files.pythonhosted.org/packages/43/4b/ac7e0aae12027748076d72a8764ff1c9d82ca75a7a52622e67ed3f765c54/pydantic_settings-2.12.0.tar.gz", hash = "sha256:005538ef951e3c2a68e1c08b292b5f2e71490def8589d4221b95dab00dafcfd0", size = 194184, upload-time = "2025-11-10T14:25:47.013Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c1/60/5d4751ba3f4a40a6891f24eec885f51afd78d208498268c734e256fb13c4/pydantic_settings-2.12.0-py3-none-any.whl", hash = "sha256:fddb9fd99a5b18da837b29710391e945b1e30c135477f484084ee513adb93809", size = 51880, upload-time = "2025-11-10T14:25:45.546Z" },
]

[[package]]
name = "pyelftools"
version = "0.32"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b9/ab/33968940b2deb3d92f5b146bc6d4009a5f95d1d06c148ea2f9ee965071af/pyelftools-0.32.tar.gz", hash = "sha256:6de90ee7b8263e740c8715a925382d4099b354f29ac48ea40d840cf7aa14ace5", size = 15047199, upload-time = "2025-02-19T14:20:05.549Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/af/43/700932c4f0638c3421177144a2e86448c0d75dbaee2c7936bda3f9fd0878/pyelftools-0.32-py3-none-any.whl", hash = "sha256:013df952a006db5e138b1edf6d8a68ecc50630adbd0d83a2d41e7f846163d738", size = 188525, upload-time = "2025-02-19T14:19:59.919Z" },
]

[[package]]
name = "pygments"
version = "2.19.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b0/77/a5b8c569bf593b0140bde72ea885a803b82086995367bf2037de0159d924/pygments-2.19.2.tar.gz", hash = "sha256:636cb2477cec7f8952536970bc533bc43743542f70392ae026374600add5b887", size = 4968631, upload-time = "2025-06-21T13:39:12.283Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c7/21/705964c7812476f378728bdf590ca4b771ec72385c533964653c68e86bdc/pygments-2.19.2-py3-none-any.whl", hash = "sha256:86540386c03d588bb81d44bc3928634ff26449851e99741617ecb9037ee5ec0b", size = 1225217, upload-time = "2025-06-21T13:39:07.939Z" },
]

[[package]]
name = "pyjwt"
version = "2.10.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e7/46/bd74733ff231675599650d3e47f361794b22ef3e3770998dda30d3b63726/pyjwt-2.10.1.tar.gz", hash = "sha256:3cc5772eb20009233caf06e9d8a0577824723b44e6648ee0a2aedb6cf9381953", size = 87785, upload-time = "2024-11-28T03:43:29.933Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/61/ad/689f02752eeec26aed679477e80e632ef1b682313be70793d798c1d5fc8f/PyJWT-2.10.1-py3-none-any.whl", hash = "sha256:dcdd193e30abefd5debf142f9adfcdd2b58004e644f25406ffaebd50bd98dacb", size = 22997, upload-time = "2024-11-28T03:43:27.893Z" },
]

[package.optional-dependencies]
crypto = [
    { name = "cryptography" },
]

[[package]]
name = "pypdf"
version = "6.7.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/10/45/8340de1c752bfda2da912ea0fa8c9a432f7de3f6315e82f1c0847811dff6/pypdf-6.7.0.tar.gz", hash = "sha256:eb95e244d9f434e6cfd157272283339ef586e593be64ee699c620f756d5c3f7e", size = 5299947, upload-time = "2026-02-08T14:47:11.897Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ed/f1/c92e75a0eb18bb10845e792054ded113010de958b6d4998e201c029417bb/pypdf-6.7.0-py3-none-any.whl", hash = "sha256:62e85036d50839cbdf45b8067c2c1a1b925517514d7cba4cbe8755a6c2829bc9", size = 330557, upload-time = "2026-02-08T14:47:10.111Z" },
]

[[package]]
name = "pystache"
version = "0.6.8"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/85/89/0a712ca22930b8c71bced8703e5bb45669c31690ea81afe15f6cb284550c/pystache-0.6.8.tar.gz", hash = "sha256:3707518e6a4d26dd189b07c10c669b1fc17df72684617c327bd3550e7075c72c", size = 101892, upload-time = "2025-03-18T11:54:47.595Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/fa/78/ffd13a516219129cef6a754a11ba2a1c0d69f1e281af4f6bca9ed5327219/pystache-0.6.8-py3-none-any.whl", hash = "sha256:7211e000974a6e06bce2d4d5cad8df03bcfffefd367209117376e4527a1c3cb8", size = 82051, upload-time = "2025-03-18T11:54:45.813Z" },
]

[[package]]
name = "python-dateutil"
version = "2.9.0.post0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "six" },
]
sdist = { url = "https://files.pythonhosted.org/packages/66/c0/0c8b6ad9f17a802ee498c46e004a0eb49bc148f2fd230864601a86dcf6db/python-dateutil-2.9.0.post0.tar.gz", hash = "sha256:37dd54208da7e1cd875388217d5e00ebd4179249f90fb72437e91a35459a0ad3", size = 342432, upload-time = "2024-03-01T18:36:20.211Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ec/57/56b9bcc3c9c6a792fcbaf139543cee77261f3651ca9da0c93f5c1221264b/python_dateutil-2.9.0.post0-py2.py3-none-any.whl", hash = "sha256:a8b2bc7bffae282281c8140a97d3aa9c14da0b136dfe83f850eea9a5f7470427", size = 229892, upload-time = "2024-03-01T18:36:18.57Z" },
]

[[package]]
name = "python-dotenv"
version = "1.2.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f0/26/19cadc79a718c5edbec86fd4919a6b6d3f681039a2f6d66d14be94e75fb9/python_dotenv-1.2.1.tar.gz", hash = "sha256:42667e897e16ab0d66954af0e60a9caa94f0fd4ecf3aaf6d2d260eec1aa36ad6", size = 44221, upload-time = "2025-10-26T15:12:10.434Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/14/1b/a298b06749107c305e1fe0f814c6c74aea7b2f1e10989cb30f544a1b3253/python_dotenv-1.2.1-py3-none-any.whl", hash = "sha256:b81ee9561e9ca4004139c6cbba3a238c32b03e4894671e181b671e8cb8425d61", size = 21230, upload-time = "2025-10-26T15:12:09.109Z" },
]

[[package]]
name = "python-multipart"
version = "0.0.22"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/94/01/979e98d542a70714b0cb2b6728ed0b7c46792b695e3eaec3e20711271ca3/python_multipart-0.0.22.tar.gz", hash = "sha256:7340bef99a7e0032613f56dc36027b959fd3b30a787ed62d310e951f7c3a3a58", size = 37612, upload-time = "2026-01-25T10:15:56.219Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1b/d0/397f9626e711ff749a95d96b7af99b9c566a9bb5129b8e4c10fc4d100304/python_multipart-0.0.22-py3-none-any.whl", hash = "sha256:2b2cd894c83d21bf49d702499531c7bafd057d730c201782048f7945d82de155", size = 24579, upload-time = "2026-01-25T10:15:54.811Z" },
]

[[package]]
name = "pytokens"
version = "0.3.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/4e/8d/a762be14dae1c3bf280202ba3172020b2b0b4c537f94427435f19c413b72/pytokens-0.3.0.tar.gz", hash = "sha256:2f932b14ed08de5fcf0b391ace2642f858f1394c0857202959000b68ed7a458a", size = 17644, upload-time = "2025-11-05T13:36:35.34Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/84/25/d9db8be44e205a124f6c98bc0324b2bb149b7431c53877fc6d1038dddaf5/pytokens-0.3.0-py3-none-any.whl", hash = "sha256:95b2b5eaf832e469d141a378872480ede3f251a5a5041b8ec6e581d3ac71bbf3", size = 12195, upload-time = "2025-11-05T13:36:33.183Z" },
]

[[package]]
name = "pytz"
version = "2025.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f8/bf/abbd3cdfb8fbc7fb3d4d38d320f2441b1e7cbe29be4f23797b4a2b5d8aac/pytz-2025.2.tar.gz", hash = "sha256:360b9e3dbb49a209c21ad61809c7fb453643e048b38924c765813546746e81c3", size = 320884, upload-time = "2025-03-25T02:25:00.538Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/81/c4/34e93fe5f5429d7570ec1fa436f1986fb1f00c3e0f43a589fe2bbcd22c3f/pytz-2025.2-py2.py3-none-any.whl", hash = "sha256:5ddf76296dd8c44c26eb8f4b6f35488f3ccbf6fbbd7adee0b7262d43f0ec2f00", size = 509225, upload-time = "2025-03-25T02:24:58.468Z" },
]

[[package]]
name = "pywin32"
version = "311"
source = { registry = "https://pypi.org/simple" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7c/af/449a6a91e5d6db51420875c54f6aff7c97a86a3b13a0b4f1a5c13b988de3/pywin32-311-cp311-cp311-win32.whl", hash = "sha256:184eb5e436dea364dcd3d2316d577d625c0351bf237c4e9a5fabbcfa5a58b151", size = 8697031, upload-time = "2025-07-14T20:13:13.266Z" },
    { url = "https://files.pythonhosted.org/packages/51/8f/9bb81dd5bb77d22243d33c8397f09377056d5c687aa6d4042bea7fbf8364/pywin32-311-cp311-cp311-win_amd64.whl", hash = "sha256:3ce80b34b22b17ccbd937a6e78e7225d80c52f5ab9940fe0506a1a16f3dab503", size = 9508308, upload-time = "2025-07-14T20:13:15.147Z" },
    { url = "https://files.pythonhosted.org/packages/44/7b/9c2ab54f74a138c491aba1b1cd0795ba61f144c711daea84a88b63dc0f6c/pywin32-311-cp311-cp311-win_arm64.whl", hash = "sha256:a733f1388e1a842abb67ffa8e7aad0e70ac519e09b0f6a784e65a136ec7cefd2", size = 8703930, upload-time = "2025-07-14T20:13:16.945Z" },
    { url = "https://files.pythonhosted.org/packages/e7/ab/01ea1943d4eba0f850c3c61e78e8dd59757ff815ff3ccd0a84de5f541f42/pywin32-311-cp312-cp312-win32.whl", hash = "sha256:750ec6e621af2b948540032557b10a2d43b0cee2ae9758c54154d711cc852d31", size = 8706543, upload-time = "2025-07-14T20:13:20.765Z" },
    { url = "https://files.pythonhosted.org/packages/d1/a8/a0e8d07d4d051ec7502cd58b291ec98dcc0c3fff027caad0470b72cfcc2f/pywin32-311-cp312-cp312-win_amd64.whl", hash = "sha256:b8c095edad5c211ff31c05223658e71bf7116daa0ecf3ad85f3201ea3190d067", size = 9495040, upload-time = "2025-07-14T20:13:22.543Z" },
    { url = "https://files.pythonhosted.org/packages/ba/3a/2ae996277b4b50f17d61f0603efd8253cb2d79cc7ae159468007b586396d/pywin32-311-cp312-cp312-win_arm64.whl", hash = "sha256:e286f46a9a39c4a18b319c28f59b61de793654af2f395c102b4f819e584b5852", size = 8710102, upload-time = "2025-07-14T20:13:24.682Z" },
    { url = "https://files.pythonhosted.org/packages/a5/be/3fd5de0979fcb3994bfee0d65ed8ca9506a8a1260651b86174f6a86f52b3/pywin32-311-cp313-cp313-win32.whl", hash = "sha256:f95ba5a847cba10dd8c4d8fefa9f2a6cf283b8b88ed6178fa8a6c1ab16054d0d", size = 8705700, upload-time = "2025-07-14T20:13:26.471Z" },
    { url = "https://files.pythonhosted.org/packages/e3/28/e0a1909523c6890208295a29e05c2adb2126364e289826c0a8bc7297bd5c/pywin32-311-cp313-cp313-win_amd64.whl", hash = "sha256:718a38f7e5b058e76aee1c56ddd06908116d35147e133427e59a3983f703a20d", size = 9494700, upload-time = "2025-07-14T20:13:28.243Z" },
    { url = "https://files.pythonhosted.org/packages/04/bf/90339ac0f55726dce7d794e6d79a18a91265bdf3aa70b6b9ca52f35e022a/pywin32-311-cp313-cp313-win_arm64.whl", hash = "sha256:7b4075d959648406202d92a2310cb990fea19b535c7f4a78d3f5e10b926eeb8a", size = 8709318, upload-time = "2025-07-14T20:13:30.348Z" },
]

[[package]]
name = "pyyaml"
version = "6.0.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/05/8e/961c0007c59b8dd7729d542c61a4d537767a59645b82a0b521206e1e25c2/pyyaml-6.0.3.tar.gz", hash = "sha256:d76623373421df22fb4cf8817020cbb7ef15c725b9d5e45f17e189bfc384190f", size = 130960, upload-time = "2025-09-25T21:33:16.546Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6d/16/a95b6757765b7b031c9374925bb718d55e0a9ba8a1b6a12d25962ea44347/pyyaml-6.0.3-cp311-cp311-macosx_10_13_x86_64.whl", hash = "sha256:44edc647873928551a01e7a563d7452ccdebee747728c1080d881d68af7b997e", size = 185826, upload-time = "2025-09-25T21:31:58.655Z" },
    { url = "https://files.pythonhosted.org/packages/16/19/13de8e4377ed53079ee996e1ab0a9c33ec2faf808a4647b7b4c0d46dd239/pyyaml-6.0.3-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:652cb6edd41e718550aad172851962662ff2681490a8a711af6a4d288dd96824", size = 175577, upload-time = "2025-09-25T21:32:00.088Z" },
    { url = "https://files.pythonhosted.org/packages/0c/62/d2eb46264d4b157dae1275b573017abec435397aa59cbcdab6fc978a8af4/pyyaml-6.0.3-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:10892704fc220243f5305762e276552a0395f7beb4dbf9b14ec8fd43b57f126c", size = 775556, upload-time = "2025-09-25T21:32:01.31Z" },
    { url = "https://files.pythonhosted.org/packages/10/cb/16c3f2cf3266edd25aaa00d6c4350381c8b012ed6f5276675b9eba8d9ff4/pyyaml-6.0.3-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:850774a7879607d3a6f50d36d04f00ee69e7fc816450e5f7e58d7f17f1ae5c00", size = 882114, upload-time = "2025-09-25T21:32:03.376Z" },
    { url = "https://files.pythonhosted.org/packages/71/60/917329f640924b18ff085ab889a11c763e0b573da888e8404ff486657602/pyyaml-6.0.3-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:b8bb0864c5a28024fac8a632c443c87c5aa6f215c0b126c449ae1a150412f31d", size = 806638, upload-time = "2025-09-25T21:32:04.553Z" },
    { url = "https://files.pythonhosted.org/packages/dd/6f/529b0f316a9fd167281a6c3826b5583e6192dba792dd55e3203d3f8e655a/pyyaml-6.0.3-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:1d37d57ad971609cf3c53ba6a7e365e40660e3be0e5175fa9f2365a379d6095a", size = 767463, upload-time = "2025-09-25T21:32:06.152Z" },
    { url = "https://files.pythonhosted.org/packages/f2/6a/b627b4e0c1dd03718543519ffb2f1deea4a1e6d42fbab8021936a4d22589/pyyaml-6.0.3-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:37503bfbfc9d2c40b344d06b2199cf0e96e97957ab1c1b546fd4f87e53e5d3e4", size = 794986, upload-time = "2025-09-25T21:32:07.367Z" },
    { url = "https://files.pythonhosted.org/packages/45/91/47a6e1c42d9ee337c4839208f30d9f09caa9f720ec7582917b264defc875/pyyaml-6.0.3-cp311-cp311-win32.whl", hash = "sha256:8098f252adfa6c80ab48096053f512f2321f0b998f98150cea9bd23d83e1467b", size = 142543, upload-time = "2025-09-25T21:32:08.95Z" },
    { url = "https://files.pythonhosted.org/packages/da/e3/ea007450a105ae919a72393cb06f122f288ef60bba2dc64b26e2646fa315/pyyaml-6.0.3-cp311-cp311-win_amd64.whl", hash = "sha256:9f3bfb4965eb874431221a3ff3fdcddc7e74e3b07799e0e84ca4a0f867d449bf", size = 158763, upload-time = "2025-09-25T21:32:09.96Z" },
    { url = "https://files.pythonhosted.org/packages/d1/33/422b98d2195232ca1826284a76852ad5a86fe23e31b009c9886b2d0fb8b2/pyyaml-6.0.3-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:7f047e29dcae44602496db43be01ad42fc6f1cc0d8cd6c83d342306c32270196", size = 182063, upload-time = "2025-09-25T21:32:11.445Z" },
    { url = "https://files.pythonhosted.org/packages/89/a0/6cf41a19a1f2f3feab0e9c0b74134aa2ce6849093d5517a0c550fe37a648/pyyaml-6.0.3-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:fc09d0aa354569bc501d4e787133afc08552722d3ab34836a80547331bb5d4a0", size = 173973, upload-time = "2025-09-25T21:32:12.492Z" },
    { url = "https://files.pythonhosted.org/packages/ed/23/7a778b6bd0b9a8039df8b1b1d80e2e2ad78aa04171592c8a5c43a56a6af4/pyyaml-6.0.3-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:9149cad251584d5fb4981be1ecde53a1ca46c891a79788c0df828d2f166bda28", size = 775116, upload-time = "2025-09-25T21:32:13.652Z" },
    { url = "https://files.pythonhosted.org/packages/65/30/d7353c338e12baef4ecc1b09e877c1970bd3382789c159b4f89d6a70dc09/pyyaml-6.0.3-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:5fdec68f91a0c6739b380c83b951e2c72ac0197ace422360e6d5a959d8d97b2c", size = 844011, upload-time = "2025-09-25T21:32:15.21Z" },
    { url = "https://files.pythonhosted.org/packages/8b/9d/b3589d3877982d4f2329302ef98a8026e7f4443c765c46cfecc8858c6b4b/pyyaml-6.0.3-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:ba1cc08a7ccde2d2ec775841541641e4548226580ab850948cbfda66a1befcdc", size = 807870, upload-time = "2025-09-25T21:32:16.431Z" },
    { url = "https://files.pythonhosted.org/packages/05/c0/b3be26a015601b822b97d9149ff8cb5ead58c66f981e04fedf4e762f4bd4/pyyaml-6.0.3-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:8dc52c23056b9ddd46818a57b78404882310fb473d63f17b07d5c40421e47f8e", size = 761089, upload-time = "2025-09-25T21:32:17.56Z" },
    { url = "https://files.pythonhosted.org/packages/be/8e/98435a21d1d4b46590d5459a22d88128103f8da4c2d4cb8f14f2a96504e1/pyyaml-6.0.3-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:41715c910c881bc081f1e8872880d3c650acf13dfa8214bad49ed4cede7c34ea", size = 790181, upload-time = "2025-09-25T21:32:18.834Z" },
    { url = "https://files.pythonhosted.org/packages/74/93/7baea19427dcfbe1e5a372d81473250b379f04b1bd3c4c5ff825e2327202/pyyaml-6.0.3-cp312-cp312-win32.whl", hash = "sha256:96b533f0e99f6579b3d4d4995707cf36df9100d67e0c8303a0c55b27b5f99bc5", size = 137658, upload-time = "2025-09-25T21:32:20.209Z" },
    { url = "https://files.pythonhosted.org/packages/86/bf/899e81e4cce32febab4fb42bb97dcdf66bc135272882d1987881a4b519e9/pyyaml-6.0.3-cp312-cp312-win_amd64.whl", hash = "sha256:5fcd34e47f6e0b794d17de1b4ff496c00986e1c83f7ab2fb8fcfe9616ff7477b", size = 154003, upload-time = "2025-09-25T21:32:21.167Z" },
    { url = "https://files.pythonhosted.org/packages/1a/08/67bd04656199bbb51dbed1439b7f27601dfb576fb864099c7ef0c3e55531/pyyaml-6.0.3-cp312-cp312-win_arm64.whl", hash = "sha256:64386e5e707d03a7e172c0701abfb7e10f0fb753ee1d773128192742712a98fd", size = 140344, upload-time = "2025-09-25T21:32:22.617Z" },
    { url = "https://files.pythonhosted.org/packages/d1/11/0fd08f8192109f7169db964b5707a2f1e8b745d4e239b784a5a1dd80d1db/pyyaml-6.0.3-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:8da9669d359f02c0b91ccc01cac4a67f16afec0dac22c2ad09f46bee0697eba8", size = 181669, upload-time = "2025-09-25T21:32:23.673Z" },
    { url = "https://files.pythonhosted.org/packages/b1/16/95309993f1d3748cd644e02e38b75d50cbc0d9561d21f390a76242ce073f/pyyaml-6.0.3-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:2283a07e2c21a2aa78d9c4442724ec1eb15f5e42a723b99cb3d822d48f5f7ad1", size = 173252, upload-time = "2025-09-25T21:32:25.149Z" },
    { url = "https://files.pythonhosted.org/packages/50/31/b20f376d3f810b9b2371e72ef5adb33879b25edb7a6d072cb7ca0c486398/pyyaml-6.0.3-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:ee2922902c45ae8ccada2c5b501ab86c36525b883eff4255313a253a3160861c", size = 767081, upload-time = "2025-09-25T21:32:26.575Z" },
    { url = "https://files.pythonhosted.org/packages/49/1e/a55ca81e949270d5d4432fbbd19dfea5321eda7c41a849d443dc92fd1ff7/pyyaml-6.0.3-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:a33284e20b78bd4a18c8c2282d549d10bc8408a2a7ff57653c0cf0b9be0afce5", size = 841159, upload-time = "2025-09-25T21:32:27.727Z" },
    { url = "https://files.pythonhosted.org/packages/74/27/e5b8f34d02d9995b80abcef563ea1f8b56d20134d8f4e5e81733b1feceb2/pyyaml-6.0.3-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:0f29edc409a6392443abf94b9cf89ce99889a1dd5376d94316ae5145dfedd5d6", size = 801626, upload-time = "2025-09-25T21:32:28.878Z" },
    { url = "https://files.pythonhosted.org/packages/f9/11/ba845c23988798f40e52ba45f34849aa8a1f2d4af4b798588010792ebad6/pyyaml-6.0.3-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:f7057c9a337546edc7973c0d3ba84ddcdf0daa14533c2065749c9075001090e6", size = 753613, upload-time = "2025-09-25T21:32:30.178Z" },
    { url = "https://files.pythonhosted.org/packages/3d/e0/7966e1a7bfc0a45bf0a7fb6b98ea03fc9b8d84fa7f2229e9659680b69ee3/pyyaml-6.0.3-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:eda16858a3cab07b80edaf74336ece1f986ba330fdb8ee0d6c0d68fe82bc96be", size = 794115, upload-time = "2025-09-25T21:32:31.353Z" },
    { url = "https://files.pythonhosted.org/packages/de/94/980b50a6531b3019e45ddeada0626d45fa85cbe22300844a7983285bed3b/pyyaml-6.0.3-cp313-cp313-win32.whl", hash = "sha256:d0eae10f8159e8fdad514efdc92d74fd8d682c933a6dd088030f3834bc8e6b26", size = 137427, upload-time = "2025-09-25T21:32:32.58Z" },
    { url = "https://files.pythonhosted.org/packages/97/c9/39d5b874e8b28845e4ec2202b5da735d0199dbe5b8fb85f91398814a9a46/pyyaml-6.0.3-cp313-cp313-win_amd64.whl", hash = "sha256:79005a0d97d5ddabfeeea4cf676af11e647e41d81c9a7722a193022accdb6b7c", size = 154090, upload-time = "2025-09-25T21:32:33.659Z" },
    { url = "https://files.pythonhosted.org/packages/73/e8/2bdf3ca2090f68bb3d75b44da7bbc71843b19c9f2b9cb9b0f4ab7a5a4329/pyyaml-6.0.3-cp313-cp313-win_arm64.whl", hash = "sha256:5498cd1645aa724a7c71c8f378eb29ebe23da2fc0d7a08071d89469bf1d2defb", size = 140246, upload-time = "2025-09-25T21:32:34.663Z" },
]

[[package]]
name = "referencing"
version = "0.37.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "attrs" },
    { name = "rpds-py" },
    { name = "typing-extensions", marker = "python_full_version < '3.13'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/22/f5/df4e9027acead3ecc63e50fe1e36aca1523e1719559c499951bb4b53188f/referencing-0.37.0.tar.gz", hash = "sha256:44aefc3142c5b842538163acb373e24cce6632bd54bdb01b21ad5863489f50d8", size = 78036, upload-time = "2025-10-13T15:30:48.871Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2c/58/ca301544e1fa93ed4f80d724bf5b194f6e4b945841c5bfd555878eea9fcb/referencing-0.37.0-py3-none-any.whl", hash = "sha256:381329a9f99628c9069361716891d34ad94af76e461dcb0335825aecc7692231", size = 26766, upload-time = "2025-10-13T15:30:47.625Z" },
]

[[package]]
name = "regex"
version = "2025.11.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/cc/a9/546676f25e573a4cf00fe8e119b78a37b6a8fe2dc95cda877b30889c9c45/regex-2025.11.3.tar.gz", hash = "sha256:1fedc720f9bb2494ce31a58a1631f9c82df6a09b49c19517ea5cc280b4541e01", size = 414669, upload-time = "2025-11-03T21:34:22.089Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f7/90/4fb5056e5f03a7048abd2b11f598d464f0c167de4f2a51aa868c376b8c70/regex-2025.11.3-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:eadade04221641516fa25139273505a1c19f9bf97589a05bc4cfcd8b4a618031", size = 488081, upload-time = "2025-11-03T21:31:11.946Z" },
    { url = "https://files.pythonhosted.org/packages/85/23/63e481293fac8b069d84fba0299b6666df720d875110efd0338406b5d360/regex-2025.11.3-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:feff9e54ec0dd3833d659257f5c3f5322a12eee58ffa360984b716f8b92983f4", size = 290554, upload-time = "2025-11-03T21:31:13.387Z" },
    { url = "https://files.pythonhosted.org/packages/2b/9d/b101d0262ea293a0066b4522dfb722eb6a8785a8c3e084396a5f2c431a46/regex-2025.11.3-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:3b30bc921d50365775c09a7ed446359e5c0179e9e2512beec4a60cbcef6ddd50", size = 288407, upload-time = "2025-11-03T21:31:14.809Z" },
    { url = "https://files.pythonhosted.org/packages/0c/64/79241c8209d5b7e00577ec9dca35cd493cc6be35b7d147eda367d6179f6d/regex-2025.11.3-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:f99be08cfead2020c7ca6e396c13543baea32343b7a9a5780c462e323bd8872f", size = 793418, upload-time = "2025-11-03T21:31:16.556Z" },
    { url = "https://files.pythonhosted.org/packages/3d/e2/23cd5d3573901ce8f9757c92ca4db4d09600b865919b6d3e7f69f03b1afd/regex-2025.11.3-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:6dd329a1b61c0ee95ba95385fb0c07ea0d3fe1a21e1349fa2bec272636217118", size = 860448, upload-time = "2025-11-03T21:31:18.12Z" },
    { url = "https://files.pythonhosted.org/packages/2a/4c/aecf31beeaa416d0ae4ecb852148d38db35391aac19c687b5d56aedf3a8b/regex-2025.11.3-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:4c5238d32f3c5269d9e87be0cf096437b7622b6920f5eac4fd202468aaeb34d2", size = 907139, upload-time = "2025-11-03T21:31:20.753Z" },
    { url = "https://files.pythonhosted.org/packages/61/22/b8cb00df7d2b5e0875f60628594d44dba283e951b1ae17c12f99e332cc0a/regex-2025.11.3-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:10483eefbfb0adb18ee9474498c9a32fcf4e594fbca0543bb94c48bac6183e2e", size = 800439, upload-time = "2025-11-03T21:31:22.069Z" },
    { url = "https://files.pythonhosted.org/packages/02/a8/c4b20330a5cdc7a8eb265f9ce593f389a6a88a0c5f280cf4d978f33966bc/regex-2025.11.3-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:78c2d02bb6e1da0720eedc0bad578049cad3f71050ef8cd065ecc87691bed2b0", size = 782965, upload-time = "2025-11-03T21:31:23.598Z" },
    { url = "https://files.pythonhosted.org/packages/b4/4c/ae3e52988ae74af4b04d2af32fee4e8077f26e51b62ec2d12d246876bea2/regex-2025.11.3-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:e6b49cd2aad93a1790ce9cffb18964f6d3a4b0b3dbdbd5de094b65296fce6e58", size = 854398, upload-time = "2025-11-03T21:31:25.008Z" },
    { url = "https://files.pythonhosted.org/packages/06/d1/a8b9cf45874eda14b2e275157ce3b304c87e10fb38d9fc26a6e14eb18227/regex-2025.11.3-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:885b26aa3ee56433b630502dc3d36ba78d186a00cc535d3806e6bfd9ed3c70ab", size = 845897, upload-time = "2025-11-03T21:31:26.427Z" },
    { url = "https://files.pythonhosted.org/packages/ea/fe/1830eb0236be93d9b145e0bd8ab499f31602fe0999b1f19e99955aa8fe20/regex-2025.11.3-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:ddd76a9f58e6a00f8772e72cff8ebcff78e022be95edf018766707c730593e1e", size = 788906, upload-time = "2025-11-03T21:31:28.078Z" },
    { url = "https://files.pythonhosted.org/packages/66/47/dc2577c1f95f188c1e13e2e69d8825a5ac582ac709942f8a03af42ed6e93/regex-2025.11.3-cp311-cp311-win32.whl", hash = "sha256:3e816cc9aac1cd3cc9a4ec4d860f06d40f994b5c7b4d03b93345f44e08cc68bf", size = 265812, upload-time = "2025-11-03T21:31:29.72Z" },
    { url = "https://files.pythonhosted.org/packages/50/1e/15f08b2f82a9bbb510621ec9042547b54d11e83cb620643ebb54e4eb7d71/regex-2025.11.3-cp311-cp311-win_amd64.whl", hash = "sha256:087511f5c8b7dfbe3a03f5d5ad0c2a33861b1fc387f21f6f60825a44865a385a", size = 277737, upload-time = "2025-11-03T21:31:31.422Z" },
    { url = "https://files.pythonhosted.org/packages/f4/fc/6500eb39f5f76c5e47a398df82e6b535a5e345f839581012a418b16f9cc3/regex-2025.11.3-cp311-cp311-win_arm64.whl", hash = "sha256:1ff0d190c7f68ae7769cd0313fe45820ba07ffebfddfaa89cc1eb70827ba0ddc", size = 270290, upload-time = "2025-11-03T21:31:33.041Z" },
    { url = "https://files.pythonhosted.org/packages/e8/74/18f04cb53e58e3fb107439699bd8375cf5a835eec81084e0bddbd122e4c2/regex-2025.11.3-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:bc8ab71e2e31b16e40868a40a69007bc305e1109bd4658eb6cad007e0bf67c41", size = 489312, upload-time = "2025-11-03T21:31:34.343Z" },
    { url = "https://files.pythonhosted.org/packages/78/3f/37fcdd0d2b1e78909108a876580485ea37c91e1acf66d3bb8e736348f441/regex-2025.11.3-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:22b29dda7e1f7062a52359fca6e58e548e28c6686f205e780b02ad8ef710de36", size = 291256, upload-time = "2025-11-03T21:31:35.675Z" },
    { url = "https://files.pythonhosted.org/packages/bf/26/0a575f58eb23b7ebd67a45fccbc02ac030b737b896b7e7a909ffe43ffd6a/regex-2025.11.3-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:3a91e4a29938bc1a082cc28fdea44be420bf2bebe2665343029723892eb073e1", size = 288921, upload-time = "2025-11-03T21:31:37.07Z" },
    { url = "https://files.pythonhosted.org/packages/ea/98/6a8dff667d1af907150432cf5abc05a17ccd32c72a3615410d5365ac167a/regex-2025.11.3-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:08b884f4226602ad40c5d55f52bf91a9df30f513864e0054bad40c0e9cf1afb7", size = 798568, upload-time = "2025-11-03T21:31:38.784Z" },
    { url = "https://files.pythonhosted.org/packages/64/15/92c1db4fa4e12733dd5a526c2dd2b6edcbfe13257e135fc0f6c57f34c173/regex-2025.11.3-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:3e0b11b2b2433d1c39c7c7a30e3f3d0aeeea44c2a8d0bae28f6b95f639927a69", size = 864165, upload-time = "2025-11-03T21:31:40.559Z" },
    { url = "https://files.pythonhosted.org/packages/f9/e7/3ad7da8cdee1ce66c7cd37ab5ab05c463a86ffeb52b1a25fe7bd9293b36c/regex-2025.11.3-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:87eb52a81ef58c7ba4d45c3ca74e12aa4b4e77816f72ca25258a85b3ea96cb48", size = 912182, upload-time = "2025-11-03T21:31:42.002Z" },
    { url = "https://files.pythonhosted.org/packages/84/bd/9ce9f629fcb714ffc2c3faf62b6766ecb7a585e1e885eb699bcf130a5209/regex-2025.11.3-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:a12ab1f5c29b4e93db518f5e3872116b7e9b1646c9f9f426f777b50d44a09e8c", size = 803501, upload-time = "2025-11-03T21:31:43.815Z" },
    { url = "https://files.pythonhosted.org/packages/7c/0f/8dc2e4349d8e877283e6edd6c12bdcebc20f03744e86f197ab6e4492bf08/regex-2025.11.3-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:7521684c8c7c4f6e88e35ec89680ee1aa8358d3f09d27dfbdf62c446f5d4c695", size = 787842, upload-time = "2025-11-03T21:31:45.353Z" },
    { url = "https://files.pythonhosted.org/packages/f9/73/cff02702960bc185164d5619c0c62a2f598a6abff6695d391b096237d4ab/regex-2025.11.3-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:7fe6e5440584e94cc4b3f5f4d98a25e29ca12dccf8873679a635638349831b98", size = 858519, upload-time = "2025-11-03T21:31:46.814Z" },
    { url = "https://files.pythonhosted.org/packages/61/83/0e8d1ae71e15bc1dc36231c90b46ee35f9d52fab2e226b0e039e7ea9c10a/regex-2025.11.3-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:8e026094aa12b43f4fd74576714e987803a315c76edb6b098b9809db5de58f74", size = 850611, upload-time = "2025-11-03T21:31:48.289Z" },
    { url = "https://files.pythonhosted.org/packages/c8/f5/70a5cdd781dcfaa12556f2955bf170cd603cb1c96a1827479f8faea2df97/regex-2025.11.3-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:435bbad13e57eb5606a68443af62bed3556de2f46deb9f7d4237bc2f1c9fb3a0", size = 789759, upload-time = "2025-11-03T21:31:49.759Z" },
    { url = "https://files.pythonhosted.org/packages/59/9b/7c29be7903c318488983e7d97abcf8ebd3830e4c956c4c540005fcfb0462/regex-2025.11.3-cp312-cp312-win32.whl", hash = "sha256:3839967cf4dc4b985e1570fd8d91078f0c519f30491c60f9ac42a8db039be204", size = 266194, upload-time = "2025-11-03T21:31:51.53Z" },
    { url = "https://files.pythonhosted.org/packages/1a/67/3b92df89f179d7c367be654ab5626ae311cb28f7d5c237b6bb976cd5fbbb/regex-2025.11.3-cp312-cp312-win_amd64.whl", hash = "sha256:e721d1b46e25c481dc5ded6f4b3f66c897c58d2e8cfdf77bbced84339108b0b9", size = 277069, upload-time = "2025-11-03T21:31:53.151Z" },
    { url = "https://files.pythonhosted.org/packages/d7/55/85ba4c066fe5094d35b249c3ce8df0ba623cfd35afb22d6764f23a52a1c5/regex-2025.11.3-cp312-cp312-win_arm64.whl", hash = "sha256:64350685ff08b1d3a6fff33f45a9ca183dc1d58bbfe4981604e70ec9801bbc26", size = 270330, upload-time = "2025-11-03T21:31:54.514Z" },
    { url = "https://files.pythonhosted.org/packages/e1/a7/dda24ebd49da46a197436ad96378f17df30ceb40e52e859fc42cac45b850/regex-2025.11.3-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:c1e448051717a334891f2b9a620fe36776ebf3dd8ec46a0b877c8ae69575feb4", size = 489081, upload-time = "2025-11-03T21:31:55.9Z" },
    { url = "https://files.pythonhosted.org/packages/19/22/af2dc751aacf88089836aa088a1a11c4f21a04707eb1b0478e8e8fb32847/regex-2025.11.3-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:9b5aca4d5dfd7fbfbfbdaf44850fcc7709a01146a797536a8f84952e940cca76", size = 291123, upload-time = "2025-11-03T21:31:57.758Z" },
    { url = "https://files.pythonhosted.org/packages/a3/88/1a3ea5672f4b0a84802ee9891b86743438e7c04eb0b8f8c4e16a42375327/regex-2025.11.3-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:04d2765516395cf7dda331a244a3282c0f5ae96075f728629287dfa6f76ba70a", size = 288814, upload-time = "2025-11-03T21:32:01.12Z" },
    { url = "https://files.pythonhosted.org/packages/fb/8c/f5987895bf42b8ddeea1b315c9fedcfe07cadee28b9c98cf50d00adcb14d/regex-2025.11.3-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:5d9903ca42bfeec4cebedba8022a7c97ad2aab22e09573ce9976ba01b65e4361", size = 798592, upload-time = "2025-11-03T21:32:03.006Z" },
    { url = "https://files.pythonhosted.org/packages/99/2a/6591ebeede78203fa77ee46a1c36649e02df9eaa77a033d1ccdf2fcd5d4e/regex-2025.11.3-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:639431bdc89d6429f6721625e8129413980ccd62e9d3f496be618a41d205f160", size = 864122, upload-time = "2025-11-03T21:32:04.553Z" },
    { url = "https://files.pythonhosted.org/packages/94/d6/be32a87cf28cf8ed064ff281cfbd49aefd90242a83e4b08b5a86b38e8eb4/regex-2025.11.3-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:f117efad42068f9715677c8523ed2be1518116d1c49b1dd17987716695181efe", size = 912272, upload-time = "2025-11-03T21:32:06.148Z" },
    { url = "https://files.pythonhosted.org/packages/62/11/9bcef2d1445665b180ac7f230406ad80671f0fc2a6ffb93493b5dd8cd64c/regex-2025.11.3-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:4aecb6f461316adf9f1f0f6a4a1a3d79e045f9b71ec76055a791affa3b285850", size = 803497, upload-time = "2025-11-03T21:32:08.162Z" },
    { url = "https://files.pythonhosted.org/packages/e5/a7/da0dc273d57f560399aa16d8a68ae7f9b57679476fc7ace46501d455fe84/regex-2025.11.3-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:3b3a5f320136873cc5561098dfab677eea139521cb9a9e8db98b7e64aef44cbc", size = 787892, upload-time = "2025-11-03T21:32:09.769Z" },
    { url = "https://files.pythonhosted.org/packages/da/4b/732a0c5a9736a0b8d6d720d4945a2f1e6f38f87f48f3173559f53e8d5d82/regex-2025.11.3-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:75fa6f0056e7efb1f42a1c34e58be24072cb9e61a601340cc1196ae92326a4f9", size = 858462, upload-time = "2025-11-03T21:32:11.769Z" },
    { url = "https://files.pythonhosted.org/packages/0c/f5/a2a03df27dc4c2d0c769220f5110ba8c4084b0bfa9ab0f9b4fcfa3d2b0fc/regex-2025.11.3-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:dbe6095001465294f13f1adcd3311e50dd84e5a71525f20a10bd16689c61ce0b", size = 850528, upload-time = "2025-11-03T21:32:13.906Z" },
    { url = "https://files.pythonhosted.org/packages/d6/09/e1cd5bee3841c7f6eb37d95ca91cdee7100b8f88b81e41c2ef426910891a/regex-2025.11.3-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:454d9b4ae7881afbc25015b8627c16d88a597479b9dea82b8c6e7e2e07240dc7", size = 789866, upload-time = "2025-11-03T21:32:15.748Z" },
    { url = "https://files.pythonhosted.org/packages/eb/51/702f5ea74e2a9c13d855a6a85b7f80c30f9e72a95493260193c07f3f8d74/regex-2025.11.3-cp313-cp313-win32.whl", hash = "sha256:28ba4d69171fc6e9896337d4fc63a43660002b7da53fc15ac992abcf3410917c", size = 266189, upload-time = "2025-11-03T21:32:17.493Z" },
    { url = "https://files.pythonhosted.org/packages/8b/00/6e29bb314e271a743170e53649db0fdb8e8ff0b64b4f425f5602f4eb9014/regex-2025.11.3-cp313-cp313-win_amd64.whl", hash = "sha256:bac4200befe50c670c405dc33af26dad5a3b6b255dd6c000d92fe4629f9ed6a5", size = 277054, upload-time = "2025-11-03T21:32:19.042Z" },
    { url = "https://files.pythonhosted.org/packages/25/f1/b156ff9f2ec9ac441710764dda95e4edaf5f36aca48246d1eea3f1fd96ec/regex-2025.11.3-cp313-cp313-win_arm64.whl", hash = "sha256:2292cd5a90dab247f9abe892ac584cb24f0f54680c73fcb4a7493c66c2bf2467", size = 270325, upload-time = "2025-11-03T21:32:21.338Z" },
    { url = "https://files.pythonhosted.org/packages/20/28/fd0c63357caefe5680b8ea052131acbd7f456893b69cc2a90cc3e0dc90d4/regex-2025.11.3-cp313-cp313t-macosx_10_13_universal2.whl", hash = "sha256:1eb1ebf6822b756c723e09f5186473d93236c06c579d2cc0671a722d2ab14281", size = 491984, upload-time = "2025-11-03T21:32:23.466Z" },
    { url = "https://files.pythonhosted.org/packages/df/ec/7014c15626ab46b902b3bcc4b28a7bae46d8f281fc7ea9c95e22fcaaa917/regex-2025.11.3-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:1e00ec2970aab10dc5db34af535f21fcf32b4a31d99e34963419636e2f85ae39", size = 292673, upload-time = "2025-11-03T21:32:25.034Z" },
    { url = "https://files.pythonhosted.org/packages/23/ab/3b952ff7239f20d05f1f99e9e20188513905f218c81d52fb5e78d2bf7634/regex-2025.11.3-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:a4cb042b615245d5ff9b3794f56be4138b5adc35a4166014d31d1814744148c7", size = 291029, upload-time = "2025-11-03T21:32:26.528Z" },
    { url = "https://files.pythonhosted.org/packages/21/7e/3dc2749fc684f455f162dcafb8a187b559e2614f3826877d3844a131f37b/regex-2025.11.3-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:44f264d4bf02f3176467d90b294d59bf1db9fe53c141ff772f27a8b456b2a9ed", size = 807437, upload-time = "2025-11-03T21:32:28.363Z" },
    { url = "https://files.pythonhosted.org/packages/1b/0b/d529a85ab349c6a25d1ca783235b6e3eedf187247eab536797021f7126c6/regex-2025.11.3-cp313-cp313t-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:7be0277469bf3bd7a34a9c57c1b6a724532a0d235cd0dc4e7f4316f982c28b19", size = 873368, upload-time = "2025-11-03T21:32:30.4Z" },
    { url = "https://files.pythonhosted.org/packages/7d/18/2d868155f8c9e3e9d8f9e10c64e9a9f496bb8f7e037a88a8bed26b435af6/regex-2025.11.3-cp313-cp313t-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:0d31e08426ff4b5b650f68839f5af51a92a5b51abd8554a60c2fbc7c71f25d0b", size = 914921, upload-time = "2025-11-03T21:32:32.123Z" },
    { url = "https://files.pythonhosted.org/packages/2d/71/9d72ff0f354fa783fe2ba913c8734c3b433b86406117a8db4ea2bf1c7a2f/regex-2025.11.3-cp313-cp313t-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:e43586ce5bd28f9f285a6e729466841368c4a0353f6fd08d4ce4630843d3648a", size = 812708, upload-time = "2025-11-03T21:32:34.305Z" },
    { url = "https://files.pythonhosted.org/packages/e7/19/ce4bf7f5575c97f82b6e804ffb5c4e940c62609ab2a0d9538d47a7fdf7d4/regex-2025.11.3-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:0f9397d561a4c16829d4e6ff75202c1c08b68a3bdbfe29dbfcdb31c9830907c6", size = 795472, upload-time = "2025-11-03T21:32:36.364Z" },
    { url = "https://files.pythonhosted.org/packages/03/86/fd1063a176ffb7b2315f9a1b08d17b18118b28d9df163132615b835a26ee/regex-2025.11.3-cp313-cp313t-musllinux_1_2_ppc64le.whl", hash = "sha256:dd16e78eb18ffdb25ee33a0682d17912e8cc8a770e885aeee95020046128f1ce", size = 868341, upload-time = "2025-11-03T21:32:38.042Z" },
    { url = "https://files.pythonhosted.org/packages/12/43/103fb2e9811205e7386366501bc866a164a0430c79dd59eac886a2822950/regex-2025.11.3-cp313-cp313t-musllinux_1_2_s390x.whl", hash = "sha256:ffcca5b9efe948ba0661e9df0fa50d2bc4b097c70b9810212d6b62f05d83b2dd", size = 854666, upload-time = "2025-11-03T21:32:40.079Z" },
    { url = "https://files.pythonhosted.org/packages/7d/22/e392e53f3869b75804762c7c848bd2dd2abf2b70fb0e526f58724638bd35/regex-2025.11.3-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:c56b4d162ca2b43318ac671c65bd4d563e841a694ac70e1a976ac38fcf4ca1d2", size = 799473, upload-time = "2025-11-03T21:32:42.148Z" },
    { url = "https://files.pythonhosted.org/packages/4f/f9/8bd6b656592f925b6845fcbb4d57603a3ac2fb2373344ffa1ed70aa6820a/regex-2025.11.3-cp313-cp313t-win32.whl", hash = "sha256:9ddc42e68114e161e51e272f667d640f97e84a2b9ef14b7477c53aac20c2d59a", size = 268792, upload-time = "2025-11-03T21:32:44.13Z" },
    { url = "https://files.pythonhosted.org/packages/e5/87/0e7d603467775ff65cd2aeabf1b5b50cc1c3708556a8b849a2fa4dd1542b/regex-2025.11.3-cp313-cp313t-win_amd64.whl", hash = "sha256:7a7c7fdf755032ffdd72c77e3d8096bdcb0eb92e89e17571a196f03d88b11b3c", size = 280214, upload-time = "2025-11-03T21:32:45.853Z" },
    { url = "https://files.pythonhosted.org/packages/8d/d0/2afc6f8e94e2b64bfb738a7c2b6387ac1699f09f032d363ed9447fd2bb57/regex-2025.11.3-cp313-cp313t-win_arm64.whl", hash = "sha256:df9eb838c44f570283712e7cff14c16329a9f0fb19ca492d21d4b7528ee6821e", size = 271469, upload-time = "2025-11-03T21:32:48.026Z" },
]

[[package]]
name = "requests"
version = "2.32.5"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "certifi" },
    { name = "charset-normalizer" },
    { name = "idna" },
    { name = "urllib3" },
]
sdist = { url = "https://files.pythonhosted.org/packages/c9/74/b3ff8e6c8446842c3f5c837e9c3dfcfe2018ea6ecef224c710c85ef728f4/requests-2.32.5.tar.gz", hash = "sha256:dbba0bac56e100853db0ea71b82b4dfd5fe2bf6d3754a8893c3af500cec7d7cf", size = 134517, upload-time = "2025-08-18T20:46:02.573Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1e/db/4254e3eabe8020b458f1a747140d32277ec7a271daf1d235b70dc0b4e6e3/requests-2.32.5-py3-none-any.whl", hash = "sha256:2462f94637a34fd532264295e186976db0f5d453d1cdd31473c85a6a161affb6", size = 64738, upload-time = "2025-08-18T20:46:00.542Z" },
]

[[package]]
name = "retry"
version = "0.9.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "decorator" },
    { name = "py" },
]
sdist = { url = "https://files.pythonhosted.org/packages/9d/72/75d0b85443fbc8d9f38d08d2b1b67cc184ce35280e4a3813cda2f445f3a4/retry-0.9.2.tar.gz", hash = "sha256:f8bfa8b99b69c4506d6f5bd3b0aabf77f98cdb17f3c9fc3f5ca820033336fba4", size = 6448, upload-time = "2016-05-11T13:58:51.541Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4b/0d/53aea75710af4528a25ed6837d71d117602b01946b307a3912cb3cfcbcba/retry-0.9.2-py2.py3-none-any.whl", hash = "sha256:ccddf89761fa2c726ab29391837d4327f819ea14d244c232a1d24c67a2f98606", size = 7986, upload-time = "2016-05-11T13:58:39.925Z" },
]

[[package]]
name = "rich"
version = "14.2.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markdown-it-py" },
    { name = "pygments" },
]
sdist = { url = "https://files.pythonhosted.org/packages/fb/d2/8920e102050a0de7bfabeb4c4614a49248cf8d5d7a8d01885fbb24dc767a/rich-14.2.0.tar.gz", hash = "sha256:73ff50c7c0c1c77c8243079283f4edb376f0f6442433aecb8ce7e6d0b92d1fe4", size = 219990, upload-time = "2025-10-09T14:16:53.064Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/25/7a/b0178788f8dc6cafce37a212c99565fa1fe7872c70c6c9c1e1a372d9d88f/rich-14.2.0-py3-none-any.whl", hash = "sha256:76bc51fe2e57d2b1be1f96c524b890b816e334ab4c1e45888799bfaab0021edd", size = 243393, upload-time = "2025-10-09T14:16:51.245Z" },
]

[[package]]
name = "rpds-py"
version = "0.30.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/20/af/3f2f423103f1113b36230496629986e0ef7e199d2aa8392452b484b38ced/rpds_py-0.30.0.tar.gz", hash = "sha256:dd8ff7cf90014af0c0f787eea34794ebf6415242ee1d6fa91eaba725cc441e84", size = 69469, upload-time = "2025-11-30T20:24:38.837Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4d/6e/f964e88b3d2abee2a82c1ac8366da848fce1c6d834dc2132c3fda3970290/rpds_py-0.30.0-cp311-cp311-macosx_10_12_x86_64.whl", hash = "sha256:a2bffea6a4ca9f01b3f8e548302470306689684e61602aa3d141e34da06cf425", size = 370157, upload-time = "2025-11-30T20:21:53.789Z" },
    { url = "https://files.pythonhosted.org/packages/94/ba/24e5ebb7c1c82e74c4e4f33b2112a5573ddc703915b13a073737b59b86e0/rpds_py-0.30.0-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:dc4f992dfe1e2bc3ebc7444f6c7051b4bc13cd8e33e43511e8ffd13bf407010d", size = 359676, upload-time = "2025-11-30T20:21:55.475Z" },
    { url = "https://files.pythonhosted.org/packages/84/86/04dbba1b087227747d64d80c3b74df946b986c57af0a9f0c98726d4d7a3b/rpds_py-0.30.0-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:422c3cb9856d80b09d30d2eb255d0754b23e090034e1deb4083f8004bd0761e4", size = 389938, upload-time = "2025-11-30T20:21:57.079Z" },
    { url = "https://files.pythonhosted.org/packages/42/bb/1463f0b1722b7f45431bdd468301991d1328b16cffe0b1c2918eba2c4eee/rpds_py-0.30.0-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:07ae8a593e1c3c6b82ca3292efbe73c30b61332fd612e05abee07c79359f292f", size = 402932, upload-time = "2025-11-30T20:21:58.47Z" },
    { url = "https://files.pythonhosted.org/packages/99/ee/2520700a5c1f2d76631f948b0736cdf9b0acb25abd0ca8e889b5c62ac2e3/rpds_py-0.30.0-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:12f90dd7557b6bd57f40abe7747e81e0c0b119bef015ea7726e69fe550e394a4", size = 525830, upload-time = "2025-11-30T20:21:59.699Z" },
    { url = "https://files.pythonhosted.org/packages/e0/ad/bd0331f740f5705cc555a5e17fdf334671262160270962e69a2bdef3bf76/rpds_py-0.30.0-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:99b47d6ad9a6da00bec6aabe5a6279ecd3c06a329d4aa4771034a21e335c3a97", size = 412033, upload-time = "2025-11-30T20:22:00.991Z" },
    { url = "https://files.pythonhosted.org/packages/f8/1e/372195d326549bb51f0ba0f2ecb9874579906b97e08880e7a65c3bef1a99/rpds_py-0.30.0-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:33f559f3104504506a44bb666b93a33f5d33133765b0c216a5bf2f1e1503af89", size = 390828, upload-time = "2025-11-30T20:22:02.723Z" },
    { url = "https://files.pythonhosted.org/packages/ab/2b/d88bb33294e3e0c76bc8f351a3721212713629ffca1700fa94979cb3eae8/rpds_py-0.30.0-cp311-cp311-manylinux_2_31_riscv64.whl", hash = "sha256:946fe926af6e44f3697abbc305ea168c2c31d3e3ef1058cf68f379bf0335a78d", size = 404683, upload-time = "2025-11-30T20:22:04.367Z" },
    { url = "https://files.pythonhosted.org/packages/50/32/c759a8d42bcb5289c1fac697cd92f6fe01a018dd937e62ae77e0e7f15702/rpds_py-0.30.0-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:495aeca4b93d465efde585977365187149e75383ad2684f81519f504f5c13038", size = 421583, upload-time = "2025-11-30T20:22:05.814Z" },
    { url = "https://files.pythonhosted.org/packages/2b/81/e729761dbd55ddf5d84ec4ff1f47857f4374b0f19bdabfcf929164da3e24/rpds_py-0.30.0-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:d9a0ca5da0386dee0655b4ccdf46119df60e0f10da268d04fe7cc87886872ba7", size = 572496, upload-time = "2025-11-30T20:22:07.713Z" },
    { url = "https://files.pythonhosted.org/packages/14/f6/69066a924c3557c9c30baa6ec3a0aa07526305684c6f86c696b08860726c/rpds_py-0.30.0-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:8d6d1cc13664ec13c1b84241204ff3b12f9bb82464b8ad6e7a5d3486975c2eed", size = 598669, upload-time = "2025-11-30T20:22:09.312Z" },
    { url = "https://files.pythonhosted.org/packages/5f/48/905896b1eb8a05630d20333d1d8ffd162394127b74ce0b0784ae04498d32/rpds_py-0.30.0-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:3896fa1be39912cf0757753826bc8bdc8ca331a28a7c4ae46b7a21280b06bb85", size = 561011, upload-time = "2025-11-30T20:22:11.309Z" },
    { url = "https://files.pythonhosted.org/packages/22/16/cd3027c7e279d22e5eb431dd3c0fbc677bed58797fe7581e148f3f68818b/rpds_py-0.30.0-cp311-cp311-win32.whl", hash = "sha256:55f66022632205940f1827effeff17c4fa7ae1953d2b74a8581baaefb7d16f8c", size = 221406, upload-time = "2025-11-30T20:22:13.101Z" },
    { url = "https://files.pythonhosted.org/packages/fa/5b/e7b7aa136f28462b344e652ee010d4de26ee9fd16f1bfd5811f5153ccf89/rpds_py-0.30.0-cp311-cp311-win_amd64.whl", hash = "sha256:a51033ff701fca756439d641c0ad09a41d9242fa69121c7d8769604a0a629825", size = 236024, upload-time = "2025-11-30T20:22:14.853Z" },
    { url = "https://files.pythonhosted.org/packages/14/a6/364bba985e4c13658edb156640608f2c9e1d3ea3c81b27aa9d889fff0e31/rpds_py-0.30.0-cp311-cp311-win_arm64.whl", hash = "sha256:47b0ef6231c58f506ef0b74d44e330405caa8428e770fec25329ed2cb971a229", size = 229069, upload-time = "2025-11-30T20:22:16.577Z" },
    { url = "https://files.pythonhosted.org/packages/03/e7/98a2f4ac921d82f33e03f3835f5bf3a4a40aa1bfdc57975e74a97b2b4bdd/rpds_py-0.30.0-cp312-cp312-macosx_10_12_x86_64.whl", hash = "sha256:a161f20d9a43006833cd7068375a94d035714d73a172b681d8881820600abfad", size = 375086, upload-time = "2025-11-30T20:22:17.93Z" },
    { url = "https://files.pythonhosted.org/packages/4d/a1/bca7fd3d452b272e13335db8d6b0b3ecde0f90ad6f16f3328c6fb150c889/rpds_py-0.30.0-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:6abc8880d9d036ecaafe709079969f56e876fcf107f7a8e9920ba6d5a3878d05", size = 359053, upload-time = "2025-11-30T20:22:19.297Z" },
    { url = "https://files.pythonhosted.org/packages/65/1c/ae157e83a6357eceff62ba7e52113e3ec4834a84cfe07fa4b0757a7d105f/rpds_py-0.30.0-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:ca28829ae5f5d569bb62a79512c842a03a12576375d5ece7d2cadf8abe96ec28", size = 390763, upload-time = "2025-11-30T20:22:21.661Z" },
    { url = "https://files.pythonhosted.org/packages/d4/36/eb2eb8515e2ad24c0bd43c3ee9cd74c33f7ca6430755ccdb240fd3144c44/rpds_py-0.30.0-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:a1010ed9524c73b94d15919ca4d41d8780980e1765babf85f9a2f90d247153dd", size = 408951, upload-time = "2025-11-30T20:22:23.408Z" },
    { url = "https://files.pythonhosted.org/packages/d6/65/ad8dc1784a331fabbd740ef6f71ce2198c7ed0890dab595adb9ea2d775a1/rpds_py-0.30.0-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:f8d1736cfb49381ba528cd5baa46f82fdc65c06e843dab24dd70b63d09121b3f", size = 514622, upload-time = "2025-11-30T20:22:25.16Z" },
    { url = "https://files.pythonhosted.org/packages/63/8e/0cfa7ae158e15e143fe03993b5bcd743a59f541f5952e1546b1ac1b5fd45/rpds_py-0.30.0-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:d948b135c4693daff7bc2dcfc4ec57237a29bd37e60c2fabf5aff2bbacf3e2f1", size = 414492, upload-time = "2025-11-30T20:22:26.505Z" },
    { url = "https://files.pythonhosted.org/packages/60/1b/6f8f29f3f995c7ffdde46a626ddccd7c63aefc0efae881dc13b6e5d5bb16/rpds_py-0.30.0-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:47f236970bccb2233267d89173d3ad2703cd36a0e2a6e92d0560d333871a3d23", size = 394080, upload-time = "2025-11-30T20:22:27.934Z" },
    { url = "https://files.pythonhosted.org/packages/6d/d5/a266341051a7a3ca2f4b750a3aa4abc986378431fc2da508c5034d081b70/rpds_py-0.30.0-cp312-cp312-manylinux_2_31_riscv64.whl", hash = "sha256:2e6ecb5a5bcacf59c3f912155044479af1d0b6681280048b338b28e364aca1f6", size = 408680, upload-time = "2025-11-30T20:22:29.341Z" },
    { url = "https://files.pythonhosted.org/packages/10/3b/71b725851df9ab7a7a4e33cf36d241933da66040d195a84781f49c50490c/rpds_py-0.30.0-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:a8fa71a2e078c527c3e9dc9fc5a98c9db40bcc8a92b4e8858e36d329f8684b51", size = 423589, upload-time = "2025-11-30T20:22:31.469Z" },
    { url = "https://files.pythonhosted.org/packages/00/2b/e59e58c544dc9bd8bd8384ecdb8ea91f6727f0e37a7131baeff8d6f51661/rpds_py-0.30.0-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:73c67f2db7bc334e518d097c6d1e6fed021bbc9b7d678d6cc433478365d1d5f5", size = 573289, upload-time = "2025-11-30T20:22:32.997Z" },
    { url = "https://files.pythonhosted.org/packages/da/3e/a18e6f5b460893172a7d6a680e86d3b6bc87a54c1f0b03446a3c8c7b588f/rpds_py-0.30.0-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:5ba103fb455be00f3b1c2076c9d4264bfcb037c976167a6047ed82f23153f02e", size = 599737, upload-time = "2025-11-30T20:22:34.419Z" },
    { url = "https://files.pythonhosted.org/packages/5c/e2/714694e4b87b85a18e2c243614974413c60aa107fd815b8cbc42b873d1d7/rpds_py-0.30.0-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:7cee9c752c0364588353e627da8a7e808a66873672bcb5f52890c33fd965b394", size = 563120, upload-time = "2025-11-30T20:22:35.903Z" },
    { url = "https://files.pythonhosted.org/packages/6f/ab/d5d5e3bcedb0a77f4f613706b750e50a5a3ba1c15ccd3665ecc636c968fd/rpds_py-0.30.0-cp312-cp312-win32.whl", hash = "sha256:1ab5b83dbcf55acc8b08fc62b796ef672c457b17dbd7820a11d6c52c06839bdf", size = 223782, upload-time = "2025-11-30T20:22:37.271Z" },
    { url = "https://files.pythonhosted.org/packages/39/3b/f786af9957306fdc38a74cef405b7b93180f481fb48453a114bb6465744a/rpds_py-0.30.0-cp312-cp312-win_amd64.whl", hash = "sha256:a090322ca841abd453d43456ac34db46e8b05fd9b3b4ac0c78bcde8b089f959b", size = 240463, upload-time = "2025-11-30T20:22:39.021Z" },
    { url = "https://files.pythonhosted.org/packages/f3/d2/b91dc748126c1559042cfe41990deb92c4ee3e2b415f6b5234969ffaf0cc/rpds_py-0.30.0-cp312-cp312-win_arm64.whl", hash = "sha256:669b1805bd639dd2989b281be2cfd951c6121b65e729d9b843e9639ef1fd555e", size = 230868, upload-time = "2025-11-30T20:22:40.493Z" },
    { url = "https://files.pythonhosted.org/packages/ed/dc/d61221eb88ff410de3c49143407f6f3147acf2538c86f2ab7ce65ae7d5f9/rpds_py-0.30.0-cp313-cp313-macosx_10_12_x86_64.whl", hash = "sha256:f83424d738204d9770830d35290ff3273fbb02b41f919870479fab14b9d303b2", size = 374887, upload-time = "2025-11-30T20:22:41.812Z" },
    { url = "https://files.pythonhosted.org/packages/fd/32/55fb50ae104061dbc564ef15cc43c013dc4a9f4527a1f4d99baddf56fe5f/rpds_py-0.30.0-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:e7536cd91353c5273434b4e003cbda89034d67e7710eab8761fd918ec6c69cf8", size = 358904, upload-time = "2025-11-30T20:22:43.479Z" },
    { url = "https://files.pythonhosted.org/packages/58/70/faed8186300e3b9bdd138d0273109784eea2396c68458ed580f885dfe7ad/rpds_py-0.30.0-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:2771c6c15973347f50fece41fc447c054b7ac2ae0502388ce3b6738cd366e3d4", size = 389945, upload-time = "2025-11-30T20:22:44.819Z" },
    { url = "https://files.pythonhosted.org/packages/bd/a8/073cac3ed2c6387df38f71296d002ab43496a96b92c823e76f46b8af0543/rpds_py-0.30.0-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:0a59119fc6e3f460315fe9d08149f8102aa322299deaa5cab5b40092345c2136", size = 407783, upload-time = "2025-11-30T20:22:46.103Z" },
    { url = "https://files.pythonhosted.org/packages/77/57/5999eb8c58671f1c11eba084115e77a8899d6e694d2a18f69f0ba471ec8b/rpds_py-0.30.0-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:76fec018282b4ead0364022e3c54b60bf368b9d926877957a8624b58419169b7", size = 515021, upload-time = "2025-11-30T20:22:47.458Z" },
    { url = "https://files.pythonhosted.org/packages/e0/af/5ab4833eadc36c0a8ed2bc5c0de0493c04f6c06de223170bd0798ff98ced/rpds_py-0.30.0-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:692bef75a5525db97318e8cd061542b5a79812d711ea03dbc1f6f8dbb0c5f0d2", size = 414589, upload-time = "2025-11-30T20:22:48.872Z" },
    { url = "https://files.pythonhosted.org/packages/b7/de/f7192e12b21b9e9a68a6d0f249b4af3fdcdff8418be0767a627564afa1f1/rpds_py-0.30.0-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9027da1ce107104c50c81383cae773ef5c24d296dd11c99e2629dbd7967a20c6", size = 394025, upload-time = "2025-11-30T20:22:50.196Z" },
    { url = "https://files.pythonhosted.org/packages/91/c4/fc70cd0249496493500e7cc2de87504f5aa6509de1e88623431fec76d4b6/rpds_py-0.30.0-cp313-cp313-manylinux_2_31_riscv64.whl", hash = "sha256:9cf69cdda1f5968a30a359aba2f7f9aa648a9ce4b580d6826437f2b291cfc86e", size = 408895, upload-time = "2025-11-30T20:22:51.87Z" },
    { url = "https://files.pythonhosted.org/packages/58/95/d9275b05ab96556fefff73a385813eb66032e4c99f411d0795372d9abcea/rpds_py-0.30.0-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:a4796a717bf12b9da9d3ad002519a86063dcac8988b030e405704ef7d74d2d9d", size = 422799, upload-time = "2025-11-30T20:22:53.341Z" },
    { url = "https://files.pythonhosted.org/packages/06/c1/3088fc04b6624eb12a57eb814f0d4997a44b0d208d6cace713033ff1a6ba/rpds_py-0.30.0-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:5d4c2aa7c50ad4728a094ebd5eb46c452e9cb7edbfdb18f9e1221f597a73e1e7", size = 572731, upload-time = "2025-11-30T20:22:54.778Z" },
    { url = "https://files.pythonhosted.org/packages/d8/42/c612a833183b39774e8ac8fecae81263a68b9583ee343db33ab571a7ce55/rpds_py-0.30.0-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:ba81a9203d07805435eb06f536d95a266c21e5b2dfbf6517748ca40c98d19e31", size = 599027, upload-time = "2025-11-30T20:22:56.212Z" },
    { url = "https://files.pythonhosted.org/packages/5f/60/525a50f45b01d70005403ae0e25f43c0384369ad24ffe46e8d9068b50086/rpds_py-0.30.0-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:945dccface01af02675628334f7cf49c2af4c1c904748efc5cf7bbdf0b579f95", size = 563020, upload-time = "2025-11-30T20:22:58.2Z" },
    { url = "https://files.pythonhosted.org/packages/0b/5d/47c4655e9bcd5ca907148535c10e7d489044243cc9941c16ed7cd53be91d/rpds_py-0.30.0-cp313-cp313-win32.whl", hash = "sha256:b40fb160a2db369a194cb27943582b38f79fc4887291417685f3ad693c5a1d5d", size = 223139, upload-time = "2025-11-30T20:23:00.209Z" },
    { url = "https://files.pythonhosted.org/packages/f2/e1/485132437d20aa4d3e1d8b3fb5a5e65aa8139f1e097080c2a8443201742c/rpds_py-0.30.0-cp313-cp313-win_amd64.whl", hash = "sha256:806f36b1b605e2d6a72716f321f20036b9489d29c51c91f4dd29a3e3afb73b15", size = 240224, upload-time = "2025-11-30T20:23:02.008Z" },
    { url = "https://files.pythonhosted.org/packages/24/95/ffd128ed1146a153d928617b0ef673960130be0009c77d8fbf0abe306713/rpds_py-0.30.0-cp313-cp313-win_arm64.whl", hash = "sha256:d96c2086587c7c30d44f31f42eae4eac89b60dabbac18c7669be3700f13c3ce1", size = 230645, upload-time = "2025-11-30T20:23:03.43Z" },
    { url = "https://files.pythonhosted.org/packages/ff/1b/b10de890a0def2a319a2626334a7f0ae388215eb60914dbac8a3bae54435/rpds_py-0.30.0-cp313-cp313t-macosx_10_12_x86_64.whl", hash = "sha256:eb0b93f2e5c2189ee831ee43f156ed34e2a89a78a66b98cadad955972548be5a", size = 364443, upload-time = "2025-11-30T20:23:04.878Z" },
    { url = "https://files.pythonhosted.org/packages/0d/bf/27e39f5971dc4f305a4fb9c672ca06f290f7c4e261c568f3dea16a410d47/rpds_py-0.30.0-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:922e10f31f303c7c920da8981051ff6d8c1a56207dbdf330d9047f6d30b70e5e", size = 353375, upload-time = "2025-11-30T20:23:06.342Z" },
    { url = "https://files.pythonhosted.org/packages/40/58/442ada3bba6e8e6615fc00483135c14a7538d2ffac30e2d933ccf6852232/rpds_py-0.30.0-cp313-cp313t-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:cdc62c8286ba9bf7f47befdcea13ea0e26bf294bda99758fd90535cbaf408000", size = 383850, upload-time = "2025-11-30T20:23:07.825Z" },
    { url = "https://files.pythonhosted.org/packages/14/14/f59b0127409a33c6ef6f5c1ebd5ad8e32d7861c9c7adfa9a624fc3889f6c/rpds_py-0.30.0-cp313-cp313t-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:47f9a91efc418b54fb8190a6b4aa7813a23fb79c51f4bb84e418f5476c38b8db", size = 392812, upload-time = "2025-11-30T20:23:09.228Z" },
    { url = "https://files.pythonhosted.org/packages/b3/66/e0be3e162ac299b3a22527e8913767d869e6cc75c46bd844aa43fb81ab62/rpds_py-0.30.0-cp313-cp313t-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:1f3587eb9b17f3789ad50824084fa6f81921bbf9a795826570bda82cb3ed91f2", size = 517841, upload-time = "2025-11-30T20:23:11.186Z" },
    { url = "https://files.pythonhosted.org/packages/3d/55/fa3b9cf31d0c963ecf1ba777f7cf4b2a2c976795ac430d24a1f43d25a6ba/rpds_py-0.30.0-cp313-cp313t-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:39c02563fc592411c2c61d26b6c5fe1e51eaa44a75aa2c8735ca88b0d9599daa", size = 408149, upload-time = "2025-11-30T20:23:12.864Z" },
    { url = "https://files.pythonhosted.org/packages/60/ca/780cf3b1a32b18c0f05c441958d3758f02544f1d613abf9488cd78876378/rpds_py-0.30.0-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:51a1234d8febafdfd33a42d97da7a43f5dcb120c1060e352a3fbc0c6d36e2083", size = 383843, upload-time = "2025-11-30T20:23:14.638Z" },
    { url = "https://files.pythonhosted.org/packages/82/86/d5f2e04f2aa6247c613da0c1dd87fcd08fa17107e858193566048a1e2f0a/rpds_py-0.30.0-cp313-cp313t-manylinux_2_31_riscv64.whl", hash = "sha256:eb2c4071ab598733724c08221091e8d80e89064cd472819285a9ab0f24bcedb9", size = 396507, upload-time = "2025-11-30T20:23:16.105Z" },
    { url = "https://files.pythonhosted.org/packages/4b/9a/453255d2f769fe44e07ea9785c8347edaf867f7026872e76c1ad9f7bed92/rpds_py-0.30.0-cp313-cp313t-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:6bdfdb946967d816e6adf9a3d8201bfad269c67efe6cefd7093ef959683c8de0", size = 414949, upload-time = "2025-11-30T20:23:17.539Z" },
    { url = "https://files.pythonhosted.org/packages/a3/31/622a86cdc0c45d6df0e9ccb6becdba5074735e7033c20e401a6d9d0e2ca0/rpds_py-0.30.0-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:c77afbd5f5250bf27bf516c7c4a016813eb2d3e116139aed0096940c5982da94", size = 565790, upload-time = "2025-11-30T20:23:19.029Z" },
    { url = "https://files.pythonhosted.org/packages/1c/5d/15bbf0fb4a3f58a3b1c67855ec1efcc4ceaef4e86644665fff03e1b66d8d/rpds_py-0.30.0-cp313-cp313t-musllinux_1_2_i686.whl", hash = "sha256:61046904275472a76c8c90c9ccee9013d70a6d0f73eecefd38c1ae7c39045a08", size = 590217, upload-time = "2025-11-30T20:23:20.885Z" },
    { url = "https://files.pythonhosted.org/packages/6d/61/21b8c41f68e60c8cc3b2e25644f0e3681926020f11d06ab0b78e3c6bbff1/rpds_py-0.30.0-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:4c5f36a861bc4b7da6516dbdf302c55313afa09b81931e8280361a4f6c9a2d27", size = 555806, upload-time = "2025-11-30T20:23:22.488Z" },
    { url = "https://files.pythonhosted.org/packages/f9/39/7e067bb06c31de48de3eb200f9fc7c58982a4d3db44b07e73963e10d3be9/rpds_py-0.30.0-cp313-cp313t-win32.whl", hash = "sha256:3d4a69de7a3e50ffc214ae16d79d8fbb0922972da0356dcf4d0fdca2878559c6", size = 211341, upload-time = "2025-11-30T20:23:24.449Z" },
    { url = "https://files.pythonhosted.org/packages/0a/4d/222ef0b46443cf4cf46764d9c630f3fe4abaa7245be9417e56e9f52b8f65/rpds_py-0.30.0-cp313-cp313t-win_amd64.whl", hash = "sha256:f14fc5df50a716f7ece6a80b6c78bb35ea2ca47c499e422aa4463455dd96d56d", size = 225768, upload-time = "2025-11-30T20:23:25.908Z" },
    { url = "https://files.pythonhosted.org/packages/69/71/3f34339ee70521864411f8b6992e7ab13ac30d8e4e3309e07c7361767d91/rpds_py-0.30.0-pp311-pypy311_pp73-macosx_10_12_x86_64.whl", hash = "sha256:c2262bdba0ad4fc6fb5545660673925c2d2a5d9e2e0fb603aad545427be0fc58", size = 372292, upload-time = "2025-11-30T20:24:16.537Z" },
    { url = "https://files.pythonhosted.org/packages/57/09/f183df9b8f2d66720d2ef71075c59f7e1b336bec7ee4c48f0a2b06857653/rpds_py-0.30.0-pp311-pypy311_pp73-macosx_11_0_arm64.whl", hash = "sha256:ee6af14263f25eedc3bb918a3c04245106a42dfd4f5c2285ea6f997b1fc3f89a", size = 362128, upload-time = "2025-11-30T20:24:18.086Z" },
    { url = "https://files.pythonhosted.org/packages/7a/68/5c2594e937253457342e078f0cc1ded3dd7b2ad59afdbf2d354869110a02/rpds_py-0.30.0-pp311-pypy311_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:3adbb8179ce342d235c31ab8ec511e66c73faa27a47e076ccc92421add53e2bb", size = 391542, upload-time = "2025-11-30T20:24:20.092Z" },
    { url = "https://files.pythonhosted.org/packages/49/5c/31ef1afd70b4b4fbdb2800249f34c57c64beb687495b10aec0365f53dfc4/rpds_py-0.30.0-pp311-pypy311_pp73-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:250fa00e9543ac9b97ac258bd37367ff5256666122c2d0f2bc97577c60a1818c", size = 404004, upload-time = "2025-11-30T20:24:22.231Z" },
    { url = "https://files.pythonhosted.org/packages/e3/63/0cfbea38d05756f3440ce6534d51a491d26176ac045e2707adc99bb6e60a/rpds_py-0.30.0-pp311-pypy311_pp73-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:9854cf4f488b3d57b9aaeb105f06d78e5529d3145b1e4a41750167e8c213c6d3", size = 527063, upload-time = "2025-11-30T20:24:24.302Z" },
    { url = "https://files.pythonhosted.org/packages/42/e6/01e1f72a2456678b0f618fc9a1a13f882061690893c192fcad9f2926553a/rpds_py-0.30.0-pp311-pypy311_pp73-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:993914b8e560023bc0a8bf742c5f303551992dcb85e247b1e5c7f4a7d145bda5", size = 413099, upload-time = "2025-11-30T20:24:25.916Z" },
    { url = "https://files.pythonhosted.org/packages/b8/25/8df56677f209003dcbb180765520c544525e3ef21ea72279c98b9aa7c7fb/rpds_py-0.30.0-pp311-pypy311_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:58edca431fb9b29950807e301826586e5bbf24163677732429770a697ffe6738", size = 392177, upload-time = "2025-11-30T20:24:27.834Z" },
    { url = "https://files.pythonhosted.org/packages/4a/b4/0a771378c5f16f8115f796d1f437950158679bcd2a7c68cf251cfb00ed5b/rpds_py-0.30.0-pp311-pypy311_pp73-manylinux_2_31_riscv64.whl", hash = "sha256:dea5b552272a944763b34394d04577cf0f9bd013207bc32323b5a89a53cf9c2f", size = 406015, upload-time = "2025-11-30T20:24:29.457Z" },
    { url = "https://files.pythonhosted.org/packages/36/d8/456dbba0af75049dc6f63ff295a2f92766b9d521fa00de67a2bd6427d57a/rpds_py-0.30.0-pp311-pypy311_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:ba3af48635eb83d03f6c9735dfb21785303e73d22ad03d489e88adae6eab8877", size = 423736, upload-time = "2025-11-30T20:24:31.22Z" },
    { url = "https://files.pythonhosted.org/packages/13/64/b4d76f227d5c45a7e0b796c674fd81b0a6c4fbd48dc29271857d8219571c/rpds_py-0.30.0-pp311-pypy311_pp73-musllinux_1_2_aarch64.whl", hash = "sha256:dff13836529b921e22f15cb099751209a60009731a68519630a24d61f0b1b30a", size = 573981, upload-time = "2025-11-30T20:24:32.934Z" },
    { url = "https://files.pythonhosted.org/packages/20/91/092bacadeda3edf92bf743cc96a7be133e13a39cdbfd7b5082e7ab638406/rpds_py-0.30.0-pp311-pypy311_pp73-musllinux_1_2_i686.whl", hash = "sha256:1b151685b23929ab7beec71080a8889d4d6d9fa9a983d213f07121205d48e2c4", size = 599782, upload-time = "2025-11-30T20:24:35.169Z" },
    { url = "https://files.pythonhosted.org/packages/d1/b7/b95708304cd49b7b6f82fdd039f1748b66ec2b21d6a45180910802f1abf1/rpds_py-0.30.0-pp311-pypy311_pp73-musllinux_1_2_x86_64.whl", hash = "sha256:ac37f9f516c51e5753f27dfdef11a88330f04de2d564be3991384b2f3535d02e", size = 562191, upload-time = "2025-11-30T20:24:36.853Z" },
]

[[package]]
name = "rsa"
version = "4.9.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "pyasn1" },
]
sdist = { url = "https://files.pythonhosted.org/packages/da/8a/22b7beea3ee0d44b1916c0c1cb0ee3af23b700b6da9f04991899d0c555d4/rsa-4.9.1.tar.gz", hash = "sha256:e7bdbfdb5497da4c07dfd35530e1a902659db6ff241e39d9953cad06ebd0ae75", size = 29034, upload-time = "2025-04-16T09:51:18.218Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/64/8d/0133e4eb4beed9e425d9a98ed6e081a55d195481b7632472be1af08d2f6b/rsa-4.9.1-py3-none-any.whl", hash = "sha256:68635866661c6836b8d39430f97a996acbd61bfa49406748ea243539fe239762", size = 34696, upload-time = "2025-04-16T09:51:17.142Z" },
]

[[package]]
name = "ruamel-yaml"
version = "0.18.16"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "ruamel-yaml-clib", marker = "platform_python_implementation == 'CPython'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/9f/c7/ee630b29e04a672ecfc9b63227c87fd7a37eb67c1bf30fe95376437f897c/ruamel.yaml-0.18.16.tar.gz", hash = "sha256:a6e587512f3c998b2225d68aa1f35111c29fad14aed561a26e73fab729ec5e5a", size = 147269, upload-time = "2025-10-22T17:54:02.346Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0f/73/bb1bc2529f852e7bf64a2dec885e89ff9f5cc7bbf6c9340eed30ff2c69c5/ruamel.yaml-0.18.16-py3-none-any.whl", hash = "sha256:048f26d64245bae57a4f9ef6feb5b552a386830ef7a826f235ffb804c59efbba", size = 119858, upload-time = "2025-10-22T17:53:59.012Z" },
]

[[package]]
name = "ruamel-yaml-clib"
version = "0.2.14"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d8/e9/39ec4d4b3f91188fad1842748f67d4e749c77c37e353c4e545052ee8e893/ruamel.yaml.clib-0.2.14.tar.gz", hash = "sha256:803f5044b13602d58ea378576dd75aa759f52116a0232608e8fdada4da33752e", size = 225394, upload-time = "2025-09-22T19:51:23.753Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b3/9f/3c51e9578b8c36fcc4bdd271a1a5bb65963a74a4b6ad1a989768a22f6c2a/ruamel.yaml.clib-0.2.14-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:5bae1a073ca4244620425cd3d3aa9746bde590992b98ee8c7c8be8c597ca0d4e", size = 270207, upload-time = "2025-09-23T14:24:11.445Z" },
    { url = "https://files.pythonhosted.org/packages/4a/16/cb02815bc2ae9c66760c0c061d23c7358f9ba51dae95ac85247662b7fbe2/ruamel.yaml.clib-0.2.14-cp311-cp311-macosx_13_0_arm64.whl", hash = "sha256:0a54e5e40a7a691a426c2703b09b0d61a14294d25cfacc00631aa6f9c964df0d", size = 137780, upload-time = "2025-09-22T19:50:37.734Z" },
    { url = "https://files.pythonhosted.org/packages/31/c6/fc687cd1b93bff8e40861eea46d6dc1a6a778d9a085684e4045ff26a8e40/ruamel.yaml.clib-0.2.14-cp311-cp311-manylinux2014_aarch64.whl", hash = "sha256:10d9595b6a19778f3269399eff6bab642608e5966183abc2adbe558a42d4efc9", size = 641590, upload-time = "2025-09-22T19:50:41.978Z" },
    { url = "https://files.pythonhosted.org/packages/45/5d/65a2bc08b709b08576b3f307bf63951ee68a8e047cbbda6f1c9864ecf9a7/ruamel.yaml.clib-0.2.14-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:dba72975485f2b87b786075e18a6e5d07dc2b4d8973beb2732b9b2816f1bad70", size = 738090, upload-time = "2025-09-22T19:50:39.152Z" },
    { url = "https://files.pythonhosted.org/packages/fb/d0/a70a03614d9a6788a3661ab1538879ed2aae4e84d861f101243116308a37/ruamel.yaml.clib-0.2.14-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:29757bdb7c142f9595cc1b62ec49a3d1c83fab9cef92db52b0ccebaad4eafb98", size = 700744, upload-time = "2025-09-22T19:50:40.811Z" },
    { url = "https://files.pythonhosted.org/packages/77/30/c93fa457611f79946d5cb6cc97493ca5425f3f21891d7b1f9b44eaa1b38e/ruamel.yaml.clib-0.2.14-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:557df28dbccf79b152fe2d1b935f6063d9cc431199ea2b0e84892f35c03bb0ee", size = 742321, upload-time = "2025-09-23T18:42:48.916Z" },
    { url = "https://files.pythonhosted.org/packages/40/85/e2c54ad637117cd13244a4649946eaa00f32edcb882d1f92df90e079ab00/ruamel.yaml.clib-0.2.14-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:26a8de280ab0d22b6e3ec745b4a5a07151a0f74aad92dd76ab9c8d8d7087720d", size = 743805, upload-time = "2025-09-22T19:50:43.58Z" },
    { url = "https://files.pythonhosted.org/packages/81/50/f899072c38877d8ef5382e0b3d47f8c4346226c1f52d6945d6f64fec6a2f/ruamel.yaml.clib-0.2.14-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:e501c096aa3889133d674605ebd018471bc404a59cbc17da3c5924421c54d97c", size = 769529, upload-time = "2025-09-22T19:50:45.707Z" },
    { url = "https://files.pythonhosted.org/packages/99/7c/96d4b5075e30c65ea2064e40c2d657c7c235d7b6ef18751cf89a935b9041/ruamel.yaml.clib-0.2.14-cp311-cp311-win32.whl", hash = "sha256:915748cfc25b8cfd81b14d00f4bfdb2ab227a30d6d43459034533f4d1c207a2a", size = 100256, upload-time = "2025-09-22T19:50:48.26Z" },
    { url = "https://files.pythonhosted.org/packages/7d/8c/73ee2babd04e8bfcf1fd5c20aa553d18bf0ebc24b592b4f831d12ae46cc0/ruamel.yaml.clib-0.2.14-cp311-cp311-win_amd64.whl", hash = "sha256:4ccba93c1e5a40af45b2f08e4591969fa4697eae951c708f3f83dcbf9f6c6bb1", size = 118234, upload-time = "2025-09-22T19:50:47.019Z" },
    { url = "https://files.pythonhosted.org/packages/b4/42/ccfb34a25289afbbc42017e4d3d4288e61d35b2e00cfc6b92974a6a1f94b/ruamel.yaml.clib-0.2.14-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:6aeadc170090ff1889f0d2c3057557f9cd71f975f17535c26a5d37af98f19c27", size = 271775, upload-time = "2025-09-23T14:24:12.771Z" },
    { url = "https://files.pythonhosted.org/packages/82/73/e628a92e80197ff6a79ab81ec3fa00d4cc082d58ab78d3337b7ba7043301/ruamel.yaml.clib-0.2.14-cp312-cp312-macosx_14_0_arm64.whl", hash = "sha256:5e56ac47260c0eed992789fa0b8efe43404a9adb608608631a948cee4fc2b052", size = 138842, upload-time = "2025-09-22T19:50:49.156Z" },
    { url = "https://files.pythonhosted.org/packages/2b/c5/346c7094344a60419764b4b1334d9e0285031c961176ff88ffb652405b0c/ruamel.yaml.clib-0.2.14-cp312-cp312-manylinux2014_aarch64.whl", hash = "sha256:a911aa73588d9a8b08d662b9484bc0567949529824a55d3885b77e8dd62a127a", size = 647404, upload-time = "2025-09-22T19:50:52.921Z" },
    { url = "https://files.pythonhosted.org/packages/df/99/65080c863eb06d4498de3d6c86f3e90595e02e159fd8529f1565f56cfe2c/ruamel.yaml.clib-0.2.14-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:a05ba88adf3d7189a974b2de7a9d56731548d35dc0a822ec3dc669caa7019b29", size = 753141, upload-time = "2025-09-22T19:50:50.294Z" },
    { url = "https://files.pythonhosted.org/packages/3d/e3/0de85f3e3333f8e29e4b10244374a202a87665d1131798946ee22cf05c7c/ruamel.yaml.clib-0.2.14-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:fb04c5650de6668b853623eceadcdb1a9f2fee381f5d7b6bc842ee7c239eeec4", size = 703477, upload-time = "2025-09-22T19:50:51.508Z" },
    { url = "https://files.pythonhosted.org/packages/d9/25/0d2f09d8833c7fd77ab8efeff213093c16856479a9d293180a0d89f6bed9/ruamel.yaml.clib-0.2.14-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:df3ec9959241d07bc261f4983d25a1205ff37703faf42b474f15d54d88b4f8c9", size = 741157, upload-time = "2025-09-23T18:42:50.408Z" },
    { url = "https://files.pythonhosted.org/packages/d3/8c/959f10c2e2153cbdab834c46e6954b6dd9e3b109c8f8c0a3cf1618310985/ruamel.yaml.clib-0.2.14-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:fbc08c02e9b147a11dfcaa1ac8a83168b699863493e183f7c0c8b12850b7d259", size = 745859, upload-time = "2025-09-22T19:50:54.497Z" },
    { url = "https://files.pythonhosted.org/packages/ed/6b/e580a7c18b485e1a5f30a32cda96b20364b0ba649d9d2baaf72f8bd21f83/ruamel.yaml.clib-0.2.14-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:c099cafc1834d3c5dac305865d04235f7c21c167c8dd31ebc3d6bbc357e2f023", size = 770200, upload-time = "2025-09-22T19:50:55.718Z" },
    { url = "https://files.pythonhosted.org/packages/ef/44/3455eebc761dc8e8fdced90f2b0a3fa61e32ba38b50de4130e2d57db0f21/ruamel.yaml.clib-0.2.14-cp312-cp312-win32.whl", hash = "sha256:b5b0f7e294700b615a3bcf6d28b26e6da94e8eba63b079f4ec92e9ba6c0d6b54", size = 98829, upload-time = "2025-09-22T19:50:58.895Z" },
    { url = "https://files.pythonhosted.org/packages/76/ab/5121f7f3b651db93de546f8c982c241397aad0a4765d793aca1dac5eadee/ruamel.yaml.clib-0.2.14-cp312-cp312-win_amd64.whl", hash = "sha256:a37f40a859b503304dd740686359fcf541d6fb3ff7fc10f539af7f7150917c68", size = 115570, upload-time = "2025-09-22T19:50:57.981Z" },
    { url = "https://files.pythonhosted.org/packages/d7/ae/e3811f05415594025e96000349d3400978adaed88d8f98d494352d9761ee/ruamel.yaml.clib-0.2.14-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:7e4f9da7e7549946e02a6122dcad00b7c1168513acb1f8a726b1aaf504a99d32", size = 269205, upload-time = "2025-09-23T14:24:15.06Z" },
    { url = "https://files.pythonhosted.org/packages/72/06/7d51f4688d6d72bb72fa74254e1593c4f5ebd0036be5b41fe39315b275e9/ruamel.yaml.clib-0.2.14-cp313-cp313-macosx_15_0_arm64.whl", hash = "sha256:dd7546c851e59c06197a7c651335755e74aa383a835878ca86d2c650c07a2f85", size = 137417, upload-time = "2025-09-22T19:50:59.82Z" },
    { url = "https://files.pythonhosted.org/packages/5a/08/b4499234a420ef42960eeb05585df5cc7eb25ccb8c980490b079e6367050/ruamel.yaml.clib-0.2.14-cp313-cp313-manylinux2014_aarch64.whl", hash = "sha256:1c1acc3a0209ea9042cc3cfc0790edd2eddd431a2ec3f8283d081e4d5018571e", size = 642558, upload-time = "2025-09-22T19:51:03.388Z" },
    { url = "https://files.pythonhosted.org/packages/b6/ba/1975a27dedf1c4c33306ee67c948121be8710b19387aada29e2f139c43ee/ruamel.yaml.clib-0.2.14-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:2070bf0ad1540d5c77a664de07ebcc45eebd1ddcab71a7a06f26936920692beb", size = 744087, upload-time = "2025-09-22T19:51:00.897Z" },
    { url = "https://files.pythonhosted.org/packages/20/15/8a19a13d27f3bd09fa18813add8380a29115a47b553845f08802959acbce/ruamel.yaml.clib-0.2.14-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:9bd8fe07f49c170e09d76773fb86ad9135e0beee44f36e1576a201b0676d3d1d", size = 699709, upload-time = "2025-09-22T19:51:02.075Z" },
    { url = "https://files.pythonhosted.org/packages/19/ee/8d6146a079ad21e534b5083c9ee4a4c8bec42f79cf87594b60978286b39a/ruamel.yaml.clib-0.2.14-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:ff86876889ea478b1381089e55cf9e345707b312beda4986f823e1d95e8c0f59", size = 708926, upload-time = "2025-09-23T18:42:51.707Z" },
    { url = "https://files.pythonhosted.org/packages/a9/f5/426b714abdc222392e68f3b8ad323930d05a214a27c7e7a0f06c69126401/ruamel.yaml.clib-0.2.14-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:1f118b707eece8cf84ecbc3e3ec94d9db879d85ed608f95870d39b2d2efa5dca", size = 740202, upload-time = "2025-09-22T19:51:04.673Z" },
    { url = "https://files.pythonhosted.org/packages/3d/ac/3c5c2b27a183f4fda8a57c82211721c016bcb689a4a175865f7646db9f94/ruamel.yaml.clib-0.2.14-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:b30110b29484adc597df6bd92a37b90e63a8c152ca8136aad100a02f8ba6d1b6", size = 765196, upload-time = "2025-09-22T19:51:05.916Z" },
    { url = "https://files.pythonhosted.org/packages/92/2e/06f56a71fd55021c993ed6e848c9b2e5e9cfce180a42179f0ddd28253f7c/ruamel.yaml.clib-0.2.14-cp313-cp313-win32.whl", hash = "sha256:f4e97a1cf0b7a30af9e1d9dad10a5671157b9acee790d9e26996391f49b965a2", size = 98635, upload-time = "2025-09-22T19:51:08.183Z" },
    { url = "https://files.pythonhosted.org/packages/51/79/76aba16a1689b50528224b182f71097ece338e7a4ab55e84c2e73443b78a/ruamel.yaml.clib-0.2.14-cp313-cp313-win_amd64.whl", hash = "sha256:090782b5fb9d98df96509eecdbcaffd037d47389a89492320280d52f91330d78", size = 115238, upload-time = "2025-09-22T19:51:07.081Z" },
]

[[package]]
name = "ruff"
version = "0.14.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/75/62/50b7727004dfe361104dfbf898c45a9a2fdfad8c72c04ae62900224d6ecf/ruff-0.14.3.tar.gz", hash = "sha256:4ff876d2ab2b161b6de0aa1f5bd714e8e9b4033dc122ee006925fbacc4f62153", size = 5558687, upload-time = "2025-10-31T00:26:26.878Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ce/8e/0c10ff1ea5d4360ab8bfca4cb2c9d979101a391f3e79d2616c9bf348cd26/ruff-0.14.3-py3-none-linux_armv6l.whl", hash = "sha256:876b21e6c824f519446715c1342b8e60f97f93264012de9d8d10314f8a79c371", size = 12535613, upload-time = "2025-10-31T00:25:44.302Z" },
    { url = "https://files.pythonhosted.org/packages/d3/c8/6724f4634c1daf52409fbf13fefda64aa9c8f81e44727a378b7b73dc590b/ruff-0.14.3-py3-none-macosx_10_12_x86_64.whl", hash = "sha256:b6fd8c79b457bedd2abf2702b9b472147cd860ed7855c73a5247fa55c9117654", size = 12855812, upload-time = "2025-10-31T00:25:47.793Z" },
    { url = "https://files.pythonhosted.org/packages/de/03/db1bce591d55fd5f8a08bb02517fa0b5097b2ccabd4ea1ee29aa72b67d96/ruff-0.14.3-py3-none-macosx_11_0_arm64.whl", hash = "sha256:71ff6edca490c308f083156938c0c1a66907151263c4abdcb588602c6e696a14", size = 11944026, upload-time = "2025-10-31T00:25:49.657Z" },
    { url = "https://files.pythonhosted.org/packages/0b/75/4f8dbd48e03272715d12c87dc4fcaaf21b913f0affa5f12a4e9c6f8a0582/ruff-0.14.3-py3-none-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:786ee3ce6139772ff9272aaf43296d975c0217ee1b97538a98171bf0d21f87ed", size = 12356818, upload-time = "2025-10-31T00:25:51.949Z" },
    { url = "https://files.pythonhosted.org/packages/ec/9b/506ec5b140c11d44a9a4f284ea7c14ebf6f8b01e6e8917734a3325bff787/ruff-0.14.3-py3-none-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:cd6291d0061811c52b8e392f946889916757610d45d004e41140d81fb6cd5ddc", size = 12336745, upload-time = "2025-10-31T00:25:54.248Z" },
    { url = "https://files.pythonhosted.org/packages/c7/e1/c560d254048c147f35e7f8131d30bc1f63a008ac61595cf3078a3e93533d/ruff-0.14.3-py3-none-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:a497ec0c3d2c88561b6d90f9c29f5ae68221ac00d471f306fa21fa4264ce5fcd", size = 13101684, upload-time = "2025-10-31T00:25:56.253Z" },
    { url = "https://files.pythonhosted.org/packages/a5/32/e310133f8af5cd11f8cc30f52522a3ebccc5ea5bff4b492f94faceaca7a8/ruff-0.14.3-py3-none-manylinux_2_17_ppc64.manylinux2014_ppc64.whl", hash = "sha256:e231e1be58fc568950a04fbe6887c8e4b85310e7889727e2b81db205c45059eb", size = 14535000, upload-time = "2025-10-31T00:25:58.397Z" },
    { url = "https://files.pythonhosted.org/packages/a2/a1/7b0470a22158c6d8501eabc5e9b6043c99bede40fa1994cadf6b5c2a61c7/ruff-0.14.3-py3-none-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:469e35872a09c0e45fecf48dd960bfbce056b5db2d5e6b50eca329b4f853ae20", size = 14156450, upload-time = "2025-10-31T00:26:00.889Z" },
    { url = "https://files.pythonhosted.org/packages/0a/96/24bfd9d1a7f532b560dcee1a87096332e461354d3882124219bcaff65c09/ruff-0.14.3-py3-none-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:3d6bc90307c469cb9d28b7cfad90aaa600b10d67c6e22026869f585e1e8a2db0", size = 13568414, upload-time = "2025-10-31T00:26:03.291Z" },
    { url = "https://files.pythonhosted.org/packages/a7/e7/138b883f0dfe4ad5b76b58bf4ae675f4d2176ac2b24bdd81b4d966b28c61/ruff-0.14.3-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:0e2f8a0bbcffcfd895df39c9a4ecd59bb80dca03dc43f7fb63e647ed176b741e", size = 13315293, upload-time = "2025-10-31T00:26:05.708Z" },
    { url = "https://files.pythonhosted.org/packages/33/f4/c09bb898be97b2eb18476b7c950df8815ef14cf956074177e9fbd40b7719/ruff-0.14.3-py3-none-manylinux_2_31_riscv64.whl", hash = "sha256:678fdd7c7d2d94851597c23ee6336d25f9930b460b55f8598e011b57c74fd8c5", size = 13539444, upload-time = "2025-10-31T00:26:08.09Z" },
    { url = "https://files.pythonhosted.org/packages/9c/aa/b30a1db25fc6128b1dd6ff0741fa4abf969ded161599d07ca7edd0739cc0/ruff-0.14.3-py3-none-musllinux_1_2_aarch64.whl", hash = "sha256:1ec1ac071e7e37e0221d2f2dbaf90897a988c531a8592a6a5959f0603a1ecf5e", size = 12252581, upload-time = "2025-10-31T00:26:10.297Z" },
    { url = "https://files.pythonhosted.org/packages/da/13/21096308f384d796ffe3f2960b17054110a9c3828d223ca540c2b7cc670b/ruff-0.14.3-py3-none-musllinux_1_2_armv7l.whl", hash = "sha256:afcdc4b5335ef440d19e7df9e8ae2ad9f749352190e96d481dc501b753f0733e", size = 12307503, upload-time = "2025-10-31T00:26:12.646Z" },
    { url = "https://files.pythonhosted.org/packages/cb/cc/a350bac23f03b7dbcde3c81b154706e80c6f16b06ff1ce28ed07dc7b07b0/ruff-0.14.3-py3-none-musllinux_1_2_i686.whl", hash = "sha256:7bfc42f81862749a7136267a343990f865e71fe2f99cf8d2958f684d23ce3dfa", size = 12675457, upload-time = "2025-10-31T00:26:15.044Z" },
    { url = "https://files.pythonhosted.org/packages/cb/76/46346029fa2f2078826bc88ef7167e8c198e58fe3126636e52f77488cbba/ruff-0.14.3-py3-none-musllinux_1_2_x86_64.whl", hash = "sha256:a65e448cfd7e9c59fae8cf37f9221585d3354febaad9a07f29158af1528e165f", size = 13403980, upload-time = "2025-10-31T00:26:17.81Z" },
    { url = "https://files.pythonhosted.org/packages/9f/a4/35f1ef68c4e7b236d4a5204e3669efdeefaef21f0ff6a456792b3d8be438/ruff-0.14.3-py3-none-win32.whl", hash = "sha256:f3d91857d023ba93e14ed2d462ab62c3428f9bbf2b4fbac50a03ca66d31991f7", size = 12500045, upload-time = "2025-10-31T00:26:20.503Z" },
    { url = "https://files.pythonhosted.org/packages/03/15/51960ae340823c9859fb60c63301d977308735403e2134e17d1d2858c7fb/ruff-0.14.3-py3-none-win_amd64.whl", hash = "sha256:d7b7006ac0756306db212fd37116cce2bd307e1e109375e1c6c106002df0ae5f", size = 13594005, upload-time = "2025-10-31T00:26:22.533Z" },
    { url = "https://files.pythonhosted.org/packages/b7/73/4de6579bac8e979fca0a77e54dec1f1e011a0d268165eb8a9bc0982a6564/ruff-0.14.3-py3-none-win_arm64.whl", hash = "sha256:26eb477ede6d399d898791d01961e16b86f02bc2486d0d1a7a9bb2379d055dc1", size = 12590017, upload-time = "2025-10-31T00:26:24.52Z" },
]

[[package]]
name = "s3transfer"
version = "0.14.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "botocore" },
]
sdist = { url = "https://files.pythonhosted.org/packages/62/74/8d69dcb7a9efe8baa2046891735e5dfe433ad558ae23d9e3c14c633d1d58/s3transfer-0.14.0.tar.gz", hash = "sha256:eff12264e7c8b4985074ccce27a3b38a485bb7f7422cc8046fee9be4983e4125", size = 151547, upload-time = "2025-09-09T19:23:31.089Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/48/f0/ae7ca09223a81a1d890b2557186ea015f6e0502e9b8cb8e1813f1d8cfa4e/s3transfer-0.14.0-py3-none-any.whl", hash = "sha256:ea3b790c7077558ed1f02a3072fb3cb992bbbd253392f4b6e9e8976941c7d456", size = 85712, upload-time = "2025-09-09T19:23:30.041Z" },
]

[[package]]
name = "safetensors"
version = "0.6.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ac/cc/738f3011628920e027a11754d9cae9abec1aed00f7ae860abbf843755233/safetensors-0.6.2.tar.gz", hash = "sha256:43ff2aa0e6fa2dc3ea5524ac7ad93a9839256b8703761e76e2d0b2a3fa4f15d9", size = 197968, upload-time = "2025-08-08T13:13:58.654Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4d/b1/3f5fd73c039fc87dba3ff8b5d528bfc5a32b597fea8e7a6a4800343a17c7/safetensors-0.6.2-cp38-abi3-macosx_10_12_x86_64.whl", hash = "sha256:9c85ede8ec58f120bad982ec47746981e210492a6db876882aa021446af8ffba", size = 454797, upload-time = "2025-08-08T13:13:52.066Z" },
    { url = "https://files.pythonhosted.org/packages/8c/c9/bb114c158540ee17907ec470d01980957fdaf87b4aa07914c24eba87b9c6/safetensors-0.6.2-cp38-abi3-macosx_11_0_arm64.whl", hash = "sha256:d6675cf4b39c98dbd7d940598028f3742e0375a6b4d4277e76beb0c35f4b843b", size = 432206, upload-time = "2025-08-08T13:13:50.931Z" },
    { url = "https://files.pythonhosted.org/packages/d3/8e/f70c34e47df3110e8e0bb268d90db8d4be8958a54ab0336c9be4fe86dac8/safetensors-0.6.2-cp38-abi3-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:1d2d2b3ce1e2509c68932ca03ab8f20570920cd9754b05063d4368ee52833ecd", size = 473261, upload-time = "2025-08-08T13:13:41.259Z" },
    { url = "https://files.pythonhosted.org/packages/2a/f5/be9c6a7c7ef773e1996dc214e73485286df1836dbd063e8085ee1976f9cb/safetensors-0.6.2-cp38-abi3-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:93de35a18f46b0f5a6a1f9e26d91b442094f2df02e9fd7acf224cfec4238821a", size = 485117, upload-time = "2025-08-08T13:13:43.506Z" },
    { url = "https://files.pythonhosted.org/packages/c9/55/23f2d0a2c96ed8665bf17a30ab4ce5270413f4d74b6d87dd663258b9af31/safetensors-0.6.2-cp38-abi3-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:89a89b505f335640f9120fac65ddeb83e40f1fd081cb8ed88b505bdccec8d0a1", size = 616154, upload-time = "2025-08-08T13:13:45.096Z" },
    { url = "https://files.pythonhosted.org/packages/98/c6/affb0bd9ce02aa46e7acddbe087912a04d953d7a4d74b708c91b5806ef3f/safetensors-0.6.2-cp38-abi3-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:fc4d0d0b937e04bdf2ae6f70cd3ad51328635fe0e6214aa1fc811f3b576b3bda", size = 520713, upload-time = "2025-08-08T13:13:46.25Z" },
    { url = "https://files.pythonhosted.org/packages/fe/5d/5a514d7b88e310c8b146e2404e0dc161282e78634d9358975fd56dfd14be/safetensors-0.6.2-cp38-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:8045db2c872db8f4cbe3faa0495932d89c38c899c603f21e9b6486951a5ecb8f", size = 485835, upload-time = "2025-08-08T13:13:49.373Z" },
    { url = "https://files.pythonhosted.org/packages/7a/7b/4fc3b2ba62c352b2071bea9cfbad330fadda70579f617506ae1a2f129cab/safetensors-0.6.2-cp38-abi3-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:81e67e8bab9878bb568cffbc5f5e655adb38d2418351dc0859ccac158f753e19", size = 521503, upload-time = "2025-08-08T13:13:47.651Z" },
    { url = "https://files.pythonhosted.org/packages/5a/50/0057e11fe1f3cead9254315a6c106a16dd4b1a19cd247f7cc6414f6b7866/safetensors-0.6.2-cp38-abi3-musllinux_1_2_aarch64.whl", hash = "sha256:b0e4d029ab0a0e0e4fdf142b194514695b1d7d3735503ba700cf36d0fc7136ce", size = 652256, upload-time = "2025-08-08T13:13:53.167Z" },
    { url = "https://files.pythonhosted.org/packages/e9/29/473f789e4ac242593ac1656fbece6e1ecd860bb289e635e963667807afe3/safetensors-0.6.2-cp38-abi3-musllinux_1_2_armv7l.whl", hash = "sha256:fa48268185c52bfe8771e46325a1e21d317207bcabcb72e65c6e28e9ffeb29c7", size = 747281, upload-time = "2025-08-08T13:13:54.656Z" },
    { url = "https://files.pythonhosted.org/packages/68/52/f7324aad7f2df99e05525c84d352dc217e0fa637a4f603e9f2eedfbe2c67/safetensors-0.6.2-cp38-abi3-musllinux_1_2_i686.whl", hash = "sha256:d83c20c12c2d2f465997c51b7ecb00e407e5f94d7dec3ea0cc11d86f60d3fde5", size = 692286, upload-time = "2025-08-08T13:13:55.884Z" },
    { url = "https://files.pythonhosted.org/packages/ad/fe/cad1d9762868c7c5dc70c8620074df28ebb1a8e4c17d4c0cb031889c457e/safetensors-0.6.2-cp38-abi3-musllinux_1_2_x86_64.whl", hash = "sha256:d944cea65fad0ead848b6ec2c37cc0b197194bec228f8020054742190e9312ac", size = 655957, upload-time = "2025-08-08T13:13:57.029Z" },
    { url = "https://files.pythonhosted.org/packages/59/a7/e2158e17bbe57d104f0abbd95dff60dda916cf277c9f9663b4bf9bad8b6e/safetensors-0.6.2-cp38-abi3-win32.whl", hash = "sha256:cab75ca7c064d3911411461151cb69380c9225798a20e712b102edda2542ddb1", size = 308926, upload-time = "2025-08-08T13:14:01.095Z" },
    { url = "https://files.pythonhosted.org/packages/2c/c3/c0be1135726618dc1e28d181b8c442403d8dbb9e273fd791de2d4384bcdd/safetensors-0.6.2-cp38-abi3-win_amd64.whl", hash = "sha256:c7b214870df923cbc1593c3faee16bec59ea462758699bd3fee399d00aac072c", size = 320192, upload-time = "2025-08-08T13:13:59.467Z" },
]

[[package]]
name = "safety"
version = "3.6.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "authlib" },
    { name = "click" },
    { name = "dparse" },
    { name = "filelock" },
    { name = "httpx" },
    { name = "jinja2" },
    { name = "marshmallow" },
    { name = "nltk" },
    { name = "packaging" },
    { name = "psutil" },
    { name = "pydantic" },
    { name = "requests" },
    { name = "ruamel-yaml" },
    { name = "safety-schemas" },
    { name = "setuptools" },
    { name = "tenacity" },
    { name = "tomlkit" },
    { name = "typer" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/4c/5a/dc84e854574cc5c24a53e04180e18bf3590c8283b80a1b1b3d3ca4390031/safety-3.6.2.tar.gz", hash = "sha256:2e148cd9a4ad2e387d2c142878b7b5a3a9cb9e6538167043faa1ba7023a032be", size = 307273, upload-time = "2025-09-24T14:14:59.627Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/84/72/d8193b84fcc35b674709a2200c78787cd94cc481ae3d65fd12e9449703a9/safety-3.6.2-py3-none-any.whl", hash = "sha256:754f8d6068d1504503b0346cbd3cb0e67015d2abc1d842f3a4e4b662cb4f44ec", size = 285954, upload-time = "2025-09-24T14:14:58.028Z" },
]

[[package]]
name = "safety-schemas"
version = "0.0.16"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "dparse" },
    { name = "packaging" },
    { name = "pydantic" },
    { name = "ruamel-yaml" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/c2/ef/0e07dfdb4104c4e42ae9fc6e8a0da7be2d72ac2ee198b32f7500796de8f3/safety_schemas-0.0.16.tar.gz", hash = "sha256:3bb04d11bd4b5cc79f9fa183c658a6a8cf827a9ceec443a5ffa6eed38a50a24e", size = 54815, upload-time = "2025-09-16T14:35:31.973Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/84/a2/7840cc32890ce4b84668d3d9dfe15a48355b683ae3fb627ac97ac5a4265f/safety_schemas-0.0.16-py3-none-any.whl", hash = "sha256:6760515d3fd1e6535b251cd73014bd431d12fe0bfb8b6e8880a9379b5ab7aa44", size = 39292, upload-time = "2025-09-16T14:35:32.84Z" },
]

[[package]]
name = "scikit-learn"
version = "1.7.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "joblib" },
    { name = "numpy" },
    { name = "scipy" },
    { name = "threadpoolctl" },
]
sdist = { url = "https://files.pythonhosted.org/packages/98/c2/a7855e41c9d285dfe86dc50b250978105dce513d6e459ea66a6aeb0e1e0c/scikit_learn-1.7.2.tar.gz", hash = "sha256:20e9e49ecd130598f1ca38a1d85090e1a600147b9c02fa6f15d69cb53d968fda", size = 7193136, upload-time = "2025-09-09T08:21:29.075Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/43/83/564e141eef908a5863a54da8ca342a137f45a0bfb71d1d79704c9894c9d1/scikit_learn-1.7.2-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:c7509693451651cd7361d30ce4e86a1347493554f172b1c72a39300fa2aea79e", size = 9331967, upload-time = "2025-09-09T08:20:32.421Z" },
    { url = "https://files.pythonhosted.org/packages/18/d6/ba863a4171ac9d7314c4d3fc251f015704a2caeee41ced89f321c049ed83/scikit_learn-1.7.2-cp311-cp311-macosx_12_0_arm64.whl", hash = "sha256:0486c8f827c2e7b64837c731c8feff72c0bd2b998067a8a9cbc10643c31f0fe1", size = 8648645, upload-time = "2025-09-09T08:20:34.436Z" },
    { url = "https://files.pythonhosted.org/packages/ef/0e/97dbca66347b8cf0ea8b529e6bb9367e337ba2e8be0ef5c1a545232abfde/scikit_learn-1.7.2-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:89877e19a80c7b11a2891a27c21c4894fb18e2c2e077815bcade10d34287b20d", size = 9715424, upload-time = "2025-09-09T08:20:36.776Z" },
    { url = "https://files.pythonhosted.org/packages/f7/32/1f3b22e3207e1d2c883a7e09abb956362e7d1bd2f14458c7de258a26ac15/scikit_learn-1.7.2-cp311-cp311-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:8da8bf89d4d79aaec192d2bda62f9b56ae4e5b4ef93b6a56b5de4977e375c1f1", size = 9509234, upload-time = "2025-09-09T08:20:38.957Z" },
    { url = "https://files.pythonhosted.org/packages/9f/71/34ddbd21f1da67c7a768146968b4d0220ee6831e4bcbad3e03dd3eae88b6/scikit_learn-1.7.2-cp311-cp311-win_amd64.whl", hash = "sha256:9b7ed8d58725030568523e937c43e56bc01cadb478fc43c042a9aca1dacb3ba1", size = 8894244, upload-time = "2025-09-09T08:20:41.166Z" },
    { url = "https://files.pythonhosted.org/packages/a7/aa/3996e2196075689afb9fce0410ebdb4a09099d7964d061d7213700204409/scikit_learn-1.7.2-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:8d91a97fa2b706943822398ab943cde71858a50245e31bc71dba62aab1d60a96", size = 9259818, upload-time = "2025-09-09T08:20:43.19Z" },
    { url = "https://files.pythonhosted.org/packages/43/5d/779320063e88af9c4a7c2cf463ff11c21ac9c8bd730c4a294b0000b666c9/scikit_learn-1.7.2-cp312-cp312-macosx_12_0_arm64.whl", hash = "sha256:acbc0f5fd2edd3432a22c69bed78e837c70cf896cd7993d71d51ba6708507476", size = 8636997, upload-time = "2025-09-09T08:20:45.468Z" },
    { url = "https://files.pythonhosted.org/packages/5c/d0/0c577d9325b05594fdd33aa970bf53fb673f051a45496842caee13cfd7fe/scikit_learn-1.7.2-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:e5bf3d930aee75a65478df91ac1225ff89cd28e9ac7bd1196853a9229b6adb0b", size = 9478381, upload-time = "2025-09-09T08:20:47.982Z" },
    { url = "https://files.pythonhosted.org/packages/82/70/8bf44b933837ba8494ca0fc9a9ab60f1c13b062ad0197f60a56e2fc4c43e/scikit_learn-1.7.2-cp312-cp312-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:b4d6e9deed1a47aca9fe2f267ab8e8fe82ee20b4526b2c0cd9e135cea10feb44", size = 9300296, upload-time = "2025-09-09T08:20:50.366Z" },
    { url = "https://files.pythonhosted.org/packages/c6/99/ed35197a158f1fdc2fe7c3680e9c70d0128f662e1fee4ed495f4b5e13db0/scikit_learn-1.7.2-cp312-cp312-win_amd64.whl", hash = "sha256:6088aa475f0785e01bcf8529f55280a3d7d298679f50c0bb70a2364a82d0b290", size = 8731256, upload-time = "2025-09-09T08:20:52.627Z" },
    { url = "https://files.pythonhosted.org/packages/ae/93/a3038cb0293037fd335f77f31fe053b89c72f17b1c8908c576c29d953e84/scikit_learn-1.7.2-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:0b7dacaa05e5d76759fb071558a8b5130f4845166d88654a0f9bdf3eb57851b7", size = 9212382, upload-time = "2025-09-09T08:20:54.731Z" },
    { url = "https://files.pythonhosted.org/packages/40/dd/9a88879b0c1104259136146e4742026b52df8540c39fec21a6383f8292c7/scikit_learn-1.7.2-cp313-cp313-macosx_12_0_arm64.whl", hash = "sha256:abebbd61ad9e1deed54cca45caea8ad5f79e1b93173dece40bb8e0c658dbe6fe", size = 8592042, upload-time = "2025-09-09T08:20:57.313Z" },
    { url = "https://files.pythonhosted.org/packages/46/af/c5e286471b7d10871b811b72ae794ac5fe2989c0a2df07f0ec723030f5f5/scikit_learn-1.7.2-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:502c18e39849c0ea1a5d681af1dbcf15f6cce601aebb657aabbfe84133c1907f", size = 9434180, upload-time = "2025-09-09T08:20:59.671Z" },
    { url = "https://files.pythonhosted.org/packages/f1/fd/df59faa53312d585023b2da27e866524ffb8faf87a68516c23896c718320/scikit_learn-1.7.2-cp313-cp313-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:7a4c328a71785382fe3fe676a9ecf2c86189249beff90bf85e22bdb7efaf9ae0", size = 9283660, upload-time = "2025-09-09T08:21:01.71Z" },
    { url = "https://files.pythonhosted.org/packages/a7/c7/03000262759d7b6f38c836ff9d512f438a70d8a8ddae68ee80de72dcfb63/scikit_learn-1.7.2-cp313-cp313-win_amd64.whl", hash = "sha256:63a9afd6f7b229aad94618c01c252ce9e6fa97918c5ca19c9a17a087d819440c", size = 8702057, upload-time = "2025-09-09T08:21:04.234Z" },
    { url = "https://files.pythonhosted.org/packages/55/87/ef5eb1f267084532c8e4aef98a28b6ffe7425acbfd64b5e2f2e066bc29b3/scikit_learn-1.7.2-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:9acb6c5e867447b4e1390930e3944a005e2cb115922e693c08a323421a6966e8", size = 9558731, upload-time = "2025-09-09T08:21:06.381Z" },
    { url = "https://files.pythonhosted.org/packages/93/f8/6c1e3fc14b10118068d7938878a9f3f4e6d7b74a8ddb1e5bed65159ccda8/scikit_learn-1.7.2-cp313-cp313t-macosx_12_0_arm64.whl", hash = "sha256:2a41e2a0ef45063e654152ec9d8bcfc39f7afce35b08902bfe290c2498a67a6a", size = 9038852, upload-time = "2025-09-09T08:21:08.628Z" },
    { url = "https://files.pythonhosted.org/packages/83/87/066cafc896ee540c34becf95d30375fe5cbe93c3b75a0ee9aa852cd60021/scikit_learn-1.7.2-cp313-cp313t-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:98335fb98509b73385b3ab2bd0639b1f610541d3988ee675c670371d6a87aa7c", size = 9527094, upload-time = "2025-09-09T08:21:11.486Z" },
    { url = "https://files.pythonhosted.org/packages/9c/2b/4903e1ccafa1f6453b1ab78413938c8800633988c838aa0be386cbb33072/scikit_learn-1.7.2-cp313-cp313t-manylinux_2_27_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:191e5550980d45449126e23ed1d5e9e24b2c68329ee1f691a3987476e115e09c", size = 9367436, upload-time = "2025-09-09T08:21:13.602Z" },
    { url = "https://files.pythonhosted.org/packages/b5/aa/8444be3cfb10451617ff9d177b3c190288f4563e6c50ff02728be67ad094/scikit_learn-1.7.2-cp313-cp313t-win_amd64.whl", hash = "sha256:57dc4deb1d3762c75d685507fbd0bc17160144b2f2ba4ccea5dc285ab0d0e973", size = 9275749, upload-time = "2025-09-09T08:21:15.96Z" },
]

[[package]]
name = "scipy"
version = "1.16.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "numpy" },
]
sdist = { url = "https://files.pythonhosted.org/packages/0a/ca/d8ace4f98322d01abcd52d381134344bf7b431eba7ed8b42bdea5a3c2ac9/scipy-1.16.3.tar.gz", hash = "sha256:01e87659402762f43bd2fee13370553a17ada367d42e7487800bf2916535aecb", size = 30597883, upload-time = "2025-10-28T17:38:54.068Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9b/5f/6f37d7439de1455ce9c5a556b8d1db0979f03a796c030bafdf08d35b7bf9/scipy-1.16.3-cp311-cp311-macosx_10_14_x86_64.whl", hash = "sha256:40be6cf99e68b6c4321e9f8782e7d5ff8265af28ef2cd56e9c9b2638fa08ad97", size = 36630881, upload-time = "2025-10-28T17:31:47.104Z" },
    { url = "https://files.pythonhosted.org/packages/7c/89/d70e9f628749b7e4db2aa4cd89735502ff3f08f7b9b27d2e799485987cd9/scipy-1.16.3-cp311-cp311-macosx_12_0_arm64.whl", hash = "sha256:8be1ca9170fcb6223cc7c27f4305d680ded114a1567c0bd2bfcbf947d1b17511", size = 28941012, upload-time = "2025-10-28T17:31:53.411Z" },
    { url = "https://files.pythonhosted.org/packages/a8/a8/0e7a9a6872a923505dbdf6bb93451edcac120363131c19013044a1e7cb0c/scipy-1.16.3-cp311-cp311-macosx_14_0_arm64.whl", hash = "sha256:bea0a62734d20d67608660f69dcda23e7f90fb4ca20974ab80b6ed40df87a005", size = 20931935, upload-time = "2025-10-28T17:31:57.361Z" },
    { url = "https://files.pythonhosted.org/packages/bd/c7/020fb72bd79ad798e4dbe53938543ecb96b3a9ac3fe274b7189e23e27353/scipy-1.16.3-cp311-cp311-macosx_14_0_x86_64.whl", hash = "sha256:2a207a6ce9c24f1951241f4693ede2d393f59c07abc159b2cb2be980820e01fb", size = 23534466, upload-time = "2025-10-28T17:32:01.875Z" },
    { url = "https://files.pythonhosted.org/packages/be/a0/668c4609ce6dbf2f948e167836ccaf897f95fb63fa231c87da7558a374cd/scipy-1.16.3-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:532fb5ad6a87e9e9cd9c959b106b73145a03f04c7d57ea3e6f6bb60b86ab0876", size = 33593618, upload-time = "2025-10-28T17:32:06.902Z" },
    { url = "https://files.pythonhosted.org/packages/ca/6e/8942461cf2636cdae083e3eb72622a7fbbfa5cf559c7d13ab250a5dbdc01/scipy-1.16.3-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:0151a0749efeaaab78711c78422d413c583b8cdd2011a3c1d6c794938ee9fdb2", size = 35899798, upload-time = "2025-10-28T17:32:12.665Z" },
    { url = "https://files.pythonhosted.org/packages/79/e8/d0f33590364cdbd67f28ce79368b373889faa4ee959588beddf6daef9abe/scipy-1.16.3-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:b7180967113560cca57418a7bc719e30366b47959dd845a93206fbed693c867e", size = 36226154, upload-time = "2025-10-28T17:32:17.961Z" },
    { url = "https://files.pythonhosted.org/packages/39/c1/1903de608c0c924a1749c590064e65810f8046e437aba6be365abc4f7557/scipy-1.16.3-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:deb3841c925eeddb6afc1e4e4a45e418d19ec7b87c5df177695224078e8ec733", size = 38878540, upload-time = "2025-10-28T17:32:23.907Z" },
    { url = "https://files.pythonhosted.org/packages/f1/d0/22ec7036ba0b0a35bccb7f25ab407382ed34af0b111475eb301c16f8a2e5/scipy-1.16.3-cp311-cp311-win_amd64.whl", hash = "sha256:53c3844d527213631e886621df5695d35e4f6a75f620dca412bcd292f6b87d78", size = 38722107, upload-time = "2025-10-28T17:32:29.921Z" },
    { url = "https://files.pythonhosted.org/packages/7b/60/8a00e5a524bb3bf8898db1650d350f50e6cffb9d7a491c561dc9826c7515/scipy-1.16.3-cp311-cp311-win_arm64.whl", hash = "sha256:9452781bd879b14b6f055b26643703551320aa8d79ae064a71df55c00286a184", size = 25506272, upload-time = "2025-10-28T17:32:34.577Z" },
    { url = "https://files.pythonhosted.org/packages/40/41/5bf55c3f386b1643812f3a5674edf74b26184378ef0f3e7c7a09a7e2ca7f/scipy-1.16.3-cp312-cp312-macosx_10_14_x86_64.whl", hash = "sha256:81fc5827606858cf71446a5e98715ba0e11f0dbc83d71c7409d05486592a45d6", size = 36659043, upload-time = "2025-10-28T17:32:40.285Z" },
    { url = "https://files.pythonhosted.org/packages/1e/0f/65582071948cfc45d43e9870bf7ca5f0e0684e165d7c9ef4e50d783073eb/scipy-1.16.3-cp312-cp312-macosx_12_0_arm64.whl", hash = "sha256:c97176013d404c7346bf57874eaac5187d969293bf40497140b0a2b2b7482e07", size = 28898986, upload-time = "2025-10-28T17:32:45.325Z" },
    { url = "https://files.pythonhosted.org/packages/96/5e/36bf3f0ac298187d1ceadde9051177d6a4fe4d507e8f59067dc9dd39e650/scipy-1.16.3-cp312-cp312-macosx_14_0_arm64.whl", hash = "sha256:2b71d93c8a9936046866acebc915e2af2e292b883ed6e2cbe5c34beb094b82d9", size = 20889814, upload-time = "2025-10-28T17:32:49.277Z" },
    { url = "https://files.pythonhosted.org/packages/80/35/178d9d0c35394d5d5211bbff7ac4f2986c5488b59506fef9e1de13ea28d3/scipy-1.16.3-cp312-cp312-macosx_14_0_x86_64.whl", hash = "sha256:3d4a07a8e785d80289dfe66b7c27d8634a773020742ec7187b85ccc4b0e7b686", size = 23565795, upload-time = "2025-10-28T17:32:53.337Z" },
    { url = "https://files.pythonhosted.org/packages/fa/46/d1146ff536d034d02f83c8afc3c4bab2eddb634624d6529a8512f3afc9da/scipy-1.16.3-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:0553371015692a898e1aa858fed67a3576c34edefa6b7ebdb4e9dde49ce5c203", size = 33349476, upload-time = "2025-10-28T17:32:58.353Z" },
    { url = "https://files.pythonhosted.org/packages/79/2e/415119c9ab3e62249e18c2b082c07aff907a273741b3f8160414b0e9193c/scipy-1.16.3-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:72d1717fd3b5e6ec747327ce9bda32d5463f472c9dce9f54499e81fbd50245a1", size = 35676692, upload-time = "2025-10-28T17:33:03.88Z" },
    { url = "https://files.pythonhosted.org/packages/27/82/df26e44da78bf8d2aeaf7566082260cfa15955a5a6e96e6a29935b64132f/scipy-1.16.3-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:1fb2472e72e24d1530debe6ae078db70fb1605350c88a3d14bc401d6306dbffe", size = 36019345, upload-time = "2025-10-28T17:33:09.773Z" },
    { url = "https://files.pythonhosted.org/packages/82/31/006cbb4b648ba379a95c87262c2855cd0d09453e500937f78b30f02fa1cd/scipy-1.16.3-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:c5192722cffe15f9329a3948c4b1db789fbb1f05c97899187dcf009b283aea70", size = 38678975, upload-time = "2025-10-28T17:33:15.809Z" },
    { url = "https://files.pythonhosted.org/packages/c2/7f/acbd28c97e990b421af7d6d6cd416358c9c293fc958b8529e0bd5d2a2a19/scipy-1.16.3-cp312-cp312-win_amd64.whl", hash = "sha256:56edc65510d1331dae01ef9b658d428e33ed48b4f77b1d51caf479a0253f96dc", size = 38555926, upload-time = "2025-10-28T17:33:21.388Z" },
    { url = "https://files.pythonhosted.org/packages/ce/69/c5c7807fd007dad4f48e0a5f2153038dc96e8725d3345b9ee31b2b7bed46/scipy-1.16.3-cp312-cp312-win_arm64.whl", hash = "sha256:a8a26c78ef223d3e30920ef759e25625a0ecdd0d60e5a8818b7513c3e5384cf2", size = 25463014, upload-time = "2025-10-28T17:33:25.975Z" },
    { url = "https://files.pythonhosted.org/packages/72/f1/57e8327ab1508272029e27eeef34f2302ffc156b69e7e233e906c2a5c379/scipy-1.16.3-cp313-cp313-macosx_10_14_x86_64.whl", hash = "sha256:d2ec56337675e61b312179a1ad124f5f570c00f920cc75e1000025451b88241c", size = 36617856, upload-time = "2025-10-28T17:33:31.375Z" },
    { url = "https://files.pythonhosted.org/packages/44/13/7e63cfba8a7452eb756306aa2fd9b37a29a323b672b964b4fdeded9a3f21/scipy-1.16.3-cp313-cp313-macosx_12_0_arm64.whl", hash = "sha256:16b8bc35a4cc24db80a0ec836a9286d0e31b2503cb2fd7ff7fb0e0374a97081d", size = 28874306, upload-time = "2025-10-28T17:33:36.516Z" },
    { url = "https://files.pythonhosted.org/packages/15/65/3a9400efd0228a176e6ec3454b1fa998fbbb5a8defa1672c3f65706987db/scipy-1.16.3-cp313-cp313-macosx_14_0_arm64.whl", hash = "sha256:5803c5fadd29de0cf27fa08ccbfe7a9e5d741bf63e4ab1085437266f12460ff9", size = 20865371, upload-time = "2025-10-28T17:33:42.094Z" },
    { url = "https://files.pythonhosted.org/packages/33/d7/eda09adf009a9fb81827194d4dd02d2e4bc752cef16737cc4ef065234031/scipy-1.16.3-cp313-cp313-macosx_14_0_x86_64.whl", hash = "sha256:b81c27fc41954319a943d43b20e07c40bdcd3ff7cf013f4fb86286faefe546c4", size = 23524877, upload-time = "2025-10-28T17:33:48.483Z" },
    { url = "https://files.pythonhosted.org/packages/7d/6b/3f911e1ebc364cb81320223a3422aab7d26c9c7973109a9cd0f27c64c6c0/scipy-1.16.3-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:0c3b4dd3d9b08dbce0f3440032c52e9e2ab9f96ade2d3943313dfe51a7056959", size = 33342103, upload-time = "2025-10-28T17:33:56.495Z" },
    { url = "https://files.pythonhosted.org/packages/21/f6/4bfb5695d8941e5c570a04d9fcd0d36bce7511b7d78e6e75c8f9791f82d0/scipy-1.16.3-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:7dc1360c06535ea6116a2220f760ae572db9f661aba2d88074fe30ec2aa1ff88", size = 35697297, upload-time = "2025-10-28T17:34:04.722Z" },
    { url = "https://files.pythonhosted.org/packages/04/e1/6496dadbc80d8d896ff72511ecfe2316b50313bfc3ebf07a3f580f08bd8c/scipy-1.16.3-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:663b8d66a8748051c3ee9c96465fb417509315b99c71550fda2591d7dd634234", size = 36021756, upload-time = "2025-10-28T17:34:13.482Z" },
    { url = "https://files.pythonhosted.org/packages/fe/bd/a8c7799e0136b987bda3e1b23d155bcb31aec68a4a472554df5f0937eef7/scipy-1.16.3-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:eab43fae33a0c39006a88096cd7b4f4ef545ea0447d250d5ac18202d40b6611d", size = 38696566, upload-time = "2025-10-28T17:34:22.384Z" },
    { url = "https://files.pythonhosted.org/packages/cd/01/1204382461fcbfeb05b6161b594f4007e78b6eba9b375382f79153172b4d/scipy-1.16.3-cp313-cp313-win_amd64.whl", hash = "sha256:062246acacbe9f8210de8e751b16fc37458213f124bef161a5a02c7a39284304", size = 38529877, upload-time = "2025-10-28T17:35:51.076Z" },
    { url = "https://files.pythonhosted.org/packages/7f/14/9d9fbcaa1260a94f4bb5b64ba9213ceb5d03cd88841fe9fd1ffd47a45b73/scipy-1.16.3-cp313-cp313-win_arm64.whl", hash = "sha256:50a3dbf286dbc7d84f176f9a1574c705f277cb6565069f88f60db9eafdbe3ee2", size = 25455366, upload-time = "2025-10-28T17:35:59.014Z" },
    { url = "https://files.pythonhosted.org/packages/e2/a3/9ec205bd49f42d45d77f1730dbad9ccf146244c1647605cf834b3a8c4f36/scipy-1.16.3-cp313-cp313t-macosx_10_14_x86_64.whl", hash = "sha256:fb4b29f4cf8cc5a8d628bc8d8e26d12d7278cd1f219f22698a378c3d67db5e4b", size = 37027931, upload-time = "2025-10-28T17:34:31.451Z" },
    { url = "https://files.pythonhosted.org/packages/25/06/ca9fd1f3a4589cbd825b1447e5db3a8ebb969c1eaf22c8579bd286f51b6d/scipy-1.16.3-cp313-cp313t-macosx_12_0_arm64.whl", hash = "sha256:8d09d72dc92742988b0e7750bddb8060b0c7079606c0d24a8cc8e9c9c11f9079", size = 29400081, upload-time = "2025-10-28T17:34:39.087Z" },
    { url = "https://files.pythonhosted.org/packages/6a/56/933e68210d92657d93fb0e381683bc0e53a965048d7358ff5fbf9e6a1b17/scipy-1.16.3-cp313-cp313t-macosx_14_0_arm64.whl", hash = "sha256:03192a35e661470197556de24e7cb1330d84b35b94ead65c46ad6f16f6b28f2a", size = 21391244, upload-time = "2025-10-28T17:34:45.234Z" },
    { url = "https://files.pythonhosted.org/packages/a8/7e/779845db03dc1418e215726329674b40576879b91814568757ff0014ad65/scipy-1.16.3-cp313-cp313t-macosx_14_0_x86_64.whl", hash = "sha256:57d01cb6f85e34f0946b33caa66e892aae072b64b034183f3d87c4025802a119", size = 23929753, upload-time = "2025-10-28T17:34:51.793Z" },
    { url = "https://files.pythonhosted.org/packages/4c/4b/f756cf8161d5365dcdef9e5f460ab226c068211030a175d2fc7f3f41ca64/scipy-1.16.3-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:96491a6a54e995f00a28a3c3badfff58fd093bf26cd5fb34a2188c8c756a3a2c", size = 33496912, upload-time = "2025-10-28T17:34:59.8Z" },
    { url = "https://files.pythonhosted.org/packages/09/b5/222b1e49a58668f23839ca1542a6322bb095ab8d6590d4f71723869a6c2c/scipy-1.16.3-cp313-cp313t-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:cd13e354df9938598af2be05822c323e97132d5e6306b83a3b4ee6724c6e522e", size = 35802371, upload-time = "2025-10-28T17:35:08.173Z" },
    { url = "https://files.pythonhosted.org/packages/c1/8d/5964ef68bb31829bde27611f8c9deeac13764589fe74a75390242b64ca44/scipy-1.16.3-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:63d3cdacb8a824a295191a723ee5e4ea7768ca5ca5f2838532d9f2e2b3ce2135", size = 36190477, upload-time = "2025-10-28T17:35:16.7Z" },
    { url = "https://files.pythonhosted.org/packages/ab/f2/b31d75cb9b5fa4dd39a0a931ee9b33e7f6f36f23be5ef560bf72e0f92f32/scipy-1.16.3-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:e7efa2681ea410b10dde31a52b18b0154d66f2485328830e45fdf183af5aefc6", size = 38796678, upload-time = "2025-10-28T17:35:26.354Z" },
    { url = "https://files.pythonhosted.org/packages/b4/1e/b3723d8ff64ab548c38d87055483714fefe6ee20e0189b62352b5e015bb1/scipy-1.16.3-cp313-cp313t-win_amd64.whl", hash = "sha256:2d1ae2cf0c350e7705168ff2429962a89ad90c2d49d1dd300686d8b2a5af22fc", size = 38640178, upload-time = "2025-10-28T17:35:35.304Z" },
    { url = "https://files.pythonhosted.org/packages/8e/f3/d854ff38789aca9b0cc23008d607ced9de4f7ab14fa1ca4329f86b3758ca/scipy-1.16.3-cp313-cp313t-win_arm64.whl", hash = "sha256:0c623a54f7b79dd88ef56da19bc2873afec9673a48f3b85b18e4d402bdd29a5a", size = 25803246, upload-time = "2025-10-28T17:35:42.155Z" },
]

[[package]]
name = "setuptools"
version = "80.9.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/18/5d/3bf57dcd21979b887f014ea83c24ae194cfcd12b9e0fda66b957c69d1fca/setuptools-80.9.0.tar.gz", hash = "sha256:f36b47402ecde768dbfafc46e8e4207b4360c654f1f3bb84475f0a28628fb19c", size = 1319958, upload-time = "2025-05-27T00:56:51.443Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a3/dc/17031897dae0efacfea57dfd3a82fdd2a2aeb58e0ff71b77b87e44edc772/setuptools-80.9.0-py3-none-any.whl", hash = "sha256:062d34222ad13e0cc312a4c02d73f059e86a4acbfbdea8f8f76b28c99f306922", size = 1201486, upload-time = "2025-05-27T00:56:49.664Z" },
]

[[package]]
name = "shellingham"
version = "1.5.4"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/58/15/8b3609fd3830ef7b27b655beb4b4e9c62313a4e8da8c676e142cc210d58e/shellingham-1.5.4.tar.gz", hash = "sha256:8dbca0739d487e5bd35ab3ca4b36e11c4078f3a234bfce294b0a0291363404de", size = 10310, upload-time = "2023-10-24T04:13:40.426Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e0/f9/0595336914c5619e5f28a1fb793285925a8cd4b432c9da0a987836c7f822/shellingham-1.5.4-py2.py3-none-any.whl", hash = "sha256:7ecfff8f2fd72616f7481040475a65b2bf8af90a56c89140852d1120324e8686", size = 9755, upload-time = "2023-10-24T04:13:38.866Z" },
]

[[package]]
name = "six"
version = "1.17.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/94/e7/b2c673351809dca68a0e064b6af791aa332cf192da575fd474ed7d6f16a2/six-1.17.0.tar.gz", hash = "sha256:ff70335d468e7eb6ec65b95b99d3a2836546063f63acc5171de367e834932a81", size = 34031, upload-time = "2024-12-04T17:35:28.174Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b7/ce/149a00dd41f10bc29e5921b496af8b574d8413afcd5e30dfa0ed46c2cc5e/six-1.17.0-py2.py3-none-any.whl", hash = "sha256:4721f391ed90541fddacab5acf947aa0d3dc7d27b2e1e8eda2be8970586c3274", size = 11050, upload-time = "2024-12-04T17:35:26.475Z" },
]

[[package]]
name = "sniffio"
version = "1.3.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a2/87/a6771e1546d97e7e041b6ae58d80074f81b7d5121207425c964ddf5cfdbd/sniffio-1.3.1.tar.gz", hash = "sha256:f4324edc670a0f49750a81b895f35c3adb843cca46f0530f79fc1babb23789dc", size = 20372, upload-time = "2024-02-25T23:20:04.057Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e9/44/75a9c9421471a6c4805dbf2356f7c181a29c1879239abab1ea2cc8f38b40/sniffio-1.3.1-py3-none-any.whl", hash = "sha256:2f6da418d1f1e0fddd844478f41680e794e6051915791a034ff65e5f100525a2", size = 10235, upload-time = "2024-02-25T23:20:01.196Z" },
]

[[package]]
name = "soupsieve"
version = "2.8"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/6d/e6/21ccce3262dd4889aa3332e5a119a3491a95e8f60939870a3a035aabac0d/soupsieve-2.8.tar.gz", hash = "sha256:e2dd4a40a628cb5f28f6d4b0db8800b8f581b65bb380b97de22ba5ca8d72572f", size = 103472, upload-time = "2025-08-27T15:39:51.78Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/14/a0/bb38d3b76b8cae341dad93a2dd83ab7462e6dbcdd84d43f54ee60a8dc167/soupsieve-2.8-py3-none-any.whl", hash = "sha256:0cc76456a30e20f5d7f2e14a98a4ae2ee4e5abdc7c5ea0aafe795f344bc7984c", size = 36679, upload-time = "2025-08-27T15:39:50.179Z" },
]

[[package]]
name = "sqlalchemy"
version = "2.0.44"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "greenlet", marker = "platform_machine == 'AMD64' or platform_machine == 'WIN32' or platform_machine == 'aarch64' or platform_machine == 'amd64' or platform_machine == 'ppc64le' or platform_machine == 'win32' or platform_machine == 'x86_64'" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/f0/f2/840d7b9496825333f532d2e3976b8eadbf52034178aac53630d09fe6e1ef/sqlalchemy-2.0.44.tar.gz", hash = "sha256:0ae7454e1ab1d780aee69fd2aae7d6b8670a581d8847f2d1e0f7ddfbf47e5a22", size = 9819830, upload-time = "2025-10-10T14:39:12.935Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e3/81/15d7c161c9ddf0900b076b55345872ed04ff1ed6a0666e5e94ab44b0163c/sqlalchemy-2.0.44-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:0fe3917059c7ab2ee3f35e77757062b1bea10a0b6ca633c58391e3f3c6c488dd", size = 2140517, upload-time = "2025-10-10T15:36:15.64Z" },
    { url = "https://files.pythonhosted.org/packages/d4/d5/4abd13b245c7d91bdf131d4916fd9e96a584dac74215f8b5bc945206a974/sqlalchemy-2.0.44-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:de4387a354ff230bc979b46b2207af841dc8bf29847b6c7dbe60af186d97aefa", size = 2130738, upload-time = "2025-10-10T15:36:16.91Z" },
    { url = "https://files.pythonhosted.org/packages/cb/3c/8418969879c26522019c1025171cefbb2a8586b6789ea13254ac602986c0/sqlalchemy-2.0.44-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c3678a0fb72c8a6a29422b2732fe423db3ce119c34421b5f9955873eb9b62c1e", size = 3304145, upload-time = "2025-10-10T15:34:19.569Z" },
    { url = "https://files.pythonhosted.org/packages/94/2d/fdb9246d9d32518bda5d90f4b65030b9bf403a935cfe4c36a474846517cb/sqlalchemy-2.0.44-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:3cf6872a23601672d61a68f390e44703442639a12ee9dd5a88bbce52a695e46e", size = 3304511, upload-time = "2025-10-10T15:47:05.088Z" },
    { url = "https://files.pythonhosted.org/packages/7d/fb/40f2ad1da97d5c83f6c1269664678293d3fe28e90ad17a1093b735420549/sqlalchemy-2.0.44-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:329aa42d1be9929603f406186630135be1e7a42569540577ba2c69952b7cf399", size = 3235161, upload-time = "2025-10-10T15:34:21.193Z" },
    { url = "https://files.pythonhosted.org/packages/95/cb/7cf4078b46752dca917d18cf31910d4eff6076e5b513c2d66100c4293d83/sqlalchemy-2.0.44-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:70e03833faca7166e6a9927fbee7c27e6ecde436774cd0b24bbcc96353bce06b", size = 3261426, upload-time = "2025-10-10T15:47:07.196Z" },
    { url = "https://files.pythonhosted.org/packages/f8/3b/55c09b285cb2d55bdfa711e778bdffdd0dc3ffa052b0af41f1c5d6e582fa/sqlalchemy-2.0.44-cp311-cp311-win32.whl", hash = "sha256:253e2f29843fb303eca6b2fc645aca91fa7aa0aa70b38b6950da92d44ff267f3", size = 2105392, upload-time = "2025-10-10T15:38:20.051Z" },
    { url = "https://files.pythonhosted.org/packages/c7/23/907193c2f4d680aedbfbdf7bf24c13925e3c7c292e813326c1b84a0b878e/sqlalchemy-2.0.44-cp311-cp311-win_amd64.whl", hash = "sha256:7a8694107eb4308a13b425ca8c0e67112f8134c846b6e1f722698708741215d5", size = 2130293, upload-time = "2025-10-10T15:38:21.601Z" },
    { url = "https://files.pythonhosted.org/packages/62/c4/59c7c9b068e6813c898b771204aad36683c96318ed12d4233e1b18762164/sqlalchemy-2.0.44-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:72fea91746b5890f9e5e0997f16cbf3d53550580d76355ba2d998311b17b2250", size = 2139675, upload-time = "2025-10-10T16:03:31.064Z" },
    { url = "https://files.pythonhosted.org/packages/d6/ae/eeb0920537a6f9c5a3708e4a5fc55af25900216bdb4847ec29cfddf3bf3a/sqlalchemy-2.0.44-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:585c0c852a891450edbb1eaca8648408a3cc125f18cf433941fa6babcc359e29", size = 2127726, upload-time = "2025-10-10T16:03:35.934Z" },
    { url = "https://files.pythonhosted.org/packages/d8/d5/2ebbabe0379418eda8041c06b0b551f213576bfe4c2f09d77c06c07c8cc5/sqlalchemy-2.0.44-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:9b94843a102efa9ac68a7a30cd46df3ff1ed9c658100d30a725d10d9c60a2f44", size = 3327603, upload-time = "2025-10-10T15:35:28.322Z" },
    { url = "https://files.pythonhosted.org/packages/45/e5/5aa65852dadc24b7d8ae75b7efb8d19303ed6ac93482e60c44a585930ea5/sqlalchemy-2.0.44-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:119dc41e7a7defcefc57189cfa0e61b1bf9c228211aba432b53fb71ef367fda1", size = 3337842, upload-time = "2025-10-10T15:43:45.431Z" },
    { url = "https://files.pythonhosted.org/packages/41/92/648f1afd3f20b71e880ca797a960f638d39d243e233a7082c93093c22378/sqlalchemy-2.0.44-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:0765e318ee9179b3718c4fd7ba35c434f4dd20332fbc6857a5e8df17719c24d7", size = 3264558, upload-time = "2025-10-10T15:35:29.93Z" },
    { url = "https://files.pythonhosted.org/packages/40/cf/e27d7ee61a10f74b17740918e23cbc5bc62011b48282170dc4c66da8ec0f/sqlalchemy-2.0.44-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:2e7b5b079055e02d06a4308d0481658e4f06bc7ef211567edc8f7d5dce52018d", size = 3301570, upload-time = "2025-10-10T15:43:48.407Z" },
    { url = "https://files.pythonhosted.org/packages/3b/3d/3116a9a7b63e780fb402799b6da227435be878b6846b192f076d2f838654/sqlalchemy-2.0.44-cp312-cp312-win32.whl", hash = "sha256:846541e58b9a81cce7dee8329f352c318de25aa2f2bbe1e31587eb1f057448b4", size = 2103447, upload-time = "2025-10-10T15:03:21.678Z" },
    { url = "https://files.pythonhosted.org/packages/25/83/24690e9dfc241e6ab062df82cc0df7f4231c79ba98b273fa496fb3dd78ed/sqlalchemy-2.0.44-cp312-cp312-win_amd64.whl", hash = "sha256:7cbcb47fd66ab294703e1644f78971f6f2f1126424d2b300678f419aa73c7b6e", size = 2130912, upload-time = "2025-10-10T15:03:24.656Z" },
    { url = "https://files.pythonhosted.org/packages/45/d3/c67077a2249fdb455246e6853166360054c331db4613cda3e31ab1cadbef/sqlalchemy-2.0.44-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:ff486e183d151e51b1d694c7aa1695747599bb00b9f5f604092b54b74c64a8e1", size = 2135479, upload-time = "2025-10-10T16:03:37.671Z" },
    { url = "https://files.pythonhosted.org/packages/2b/91/eabd0688330d6fd114f5f12c4f89b0d02929f525e6bf7ff80aa17ca802af/sqlalchemy-2.0.44-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:0b1af8392eb27b372ddb783b317dea0f650241cea5bd29199b22235299ca2e45", size = 2123212, upload-time = "2025-10-10T16:03:41.755Z" },
    { url = "https://files.pythonhosted.org/packages/b0/bb/43e246cfe0e81c018076a16036d9b548c4cc649de241fa27d8d9ca6f85ab/sqlalchemy-2.0.44-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:2b61188657e3a2b9ac4e8f04d6cf8e51046e28175f79464c67f2fd35bceb0976", size = 3255353, upload-time = "2025-10-10T15:35:31.221Z" },
    { url = "https://files.pythonhosted.org/packages/b9/96/c6105ed9a880abe346b64d3b6ddef269ddfcab04f7f3d90a0bf3c5a88e82/sqlalchemy-2.0.44-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:b87e7b91a5d5973dda5f00cd61ef72ad75a1db73a386b62877d4875a8840959c", size = 3260222, upload-time = "2025-10-10T15:43:50.124Z" },
    { url = "https://files.pythonhosted.org/packages/44/16/1857e35a47155b5ad927272fee81ae49d398959cb749edca6eaa399b582f/sqlalchemy-2.0.44-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:15f3326f7f0b2bfe406ee562e17f43f36e16167af99c4c0df61db668de20002d", size = 3189614, upload-time = "2025-10-10T15:35:32.578Z" },
    { url = "https://files.pythonhosted.org/packages/88/ee/4afb39a8ee4fc786e2d716c20ab87b5b1fb33d4ac4129a1aaa574ae8a585/sqlalchemy-2.0.44-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:1e77faf6ff919aa8cd63f1c4e561cac1d9a454a191bb864d5dd5e545935e5a40", size = 3226248, upload-time = "2025-10-10T15:43:51.862Z" },
    { url = "https://files.pythonhosted.org/packages/32/d5/0e66097fc64fa266f29a7963296b40a80d6a997b7ac13806183700676f86/sqlalchemy-2.0.44-cp313-cp313-win32.whl", hash = "sha256:ee51625c2d51f8baadf2829fae817ad0b66b140573939dd69284d2ba3553ae73", size = 2101275, upload-time = "2025-10-10T15:03:26.096Z" },
    { url = "https://files.pythonhosted.org/packages/03/51/665617fe4f8c6450f42a6d8d69243f9420f5677395572c2fe9d21b493b7b/sqlalchemy-2.0.44-cp313-cp313-win_amd64.whl", hash = "sha256:c1c80faaee1a6c3428cecf40d16a2365bcf56c424c92c2b6f0f9ad204b899e9e", size = 2127901, upload-time = "2025-10-10T15:03:27.548Z" },
    { url = "https://files.pythonhosted.org/packages/9c/5e/6a29fa884d9fb7ddadf6b69490a9d45fded3b38541713010dad16b77d015/sqlalchemy-2.0.44-py3-none-any.whl", hash = "sha256:19de7ca1246fbef9f9d1bff8f1ab25641569df226364a0e40457dc5457c54b05", size = 1928718, upload-time = "2025-10-10T15:29:45.32Z" },
]

[package.optional-dependencies]
asyncio = [
    { name = "greenlet" },
]

[[package]]
name = "sqlean-py"
version = "3.49.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/67/eb/ac95fab0bc4658124b4ec8fbc31fc494165ab4544606ae91b9a489907dad/sqlean_py-3.49.1.tar.gz", hash = "sha256:210d89989226b988d7d6391f837387d3b81e8cd608c997e0bd37826e395970e7", size = 3319012, upload-time = "2025-05-02T11:58:24.307Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7a/0e/5abd9f12008918dfbce0add356eee8a6f076c3cb24af4a5d2694a8b9f009/sqlean_py-3.49.1-cp311-cp311-macosx_10_15_x86_64.whl", hash = "sha256:9858cd066c7105145d56aae2d9c0a6c8baf343b642e41c9a96a83ff3033e5395", size = 1128201, upload-time = "2025-05-02T11:57:44.744Z" },
    { url = "https://files.pythonhosted.org/packages/39/21/f39ee0b16050b79fb86507e0affd623f6f7fba04f3d3b1dc7e41b93ada7d/sqlean_py-3.49.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:b034fd390fccbb62198e0163e885111de86f2a20767a2f31d38313008cb57442", size = 1053419, upload-time = "2025-05-02T11:57:46.545Z" },
    { url = "https://files.pythonhosted.org/packages/e2/10/2f2bd23d2ec66662bebed7d83fcc912af97dd12be739fd5bd3c08444a55c/sqlean_py-3.49.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:09d7b002f490fd0dad98e884a6e05f062d02ca6520c1910b486fb9e19c5e61ab", size = 2995449, upload-time = "2025-05-02T11:57:47.853Z" },
    { url = "https://files.pythonhosted.org/packages/03/d7/c9970eedb0876f3bcf3f0e230ef68f41fa4bb1c88a67f437f88f0cb0d62b/sqlean_py-3.49.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:f8738695e3ca05cd47b16808d8ad8cd973f1eb6e32497364512a26cb4e61ad63", size = 3000141, upload-time = "2025-05-02T11:57:49.388Z" },
    { url = "https://files.pythonhosted.org/packages/a6/ce/a41b35ecaf7825fbf63cedabfe3ee89f26b75556432ab547476c0f039650/sqlean_py-3.49.1-cp311-cp311-win_amd64.whl", hash = "sha256:7bf2e118ea3c5c16c6a0be4b80d31c9392ffee231e61f08464cc8f892e40c628", size = 803486, upload-time = "2025-05-02T11:57:50.872Z" },
    { url = "https://files.pythonhosted.org/packages/09/dd/6dbcda7d883701eb8a6f55fc5636919b04f84ad9c9be33b3309199150dd4/sqlean_py-3.49.1-cp311-cp311-win_arm64.whl", hash = "sha256:ff575bb11a3013963e4b2edb0eaafc771e8dbe193f22151ee2c3ecc694f25eee", size = 739176, upload-time = "2025-05-02T11:57:52.08Z" },
    { url = "https://files.pythonhosted.org/packages/23/0e/95379c801907f8da939be30c61b63ef881eb18cc0a90713cc74002deaf16/sqlean_py-3.49.1-cp312-cp312-macosx_10_15_x86_64.whl", hash = "sha256:b43397ac27312a20fef8f5db0d011d3676fddea04850d6c35ad1d7644d146f71", size = 1129522, upload-time = "2025-05-02T11:57:53.238Z" },
    { url = "https://files.pythonhosted.org/packages/65/94/b4c5d0ff47f179a0729dc71832558f63a1605e931f773b6d435a767baca9/sqlean_py-3.49.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:56a3388f4fe08e1332af424eaaf378eb9e258165885a4e284c5238e4837b2232", size = 1053757, upload-time = "2025-05-02T11:57:54.966Z" },
    { url = "https://files.pythonhosted.org/packages/2d/11/f8a5c0f7fb889cabbd8c7f887f9e261b65bf45fa1d33a245490855bff53e/sqlean_py-3.49.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:e9bbc00d57f68dbb3f5dea20380bdad7fa9299b3c2a8d8b3798c2bf315146be9", size = 3003708, upload-time = "2025-05-02T11:57:57.035Z" },
    { url = "https://files.pythonhosted.org/packages/47/84/065a21e9a578ef13d9749c2bf3c382f7e50a1644af7d7a109924fbc6faee/sqlean_py-3.49.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:ae92413470409b3b3678c797db82c1d247b6ed2198017b5e893d9fc0606e061f", size = 3008238, upload-time = "2025-05-02T11:57:58.927Z" },
    { url = "https://files.pythonhosted.org/packages/e8/e5/d980bf0c5e67cfd4486b5e6d8daea6815fdac57b3d0899c23127a30283b5/sqlean_py-3.49.1-cp312-cp312-win_amd64.whl", hash = "sha256:b45ed4adb8442299019988d5e90aa1474f3ef8c71f6e8921a70705b9d971c590", size = 804506, upload-time = "2025-05-02T11:58:00.583Z" },
    { url = "https://files.pythonhosted.org/packages/f2/d1/8828ec685022e2b86ebd717743359dd5e8eab70a9c1ebff78aa733848216/sqlean_py-3.49.1-cp312-cp312-win_arm64.whl", hash = "sha256:c2537f69879adaed22b16e840d494c440ece5b49d28a5a51094e6c8ca6a2b0a5", size = 739690, upload-time = "2025-05-02T11:58:02.262Z" },
    { url = "https://files.pythonhosted.org/packages/c4/d3/30a7dc9f6030ea2a1c76fcbb220d1f5d95a16f22f50d4cd80c8778ca5018/sqlean_py-3.49.1-cp313-cp313-macosx_10_15_x86_64.whl", hash = "sha256:ba8e5fc5b9d6682f3fbb626e1f936a4c4ac7377c3d044beaef695e6306a9a39b", size = 1129238, upload-time = "2025-05-02T11:58:04.085Z" },
    { url = "https://files.pythonhosted.org/packages/87/73/ccd43c0d6ca4248005687c5c1ce121924e368c0b195b98880810f468312d/sqlean_py-3.49.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:3112cce35bb97f17b55419e955dc74c7deebb0b548e54d99b3e32bb3d3c62ce4", size = 1053654, upload-time = "2025-05-02T11:58:06.153Z" },
    { url = "https://files.pythonhosted.org/packages/82/d5/cfdb8098117fff9f7856d5c86c93d9c7bebdb5801b551cfabf36e117b764/sqlean_py-3.49.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:9974027675e1edf8a8c90383f95e4038052e96ef7a9a8fa7f8125ed275cc28ba", size = 3000002, upload-time = "2025-05-02T11:58:07.54Z" },
    { url = "https://files.pythonhosted.org/packages/96/52/7e713a61ded163a5fece9fb144b60107889e5d813ba9cff278e65673b6f9/sqlean_py-3.49.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:11fe4e2e74c1749bf98e4aae8fb02978e4c03d4a491be18c4e5b244b29408fdf", size = 3004709, upload-time = "2025-05-02T11:58:09.012Z" },
    { url = "https://files.pythonhosted.org/packages/c4/d6/455e75e1e540b64e230f7282ec55777e030190a486e98a2fce5d6437afa2/sqlean_py-3.49.1-cp313-cp313-win_amd64.whl", hash = "sha256:de820bdb39729044f9ed94f0addfe308b020479334146036a773f470d7594d87", size = 804300, upload-time = "2025-05-02T11:58:10.552Z" },
    { url = "https://files.pythonhosted.org/packages/99/bf/b63830855455fd22278ddc78cc7c64dffb5e1a69c15245c18275317ae9d5/sqlean_py-3.49.1-cp313-cp313-win_arm64.whl", hash = "sha256:3c1661f2fcf4d10ec3940ef8d2146bb58260b409c9033f7a727a6962e2032b7c", size = 739448, upload-time = "2025-05-02T11:58:12.458Z" },
]

[[package]]
name = "sse-starlette"
version = "3.2.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "starlette" },
]
sdist = { url = "https://files.pythonhosted.org/packages/8b/8d/00d280c03ffd39aaee0e86ec81e2d3b9253036a0f93f51d10503adef0e65/sse_starlette-3.2.0.tar.gz", hash = "sha256:8127594edfb51abe44eac9c49e59b0b01f1039d0c7461c6fd91d4e03b70da422", size = 27253, upload-time = "2026-01-17T13:11:05.62Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/96/7f/832f015020844a8b8f7a9cbc103dd76ba8e3875004c41e08440ea3a2b41a/sse_starlette-3.2.0-py3-none-any.whl", hash = "sha256:5876954bd51920fc2cd51baee47a080eb88a37b5b784e615abb0b283f801cdbf", size = 12763, upload-time = "2026-01-17T13:11:03.775Z" },
]

[[package]]
name = "starlette"
version = "0.49.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "typing-extensions", marker = "python_full_version < '3.13'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/de/1a/608df0b10b53b0beb96a37854ee05864d182ddd4b1156a22f1ad3860425a/starlette-0.49.3.tar.gz", hash = "sha256:1c14546f299b5901a1ea0e34410575bc33bbd741377a10484a54445588d00284", size = 2655031, upload-time = "2025-11-01T15:12:26.13Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a3/e0/021c772d6a662f43b63044ab481dc6ac7592447605b5b35a957785363122/starlette-0.49.3-py3-none-any.whl", hash = "sha256:b579b99715fdc2980cf88c8ec96d3bf1ce16f5a8051a7c2b84ef9b1cdecaea2f", size = 74340, upload-time = "2025-11-01T15:12:24.387Z" },
]

[[package]]
name = "stevedore"
version = "5.5.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/2a/5f/8418daad5c353300b7661dd8ce2574b0410a6316a8be650a189d5c68d938/stevedore-5.5.0.tar.gz", hash = "sha256:d31496a4f4df9825e1a1e4f1f74d19abb0154aff311c3b376fcc89dae8fccd73", size = 513878, upload-time = "2025-08-25T12:54:26.806Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/80/c5/0c06759b95747882bb50abda18f5fb48c3e9b0fbfc6ebc0e23550b52415d/stevedore-5.5.0-py3-none-any.whl", hash = "sha256:18363d4d268181e8e8452e71a38cd77630f345b2ef6b4a8d5614dac5ee0d18cf", size = 49518, upload-time = "2025-08-25T12:54:25.445Z" },
]

[[package]]
name = "strawberry-graphql"
version = "0.270.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "graphql-core" },
    { name = "packaging" },
    { name = "python-dateutil" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/67/aa/9d8a53fbf0271e7a5c5155b76d256caf4b94f422676226253648871cc7c1/strawberry_graphql-0.270.1.tar.gz", hash = "sha256:d64524a943851d83252e39b82ef768ee494259edecf9510b37bad9a46b745db8", size = 207190, upload-time = "2025-05-22T12:29:28.617Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/99/e0/c45d74578e7b8cb7e082697d998cebd8ef97afa3d7aedc22e4acd8ae7163/strawberry_graphql-0.270.1-py3-none-any.whl", hash = "sha256:3593086dc08614ae241cb88f7691e90f90b01cab6ee6351cb3838fc5ba8bfab0", size = 301232, upload-time = "2025-05-22T12:29:25.739Z" },
]

[[package]]
name = "striprtf"
version = "0.0.26"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/25/20/3d419008265346452d09e5dadfd5d045b64b40d8fc31af40588e6c76997a/striprtf-0.0.26.tar.gz", hash = "sha256:fdb2bba7ac440072d1c41eab50d8d74ae88f60a8b6575c6e2c7805dc462093aa", size = 6258, upload-time = "2023-07-20T14:30:36.29Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a3/cf/0fea4f4ba3fc2772ac2419278aa9f6964124d4302117d61bc055758e000c/striprtf-0.0.26-py3-none-any.whl", hash = "sha256:8c8f9d32083cdc2e8bfb149455aa1cc5a4e0a035893bedc75db8b73becb3a1bb", size = 6914, upload-time = "2023-07-20T14:30:35.338Z" },
]

[[package]]
name = "tenacity"
version = "9.1.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/0a/d4/2b0cd0fe285e14b36db076e78c93766ff1d529d70408bd1d2a5a84f1d929/tenacity-9.1.2.tar.gz", hash = "sha256:1169d376c297e7de388d18b4481760d478b0e99a777cad3a9c86e556f4b697cb", size = 48036, upload-time = "2025-04-02T08:25:09.966Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e5/30/643397144bfbfec6f6ef821f36f33e57d35946c44a2352d3c9f0ae847619/tenacity-9.1.2-py3-none-any.whl", hash = "sha256:f77bf36710d8b73a50b2dd155c97b870017ad21afe6ab300326b0371b3b05138", size = 28248, upload-time = "2025-04-02T08:25:07.678Z" },
]

[[package]]
name = "textual"
version = "6.11.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markdown-it-py", extra = ["linkify"] },
    { name = "mdit-py-plugins" },
    { name = "platformdirs" },
    { name = "pygments" },
    { name = "rich" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/55/06/906f86bbc59ec7cd3fb424250e19ce670406d1f28e49e86c2221e9fd7ed2/textual-6.11.0.tar.gz", hash = "sha256:08237ebda0cfbbfd1a4e2fd3039882b35894a73994f6f0fcc12c5b0d78acf3cc", size = 1584292, upload-time = "2025-12-18T10:48:38.033Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b5/fc/5e2988590ff2e0128eea6446806c904445a44e17256c67141573ea16b5a5/textual-6.11.0-py3-none-any.whl", hash = "sha256:9e663b73ed37123a9b13c16a0c85e09ef917a4cfded97814361ed5cccfa40f89", size = 714886, upload-time = "2025-12-18T10:48:36.269Z" },
]

[[package]]
name = "threadpoolctl"
version = "3.6.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b7/4d/08c89e34946fce2aec4fbb45c9016efd5f4d7f24af8e5d93296e935631d8/threadpoolctl-3.6.0.tar.gz", hash = "sha256:8ab8b4aa3491d812b623328249fab5302a68d2d71745c8a4c719a2fcaba9f44e", size = 21274, upload-time = "2025-03-13T13:49:23.031Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/32/d5/f9a850d79b0851d1d4ef6456097579a9005b31fea68726a4ae5f2d82ddd9/threadpoolctl-3.6.0-py3-none-any.whl", hash = "sha256:43a0b8fd5a2928500110039e43a5eed8480b918967083ea48dc3ab9f13c4a7fb", size = 18638, upload-time = "2025-03-13T13:49:21.846Z" },
]

[[package]]
name = "tiktoken"
version = "0.12.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "regex" },
    { name = "requests" },
]
sdist = { url = "https://files.pythonhosted.org/packages/7d/ab/4d017d0f76ec3171d469d80fc03dfbb4e48a4bcaddaa831b31d526f05edc/tiktoken-0.12.0.tar.gz", hash = "sha256:b18ba7ee2b093863978fcb14f74b3707cdc8d4d4d3836853ce7ec60772139931", size = 37806, upload-time = "2025-10-06T20:22:45.419Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/de/46/21ea696b21f1d6d1efec8639c204bdf20fde8bafb351e1355c72c5d7de52/tiktoken-0.12.0-cp311-cp311-macosx_10_12_x86_64.whl", hash = "sha256:6e227c7f96925003487c33b1b32265fad2fbcec2b7cf4817afb76d416f40f6bb", size = 1051565, upload-time = "2025-10-06T20:21:44.566Z" },
    { url = "https://files.pythonhosted.org/packages/c9/d9/35c5d2d9e22bb2a5f74ba48266fb56c63d76ae6f66e02feb628671c0283e/tiktoken-0.12.0-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:c06cf0fcc24c2cb2adb5e185c7082a82cba29c17575e828518c2f11a01f445aa", size = 995284, upload-time = "2025-10-06T20:21:45.622Z" },
    { url = "https://files.pythonhosted.org/packages/01/84/961106c37b8e49b9fdcf33fe007bb3a8fdcc380c528b20cc7fbba80578b8/tiktoken-0.12.0-cp311-cp311-manylinux_2_28_aarch64.whl", hash = "sha256:f18f249b041851954217e9fd8e5c00b024ab2315ffda5ed77665a05fa91f42dc", size = 1129201, upload-time = "2025-10-06T20:21:47.074Z" },
    { url = "https://files.pythonhosted.org/packages/6a/d0/3d9275198e067f8b65076a68894bb52fd253875f3644f0a321a720277b8a/tiktoken-0.12.0-cp311-cp311-manylinux_2_28_x86_64.whl", hash = "sha256:47a5bc270b8c3db00bb46ece01ef34ad050e364b51d406b6f9730b64ac28eded", size = 1152444, upload-time = "2025-10-06T20:21:48.139Z" },
    { url = "https://files.pythonhosted.org/packages/78/db/a58e09687c1698a7c592e1038e01c206569b86a0377828d51635561f8ebf/tiktoken-0.12.0-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:508fa71810c0efdcd1b898fda574889ee62852989f7c1667414736bcb2b9a4bd", size = 1195080, upload-time = "2025-10-06T20:21:49.246Z" },
    { url = "https://files.pythonhosted.org/packages/9e/1b/a9e4d2bf91d515c0f74afc526fd773a812232dd6cda33ebea7f531202325/tiktoken-0.12.0-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:a1af81a6c44f008cba48494089dd98cccb8b313f55e961a52f5b222d1e507967", size = 1255240, upload-time = "2025-10-06T20:21:50.274Z" },
    { url = "https://files.pythonhosted.org/packages/9d/15/963819345f1b1fb0809070a79e9dd96938d4ca41297367d471733e79c76c/tiktoken-0.12.0-cp311-cp311-win_amd64.whl", hash = "sha256:3e68e3e593637b53e56f7237be560f7a394451cb8c11079755e80ae64b9e6def", size = 879422, upload-time = "2025-10-06T20:21:51.734Z" },
    { url = "https://files.pythonhosted.org/packages/a4/85/be65d39d6b647c79800fd9d29241d081d4eeb06271f383bb87200d74cf76/tiktoken-0.12.0-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:b97f74aca0d78a1ff21b8cd9e9925714c15a9236d6ceacf5c7327c117e6e21e8", size = 1050728, upload-time = "2025-10-06T20:21:52.756Z" },
    { url = "https://files.pythonhosted.org/packages/4a/42/6573e9129bc55c9bf7300b3a35bef2c6b9117018acca0dc760ac2d93dffe/tiktoken-0.12.0-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:2b90f5ad190a4bb7c3eb30c5fa32e1e182ca1ca79f05e49b448438c3e225a49b", size = 994049, upload-time = "2025-10-06T20:21:53.782Z" },
    { url = "https://files.pythonhosted.org/packages/66/c5/ed88504d2f4a5fd6856990b230b56d85a777feab84e6129af0822f5d0f70/tiktoken-0.12.0-cp312-cp312-manylinux_2_28_aarch64.whl", hash = "sha256:65b26c7a780e2139e73acc193e5c63ac754021f160df919add909c1492c0fb37", size = 1129008, upload-time = "2025-10-06T20:21:54.832Z" },
    { url = "https://files.pythonhosted.org/packages/f4/90/3dae6cc5436137ebd38944d396b5849e167896fc2073da643a49f372dc4f/tiktoken-0.12.0-cp312-cp312-manylinux_2_28_x86_64.whl", hash = "sha256:edde1ec917dfd21c1f2f8046b86348b0f54a2c0547f68149d8600859598769ad", size = 1152665, upload-time = "2025-10-06T20:21:56.129Z" },
    { url = "https://files.pythonhosted.org/packages/a3/fe/26df24ce53ffde419a42f5f53d755b995c9318908288c17ec3f3448313a3/tiktoken-0.12.0-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:35a2f8ddd3824608b3d650a000c1ef71f730d0c56486845705a8248da00f9fe5", size = 1194230, upload-time = "2025-10-06T20:21:57.546Z" },
    { url = "https://files.pythonhosted.org/packages/20/cc/b064cae1a0e9fac84b0d2c46b89f4e57051a5f41324e385d10225a984c24/tiktoken-0.12.0-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:83d16643edb7fa2c99eff2ab7733508aae1eebb03d5dfc46f5565862810f24e3", size = 1254688, upload-time = "2025-10-06T20:21:58.619Z" },
    { url = "https://files.pythonhosted.org/packages/81/10/b8523105c590c5b8349f2587e2fdfe51a69544bd5a76295fc20f2374f470/tiktoken-0.12.0-cp312-cp312-win_amd64.whl", hash = "sha256:ffc5288f34a8bc02e1ea7047b8d041104791d2ddbf42d1e5fa07822cbffe16bd", size = 878694, upload-time = "2025-10-06T20:21:59.876Z" },
    { url = "https://files.pythonhosted.org/packages/00/61/441588ee21e6b5cdf59d6870f86beb9789e532ee9718c251b391b70c68d6/tiktoken-0.12.0-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:775c2c55de2310cc1bc9a3ad8826761cbdc87770e586fd7b6da7d4589e13dab3", size = 1050802, upload-time = "2025-10-06T20:22:00.96Z" },
    { url = "https://files.pythonhosted.org/packages/1f/05/dcf94486d5c5c8d34496abe271ac76c5b785507c8eae71b3708f1ad9b45a/tiktoken-0.12.0-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:a01b12f69052fbe4b080a2cfb867c4de12c704b56178edf1d1d7b273561db160", size = 993995, upload-time = "2025-10-06T20:22:02.788Z" },
    { url = "https://files.pythonhosted.org/packages/a0/70/5163fe5359b943f8db9946b62f19be2305de8c3d78a16f629d4165e2f40e/tiktoken-0.12.0-cp313-cp313-manylinux_2_28_aarch64.whl", hash = "sha256:01d99484dc93b129cd0964f9d34eee953f2737301f18b3c7257bf368d7615baa", size = 1128948, upload-time = "2025-10-06T20:22:03.814Z" },
    { url = "https://files.pythonhosted.org/packages/0c/da/c028aa0babf77315e1cef357d4d768800c5f8a6de04d0eac0f377cb619fa/tiktoken-0.12.0-cp313-cp313-manylinux_2_28_x86_64.whl", hash = "sha256:4a1a4fcd021f022bfc81904a911d3df0f6543b9e7627b51411da75ff2fe7a1be", size = 1151986, upload-time = "2025-10-06T20:22:05.173Z" },
    { url = "https://files.pythonhosted.org/packages/a0/5a/886b108b766aa53e295f7216b509be95eb7d60b166049ce2c58416b25f2a/tiktoken-0.12.0-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:981a81e39812d57031efdc9ec59fa32b2a5a5524d20d4776574c4b4bd2e9014a", size = 1194222, upload-time = "2025-10-06T20:22:06.265Z" },
    { url = "https://files.pythonhosted.org/packages/f4/f8/4db272048397636ac7a078d22773dd2795b1becee7bc4922fe6207288d57/tiktoken-0.12.0-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:9baf52f84a3f42eef3ff4e754a0db79a13a27921b457ca9832cf944c6be4f8f3", size = 1255097, upload-time = "2025-10-06T20:22:07.403Z" },
    { url = "https://files.pythonhosted.org/packages/8e/32/45d02e2e0ea2be3a9ed22afc47d93741247e75018aac967b713b2941f8ea/tiktoken-0.12.0-cp313-cp313-win_amd64.whl", hash = "sha256:b8a0cd0c789a61f31bf44851defbd609e8dd1e2c8589c614cc1060940ef1f697", size = 879117, upload-time = "2025-10-06T20:22:08.418Z" },
    { url = "https://files.pythonhosted.org/packages/ce/76/994fc868f88e016e6d05b0da5ac24582a14c47893f4474c3e9744283f1d5/tiktoken-0.12.0-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:d5f89ea5680066b68bcb797ae85219c72916c922ef0fcdd3480c7d2315ffff16", size = 1050309, upload-time = "2025-10-06T20:22:10.939Z" },
    { url = "https://files.pythonhosted.org/packages/f6/b8/57ef1456504c43a849821920d582a738a461b76a047f352f18c0b26c6516/tiktoken-0.12.0-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:b4e7ed1c6a7a8a60a3230965bdedba8cc58f68926b835e519341413370e0399a", size = 993712, upload-time = "2025-10-06T20:22:12.115Z" },
    { url = "https://files.pythonhosted.org/packages/72/90/13da56f664286ffbae9dbcfadcc625439142675845baa62715e49b87b68b/tiktoken-0.12.0-cp313-cp313t-manylinux_2_28_aarch64.whl", hash = "sha256:fc530a28591a2d74bce821d10b418b26a094bf33839e69042a6e86ddb7a7fb27", size = 1128725, upload-time = "2025-10-06T20:22:13.541Z" },
    { url = "https://files.pythonhosted.org/packages/05/df/4f80030d44682235bdaecd7346c90f67ae87ec8f3df4a3442cb53834f7e4/tiktoken-0.12.0-cp313-cp313t-manylinux_2_28_x86_64.whl", hash = "sha256:06a9f4f49884139013b138920a4c393aa6556b2f8f536345f11819389c703ebb", size = 1151875, upload-time = "2025-10-06T20:22:14.559Z" },
    { url = "https://files.pythonhosted.org/packages/22/1f/ae535223a8c4ef4c0c1192e3f9b82da660be9eb66b9279e95c99288e9dab/tiktoken-0.12.0-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:04f0e6a985d95913cabc96a741c5ffec525a2c72e9df086ff17ebe35985c800e", size = 1194451, upload-time = "2025-10-06T20:22:15.545Z" },
    { url = "https://files.pythonhosted.org/packages/78/a7/f8ead382fce0243cb625c4f266e66c27f65ae65ee9e77f59ea1653b6d730/tiktoken-0.12.0-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:0ee8f9ae00c41770b5f9b0bb1235474768884ae157de3beb5439ca0fd70f3e25", size = 1253794, upload-time = "2025-10-06T20:22:16.624Z" },
    { url = "https://files.pythonhosted.org/packages/93/e0/6cc82a562bc6365785a3ff0af27a2a092d57c47d7a81d9e2295d8c36f011/tiktoken-0.12.0-cp313-cp313t-win_amd64.whl", hash = "sha256:dc2dd125a62cb2b3d858484d6c614d136b5b848976794edfb63688d539b8b93f", size = 878777, upload-time = "2025-10-06T20:22:18.036Z" },
]

[[package]]
name = "tokenizers"
version = "0.22.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "huggingface-hub" },
]
sdist = { url = "https://files.pythonhosted.org/packages/1c/46/fb6854cec3278fbfa4a75b50232c77622bc517ac886156e6afbfa4d8fc6e/tokenizers-0.22.1.tar.gz", hash = "sha256:61de6522785310a309b3407bac22d99c4db5dba349935e99e4d15ea2226af2d9", size = 363123, upload-time = "2025-09-19T09:49:23.424Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/bf/33/f4b2d94ada7ab297328fc671fed209368ddb82f965ec2224eb1892674c3a/tokenizers-0.22.1-cp39-abi3-macosx_10_12_x86_64.whl", hash = "sha256:59fdb013df17455e5f950b4b834a7b3ee2e0271e6378ccb33aa74d178b513c73", size = 3069318, upload-time = "2025-09-19T09:49:11.848Z" },
    { url = "https://files.pythonhosted.org/packages/1c/58/2aa8c874d02b974990e89ff95826a4852a8b2a273c7d1b4411cdd45a4565/tokenizers-0.22.1-cp39-abi3-macosx_11_0_arm64.whl", hash = "sha256:8d4e484f7b0827021ac5f9f71d4794aaef62b979ab7608593da22b1d2e3c4edc", size = 2926478, upload-time = "2025-09-19T09:49:09.759Z" },
    { url = "https://files.pythonhosted.org/packages/1e/3b/55e64befa1e7bfea963cf4b787b2cea1011362c4193f5477047532ce127e/tokenizers-0.22.1-cp39-abi3-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:19d2962dd28bc67c1f205ab180578a78eef89ac60ca7ef7cbe9635a46a56422a", size = 3256994, upload-time = "2025-09-19T09:48:56.701Z" },
    { url = "https://files.pythonhosted.org/packages/71/0b/fbfecf42f67d9b7b80fde4aabb2b3110a97fac6585c9470b5bff103a80cb/tokenizers-0.22.1-cp39-abi3-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:38201f15cdb1f8a6843e6563e6e79f4abd053394992b9bbdf5213ea3469b4ae7", size = 3153141, upload-time = "2025-09-19T09:48:59.749Z" },
    { url = "https://files.pythonhosted.org/packages/17/a9/b38f4e74e0817af8f8ef925507c63c6ae8171e3c4cb2d5d4624bf58fca69/tokenizers-0.22.1-cp39-abi3-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:d1cbe5454c9a15df1b3443c726063d930c16f047a3cc724b9e6e1a91140e5a21", size = 3508049, upload-time = "2025-09-19T09:49:05.868Z" },
    { url = "https://files.pythonhosted.org/packages/d2/48/dd2b3dac46bb9134a88e35d72e1aa4869579eacc1a27238f1577270773ff/tokenizers-0.22.1-cp39-abi3-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:e7d094ae6312d69cc2a872b54b91b309f4f6fbce871ef28eb27b52a98e4d0214", size = 3710730, upload-time = "2025-09-19T09:49:01.832Z" },
    { url = "https://files.pythonhosted.org/packages/93/0e/ccabc8d16ae4ba84a55d41345207c1e2ea88784651a5a487547d80851398/tokenizers-0.22.1-cp39-abi3-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:afd7594a56656ace95cdd6df4cca2e4059d294c5cfb1679c57824b605556cb2f", size = 3412560, upload-time = "2025-09-19T09:49:03.867Z" },
    { url = "https://files.pythonhosted.org/packages/d0/c6/dc3a0db5a6766416c32c034286d7c2d406da1f498e4de04ab1b8959edd00/tokenizers-0.22.1-cp39-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:e2ef6063d7a84994129732b47e7915e8710f27f99f3a3260b8a38fc7ccd083f4", size = 3250221, upload-time = "2025-09-19T09:49:07.664Z" },
    { url = "https://files.pythonhosted.org/packages/d7/a6/2c8486eef79671601ff57b093889a345dd3d576713ef047776015dc66de7/tokenizers-0.22.1-cp39-abi3-musllinux_1_2_aarch64.whl", hash = "sha256:ba0a64f450b9ef412c98f6bcd2a50c6df6e2443b560024a09fa6a03189726879", size = 9345569, upload-time = "2025-09-19T09:49:14.214Z" },
    { url = "https://files.pythonhosted.org/packages/6b/16/32ce667f14c35537f5f605fe9bea3e415ea1b0a646389d2295ec348d5657/tokenizers-0.22.1-cp39-abi3-musllinux_1_2_armv7l.whl", hash = "sha256:331d6d149fa9c7d632cde4490fb8bbb12337fa3a0232e77892be656464f4b446", size = 9271599, upload-time = "2025-09-19T09:49:16.639Z" },
    { url = "https://files.pythonhosted.org/packages/51/7c/a5f7898a3f6baa3fc2685c705e04c98c1094c523051c805cdd9306b8f87e/tokenizers-0.22.1-cp39-abi3-musllinux_1_2_i686.whl", hash = "sha256:607989f2ea68a46cb1dfbaf3e3aabdf3f21d8748312dbeb6263d1b3b66c5010a", size = 9533862, upload-time = "2025-09-19T09:49:19.146Z" },
    { url = "https://files.pythonhosted.org/packages/36/65/7e75caea90bc73c1dd8d40438adf1a7bc26af3b8d0a6705ea190462506e1/tokenizers-0.22.1-cp39-abi3-musllinux_1_2_x86_64.whl", hash = "sha256:a0f307d490295717726598ef6fa4f24af9d484809223bbc253b201c740a06390", size = 9681250, upload-time = "2025-09-19T09:49:21.501Z" },
    { url = "https://files.pythonhosted.org/packages/30/2c/959dddef581b46e6209da82df3b78471e96260e2bc463f89d23b1bf0e52a/tokenizers-0.22.1-cp39-abi3-win32.whl", hash = "sha256:b5120eed1442765cd90b903bb6cfef781fd8fe64e34ccaecbae4c619b7b12a82", size = 2472003, upload-time = "2025-09-19T09:49:27.089Z" },
    { url = "https://files.pythonhosted.org/packages/b3/46/e33a8c93907b631a99377ef4c5f817ab453d0b34f93529421f42ff559671/tokenizers-0.22.1-cp39-abi3-win_amd64.whl", hash = "sha256:65fd6e3fb11ca1e78a6a93602490f134d1fdeb13bcef99389d5102ea318ed138", size = 2674684, upload-time = "2025-09-19T09:49:24.953Z" },
]

[[package]]
name = "tomlkit"
version = "0.13.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/cc/18/0bbf3884e9eaa38819ebe46a7bd25dcd56b67434402b66a58c4b8e552575/tomlkit-0.13.3.tar.gz", hash = "sha256:430cf247ee57df2b94ee3fbe588e71d362a941ebb545dec29b53961d61add2a1", size = 185207, upload-time = "2025-06-05T07:13:44.947Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/bd/75/8539d011f6be8e29f339c42e633aae3cb73bffa95dd0f9adec09b9c58e85/tomlkit-0.13.3-py3-none-any.whl", hash = "sha256:c89c649d79ee40629a9fda55f8ace8c6a1b42deb912b2a8fd8d942ddadb606b0", size = 38901, upload-time = "2025-06-05T07:13:43.546Z" },
]

[[package]]
name = "tqdm"
version = "4.67.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama", marker = "sys_platform == 'win32'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/a8/4b/29b4ef32e036bb34e4ab51796dd745cdba7ed47ad142a9f4a1eb8e0c744d/tqdm-4.67.1.tar.gz", hash = "sha256:f8aef9c52c08c13a65f30ea34f4e5aac3fd1a34959879d7e59e63027286627f2", size = 169737, upload-time = "2024-11-24T20:12:22.481Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d0/30/dc54f88dd4a2b5dc8a0279bdd7270e735851848b762aeb1c1184ed1f6b14/tqdm-4.67.1-py3-none-any.whl", hash = "sha256:26445eca388f82e72884e0d580d5464cd801a3ea01e63e5601bdff9ba6a48de2", size = 78540, upload-time = "2024-11-24T20:12:19.698Z" },
]

[[package]]
name = "transformers"
version = "4.57.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "filelock" },
    { name = "huggingface-hub" },
    { name = "numpy" },
    { name = "packaging" },
    { name = "pyyaml" },
    { name = "regex" },
    { name = "requests" },
    { name = "safetensors" },
    { name = "tokenizers" },
    { name = "tqdm" },
]
sdist = { url = "https://files.pythonhosted.org/packages/d6/68/a39307bcc4116a30b2106f2e689130a48de8bd8a1e635b5e1030e46fcd9e/transformers-4.57.1.tar.gz", hash = "sha256:f06c837959196c75039809636cd964b959f6604b75b8eeec6fdfc0440b89cc55", size = 10142511, upload-time = "2025-10-14T15:39:26.18Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/71/d3/c16c3b3cf7655a67db1144da94b021c200ac1303f82428f2beef6c2e72bb/transformers-4.57.1-py3-none-any.whl", hash = "sha256:b10d05da8fa67dc41644dbbf9bc45a44cb86ae33da6f9295f5fbf5b7890bd267", size = 11990925, upload-time = "2025-10-14T15:39:23.085Z" },
]

[[package]]
name = "typer"
version = "0.20.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "rich" },
    { name = "shellingham" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/8f/28/7c85c8032b91dbe79725b6f17d2fffc595dff06a35c7a30a37bef73a1ab4/typer-0.20.0.tar.gz", hash = "sha256:1aaf6494031793e4876fb0bacfa6a912b551cf43c1e63c800df8b1a866720c37", size = 106492, upload-time = "2025-10-20T17:03:49.445Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/78/64/7713ffe4b5983314e9d436a90d5bd4f63b6054e2aca783a3cfc44cb95bbf/typer-0.20.0-py3-none-any.whl", hash = "sha256:5b463df6793ec1dca6213a3cf4c0f03bc6e322ac5e16e13ddd622a889489784a", size = 47028, upload-time = "2025-10-20T17:03:47.617Z" },
]

[[package]]
name = "typing-extensions"
version = "4.15.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/72/94/1a15dd82efb362ac84269196e94cf00f187f7ed21c242792a923cdb1c61f/typing_extensions-4.15.0.tar.gz", hash = "sha256:0cea48d173cc12fa28ecabc3b837ea3cf6f38c6d1136f85cbaaf598984861466", size = 109391, upload-time = "2025-08-25T13:49:26.313Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/18/67/36e9267722cc04a6b9f15c7f3441c2363321a3ea07da7ae0c0707beb2a9c/typing_extensions-4.15.0-py3-none-any.whl", hash = "sha256:f0fa19c6845758ab08074a0cfa8b7aecb71c999ca73d62883bc25cc018c4e548", size = 44614, upload-time = "2025-08-25T13:49:24.86Z" },
]

[[package]]
name = "typing-inspect"
version = "0.9.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "mypy-extensions" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/dc/74/1789779d91f1961fa9438e9a8710cdae6bd138c80d7303996933d117264a/typing_inspect-0.9.0.tar.gz", hash = "sha256:b23fc42ff6f6ef6954e4852c1fb512cdd18dbea03134f91f856a95ccc9461f78", size = 13825, upload-time = "2023-05-24T20:25:47.612Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/65/f3/107a22063bf27bdccf2024833d3445f4eea42b2e598abfbd46f6a63b6cb0/typing_inspect-0.9.0-py3-none-any.whl", hash = "sha256:9ee6fc59062311ef8547596ab6b955e1b8aa46242d854bfc78f4f6b0eff35f9f", size = 8827, upload-time = "2023-05-24T20:25:45.287Z" },
]

[[package]]
name = "typing-inspection"
version = "0.4.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/55/e3/70399cb7dd41c10ac53367ae42139cf4b1ca5f36bb3dc6c9d33acdb43655/typing_inspection-0.4.2.tar.gz", hash = "sha256:ba561c48a67c5958007083d386c3295464928b01faa735ab8547c5692e87f464", size = 75949, upload-time = "2025-10-01T02:14:41.687Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/dc/9b/47798a6c91d8bdb567fe2698fe81e0c6b7cb7ef4d13da4114b41d239f65d/typing_inspection-0.4.2-py3-none-any.whl", hash = "sha256:4ed1cacbdc298c220f1bd249ed5287caa16f34d44ef4e9c3d0cbad5b521545e7", size = 14611, upload-time = "2025-10-01T02:14:40.154Z" },
]

[[package]]
name = "tzdata"
version = "2025.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/95/32/1a225d6164441be760d75c2c42e2780dc0873fe382da3e98a2e1e48361e5/tzdata-2025.2.tar.gz", hash = "sha256:b60a638fcc0daffadf82fe0f57e53d06bdec2f36c4df66280ae79bce6bd6f2b9", size = 196380, upload-time = "2025-03-23T13:54:43.652Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/5c/23/c7abc0ca0a1526a0774eca151daeb8de62ec457e77262b66b359c3c7679e/tzdata-2025.2-py2.py3-none-any.whl", hash = "sha256:1a403fada01ff9221ca8044d701868fa132215d84beb92242d9acd2147f667a8", size = 347839, upload-time = "2025-03-23T13:54:41.845Z" },
]

[[package]]
name = "uc-micro-py"
version = "1.0.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/91/7a/146a99696aee0609e3712f2b44c6274566bc368dfe8375191278045186b8/uc-micro-py-1.0.3.tar.gz", hash = "sha256:d321b92cff673ec58027c04015fcaa8bb1e005478643ff4a500882eaab88c48a", size = 6043, upload-time = "2024-02-09T16:52:01.654Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/37/87/1f677586e8ac487e29672e4b17455758fce261de06a0d086167bb760361a/uc_micro_py-1.0.3-py3-none-any.whl", hash = "sha256:db1dffff340817673d7b466ec86114a9dc0e9d4d9b5ba229d9d60e5c12600cd5", size = 6229, upload-time = "2024-02-09T16:52:00.371Z" },
]

[[package]]
name = "urllib3"
version = "2.6.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/c7/24/5f1b3bdffd70275f6661c76461e25f024d5a38a46f04aaca912426a2b1d3/urllib3-2.6.3.tar.gz", hash = "sha256:1b62b6884944a57dbe321509ab94fd4d3b307075e0c2eae991ac71ee15ad38ed", size = 435556, upload-time = "2026-01-07T16:24:43.925Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/39/08/aaaad47bc4e9dc8c725e68f9d04865dbcb2052843ff09c97b08904852d84/urllib3-2.6.3-py3-none-any.whl", hash = "sha256:bf272323e553dfb2e87d9bfd225ca7b0f467b919d7bbd355436d3fd37cb0acd4", size = 131584, upload-time = "2026-01-07T16:24:42.685Z" },
]

[[package]]
name = "uvicorn"
version = "0.38.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "h11" },
]
sdist = { url = "https://files.pythonhosted.org/packages/cb/ce/f06b84e2697fef4688ca63bdb2fdf113ca0a3be33f94488f2cadb690b0cf/uvicorn-0.38.0.tar.gz", hash = "sha256:fd97093bdd120a2609fc0d3afe931d4d4ad688b6e75f0f929fde1bc36fe0e91d", size = 80605, upload-time = "2025-10-18T13:46:44.63Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ee/d9/d88e73ca598f4f6ff671fb5fde8a32925c2e08a637303a1d12883c7305fa/uvicorn-0.38.0-py3-none-any.whl", hash = "sha256:48c0afd214ceb59340075b4a052ea1ee91c16fbc2a9b1469cca0e54566977b02", size = 68109, upload-time = "2025-10-18T13:46:42.958Z" },
]

[[package]]
name = "websockets"
version = "15.0.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/21/e6/26d09fab466b7ca9c7737474c52be4f76a40301b08362eb2dbc19dcc16c1/websockets-15.0.1.tar.gz", hash = "sha256:82544de02076bafba038ce055ee6412d68da13ab47f0c60cab827346de828dee", size = 177016, upload-time = "2025-03-05T20:03:41.606Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9f/32/18fcd5919c293a398db67443acd33fde142f283853076049824fc58e6f75/websockets-15.0.1-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:823c248b690b2fd9303ba00c4f66cd5e2d8c3ba4aa968b2779be9532a4dad431", size = 175423, upload-time = "2025-03-05T20:01:56.276Z" },
    { url = "https://files.pythonhosted.org/packages/76/70/ba1ad96b07869275ef42e2ce21f07a5b0148936688c2baf7e4a1f60d5058/websockets-15.0.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:678999709e68425ae2593acf2e3ebcbcf2e69885a5ee78f9eb80e6e371f1bf57", size = 173082, upload-time = "2025-03-05T20:01:57.563Z" },
    { url = "https://files.pythonhosted.org/packages/86/f2/10b55821dd40eb696ce4704a87d57774696f9451108cff0d2824c97e0f97/websockets-15.0.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:d50fd1ee42388dcfb2b3676132c78116490976f1300da28eb629272d5d93e905", size = 173330, upload-time = "2025-03-05T20:01:59.063Z" },
    { url = "https://files.pythonhosted.org/packages/a5/90/1c37ae8b8a113d3daf1065222b6af61cc44102da95388ac0018fcb7d93d9/websockets-15.0.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:d99e5546bf73dbad5bf3547174cd6cb8ba7273062a23808ffea025ecb1cf8562", size = 182878, upload-time = "2025-03-05T20:02:00.305Z" },
    { url = "https://files.pythonhosted.org/packages/8e/8d/96e8e288b2a41dffafb78e8904ea7367ee4f891dafc2ab8d87e2124cb3d3/websockets-15.0.1-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:66dd88c918e3287efc22409d426c8f729688d89a0c587c88971a0faa2c2f3792", size = 181883, upload-time = "2025-03-05T20:02:03.148Z" },
    { url = "https://files.pythonhosted.org/packages/93/1f/5d6dbf551766308f6f50f8baf8e9860be6182911e8106da7a7f73785f4c4/websockets-15.0.1-cp311-cp311-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:8dd8327c795b3e3f219760fa603dcae1dcc148172290a8ab15158cf85a953413", size = 182252, upload-time = "2025-03-05T20:02:05.29Z" },
    { url = "https://files.pythonhosted.org/packages/d4/78/2d4fed9123e6620cbf1706c0de8a1632e1a28e7774d94346d7de1bba2ca3/websockets-15.0.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:8fdc51055e6ff4adeb88d58a11042ec9a5eae317a0a53d12c062c8a8865909e8", size = 182521, upload-time = "2025-03-05T20:02:07.458Z" },
    { url = "https://files.pythonhosted.org/packages/e7/3b/66d4c1b444dd1a9823c4a81f50231b921bab54eee2f69e70319b4e21f1ca/websockets-15.0.1-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:693f0192126df6c2327cce3baa7c06f2a117575e32ab2308f7f8216c29d9e2e3", size = 181958, upload-time = "2025-03-05T20:02:09.842Z" },
    { url = "https://files.pythonhosted.org/packages/08/ff/e9eed2ee5fed6f76fdd6032ca5cd38c57ca9661430bb3d5fb2872dc8703c/websockets-15.0.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:54479983bd5fb469c38f2f5c7e3a24f9a4e70594cd68cd1fa6b9340dadaff7cf", size = 181918, upload-time = "2025-03-05T20:02:11.968Z" },
    { url = "https://files.pythonhosted.org/packages/d8/75/994634a49b7e12532be6a42103597b71098fd25900f7437d6055ed39930a/websockets-15.0.1-cp311-cp311-win32.whl", hash = "sha256:16b6c1b3e57799b9d38427dda63edcbe4926352c47cf88588c0be4ace18dac85", size = 176388, upload-time = "2025-03-05T20:02:13.32Z" },
    { url = "https://files.pythonhosted.org/packages/98/93/e36c73f78400a65f5e236cd376713c34182e6663f6889cd45a4a04d8f203/websockets-15.0.1-cp311-cp311-win_amd64.whl", hash = "sha256:27ccee0071a0e75d22cb35849b1db43f2ecd3e161041ac1ee9d2352ddf72f065", size = 176828, upload-time = "2025-03-05T20:02:14.585Z" },
    { url = "https://files.pythonhosted.org/packages/51/6b/4545a0d843594f5d0771e86463606a3988b5a09ca5123136f8a76580dd63/websockets-15.0.1-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:3e90baa811a5d73f3ca0bcbf32064d663ed81318ab225ee4f427ad4e26e5aff3", size = 175437, upload-time = "2025-03-05T20:02:16.706Z" },
    { url = "https://files.pythonhosted.org/packages/f4/71/809a0f5f6a06522af902e0f2ea2757f71ead94610010cf570ab5c98e99ed/websockets-15.0.1-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:592f1a9fe869c778694f0aa806ba0374e97648ab57936f092fd9d87f8bc03665", size = 173096, upload-time = "2025-03-05T20:02:18.832Z" },
    { url = "https://files.pythonhosted.org/packages/3d/69/1a681dd6f02180916f116894181eab8b2e25b31e484c5d0eae637ec01f7c/websockets-15.0.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:0701bc3cfcb9164d04a14b149fd74be7347a530ad3bbf15ab2c678a2cd3dd9a2", size = 173332, upload-time = "2025-03-05T20:02:20.187Z" },
    { url = "https://files.pythonhosted.org/packages/a6/02/0073b3952f5bce97eafbb35757f8d0d54812b6174ed8dd952aa08429bcc3/websockets-15.0.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:e8b56bdcdb4505c8078cb6c7157d9811a85790f2f2b3632c7d1462ab5783d215", size = 183152, upload-time = "2025-03-05T20:02:22.286Z" },
    { url = "https://files.pythonhosted.org/packages/74/45/c205c8480eafd114b428284840da0b1be9ffd0e4f87338dc95dc6ff961a1/websockets-15.0.1-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:0af68c55afbd5f07986df82831c7bff04846928ea8d1fd7f30052638788bc9b5", size = 182096, upload-time = "2025-03-05T20:02:24.368Z" },
    { url = "https://files.pythonhosted.org/packages/14/8f/aa61f528fba38578ec553c145857a181384c72b98156f858ca5c8e82d9d3/websockets-15.0.1-cp312-cp312-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:64dee438fed052b52e4f98f76c5790513235efaa1ef7f3f2192c392cd7c91b65", size = 182523, upload-time = "2025-03-05T20:02:25.669Z" },
    { url = "https://files.pythonhosted.org/packages/ec/6d/0267396610add5bc0d0d3e77f546d4cd287200804fe02323797de77dbce9/websockets-15.0.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:d5f6b181bb38171a8ad1d6aa58a67a6aa9d4b38d0f8c5f496b9e42561dfc62fe", size = 182790, upload-time = "2025-03-05T20:02:26.99Z" },
    { url = "https://files.pythonhosted.org/packages/02/05/c68c5adbf679cf610ae2f74a9b871ae84564462955d991178f95a1ddb7dd/websockets-15.0.1-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:5d54b09eba2bada6011aea5375542a157637b91029687eb4fdb2dab11059c1b4", size = 182165, upload-time = "2025-03-05T20:02:30.291Z" },
    { url = "https://files.pythonhosted.org/packages/29/93/bb672df7b2f5faac89761cb5fa34f5cec45a4026c383a4b5761c6cea5c16/websockets-15.0.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:3be571a8b5afed347da347bfcf27ba12b069d9d7f42cb8c7028b5e98bbb12597", size = 182160, upload-time = "2025-03-05T20:02:31.634Z" },
    { url = "https://files.pythonhosted.org/packages/ff/83/de1f7709376dc3ca9b7eeb4b9a07b4526b14876b6d372a4dc62312bebee0/websockets-15.0.1-cp312-cp312-win32.whl", hash = "sha256:c338ffa0520bdb12fbc527265235639fb76e7bc7faafbb93f6ba80d9c06578a9", size = 176395, upload-time = "2025-03-05T20:02:33.017Z" },
    { url = "https://files.pythonhosted.org/packages/7d/71/abf2ebc3bbfa40f391ce1428c7168fb20582d0ff57019b69ea20fa698043/websockets-15.0.1-cp312-cp312-win_amd64.whl", hash = "sha256:fcd5cf9e305d7b8338754470cf69cf81f420459dbae8a3b40cee57417f4614a7", size = 176841, upload-time = "2025-03-05T20:02:34.498Z" },
    { url = "https://files.pythonhosted.org/packages/cb/9f/51f0cf64471a9d2b4d0fc6c534f323b664e7095640c34562f5182e5a7195/websockets-15.0.1-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:ee443ef070bb3b6ed74514f5efaa37a252af57c90eb33b956d35c8e9c10a1931", size = 175440, upload-time = "2025-03-05T20:02:36.695Z" },
    { url = "https://files.pythonhosted.org/packages/8a/05/aa116ec9943c718905997412c5989f7ed671bc0188ee2ba89520e8765d7b/websockets-15.0.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:5a939de6b7b4e18ca683218320fc67ea886038265fd1ed30173f5ce3f8e85675", size = 173098, upload-time = "2025-03-05T20:02:37.985Z" },
    { url = "https://files.pythonhosted.org/packages/ff/0b/33cef55ff24f2d92924923c99926dcce78e7bd922d649467f0eda8368923/websockets-15.0.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:746ee8dba912cd6fc889a8147168991d50ed70447bf18bcda7039f7d2e3d9151", size = 173329, upload-time = "2025-03-05T20:02:39.298Z" },
    { url = "https://files.pythonhosted.org/packages/31/1d/063b25dcc01faa8fada1469bdf769de3768b7044eac9d41f734fd7b6ad6d/websockets-15.0.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:595b6c3969023ecf9041b2936ac3827e4623bfa3ccf007575f04c5a6aa318c22", size = 183111, upload-time = "2025-03-05T20:02:40.595Z" },
    { url = "https://files.pythonhosted.org/packages/93/53/9a87ee494a51bf63e4ec9241c1ccc4f7c2f45fff85d5bde2ff74fcb68b9e/websockets-15.0.1-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:3c714d2fc58b5ca3e285461a4cc0c9a66bd0e24c5da9911e30158286c9b5be7f", size = 182054, upload-time = "2025-03-05T20:02:41.926Z" },
    { url = "https://files.pythonhosted.org/packages/ff/b2/83a6ddf56cdcbad4e3d841fcc55d6ba7d19aeb89c50f24dd7e859ec0805f/websockets-15.0.1-cp313-cp313-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:0f3c1e2ab208db911594ae5b4f79addeb3501604a165019dd221c0bdcabe4db8", size = 182496, upload-time = "2025-03-05T20:02:43.304Z" },
    { url = "https://files.pythonhosted.org/packages/98/41/e7038944ed0abf34c45aa4635ba28136f06052e08fc2168520bb8b25149f/websockets-15.0.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:229cf1d3ca6c1804400b0a9790dc66528e08a6a1feec0d5040e8b9eb14422375", size = 182829, upload-time = "2025-03-05T20:02:48.812Z" },
    { url = "https://files.pythonhosted.org/packages/e0/17/de15b6158680c7623c6ef0db361da965ab25d813ae54fcfeae2e5b9ef910/websockets-15.0.1-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:756c56e867a90fb00177d530dca4b097dd753cde348448a1012ed6c5131f8b7d", size = 182217, upload-time = "2025-03-05T20:02:50.14Z" },
    { url = "https://files.pythonhosted.org/packages/33/2b/1f168cb6041853eef0362fb9554c3824367c5560cbdaad89ac40f8c2edfc/websockets-15.0.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:558d023b3df0bffe50a04e710bc87742de35060580a293c2a984299ed83bc4e4", size = 182195, upload-time = "2025-03-05T20:02:51.561Z" },
    { url = "https://files.pythonhosted.org/packages/86/eb/20b6cdf273913d0ad05a6a14aed4b9a85591c18a987a3d47f20fa13dcc47/websockets-15.0.1-cp313-cp313-win32.whl", hash = "sha256:ba9e56e8ceeeedb2e080147ba85ffcd5cd0711b89576b83784d8605a7df455fa", size = 176393, upload-time = "2025-03-05T20:02:53.814Z" },
    { url = "https://files.pythonhosted.org/packages/1b/6c/c65773d6cab416a64d191d6ee8a8b1c68a09970ea6909d16965d26bfed1e/websockets-15.0.1-cp313-cp313-win_amd64.whl", hash = "sha256:e09473f095a819042ecb2ab9465aee615bd9c2028e4ef7d933600a8401c79561", size = 176837, upload-time = "2025-03-05T20:02:55.237Z" },
    { url = "https://files.pythonhosted.org/packages/fa/a8/5b41e0da817d64113292ab1f8247140aac61cbf6cfd085d6a0fa77f4984f/websockets-15.0.1-py3-none-any.whl", hash = "sha256:f7a866fbc1e97b5c617ee4116daaa09b722101d4a3c170c787450ba409f9736f", size = 169743, upload-time = "2025-03-05T20:03:39.41Z" },
]

[[package]]
name = "wrapt"
version = "1.17.3"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/95/8f/aeb76c5b46e273670962298c23e7ddde79916cb74db802131d49a85e4b7d/wrapt-1.17.3.tar.gz", hash = "sha256:f66eb08feaa410fe4eebd17f2a2c8e2e46d3476e9f8c783daa8e09e0faa666d0", size = 55547, upload-time = "2025-08-12T05:53:21.714Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/52/db/00e2a219213856074a213503fdac0511203dceefff26e1daa15250cc01a0/wrapt-1.17.3-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:273a736c4645e63ac582c60a56b0acb529ef07f78e08dc6bfadf6a46b19c0da7", size = 53482, upload-time = "2025-08-12T05:51:45.79Z" },
    { url = "https://files.pythonhosted.org/packages/5e/30/ca3c4a5eba478408572096fe9ce36e6e915994dd26a4e9e98b4f729c06d9/wrapt-1.17.3-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:5531d911795e3f935a9c23eb1c8c03c211661a5060aab167065896bbf62a5f85", size = 38674, upload-time = "2025-08-12T05:51:34.629Z" },
    { url = "https://files.pythonhosted.org/packages/31/25/3e8cc2c46b5329c5957cec959cb76a10718e1a513309c31399a4dad07eb3/wrapt-1.17.3-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:0610b46293c59a3adbae3dee552b648b984176f8562ee0dba099a56cfbe4df1f", size = 38959, upload-time = "2025-08-12T05:51:56.074Z" },
    { url = "https://files.pythonhosted.org/packages/5d/8f/a32a99fc03e4b37e31b57cb9cefc65050ea08147a8ce12f288616b05ef54/wrapt-1.17.3-cp311-cp311-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl", hash = "sha256:b32888aad8b6e68f83a8fdccbf3165f5469702a7544472bdf41f582970ed3311", size = 82376, upload-time = "2025-08-12T05:52:32.134Z" },
    { url = "https://files.pythonhosted.org/packages/31/57/4930cb8d9d70d59c27ee1332a318c20291749b4fba31f113c2f8ac49a72e/wrapt-1.17.3-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:8cccf4f81371f257440c88faed6b74f1053eef90807b77e31ca057b2db74edb1", size = 83604, upload-time = "2025-08-12T05:52:11.663Z" },
    { url = "https://files.pythonhosted.org/packages/a8/f3/1afd48de81d63dd66e01b263a6fbb86e1b5053b419b9b33d13e1f6d0f7d0/wrapt-1.17.3-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:d8a210b158a34164de8bb68b0e7780041a903d7b00c87e906fb69928bf7890d5", size = 82782, upload-time = "2025-08-12T05:52:12.626Z" },
    { url = "https://files.pythonhosted.org/packages/1e/d7/4ad5327612173b144998232f98a85bb24b60c352afb73bc48e3e0d2bdc4e/wrapt-1.17.3-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:79573c24a46ce11aab457b472efd8d125e5a51da2d1d24387666cd85f54c05b2", size = 82076, upload-time = "2025-08-12T05:52:33.168Z" },
    { url = "https://files.pythonhosted.org/packages/bb/59/e0adfc831674a65694f18ea6dc821f9fcb9ec82c2ce7e3d73a88ba2e8718/wrapt-1.17.3-cp311-cp311-win32.whl", hash = "sha256:c31eebe420a9a5d2887b13000b043ff6ca27c452a9a22fa71f35f118e8d4bf89", size = 36457, upload-time = "2025-08-12T05:53:03.936Z" },
    { url = "https://files.pythonhosted.org/packages/83/88/16b7231ba49861b6f75fc309b11012ede4d6b0a9c90969d9e0db8d991aeb/wrapt-1.17.3-cp311-cp311-win_amd64.whl", hash = "sha256:0b1831115c97f0663cb77aa27d381237e73ad4f721391a9bfb2fe8bc25fa6e77", size = 38745, upload-time = "2025-08-12T05:53:02.885Z" },
    { url = "https://files.pythonhosted.org/packages/9a/1e/c4d4f3398ec073012c51d1c8d87f715f56765444e1a4b11e5180577b7e6e/wrapt-1.17.3-cp311-cp311-win_arm64.whl", hash = "sha256:5a7b3c1ee8265eb4c8f1b7d29943f195c00673f5ab60c192eba2d4a7eae5f46a", size = 36806, upload-time = "2025-08-12T05:52:53.368Z" },
    { url = "https://files.pythonhosted.org/packages/9f/41/cad1aba93e752f1f9268c77270da3c469883d56e2798e7df6240dcb2287b/wrapt-1.17.3-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:ab232e7fdb44cdfbf55fc3afa31bcdb0d8980b9b95c38b6405df2acb672af0e0", size = 53998, upload-time = "2025-08-12T05:51:47.138Z" },
    { url = "https://files.pythonhosted.org/packages/60/f8/096a7cc13097a1869fe44efe68dace40d2a16ecb853141394047f0780b96/wrapt-1.17.3-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:9baa544e6acc91130e926e8c802a17f3b16fbea0fd441b5a60f5cf2cc5c3deba", size = 39020, upload-time = "2025-08-12T05:51:35.906Z" },
    { url = "https://files.pythonhosted.org/packages/33/df/bdf864b8997aab4febb96a9ae5c124f700a5abd9b5e13d2a3214ec4be705/wrapt-1.17.3-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:6b538e31eca1a7ea4605e44f81a48aa24c4632a277431a6ed3f328835901f4fd", size = 39098, upload-time = "2025-08-12T05:51:57.474Z" },
    { url = "https://files.pythonhosted.org/packages/9f/81/5d931d78d0eb732b95dc3ddaeeb71c8bb572fb01356e9133916cd729ecdd/wrapt-1.17.3-cp312-cp312-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl", hash = "sha256:042ec3bb8f319c147b1301f2393bc19dba6e176b7da446853406d041c36c7828", size = 88036, upload-time = "2025-08-12T05:52:34.784Z" },
    { url = "https://files.pythonhosted.org/packages/ca/38/2e1785df03b3d72d34fc6252d91d9d12dc27a5c89caef3335a1bbb8908ca/wrapt-1.17.3-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:3af60380ba0b7b5aeb329bc4e402acd25bd877e98b3727b0135cb5c2efdaefe9", size = 88156, upload-time = "2025-08-12T05:52:13.599Z" },
    { url = "https://files.pythonhosted.org/packages/b3/8b/48cdb60fe0603e34e05cffda0b2a4adab81fd43718e11111a4b0100fd7c1/wrapt-1.17.3-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:0b02e424deef65c9f7326d8c19220a2c9040c51dc165cddb732f16198c168396", size = 87102, upload-time = "2025-08-12T05:52:14.56Z" },
    { url = "https://files.pythonhosted.org/packages/3c/51/d81abca783b58f40a154f1b2c56db1d2d9e0d04fa2d4224e357529f57a57/wrapt-1.17.3-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:74afa28374a3c3a11b3b5e5fca0ae03bef8450d6aa3ab3a1e2c30e3a75d023dc", size = 87732, upload-time = "2025-08-12T05:52:36.165Z" },
    { url = "https://files.pythonhosted.org/packages/9e/b1/43b286ca1392a006d5336412d41663eeef1ad57485f3e52c767376ba7e5a/wrapt-1.17.3-cp312-cp312-win32.whl", hash = "sha256:4da9f45279fff3543c371d5ababc57a0384f70be244de7759c85a7f989cb4ebe", size = 36705, upload-time = "2025-08-12T05:53:07.123Z" },
    { url = "https://files.pythonhosted.org/packages/28/de/49493f962bd3c586ab4b88066e967aa2e0703d6ef2c43aa28cb83bf7b507/wrapt-1.17.3-cp312-cp312-win_amd64.whl", hash = "sha256:e71d5c6ebac14875668a1e90baf2ea0ef5b7ac7918355850c0908ae82bcb297c", size = 38877, upload-time = "2025-08-12T05:53:05.436Z" },
    { url = "https://files.pythonhosted.org/packages/f1/48/0f7102fe9cb1e8a5a77f80d4f0956d62d97034bbe88d33e94699f99d181d/wrapt-1.17.3-cp312-cp312-win_arm64.whl", hash = "sha256:604d076c55e2fdd4c1c03d06dc1a31b95130010517b5019db15365ec4a405fc6", size = 36885, upload-time = "2025-08-12T05:52:54.367Z" },
    { url = "https://files.pythonhosted.org/packages/fc/f6/759ece88472157acb55fc195e5b116e06730f1b651b5b314c66291729193/wrapt-1.17.3-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:a47681378a0439215912ef542c45a783484d4dd82bac412b71e59cf9c0e1cea0", size = 54003, upload-time = "2025-08-12T05:51:48.627Z" },
    { url = "https://files.pythonhosted.org/packages/4f/a9/49940b9dc6d47027dc850c116d79b4155f15c08547d04db0f07121499347/wrapt-1.17.3-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:54a30837587c6ee3cd1a4d1c2ec5d24e77984d44e2f34547e2323ddb4e22eb77", size = 39025, upload-time = "2025-08-12T05:51:37.156Z" },
    { url = "https://files.pythonhosted.org/packages/45/35/6a08de0f2c96dcdd7fe464d7420ddb9a7655a6561150e5fc4da9356aeaab/wrapt-1.17.3-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:16ecf15d6af39246fe33e507105d67e4b81d8f8d2c6598ff7e3ca1b8a37213f7", size = 39108, upload-time = "2025-08-12T05:51:58.425Z" },
    { url = "https://files.pythonhosted.org/packages/0c/37/6faf15cfa41bf1f3dba80cd3f5ccc6622dfccb660ab26ed79f0178c7497f/wrapt-1.17.3-cp313-cp313-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl", hash = "sha256:6fd1ad24dc235e4ab88cda009e19bf347aabb975e44fd5c2fb22a3f6e4141277", size = 88072, upload-time = "2025-08-12T05:52:37.53Z" },
    { url = "https://files.pythonhosted.org/packages/78/f2/efe19ada4a38e4e15b6dff39c3e3f3f73f5decf901f66e6f72fe79623a06/wrapt-1.17.3-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:0ed61b7c2d49cee3c027372df5809a59d60cf1b6c2f81ee980a091f3afed6a2d", size = 88214, upload-time = "2025-08-12T05:52:15.886Z" },
    { url = "https://files.pythonhosted.org/packages/40/90/ca86701e9de1622b16e09689fc24b76f69b06bb0150990f6f4e8b0eeb576/wrapt-1.17.3-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:423ed5420ad5f5529db9ce89eac09c8a2f97da18eb1c870237e84c5a5c2d60aa", size = 87105, upload-time = "2025-08-12T05:52:17.914Z" },
    { url = "https://files.pythonhosted.org/packages/fd/e0/d10bd257c9a3e15cbf5523025252cc14d77468e8ed644aafb2d6f54cb95d/wrapt-1.17.3-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:e01375f275f010fcbf7f643b4279896d04e571889b8a5b3f848423d91bf07050", size = 87766, upload-time = "2025-08-12T05:52:39.243Z" },
    { url = "https://files.pythonhosted.org/packages/e8/cf/7d848740203c7b4b27eb55dbfede11aca974a51c3d894f6cc4b865f42f58/wrapt-1.17.3-cp313-cp313-win32.whl", hash = "sha256:53e5e39ff71b3fc484df8a522c933ea2b7cdd0d5d15ae82e5b23fde87d44cbd8", size = 36711, upload-time = "2025-08-12T05:53:10.074Z" },
    { url = "https://files.pythonhosted.org/packages/57/54/35a84d0a4d23ea675994104e667ceff49227ce473ba6a59ba2c84f250b74/wrapt-1.17.3-cp313-cp313-win_amd64.whl", hash = "sha256:1f0b2f40cf341ee8cc1a97d51ff50dddb9fcc73241b9143ec74b30fc4f44f6cb", size = 38885, upload-time = "2025-08-12T05:53:08.695Z" },
    { url = "https://files.pythonhosted.org/packages/01/77/66e54407c59d7b02a3c4e0af3783168fff8e5d61def52cda8728439d86bc/wrapt-1.17.3-cp313-cp313-win_arm64.whl", hash = "sha256:7425ac3c54430f5fc5e7b6f41d41e704db073309acfc09305816bc6a0b26bb16", size = 36896, upload-time = "2025-08-12T05:52:55.34Z" },
    { url = "https://files.pythonhosted.org/packages/1f/f6/a933bd70f98e9cf3e08167fc5cd7aaaca49147e48411c0bd5ae701bb2194/wrapt-1.17.3-py3-none-any.whl", hash = "sha256:7171ae35d2c33d326ac19dd8facb1e82e5fd04ef8c6c0e394d7af55a55051c22", size = 23591, upload-time = "2025-08-12T05:53:20.674Z" },
]

[[package]]
name = "xmltodict"
version = "1.0.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/6a/aa/917ceeed4dbb80d2f04dbd0c784b7ee7bba8ae5a54837ef0e5e062cd3cfb/xmltodict-1.0.2.tar.gz", hash = "sha256:54306780b7c2175a3967cad1db92f218207e5bc1aba697d887807c0fb68b7649", size = 25725, upload-time = "2025-09-17T21:59:26.459Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c0/20/69a0e6058bc5ea74892d089d64dfc3a62ba78917ec5e2cfa70f7c92ba3a5/xmltodict-1.0.2-py3-none-any.whl", hash = "sha256:62d0fddb0dcbc9f642745d8bbf4d81fd17d6dfaec5a15b5c1876300aad92af0d", size = 13893, upload-time = "2025-09-17T21:59:24.859Z" },
]

[[package]]
name = "yarl"
version = "1.22.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "idna" },
    { name = "multidict" },
    { name = "propcache" },
]
sdist = { url = "https://files.pythonhosted.org/packages/57/63/0c6ebca57330cd313f6102b16dd57ffaf3ec4c83403dcb45dbd15c6f3ea1/yarl-1.22.0.tar.gz", hash = "sha256:bebf8557577d4401ba8bd9ff33906f1376c877aa78d1fe216ad01b4d6745af71", size = 187169, upload-time = "2025-10-06T14:12:55.963Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4d/27/5ab13fc84c76a0250afd3d26d5936349a35be56ce5785447d6c423b26d92/yarl-1.22.0-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:1ab72135b1f2db3fed3997d7e7dc1b80573c67138023852b6efb336a5eae6511", size = 141607, upload-time = "2025-10-06T14:09:16.298Z" },
    { url = "https://files.pythonhosted.org/packages/6a/a1/d065d51d02dc02ce81501d476b9ed2229d9a990818332242a882d5d60340/yarl-1.22.0-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:669930400e375570189492dc8d8341301578e8493aec04aebc20d4717f899dd6", size = 94027, upload-time = "2025-10-06T14:09:17.786Z" },
    { url = "https://files.pythonhosted.org/packages/c1/da/8da9f6a53f67b5106ffe902c6fa0164e10398d4e150d85838b82f424072a/yarl-1.22.0-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:792a2af6d58177ef7c19cbf0097aba92ca1b9cb3ffdd9c7470e156c8f9b5e028", size = 94963, upload-time = "2025-10-06T14:09:19.662Z" },
    { url = "https://files.pythonhosted.org/packages/68/fe/2c1f674960c376e29cb0bec1249b117d11738db92a6ccc4a530b972648db/yarl-1.22.0-cp311-cp311-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:3ea66b1c11c9150f1372f69afb6b8116f2dd7286f38e14ea71a44eee9ec51b9d", size = 368406, upload-time = "2025-10-06T14:09:21.402Z" },
    { url = "https://files.pythonhosted.org/packages/95/26/812a540e1c3c6418fec60e9bbd38e871eaba9545e94fa5eff8f4a8e28e1e/yarl-1.22.0-cp311-cp311-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:3e2daa88dc91870215961e96a039ec73e4937da13cf77ce17f9cad0c18df3503", size = 336581, upload-time = "2025-10-06T14:09:22.98Z" },
    { url = "https://files.pythonhosted.org/packages/0b/f5/5777b19e26fdf98563985e481f8be3d8a39f8734147a6ebf459d0dab5a6b/yarl-1.22.0-cp311-cp311-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:ba440ae430c00eee41509353628600212112cd5018d5def7e9b05ea7ac34eb65", size = 388924, upload-time = "2025-10-06T14:09:24.655Z" },
    { url = "https://files.pythonhosted.org/packages/86/08/24bd2477bd59c0bbd994fe1d93b126e0472e4e3df5a96a277b0a55309e89/yarl-1.22.0-cp311-cp311-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:e6438cc8f23a9c1478633d216b16104a586b9761db62bfacb6425bac0a36679e", size = 392890, upload-time = "2025-10-06T14:09:26.617Z" },
    { url = "https://files.pythonhosted.org/packages/46/00/71b90ed48e895667ecfb1eaab27c1523ee2fa217433ed77a73b13205ca4b/yarl-1.22.0-cp311-cp311-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:4c52a6e78aef5cf47a98ef8e934755abf53953379b7d53e68b15ff4420e6683d", size = 365819, upload-time = "2025-10-06T14:09:28.544Z" },
    { url = "https://files.pythonhosted.org/packages/30/2d/f715501cae832651d3282387c6a9236cd26bd00d0ff1e404b3dc52447884/yarl-1.22.0-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:3b06bcadaac49c70f4c88af4ffcfbe3dc155aab3163e75777818092478bcbbe7", size = 363601, upload-time = "2025-10-06T14:09:30.568Z" },
    { url = "https://files.pythonhosted.org/packages/f8/f9/a678c992d78e394e7126ee0b0e4e71bd2775e4334d00a9278c06a6cce96a/yarl-1.22.0-cp311-cp311-musllinux_1_2_armv7l.whl", hash = "sha256:6944b2dc72c4d7f7052683487e3677456050ff77fcf5e6204e98caf785ad1967", size = 358072, upload-time = "2025-10-06T14:09:32.528Z" },
    { url = "https://files.pythonhosted.org/packages/2c/d1/b49454411a60edb6fefdcad4f8e6dbba7d8019e3a508a1c5836cba6d0781/yarl-1.22.0-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:d5372ca1df0f91a86b047d1277c2aaf1edb32d78bbcefffc81b40ffd18f027ed", size = 385311, upload-time = "2025-10-06T14:09:34.634Z" },
    { url = "https://files.pythonhosted.org/packages/87/e5/40d7a94debb8448c7771a916d1861d6609dddf7958dc381117e7ba36d9e8/yarl-1.22.0-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:51af598701f5299012b8416486b40fceef8c26fc87dc6d7d1f6fc30609ea0aa6", size = 381094, upload-time = "2025-10-06T14:09:36.268Z" },
    { url = "https://files.pythonhosted.org/packages/35/d8/611cc282502381ad855448643e1ad0538957fc82ae83dfe7762c14069e14/yarl-1.22.0-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:b266bd01fedeffeeac01a79ae181719ff848a5a13ce10075adbefc8f1daee70e", size = 370944, upload-time = "2025-10-06T14:09:37.872Z" },
    { url = "https://files.pythonhosted.org/packages/2d/df/fadd00fb1c90e1a5a8bd731fa3d3de2e165e5a3666a095b04e31b04d9cb6/yarl-1.22.0-cp311-cp311-win32.whl", hash = "sha256:a9b1ba5610a4e20f655258d5a1fdc7ebe3d837bb0e45b581398b99eb98b1f5ca", size = 81804, upload-time = "2025-10-06T14:09:39.359Z" },
    { url = "https://files.pythonhosted.org/packages/b5/f7/149bb6f45f267cb5c074ac40c01c6b3ea6d8a620d34b337f6321928a1b4d/yarl-1.22.0-cp311-cp311-win_amd64.whl", hash = "sha256:078278b9b0b11568937d9509b589ee83ef98ed6d561dfe2020e24a9fd08eaa2b", size = 86858, upload-time = "2025-10-06T14:09:41.068Z" },
    { url = "https://files.pythonhosted.org/packages/2b/13/88b78b93ad3f2f0b78e13bfaaa24d11cbc746e93fe76d8c06bf139615646/yarl-1.22.0-cp311-cp311-win_arm64.whl", hash = "sha256:b6a6f620cfe13ccec221fa312139135166e47ae169f8253f72a0abc0dae94376", size = 81637, upload-time = "2025-10-06T14:09:42.712Z" },
    { url = "https://files.pythonhosted.org/packages/75/ff/46736024fee3429b80a165a732e38e5d5a238721e634ab41b040d49f8738/yarl-1.22.0-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:e340382d1afa5d32b892b3ff062436d592ec3d692aeea3bef3a5cfe11bbf8c6f", size = 142000, upload-time = "2025-10-06T14:09:44.631Z" },
    { url = "https://files.pythonhosted.org/packages/5a/9a/b312ed670df903145598914770eb12de1bac44599549b3360acc96878df8/yarl-1.22.0-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:f1e09112a2c31ffe8d80be1b0988fa6a18c5d5cad92a9ffbb1c04c91bfe52ad2", size = 94338, upload-time = "2025-10-06T14:09:46.372Z" },
    { url = "https://files.pythonhosted.org/packages/ba/f5/0601483296f09c3c65e303d60c070a5c19fcdbc72daa061e96170785bc7d/yarl-1.22.0-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:939fe60db294c786f6b7c2d2e121576628468f65453d86b0fe36cb52f987bd74", size = 94909, upload-time = "2025-10-06T14:09:48.648Z" },
    { url = "https://files.pythonhosted.org/packages/60/41/9a1fe0b73dbcefce72e46cf149b0e0a67612d60bfc90fb59c2b2efdfbd86/yarl-1.22.0-cp312-cp312-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:e1651bf8e0398574646744c1885a41198eba53dc8a9312b954073f845c90a8df", size = 372940, upload-time = "2025-10-06T14:09:50.089Z" },
    { url = "https://files.pythonhosted.org/packages/17/7a/795cb6dfee561961c30b800f0ed616b923a2ec6258b5def2a00bf8231334/yarl-1.22.0-cp312-cp312-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:b8a0588521a26bf92a57a1705b77b8b59044cdceccac7151bd8d229e66b8dedb", size = 345825, upload-time = "2025-10-06T14:09:52.142Z" },
    { url = "https://files.pythonhosted.org/packages/d7/93/a58f4d596d2be2ae7bab1a5846c4d270b894958845753b2c606d666744d3/yarl-1.22.0-cp312-cp312-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:42188e6a615c1a75bcaa6e150c3fe8f3e8680471a6b10150c5f7e83f47cc34d2", size = 386705, upload-time = "2025-10-06T14:09:54.128Z" },
    { url = "https://files.pythonhosted.org/packages/61/92/682279d0e099d0e14d7fd2e176bd04f48de1484f56546a3e1313cd6c8e7c/yarl-1.22.0-cp312-cp312-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:f6d2cb59377d99718913ad9a151030d6f83ef420a2b8f521d94609ecc106ee82", size = 396518, upload-time = "2025-10-06T14:09:55.762Z" },
    { url = "https://files.pythonhosted.org/packages/db/0f/0d52c98b8a885aeda831224b78f3be7ec2e1aa4a62091f9f9188c3c65b56/yarl-1.22.0-cp312-cp312-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:50678a3b71c751d58d7908edc96d332af328839eea883bb554a43f539101277a", size = 377267, upload-time = "2025-10-06T14:09:57.958Z" },
    { url = "https://files.pythonhosted.org/packages/22/42/d2685e35908cbeaa6532c1fc73e89e7f2efb5d8a7df3959ea8e37177c5a3/yarl-1.22.0-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:1e8fbaa7cec507aa24ea27a01456e8dd4b6fab829059b69844bd348f2d467124", size = 365797, upload-time = "2025-10-06T14:09:59.527Z" },
    { url = "https://files.pythonhosted.org/packages/a2/83/cf8c7bcc6355631762f7d8bdab920ad09b82efa6b722999dfb05afa6cfac/yarl-1.22.0-cp312-cp312-musllinux_1_2_armv7l.whl", hash = "sha256:433885ab5431bc3d3d4f2f9bd15bfa1614c522b0f1405d62c4f926ccd69d04fa", size = 365535, upload-time = "2025-10-06T14:10:01.139Z" },
    { url = "https://files.pythonhosted.org/packages/25/e1/5302ff9b28f0c59cac913b91fe3f16c59a033887e57ce9ca5d41a3a94737/yarl-1.22.0-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:b790b39c7e9a4192dc2e201a282109ed2985a1ddbd5ac08dc56d0e121400a8f7", size = 382324, upload-time = "2025-10-06T14:10:02.756Z" },
    { url = "https://files.pythonhosted.org/packages/bf/cd/4617eb60f032f19ae3a688dc990d8f0d89ee0ea378b61cac81ede3e52fae/yarl-1.22.0-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:31f0b53913220599446872d757257be5898019c85e7971599065bc55065dc99d", size = 383803, upload-time = "2025-10-06T14:10:04.552Z" },
    { url = "https://files.pythonhosted.org/packages/59/65/afc6e62bb506a319ea67b694551dab4a7e6fb7bf604e9bd9f3e11d575fec/yarl-1.22.0-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:a49370e8f711daec68d09b821a34e1167792ee2d24d405cbc2387be4f158b520", size = 374220, upload-time = "2025-10-06T14:10:06.489Z" },
    { url = "https://files.pythonhosted.org/packages/e7/3d/68bf18d50dc674b942daec86a9ba922d3113d8399b0e52b9897530442da2/yarl-1.22.0-cp312-cp312-win32.whl", hash = "sha256:70dfd4f241c04bd9239d53b17f11e6ab672b9f1420364af63e8531198e3f5fe8", size = 81589, upload-time = "2025-10-06T14:10:09.254Z" },
    { url = "https://files.pythonhosted.org/packages/c8/9a/6ad1a9b37c2f72874f93e691b2e7ecb6137fb2b899983125db4204e47575/yarl-1.22.0-cp312-cp312-win_amd64.whl", hash = "sha256:8884d8b332a5e9b88e23f60bb166890009429391864c685e17bd73a9eda9105c", size = 87213, upload-time = "2025-10-06T14:10:11.369Z" },
    { url = "https://files.pythonhosted.org/packages/44/c5/c21b562d1680a77634d748e30c653c3ca918beb35555cff24986fff54598/yarl-1.22.0-cp312-cp312-win_arm64.whl", hash = "sha256:ea70f61a47f3cc93bdf8b2f368ed359ef02a01ca6393916bc8ff877427181e74", size = 81330, upload-time = "2025-10-06T14:10:13.112Z" },
    { url = "https://files.pythonhosted.org/packages/ea/f3/d67de7260456ee105dc1d162d43a019ecad6b91e2f51809d6cddaa56690e/yarl-1.22.0-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:8dee9c25c74997f6a750cd317b8ca63545169c098faee42c84aa5e506c819b53", size = 139980, upload-time = "2025-10-06T14:10:14.601Z" },
    { url = "https://files.pythonhosted.org/packages/01/88/04d98af0b47e0ef42597b9b28863b9060bb515524da0a65d5f4db160b2d5/yarl-1.22.0-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:01e73b85a5434f89fc4fe27dcda2aff08ddf35e4d47bbbea3bdcd25321af538a", size = 93424, upload-time = "2025-10-06T14:10:16.115Z" },
    { url = "https://files.pythonhosted.org/packages/18/91/3274b215fd8442a03975ce6bee5fe6aa57a8326b29b9d3d56234a1dca244/yarl-1.22.0-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:22965c2af250d20c873cdbee8ff958fb809940aeb2e74ba5f20aaf6b7ac8c70c", size = 93821, upload-time = "2025-10-06T14:10:17.993Z" },
    { url = "https://files.pythonhosted.org/packages/61/3a/caf4e25036db0f2da4ca22a353dfeb3c9d3c95d2761ebe9b14df8fc16eb0/yarl-1.22.0-cp313-cp313-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:b4f15793aa49793ec8d1c708ab7f9eded1aa72edc5174cae703651555ed1b601", size = 373243, upload-time = "2025-10-06T14:10:19.44Z" },
    { url = "https://files.pythonhosted.org/packages/6e/9e/51a77ac7516e8e7803b06e01f74e78649c24ee1021eca3d6a739cb6ea49c/yarl-1.22.0-cp313-cp313-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:e5542339dcf2747135c5c85f68680353d5cb9ffd741c0f2e8d832d054d41f35a", size = 342361, upload-time = "2025-10-06T14:10:21.124Z" },
    { url = "https://files.pythonhosted.org/packages/d4/f8/33b92454789dde8407f156c00303e9a891f1f51a0330b0fad7c909f87692/yarl-1.22.0-cp313-cp313-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:5c401e05ad47a75869c3ab3e35137f8468b846770587e70d71e11de797d113df", size = 387036, upload-time = "2025-10-06T14:10:22.902Z" },
    { url = "https://files.pythonhosted.org/packages/d9/9a/c5db84ea024f76838220280f732970aa4ee154015d7f5c1bfb60a267af6f/yarl-1.22.0-cp313-cp313-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:243dda95d901c733f5b59214d28b0120893d91777cb8aa043e6ef059d3cddfe2", size = 397671, upload-time = "2025-10-06T14:10:24.523Z" },
    { url = "https://files.pythonhosted.org/packages/11/c9/cd8538dc2e7727095e0c1d867bad1e40c98f37763e6d995c1939f5fdc7b1/yarl-1.22.0-cp313-cp313-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:bec03d0d388060058f5d291a813f21c011041938a441c593374da6077fe21b1b", size = 377059, upload-time = "2025-10-06T14:10:26.406Z" },
    { url = "https://files.pythonhosted.org/packages/a1/b9/ab437b261702ced75122ed78a876a6dec0a1b0f5e17a4ac7a9a2482d8abe/yarl-1.22.0-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:b0748275abb8c1e1e09301ee3cf90c8a99678a4e92e4373705f2a2570d581273", size = 365356, upload-time = "2025-10-06T14:10:28.461Z" },
    { url = "https://files.pythonhosted.org/packages/b2/9d/8e1ae6d1d008a9567877b08f0ce4077a29974c04c062dabdb923ed98e6fe/yarl-1.22.0-cp313-cp313-musllinux_1_2_armv7l.whl", hash = "sha256:47fdb18187e2a4e18fda2c25c05d8251a9e4a521edaed757fef033e7d8498d9a", size = 361331, upload-time = "2025-10-06T14:10:30.541Z" },
    { url = "https://files.pythonhosted.org/packages/ca/5a/09b7be3905962f145b73beb468cdd53db8aa171cf18c80400a54c5b82846/yarl-1.22.0-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:c7044802eec4524fde550afc28edda0dd5784c4c45f0be151a2d3ba017daca7d", size = 382590, upload-time = "2025-10-06T14:10:33.352Z" },
    { url = "https://files.pythonhosted.org/packages/aa/7f/59ec509abf90eda5048b0bc3e2d7b5099dffdb3e6b127019895ab9d5ef44/yarl-1.22.0-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:139718f35149ff544caba20fce6e8a2f71f1e39b92c700d8438a0b1d2a631a02", size = 385316, upload-time = "2025-10-06T14:10:35.034Z" },
    { url = "https://files.pythonhosted.org/packages/e5/84/891158426bc8036bfdfd862fabd0e0fa25df4176ec793e447f4b85cf1be4/yarl-1.22.0-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:e1b51bebd221006d3d2f95fbe124b22b247136647ae5dcc8c7acafba66e5ee67", size = 374431, upload-time = "2025-10-06T14:10:37.76Z" },
    { url = "https://files.pythonhosted.org/packages/bb/49/03da1580665baa8bef5e8ed34c6df2c2aca0a2f28bf397ed238cc1bbc6f2/yarl-1.22.0-cp313-cp313-win32.whl", hash = "sha256:d3e32536234a95f513bd374e93d717cf6b2231a791758de6c509e3653f234c95", size = 81555, upload-time = "2025-10-06T14:10:39.649Z" },
    { url = "https://files.pythonhosted.org/packages/9a/ee/450914ae11b419eadd067c6183ae08381cfdfcb9798b90b2b713bbebddda/yarl-1.22.0-cp313-cp313-win_amd64.whl", hash = "sha256:47743b82b76d89a1d20b83e60d5c20314cbd5ba2befc9cda8f28300c4a08ed4d", size = 86965, upload-time = "2025-10-06T14:10:41.313Z" },
    { url = "https://files.pythonhosted.org/packages/98/4d/264a01eae03b6cf629ad69bae94e3b0e5344741e929073678e84bf7a3e3b/yarl-1.22.0-cp313-cp313-win_arm64.whl", hash = "sha256:5d0fcda9608875f7d052eff120c7a5da474a6796fe4d83e152e0e4d42f6d1a9b", size = 81205, upload-time = "2025-10-06T14:10:43.167Z" },
    { url = "https://files.pythonhosted.org/packages/88/fc/6908f062a2f77b5f9f6d69cecb1747260831ff206adcbc5b510aff88df91/yarl-1.22.0-cp313-cp313t-macosx_10_13_universal2.whl", hash = "sha256:719ae08b6972befcba4310e49edb1161a88cdd331e3a694b84466bd938a6ab10", size = 146209, upload-time = "2025-10-06T14:10:44.643Z" },
    { url = "https://files.pythonhosted.org/packages/65/47/76594ae8eab26210b4867be6f49129861ad33da1f1ebdf7051e98492bf62/yarl-1.22.0-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:47d8a5c446df1c4db9d21b49619ffdba90e77c89ec6e283f453856c74b50b9e3", size = 95966, upload-time = "2025-10-06T14:10:46.554Z" },
    { url = "https://files.pythonhosted.org/packages/ab/ce/05e9828a49271ba6b5b038b15b3934e996980dd78abdfeb52a04cfb9467e/yarl-1.22.0-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:cfebc0ac8333520d2d0423cbbe43ae43c8838862ddb898f5ca68565e395516e9", size = 97312, upload-time = "2025-10-06T14:10:48.007Z" },
    { url = "https://files.pythonhosted.org/packages/d1/c5/7dffad5e4f2265b29c9d7ec869c369e4223166e4f9206fc2243ee9eea727/yarl-1.22.0-cp313-cp313t-manylinux2014_aarch64.manylinux_2_17_aarch64.manylinux_2_28_aarch64.whl", hash = "sha256:4398557cbf484207df000309235979c79c4356518fd5c99158c7d38203c4da4f", size = 361967, upload-time = "2025-10-06T14:10:49.997Z" },
    { url = "https://files.pythonhosted.org/packages/50/b2/375b933c93a54bff7fc041e1a6ad2c0f6f733ffb0c6e642ce56ee3b39970/yarl-1.22.0-cp313-cp313t-manylinux2014_armv7l.manylinux_2_17_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:2ca6fd72a8cd803be290d42f2dec5cdcd5299eeb93c2d929bf060ad9efaf5de0", size = 323949, upload-time = "2025-10-06T14:10:52.004Z" },
    { url = "https://files.pythonhosted.org/packages/66/50/bfc2a29a1d78644c5a7220ce2f304f38248dc94124a326794e677634b6cf/yarl-1.22.0-cp313-cp313t-manylinux2014_ppc64le.manylinux_2_17_ppc64le.manylinux_2_28_ppc64le.whl", hash = "sha256:ca1f59c4e1ab6e72f0a23c13fca5430f889634166be85dbf1013683e49e3278e", size = 361818, upload-time = "2025-10-06T14:10:54.078Z" },
    { url = "https://files.pythonhosted.org/packages/46/96/f3941a46af7d5d0f0498f86d71275696800ddcdd20426298e572b19b91ff/yarl-1.22.0-cp313-cp313t-manylinux2014_s390x.manylinux_2_17_s390x.manylinux_2_28_s390x.whl", hash = "sha256:6c5010a52015e7c70f86eb967db0f37f3c8bd503a695a49f8d45700144667708", size = 372626, upload-time = "2025-10-06T14:10:55.767Z" },
    { url = "https://files.pythonhosted.org/packages/c1/42/8b27c83bb875cd89448e42cd627e0fb971fa1675c9ec546393d18826cb50/yarl-1.22.0-cp313-cp313t-manylinux2014_x86_64.manylinux_2_17_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:9d7672ecf7557476642c88497c2f8d8542f8e36596e928e9bcba0e42e1e7d71f", size = 341129, upload-time = "2025-10-06T14:10:57.985Z" },
    { url = "https://files.pythonhosted.org/packages/49/36/99ca3122201b382a3cf7cc937b95235b0ac944f7e9f2d5331d50821ed352/yarl-1.22.0-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:3b7c88eeef021579d600e50363e0b6ee4f7f6f728cd3486b9d0f3ee7b946398d", size = 346776, upload-time = "2025-10-06T14:10:59.633Z" },
    { url = "https://files.pythonhosted.org/packages/85/b4/47328bf996acd01a4c16ef9dcd2f59c969f495073616586f78cd5f2efb99/yarl-1.22.0-cp313-cp313t-musllinux_1_2_armv7l.whl", hash = "sha256:f4afb5c34f2c6fecdcc182dfcfc6af6cccf1aa923eed4d6a12e9d96904e1a0d8", size = 334879, upload-time = "2025-10-06T14:11:01.454Z" },
    { url = "https://files.pythonhosted.org/packages/c2/ad/b77d7b3f14a4283bffb8e92c6026496f6de49751c2f97d4352242bba3990/yarl-1.22.0-cp313-cp313t-musllinux_1_2_ppc64le.whl", hash = "sha256:59c189e3e99a59cf8d83cbb31d4db02d66cda5a1a4374e8a012b51255341abf5", size = 350996, upload-time = "2025-10-06T14:11:03.452Z" },
    { url = "https://files.pythonhosted.org/packages/81/c8/06e1d69295792ba54d556f06686cbd6a7ce39c22307100e3fb4a2c0b0a1d/yarl-1.22.0-cp313-cp313t-musllinux_1_2_s390x.whl", hash = "sha256:5a3bf7f62a289fa90f1990422dc8dff5a458469ea71d1624585ec3a4c8d6960f", size = 356047, upload-time = "2025-10-06T14:11:05.115Z" },
    { url = "https://files.pythonhosted.org/packages/4b/b8/4c0e9e9f597074b208d18cef227d83aac36184bfbc6eab204ea55783dbc5/yarl-1.22.0-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:de6b9a04c606978fdfe72666fa216ffcf2d1a9f6a381058d4378f8d7b1e5de62", size = 342947, upload-time = "2025-10-06T14:11:08.137Z" },
    { url = "https://files.pythonhosted.org/packages/e0/e5/11f140a58bf4c6ad7aca69a892bff0ee638c31bea4206748fc0df4ebcb3a/yarl-1.22.0-cp313-cp313t-win32.whl", hash = "sha256:1834bb90991cc2999f10f97f5f01317f99b143284766d197e43cd5b45eb18d03", size = 86943, upload-time = "2025-10-06T14:11:10.284Z" },
    { url = "https://files.pythonhosted.org/packages/31/74/8b74bae38ed7fe6793d0c15a0c8207bbb819cf287788459e5ed230996cdd/yarl-1.22.0-cp313-cp313t-win_amd64.whl", hash = "sha256:ff86011bd159a9d2dfc89c34cfd8aff12875980e3bd6a39ff097887520e60249", size = 93715, upload-time = "2025-10-06T14:11:11.739Z" },
    { url = "https://files.pythonhosted.org/packages/69/66/991858aa4b5892d57aef7ee1ba6b4d01ec3b7eb3060795d34090a3ca3278/yarl-1.22.0-cp313-cp313t-win_arm64.whl", hash = "sha256:7861058d0582b847bc4e3a4a4c46828a410bca738673f35a29ba3ca5db0b473b", size = 83857, upload-time = "2025-10-06T14:11:13.586Z" },
    { url = "https://files.pythonhosted.org/packages/73/ae/b48f95715333080afb75a4504487cbe142cae1268afc482d06692d605ae6/yarl-1.22.0-py3-none-any.whl", hash = "sha256:1380560bdba02b6b6c90de54133c81c9f2a453dee9912fe58c1dcced1edb7cff", size = 46814, upload-time = "2025-10-06T14:12:53.872Z" },
]

[[package]]
name = "zipp"
version = "3.23.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e3/02/0f2892c661036d50ede074e376733dca2ae7c6eb617489437771209d4180/zipp-3.23.0.tar.gz", hash = "sha256:a07157588a12518c9d4034df3fbbee09c814741a33ff63c05fa29d26a2404166", size = 25547, upload-time = "2025-06-08T17:06:39.4Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2e/54/647ade08bf0db230bfea292f893923872fd20be6ac6f53b2b936ba839d75/zipp-3.23.0-py3-none-any.whl", hash = "sha256:071652d6115ed432f5ce1d34c336c0adfd6a884660d1e9712a256d3d3bd4b14e", size = 10276, upload-time = "2025-06-08T17:06:38.034Z" },
]

```