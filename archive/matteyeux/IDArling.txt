Project Path: arc_matteyeux_IDArling_fu2foxnr

Source Tree:

```txt
arc_matteyeux_IDArling_fu2foxnr
├── LICENSE.md
├── MANIFEST.in
├── README.md
├── easy_install.py
├── idarling
│   ├── __init__.py
│   ├── core
│   │   ├── __init__.py
│   │   ├── core.py
│   │   ├── events.py
│   │   └── hooks.py
│   ├── interface
│   │   ├── __init__.py
│   │   ├── actions.py
│   │   ├── dialogs.py
│   │   ├── filter.py
│   │   ├── interface.py
│   │   ├── invites.py
│   │   ├── painter.py
│   │   └── widget.py
│   ├── module.py
│   ├── network
│   │   ├── __init__.py
│   │   ├── client.py
│   │   ├── network.py
│   │   └── server.py
│   ├── plugin.py
│   ├── resources
│   │   ├── clear.png
│   │   ├── cold.png
│   │   ├── connected.png
│   │   ├── connecting.png
│   │   ├── disconnected.png
│   │   ├── download.png
│   │   ├── empty.png
│   │   ├── hot.png
│   │   ├── idarling.png
│   │   ├── invite.png
│   │   ├── location.png
│   │   ├── settings.png
│   │   ├── upload.png
│   │   ├── user.png
│   │   ├── users.png
│   │   └── warm.png
│   ├── server.py
│   ├── shared
│   │   ├── __init__.py
│   │   ├── commands.py
│   │   ├── discovery.py
│   │   ├── forms.py
│   │   ├── local_types.py
│   │   ├── models.py
│   │   ├── packets.py
│   │   ├── server.py
│   │   ├── sockets.py
│   │   ├── storage.py
│   │   └── utils.py
│   └── test
│       ├── delete_netnode.py
│       ├── ida_noplugin.bat
│       ├── kernel32.dll
│       ├── kernel32_test_events.py
│       ├── ntoskrnl.exe
│       ├── ntoskrnl_test_events.py
│       ├── test_compression.py
│       └── test_hook.py
├── idarling_plugin.py
├── idarling_server.py
├── img
│   └── open_from_server.png
└── setup.py

```

`LICENSE.md`:

```md
### GNU GENERAL PUBLIC LICENSE

Version 3, 29 June 2007

Copyright (C) 2007 Free Software Foundation, Inc.
<https://fsf.org/>

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.

### Preamble

The GNU General Public License is a free, copyleft license for
software and other kinds of works.

The licenses for most software and other practical works are designed
to take away your freedom to share and change the works. By contrast,
the GNU General Public License is intended to guarantee your freedom
to share and change all versions of a program--to make sure it remains
free software for all its users. We, the Free Software Foundation, use
the GNU General Public License for most of our software; it applies
also to any other work released this way by its authors. You can apply
it to your programs, too.

When we speak of free software, we are referring to freedom, not
price. Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights. Therefore, you
have certain responsibilities if you distribute copies of the
software, or if you modify it: responsibilities to respect the freedom
of others.

For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received. You must make sure that they, too, receive
or can get the source code. And you must show them these terms so they
know their rights.

Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software. For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the
manufacturer can do so. This is fundamentally incompatible with the
aim of protecting users' freedom to change the software. The
systematic pattern of such abuse occurs in the area of products for
individuals to use, which is precisely where it is most unacceptable.
Therefore, we have designed this version of the GPL to prohibit the
practice for those products. If such problems arise substantially in
other domains, we stand ready to extend this provision to those
domains in future versions of the GPL, as needed to protect the
freedom of users.

Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish
to avoid the special danger that patents applied to a free program
could make it effectively proprietary. To prevent this, the GPL
assures that patents cannot be used to render the program non-free.

The precise terms and conditions for copying, distribution and
modification follow.

### TERMS AND CONDITIONS

#### 0. Definitions.

"This License" refers to version 3 of the GNU General Public License.

"Copyright" also means copyright-like laws that apply to other kinds
of works, such as semiconductor masks.

"The Program" refers to any copyrightable work licensed under this
License. Each licensee is addressed as "you". "Licensees" and
"recipients" may be individuals or organizations.

To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of
an exact copy. The resulting work is called a "modified version" of
the earlier work or a work "based on" the earlier work.

A "covered work" means either the unmodified Program or a work based
on the Program.

To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy. Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

To "convey" a work means any kind of propagation that enables other
parties to make or receive copies. Mere interaction with a user
through a computer network, with no transfer of a copy, is not
conveying.

An interactive user interface displays "Appropriate Legal Notices" to
the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License. If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

#### 1. Source Code.

The "source code" for a work means the preferred form of the work for
making modifications to it. "Object code" means any non-source form of
a work.

A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form. A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities. However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work. For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

The Corresponding Source need not include anything that users can
regenerate automatically from other parts of the Corresponding Source.

The Corresponding Source for a work in source code form is that same
work.

#### 2. Basic Permissions.

All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met. This License explicitly affirms your unlimited
permission to run the unmodified Program. The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work. This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

You may make, run and propagate covered works that you do not convey,
without conditions so long as your license otherwise remains in force.
You may convey covered works to others for the sole purpose of having
them make modifications exclusively for you, or provide you with
facilities for running those works, provided that you comply with the
terms of this License in conveying all material for which you do not
control copyright. Those thus making or running the covered works for
you must do so exclusively on your behalf, under your direction and
control, on terms that prohibit them from making any copies of your
copyrighted material outside their relationship with you.

Conveying under any other circumstances is permitted solely under the
conditions stated below. Sublicensing is not allowed; section 10 makes
it unnecessary.

#### 3. Protecting Users' Legal Rights From Anti-Circumvention Law.

No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such
circumvention is effected by exercising rights under this License with
respect to the covered work, and you disclaim any intention to limit
operation or modification of the work as a means of enforcing, against
the work's users, your or third parties' legal rights to forbid
circumvention of technological measures.

#### 4. Conveying Verbatim Copies.

You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

#### 5. Conveying Modified Source Versions.

You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these
conditions:

-   a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.
-   b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under
    section 7. This requirement modifies the requirement in section 4
    to "keep intact all notices".
-   c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy. This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged. This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.
-   d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit. Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

#### 6. Conveying Non-Source Forms.

You may convey a covered work in object code form under the terms of
sections 4 and 5, provided that you also convey the machine-readable
Corresponding Source under the terms of this License, in one of these
ways:

-   a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.
-   b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the Corresponding
    Source from a network server at no charge.
-   c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source. This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.
-   d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge. You need not require recipients to copy the
    Corresponding Source along with the object code. If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source. Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.
-   e) Convey the object code using peer-to-peer transmission,
    provided you inform other peers where the object code and
    Corresponding Source of the work are being offered to the general
    public at no charge under subsection 6d.

A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal,
family, or household purposes, or (2) anything designed or sold for
incorporation into a dwelling. In determining whether a product is a
consumer product, doubtful cases shall be resolved in favor of
coverage. For a particular product received by a particular user,
"normally used" refers to a typical or common use of that class of
product, regardless of the status of the particular user or of the way
in which the particular user actually uses, or expects or is expected
to use, the product. A product is a consumer product regardless of
whether the product has substantial commercial, industrial or
non-consumer uses, unless such uses represent the only significant
mode of use of the product.

"Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to
install and execute modified versions of a covered work in that User
Product from a modified version of its Corresponding Source. The
information must suffice to ensure that the continued functioning of
the modified object code is in no case prevented or interfered with
solely because modification has been made.

If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information. But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or
updates for a work that has been modified or installed by the
recipient, or for the User Product in which it has been modified or
installed. Access to a network may be denied when the modification
itself materially and adversely affects the operation of the network
or violates the rules and protocols for communication across the
network.

Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

#### 7. Additional Terms.

"Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law. If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it. (Additional permissions may be written to require their own
removal in certain cases when you modify the work.) You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders
of that material) supplement the terms of this License with terms:

-   a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or
-   b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or
-   c) Prohibiting misrepresentation of the origin of that material,
    or requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or
-   d) Limiting the use for publicity purposes of names of licensors
    or authors of the material; or
-   e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or
-   f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions
    of it) with contractual assumptions of liability to the recipient,
    for any liability that these contractual assumptions directly
    impose on those licensors and authors.

All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10. If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term. If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions; the
above requirements apply either way.

#### 8. Termination.

You may not propagate or modify a covered work except as expressly
provided under this License. Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License. If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

#### 9. Acceptance Not Required for Having Copies.

You are not required to accept this License in order to receive or run
a copy of the Program. Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance. However,
nothing other than this License grants you permission to propagate or
modify any covered work. These actions infringe copyright if you do
not accept this License. Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

#### 10. Automatic Licensing of Downstream Recipients.

Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License. You are not responsible
for enforcing compliance by third parties with this License.

An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations. If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License. For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

#### 11. Patents.

A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based. The
work thus licensed is called the contributor's "contributor version".

A contributor's "essential patent claims" are all patent claims owned
or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version. For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement). To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients. "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

A patent license is "discriminatory" if it does not include within the
scope of its coverage, prohibits the exercise of, or is conditioned on
the non-exercise of one or more of the rights that are specifically
granted under this License. You may not convey a covered work if you
are a party to an arrangement with a third party that is in the
business of distributing software, under which you make payment to the
third party based on the extent of your activity of conveying the
work, and under which the third party grants, to any of the parties
who would receive the covered work from you, a discriminatory patent
license (a) in connection with copies of the covered work conveyed by
you (or copies made from those copies), or (b) primarily for and in
connection with specific products or compilations that contain the
covered work, unless you entered into that arrangement, or that patent
license was granted, prior to 28 March 2007.

Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

#### 12. No Surrender of Others' Freedom.

If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License. If you cannot convey a
covered work so as to satisfy simultaneously your obligations under
this License and any other pertinent obligations, then as a
consequence you may not convey it at all. For example, if you agree to
terms that obligate you to collect a royalty for further conveying
from those to whom you convey the Program, the only way you could
satisfy both those terms and this License would be to refrain entirely
from conveying the Program.

#### 13. Use with the GNU Affero General Public License.

Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work. The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

#### 14. Revised Versions of this License.

The Free Software Foundation may publish revised and/or new versions
of the GNU General Public License from time to time. Such new versions
will be similar in spirit to the present version, but may differ in
detail to address new problems or concerns.

Each version is given a distinguishing version number. If the Program
specifies that a certain numbered version of the GNU General Public
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that numbered version or
of any later version published by the Free Software Foundation. If the
Program does not specify a version number of the GNU General Public
License, you may choose any version ever published by the Free
Software Foundation.

If the Program specifies that a proxy can decide which future versions
of the GNU General Public License can be used, that proxy's public
statement of acceptance of a version permanently authorizes you to
choose that version for the Program.

Later license versions may give you additional or different
permissions. However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

#### 15. Disclaimer of Warranty.

THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
CORRECTION.

#### 16. Limitation of Liability.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR
CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

#### 17. Interpretation of Sections 15 and 16.

If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS

### How to Apply These Terms to Your New Programs

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

To do so, attach the following notices to the program. It is safest to
attach them to the start of each source file to most effectively state
the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

        <one line to give the program's name and a brief idea of what it does.>
        Copyright (C) <year>  <name of author>

        This program is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper
mail.

If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

        <program>  Copyright (C) <year>  <name of author>
        This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
        This is free software, and you are welcome to redistribute it
        under certain conditions; type `show c' for details.

The hypothetical commands \`show w' and \`show c' should show the
appropriate parts of the General Public License. Of course, your
program's commands might be different; for a GUI interface, you would
use an "about box".

You should also get your employer (if you work as a programmer) or
school, if any, to sign a "copyright disclaimer" for the program, if
necessary. For more information on this, and how to apply and follow
the GNU GPL, see <https://www.gnu.org/licenses/>.

The GNU General Public License does not permit incorporating your
program into proprietary programs. If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library. If this is what you want to do, use the
GNU Lesser General Public License instead of this License. But first,
please read <https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`MANIFEST.in`:

```in
recursive-include idarling/resources *.png

```

`README.md`:

```md
- [IDArling](#idarling)
  - [Overview](#overview)
  - [Releases](#releases)
  - [Installation](#installation)
    - [Server-side](#server-side)
    - [Client-side](#client-side)
    - [Integrated server](#integrated-server)
  - [Connection to server and usage](#connection-to-server-and-usage)
  - [Features](#features)
    - [General features](#general-features)
    - [Implementation details](#implementation-details)
    - [Known changes already synced by IDArling](#known-changes-already-synced-by-idarling)
    - [Known changes not currently synced by IDArling](#known-changes-not-currently-synced-by-idarling)
- [Thanks](#thanks)
- [Authors](#authors)
-------------------------------------------------------------------------------

# IDArling

<p align="center">
    <img src="https://i.imgur.com/9Vxm0Fn.png" />
</p>

## Overview

IDArling is a collaborative reverse engineering plugin for [IDA Pro](https://www.hex-rays.com/products/ida/)
and [Hex-Rays](https://www.hex-rays.com/products/decompiler/index.shtml). It
allows to synchronize in real-time the changes made to an IDA database by multiple IDA
users, by connecting together different instances of IDA Pro.

It works by hooking certain IDA events generated by one user in IDA and 
propagating the detected changes to other IDA users through a server architecture.
It supports working from a given snapshot with changes done by other IDA users 
re-applied to every other user loading the same snapshot.

## Releases

This project is under active development. Feel free to send a PR if you would
like to help! :-)

It is stable enough to be used in its current state, but be aware of the features
IDArling does not support before using it so you can save a new snapshot to work
around the limitations (see below).

Note: this is a fork of [https://github.com/IDArlingTeam/IDArling](IDArlingTeam).
The IDArlingTeam version supports IDA 7.0+ and Python2/3. Our fork only supports
the latest version of IDA Pro (7.5 atm) and Python 3 but has more features.

Note: if you migrate from IDArlingTeam installation, you are advised to backup
your old IDBs and start from a fresh new server. This is because we had to break
backward compability to add certain features.

## Installation

There are two different use cases:

* IDA Pro used for both the IDArling client (IDA Pro plugin) and IDArling server, 
  by using the "Integrated Server". You can ignore the "Server-side" installation.
* IDA Pro used for the IDArling clients and a remote IDArling server known as 
  "Standalone Server" or "Dedicated Server". You can refer to the "Server-side"
  and "Client-side" installation

### Server-side

Python3 is required.

The IDArling server is run on a remote system from the command-line. Generally
simply running `./idarling_server.py --no-ssl` is sufficient. A more advanced invocation is:

```
python3 idarling_server.py -h 192.168.1.1 -p 12345 --no-ssl -l DEBUG
```

### Client-side

The latest version of IDA Pro (7.5 atm) with IDA Python 3 is supported.

Install the IDArling client into the IDA plugins folder.

- Copy `idarling_plugin.py` and the `idarling` folder to the IDA plugins folder.
    - On Windows, the folder is at `C:\Program Files\IDA 7.x\plugins`
    - On macOS, the folder is at `/Applications/IDA Pro 7.x/idabin/plugins`
    - On Linux, the folder may be at `~/ida-7.x/plugins/`
- Alternatively, you can use the IDAUSR folder such as 
  `C:\Users\<user>\AppData\Roaming\Hex-Rays\IDA Pro\plugins` on Windows.
- Alternatively, you can use the "easy install" method by copying the following
line into the console:

```
import urllib2; exec(urllib2.urlopen('https://raw.githubusercontent.com/fidgetingbits/IDArling/master/easy_install.py')).read()
```

### Integrated server

To enable the integrated server, you can choose "Integrated Server" after right-clicking
the IDArling widget located in the status bar.

The integrated server requires PySide6, which is integrated into IDA. If you're
using an external Python installation, we recommand using Python 3, which offers
a pre-built package that can be installed with a simple `pip install PySide6`.

## Connection to server and usage

Open the "Settings" dialog accessible from the right-clicking the IDArling widget located
in the status bar. Show the servers list by clicking on the "Network Settings"
tabs and add your server to it. Connect to the server by clicking on it after 
right-clicking the widget again. Finally, you should be able to access the
following menus to upload or download a database:

* File --> Open from server
* File --> Save to server

![](img/open_from_server.png)

## Features

### General features

The main features of IDArling (advertised originally) are:

* hooking general user events
* structure and enumeration support
* Hex-Rays decompiler syncing
* replay engine and auto-saving
* database loading and saving
* interactive status bar widget
* user cursors (instructions, functions, navbar)
* invite and following an user moves
* dedicated server using Qt5
* integrated server within IDA
* LAN servers discovery
* following an user moves in real time

### Implementation details

In order to understand what change is actually synced vs not synced, it is 
worth mentioning some implementation details.

We like to define the following terms in the IDArling jargon:

- **project**: a project corresponds to a researched topic such as a given CVE, malware family,
  etc. regrouping several binary files
- **binary file**: a binary file corresponds to a given file to analyse (i.e. unique SHA-256 hash)
- **database snapshot**: a database snapshot is a snapshot of an IDB as a given time. It is 
  used as a baseline to apply any change made from this snapshot by any other 
  IDA user

In general, the first thing is to create a project for the research topic you are
starting. Then, you create a binary file to analyse a given file with a unique hash (e.g. `ntoskrnl.exe`
on Windows 10 1809 x64 from May 2019) and then you create one initial database snapshot and
save the current IDB as that snapshot on the server.

All the changes made for this IDB can live in the same saved snapshot as long as all
the changes you do are synced by IDArling. However, if there are some major changes that are
not synced by IDArling, you need to create an additional snapshot to save these changes
and all users SHOULD then use that particular snapshot.

In general, it is better to always start from the latest snapshot for a given binary file
when you start working from the IDArling server, except if you know what you are doing.

Another important detail of IDArling is that **it stores in the IDB itself the project, binary file
and database snapshot** that was used when saving the IDB onto the server. Because of that, it is
possible to open a local copy of a given IDB that was previously used with IDArling and the IDArling 
plugin will recognise what snapshot this IDB is part of.

If you decide to save an IDB to a new snapshot, you are NOT REQUIRED to then close the IDB and open 
the new snapshot that you have just saved. You can keep working from your existing 
already-opened IDB. This is because the new project, binary file and database snapshot are automatically
updated in your local copy of the IDB. The only exception to this would be if someone else 
simultaneously saved their own IDB and uploaded a new snapshot and you want to use that snapshot.

### Known changes already synced by IDArling

The changes are indicated as "**ticks**" in the IDArling plugin jaron.

In general, the changes applied to a given snapshot are retrieved the next 
time you open the particular snapshot as the events will be propagated to the 
base IDB or your local copy.

* Syncs variable names in Hex-Rays
* Syncs comments in Hex-Rays
* Syncs function prototype edits in both IDA and Hex-Rays
* Syncs integer type (hex / integer / binary / enum) changes in both IDA and Hex-Rays
* Manually creating an enum and pasting in the code will actually sync across
 IDBs
 
Note: the above list is not up-to-date and needs to be updated.

### Known changes not currently synced by IDArling

These changes typically require you to create a new database (i.e. snapshot, as
explained above) so you don't lose your changes. It is typically the case for
actions that do not generate events that IDArling can catch and propagate.

We are tracking in 2 categories the issues on our github repository:

* [Fatal non-propagated features](https://github.com/fidgetingbits/IDArling/labels/fatal%20non-propagated%20feature): 
  These are features of IDA that are not propagated over IDArling that 
  potentially corrupt the IDB. An example would be if new types were not created 
  properly. If it were the case, it means all actions that depend on the types 
  existing would be broken, e.g. decompiler/disassembler output that relies on 
  these structures, etc.
* [Non-propagated features](https://github.com/fidgetingbits/IDArling/issues?q=is%3Aissue+is%3Aopen+label%3A%22non-propagated+feature%22):
  These are features of IDA that are not propagated over IDArling but do not 
  risk corrupting the IDB. An example would be if bookmarks were not propagated.
  It is not the case but if it were, only bookmarks would be missing and all the
  other contents from the IDBs would still be sane.

Note that some of the issues have been marked as "won't fix" and closed as atm
we don't think they are worth fixing but feel free to add comments if you disagree.

# Thanks

This project is inspired by [Sol[IDA]rity](https://solidarity.re/). It started
after contacting its authors and asking if it was ever going to be released to
the public. [Lighthouse](https://github.com/gaasedelen/lighthouse) source code
was also carefully studied to understand how to write better IDA plugins.

* Previous plugins, namely [CollabREate](https://github.com/cseagle/collabREate),
[IDASynergy](https://github.com/CubicaLabs/IDASynergy),
[YaCo](https://github.com/DGA-MI-SSI/YaCo), were studied during the development
process;
* The icons are edited and combined versions from the sites [freeiconshop.com](http://freeiconshop.com/)
and [www.iconsplace.com](http://www.iconsplace.com).

Thanks to Quarkslab for allowing this release.

# Authors

* Alexandre Adamski <<neat@idarling.re>>
* Joffrey Guilbon <<patate@idarling.re>>
* Cedric Halbronn ([@saidelike](https://twitter.com/saidelike))
* Aaron Adams ([@FidgetingBits](https://twitter.com/fidgetingbits))
* rigmar

If you have any questions not worthy of a bug report, feel free to ping us at
[#idarling on freenode](https://kiwiirc.com/client/irc.freenode.net/idarling)
and ask away.

```

`easy_install.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import os
import shutil
import urllib2
import zipfile

import ida_diskio
import ida_loader

# Allow the user to override the download URL
if "URL" not in locals():
    URL = "https://github.com/IDArlingTeam/IDArling/archive/master.zip"

print("[*] Installing IDArling...")
# Install into the user directory on all platforms
user_dir = ida_diskio.get_user_idadir()
plug_dir = os.path.join(user_dir, "plugins")
if not os.path.exists(plug_dir):
    os.makedirs(plug_dir, 493)  # 0755

print("[*] Downloading master.zip archive...")
archive_path = os.path.join(plug_dir, "master.zip")
if os.path.exists(archive_path):
    os.remove(archive_path)
with open(archive_path, "wb") as f:
    f.write(urllib2.urlopen(URL).read())

print("[*] Unzipping master.zip archive...")
archive_dir = os.path.join(plug_dir, "IDArling-master")
if os.path.exists(archive_dir):
    shutil.rmtree(archive_dir)
with zipfile.ZipFile(archive_path, "r") as zip:
    for zip_file in zip.namelist():
        if zip_file.startswith(os.path.basename(archive_dir)):
            zip.extract(zip_file, plug_dir)

print("[*] Moving the IDArling files...")
src_path = os.path.join(archive_dir, "idarling_plugin.py")
dst_path = os.path.join(plug_dir, os.path.basename(src_path))
if os.path.exists(dst_path):
    os.remove(dst_path)
shutil.move(src_path, dst_path)
src_dir = os.path.join(archive_dir, "idarling")
dst_dir = os.path.join(plug_dir, os.path.basename(src_dir))
if os.path.exists(dst_dir):
    shutil.rmtree(dst_dir)
shutil.move(src_dir, dst_dir)

print("[*] Removing master.zip archive...")
if os.path.exists(archive_path):
    os.remove(archive_path)
if os.path.exists(archive_dir):
    shutil.rmtree(archive_dir)

print("[*] Loading IDArling into IDA Pro...")
plugin_path = os.path.join(plug_dir, "idarling_plugin.py")
ida_loader.load_plugin(plugin_path)

print("[*] IDArling installed successfully!")

```

`idarling/core/core.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import ctypes
import os
import sys

import ida_auto
import ida_diskio
import ida_idp
import ida_kernwin
import ida_netnode
import ida_typeinf

from PySide6.QtCore import QCoreApplication, QFileInfo  # noqa: I202

from .hooks import HexRaysHooks, IDBHooks, IDPHooks, UIHooks
from ..module import Module
from ..shared.commands import (
    JoinSession,
    LeaveSession,
    ListSnapshots,
    UpdateLocation,
)
from ..shared.local_types import ImportLocalType

if sys.version_info > (3,):
    long = int


class Core(Module):
    """
    This is the core module. It is responsible for interacting with the IDA
    kernel. It will handle hooking, sending, and replaying of user events.
    """

    NETNODE_NAME = "$ idarling"

    @staticmethod
    def get_ida_dll(app_name=None):
        if app_name is None:
            app_path = QCoreApplication.applicationFilePath()
            app_name = QFileInfo(app_path).fileName()
        idaname = "ida64" if "64" in app_name else "ida"
        if sys.platform == "win32":
            dllname, dlltype = idaname + ".dll", ctypes.windll
        elif sys.platform in ["linux", "linux2"]:
            dllname, dlltype = "lib" + idaname + ".so", ctypes.cdll
        elif sys.platform == "darwin":
            dllname, dlltype = "lib" + idaname + ".dylib", ctypes.cdll
        dllpath = ida_diskio.idadir(None)
        if not os.path.exists(os.path.join(dllpath, dllname)):
            dllpath = dllpath.replace("ida64", "ida")
        return dlltype[os.path.join(dllpath, dllname)]

    def __init__(self, plugin):
        super(Core, self).__init__(plugin)
        self._project = None
        self._binary = None
        self._snapshot = None
        self._tick = -1
        self._users = {}
        self._session_joined = False

        self._idb_hooks = None
        self._idp_hooks = None
        self._hxe_hooks = None

        self._idb_hooks_core = None
        self._idp_hooks_core = None
        self._ui_hooks_core = None
        self._view_hooks_core = None
        self._hooked = False

        self.local_type_map = {}
        self.delete_candidates = {}

    @property
    def project(self):
        return self._project

    @project.setter
    def project(self, project):
        self._project = project
        self.save_netnode()

    @property
    def binary(self):
        return self._binary

    @binary.setter
    def binary(self, binary):
        self._binary = binary
        self.save_netnode()

    @property
    def snapshot(self):
        return self._snapshot

    @snapshot.setter
    def snapshot(self, snapshot):
        self._snapshot = snapshot
        self.save_netnode()

    @property
    def tick(self):
        return self._tick

    @tick.setter
    def tick(self, tick):
        self._tick = tick
        self.save_netnode()

    def update_local_types_map(self):
        for i in range(1, ida_typeinf.get_ordinal_count(ida_typeinf.get_idati())):
            t = ImportLocalType(i)
            self.local_type_map[i] = t

    def add_user(self, name, user):
        self._users[name] = user
        self._plugin.interface.painter.refresh()
        self._plugin.interface.widget.refresh()

    def remove_user(self, name):
        user = self._users.pop(name)
        self._plugin.interface.painter.refresh()
        self._plugin.interface.widget.refresh()
        return user

    def get_user(self, name):
        return self._users[name]

    def get_users(self):
        return self._users

    def _install(self):
        # Instantiate the hooks
        self._idb_hooks = IDBHooks(self._plugin)
        self._idp_hooks = IDPHooks(self._plugin)
        self._hxe_hooks = HexRaysHooks(self._plugin)
        self._ui_hooks = UIHooks(self._plugin)

        core = self
        self._plugin.logger.debug("Installing core hooks")

        class IDBHooksCore(ida_idp.IDB_Hooks):
            def closebase(self):
                core._plugin.logger.trace("Closebase hook")
                core.leave_session()
                core.save_netnode()

                core.project = None
                core.binary = None
                core.snapshot = None
                core.ticks = 0
                return 0

        self._idb_hooks_core = IDBHooksCore()
        self._idb_hooks_core.hook()

        class IDPHooksCore(ida_idp.IDP_Hooks):
            def ev_get_bg_color(self, color, ea):
                #core._plugin.logger.trace("Get bg color hook")
                value = core._plugin.interface.painter.get_bg_color(ea)
                if value is not None:
                    ctypes.c_uint.from_address(long(color)).value = value
                    return 1
                return 0

            def ev_auto_queue_empty(self, arg):
                #core._plugin.logger.debug("Auto queue empty hook")
                if ida_auto.get_auto_state() == ida_auto.AU_NONE:
                    client = core._plugin.network.client
                    if client:
                        client.call_events()
                return super(self.__class__, self).ev_auto_queue_empty(arg)

        self._idp_hooks_core = IDPHooksCore()
        self._idp_hooks_core.hook()

        class UIHooksCore(ida_kernwin.UI_Hooks):
            def ready_to_run(self):
                core._plugin.logger.trace("Ready to run hook")
                core.load_netnode()
                core.join_session()
                # XXX - calling this function triggered lots of errors
                # when moving to Python 3
                core._plugin.interface.painter.ready_to_run()

            def get_ea_hint(self, ea):
                core._plugin.logger.trace("Get ea hint hook")
                return core._plugin.interface.painter.get_ea_hint(ea)

            def widget_visible(self, widget):
                core._plugin.logger.trace("Widget visible")
                core._plugin.interface.painter.widget_visible(widget)

        self._ui_hooks_core = UIHooksCore()
        self._ui_hooks_core.hook()

        class ViewHooksCore(ida_kernwin.View_Hooks):
            def view_loc_changed(self, view, now, was):
                # Even if it is a core hook, there is no point sending an
                # UpdateLocation if we are not in a valid session
                if not core._session_joined:
                    return
                #core._plugin.logger.trace("View loc changed hook")
                if now.plce.toea() != was.plce.toea():
                    name = core._plugin.config["user"]["name"]
                    color = core._plugin.config["user"]["color"]
                    core._plugin.network.send_packet(
                        UpdateLocation(name, now.plce.toea(), color)
                    )

        self._view_hooks_core = ViewHooksCore()
        self._view_hooks_core.hook()
        return True

    def _uninstall(self):
        self._plugin.logger.debug("Uninstalling core hooks")
        self._idb_hooks_core.unhook()
        self._ui_hooks_core.unhook()
        self._view_hooks_core.unhook()
        self.unhook_all()
        return True

    def hook_all(self):
        """Install all the user events hooks."""
        if self._hooked:
            return

        self._plugin.logger.debug("Installing hooks")
        self._idb_hooks.hook()
        self._idp_hooks.hook()
        self._hxe_hooks.hook()
        self._ui_hooks.hook()
        self._hooked = True
        self._plugin.core.update_local_types_map()

    def unhook_all(self):
        """Uninstall all the user events hooks."""
        if not self._hooked:
            return

        self._plugin.logger.debug("Uninstalling hooks")
        self._idb_hooks.unhook()
        self._idp_hooks.unhook()
        self._hxe_hooks.unhook()
        self._ui_hooks.unhook()
        self._hooked = False

    def load_netnode_old(self):
        self._plugin.logger.warning("Old idb detected, please save your idb as a new snapshot")
        node = ida_netnode.netnode(Core.NETNODE_NAME, 0, True)

        self._project = node.hashstr("group") or None
        self._binary = node.hashstr("project") or None
        self._snapshot = node.hashstr("database") or None
        self._tick = int(node.hashstr("tick") or "0")

        # Replacing old netnode in local idb
        node.kill()
        self.save_netnode()

    def load_netnode(self):
        """
        Load data from our custom netnode. Netnodes are the mechanism used by
        IDA to load and save information into an idb. IDArling uses its own
        netnode to remember which project, binary and snapshot an idb belongs to.
        """
        node = ida_netnode.netnode(Core.NETNODE_NAME, 0, True)
        if node.hashstr("database"):
            self.load_netnode_old()
        else:
            self._project = node.hashstr("project") or None
            self._binary = node.hashstr("binary") or None
            self._snapshot = node.hashstr("snapshot") or None
            self._tick = int(node.hashstr("tick") or "0")

        self._plugin.logger.debug(
            "Loaded netnode: project=%s, binary=%s, snapshot=%s, tick=%d"
            % (self._project, self._binary, self._snapshot, self._tick)
        )

    def save_netnode(self):
        """Save data into our custom netnode."""
        node = ida_netnode.netnode(Core.NETNODE_NAME, 0, True)

        # node.hashset does not work anymore with direct string
        # use of hashet_buf instead
        # (see https://github.com/idapython/src/blob/master/swig/netnode.i#L162)
        if self._project:
            node.hashset_buf("project", str(self._project))
        if self._binary:
            node.hashset_buf("binary", str(self._binary))
        if self._snapshot:
            node.hashset_buf("snapshot", str(self._snapshot))
        # We need the test to be non-zero as we need to reset and save tick=0 
        # when saving an IDB to a new snapshot
        if self._tick != -1:
            node.hashset_buf("tick", str(self._tick))

        self._plugin.logger.debug(
            "Saved netnode: project=%s, binary=%s, snapshot=%s, tick=%d"
            % (self._project, self._binary, self._snapshot, self._tick)
        )

    def join_session(self):
        """Join the collaborative session."""
        if self._project and self._binary and self._snapshot:
            if self._session_joined:
                self._plugin.logger.debug("Joining a new session")
            else:
                self._plugin.logger.debug("Joining session")

            def snapshots_listed(reply):
                if any(d.name == self._snapshot for d in reply.snapshots):
                    self._plugin.logger.debug("Snapshot is on the server")
                else:
                    self._plugin.logger.debug("Snapshot is not on the server")
                    return  # Do not go further

                name = self._plugin.config["user"]["name"]
                color = self._plugin.config["user"]["color"]
                ea = ida_kernwin.get_screen_ea()
                self._plugin.network.send_packet(
                    JoinSession(
                        self._project,
                        self._binary,
                        self._snapshot,
                        self._tick,
                        name,
                        color,
                        ea,
                    )
                )
                self._session_joined = True
                self.hook_all()
                self._users.clear()

            d = self._plugin.network.send_packet(
                ListSnapshots.Query(self._project, self._binary)
            )
            if d:
                d.add_callback(snapshots_listed)
                d.add_errback(self._plugin.logger.exception)
        else:
            self._plugin.logger.debug("Not joining any session yet")
            self._session_joined = False

    def leave_session(self):
        """Leave the collaborative session."""
        if not self._session_joined:
            self._plugin.logger.debug("Already left session")
            return

        self._plugin.logger.debug("Leaving session")
        if self._project and self._binary and self._snapshot:
            name = self._plugin.config["user"]["name"]
            self._plugin.network.send_packet(LeaveSession(name))
            self._users.clear()
            self.unhook_all()
        self._session_joined = False

```

`idarling/core/events.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import ctypes
import pickle
import sys

import ida_bytes
import ida_funcs
import ida_hexrays
import ida_idaapi
import ida_kernwin
import ida_lines
import ida_nalt
import ida_name
import ida_netnode
import ida_pro
import ida_range
import ida_segment
import ida_segregs
import ida_typeinf
import ida_ua
import ida_idc
import ida_offset
import idc

from ..shared.local_types import GetTypeString, LocalType, InsertType
from ..shared.packets import DefaultEvent

if sys.version_info > (3,):
    unicode = str


# Base class inherited by all events (assembly, HexRays, struct, enums, etc.)
class Event(DefaultEvent):
    """
    This is a common class for all events that provides utility methods to
    encode/decode strings and raw bytes. Events should also implement __call__
    which is called when the event needs to be replayed into IDA.
    """

    @staticmethod
    def encode(s):
        """Encodes a unicode string into UTF-8 bytes."""
        if isinstance(s, bytes):
            return s
        elif isinstance(s, unicode):
            return s.encode("utf-8")
        raise NotImplementedError("encode(): %s not implemented" % (type(s)))

    @staticmethod
    def encode_bytes(s):
        """Encodes a unicode string into raw bytes."""
        if isinstance(s, bytes):
            return s
        elif isinstance(s, unicode):
            return s.encode("raw_unicode_escape")
        else:
            return s

    @staticmethod
    def decode(s):
        """Decodes UTF-8 bytes into a unicode string."""
        if isinstance(s, unicode):
            return s
        elif isinstance(s, bytes):
            return s.decode("utf-8")
        raise NotImplementedError("decode(): %s not implemented" % (type(s)))

    @staticmethod
    def decode_bytes(s):
        """Decodes raw bytes into a unicode string."""
        if isinstance(s, unicode):
            return s
        elif isinstance(s, bytes):
            return s.decode("raw_unicode_escape")
        else:
            return s

    def __call__(self):
        """Reproduce the underlying user event into IDA."""
        raise NotImplementedError("__call__() not implemented")


class MakeCodeEvent(Event):
    __event__ = "make_code"

    def __init__(self, ea):
        super(MakeCodeEvent, self).__init__()
        self.ea = ea

    def __call__(self):
        ida_ua.create_insn(self.ea)


class MakeDataEvent(Event):
    __event__ = "make_data"

    def __init__(self, ea, flags, size, sname):
        super(MakeDataEvent, self).__init__()
        self.ea = ea
        self.flags = flags
        self.size = size
        self.sname = sname

    def __call__(self):
        ida_bytes.create_data(self.ea, ida_bytes.calc_dflags(self.flags, True), self.size, idc.get_struc_id(self.sname) if self.sname else ida_netnode.BADNODE)


class RenamedEvent(Event):
    __event__ = "renamed"

    def __init__(self, ea, new_name, local_name):
        super(RenamedEvent, self).__init__()
        self.ea = ea
        self.new_name = new_name
        self.local_name = local_name

    def __call__(self):
        flags = ida_name.SN_LOCAL if self.local_name else 0
        ida_name.set_name(
            self.ea, self.new_name, flags | ida_name.SN_NOWARN
        )
        ida_kernwin.request_refresh(ida_kernwin.IWID_DISASMS)
        ida_kernwin.request_refresh(ida_kernwin.IWID_STKVIEW)

        if hasattr(ida_kernwin, "IWID_STRUCTS"):
            ida_kernwin.request_refresh(ida_kernwin.IWID_STRUCTS)
        else:
            ida_kernwin.refresh_idaview_anyway()

        HexRaysEvent.refresh_pseudocode_view(self.ea)


class FuncAddedEvent(Event):
    __event__ = "func_added"

    def __init__(self, start_ea, end_ea):
        super(FuncAddedEvent, self).__init__()
        self.start_ea = start_ea
        self.end_ea = end_ea

    def __call__(self):
        ida_funcs.add_func(self.start_ea, self.end_ea)


class DeletingFuncEvent(Event):
    __event__ = "deleting_func"

    def __init__(self, start_ea):
        super(DeletingFuncEvent, self).__init__()
        self.start_ea = start_ea

    def __call__(self):
        ida_funcs.del_func(self.start_ea)


class SetFuncStartEvent(Event):
    __event__ = "set_func_start"

    def __init__(self, start_ea, new_start):
        super(SetFuncStartEvent, self).__init__()
        self.start_ea = start_ea
        self.new_start = new_start

    def __call__(self):
        ida_funcs.set_func_start(self.start_ea, self.new_start)


class SetFuncEndEvent(Event):
    __event__ = "set_func_end"

    def __init__(self, start_ea, new_end):
        super(SetFuncEndEvent, self).__init__()
        self.start_ea = start_ea
        self.new_end = new_end

    def __call__(self):
        ida_funcs.set_func_end(self.start_ea, self.new_end)


class FuncTailAppendedEvent(Event):
    __event__ = "func_tail_appended"

    def __init__(self, start_ea_func, start_ea_tail, end_ea_tail):
        super(FuncTailAppendedEvent, self).__init__()
        self.start_ea_func = start_ea_func
        self.start_ea_tail = start_ea_tail
        self.end_ea_tail = end_ea_tail

    def __call__(self):
        func = ida_funcs.get_func(self.start_ea_func)
        ida_funcs.append_func_tail(func, self.start_ea_tail, self.end_ea_tail)


class FuncTailDeletedEvent(Event):
    __event__ = "func_tail_deleted"

    def __init__(self, start_ea_func, tail_ea):
        super(FuncTailDeletedEvent, self).__init__()
        self.start_ea_func = start_ea_func
        self.tail_ea = tail_ea

    def __call__(self):
        func = ida_funcs.get_func(self.start_ea_func)
        ida_funcs.remove_func_tail(func, self.tail_ea)


class TailOwnerChangedEvent(Event):
    __event__ = "tail_owner_changed"

    def __init__(self, tail_ea, owner_func):
        super(TailOwnerChangedEvent, self).__init__()
        self.tail_ea = tail_ea
        self.owner_func = owner_func

    def __call__(self):
        tail = ida_funcs.get_fchunk(self.tail_ea)
        ida_funcs.set_tail_owner(tail, self.owner_func)


class CmtChangedEvent(Event):
    __event__ = "cmt_changed"

    def __init__(self, ea, comment, rptble):
        super(CmtChangedEvent, self).__init__()
        self.ea = ea
        self.comment = comment
        self.rptble = rptble

    def __call__(self):
        ida_bytes.set_cmt(self.ea, self.comment, self.rptble)


class RangeCmtChangedEvent(Event):
    __event__ = "range_cmt_changed"

    def __init__(self, kind, a, cmt, rptble):
        super(RangeCmtChangedEvent, self).__init__()
        self.kind = kind
        self.start_ea = a.start_ea
        self.end_ea = a.end_ea
        self.cmt = cmt
        self.rptble = rptble

    def __call__(self):
        cmt = self.cmt
        if self.kind == ida_range.RANGE_KIND_FUNC:
            func = ida_funcs.get_func(self.start_ea)
            ida_funcs.set_func_cmt(func, cmt, self.rptble)
        elif self.kind == ida_range.RANGE_KIND_SEGMENT:
            segment = ida_segment.getseg(self.start_ea)
            ida_segment.set_segment_cmt(segment, cmt, self.rptble)
        else:
            raise Exception("Unsupported range kind: %d" % self.kind)


class ExtraCmtChangedEvent(Event):
    __event__ = "extra_cmt_changed"

    def __init__(self, ea, line_idx, cmt):
        super(ExtraCmtChangedEvent, self).__init__()
        self.ea = ea
        self.line_idx = line_idx
        self.cmt = cmt

    def __call__(self):
        ida_lines.del_extra_cmt(self.ea, self.line_idx)
        isprev = 1 if self.line_idx - 1000 < 1000 else 0
        if not self.cmt:
            return 0
        ida_lines.add_extra_cmt(self.ea, isprev, self.cmt)


class TiChangedEvent(Event):
    __event__ = "ti_changed"

    def __init__(self, ea, py_type, name):
        super(TiChangedEvent, self).__init__()
        self.ea = ea
        self.py_type = []
        self.name = name
        if py_type:
            self.py_type.extend(Event.decode_bytes(t) for t in py_type)

    def __call__(self):
        py_type = [Event.encode_bytes(t) for t in self.py_type]
        if len(py_type) == 3:
            py_type = py_type[1:]
        if len(py_type) >= 2:
            if self.name:
                r = idc.get_member_by_fullname(self.name)
                if r:
                    self.ea = r[0].id
            ida_typeinf.apply_type(
                None,
                GetTypeString(py_type[0]),
                py_type[1],
                self.ea,
                ida_typeinf.TINFO_DEFINITE,
            )


class LocalTypesChangedEvent(Event):
    __event__ = "local_types_changed"

    def __init__(self, local_types):
        super(LocalTypesChangedEvent, self).__init__()
        self.local_types = local_types

    def __call__(self):
        for t_old, t_new in self.local_types:
            if t_new:
                name, parsed_list, type_fields = t_new
                t_new = LocalType(name=name,parsedList=parsed_list,TypeFields=type_fields.encode())
                InsertType(t_new,fReplace=True)
        ida_kernwin.request_refresh(ida_kernwin.IWID_LOCTYPS)
        # XXX - old code below to delete?
        # from .core import Core
        #
        # dll = Core.get_ida_dll()
        #
        # get_idati = dll.get_idati
        # get_idati.argtypes = []
        # get_idati.restype = ctypes.c_void_p
        #
        # set_numbered_type = dll.set_numbered_type
        # set_numbered_type.argtypes = [
        #     ctypes.c_void_p,
        #     ctypes.c_uint32,
        #     ctypes.c_int,
        #     ctypes.c_char_p,
        #     ctypes.c_char_p,
        #     ctypes.c_char_p,
        #     ctypes.c_char_p,
        #     ctypes.c_char_p,
        #     ctypes.c_int,
        # ]
        # set_numbered_type.restype = ctypes.c_int
        #
        # py_ti = ida_typeinf.get_idati()
        # ordinal_qty = ida_typeinf.get_ordinal_qty(py_ti) - 1
        # last_ordinal = self.local_types[-1][0]
        # if ordinal_qty < last_ordinal:
        #     ida_typeinf.alloc_type_ordinals(py_ti, last_ordinal - ordinal_qty)
        # else:
        #     for py_ordinal in range(last_ordinal + 1, ordinal_qty + 1):
        #         ida_typeinf.del_numbered_type(py_ti, py_ordinal)
        #
        # local_types = self.local_types
        # for py_ord, name, type, fields, cmt, fieldcmts, sclass in local_types:
        #     if type:
        #         ti = get_idati()
        #         ordinal = ctypes.c_uint32(py_ord)
        #         ntf_flags = ctypes.c_int(ida_typeinf.NTF_REPLACE)
        #         name = ctypes.c_char_p(Event.encode_bytes(name))
        #         type = ctypes.c_char_p(Event.encode_bytes(type))
        #         fields = ctypes.c_char_p(Event.encode_bytes(fields))
        #         cmt = ctypes.c_char_p(Event.encode_bytes(cmt))
        #         fieldcmts = ctypes.c_char_p(Event.encode_bytes(fieldcmts))
        #         sclass = ctypes.c_int(sclass)
        #         set_numbered_type(
        #             ti,
        #             ordinal,
        #             ntf_flags,
        #             name,
        #             type,
        #             fields,
        #             cmt,
        #             fieldcmts,
        #             sclass,
        #         )
        #
        # ida_kernwin.request_refresh(ida_kernwin.IWID_LOCTYPS)


class OpTypeChangedEvent(Event):
    __event__ = "op_type_changed"

    def __init__(self, ea, n, op, extra):
        super(OpTypeChangedEvent, self).__init__()
        self.ea = ea
        self.n = n
        self.op = op
        self.extra = extra

    def __call__(self):
        if self.op == "hex":
            ida_bytes.op_hex(self.ea, self.n)
        if self.op == "bin":
            ida_bytes.op_bin(self.ea, self.n)
        if self.op == "dec":
            ida_bytes.op_dec(self.ea, self.n)
        if self.op == "chr":
            ida_bytes.op_chr(self.ea, self.n)
        if self.op == "oct":
            ida_bytes.op_oct(self.ea, self.n)
        if self.op == "offset":
            ida_offset.op_plain_offset(self.ea, self.n, 0)
        if self.op == "enum":
            id = idc.get_enum(self.extra["ename"])
            ida_bytes.op_enum(self.ea, self.n, id, self.extra["serial"])
        if self.op == "struct":
            path_len = len(self.extra["spath"])
            path = ida_pro.tid_array(path_len)
            for i in range(path_len):
                sname = self.extra["spath"][i]
                path[i] = idc.get_struc_id(sname)
            insn = ida_ua.insn_t()
            ida_ua.decode_insn(insn, self.ea)
            ida_bytes.op_stroff(
                insn, self.n, path.cast(), path_len, self.extra["delta"]
            )
        if self.op == "stkvar":
            ida_bytes.op_stkvar(self.ea, self.n)
        # FIXME: No hooks are called when inverting sign
        # if self.op == 'invert_sign':
        #     idc.toggle_sign(ea, n)


class EnumCreatedEvent(Event):
    __event__ = "enum_created"

    def __init__(self, enum, name):
        super(EnumCreatedEvent, self).__init__()
        self.enum = enum
        self.name = name

    def __call__(self):
        idc.add_enum(self.enum, self.name, 0)


class EnumDeletedEvent(Event):
    __event__ = "enum_deleted"

    def __init__(self, ename):
        super(EnumDeletedEvent, self).__init__()
        self.ename = ename

    def __call__(self):
        idc.del_enum(idc.get_enum(self.ename))


class EnumRenamedEvent(Event):
    __event__ = "enum_renamed"

    def __init__(self, oldname, newname, is_enum):
        super(EnumRenamedEvent, self).__init__()
        self.oldname = oldname
        self.newname = newname
        self.is_enum = is_enum

    def __call__(self):
        if self.is_enum:
            enum = idc.get_enum(self.oldname)
            idc.set_enum_name(enum, self.newname)
        else:
            emem = idc.get_enum_member_by_name(self.oldname)
            idc.set_enum_member_name(emem, self.newname)


class EnumBfChangedEvent(Event):
    __event__ = "enum_bf_changed"

    def __init__(self, ename, bf_flag):
        super(EnumBfChangedEvent, self).__init__()
        self.ename = ename
        self.bf_flag = bf_flag

    def __call__(self):
        enum = idc.get_enum(self.ename)
        idc.set_enum_bf(enum, self.bf_flag)


class EnumCmtChangedEvent(Event):
    __event__ = "enum_cmt_changed"

    def __init__(self, emname, cmt, repeatable_cmt):
        super(EnumCmtChangedEvent, self).__init__()
        self.emname = emname
        self.cmt = cmt
        self.repeatable_cmt = repeatable_cmt

    def __call__(self):
        emem = idc.get_enum_member_by_name(self.emname)
        cmt = self.cmt if self.cmt else ""
        idc.set_enum_cmt(emem, cmt, self.repeatable_cmt)


class EnumMemberCreatedEvent(Event):
    __event__ = "enum_member_created"

    def __init__(self, ename, name, value, bmask):
        super(EnumMemberCreatedEvent, self).__init__()
        self.ename = ename
        self.name = name
        self.value = value
        self.bmask = bmask

    def __call__(self):
        enum = idc.get_enum(self.ename)
        idc.add_enum_member(
            enum, self.name, self.value, self.bmask
        )


class EnumMemberDeletedEvent(Event):
    __event__ = "enum_member_deleted"

    def __init__(self, ename, value, serial, bmask):
        super(EnumMemberDeletedEvent, self).__init__()
        self.ename = ename
        self.value = value
        self.serial = serial
        self.bmask = bmask

    def __call__(self):
        enum = idc.get_enum(self.ename)
        idc.del_enum_member(enum, self.value, self.serial, self.bmask)


class StrucCreatedEvent(Event):
    __event__ = "struc_created"

    def __init__(self, struc, name, is_union):
        super(StrucCreatedEvent, self).__init__()
        self.struc = struc
        self.name = name
        self.is_union = is_union

    def __call__(self):
        idc.add_struc(
            ida_idaapi.BADADDR, self.name, self.is_union
        )


class StrucDeletedEvent(Event):
    __event__ = "struc_deleted"

    def __init__(self, sname):
        super(StrucDeletedEvent, self).__init__()
        self.sname = sname

    def __call__(self):
        struc = idc.get_struc_id(self.sname)
        idc.del_struc(idc.get_struc(struc))


class StrucRenamedEvent(Event):
    __event__ = "struc_renamed"

    def __init__(self, oldname, newname):
        super(StrucRenamedEvent, self).__init__()
        self.oldname = oldname
        self.newname = newname

    def __call__(self):
        struc = idc.get_struc_id(self.oldname)
        idc.set_struc_name(struc, self.newname)


class StrucCmtChangedEvent(Event):
    __event__ = "struc_cmt_changed"

    def __init__(self, sname, smname, cmt, repeatable_cmt):
        super(StrucCmtChangedEvent, self).__init__()
        self.sname = sname
        self.smname = smname
        self.cmt = cmt
        self.repeatable_cmt = repeatable_cmt

    def __call__(self):
        struc = idc.get_struc_id(self.sname)
        sptr = idc.get_struc(struc)
        cmt = self.cmt if self.cmt else ""
        if self.smname:
            mptr = idc.get_member_by_name(
                sptr, self.smname
            )
            idc.set_member_cmt(mptr, cmt, self.repeatable_cmt)
        else:
            idc.set_struc_cmt(sptr.id, cmt, self.repeatable_cmt)


class StrucMemberEvent(Event):
    """
    Base class inherited by all "struc_member_*" events
    """
    @staticmethod
    def _get_sptr(struct_name):
        struc_id = idc.get_struc_id(struct_name)
        return idc.get_struc(struc_id)

    @staticmethod
    def _get_member_type(type_flag, extra):
        mt = ida_nalt.opinfo_t()
        if ida_bytes.is_struct(type_flag):
            mt.tid = idc.get_struc_id(extra['struc_name'])
        if type_flag & ida_bytes.off_flag():
            mt.ri = ida_nalt.refinfo_t()
            mt.ri.init(
                extra['flags'],
                extra['base'],
                extra['target'],
                extra['tdelta'],
            )
        if type_flag & ida_bytes.enum_flag():
            mt.ec.serial = extra['serial']
            # Backwards compatibility: Past versions didn't store the tid
            mt.ec.tid = extra.get('tid', 0)
        if ida_bytes.is_strlit(type_flag):
            mt.strtype = extra['strtype']

        return mt


class StrucMemberCreatedEvent(StrucMemberEvent):
    __event__ = "struc_member_created"

    def __init__(self, sname, fieldname, offset, flag, nbytes, extra):
        super(StrucMemberCreatedEvent, self).__init__()
        self.sname = sname
        self.fieldname = fieldname
        self.offset = offset
        self.flag = flag
        self.nbytes = nbytes
        self.extra = extra

    def __call__(self):
        sptr = self._get_sptr(self.sname)
        mt = self._get_member_type(self.flag, self.extra)
        idc.add_struc_member(
            sptr,
            self.fieldname,
            self.offset,
            self.flag,
            mt,
            self.nbytes,
        )


class StrucMemberChangedEvent(StrucMemberEvent):
    __event__ = "struc_member_changed"

    def __init__(self, sname, soff, eoff, flag, extra):
        super(StrucMemberChangedEvent, self).__init__()
        self.sname = sname
        self.soff = soff
        self.eoff = eoff
        self.flag = flag
        self.extra = extra

    def __call__(self):
        sptr = self._get_sptr(self.sname)
        mt = self._get_member_type(self.flag, self.extra)
        idc.set_member_type(
            sptr, self.soff, self.flag, mt, self.eoff - self.soff
        )


class StrucMemberDeletedEvent(StrucMemberEvent):
    __event__ = "struc_member_deleted"

    def __init__(self, sname, offset):
        super(StrucMemberDeletedEvent, self).__init__()
        self.sname = sname
        self.offset = offset

    def __call__(self):
        sptr = self._get_sptr(self.sname)
        idc.del_struc_member(sptr, self.offset)


class StrucMemberRenamedEvent(StrucMemberEvent):
    __event__ = "struc_member_renamed"

    def __init__(self, sname, offset, newname):
        super(StrucMemberRenamedEvent, self).__init__()
        self.sname = sname
        self.offset = offset
        self.newname = newname

    def __call__(self):
        sptr = self._get_sptr(self.sname)
        idc.set_member_name(
            sptr, self.offset, self.newname
        )


class ExpandingStrucEvent(Event):
    __event__ = "expanding_struc"

    def __init__(self, sname, offset, delta):
        super(ExpandingStrucEvent, self).__init__()
        self.sname = sname
        self.offset = offset
        self.delta = delta

    def __call__(self):
        struc = idc.get_struc_id(self.sname)
        sptr = idc.get_struc(struc)
        idc.expand_struc(sptr, self.offset, self.delta)


class SegmAddedEvent(Event):
    __event__ = "segm_added_event"

    def __init__(
        self,
        name,
        class_,
        start_ea,
        end_ea,
        orgbase,
        align,
        comb,
        perm,
        bitness,
        flags,
    ):
        super(SegmAddedEvent, self).__init__()
        self.name = name
        self.class_ = class_
        self.start_ea = start_ea
        self.end_ea = end_ea
        self.orgbase = orgbase
        self.align = align
        self.comb = comb
        self.perm = perm
        self.bitness = bitness
        self.flags = flags

    def __call__(self):
        seg = ida_segment.segment_t()
        seg.start_ea = self.start_ea
        seg.end_ea = self.end_ea
        seg.orgbase = self.orgbase
        seg.align = self.align
        seg.comb = self.comb
        seg.perm = self.perm
        seg.bitness = self.bitness
        seg.flags = self.flags
        ida_segment.add_segm_ex(
            seg,
            self.name,
            self.class_,
            ida_segment.ADDSEG_QUIET | ida_segment.ADDSEG_NOSREG,
        )


class SegmDeletedEvent(Event):
    __event__ = "segm_deleted_event"

    def __init__(self, ea, flags):
        super(SegmDeletedEvent, self).__init__()
        self.ea = ea
        self.flags = flags

    def __call__(self):
        if not hasattr(self, 'flags'):
            # segm_deleted events created prior to IDA 7.7 lack flags
            self.flags = 0
        ida_segment.del_segm(
            self.ea, self.flags | ida_segment.SEGMOD_SILENT
        )


class SegmStartChangedEvent(Event):
    __event__ = "segm_start_changed_event"

    def __init__(self, newstart, ea):
        super(SegmStartChangedEvent, self).__init__()
        self.newstart = newstart
        self.ea = ea

    def __call__(self):
        ida_segment.set_segm_start(self.ea, self.newstart, 0)


class SegmEndChangedEvent(Event):
    __event__ = "segm_end_changed_event"

    def __init__(self, newend, ea):
        super(SegmEndChangedEvent, self).__init__()
        self.newend = newend
        self.ea = ea

    def __call__(self):
        ida_segment.set_segm_end(self.ea, self.newend, 0)


class SegmNameChangedEvent(Event):
    __event__ = "segm_name_changed_event"

    def __init__(self, ea, name):
        super(SegmNameChangedEvent, self).__init__()
        self.ea = ea
        self.name = name

    def __call__(self):
        seg = ida_segment.getseg(self.ea)
        ida_segment.set_segm_name(seg, self.name)


class SegmClassChangedEvent(Event):
    __event__ = "segm_class_changed_event"

    def __init__(self, ea, sclass):
        super(SegmClassChangedEvent, self).__init__()
        self.ea = ea
        self.sclass = sclass

    def __call__(self):
        seg = ida_segment.getseg(self.ea)
        ida_segment.set_segm_class(seg, self.sclass)


class SegmAttrsUpdatedEvent(Event):
    __event__ = "segm_attrs_updated_event"

    def __init__(self, ea, perm, bitness):
        super(SegmAttrsUpdatedEvent, self).__init__()
        self.ea = ea
        self.perm = perm
        self.bitness = bitness

    def __call__(self):
        s = ida_segment.getseg(self.ea)
        s.perm = self.perm
        s.bitness = self.bitness
        s.update()


class SegmMoved(Event):
    __event__ = "segm_moved_event"

    def __init__(self, from_ea, to_ea, changed_netmap):
        super(SegmMoved, self).__init__()
        self.from_ea = from_ea
        self.to_ea = to_ea
        self.changed_netmap = changed_netmap

    def __call__(self):
        flags = ida_segment.MSF_NETNODES if not self.changed_netmap else 0
        s = ida_segment.getseg(self.from_ea)
        ida_segment.move_segm(s, self.to_ea, flags)


class UndefinedEvent(Event):
    __event__ = "undefined"

    def __init__(self, ea):
        super(UndefinedEvent, self).__init__()
        self.ea = ea

    def __call__(self):
        ida_bytes.del_items(self.ea)


class BytePatchedEvent(Event):
    __event__ = "byte_patched"

    def __init__(self, ea, value):
        super(BytePatchedEvent, self).__init__()
        self.ea = ea
        self.value = value

    def __call__(self):
        ida_bytes.patch_byte(self.ea, self.value)


class BookmarkChangedEvent(Event):
    __event__ = "bookmark_changed"

    def __init__(self, ea, pos, cmt):
        super(BookmarkChangedEvent, self).__init__()
        self.ea = ea
        self.pos = pos
        self.cmt = cmt

    def __call__(self):
        idc.put_bookmark(self.ea, 0, 0, 0, self.pos, self.cmt)


class SgrChanged(Event):
    __event__ = "sgr_changed"

    @staticmethod
    def get_sreg_ranges(rg):
        sreg_ranges = []
        sreg_ranges_qty = ida_segregs.get_sreg_ranges_qty(rg)
        for n in range(sreg_ranges_qty):
            sreg_range = ida_segregs.sreg_range_t()
            ida_segregs.getn_sreg_range(sreg_range, rg, n)
            sreg_ranges.append(
                (
                    sreg_range.start_ea,
                    sreg_range.end_ea,
                    sreg_range.val,
                    sreg_range.tag,
                )
            )
        return sreg_ranges

    def __init__(self, rg, sreg_ranges):
        super(SgrChanged, self).__init__()
        self.rg = rg
        self.sreg_ranges = sreg_ranges

    def __call__(self):
        new_ranges = {r[0]: r for r in self.sreg_ranges}
        old_ranges = {r[0]: r for r in SgrChanged.get_sreg_ranges(self.rg)}

        start_eas = sorted(
            set(list(new_ranges.keys()) + list(old_ranges.keys()))
        )
        for start_ea in start_eas:
            new_range = new_ranges.get(start_ea, None)
            old_range = old_ranges.get(start_ea, None)

            if new_range and not old_range:
                _, __, val, tag = new_range
                ida_segregs.split_sreg_range(start_ea, self.rg, val, tag, True)

            if not new_range and old_range:
                ida_segregs.del_sreg_range(start_ea, self.rg)

            if new_range and old_range:
                _, __, new_val, new_tag = new_range
                _, __, old_val, old_tag = old_range
                if new_val != old_val or new_tag != old_tag:
                    ida_segregs.split_sreg_range(
                        start_ea, self.rg, new_val, new_tag, True
                    )

        ida_kernwin.request_refresh(ida_kernwin.IWID_SEGREGS)

class MakeUnknown(Event):
    __event__ = "make_unknown"

    def __init__(self, ea):
        super(MakeUnknown, self).__init__()
        self.ea = ea

    def __call__(self):
        ida_bytes.del_items(self.ea, 1)


# class GenRegvarDefEvent(Event):
#    __event__ = "gen_regvar_def"
#
#    def __init__(self, ea, canonical_name, new_name, cmt):
#        super(GenRegvarDefEvent, self).__init__()
#        self.ea = ea
#        self.canonical_name = canonical_name
#        self.new_name = new_name
#        self.cmt = cmt
#
#    def __call__(self):
#        func = ida_funcs.get_func(self.ea)
#        ida_frame.add_regvar(
#            func,
#            func.start_ea,
#            func.end_ea,
#            self.canonical_name,
#            self.new_name,
#            self.cmt,
#        )


# Base class inherited by all HexRays-specific events
class HexRaysEvent(Event):
    @staticmethod
    def refresh_pseudocode_view(ea):
        """Refreshes the pseudocode view in IDA."""
        names = ["Pseudocode-%c" % chr(ord("A") + i) for i in range(5)]
        for name in names:
            widget = ida_kernwin.find_widget(name)
            if widget:
                vu = ida_hexrays.get_widget_vdui(widget)

                # Check if the address is in the same function
                func_ea = vu.cfunc.entry_ea
                func = ida_funcs.get_func(func_ea)
                # print("refresh_pseudocode_view: func_ea = 0x%X, ea = 0x%X, " % (func_ea, ea), ida_funcs.func_contains(func, ea))
                if ida_funcs.func_contains(func, ea):
                    vu.refresh_view(False)


class UserLabelsEvent(HexRaysEvent):
    __event__ = "user_labels"

    def __init__(self, ea, labels):
        super(UserLabelsEvent, self).__init__()
        self.ea = ea
        self.labels = labels

    def __call__(self):
        labels = ida_hexrays.user_labels_new()
        for org_label, name in self.labels:
            ida_hexrays.user_labels_insert(labels, org_label, name)
        ida_hexrays.save_user_labels(self.ea, labels)
        HexRaysEvent.refresh_pseudocode_view(self.ea)


class UserCmtsEvent(HexRaysEvent):
    __event__ = "user_cmts"

    def __init__(self, ea, cmts):
        super(UserCmtsEvent, self).__init__()
        self.ea = ea
        self.cmts = cmts

    def __call__(self):
        cmts = ida_hexrays.user_cmts_new()
        for (tl_ea, tl_itp), cmt in self.cmts:
            tl = ida_hexrays.treeloc_t()
            tl.ea = tl_ea
            tl.itp = tl_itp
            cmts.insert(tl, ida_hexrays.citem_cmt_t(cmt))
        ida_hexrays.save_user_cmts(self.ea, cmts)
        HexRaysEvent.refresh_pseudocode_view(self.ea)


class UserIflagsEvent(HexRaysEvent):
    __event__ = "user_iflags"

    def __init__(self, ea, iflags):
        super(UserIflagsEvent, self).__init__()
        self.ea = ea
        self.iflags = iflags

    def __call__(self):
        # FIXME: Hey-Rays bindings are currently broken
        # iflags = ida_hexrays.user_iflags_new()
        # for (cl_ea, cl_op), f in self.iflags:
        #     cl = ida_hexrays.citem_locator_t(cl_ea, cl_op)
        #     iflags.insert(cl, f)
        # ida_hexrays.save_user_iflags(self.ea, iflags)

        ida_hexrays.save_user_iflags(self.ea, ida_hexrays.user_iflags_new())
        HexRaysEvent.refresh_pseudocode_view(self.ea)

        cfunc = ida_hexrays.decompile(self.ea)
        for (cl_ea, cl_op), f in self.iflags:
            cl = ida_hexrays.citem_locator_t(cl_ea, cl_op)
            cfunc.set_user_iflags(cl, f)
        cfunc.save_user_iflags()
        HexRaysEvent.refresh_pseudocode_view(self.ea)


class UserLvarSettingsEvent(HexRaysEvent):
    __event__ = "user_lvar_settings"

    def __init__(self, ea, lvar_settings):
        super(UserLvarSettingsEvent, self).__init__()
        self.ea = ea
        self.lvar_settings = lvar_settings

    def __call__(self):
        if len(self.lvar_settings) == 0:
            return

        lvinf = ida_hexrays.lvar_uservec_t()
        lvinf.lvvec = ida_hexrays.lvar_saved_infos_t()
        if "lvvec" in self.lvar_settings:
            for lv in self.lvar_settings["lvvec"]:
                lvinf.lvvec.push_back(
                    UserLvarSettingsEvent._get_lvar_saved_info(lv)
                )
        lvinf.sizes = ida_pro.intvec_t()
        if "sizes" in self.lvar_settings:
            for i in self.lvar_settings["sizes"]:
                lvinf.sizes.push_back(i)
        lvinf.lmaps = ida_hexrays.lvar_mapping_t()
        if "lmaps" in self.lvar_settings:
            for key, val in self.lvar_settings["lmaps"]:
                key = UserLvarSettingsEvent._get_lvar_locator(key)
                val = UserLvarSettingsEvent._get_lvar_locator(val)
                ida_hexrays.lvar_mapping_insert(lvinf.lmaps, key, val)
        if "stkoff_delta" in self.lvar_settings:
            lvinf.stkoff_delta = self.lvar_settings["stkoff_delta"]
        if "ulv_flags" in self.lvar_settings:
            lvinf.ulv_flags = self.lvar_settings["ulv_flags"]
        ida_hexrays.save_user_lvar_settings(self.ea, lvinf)
        HexRaysEvent.refresh_pseudocode_view(self.ea)

    @staticmethod
    def _get_lvar_saved_info(dct):
        lv = ida_hexrays.lvar_saved_info_t()
        lv.ll = UserLvarSettingsEvent._get_lvar_locator(dct["ll"])
        lv.name = dct["name"]
        lv.type = UserLvarSettingsEvent._get_tinfo(dct["type"])
        lv.cmt = dct["cmt"]
        lv.flags = dct["flags"]
        return lv

    @staticmethod
    def _get_tinfo(dct):
        type, fields, fldcmts, parsed_list = dct
        # type = Event.encode_bytes(type)
        fields = Event.encode_bytes(fields)
        fldcmts = Event.encode_bytes(fldcmts)
        type = None if parsed_list is None else GetTypeString(pickle.loads(Event.encode_bytes(parsed_list)))
        type_ = ida_typeinf.tinfo_t()
        if type is not None:
            type_.deserialize(None, type, fields, fldcmts)
        return type_

    @staticmethod
    def _get_lvar_locator(dct):
        ll = ida_hexrays.lvar_locator_t()
        ll.location = UserLvarSettingsEvent._get_vdloc(dct["location"])
        ll.defea = dct["defea"]
        return ll

    @staticmethod
    def _get_vdloc(dct):
        location = ida_hexrays.vdloc_t()
        if dct["atype"] == ida_typeinf.ALOC_NONE:
            pass
        elif dct["atype"] == ida_typeinf.ALOC_STACK:
            location.set_stkoff(dct["stkoff"])
        elif dct["atype"] == ida_typeinf.ALOC_DIST:
            pass  # FIXME: Not supported
        elif dct["atype"] == ida_typeinf.ALOC_REG1:
            location.set_reg1(dct["reg1"])
        elif dct["atype"] == ida_typeinf.ALOC_REG2:
            location.set_reg2(dct["reg1"], dct["reg2"])
        elif dct["atype"] == ida_typeinf.ALOC_RREL:
            pass  # FIXME: Not supported
        elif dct["atype"] == ida_typeinf.ALOC_STATIC:
            location.set_ea(dct["ea"])
        elif dct["atype"] == ida_typeinf.ALOC_CUSTOM:
            pass  # FIXME: Not supported
        return location


class UserNumformsEvent(HexRaysEvent):
    __event__ = "user_numforms"

    def __init__(self, ea, numforms):
        super(UserNumformsEvent, self).__init__()
        self.ea = ea
        self.numforms = numforms

    def __call__(self):
        numforms = ida_hexrays.user_numforms_new()
        for _ol, _nf in self.numforms:
            ol = ida_hexrays.operand_locator_t(_ol["ea"], _ol["opnum"])
            nf = ida_hexrays.number_format_t()
            nf.flags = _nf["flags"]
            nf.opnum = _nf["opnum"]
            nf.props = _nf["props"]
            nf.serial = _nf["serial"]
            nf.org_nbytes = _nf["org_nbytes"]
            nf.type_name = _nf["type_name"]
            ida_hexrays.user_numforms_insert(numforms, ol, nf)
        ida_hexrays.save_user_numforms(self.ea, numforms)
        HexRaysEvent.refresh_pseudocode_view(self.ea)

```

`idarling/core/hooks.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
# import ctypes
import pickle

import ida_auto
import ida_bytes
import ida_funcs
import ida_hexrays
import ida_idaapi
import ida_idp
import ida_kernwin
import ida_nalt
import idc
import ida_netnode
import ida_pro
import ida_segment
import ida_typeinf

fDebug = False
if fDebug:
    import pydevd_pycharm
import sys
sys.setrecursionlimit(10000)

from . import events as evt  # noqa: I100,I202
from .events import Event  # noqa: I201
from ..shared.local_types import ParseTypeString, ImportLocalType


class Hooks(object):
    """
    This is a common class for all client hooks. It adds an utility method to
    send an user event to all other clients through the server.
    """

    def __init__(self, plugin):
        self._plugin = plugin

    def _send_packet(self, event):
        """Sends a packet to the server."""
        # Check if it comes from the auto-analyzer
        if ida_auto.get_auto_state() == ida_auto.AU_NONE:
            self._plugin.network.send_packet(event)
        else:
            #self._plugin.logger.debug("Ignoring a packet")
            pass

# See idasdk74.zip: idasdk74/include/idp.hpp for methods' documentation
# See C:\Program Files\IDA Pro 7.4\python\3\ida_idp.py for methods' prototypes
# The order for methods below is the same as the idp.hpp file to ease making changes
class IDBHooks(Hooks, ida_idp.IDB_Hooks):
    def __init__(self, plugin):
        ida_idp.IDB_Hooks.__init__(self)
        Hooks.__init__(self, plugin)
        self.last_local_type = None

    def auto_empty_finally(self):
        self._plugin.logger.debug("auto_empty_finally() not implemented yet")
        return 0

    def auto_empty(self):
        self._plugin.logger.debug("auto_empty() not implemented yet")
        return 0

    def local_types_changed(self):
        changed_types = []
        # self._plugin.logger.trace(self._plugin.core.local_type_map)
        for i in range(1, ida_typeinf.get_ordinal_count(ida_typeinf.get_idati())):
            t = ImportLocalType(i)
            if t and t.name and idc.get_struc_id(t.name) == ida_idaapi.BADADDR and idc.get_enum(t.name) == ida_idaapi.BADADDR:
                if i in self._plugin.core.local_type_map:
                    t_old = self._plugin.core.local_type_map[i]
                    if t_old and not t.isEqual(t_old):
                        changed_types.append((t_old.to_tuple(),t.to_tuple()))
                    elif t_old is None and i in self._plugin.core.delete_candidates:
                        if not self._plugin.core.delete_candidates[i].isEqual(t):
                            changed_types.append((self._plugin.core.delete_candidates[i].to_tuple(), t.to_tuple()))
                        del self._plugin.core.delete_candidates[i]

                else:
                    changed_types.append((None,t.to_tuple()))
            if t is None:
                assert i in self._plugin.core.local_type_map
                if i in self._plugin.core.local_type_map:
                    t_old = self._plugin.core.local_type_map[i]
                    if t_old != t:
                        self._plugin.core.delete_candidates[i] = t_old
                    elif i in self._plugin.core.delete_candidates:
                        #changed_types.append((self._plugin.core.delete_candidates[i],None))
                        del self._plugin.core.delete_candidates[i]

                    # t_old = self._plugin.core.local_type_map[i]
                    # changed_types.append((t_old,None))
        # self._plugin.logger.trace(changed_types)
        if fDebug:
            pydevd_pycharm.settrace('localhost', port=2233, stdoutToServer=True, stderrToServer=True, suspend=False)
        self._plugin.logger.trace("Changed_types: %s"%list(map(lambda x: (x[0][0] if x[0] else None, x[1][0] if x[1] else None),changed_types)))
        if len(changed_types) > 0:
            self._send_packet(evt.LocalTypesChangedEvent(changed_types))
        self._plugin.core.update_local_types_map()
        return 0
        # XXX - old code below to delete?
        # from .core import Core

        # dll = Core.get_ida_dll()

        # get_idati = dll.get_idati
        # get_idati.argtypes = []
        # get_idati.restype = ctypes.c_void_p

        # get_numbered_type = dll.get_numbered_type
        # get_numbered_type.argtypes = [
        #     ctypes.c_void_p,
        #     ctypes.c_uint32,
        #     ctypes.POINTER(ctypes.c_char_p),
        #     ctypes.POINTER(ctypes.c_char_p),
        #     ctypes.POINTER(ctypes.c_char_p),
        #     ctypes.POINTER(ctypes.c_char_p),
        #     ctypes.POINTER(ctypes.c_int),
        # ]
        # get_numbered_type.restype = ctypes.c_bool

        # local_types = []
        # py_ti = ida_typeinf.get_idati()
        # for py_ord in range(1, ida_typeinf.get_ordinal_qty(py_ti)):
        #     name = ida_typeinf.get_numbered_type_name(py_ti, py_ord)

        #     ti = get_idati()
        #     ordinal = ctypes.c_uint32(py_ord)
        #     type = ctypes.c_char_p()
        #     fields = ctypes.c_char_p()
        #     cmt = ctypes.c_char_p()
        #     fieldcmts = ctypes.c_char_p()
        #     sclass = ctypes.c_int()
        #     get_numbered_type(
        #         ti,
        #         ordinal,
        #         ctypes.pointer(type),
        #         ctypes.pointer(fields),
        #         ctypes.pointer(cmt),
        #         ctypes.pointer(fieldcmts),
        #         ctypes.pointer(sclass),
        #     )
        #     local_types.append(
        #         (
        #             py_ord,
        #             name,
        #             type.value,
        #             fields.value,
        #             cmt.value,
        #             fieldcmts.value,
        #             sclass.value,
        #         )
        #     )
        # self._send_packet(evt.LocalTypesChangedEvent(local_types))
        # return 0

    def ti_changed(self, ea, type, fname):
        self._plugin.logger.debug("ti_changed(ea = 0x%X, type = %s, fname = %s)" % (ea, type, fname))
        name = ""
        if idc.is_member_id(ea):
            name = idc.get_struc_name(ea)
        type = ida_typeinf.idc_get_type_raw(ea)
        self._send_packet(evt.TiChangedEvent(ea, (ParseTypeString(type[0]) if type else [], type[1] if type else None), name))
        return 0

    def op_ti_changed(self, ea, n, type, fnames):
        self._plugin.logger.debug("op_ti_changed() not implemented yet")
        return 0

    def op_type_changed(self, ea, n):
        self._plugin.logger.debug("op_type_changed(ea = %x, n = %d)" % (ea,n))
        def gather_enum_info(ea, n):
            id = ida_bytes.get_enum_id(ea, n)[0]
            serial = idc.get_enum_idx(id)
            return id, serial

        extra = {}
        mask = ida_bytes.MS_0TYPE if not n else ida_bytes.MS_1TYPE
        flags = ida_bytes.get_full_flags(ea)
        self._plugin.logger.debug("op_type_changed: flags = 0x%X)" % flags)
        def is_flag(type):
            return flags & mask == mask & type

        if is_flag(ida_bytes.hex_flag()):
            op = "hex"
        elif is_flag(ida_bytes.dec_flag()):
            op = "dec"
        elif is_flag(ida_bytes.char_flag()):
            op = "chr"
        elif is_flag(ida_bytes.bin_flag()):
            op = "bin"
        elif is_flag(ida_bytes.oct_flag()):
            op = "oct"
        elif is_flag(ida_bytes.off_flag()):
            op = "offset"
        elif is_flag(ida_bytes.enum_flag()):
            op = "enum"
            id, serial = gather_enum_info(ea, n)
            ename = idc.get_enum_name(id)
            extra["ename"] = Event.decode(ename)
            extra["serial"] = serial
        elif flags & ida_bytes.stroff_flag():
            op = "struct"
            path = ida_pro.tid_array(1)
            delta = ida_pro.sval_pointer()
            path_len = ida_bytes.get_stroff_path(
                path.cast(), delta.cast(), ea, n
            )
            spath = []
            for i in range(path_len):
                sname = idc.get_struc_name(path[i])
                spath.append(Event.decode(sname))
            extra["delta"] = delta.value()
            extra["spath"] = spath
        elif is_flag(ida_bytes.stkvar_flag()):
            op = "stkvar"
        # FIXME: No hooks are called when inverting sign
        # elif ida_bytes.is_invsign(ea, flags, n):
        #     op = 'invert_sign'
        else:
            return 0  # FIXME: Find a better way to do this
        self._send_packet(evt.OpTypeChangedEvent(ea, n, op, extra))
        return 0

    def enum_created(self, enum):
        name = idc.get_enum_name(enum)
        self._send_packet(evt.EnumCreatedEvent(enum, name))
        return 0

    # XXX - use enum_deleted(self, id) instead?
    def deleting_enum(self, id):
        self._send_packet(evt.EnumDeletedEvent(idc.get_enum_name(id)))
        return 0

    # XXX - use enum_renamed(self, id) instead?
    def renaming_enum(self, id, is_enum, newname):
        if is_enum:
            oldname = idc.get_enum_name(id)
        else:
            oldname = idc.get_enum_member_name(id)
        self._send_packet(evt.EnumRenamedEvent(oldname, newname, is_enum))
        return 0

    def enum_bf_changed(self, id):
        bf_flag = 1 if idc.is_bf(id) else 0
        ename = idc.get_enum_name(id)
        self._send_packet(evt.EnumBfChangedEvent(ename, bf_flag))
        return 0

    def enum_cmt_changed(self, tid, repeatable_cmt):
        cmt = idc.get_enum_cmt(tid, repeatable_cmt)
        emname = idc.get_enum_name(tid)
        self._send_packet(evt.EnumCmtChangedEvent(emname, cmt, repeatable_cmt))
        return 0

    def enum_member_created(self, id, cid):
        ename = idc.get_enum_name(id)
        name = idc.get_enum_member_name(cid)
        value = idc.get_enum_member_value(cid)
        bmask = idc.get_enum_member_bmask(cid)
        self._send_packet(
            evt.EnumMemberCreatedEvent(ename, name, value, bmask)
        )
        return 0

    # XXX - use enum_member_deleted(self, id, cid) instead?
    def deleting_enum_member(self, id, cid):
        ename = idc.get_enum_name(id)
        value = idc.get_enum_member_value(cid)
        serial = idc.get_enum_member_serial(cid)
        bmask = idc.get_enum_member_bmask(cid)
        self._send_packet(
            evt.EnumMemberDeletedEvent(ename, value, serial, bmask)
        )
        return 0

    def struc_created(self, tid):
        name = idc.get_struc_name(tid)
        is_union = idc.is_union(tid)
        self._send_packet(evt.StrucCreatedEvent(tid, name, is_union))
        return 0

    # XXX - use struc_deleted(self, struc_id) instead?
    def deleting_struc(self, sptr):
        sname = idc.get_struc_name(sptr.id)
        self._send_packet(evt.StrucDeletedEvent(sname))
        return 0

    def struc_align_changed(self, sptr):
        self._plugin.logger.debug("struc_align_changed() not implemented yet")
        return 0

    # XXX - use struc_renamed(self, sptr) instead?
    def renaming_struc(self, id, oldname, newname):
        self._send_packet(evt.StrucRenamedEvent(oldname, newname))
        return 0

    # XXX - use struc_expanded(self, sptr) instead 
    def expanding_struc(self, sptr, offset, delta):
        sname = idc.get_struc_name(sptr.id)
        self._send_packet(evt.ExpandingStrucEvent(sname, offset, delta))
        return 0

    def struc_member_created(self, sptr, mptr):
        extra = {}
        sname = idc.get_struc_name(sptr.id)
        fieldname = idc.get_member_name(mptr.id)
        offset = 0 if mptr.unimem() else mptr.soff
        flag = mptr.flag
        nbytes = mptr.eoff if mptr.unimem() else mptr.eoff - mptr.soff
        mt = ida_nalt.opinfo_t()
        is_not_data = idc.retrieve_member_info(mt, mptr)
        if is_not_data:
            if flag & ida_bytes.off_flag():
                extra["target"] = mt.ri.target
                extra["base"] = mt.ri.base
                extra["tdelta"] = mt.ri.tdelta
                extra["flags"] = mt.ri.flags
                self._send_packet(
                    evt.StrucMemberCreatedEvent(
                        sname, fieldname, offset, flag, nbytes, extra
                    )
                )
            elif flag & ida_bytes.enum_flag():
                extra["serial"] = mt.ec.serial
                extra["tid"] = mt.ec.tid
                self._send_packet(
                    evt.StrucMemberCreatedEvent(
                        sname, fieldname, offset, flag, nbytes, extra
                    )
                )
            elif flag & ida_bytes.stru_flag():
                extra["struc_name"] = idc.get_struc_name(mt.tid)
                if flag & ida_bytes.strlit_flag():
                    extra["strtype"] = mt.strtype
                self._send_packet(
                    evt.StrucMemberCreatedEvent(
                        sname, fieldname, offset, flag, nbytes, extra
                    )
                )
        else:
            self._send_packet(
                evt.StrucMemberCreatedEvent(
                    sname, fieldname, offset, flag, nbytes, extra
                )
            )
        return 0

    def struc_member_deleted(self, sptr, off1, off2):
        sname = idc.get_struc_name(sptr.id)
        self._send_packet(evt.StrucMemberDeletedEvent(sname, off2))
        return 0

    # XXX - use struc_member_renamed(self, sptr, mptr) instead?
    def renaming_struc_member(self, sptr, mptr, newname):
        sname = idc.get_struc_name(sptr.id)
        offset = mptr.soff
        self._send_packet(evt.StrucMemberRenamedEvent(sname, offset, newname))
        return 0

    def struc_member_changed(self, sptr, mptr):
        extra = {}

        sname = idc.get_struc_name(sptr.id)
        flag = mptr.flag
        mt = ida_nalt.opinfo_t()
        is_not_data = idc.retrieve_member_info(mt, mptr)
        if is_not_data:
            if flag & ida_bytes.off_flag():
                extra["target"] = mt.ri.target
                extra["base"] = mt.ri.base
                extra["tdelta"] = mt.ri.tdelta
                extra["flags"] = mt.ri.flags
                self._send_packet(
                    evt.StrucMemberChangedEvent(
                        sname, mptr.soff, mptr.eoff, flag, extra
                    )
                )
            elif flag & ida_bytes.enum_flag():
                extra["serial"] = mt.ec.serial
                extra["tid"] = mt.ec.tid
                self._send_packet(
                    evt.StrucMemberChangedEvent(
                        sname, mptr.soff, mptr.eoff, flag, extra
                    )
                )
            elif flag & ida_bytes.stru_flag():
                extra["struc_name"] = idc.get_struc_name(mt.tid)
                if flag & ida_bytes.strlit_flag():
                    extra["strtype"] = mt.strtype
                self._send_packet(
                    evt.StrucMemberChangedEvent(
                        sname, mptr.soff, mptr.eoff, flag, extra
                    )
                )
        else:
            self._send_packet(
                evt.StrucMemberChangedEvent(
                    sname, mptr.soff, mptr.eoff, flag, extra
                )
            )
        return 0

    def struc_cmt_changed(self, id, repeatable_cmt):
        fullname = idc.get_struc_name(id)
        if "." in fullname:
            sname, smname = fullname.split(".", 1)
        else:
            sname = fullname
            smname = ""
        cmt = idc.get_struc_cmt(id, repeatable_cmt)
        self._send_packet(
            evt.StrucCmtChangedEvent(sname, smname, cmt, repeatable_cmt)
        )
        return 0

    def segm_added(self, s):
        self._send_packet(
            evt.SegmAddedEvent(
                ida_segment.get_segm_name(s),
                ida_segment.get_segm_class(s),
                s.start_ea,
                s.end_ea,
                s.orgbase,
                s.align,
                s.comb,
                s.perm,
                s.bitness,
                s.flags,
            )
        )
        return 0

    # The flags argument was added in IDA 7.7
    def segm_deleted(self, start_ea, end_ea, flags=0):
        self._send_packet(evt.SegmDeletedEvent(start_ea, flags))
        return 0

    def segm_start_changed(self, s, oldstart):
        self._send_packet(evt.SegmStartChangedEvent(s.start_ea, oldstart))
        return 0

    def segm_end_changed(self, s, oldend):
        self._send_packet(evt.SegmEndChangedEvent(s.end_ea, s.start_ea))
        return 0

    def segm_name_changed(self, s, name):
        self._send_packet(evt.SegmNameChangedEvent(s.start_ea, name))
        return 0

    def segm_class_changed(self, s, sclass):
        self._send_packet(evt.SegmClassChangedEvent(s.start_ea, sclass))
        return 0

    def segm_attrs_updated(self, s):
        self._send_packet(
            evt.SegmAttrsUpdatedEvent(s.start_ea, s.perm, s.bitness)
        )
        return 0

    def segm_moved(self, from_ea, to_ea, size, changed_netmap):
        self._send_packet(evt.SegmMoved(from_ea, to_ea, changed_netmap))
        return 0

    def allsegs_moved(self, info):
        self._plugin.logger.debug("allsegs_moved() not implemented yet")
        return 0

    def func_added(self, func):
        self._send_packet(evt.FuncAddedEvent(func.start_ea, func.end_ea))
        return 0

    def set_func_start(self, func, new_start):
        self._send_packet(evt.SetFuncStartEvent(func.start_ea, new_start))
        return 0

    def set_func_end(self, func, new_end):
        self._send_packet(evt.SetFuncEndEvent(func.start_ea, new_end))
        return 0

    def deleting_func(self, func):
        self._send_packet(evt.DeletingFuncEvent(func.start_ea))
        return 0

    def func_tail_appended(self, func, tail):
        self._send_packet(
            evt.FuncTailAppendedEvent(
                func.start_ea, tail.start_ea, tail.end_ea
            )
        )
        return 0

    def func_tail_deleted(self, func, tail_ea):
        self._send_packet(evt.FuncTailDeletedEvent(func.start_ea, tail_ea))
        return 0

    def tail_owner_changed(self, tail, owner_func, old_owner):
        self._send_packet(evt.TailOwnerChangedEvent(tail.start_ea, owner_func))
        return 0

    def func_noret_changed(self, pfn):
        self._plugin.logger.debug("func_noret_changed() not implemented yet")
        return 0

    def sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag):
        # FIXME: sgr_changed is not triggered when a segment register is
        # being deleted by the user, so we need to sent the complete list
        sreg_ranges = evt.SgrChanged.get_sreg_ranges(regnum)
        self._send_packet(evt.SgrChanged(regnum, sreg_ranges))
        return 0

    # def make_code(self, insn):
    #     self._send_packet(evt.MakeCodeEvent(insn.ea))
    #     return 0

    def make_data(self, ea, flags, tid, size):
        self._plugin.logger.debug("make_data(ea = %x, flags = %x, tid = %x, size = %x)" % (ea, flags, tid, size))
        # Note: MakeDataEvent.sname == '' is convention for BADNODE
        self._send_packet(evt.MakeDataEvent(ea, flags, size, idc.get_struc_name(tid) if tid != ida_netnode.BADNODE else ''))
        return 0

    def renamed(self, ea, new_name, local_name):
        self._plugin.logger.debug("renamed(ea = %x, new_name = %s, local_name = %d)" % (ea, new_name, local_name))
        # `idc.get_struc` was removed in newer IDA Python APIs; avoid calling it.
        # We only need to detect member-id or enum rename events here.
        if idc.is_member_id(ea) or idc.get_enum_name(ea):
            # Drop hook to avoid duplicate since already handled by the following hooks:
            # - renaming_struc_member() -> sends 'StrucMemberRenamedEvent'
            # - renaming_struc() -> sends 'StrucRenamedEvent' 
            # - renaming_enum() -> sends 'EnumRenamedEvent' 
            return 0 
        self._send_packet(evt.RenamedEvent(ea, new_name, local_name))
        return 0

    def byte_patched(self, ea, old_value):
        self._send_packet(
            evt.BytePatchedEvent(ea, ida_bytes.get_wide_byte(ea))
        )
        return 0

    def cmt_changed(self, ea, repeatable_cmt):
        cmt = ida_bytes.get_cmt(ea, repeatable_cmt)
        cmt = "" if not cmt else cmt
        self._send_packet(evt.CmtChangedEvent(ea, cmt, repeatable_cmt))
        return 0

    def range_cmt_changed(self, kind, a, cmt, repeatable):
        self._send_packet(evt.RangeCmtChangedEvent(kind, a, cmt, repeatable))
        return 0

    def extra_cmt_changed(self, ea, line_idx, cmt):
        self._send_packet(evt.ExtraCmtChangedEvent(ea, line_idx, cmt))
        return 0

    def item_color_changed(self, ea, color):
        # See #31 on fidgetingbits/IDArling
        #self._plugin.logger.debug("item_color_changed() not implemented yet")
        return 0

    def callee_addr_changed(self, ea, callee):
        self._plugin.logger.debug("callee_addr_changed() not implemented yet")
        return 0

    # def destroyed_items(self, ea1, ea2, will_disable_range):
    #     self._plugin.logger.debug("destroyed_items(ea1 = %x, ea2 = %x, will_disable_range = %d) not implemented yet" % (ea1, ea2, will_disable_range))
    #     return 0

    # def changing_op_type(self, ea, n, opinfo):
    #     self._plugin.logger.debug("changing_op_type(ea = %x, n = %d, opinfo = %s) not implemented yet" % (ea, n, opinfo))
    #     return 0

    def bookmark_changed(self, index, pos, desc):
        rinfo = pos.renderer_info()
        plce = pos.place()
        ea = plce.touval(pos)
        self._send_packet(evt.BookmarkChangedEvent(ea, index, desc))
        return 0

    def sgr_deleted(self, start_ea, end_ea, regnum):
        self._plugin.logger.debug("sgr_deleted() not implemented yet")
        return 0


class IDPHooks(Hooks, ida_idp.IDP_Hooks):
    def __init__(self, plugin):
        ida_idp.IDP_Hooks.__init__(self)
        Hooks.__init__(self, plugin)

    # def ev_undefine(self, ea):
    #     self._send_packet(evt.UndefinedEvent(ea))
    #     return ida_idp.IDP_Hooks.ev_undefine(self, ea)

    def ev_adjust_argloc(self, *args):
        return ida_idp.IDP_Hooks.ev_adjust_argloc(self, *args)

    # def ev_emu_insn(self,insn):
    #     self._plugin.logger.debug("ev_emu_insn(insn.ea = %X) not implemented yet"%insn.ea)
    #     return ida_idp.IDP_Hooks.ev_emu_insn(self, insn)
    #
    # def ev_auto_queue_empty(self,type):
    #     disp = ida_auto.auto_display_t()
    #     ida_auto.get_auto_display(disp)
    #     self._plugin.logger.debug("ev_auto_queue_empty(type = %d. disp.ea = %X, disp.type = %d, disp.state = %d"%(type,disp.ea,disp.type,disp.state))
    #     return ida_idp.IDP_Hooks.ev_auto_queue_empty(self, type)
    #
    # def ev_gen_regvar_def(self, outctx, v):
    #    self._send_packet(
    #        evt.GenRegvarDefEvent(outctx.bin_ea, v.canon, v.user, v.cmt)
    #    )
    #    return ida_idp.IDP_Hooks.ev_gen_regvar_def(self, outctx, v)


class HexRaysHooks(Hooks):
    def __init__(self, plugin):
        super(HexRaysHooks, self).__init__(plugin)
        self._available = None
        self._installed = False
        # We cache all HexRays data the first time we encounter a new function
        # and only send events to IDArling server if we didn't encounter the
        # specific data for a given function. This is just an optimization to 
        # reduce the amount of messages sent and replicated to other users
        self._cached_funcs = {}

    def hook(self):
        if self._available is None:
            if not ida_hexrays.init_hexrays_plugin():
                self._plugin.logger.info("Hex-Rays SDK is not available")
                self._available = False
            else:
                ida_hexrays.install_hexrays_callback(self._hxe_callback)
                self._available = True

        if self._available:
            self._installed = True

    def unhook(self):
        if self._available:
            self._installed = False

    def _hxe_callback(self, event, *_):
        if not self._installed:
            return 0

        if event == ida_hexrays.hxe_func_printed:
            ea = ida_kernwin.get_screen_ea()
            func = ida_funcs.get_func(ea)
            if func is None:
                return 0
            
            if func.start_ea not in self._cached_funcs.keys():
                self._cached_funcs[func.start_ea] = {}
                self._cached_funcs[func.start_ea]["labels"] = []
                self._cached_funcs[func.start_ea]["cmts"] = []
                self._cached_funcs[func.start_ea]["iflags"] = []
                self._cached_funcs[func.start_ea]["lvar_settings"] = []
                self._cached_funcs[func.start_ea]["numforms"] = []
            self._send_user_labels(func.start_ea)
            self._send_user_cmts(func.start_ea)
            self._send_user_iflags(func.start_ea)
            self._send_user_lvar_settings(func.start_ea)
            self._send_user_numforms(func.start_ea)
        return 0

    @staticmethod
    def _get_user_labels(ea):
        user_labels = ida_hexrays.restore_user_labels(ea)
        if user_labels is None:
            user_labels = ida_hexrays.user_labels_new()
        labels = []
        it = ida_hexrays.user_labels_begin(user_labels)
        while it != ida_hexrays.user_labels_end(user_labels):
            org_label = ida_hexrays.user_labels_first(it)
            name = ida_hexrays.user_labels_second(it)
            labels.append((org_label, Event.decode(name)))
            it = ida_hexrays.user_labels_next(it)
        ida_hexrays.user_labels_free(user_labels)
        return labels

    def _send_user_labels(self, ea):
        labels = HexRaysHooks._get_user_labels(ea)
        if labels != self._cached_funcs[ea]["labels"]:
            self._send_packet(evt.UserLabelsEvent(ea, labels))
            self._cached_funcs[ea]["labels"] = labels

    @staticmethod
    def _get_user_cmts(ea):
        user_cmts = ida_hexrays.restore_user_cmts(ea)
        if user_cmts is None:
            user_cmts = ida_hexrays.user_cmts_new()
        cmts = []
        it = ida_hexrays.user_cmts_begin(user_cmts)
        while it != ida_hexrays.user_cmts_end(user_cmts):
            tl = ida_hexrays.user_cmts_first(it)
            cmt = ida_hexrays.user_cmts_second(it)
            cmts.append(((tl.ea, tl.itp), Event.decode(str(cmt))))
            it = ida_hexrays.user_cmts_next(it)
        ida_hexrays.user_cmts_free(user_cmts)
        return cmts

    def _send_user_cmts(self, ea):
        cmts = HexRaysHooks._get_user_cmts(ea)
        if cmts != self._cached_funcs[ea]["cmts"]:
            self._send_packet(evt.UserCmtsEvent(ea, cmts))
            self._cached_funcs[ea]["cmts"] = cmts

    @staticmethod
    def _get_user_iflags(ea):
        user_iflags = ida_hexrays.restore_user_iflags(ea)
        if user_iflags is None:
            user_iflags = ida_hexrays.user_iflags_new()
        iflags = []
        it = ida_hexrays.user_iflags_begin(user_iflags)
        while it != ida_hexrays.user_iflags_end(user_iflags):
            cl = ida_hexrays.user_iflags_first(it)
            f = ida_hexrays.user_iflags_second(it)

            # FIXME: Temporary while Hex-Rays update their API
            def read_type_sign(obj):
                import ctypes
                import struct

                buf = ctypes.string_at(id(obj), 4)
                return struct.unpack("I", buf)[0]

            f = read_type_sign(f)
            iflags.append(((cl.ea, cl.op), f))
            it = ida_hexrays.user_iflags_next(it)
        ida_hexrays.user_iflags_free(user_iflags)
        return iflags

    def _send_user_iflags(self, ea):
        iflags = HexRaysHooks._get_user_iflags(ea)
        if iflags != self._cached_funcs[ea]["iflags"]:
            self._send_packet(evt.UserIflagsEvent(ea, iflags))
            self._cached_funcs[ea]["iflags"] = iflags

    @staticmethod
    def _get_user_lvar_settings(ea):
        dct = {}
        lvinf = ida_hexrays.lvar_uservec_t()
        ret = ida_hexrays.restore_user_lvar_settings(lvinf, ea)
        # print("_get_user_lvar_settings: ret = %x" % ret)
        if ret:
            dct["lvvec"] = []
            for lv in lvinf.lvvec:
                dct["lvvec"].append(HexRaysHooks._get_lvar_saved_info(lv))
            if hasattr(lvinf, "sizes"):
                dct["sizes"] = list(lvinf.sizes)
            dct["lmaps"] = []
            it = ida_hexrays.lvar_mapping_begin(lvinf.lmaps)
            while it != ida_hexrays.lvar_mapping_end(lvinf.lmaps):
                key = ida_hexrays.lvar_mapping_first(it)
                key = HexRaysHooks._get_lvar_locator(key)
                val = ida_hexrays.lvar_mapping_second(it)
                val = HexRaysHooks._get_lvar_locator(val)
                dct["lmaps"].append((key, val))
                it = ida_hexrays.lvar_mapping_next(it)
            dct["stkoff_delta"] = lvinf.stkoff_delta
            dct["ulv_flags"] = lvinf.ulv_flags
        return dct

    @staticmethod
    def _get_lvar_saved_info(lv):
        return {
            "ll": HexRaysHooks._get_lvar_locator(lv.ll),
            "name": Event.decode(lv.name),
            "type": HexRaysHooks._get_tinfo(lv.type),
            "cmt": Event.decode(lv.cmt),
            "flags": lv.flags,
        }

    @staticmethod
    def _get_tinfo(type):
        if type.empty():
            return None, None, None, None

        type, fields, fldcmts = type.serialize()
        fields = Event.decode_bytes(fields)
        fldcmts = Event.decode_bytes(fldcmts)
        parsed_list = Event.decode_bytes(pickle.dumps(ParseTypeString(type)))
        type = Event.decode_bytes(type)
        return type, fields, fldcmts, parsed_list

    @staticmethod
    def _get_lvar_locator(ll):
        return {
            "location": HexRaysHooks._get_vdloc(ll.location),
            "defea": ll.defea,
        }

    @staticmethod
    def _get_vdloc(location):
        return {
            "atype": location.atype(),
            "reg1": location.reg1(),
            "reg2": location.reg2(),
            "stkoff": location.stkoff(),
            "ea": location.get_ea(),
        }

    def _send_user_lvar_settings(self, ea):
        lvar_settings = HexRaysHooks._get_user_lvar_settings(ea)
        if lvar_settings != self._cached_funcs[ea]["lvar_settings"]:
            self._send_packet(evt.UserLvarSettingsEvent(ea, lvar_settings))
            self._cached_funcs[ea]["lvar_settings"] = lvar_settings

    @staticmethod
    def _get_user_numforms(ea):
        user_numforms = ida_hexrays.restore_user_numforms(ea)
        if user_numforms is None:
            user_numforms = ida_hexrays.user_numforms_new()
        numforms = []
        it = ida_hexrays.user_numforms_begin(user_numforms)
        while it != ida_hexrays.user_numforms_end(user_numforms):
            ol = ida_hexrays.user_numforms_first(it)
            nf = ida_hexrays.user_numforms_second(it)
            numforms.append(
                (
                    HexRaysHooks._get_operand_locator(ol),
                    HexRaysHooks._get_number_format(nf),
                )
            )
            it = ida_hexrays.user_numforms_next(it)
        ida_hexrays.user_numforms_free(user_numforms)
        return numforms

    @staticmethod
    def _get_operand_locator(ol):
        return {"ea": ol.ea, "opnum": ol.opnum}

    @staticmethod
    def _get_number_format(nf):
        return {
            "flags": nf.flags,
            "opnum": nf.opnum,
            "props": nf.props,
            "serial": nf.serial,
            "org_nbytes": nf.org_nbytes,
            "type_name": nf.type_name,
        }

    def _send_user_numforms(self, ea):
        numforms = HexRaysHooks._get_user_numforms(ea)
        if numforms != self._cached_funcs[ea]["numforms"]:
            self._send_packet(evt.UserNumformsEvent(ea, numforms))
            self._cached_funcs[ea]["numforms"] = numforms


class UIHooks(Hooks, ida_kernwin.UI_Hooks):
    def __init__(self,plugin):
        ida_kernwin.UI_Hooks.__init__(self)
        Hooks.__init__(self, plugin)
        self.actions = []

    def preprocess_action(self, name):
        ea = ida_kernwin.get_screen_ea()
        self._plugin.logger.debug("preprocess_action(name = %s). ea = 0x%X." % (name, ea))
        if name == "MakeUnknown":
            self.actions.append((name, ea))
        elif name == "MakeCode":
            self.actions.append((name, ea))
        return 0

    def postprocess_action(self):
        self._plugin.logger.debug("postprocess_action()")
        if len(self.actions):
            name, ea = self.actions.pop()
            if name == "MakeUnknown":
                flags = ida_bytes.get_full_flags(ea)
                if ida_bytes.is_unknown(flags):
                    self._send_packet(evt.MakeUnknown(ea))
            elif name == "MakeCode":
                flags = ida_bytes.get_full_flags(ea)
                if ida_bytes.is_code(flags):
                    self._send_packet(evt.MakeCodeEvent(ea))

```

`idarling/interface/actions.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import ctypes
from functools import partial
import os
import shutil
import tempfile
import bz2

import ida_auto
import ida_idaapi
import ida_kernwin
import ida_loader

from PySide6.QtCore import QCoreApplication, QFileInfo, Qt  # noqa: I202
from PySide6.QtGui import QIcon
from PySide6.QtWidgets import QMessageBox, QProgressDialog

from .dialogs import OpenDialog, SaveDialog
from ..shared.commands import DownloadFile, UpdateFile


class Action(object):
    """
    An action is attached to a specific menu, has a custom text, icon, tooltip
    and finally a handler that is called when it is clicked by the user.
    """

    _ACTION_ID = None

    def __init__(self, plugin, menu, text, tooltip, icon, handler):
        super(Action, self).__init__()
        self._plugin = plugin

        self._menu = menu
        self._text = text
        self._tooltip = tooltip
        self._icon = icon
        self._icon_id = ida_idaapi.BADADDR
        self._handler = handler

    @property
    def handler(self):
        return self._handler

    def install(self):
        action_name = self.__class__.__name__

        # Read and load the icon file
        icon_data_fd = open(self._icon, "rb")
        icon_data = icon_data_fd.read()
        icon_data_fd.close()
        self._icon_id = ida_kernwin.load_custom_icon(data=icon_data)

        # Create the action descriptor
        action_desc = ida_kernwin.action_desc_t(
            self._ACTION_ID,
            self._text,
            self._handler,
            None,
            self._tooltip,
            self._icon_id,
        )

        # Register the action using its descriptor
        result = ida_kernwin.register_action(action_desc)
        if not result:
            raise RuntimeError("Failed to register action %s" % action_name)

        # Attach the action to the chosen menu
        result = ida_kernwin.attach_action_to_menu(
            self._menu, self._ACTION_ID, ida_kernwin.SETMENU_APP
        )
        if not result:
            action_name = self.__class__.__name__
            raise RuntimeError("Failed to install action %s" % action_name)

        self._plugin.logger.debug("Installed action %s" % action_name)
        return True

    def uninstall(self):
        action_name = self.__class__.__name__

        # Detach the action from the chosen menu
        result = ida_kernwin.detach_action_from_menu(
            self._menu, self._ACTION_ID
        )
        if not result:
            return False

        # Un-register the action using its id
        result = ida_kernwin.unregister_action(self._ACTION_ID)
        if not result:
            return False

        # Free the custom icon using its id
        ida_kernwin.free_custom_icon(self._icon_id)
        self._icon_id = ida_idaapi.BADADDR

        self._plugin.logger.debug("Uninstalled action %s" % action_name)
        return True

    def update(self):
        """Check if the action should be enabled or not."""
        ida_kernwin.update_action_state(
            self._ACTION_ID, self._handler.update(None)
        )


class ActionHandler(ida_kernwin.action_handler_t):
    """An action handler will display one of the dialogs to the user."""

    _DIALOG = None

    @staticmethod
    def _on_progress(progress, count, total):
        """Called when some progress has been made."""
        progress.setRange(0, total)
        progress.setValue(count)

    def __init__(self, plugin):
        super(ActionHandler, self).__init__()
        self._plugin = plugin

    def update(self, ctx):
        """Update the state of the associated action."""
        if self._plugin.network.connected:
            return ida_kernwin.AST_ENABLE
        return ida_kernwin.AST_DISABLE

    def activate(self, ctx):
        """Called when the action is clicked by the user."""
        dialog_name = self._DIALOG.__name__
        self._plugin.logger.debug("Showing dialog %s" % dialog_name)
        dialog = self._DIALOG(self._plugin)
        dialog.accepted.connect(partial(self._dialog_accepted, dialog))
        dialog.exec_()
        return 1

    def _dialog_accepted(self, dialog):
        """Called when the dialog is accepted by the user."""
        raise NotImplementedError("dialog_accepted() not implemented")


class OpenAction(Action):
    """The "Open from server..." action installed in the "File" menu."""

    _ACTION_ID = "idarling:open"

    def __init__(self, plugin):
        super(OpenAction, self).__init__(
            plugin,
            "File/Open",
            "Open from server...",
            "Load a database from server",
            plugin.plugin_resource("download.png"),
            OpenActionHandler(plugin),
        )


class OpenActionHandler(ActionHandler):
    """The action handler for the "Open from server..." action."""

    _DIALOG = OpenDialog

    def _dialog_accepted(self, dialog):
        project, binary, snapshot = dialog.get_result()

        # Create the download progress dialog
        text = "Downloading database from server, please wait..."
        progress = QProgressDialog(text, "Cancel", 0, 1)
        progress.setCancelButton(None)  # Remove cancel button
        progress.setModal(True)  # Set as a modal dialog
        window_flags = progress.windowFlags()  # Disable close button
        progress.setWindowFlags(window_flags & ~Qt.WindowCloseButtonHint)
        progress.setWindowTitle("Open from server")
        icon_path = self._plugin.plugin_resource("download.png")
        progress.setWindowIcon(QIcon(icon_path))

        # Send a packet to download the file
        packet = DownloadFile.Query(project.name, binary.name, snapshot.name)
        callback = partial(self._on_progress, progress)

        def set_download_callback(reply):
            reply.downback = callback

        d = self._plugin.network.send_packet(packet)
        d.add_initback(set_download_callback)
        d.add_callback(partial(self._file_downloaded, project, snapshot, progress))
        d.add_errback(self._plugin.logger.exception)
        progress.show()

    def _file_downloaded(self, project, snapshot, progress, reply):
        """Called when the file has been downloaded."""
        progress.close()

        # Get the absolute path of the file
        app_path = QCoreApplication.applicationFilePath()
        app_name = QFileInfo(app_path).fileName()
        file_ext = "i64"
        file_name = "%s_%s_%s.%s" % (project.name, snapshot.binary, snapshot.name, file_ext)
        file_path = os.path.join(self._plugin.config["files_dir"], file_name)

        # Write the file to disk
        decompressed_content = bz2.decompress(reply.content)
        with open(file_path, "wb") as output_file:
            output_file.write(decompressed_content)
        self._plugin.logger.info("Saved file %s" % file_name)

        # Save the old database
        database = ida_loader.get_path(ida_loader.PATH_TYPE_IDB)
        if database:
            ida_loader.save_database(database, ida_loader.DBFL_TEMP)

        # This is a very ugly hack used to open a database into IDA. We don't
        # have any function for this in the SDK, so I sorta hijacked the
        # snapshot functionality in this effect.

        # Get the library to call functions not present in the bindings
        dll = self._plugin.core.get_ida_dll(app_name)

        # Close the old database using the term_database library function
        old_path = ida_loader.get_path(ida_loader.PATH_TYPE_IDB)
        if old_path:
            dll.term_database()

        # Open the new database using the init_database library function
        # This call only won't be enough because the user interface won't
        # be initialized, this is why the snapshot functionality is used for
        args = [app_name, file_path]
        argc = len(args)
        argv = (ctypes.POINTER(ctypes.c_char) * (argc + 1))()
        for i, arg in enumerate(args):
            arg = arg.encode("utf-8")
            argv[i] = ctypes.create_string_buffer(arg)

        v = ctypes.c_int(0)
        av = ctypes.addressof(v)
        pv = ctypes.cast(av, ctypes.POINTER(ctypes.c_int))
        dll.init_database(argc, argv, pv)

        # Create a temporary copy of the new database because we cannot use
        # the snapshot functionality to restore the currently opened database
        file_ext = ".i64"
        tmp_file, tmp_path = tempfile.mkstemp(suffix=file_ext)
        shutil.copyfile(file_path, tmp_path)

        # This hook is used to delete the temporary database when all done
        class TmpUIHooks(ida_kernwin.UI_Hooks):
            def database_inited(self, is_new_database, idc_script):
                self.unhook()

                os.close(tmp_file)
                if os.path.exists(tmp_path):
                    os.remove(tmp_path)

        hooks = TmpUIHooks()
        hooks.hook()

        # Call the restore_database_snapshot library function
        # This will initialize the user interface, completing the process
        s = ida_loader.snapshot_t()
        s.filename = tmp_path  # Use the temporary database
        ida_kernwin.restore_database_snapshot(s, None, None)


class SaveAction(Action):
    """The "Save to server..." action installed in the "File" menu."""

    _ACTION_ID = "idarling:save"

    def __init__(self, plugin):
        super(SaveAction, self).__init__(
            plugin,
            "File/Save",
            "Save to server...",
            "Save a database to server",
            plugin.plugin_resource("upload.png"),
            SaveActionHandler(plugin),
        )


class SaveActionHandler(ActionHandler):
    """The action handler for the "Save to server..." action."""

    _DIALOG = SaveDialog

    @staticmethod
    def upload_file(plugin, packet):
        # Save the current database with a tick=0 since it is a new snapshot
        plugin.core.tick = 0
        plugin.core.save_netnode()
        input_path = ida_loader.get_path(ida_loader.PATH_TYPE_IDB)
        ida_loader.save_database(input_path, 0)

        with open(input_path, "rb") as input_file:
            uncompressed_content = input_file.read()
        packet.content = bz2.compress(uncompressed_content)

        # Create the upload progress dialog
        text = "Uploading database to server, please wait..."
        progress = QProgressDialog(text, "Cancel", 0, 1)
        progress.setCancelButton(None)  # Remove cancel button
        progress.setModal(True)  # Set as a modal dialog
        window_flags = progress.windowFlags()  # Disable close button
        progress.setWindowFlags(window_flags & ~Qt.WindowCloseButtonHint)
        progress.setWindowTitle("Save to server")
        icon_path = plugin.plugin_resource("upload.png")
        progress.setWindowIcon(QIcon(icon_path))

        # Send the packet to upload the file
        packet.upback = partial(SaveActionHandler._on_progress, progress)
        d = plugin.network.send_packet(packet)
        if d:
            d.add_callback(
                partial(SaveActionHandler.file_uploaded, plugin, progress)
            )
            d.add_errback(plugin.logger.exception)
        progress.show()

    @staticmethod
    def file_uploaded(plugin, progress, _):
        progress.close()

        # Show a success dialog
        success = QMessageBox()
        success.setIcon(QMessageBox.Information)
        success.setStandardButtons(QMessageBox.Ok)
        success.setText("Database successfully uploaded!")
        success.setWindowTitle("Save to server")
        icon_path = plugin.plugin_resource("upload.png")
        success.setWindowIcon(QIcon(icon_path))
        success.exec_()

        # Subscribe to the event stream
        plugin.core.join_session()

    def update(self, ctx):
        if not ida_loader.get_path(ida_loader.PATH_TYPE_IDB):
            return ida_kernwin.AST_DISABLE
        if not ida_auto.auto_is_ok():
            return ida_kernwin.AST_DISABLE
        return super(SaveActionHandler, self).update(ctx)

    def _dialog_accepted(self, dialog):
        project, binary, snapshot = dialog.get_result()
        self._plugin.core.project = project.name
        self._plugin.core.binary = binary.name
        self._plugin.core.snapshot = snapshot.name

        # Create the packet that will hold the file
        packet = UpdateFile.Query(project.name, binary.name, snapshot.name)
        SaveActionHandler.upload_file(self._plugin, packet)

```

`idarling/interface/dialogs.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import datetime
from functools import partial
import logging, time
import binascii
import platform

import ida_loader
import ida_nalt
import idc

from PySide6.QtCore import QRegularExpression, Qt, QDir  # noqa: I202
from PySide6.QtGui import QIcon, QRegularExpressionValidator
from PySide6.QtWidgets import (
    QCheckBox,
    QColorDialog,
    QComboBox,
    QDialog,
    QFormLayout,
    QGridLayout,
    QGroupBox,
    QHBoxLayout,
    QHeaderView,
    QLabel,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QTableWidget,
    QTableWidgetItem,
    QTabWidget,
    QVBoxLayout,
    QWidget, QSizePolicy, QFileDialog,
)

# QHeaderView enum compatibility between PyQt5 and PySide6
try:
    _HV_Stretch = QHeaderView.ResizeMode.Stretch
    _HV_ResizeToContents = QHeaderView.ResizeMode.ResizeToContents
except AttributeError:
    _HV_Stretch = QHeaderView.Stretch
    _HV_ResizeToContents = QHeaderView.ResizeToContents

from ..shared.commands import (
    CreateProject,
    CreateBinary,
    CreateSnapshot,
    RenameBinary,
    ListProjects,
    ListBinaries,
    ListSnapshots,
    UpdateUserColor,
    UpdateUserName,
    DeleteProject,
    DeleteBinary,
    DeleteSnapshot,
)
from ..shared.models import Project, Binary, Snapshot


class OpenDialog(QDialog):
    """This dialog is shown to user to select which remote snapshot to load."""

    def __init__(self, plugin):
        super(OpenDialog, self).__init__()
        self._plugin = plugin
        self._projects = None
        self._binaries = None
        self._snapshots = None

        # General setup of the dialog
        self.setWindowTitle("Open from Remote Server")
        icon_path = self._plugin.plugin_resource("download.png")
        self.setWindowIcon(QIcon(icon_path))
        self.resize(1400, 450)

        # Setup of the layout and widgets
        layout = QVBoxLayout(self)
        main = QWidget(self)
        main_layout = QGridLayout(main)
        layout.addWidget(main)

        # Projects - left layout
        self._left_side = QWidget(main)
        self._left_layout = QVBoxLayout(self._left_side)
        self._projects_table = QTableWidget(0, 1, self._left_side)
        self._projects_table.setHorizontalHeaderLabels(("Projects",))
        self._projects_table.horizontalHeader().setSectionsClickable(False)
        self._projects_table.horizontalHeader().setStretchLastSection(True)
        self._projects_table.verticalHeader().setVisible(False)
        self._projects_table.setSelectionBehavior(QTableWidget.SelectRows)
        self._projects_table.setSelectionMode(QTableWidget.SingleSelection)
        self._projects_table.itemSelectionChanged.connect(
            self._project_clicked
        )
        self._left_layout.addWidget(self._projects_table)
        main_layout.addWidget(self._left_side, 0, 0)
        main_layout.setColumnStretch(0, 1)

        self.delete_project_button = QPushButton("Delete Project", self._left_side)
        self.delete_project_button.setEnabled(False)
        self.delete_project_button.clicked.connect(self._delete_project_clicked)
        self._left_layout.addWidget(self.delete_project_button)

        # Binaries - middle layout
        self._middle_side = QWidget(main)
        self._middle_layout = QVBoxLayout(self._middle_side)
        self._binaries_table = QTableWidget(0, 1, self._middle_side)
        self._binaries_table.setHorizontalHeaderLabels(("Binary Files",))
        self._binaries_table.horizontalHeader().setSectionsClickable(False)
        self._binaries_table.horizontalHeader().setStretchLastSection(True)
        self._binaries_table.verticalHeader().setVisible(False)
        self._binaries_table.setSelectionBehavior(QTableWidget.SelectRows)
        self._binaries_table.setSelectionMode(QTableWidget.SingleSelection)
        self._binaries_table.itemClicked.connect(
            self._binary_clicked
        )
        self._middle_layout.addWidget(self._binaries_table)
        main_layout.addWidget(self._middle_side, 0, 1)
        main_layout.setColumnStretch(1, 1)

        # Create a binary button
        self._rename_binary_button = QPushButton("Rename Binary File", self._middle_side)
        self._rename_binary_button.setEnabled(False)
        self._rename_binary_button.clicked.connect(self._rename_binary_button_clicked)
        self._middle_layout.addWidget(self._rename_binary_button)

        self._delete_binary_button = QPushButton(
            "Delete Binary File", self._middle_side
        )
        self._delete_binary_button.setEnabled(False)
        self._delete_binary_button.clicked.connect(
            self._delete_binary_clicked
        )
        self._middle_layout.addWidget(self._delete_binary_button)

        # Snapshots - right layout
        right_side = QWidget(main)
        right_layout = QVBoxLayout(right_side)
        details_project = QGroupBox("Details", right_side)
        details_layout = QGridLayout(details_project)
        self._file_label = QLabel("<b>File:</b>")
        details_layout.addWidget(self._file_label, 0, 0)
        self._hash_label = QLabel("<b>Hash:</b>")
        details_layout.addWidget(self._hash_label, 1, 0)
        details_layout.setColumnStretch(0, 1)
        self._type_label = QLabel("<b>Type:</b>")
        details_layout.addWidget(self._type_label, 0, 1)
        self._date_label = QLabel("<b>Date:</b>")
        details_layout.addWidget(self._date_label, 1, 1)
        details_layout.setColumnStretch(1, 1)
        right_layout.addWidget(details_project)
        main_layout.addWidget(right_side, 0, 2)
        main_layout.setColumnStretch(2, 2)

        # Snapshots table
        self._snapshots_project = QGroupBox("Database Snapshots", right_side)
        self._snapshots_layout = QVBoxLayout(self._snapshots_project)
        self._snapshots_table = QTableWidget(0, 3, self._snapshots_project)
        labels = ("Name", "Date", "Ticks")
        self._snapshots_table.setHorizontalHeaderLabels(labels)
        horizontal_header = self._snapshots_table.horizontalHeader()
        horizontal_header.setSectionsClickable(False)
        horizontal_header.setSectionResizeMode(0, _HV_Stretch)
        self._snapshots_table.verticalHeader().setVisible(False)
        self._snapshots_table.setSelectionBehavior(QTableWidget.SelectRows)
        self._snapshots_table.setSelectionMode(QTableWidget.SingleSelection)
        self._snapshots_table.itemSelectionChanged.connect(
            self._snapshot_clicked
        )
        self._snapshots_table.itemDoubleClicked.connect(
            self._snapshot_double_clicked
        )
        self._snapshots_layout.addWidget(self._snapshots_table)

        self._delete_snapshot_button = QPushButton(
            "Delete Database Snapshot", self._snapshots_project
        )
        self._delete_snapshot_button.setEnabled(False)
        self._delete_snapshot_button.clicked.connect(
            self._delete_snapshot_clicked
        )
        self._snapshots_layout.addWidget(self._delete_snapshot_button)
        right_layout.addWidget(self._snapshots_project)

        # General buttons - bottom right "stretched" layout
        buttons_widget = QWidget(self)
        buttons_layout = QHBoxLayout(buttons_widget)
        buttons_layout.addStretch()

        # Open button
        self._accept_button = QPushButton("Open", buttons_widget)
        self._accept_button.setEnabled(False)
        # self.accept is a QDialog virtual method
        self._accept_button.clicked.connect(self.accept)

        # Cancel button
        cancel_button = QPushButton("Cancel", buttons_widget)
        # self.reject is a QDialog virtual method
        cancel_button.clicked.connect(self.reject)

        # Place buttons onto UI
        buttons_layout.addWidget(cancel_button)
        buttons_layout.addWidget(self._accept_button)
        layout.addWidget(buttons_widget)

        # Ask the server for the list of projects
        d = self._plugin.network.send_packet(ListProjects.Query())
        d.add_callback(self._projects_listed)
        d.add_errback(self._plugin.logger.exception)

    ##### PROJECTS #####

    def _projects_listed(self, reply):
        """Called when the projects list is received."""
        self._projects = sorted(reply.projects, key=lambda x: x.name) # sort projects by name
        #self._projects = sorted(reply.projects, key=lambda x: x.date, reverse=True) # sort projects by reverse date
        self._refresh_projects()

    def _refresh_projects(self):
        """Refreshes the projects table."""
        self._projects_table.setRowCount(len(self._projects))
        for i, project in enumerate(self._projects):
            item = QTableWidgetItem(project.name)
            item.setData(Qt.UserRole, project)
            item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            self._projects_table.setItem(i, 0, item)

    def _project_clicked(self):
        self._plugin.logger.debug("OpenDialog._project_clicked()")
        """Called when a project item is clicked."""
        project = self._projects_table.selectedItems()[0].data(Qt.UserRole)

        # Ask the server for the list of binaries
        d = self._plugin.network.send_packet(ListBinaries.Query(project.name))
        d.add_callback(partial(self._binaries_listed))
        d.add_errback(self._plugin.logger.exception)

        self.delete_project_button.setEnabled(True)

    def _delete_project_clicked(self):
        self._plugin.logger.debug("OpenDialog._delete_project_clicked()")
        project = self._projects_table.selectedItems()[0].data(Qt.UserRole)
        d = self._plugin.network.send_packet(DeleteProject.Query(project.name))
        d.add_callback(partial(self._project_deleted, project))
        d.add_errback(self._plugin.logger.exception)

    def _project_deleted(self, project, reply):
        if reply.deleted:
            for e in self._projects:
                if e.name == project.name:
                    self._projects.remove(e)
            self._refresh_projects()
        else:
            QMessageBox.about(self, "IDArling Error", "Unable to delete.\n"
                                                      "Likely more than one client connected to target?")

    ##### BINARIES #####

    def _binaries_listed(self, reply):
        self._plugin.logger.debug("OpenDialog._binaries_listed()")
        """Called when the binaries list is received."""
        self._binaries = sorted(reply.binaries, key=lambda x: x.name) # sort binary by name
        #self._binaries = sorted(reply.binaries, key=lambda x: x.date, reverse=True) # sort binary by reverse date
        self._refresh_binaries()

    def _refresh_binaries(self):
        self._plugin.logger.debug("OpenDialog._refresh_binaries()")
        """Refreshes the binaries table."""
        self._binaries_table.setRowCount(len(self._binaries))
        for i, binary in enumerate(self._binaries):
            item = QTableWidgetItem(binary.name)
            item.setData(Qt.UserRole, binary)
            item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            self._binaries_table.setItem(i, 0, item)

    def _binary_clicked(self):
        """Called when a binary item is clicked."""
        self._plugin.logger.debug("OpenDialog._binary_clicked()")
        if len(self._binaries) == 0:
            self._plugin.logger.info("No binary to display yet 2")
            return  # no binary in the project yet

        project = self._projects_table.selectedItems()[0].data(Qt.UserRole)
        binary_items = self._binaries_table.selectedItems()
        if not binary_items:
            self._plugin.logger.info("No selected item 2")
            return
        binary = binary_items[0].data(Qt.UserRole)
        self._file_label.setText("<b>File:</b> %s" % str(binary.file))
        self._hash_label.setText("<b>Hash:</b> %s" % str(binary.hash))
        self._type_label.setText("<b>Type:</b> %s" % str(binary.type))
        self._date_label.setText("<b>Date:</b> %s" % str(binary.date))

        # Ask the server for the list of snapshots
        d = self._plugin.network.send_packet(ListSnapshots.Query(project.name, binary.name))
        d.add_callback(partial(self._snapshots_listed))
        d.add_errback(self._plugin.logger.exception)
        self._rename_binary_button.setEnabled(True)
        self._delete_binary_button.setEnabled(True)

    def _delete_binary_clicked(self):
        self._plugin.logger.debug("OpenDialog._delete_binary_clicked()")
        project = self._projects_table.selectedItems()[0].data(Qt.UserRole)
        binary_items = self._binaries_table.selectedItems()
        if not binary_items:
            self._plugin.logger.info("No selected item 2")
            return
        binary = binary_items[0].data(Qt.UserRole)
        d = self._plugin.network.send_packet(DeleteBinary.Query(project.name, binary.name))
        d.add_callback(partial(self._binary_deleted, binary))
        d.add_errback(self._plugin.logger.exception)

    def _binary_deleted(self, binary, reply):
        if reply.deleted:
            for e in self._binaries:
                if e.name == binary.name:
                    self._binaries.remove(e)
            self._refresh_binaries()
            self._snapshots_table.clearContents()
        else:
            QMessageBox.about(self, "IDArling Error", "Unable to delete.\n"
                                                      "Likely more than one client connected to target?")

    def _rename_binary_button_clicked(self, _):
        current_binary = self._binaries_table.selectedItems()[0].data(Qt.UserRole).name
        dialog = RenameBinaryDialog(self._plugin, "Rename binary", current_binary)
        dialog.accepted.connect(partial(self._rename_binary_dialog_accepted, dialog))
        dialog.exec_()

    def _rename_binary_dialog_accepted(self, dialog):
        project = self._projects_table.selectedItems()[0].data(Qt.UserRole).name
        old_name = self._binaries_table.selectedItems()[0].data(Qt.UserRole).name
        new_name = dialog.get_result()
        self._plugin.logger.info("Request to rename to %s to %s in project: %s" % (old_name, new_name, project))
        # Send the packet to the server with the new name
        d = self._plugin.network.send_packet(RenameBinary.Query(project, old_name, new_name))
        d.add_callback(self._binary_renamed)
        d.add_errback(self._plugin.logger.exception)

    def _binary_renamed(self, reply):
        self._renamed = reply.renamed
        if self._renamed:
            self._binaries = self.sort_binaries(reply.binaries)
            self._refresh_binaries()
        else:
            self._plugin.logger.debug("Create binary dialog")
            QMessageBox.about(self, "IDArling Error", "Unable to rename.\n"
                    "Likely more than one client connected?")

    ##### SNAPSHOTS #####

    def _snapshots_listed(self, reply):
        """Called when the snapshots list is received."""
        self._snapshots = self.sort_snapshots(reply.snapshots)
        self._refresh_snapshots()

    def _refresh_snapshots(self):
        """Refreshes the table of snapshots."""

        def create_item(text, snapshot):
            item = QTableWidgetItem(text)
            item.setData(Qt.UserRole, snapshot)
            item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            if snapshot.tick == -1:
                item.setFlags(item.flags() & ~Qt.ItemIsEnabled)
            return item

        self._snapshots_table.setRowCount(len(self._snapshots))
        for i, snapshot in enumerate(self._snapshots):
            self._snapshots_table.setItem(
                i, 0, create_item(snapshot.name, snapshot)
            )
            self._snapshots_table.setItem(
                i, 1, create_item(snapshot.date, snapshot)
            )
            tick = str(snapshot.tick) if snapshot.tick != -1 else "<none>"
            self._snapshots_table.setItem(i, 2, create_item(tick, snapshot))

    def _snapshot_clicked(self):
        self._accept_button.setEnabled(True)
        self._delete_snapshot_button.setEnabled(True)

    def _delete_snapshot_clicked(self):
        self._plugin.logger.debug("OpenDialog._delete_snapshot_clicked()")
        project = self._projects_table.selectedItems()[0].data(Qt.UserRole)
        binary_items = self._binaries_table.selectedItems()
        if not binary_items:
            self._plugin.logger.info("No selected item 2")
            return
        binary = binary_items[0].data(Qt.UserRole)
        snapshot = self._snapshots_table.selectedItems()[0].data(Qt.UserRole)
        d = self._plugin.network.send_packet(DeleteSnapshot.Query(project.name, binary.name, snapshot.name))
        d.add_callback(partial(self._snapshot_deleted, snapshot))
        d.add_errback(self._plugin.logger.exception)

    def _snapshot_deleted(self, snapshot, reply):
        if reply.deleted:
            for e in self._snapshots:
                if e.name == snapshot.name:
                    self._snapshots.remove(e)
            self._refresh_snapshots()
        else:
            QMessageBox.about(self, "IDArling Error", "Unable to delete.\n"
                                                      "Likely more than one client connected to target?")

    def _snapshot_double_clicked(self):
        binary_type = self._binaries_table.selectedItems()[0].data(Qt.UserRole).type
        # For now we are only detecting some bad matching between IDA architecture
        # and the disassembled binary's architecture but we would need to 
        # actually save a binary architecture (32-bit or 64-bit) to support all
        # cases
        # E.g. below we support "Portable executable for 80386 (PE)" vs 
        # "Portable executable for AMD64 (PE)"
        # ida.exe vs ida64.exe can be determined using idc.BADADDR trick
        if (idc.BADADDR == 0xffffffffffffffff and "80386" in binary_type) \
         or (idc.BADADDR == 0xffffffff and "AMD64" in binary_type):
            QMessageBox.about(self, "IDArling Error", "Wrong architecture!\n"
                    "You must use the right version of IDA/IDA64,")
            return
        self.accept()

    ##### HELPERS #####

    def get_result(self):
        """Get the binary and snapshot selected by the user."""
        project = self._projects_table.selectedItems()[0].data(Qt.UserRole)
        binary = self._binaries_table.selectedItems()[0].data(Qt.UserRole)
        snapshot = self._snapshots_table.selectedItems()[0].data(Qt.UserRole)
        return project, binary, snapshot

    # XXX - Make x.name configurable based on clicking on columns
    def sort_binaries(self, binaries):
        #return sorted(binaries, key=lambda x: x.date, reverse=True) # sort binary by reverse date
        return sorted(binaries, key=lambda x: x.name)

    # XXX - Make x.date configurable based on clicking on columns
    def sort_snapshots(self, snapshots):
        return sorted(snapshots, key=lambda x: x.date, reverse=True) # sort snapshots by reverse date

class SaveDialog(OpenDialog):
    """
    This save dialog is shown to user to select which remote snapshot to save. We
    extend the open dialog to reuse most of the UI setup code.
    """

    def __init__(self, plugin):
        super(SaveDialog, self).__init__(plugin)
        self._project = None
        self._binary = None

        # General setup of the dialog
        self.setWindowTitle("Save to Remote Server")
        icon_path = self._plugin.plugin_resource("upload.png")
        self.setWindowIcon(QIcon(icon_path))

        # Change the accept button text
        self._accept_button.setText("Save")

        # Add a button to create a project
        create_project_button = QPushButton("Create Project", self._left_side)
        create_project_button.clicked.connect(self._create_project_clicked)
        self._left_layout.addWidget(create_project_button)

        # Add a button to create a binary
        self._create_binary_button = QPushButton(
            "Create Binary File", self._middle_side
        )
        self._create_binary_button.setEnabled(False)
        self._create_binary_button.clicked.connect(
            self._create_binary_clicked
        )
        self._middle_layout.addWidget(self._create_binary_button)

        # Add a button to create a snapshot
        self._create_snapshot_button = QPushButton(
            "Create Database Snapshot", self._snapshots_project
        )
        self._create_snapshot_button.setEnabled(False)
        self._create_snapshot_button.clicked.connect(
            self._create_snapshot_clicked
        )
        self._snapshots_layout.addWidget(self._create_snapshot_button)

    ##### PROJECTS #####

    # XXX - not needed?
    def _refresh_projects(self):
        super(SaveDialog, self)._refresh_projects()
        for row in range(self._projects_table.rowCount()):
            item = self._projects_table.item(row, 0)
            project = item.data(Qt.UserRole)
            pass

    def _project_clicked(self):
        super(SaveDialog, self)._project_clicked()
        self._project = self._projects_table.selectedItems()[0].data(
            Qt.UserRole
        )
        self._create_binary_button.setEnabled(True)

    def _create_project_clicked(self):
        dialog = CreateProjectDialog(self._plugin)
        dialog.accepted.connect(partial(self._create_project_accepted, dialog))
        dialog.exec_()

    def _create_project_accepted(self, dialog):
        """Called when the project creation dialog is accepted."""
        name = dialog.get_result()
        # Ensure we don't already have a project with that name
        if any(project.name == name for project in self._projects):
            failure = QMessageBox()
            failure.setIcon(QMessageBox.Warning)
            failure.setStandardButtons(QMessageBox.Ok)
            failure.setText("A project with that name already exists!")
            failure.setWindowTitle("New Project")
            icon_path = self._plugin.plugin_resource("upload.png")
            failure.setWindowIcon(QIcon(icon_path))
            failure.exec_()
            return

        # Get all the information we need and sent it to the server
        date_format = "%Y/%m/%d %H:%M"
        date = datetime.datetime.now().strftime(date_format)
        project = Project(name, date)
        d = self._plugin.network.send_packet(CreateProject.Query(project))
        d.add_callback(partial(self._project_created, project))
        d.add_errback(self._plugin.logger.exception)

    def _project_created(self, project, _):
        """Called when the create project reply is received."""
        self._projects.append(project)
        self._refresh_projects()
        row = len(self._projects) - 1
        self._projects_table.selectRow(row)
        self._accept_button.setEnabled(False)

    ##### BINARIES #####

    def _refresh_binaries(self):
        self._plugin.logger.debug("SaveDialog._refresh_binaries()")
        super(SaveDialog, self)._refresh_binaries()
        self._plugin.logger.debug("SaveDialog._refresh_binaries() continue")

        if len(self._binaries) == 0:
            self._plugin.logger.info("No binary to display yet 3")
            return  # no binary in the project yet

        hash = ida_nalt.retrieve_input_file_md5()
        if hash.endswith(b'\x00'):
            hash = hash[0:-1]
        # This decode is safe, because we have an hash in hex format
        hash = binascii.hexlify(hash).decode('utf-8')
        for row in range(self._binaries_table.rowCount()):
            item = self._binaries_table.item(row, 0)
            binary = item.data(Qt.UserRole)
            if binary.hash != hash:
                item.setFlags(item.flags() & ~Qt.ItemIsEnabled)

    def _binary_clicked(self):
        self._plugin.logger.debug("SaveDialog._binary_clicked()")
        super(SaveDialog, self)._binary_clicked()
        self._plugin.logger.debug("SaveDialog._binary_clicked() continue")
        binary_items = self._binaries_table.selectedItems()
        if not binary_items:
            self._plugin.logger.info("No selected item 2")
            return
        self._binary = binary_items[0].data(Qt.UserRole)
        self._create_snapshot_button.setEnabled(True)

    def _create_binary_clicked(self):
        dialog = CreateBinaryDialog(self._plugin)
        dialog.accepted.connect(partial(self._create_binary_accepted, dialog))
        dialog.exec_()

    def _create_binary_accepted(self, dialog):
        """Called when the binary creation dialog is accepted."""
        name = dialog.get_result()
        # Ensure we don't already have a binary with that name
        # Note: 2 different projects can have two binaries with the same name
        # and it will effectively be 2 different binaries
        if any(binary.name == name for binary in self._binaries):
            failure = QMessageBox()
            failure.setIcon(QMessageBox.Warning)
            failure.setStandardButtons(QMessageBox.Ok)
            failure.setText("A binary with that name already exists!")
            failure.setWindowTitle("New Binary")
            icon_path = self._plugin.plugin_resource("upload.png")
            failure.setWindowIcon(QIcon(icon_path))
            failure.exec_()
            return

        # Get all the information we need and sent it to the server
        hash = ida_nalt.retrieve_input_file_md5()
        # Remove the trailing null byte, if exists
        if hash.endswith(b'\x00'):
            hash = hash[0:-1]
        # This decode is safe, because we have an hash in hex format
        hash = binascii.hexlify(hash).decode('utf-8')
        file = ida_nalt.get_root_filename()
        ftype = ida_loader.get_file_type_name()
        date_format = "%Y/%m/%d %H:%M"
        date = datetime.datetime.now().strftime(date_format)
        binary = Binary(self._project.name, name, hash, file, ftype, date)
        d = self._plugin.network.send_packet(CreateBinary.Query(binary))
        d.add_callback(partial(self._binary_created, binary))
        d.add_errback(self._plugin.logger.exception)

    def _binary_created(self, binary, _):
        """Called when the create binary reply is received."""
        self._binaries.append(binary)
        self._refresh_binaries()
        row = len(self._binaries) - 1
        self._binaries_table.selectRow(row)
        self._accept_button.setEnabled(False)

    ##### SNAPSHOTS #####

    def _refresh_snapshots(self):
        super(SaveDialog, self)._refresh_snapshots()
        for row in range(self._snapshots_table.rowCount()):
            for col in range(3):
                item = self._snapshots_table.item(row, col)
                item.setFlags(item.flags() | Qt.ItemIsEnabled)

    def _create_snapshot_clicked(self):
        """Called when the create snapshot button is clicked."""
        dialog = CreateSnapshotDialog(self._plugin)
        dialog.accepted.connect(
            partial(self._create_snapshot_accepted, dialog)
        )
        dialog.exec_()

    def _create_snapshot_accepted(self, dialog):
        """Called when the snapshot creation dialog is accepted."""
        name = dialog.get_result()

        # Ensure we don't already have a snapshot with that name
        if any(snapshot.name == name for snapshot in self._snapshots):
            failure = QMessageBox()
            failure.setIcon(QMessageBox.Warning)
            failure.setStandardButtons(QMessageBox.Ok)
            failure.setText("A snapshot with that name already exists!")
            failure.setWindowTitle("New Snapshot")
            icon_path = self._plugin.plugin_resource("upload.png")
            failure.setWindowIcon(QIcon(icon_path))
            failure.exec_()
            return

        # Get all the information we need and sent it to the server
        date_format = "%Y/%m/%d %H:%M"
        date = datetime.datetime.now().strftime(date_format)
        snapshot = Snapshot(self._project.name, self._binary.name, name, date, -1)
        d = self._plugin.network.send_packet(CreateSnapshot.Query(snapshot))
        d.add_callback(partial(self._snapshot_created, snapshot))
        d.add_errback(self._plugin.logger.exception)

    def _snapshot_created(self, snapshot, _):
        """Called when the new snapshot reply is received."""
        self._snapshots.append(snapshot)
        self._refresh_snapshots()
        row = len(self._snapshots) - 1
        self._snapshots_table.selectRow(row)

class CreateProjectDialog(QDialog):
    """The dialog shown when an user wants to create a project."""

    def __init__(self, plugin):
        super(CreateProjectDialog, self).__init__()
        self._plugin = plugin

        # General setup of the dialog
        self._plugin.logger.debug("Create project dialog")
        self.setWindowTitle("Create Project")
        icon_path = plugin.plugin_resource("upload.png")
        self.setWindowIcon(QIcon(icon_path))
        self.resize(100, 100)

        # Set up the layout and widgets
        layout = QVBoxLayout(self)

        self._nameLabel = QLabel("<b>Project Name</b>")
        layout.addWidget(self._nameLabel)
        self._nameEdit = QLineEdit()
        self._nameEdit.setValidator(QRegularExpressionValidator(QRegularExpression("[a-zA-Z0-9-]+")))
        layout.addWidget(self._nameEdit)

        buttons = QWidget(self)
        buttons_layout = QHBoxLayout(buttons)
        create_button = QPushButton("Create")
        create_button.clicked.connect(self.accept)
        buttons_layout.addWidget(create_button)
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.reject)
        buttons_layout.addWidget(cancel_button)
        layout.addWidget(buttons)

    def get_result(self):
        """Get the name entered by the user."""
        return self._nameEdit.text()


class CreateBinaryDialog(CreateProjectDialog):
    """The dialog shown when an user wants to create a binary. We extend the
    create binary dialog to avoid duplicating the UI setup code.
    """

    def __init__(self, plugin):
        super(CreateBinaryDialog, self).__init__(plugin)
        #self._plugin.logger.debug("Create binary dialog")
        self.setWindowTitle("Create Binary File")
        self._nameLabel.setText("<b>Binary Name</b>")


class CreateSnapshotDialog(CreateProjectDialog):
    """
    The dialog shown when an user wants to create a snapshot. We extend the
    create binary dialog to avoid duplicating the UI setup code.
    """

    def __init__(self, plugin):
        super(CreateSnapshotDialog, self).__init__(plugin)
        #self._plugin.logger.debug("Create snapshot dialog")
        self.setWindowTitle("Create Database Snapshot")
        self._nameLabel.setText("<b>Snapshot Name</b>")


class SettingsDialog(QDialog):
    """
    The dialog allowing an user to configure the plugin. It has multiple tabs
    used to group the settings by category (general, network, etc.).
    """

    def __init__(self, plugin):
        super(SettingsDialog, self).__init__()
        self._plugin = plugin

        # General setup of the dialog
        self._plugin.logger.debug("Showing settings dialog")
        self.setWindowTitle("Settings")
        icon_path = self._plugin.plugin_resource("settings.png")
        self.setWindowIcon(QIcon(icon_path))
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowCloseButtonHint)

        window_widget = QWidget(self)
        window_layout = QVBoxLayout(window_widget)
        tabs = QTabWidget(window_widget)
        window_layout.addWidget(tabs)

        # "General Settings" tab
        tab = QWidget(tabs)
        layout = QFormLayout(tab)
        layout.setFormAlignment(Qt.AlignVCenter)
        tabs.addTab(tab, "General Settings")

        user_widget = QWidget(tab)
        user_layout = QHBoxLayout(user_widget)
        layout.addRow(user_widget)

        # User color
        self._color_button = QPushButton("")
        self._color_button.setFixedSize(50, 30)

        def color_button_activated(_):
            self._set_color(qt_color=QColorDialog.getColor().rgb())

        self._color = self._plugin.config["user"]["color"]
        self._set_color(ida_color=self._color)
        self._color_button.clicked.connect(color_button_activated)
        user_layout.addWidget(self._color_button)

        # User name
        self._name_line_edit = QLineEdit()
        name = self._plugin.config["user"]["name"]
        self._name_line_edit.setText(name)
        user_layout.addWidget(self._name_line_edit)

        dir_combo_box = QWidget(tab)
        dir_combo_box_layout = QGridLayout()
        browseButton = self._createButton("&Browse...", self._browse_button_clicked)
        self.directoryComboBox = self._createComboBox(self._plugin.config["files_dir"])
        directoryLabel = QLabel("Files directory:")
        dir_combo_box_layout.addWidget(directoryLabel, 0, 0)
        dir_combo_box_layout.addWidget(self.directoryComboBox, 0, 1)
        dir_combo_box_layout.addWidget(browseButton, 0, 2)
        dir_combo_box.setLayout(dir_combo_box_layout)
        layout.addRow(dir_combo_box)

        text = "Disable all user cursors"
        self._disable_all_cursors_checkbox = QCheckBox(text)
        layout.addRow(self._disable_all_cursors_checkbox)
        navbar_checked = not self._plugin.config["cursors"]["navbar"]
        funcs_checked = not self._plugin.config["cursors"]["funcs"]
        disasm_checked = not self._plugin.config["cursors"]["disasm"]
        all_checked = navbar_checked and funcs_checked and disasm_checked
        self._disable_all_cursors_checkbox.setChecked(all_checked)

        def state_changed(state):
            enabled = state == Qt.Unchecked
            self._disable_navbar_cursors_checkbox.setChecked(not enabled)
            self._disable_navbar_cursors_checkbox.setEnabled(enabled)
            self._disable_funcs_cursors_checkbox.setChecked(not enabled)
            self._disable_funcs_cursors_checkbox.setEnabled(enabled)
            self._disable_disasm_cursors_checkbox.setChecked(not enabled)
            self._disable_disasm_cursors_checkbox.setEnabled(enabled)

        self._disable_all_cursors_checkbox.stateChanged.connect(state_changed)

        style_sheet = """QCheckBox{ margin-left: 20px; }"""

        text = "Disable navigation bar user cursors"
        self._disable_navbar_cursors_checkbox = QCheckBox(text)
        layout.addRow(self._disable_navbar_cursors_checkbox)
        self._disable_navbar_cursors_checkbox.setChecked(navbar_checked)
        self._disable_navbar_cursors_checkbox.setEnabled(not all_checked)
        self._disable_navbar_cursors_checkbox.setStyleSheet(style_sheet)

        text = "Disable functions window user cursors"
        self._disable_funcs_cursors_checkbox = QCheckBox(text)
        layout.addRow(self._disable_funcs_cursors_checkbox)
        self._disable_funcs_cursors_checkbox.setChecked(funcs_checked)
        self._disable_funcs_cursors_checkbox.setEnabled(not all_checked)
        self._disable_funcs_cursors_checkbox.setStyleSheet(style_sheet)

        text = "Disable disassembly view user cursors"
        self._disable_disasm_cursors_checkbox = QCheckBox(text)
        layout.addRow(self._disable_disasm_cursors_checkbox)
        self._disable_disasm_cursors_checkbox.setChecked(disasm_checked)
        self._disable_disasm_cursors_checkbox.setEnabled(not all_checked)
        self._disable_disasm_cursors_checkbox.setStyleSheet(style_sheet)

        text = "Allow other users to send notifications"
        self._notifications_checkbox = QCheckBox(text)
        layout.addRow(self._notifications_checkbox)
        checked = self._plugin.config["user"]["notifications"]
        self._notifications_checkbox.setChecked(checked)

        # Log level
        debug_level_label = QLabel("Logging level: ")
        self._debug_level_combo_box = QComboBox()
        self._debug_level_combo_box.addItem("CRITICAL", logging.CRITICAL)
        self._debug_level_combo_box.addItem("ERROR", logging.ERROR)
        self._debug_level_combo_box.addItem("WARNING", logging.WARNING)
        self._debug_level_combo_box.addItem("INFO", logging.INFO)
        self._debug_level_combo_box.addItem("DEBUG", logging.DEBUG)
        self._debug_level_combo_box.addItem("TRACE", logging.TRACE)
        level = self._plugin.config["level"]
        index = self._debug_level_combo_box.findData(level)
        self._debug_level_combo_box.setCurrentIndex(index)
        layout.addRow(debug_level_label, self._debug_level_combo_box)

        # "Network Settings" tab
        tab = QWidget(tabs)
        layout = QVBoxLayout(tab)
        tab.setLayout(layout)
        tabs.addTab(tab, "Network Settings")

        top_widget = QWidget(tab)
        layout.addWidget(top_widget)
        top_layout = QHBoxLayout(top_widget)

        self._servers = list(self._plugin.config["servers"])
        self._servers_table = QTableWidget(len(self._servers), 3, self)
        top_layout.addWidget(self._servers_table)
        for i, server in enumerate(self._servers):
            # Server host and port
            item = QTableWidgetItem("%s:%d" % (server["host"], server["port"]))
            item.setData(Qt.UserRole, server)
            item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            # XXX - This prevented editing a server entry for your current 
            # server because the row cannot be selected properly with 
            # SingleSelection option selected
            #if self._plugin.network.server == server:
            #    item.setFlags((item.flags() & ~Qt.ItemIsSelectable))
            self._servers_table.setItem(i, 0, item)

            # Server has SSL enabled?
            ssl_checkbox = QTableWidgetItem()
            state = Qt.Unchecked if server["no_ssl"] else Qt.Checked
            ssl_checkbox.setCheckState(state)
            ssl_checkbox.setFlags((ssl_checkbox.flags() & ~Qt.ItemIsEditable))
            ssl_checkbox.setFlags((ssl_checkbox.flags() & ~Qt.ItemIsUserCheckable))
            self._servers_table.setItem(i, 1, ssl_checkbox)

            # Auto-connect enabled?
            auto_checkbox = QTableWidgetItem()
            state = Qt.Unchecked if not server["auto_connect"] else Qt.Checked
            auto_checkbox.setCheckState(state)
            auto_checkbox.setFlags((auto_checkbox.flags() & ~Qt.ItemIsEditable))
            auto_checkbox.setFlags((auto_checkbox.flags() & ~Qt.ItemIsUserCheckable))
            self._servers_table.setItem(i, 2, auto_checkbox)

        self._servers_table.setHorizontalHeaderLabels(("Servers", "SSL",
                    "Auto"))
        horizontal_header = self._servers_table.horizontalHeader()
        horizontal_header.setSectionsClickable(False)
        horizontal_header.setSectionResizeMode(0, _HV_Stretch)
        horizontal_header.setSectionResizeMode(1, _HV_ResizeToContents)
        horizontal_header.setSectionResizeMode(2, _HV_ResizeToContents)
        self._servers_table.verticalHeader().setVisible(False)
        self._servers_table.setSelectionBehavior(QTableWidget.SelectRows)
        self._servers_table.setSelectionMode(QTableWidget.SingleSelection)
        self._servers_table.itemClicked.connect(self._server_clicked)
        self._servers_table.itemDoubleClicked.connect(
            self._server_double_clicked
        )
        self._servers_table.setMaximumHeight(100)

        buttons_widget = QWidget(top_widget)
        buttons_layout = QVBoxLayout(buttons_widget)
        top_layout.addWidget(buttons_widget)

        # Add server button
        self._add_button = QPushButton("Add Server")
        self._add_button.clicked.connect(self._add_button_clicked)
        buttons_layout.addWidget(self._add_button)

        # Edit server button
        self._edit_button = QPushButton("Edit Server")
        self._edit_button.setEnabled(False)
        self._edit_button.clicked.connect(self._edit_button_clicked)
        buttons_layout.addWidget(self._edit_button)

        # Delete server button
        self._delete_button = QPushButton("Delete Server")
        self._delete_button.setEnabled(False)
        self._delete_button.clicked.connect(self._delete_button_clicked)
        buttons_layout.addWidget(self._delete_button)

        bottom_widget = QWidget(tab)
        bottom_layout = QFormLayout(bottom_widget)
        layout.addWidget(bottom_widget)

        # TCP Keep-Alive settings
        keep_cnt_label = QLabel("Keep-Alive Count: ")
        self._keep_cnt_spin_box = QSpinBox(bottom_widget)
        self._keep_cnt_spin_box.setRange(0, 86400)
        self._keep_cnt_spin_box.setValue(self._plugin.config["keep"]["cnt"])
        self._keep_cnt_spin_box.setSuffix(" packets")
        bottom_layout.addRow(keep_cnt_label, self._keep_cnt_spin_box)

        keep_intvl_label = QLabel("Keep-Alive Interval: ")
        self._keep_intvl_spin_box = QSpinBox(bottom_widget)
        self._keep_intvl_spin_box.setRange(0, 86400)
        self._keep_intvl_spin_box.setValue(
            self._plugin.config["keep"]["intvl"]
        )
        self._keep_intvl_spin_box.setSuffix(" seconds")
        bottom_layout.addRow(keep_intvl_label, self._keep_intvl_spin_box)

        keep_idle_label = QLabel("Keep-Alive Idle: ")
        self._keep_idle_spin_box = QSpinBox(bottom_widget)
        self._keep_idle_spin_box.setRange(0, 86400)
        self._keep_idle_spin_box.setValue(self._plugin.config["keep"]["idle"])
        self._keep_idle_spin_box.setSuffix(" seconds")
        bottom_layout.addRow(keep_idle_label, self._keep_idle_spin_box)

        # Buttons commons to all tabs
        actions_widget = QWidget(self)
        actions_layout = QHBoxLayout(actions_widget)

        # Cancel = do not save the changes and close the dialog
        def cancel(_):
            self.reject()

        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(cancel)
        actions_layout.addWidget(cancel_button)

        # Reset = reset all settings from all tabs to default values
        reset_button = QPushButton("Reset")
        reset_button.clicked.connect(self._reset)
        actions_layout.addWidget(reset_button)

        # Save = save the changes and close the dialog
        def save(_):
            self._commit()
            self.accept()

        save_button = QPushButton("Save")
        save_button.clicked.connect(save)
        actions_layout.addWidget(save_button)
        window_layout.addWidget(actions_widget)

        # Do not allow the user to resize the dialog
        self.setFixedSize(
            window_widget.sizeHint().width(), window_widget.sizeHint().height()
        )

    def _set_color(self, ida_color=None, qt_color=None):
        """Sets the color of the user color button."""
        # IDA represents colors as 0xBBGGRR
        if ida_color is not None:
            r = ida_color & 255
            g = (ida_color >> 8) & 255
            b = (ida_color >> 16) & 255

        # Qt represents colors as 0xRRGGBB
        if qt_color is not None:
            r = (qt_color >> 16) & 255
            g = (qt_color >> 8) & 255
            b = qt_color & 255

        ida_color = r | g << 8 | b << 16
        qt_color = r << 16 | g << 8 | b

        # Set the stylesheet of the button
        css = "QPushButton {background-color: #%06x; color: #%06x;}"
        self._color_button.setStyleSheet(css % (qt_color, qt_color))
        self._color = ida_color

    def _server_clicked(self, _):
        self._edit_button.setEnabled(True)
        self._delete_button.setEnabled(True)

    def _server_double_clicked(self, _):
        item = self._servers_table.selectedItems()[0]
        server = item.data(Qt.UserRole)
        # If not the current server, connect to it
        if (
            not self._plugin.network.connected
            or self._plugin.network.server != server
        ):
            self._plugin.network.stop_server()
            self._plugin.network.connect(server)
        self.accept()

    def _add_button_clicked(self, _):
        dialog = ServerInfoDialog(self._plugin, "Add server")
        dialog.accepted.connect(partial(self._add_dialog_accepted, dialog))
        dialog.exec_()

    def _edit_button_clicked(self, _):
        selected = self._servers_table.selectedItems()
        if len(selected) == 0:
            self._plugin.logger.warning("No server selected")
            return
        item = selected[0]
        server = item.data(Qt.UserRole)
        dialog = ServerInfoDialog(self._plugin, "Edit server", server)
        dialog.accepted.connect(partial(self._edit_dialog_accepted, dialog))
        dialog.exec_()

    def _delete_button_clicked(self, _):
        item = self._servers_table.selectedItems()[0]
        server = item.data(Qt.UserRole)
        self._servers.remove(server)
        self._plugin.save_config()
        self._servers_table.removeRow(item.row())
        self.update()

    def _add_dialog_accepted(self, dialog):
        """Called when the dialog to add a server is accepted."""
        server = dialog.get_result()
        self._servers.append(server)
        row_count = self._servers_table.rowCount()
        self._servers_table.insertRow(row_count)

        new_server = QTableWidgetItem(
            "%s:%d" % (server["host"], server["port"])
        )
        new_server.setData(Qt.UserRole, server)
        new_server.setFlags(new_server.flags() & ~Qt.ItemIsEditable)
        self._servers_table.setItem(row_count, 0, new_server)

        new_checkbox = QTableWidgetItem()
        state = Qt.Unchecked if server["no_ssl"] else Qt.Checked
        new_checkbox.setCheckState(state)
        new_checkbox.setFlags((new_checkbox.flags() & ~Qt.ItemIsEditable))
        new_checkbox.setFlags(new_checkbox.flags() & ~Qt.ItemIsUserCheckable)
        self._servers_table.setItem(row_count, 1, new_checkbox)
        self.update()

    def _edit_dialog_accepted(self, dialog):
        """Called when the dialog to edit a server is accepted."""
        server = dialog.get_result()
        item = self._servers_table.selectedItems()[0]
        self._servers[item.row()] = server

        item.setText("%s:%d" % (server["host"], server["port"]))
        item.setData(Qt.UserRole, server)
        item.setFlags(item.flags() & ~Qt.ItemIsEditable)

        checkbox = self._servers_table.item(item.row(), 1)
        state = Qt.Unchecked if server["no_ssl"] else Qt.Checked
        checkbox.setCheckState(state)
        self.update()

    def _reset(self, _):
        """Resets all the form elements to their default value."""
        config = self._plugin.default_config()

        self._name_line_edit.setText(config["user"]["name"])
        self._set_color(ida_color=config["user"]["color"])

        navbar_checked = not config["cursors"]["navbar"]
        funcs_checked = not config["cursors"]["funcs"]
        disasm_checked = not config["cursors"]["disasm"]
        all_checked = navbar_checked and funcs_checked and disasm_checked
        self._disable_all_cursors_checkbox.setChecked(all_checked)

        self._disable_navbar_cursors_checkbox.setChecked(navbar_checked)
        self._disable_navbar_cursors_checkbox.setEnabled(not all_checked)
        self._disable_funcs_cursors_checkbox.setChecked(funcs_checked)
        self._disable_funcs_cursors_checkbox.setEnabled(not all_checked)
        self._disable_disasm_cursors_checkbox.setChecked(disasm_checked)
        self._disable_disasm_cursors_checkbox.setEnabled(not all_checked)

        checked = config["user"]["notifications"]
        self._notifications_checkbox.setChecked(checked)

        index = self._debug_level_combo_box.findData(config["level"])
        self._debug_level_combo_box.setCurrentIndex(index)

        del self._servers[:]
        self._servers_table.clearContents()
        self._keep_cnt_spin_box.setValue(config["keep"]["cnt"])
        self._keep_intvl_spin_box.setValue(config["keep"]["intvl"])
        self._keep_idle_spin_box.setValue(config["keep"]["idle"])

    def _commit(self):
        """Commits all the changes made to the form elements."""
        name = self._name_line_edit.text()
        if self._plugin.config["user"]["name"] != name:
            old_name = self._plugin.config["user"]["name"]
            self._plugin.network.send_packet(UpdateUserName(old_name, name))
            self._plugin.config["user"]["name"] = name

        if self._plugin.config["user"]["color"] != self._color:
            name = self._plugin.config["user"]["name"]
            old_color = self._plugin.config["user"]["color"]
            packet = UpdateUserColor(name, old_color, self._color)
            self._plugin.network.send_packet(packet)
            self._plugin.config["user"]["color"] = self._color
            self._plugin.interface.widget.refresh()

        all_ = self._disable_all_cursors_checkbox.isChecked()
        checked = self._disable_navbar_cursors_checkbox.isChecked()
        self._plugin.config["cursors"]["navbar"] = not all_ and not checked
        checked = self._disable_funcs_cursors_checkbox.isChecked()
        self._plugin.config["cursors"]["funcs"] = not all_ and not checked
        checked = self._disable_disasm_cursors_checkbox.isChecked()
        self._plugin.config["cursors"]["disasm"] = not all_ and not checked

        checked = self._notifications_checkbox.isChecked()
        self._plugin.config["user"]["notifications"] = checked

        index = self._debug_level_combo_box.currentIndex()
        level = self._debug_level_combo_box.itemData(index)
        self._plugin.logger.setLevel(level)
        self._plugin.config["level"] = level

        self._plugin.config["servers"] = self._servers
        cnt = self._keep_cnt_spin_box.value()
        self._plugin.config["keep"]["cnt"] = cnt
        intvl = self._keep_intvl_spin_box.value()
        self._plugin.config["keep"]["intvl"] = intvl
        idle = self._keep_idle_spin_box.value()
        self._plugin.config["keep"]["idle"] = idle
        if self._plugin.network.client:
            self._plugin.network.client.set_keep_alive(cnt, intvl, idle)

        files_path = self.directoryComboBox.currentText()
        self._plugin.config["files_dir"] = files_path

        self._plugin.save_config()

    def _createButton(self, text, member):
        button = QPushButton(text)
        button.clicked.connect(member)
        return button

    def _createComboBox(self,text):
        comboBox = QComboBox()
        comboBox.setEditable(True)
        comboBox.addItem(text)
        comboBox.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        return comboBox

    def _browse_button_clicked(self):
        directory = QFileDialog.getExistingDirectory(self, "Find Files",
                self.directoryComboBox.currentText())

        if directory:
            if self.directoryComboBox.findText(directory) == -1:
                self.directoryComboBox.addItem(directory)

            self.directoryComboBox.setCurrentIndex(self.directoryComboBox.findText(directory))

class RenameBinaryDialog(QDialog):
    """The dialog shown when an user wants to rename a binary."""

    def __init__(self, plugin, title, current_value, server=None):
        super(RenameBinaryDialog, self).__init__()
        self._plugin = plugin

        # General setup of the dialog
        self._plugin.logger.debug("Showing rename binary dialog")
        self.setWindowTitle(title)
        icon_path = plugin.plugin_resource("settings.png")
        self.setWindowIcon(QIcon(icon_path))
        self.resize(100, 100)

        # Setup the layout and widgets
        layout = QVBoxLayout(self)

        self._rename_binary_name_label = QLabel("<b>New Binary Name</b>")
        layout.addWidget(self._rename_binary_name_label)
        self._new_binary_name = QLineEdit()
        # Populate the field with the old name and already selected
        self._new_binary_name.setText(current_value)
        self._new_binary_name.setSelection(0, len(current_value))
        layout.addWidget(self._new_binary_name)

        self._add_button = QPushButton("OK")
        self._add_button.clicked.connect(self.accept)
        down_side = QWidget(self)
        buttons_layout = QHBoxLayout(down_side)
        buttons_layout.addWidget(self._add_button)
        self._cancel_button = QPushButton("Cancel")
        self._cancel_button.clicked.connect(self.reject)
        buttons_layout.addWidget(self._cancel_button)
        layout.addWidget(down_side)

    def get_result(self):
        return self._new_binary_name.text()

class ServerInfoDialog(QDialog):
    """The dialog shown when an user creates or edits a server."""

    def __init__(self, plugin, title, server=None):
        super(ServerInfoDialog, self).__init__()
        self._plugin = plugin

        # General setup of the dialog
        self._plugin.logger.debug("Showing server info dialog")
        self.setWindowTitle(title)
        icon_path = plugin.plugin_resource("settings.png")
        self.setWindowIcon(QIcon(icon_path))
        self.resize(100, 100)

        # Setup the layout and widgets
        layout = QVBoxLayout(self)

        self._server_name_label = QLabel("<b>Server Host</b>")
        layout.addWidget(self._server_name_label)
        self._server_name = QLineEdit()
        self._server_name.setPlaceholderText("127.0.0.1")
        layout.addWidget(self._server_name)

        self._server_name_label = QLabel("<b>Server Port</b>")
        layout.addWidget(self._server_name_label)
        self._server_port = QLineEdit()
        self._server_port.setPlaceholderText("31013")
        layout.addWidget(self._server_port)

        self._no_ssl_checkbox = QCheckBox("Disable SSL")
        layout.addWidget(self._no_ssl_checkbox)

        self._auto_connect_checkbox = QCheckBox("Auto-connect on startup")
        layout.addWidget(self._auto_connect_checkbox)

        # Set the form elements values if we have a base
        if server is not None:
            self._server_name.setText(server["host"])
            self._server_port.setText(str(server["port"]))
            self._no_ssl_checkbox.setChecked(server["no_ssl"])
            self._auto_connect_checkbox.setChecked(server["auto_connect"])

        down_side = QWidget(self)
        buttons_layout = QHBoxLayout(down_side)
        self._add_button = QPushButton("OK")
        self._add_button.clicked.connect(self.accept)
        buttons_layout.addWidget(self._add_button)
        self._cancel_button = QPushButton("Cancel")
        self._cancel_button.clicked.connect(self.reject)
        buttons_layout.addWidget(self._cancel_button)
        layout.addWidget(down_side)

    def get_result(self):
        """Get the server resulting from the form elements values."""
        return {
            "host": self._server_name.text() or "127.0.0.1",
            "port": int(self._server_port.text() or "31013"),
            "no_ssl": self._no_ssl_checkbox.isChecked(),
            "auto_connect": self._auto_connect_checkbox.isChecked(),
        }

```

`idarling/interface/filter.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import ida_funcs
import ida_kernwin

from PySide6.QtCore import QEvent, QObject, Qt  # noqa: I202
from PySide6.QtGui import QAction, QContextMenuEvent, QIcon, QImage, QPixmap, QShowEvent
from PySide6.QtWidgets import (
    QApplication,
    QDialog,
    QGroupBox,
    QLabel,
    QMenu,
    QTableView,
    QWidget,
)


from .widget import StatusWidget
from ..shared.commands import InviteToLocation


class EventFilter(QObject):
    """
    This Qt event filter is used to replace the IDA icon with our
    own and to setup the invites context menu in the disassembler view.
    """

    def __init__(self, plugin, parent=None):
        super(EventFilter, self).__init__(parent)
        self._plugin = plugin
        self._intercept = False

    def install(self):
        self._plugin.logger.debug("Installing the event filter")
        QApplication.instance().installEventFilter(self)

    def uninstall(self):
        self._plugin.logger.debug("Uninstalling the event filter")
        QApplication.instance().removeEventFilter(self)

    def _replace_icon(self, label):
        pixmap = QPixmap(self._plugin.plugin_resource("idarling.png"))
        pixmap = pixmap.scaled(
            label.sizeHint().width(),
            label.sizeHint().height(),
            Qt.KeepAspectRatio,
            Qt.SmoothTransformation,
        )
        label.setPixmap(pixmap)

    def _insert_menu(self, obj):
        # Find where to install our submenu
        sep = None
        for act in obj.actions():
            if act.isSeparator():
                sep = act
            if "Undefine" in act.text():
                break
        obj.insertSeparator(sep)

        # Setup our custom menu text and icon
        menu = QMenu("Invite to location", obj)
        pixmap = QPixmap(self._plugin.plugin_resource("invite.png"))
        menu.setIcon(QIcon(pixmap))

        # Setup our first submenu entry text and icon
        everyone = QAction("Everyone", menu)
        pixmap = QPixmap(self._plugin.plugin_resource("users.png"))
        everyone.setIcon(QIcon(pixmap))

        def invite_to(name):
            """Send an invitation to the current location."""
            loc = ida_kernwin.get_screen_ea()
            packet = InviteToLocation(name, loc)
            self._plugin.network.send_packet(packet)

        # Handler for when the action is clicked
        def invite_to_everyone():
            invite_to("everyone")

        everyone.triggered.connect(invite_to_everyone)
        menu.addAction(everyone)

        menu.addSeparator()
        template = self._plugin.plugin_resource("user.png")

        def create_action(name, color):
            action = QAction(name, menu)
            pixmap = StatusWidget.make_icon(template, color)
            action.setIcon(QIcon(pixmap))

            # Handler for when the action is clicked
            def invite_to_user():
                invite_to(name)

            action.triggered.connect(invite_to_user)
            return action

        # Insert an action for each connected user
        for name, user in self._plugin.core.get_users().items():
            menu.addAction(create_action(name, user["color"]))
        obj.insertMenu(sep, menu)

    def _set_tooltip(self, obj, ev):
        cursors = self._plugin.config["cursors"]
        if not cursors["funcs"]:
            return

        obj.setToolTip("")
        index = obj.parent().indexAt(ev.pos())
        func_ea = int(index.sibling(index.row(), 2).data(), 16)
        func = ida_funcs.get_func(func_ea)

        # Find the corresponding username
        for name, user in self._plugin.core.get_users().items():
            if ida_funcs.func_contains(func, user["ea"]):
                # Set the tooltip
                obj.setToolTip(name)
                break

    def eventFilter(self, obj, ev):  # noqa: N802
        # XXX - commented because of https://github.com/IDArlingTeam/IDArling/issues/104
        # because it is better to avoid huge CPU usage and not have the IDArling logo in the About of IDA Pro
        # So we will need to properly fix it to re-enable the easter egg
        #
        # Is it a QShowEvent on a QDialog named "Dialog"?
        #if (
        #    ev.__class__ == ev,
        #    QShowEvent
        #    and obj.__class__ == QDialog
        #    and obj.windowTitle() == "About",
        #):
        #    # Find a child QGroupBox
        #    for groupBox in obj.children():
        #        if groupBox.__class__ == QGroupBox:
        #            # Find a child QLabel with an icon
        #            for label in groupBox.children():
        #                if isinstance(label, QLabel) and label.pixmap():
        #                    self._replace_icon(label)

        # Is it a QContextMenuEvent on a QWidget?
        if isinstance(obj, QWidget) and isinstance(ev, QContextMenuEvent):
            # Find a parent titled "IDA View"
            parent = obj
            while parent:
                if parent.windowTitle().startswith("IDA View"):
                    # Intercept the next context menu
                    self._intercept = True
                parent = parent.parent()

        # Is it a QShowEvent on a QMenu?
        if isinstance(obj, QMenu) and isinstance(ev, QShowEvent):
            # Should we intercept?
            if self._intercept:
                self._insert_menu(obj)
                self._intercept = False

        # Is it a ToolTip event on a QWidget with a parent?
        if (
            ev.type() == QEvent.ToolTip
            and obj.__class__ == QWidget
            and obj.parent()
        ):
            table_view = obj.parent()
            # Is it a QTableView with a parent?
            if table_view.__class__ == QTableView and table_view.parent():
                func_window = table_view.parent()
                # Is it a QWidget titled "Functions window"?
                if (
                    func_window.__class__ == QWidget
                    and func_window.windowTitle() == "Functions window"
                ):
                    self._set_tooltip(obj, ev)

        return False

```

`idarling/interface/interface.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import time

from PySide6.QtGui import QPixmap
from PySide6.QtWidgets import QApplication, QMainWindow

from .actions import OpenAction, SaveAction
from .filter import EventFilter
from .invites import Invite
from .painter import Painter
from .widget import StatusWidget
from ..module import Module


class Interface(Module):
    """
    This is the interface module. It is responsible for all interactions with
    the user interface. It manages the all the actions, dialog, cursors,
    invites and the handy status bar widget.
    """

    def __init__(self, plugin):
        super(Interface, self).__init__(plugin)
        self._invites = []
        self._followed = None

        # Find the QMainWindow instance
        self._plugin.logger.debug("Searching for the main window")
        app = QApplication.instance()
        for widget in app.topLevelWidgets():
            if isinstance(widget, QMainWindow):
                self._window = widget
                break

        self._open_action = OpenAction(plugin)
        self._save_action = SaveAction(plugin)

        self._painter = Painter(plugin)
        self._filter = EventFilter(plugin)
        self._widget = StatusWidget(plugin)

    @property
    def widget(self):
        return self._widget

    @property
    def painter(self):
        return self._painter

    @property
    def invites(self):
        """Get all active invites."""
        invites = []
        for invite in self._invites:
            # Check if still active
            if (
                invite.callback
                and not invite.triggered
                and time.time() - invite.time < 180.0
            ):
                invites.append(invite)
        return invites

    @property
    def open_action(self):
        return self._open_action

    @property
    def save_action(self):
        return self._save_action

    @property
    def followed(self):
        return self._followed

    @followed.setter
    def followed(self, followed):
        self._followed = followed

    def _install(self):
        self._open_action.install()
        self._save_action.install()
        self._filter.install()
        self._widget.install(self._window)
        return True

    def _uninstall(self):
        self._open_action.uninstall()
        self._save_action.uninstall()
        self._filter.uninstall()
        self._widget.uninstall(self._window)
        return True

    def update(self):
        """Update the actions and widget."""
        if not self._plugin.network.connected:
            self.clear_invites()

        self._open_action.update()
        self._save_action.update()
        self._widget.refresh()

    def show_invite(self, text, icon, callback=None):
        """
        Display a toast notification to the user. The notification will have
        the specified text, icon and callback function (triggered on click).
        """
        # Check if notifications aren't disabled
        if not self._plugin.config["user"]["notifications"]:
            return

        invite = Invite(self._plugin, self._window)
        invite.time = time.time()
        invite.text = text
        invite.icon = QPixmap(icon)
        invite.callback = callback
        invite.show()
        self._invites.append(invite)

    def clear_invites(self):
        """Clears the invites list."""
        del self._invites[:]
        self._widget.refresh()

```

`idarling/interface/invites.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
from PySide6.QtCore import (
    Property,
    QPoint,
    QPropertyAnimation,
    QRect,
    Qt,
    QTimer,
)
from PySide6.QtGui import QBrush, QColor, QPainter
from PySide6.QtWidgets import QHBoxLayout, QLabel, QWidget


class Invite(QWidget):
    """
    An invite is a small notification being displayed in the bottom right
    corner of the window. It fades in and out, and is used to invite an user
    to jump to a certain location. Some other uses might be added later.
    """

    def __init__(self, plugin, parent=None):
        super(Invite, self).__init__(parent)
        self._plugin = plugin
        self._time = 0

        self.setWindowFlags(
            Qt.FramelessWindowHint | Qt.Tool | Qt.WindowStaysOnTopHint
        )
        self.setAttribute(Qt.WA_ShowWithoutActivating)
        self.setAttribute(Qt.WA_TranslucentBackground)

        self._icon = QLabel()
        self._icon.setAutoFillBackground(False)
        self._icon.setAttribute(Qt.WA_TranslucentBackground)

        self._text = QLabel()
        self._text.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

        self._layout = QHBoxLayout()
        self._layout.addWidget(self._text)
        self.setLayout(self._layout)

        # Fade in and out animation
        self._popup_opacity = 0.0
        self._animation = QPropertyAnimation()
        self._animation.setTargetObject(self)
        self._animation.setPropertyName(b"popup_opacity")
        self._animation.finished.connect(self.hide)

        # Timer used to auto-close the window
        self._timer = QTimer()
        self._timer.timeout.connect(self.hide_animation)
        self._callback = None
        self._triggered = False

    @property
    def time(self):
        return self._time

    @time.setter
    def time(self, time):
        self._time = time

    @property
    def text(self):
        return self._text.text()

    @text.setter
    def text(self, text):
        self._text.setText(text)
        self.adjustSize()

    @property
    def icon(self):
        return self._icon.pixmap()

    @icon.setter
    def icon(self, pixmap):
        # Resize the given pixmap
        pixmap_height = self._text.sizeHint().height()
        self._icon.setPixmap(
            pixmap.scaled(
                pixmap_height,
                pixmap_height,
                Qt.KeepAspectRatio,
                Qt.SmoothTransformation,
            )
        )
        self._layout.insertWidget(0, self._icon)

    @property
    def callback(self):
        return self._callback

    @callback.setter
    def callback(self, callback):
        self._callback = callback

    @property
    def triggered(self):
        return self._triggered

    @triggered.setter
    def triggered(self, triggered):
        self._triggered = triggered

    def paintEvent(self, event):  # noqa: N802
        """We override the painting event to draw the invite ourselves."""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        rect = QRect(self.rect())

        # Draw the border
        painter.setBrush(QBrush(QColor(122, 122, 122)))
        painter.setPen(Qt.NoPen)
        painter.drawRect(rect)

        rect.setX(rect.x() + 1)
        rect.setY(rect.y() + 1)
        rect.setWidth(rect.width() - 1)
        rect.setHeight(rect.height() - 1)

        # Draw the background
        painter.setBrush(QBrush(QColor(255, 255, 225)))
        painter.setPen(Qt.NoPen)
        painter.drawRect(rect)

    def mouseReleaseEvent(self, event):  # noqa: N802
        """
        This function is called when the user clicks the invite. It triggers
        the callback function is it has been specified, and hides the invite.
        """
        if self._callback:
            self._callback()
        self._triggered = True
        self._popup_opacity = 0.0
        self.hide()

    def show(self):
        """Shows the invite to user. It triggers a fade in effect."""
        self._plugin.logger.debug("Showing invite %s" % self.text)
        self.setWindowOpacity(0.0)

        self._animation.setDuration(500)
        self._animation.setStartValue(0.0)
        self._animation.setEndValue(1.0)

        # Map the notification to the bottom right corner
        pos = QPoint(self.parent().width() - 25, self.parent().height() - 50)
        pos = self.parent().mapToGlobal(pos)

        self.setGeometry(
            pos.x() - self.width(),
            pos.y() - self.height(),
            self.width(),
            self.height(),
        )
        super(Invite, self).show()

        self._animation.start()
        self._timer.start(3500)

    def hide(self):
        """Hides the invite only if it is fully transparent."""
        if self._popup_opacity == 0.0:
            self._plugin.interface.widget.refresh()
            super(Invite, self).hide()

    def hide_animation(self):
        """Hides the invite. It triggers the fade out animation."""
        self._timer.stop()
        self._animation.setDuration(500)
        self._animation.setStartValue(1.0)
        self._animation.setEndValue(0.0)
        self._animation.start()

    @Property(float)
    def popup_opacity(self):
        return self._popup_opacity

    @popup_opacity.setter
    def popup_opacity(self, opacity):
        self._popup_opacity = opacity
        self.setWindowOpacity(opacity)

```

`idarling/interface/painter.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import sys

import ida_funcs
import ida_kernwin

from PySide6.QtCore import (  # noqa: I202
    QAbstractItemModel,
    QModelIndex,
    QObject,
    Qt,
)
from PySide6.QtGui import QColor
from PySide6.QtWidgets import QStyledItemDelegate, QWidget
from shiboken6 import wrapInstance

from .widget import StatusWidget

if sys.version_info > (3,):
    long = int


class Painter(QObject):
    class ProxyItemDelegate(QStyledItemDelegate):
        def __init__(self, delegate, model, parent=None):
            super(Painter.ProxyItemDelegate, self).__init__(parent)
            self._delegate = delegate
            self._model = model

        def paint(self, painter, option, index):
            index = self._model.index(index.row(), index.column())
            self._delegate.paint(painter, option, index)

    class ProxyItemModel(QAbstractItemModel):
        def __init__(self, model, plugin, parent=None):
            super(Painter.ProxyItemModel, self).__init__(parent)
            self._model = model
            self._plugin = plugin

        def index(self, row, column, parent=QModelIndex()):
            return self.createIndex(row, column)

        def parent(self, index):
            index = self._model.index(index.row(), index.column())
            return self._model.parent(index)

        def rowCount(self):  # noqa: N802
            return self._model.rowCount()

        def columnCount(self):  # noqa: N802
            return self._model.columnCount()

        def data(self, index, role=Qt.DisplayRole):
            # Check if disabled by the user
            cursors = self._plugin.config["cursors"]
            if role == Qt.BackgroundRole and cursors["funcs"]:
                func_ea = int(index.sibling(index.row(), 2).data(), 16)
                func = ida_funcs.get_func(func_ea)
                for user in self._plugin.core.get_users().values():
                    if ida_funcs.func_contains(func, user["ea"]):
                        r, g, b = StatusWidget.ida_to_python(user["color"])
                        return QColor(StatusWidget.python_to_qt(r, g, b))
            index = self._model.index(index.row(), index.column())
            return self._model.data(index, role)

    def __init__(self, plugin):
        super(Painter, self).__init__()
        self._plugin = plugin

        self._ida_nav_colorizer = None
        self._nbytes = 0

    # XXX - unused since moved to Python3 in IDA due to errors in PySide6
    # "OverflowError: Python int too large to convert to C long"
    # See https://www.hex-rays.com/products/ida/support/idapython_docs/ida_kernwin-module.html#set_nav_colorizer
    def nav_colorizer(self, ea, nbytes):
        """This is the custom nav colorizer used by the painter."""
        self._nbytes = nbytes

        # There is a bug in IDA: with a huge number of segments, all the navbar
        # is colored with the user color. This will be resolved in IDA 7.2.
        # XXX - commented as error while loading in IDA >= 7.3
        #cursors = self._plugin.config["cursors"]
        #if cursors["navbar"]:
        #    for user in self._plugin.core.get_users().values():
        #        # Cursor color
        #        if ea - nbytes * 2 <= user["ea"] <= ea + nbytes * 2:
        #            return long(user["color"])
        #        # Cursor borders
        #        if ea - nbytes * 4 <= user["ea"] <= ea + nbytes * 4:
        #            return long(0)
        orig = ida_kernwin.call_nav_colorizer(
            self._ida_nav_colorizer, ea, nbytes
        )
        return long(orig)

    def ready_to_run(self):
        # The default nav colorized can only be recovered once!
        # XXX - commented, see above
        #ida_nav_colorizer = ida_kernwin.set_nav_colorizer(self.nav_colorizer)
        ida_nav_colorizer = None
        if ida_nav_colorizer is not None:
            self._ida_nav_colorizer = ida_nav_colorizer
        self.refresh()

    def get_ea_hint(self, ea):
        cursors = self._plugin.config["cursors"]
        if not cursors["navbar"]:
            return None

        for name, user in self._plugin.core.get_users().items():
            start_ea = user["ea"] - self._nbytes * 4
            end_ea = user["ea"] + self._nbytes * 4
            # Check if the navbar range contains the user's address
            if start_ea <= ea <= end_ea:
                return str(name)

    def get_bg_color(self, ea):
        # Check if disabled by the user
        cursors = self._plugin.config["cursors"]
        if not cursors["disasm"]:
            return None

        for user in self._plugin.core.get_users().values():
            if ea == user["ea"]:
                return user["color"]
        return None

    def widget_visible(self, twidget):
        widget = wrapInstance(int(twidget), QWidget)
        if widget.windowTitle() != "Functions window":
            return
        table = widget.layout().itemAt(0).widget()

        # Replace the table's item delegate
        model = Painter.ProxyItemModel(table.model(), self._plugin, self)
        old_deleg = table.itemDelegate()
        new_deleg = Painter.ProxyItemDelegate(old_deleg, model, self)
        table.setItemDelegate(new_deleg)

    def refresh(self):
        ida_kernwin.refresh_navband(True)
        ida_kernwin.request_refresh(ida_kernwin.IWID_DISASMS)
        ida_kernwin.request_refresh(ida_kernwin.IWID_FUNCS)

```

`idarling/interface/widget.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import colorsys
from functools import partial, lru_cache
import time

from PySide6.QtCore import QPoint, QRect, QSize, Qt, QTimer
from PySide6.QtGui import QAction, QActionGroup, QIcon, QImage, QPainter, QPixmap, QRegion
from PySide6.QtWidgets import QLabel, QMenu, QWidget

from .dialogs import SettingsDialog


class StatusWidget(QWidget):
    """
    This is the widget that is displayed in the status bar of the window. It
    allow the user to connect to server, as well as to access the settings.
    """

    @staticmethod
    def ida_to_python(c):
        # IDA colors are 0xBBGGRR.
        r = (c & 255) / 255.0
        g = ((c >> 8) & 255) / 255.0
        b = ((c >> 16) & 255) / 255.0
        return r, g, b

    @staticmethod
    def python_to_qt(r, g, b):
        # Qt colors are 0xRRGGBB
        r = int(r * 255) << 16
        g = int(g * 255) << 8
        b = int(b * 255)
        return 0xFF000000 | r | g | b

    @staticmethod
    @lru_cache(maxsize=32)
    def make_icon(template, color):
        """
        Create an icon for the specified user color. It will be used to
        generate on the fly an icon representing the user.
        """
        # Get a light and dark version of the user color
        r, g, b = StatusWidget.ida_to_python(color)
        h, l, s = colorsys.rgb_to_hls(r, g, b)
        r, g, b = colorsys.hls_to_rgb(h, 0.5, 1.0)
        light = StatusWidget.python_to_qt(r, g, b)
        r, g, b = colorsys.hls_to_rgb(h, 0.25, 1.0)
        dark = StatusWidget.python_to_qt(r, g, b)

        # Replace the icon pixel with our two colors
        image = QImage(template)
        for x in range(image.width()):
            for y in range(image.height()):
                c = image.pixel(x, y)
                if (c & 0xFFFFFF) == 0xFFFFFF:
                    image.setPixel(x, y, light)
                if (c & 0xFFFFFF) == 0x000000:
                    image.setPixel(x, y, dark)
        return QPixmap(image)

    def __init__(self, plugin):
        super(StatusWidget, self).__init__()
        self._plugin = plugin

        # Create the sub-widgets
        def new_label():
            widget = QLabel()
            widget.setAutoFillBackground(False)
            widget.setAttribute(Qt.WA_PaintOnScreen)
            widget.setAttribute(Qt.WA_TranslucentBackground)
            return widget

        self._servers_text_widget = new_label()
        self._servers_icon_widget = new_label()
        self._invites_text_widget = new_label()
        self._invites_icon_widget = new_label()
        self._users_text_widget = new_label()
        self._users_icon_widget = new_label()

        # Set a custom context menu policy
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self._context_menu)

        # Timer signaling it is time to update the widget
        self._timer = QTimer()
        self._timer.setInterval(1000)
        self._timer.timeout.connect(self.refresh)

    def install(self, window):
        self._plugin.logger.debug("Installing the status bar widget")
        window.statusBar().addPermanentWidget(self)
        self._timer.start()
        self.refresh()

    def uninstall(self, window):
        self._plugin.logger.debug("Uninstalling the status bar widget")
        window.statusBar().removeWidget(self)
        self._timer.stop()

    def refresh(self):
        """Called to update the widget when the network state has changed."""
        #self._plugin.logger.trace("Refreshing the status bar widget")

        # Get the corresponding color, text and icon
        if self._plugin.network.connected:
            color, text, icon = "green", "Connected", "connected.png"
        elif self._plugin.network.client:
            color, text, icon = "orange", "Connecting", "connecting.png"
        else:
            color, text, icon = "red", "Disconnected", "disconnected.png"

        # Update the text of the server widgets
        server = self._plugin.network.server
        if server is None:
            server = "&lt;no server&gt;"
        else:
            server = "%s:%d" % (server["host"], server["port"])
        text_format = '%s | %s -- <span style="color: %s;">%s</span>'
        self._servers_text_widget.setText(
            text_format % (self._plugin.description(), server, color, text)
        )
        self._servers_text_widget.adjustSize()

        # Update the icon of the server widgets
        pixmap = QPixmap(self._plugin.plugin_resource(icon))
        pixmap_height = self._servers_text_widget.sizeHint().height()
        self._servers_icon_widget.setPixmap(
            pixmap.scaled(
                pixmap_height,
                pixmap_height,
                Qt.KeepAspectRatio,
                Qt.SmoothTransformation,
            )
        )

        # Get all active invites
        invites = self._plugin.interface.invites
        # Find the most recent one
        most_recent = 0
        if invites:
            most_recent = max(invite.time for invite in invites)

        # Get the corresponding icon
        if most_recent > 0 and time.time() - most_recent < 60.0:
            icon = "hot.png"
        elif most_recent > 0 and time.time() - most_recent < 300.0:
            icon = "warm.png"
        elif most_recent > 0:
            icon = "cold.png"
        else:
            icon = "empty.png"

        # Update the text of the invites widgets
        self._invites_text_widget.setText(" | %d " % len(invites))
        self._invites_text_widget.adjustSize()

        # Update the icon of the invites widgets
        pixmap = QPixmap(self._plugin.plugin_resource(icon))
        pixmap_height = self._servers_text_widget.sizeHint().height()
        self._invites_icon_widget.setPixmap(
            pixmap.scaled(
                pixmap_height,
                pixmap_height,
                Qt.KeepAspectRatio,
                Qt.SmoothTransformation,
            )
        )

        # Update the text of the users widget
        users = len(self._plugin.core.get_users())
        self._users_text_widget.setText(" | %d" % users)
        self._users_text_widget.adjustSize()

        # Update the icon of the users widget
        template = self._plugin.plugin_resource("user.png")
        color = self._plugin.config["user"]["color"]
        pixmap = self.make_icon(template, color)
        pixmap_height = self._servers_text_widget.sizeHint().height()
        self._users_icon_widget.setPixmap(
            pixmap.scaled(
                pixmap_height,
                pixmap_height,
                Qt.KeepAspectRatio,
                Qt.SmoothTransformation,
            )
        )

        # Update the size of the widget
        self.updateGeometry()

    def sizeHint(self):  # noqa: N802
        """Called when the widget size is being determined internally."""
        width = 3 + self._servers_text_widget.sizeHint().width()
        width += 3 + self._servers_icon_widget.sizeHint().width()
        width += 3 + self._invites_text_widget.sizeHint().width()
        width += 3 + self._invites_icon_widget.sizeHint().width()
        width += 3 + self._users_text_widget.sizeHint().width()
        width += 3 + self._users_icon_widget.sizeHint().width()
        return QSize(width, self._servers_text_widget.sizeHint().height())

    def _context_menu(self, point):
        """Called when the context menu is being requested."""
        width_server = 3 + self._servers_text_widget.sizeHint().width()
        width_server += 3 + self._servers_icon_widget.sizeHint().width()
        width_invites = width_server
        width_invites += 3 + self._invites_text_widget.sizeHint().width()
        width_invites += 3 + self._invites_icon_widget.sizeHint().width()

        if point.x() < width_server + 3:
            self._servers_context_menu(point)
        elif width_server < point.x() < width_invites + 3:
            self._invites_context_menu(point)
        else:
            self._users_context_menu(point)

    def _servers_context_menu(self, point):
        """Populates the server context menu."""
        menu = QMenu(self)

        # Add the settings action
        settings = QAction("Settings...", menu)
        icon_path = self._plugin.plugin_resource("settings.png")
        settings.setIcon(QIcon(icon_path))

        # Add a handler on the action
        def settings_action_triggered():
            SettingsDialog(self._plugin).exec_()

        settings.triggered.connect(settings_action_triggered)
        menu.addAction(settings)

        # Add the integrated server action
        menu.addSeparator()
        integrated = QAction("Integrated Server", menu)
        integrated.setCheckable(True)

        def integrated_action_triggered():
            # Start or stop the server
            if integrated.isChecked():
                self._plugin.network.start_server()
            else:
                self._plugin.network.stop_server()

        integrated.setChecked(self._plugin.network.started)
        integrated.triggered.connect(integrated_action_triggered)
        menu.addAction(integrated)

        def create_servers_group(servers):
            """Create an action group for the specified servers."""
            servers_group = QActionGroup(self)
            current_server = self._plugin.network.server

            for server in servers:
                is_connected = (
                    current_server is not None
                    and server["host"] == current_server["host"]
                    and server["port"] == current_server["port"]
                )
                server_text = "%s:%d" % (server["host"], server["port"])
                server_action = QAction(server_text, menu)
                server_action._server = server
                server_action.setCheckable(True)
                server_action.setChecked(is_connected)
                servers_group.addAction(server_action)

            def server_action_triggered(server_action):
                """
                Called when a action is clicked. Connects to the new server
                or disconnects from the old server.
                """
                server = server_action._server
                was_connected = self._plugin.network.server == server
                self._plugin.network.stop_server()
                self._plugin.network.disconnect()
                if not was_connected:
                    self._plugin.network.connect(server)

            servers_group.triggered.connect(server_action_triggered)

            return servers_group

        # Add the discovered servers
        user_servers = self._plugin.config["servers"]
        disc_servers = self._plugin.network.discovery.servers
        disc_servers = [s for s, t in disc_servers if time.time() - t < 10.0]
        disc_servers = [s for s in disc_servers if s not in user_servers]
        if (
            self._plugin.network.started
            and self._plugin.network.server in disc_servers
        ):
            disc_servers.remove(self._plugin.network.server)
        if disc_servers:
            menu.addSeparator()
            servers_group = create_servers_group(disc_servers)
            menu.addActions(servers_group.actions())

        # Add the configured servers
        if user_servers:
            menu.addSeparator()
            servers_group = create_servers_group(user_servers)
            menu.addActions(servers_group.actions())

        # Show the context menu
        menu.exec_(self.mapToGlobal(point))

    def _invites_context_menu(self, point):
        """Populate the invites context menu."""
        menu = QMenu(self)

        # Get all active invites
        invites = self._plugin.interface.invites
        # Sort invites by time ascending
        invites = sorted(invites, key=lambda x: x.time)

        clear = QAction("Clear invites", menu)
        icon_path = self._plugin.plugin_resource("clear.png")
        clear.setIcon(QIcon(icon_path))
        clear.triggered.connect(self._plugin.interface.clear_invites)
        clear.setEnabled(bool(invites))
        menu.addAction(clear)

        if invites:
            menu.addSeparator()

            # Add an action for each invite
            for invite in invites:
                action = QAction(invite.text, menu)
                action.setIcon(QIcon(invite.icon))

                def action_triggered():
                    if invite.callback:
                        invite.callback()
                    invite.triggered = True
                    self.refresh()

                action.triggered.connect(action_triggered)
                menu.addAction(action)

        # Show the context menu
        menu.exec_(self.mapToGlobal(point))

    def _users_context_menu(self, point):
        """Populate the invites context menu."""
        menu = QMenu(self)

        template = self._plugin.plugin_resource("user.png")

        users = self._plugin.core.get_users()
        follow_all = QAction("Follow all", menu)
        pixmap = QPixmap(self._plugin.plugin_resource("users.png"))
        follow_all.setIcon(QIcon(pixmap))
        follow_all.setEnabled(bool(users))
        follow_all.setCheckable(True)
        follow_all.setChecked(self._plugin.interface.followed == "everyone")

        def follow_triggered(name):
            interface = self._plugin.interface
            interface.followed = name if interface.followed != name else None

        follow_all.triggered.connect(partial(follow_triggered, "everyone"))
        menu.addAction(follow_all)
        if users:
            menu.addSeparator()

            # Get all active users
            for name, user in users.items():
                is_followed = self._plugin.interface.followed == name
                text = "Follow %s" % name
                action = QAction(text, menu)
                action.setCheckable(True)
                action.setChecked(is_followed)
                pixmap = StatusWidget.make_icon(template, user["color"])
                action.setIcon(QIcon(pixmap))

                action.triggered.connect(partial(follow_triggered, name))
                menu.addAction(action)

        menu.exec_(self.mapToGlobal(point))

    def paintEvent(self, event):  # noqa: N802
        """Called when the widget is being painted."""
        # Adjust the buffer size according to the pixel ratio
        dpr = self.devicePixelRatioF()
        buffer = QPixmap(int(self.width() * dpr), int(self.height() * dpr))
        buffer.setDevicePixelRatio(dpr)
        buffer.fill(Qt.transparent)

        painter = QPainter(buffer)

        # Paint the server text widget
        region = QRegion(
            QRect(QPoint(0, 0), self._servers_text_widget.sizeHint())
        )
        self._servers_text_widget.render(painter, QPoint(0, 0), region)
        # Paint the server icon widget
        region = QRegion(
            QRect(QPoint(0, 0), self._servers_icon_widget.sizeHint())
        )
        x = self._servers_text_widget.sizeHint().width() + 3
        self._servers_icon_widget.render(painter, QPoint(x, 0), region)
        # Paint the invites text widget
        region = QRegion(
            QRect(QPoint(0, 0), self._invites_text_widget.sizeHint())
        )
        x += self._servers_icon_widget.sizeHint().width() + 3
        self._invites_text_widget.render(painter, QPoint(x, 0), region)
        # Paint the invites icon widget
        region = QRegion(
            QRect(QPoint(0, 0), self._invites_icon_widget.sizeHint())
        )
        x += self._invites_text_widget.sizeHint().width() + 3
        self._invites_icon_widget.render(painter, QPoint(x, 0), region)
        # Paint the users text widget
        region = QRegion(
            QRect(QPoint(0, 0), self._users_text_widget.sizeHint())
        )
        x += self._invites_icon_widget.sizeHint().width() + 3
        self._users_text_widget.render(painter, QPoint(x, 0), region)
        # Paint the users icon widget
        region = QRegion(
            QRect(QPoint(0, 0), self._users_icon_widget.sizeHint())
        )
        x += self._users_text_widget.sizeHint().width() + 3
        self._users_icon_widget.render(painter, QPoint(x, 0), region)
        painter.end()

        painter = QPainter(self)
        painter.drawPixmap(event.rect(), buffer, buffer.rect())
        painter.end()

```

`idarling/module.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.


class Module(object):
    """
    The plugin is organized into modules. Modules allow grouping the
    functionality of the plugin and facilitate information communication.
    """

    def __init__(self, plugin):
        self._plugin = plugin
        self._installed = False

    def install(self):
        """Install the module. Called by the plugin."""
        if self._installed:
            return False
        self._installed = True
        return self._install()

    def _install(self):
        """Install the module. Overloaded by the module."""
        raise NotImplementedError("_install() not implemented")

    def uninstall(self):
        """Uninstall the module. Called by the plugin."""
        if not self._installed:
            return False
        self._installed = False
        return self._uninstall()

    def _uninstall(self):
        """Uninstall the module. Overloaded by the module."""
        raise NotImplementedError("_uninstall() not implemented")

```

`idarling/network/client.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import ida_auto
import ida_kernwin

from PySide6.QtGui import QImage, QPixmap  # noqa: I202

from ..interface.widget import StatusWidget
from ..shared.commands import (
    DownloadFile,
    InviteToLocation,
    JoinSession,
    LeaveSession,
    UpdateLocation,
    UpdateUserColor,
    UpdateUserName,
    DeleteProject,
    DeleteBinary,
    DeleteSnapshot,
)
from ..shared.packets import Command, Event
from ..shared.sockets import ClientSocket


class Client(ClientSocket):
    """
    This class represents a client socket for the client. It implements all the
    handlers for the packet the server is susceptible to send.
    """

    def __init__(self, plugin, parent=None):
        ClientSocket.__init__(self, plugin.logger, parent)
        self._plugin = plugin
        self._events = []

        # Setup command handlers
        self._handlers = {
            JoinSession: self._handle_join_session,
            LeaveSession: self._handle_leave_session,
            UpdateLocation: self._handle_update_location,
            InviteToLocation: self._handle_invite_to_location,
            UpdateUserName: self._handle_update_user_name,
            UpdateUserColor: self._handle_update_user_color,
            DownloadFile.Query: self._handle_download_file,
            DeleteProject: self._handle_delete_project,
            DeleteBinary: self._handle_delete_binary,
            DeleteSnapshot: self._handle_delete_snapshot,
        }

    def call_events(self):
        while self._events and ida_auto.get_auto_state() == ida_auto.AU_NONE:
            packet = self._events.pop(0)
            self._call_event(packet)

    def _call_event(self, packet):
        self._plugin.core.unhook_all()

        try:
            packet()
        except Exception as e:
            self._logger.warning("Error while calling event")
            self._logger.exception(e)

        self._plugin.core.hook_all()

        # Check for de-synchronization
        if self._plugin.core.tick >= packet.tick:
            self._logger.warning("De-synchronization detected!")
            packet.tick = self._plugin.core.tick
        self._plugin.core.tick = packet.tick
        self._plugin.logger.debug("returning from call_event")

    def recv_packet(self, packet):
        if isinstance(packet, Command):
            # Call the corresponding handler
            self._handlers[packet.__class__](packet)

        elif isinstance(packet, Event):
            # If we already have some events queued
            if self._events or ida_auto.get_auto_state() != ida_auto.AU_NONE:
                self._events.append(packet)
            else:
                self._call_event(packet)

        else:
            return False
        return True

    def send_packet(self, packet):
        if isinstance(packet, Event):
            self._plugin.core.tick += 1
            packet.tick = self._plugin.core.tick
        return ClientSocket.send_packet(self, packet)

    def terminate(self, err=None):
        ret = ClientSocket.close_connection(self, err)
        self._plugin.network._client = None
        self._plugin.network._server = None

        # Update the user interface
        self._plugin.interface.update()
        self._plugin.interface.clear_invites()
        return ret

    def _check_socket(self):
        was_connected = self._connected
        ret = ClientSocket._check_socket(self)
        if not was_connected and self._connected:
            # Update the user interface
            self._plugin.interface.update()
            # Subscribe to the events
            self._plugin.core.join_session()
        return ret

    def _handle_join_session(self, packet):
        # Update the users list
        user = {"color": packet.color, "ea": packet.ea}
        self._plugin.core.add_user(packet.name, user)

        # Show a toast notification
        if packet.silent:
            return
        text = "%s joined the session" % packet.name
        template = self._plugin.plugin_resource("user.png")
        icon = StatusWidget.make_icon(template, packet.color)
        self._plugin.interface.show_invite(text, icon)

    def _handle_leave_session(self, packet):
        # Update the users list
        user = self._plugin.core.remove_user(packet.name)
        # Refresh the users count
        self._plugin.interface.widget.refresh()

        # Show a toast notification
        if packet.silent:
            return
        text = "%s left the session" % packet.name
        template = self._plugin.plugin_resource("user.png")
        icon = StatusWidget.make_icon(template, user["color"])
        self._plugin.interface.show_invite(text, icon)

    def _handle_invite_to_location(self, packet):
        # Show a toast notification
        text = "%s - Jump to %#x" % (packet.name, packet.loc)
        icon = self._plugin.plugin_resource("location.png")

        def callback():
            ida_kernwin.jumpto(packet.loc)

        self._plugin.interface.show_invite(text, QPixmap(icon), callback)

    def _handle_update_user_name(self, packet):
        # Update the users list
        user = self._plugin.core.remove_user(packet.old_name)
        self._plugin.core.add_user(packet.new_name, user)

    def _handle_update_user_color(self, packet):
        # Update the users list
        user = self._plugin.core.get_user(packet.name)
        user["color"] = packet.new_color
        self._plugin.core.add_user(packet.name, user)

    def _handle_update_location(self, packet):
        # Update the users list
        user = self._plugin.core.get_user(packet.name)
        user["ea"] = packet.ea
        self._plugin.core.add_user(packet.name, user)

        followed = self._plugin.interface.followed
        if followed == packet.name or followed == "everyone":
            ida_kernwin.jumpto(packet.ea)

    def _handle_download_file(self, query):
        # Upload the current snapshot
        self._plugin.interface.save_action.handler.upload_file(
            self._plugin, DownloadFile.Reply(query)
        )

    def _handle_delete_project(self, packet):
        # TODO: Handle situation then user snapshot in deleted project
        self.terminate()

    def _handle_delete_binary(self, packet):
        # TODO: Handle situation then user snapshot in deleted binary
        self.terminate()

    def _handle_delete_snapshot(self, packet):
        # TODO: Handle situation then user snapshot deleted
        self.terminate()
```

`idarling/network/network.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import errno
import os
import socket
import ssl

from .client import Client
from .server import IntegratedServer
from ..module import Module
from ..shared.discovery import ServersDiscovery

fDebug = False
if fDebug:
    import pydevd_pycharm


class Network(Module):
    """
    This is the interface module. It is responsible for interacting with the
    server over the network. It manages the three sockets used with the plugin
    (client, discovery client, integrated server).
    """

    def __init__(self, plugin):
        super(Network, self).__init__(plugin)
        self._discovery = ServersDiscovery(plugin.logger)

        self._client = None
        self._server = None
        self._integrated = None

    @property
    def client(self):
        return self._client

    @property
    def server(self):
        return self._server

    @property
    def discovery(self):
        return self._discovery

    @property
    def connected(self):
        return self._client.connected if self._client else False

    @property
    def started(self):
        return bool(self._integrated)

    def _install(self):
        self._discovery.start()
        return True

    def _uninstall(self):
        self._discovery.stop()
        self.disconnect()
        return True

    def connect(self, server):
        if fDebug:
            pydevd_pycharm.settrace('localhost', port=2233, stdoutToServer=True, stderrToServer=True, suspend=True)
        """Connect to the specified server."""
        # Make sure we're not already connected
        if self._client:
            return

        self._client = Client(self._plugin)
        self._server = server.copy()  # Make a copy
        host = self._server["host"]
        if host == "0.0.0.0":  # Windows can't connect to 0.0.0.0
            host = "127.0.0.1"
        port = self._server["port"]
        no_ssl = self._server["no_ssl"]

        # Update the user interface
        self._plugin.interface.update()
        self._plugin.logger.info("Connecting to %s:%d..." % (host, port))

        # Create a new socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        # Wrap the socket in a SSL tunnel
        if not no_ssl:
            ctx = ssl.create_default_context()
            # XXX - add SSL cert/hostname check or support both through setting
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            sock = ctx.wrap_socket(
                sock, server_hostname=host, do_handshake_on_connect=True
            )
        self._client.wrap_socket(sock)

        # Set TCP keep-alive options
        cnt = self._plugin.config["keep"]["cnt"]
        intvl = self._plugin.config["keep"]["intvl"]
        idle = self._plugin.config["keep"]["idle"]
        self._client.set_keep_alive(cnt, intvl, idle)

        # Connect the socket
        sock.settimeout(0)  # No timeout
        sock.setblocking(0)  # No blocking
        try:
            err = sock.connect_ex((host, port))
            if err not in (0, errno.EINPROGRESS, errno.EWOULDBLOCK):
                raise OSError(err, os.strerror(err), '')
        except OSError as e:
            self._plugin._logger.exception(e)
            self._client.terminate()

    def disconnect(self):
        """Disconnect from the current server."""
        # Make sure we aren't already disconnected
        if not self._client:
            return

        self._plugin.logger.info("Disconnecting...")
        self._client.terminate()

    def send_packet(self, packet):
        """Send a packet to the server."""
        if self.connected:
            return self._client.send_packet(packet)
        return None

    def start_server(self):
        """Start the integrated server."""
        if self._integrated:
            return

        self._plugin.logger.info("Starting the integrated server...")
        server = IntegratedServer(self._plugin)
        if not server.start("0.0.0.0"):
            return  # Couldn't start the server
        self._integrated = server
        integrated_arg = {
            "host": "0.0.0.0",
            "port": server.port,
            "no_ssl": True,
        }
        # Connect the client to the server
        self.disconnect()
        self.connect(integrated_arg)

    def stop_server(self):
        """Stop the integrated server."""
        if not self._integrated:
            return

        self._plugin.logger.info("Stopping the integrated server...")
        self.disconnect()
        self._integrated.stop()
        self._integrated = None

```

`idarling/network/server.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
from ..shared.server import Server


class IntegratedServer(Server):
    """
    The integrated server inherits the logic from Server. It simply needs to
    define the server_file method to indicate where to save the databases.
    """

    def __init__(self, plugin, parent=None):
        self._plugin = plugin
        Server.__init__(self, plugin.logger, parent)

    def server_file(self, filename):
        return self._plugin.user_resource("files", filename)

```

`idarling/plugin.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import colorsys
import json
import logging
import os
import random

import ida_diskio
import ida_idaapi
import ida_kernwin

from .core.core import Core
from .interface.interface import Interface
from .network.network import Network
from .shared.utils import start_logging




class IdarlingPlugin(ida_idaapi.plugin_t):
    """
    This is the main class of the plugin. It subclasses plugin_t as required
    by IDA. It holds the modules of plugin, which themselves provides the
    functionality of the plugin (hooking/events, interface, networking, etc.).
    """

    # Mandatory definitions
    PLUGIN_NAME = "IDArling"
    PLUGIN_VERSION = "0.0.3"
    PLUGIN_AUTHORS = "The IDArling Team"

    # These flags specify that the plugin should persist between databases
    # loading and saving, and should not have a menu entry.
    flags = ida_idaapi.PLUGIN_FIX | ida_idaapi.PLUGIN_HIDE
    comment = "Collaborative Reverse Engineering plugin"
    help = ""
    wanted_name = PLUGIN_NAME
    wanted_hotkey = ""

    @staticmethod
    def description():
        """Return the description displayed in the console."""
        return "{} v{}".format(IdarlingPlugin.PLUGIN_NAME, IdarlingPlugin.PLUGIN_VERSION)

    @staticmethod
    def plugin_resource(filename):
        """
        Return the absolute path to a plugin resource located within the
        plugin's installation folder (should be within idarling/resources).
        """
        plugin_path = os.path.abspath(os.path.dirname(__file__))
        return os.path.join(plugin_path, "resources", filename)

    @staticmethod
    def user_resource(directory, filename):
        """
        Return the absolute path to a resource located in the user directory.
        It should be:
        * %APPDATA%\\Roaming\\Hex-Rays\\IDA Pro\\plugin\\idarling under Windows
        * $HOME/.idapro/plugins/idarling under Linux and MacOS.
        """
        user_dir = ida_diskio.get_user_idadir()
        plug_dir = os.path.join(user_dir, "plugins")
        local_dir = os.path.join(plug_dir, "idarling")
        res_dir = os.path.join(local_dir, directory)
        if not os.path.exists(res_dir):
            os.makedirs(res_dir, 493)  # 0755
        return os.path.join(res_dir, filename)

    @staticmethod
    def default_config():
        """
        Return the default configuration options. This is used to initialize
        the configuration file the first time the plugin is launched, and also
        when the user is resetting the settings via the dialog.
        """
        r, g, b = colorsys.hls_to_rgb(random.random(), 0.5, 1.0)
        color = int(b * 255) << 16 | int(g * 255) << 8 | int(r * 255)
        file_path = IdarlingPlugin.user_resource("files", "")
        return {
            "level": logging.INFO,
            "servers": [],
            "keep": {"cnt": 4, "intvl": 15, "idle": 240},
            "cursors": {"navbar": True, "funcs": True, "disasm": True},
            "user": {"color": color, "name": "unnamed", "notifications": True},
            "files_dir": file_path,
        }

    def __init__(self):
        # Check if the plugin is running with IDA terminal
        if not ida_kernwin.is_idaq():
            raise RuntimeError("IDArling cannot be used in terminal mode")

        # Load the default configuration
        self._config = self.default_config()
        # Then setup the default logger
        log_path = self.user_resource("logs", "idarling.%s.log" % os.getpid())
        level = self.config["level"]
        self._logger = start_logging(log_path, "IDArling.IdarlingPlugin", level)

        self._core = Core(self)
        self._interface = Interface(self)
        self._network = Network(self)

    @property
    def config(self):
        return self._config

    @property
    def logger(self):
        return self._logger

    @property
    def core(self):
        return self._core

    @property
    def interface(self):
        return self._interface

    @property
    def network(self):
        return self._network

    def init(self):
        """
        This method is called when IDA is loading the plugin. It will first
        load the configuration file, then initialize all the modules.
        """

        try:
            self.load_config()

            self._interface.install()
            self._network.install()
            self._core.install()
        except Exception as e:
            self._logger.error("Failed to initialize")
            self._logger.exception(e)
            skip = ida_idaapi.PLUGIN_SKIP
            return skip

        self._print_banner()
        self._logger.info("Initialized properly")
        keep = ida_idaapi.PLUGIN_KEEP

        self._auto_connect()

        return keep

    def _auto_connect(self):
        for server in self._config["servers"]:
            if "auto_connect" in server and server["auto_connect"]:
                self.logger.info("Attempting to auto-connect to {}:{}".format(
                                 server["host"], server["port"]))
                self._network.connect(server)

    def _print_banner(self):
        """Print the banner that you see in the console."""
        copyright = "(c) %s" % self.PLUGIN_AUTHORS
        self._logger.info("-" * 75)
        self._logger.info("%s - %s" % (self.description(), copyright))
        self._logger.info("-" * 75)

    def term(self):
        """
        This method is called when IDA is unloading the plugin. It will
        terminated all the modules, then save the configuration file.
        """
        try:
            self._core.uninstall()
            self._network.uninstall()
            self._interface.uninstall()

            self.save_config()
        except Exception as e:
            self._logger.error("Failed to terminate properly")
            self._logger.exception(e)
            return

        self._logger.info("Terminated properly")

    def run(self, _):
        """
        This method is called when IDA is running the plugin as a script.
        Because IDArling isn't runnable per se, we need to return False.
        """
        ida_kernwin.warning("IDArling cannot be run as a script")
        return False

    def load_config(self):
        """
        Load the configuration file. It is a JSON file that contains all the
        settings of the plugin. The configured log level is set here.
        """
        config_path = self.user_resource("files", "config.json")
        if not os.path.isfile(config_path):
            return
        with open(config_path, "rb") as config_file:
            try:
                self._config.update(json.loads(config_file.read()))
            except ValueError:
                self._logger.warning("Couldn't load config file")
                return
            self._logger.setLevel(self._config["level"])
            self._logger.debug("Loaded config: %s" % self._config)

        # Gracefully handle older configs with missing settings
        self.retrofit_config()

    def retrofit_config(self):
        """
        As more and more config options are added we need to gracefully handle
        older configs that would otherwise cause errors.
        """

        count = 0
        for server in self._config["servers"]:
            if "auto_connect" not in server:
                self._config["servers"][count]["auto_connect"] = False
            count += 1

        self.save_config()

    def save_config(self):
        """Save the configuration file."""
        config_path = self.user_resource("files", "config.json")
        with open(config_path, "w") as config_file:
            config_file.write(json.dumps(self._config))
            self._logger.debug("Saved config: %s" % self._config)

```

`idarling/server.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import argparse
import os
import signal
import sys
import traceback

from PySide6.QtCore import QCoreApplication, QTimer

from .shared.server import Server
from .shared.utils import start_logging


class DedicatedServer(Server):
    """
    This is the dedicated/standalone server. It can be invoked from the command line. It
    requires only PySide6 and should be invoked from Python 3. The dedicated
    server should be used when the integrated doesn't fulfil the user's needs.
    """

    def __init__(self, level, parent=None):
        # Get the path to the log file
        log_dir = os.path.join(os.path.dirname(__file__), "logs")
        log_dir = os.path.abspath(log_dir)
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
        log_path = os.path.join(log_dir, "idarling.%s.log" % os.getpid())

        logger = start_logging(log_path, "IDArling.Server", level)
        Server.__init__(self, logger, parent, level)

    def server_file(self, filename):
        """
        This function returns the absolute path to a server's file. It should
        be located within a files/ subdirectory of the current directory.
        """
        files_dir = os.path.join(os.path.dirname(__file__), "files")
        files_dir = os.path.abspath(files_dir)
        if not os.path.exists(files_dir):
            os.makedirs(files_dir)
        return os.path.join(files_dir, filename)


def start(args):
    app = QCoreApplication(sys.argv)
    sys.excepthook = traceback.print_exception

    server = DedicatedServer(args.level)
    server.SNAPSHOT_INTERVAL = args.interval
    server.start(args.host, args.port, args.ssl)

    # Allow the use of Ctrl-C to stop the server
    def sigint_handler(_, __):
        server.stop()
        app.exit(0)

    signal.signal(signal.SIGINT, sigint_handler)

    # This timer gives the application a chance to be interrupted every 50 ms
    # even if it stuck in a loop or something
    def safe_timer(timeout, func, *args, **kwargs):
        def timer_event():
            try:
                func(*args, **kwargs)
            finally:
                QTimer.singleShot(timeout, timer_event)

        QTimer.singleShot(timeout, timer_event)

    safe_timer(50, lambda: None)

    return app.exec_()


def main():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument(
        "--help", action="help", help="show this help message and exit"
    )

    # Users can specify the host and port to start the server on
    parser.add_argument(
        "-h",
        "--host",
        type=str,
        default="127.0.0.1",
        help="the hostname to start listening on",
    )
    parser.add_argument(
        "-p",
        "--port",
        type=int,
        default=31013,
        help="the port to start listening on",
    )

    # Users must specify the path to the certificate chain and the
    # corresponding private key of the server, or disable SSL altogether.
    security = parser.add_mutually_exclusive_group(required=True)
    security.add_argument(
        "--ssl",
        type=str,
        nargs=2,
        metavar=("fullchain.pem", "privkey.pem"),
        help="the certificate and private key files",
    )
    security.add_argument(
        "--no-ssl", action="store_true", help="disable SSL (not recommended)"
    )

    # Users can also change the logging level if the they want some debug
    levels = ["CRITICAL", "ERROR", "WARNING", "INFO", "DEBUG", "TRACE"]
    parser.add_argument(
        "-l",
        "--level",
        type=str,
        choices=levels,
        default=None,
        help="the log level",
    )

    # Interval in ticks between database snapshot
    parser.add_argument(
        "-i",
        "--interval",
        type=int,
        default=0,
        help="database snapshot interval",
    )

    start(parser.parse_args())

```

`idarling/shared/commands.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
from .models import Project, Binary, Snapshot
from .packets import (
    Command,
    Container,
    DefaultCommand,
    ParentCommand,
    Query as IQuery,
    Reply as IReply,
)


class ListProjects(ParentCommand):
    __command__ = "list_projects"

    class Query(IQuery, DefaultCommand):
        pass

    class Reply(IReply, Command):
        def __init__(self, query, projects):
            super(ListProjects.Reply, self).__init__(query)
            self.projects = projects

        def build_command(self, dct):
            dct["projects"] = [project.build({}) for project in self.projects]

        def parse_command(self, dct):
            self.projects = [
                Project.new(project) for project in dct["projects"]
            ]


class ListBinaries(ParentCommand):
    __command__ = "list_binaries"

    class Query(IQuery, DefaultCommand):
        def __init__(self, project):
            super(ListBinaries.Query, self).__init__()
            self.project = project

    class Reply(IReply, Command):
        def __init__(self, query, binaries):
            super(ListBinaries.Reply, self).__init__(query)
            self.binaries = binaries

        def build_command(self, dct):
            dct["binaries"] = [binary.build({}) for binary in self.binaries]

        def parse_command(self, dct):
            self.binaries = [
                Binary.new(binary) for binary in dct["binaries"]
            ]


class ListSnapshots(ParentCommand):
    __command__ = "list_snapshots"

    class Query(IQuery, DefaultCommand):
        def __init__(self, project, binary):
            super(ListSnapshots.Query, self).__init__()
            self.project = project
            self.binary = binary

    class Reply(IReply, Command):
        def __init__(self, query, snapshots):
            super(ListSnapshots.Reply, self).__init__(query)
            self.snapshots = snapshots

        def build_command(self, dct):
            dct["snapshots"] = [
                snapshot.build({}) for snapshot in self.snapshots
            ]

        def parse_command(self, dct):
            self.snapshots = [
                Snapshot.new(snapshot) for snapshot in dct["snapshots"]
            ]


class CreateProject(ParentCommand):
    __command__ = "create_project"

    class Query(IQuery, Command):
        def __init__(self, project):
            super(CreateProject.Query, self).__init__()
            self.project = project

        def build_command(self, dct):
            self.project.build(dct["project"])

        def parse_command(self, dct):
            self.project = Project.new(dct["project"])

    class Reply(IReply, Command):
        pass


class DeleteProject(ParentCommand):
    __command__ = "delete_project"

    class Query(IQuery, DefaultCommand):
        def __init__(self, project):
            super(DeleteProject.Query, self).__init__()
            self.project = project

    class Reply(IReply, DefaultCommand):
        def __init__(self, query, deleted):
            super(DeleteProject.Reply, self).__init__(query)
            self.deleted = deleted

class CreateBinary(ParentCommand):
    __command__ = "create_binary"

    class Query(IQuery, Command):
        def __init__(self, binary):
            super(CreateBinary.Query, self).__init__()
            self.binary = binary

        def build_command(self, dct):
            self.binary.build(dct["binary"])

        def parse_command(self, dct):
            self.binary = Binary.new(dct["binary"])

    class Reply(IReply, Command):
        pass

class DeleteBinary(ParentCommand):
    __command__ = "delete_binary"

    class Query(IQuery, DefaultCommand):
        def __init__(self, project, binary):
            super(DeleteBinary.Query, self).__init__()
            self.project = project
            self.binary = binary

    class Reply(IReply, DefaultCommand):
        def __init__(self, query, deleted):
            super(DeleteBinary.Reply, self).__init__(query)
            self.deleted = deleted


class CreateSnapshot(ParentCommand):
    __command__ = "create_snapshot"

    class Query(IQuery, Command):
        def __init__(self, snapshot):
            super(CreateSnapshot.Query, self).__init__()
            self.snapshot = snapshot

        def build_command(self, dct):
            self.snapshot.build(dct["snapshot"])

        def parse_command(self, dct):
            self.snapshot = Snapshot.new(dct["snapshot"])

    class Reply(IReply, Command):
        pass

class DeleteSnapshot(ParentCommand):
    __command__ = "delete_snapshot"

    class Query(IQuery, DefaultCommand):
        def __init__(self, project, binary, snapshot):
            super(DeleteSnapshot.Query, self).__init__()
            self.project = project
            self.binary = binary
            self.snapshot = snapshot

    class Reply(IReply, DefaultCommand):
        def __init__(self, query, deleted):
            super(DeleteSnapshot.Reply, self).__init__(query)
            self.deleted = deleted

class UpdateFile(ParentCommand):
    __command__ = "update_file"

    class Query(IQuery, Container, DefaultCommand):
        def __init__(self, project, binary, snapshot):
            super(UpdateFile.Query, self).__init__()
            self.project = project
            self.binary = binary
            self.snapshot = snapshot

    class Reply(IReply, Command):
        pass


class DownloadFile(ParentCommand):
    __command__ = "download_file"

    class Query(IQuery, DefaultCommand):
        def __init__(self, project, binary, snapshot):
            super(DownloadFile.Query, self).__init__()
            self.project = project
            self.binary = binary
            self.snapshot = snapshot

    class Reply(IReply, Container, Command):
        pass

class RenameBinary(ParentCommand):
    __command__ = "rename_binary"

    class Query(IQuery, DefaultCommand):
        def __init__(self, project, old_name, new_name):
            super(RenameBinary.Query, self).__init__()
            self.project = project
            self.old_name = old_name
            self.new_name = new_name

    class Reply(IReply, Command):
        def __init__(self, query, binaries, renamed):
            super(RenameBinary.Reply, self).__init__(query)
            self.binaries = binaries
            self.renamed = renamed

        def build_command(self, dct):
            dct["renamed"] = self.renamed
            dct["binaries"] = [binary.build({}) for binary in self.binaries]

        def parse_command(self, dct):
            self.renamed = dct["renamed"]
            self.binaries = [
                Binary.new(binary) for binary in dct["binaries"]
            ]

class JoinSession(DefaultCommand):
    __command__ = "join_session"

    def __init__(self, project, binary, snapshot, tick, name, color, ea, silent=True):
        super(JoinSession, self).__init__()
        self.project = project
        self.binary = binary
        self.snapshot = snapshot
        self.tick = tick
        self.name = name
        self.color = color
        self.ea = ea
        self.silent = silent


class LeaveSession(DefaultCommand):
    __command__ = "leave_session"

    def __init__(self, name, silent=True):
        super(LeaveSession, self).__init__()
        self.name = name
        self.silent = silent


class UpdateUserName(DefaultCommand):
    __command__ = "update_user_name"

    def __init__(self, old_name, new_name):
        super(UpdateUserName, self).__init__()
        self.old_name = old_name
        self.new_name = new_name


class UpdateUserColor(DefaultCommand):
    __command__ = "update_user_color"

    def __init__(self, name, old_color, new_color):
        super(UpdateUserColor, self).__init__()
        self.name = name
        self.old_color = old_color
        self.new_color = new_color


class UpdateLocation(DefaultCommand):
    __command__ = "update_location"

    def __init__(self, name, ea, color):
        super(UpdateLocation, self).__init__()
        self.name = name
        self.ea = ea
        self.color = color


class InviteToLocation(DefaultCommand):
    __command__ = "invite_to_location"

    def __init__(self, name, loc):
        super(InviteToLocation, self).__init__()
        self.name = name
        self.loc = loc

```

`idarling/shared/discovery.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import platform
import socket
import time
import errno

from PySide6.QtCore import QObject, QSocketNotifier, QTimer


DISCOVERY_REQUEST = "IDARLING_DISCOVERY_REQUEST"
DISCOVERY_REPLY = "IDARLING_DISCOVERY_REPLY"


class ClientsDiscovery(QObject):
    """
    This class is used by the server to discover client on the local network.
    It uses an UDP socket broadcasting the server hostname and port on the
    port 31013. A client will reply back with a simple message.
    """

    def __init__(self, logger, parent=None):
        super(ClientsDiscovery, self).__init__(parent)
        self._logger = logger
        self._info = None

        self._socket = None
        self._read_notifier = None
        self._started = False

        # Timer signaling that it's time to broadcast
        self._timer = QTimer()
        self._timer.setInterval(10000)
        self._timer.timeout.connect(self._send_request)

    def start(self, host, port, ssl):
        """Start the discovery process and broadcast the given information."""
        self._logger.debug("Starting clients discovery")
        ssl_used = False
        if ssl is not None:
            ssl_used = True
        self._info = "%s %d %s" % (host, port, str(ssl_used))
        # Create a datagram socket capable of broadcasting
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        self._socket.settimeout(0)  # No timeout
        self._socket.setblocking(0)  # No blocking

        self._read_notifier = QSocketNotifier(
            self._socket.fileno(), QSocketNotifier.Read, self
        )
        self._read_notifier.activated.connect(self._notify_read)
        self._read_notifier.setEnabled(True)
        self._started = True
        self._timer.start()
        self._send_request()

    def stop(self):
        """Stop the discovery process."""
        self._logger.debug("Stopping clients discovery")
        self._read_notifier.setEnabled(False)
        if self._socket:
            try:
                self._socket.close()
            except socket.error:
                pass
        self._socket = None
        self._started = False
        self._timer.stop()

    def _send_request(self):
        """This function sends to discovery request packets."""
        # This is very verbose as it triggers every 1 sec so only enable when debugging
        #self._logger.trace("Sending discovery request")
        request = DISCOVERY_REQUEST + " " + self._info
        request = request.encode("utf-8")
        while len(request):
            try:
                self._socket.setblocking(0)
                sent = self._socket.sendto(
                    request, 0, ("<broadcast>", 31013)
                )
                request = request[sent:]
            except socket.error as e:
                # Some systems may not be able to broadcast on all interfaces
                # ("No route to host" / network unreachable). Don't spam
                # warnings for those expected transient errors.
                err_no = getattr(e, "errno", None)
                if err_no in (errno.EHOSTUNREACH, errno.ENETUNREACH):
                    self._logger.debug("Couldn't send discovery request (network unreachable): {}".format(e))
                else:
                    self._logger.warning("Couldn't send discovery request: {}".format(e))
                # Force return, otherwise the while loop will halt IDA
                return

    def _notify_read(self):
        """This function is called when a discovery reply is received."""
        response, address = self._socket.recvfrom(4096)
        response = response.decode("utf-8")
        # if response == DISCOVERY_REPLY:
        #     self._logger.trace("Received discovery reply from %s:%d" % address)


class ServersDiscovery(QObject):
    """
    This class is used by the client to discover servers on the local network.
    It uses an UDP socket listening on port 31013 to received the request
    broadcasted by the server. Discovery server will be shown in the UI.
    """

    def __init__(self, logger, parent=None):
        super(ServersDiscovery, self).__init__(parent)
        self._logger = logger
        self._servers = []

        self._socket = None
        self._read_notifier = None
        self._started = False

    @property
    def servers(self):
        return self._servers

    def start(self):
        """Start the discovery process and listen for discovery requests."""
        self._logger.debug("Starting servers discovery")

        # Create a datagram socket bound on port 31013
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        if platform.system() == "Darwin":
            self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        self._socket.bind(("", 31013))
        self._socket.settimeout(0)
        self._socket.setblocking(0)

        self._read_notifier = QSocketNotifier(
            self._socket.fileno(), QSocketNotifier.Read, self
        )
        self._read_notifier.activated.connect(self._notify_read)
        self._read_notifier.setEnabled(True)
        self._started = True

    def stop(self):
        """Stop the discovery process."""
        self._logger.debug("Stopping servers discovery")
        self._read_notifier.setEnabled(False)
        try:
            self._socket.close()
        except socket.errno:
            pass
        self._socket = None
        self._started = False

    def _notify_read(self):
        """This function is called when a discovery request is received."""
        request, address = self._socket.recvfrom(4096)
        request = request.decode("utf-8")
        if request.startswith(DISCOVERY_REQUEST):
            # self._logger.trace(
            #             #     "Received discovery request from %s:%d" % address
            #             # )
            # Get the server information
            _, host, port, ssl = request.split()
            server = {"host": host, "port": int(port), "no_ssl": ssl != "True"}

            # Remove the old value
            self._servers = [(s, t) for (s, t) in self._servers if s != server]
            # Append the new value
            self._servers.append((server, time.time()))

            #self._logger.trace("Sending discovery reply to %s:%d" % address)
            # Reply to the discovery request
            reply = DISCOVERY_REPLY
            reply = reply.encode("utf-8")
            try:
                self._socket.sendto(reply, address)
            except socket.error:
                self._logger.warning("Couldn't send discovery reply")

```

`idarling/shared/forms.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import idaapi
from PySide6.QtWidgets import *
from PySide6.QtGui import *
from PySide6.QtCore import *
from PySide6 import QtGui, QtCore, QtWidgets
from difflib import *


try:
    UNICODE_EXISTS = bool(type(unicode))
except NameError:
    unicode = lambda s: str(s)


def format(color, style=''):
    """Return a QTextCharFormat with the given attributes.
    """

    _color = QColor()
    # _color.setNamedColor(color)
    # _color.setHsl(100,100,100)
    _color.setRed(204)
    _color.setGreen(255)
    _color.setBlue(230)
    _format = QTextCharFormat()
    # _format.setForeground(_color)
    _format.setBackground(_color)
    if 'bold' in style:
        _format.setFontWeight(QFont.Bold)
    if 'italic' in style:
        _format.setFontItalic(True)

    return _format

class MergedResult(object):

    def __init__(self,diff = None):
        self.leftText = {}
        self.rigthText = {}
        self.mergedText = {}
        self.diffs = {'-': {}, '+': {}}
        if diff is not None:
            self.parseDiff(diff)
            self.GetMergedText()

    def parseDiff(self,diff):
        lineNumL = 1
        lineNumR = 1
        prevType = ""
        for l in diff:
            lineType = l[:1]
            line = l[2:]
            if lineType == prevType:
                df = lineNumL - lineNumR
                if df < 0:
                    for s in range(0, abs(df)):
                        self.leftText[lineNumL] = (lineNumL, "\n", "!")
                        lineNumL += 1
                elif df > 0:
                    for s in range(0, df):
                        self.rigthText[lineNumR] = (lineNumR, "\n", "!")
                        lineNumR += 1
            if lineType == " ":
                df = lineNumL - lineNumR
                if df < 0:
                    for s in range(0,abs(df)):
                        self.leftText[lineNumL]=(lineNumL, "\n", "!")
                        lineNumL +=1
                elif df > 0:
                    for s in range(0,df):
                        self.rigthText[lineNumR]=(lineNumR, "\n", "!")
                        lineNumR +=1

                self.leftText[lineNumL] = (lineNumL,line,lineType)
                self.rigthText[lineNumR] = (lineNumR,line,lineType)
                lineNumL += 1
                lineNumR += 1
                prevType = ""
            if lineType == "-":
                self.leftText[lineNumL] = (lineNumL,line,lineType)
                prevType = lineType
                lineNumL += 1
            if lineType == "+":
                self.rigthText[lineNumR] = (lineNumR, line, lineType)
                prevType = lineType
                lineNumR += 1
            if lineType == "?":
                #self.diffs.append((lineNumL if prevType == "-" else lineNumR,prevType) + (self.parseDiffLine(line),))
                self.diffs[prevType][(lineNumL if prevType == "-" else lineNumR) - 1] = self.parseDiffLine(line)
                prevType = ""


    def parseDiffLine(self,line):
        raw = []
        i = 0
        line = line.rstrip("\n")
        for i, ch in enumerate(line):
            if ch != " ":
                raw.append((i,ch))
        ret = []
        i = 0
        if len(raw) > 1:
            startPos = raw[i][0]
            prevPos = startPos
            prevCH = raw[i][1]
            i += 1
            while i < len(raw):

                if prevPos + 1 == raw[i][0] and prevCH == raw[i][1]:
                    prevPos += 1
                else:
                    ret.append((startPos,prevPos,prevCH))
                    startPos = raw[i][0]
                    prevPos = startPos
                    prevCH = raw[i][1]
                i += 1
            ret.append((startPos, prevPos, prevCH))
        else:
            ret.append((raw[i][0], raw[i][0], raw[i][1]))

        return ret

    def GetMergedText(self):
        for lineNum in self.leftText:
            lineNum, line, lnType = self.leftText[lineNum]
            if lnType == " ":
                self.mergedText[lineNum] = (lineNum, line, lnType)
            elif lnType == "!":
                self.mergedText[lineNum] = (lineNum, self.rigthText[lineNum][1],self.rigthText[lineNum][2])
            elif lnType == "-":
                if self.rigthText[lineNum][2] == "!":
                    self.mergedText[lineNum] = (lineNum, "\n","!")
                else:
                    self.mergedText[lineNum] = (lineNum, line, lnType)
        return self.mergedText

class LNTextEdit(QtWidgets.QFrame):
    class NumberBar(QtWidgets.QWidget):

        def __init__(self, edit):
            QtWidgets.QWidget.__init__(self, edit)

            self.edit = edit
            self.adjustWidth(1)

        def paintEvent(self, event):
            self.edit.numberbarPaint(self, event)
            QtWidgets.QWidget.paintEvent(self, event)

        def adjustWidth(self, count):
            width = self.fontMetrics().width(unicode(count))
            if self.width() != width:
                self.setFixedWidth(width)

        def updateContents(self, rect, scroll):
            if scroll:
                self.scroll(0, scroll)
            else:
                # It would be nice to do
                # self.update(0, rect.y(), self.width(), rect.height())
                # But we can't because it will not remove the bold on the
                # current line if word wrap is enabled and a new block is
                # selected.
                self.update()



    class PlainTextEdit(QtWidgets.QPlainTextEdit):
        def __init__(self, *args):
            QtWidgets.QPlainTextEdit.__init__(self, *args)
            self.setFrameStyle(QtWidgets.QFrame.NoFrame)
            self.zoomWheelEnabled = 0
            self.highlight()
            # self.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
            self.cursorPositionChanged.connect(self.highlight)

        def dragEnterEvent(self, event):
            data = event.mimeData()
            urls = data.urls()
            if (urls and urls[0].scheme() == 'file'):
                event.acceptProposedAction()

        def dragMoveEvent(self, event):
            data = event.mimeData()
            urls = data.urls()
            if (urls and urls[0].scheme() == 'file'):
                event.acceptProposedAction()

        def dropEvent(self, event):
            data = event.mimeData()
            urls = data.urls()
            if (urls and urls[0].scheme() == 'file'):
                txt = "\n".join([unicode(url.path())[1:] for url in urls])  # remove 1st / char
                self.insertPlainText(txt)

        def zoom_in(self):
            font = self.document().defaultFont()
            size = font.pointSize()
            if size < 28:
                size += 2
                font.setPointSize(size)
            self.setFont(font)

        def zoom_out(self):
            font = self.document().defaultFont()
            size = font.pointSize()
            if size > 6:
                size -= 2
                font.setPointSize(size)
            self.setFont(font)

        def wheelEvent(self, event, forward=True):
            if event.modifiers() == QtCore.Qt.ControlModifier:
                if self.zoomWheelEnabled == 1:
                    if event.delta() == 120:
                        self.zoom_in()
                    elif event.delta() == -120:
                        self.zoom_out()
                event.ignore()
            QtWidgets.QPlainTextEdit.wheelEvent(self, event)

        def highlight(self):
            hi_selection = QtWidgets.QTextEdit.ExtraSelection()

            hi_selection.format.setBackground(self.palette().alternateBase())
            hi_selection.format.setProperty(QtGui.QTextFormat.FullWidthSelection, 1)  # QtCore.QVariant(True)
            hi_selection.cursor = self.textCursor()
            hi_selection.cursor.clearSelection()

            self.setExtraSelections([hi_selection])

        def numberbarPaint(self, number_bar, event):
            font_metrics = self.fontMetrics()
            current_line = self.document().findBlock(self.textCursor().position()).blockNumber() + 1

            block = self.firstVisibleBlock()
            line_count = block.blockNumber()
            painter = QtGui.QPainter(number_bar)
            painter.fillRect(event.rect(), self.palette().base())

            # Iterate over all visible text blocks in the document.
            while block.isValid():
                line_count += 1
                block_top = self.blockBoundingGeometry(block).translated(self.contentOffset()).top()

                # Check if the position of the block is out side of the visible
                # area.
                if not block.isVisible() or block_top >= event.rect().bottom():
                    break

                # We want the line number for the selected line to be bold.
                if line_count == current_line:
                    font = painter.font()
                    font.setBold(True)
                    painter.setFont(font)
                else:
                    font = painter.font()
                    font.setBold(False)
                    painter.setFont(font)

                # Draw the line number right justified at the position of the line.
                paint_rect = QtCore.QRect(0, block_top, number_bar.width(), font_metrics.height())
                painter.drawText(paint_rect, QtCore.Qt.AlignRight, unicode(line_count))

                block = block.next()

            painter.end()

    def __init__(self, *args):
        QtWidgets.QFrame.__init__(self, *args)

        self.setFrameStyle(QtWidgets.QFrame.StyledPanel | QtWidgets.QFrame.Sunken)

        self.edit = self.PlainTextEdit()
        self.number_bar = self.NumberBar(self.edit)

        hbox = QtWidgets.QHBoxLayout(self)
        hbox.setSpacing(0)
        hbox.setContentsMargins(0, 0, 0, 0)  # setMargin
        hbox.addWidget(self.number_bar)
        hbox.addWidget(self.edit)

        self.edit.blockCountChanged.connect(self.number_bar.adjustWidth)
        self.edit.updateRequest.connect(self.number_bar.updateContents)

    def text(self):
        return unicode(self.edit.toPlainText())

    def getText(self):
        return unicode(self.edit.toPlainText())

    def setText(self, text):
        self.edit.setPlainText(text)

    def insertText(self, text):
        self.edit.insertPlainText(text)

    def insertPlainText(self, text):
        self.insertText(text)

    def isModified(self):
        return self.edit.document().isModified()

    def setModified(self, modified):
        self.edit.document().setModified(modified)

    def setLineWrapMode(self, mode):
        self.edit.setLineWrapMode(mode)

    def setWrap(self, state):
        if state == 0:
            self.edit.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)
        else:
            self.edit.setLineWrapMode(QtWidgets.QPlainTextEdit.WidgetWidth)

    def setReadOnly(self, state):
        self.edit.setReadOnly(state)

    def setReadOnlyStyle(self, state):
        if state == 1:
            mainWindowBgColor = QtWidgets.QPalette().color(QtWidgets.QPalette.Window)
            self.setStyleSheet(
                'QPlainTextEdit[readOnly="true"] { background-color: %s;} QFrame {border: 0px}' % mainWindowBgColor.name())
            self.setHighlight(0)
        else:
            self.setStyleSheet('')
            self.setHighlight(1)

    def setFontSize(self, value):
        font = self.edit.document().defaultFont()
        if value > 6 and value < 28:
            font.setPointSize(value)
            self.edit.setFont(font)

    def getFontSize(self):
        font = self.edit.document().defaultFont()
        size = font.pointSize()
        return size

    def resetFontSize(self):
        font = self.edit.document().defaultFont()
        font.setPointSize(8)
        self.edit.setFont(font)

    def setZoom(self, mode):
        if mode == 0:
            self.edit.zoomWheelEnabled = 0
        else:
            self.edit.zoomWheelEnabled = 1

    def setHighlight(self, state):
        txtEdit = self.edit
        if state == 0:
            txtEdit.cursorPositionChanged.disconnect()
            txtEdit.setExtraSelections([])
        else:
            txtEdit.cursorPositionChanged.connect(txtEdit.highlight)

    def setMergeText(self, lines, diffs, left=True):
        self.diffs = diffs
        self.lines = lines
        line_start = 0
        for lineNum, line, lnType in lines.values():
            line = line.rstrip("\n")
            # print (line)
            self.edit.appendPlainText(line)
            if left is not None:
                if lineNum in diffs["-" if left else "+"]:
                    for start_diff_pos, end_diff_pos, diff_type in diffs["-" if left else "+"][lineNum]:
                        hi_selection = QTextEdit.ExtraSelection()
                        hi_selection.cursor = QTextCursor(self.edit.document())
                        hi_selection.cursor.setPosition(line_start + start_diff_pos)
                        hi_selection.cursor.setPosition(line_start + end_diff_pos + 1, QTextCursor.KeepAnchor)
                        hi_selection.cursor.setCharFormat(format("green"))
                        hi_selection.cursor.clearSelection()
                else:
                    if lnType != " ":
                        hi_selection = QTextEdit.ExtraSelection()
                        hi_selection.cursor = QTextCursor(self.edit.document())
                        hi_selection.cursor.setPosition(line_start)
                        hi_selection.cursor.setPosition(line_start + len(line), QTextCursor.KeepAnchor)
                        hi_selection.cursor.setCharFormat(format("green"))
                        hi_selection.cursor.clearSelection()
            line_start += (len(line) + 1)

class DublicateResolverUI(QDialog):
    def __init__(self,leftText = "", rightText = "",fToStorage = True):
        flags = Qt.WindowFlags(Qt.WindowMinimizeButtonHint | Qt.WindowCloseButtonHint | Qt.WindowMaximizeButtonHint)
        super(DublicateResolverUI, self).__init__(flags=flags)
        self.textEdits = []
        self.sel = 1
        self.selText = ""
        self.fToStorage = fToStorage
        self.leftText = leftText.splitlines(True)
        self.rightText = rightText.splitlines(True)
        self.MR = MergedResult(self.GetDiff(self.leftText,self.rightText))

        self.initUI()


    def initUI(self):
        qlLeft = QLabel('Existing type in the repository' if self.fToStorage else "Existing local type")
        qlRight = QLabel('New type from the repository' if not self.fToStorage else "New local type")
        qlMerged = QLabel('Merged type')

        self.textEdit1 = LNTextEdit()
        self.textEdit1.edit.cursorPositionChanged.connect(self.highlight)
        self.textEdit2 = LNTextEdit()
        self.textEdit2.edit.cursorPositionChanged.connect(self.highlight)
        self.textEdit3 = LNTextEdit()
        self.textEdit3.edit.cursorPositionChanged.connect(self.highlight)
        self.textEdits = [self.textEdit1.edit,self.textEdit2.edit,self.textEdit3.edit]
        # textEdit1 = QTextEdit()
        # textEdit2 = QTextEdit()
        # textEdit3 = QTextEdit()

        #hi = PythonHighlighter(textEdit1)
        #print hi.currentBlock().text()

        #self.textEdit1.setText("AAAAAAAAAAAABBBBBBBBB\nCCCCCCCCCDDDDDDDDDD\nAAAAAAAAAAAABBBBBBBBB\nAAAAAAAAAAAABBBBBBBBB\nAAAAAAAAAAAABBBBBBBBB\nAAAAAAAAAAAABBBBBBBBB\nAAAAAAAAAAAABBBBBBBBB")
        # self.textEdit1.edit.appendPlainText("DDDDDDDDD")
        # self.textEdit1.edit.appendPlainText("DDDDDDDDD")
        #self.textEdit1.setReadOnly(True)
        #print hi.currentBlock().text()

        grid = QGridLayout()
        grid.setSpacing(10)

        grid.addWidget(qlLeft, 0, 1)
        grid.addWidget(self.textEdit1, 1, 1)

        grid.addWidget(qlMerged, 0, 3)
        grid.addWidget(self.textEdit2, 1, 3)

        grid.addWidget(qlRight, 0, 5)
        grid.addWidget(self.textEdit3, 1, 5)

        btLeftAll = QPushButton("Use left")
        grid.addWidget(btLeftAll,2,1)
        btLeft = QPushButton(">")
        grid.addWidget(btLeft,1,2)

        btLeft.clicked.connect(self.Left)
        btLeftAll.clicked.connect(self.LeftAll)

        btRightAll = QPushButton("Use right")
        grid.addWidget(btRightAll, 2, 5)
        btRight = QPushButton("<")
        grid.addWidget(btRight, 1, 4)

        btRight.clicked.connect(self.Right)
        btRightAll.clicked.connect(self.RightAll)

        btUseMerged = QPushButton("Use merged")
        grid.addWidget(btUseMerged,2,3)

        btUseMerged.clicked.connect(self.UseMerged)

        self.setLayout(grid)
        # self.resize(self.sizeHint())r
        QP = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setSizePolicy(QP)
        # print self.size()
        mainGeo = QCoreApplication.instance().desktop().screenGeometry()
        for w in QCoreApplication.instance().allWidgets():
            if type(w) == QMainWindow:
                mainGeo = w.geometry()
                break
        #mainGeo.setHeight(mainGeo.height() - 300)
        #mainGeo.setWidth(mainGeo.width() - 300)
        #print mainGeo

        #print QCoreApplication.instance().desktop().screenGeometry()
        self.setMinimumSize(mainGeo.width()/4*3,mainGeo.height()/4*3)
        #print self.size()
        #self.resize(QSize(rec.width() - 400, rec.height() - 400))
        # self.setGeometry(600, 600, 600, 600)
        self.setWindowTitle('Review')
        self.textEdit1.setMergeText(self.MR.leftText, self.MR.diffs)
        self.textEdit3.setMergeText(self.MR.rigthText, self.MR.diffs, False)
        self.textEdit2.setMergeText(self.MR.GetMergedText(), self.MR.diffs, False)
        self.textEdit1.setReadOnly(True)
        self.textEdit3.setReadOnly(True)


    def highlight(self):
        # print (self.sender())
        # if self.sender() == self.textEdit1.edit:
        #     print ("same")
        # print self.toPlainText()
        # print self
        # obj = self if self.sender() is None else self.sender()
        hi_selection = QTextEdit.ExtraSelection()

        hi_selection.format.setBackground(self.sender().palette().alternateBase())
        hi_selection.format.setProperty(QTextFormat.FullWidthSelection, QVariant(True))
        hi_selection.cursor = self.sender().textCursor()
        cursor = hi_selection.cursor
        line_num = cursor.blockNumber()
        hi_selection.cursor.clearSelection()

        self.sender().setExtraSelections([hi_selection])
        for edit in self.textEdits:
            if edit.textCursor().blockNumber() != line_num:
                hi_selection = QTextEdit.ExtraSelection()

                hi_selection.format.setBackground(edit.palette().alternateBase())
                hi_selection.format.setProperty(QTextFormat.FullWidthSelection, QVariant(True))
                bl = edit.document().findBlockByNumber(line_num)
                cr = edit.textCursor()
                cr.setPosition(bl.position())
                # print ("pos = %d"%bl.position())
                # print ("len = %d"%bl.length())
                edit.setTextCursor(cr)
                hi_selection.cursor = edit.textCursor()
                hi_selection.cursor.clearSelection()

                edit.setExtraSelections([hi_selection])

    def Left(self):
        line_num = self.textEdit2.edit.textCursor().blockNumber() + 1
        ct = self.textEdit2.lines[line_num]
        line = self.textEdit1.lines[line_num][1]
        self.textEdit2.lines[line_num] = (ct[0], line, ct[2])
        self.textEdit2.edit.document().clear()
        self.textEdit2.setMergeText(self.textEdit2.lines,self.textEdit2.diffs,False)
        block = self.textEdit2.edit.document().findBlockByNumber(line_num)
        cr = self.textEdit2.edit.textCursor()
        cr.setPosition(block.position())
        self.textEdit2.edit.setTextCursor(cr)

    def Right(self):
        line_num = self.textEdit2.edit.textCursor().blockNumber() + 1
        ct = self.textEdit2.lines[line_num]
        line = self.textEdit3.lines[line_num][1]
        self.textEdit2.lines[line_num] = (ct[0], line, ct[2])
        self.textEdit2.edit.document().clear()
        self.textEdit2.setMergeText(self.textEdit2.lines,self.textEdit2.diffs,False)
        block = self.textEdit2.edit.document().findBlockByNumber(line_num)
        cr = self.textEdit2.edit.textCursor()
        cr.setPosition(block.position())
        self.textEdit2.edit.setTextCursor(cr)

    def LeftAll(self):
        self.sel = 1
        self.close()

    def RightAll(self):
        self.sel = 2
        self.close()

    def UseMerged(self):
        self.sel = 0
        self.close()

    def closeEvent(self, QCloseEvent):
        edit = None
        if self.sel == 0:
            self.selText = self.textEdit2.edit.toPlainText()
        elif self.sel == 1:
            self.selText = self.textEdit1.edit.toPlainText()
        elif self.sel == 2:
            self.selText = self.textEdit3.edit.toPlainText()

    @staticmethod
    def GetDiff(s1,s2):
        d = Differ()

        result = list(d.compare(s1, s2))
        return result
    def Go(self):
        self.setWindowModality(Qt.ApplicationModal)
        # self.setWindowModality(Qt.WindowModal)
        oldTo = idaapi.set_script_timeout(0)
        res = self.exec_()
        idaapi.set_script_timeout(oldTo)
        return res

```

`idarling/shared/local_types.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import base64
import collections
import pickle
import struct

import ida_pro
import ida_typeinf
import idaapi
import idc

from idarling.shared import forms

fDebug = False
if fDebug:
    import pydevd_pycharm


class TinfoReader(object):
    def __init__(self, tp):
        self.pos = 0
        self.tp = tp
    
    def read_byte(self):
        (result,) = struct.unpack("<B", self.tp[self.pos:self.pos + 1])
        self.pos += 1
        return result
    
    def read_string(self, cb):
        ret = self.tp[self.pos:self.pos + cb]
        self.pos += cb
        return ret
    
    def keep_going(self):
        return self.pos < len(self.tp)


def encode_ordinal_to_string(ordinal):
    enc = []
    # print "encode_ordinal_to_string: ordinal %d"%ordinal
    enc.append(ordinal & 0x7f | 0x40)
    if ordinal > 0x3f:
        bt = ordinal
        bt = bt // 0x40
        enc.append(bt & 0x7f | 0x80)
        while bt > 0x7f:
            bt = bt // 0x80
            enc.append(bt & 0x7f | 0x80)
    # stemp = struct.pack("B",len(enc)+2) + "#"
    stemp = []
    stemp.append(len(enc) + 2)
    stemp.append(ord("#"))
    # for i in range(0,len(enc)):
    #     stemp = stemp + struct.pack("B",enc.pop(-1))
    # print stemp
    # print enc
    enc.reverse()
    # print enc
    stemp = stemp + enc
    return stemp


def decode_ordinal_string(enc):
    if enc[1] == ord("#"):
        ord_num = 0
        i = 0
        fEnd = 0
        str_len = struct.unpack("B", enc[0:1])[0] - 2
        # print len
        for ch in enc[2:]:
            if ch == 0:
                return 0
            ord_num = ord_num * 0x40
            if ch & 0x80 != 0:
                ord_num = ord_num * 2
                ch = ch & 0x7f
            else:
                ch = ch & 0x3f
                fEnd = 1
            ord_num = ord_num | ch
            i = i + 1
            if fEnd > 0 or i >= str_len:
                break
        return ord_num
    return 0


class LocalType(object):
    
    # Flags = {
    #     "struct":1,
    #     "enum":2,
    #     "other":4,
    #     "standard":8
    # }
    
    def __init__(self, name=b"", TypeString=b"", TypeFields=b"", cmt=b"", fieldcmts=b"", sclass=0, parsedList=None, depends=None, isStandard=False):
        self.TypeString = TypeString
        self.TypeFields = TypeFields
        self.cmt = cmt
        self.fieldcmts = fieldcmts if type(fieldcmts) == bytes else fieldcmts.encode("utf-8")
        self.sclass = sclass
        self.name = name
        self.parsedList = [] if parsedList is None else parsedList
        self.depends = [] if depends is None else depends
        self.depends_ordinals = []
        self.flags = 8 if isStandard else 0
        # print "Type string: %s"%self.TypeString.encode("HEX")
        if self.TypeString != b"":
            self.parsedList = self.ParseTypeString(self.TypeString)
        if self.parsedList is not None and self.TypeString == b"":
            self.TypeString = self.GetTypeString()
        if self.TypeString != b"":
            if self.is_su():
                self.flags |= 1
            elif self.is_enum():
                self.flags |= 2
            elif self.isnt_sue():
                self.flags |= 4
    
    # def __init__(self, idx):
    #     self.name = None
    #     self.parsedList = []
    #     self.TypeString = None
    #     self.TypeFields = None
    #     self.cmt = None
    #     self.fieldcmts = None
    #     self.sclass = None
    #     self.depends = []
    
    @staticmethod
    def find_type_by_name(name):
        my_ti = idaapi.get_idati()
        ordinal = idaapi.get_type_ordinal(my_ti, name)
    
    def GetTypeString(self):
        ti = idaapi.get_idati()
        # print "GetTypeString: name %s"%self.name
        the_bytes = []
        for thing in self.parsedList:
            if type(thing) == int:  # if it's a byte, just put it back in
                the_bytes.append(thing)
            elif len(thing) == 1:
                if list(thing.keys())[0] == "local_type":
                    the_bytes.append(ord("="))  # a type starts with =
                # print type(thing["local_type"]),thing["local_type"]
                ordinal = idaapi.get_type_ordinal(ti, list(thing.values())[0])  # get the ordinal of the Local Type based on its name
                if ordinal > 0:
                    the_bytes = the_bytes + encode_ordinal_to_string(ordinal)
                else:
                    raise NameError("Depends local type not in IDB")
            else:
                raise NameError("Wrong depend record for type: %s!" % self.name)
        packed = struct.pack("%dB" % len(the_bytes), *the_bytes)
        return packed
    
    def ParseTypeString(self, type_string):
        if fDebug:
            pydevd_pycharm.settrace('127.0.0.1', port=31337, stdoutToServer=True, stderrToServer=True, suspend=False)
        tp = TinfoReader(type_string)
        # print idc_print_type(type_, fields, "fun_name", 0)
        # print type_.encode("string_escape")
        output = []
        """
        Attempt to copy the tinfo from a location, replacing any Local Types with our own representation of them.
        Pass all other bytes through as-is.
        """
        while tp.keep_going():
            a_byte = tp.read_byte()
            unwritten_bytes = [a_byte]
            if a_byte == ord("=") and tp.pos < len(tp.tp):  # a type begins
                ordinal_length = tp.read_byte()
                if tp.pos < len(tp.tp) and len(tp.tp) - (tp.pos + ordinal_length - 1) >= 0:
                    number_marker = tp.read_byte()
                    if number_marker == ord("#"):  # this is a Local Type referred to by its ordinal
                        ordinal = decode_ordinal_string(struct.pack("B", ordinal_length) + b"#" + tp.read_string(ordinal_length - 2))
                        t = idc.get_numbered_type_name(ordinal)
                        output.append({"local_type": t})
                        if t not in self.depends:
                            self.depends.append(t)
                            self.depends_ordinals.append(ordinal)
                        continue
                    else:
                        unwritten_bytes.append(ordinal_length)
                        unwritten_bytes.append(number_marker)
                else:
                    unwritten_bytes.append(ordinal_length)
            elif a_byte == ord("#") and ((len(output) >= 4 and output[-4:-1] == [0x0A, 0x0D, 0x01]) or (len(output) >= 3 and output[-3:-1] == [0x0D, 0x01])):
                ordinal_length = output[-1]
                output.pop(-1)
                ordinal = decode_ordinal_string(struct.pack("B", ordinal_length) + b"#" + tp.read_string(ordinal_length - 2))
                t = idc.get_numbered_type_name(ordinal)
                output.append({"rare_local_type": t})
                if t not in self.depends:
                    self.depends.append(t)
                    self.depends_ordinals.append(ordinal)
                continue
            
            output += unwritten_bytes  # put all the bytes we didn't consume into the output as-is
        
        return output
    
    def to_dict(self):
        ser_dic = collections.OrderedDict()
        ser_dic['name'] = self.name
        ser_dic['TypeString'] = base64.b64encode(self.TypeString)
        ser_dic['TypeFields'] = base64.b64encode(self.TypeFields)
        ser_dic['cmt'] = base64.b64encode(self.cmt)
        ser_dic['fieldcmts'] = base64.b64encode(self.fieldcmts)
        ser_dic['sclass'] = base64.b64encode(pickle.dumps(self.sclass))
        ser_dic['parsedList'] = base64.b64encode(pickle.dumps(self.parsedList))
        ser_dic['depends'] = base64.b64encode(pickle.dumps(self.depends))
        ser_dic['depends_ordinals'] = base64.b64encode(pickle.dumps(self.depends_ordinals))
        ser_dic['flags'] = self.flags
        return ser_dic
    
    def to_iter(self):
        return self.name, base64.b64encode(self.TypeString), base64.b64encode(self.TypeFields), base64.b64encode(self.cmt), base64.b64encode(
            self.fieldcmts), base64.b64encode(pickle.dumps(self.sclass)), base64.b64encode(pickle.dumps(self.parsedList)), base64.b64encode(
            pickle.dumps(self.depends)), base64.b64encode(pickle.dumps(self.depends_ordinals)), self.flags
    
    def from_dict(self, ser_dic):
        self.name = ser_dic['name']
        self.TypeString = base64.b64decode(ser_dic['TypeString'])
        # print "from_dict; TypeString = %s"%self.TypeString
        self.TypeFields = base64.b64decode(ser_dic['TypeFields'])
        self.cmt = base64.b64decode(ser_dic['cmt'])
        self.fieldcmts = base64.b64decode(ser_dic['fieldcmts'])
        self.sclass = int(ser_dic['sclass'])
        self.parsedList = ser_dic['parsedList']
        self.depends = ser_dic['depends']
        self.depends_ordinals = ser_dic['depends_ordinals']
        # self.sclass = ctypes.c_ulong(self.sclass)
        self.flags = ser_dic['flags']
        return self
    
    def print_type(self):
        ret = idaapi.idc_print_type(self.GetTypeString(), self.TypeFields, self.name, idaapi.PRTYPE_MULTI | idaapi.PRTYPE_TYPE)
        if ret is None:
            return ""
        i = 0
        ret = ret.strip()
        return ret
    
    def is_standard(self):
        return self.flags & 8 == 8
    
    def isEqual(self, t):
        if t and  self.parsedList == t.parsedList \
                and self.TypeFields == t.TypeFields \
                and self.name == t.name:
            return True
        return False
    
    def __eq__(self, other):
        if isinstance(other, LocalType):
            return self.isEqual(other)
        return False
        
    def to_tuple(self):
       return self.name, self.parsedList, self.TypeFields.decode()
   
    def is_complex(self):
        return self.TypeString[0] & idaapi.TYPE_BASE_MASK == idaapi.BT_COMPLEX
    
    def is_typedef(self):
        return self.TypeString[0] & idaapi.TYPE_FULL_MASK == idaapi.BTF_TYPEDEF
    
    def is_sue(self):
        return self.is_complex() and not self.is_typedef()
    
    def isnt_sue(self):
        return not self.is_sue()
    
    def is_su(self):
        return self.is_complex() and not self.is_typedef() and not self.is_enum()
    
    def is_paf(self):
        t = self.TypeString[0] & idaapi.TYPE_BASE_MASK
        return (t >= idaapi.BT_PTR) & (t <= idaapi.BT_FUNC)
    
    def is_func(self):
        return self.TypeString[0] & idaapi.TYPE_BASE_MASK == idaapi.BT_FUNC
    
    def is_struct(self):
        return self.TypeString[0] & idaapi.TYPE_FULL_MASK == idaapi.BTF_STRUCT
    
    def is_union(self):
        return self.TypeString[0] & idaapi.TYPE_FULL_MASK == idaapi.BTF_UNION
    
    def is_enum(self):
        return self.TypeString[0] & idaapi.TYPE_FULL_MASK == idaapi.BTF_ENUM
    
    def is_ptr(self):
        return self.TypeString[0] & idaapi.TYPE_FULL_MASK == idaapi.BT_PTR
    
    @staticmethod
    def is_complex_static(TypeString):
        return TypeString[0] & idaapi.TYPE_BASE_MASK == idaapi.BT_COMPLEX
    
    @staticmethod
    def is_typedef_static(TypeString):
        return TypeString[0] & idaapi.TYPE_FULL_MASK == idaapi.BTF_TYPEDEF
    
    @staticmethod
    def is_sue_static(TypeString):
        return LocalType.is_complex_static(TypeString) and not LocalType.is_typedef_static(TypeString)
    
    @staticmethod
    def isnt_sue_static(TypeString):
        return not LocalType.is_sue_static(TypeString)
    
    @staticmethod
    def is_su_static(TypeString):
        return LocalType.is_complex_static(TypeString) and not LocalType.is_typedef_static(TypeString) and not LocalType.is_enum_static(TypeString)
    
    @staticmethod
    def is_paf_static(TypeString):
        t = TypeString[0] & idaapi.TYPE_BASE_MASK
        return (t >= idaapi.BT_PTR) & (t <= idaapi.BT_FUNC)
    
    @staticmethod
    def is_func_static(TypeString):
        return TypeString[0] & idaapi.TYPE_BASE_MASK == idaapi.BT_FUNC
    
    @staticmethod
    def is_struct_static(TypeString):
        return TypeString[0] & idaapi.TYPE_FULL_MASK == idaapi.BTF_STRUCT
    
    @staticmethod
    def is_union_static(TypeString):
        return TypeString[0] & idaapi.TYPE_FULL_MASK == idaapi.BTF_UNION
    
    @staticmethod
    def is_enum_static(TypeString):
        return TypeString[0] & idaapi.TYPE_FULL_MASK == idaapi.BTF_ENUM


def ParseTypeString(type_string):
    if fDebug:
        pydevd_pycharm.settrace('127.0.0.1', port=31337, stdoutToServer=True, stderrToServer=True, suspend=False)
    tp = TinfoReader(type_string)
    # print idc_print_type(type_, fields, "fun_name", 0)
    # print type_.encode("string_escape")
    output = []
    """
    Attempt to copy the tinfo from a location, replacing any Local Types with our own representation of them.
    Pass all other bytes through as-is.
    """
    while tp.keep_going():
        a_byte = tp.read_byte()
        unwritten_bytes = [a_byte]
        if a_byte == ord("=") and tp.pos < len(tp.tp):  # a type begins
            ordinal_length = tp.read_byte()
            if tp.pos < len(tp.tp) and len(tp.tp) - (tp.pos + ordinal_length - 1) >= 0:
                number_marker = tp.read_byte()
                if number_marker == ord("#"):  # this is a Local Type referred to by its ordinal
                    ordinal = decode_ordinal_string(struct.pack("B", ordinal_length) + b"#" + tp.read_string(ordinal_length - 2))
                    t = idc.get_numbered_type_name(ordinal)
                    output.append({"local_type": t})
                    # if t not in self.depends:
                    #     self.depends.append(t)
                    #     self.depends_ordinals.append(ordinal)
                    continue
                else:
                    unwritten_bytes.append(ordinal_length)
                    unwritten_bytes.append(number_marker)
            else:
                unwritten_bytes.append(ordinal_length)
        elif a_byte == ord("#") and ((len(output) >= 4 and output[-4:-1] == [0x0A, 0x0D, 0x01]) or (len(output) >= 3 and output[-3:-1] == [0x0D, 0x01])):
            ordinal_length = output[-1]
            output.pop(-1)
            ordinal = decode_ordinal_string(struct.pack("B", ordinal_length) + b"#" + tp.read_string(ordinal_length - 2))
            t = idc.get_numbered_type_name(ordinal)
            output.append({"rare_local_type": t})
            # if t not in self.depends:
            #     self.depends.append(t)
            #     self.depends_ordinals.append(ordinal)
            continue
        
        output += unwritten_bytes  # put all the bytes we didn't consume into the output as-is
    
    return output


def GetTypeString(parsedList, name=""):
    ti = idaapi.get_idati()
    # print "GetTypeString: name %s"%self.name
    the_bytes = []
    for thing in parsedList:
        if type(thing) == int:  # if it's a byte, just put it back in
            the_bytes.append(thing)
        elif len(thing) == 1:
            if list(thing.keys())[0] == "local_type":
                the_bytes.append(ord("="))  # a type starts with =
            # print type(thing["local_type"]),thing["local_type"]
            ordinal = idaapi.get_type_ordinal(ti, list(thing.values())[0])  # get the ordinal of the Local Type based on its name
            if ordinal > 0:
                the_bytes = the_bytes + encode_ordinal_to_string(ordinal)
            else:
                raise NameError("Depends local type not in IDB")
        else:
            raise NameError("Wrong depend record for type: %s!" % name)
    packed = struct.pack("%dB" % len(the_bytes), *the_bytes)
    return packed


def ImportLocalType(idx):
    name = ida_typeinf.get_numbered_type_name(ida_typeinf.get_idati(), idx)
    # todo: doing something with empty and error types
    ret = ida_typeinf.get_numbered_type(
        ida_typeinf.get_idati(),
        idx
    )
    if ret is not None:
        typ_type, typ_fields, typ_cmt, typ_fieldcmts, typ_sclass = ret
        if typ_type is None:
            typ_type = b""
        if typ_fields is None:
            typ_fields = b""
        if typ_cmt is None:
            typ_cmt = b""
        if typ_fieldcmts is None:
            typ_fieldcmts = b""
        return LocalType(name, typ_type, typ_fields, typ_cmt, typ_fieldcmts, typ_sclass)
    return None

def ImportNamedLocalType(idx):
    name = ida_typeinf.get_numbered_type_name(ida_typeinf.get_idati(), idx)
    if name:
        # todo: doing something with empty and error types
        ret = ida_typeinf.get_numbered_type(
            ida_typeinf.get_idati(),
            idx
        )
        if ret is not None:
            typ_type, typ_fields, typ_cmt, typ_fieldcmts, typ_sclass = ret
            if typ_type is None:
                typ_type = b""
            if typ_fields is None:
                typ_fields = b""
            if typ_cmt is None:
                typ_cmt = b""
            if typ_fieldcmts is None:
                typ_fieldcmts = b""
            return LocalType(name, typ_type, typ_fields, typ_cmt, typ_fieldcmts, typ_sclass)
    return None


def DuplicateResolver(t1, t2, fToStorage=False):
    f = forms.DublicateResolverUI(t1.print_type(), t2.print_type(), fToStorage)
    while True:
        f.Go()
        if f.sel == 1:
            return t1
        elif f.sel == 2:
            return t2
        else:
            r = idc.parse_decl(f.selText, 0x008E)
            if r is not None:
                return LocalType(r[0], r[1], r[2])


def getTypeOrdinal(name):
    my_ti = ida_typeinf.get_idati()
    return ida_typeinf.get_type_ordinal(my_ti, name)


def InsertType(type_obj, fReplace=False):
    # print("Insert type %s." % type_obj.name)
    wrapperTypeString = b'\x0d\x01\x01'
    if getTypeOrdinal(type_obj.name) != 0:
        idx = getTypeOrdinal(type_obj.name)
        t = ImportLocalType(idx)
        if (t.TypeFields is None or t.TypeFields == "") and t.is_sue():
            fReplace = True
        if t.isEqual(type_obj) or type_obj.TypeString == wrapperTypeString:
            return 1
        if not fReplace:
            type_obj = DuplicateResolver(t, type_obj, False)
    else:
        idx = ida_typeinf.alloc_type_ordinals(idaapi.get_idati(), 1)
    tif = ida_typeinf.tinfo_t()
    ret = tif.deserialize(ida_typeinf.get_idati(), type_obj.GetTypeString(), type_obj.TypeFields, type_obj.fieldcmts)
    if not ret:
        idaapi.warning("Error on tinfo deserilization, type name = %s, ret = %d" % (type_obj.name, ret))
        ret = -1
    else:
        ret = tif.set_numbered_type(idaapi.get_idati(), idx, 0x4, type_obj.name)
    del tif
    # ret = idaapi.set_numbered_type(
    #     my_ti,
    #     idx,
    #     0x4,
    #     type_obj.name,
    #     type_obj.GetTypeString(),
    #     type_obj.TypeFields,
    #     type_obj.cmt,
    #     type_obj.fieldcmts
    # )
    # print "Insert type %s. ret = %d"%(type_obj.name,ret)
    if (ida_pro.IDA_SDK_VERSION < 700 and ret != 1) or (ida_pro.IDA_SDK_VERSION >= 700 and ret != 0):
        print("bad insert: %s; ret = %d" % (type_obj.name, ret))
    return ret


def checkExistence(name_list, target_list):
    for name in name_list:
        if name not in target_list:
            return False
    return True


def addTypeWrapper(name):
    wrapperTypeString = b'\x0d\x01\x01'
    return LocalType(name, wrapperTypeString)


def resolveDependencies(startList):
    toResolve = startList
    toResolveNames = []
    # print "resolveDependencies: startList", startList
    prev_len = -1
    for t in toResolve:
        toResolveNames.append(t.name)
    sortedList = []
    # print "resolveDependencies: toResolveNames", toResolve
    # toResolveNames = toResolve
    # toResolve = self.getFromStorage(toResolve)
    prev_len = len(toResolve)
    sortedListNames = []
    
    while len(toResolve) > 0:
        for t in toResolve:
            if len(t.depends) == 0:
                sortedList.append(t)
                toResolve.remove(t)
                sortedListNames.append(t.name)
                toResolveNames.remove(t.name)
            else:
                if checkExistence(t.depends, sortedListNames):
                    sortedList.append(t)
                    toResolve.remove(t)
                    sortedListNames.append(t.name)
                    toResolveNames.remove(t.name)
        if prev_len == len(toResolve):
            for t in toResolve:
                for name in t.depends:
                    if checkExistence([name], sortedListNames):
                        continue
                    elif checkExistence([name], toResolveNames):
                        sortedList.append(addTypeWrapper(name))
                        sortedListNames.append(name)
                        continue
                    else:
                        raise NameError("resolveDependencies: Unresolved type dependencies %s" % name)
        prev_len = len(toResolve)
    return sortedList
```

`idarling/shared/models.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
from .packets import Default


class Model(Default):
    """
    A model is an object that can be serialized and sent over the network, but 
    that can be saved into the SQL database used by the server.
    """

    def build(self, dct):
        self.build_default(dct)
        return dct

    def parse(self, dct):
        self.parse_default(dct)
        return self

    def __repr__(self):
        """
        Return a textual representation of the object. It will mainly be used
        for pretty-printing into the console.
        """
        attrs = u", ".join(
            [
                u"{}={}".format(key, val)
                for key, val in Default.attrs(self.__dict__).items()
            ]
        )
        return u"{}({})".format(self.__class__.__name__, attrs)


class Project(Model):
    """
    IDBs are organized into projects, binaries and snapshots. A project contains all
    the files associated to a given topic, CVE, malware, etc. that we want to 
    group together to ease differentiating from another research topic.
    """

    def __init__(self, name, date):
        super(Project, self).__init__()
        self.name = name
        self.date = date


class Binary(Model):
    """
    IDBs are organized into projects, binaries and snapshots. A binary regroups
    multiples revisions of an IDB. It has a name, the hash of the input file,
    the path to the input file, the type of the input file and the date of the
    snapshot creation.
    """

    def __init__(self, project, name, hash, file, type, date):
        super(Binary, self).__init__()
        self.project = project
        self.name = name
        self.hash = hash
        self.file = file
        self.type = type
        self.date = date


class Snapshot(Model):
    """
    IDBs are organized into projects, binaries and snapshots. A snapshot corresponds to
    a revision of an IDB. It has a binary, a name, a date of creation, and a
    current tick (events) count.
    """

    def __init__(self, project, binary, name, date, tick=0):
        super(Snapshot, self).__init__()
        self.project = project
        self.binary = binary
        self.name = name
        self.date = date
        self.tick = tick

```

`idarling/shared/packets.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import collections
import itertools


def with_metaclass(meta, *bases):
    """Python 2 and 3 compatible way to add a meta-class."""

    class Metaclass(type):
        def __new__(cls, name, this_bases, d):
            return meta(name, bases, d)

        @classmethod
        def __prepare__(cls, name, _):
            return meta.__prepare__(name, bases)

    return type.__new__(Metaclass, "temporary_class", (), {})


class Serializable(object):
    """
    This base class for an object than can be serialized. More specifically,
    such objects can be read from and written into a Python dictionary.
    """

    @classmethod
    def new(cls, dct):
        """Creates a new instance of the object."""
        obj = cls.__new__(cls)
        object.__init__(obj)
        obj.parse(dct)
        return obj

    def build(self, dct):
        """Writes the object into the dictionary."""
        pass

    def parse(self, dct):
        """Reads the object from the dictionary."""
        pass


class Default(Serializable):
    """This object will be serialized using its attributes dictionary."""

    @staticmethod
    def attrs(dct):
        """
        Get a filtered version of an attributes dictionary. This method
        currently simply removes the private attributes of the object.
        """
        return {
            key: val for key, val in dct.items() if not key.startswith("_")
        }

    def build_default(self, dct):
        """Write the object to the dictionary."""
        dct.update(Default.attrs(self.__dict__))

    def parse_default(self, dct):
        """Read the object from the dictionary."""
        self.__dict__.update(Default.attrs(dct))


class PacketFactory(type):
    """
    A metaclass that is used to register new packet classes as they are being
    defined, and instantiate new packets from their name when necessary.
    """

    _PACKETS = {}

    @staticmethod
    def __new__(mcs, name, bases, attrs):
        """Register a new packet class into the factory."""
        cls = super(PacketFactory, mcs).__new__(mcs, name, bases, attrs)
        if (
            cls.__type__ is not None
            and cls.__type__ not in PacketFactory._PACKETS
        ):
            PacketFactory._PACKETS[cls.__type__] = cls
        return cls

    @classmethod
    def get_class(mcs, dct, server=False):  # noqa: N804
        """
        Instantiate the packet corresponding to the serialized dictionary. It
        will check if the packet type is registered, the deferred the
        request to the specialized packet factory.
        """
        cls = PacketFactory._PACKETS[dct["type"]]
        if type(cls) != mcs:
            cls = type(cls).get_class(dct, server)
        return cls


class Packet(with_metaclass(PacketFactory, Serializable)):
    """
    The base class for every packet received. Currently, the packet can
    only be of two kinds: either it is an event or a command.
    """

    __type__ = None

    def __init__(self):
        super(Packet, self).__init__()
        assert self.__type__ is not None, "__type__ not implemented"

    @staticmethod
    def parse_packet(dct, server=False):
        """Parse the packet from a dictionary."""
        cls = PacketFactory.get_class(dct, server)
        packet = cls.new(dct)
        if isinstance(packet, Reply):
            packet.trigger_initback()
        return packet

    def build_packet(self):
        """Build the packet into a dictionary."""
        dct = collections.defaultdict(collections.defaultdict)
        self.build(dct)
        return dct

    def __repr__(self):
        """
        Return a textual representation of a packet. Currently, it is only
        used to pretty-print the packet contents into the console.
        """
        name = self.__class__.__name__
        if isinstance(self, Query) or isinstance(self, Reply):
            name = self.__parent__.__name__ + "." + name
        attrs = [
            "{}={}".format(k, v)
            for k, v in Default.attrs(self.__dict__).items()
        ]
        return "{}({})".format(name, ", ".join(attrs))


class PacketDeferred(object):
    """
    An Twisted-like deferred object that supports a standard callback, as well
    as a new callback triggered when the expected packet is being instantiated.
    """

    def __init__(self):
        super(PacketDeferred, self).__init__()
        self._errback = None

        self._callback = None
        self._callresult = None
        self._called = False

        self._initback = None
        self._initresult = None
        self._inited = False

    def add_callback(self, callback):
        """Register a callback for this deferred."""
        self._callback = callback
        if self._called:
            self._run_callback()
        return self

    def add_errback(self, errback):
        """Register an errback for this deferred."""
        self._errback = errback
        return self

    def add_initback(self, initback):
        """Register an initback for this deferred."""
        self._initback = initback
        if self._inited:
            self._run_initback()
        return self

    def callback(self, result):
        """Trigger the callback function."""
        if self._called:
            raise RuntimeError("Callback already triggered")
        self._called = True
        self._callresult = result
        self._run_callback()

    def initback(self, result):
        """Trigger the initback function."""
        if self._inited:
            raise RuntimeError("Initback already triggered")
        self._inited = True
        self._initresult = result
        self._run_initback()

    def _run_callback(self):
        """Internal method that calls the callback/errback function."""
        if self._callback:
            try:
                self._callback(self._callresult)
            except Exception as e:
                self._errback(e)

    def _run_initback(self):
        """Internal method that call the initback/errback function."""
        if self._initback:
            try:
                self._initback(self._initresult)
            except Exception as e:
                self._errback(e)


class EventFactory(PacketFactory):
    """A packet factory specialized for event packets."""

    _EVENTS = {}

    @staticmethod
    def __new__(mcs, name, bases, attrs):
        cls = super(EventFactory, mcs).__new__(mcs, name, bases, attrs)
        if (
            cls.__event__ is not None
            and cls.__event__ not in EventFactory._EVENTS
        ):
            EventFactory._EVENTS[cls.__event__] = cls
        return cls

    @classmethod
    def get_class(mcs, dct, server=False):  # noqa: N804
        if server:  # Server only knows about DefaultEvent
            return DefaultEvent

        cls = EventFactory._EVENTS[dct["event_type"]]
        if type(cls) != mcs:
            cls = type(cls).get_class(dct, server)
        return cls


class Event(with_metaclass(EventFactory, Packet)):
    """Base class for all events. They have a subtype and a tick count."""

    __type__ = "event"
    __event__ = None

    def __init__(self):
        super(Event, self).__init__()
        assert self.__event__ is not None, "__event__ not implemented"
        self._tick = 0

    @property
    def tick(self):
        """Get the tick count."""
        return self._tick

    @tick.setter
    def tick(self, tick):
        """Set the tick count."""
        self._tick = tick

    def build(self, dct):
        dct["type"] = self.__type__
        dct["event_type"] = self.__event__
        dct["tick"] = self._tick
        self.build_event(dct)
        return dct

    def parse(self, dct):
        self._tick = dct.pop("tick")
        self.parse_event(dct)
        return self

    def build_event(self, dct):
        """Build the event into a dictionary."""
        pass

    def parse_event(self, dct):
        """Parse the event from a dictionary."""
        pass


class DefaultEvent(Default, Event):
    """
    This is a class that should be subclassed for events that can be serialized
    from their attributes (which should be almost all of them).
    """

    def build_event(self, dct):
        self.build_default(dct)

    def parse_event(self, dct):
        self.parse_default(dct)


class CommandFactory(PacketFactory):
    """A packet factory specialized for commands packets."""

    _COMMANDS = {}

    @staticmethod
    def __new__(mcs, name, bases, attrs):
        cls = super(CommandFactory, mcs).__new__(mcs, name, bases, attrs)
        if (
            cls.__command__ is not None
            and cls.__command__ not in CommandFactory._COMMANDS
        ):
            # Does this command have a query and a reply
            if issubclass(cls, ParentCommand):
                # Register the query
                cls.Query.__parent__ = cls
                cls.Query.__command__ = cls.__command__ + "_query"
                CommandFactory._COMMANDS[cls.Query.__command__] = cls.Query

                # Register the reply
                cls.Reply.__parent__ = cls
                cls.Reply.__command__ = cls.__command__ + "_reply"
                CommandFactory._COMMANDS[cls.Reply.__command__] = cls.Reply
            else:
                CommandFactory._COMMANDS[cls.__command__] = cls
        return cls

    @classmethod
    def get_class(mcs, dct, server=False):  # noqa: N804
        cls = CommandFactory._COMMANDS[dct["command_type"]]
        if type(cls) != mcs:
            cls = type(cls).get_class(dct, server)
        return cls


class Command(with_metaclass(CommandFactory, Packet)):
    """Base class for all commands. Commands have a subtype."""

    __type__ = "command"
    __command__ = None

    def __init__(self):
        super(Command, self).__init__()
        assert self.__command__ is not None, "__command__ not implemented"

    def build(self, dct):
        dct["type"] = self.__type__
        dct["command_type"] = self.__command__
        self.build_command(dct)
        return dct

    def parse(self, dct):
        self.parse_command(dct)
        return self

    def build_command(self, dct):
        """Build a command into a dictionary."""
        pass

    def parse_command(self, dct):
        """Parse a command from a dictionary."""
        pass


class DefaultCommand(Default, Command):
    """
    This is a class that should be subclassed for events that can be serialized
    from their attributes (which is way rarer than for events).
    """

    def build_command(self, dct):
        self.build_default(dct)

    def parse_command(self, dct):
        self.parse_default(dct)


class ParentCommand(Command):
    """
    This class is used to define a command that expects an answer. Basically,
    it should subclass this class, and define two instance attributes Query and
    Reply that should themselves subclass packets.Query and packets.Reply.
    """

    __callbacks__ = {}
    Query, Reply = None, None


class Query(Packet):
    """A query is a packet sent that will expect to received a reply."""

    __parent__ = None

    _NEXT_ID = itertools.count()

    def __init__(self):
        super(Query, self).__init__()
        self._id = next(Query._NEXT_ID)

    @property
    def id(self):
        """Get the query identifier."""
        return self._id

    def build(self, dct):
        super(Query, self).build(dct)
        dct["__id__"] = self._id
        return dct

    def parse(self, dct):
        super(Query, self).parse(dct)
        self._id = dct["__id__"]
        return self

    def register_callback(self, d):
        """Register a callback triggered when the answer is received."""
        self.__parent__.__callbacks__[self._id] = d


class Reply(Packet):
    """A reply is a packet sent when a query packet is received."""

    __parent__ = None

    def __init__(self, query):
        super(Reply, self).__init__()
        self._id = query.id

    @property
    def id(self):
        """Get the query identifier."""
        return self._id

    def build(self, dct):
        super(Reply, self).build(dct)
        dct["__id__"] = self._id
        return dct

    def parse(self, dct):
        super(Reply, self).parse(dct)
        self._id = dct["__id__"]
        return self

    def trigger_callback(self):
        """Trigger the finalization callback of the query."""
        d = self.__parent__.__callbacks__[self._id]
        d.callback(self)
        del self.__parent__.__callbacks__[self._id]

    def trigger_initback(self):
        """Trigger the initialization callback of the query."""
        d = self.__parent__.__callbacks__[self._id]
        d.initback(self)


class Container(Command):
    """
    Containers are a special kind of commands that will contain some raw data.
    This is useful for exchanging files as they don't have to be encoded.
    """

    @staticmethod
    def __new__(cls, *args, **kwargs):
        self = super(Container, cls).__new__(cls)
        self._upback = None
        self._downback = None
        return self

    def __init__(self):
        super(Container, self).__init__()
        self._size = 0
        self._content = None
        self._upback = None
        self._downback = None

    @property
    def content(self):
        """Get the raw content."""
        return self._content

    @content.setter
    def content(self, content):
        """Set the raw content."""
        self._content = content
        self._size = len(content)

    @property
    def size(self):
        """Get the content size."""
        return self._size

    @size.setter
    def size(self, size):
        """Set the content size."""
        self._size = size

    @property
    def upback(self):
        """Get the upload callback triggered when some data is sent."""
        return self._upback

    @upback.setter
    def upback(self, upback):
        """Set the upload callback triggered when some data is sent."""
        self._upback = upback

    @property
    def downback(self):
        """Get the download callback triggered when some data is received."""
        return self._downback

    @downback.setter
    def downback(self, downback):
        """Set the download callback triggered when some data is received."""
        self._downback = downback

    def build(self, dct):
        super(Container, self).build(dct)
        dct["__size__"] = len(self._content)
        return dct

    def parse(self, dct):
        self._size = dct["__size__"]
        super(Container, self).parse(dct)
        return self

```

`idarling/shared/server.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import logging
import os
import sys
import socket
import ssl
import threading
import bz2
import json
from functools import partial

from .commands import (
    CreateProject,
    CreateBinary,
    CreateSnapshot,
    DownloadFile,
    InviteToLocation,
    JoinSession,
    LeaveSession,
    ListProjects,
    ListBinaries,
    ListSnapshots,
    RenameBinary,
    UpdateFile,
    UpdateLocation,
    UpdateUserColor,
    UpdateUserName,
    DeleteProject,
    DeleteBinary,
    DeleteSnapshot,
)
from .discovery import ClientsDiscovery
from .packets import Command, Event
from .sockets import ClientSocket, ServerSocket
from .storage import Storage


class ServerClient(ClientSocket):
    """
    This class represents a client socket for the server. It implements all the
    handlers for the packet the client is susceptible to send.
    """

    def __init__(self, logger, parent=None):
        """

        @type parent: Server
        """

        ClientSocket.__init__(self, logger, parent)
        self._project = None
        self._binary = None
        self._snapshot = None
        self._name = None
        self._color = None
        self._ea = None
        self._handlers = {}

    @property
    def project(self):
        return self._project

    @property
    def binary(self):
        return self._binary

    @property
    def snapshot(self):
        return self._snapshot

    @property
    def name(self):
        return self._name

    @property
    def color(self):
        return self._color

    @property
    def ea(self):
        return self._ea

    def wrap_socket(self, sock):
        ClientSocket.wrap_socket(self, sock)

        # Setup command handlers
        self._handlers = {
            ListProjects.Query: self._handle_list_projects,
            ListBinaries.Query: self._handle_list_binaries,
            ListSnapshots.Query: self._handle_list_snapshots,
            CreateProject.Query: self._handle_create_project,
            CreateBinary.Query: self._handle_create_binary,
            CreateSnapshot.Query: self._handle_create_snapshot,
            UpdateFile.Query: self._handle_upload_file,
            DownloadFile.Query: self._handle_download_file,
            RenameBinary.Query: self._handle_rename_binary,
            JoinSession: self._handle_join_session,
            LeaveSession: self._handle_leave_session,
            UpdateLocation: self._handle_update_location,
            InviteToLocation: self._handle_invite_to_location,
            UpdateUserName: self._handle_update_user_name,
            UpdateUserColor: self._handle_update_user_color,
            DeleteProject.Query: self._handle_delete_project,
            DeleteBinary.Query: self._handle_delete_binary,
            DeleteSnapshot.Query: self._handle_delete_snapshot,
        }

        # Add host and port as a prefix to our logger
        prefix = "%s:%d" % sock.getpeername()

        class CustomAdapter(logging.LoggerAdapter):
            def process(self, msg, kwargs):
                return "(%s) %s" % (prefix, msg), kwargs

        self._logger = CustomAdapter(self._logger, {})

    def close_client(self, err=None, notify=True):
        # Notify other users that we disconnected
        self.parent().reject(self)
        if self._project and self._binary and self._snapshot and notify:
            self.parent().forward_users(self, LeaveSession(self.name, False))
        ClientSocket.close_connection(self, err)

    def recv_packet(self, packet):
        if isinstance(packet, Command):
            # Call the corresponding handler
            self._handlers[packet.__class__](packet)

        elif isinstance(packet, Event):
            if not self._project or not self._binary or not self._snapshot:
                self._logger.warning(
                    "Received a packet from an unsubscribed client"
                )
                return True

            # Check for de-synchronization
            tick = self.parent().storage.last_tick(
                self._project, self._binary, self._snapshot
            )
            if tick >= packet.tick:
                self._logger.warning("De-synchronization detected!")
                packet.tick = tick + 1

            # Save the event into the snapshot
            self.parent().storage.insert_event(self, packet)
            # Forward the event to the other users
            self.parent().forward_users(self, packet)

            # Ask for a snapshot of the snapshot if needed
            interval = self.parent().SNAPSHOT_INTERVAL
            if packet.tick and interval and packet.tick % interval == 0:

                def file_downloaded(reply):
                    file_name = "%s_%s_%s.i64" % (self._project, self._binary, self._snapshot)
                    file_path = self.parent().server_file(file_name)

                    # Write the file to disk
                    with open(file_path, "wb") as output_file:
                        output_file.write(reply.content)
                    self._logger.info("Auto-saved file %s" % file_name)

                d = self.send_packet(
                    DownloadFile.Query(self._project, self._binary, self._snapshot)
                )
                d.add_callback(file_downloaded)
                d.add_errback(self._logger.exception)
        else:
            return False
        return True

    def _handle_rename_binary(self, query):
        self._logger.info("Got rename binary request")
        binaries = self.parent().storage.select_binaries(query.project)
        for binary in binaries:
            if binary.name == query.new_name:
                self._logger.error("Attempt to rename binary to existing name")
                return

        # Grab the snapshot lock. This basically means no other client can be
        # connected for a rename to occur.
        db_update_locked = False
        for binary in binaries:
            if binary.name == query.old_name:
                self.parent().client_lock.acquire()
                # Only do the rename if we could lock the db. Otherwise we will
                # mess with other clients.
                db_update_locked = self.parent().db_update_lock.acquire(blocking=False)
                self.parent().client_lock.release()
                if db_update_locked:
                    self.parent().storage.update_binary_name(query.project, query.old_name, query.new_name)
                    self.parent().storage.update_snapshot_binary(query.project, query.old_name, query.new_name)
                    self.parent().storage.update_events_binary(query.project, query.old_name, query.new_name)

                    # We just changed the table entries so be sure to use new names 
                    # for queries
                    snapshots = self.parent().storage.select_snapshots(query.project, query.new_name)
                    for snapshot in snapshots:
                        old_file_name = "%s_%s_%s.i64" % (query.project, query.old_name, snapshot.name)
                        new_file_name = "%s_%s_%s.i64" % (query.project, query.new_name, snapshot.name)
                        old_file_path = self.parent().server_file(old_file_name)
                        new_file_path = self.parent().server_file(new_file_name)
                        # If a rename happens before a file is uploaded, the 
                        # idb won't exist
                        if os.path.exists(old_file_path):
                            self._logger.info("Renaming: %s to %s" % (old_file_path, new_file_name))
                            os.rename(old_file_path, new_file_path)
                        else:
                            self._logger.warning("Skipping file rename due to non existing file: %s" % old_file_path)

                    self.parent().db_update_lock.release()
                else:
                    self._logger.info("Skipping rename due to snapshot lock")

        # Resend an updated list of binary names since it just changed
        binaries = self.parent().storage.select_binaries(query.project)
        self.send_packet(RenameBinary.Reply(query, binaries, db_update_locked))

    def _handle_list_projects(self, query):
        self._logger.info("Got list projects request")
        projects = self.parent().storage.select_projects()
        self.send_packet(ListProjects.Reply(query, projects))

    def _handle_list_binaries(self, query):
        self._logger.info("Got list binaries request")
        binaries = self.parent().storage.select_binaries(query.project)
        self.send_packet(ListBinaries.Reply(query, binaries))

    def _handle_list_snapshots(self, query):
        self._logger.info("Got list snapshots request")
        snapshots = self.parent().storage.select_snapshots(query.project, query.binary)
        for snapshot in snapshots:
            snapshot_info = snapshot.project, snapshot.binary, snapshot.name
            file_name = "%s_%s_%s.i64" % (snapshot_info)
            file_path = self.parent().server_file(file_name)
            if os.path.isfile(file_path):
                snapshot.tick = self.parent().storage.last_tick(*snapshot_info)
            else:
                snapshot.tick = -1
        self.send_packet(ListSnapshots.Reply(query, snapshots))

    def _handle_create_project(self, query):
        self.parent().storage.insert_project(query.project)
        self.send_packet(CreateProject.Reply(query))

    def _handle_create_binary(self, query):
        self.parent().storage.insert_binary(query.binary)
        self.send_packet(CreateBinary.Reply(query))

    def _handle_create_snapshot(self, query):
        self.parent().storage.insert_snapshot(query.snapshot)
        self.send_packet(CreateSnapshot.Reply(query))

    def _handle_upload_file(self, query):
        snapshot = self.parent().storage.select_snapshot(
            query.project, query.binary, query.snapshot
        )
        file_name = "%s_%s_%s.i64" % (query.project, snapshot.binary, snapshot.name)
        file_path = self.parent().server_file(file_name)

        # Write the file received to disk
        decompressed_content = bz2.decompress(query.content)
        with open(file_path, "wb") as output_file:
            output_file.write(decompressed_content)
        self._logger.info("Saved file %s" % file_name)
        self.send_packet(UpdateFile.Reply(query))

    def _handle_download_file(self, query):
        snapshot = self.parent().storage.select_snapshot(
            query.project, query.binary, query.snapshot
        )
        file_name = "%s_%s_%s.i64" % (query.project, snapshot.binary, snapshot.name)
        file_path = self.parent().server_file(file_name)

        # Read file from disk and sent it
        reply = DownloadFile.Reply(query)
        with open(file_path, "rb") as input_file:
            uncompressed_content = input_file.read()
        reply.content = bz2.compress(uncompressed_content)
        self._logger.info("Loaded file %s" % file_name)
        self.send_packet(reply)

    def _handle_join_session(self, packet):
        self._project = packet.project
        self._binary = packet.binary
        self._snapshot = packet.snapshot
        self._name = packet.name
        self._color = packet.color
        self._ea = packet.ea

        # Inform the other users that we joined
        packet.silent = False
        self.parent().forward_users(self, packet)

        # Inform ourselves about the other users
        for user in self.parent().get_users(self):
            self.send_packet(
                JoinSession(
                    packet.project,
                    packet.binary,
                    packet.snapshot,
                    packet.tick,
                    user.name,
                    user.color,
                    user.ea,
                )
            )

        # Send all missed events
        events = self.parent().storage.select_events(
            self._project, self._binary, self._snapshot, packet.tick
        )
        self._logger.debug("Sending %d missed events..." % len(events))
        for event in events:
            self.send_packet(event)
        self._logger.debug("Done sending %d missed events" % len(events))

    def _handle_leave_session(self, packet):
        # Inform others users that we are leaving
        packet.silent = False
        self.parent().forward_users(self, packet)

        self._project = None
        self._binary = None
        self._snapshot = None
        self._name = None
        self._color = None

    def _handle_update_location(self, packet):
        self.parent().forward_users(self, packet)

    def _handle_invite_to_location(self, packet):
        def matches(other):
            return other.name == packet.name or packet.name == "everyone"

        packet.name = self._name
        self.parent().forward_users(self, packet, matches)

    def _handle_update_user_name(self, packet):
        # FXIME: ensure the name isn't already taken
        self._name = packet.new_name
        self.parent().forward_users(self, packet)

    def _handle_update_user_color(self, packet):
        self.parent().forward_users(self, packet)

    def _delete_project_files(self, project):
        binaries = self.parent().storage.select_binaries(project)
        for binary in binaries:
            self._delete_binary_files(project, binary.name)

    def _delete_binary_files(self, project, binary):
        snapshots = self.parent().storage.select_snapshots(project, binary)
        for db in snapshots:
            self._delete_snapshot_files(project, binary, db.name)

    def _delete_snapshot_files(self, project, binary, snapshot):
        file_name = "%s_%s_%s.i64" % (project, binary, snapshot)
        file_path = self.parent().server_file(file_name)
        try:
            os.remove(file_path)
        except FileNotFoundError:
            pass

    def _handle_delete_project(self, packet):
        def match_project(user, project):
            return user.project == project

        if  len(self.parent().get_users(self,partial(match_project, project=packet.project))):
            self.send_packet(DeleteProject.Reply(packet, False))
        else:
            self._delete_project_files(packet.project)
            self.parent().storage.delete_project(packet.project)
            # self.parent().forward_users(self,packet,partial(match_project,project=packet.project))
            self.send_packet(DeleteProject.Reply(packet, True))

    def _handle_delete_binary(self,packet):
        def match_user(user, project, binary):
            return user.project == project and user.binary == binary

        if  len(self.parent().get_users(self, partial(match_user, project=packet.project, binary=packet.binary))):
            self.send_packet(DeleteBinary.Reply(packet, False))
        else:
            self._delete_binary_files(packet.project, packet.binary)
            self.parent().storage.delete_binary(packet.project, packet.binary)
            # self.parent().forward_users(self,packet,partial(match_user, project=packet.project,binary=packet.binary))
            self.send_packet(DeleteBinary.Reply(packet, True))

    def _handle_delete_snapshot(self, packet):
        def match_user(user, project, binary, snapshot):
            return user.project == project and user.binary == binary and user.snapshot == snapshot

        if len(self.parent().get_users(self,partial(match_user, project=packet.project, binary=packet.binary,snapshot=packet.snapshot))):
            self.send_packet(DeleteSnapshot.Reply(packet, False))
        else:
            self._delete_snapshot_files(packet.project, packet.binary, packet.snapshot)
            self.parent().storage.delete_snapshot(packet.project, packet.binary, packet.snapshot)
            # self.parent().forward_users(self, packet)
            self.send_packet(DeleteSnapshot.Reply(packet, True))

class Migrate(object):

    # This migration typically took ~2h with a database with 140k+ events
    def do1(server):
        server._logger.warning("Migration do1(), please don't interrupt that process...")

        server._logger.warning("Migration do1(): saving old db...")
        if os.path.exists(server.server_file("database_1.db")):
            server._logger.error("Migration do1(): database_1.db already exist!")
            sys.exit(1)
        os.rename(server.server_file("database.db"), server.server_file("database_1.db"))

        server._logger.warning("Migration do1(): loading old db...")
        old_storage = Storage(server.server_file("database_1.db"))
        old_level1_rows = old_storage._select_all("groups")
        old_level2_rows = old_storage._select_all("projects")
        old_level3_rows = old_storage._select_all("databases")
        old_events_rows = old_storage._select_all("events")

        new_storage = Storage(server.server_file("database.db"))
        new_storage.initialize()

        server._logger.warning("Migration do1(): inserting projects...")
        new_storage._insert_all("projects", old_level1_rows)

        server._logger.warning("Migration do1(): inserting binaries...")
        new_level2_rows = []
        for row in old_level2_rows:
            row["project"] = row.pop("group_name")
            new_level2_rows.append(row)
        new_storage._insert_all("binaries", new_level2_rows)

        server._logger.warning("Migration do1(): inserting snapshots...")
        new_level3_rows = []
        for row in old_level3_rows:
            row["binary"] = row.pop("project")
            row["project"] = row.pop("group_name")
            new_level3_rows.append(row)
        new_storage._insert_all("snapshots", new_level3_rows)

        server._logger.warning("Migration do1(): inserting events...")
        i = 1
        for row in old_events_rows:
            if i % 1000 == 0:
                server._logger.warning("Migration do1(): %d events done..." % i)
            row["snapshot"] = row.pop("database")
            row["binary"] = row.pop("project")
            row["project"] = row.pop("group_name")
            new_storage._insert("events", row)
            i += 1

        server._logger.warning("Migration do1(): done")

class Server(ServerSocket):
    """
    This class represents a server socket for the server. It is used by both
    the integrated and dedicated server implementations. It doesn't do much.
    """

    SNAPSHOT_INTERVAL = 0  # ticks

    def __init__(self, logger, parent=None, level=None):
        ServerSocket.__init__(self, logger, parent)
        self._ssl = None
        self._clients = []

        # Load the configuration
        self._config_path = self.server_file("config_server.json")
        self._config = self.default_config()
        self.load_config()
        if level != None:
            self._logger.setLevel(level)
        else:
            self._logger.setLevel(self._config["level"])
        self.save_config()

        # Check if any migration
        self.migrate()

        # Initialize the storage
        self._storage = Storage(self.server_file("database.db"))
        self._storage.initialize()

        self._discovery = ClientsDiscovery(logger)
        # A temporory lock to stop clients while updating other locks
        self.client_lock = threading.Lock()
        # A long term lock that stops breaking database updates when multiple
        # clients are connected
        self.db_update_lock = threading.Lock()

    @property
    def config_path(self):
        return self._config_path

    @property
    def config(self):
        return self._config

    @property
    def storage(self):
        return self._storage

    @property
    def host(self):
        return self._socket.getsockname()[0]

    @property
    def port(self):
        return self._socket.getsockname()[1]

    @staticmethod
    def default_config():
        """
        Return the default configuration options. This is used to initialize
        the configuration file the first time the server is started
        """
        return {
            "level": logging.INFO,
            "migration": -1,
        }

    def migrate(self):
        migrationId = self.config["migration"]
        while migrationId >= 0:
            migrationId += 1
            method_name = "do%d" % migrationId
            try:
                method = getattr(Migrate, method_name)
            except AttributeError:
                break
            method(self)
            self.config["migration"] = migrationId
            self.save_config()

    def load_config(self):
        """
        Load the configuration file. It is a JSON file that contains all the
        settings of the server.
        """
        if not os.path.isfile(self.config_path):
            return
        with open(self.config_path, "rb") as config_file:
            try:
                self._config.update(json.loads(config_file.read()))
            except ValueError:
                self._logger.warning("Couldn't load config file")
                return
            self._logger.debug("Loaded config: %s" % self._config)

    def save_config(self):
        """Save the configuration file."""
        self._config["level"] = self._logger.level
        with open(self.config_path, "w") as config_file:
            config_file.write(json.dumps(self._config))
            self._logger.debug("Saved config: %s" % self._config)

    def start(self, host, port=0, ssl_=None):
        """Starts the server on the specified host and port."""
        self._logger.info("Starting the server on %s:%d" % (host, port))

        # Load the system certificate chain
        self._ssl = ssl_
        if self._ssl:
            cert, key = self._ssl
            self._ssl = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            self._ssl.load_cert_chain(certfile=cert, keyfile=key)

        # Create, bind and set the socket options
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        try:
            sock.bind((host, port))
        except socket.error as e:
            self._logger.warning("Could not start the server")
            self._logger.exception(e)
            return False
        sock.settimeout(0)  # No timeout
        sock.setblocking(0)  # No blocking
        sock.listen(5)
        self.set_socket(sock)

        # Start discovering clients
        host, port = sock.getsockname()
        self._discovery.start(host, port, self._ssl)
        return True

    def stop(self):
        """Terminates all the connections and stops the server."""
        self._logger.info("Stopping the server")
        self._discovery.stop()
        # Disconnect all clients
        for client in list(self._clients):
            client.close_client(notify=False)
        self.close_listener()
        try:
            self.db_update_lock.release()
        except RuntimeError:
            # It might not actually be locked
            pass
        return True

    def _accept(self, sock):
        """Called when an user connects."""
        client = ServerClient(self._logger, self)

        if self._ssl:
            # Wrap the socket in an SSL tunnel
            sock = self._ssl.wrap_socket(
                sock, server_side=True, do_handshake_on_connect=False
            )

        sock.settimeout(0)  # No timeout
        sock.setblocking(0)  # No blocking

        # If we already have at least one connection, lock the mutex that
        # prevents database updates like renaming. Connecting clients will
        # block until an existing blocking operation, like a porject rename, is
        # completed
        self.client_lock.acquire()
        if len(self._clients) == 1:
            self.db_update_lock.acquire()
        client.wrap_socket(sock)
        self._clients.append(client)
        self.client_lock.release()

    def reject(self, client):
        """Called when a user disconnects."""

        # Allow clients to update database again
        self.client_lock.acquire()
        self._clients.remove(client)
        if len(self._clients) <= 1:
            try:
                self.db_update_lock.release()
            except RuntimeError:
                pass

        self.client_lock.release()

    def get_users(self, client, matches=None):
        """Get the other users on the same snapshot."""
        users = []
        for user in self._clients:
            if (matches is None and
                (user.binary != client.binary
                or user.snapshot != client.snapshot)
            ):
                continue
            if user == client or (matches and not matches(user)):
                continue
            users.append(user)
        return users

    def forward_users(self, client, packet, matches=None):
        """Sends the packet to the other users on the same snapshot."""
        for user in self.get_users(client, matches):
            user.send_packet(packet)

    def server_file(self, filename):
        """Get the absolute path of a local resource."""
        raise NotImplementedError("server_file() not implemented")

```

`idarling/shared/sockets.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import collections
import errno
import json
import os
import socket
import ssl
import sys

from PySide6.QtCore import QCoreApplication, QEvent, QObject, QSocketNotifier

from .packets import Container, Packet, PacketDeferred, Query, Reply
from ..shared.commands import (
    UpdateLocation,
)

class PacketEvent(QEvent):
    """
    This Qt event is fired when a new packet is received by the client,
    urging it to go check the incoming messages queue.
    """

    EVENT_TYPE = QEvent.Type(QEvent.registerEventType())

    def __init__(self):
        super(PacketEvent, self).__init__(PacketEvent.EVENT_TYPE)


class ClientSocket(QObject):
    """
    This class is acts a bridge between a client socket and the Qt event loop.
    By using a QSocketNotifier, we can be notified when some data is ready to
    be read or written on the socket, not requiring an extra thread.
    """

    MAX_DATA_SIZE = 65535

    def __init__(self, logger, parent=None):
        QObject.__init__(self, parent)
        self._logger = logger
        self._socket = None
        self._server = parent and isinstance(parent, ServerSocket)

        self._read_buffer = bytearray()
        self._read_notifier = None
        self._read_packet = None

        self._write_buffer = bytearray()
        self._write_cursor = 0
        self._write_notifier = None
        self._write_packet = None

        self._connected = False
        self._outgoing = collections.deque()
        self._incoming = collections.deque()

    @property
    def connected(self):
        """Is the underlying socket connected?"""
        return self._connected

    def wrap_socket(self, sock):
        """Sets the underlying socket to use."""
        self._read_notifier = QSocketNotifier(
            sock.fileno(), QSocketNotifier.Read, self
        )
        self._read_notifier.activated.connect(self._notify_read)
        self._read_notifier.setEnabled(True)

        self._write_notifier = QSocketNotifier(
            sock.fileno(), QSocketNotifier.Write, self
        )
        self._write_notifier.activated.connect(self._notify_write)
        self._write_notifier.setEnabled(True)

        self._socket = sock

    def close_connection(self, err=None):
        """Terminates the current connection."""
        if not self._socket:
            return

        if err:
            if isinstance(err, ConnectionRefusedError):
                self._logger.error("Connection refused")
            else:
                self._logger.exception(err)
        self._logger.info("Disconnected")
        self._read_notifier.setEnabled(False)
        self._write_notifier.setEnabled(False)
        try:
            self._socket.shutdown(socket.SHUT_RDWR)
            self._socket.close()
        except socket.error:
            pass
        self._socket = None
        self._connected = False

    def set_keep_alive(self, cnt, intvl, idle):
        """
        Set the TCP keep-alive of the underlying socket.

        It activates after idle seconds of idleness, sends a keep-alive ping
        once every intvl seconds, and disconnects after `cnt`failed pings.
        """
        # Taken from https://github.com/markokr/skytools/
        tcp_keepcnt = getattr(socket, "TCP_KEEPCNT", None)
        tcp_keepintvl = getattr(socket, "TCP_KEEPINTVL", None)
        tcp_keepidle = getattr(socket, "TCP_KEEPIDLE", None)
        tcp_keepalive = getattr(socket, "TCP_KEEPALIVE", None)
        sio_keeplive_vals = getattr(socket, "SIO_KEEPALIVE_VALS", None)
        if (
            tcp_keepidle is None
            and tcp_keepalive is None
            and sys.platform == "darwin"
        ):
            tcp_keepalive = 0x10

        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
        if tcp_keepcnt is not None:
            self._socket.setsockopt(socket.IPPROTO_TCP, tcp_keepcnt, cnt)
        if tcp_keepintvl is not None:
            self._socket.setsockopt(socket.IPPROTO_TCP, tcp_keepintvl, intvl)
        if tcp_keepidle is not None:
            self._socket.setsockopt(socket.IPPROTO_TCP, tcp_keepidle, idle)
        elif tcp_keepalive is not None:
            self._socket.setsockopt(socket.IPPROTO_TCP, tcp_keepalive, idle)
        elif sio_keeplive_vals is not None:
            self._socket.ioctl(
                sio_keeplive_vals, (1, idle * 1000, intvl * 1000)
            )

    def _check_socket(self):
        """Check if the connection has been established yet."""
        # Ignore if you're already connected
        if self._connected:
            return True

        # Check if the connection was successful
        ret = self._socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
        if ret != 0:
            if ret != errno.EINPROGRESS and ret != errno.EWOULDBLOCK:
                self.close_connection(socket.error(ret, os.strerror(ret)))
            return False
        else:
            self._connected = True
            self._logger.info("Connected")
            return True

    def _notify_read(self):
        """Callback called when some data is ready to be read on the socket."""
        if not self._check_socket():
            return

        # Read as many bytes as possible
        try:
            data = self._socket.recv(ClientSocket.MAX_DATA_SIZE)
            if not data:
                self.close_connection()
                return
        except socket.error as e:
            if (
                e.errno not in (errno.EAGAIN, errno.EWOULDBLOCK)
                and not isinstance(e, ssl.SSLWantReadError)
                and not isinstance(e, ssl.SSLWantWriteError)
            ):
                self.close_connection(e)
            return  # No more data available
        self._read_buffer.extend(data)

        # Split the received data on new lines (= packets)
        while True:
            if self._read_packet is None:
                if b"\n" in self._read_buffer:
                    pos = self._read_buffer.index(b"\n")
                    line = self._read_buffer[:pos]
                    self._read_buffer = self._read_buffer[
                        pos + 1 :  # noqa: E203
                    ]

                    # Try to parse the line (= packet)
                    try:
                        try:
                            decoded = line.decode("utf-8")
                        except UnicodeDecodeError as e:
                            # Received binary data (for example an SSL/TLS
                            # handshake) on a plaintext socket. Close the
                            # connection to avoid trying to parse arbitrary
                            # binary data as JSON.
                            self._logger.warning(
                                "Invalid (non-UTF8) packet received: %s", line
                            )
                            self._logger.debug("Closing connection")
                            self.close_connection()
                            return

                        dct = json.loads(decoded)
                        self._read_packet = Packet.parse_packet(dct, self._server)
                    except Exception as e:
                        msg = "Invalid packet received: %s" % line
                        self._logger.warning(msg)
                        self._logger.exception(e)
                        continue
                else:
                    break  # Not enough data for a packet

            else:
                if isinstance(self._read_packet, Container):
                    avail = len(self._read_buffer)
                    total = self._read_packet.size

                    # Trigger the downback
                    if self._read_packet.downback:
                        self._read_packet.downback(min(avail, total), total)

                    # Read the container's content
                    if avail >= total:
                        self._read_packet.content = self._read_buffer[:total]
                        self._read_buffer = self._read_buffer[total:]
                    else:
                        break  # Not enough data for a packet

                self._incoming.append(self._read_packet)
                self._read_packet = None

        if self._incoming:
            QCoreApplication.instance().postEvent(self, PacketEvent())

    def _notify_write(self):
        """Callback called when some data is ready to be written on the socket."""
        if not self._check_socket():
            return

        if self._write_cursor >= len(self._write_buffer):
            if not self._outgoing:
                self._write_notifier.setEnabled(False)
                return  # No more packets to send
            self._write_packet = self._outgoing.popleft()

            # Dump the packet as a line
            try:
                line = json.dumps(self._write_packet.build_packet())
                line = line.encode("utf-8") + b"\n"
            except Exception as e:
                msg = "Invalid packet being sent: %s" % self._write_packet
                self._logger.warning(msg + "\n")
                self._logger.exception(str(e) + "\n")
                return

            # Write the container's content
            self._write_buffer = bytearray(line)
            self._write_cursor = 0
            if isinstance(self._write_packet, Container):
                data = self._write_packet.content
                self._write_buffer.extend(bytearray(data))
                self._write_packet.size += len(line)

        # Send as many bytes as possible
        try:
            pos = self._write_cursor
            avail = len(self._write_buffer) - pos
            count = min(avail, ClientSocket.MAX_DATA_SIZE)
            data = self._write_buffer[pos : pos + count]  # noqa: E203
            self._write_cursor += self._socket.send(data)
        except socket.error as e:
            if (
                e.errno not in (errno.EAGAIN, errno.EWOULDBLOCK)
                and not isinstance(e, ssl.SSLWantReadError)
                and not isinstance(e, ssl.SSLWantWriteError)
            ):
                self.close_connection(e)
            return  # Can't write anything

        # Trigger the upback
        if (
            isinstance(self._write_packet, Container)
            and self._write_packet.upback
        ):
            self._write_packet.size -= count
            total = len(self._write_packet.content)
            sent = max(total - self._write_packet.size, 0)
            self._write_packet.upback(sent, total)

        if (
            self._write_cursor >= len(self._write_buffer)
            and not self._outgoing
        ):
            self._write_notifier.setEnabled(False)

    def event(self, event):
        """Callback called when a Qt event is fired."""
        if isinstance(event, PacketEvent):
            self._dispatch()
            event.accept()
            return True
        else:
            event.ignore()
            return False

    def _dispatch(self):
        """Callback called when a PacketEvent is received."""
        while self._incoming:
            packet = self._incoming.popleft()
            if not isinstance(packet, UpdateLocation):
                self._logger.debug("Received packet: %s" % packet)

            # Notify for replies
            if isinstance(packet, Reply):
                packet.trigger_callback()

            # Otherwise forward to the subclass
            elif not self.recv_packet(packet):
                self._logger.warning("Unhandled packet received: %s" % packet)

    def send_packet(self, packet):
        """Sends a packet the other party."""
        if not self._connected:
            self._logger.warning("Sending packet while disconnected")
            return None

        # UpdateLocation are sent very often so not logging
        if not isinstance(packet, UpdateLocation):
            self._logger.debug("Sending packet: %s" % packet)

        # Enqueue the packet
        self._outgoing.append(packet)
        if not self._write_notifier.isEnabled():
            self._write_notifier.setEnabled(True)

        # Queries return a packet deferred
        if isinstance(packet, Query):
            d = PacketDeferred()
            packet.register_callback(d)
            return d
        return None

    def recv_packet(self, packet):
        """Receives a packet from the other party."""
        raise NotImplementedError("recv_packet() not implemented")


class ServerSocket(QObject):
    """
    This class is acts a bridge between a server socket and the Qt event loop.
    See the ClientSocket class for a more detailed explanation.
    """

    def __init__(self, logger, parent=None):
        QObject.__init__(self, parent)
        self._logger = logger
        self._socket = None
        self._connected = False
        self._accept_notifier = None

    @property
    def connected(self):
        """Is the underlying socket connected?"""
        return self._connected

    def set_socket(self, sock):
        """Sets the underlying socket to utilize."""
        self._accept_notifier = QSocketNotifier(
            sock.fileno(), QSocketNotifier.Read, self
        )
        self._accept_notifier.activated.connect(self._notify_accept)
        self._accept_notifier.setEnabled(True)

        self._socket = sock
        self._connected = True

    def close_listener(self, err=None):
        """Terminates the current connection."""
        if not self._socket:
            return
        if err:
            self._logger.warning("Connection lost")
            self._logger.exception(err)
        self._accept_notifier.setEnabled(False)
        try:
            self._socket.close()
        except socket.error:
            pass
        self._socket = None
        self._connected = False

    def _notify_accept(self):
        """Callback called when a client is connecting."""
        while True:
            try:
                sock, address = self._socket.accept()
            except socket.error as e:
                if e.errno in (errno.EAGAIN, errno.EWOULDBLOCK):
                    break
                self.close_listener(e)
                break
            self._accept(sock)

    def _accept(self, socket):
        """Handles the client who newly connected."""
        raise NotImplementedError("accept() is not implemented")

```

`idarling/shared/storage.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import json
import sqlite3

from .models import Project, Binary, Snapshot
from .packets import Default, DefaultEvent


class Storage(object):
    """
    This object is used to access the SQL database used by the server. It
    also defines some utility methods. Currently, only SQLite3 is implemented.
    """

    def __init__(self, dbpath):
        self._conn = sqlite3.connect(dbpath, check_same_thread=False)
        self._conn.isolation_level = None  # No need to commit
        self._conn.row_factory = sqlite3.Row  # Use Row objects

    def initialize(self):
        """Create all the default tables."""
        self._create(
            "projects",
            [
                "name text not null",
                "date text not null",
                "primary key (name)",
            ],
        )
        self._create(
            "binaries",
            [
                "project text not null",
                "name text not null",
                "hash text not null",
                "file text not null",
                "type text not null",
                "date text not null",
                "foreign key(project) references projects(name)",
                "primary key (project, name)",
            ],
        )
        self._create(
            "snapshots",
            [
                "project text not null",
                "binary text not null",
                "name text not null",
                "date text not null",
                "foreign key(project) references projects(name)",
                "foreign key(project, binary) references binaries(project, name)",
                "primary key(project, binary, name)",
            ],
        )
        self._create(
            "events",
            [
                "project text not null",
                "binary text not null",
                "snapshot text not null",
                "tick integer not null",
                "dict text not null",
                "foreign key(project) references projects(name)",
                "foreign key(project, binary) references binaries(project, name)",
                "foreign key(project, binary, snapshot)"
                "     references snapshots(project, binary, name)",
                "primary key(project, binary, snapshot, tick)",
            ],
        )

    def insert_project(self, project):
        """Insert a new project into the database."""
        self._insert("projects", Default.attrs(project.__dict__))

    def select_project(self, name):
        """Select the project with the given name."""
        objects = self.select_projects(name, 1)
        return objects[0] if objects else None

    def select_projects(self, name=None, limit=None):
        """Select the projects with the given name."""
        results = self._select("projects", {"name": name}, limit)
        return [Project(**result) for result in results]

    def insert_binary(self, binary):
        """Insert a new binary into the database."""
        self._insert("binaries", Default.attrs(binary.__dict__))

    def select_binary(self, name):
        """Select the binary with the given name."""
        objects = self.select_binaries(name, 1)
        return objects[0] if objects else None

    def select_binaries(self, project=None, name=None, limit=None):
        """Select the binaries with the given project and name."""
        results = self._select(
            "binaries", {"project": project, "name": name}, limit
        )
        return [Binary(**result) for result in results]

    def update_binary_name(self, project=None, old_name=None, new_name=None, limit=None):
        """Update a binary with the given new name."""
        self._update("binaries", "name", new_name, {"project": project, "name": old_name}, limit)

    def update_snapshot_binary(self, project=None, old_name=None, new_name=None, limit=None):
        """Update a binary with the given new name."""
        self._update("snapshots", "binary", new_name, {"project": project, "binary": old_name}, limit)

    def update_events_binary(self, project=None, old_name=None, new_name=None, limit=None):
        """Update a binary with the given new name."""
        self._update("events", "binary", new_name, {"project": project, "binary": old_name}, limit)

    def insert_snapshot(self, snapshot):
        """Insert a new snapshot into the database."""
        attrs = Default.attrs(snapshot.__dict__)
        attrs.pop("tick")
        self._insert("snapshots", attrs)

    def select_snapshot(self, project, binary, name):
        """Select the snapshot with the given binary and name."""
        objects = self.select_snapshots(project, binary, name, 1)
        return objects[0] if objects else None

    def select_snapshots(self, project=None, binary=None, name=None, limit=None):
        """Select the snapshots with the given binary and name."""
        results = self._select(
            "snapshots", {"project": project, "binary": binary, "name": name}, limit
        )
        return [Snapshot(**result) for result in results]

    def insert_event(self, client, event):
        """Insert a new event into the database."""
        dct = DefaultEvent.attrs(event.__dict__)
        self._insert(
            "events",
            {
                "project": client.project,
                "binary": client.binary,
                "snapshot": client.snapshot,
                "tick": event.tick,
                "dict": json.dumps(dct),
            },
        )

    def select_events(self, project, binary, snapshot, tick):
        """Get all events sent after the given tick count."""
        c = self._conn.cursor()
        sql = "select * from events where project = ? and binary = ? and snapshot = ?"
        sql += "and tick > ? order by tick asc;"
        c.execute(sql, [project, binary, snapshot, tick])
        events = []
        for result in c.fetchall():
            dct = json.loads(result["dict"])
            dct["tick"] = result["tick"]
            events.append(DefaultEvent.new(dct))
        return events

    def last_tick(self, project, binary, snapshot):
        """Get the last tick of the specified binary and snapshot."""
        c = self._conn.cursor()
        sql = "select tick from events where project = ? and binary = ? and snapshot = ? "
        sql += "order by tick desc limit 1;"
        c.execute(sql, [project, binary, snapshot])
        result = c.fetchone()
        return result["tick"] if result else 0

    def delete_events(self, project, binary, snapshot):
        self._delete("events", {"project": project, "binary": binary, "snapshot": snapshot})

    def delete_snapshot(self, project, binary, snapshot):
        self.delete_events(project, binary, snapshot)
        self._delete("snapshots", {"project": project, "binary": binary, "name": snapshot})

    def delete_binary(self, project, binary):
        self._delete("events", {"project": project, "binary": binary})
        self._delete("snapshots", {"project": project, "binary": binary})
        self._delete("binaries", {"project": project, "name": binary})

    def delete_project(self, project):
        self._delete("events", {"project": project})
        self._delete("snapshots", {"project": project})
        self._delete("binaries", {"project": project})
        self._delete("projects", {"name": project})

    def _create(self, table, cols):
        """Create a table with the given name and columns."""
        c = self._conn.cursor()
        sql = "create table if not exists {} ({});"
        c.execute(sql.format(table, ", ".join(cols)))

    def _select_all(self, table):
        """Select all the rows of a table."""
        c = self._conn.cursor()
        sql = "select * from {}".format(table)
        c.execute(sql)
        return [dict(row) for row in c.fetchall()]

    def _select(self, table, fields, limit=None):
        """Select the rows of a table matching the given values."""
        c = self._conn.cursor()
        sql = "select * from {}".format(table)
        fields = {key: val for key, val in fields.items() if val}
        if len(fields):
            cols = ["{} = ?".format(col) for col in fields.keys()]
            sql = (sql + " where {}").format(" and ".join(cols))
        sql += " limit {};".format(limit) if limit else ";"
        c.execute(sql, list(fields.values()))
        return c.fetchall()

    def _delete(self, table, fields):
        """Delete the rows of a table matching the given values."""
        c = self._conn.cursor()
        sql = "delete from {}".format(table)
        fields = {key: val for key, val in fields.items() if val}
        if len(fields):
            cols = ["{} = ?".format(col) for col in fields.keys()]
            sql = (sql + " where {}").format(" and ".join(cols))
        sql +=  ";"
        c.execute(sql, list(fields.values()))


    def _update(self, table, field, new_value, search_fields, limit=None):
        """Update the field in a table matching the given search fields."""
        c = self._conn.cursor()
        sql = "update {} set {} = ?".format(table, field)
        search_fields = {key: val for key, val in search_fields.items() if val}
        if len(search_fields):
            cols = ["{} = ?".format(col) for col in search_fields.keys()]
            sql = (sql + " where {}").format(" and ".join(cols))
        sql += " limit {};".format(limit) if limit else ";"
        conditions = [new_value] + list(search_fields.values())
        #print(sql)
        #print(conditions)
        c.execute(sql, conditions)
        return c.fetchall()

    def _insert_all(self, table, rows):
        for fields in rows:
            self._insert(table, fields)

    def _insert(self, table, fields):
        """Insert a row into a table with the given values."""
        c = self._conn.cursor()
        sql = "insert into {} ({}) values ({});"
        keys = ", ".join(fields.keys())
        vals = ", ".join(["?"] * len(fields))
        c.execute(sql.format(table, keys, vals), list(fields.values()))

```

`idarling/shared/utils.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
import logging

_loggers = {}


def start_logging(log_path, log_name, level):
    """
    Setup the logger: add a new log level, create a logger which logs into
    the console and also into a log files located at: logs/idarling.%pid%.log.
    """
    global _loggers

    if log_name in _loggers:
        return _loggers[log_name]

    # Add a new log level called TRACE, and more verbose that DEBUG.
    logging.TRACE = 5
    logging.addLevelName(logging.TRACE, "TRACE")
    logging.Logger.trace = lambda inst, msg, *args, **kwargs: inst.log(
        logging.TRACE, msg, *args, **kwargs
    )
    logging.trace = lambda msg, *args, **kwargs: logging.log(
        logging.TRACE, msg, *args, **kwargs
    )

    logger = logging.getLogger(log_name)
    if level != None:
        if not isinstance(level, int):
            level = getattr(logging, level)
        logger.setLevel(level)

    # Log to the console with a first format
    logger.propagate = False # avoid having 2 log lines
    stream_handler = logging.StreamHandler()
    log_format = "[idarling][%(levelname)s] %(message)s"
    formatter = logging.Formatter(fmt=log_format)
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)

    # Log to the disk with a second format
    file_handler = logging.FileHandler(log_path)
    log_format = "[%(asctime)s][%(levelname)s] %(message)s"
    formatter = logging.Formatter(fmt=log_format, datefmt="%H:%M:%S")
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    _loggers[log_name] = logger
    return logger

```

`idarling/test/delete_netnode.py`:

```py
# Careful: there is a callback called when the IDB is closed or when we connect
# to the server so the netnode is recreated if idarling is running which we want 
# to avoid. 
# A workaround is to temporarily disable idarling by removing the plugin so it
# does not load to avoid the netnode to be recreated but it is annoying.
# A better way is to set IDAUSR to a path that does not exists so no plugin is loaded
# see ida_noplugin.bat
import ida_netnode
NETNODE_NAME = "$ idarling"
node = ida_netnode.netnode(NETNODE_NAME)
if ida_netnode.exist(node):
    node.kill()
    print('[+] \"%s\" node killed in action' % NETNODE_NAME)
else:
    print('[x] \"%s\" node does not exist' % NETNODE_NAME)
```

`idarling/test/ida_noplugin.bat`:

```bat
@echo off

REM Sometimes we need to temporarily disable idarling by removing the plugin so it
REM does not load to avoid.
REM A better way is to set IDAUSR to a path that does not exists so no plugin is loaded
REM https://www.hex-rays.com/products/ida/support/idadoc/1375.shtml
set IDAUSR=C:\notexist

REM Start IDA
"C:\Program Files\IDA Pro 7.5\ida.exe"
```

`idarling/test/kernel32_test_events.py`:

```py
# hardcoded for kernel32.dll
#
# Usage:
# 1. Load kernel32.dll with symbols in IDA
# 2. Enable TRACE level logs on both IDArling IDA plugin and remote server
# 3. Connect to IDArling server from IDA and save IDB before doing anything in IDA
# 4. run IDA script: test_events.py
# 5. check events being sent by IDA plugin / received by server
# 6. Close IDA and re-open previously saved snapshot
# 7. Check replay of events sent by server / received by IDA plugin

import time, ida_hexrays

print("[+] Create nops at 0x78D35379 -> MakeCodeEvent")
create_insn(0x78D35379)
print("[+] Create 3-byte data at 0x78DBDC90 -> MakeDataEvent")
create_data(0x78DBDC90, 1024, 3, -1)
print("[+] Rename at 0x78DBDC90 -> RenamedEvent")
set_name(0x78DBDC90, "TestName", 0)

print("[+] Add an empty function at 0x78DE7B30 and 0x78DF3170 -> FuncAddedEvent")
add_func(0x78DE7B30)
add_func(0x78DF3170)

print("[+] Delete previous function at 0x78DF3170 -> DeletingFuncEvent")
del_func(0x78DF3170)

# XXX - SetFuncStartEvent
# XXX - SetFuncEndEvent
# XXX - FuncTailAppendedEvent
# XXX - FuncTailDeletedEvent
# XXX - TailOwnerChangedEvent

print("[+] Set 2 comments in assembly at 0x78DF3170 and 0x78DF3171 -> CmtChangedEvent")
set_cmt(0x78DF3170, "test comment non repeatable", 0)
set_cmt(0x78DF3171, "test comment repeatable", 1)

print("[+] Set a function comment at 0x78DBB050 -> RangeCmtChangedEvent")
func = ida_funcs.get_func(0x78DBB050)
ida_funcs.set_func_cmt(func, "function comment", 0)

print("[+] Set 2 comments before and after at 0x78DE7B30 -> CmtChangedEvent")
ida_lines.add_extra_cmt(0x78DE7B30, 1, "previous comment")
ida_lines.add_extra_cmt(0x78DE7B30, 0, "next comment")

# XXX - TiChangedEvent
# XXX - LocalTypesChangedEvent
# XXX - OpTypeChangedEvent

print("[+] Change the argument: 0C000000D hexadecimal to decimal at 0x78DBB46A in assembly  -> OpTypeChangedEvent")
op_dec(0x78DBB46A, 1)

print("[+] Create an enum -> EnumCreatedEvent")
ida_enum.add_enum(BADADDR, "test_enum_name", 0)
ida_enum.add_enum(BADADDR, "test_enum_name_to_rename", 0)
ida_enum.add_enum(BADADDR, "test_enum_name_to_delete", 0)

print("[+] Delete an enum -> EnumDeletedEvent")
ida_enum.del_enum(ida_enum.get_enum("test_enum_name_to_delete"))
        
print("[+] Rename an enum -> EnumRenamedEvent")
enum = ida_enum.get_enum("test_enum_name_to_rename")
ida_enum.set_enum_name(enum, "test_enum_renamed")

# XXX - EnumBfChangedEvent
# XXX - EnumCmtChangedEvent

print("[+] Add enum members -> EnumMemberCreatedEvent")
enum = ida_enum.get_enum("test_enum_name")
ida_enum.add_enum_member(enum, "TEST_ENUM_0", 0, -1)
ida_enum.add_enum_member(enum, "TEST_ENUM_0x10", 0x10, -1)
ida_enum.add_enum_member(enum, "TEST_ENUM_0x20_to_delete", 0x20, -1)

print("[+] Delete enum members -> EnumMemberDeletedEvent")
enum = ida_enum.get_enum("test_enum_name")
ida_enum.del_enum_member(enum, 0x20, 0, -1)

print("[+] Create a struct -> StrucCreatedEvent")
ida_struct.add_struc(BADADDR, "test_struct_name", 0)
ida_struct.add_struc(BADADDR, "test_struct_name_to_delete", 0)

print("[+] Delete a struct -> StrucDeletedEvent")
struc = ida_struct.get_struc_id("test_struct_name_to_delete")
ida_struct.del_struc(ida_struct.get_struc(struc))

print("[+] Rename _UNICODE_STRING to _UNICODE_STRING_RENAMED -> StrucRenamedEvent")
struc = ida_struct.get_struc_id("_UNICODE_STRING")
ida_struct.set_struc_name(struc, "_UNICODE_STRING_RENAMED")

# XXX - StrucCmtChangedEvent

# XXX - StrucMemberCreatedEvent
#struc = ida_struct.get_struc_id("test_struct_name")
#sptr = ida_struct.get_struc(struc)
#ida_struct.add_struc_member(sptr, "field_0", 0x0, ida_bytes.qword_flag(), ida_nalt.opinfo_t(), 4)
        
# XXX - StrucMemberChangedEvent
# XXX - StrucMemberDeletedEvent
# XXX - StrucMemberRenamedEvent
# XXX - ExpandingStrucEvent
# XXX - SegmAddedEvent
# XXX - SegmDeletedEvent
# XXX - SegmStartChangedEvent
# XXX - SegmEndChangedEvent
# XXX - SegmNameChangedEvent
# XXX - SegmClassChangedEvent
# XXX - SegmAttrsUpdatedEvent
# XXX - SegmMoved

print("[+] Undefining string at 0x78DBDCB0 -> UndefinedEvent")
del_items(0x78DBDCB0)

# XXX - BytePatchedEvent
# XXX - SgrChanged

# XXX - UserLabelsEvent

print("[+] Defining 2 comments in HexRays window in function defined at 0x78DBB091 -> UserCmtsEvent")
list_comments = [((0x78DBB06A, 74), 'one comment in HexRays'), ((0x78DBB091, 74), 'another comment in HexRays')]
cmts = ida_hexrays.user_cmts_new()
for (tl_ea, tl_itp), cmt in list_comments:
    tl = ida_hexrays.treeloc_t()
    tl.ea = tl_ea
    tl.itp = tl_itp
    cmts.insert(tl, ida_hexrays.citem_cmt_t(cmt))
ida_hexrays.save_user_cmts(0x78DBB050, cmts)

# XXX - UserIflagsEvent
# XXX - UserLvarSettingsEvent
# XXX - UserNumformsEvent
```

`idarling/test/ntoskrnl_test_events.py`:

```py
# hardcoded for ntoskrnl.exe
#
# Usage:
# 1. Load ntoskrnl.exe with symbols in IDA
# 2. Enable TRACE level logs on both IDArling IDA plugin and remote server
# 3. Connect to IDArling server from IDA and save IDB before doing anything in IDA
# 4. run IDA script: test_events.py
# 5. check events being sent by IDA plugin / received by server
# 6. Close IDA and re-open previously saved snapshot
# 7. Check replay of events sent by server / received by IDA plugin

import time, ida_hexrays

print("[+] Create nops at 0x140321990 -> MakeCodeEvent")
create_insn(0x140321990)
print("[+] Create 3-byte data at 0x1402B7B95 -> MakeDataEvent")
create_data(0x1402B7B95, 1024, 3, -1)
print("[+] Rename at 0x1402B7B88 -> RenamedEvent")
set_name(0x1402B7B88, "TestName", 0)

print("[+] Add an empty function at 0x140004998 and 0x140005779 -> FuncAddedEvent")
add_func(0x140004998)
add_func(0x140005779)

print("[+] Delete previous function at 0x140005779 -> DeletingFuncEvent")
del_func(0x140005779)

# XXX - SetFuncStartEvent
# XXX - SetFuncEndEvent
# XXX - FuncTailAppendedEvent
# XXX - FuncTailDeletedEvent
# XXX - TailOwnerChangedEvent

print("[+] Set 2 comments in assembly at 0x140005779 and 0x14000577a -> CmtChangedEvent")
set_cmt(0x140005779, "test comment non repeatable", 0)
set_cmt(0x14000577a, "test comment repeatable", 1)

print("[+] Set a function comment at 0x140321998 -> RangeCmtChangedEvent")
func = ida_funcs.get_func(0x140321998)
ida_funcs.set_func_cmt(func, "function comment", 0)

print("[+] Set 2 comments before and after at 0x140004998 -> CmtChangedEvent")
ida_lines.add_extra_cmt(0x140004998, 1, "previous comment")
ida_lines.add_extra_cmt(0x140004998, 0, "next comment")

# XXX - TiChangedEvent
# XXX - LocalTypesChangedEvent
# XXX - OpTypeChangedEvent

print("[+] Change the argument: 0C0190052 hexadecimal to decimal at 0x140321C6E in assembly  -> OpTypeChangedEvent")
op_dec(0x140321C6E, 1)

print("[+] Create an enum -> EnumCreatedEvent")
ida_enum.add_enum(BADADDR, "test_enum_name", 0)
ida_enum.add_enum(BADADDR, "test_enum_name_to_rename", 0)
ida_enum.add_enum(BADADDR, "test_enum_name_to_delete", 0)

print("[+] Delete an enum -> EnumDeletedEvent")
ida_enum.del_enum(ida_enum.get_enum("test_enum_name_to_delete"))
        
print("[+] Rename an enum -> EnumRenamedEvent")
enum = ida_enum.get_enum("test_enum_name_to_rename")
ida_enum.set_enum_name(enum, "test_enum_renamed")

# XXX - EnumBfChangedEvent
# XXX - EnumCmtChangedEvent

print("[+] Add enum members -> EnumMemberCreatedEvent")
enum = ida_enum.get_enum("test_enum_name")
ida_enum.add_enum_member(enum, "TEST_ENUM_0", 0, -1)
ida_enum.add_enum_member(enum, "TEST_ENUM_0x10", 0x10, -1)
ida_enum.add_enum_member(enum, "TEST_ENUM_0x20_to_delete", 0x20, -1)

print("[+] Delete enum members -> EnumMemberDeletedEvent")
enum = ida_enum.get_enum("test_enum_name")
ida_enum.del_enum_member(enum, 0x20, 0, -1)

print("[+] Create a struct -> StrucCreatedEvent")
ida_struct.add_struc(BADADDR, "test_struct_name", 0)
ida_struct.add_struc(BADADDR, "test_struct_name_to_delete", 0)

print("[+] Delete a struct -> StrucDeletedEvent")
struc = ida_struct.get_struc_id("test_struct_name_to_delete")
ida_struct.del_struc(ida_struct.get_struc(struc))

print("[+] Rename GUID to GUID_RENAMED -> StrucRenamedEvent")
struc = ida_struct.get_struc_id("GUID")
ida_struct.set_struc_name(struc, "GUID_RENAMED")

# XXX - StrucCmtChangedEvent

# XXX - StrucMemberCreatedEvent
        
# XXX - StrucMemberChangedEvent
# XXX - StrucMemberDeletedEvent
# XXX - StrucMemberRenamedEvent
# XXX - ExpandingStrucEvent
# XXX - SegmAddedEvent
# XXX - SegmDeletedEvent
# XXX - SegmStartChangedEvent
# XXX - SegmEndChangedEvent
# XXX - SegmNameChangedEvent
# XXX - SegmClassChangedEvent
# XXX - SegmAttrsUpdatedEvent
# XXX - SegmMoved

print("[+] Undefining string at 0x1402B7B78 -> UndefinedEvent")
del_items(0x1402B7B78)

# XXX - BytePatchedEvent
# XXX - SgrChanged

# XXX - UserLabelsEvent

print("[+] Defining 2 comments in HexRays window in function defined at 0x140321998 -> UserCmtsEvent")
list_comments = [((0x1403219E6, 74), 'one comment in HexRays'), ((0x140321A76, 74), 'another comment in HexRays')]
cmts = ida_hexrays.user_cmts_new()
for (tl_ea, tl_itp), cmt in list_comments:
    tl = ida_hexrays.treeloc_t()
    tl.ea = tl_ea
    tl.itp = tl_itp
    cmts.insert(tl, ida_hexrays.citem_cmt_t(cmt))
ida_hexrays.save_user_cmts(0x140321998, cmts)

# XXX - UserIflagsEvent
# XXX - UserLvarSettingsEvent
# XXX - UserNumformsEvent
```

`idarling/test/test_compression.py`:

```py
# https://docs.python.org/3/library/bz2.html#examples-of-usage
# https://www.programcreek.com/python/example/6089/bz2.BZ2Decompressor

import bz2, hexdump

original_data = b'abc'*1000

def gen_data(data, chunk_size=1000):
    """Yield incremental blocks of chunksize bytes."""
    len_data = len(data)
    total_count_sent = 0
    for i in range(int(len_data/chunk_size)):
        yield data[chunk_size*i: chunk_size*(i+1)]
    if len_data % chunk_size != 0:
        yield data[-(len_data%chunk_size):]
    else:
        yield b''

comp = bz2.BZ2Compressor()
out = b""
for chunk in gen_data(original_data):
    out = out + comp.compress(chunk)

# Finish the compression process.  Call this once you have
# finished providing data to the compressor.
out = out + comp.flush()

hexdump.hexdump(out)
print("-"*30)


decomp = bz2.BZ2Decompressor()
data_decompressed = b''
for chunk in gen_data(out):
    data_decompressed += decomp.decompress(chunk)

print(len(data_decompressed))
hexdump.hexdump(data_decompressed[:100])
```

`idarling/test/test_hook.py`:

```py
import ida_idp, ida_typeinf, ida_bytes, ida_enum, ida_hexrays

class MyIDBHooks(ida_idp.IDB_Hooks):
    def __init__(self):
        ida_idp.IDB_Hooks.__init__(self)
        print("MyIDBHooks init done")

    def make_code(self, insn):
        print("Detected a make code at 0x%x" % (insn.ea))
        return 0

    def make_data(self, ea, flags, tid, size):
        print("Detected a make data at 0x%x of size 0x%x" % (ea, size))
        return 0

    def renamed(self, ea, new_name, local_name):
        print("Detected a renamed at 0x%x to %s (is_local=%s)" % (ea, new_name, local_name))
        return 0

    def func_added(self, func):
        print("Detected a new function at 0x%x" % (func.start_ea))
        return 0

    def deleting_func(self, func):
        print("Detected a deleted function at 0x%x" % (func.start_ea))
        return 0

    def set_func_start(self, func, new_start):
        print("Detected a new function start from %x to 0x%x" % (func.start_ea, new_start))
        return 0

    def set_func_end(self, func, new_end):
        print("Detected a new function end to 0x%x" % (new_end))
        return 0

    def func_tail_appended(self, func, tail):
        print("Detected a new tail appended at 0x%x" % (tail.start_ea))
        return 0

    def func_tail_deleted(self, func, tail_ea):
        print("Detected a new tail deleted at 0x%x" % (tail_ea))
        return 0

    def tail_owner_changed(self, tail, owner_func, old_owner):
        print("Detected a tail owner changed at 0x%x for %s" % (tail.start_ea, owner_func))
        return 0

    def cmt_changed(self, ea, repeatable_cmt):
        cmt = ida_bytes.get_cmt(ea, repeatable_cmt)
        cmt = "" if not cmt else cmt
        print("Detected a comment changed at 0x%x for %s, %s" % (ea, cmt, repeatable_cmt))
        return 0

    def range_cmt_changed(self, kind, a, cmt, repeatable):
        print("Detected a range comment changed at 0x%x for %s" % (a.start_ea, cmt))
        return 0

    def extra_cmt_changed(self, ea, line_idx, cmt):
        print("Detected an extra comment changed at 0x%x for %s" % (ea, cmt))
        return 0

    def ti_changed(self, ea, type, fname):
        type = ida_typeinf.idc_get_type_raw(ea)
        print("Detected a ti changed at 0x%x for type: %s" % (ea, type))
        return 0
        
    def op_type_changed(self, ea, n):
        print("Detected an op type changed at 0x%x for %d" % (ea, n))
        return 0

    def enum_created(self, enum):
        name = ida_enum.get_enum_name(enum)
        print("Detected a new enum created: 0x%x (%s)" % (enum, name))
        return 0

    def deleting_enum(self, id):
        name = ida_enum.get_enum_name(id)
        print("Detected a enum deleted: 0x%x (%s)" % (id, name))
        return 0

    def renaming_enum(self, id, is_enum, newname):
        if is_enum:
            oldname = ida_enum.get_enum_name(id)
        else:
            oldname = ida_enum.get_enum_member_name(id)
        print("Detected an enum renamed from %s to %s (is_enum=%s)" % (oldname, newname, is_enum))
        return 0

    def enum_bf_changed(self, id):
        ename = ida_enum.get_enum_name(id)
        print("Detected a bf changed: 0x%x (%s)" % (id, ename))
        return 0

    def enum_cmt_changed(self, tid, repeatable_cmt):
        cmt = ida_enum.get_enum_cmt(tid, repeatable_cmt)
        emname = ida_enum.get_enum_name(tid)
        print("Detected an enum comment changed for 0x%x (%s): %s, %s" % (tid, emname, cmt, repeatable_cmt))
        return 0

    def enum_member_created(self, id, cid):
        ename = ida_enum.get_enum_name(id)
        name = ida_enum.get_enum_member_name(cid)
        value = ida_enum.get_enum_member_value(cid)
        bmask = ida_enum.get_enum_member_bmask(cid)
        print("Detected a new enum member created: 0x%x (%s), 0x%x (%s) = 0x%x, 0x%x" % (id, ename, cid, name, value, bmask))
        return 0

    def deleting_enum_member(self, id, cid):
        ename = ida_enum.get_enum_name(id)
        value = ida_enum.get_enum_member_value(cid)
        serial = ida_enum.get_enum_member_serial(cid)
        bmask = ida_enum.get_enum_member_bmask(cid)
        print("Detected a new enum member created: 0x%x (%s), 0x%x (%s) = 0x%x, 0x%x" % (id, ename, cid, serial, value, bmask))
        return 0

    def struc_created(self, tid):
        name = ida_struct.get_struc_name(tid)
        is_union = ida_struct.is_union(tid)
        print("Detected a new struct created: 0x%x (%s) (is_union=%s)" % (tid, name, is_union))
        return 0

    def deleting_struc(self, sptr):
        sname = ida_struct.get_struc_name(sptr.id)
        print("Detected a new struct deleted: 0x%x (%s)" % (sptr.id, sname))
        return 0

    def renaming_struc(self, id, oldname, newname):
        print("Detected a struct renamed from %s to %s" % (oldname, newname))
        return 0

    def struc_member_created(self, sptr, mptr):
        sname = ida_struct.get_struc_name(sptr.id)
        fieldname = ida_struct.get_member_name(mptr.id)
        print("Detected a struct member created %s.%s" % (sname, fieldname))
        return 0
        
    def struc_member_deleted(self, sptr, off1, off2):
        sname = ida_struct.get_struc_name(sptr.id)
        print("Detected a struct member deleted %s at offset 0x%x" % (sname, off2))
        return 0

    def renaming_struc_member(self, sptr, mptr, newname):
        sname = ida_struct.get_struc_name(sptr.id)
        offset = mptr.soff
        print("Detected a struct member renamed %s at offset 0x%x with new name: %s" % (sname, offset, newname))
        return 0

    def struc_cmt_changed(self, id, repeatable_cmt):
        fullname = ida_struct.get_struc_name(id)
        if "." in fullname:
            sname, smname = fullname.split(".", 1)
        else:
            sname = fullname
            smname = ""
        cmt = ida_struct.get_struc_cmt(id, repeatable_cmt)
        print("Detected a struct comment changed for 0x%x (%s and %s): %s, %s" % (id, sname, smname, cmt, repeatable_cmt))
        return 0
        
    def struc_member_changed(self, sptr, mptr):
        sname = ida_struct.get_struc_name(sptr.id)
        print("Detected a struct member changed %s at offset 0x%x" % (sname, mptr.eoff))
        return 0

    def expanding_struc(self, sptr, offset, delta):
        sname = ida_struct.get_struc_name(sptr.id)
        print("Detected a struct expansion: %s at offset 0x%x (delta=0x%x)" % (sname, offset, delta))
        return 0

    def segm_added(self, s):
        print("Detected a segment added: %s [0x%x, 0x%x]" % (ida_segment.get_segm_name(s), s.start_ea, s.end_ea))
        return 0
        
    def segm_deleted(self, start_ea, end_ea):
        print("Detected a segment deleted: [0x%x, 0x%x]" % (start_ea, end_ea))
        return 0

    def segm_start_changed(self, s, oldstart):
        print("Detected a segment changed: %s start from 0x%x to 0x%x" % (ida_segment.get_segm_name(s), oldstart, s.start_ea))
        return 0

    def segm_end_changed(self, s, oldend):
        print("Detected a segment changed: %s end from 0x%x to 0x%x" % (ida_segment.get_segm_name(s), oldend, s.end_ea))
        return 0

    def segm_name_changed(self, s, name):
        print("Detected a segment name changed: %s for [0x%x, 0x%x]" % (name, s.start_ea, s.end_ea))
        return 0

    def segm_class_changed(self, s, sclass):
        print("Detected a segment class changed for start: 0x%x, class: 0x%x" % (s.start_ea, sclass))
        return 0

    def segm_attrs_updated(self, s):
        print("Detected a segment attributes changed for start: 0x%x, perms: 0x%x" % (s.start_ea, s.perm))
        return 0

    def segm_moved(self, from_ea, to_ea, size, changed_netmap):
        print("Detected a segment moved from 0x%x to 0x%x" % (from_ea, to_ea))
        return 0

    def byte_patched(self, ea, old_value):
        bytes = ida_bytes.get_wide_byte(ea)
        print("Detected a byte patched: at 0x%x" % (ea))
        return 0

    def sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag):
        # XXX
        print("Detected sgr_changed()")
        return 0

class MyHexRaysHooks(ida_idp.IDB_Hooks):
    def __init__(self):
        ida_idp.IDB_Hooks.__init__(self)
        print("MyHexRaysHooks init done")
        self._available = None
        self._installed = False
        self._func_ea = ida_idaapi.BADADDR
        self._labels = {}
        self._cmts = {}
        self._iflags = {}
        self._lvar_settings = {}
        self._numforms = {}

    def hook(self):
        if self._available is None:
            if not ida_hexrays.init_hexrays_plugin():
                self._plugin.logger.info("Hex-Rays SDK is not available")
                self._available = False
            else:
                ida_hexrays.install_hexrays_callback(self._hxe_callback)
                self._available = True

        if self._available:
            self._installed = True

    def unhook(self):
        if self._available:
            self._installed = False
            
    def _hxe_callback(self, event, *_):
        if not self._installed:
            print("HexRays hooks not installed, exiting early")
            return 0

        if event == ida_hexrays.hxe_func_printed:
            ea = ida_kernwin.get_screen_ea()
            func = ida_funcs.get_func(ea)
            if func is None:
                print("func is None, early exit")
                return 0

            if self._func_ea != func.start_ea:
                self._func_ea = func.start_ea
                self._labels = MyHexRaysHooks._get_user_labels(self._func_ea)
                self._cmts = MyHexRaysHooks._get_user_cmts(self._func_ea)
                self._iflags = MyHexRaysHooks._get_user_iflags(self._func_ea)
                self._lvar_settings = MyHexRaysHooks._get_user_lvar_settings(
                    self._func_ea
                )
                self._numforms = MyHexRaysHooks._get_user_numforms(self._func_ea)
            self._print_user_labels(func.start_ea)
            self._print_user_cmts(func.start_ea)
            self._print_user_iflags(func.start_ea)
            self._print_user_lvar_settings(func.start_ea)
            self._print_user_numforms(func.start_ea)
        else:
            print("HexRays: main SKIPPED")
        return 0
        
    @staticmethod
    def _get_user_labels(ea):
        user_labels = ida_hexrays.restore_user_labels(ea)
        if user_labels is None:
            user_labels = ida_hexrays.user_labels_new()
        labels = []
        it = ida_hexrays.user_labels_begin(user_labels)
        while it != ida_hexrays.user_labels_end(user_labels):
            org_label = ida_hexrays.user_labels_first(it)
            name = ida_hexrays.user_labels_second(it)
            labels.append((org_label, Event.decode(name)))
            it = ida_hexrays.user_labels_next(it)
        ida_hexrays.user_labels_free(user_labels)
        return labels

    def _print_user_labels(self, ea):
        labels = MyHexRaysHooks._get_user_labels(ea)
        if labels != self._labels:
            print("HexRays: Detected a user labels at 0x%x: %s" % (ea, labels))
            self._labels = labels
        else:
            print("HexRays: Detected a user labels SKIPPED")

    @staticmethod
    def _get_user_cmts(ea):
        user_cmts = ida_hexrays.restore_user_cmts(ea)
        if user_cmts is None:
            user_cmts = ida_hexrays.user_cmts_new()
        cmts = []
        it = ida_hexrays.user_cmts_begin(user_cmts)
        while it != ida_hexrays.user_cmts_end(user_cmts):
            tl = ida_hexrays.user_cmts_first(it)
            cmt = ida_hexrays.user_cmts_second(it)
            cmts.append(((tl.ea, tl.itp), cmt))
            it = ida_hexrays.user_cmts_next(it)
        ida_hexrays.user_cmts_free(user_cmts)
        return cmts

    def _print_user_cmts(self, ea):
        cmts = MyHexRaysHooks._get_user_cmts(ea)
        if cmts != self._cmts:
            print("HexRays: Detected a user cmts at 0x%x: %s" % (ea, cmts))
            self._cmts = cmts
        else:
            print("HexRays: Detected a user cmts SKIPPED")

    @staticmethod
    def _get_user_iflags(ea):
        user_iflags = ida_hexrays.restore_user_iflags(ea)
        if user_iflags is None:
            user_iflags = ida_hexrays.user_iflags_new()
        iflags = []
        it = ida_hexrays.user_iflags_begin(user_iflags)
        while it != ida_hexrays.user_iflags_end(user_iflags):
            cl = ida_hexrays.user_iflags_first(it)
            f = ida_hexrays.user_iflags_second(it)

            # FIXME: Temporary while Hex-Rays update their API
            def read_type_sign(obj):
                import ctypes
                import struct

                buf = ctypes.string_at(id(obj), 4)
                return struct.unpack("I", buf)[0]

            f = read_type_sign(f)
            iflags.append(((cl.ea, cl.op), f))
            it = ida_hexrays.user_iflags_next(it)
        ida_hexrays.user_iflags_free(user_iflags)
        return iflags

    def _print_user_iflags(self, ea):
        iflags = MyHexRaysHooks._get_user_iflags(ea)
        if iflags != self._iflags:
            print("HexRays: Detected a user iflags at 0x%x: %s" % (ea, iflags))
            self._iflags = iflags
        else:
            print("HexRays: Detected a user iflags SKIPPED")

    @staticmethod
    def _get_user_lvar_settings(ea):
        dct = {}
        lvinf = ida_hexrays.lvar_uservec_t()
        if ida_hexrays.restore_user_lvar_settings(lvinf, ea):
            dct["lvvec"] = []
            for lv in lvinf.lvvec:
                dct["lvvec"].append(MyHexRaysHooks._get_lvar_saved_info(lv))
            if hasattr(lvinf, "sizes"):
                dct["sizes"] = list(lvinf.sizes)
            dct["lmaps"] = []
            it = ida_hexrays.lvar_mapping_begin(lvinf.lmaps)
            while it != ida_hexrays.lvar_mapping_end(lvinf.lmaps):
                key = ida_hexrays.lvar_mapping_first(it)
                key = MyHexRaysHooks._get_lvar_locator(key)
                val = ida_hexrays.lvar_mapping_second(it)
                val = MyHexRaysHooks._get_lvar_locator(val)
                dct["lmaps"].append((key, val))
                it = ida_hexrays.lvar_mapping_next(it)
            dct["stkoff_delta"] = lvinf.stkoff_delta
            dct["ulv_flags"] = lvinf.ulv_flags
        return dct

    @staticmethod
    def _get_lvar_saved_info(lv):
        return {
            "ll": MyHexRaysHooks._get_lvar_locator(lv.ll),
            "name": lv.name,
            "type": MyHexRaysHooks._get_tinfo(lv.type),
            "cmt": lv.cmt,
            "flags": lv.flags,
        }

    @staticmethod
    def _get_tinfo(type):
        if type.empty():
            return None, None, None

        type, fields, fldcmts = type.serialize()
        return type, fields, fldcmts

    @staticmethod
    def _get_lvar_locator(ll):
        return {
            "location": MyHexRaysHooks._get_vdloc(ll.location),
            "defea": ll.defea,
        }

    @staticmethod
    def _get_vdloc(location):
        return {
            "atype": location.atype(),
            "reg1": location.reg1(),
            "reg2": location.reg2(),
            "stkoff": location.stkoff(),
            "ea": location.get_ea(),
        }

    def _print_user_lvar_settings(self, ea):
        lvar_settings = MyHexRaysHooks._get_user_lvar_settings(ea)
        if lvar_settings != self._lvar_settings:
            print("HexRays: Detected a user lvars settings at 0x%x: %s" % (ea, lvar_settings))
            self._lvar_settings = lvar_settings
        else:
            print("HexRays: Detected a user lvars settings SKIPPED")

    @staticmethod
    def _get_user_numforms(ea):
        user_numforms = ida_hexrays.restore_user_numforms(ea)
        if user_numforms is None:
            user_numforms = ida_hexrays.user_numforms_new()
        numforms = []
        it = ida_hexrays.user_numforms_begin(user_numforms)
        while it != ida_hexrays.user_numforms_end(user_numforms):
            ol = ida_hexrays.user_numforms_first(it)
            nf = ida_hexrays.user_numforms_second(it)
            numforms.append(
                (
                    MyHexRaysHooks._get_operand_locator(ol),
                    MyHexRaysHooks._get_number_format(nf),
                )
            )
            it = ida_hexrays.user_numforms_next(it)
        ida_hexrays.user_numforms_free(user_numforms)
        return numforms

    @staticmethod
    def _get_operand_locator(ol):
        return {"ea": ol.ea, "opnum": ol.opnum}

    @staticmethod
    def _get_number_format(nf):
        return {
            "flags": nf.flags,
            "opnum": nf.opnum,
            "props": nf.props,
            "serial": nf.serial,
            "org_nbytes": nf.org_nbytes,
            "type_name": nf.type_name,
        }

    def _print_user_numforms(self, ea):
        numforms = MyHexRaysHooks._get_user_numforms(ea)
        if numforms != self._numforms:
            print("HexRays: Detected a user numforms at 0x%x: %s" % (ea, numforms))
            self._numforms = numforms
        else:
            print("HexRays: Detected a user numforms SKIPPED")

idb_hooks = MyIDBHooks()
idb_hooks.hook()
print("MyIDBHooks installed")

hexrays_hooks = MyHexRaysHooks()
hexrays_hooks.hook()
print("MyHexRaysHooks installed")
```

`idarling_plugin.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
from idarling.plugin import IdarlingPlugin


def PLUGIN_ENTRY():  # noqa: N802
    """Mandatory entry point for IDAPython plugins."""
    return IdarlingPlugin()

```

`idarling_server.py`:

```py
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
from idarling import server


if __name__ == "__main__":
    server.main()

```

`setup.py`:

```py
#!/usr/bin/env python
from setuptools import find_packages, setup


setup(
    name="idarling",
    version="0.1",
    description="Collaborative Reverse Engineering plugin for IDA Pro",
    url="https://github.com/IDArlingTeam/IDArling",
    packages=find_packages(),
    install_requires=["PySide6; python_version >= '3.9'"],
    include_package_data=True,
    entry_points={
        "idapython_plugins": ["idarling=idarling.plugin:IdarlingPlugin"],
        "console_scripts": ["idarling_server=idarling.server:main"],
    },
)

```