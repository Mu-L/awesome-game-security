Project Path: arc_afulsamet_integrity_h44e0y94

Source Tree:

```txt
arc_afulsamet_integrity_h44e0y94
├── README.md
├── examples
│   ├── basic
│   │   └── basic.c
│   ├── compile-example.bat
│   ├── custom
│   │   └── custom.c
│   ├── image-from-peb
│   │   └── image-from-peb.c
│   └── shared.h
└── memory-integrity.h

```

`README.md`:

```md
# Memory Integrity

Zero-overhead, header-only C library for runtime memory integrity verification of Windows Portable Executable (PE) images. This library provides hardware-accelerated checksum computation and real-time detection of unauthorized code modifications in non-writable sections.

## API Reference

### Initialization

```c
af_status af_mintegrity_initialize(af_mintegrity_t *integrity, af_byte *image);
```

Initializes the integrity verification context with the specified PE image and computes the baseline checksum of all non-writable sections.

**Parameters:**
- `integrity`: Pointer to integrity context structure
- `image`: Base address of the PE image

**Returns:** Status code indicating success (`AF_MINTEGRITY_SUCCESS`) or failure (`AF_MINTEGRITY_INVALID_IMAGE`)

### Verification

```c
af_byte af_mintegrity_compare(af_mintegrity_t *integrity, af_dword *checksum);
```

Performs runtime integrity verification by recomputing checksums and comparing to the baseline.

**Parameters:**
- `integrity`: Pointer to integrity context structure
- `checksum`: Current checksum value

**Returns:** Boolean result indicating integrity status (1 = intact, 0 = compromised)

### Checksum

```c
void af_mintegrity_checksum(const af_byte *const data, af_dword length, af_dword *checksum);
```

Computes hardware-accelerated CRC32 checksum over the specified byte array. This function can be overridden by defining `AF_MINTEGRITY_CUSTOM_CHECKSUM`.

## Requirements

### Compiler support
- **Microsoft Visual C++**
- **GCC/Clang**: Requires `-mcrc32` compilation flag for hardware acceleration

### Dependencies
- Windows SDK (for PE structure definitions)
- CPU with SSE4.2 support (for hardware-accelerated checksums)

## Build examples
Available toolchains are `msvc`, `gcc` and `clang`.
```bash
examples\compile-example.bat (msvc|gcc|clang) (basic|custom|image-from-peb)
```

## Contributing

- Cross-platform support extensions
- Security enhancement proposals

```

`examples/basic/basic.c`:

```c
#include "..\shared.h"

int main(int argc, char **argv) {
  af_byte *image = ( af_byte * ) ( GetModuleHandleA(0) );
  return __af_shared_mintegrity_routine(image);
}

```

`examples/compile-example.bat`:

```bat
@echo off

set toolchain=%~1
set project=%~2
set directory=%~dp0%project%

if not exist %directory%\%project%.c (
  echo Error: Project directory '%~dp0%project%' does not exist. 1>&2
  exit /b 1
)

set source=%directory%\%project%.c
set output=%directory%-%toolchain%-mint.exe

if '%toolchain%' == 'clang' (
  clang -O3 -std=c89 -mcrc32 %source% -o %output%
  exit /b %errorlevel%
)

if '%toolchain%' == 'gcc' (
  gcc -s -O3 -std=c89 -mcrc32 %source% -o %output%
  exit /b %errorlevel%
)

if '%toolchain%' == 'msvc' (
  pushd %~dp0 && cl /O2 /std:c11 %source% /Fe:%output%
  popd && exit /b %errorlevel%
)

echo Error: Unknown toolchain '%toolchain%', try to use 'msvc', 'gcc' or 'clang'. 1>&2
exit /b 1

```

`examples/custom/custom.c`:

```c
#define AF_MINTEGRITY_CUSTOM_CHECKSUM
#define AF_MINTEGRITY_CHECKSUM_INITIAL ( 0x811C9DC5 ) /* FNV_offset_basis */
#include "..\shared.h"

/*
 * FNV1a 32-bit implementation
 * https://en.m.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function
 */
_af_mintegrity_api void af_mintegrity_checksum(const af_byte *const data, af_dword length, af_dword *checksum) {
  af_dword index = 0;
  for ( ; index < length; ++index ) {
    *checksum ^= data[index];
    *checksum *= 0x01000193; /* FNV_prime */
  }
}

int main(int argc, char **argv) {
  af_byte *image = ( af_byte * ) ( GetModuleHandleA(0) );
  return __af_shared_mintegrity_routine(image);
}

```

`examples/image-from-peb/image-from-peb.c`:

```c
#include "..\shared.h"

af_qword af_mintegrity_rdgsq(af_qword offset) {
  af_qword reg;
#ifdef _MSC_VER
  reg = __readgsqword(offset);
#else
  __asm__ volatile ( "movq %%gs:%1, %0" : "=r" ( reg ) : "m" ( * ( af_qword * ) offset ) : "memory" );
#endif
  return reg;
}

af_byte *af_mintegrity_image(af_dword checksum) {
  af_byte *peb   =   ( af_byte *  ) ( af_mintegrity_rdgsq(0x60) );
  af_byte *head  = * ( af_byte ** ) ( peb + 0x18 ) + 0x10;
  af_byte *entry = * ( af_byte ** ) ( head );
  if ( checksum == 0 ) {
    return * ( af_byte ** ) ( entry + 0x30 );
  }

  for ( ; entry != head; entry = * ( af_byte ** ) entry ) {
    af_word *name  = * ( af_word ** ) ( entry + 0x60 );
    af_word length = * ( af_word *  ) ( entry + 0x58 ); /* in bytes */

    af_dword entry_checksum = AF_MINTEGRITY_CHECKSUM_INITIAL;
    af_mintegrity_checksum(( const af_byte *const ) name, length, &entry_checksum);
    if ( entry_checksum == checksum ) {
      return * ( af_byte ** ) ( entry + 0x30 );
    }
  }

  return 0;
}

int main(int argc, char **argv) {
  af_byte *image = af_mintegrity_image(0x404D51B3); /* crc32-checksum: ntdll.dll */
  return __af_shared_mintegrity_routine(image);
}

```

`examples/shared.h`:

```h
/* Standart C */
#include <stdio.h>

/* Memory integrity */
#include "..\memory-integrity.h"

_af_mintegrity_api int __af_shared_mintegrity_routine(af_byte *image) {
  af_mintegrity_t integrity;
  af_status status = af_mintegrity_initialize(&integrity, image);
  if ( status > AF_MINTEGRITY_SUCCESS ) {
    fprintf(stderr, "Failed to initialize memory integrity check. "
      "( status: %lX, image: %p )\n", status, image);
    return EXIT_FAILURE;
  }

  printf("Initialized memory integrity check with checksum %X\n", integrity.checksum);

  af_dword checksum;
  while ( af_mintegrity_compare(&integrity, &checksum) ) {
    Sleep(500);
  }

  printf("Routine is aborted because of current checksum %X\n", checksum);
  return EXIT_FAILURE;
}

```

`memory-integrity.h`:

```h
#ifndef __AF_MINTEGRITY_H__
#define __AF_MINTEGRITY_H__

#include <windows.h>
#include <winnt.h>

#ifdef _MSC_VER
  #include <immintrin.h>
#endif

/* -- macros ------------------------------------------ */
#ifdef _MSC_VER
  #define _af_mintegrity_api __forceinline
#else
  #define _af_mintegrity_api __attribute__((always_inline))
#endif

/* -- forward winnt types ----------------------------- */
typedef IMAGE_DOS_HEADER     _af_win_image_dos_header;
typedef IMAGE_NT_HEADERS     _af_win_image_nt_headers;
typedef IMAGE_FILE_HEADER    _af_win_image_file_header;
typedef IMAGE_SECTION_HEADER _af_win_image_section_header;

/* -- af types ---------------------------------------- */
typedef unsigned char      af_byte;
typedef unsigned short     af_word;
typedef unsigned int       af_dword;
typedef unsigned long long af_qword;
typedef unsigned long      af_status;

/* -- af statuses ------------------------------------- */
#define AF_MINTEGRITY_SUCCESS       ( 1 << 0 )
#define AF_MINTEGRITY_INVALID_IMAGE ( 1 << 1 )

/* -- af structs -------------------------------------- */
typedef struct af_mintegrity_s {
  af_byte *image;
  af_dword checksum;
} af_mintegrity_t;

/* -- forward checksum fn declare --------------------- */
void af_mintegrity_checksum(const af_byte *const, af_dword, af_dword *);

#ifndef AF_MINTEGRITY_CHECKSUM_INITIAL
#define AF_MINTEGRITY_CHECKSUM_INITIAL ( 0ULL )
#endif

#ifndef AF_MINTEGRITY_CUSTOM_CHECKSUM
/*
 * Computes a CRC32 checksum over a byte array using hardware-accelerated
 * instructions. Requires CRC32 instruction support (-mcrc32 flag for GCC/Clang).
 */
_af_mintegrity_api void af_mintegrity_checksum(const af_byte *const data, af_dword length, af_dword *checksum) {
  af_dword index = 0;
  for ( ; index < length; index++ ) {
#ifdef _MSC_VER
    *checksum = _mm_crc32_u8(*checksum, data[index]);
#else
    *checksum = __builtin_ia32_crc32qi(*checksum, data[index]);
#endif
  }
}
#endif

/*
 * Parses a Windows Portable Executable (PE) image and
 * computes a cumulative checksum for non-writable sections.
 */
_af_mintegrity_api af_status __af_mintegrity_section_checksum(af_byte *image, af_dword *checksum) {
  _af_win_image_dos_header *dos = ( _af_win_image_dos_header * ) ( image );
  if ( dos->e_magic != IMAGE_DOS_SIGNATURE ) {
    return AF_MINTEGRITY_INVALID_IMAGE;
  }

  _af_win_image_nt_headers  *nt = ( _af_win_image_nt_headers * ) ( image + dos->e_lfanew );
  _af_win_image_file_header *fh = &nt->FileHeader;

  _af_win_image_section_header *start = IMAGE_FIRST_SECTION(nt);
  _af_win_image_section_header *end   = start + fh->NumberOfSections;
  while ( start < end ) {
    _af_win_image_section_header *section = start++;
    if ( section->Characteristics & IMAGE_SCN_MEM_WRITE ) {
      continue;
    }

    af_byte *scdata = image + section->VirtualAddress;
    af_dword length = section->Misc.VirtualSize;
    af_mintegrity_checksum(scdata, length, checksum);
  }

  return AF_MINTEGRITY_SUCCESS;
}

/*
 * Initializes a memory integrity context with a PE image and computes baseline checksum.
 */
_af_mintegrity_api af_status af_mintegrity_initialize(af_mintegrity_t *integrity, af_byte *image) {
  integrity->image = image;
  integrity->checksum = AF_MINTEGRITY_CHECKSUM_INITIAL;
  return __af_mintegrity_section_checksum(image, &integrity->checksum);
}

/*
 * Performs runtime memory integrity verification by computing a new checksum of
 * the PE image's non-writable sections and comparing it to the baseline checksum.
 */
_af_mintegrity_api af_byte af_mintegrity_compare(af_mintegrity_t *integrity, af_dword *checksum) {
  *checksum = AF_MINTEGRITY_CHECKSUM_INITIAL;
  __af_mintegrity_section_checksum(integrity->image, checksum);
  return integrity->checksum == *checksum;
}

#endif

```